Sections:
00: "DATA" (0-218)
01: "seg500" (500-500)
02: "CODE" (0-7627)


Source: "boot.asm"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;-------------------------------------------------------------------------------
                            	    37: ;
                            	    38: ; system memory map
                            	    39: ;
                            	    40: ;
                            	    41: ; 00000000 +----------------+      <+
                            	    42: ;          | startup sp,pc  | 8 B   |
                            	    43: ; 00000008 +----------------+       |
                            	    44: ;					 |    vectors     | pair shared+
                            	    45: ; 00000400 +----------------+       |
                            	    46: ;					 |   bios mem     |       |
                            	    47: ; 00001000 +----------------+       |
                            	    48: ;					 |   bios code    |       |
                            	    49: ; 00008000 +----------------+      <+
                            	    50: ;					 |    unused      |
                            	    51: ; 00040000 +----------------+
                            	    52: ;					 |   local ram    |
                            	    53: ; 00042000 +----------------+
                            	    54: ;					 |    unused      |
                            	    55: ; 00100000 +----------------+
                            	    56: ;					 |   global ram   |
                            	    57: ; 00101000 +----------------+
                            	    58: ;					 | serial rcvbuf  |
                            	    59: ; 00102000 +----------------+
                            	    60: ;					 |    unused      |
                            	    61: ; 20000000 +----------------+
                            	    62: ;          |                |
                            	    63: ;          |                |
                            	    64: ;          |                |
                            	    65: ;          :  dram memory   : 512 MB
                            	    66: ;          |                |
                            	    67: ;          |                |
                            	    68: ;          |                |
                            	    69: ; 40000000 +----------------+
                            	    70: ;          |                |
                            	    71: ;          :     unused     :
                            	    72: ;          |                |
                            	    73: ; FD000000 +----------------+
                            	    74: ;          |                |
                            	    75: ;          :    I/O area    : 1.0 M
                            	    76: ;          |                |
                            	    77: ; FFE00000 +----------------+
                            	    78: ;          |                |
                            	    79: ;          :     unused     :
                            	    80: ;          |                |
                            	    81: ; FFFFFFFF +----------------+
                            	    82: ;
                            	    83: ;-------------------------------------------------------------------------------
                            	    84: ;
                            	    85: HAS_MMU equ 0
                            	    86: 
                            	    87: CTRLC	EQU		$03
                            	    88: CTRLH	EQU		$08
                            	    89: CTRLS	EQU		$13
                            	    90: CTRLX	EQU		$18
                            	    91: CTRLZ	EQU		$1A
                            	    92: LF		EQU		$0A
                            	    93: CR		EQU		$0D
                            	    94: XON		EQU		$11
                            	    95: XOFF	EQU		$13
                            	    96: 
                            	    97: SC_F12  EQU    $07
                            	    98: SC_C    EQU    $21
                            	    99: SC_T    EQU    $2C
                            	   100: SC_Z    EQU    $1A
                            	   101: SC_KEYUP	EQU		$F0
                            	   102: SC_EXTEND   EQU		$E0
                            	   103: SC_CTRL		EQU		$14
                            	   104: SC_RSHIFT	EQU		$59
                            	   105: SC_NUMLOCK	EQU		$77
                            	   106: SC_SCROLLLOCK	EQU	$7E
                            	   107: SC_CAPSLOCK		EQU	$58
                            	   108: SC_ALT		EQU		$11
                            	   109: SC_LSHIFT	EQU		$12
                            	   110: SC_DEL		EQU		$71		; extend
                            	   111: SC_LCTRL	EQU		$58
                            	   112: SC_TAB      EQU		$0D
                            	   113: 
                            	   114: 	if HAS_MMU
                            	   115: TEXTREG		EQU	$1E3FF00	; virtual addresses
                            	   116: txtscreen	EQU	$1E00000
                            	   117: semamem		EQU	$1E50000
                            	   118: ACIA			EQU	$1E60000
                            	   119: ACIA_RX		EQU	0
                            	   120: ACIA_TX		EQU	0
                            	   121: ACIA_STAT	EQU	4
                            	   122: ACIA_CMD	EQU	8
                            	   123: ACIA_CTRL	EQU	12
                            	   124: I2C2 			equ $01E69000
                            	   125: I2C_PREL 	equ 0
                            	   126: I2C_PREH 	equ 1
                            	   127: I2C_CTRL 	equ 2
                            	   128: I2C_RXR 	equ 3
                            	   129: I2C_TXR 	equ 3
                            	   130: I2C_CMD 	equ 4
                            	   131: I2C_STAT 	equ 4
                            	   132: PLIC			EQU	$1E90000
                            	   133: MMU				EQU $FDC00000	; physical address
                            	   134: leds			EQU	$1EFFF00	; virtual addresses
                            	   135: keybd			EQU	$1EFFE00
                            	   136: KEYBD			EQU	$1EFFE00
                            	   137: RAND			EQU	$1EFFD00
                            	   138: RAND_NUM	EQU	$1EFFD00
                            	   139: RAND_STRM	EQU	$1EFFD04
                            	   140: RAND_MZ		EQU $1EFFD08
                            	   141: RAND_MW		EQU	$1EFFD0C
                            	   142: RST_REG		EQU	$1EFFC00
                            	   143: IO_BITMAP	EQU $1F00000
                            	   144: 	else
                            	   145: TEXTREG		EQU	$FD03FF00	; virtual addresses
                            	   146: txtscreen	EQU	$FD000000
                            	   147: semamem		EQU	$FD050000
                            	   148: ACIA			EQU	$FD060000
                            	   149: ACIA_RX		EQU	0
                            	   150: ACIA_TX		EQU	0
                            	   151: ACIA_STAT	EQU	4
                            	   152: ACIA_CMD	EQU	8
                            	   153: ACIA_CTRL	EQU	12
                            	   154: I2C2 			equ $FD069000
                            	   155: I2C_PREL 	equ 0
                            	   156: I2C_PREH 	equ 1
                            	   157: I2C_CTRL 	equ 2
                            	   158: I2C_RXR 	equ 3
                            	   159: I2C_TXR 	equ 3
                            	   160: I2C_CMD 	equ 4
                            	   161: I2C_STAT 	equ 4
                            	   162: PLIC			EQU	$FD090000
                            	   163: MMU				EQU $FDC00000	; physical address
                            	   164: leds			EQU	$FD0FFF00	; virtual addresses
                            	   165: keybd			EQU	$FD0FFE00
                            	   166: KEYBD			EQU	$FD0FFE00
                            	   167: RAND			EQU	$FD0FFD00
                            	   168: RAND_NUM	EQU	$FD0FFD00
                            	   169: RAND_STRM	EQU	$FD0FFD04
                            	   170: RAND_MZ		EQU $FD0FFD08
                            	   171: RAND_MW		EQU	$FD0FFD0C
                            	   172: RST_REG		EQU	$FD0FFC00
                            	   173: IO_BITMAP	EQU $FD100000
                            	   174: 	endif
                            	   175: 
                            	   176: SERIAL_SEMA	EQU	2
                            	   177: KEYBD_SEMA	EQU	3
                            	   178: RAND_SEMA		EQU	4
                            	   179: SCREEN_SEMA	EQU	5
                            	   180: MEMORY_SEMA EQU 6
                            	   181: TCB_SEMA 		EQU	7
                            	   182: 
                            	   183: 	data
00:00000000 00040FFC        	   184: 	dc.l		$00040FFC
00:00000004 00000000        	   185: 	dc.l		start
00:00000008 000071FA        	   186: 	dc.l		bus_err
00:0000000C 00000000        	   187: 	dc.l		0
00:00000010 0000754E        	   188: 	dc.l		illegal_trap		* ILLEGAL instruction
00:00000014 00000000        	   189: 	dc.l		0
00:00000018 000002C2        	   190: 	dc.l		chk_exception		; CHK
00:0000001C 0000040A        	   191: 	dc.l		EXCEPTION_7			* TRAPV
00:00000020 00000000        	   192: 	dc.l		0
00:00000024 00000000        	   193: 	dc.l		0
                            	   194: 	
                            	   195: 	; 10
00:00000028 00000000        	   196: 	dc.l		0
00:0000002C 00000000        	   197: 	dc.l		0
00:00000030 00000000        	   198: 	dc.l		0
00:00000034 00000000        	   199: 	dc.l		0
00:00000038 00000000        	   200: 	dc.l		0
00:0000003C 00000000        	   201: 	dc.l		0
00:00000040 00000000        	   202: 	dc.l		0
00:00000044 00000000        	   203: 	dc.l		0
00:00000048 00000000        	   204: 	dc.l		0
00:0000004C 00000000        	   205: 	dc.l		0
                            	   206: 	
                            	   207: 	; 20
00:00000050 00000000        	   208: 	dc.l		0
00:00000054 00000000        	   209: 	dc.l		0
00:00000058 00000000        	   210: 	dc.l		0
00:0000005C 00000000        	   211: 	dc.l		0
00:00000060 00007502        	   212: 	dc.l		SpuriousIRQ
00:00000064 00000000        	   213: 	dc.l		0
00:00000068 00000000        	   214: 	dc.l		0
00:0000006C 000074DC        	   215: 	dc.l		irq3_rout
00:00000070 00000000        	   216: 	dc.l		0
00:00000074 00000000        	   217: 	dc.l		0
                            	   218: 	
                            	   219: 	; 30
00:00000078 0000748E        	   220: 	dc.l		TickIRQ						; IRQ 30 - timer / keyboard
00:0000007C 00007504        	   221: 	dc.l		nmi_rout
00:00000080 00000000        	   222: 	dc.l		0
00:00000084 00000000        	   223: 	dc.l		0
00:00000088 00000000        	   224: 	dc.l		0
00:0000008C 000071FE        	   225: 	dc.l		trap3							; breakpoint
00:00000090 00000000        	   226: 	dc.l		0
00:00000094 00000000        	   227: 	dc.l		0
00:00000098 00000000        	   228: 	dc.l		0
00:0000009C 00000000        	   229: 	dc.l		0
                            	   230: 
                            	   231: 	; 40
00:000000A0 00000000        	   232: 	dc.l		0
00:000000A4 00000000        	   233: 	dc.l		0
00:000000A8 00000000        	   234: 	dc.l		0
00:000000AC 00000000        	   235: 	dc.l		0
00:000000B0 00000000        	   236: 	dc.l		0
00:000000B4 00000000        	   237: 	dc.l		0
00:000000B8 00000000        	   238: 	dc.l		0
00:000000BC 00005470        	   239: 	dc.l		TRAP15
00:000000C0 00000000        	   240: 	dc.l		0
00:000000C4 00000000        	   241: 	dc.l		0
                            	   242: 
                            	   243: 	; 50	
00:000000C8 00000000        	   244: 	dc.l		0
00:000000CC 00000000        	   245: 	dc.l		0
00:000000D0 00000000        	   246: 	dc.l		0
00:000000D4 00000000        	   247: 	dc.l		0
00:000000D8 00000000        	   248: 	dc.l		0
00:000000DC 00000000        	   249: 	dc.l		0
00:000000E0 00000000        	   250: 	dc.l		0
00:000000E4 00000000        	   251: 	dc.l		0
00:000000E8 00000000        	   252: 	dc.l		0
00:000000EC 00007564        	   253: 	dc.l		io_irq
                            	   254: 
                            	   255: 	; 60
00:000000F0 00005ABA        	   256: 	dc.l		KeybdIRQ
00:000000F4 00006FFC        	   257: 	dc.l		SerialIRQ
00:000000F8 00000000        	   258: 	dc.l		0
00:000000FC 00007516        	   259: 	dc.l		brdisp_trap
00:00000100 00000000        	   260: 	dc.l		0
00:00000104 00000000        	   261: 	dc.l		0
00:00000108 00000000        	   262: 	dc.l		0
00:0000010C 00000000        	   263: 	dc.l		0
00:00000110 00000000        	   264: 	dc.l		0
00:00000114 00000000        	   265: 	dc.l		0
                            	   266: 
                            	   267: 	org			$400
                            	   268: 
                            	   269: InstalledIRQ:
00:00000400 00000000        	   270: 	dc.l		0
00:00000404 00000000        	   271: 	dc.l		0
00:00000408 00000000        	   272: 	dc.l		0
00:0000040C 00000000        	   273: 	dc.l		0
00:00000410 00000000        	   274: 	dc.l		0
00:00000414 00000000        	   275: 	dc.l		0
00:00000418 00000000        	   276: 	dc.l		0
00:0000041C 00000000        	   277: 	dc.l		0
                            	   278: 
00:00000420 00000000        	   279: 	dc.l		0
00:00000424 00000000        	   280: 	dc.l		0
00:00000428 00000000        	   281: 	dc.l		0
00:0000042C 00000000        	   282: 	dc.l		0
00:00000430 00000000        	   283: 	dc.l		0
00:00000434 00000000        	   284: 	dc.l		0
00:00000438 00000000        	   285: 	dc.l		0
00:0000043C 00000000        	   286: 	dc.l		0
                            	   287: 
00:00000440 00000000        	   288: 	dc.l		0
00:00000444 00000000        	   289: 	dc.l		0
00:00000448 00000000        	   290: 	dc.l		0
00:0000044C 00000000        	   291: 	dc.l		0
00:00000450 00000000        	   292: 	dc.l		0
00:00000454 00000000        	   293: 	dc.l		0
00:00000458 00000000        	   294: 	dc.l		0
00:0000045C 00000000        	   295: 	dc.l		0
                            	   296: 
00:00000460 00000000        	   297: 	dc.l		0
00:00000464 00000000        	   298: 	dc.l		0
00:00000468 00000000        	   299: 	dc.l		0
00:0000046C 00000000        	   300: 	dc.l		0
00:00000470 00000000        	   301: 	dc.l		0
00:00000474 00000000        	   302: 	dc.l		0
00:00000478 00000000        	   303: 	dc.l		0
00:0000047C 00000000        	   304: 	dc.l		0
                            	   305: 
00:00000480 00000000        	   306: 	dc.l		0
00:00000484 00000000        	   307: 	dc.l		0
00:00000488 00000000        	   308: 	dc.l		0
00:0000048C 00000000        	   309: 	dc.l		0
00:00000490 00000000        	   310: 	dc.l		0
00:00000494 00000000        	   311: 	dc.l		0
00:00000498 00000000        	   312: 	dc.l		0
00:0000049C 00000000        	   313: 	dc.l		0
                            	   314: 
00:000004A0 00000000        	   315: 	dc.l		0
00:000004A4 00000000        	   316: 	dc.l		0
00:000004A8 00000000        	   317: 	dc.l		0
00:000004AC 00000000        	   318: 	dc.l		0
00:000004B0 00000000        	   319: 	dc.l		0
00:000004B4 00000000        	   320: 	dc.l		0
00:000004B8 00000000        	   321: 	dc.l		0
00:000004BC 00000000        	   322: 	dc.l		0
                            	   323: 
00:000004C0 00000000        	   324: 	dc.l		0
00:000004C4 00000000        	   325: 	dc.l		0
00:000004C8 00000000        	   326: 	dc.l		0
00:000004CC 00000000        	   327: 	dc.l		0
00:000004D0 00000000        	   328: 	dc.l		0
00:000004D4 00000000        	   329: 	dc.l		0
00:000004D8 00000000        	   330: 	dc.l		0
00:000004DC 00000000        	   331: 	dc.l		0
                            	   332: 
00:000004E0 00000000        	   333: 	dc.l		0
00:000004E4 00000000        	   334: 	dc.l		0
00:000004E8 00000000        	   335: 	dc.l		0
00:000004EC 00000000        	   336: 	dc.l		0
00:000004F0 00000000        	   337: 	dc.l		0
00:000004F4 00000000        	   338: 	dc.l		0
00:000004F8 00000000        	   339: 	dc.l		0
00:000004FC 00000000        	   340: 	dc.l		0
                            	   341: 
                            	   342: 	org			$500
                            	   343: 
                            	   344: ;-------------------------------------------------------------------------------
                            	   345: ;-------------------------------------------------------------------------------
                            	   346: 
                            	   347: ; BIOS variables which must be local (not shared) to each core
                            	   348: 
                            	   349: CursorRow	equ		$40000
                            	   350: CursorCol	equ		$40001
                            	   351: TextPos		equ		$40002
                            	   352: TextCurpos	equ	$40002
                            	   353: TextScr			equ	$40004
                            	   354: S19StartAddress	equ	$40008
                            	   355: KeybdEcho		equ	$4000C
                            	   356: KeybdWaitFlag	equ	$4000D
                            	   357: CmdBuf			equ $40040
                            	   358: CmdBufEnd		equ	$40080
                            	   359: fgColor			equ	$40084
                            	   360: bkColor			equ	$40088
                            	   361: TextRows		equ	$4008C
                            	   362: TextCols		equ	$4008D
                            	   363: _fpTextIncr	equ $40094
                            	   364: _canary			equ $40098
                            	   365: IRQFlag			equ $400A0
                            	   366: Regsave			equ	$40100
                            	   367: numBreakpoints	equ		8
                            	   368: BreakpointFlag	equ		$40200
                            	   369: NumSetBreakpoints	equ	$40202	; to $40203
                            	   370: Breakpoints			equ		$40220	; to $40240
                            	   371: BreakpointWords	equ		$40280	; to $402A0
                            	   372: fpBuf       equ $402C0
                            	   373: ;RunningTCB  equ $40300
                            	   374: _exp equ $40500
                            	   375: _digit equ $40504
                            	   376: _width equ $40508
                            	   377: _E equ $4050C
                            	   378: _digits_before_decpt equ $40510
                            	   379: _precision equ $40514
                            	   380: _fpBuf equ $40520	; to $40560
                            	   381: _fpWork equ $40600
                            	   382: TimerStack	equ	$40BFC
                            	   383: 
                            	   384: ; Keyboard buffer is in shared memory
                            	   385: IOFocus			EQU	$00100000
                            	   386: memend			equ $00100004
                            	   387: KeybdLEDs		equ	$0010000E
                            	   388: _KeyState1	equ	$0010000F
                            	   389: _KeyState2	equ	$00100010
                            	   390: _KeybdHead	equ	$00100011
                            	   391: _KeybdTail	equ	$00100012
                            	   392: _KeybdCnt		equ	$00100013
                            	   393: KeybdID			equ	$00100016
                            	   394: _KeybdBuf		equ	$00100020
                            	   395: S19Checksum	equ	$00100150
                            	   396: SerTailRcv	equ	$00100160
                            	   397: SerHeadRcv	equ	$00100162
                            	   398: SerRcvXon		equ	$00100164
                            	   399: SerRcvXoff	equ	$00100165
                            	   400: SerRcvBuf		equ	$00101000
                            	   401: RTCBuf			equ $00100200	; to $0010023F
                            	   402: 
                            	   403: 	include "..\Femtiki\source\kernel\Femtiki_vars.x68"

Source: "..\Femtiki\source\kernel\Femtiki_vars.x68"
                            	     1: 
                            	     2: PAMShareCounts	EQU	$20000000	; one byte for each physical page of memory
                            	     3: tcbs						EQU	$20010000	; 4095*256 = 1MB
                            	     4: tcbs_end				EQU	$20020000
                            	     5: messages				EQU	$20020000	; 32*8192 (680*16=21760 messages)
                            	     6: messages_end		EQU	$20060000
                            	     7: mailboxes				EQU	$20060000
                            	     8: mailboxes_end		EQU	$20078000	;	12*8192 (816*12=9792 mailboxes)
                            	     9: acbs						EQU	$20080000	; 32*2*8192 =512kB
                            	    10: acbs_end				EQU	$20100000
                            	    11: 
                            	    12: 
                            	    13: sys_stacks			EQU	$DF0000
                            	    14: 
                            	    15: FemtikiVars			EQU	$00100200
                            	    16: PAMLastAllocate2	EQU		$00100218
                            	    17: RunningAID		EQU		$00100220
                            	    18: RunningTCB			EQU		$00100224
                            	    19: ACBPtrs				EQU		$00100228
                            	    20: MidStackBottoms	EQU		$00100264
                            	    21: FemtikiInited	EQU		$00100284
                            	    22: missed_ticks	EQU		$00100288
                            	    23: IOFocusList		EQU		$0010028C
                            	    24: IOFocusID			EQU		$001002AC
                            	    25: iof_switch		EQU		$001002AD
                            	    26: nMessage			EQU		$001002AE
                            	    27: nMailbox			EQU		$001002B0
                            	    28: hKeybdMbx			EQU		$001002BA
                            	    29: hFocusSwitchMbx		EQU		$001002BC
                            	    30: BIOS_RespMbx	EQU		$001002BE
                            	    31: hasUltraHighPriorityTasks	EQU		$001002C0
                            	    32: im_save				EQU		$001002C2
                            	    33: sp_tmp				EQU		$001002C4
                            	    34: startQNdx			EQU		$001002C6
                            	    35: NPAGES				EQU		$001002D8
                            	    36: syspages			EQU		$001002DA
                            	    37: mmu_FreeMaps	EQU		$001002E0
                            	    38: mmu_entries		EQU		$00100300
                            	    39: freelist			EQU		$00100302
                            	    40: hSearchMap		EQU		$00100304
                            	    41: OSActive			EQU		$00100305
                            	    42: FreeACB				EQU		$00100308
                            	    43: FreeTCB				EQU		$0010030C
                            	    44: FreeMSG				EQU		$00100310
                            	    45: FreeMBX				EQU		$00100314
                            	    46: TimeoutList		EQU		$00100318
                            	    47: QueueCycle    EQU   $0010031C
                            	    48: readyQ				EQU		$00100320
                            	    49: readyQTail		EQU		$00100340
                            	    50: FemtikiVars_end	EQU	$00100400
                            	    51: 
                            	    52: ;gc_stack		rmb		512
                            	    53: ;gc_pc				fcdw		0
                            	    54: ;gc_omapno		fcw			0
                            	    55: ;gc_mapno		fcw			0
                            	    56: ;gc_dl				fcw			0
                            	    57: 

Source: "boot.asm"
                            	   404: 
                            	   405: 	code
                            	   406: 	align		2
                            	   407: start:
                            	   408: ;	fadd (a0)+,fp2
02:00000000 46FC2700        	   409: 	move.w #$2700,sr					; enable level 6 and higher interrupts
02:00000004 7000            	   410: 	moveq #0,d0								; set address space zero
02:00000006 4E7B0003        	   411: 	movec d0,asid
                            	   412: 	; Setup circuit select signals
02:0000000A 203CFDC00000    	   413: 	move.l #MMU,d0
02:00000010 4E7B0014        	   414: 	movec d0,mmus
                            	   415: 	if HAS_MMU
                            	   416: 		move.l #$01F00000,d0			; set virtual address for iop bitmap
                            	   417: 		movec d0,iops
                            	   418: 		move.l #$01E00000,d0			; set virtual address for io block
                            	   419: 		movec d0,ios
                            	   420: 	else
02:00000014 203CFD100000    	   421: 		move.l #$FD100000,d0			; set virtual address for iop bitmap
02:0000001A 4E7B0016        	   422: 		movec d0,iops
02:0000001E 203CFD000000    	   423: 		move.l #$FD000000,d0			; set virtual address for io block
02:00000024 4E7B0015        	   424: 		movec d0,ios
                            	   425: 	endif
02:00000028 4E7A0FE0        	   426: 	movec coreno,d0							; set initial value of thread register
02:0000002C 4840            	   427: 	swap d0											; coreno in high eight bits
02:0000002E E188            	   428: 	lsl.l #8,d0
02:00000030 4E7B0012        	   429: 	movec d0,tr
                            	   430: 	; Prepare local variable storage
02:00000034 303C03FF        	   431: 	move.w #1023,d0						; 1024 longs to clear
02:00000038 41F900040000    	   432: 	lea	$40000,a0							; non shared local memory address
                            	   433: .0111:
02:0000003E 4298            	   434: 	clr.l	(a0)+								; clear the memory area
02:00000040 51C8FFFC        	   435: 	dbra d0,.0111
02:00000044 23FC001FFFFF0004	   436: 	move.l #$1fffff,fgColor		; set foreground / background color
02:0000004C 0084
02:0000004E 23FC0000003F0004	   437: 	move.l #$00003f,bkColor
02:00000056 0088
02:00000058 4E7A0FE0        	   438: 	movec.l	coreno,d0					; get core number (2 to 9)
02:0000005C 5500            	   439: 	subi.b #2,d0							; adjust (0 to 7)
02:0000005E C0FC4000        	   440: 	mulu #16384,d0						; compute screen location
                            	   441: 	if HAS_MMU
                            	   442: 		addi.l #$01E00000,d0
                            	   443: 	else
02:00000062 0680FD000000    	   444: 		addi.l #$FD000000,d0
                            	   445: 	endif
02:00000068 23C000040004    	   446: 	move.l d0,TextScr
02:0000006E 13FC00400004008D	   447: 	move.b #64,TextCols				; set rows and columns
02:00000076 13FC00200004008C	   448: 	move.b #32,TextRows
02:0000007E 4E7A0FE0        	   449: 	movec.l	coreno,d0					; get core number
02:00000082 0C000002        	   450: 	cmpi.b #2,d0
02:00000086 667C            	   451: 	bne	start_other
02:00000088 13C000100000    	   452: 	move.b d0,IOFocus					; Set the IO focus in global memory
                            	   453: 	if HAS_MMU
                            	   454: 		bsr InitMMU							; Can't access anything till this is done
                            	   455: 	endif
02:0000008E 61000096        	   456: 	bsr	InitIOPBitmap					; not going to get far without this
02:00000092 61000186        	   457: 	bsr	InitSemaphores
02:00000096 610000DE        	   458: 	bsr	InitRand
02:0000009A 6100011A        	   459: 	bsr RandGetNum
02:0000009E 0281FFFFFF00    	   460: 	andi.l #$FFFFFF00,d1
02:000000A4 23C100040098    	   461: 	move.l d1,_canary
02:000000AA 4E7B1020        	   462: 	movec d1,canary
02:000000AE 61000226        	   463: 	bsr	Delay3s						; give devices time to reset
02:000000B2 6100502A        	   464: 	bsr	clear_screen
                            	   465: 
02:000000B6 61005592        	   466: 	bsr	_KeybdInit
                            	   467: ;	bsr	InitIRQ
02:000000BA 61006E00        	   468: 	bsr	SerialInit
02:000000BE 61006FCC        	   469: 	bsr init_i2c
                            	   470: ;	bsr rtc_read
                            	   471: 
                            	   472: 	; Write startup message to screen
                            	   473: 
02:000000C2 43FA74B4        	   474: 	lea	msg_start,a1
02:000000C6 6100532A        	   475: 	bsr	DisplayString
                            	   476: ;	bsr	FemtikiInit
02:000000CA 4E7A0FE0        	   477: 	movec	coreno,d0
02:000000CE 4840            	   478: 	swap d0
02:000000D0 7201            	   479: 	moveq	#1,d1
02:000000D2 610001A8        	   480: 	bsr	UnlockSemaphore	; allow another cpu access
02:000000D6 7200            	   481: 	moveq	#0,d1
02:000000D8 610001A2        	   482: 	bsr	UnlockSemaphore	; allow other cpus to proceed
02:000000DC 33FCA4A4FD0FFF00	   483: 	move.w #$A4A4,leds			; diagnostics
02:000000E4 610054C4        	   484: 	bsr	init_plic				; initialize platform level interrupt controller
02:000000E8 60005DCE        	   485: 	bra	StartMon
02:000000EC 61000228        	   486: 	bsr	cpu_test
                            	   487: ;	lea	brdisp_trap,a0	; set brdisp trap vector
                            	   488: ;	move.l	a0,64*4
                            	   489: 
                            	   490: loop2:
02:000000F0 70FF            	   491: 	move.l	#-1,d0
                            	   492: loop1:
02:000000F2 2200            	   493: 	move.l	d0,d1
02:000000F4 E089            	   494: 	lsr.l		#8,d1
02:000000F6 E089            	   495: 	lsr.l		#8,d1
02:000000F8 13C1FD0FFF00    	   496: 	move.b	d1,leds
02:000000FE 51C8FFF2        	   497: 	dbra		d0,loop1
02:00000102 60EC            	   498: 	bra			loop2
                            	   499: 
                            	   500: start_other:
02:00000104 610001F4        	   501: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
02:00000108 610001F0        	   502: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
02:0000010C 61004FD0        	   503: 	bsr			clear_screen
02:00000110 4E7A1FE0        	   504: 	movec		coreno,d1
02:00000114 61006A8A        	   505: 	bsr			DisplayByte
02:00000118 43FA7485        	   506: 	lea			msg_core_start,a1
02:0000011C 610052D4        	   507: 	bsr			DisplayString
                            	   508: ;	bsr			FemtikiInitIRQ
                            	   509: do_nothing:	
02:00000120 60005D96        	   510: 	bra			StartMon
02:00000124 60FA            	   511: 	bra			do_nothing
                            	   512: 
                            	   513: ;------------------------------------------------------------------------------
                            	   514: ; Initialize the MMU to allow thread #0 access to IO
                            	   515: ;------------------------------------------------------------------------------
                            	   516: 	if HAS_MMU
                            	   517: 	align 2
                            	   518: mmu_adrtbl:	; virtual address[24:16], physical address[31:16] bytes reversed!
                            	   519: 	dc.l	$0010,$10000300	; global scratch pad
                            	   520: 	dc.l	$01E0,$00FD0300	
                            	   521: 	dc.l	$01E1,$01FD0300
                            	   522: 	dc.l	$01E2,$02FD0300
                            	   523: 	dc.l  $01E3,$03FD0300
                            	   524: 	dc.l	$01E5,$05FD0300
                            	   525: 	dc.l	$01E6,$06FD0300
                            	   526: 	dc.l	$01E9,$09FD0300
                            	   527: 	dc.l	$01EF,$0FFD0300
                            	   528: 	dc.l	$01F0,$10FD0300
                            	   529: 	dc.l  $01FF,$FFFF0300	; all ones output for IRQ ack needed
                            	   530: 
                            	   531: 	even
                            	   532: InitMMU:
                            	   533: 	lea MMU+8,a0				; first 128kB is local RAM
                            	   534: 	move.l #$32000,d2		; map all pages to DRAM
                            	   535: 	move.l #510,d0			; then override for IO later
                            	   536: .0002
                            	   537: 	move.l d2,d1
                            	   538: 	bsr rbo
                            	   539: 	move.l d1,(a0)+
                            	   540: 	addi.w #1,d2				; increment DRAM page number
                            	   541: 	dbra d0,.0002
                            	   542: 	lea MMU,a0					; now program IO access
                            	   543: 	lea mmu_adrtbl,a1
                            	   544: 	moveq #10,d0
                            	   545: .0001
                            	   546: 	move.l (a1)+,d2
                            	   547: 	lsl.l #2,d2
                            	   548: 	move.l (a1)+,(a0,d2.w)
                            	   549: 	dbra d0,.0001
                            	   550: 	rts	
                            	   551: 	endif
                            	   552: 
                            	   553: ;------------------------------------------------------------------------------
                            	   554: ; The IO bitmap needs to be initialized to allow access to IO.
                            	   555: ;------------------------------------------------------------------------------
                            	   556: 
                            	   557: InitIOPBitmap:
02:00000126 7600            	   558: 	moveq #0,d3				; d3 = asid value
02:00000128 303C003F        	   559: 	move.w #63,d0			; 64 bitmaps to setup
02:0000012C 4E7A8016        	   560: 	movec iops,a0			; a0 = IOP bitmap address
02:00000130 2248            	   561: 	movea.l a0,a1			; a1 = table address
                            	   562: .0004
02:00000132 4A03            	   563: 	tst.b d3
02:00000134 57C1            	   564: 	seq d1						; set entire bitmap for asid 0, otherwise clear entire bitmap
02:00000136 4881            	   565: 	ext.w	d1					; make into a long value
02:00000138 48C1            	   566: 	ext.l d1
02:0000013A 383C007F        	   567: 	move.w #127,d4
                            	   568: .0001
02:0000013E 22C1            	   569: 	move.l d1,(a1)+		; set or clear entire table
02:00000140 51CCFFFC        	   570: 	dbra d4,.0001
02:00000144 72FF            	   571: 	moveq #-1,d1
02:00000146 214100A0        	   572: 	move.l d1,160(a0)	; all cores have access to semaphores
02:0000014A 214100A4        	   573: 	move.l d1,164(a0)
02:0000014E 214100A8        	   574: 	move.l d1,168(a0)
02:00000152 214100AC        	   575: 	move.l d1,172(a0)
02:00000156 217C0000000201FC	   576: 	move.l #2,508(a0)	; all cores access random # generator
02:0000015E 4840            	   577: 	swap d0
02:00000160 303C001F        	   578: 	move.w #31,d0			; 32 long words for the screen area per bitmap
                            	   579: .0003
02:00000164 20C1            	   580: 	move.l d1,(a0)+		; all cores have access to a screen
02:00000166 51C8FFFC        	   581: 	dbra d0,.0003
02:0000016A 4840            	   582: 	swap d0
02:0000016C 5203            	   583: 	addi.b #1,d3			; do next address space
02:0000016E 2049            	   584: 	movea.l a1,a0			; a0 points to area for next address space
02:00000170 51C8FFC0        	   585: 	dbra d0,.0004
02:00000174 4E75            	   586: 	rts	
                            	   587: 	
                            	   588: ;------------------------------------------------------------------------------
                            	   589: ; RandInit
                            	   590: ; 	Initialize random number generator.
                            	   591: ;
                            	   592: ; Modifies:
                            	   593: ;		none
                            	   594: ; Parameters:
                            	   595: ;		none
                            	   596: ;	Returns:
                            	   597: ;		none
                            	   598: ;------------------------------------------------------------------------------
                            	   599: 
                            	   600: InitRand:
                            	   601: RandInit:
02:00000176 48E7C000        	   602: 	movem.l	d0/d1,-(a7)
02:0000017A 7025            	   603: 	moveq #37,d0								; lock semaphore
02:0000017C 7204            	   604: 	moveq	#RAND_SEMA,d1
02:0000017E 4E4F            	   605: 	trap #15
02:00000180 4E7A0FE0        	   606: 	movec coreno,d0							; d0 = core number
02:00000184 ED88            	   607: 	lsl.l	#6,d0									; allow 64 streams per core
02:00000186 23C0FD0FFD04    	   608: 	move.l d0,RAND_STRM					; select the stream
02:0000018C 23FC12345678FD0F	   609: 	move.l #$12345678,RAND_MZ		; initialize to some value
02:00000194 FD08
02:00000196 23FC98765432FD0F	   610: 	move.l #$98765432,RAND_MW
02:0000019E FD0C
02:000001A0 23FC2E5BF271FD0F	   611: 	move.l #777777777,RAND_NUM	; generate first number
02:000001A8 FD00
02:000001AA 7026            	   612: 	moveq #38,d0								; unlock semaphore
02:000001AC 7204            	   613: 	moveq	#RAND_SEMA,d1
02:000001AE 4E4F            	   614: 	trap #15
02:000001B0 4CDF0003        	   615: 	movem.l	(a7)+,d0/d1
02:000001B4 4E75            	   616: 	rts
                            	   617: 
                            	   618: ;------------------------------------------------------------------------------
                            	   619: ; Returns
                            	   620: ;		d1 = random integer
                            	   621: ;------------------------------------------------------------------------------
                            	   622: 
                            	   623: RandGetNum:
02:000001B6 48E7A000        	   624: 	movem.l	d0/d2,-(a7)
02:000001BA 7025            	   625: 	moveq #37,d0								; lock semaphore
02:000001BC 7204            	   626: 	moveq	#RAND_SEMA,d1
02:000001BE 4E4F            	   627: 	trap #15
02:000001C0 4E7A0FE0        	   628: 	movec	coreno,d0
02:000001C4 ED88            	   629: 	lsl.l	#6,d0
02:000001C6 23C0FD0FFD04    	   630: 	move.l d0,RAND_STRM					; select the stream
02:000001CC 2439FD0FFD00    	   631: 	move.l RAND_NUM,d2					; d2 = random number
02:000001D2 42B9FD0FFD00    	   632: 	clr.l	RAND_NUM							; generate next number
02:000001D8 7026            	   633: 	moveq #38,d0								; unlock semaphore
02:000001DA 7204            	   634: 	moveq	#RAND_SEMA,d1
02:000001DC 4E4F            	   635: 	trap #15
02:000001DE 2202            	   636: 	move.l d2,d1
02:000001E0 4CDF0005        	   637: 	movem.l	(a7)+,d0/d2
02:000001E4 4E75            	   638: 	rts
                            	   639: 
                            	   640: ;------------------------------------------------------------------------------
                            	   641: ; Returns
                            	   642: ;		fp0 = random float between 0 and 1.
                            	   643: ;------------------------------------------------------------------------------
                            	   644: 
                            	   645: _GetRand:
02:000001E6 61CE            	   646: 	bsr RandGetNum
02:000001E8 F2015000        	   647: 	fmove d1,fp0
02:000001EC F23C408080000000	   648: 	fmove.l #$80000000,fp1
02:000001F4 F2000420        	   649: 	fdiv fp1,fp0
02:000001F8 F23C50800002    	   650: 	fmove.w #$2,fp1
02:000001FE F2000420        	   651: 	fdiv fp1,fp0
02:00000202 4E75            	   652: 	rts
                            	   653: 
                            	   654: ;------------------------------------------------------------------------------
                            	   655: ; RandWait
                            	   656: ;    Wait some random number of clock cycles before returning.
                            	   657: ;------------------------------------------------------------------------------
                            	   658: 
                            	   659: RandWait:
02:00000204 48E7C000        	   660: 	movem.l	d0/d1,-(a7)
02:00000208 61AC            	   661: 	bsr			RandGetNum
02:0000020A 0241000F        	   662: 	andi.w	#15,d1
                            	   663: .0001:
02:0000020E 4E71            	   664: 	nop
02:00000210 51C9FFFC        	   665: 	dbra		d1,.0001
02:00000214 4CDF0003        	   666: 	movem.l	(a7)+,d0/d1
02:00000218 4E75            	   667: 	rts
                            	   668: 
                            	   669: ;------------------------------------------------------------------------------
                            	   670: ; Initialize semaphores
                            	   671: ; - all semaphores are set to unlocked except the first one, which is locked
                            	   672: ; for core #2.
                            	   673: ;
                            	   674: ; Parameters:
                            	   675: ;		<none>
                            	   676: ; Modifies:
                            	   677: ;		<none>
                            	   678: ; Returns:
                            	   679: ;		<none>
                            	   680: ;------------------------------------------------------------------------------
                            	   681: 
                            	   682: InitSemaphores:
02:0000021A 48E74080        	   683: 	movem.l	d1/a0,-(a7)
02:0000021E 41F9FD050000    	   684: 	lea			semamem,a0
02:00000224 217C000200002000	   685: 	move.l	#$20000,$2000(a0)	; lock the first semaphore for core #2, thread #0
02:0000022C 323C00FE        	   686: 	move.w	#254,d1
                            	   687: .0001:
02:00000230 5888            	   688: 	lea			4(a0),a0
02:00000232 42A82000        	   689: 	clr.l		$2000(a0)					; write zeros to unlock
02:00000236 51C9FFF8        	   690: 	dbra		d1,.0001
02:0000023A 4CDF0102        	   691: 	movem.l	(a7)+,d1/a0
02:0000023E 4E75            	   692: 	rts
                            	   693: 
                            	   694: ; -----------------------------------------------------------------------------
                            	   695: ; Parameters:
                            	   696: ;		d1 semaphore number
                            	   697: ;
                            	   698: ; Side Effects:
                            	   699: ;		increments semaphore, saturates at 255
                            	   700: ;
                            	   701: ; Returns:	
                            	   702: ; 	z flag set if semaphore was zero
                            	   703: ; -----------------------------------------------------------------------------
                            	   704: 
                            	   705: ;IncrementSemaphore:
                            	   706: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   707: ;	lea			semamem,a0			; point to semaphore memory
                            	   708: ;	ext.w		d1							; make d1 word value
                            	   709: ;	asl.w		#4,d1						; align to memory
                            	   710: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   711: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   712: ;	rts
                            	   713: 	
                            	   714: ; -----------------------------------------------------------------------------
                            	   715: ; Parameters:
                            	   716: ;		d1 semaphore number
                            	   717: ;
                            	   718: ; Side Effects:
                            	   719: ;		decrements semaphore, saturates at zero
                            	   720: ;
                            	   721: ; Returns:	
                            	   722: ; 	z flag set if semaphore was zero
                            	   723: ; -----------------------------------------------------------------------------
                            	   724: 
                            	   725: ;DecrementSemaphore:
                            	   726: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   727: ;	lea			semamem,a0			; point to semaphore memory
                            	   728: ;	andi.w	#255,d1					; make d1 word value
                            	   729: ;	asl.w		#4,d1						; align to memory
                            	   730: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   731: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   732: ;	rts
                            	   733: 
                            	   734: ; -----------------------------------------------------------------------------
                            	   735: ; Lock a semaphore
                            	   736: ;
                            	   737: ; Parameters:
                            	   738: ;		d0 = key
                            	   739: ;		d1 = semaphore number
                            	   740: ; -----------------------------------------------------------------------------
                            	   741: 
                            	   742: LockSemaphore:
02:00000240 4E75            	   743: 	rts
02:00000242 48E74080        	   744: 	movem.l	d1/a0,-(a7)			; save registers
02:00000246 41F9FD050000    	   745: 	lea			semamem,a0			; point to semaphore memory lock area
02:0000024C 024100FF        	   746: 	andi.w	#255,d1					; make d1 word value
02:00000250 E549            	   747: 	lsl.w		#2,d1						; align to memory
                            	   748: .0001
02:00000252 21801000        	   749: 	move.l	d0,(a0,d1.w)		; try and write the semaphore
02:00000256 B0B01000        	   750: 	cmp.l		(a0,d1.w),d0		; did it lock?
02:0000025A 66F6            	   751: 	bne.s		.0001						; no, try again
02:0000025C 4CDF0102        	   752: 	movem.l	(a7)+,a0/d1			; restore regs
02:00000260 4E75            	   753: 	rts
                            	   754: 	
                            	   755: ; -----------------------------------------------------------------------------
                            	   756: ; Unlocks a semaphore even if not the owner.
                            	   757: ;
                            	   758: ; Parameters:
                            	   759: ;		d1 semaphore number
                            	   760: ; -----------------------------------------------------------------------------
                            	   761: 
                            	   762: ForceUnlockSemaphore:
02:00000262 48E74080        	   763: 	movem.l	d1/a0,-(a7)				; save registers
02:00000266 41F9FD053000    	   764: 	lea			semamem+$3000,a0	; point to semaphore memory read/write area
02:0000026C 024100FF        	   765: 	andi.w	#255,d1						; make d1 word value
02:00000270 E549            	   766: 	lsl.w		#2,d1							; align to memory
02:00000272 42B01000        	   767: 	clr.l		(a0,d1.w)					; write zero to unlock
02:00000276 4CDF0102        	   768: 	movem.l	(a7)+,a0/d1				; restore regs
02:0000027A 4E75            	   769: 	rts
                            	   770: 
                            	   771: ; -----------------------------------------------------------------------------
                            	   772: ; Unlocks a semaphore. Must be the owner to have effect.
                            	   773: ; Three cases:
                            	   774: ;	1) the owner, the semaphore will be reset to zero
                            	   775: ;	2) not the owner, the write will be ignored
                            	   776: ; 3) already unlocked, the write will be ignored
                            	   777: ;
                            	   778: ; Parameters:
                            	   779: ;		d0 = key
                            	   780: ;		d1 = semaphore number
                            	   781: ; -----------------------------------------------------------------------------
                            	   782: 
                            	   783: UnlockSemaphore:
02:0000027C 60E4            	   784: 	bra ForceUnlockSemaphore
02:0000027E 48E74080        	   785: 	movem.l	d1/a0,-(a7)				; save registers
02:00000282 41F9FD051000    	   786: 	lea			semamem+$1000,a0	; point to semaphore memory unlock area
02:00000288 024100FF        	   787: 	andi.w	#255,d1						; make d1 word value
02:0000028C E549            	   788: 	lsl.w		#2,d1							; align to memory
02:0000028E 21801000        	   789: 	move.l	d0,(a0,d1.w)			; write matching value to unlock
02:00000292 4CDF0102        	   790: 	movem.l	(a7)+,a0/d1				; restore regs
02:00000296 4E75            	   791: 	rts
                            	   792: 
                            	   793: ; -----------------------------------------------------------------------------
                            	   794: ; Parameters:
                            	   795: ;		d1 = semaphore to lock / unlock
                            	   796: ; -----------------------------------------------------------------------------
                            	   797: 
                            	   798: T15LockSemaphore:	
02:00000298 4E7A0012        	   799: 	movec tr,d0
02:0000029C 60A2            	   800: 	bra LockSemaphore
                            	   801: 
                            	   802: T15UnlockSemaphore:
02:0000029E 4E7A0012        	   803: 	movec tr,d0
02:000002A2 60D8            	   804: 	bra UnlockSemaphore
                            	   805: 
                            	   806: T15GetFloat:
02:000002A4 2049            	   807: 	move.l a1,a0
02:000002A6 2001            	   808: 	move.l d1,d0
02:000002A8 6100681E        	   809: 	bsr _GetFloat
02:000002AC 2248            	   810: 	move.l a0,a1
02:000002AE 2200            	   811: 	move.l d0,d1
02:000002B0 4E75            	   812: 	rts
                            	   813: 
                            	   814: T15Abort:
02:000002B2 610068EC        	   815: 	bsr DisplayByte
02:000002B6 43FA7355        	   816: 	lea msgStackCanary,a1
02:000002BA 6100514C        	   817: 	bsr DisplayStringCRLF
02:000002BE 60005C02        	   818: 	bra Monitor
                            	   819: 
                            	   820: chk_exception:
02:000002C2 222F0004        	   821: 	move.l 4(sp),d1
02:000002C6 610068CC        	   822: 	bsr DisplayTetra
02:000002CA 43FA7333        	   823: 	lea msgChk,a1
02:000002CE 61005138        	   824: 	bsr DisplayStringCRLF
02:000002D2 60005BEE        	   825: 	bra Monitor
                            	   826: 
                            	   827: ; -----------------------------------------------------------------------------
                            	   828: ; Delay for a few seconds to allow some I/O reset operations to take place.
                            	   829: ; -----------------------------------------------------------------------------
                            	   830: 
                            	   831: Delay3s:
02:000002D6 203C002DC6C0    	   832: 	move.l	#3000000,d0		; this should take a few seconds to loop
02:000002DC 41F9FD0FFF00    	   833: 	lea			leds,a0				; a0 = address of LED output register
02:000002E2 6002            	   834: 	bra			dly3s1				; branch to the loop
                            	   835: dly3s2:	
02:000002E4 4840            	   836: 	swap		d0						; loop is larger than 16-bits
                            	   837: dly3s1:
02:000002E6 2200            	   838: 	move.l	d0,d1					; the counter cycles fast, so use upper bits for display
02:000002E8 E199            	   839: 	rol.l		#8,d1					; could use swap here, but lets test rol
02:000002EA E199            	   840: 	rol.l		#8,d1
02:000002EC 1081            	   841: 	move.b	d1,(a0)				; set the LEDs
02:000002EE 51C8FFF6        	   842: 	dbra		d0,dly3s1			; decrement and branch back
02:000002F2 4840            	   843: 	swap		d0
02:000002F4 51C8FFEE        	   844: 	dbra		d0,dly3s2
02:000002F8 4E75            	   845: 	rts
                            	   846: 
                            	   847: Delay3s2:
02:000002FA 4E7A0FE0        	   848: 	movec		coreno,d0			; vary delay by core to stagger startup
02:000002FE E188            	   849: 	lsl.l		#8,d0
02:00000300 0680002DC6C0    	   850: 	addi.l	#3000000,d0		; this should take a few seconds to loop
02:00000306 6002            	   851: 	bra			.0001					; branch to the loop
                            	   852: .0002	
02:00000308 4840            	   853: 	swap		d0						; loop is larger than 16-bits
                            	   854: .0001
02:0000030A 51C8FFFE        	   855: 	dbra		d0,.0001			; decrement and branch back
02:0000030E 4840            	   856: 	swap		d0
02:00000310 51C8FFF6        	   857: 	dbra		d0,.0002
02:00000314 4E75            	   858: 	rts
                            	   859: 
                            	   860: 	include "cputest.asm"

Source: "cputest.asm"
                            	     1: ** @name cputest.s Tests 68000 cpu
                            	     2: *
                            	     3: * Based on https://github.com/MicroCoreLabs/Projects/blob/master/MCL68/MC68000_Test_Code/MC68000_test_all_opcodes.X68
                            	     4: *
                            	     5: * Converted into a CD-i system ROM image by CD-i Fan:
                            	     6: * - comment lines must start in first column
                            	     7: * - replaced org instructions by suitable rept
                            	     8: * - copy vectors to low memory at startup
                            	     9: * - replaced jsr/jmp by bsr/bra for position independence
                            	    10: * - replaced move.l by moveq whenever possible
                            	    11: * - converted branches to short form whenever possible (e.g. beq => beq.s)
                            	    12: * - added immediate suffix to opcodes where required (e.g. and => andi)
                            	    13: * The last three modifications are required to make the test work;
                            	    14: * apparently the original assembler was somewhat smarter then
                            	    15: * the Microware OS-9 assembler and did this automatically.
                            	    16: *
                            	    17: * In some cases the opcodes of the test are used as test data!
                            	    18: *
                            	    19: * Original file header follows.
                            	    20: *
                            	    21: *  File Name   :  MCL68 Opcode Tests
                            	    22: *  Used on     :
                            	    23: *  Author      :  Ted Fried, MicroCore Labs
                            	    24: *  Creation    :  7/14/2020
                            	    25: *
                            	    26: *   Description:
                            	    27: *   ============
                            	    28: *
                            	    29: *  Program to test all of the Motorola 68000's opcodes.
                            	    30: *
                            	    31: *  If failures are detected, the code will immediately loop on itself.
                            	    32: *  All addressing modes, data sizes, and opcode combinations are tested.
                            	    33: *
                            	    34: *  This code was developed using the Easy68K simulator where all tests passed!
                            	    35: *
                            	    36: *------------------------------------------------------------------------
                            	    37: *
                            	    38: * Modification History:
                            	    39: * =====================
                            	    40: *
                            	    41: * Revision 1 7/14/2020
                            	    42: * Initial revision
                            	    43: *
                            	    44: *
                            	    45: *------------------------------------------------------------------------
                            	    46: *
                            	    47: * Copyright (c) 2020 Ted Fried
                            	    48: *
                            	    49: * Permission is hereby granted, free of charge, to any person obtaining a copy
                            	    50: * of this software and associated documentation files (the "Software"), to deal
                            	    51: * in the Software without restriction, including without limitation the rights
                            	    52: * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                            	    53: * copies of the Software, and to permit persons to whom the Software is
                            	    54: * furnished to do so, subject to the following conditions:
                            	    55: *
                            	    56: * The above copyright notice and this permission notice shall be included in all
                            	    57: * copies or substantial portions of the Software.
                            	    58: *
                            	    59: * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            	    60: * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            	    61: * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            	    62: * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            	    63: * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                            	    64: * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                            	    65: * SOFTWARE.
                            	    66: 
                            	    67: * Modified for rf68000 project (c) 2022 Robert Finch
                            	    68: 
                            	    69: *	data
                            	    70: *	dc.l		$0001FFFC						; top of local ram area
                            	    71: *	dc.l		start
                            	    72: 
                            	    73: *    org $1000												; code starts at $400 in local ram
                            	    74: *start:
                            	    75: *	move.l	$FFFFFFE0,d0		; get core number
                            	    76: *	cmpi.b	#2,d0
                            	    77: *	bne			do_nothing
                            	    78: 
                            	    79: *	lea			EXCEPTION_6,a0	* check exception vector
                            	    80: *	move.l	a0,6*4
                            	    81: *	lea			EXCEPTION_7,a0	* TRAPV exception vector
                            	    82: *	move.l	a0,7*4
                            	    83: 
                            	    84: cpu_test:
02:00000316 610000FA        	    85: 	bsr	op_ORI_TO_CCR
02:0000031A 61000118        	    86: 	bsr	op_ORI_TO_SR
02:0000031E 61000136        	    87: 	bsr	op_EORI_TO_CCR
02:00000322 61000158        	    88: 	bsr	op_EORI_TO_SR
02:00000326 6100017A        	    89: 	bsr	op_ANDI_TO_CCR
02:0000032A 6100019C        	    90: 	bsr	op_ANDI_TO_SR
02:0000032E 610001BE        	    91: 	bsr	op_BTST
02:00000332 61000564        	    92: 	bsr	op_BCHG
02:00000336 610008C8        	    93: 	bsr	op_BCLR
02:0000033A 61000C12        	    94: 	bsr	op_BSET
02:0000033E 61000F56        	    95: 	bsr op_MOVEP
02:00000342 61000FDE        	    96: 	bsr op_BOOL_I
02:00000346 610011C2        	    97: 	bsr op_CMP_I
02:0000034A 610013A6        	    98: 	bsr op_ADD_I
02:0000034E 61001528        	    99: 	bsr op_SUB_I
02:00000352 610016AA        	   100: 	bsr op_MOVE
02:00000356 610018B2        	   101: 	bsr op_MOVE_xxx_FLAGS
02:0000035A 61001AA2        	   102: 	bsr op_EXT
02:0000035E 61001ACA        	   103: 	bsr op_SWAP
02:00000362 61001ADC        	   104: 	bsr op_LEAPEA
02:00000366 61001B84        	   105: 	bsr op_TAS
02:0000036A 61001BA6        	   106: 	bsr op_TST
02:0000036E 61001BE0        	   107: 	bsr op_LINKS
02:00000372 61001BFA        	   108: 	bsr op_MOVE_USP
02:00000376 61001C06        	   109: 	bsr op_CHK
02:0000037A 61001C3C        	   110: 	bsr op_NEGS
02:0000037E 61001FC6        	   111: 	bsr op_MOVEM
                            	   112: *	bsr op_ABCD
                            	   113: *	bsr op_SBCD
                            	   114: *	bsr op_NBCD
02:00000382 61002562        	   115: 	bsr op_TRAPV
02:00000386 6100257A        	   116: 	bsr op_RTR
02:0000038A 61001148        	   117: 	bsr op_BSR
02:0000038E 61002594        	   118: 	bsr op_BCC
02:00000392 61002610        	   119: 	bsr op_DBCC
02:00000396 61002632        	   120: 	bsr op_SCC
02:0000039A 6100265E        	   121: 	bsr op_ADDQ
02:0000039E 61002714        	   122: 	bsr op_SUBQ
02:000003A2 610027CA        	   123: 	bsr op_MOVEQ
02:000003A6 610027E2        	   124: 	bsr op_DIVU
                            	   125: *	bsr op_DIVS
02:000003AA 61002882        	   126: 	bsr op_OR
02:000003AE 61002968        	   127: 	bsr op_AND
02:000003B2 61002A4E        	   128: 	bsr op_EOR
02:000003B6 61002AC0        	   129: 	bsr op_CMP
02:000003BA 61002B32        	   130: 	bsr op_CMPA
02:000003BE 61002B94        	   131: 	bsr op_CMPM
02:000003C2 61002C36        	   132: 	bsr op_ADD
02:000003C6 61002D1C        	   133: 	bsr op_SUB
02:000003CA 61002E02        	   134: 	bsr op_ADDA
02:000003CE 61002E4A        	   135: 	bsr op_SUBA
02:000003D2 61002E92        	   136: 	bsr op_ADDX	
02:000003D6 61002F9E        	   137: 	bsr op_SUBX
02:000003DA 610030AA        	   138: 	bsr op_MULU
02:000003DE 610030F2        	   139: 	bsr op_MULS
02:000003E2 6100313A        	   140: 	bsr op_EXG
02:000003E6 610031A4        	   141: 	bsr op_ROx
02:000003EA 610033D6        	   142: 	bsr op_ROXx
02:000003EE 61003608        	   143: 	bsr op_SHIFTS
02:000003F2 61003846        	   144: 	bsr op_SHIFTS2
                            	   145: 
02:000003F6 4E75            	   146: 	rts
                            	   147: 	bra ALL_DONE
                            	   148: 
                            	   149: * Loop here when all tests pass
                            	   150: *
                            	   151: 
02:000003F8 60FE            	   152: ALL_DONE: bra.s ALL_DONE
                            	   153: 
02:000003FA 263C33333333    	   154: BSR_FAR1:       move.l #$33333333,d3
02:00000400 4E75            	   155:                 rts
                            	   156: 
                            	   157: ;	moveq		#-1,d0
                            	   158: ;	move.l	d0,$FD0FFF00
                            	   159: ;do_nothing:
                            	   160: ;	bra			*		
                            	   161: 
                            	   162: 
                            	   163: * Exception Vector = 6   CHK Instruction
                            	   164: *
                            	   165: *	align	4
                            	   166: EXCEPTION_6:
02:00000402 2C3CEEEE0006    	   167: 	move.l #$EEEE0006,d6      * Set d6 to the exception vector
02:00000408 4E73            	   168: 	rte
                            	   169: 
                            	   170: * Exception Vector = 7   TRAPV Instruction
                            	   171: *
                            	   172: *	align	4
                            	   173: EXCEPTION_7:
02:0000040A 203C12345678    	   174: 	move.l #$12345678,d0      * Set d6 to the exception vector
02:00000410 4E73            	   175: 	rte
                            	   176: 
                            	   177: ;-----------------------------------------------------------
                            	   178: ;-----------------------------------------------------------
                            	   179: ; OPCODE : ORI_TO_CCR
                            	   180: ;-----------------------------------------------------------
                            	   181: ;-----------------------------------------------------------
                            	   182: op_ORI_TO_CCR:
                            	   183: 
02:00000412 003C00FF        	   184:     ori.b #$FF,CCR
02:00000416 6AFE            	   185:     bpl.s *                   ; branch if Z clear
02:00000418 66FE            	   186:     bne.s *                   ; branch if N clear
02:0000041A 68FE            	   187:     bvc.s *                   ; branch if V clear
02:0000041C 64FE            	   188:     bcc.s *                   ; branch if C clear
                            	   189: 
02:0000041E 44FC0000        	   190:     move #$00,CCR
02:00000422 003C0000        	   191:     ori.b #$00,CCR
02:00000426 67FE            	   192:     beq.s *                   ; branch if Z set
02:00000428 6BFE            	   193:     bmi.s *                   ; branch if N set
02:0000042A 69FE            	   194:     bvs.s *                   ; branch if V set
02:0000042C 65FE            	   195:     bcs.s *                   ; branch if C set
                            	   196: 
02:0000042E 46FC2700        	   197:     move.w #$2700,SR          ; Put flags back to initial value
                            	   198: 
02:00000432 4E75            	   199:     rts
                            	   200: 
                            	   201: ;-----------------------------------------------------------
                            	   202: ;-----------------------------------------------------------
                            	   203: ; OPCODE : ORI_TO_SR
                            	   204: ;-----------------------------------------------------------
                            	   205: ;-----------------------------------------------------------
                            	   206: 
                            	   207: op_ORI_TO_SR:
                            	   208: 
02:00000434 007C2FFF        	   209:     ori.w #$2FFF,SR
02:00000438 6AFE            	   210:     bpl.s *                   * branch if Z clear
02:0000043A 66FE            	   211:     bne.s *                   * branch if N clear
02:0000043C 68FE            	   212:     bvc.s *                   * branch if V clear
02:0000043E 64FE            	   213:     bcc.s *                   * branch if C clear
                            	   214: 
02:00000440 46FC2000        	   215:     move.w #$2000,SR
02:00000444 007C0000        	   216:     ori.w #$0000,SR
02:00000448 67FE            	   217:     beq.s *                   * branch if Z set
02:0000044A 6BFE            	   218:     bmi.s *                   * branch if N set
02:0000044C 69FE            	   219:     bvs.s *                   * branch if V set
02:0000044E 65FE            	   220:     bcs.s *                   * branch if C set
                            	   221: 
02:00000450 46FC2700        	   222:     move.w #$2700,sr         * Put flags back to initial value
                            	   223: 
02:00000454 4E75            	   224:     rts
                            	   225: ; 
                            	   226: ;-----------------------------------------------------------
                            	   227: ;-----------------------------------------------------------
                            	   228: ; OPCODE : EORI_TO_CCR
                            	   229: ;-----------------------------------------------------------
                            	   230: ;-----------------------------------------------------------
                            	   231: op_EORI_TO_CCR:
                            	   232: 
02:00000456 44FC0000        	   233:     move #$00,CCR
02:0000045A 0A3C00FF        	   234:     eori.b #$FF,CCR
02:0000045E 6AFE            	   235:     bpl.s *                   ; branch if Z clear
02:00000460 66FE            	   236:     bne.s *                   ; branch if N clear
02:00000462 68FE            	   237:     bvc.s *                   ; branch if V clear
02:00000464 64FE            	   238:     bcc.s *                   ; branch if C clear
                            	   239: 
02:00000466 44FC0000        	   240:     move #$00,CCR
02:0000046A 0A3C0000        	   241:     eori.b #$00,CCR
02:0000046E 67FE            	   242:     beq.s *                   ; branch if Z set
02:00000470 6BFE            	   243:     bmi.s *                   ; branch if N set
02:00000472 69FE            	   244:     bvs.s *                   ; branch if V set
02:00000474 65FE            	   245:     bcs.s *                   ; branch if C set
                            	   246: 
02:00000476 46FC2700        	   247:     move.w #$2700,sr           ; Put flags back to initial value
                            	   248: 
02:0000047A 4E75            	   249:     rts
                            	   250: 
                            	   251: 
                            	   252: 
                            	   253: *-----------------------------------------------------------
                            	   254: *-----------------------------------------------------------
                            	   255: * OPCODE : EORI_TO_SR
                            	   256: *-----------------------------------------------------------
                            	   257: *-----------------------------------------------------------
                            	   258: op_EORI_TO_SR:
                            	   259: 
02:0000047C 46FC2000        	   260:     move.w #$2000,SR
02:00000480 0A7C0FFF        	   261:     eori.w #$0FFF,SR
02:00000484 6AFE            	   262:     bpl.s *                   * branch if Z clear
02:00000486 66FE            	   263:     bne.s *                   * branch if N clear
02:00000488 68FE            	   264:     bvc.s *                   * branch if V clear
02:0000048A 64FE            	   265:     bcc.s *                   * branch if C clear
                            	   266: 
02:0000048C 46FC2000        	   267:     move.w #$2000,SR
02:00000490 0A7C0000        	   268:     eori.w #$0000,SR
02:00000494 67FE            	   269:     beq.s *                   * branch if Z set
02:00000496 6BFE            	   270:     bmi.s *                   * branch if N set
02:00000498 69FE            	   271:     bvs.s *                   * branch if V set
02:0000049A 65FE            	   272:     bcs.s *                   * branch if C set
                            	   273: 
02:0000049C 46FC2700        	   274:     move.w #$2700,sr          * Put flags back to initial value
                            	   275: 
02:000004A0 4E75            	   276:     rts
                            	   277: 
                            	   278: 
                            	   279: 
                            	   280: *-----------------------------------------------------------
                            	   281: *-----------------------------------------------------------
                            	   282: * OPCODE : ANDI_TO_CCR
                            	   283: *-----------------------------------------------------------
                            	   284: *-----------------------------------------------------------
                            	   285: op_ANDI_TO_CCR:
                            	   286: 
02:000004A2 44FC00FF        	   287:     move #$FF,CCR
02:000004A6 023C00FF        	   288:     andi.b #$FF,CCR
02:000004AA 6AFE            	   289:     bpl.s *                   * branch if Z clear
02:000004AC 66FE            	   290:     bne.s *                   * branch if N clear
02:000004AE 68FE            	   291:     bvc.s *                   * branch if V clear
02:000004B0 64FE            	   292:     bcc.s *                   * branch if C clear
                            	   293: 
02:000004B2 44FC00FF        	   294:     move #$FF,CCR
02:000004B6 023C0000        	   295:     andi.b #$00,CCR
02:000004BA 67FE            	   296:     beq.s *                   * branch if Z set
02:000004BC 6BFE            	   297:     bmi.s *                   * branch if N set
02:000004BE 69FE            	   298:     bvs.s *                   * branch if V set
02:000004C0 65FE            	   299:     bcs.s *                   * branch if C set
                            	   300: 
02:000004C2 46FC2700        	   301:     move #$2700,SR           * Put flags back to initial value
                            	   302: 
02:000004C6 4E75            	   303:     rts
                            	   304: 
                            	   305: 
                            	   306: 
                            	   307: *-----------------------------------------------------------
                            	   308: *-----------------------------------------------------------
                            	   309: * OPCODE : ANDI_TO_SR
                            	   310: *-----------------------------------------------------------
                            	   311: *-----------------------------------------------------------
                            	   312: op_ANDI_TO_SR:
02:000004C8 46FC20FF        	   313:     move.w #$20FF,SR
02:000004CC 027CFFFF        	   314:     andi.w #$FFFF,SR
02:000004D0 6AFE            	   315:     bpl.s *                   * branch if Z clear
02:000004D2 66FE            	   316:     bne.s *                   * branch if N clear
02:000004D4 68FE            	   317:     bvc.s *                   * branch if V clear
02:000004D6 64FE            	   318:     bcc.s *                   * branch if C clear
                            	   319: 
02:000004D8 46FC20FF        	   320:     move.w #$20FF,SR
02:000004DC 027CFF00        	   321:     andi.w #$FF00,SR
02:000004E0 67FE            	   322:     beq.s *                   * branch if Z set
02:000004E2 6BFE            	   323:     bmi.s *                   * branch if N set
02:000004E4 69FE            	   324:     bvs.s *                   * branch if V set
02:000004E6 65FE            	   325:     bcs.s *                   * branch if C set
                            	   326: 
02:000004E8 46FC2700        	   327:     move.w #$2700,sr           * Put flags back to initial value
                            	   328: 
02:000004EC 4E75            	   329:     rts
                            	   330: 
                            	   331: 
                            	   332: *-----------------------------------------------------------
                            	   333: *-----------------------------------------------------------
                            	   334: * OPCODE : BTST
                            	   335: *-----------------------------------------------------------
                            	   336: *-----------------------------------------------------------
                            	   337: op_BTST:
                            	   338: 
                            	   339: *  Bit Number.s Static
                            	   340: 
                            	   341: *             EA = Dn  - LONG only
02:000004EE 203C80000001    	   342:             move.l #$80000001,d0      * populate test data
02:000004F4 08000000        	   343:             btst.l #0,d0
02:000004F8 67FE            	   344:             beq.s *               * branch if Z set
02:000004FA 08000001        	   345:             btst.l #1,d0              *
02:000004FE 66FE            	   346:             bne.s *               * branch if Z clear
02:00000500 0800001F        	   347:             btst.l #31,d0             *
02:00000504 67FE            	   348:             beq.s *               * branch if Z set
                            	   349: 
                            	   350: 
                            	   351: *             EA = (An)  - BYTE only
02:00000506 307C0100        	   352:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000050A 10BC0081        	   353:             move.b #$81,(a0)          * populate test data
02:0000050E 1210            	   354:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:00000510 08100000        	   355:             btst.b #0,(a0)
02:00000514 67FE            	   356:             beq.s *               * branch if Z set
02:00000516 08100001        	   357:             btst.b #1,(a0)            *
02:0000051A 66FE            	   358:             bne.s *               * branch if Z clear
02:0000051C 08100007        	   359:             btst.b #7,(a0)            *
02:00000520 67FE            	   360:             beq.s *               * branch if Z set
                            	   361: 
                            	   362: 
                            	   363: *             EA = (An)+  - BYTE only
02:00000522 307C0100        	   364:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000526 10FC0001        	   365:             move.b #$01,(a0)+         * populate test data
02:0000052A 10FC00FC        	   366:             move.b #$FC,(a0)+         * populate test data
02:0000052E 10FC0080        	   367:             move.b #$80,(a0)+         * populate test data
02:00000532 307C0100        	   368:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000536 08180000        	   369:             btst.b #0,(a0)+
02:0000053A 67FE            	   370:             beq.s *               * branch if Z set
02:0000053C 08180001        	   371:             btst.b #1,(a0)+           *
02:00000540 66FE            	   372:             bne.s *               * branch if Z clear
02:00000542 08180007        	   373:             btst.b #7,(a0)+           *
02:00000546 67FE            	   374:             beq.s *               * branch if Z set
                            	   375: 
                            	   376: 
                            	   377: *             EA = -(An)  - BYTE only
02:00000548 307C0100        	   378:             move.l #$00000100,a0      * point to memory to address
02:0000054C 10FC0080        	   379:             move.b #$80,(a0)+         * populate test data
02:00000550 10FC00FC        	   380:             move.b #$FC,(a0)+         * populate test data
02:00000554 10FC0001        	   381:             move.b #$01,(a0)+         * populate test data
02:00000558 307C0103        	   382:             move.l #$00000103,a0      * point to memory to address
02:0000055C 08200000        	   383:             btst.b #0,-(a0)
02:00000560 67FE            	   384:             beq.s *               * branch if Z set
02:00000562 08200001        	   385:             btst.b #1,-(a0)           *
02:00000566 66FE            	   386:             bne.s *               * branch if Z clear
02:00000568 08200007        	   387:             btst.b #7,-(a0)           *
02:0000056C 67FE            	   388:             beq.s *               * branch if Z set
                            	   389: 
                            	   390: 
                            	   391: *             EA = n(An)  - BYTE only
02:0000056E 307C0100        	   392:             move.l #$00000100,a0      * point to memory to address
02:00000572 10FC0001        	   393:             move.b #$01,(a0)+         * populate test data
02:00000576 10FC00FC        	   394:             move.b #$FC,(a0)+         * populate test data
02:0000057A 10FC0080        	   395:             move.b #$80,(a0)+         * populate test data
02:0000057E 307C0100        	   396:             move.l #$00000100,a0      * point to memory to address
02:00000582 08100000        	   397:             btst.b #0,0(a0)
02:00000586 67FE            	   398:             beq.s *               * branch if Z set
02:00000588 082800010001    	   399:             btst.b #1,1(a0)           *
02:0000058E 66FE            	   400:             bne.s *               * branch if Z clear
02:00000590 082800070002    	   401:             btst.b #7,2(a0)           *
02:00000596 67FE            	   402:             beq.s *               * branch if Z set
                            	   403: 
                            	   404: 
                            	   405: *             EA = n(An,R.W)  - BYTE only
02:00000598 307C0100        	   406:             move.l #$00000100,a0      * point to memory to address
02:0000059C 93C9            	   407:             move.l #$00000000,a1      * point to memory to address
02:0000059E 347C0001        	   408:             move.l #$00000001,a2      * point to memory to address
02:000005A2 7000            	   409:             moveq  #$00000000,d0      * point to memory to address
02:000005A4 7201            	   410:             moveq  #$00000001,d1      * point to memory to address
02:000005A6 083000000000    	   411:             btst.b #0,0(a0,d0.w)
02:000005AC 67FE            	   412:             beq.s *               * branch if Z set
02:000005AE 083000011000    	   413:             btst.b #1,0(a0,d1.w)      *
02:000005B4 66FE            	   414:             bne.s *               * branch if Z clear
02:000005B6 083000071001    	   415:             btst.b #7,1(a0,d1.w)      *
02:000005BC 67FE            	   416:             beq.s *               * branch if Z set
                            	   417: *             EA = n(An,R.L)  - BYTE only
02:000005BE 083000000800    	   418:             btst.b #0,0(a0,d0.l)
02:000005C4 67FE            	   419:             beq.s *               * branch if Z set
02:000005C6 083000011800    	   420:             btst.b #1,0(a0,d1.l)      *
02:000005CC 66FE            	   421:             bne.s *               * branch if Z clear
02:000005CE 083000071801    	   422:             btst.b #7,1(a0,d1.l)      *
02:000005D4 67FE            	   423:             beq.s *               * branch if Z set
                            	   424: *             EA = n(An,A.W)  - BYTE only
02:000005D6 083000009000    	   425:             btst.b #0,0(a0,a1.w)
02:000005DC 67FE            	   426:             beq.s *               * branch if Z set
02:000005DE 08300001A000    	   427:             btst.b #1,0(a0,a2.w)      *
02:000005E4 66FE            	   428:             bne.s *               * branch if Z clear
02:000005E6 08300007A001    	   429:             btst.b #7,1(a0,a2.w)      *
02:000005EC 67FE            	   430:             beq.s *               * branch if Z set
                            	   431: *             EA = n(An,A.L)  - BYTE only
02:000005EE 083000009800    	   432:             btst.b #0,0(a0,a1.l)
02:000005F4 67FE            	   433:             beq.s *               * branch if Z set
02:000005F6 08300001A800    	   434:             btst.b #1,0(a0,a2.l)      *
02:000005FC 66FE            	   435:             bne.s *               * branch if Z clear
02:000005FE 08300007A801    	   436:             btst.b #7,1(a0,a2.l)      *
02:00000604 67FE            	   437:             beq.s *               * branch if Z set
                            	   438: 
                            	   439: 
                            	   440: *             EA = x.W  - BYTE only
02:00000606 083800000100    	   441:             btst.b #0,$0100
02:0000060C 67FE            	   442:             beq.s *               * branch if Z set
02:0000060E 083800010101    	   443:             btst.b #1,$0101           *
02:00000614 66FE            	   444:             bne.s *               * branch if Z clear
02:00000616 083800070102    	   445:             btst.b #7,$0102           *
02:0000061C 67FE            	   446:             beq.s *               * branch if Z set
                            	   447: 
                            	   448: 
                            	   449: *             EA = x.L  - BYTE only
02:0000061E 207C0000F100    	   450:             move.l #$F100,a0      * point to memory to address 0x100
02:00000624 10FC0001        	   451:             move.b #$01,(a0)+         * populate test data
02:00000628 10FC00FC        	   452:             move.b #$FC,(a0)+         * populate test data
02:0000062C 10FC0080        	   453:             move.b #$80,(a0)+         * populate test data
02:00000630 083900000000F100	   454:             btst.b #0,$F100
02:00000638 67FE            	   455:             beq.s *               * branch if Z set
02:0000063A 083900010000F101	   456:             btst.b #1,$F101       *
02:00000642 66FE            	   457:             bne.s *               * branch if Z clear
02:00000644 083900070000F102	   458:             btst.b #7,$F102       *
02:0000064C 67FE            	   459:             beq.s *               * branch if Z set
                            	   460: 
                            	   461: 
                            	   462: *             EA = x(PC)  - BYTE only
02:0000064E 4BFAFE9E        	   463:             lea op_BTST(pc),a5
02:00000652 083A0000FE98    	   464:             btst.b #0,op_BTST(pc)
02:00000658 66FE            	   465:             bne.s *               * branch if Z clear
02:0000065A 083A0003001A    	   466:             btst.b #3,op_BTST0(pc)     *
02:00000660 67FE            	   467:             beq.s *               * branch if Z set
02:00000662 083A00060074    	   468:             btst.b #6,op_BTST12(pc)    *
02:00000668 67FE            	   469:             beq.s *               * branch if Z set
                            	   470: 
                            	   471: 
                            	   472: *             EA = n(PC,R.W)  - BYTE only
02:0000066A 307C0100        	   473:             move.l #$00000100,a0      * point to memory to address
02:0000066E 93C9            	   474:             move.l #$00000000,a1      * point to memory to address
02:00000670 347C0001        	   475:             move.l #$00000001,a2      * point to memory to address
02:00000674 7000            	   476:             moveq  #$00000000,d0      * point to memory to address
02:00000676 7201            	   477:             moveq  #$00000001,d1      * point to memory to address
                            	   478: 
02:00000678 083B000000FC    	   479: op_BTST0:   btst.b #0,op_BTST0(pc,d0.w)
02:0000067E 66FE            	   480:             bne.s *               * branch if Z clear
                            	   481: 
02:00000680 4BFB1002        	   482:             lea op_BTST1(pc,d1.w),a5
02:00000684 083B000110FC    	   483: op_BTST1:   btst.b #1,op_BTST1(pc,d1.w)      *
02:0000068A 67FE            	   484:             beq.s *               * branch if Z set
02:0000068C 083B000710FC    	   485: op_BTST2:   btst.b #7,op_BTST2(pc,d1.w)      *
02:00000692 66FE            	   486:             bne.s *               * branch if Z clear
                            	   487: *             EA = n(PC,R.L)  - BYTE only
02:00000694 083B000008FC    	   488: op_BTST3:   btst.b #0,op_BTST3(pc,d0.l)
02:0000069A 66FE            	   489:             bne.s *               * branch if Z clear
02:0000069C 083B000118FC    	   490: op_BTST4:   btst.b #1,op_BTST4(pc,d1.l)      *
02:000006A2 67FE            	   491:             beq.s *               * branch if Z set
02:000006A4 083B000718FC    	   492: op_BTST5:   btst.b #7,op_BTST5(pc,d1.l)      *
02:000006AA 66FE            	   493:             bne.s *               * branch if Z clear
                            	   494: *             EA = n(PC,A.W)  - BYTE only
02:000006AC 083B000090FC    	   495: op_BTST6    btst.b #0,op_BTST6(pc,a1.w)
02:000006B2 66FE            	   496:             bne.s *               * branch if Z clear
02:000006B4 083B0001A0FC    	   497: op_BTST7:   btst.b #1,op_BTST7(pc,a2.w)      *
02:000006BA 67FE            	   498:             beq.s *               * branch if Z set
02:000006BC 083B0007A0FC    	   499: op_BTST8:   btst.b #7,op_BTST8(pc,a2.w)      *
02:000006C2 66FE            	   500:             bne.s *               * branch if Z clear
                            	   501: *             EA = n(PC,A.L)  - BYTE only
02:000006C4 083B000098FC    	   502: op_BTST9:   btst.b #0,op_BTST9(pc,a1.l)
02:000006CA 66FE            	   503:             bne.s *               * branch if Z clear
02:000006CC 083B0001A8FC    	   504: op_BTST10:  btst.b #1,op_BTST10(pc,a2.l)      *
02:000006D2 67FE            	   505:             beq.s *               * branch if Z set
02:000006D4 083B0007A8FC    	   506: op_BTST11:  btst.b #7,op_BTST11(pc,a2.l)      *
02:000006DA 66FE            	   507: op_BTST12:  bne.s *               * branch if Z clear
                            	   508: 
                            	   509: 
                            	   510: 
                            	   511: * Bit Number.s Dynamic
                            	   512: 
                            	   513: *             EA = Dn  - LONG only
02:000006DC 203C80000001    	   514:             move.l #$80000001,d0      * populate test data
02:000006E2 7A00            	   515:             move.l #0,d5              * populate bit.s number to test
02:000006E4 7C01            	   516:             move.l #1,d6              * populate bit.s number to test
02:000006E6 7E1F            	   517:             move.l #31,d7              * populate bit.s number to test
                            	   518: 
02:000006E8 0B00            	   519:             btst.l d5,d0
02:000006EA 67FE            	   520:             beq.s *               * branch if Z set
02:000006EC 0D00            	   521:             btst.l d6,d0              *
02:000006EE 66FE            	   522:             bne.s *               * branch if Z clear
02:000006F0 0F00            	   523:             btst.l d7,d0             *
02:000006F2 67FE            	   524:             beq.s *               * branch if Z set
                            	   525: 
                            	   526: 
                            	   527: *             EA = (An)  - BYTE only
02:000006F4 7A00            	   528:             move.l #0,d5              * populate bit.s number to test
02:000006F6 7C01            	   529:             move.l #1,d6              * populate bit.s number to test
02:000006F8 7E07            	   530:             move.l #7,d7              * populate bit.s number to test
02:000006FA 307C0100        	   531:             move.l #$00000100,a0      * point to memory to address 0x100
02:000006FE 10BC0081        	   532:             move.b #$81,(a0)          * populate test data
02:00000702 1210            	   533:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:00000704 0B10            	   534:             btst.b d5,(a0)
02:00000706 67FE            	   535:             beq.s *               * branch if Z set
02:00000708 0D10            	   536:             btst.b d6,(a0)            *
02:0000070A 66FE            	   537:             bne.s *               * branch if Z clear
02:0000070C 0F10            	   538:             btst.b d7,(a0)            *
02:0000070E 67FE            	   539:             beq.s *               * branch if Z set
                            	   540: 
                            	   541: * ---
                            	   542: 
                            	   543: 
                            	   544: *             EA = (An)+  - BYTE only
02:00000710 307C0100        	   545:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000714 10FC0001        	   546:             move.b #$01,(a0)+         * populate test data
02:00000718 10FC00FC        	   547:             move.b #$FC,(a0)+         * populate test data
02:0000071C 10FC0080        	   548:             move.b #$80,(a0)+         * populate test data
02:00000720 307C0100        	   549:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000724 0B18            	   550:             btst.b d5,(a0)+
02:00000726 67FE            	   551:             beq.s *               * branch if Z set
02:00000728 0D18            	   552:             btst.b d6,(a0)+           *
02:0000072A 66FE            	   553:             bne.s *               * branch if Z clear
02:0000072C 0F18            	   554:             btst.b d7,(a0)+           *
02:0000072E 67FE            	   555:             beq.s *               * branch if Z set
                            	   556: 
                            	   557: 
                            	   558: *             EA = -(An)  - BYTE only
02:00000730 307C0100        	   559:             move.l #$00000100,a0      * point to memory to address
02:00000734 10FC0080        	   560:             move.b #$80,(a0)+         * populate test data
02:00000738 10FC00FC        	   561:             move.b #$FC,(a0)+         * populate test data
02:0000073C 10FC0001        	   562:             move.b #$01,(a0)+         * populate test data
02:00000740 307C0103        	   563:             move.l #$00000103,a0      * point to memory to address
02:00000744 0B20            	   564:             btst.b d5,-(a0)
02:00000746 67FE            	   565:             beq.s *               * branch if Z set
02:00000748 0D20            	   566:             btst.b d6,-(a0)           *
02:0000074A 66FE            	   567:             bne.s *               * branch if Z clear
02:0000074C 0F20            	   568:             btst.b d7,-(a0)           *
02:0000074E 67FE            	   569:             beq.s *               * branch if Z set
                            	   570: 
                            	   571: 
                            	   572: *             EA = n(An)  - BYTE only
02:00000750 307C0100        	   573:             move.l #$00000100,a0      * point to memory to address
02:00000754 10FC0001        	   574:             move.b #$01,(a0)+         * populate test data
02:00000758 10FC00FC        	   575:             move.b #$FC,(a0)+         * populate test data
02:0000075C 10FC0080        	   576:             move.b #$80,(a0)+         * populate test data
02:00000760 307C0100        	   577:             move.l #$00000100,a0      * point to memory to address
02:00000764 0B10            	   578:             btst.b d5,0(a0)
02:00000766 67FE            	   579:             beq.s *               * branch if Z set
02:00000768 0D280001        	   580:             btst.b d6,1(a0)           *
02:0000076C 66FE            	   581:             bne.s *               * branch if Z clear
02:0000076E 0F280002        	   582:             btst.b d7,2(a0)           *
02:00000772 67FE            	   583:             beq.s *               * branch if Z set
                            	   584: 
                            	   585: 
                            	   586: *             EA = n(An,R.W)  - BYTE only
02:00000774 307C0100        	   587:             move.l #$00000100,a0      * point to memory to address
02:00000778 93C9            	   588:             move.l #$00000000,a1      * point to memory to address
02:0000077A 347C0001        	   589:             move.l #$00000001,a2      * point to memory to address
02:0000077E 7000            	   590:             moveq  #$00000000,d0      * point to memory to address
02:00000780 7201            	   591:             moveq  #$00000001,d1      * point to memory to address
02:00000782 0B300000        	   592:             btst.b d5,0(a0,d0.w)
02:00000786 67FE            	   593:             beq.s *               * branch if Z set
02:00000788 0D301000        	   594:             btst.b d6,0(a0,d1.w)      *
02:0000078C 66FE            	   595:             bne.s *               * branch if Z clear
02:0000078E 0F301001        	   596:             btst.b d7,1(a0,d1.w)      *
02:00000792 67FE            	   597:             beq.s *               * branch if Z set
                            	   598: *             EA = n(An,R.L)  - BYTE only
02:00000794 0B300800        	   599:             btst.b d5,0(a0,d0.l)
02:00000798 67FE            	   600:             beq.s *               * branch if Z set
02:0000079A 0D301800        	   601:             btst.b d6,0(a0,d1.l)      *
02:0000079E 66FE            	   602:             bne.s *               * branch if Z clear
02:000007A0 0F301801        	   603:             btst.b d7,1(a0,d1.l)      *
02:000007A4 67FE            	   604:             beq.s *               * branch if Z set
                            	   605: *             EA = n(An,A.W)  - BYTE only
02:000007A6 0B309000        	   606:             btst.b d5,0(a0,a1.w)
02:000007AA 67FE            	   607:             beq.s *               * branch if Z set
02:000007AC 0D30A000        	   608:             btst.b d6,0(a0,a2.w)      *
02:000007B0 66FE            	   609:             bne.s *               * branch if Z clear
02:000007B2 0F30A001        	   610:             btst.b d7,1(a0,a2.w)      *
02:000007B6 67FE            	   611:             beq.s *               * branch if Z set
                            	   612: *             EA = n(An,A.L)  - BYTE only
02:000007B8 0B309800        	   613:             btst.b d5,0(a0,a1.l)
02:000007BC 67FE            	   614:             beq.s *               * branch if Z set
02:000007BE 0D30A800        	   615:             btst.b d6,0(a0,a2.l)      *
02:000007C2 66FE            	   616:             bne.s *               * branch if Z clear
02:000007C4 0F30A801        	   617:             btst.b d7,1(a0,a2.l)      *
02:000007C8 67FE            	   618:             beq.s *               * branch if Z set
                            	   619: 
                            	   620: 
                            	   621: *             EA = x.W  - BYTE only
02:000007CA 0B380100        	   622:             btst.b d5,$0100
02:000007CE 67FE            	   623:             beq.s *               * branch if Z set
02:000007D0 0D380101        	   624:             btst.b d6,$0101           *
02:000007D4 66FE            	   625:             bne.s *               * branch if Z clear
02:000007D6 0F380102        	   626:             btst.b d7,$0102           *
02:000007DA 67FE            	   627:             beq.s *               * branch if Z set
                            	   628: 
                            	   629: 
                            	   630: *             EA = x.L  - BYTE only
02:000007DC 207C0000F100    	   631:             move.l #$F100,a0      * point to memory to address 0x100
02:000007E2 10FC0001        	   632:             move.b #$01,(a0)+         * populate test data
02:000007E6 10FC00FC        	   633:             move.b #$FC,(a0)+         * populate test data
02:000007EA 10FC0080        	   634:             move.b #$80,(a0)+         * populate test data
02:000007EE 0B390000F100    	   635:             btst.b d5,$F100
02:000007F4 67FE            	   636:             beq.s *               * branch if Z set
02:000007F6 0D390000F101    	   637:             btst.b d6,$F101       *
02:000007FC 66FE            	   638:             bne.s *               * branch if Z clear
02:000007FE 0F390000F102    	   639:             btst.b d7,$F102       *
02:00000804 67FE            	   640:             beq.s *               * branch if Z set
                            	   641: 
                            	   642: 
                            	   643: *             EA = x(PC)  - BYTE only
02:00000806 7C03            	   644:             move.l #3,d6              * populate bit.s number to test
02:00000808 7E06            	   645:             move.l #6,d7              * populate bit.s number to test
02:0000080A 4BFAFCE2        	   646:             lea op_BTST(pc),a5
02:0000080E 0B3AFCDE        	   647:             btst.b d5,op_BTST(pc)
02:00000812 66FE            	   648:             bne.s *               * branch if Z clear
02:00000814 0D3AFE62        	   649:             btst.b d6,op_BTST0(pc)     *
02:00000818 67FE            	   650:             beq.s *               * branch if Z set
02:0000081A 0F3AFEBE        	   651:             btst.b d7,op_BTST12(pc)    *
02:0000081E 67FE            	   652:             beq.s *               * branch if Z set
                            	   653: 
                            	   654: 
                            	   655: *             EA = n(PC,R.W)  - BYTE only
02:00000820 307C0100        	   656:             move.l #$00000100,a0      * point to memory to address
02:00000824 93C9            	   657:             move.l #$00000000,a1      * point to memory to address
02:00000826 347C0001        	   658:             move.l #$00000001,a2      * point to memory to address
02:0000082A 7000            	   659:             moveq  #$00000000,d0      * point to memory to address
02:0000082C 7201            	   660:             moveq  #$00000001,d1      * point to memory to address
02:0000082E 7C01            	   661:             move.l #1,d6              * populate bit.s number to test
02:00000830 7E07            	   662:             move.l #7,d7              * populate bit.s number to test
                            	   663: 
02:00000832 0B3B00FE        	   664: op_BTST20:  btst.b d5,op_BTST20(pc,d0.w)
02:00000836 67FE            	   665:             beq.s *               * branch if Z set
02:00000838 4BFB1002        	   666:             lea op_BTST21(pc,d1.w),a5
02:0000083C 0D3B10FE        	   667: op_BTST21:  btst.b d6,op_BTST21(pc,d1.w)      *
02:00000840 67FE            	   668:             beq.s *               * branch if Z set
02:00000842 0F3B10FE        	   669: op_BTST22:  btst.b d7,op_BTST22(pc,d1.w)      *
02:00000846 66FE            	   670:             bne.s *               * branch if Z clear
                            	   671: *             EA = n(PC,R.L)  - BYTE only
02:00000848 0B3B08FE        	   672: op_BTST23:  btst.b d5,op_BTST23(pc,d0.l)
02:0000084C 67FE            	   673:             beq.s *               * branch if Z set
02:0000084E 0D3B18FE        	   674: op_BTST24: btst.b d6,op_BTST24(pc,d1.l)      *
02:00000852 67FE            	   675:             beq.s *               * branch if Z set
02:00000854 0F3B18FE        	   676: op_BTST25  btst.b d7,op_BTST25(pc,d1.l)      *
02:00000858 66FE            	   677:             bne.s *               * branch if Z clear
                            	   678: *             EA = n(PC,A.W)  - BYTE only
02:0000085A 0B3B90FE        	   679: op_BTST26   btst.b d5,op_BTST26(pc,a1.w)
02:0000085E 67FE            	   680:             beq.s *               * branch if Z set
02:00000860 0D3BA0FE        	   681: op_BTST27:  btst.b d6,op_BTST27(pc,a2.w)      *
02:00000864 67FE            	   682:             beq.s *               * branch if Z set
02:00000866 0F3BA0FE        	   683: op_BTST28:  btst.b d7,op_BTST28(pc,a2.w)      *
02:0000086A 66FE            	   684:             bne.s *               * branch if Z clear
                            	   685: *             EA = n(PC,A.L)  - BYTE only
02:0000086C 0B3B98FE        	   686: op_BTST29:  btst.b d5,op_BTST29(pc,a1.l)
02:00000870 67FE            	   687:             beq.s *               * branch if Z set
02:00000872 0D3BA8FE        	   688: op_BTST30:  btst.b d6,op_BTST30(pc,a2.l)      *
02:00000876 67FE            	   689:             beq.s *               * branch if Z set
02:00000878 0F3BA8FE        	   690: op_BTST31:  btst.b d7,op_BTST31(pc,a2.l)      *
02:0000087C 66FE            	   691: op_BTST32:  bne.s *               * branch if Z clear
                            	   692: 
                            	   693: *             EA = #x  - BYTE only
                            	   694: 
02:0000087E 7A00            	   695:             move.l #0,d5              * populate bit.s number to test
02:00000880 7C03            	   696:             move.l #3,d6              * populate bit.s number to test
02:00000882 7E07            	   697:             move.l #7,d7              * populate bit.s number to test
                            	   698: 
02:00000884 0B3C0088        	   699:             btst.b d5,#$88
02:00000888 66FE            	   700:             bne.s *               * branch if Z clear
02:0000088A 0D3C0088        	   701:             btst.b d6,#$88
02:0000088E 67FE            	   702:             beq.s *               * branch if Z set
02:00000890 0F3C0088        	   703:             btst.b d7,#$88
02:00000894 67FE            	   704:             beq.s *               * branch if Z set
                            	   705: 
                            	   706: 
02:00000896 4E75            	   707:     rts
                            	   708: 
                            	   709: *-----------------------------------------------------------
                            	   710: *-----------------------------------------------------------
                            	   711: * OPCODE : BCHG
                            	   712: *-----------------------------------------------------------
                            	   713: *-----------------------------------------------------------
                            	   714: op_BCHG:
                            	   715: 
                            	   716: 
                            	   717: *  Bit Number.s Static
                            	   718: 
                            	   719: *             EA = Dn  - LONG only
02:00000898 203C80000001    	   720:             move.l #$80000001,d0      * populate test data
02:0000089E 08400000        	   721:             bchg.l #0,d0
02:000008A2 67FE            	   722:             beq.s *               * branch if Z set
02:000008A4 08400001        	   723:             bchg.l #1,d0              *
02:000008A8 66FE            	   724:             bne.s *               * branch if Z clear
02:000008AA 0840001F        	   725:             bchg.l #31,d0             *
02:000008AE 67FE            	   726:             beq.s *               * branch if Z set
02:000008B0 0C8000000002    	   727:             cmpi.l #$00000002,d0
02:000008B6 66FE            	   728:             bne.s *               * branch if Z clear
                            	   729: 
                            	   730: 
                            	   731: *             EA = (An)  - BYTE only
02:000008B8 307C0100        	   732:             move.l #$00000100,a0      * point to memory to address 0x100
02:000008BC 10BC0081        	   733:             move.b #$81,(a0)          * populate test data
02:000008C0 1210            	   734:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:000008C2 08500000        	   735:             bchg.b #0,(a0)
02:000008C6 67FE            	   736:             beq.s *               * branch if Z set
02:000008C8 08500001        	   737:             bchg.b #1,(a0)            *
02:000008CC 66FE            	   738:             bne.s *               * branch if Z clear
02:000008CE 08500007        	   739:             bchg.b #7,(a0)            *
02:000008D2 67FE            	   740:             beq.s *               * branch if Z set
02:000008D4 0C100002        	   741:             cmpi.b #$02,(a0)
02:000008D8 66FE            	   742:             bne.s *               * branch if Z clear
                            	   743: 
                            	   744: *             EA = (An)+  - BYTE only
02:000008DA 307C0100        	   745:             move.l #$00000100,a0      * point to memory to address 0x100
02:000008DE 10FC0001        	   746:             move.b #$01,(a0)+         * populate test data
02:000008E2 10FC00FC        	   747:             move.b #$FC,(a0)+         * populate test data
02:000008E6 10FC0080        	   748:             move.b #$80,(a0)+         * populate test data
02:000008EA 307C0100        	   749:             move.l #$00000100,a0      * point to memory to address 0x100
02:000008EE 08580000        	   750:             bchg.b #0,(a0)+
02:000008F2 67FE            	   751:             beq.s *               * branch if Z set
02:000008F4 08580001        	   752:             bchg.b #1,(a0)+           *
02:000008F8 66FE            	   753:             bne.s *               * branch if Z clear
02:000008FA 08580007        	   754:             bchg.b #7,(a0)+           *
02:000008FE 67FE            	   755:             beq.s *               * branch if Z set
02:00000900 307C0100        	   756:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000904 4A18            	   757:             cmpi.b #$00,(a0)+
02:00000906 66FE            	   758:             bne.s *               * branch if Z clear
02:00000908 0C1800FE        	   759:             cmpi.b #$FE,(a0)+
02:0000090C 66FE            	   760:             bne.s *               * branch if Z clear
02:0000090E 4A18            	   761:             cmpi.b #$00,(a0)+
02:00000910 66FE            	   762:             bne.s *               * branch if Z clear
                            	   763: 
                            	   764: *             EA = -(An)  - BYTE only
02:00000912 307C0100        	   765:             move.l #$00000100,a0      * point to memory to address
02:00000916 10FC0080        	   766:             move.b #$80,(a0)+         * populate test data
02:0000091A 10FC00FC        	   767:             move.b #$FC,(a0)+         * populate test data
02:0000091E 10FC0001        	   768:             move.b #$01,(a0)+         * populate test data
02:00000922 307C0103        	   769:             move.l #$00000103,a0      * point to memory to address
02:00000926 08600000        	   770:             bchg.b #0,-(a0)
02:0000092A 67FE            	   771:             beq.s *               * branch if Z set
02:0000092C 08600001        	   772:             bchg.b #1,-(a0)           *
02:00000930 66FE            	   773:             bne.s *               * branch if Z clear
02:00000932 08600007        	   774:             bchg.b #7,-(a0)           *
02:00000936 67FE            	   775:             beq.s *               * branch if Z set
02:00000938 307C0103        	   776:             move.l #$00000103,a0      * point to memory to address 0x100
02:0000093C 4A20            	   777:             cmpi.b #$00,-(a0)
02:0000093E 66FE            	   778:             bne.s *               * branch if Z clear
02:00000940 0C2000FE        	   779:             cmpi.b #$FE,-(a0)
02:00000944 66FE            	   780:             bne.s *               * branch if Z clear
02:00000946 4A20            	   781:             cmpi.b #$00,-(a0)
02:00000948 66FE            	   782:             bne.s *               * branch if Z clear
                            	   783: 
                            	   784: 
                            	   785: *             EA = n(An)  - BYTE only
02:0000094A 307C0100        	   786:             move.l #$00000100,a0      * point to memory to address
02:0000094E 10FC0001        	   787:             move.b #$01,(a0)+         * populate test data
02:00000952 10FC00FC        	   788:             move.b #$FC,(a0)+         * populate test data
02:00000956 10FC0080        	   789:             move.b #$80,(a0)+         * populate test data
02:0000095A 307C0100        	   790:             move.l #$00000100,a0      * point to memory to address
02:0000095E 08500000        	   791:             bchg.b #0,0(a0)
02:00000962 67FE            	   792:             beq.s *               * branch if Z set
02:00000964 086800010001    	   793:             bchg.b #1,1(a0)           *
02:0000096A 66FE            	   794:             bne.s *               * branch if Z clear
02:0000096C 086800070002    	   795:             bchg.b #7,2(a0)           *
02:00000972 67FE            	   796:             beq.s *               * branch if Z set
02:00000974 307C0100        	   797:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000978 4A18            	   798:             cmpi.b #$00,(a0)+
02:0000097A 66FE            	   799:             bne.s *               * branch if Z clear
02:0000097C 0C1800FE        	   800:             cmpi.b #$FE,(a0)+
02:00000980 66FE            	   801:             bne.s *               * branch if Z clear
02:00000982 4A18            	   802:             cmpi.b #$00,(a0)+
02:00000984 66FE            	   803:             bne.s *               * branch if Z clear
                            	   804: 
                            	   805: 
                            	   806: *             EA = n(An,D.W)  - BYTE only
02:00000986 307C0100        	   807:             move.l #$00000100,a0      * point to memory to address
02:0000098A 93C9            	   808:             move.l #$00000000,a1      * point to memory to address
02:0000098C 347C0001        	   809:             move.l #$00000001,a2      * point to memory to address
02:00000990 7000            	   810:             moveq  #$00000000,d0      * point to memory to address
02:00000992 7201            	   811:             moveq  #$00000001,d1      * point to memory to address
02:00000994 087000000000    	   812:             bchg.b #0,0(a0,d0.w)
02:0000099A 66FE            	   813:             bne.s *               * branch if Z clear
02:0000099C 087000011000    	   814:             bchg.b #1,0(a0,d1.w)      *
02:000009A2 67FE            	   815:             beq.s *               * branch if Z set
02:000009A4 087000071001    	   816:             bchg.b #7,1(a0,d1.w)      *
02:000009AA 66FE            	   817:             bne.s *               * branch if Z clear
                            	   818: *             EA = n(An,D.L)  - BYTE only
02:000009AC 087000000800    	   819:             bchg.b #0,0(a0,d0.l)
02:000009B2 67FE            	   820:             beq.s *               * branch if Z set
02:000009B4 087000011800    	   821:             bchg.b #1,0(a0,d1.l)      *
02:000009BA 66FE            	   822:             bne.s *               * branch if Z clear
02:000009BC 087000071801    	   823:             bchg.b #7,1(a0,d1.l)      *
02:000009C2 67FE            	   824:             beq.s *               * branch if Z set
                            	   825: *             EA = n(An,A.W)  - BYTE only
02:000009C4 087000009000    	   826:             bchg.b #0,0(a0,a1.w)
02:000009CA 66FE            	   827:             bne.s *               * branch if Z clear
02:000009CC 08700001A000    	   828:             bchg.b #1,0(a0,a2.w)      *
02:000009D2 67FE            	   829:             beq.s *               * branch if Z set
02:000009D4 08700007A001    	   830:             bchg.b #7,1(a0,a2.w)      *
02:000009DA 66FE            	   831:             bne.s *               * branch if Z clear
                            	   832: *             EA = n(An,A.L)  - BYTE only
02:000009DC 087000009800    	   833:             bchg.b #0,0(a0,a1.l)
02:000009E2 67FE            	   834:             beq.s *               * branch if Z set
02:000009E4 08700001A800    	   835:             bchg.b #1,0(a0,a2.l)      *
02:000009EA 66FE            	   836:             bne.s *               * branch if Z clear
02:000009EC 08700007A801    	   837:             bchg.b #7,1(a0,a2.l)      *
02:000009F2 67FE            	   838:             beq.s *               * branch if Z set
02:000009F4 307C0100        	   839:             move.l #$00000100,a0      * point to memory to address 0x100
02:000009F8 4A18            	   840:             cmpi.b #$00,(a0)+
02:000009FA 66FE            	   841:             bne.s *               * branch if Z clear
02:000009FC 0C1800FE        	   842:             cmpi.b #$FE,(a0)+
02:00000A00 66FE            	   843:             bne.s *               * branch if Z clear
02:00000A02 4A18            	   844:             cmpi.b #$00,(a0)+
02:00000A04 66FE            	   845:             bne.s *               * branch if Z clear
                            	   846: 
                            	   847: 
                            	   848: *             EA = x.W  - BYTE only
02:00000A06 087800000100    	   849:             bchg.b #0,$0100
02:00000A0C 66FE            	   850:             bne.s *               * branch if Z clear
02:00000A0E 087800010101    	   851:             bchg.b #1,$0101           *
02:00000A14 67FE            	   852:             beq.s *               * branch if Z set
02:00000A16 087800070102    	   853:             bchg.b #7,$0102           *
02:00000A1C 66FE            	   854:             bne.s *               * branch if Z clear
02:00000A1E 307C0100        	   855:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A22 0C180001        	   856:             cmpi.b #$01,(a0)+
02:00000A26 66FE            	   857:             bne.s *               * branch if Z clear
02:00000A28 0C1800FC        	   858:             cmpi.b #$FC,(a0)+
02:00000A2C 66FE            	   859:             bne.s *               * branch if Z clear
02:00000A2E 0C180080        	   860:             cmpi.b #$80,(a0)+
02:00000A32 66FE            	   861:             bne.s *               * branch if Z clear
                            	   862: 
                            	   863: *             EA = x.L  - BYTE only
02:00000A34 207C0000F100    	   864:             move.l #$F100,a0      * point to memory to address 0x100
02:00000A3A 10FC0001        	   865:             move.b #$01,(a0)+         * populate test data
02:00000A3E 10FC00FC        	   866:             move.b #$FC,(a0)+         * populate test data
02:00000A42 10FC0080        	   867:             move.b #$80,(a0)+         * populate test data
02:00000A46 087900000000F100	   868:             bchg.b #0,$F100
02:00000A4E 67FE            	   869:             beq.s *               * branch if Z set
02:00000A50 087900010000F101	   870:             bchg.b #1,$F101       *
02:00000A58 66FE            	   871:             bne.s *               * branch if Z clear
02:00000A5A 087900070000F102	   872:             bchg.b #7,$F102       *
02:00000A62 67FE            	   873:             beq.s *               * branch if Z set
02:00000A64 307C0100        	   874:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A68 0C180001        	   875:             cmpi.b #$01,(a0)+
02:00000A6C 66FE            	   876:             bne.s *               * branch if Z clear
02:00000A6E 0C1800FC        	   877:             cmpi.b #$FC,(a0)+
02:00000A72 66FE            	   878:             bne.s *               * branch if Z clear
02:00000A74 0C180080        	   879:             cmpi.b #$80,(a0)+
02:00000A78 66FE            	   880:             bne.s *               * branch if Z clear
                            	   881: 
                            	   882: 
                            	   883: * Bit Number.s Dynamic
                            	   884: 
                            	   885: *             EA = Dn  - LONG only
02:00000A7A 203C80000001    	   886:             move.l #$80000001,d0      * populate test data
02:00000A80 7A00            	   887:             move.l #0,d5              * populate bit.s number to test
02:00000A82 7C01            	   888:             move.l #1,d6              * populate bit.s number to test
02:00000A84 7E1F            	   889:             move.l #31,d7              * populate bit.s number to test
                            	   890: 
02:00000A86 0B40            	   891:             bchg.l d5,d0
02:00000A88 67FE            	   892:             beq.s *               * branch if Z set
02:00000A8A 0D40            	   893:             bchg.l d6,d0              *
02:00000A8C 66FE            	   894:             bne.s *               * branch if Z clear
02:00000A8E 0F40            	   895:             bchg.l d7,d0             *
02:00000A90 67FE            	   896:             beq.s *               * branch if Z set
02:00000A92 0C8000000002    	   897:             cmpi.l #$00000002,d0
02:00000A98 66FE            	   898:             bne.s *               * branch if Z clear
                            	   899: 
                            	   900: 
                            	   901: *             EA = (An)  - BYTE only
02:00000A9A 7A00            	   902:             move.l #0,d5              * populate bit.s number to test
02:00000A9C 7C01            	   903:             move.l #1,d6              * populate bit.s number to test
02:00000A9E 7E07            	   904:             move.l #7,d7              * populate bit.s number to test
02:00000AA0 307C0100        	   905:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000AA4 10BC0081        	   906:             move.b #$81,(a0)          * populate test data
02:00000AA8 1210            	   907:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:00000AAA 0B50            	   908:             bchg.b d5,(a0)
02:00000AAC 67FE            	   909:             beq.s *               * branch if Z set
02:00000AAE 0D50            	   910:             bchg.b d6,(a0)            *
02:00000AB0 66FE            	   911:             bne.s *               * branch if Z clear
02:00000AB2 0F50            	   912:             bchg.b d7,(a0)            *
02:00000AB4 67FE            	   913:             beq.s *               * branch if Z set
02:00000AB6 0C100002        	   914:             cmpi.b #$02,(a0)
02:00000ABA 66FE            	   915:             bne.s *               * branch if Z clear
                            	   916: 
                            	   917: 
                            	   918: *             EA = (An)+  - BYTE only
02:00000ABC 307C0100        	   919:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000AC0 10FC0001        	   920:             move.b #$01,(a0)+         * populate test data
02:00000AC4 10FC00FC        	   921:             move.b #$FC,(a0)+         * populate test data
02:00000AC8 10FC0080        	   922:             move.b #$80,(a0)+         * populate test data
02:00000ACC 307C0100        	   923:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000AD0 0B58            	   924:             bchg.b d5,(a0)+
02:00000AD2 67FE            	   925:             beq.s *               * branch if Z set
02:00000AD4 0D58            	   926:             bchg.b d6,(a0)+           *
02:00000AD6 66FE            	   927:             bne.s *               * branch if Z clear
02:00000AD8 0F58            	   928:             bchg.b d7,(a0)+           *
02:00000ADA 67FE            	   929:             beq.s *               * branch if Z set
02:00000ADC 307C0100        	   930:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000AE0 4A18            	   931:             cmpi.b #$00,(a0)+
02:00000AE2 66FE            	   932:             bne.s *               * branch if Z clear
02:00000AE4 0C1800FE        	   933:             cmpi.b #$FE,(a0)+
02:00000AE8 66FE            	   934:             bne.s *               * branch if Z clear
02:00000AEA 4A18            	   935:             cmpi.b #$00,(a0)+
02:00000AEC 66FE            	   936:             bne.s *               * branch if Z clear
                            	   937: 
                            	   938: *             EA = -(An)  - BYTE only
02:00000AEE 307C0100        	   939:             move.l #$00000100,a0      * point to memory to address
02:00000AF2 10FC0080        	   940:             move.b #$80,(a0)+         * populate test data
02:00000AF6 10FC00FC        	   941:             move.b #$FC,(a0)+         * populate test data
02:00000AFA 10FC0001        	   942:             move.b #$01,(a0)+         * populate test data
02:00000AFE 307C0103        	   943:             move.l #$00000103,a0      * point to memory to address
02:00000B02 0B60            	   944:             bchg.b d5,-(a0)
02:00000B04 67FE            	   945:             beq.s *               * branch if Z set
02:00000B06 0D60            	   946:             bchg.b d6,-(a0)           *
02:00000B08 66FE            	   947:             bne.s *               * branch if Z clear
02:00000B0A 0F60            	   948:             bchg.b d7,-(a0)           *
02:00000B0C 67FE            	   949:             beq.s *               * branch if Z set
02:00000B0E 307C0103        	   950:             move.l #$00000103,a0      * point to memory to address 0x100
02:00000B12 4A20            	   951:             cmpi.b #$00,-(a0)
02:00000B14 66FE            	   952:             bne.s *               * branch if Z clear
02:00000B16 0C2000FE        	   953:             cmpi.b #$FE,-(a0)
02:00000B1A 66FE            	   954:             bne.s *               * branch if Z clear
02:00000B1C 4A20            	   955:             cmpi.b #$00,-(a0)
02:00000B1E 66FE            	   956:             bne.s *               * branch if Z clear
                            	   957: 
                            	   958: *             EA = n(An)  - BYTE only
02:00000B20 307C0100        	   959:             move.l #$00000100,a0      * point to memory to address
02:00000B24 10FC0001        	   960:             move.b #$01,(a0)+         * populate test data
02:00000B28 10FC00FC        	   961:             move.b #$FC,(a0)+         * populate test data
02:00000B2C 10FC0080        	   962:             move.b #$80,(a0)+         * populate test data
02:00000B30 307C0100        	   963:             move.l #$00000100,a0      * point to memory to address
02:00000B34 0B50            	   964:             bchg.b d5,0(a0)
02:00000B36 67FE            	   965:             beq.s *               * branch if Z set
02:00000B38 0D680001        	   966:             bchg.b d6,1(a0)           *
02:00000B3C 66FE            	   967:             bne.s *               * branch if Z clear
02:00000B3E 0F680002        	   968:             bchg.b d7,2(a0)           *
02:00000B42 67FE            	   969:             beq.s *               * branch if Z set
02:00000B44 307C0100        	   970:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000B48 4A18            	   971:             cmpi.b #$00,(a0)+
02:00000B4A 66FE            	   972:             bne.s *               * branch if Z clear
02:00000B4C 0C1800FE        	   973:             cmpi.b #$FE,(a0)+
02:00000B50 66FE            	   974:             bne.s *               * branch if Z clear
02:00000B52 4A18            	   975:             cmpi.b #$00,(a0)+
02:00000B54 66FE            	   976:             bne.s *               * branch if Z clear
                            	   977: 
                            	   978: *             EA = n(An,R.W)  - BYTE only
02:00000B56 307C0100        	   979:             move.l #$00000100,a0      * point to memory to address
02:00000B5A 93C9            	   980:             move.l #$00000000,a1      * point to memory to address
02:00000B5C 347C0001        	   981:             move.l #$00000001,a2      * point to memory to address
02:00000B60 7000            	   982:             moveq  #$00000000,d0      * point to memory to address
02:00000B62 7201            	   983:             moveq  #$00000001,d1      * point to memory to address
02:00000B64 0B700000        	   984:             bchg.b d5,0(a0,d0.w)
02:00000B68 66FE            	   985:             bne.s *               * branch if Z clear
02:00000B6A 0D701000        	   986:             bchg.b d6,0(a0,d1.w)      *
02:00000B6E 67FE            	   987:             beq.s *               * branch if Z set
02:00000B70 0F701001        	   988:             bchg.b d7,1(a0,d1.w)      *
02:00000B74 66FE            	   989:             bne.s *               * branch if Z clear
                            	   990: *             EA = n(An,R.L)  - BYTE only
02:00000B76 0B700800        	   991:             bchg.b d5,0(a0,d0.l)
02:00000B7A 67FE            	   992:             beq.s *               * branch if Z set
02:00000B7C 0D701800        	   993:             bchg.b d6,0(a0,d1.l)      *
02:00000B80 66FE            	   994:             bne.s *               * branch if Z clear
02:00000B82 0F701801        	   995:             bchg.b d7,1(a0,d1.l)      *
02:00000B86 67FE            	   996:             beq.s *               * branch if Z set
                            	   997: *             EA = n(An,A.W)  - BYTE only
02:00000B88 0B709000        	   998:             bchg.b d5,0(a0,a1.w)
02:00000B8C 66FE            	   999:             bne.s *               * branch if Z clear
02:00000B8E 0D70A000        	  1000:             bchg.b d6,0(a0,a2.w)      *
02:00000B92 67FE            	  1001:             beq.s *               * branch if Z set
02:00000B94 0F70A001        	  1002:             bchg.b d7,1(a0,a2.w)      *
02:00000B98 66FE            	  1003:             bne.s *               * branch if Z clear
                            	  1004: *             EA = n(An,A.L)  - BYTE only
02:00000B9A 0B709800        	  1005:             bchg.b d5,0(a0,a1.l)
02:00000B9E 67FE            	  1006:             beq.s *               * branch if Z set
02:00000BA0 0D70A800        	  1007:             bchg.b d6,0(a0,a2.l)      *
02:00000BA4 66FE            	  1008:             bne.s *               * branch if Z clear
02:00000BA6 0F70A801        	  1009:             bchg.b d7,1(a0,a2.l)      *
02:00000BAA 67FE            	  1010:             beq.s *               * branch if Z set
02:00000BAC 4A18            	  1011:             cmpi.b #$00,(a0)+
02:00000BAE 66FE            	  1012:             bne.s *               * branch if Z clear
                            	  1013: 
                            	  1014: *             EA = x.W  - BYTE only
02:00000BB0 0B780100        	  1015:             bchg.b d5,$0100
02:00000BB4 66FE            	  1016:             bne.s *               * branch if Z clear
02:00000BB6 0D780101        	  1017:             bchg.b d6,$0101           *
02:00000BBA 67FE            	  1018:             beq.s *               * branch if Z set
02:00000BBC 0F780102        	  1019:             bchg.b d7,$0102           *
02:00000BC0 66FE            	  1020:             bne.s *               * branch if Z clear
02:00000BC2 0C1800FC        	  1021:             cmpi.b #$FC,(a0)+
02:00000BC6 66FE            	  1022:             bne.s *               * branch if Z clear
                            	  1023: 
                            	  1024: *             EA = x.L  - BYTE only
02:00000BC8 207C0000F100    	  1025:             move.l #$F100,a0      * point to memory to address 0x100
02:00000BCE 10FC0001        	  1026:             move.b #$01,(a0)+         * populate test data
02:00000BD2 10FC00FC        	  1027:             move.b #$FC,(a0)+         * populate test data
02:00000BD6 10FC0080        	  1028:             move.b #$80,(a0)+         * populate test data
02:00000BDA 0B790000F100    	  1029:             bchg.b d5,$F100
02:00000BE0 67FE            	  1030:             beq.s *               * branch if Z set
02:00000BE2 0D790000F101    	  1031:             bchg.b d6,$F101       *
02:00000BE8 66FE            	  1032:             bne.s *               * branch if Z clear
02:00000BEA 0F790000F102    	  1033:             bchg.b d7,$F102       *
02:00000BF0 67FE            	  1034:             beq.s *               * branch if Z set
02:00000BF2 207C0000F101    	  1035:             move.l #$F101,a0      * point to memory to address 0x100
02:00000BF8 0C1000FE        	  1036:             cmpi.b #$FE,(a0)
02:00000BFC 66FE            	  1037:             bne.s *               * branch if Z clear
                            	  1038: 
                            	  1039: 
02:00000BFE 4E75            	  1040:     rts
                            	  1041: 
                            	  1042: *-----------------------------------------------------------
                            	  1043: *-----------------------------------------------------------
                            	  1044: * OPCODE : BCLR
                            	  1045: *-----------------------------------------------------------
                            	  1046: *-----------------------------------------------------------
                            	  1047: op_BCLR:
                            	  1048: 
                            	  1049: 
                            	  1050: *  Bit Number.s Static
                            	  1051: 
                            	  1052: *             EA = Dn  - LONG only
02:00000C00 203CFF0000FF    	  1053:             move.l #$FF0000FF,d0      * populate test data
02:00000C06 08800000        	  1054:             bclr.l #0,d0
02:00000C0A 67FE            	  1055:             beq.s *               * branch if Z set
02:00000C0C 08800001        	  1056:             bclr.l #1,d0              *
02:00000C10 67FE            	  1057:             beq.s *               * branch if Z set
02:00000C12 0880000F        	  1058:             bclr.l #15,d0             *
02:00000C16 66FE            	  1059:             bne.s *               * branch if Z clear
02:00000C18 0880001F        	  1060:             bclr.l #31,d0             *
02:00000C1C 67FE            	  1061:             beq.s *               * branch if Z set
02:00000C1E 0C807F0000FC    	  1062:             cmpi.l #$7F0000FC,d0
02:00000C24 66FE            	  1063:             bne.s *               * branch if Z clear
                            	  1064: 
                            	  1065: 
                            	  1066: *             EA = (An)  - BYTE only
02:00000C26 307C0100        	  1067:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C2A 10BC000F        	  1068:             move.b #$0F,(a0)          * populate test data
02:00000C2E 08900000        	  1069:             bclr.b #0,(a0)
02:00000C32 67FE            	  1070:             beq.s *               * branch if Z set
02:00000C34 08900007        	  1071:             bclr.b #7,(a0)            *
02:00000C38 66FE            	  1072:             bne.s *               * branch if Z clear
02:00000C3A 0C10000E        	  1073:             cmpi.b #$0E,(a0)
02:00000C3E 66FE            	  1074:             bne.s *               * branch if Z clear
                            	  1075: 
                            	  1076: *             EA = (An)+  - BYTE only
02:00000C40 307C0100        	  1077:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C44 10FC0001        	  1078:             move.b #$01,(a0)+         * populate test data
02:00000C48 4218            	  1079:             move.b #$00,(a0)+         * populate test data
02:00000C4A 307C0100        	  1080:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C4E 08980000        	  1081:             bclr.b #0,(a0)+
02:00000C52 67FE            	  1082:             beq.s *               * branch if Z set
02:00000C54 08980001        	  1083:             bclr.b #1,(a0)+           *
02:00000C58 66FE            	  1084:             bne.s *               * branch if Z clear
02:00000C5A 307C0100        	  1085:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C5E 4A18            	  1086:             cmpi.b #$00,(a0)+
02:00000C60 66FE            	  1087:             bne.s *               * branch if Z clear
02:00000C62 4A18            	  1088:             cmpi.b #$00,(a0)+
02:00000C64 66FE            	  1089:             bne.s *               * branch if Z clear
                            	  1090: 
                            	  1091: 
                            	  1092: *             EA = -(An)  - BYTE only
02:00000C66 307C0100        	  1093:             move.l #$00000100,a0      * point to memory to address
02:00000C6A 10FC0001        	  1094:             move.b #$01,(a0)+         * populate test data
02:00000C6E 10FC0080        	  1095:             move.b #$80,(a0)+         * populate test data
02:00000C72 08A00007        	  1096:             bclr.b #7,-(a0)
02:00000C76 67FE            	  1097:             beq.s *               * branch if Z set
02:00000C78 08A00000        	  1098:             bclr.b #0,-(a0)           *
02:00000C7C 67FE            	  1099:             beq.s *               * branch if Z set
02:00000C7E 307C0102        	  1100:             move.l #$00000102,a0      * point to memory to address 0x100
02:00000C82 4A20            	  1101:             cmpi.b #$00,-(a0)
02:00000C84 66FE            	  1102:             bne.s *               * branch if Z clear
02:00000C86 4A20            	  1103:             cmpi.b #$00,-(a0)
02:00000C88 66FE            	  1104:             bne.s *               * branch if Z clear
                            	  1105: 
                            	  1106: 
                            	  1107: *             EA = n(An)  - BYTE only
02:00000C8A 307C0100        	  1108:             move.l #$00000100,a0      * point to memory to address
02:00000C8E 10FC00FF        	  1109:             move.b #$FF,(a0)+         * populate test data
02:00000C92 10FC00FF        	  1110:             move.b #$FF,(a0)+         * populate test data
02:00000C96 307C0100        	  1111:             move.l #$00000100,a0      * point to memory to address
02:00000C9A 08900000        	  1112:             bclr.b #0,0(a0)
02:00000C9E 67FE            	  1113:             beq.s *               * branch if Z set
02:00000CA0 08A800040001    	  1114:             bclr.b #4,1(a0)           *
02:00000CA6 67FE            	  1115:             beq.s *               * branch if Z set
02:00000CA8 307C0100        	  1116:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000CAC 0C1800FE        	  1117:             cmpi.b #$FE,(a0)+
02:00000CB0 66FE            	  1118:             bne.s *               * branch if Z clear
02:00000CB2 0C1800EF        	  1119:             cmpi.b #$EF,(a0)+
02:00000CB6 66FE            	  1120:             bne.s *               * branch if Z clear
                            	  1121: 
                            	  1122: 
                            	  1123: *             EA = n(An,D.W)  - BYTE only
02:00000CB8 307C0100        	  1124:             move.l #$00000100,a0      * point to memory to address
02:00000CBC 93C9            	  1125:             move.l #$00000000,a1      * point to memory to address
02:00000CBE 347C0001        	  1126:             move.l #$00000001,a2      * point to memory to address
02:00000CC2 7000            	  1127:             moveq  #$00000000,d0      * point to memory to address
02:00000CC4 7201            	  1128:             moveq  #$00000001,d1      * point to memory to address
02:00000CC6 10FC00FF        	  1129:             move.b #$FF,(a0)+         * populate test data
02:00000CCA 10FC00FF        	  1130:             move.b #$FF,(a0)+         * populate test data
02:00000CCE 307C0100        	  1131:             move.l #$00000100,a0      * point to memory to address
02:00000CD2 08B000000000    	  1132:             bclr.b #0,0(a0,d0.w)
02:00000CD8 67FE            	  1133:             beq.s *               * branch if Z set
02:00000CDA 08B000011000    	  1134:             bclr.b #1,0(a0,d1.w)      *
02:00000CE0 67FE            	  1135:             beq.s *               * branch if Z set
02:00000CE2 08B000021001    	  1136:             bclr.b #2,1(a0,d1.w)      *
02:00000CE8 66FE            	  1137:             bne.s *               * branch if Z clear
                            	  1138: *             EA = n(An,D.L)  - BYTE only
02:00000CEA 08B000030800    	  1139:             bclr.b #3,0(a0,d0.l)
02:00000CF0 67FE            	  1140:             beq.s *               * branch if Z set
02:00000CF2 08B000041800    	  1141:             bclr.b #4,0(a0,d1.l)      *
02:00000CF8 67FE            	  1142:             beq.s *               * branch if Z set
02:00000CFA 08B000051801    	  1143:             bclr.b #5,1(a0,d1.l)      *
02:00000D00 66FE            	  1144:             bne.s *               * branch if Z clear
                            	  1145: *             EA = n(An,A.W)  - BYTE only
02:00000D02 08B000069000    	  1146:             bclr.b #6,0(a0,a1.w)
02:00000D08 67FE            	  1147:             beq.s *               * branch if Z set
02:00000D0A 08B00001A000    	  1148:             bclr.b #1,0(a0,a2.w)      *
02:00000D10 66FE            	  1149:             bne.s *               * branch if Z clear
02:00000D12 08B00007A001    	  1150:             bclr.b #7,1(a0,a2.w)      *
02:00000D18 67FE            	  1151:             beq.s *               * branch if Z set
                            	  1152: *             EA = n(An,A.L)  - BYTE only
02:00000D1A 08B000009800    	  1153:             bclr.b #0,0(a0,a1.l)
02:00000D20 66FE            	  1154:             bne.s *               * branch if Z clear
02:00000D22 08B00000A800    	  1155:             bclr.b #0,0(a0,a2.l)      *
02:00000D28 67FE            	  1156:             beq.s *               * branch if Z set
02:00000D2A 08B00001A801    	  1157:             bclr.b #1,1(a0,a2.l)      *
02:00000D30 66FE            	  1158:             bne.s *               * branch if Z clear
02:00000D32 307C0100        	  1159:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000D36 0C1800B6        	  1160:             cmpi.b #$B6,(a0)+
02:00000D3A 66FE            	  1161:             bne.s *               * branch if Z clear
02:00000D3C 0C1800EC        	  1162:             cmpi.b #$EC,(a0)+
02:00000D40 66FE            	  1163:             bne.s *               * branch if Z clear
02:00000D42 0C180059        	  1164:             cmpi.b #$59,(a0)+
02:00000D46 67FE            	  1165:             beq.s *               * branch if Z set
                            	  1166: 
                            	  1167: 
                            	  1168: *             EA = x.W  - BYTE only
02:00000D48 307C0100        	  1169:             move.l #$00000100,a0      * point to memory to address
02:00000D4C 10FC00FF        	  1170:             move.b #$FF,(a0)+         * populate test data
02:00000D50 08B800000100    	  1171:             bclr.b #0,$0100
02:00000D56 67FE            	  1172:             beq.s *               * branch if Z set
02:00000D58 08B800010100    	  1173:             bclr.b #1,$0100           *
02:00000D5E 67FE            	  1174:             beq.s *               * branch if Z set
02:00000D60 307C0100        	  1175:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000D64 0C1800FC        	  1176:             cmpi.b #$FC,(a0)+
02:00000D68 66FE            	  1177:             bne.s *               * branch if Z clear
                            	  1178: 
                            	  1179: 
                            	  1180: *             EA = x.L  - BYTE only
02:00000D6A 207C0000F100    	  1181:             move.l #$F100,a0      * point to memory to address 0x100
02:00000D70 10BC00FF        	  1182:             move.b #$FF,(a0)          * populate test data
02:00000D74 08B900000000F100	  1183:             bclr.b #0,$F100
02:00000D7C 67FE            	  1184:             beq.s *               * branch if Z set
02:00000D7E 08B900010000F100	  1185:             bclr.b #1,$F100       *
02:00000D86 67FE            	  1186:             beq.s *               * branch if Z set
02:00000D88 08B900020000F100	  1187:             bclr.b #2,$F100       *
02:00000D90 67FE            	  1188:             beq.s *               * branch if Z set
02:00000D92 207C0000F100    	  1189:             move.l #$F100,a0      * point to memory to address 0x100
02:00000D98 0C1800F8        	  1190:             cmpi.b #$F8,(a0)+
02:00000D9C 66FE            	  1191:             bne.s *               * branch if Z clear
                            	  1192: 
                            	  1193: 
                            	  1194: * Bit Number.s Dynamic
                            	  1195: 
                            	  1196: *             EA = Dn  - LONG only
02:00000D9E 203CFF00FF00    	  1197:             move.l #$FF00FF00,d0      * populate test data
02:00000DA4 7A00            	  1198:             move.l #0,d5              * populate bit.s number to test
02:00000DA6 7C01            	  1199:             move.l #1,d6              * populate bit.s number to test
02:00000DA8 7E1F            	  1200:             move.l #31,d7              * populate bit.s number to test
                            	  1201: 
02:00000DAA 0B80            	  1202:             bclr.l d5,d0
02:00000DAC 66FE            	  1203:             bne.s *               * branch if Z clear
02:00000DAE 0D80            	  1204:             bclr.l d6,d0              *
02:00000DB0 66FE            	  1205:             bne.s *               * branch if Z clear
02:00000DB2 0F80            	  1206:             bclr.l d7,d0             *
02:00000DB4 67FE            	  1207:             beq.s *               * branch if Z set
02:00000DB6 0C807F00FF00    	  1208:             cmpi.l #$7F00FF00,d0
02:00000DBC 66FE            	  1209:             bne.s *               * branch if Z clear
                            	  1210: 
                            	  1211: 
                            	  1212: *             EA = (An)  - BYTE only
02:00000DBE 7A00            	  1213:             move.l #0,d5              * populate bit.s number to test
02:00000DC0 7C01            	  1214:             move.l #1,d6              * populate bit.s number to test
02:00000DC2 7E07            	  1215:             move.l #7,d7              * populate bit.s number to test
02:00000DC4 307C0100        	  1216:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000DC8 10BC0081        	  1217:             move.b #$81,(a0)          * populate test data
02:00000DCC 0B90            	  1218:             bclr.b d5,(a0)
02:00000DCE 67FE            	  1219:             beq.s *               * branch if Z set
02:00000DD0 0D90            	  1220:             bclr.b d6,(a0)            *
02:00000DD2 66FE            	  1221:             bne.s *               * branch if Z clear
02:00000DD4 0F90            	  1222:             bclr.b d7,(a0)            *
02:00000DD6 67FE            	  1223:             beq.s *               * branch if Z set
02:00000DD8 4A10            	  1224:             cmpi.b #$00,(a0)
02:00000DDA 66FE            	  1225:             bne.s *               * branch if Z clear
                            	  1226: 
                            	  1227: 
                            	  1228: *             EA = (An)+  - BYTE only
02:00000DDC 307C0100        	  1229:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000DE0 10FC0001        	  1230:             move.b #$01,(a0)+         * populate test data
02:00000DE4 10FC00FC        	  1231:             move.b #$FC,(a0)+         * populate test data
02:00000DE8 10FC0080        	  1232:             move.b #$80,(a0)+         * populate test data
02:00000DEC 307C0100        	  1233:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000DF0 0B98            	  1234:             bclr.b d5,(a0)+
02:00000DF2 67FE            	  1235:             beq.s *               * branch if Z set
02:00000DF4 0D98            	  1236:             bclr.b d6,(a0)+           *
02:00000DF6 66FE            	  1237:             bne.s *               * branch if Z clear
02:00000DF8 0F98            	  1238:             bclr.b d7,(a0)+           *
02:00000DFA 67FE            	  1239:             beq.s *               * branch if Z set
02:00000DFC 307C0100        	  1240:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000E00 4A18            	  1241:             cmpi.b #$00,(a0)+
02:00000E02 66FE            	  1242:             bne.s *               * branch if Z clear
02:00000E04 0C1800FC        	  1243:             cmpi.b #$FC,(a0)+
02:00000E08 66FE            	  1244:             bne.s *               * branch if Z clear
02:00000E0A 4A18            	  1245:             cmpi.b #$00,(a0)+
02:00000E0C 66FE            	  1246:             bne.s *               * branch if Z clear
                            	  1247: 
                            	  1248: *             EA = -(An)  - BYTE only
02:00000E0E 307C0100        	  1249:             move.l #$00000100,a0      * point to memory to address
02:00000E12 10FC0080        	  1250:             move.b #$80,(a0)+         * populate test data
02:00000E16 10FC00FC        	  1251:             move.b #$FC,(a0)+         * populate test data
02:00000E1A 10FC0001        	  1252:             move.b #$01,(a0)+         * populate test data
02:00000E1E 307C0103        	  1253:             move.l #$00000103,a0      * point to memory to address
02:00000E22 0BA0            	  1254:             bclr.b d5,-(a0)
02:00000E24 67FE            	  1255:             beq.s *               * branch if Z set
02:00000E26 0DA0            	  1256:             bclr.b d6,-(a0)           *
02:00000E28 66FE            	  1257:             bne.s *               * branch if Z clear
02:00000E2A 0FA0            	  1258:             bclr.b d7,-(a0)           *
02:00000E2C 67FE            	  1259:             beq.s *               * branch if Z set
02:00000E2E 307C0103        	  1260:             move.l #$00000103,a0      * point to memory to address 0x100
02:00000E32 4A20            	  1261:             cmpi.b #$00,-(a0)
02:00000E34 66FE            	  1262:             bne.s *               * branch if Z clear
02:00000E36 0C2000FC        	  1263:             cmpi.b #$FC,-(a0)
02:00000E3A 66FE            	  1264:             bne.s *               * branch if Z clear
02:00000E3C 4A20            	  1265:             cmpi.b #$00,-(a0)
02:00000E3E 66FE            	  1266:             bne.s *               * branch if Z clear
                            	  1267: 
                            	  1268: *             EA = n(An)  - BYTE only
02:00000E40 307C0100        	  1269:             move.l #$00000100,a0      * point to memory to address
02:00000E44 10FC0001        	  1270:             move.b #$01,(a0)+         * populate test data
02:00000E48 10FC00FC        	  1271:             move.b #$FC,(a0)+         * populate test data
02:00000E4C 10FC0080        	  1272:             move.b #$80,(a0)+         * populate test data
02:00000E50 307C0100        	  1273:             move.l #$00000100,a0      * point to memory to address
02:00000E54 0B90            	  1274:             bclr.b d5,0(a0)
02:00000E56 67FE            	  1275:             beq.s *               * branch if Z set
02:00000E58 0DA80001        	  1276:             bclr.b d6,1(a0)           *
02:00000E5C 66FE            	  1277:             bne.s *               * branch if Z clear
02:00000E5E 0FA80002        	  1278:             bclr.b d7,2(a0)           *
02:00000E62 67FE            	  1279:             beq.s *               * branch if Z set
02:00000E64 307C0100        	  1280:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000E68 4A18            	  1281:             cmpi.b #$00,(a0)+
02:00000E6A 66FE            	  1282:             bne.s *               * branch if Z clear
02:00000E6C 0C1800FC        	  1283:             cmpi.b #$FC,(a0)+
02:00000E70 66FE            	  1284:             bne.s *               * branch if Z clear
02:00000E72 4A18            	  1285:             cmpi.b #$00,(a0)+
02:00000E74 66FE            	  1286:             bne.s *               * branch if Z clear
                            	  1287: 
                            	  1288: *             EA = n(An,R.W)  - BYTE only
02:00000E76 307C0100        	  1289:             move.l #$00000100,a0      * point to memory to address
02:00000E7A 10FC00FF        	  1290:             move.b #$FF,(a0)+         * populate test data
02:00000E7E 10FC00FF        	  1291:             move.b #$FF,(a0)+         * populate test data
02:00000E82 10FC00FF        	  1292:             move.b #$FF,(a0)+         * populate test data
02:00000E86 307C0103        	  1293:             move.l #$00000103,a0      * point to memory to address
02:00000E8A 307C0100        	  1294:             move.l #$00000100,a0      * point to memory to address
02:00000E8E 93C9            	  1295:             move.l #$00000000,a1      * point to memory to address
02:00000E90 347C0001        	  1296:             move.l #$00000001,a2      * point to memory to address
02:00000E94 7000            	  1297:             moveq  #$00000000,d0      * point to memory to address
02:00000E96 7201            	  1298:             moveq  #$00000001,d1      * point to memory to address
02:00000E98 0BB00000        	  1299:             bclr.b d5,0(a0,d0.w)
02:00000E9C 67FE            	  1300:             beq.s *               * branch if Z set
02:00000E9E 0DB01000        	  1301:             bclr.b d6,0(a0,d1.w)      *
02:00000EA2 67FE            	  1302:             beq.s *               * branch if Z set
02:00000EA4 0FB01001        	  1303:             bclr.b d7,1(a0,d1.w)      *
02:00000EA8 67FE            	  1304:             beq.s *               * branch if Z set
                            	  1305: *             EA = n(An,R.L)  - BYTE only
02:00000EAA 0BB00800        	  1306:             bclr.b d5,0(a0,d0.l)
02:00000EAE 66FE            	  1307:             bne.s *               * branch if Z clear
02:00000EB0 0DB01800        	  1308:             bclr.b d6,0(a0,d1.l)      *
02:00000EB4 66FE            	  1309:             bne.s *               * branch if Z clear
02:00000EB6 0FB01801        	  1310:             bclr.b d7,1(a0,d1.l)      *
02:00000EBA 66FE            	  1311:             bne.s *               * branch if Z clear
                            	  1312: *             EA = n(An,A.W)  - BYTE only
02:00000EBC 0BB09000        	  1313:             bclr.b d5,0(a0,a1.w)
02:00000EC0 66FE            	  1314:             bne.s *               * branch if Z clear
02:00000EC2 0DB0A000        	  1315:             bclr.b d6,0(a0,a2.w)      *
02:00000EC6 66FE            	  1316:             bne.s *               * branch if Z clear
02:00000EC8 0FB0A001        	  1317:             bclr.b d7,1(a0,a2.w)      *
02:00000ECC 66FE            	  1318:             bne.s *               * branch if Z clear
                            	  1319: *             EA = n(An,A.L)  - BYTE only
02:00000ECE 0BB09800        	  1320:             bclr.b d5,0(a0,a1.l)
02:00000ED2 66FE            	  1321:             bne.s *               * branch if Z clear
02:00000ED4 0DB0A800        	  1322:             bclr.b d6,0(a0,a2.l)      *
02:00000ED8 66FE            	  1323:             bne.s *               * branch if Z clear
02:00000EDA 0FB0A801        	  1324:             bclr.b d7,1(a0,a2.l)      *
02:00000EDE 66FE            	  1325:             bne.s *               * branch if Z clear
02:00000EE0 307C0100        	  1326:             move.l #$00000100,a0      * point to memory to address
02:00000EE4 0C1000FE        	  1327:             cmpi.b #$FE,(a0)
02:00000EE8 66FE            	  1328:             bne.s *               * branch if Z clear
                            	  1329: 
                            	  1330: *             EA = x.W  - BYTE only
02:00000EEA 307C0100        	  1331:             move.l #$00000100,a0      * point to memory to address
02:00000EEE 10FC00FF        	  1332:             move.b #$FF,(a0)+         * populate test data
02:00000EF2 10FC00FF        	  1333:             move.b #$FF,(a0)+         * populate test data
02:00000EF6 10FC00FF        	  1334:             move.b #$FF,(a0)+         * populate test data
02:00000EFA 0BB80100        	  1335:             bclr.b d5,$0100
02:00000EFE 67FE            	  1336:             beq.s *               * branch if Z set
02:00000F00 0DB80101        	  1337:             bclr.b d6,$0101           *
02:00000F04 67FE            	  1338:             beq.s *               * branch if Z set
02:00000F06 0FB80102        	  1339:             bclr.b d7,$0102           *
02:00000F0A 67FE            	  1340:             beq.s *               * branch if Z set
02:00000F0C 307C0100        	  1341:             move.l #$00000100,a0      * point to memory to address
02:00000F10 0C1800FE        	  1342:             cmpi.b #$FE,(a0)+
02:00000F14 66FE            	  1343:             bne.s *               * branch if Z clear
                            	  1344: 
                            	  1345: *             EA = x.L  - BYTE only
02:00000F16 207C0000F100    	  1346:             move.l #$F100,a0      * point to memory to address 0x100
02:00000F1C 10FC0001        	  1347:             move.b #$01,(a0)+         * populate test data
02:00000F20 10FC00FC        	  1348:             move.b #$FC,(a0)+         * populate test data
02:00000F24 10FC0080        	  1349:             move.b #$80,(a0)+         * populate test data
02:00000F28 0BB90000F100    	  1350:             bclr.b d5,$F100
02:00000F2E 67FE            	  1351:             beq.s *               * branch if Z set
02:00000F30 0DB90000F101    	  1352:             bclr.b d6,$F101       *
02:00000F36 66FE            	  1353:             bne.s *               * branch if Z clear
02:00000F38 0FB90000F102    	  1354:             bclr.b d7,$F102       *
02:00000F3E 67FE            	  1355:             beq.s *               * branch if Z set
02:00000F40 207C0000F101    	  1356:             move.l #$F101,a0      * point to memory to address 0x100
02:00000F46 0C1000FC        	  1357:             cmpi.b #$FC,(a0)
02:00000F4A 66FE            	  1358:             bne.s *               * branch if Z clear
                            	  1359: 
                            	  1360: 
                            	  1361: 
02:00000F4C 4E75            	  1362:     rts
                            	  1363: 
                            	  1364: *-----------------------------------------------------------
                            	  1365: *-----------------------------------------------------------
                            	  1366: * OPCODE : BSET
                            	  1367: *-----------------------------------------------------------
                            	  1368: *-----------------------------------------------------------
                            	  1369: op_BSET:
                            	  1370: 
                            	  1371: 
                            	  1372: *  Bit Number.s Static
                            	  1373: 
                            	  1374: *             EA = Dn  - LONG only
02:00000F4E 7000            	  1375:             moveq  #$00000000,d0      * populate test data
02:00000F50 08C00000        	  1376:             bset.l #0,d0
02:00000F54 66FE            	  1377:             bne.s *               * branch if Z clear
02:00000F56 08C00001        	  1378:             bset.l #1,d0              *
02:00000F5A 66FE            	  1379:             bne.s *               * branch if Z clear
02:00000F5C 08C0000F        	  1380:             bset.l #15,d0             *
02:00000F60 66FE            	  1381:             bne.s *               * branch if Z clear
02:00000F62 08C0001F        	  1382:             bset.l #31,d0             *
02:00000F66 66FE            	  1383:             bne.s *               * branch if Z clear
02:00000F68 0C8080008003    	  1384:             cmpi.l #$80008003,d0
02:00000F6E 66FE            	  1385:             bne.s *               * branch if Z clear
                            	  1386: 
                            	  1387: 
                            	  1388: *             EA = (An)  - BYTE only
02:00000F70 307C0100        	  1389:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000F74 4210            	  1390:             move.b #$00,(a0)          * populate test data
02:00000F76 08D00000        	  1391:             bset.b #0,(a0)
02:00000F7A 66FE            	  1392:             bne.s *               * branch if Z clear
02:00000F7C 08D00007        	  1393:             bset.b #7,(a0)            *
02:00000F80 66FE            	  1394:             bne.s *               * branch if Z clear
02:00000F82 0C100081        	  1395:             cmpi.b #$81,(a0)
02:00000F86 66FE            	  1396:             bne.s *               * branch if Z clear
                            	  1397: 
                            	  1398: *             EA = (An)+  - BYTE only
02:00000F88 307C0100        	  1399:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000F8C 4218            	  1400:             move.b #$00,(a0)+         * populate test data
02:00000F8E 4218            	  1401:             move.b #$00,(a0)+         * populate test data
02:00000F90 307C0100        	  1402:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000F94 08D80000        	  1403:             bset.b #0,(a0)+
02:00000F98 66FE            	  1404:             bne.s *               * branch if Z clear
02:00000F9A 08D80001        	  1405:             bset.b #1,(a0)+           *
02:00000F9E 66FE            	  1406:             bne.s *               * branch if Z clear
02:00000FA0 307C0100        	  1407:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000FA4 0C180001        	  1408:             cmpi.b #$01,(a0)+
02:00000FA8 66FE            	  1409:             bne.s *               * branch if Z clear
02:00000FAA 0C180002        	  1410:             cmpi.b #$02,(a0)+
02:00000FAE 66FE            	  1411:             bne.s *               * branch if Z clear
                            	  1412: 
                            	  1413: 
                            	  1414: *             EA = -(An)  - BYTE only
02:00000FB0 307C0100        	  1415:             move.l #$00000100,a0      * point to memory to address
02:00000FB4 4218            	  1416:             move.b #$00,(a0)+         * populate test data
02:00000FB6 4218            	  1417:             move.b #$00,(a0)+         * populate test data
02:00000FB8 08E00007        	  1418:             bset.b #7,-(a0)
02:00000FBC 66FE            	  1419:             bne.s *               * branch if Z clear
02:00000FBE 08E00000        	  1420:             bset.b #0,-(a0)           *
02:00000FC2 66FE            	  1421:             bne.s *               * branch if Z clear
02:00000FC4 307C0102        	  1422:             move.l #$00000102,a0      * point to memory to address 0x100
02:00000FC8 0C200080        	  1423:             cmpi.b #$80,-(a0)
02:00000FCC 66FE            	  1424:             bne.s *               * branch if Z clear
02:00000FCE 0C200001        	  1425:             cmpi.b #$01,-(a0)
02:00000FD2 66FE            	  1426:             bne.s *               * branch if Z clear
                            	  1427: 
                            	  1428: 
                            	  1429: *             EA = n(An)  - BYTE only
02:00000FD4 307C0100        	  1430:             move.l #$00000100,a0      * point to memory to address
02:00000FD8 4218            	  1431:             move.b #$00,(a0)+         * populate test data
02:00000FDA 4218            	  1432:             move.b #$00,(a0)+         * populate test data
02:00000FDC 307C0100        	  1433:             move.l #$00000100,a0      * point to memory to address
02:00000FE0 08D00000        	  1434:             bset.b #0,0(a0)
02:00000FE4 66FE            	  1435:             bne.s *               * branch if Z clear
02:00000FE6 08E800040001    	  1436:             bset.b #4,1(a0)           *
02:00000FEC 66FE            	  1437:             bne.s *               * branch if Z clear
02:00000FEE 307C0100        	  1438:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000FF2 0C180001        	  1439:             cmpi.b #$01,(a0)+
02:00000FF6 66FE            	  1440:             bne.s *               * branch if Z clear
02:00000FF8 0C180010        	  1441:             cmpi.b #$10,(a0)+
02:00000FFC 66FE            	  1442:             bne.s *               * branch if Z clear
                            	  1443: 
                            	  1444: 
                            	  1445: *             EA = n(An,D.W)  - BYTE only
02:00000FFE 307C0100        	  1446:             move.l #$00000100,a0      * point to memory to address
02:00001002 93C9            	  1447:             move.l #$00000000,a1      * point to memory to address
02:00001004 347C0004        	  1448:             move.l #$00000004,a2      * point to memory to address
02:00001008 7000            	  1449:             moveq  #$00000000,d0      * point to memory to address
02:0000100A 7201            	  1450:             moveq  #$00000001,d1      * point to memory to address
02:0000100C 4218            	  1451:             move.b #$00,(a0)+         * populate test data
02:0000100E 4218            	  1452:             move.b #$00,(a0)+         * populate test data
02:00001010 4218            	  1453:             move.b #$00,(a0)+         * populate test data
02:00001012 4218            	  1454:             move.b #$00,(a0)+         * populate test data
02:00001014 4218            	  1455:             move.b #$00,(a0)+         * populate test data
02:00001016 4218            	  1456:             move.b #$00,(a0)+         * populate test data
02:00001018 4218            	  1457:             move.b #$00,(a0)+         * populate test data
02:0000101A 4218            	  1458:             move.b #$00,(a0)+         * populate test data
02:0000101C 4218            	  1459:             move.b #$00,(a0)+         * populate test data
02:0000101E 4218            	  1460:             move.b #$00,(a0)+         * populate test data
02:00001020 307C0100        	  1461:             move.l #$00000100,a0      * point to memory to address
02:00001024 08F000000000    	  1462:             bset.b #0,0(a0,d0.w)
02:0000102A 66FE            	  1463:             bne.s *               * branch if Z clear
02:0000102C 08F000011000    	  1464:             bset.b #1,0(a0,d1.w)      *
02:00001032 66FE            	  1465:             bne.s *               * branch if Z clear
02:00001034 08F000021001    	  1466:             bset.b #2,1(a0,d1.w)      *
02:0000103A 66FE            	  1467:             bne.s *               * branch if Z clear
                            	  1468: *             EA = n(An,D.L)  - BYTE only
02:0000103C 08F000030802    	  1469:             bset.b #3,2(a0,d0.l)
02:00001042 66FE            	  1470:             bne.s *               * branch if Z clear
02:00001044 08F000041800    	  1471:             bset.b #4,0(a0,d1.l)      *
02:0000104A 66FE            	  1472:             bne.s *               * branch if Z clear
02:0000104C 08F000051801    	  1473:             bset.b #5,1(a0,d1.l)      *
02:00001052 66FE            	  1474:             bne.s *               * branch if Z clear
                            	  1475: *             EA = n(An,A.W)  - BYTE only
02:00001054 08F000069000    	  1476:             bset.b #6,0(a0,a1.w)
02:0000105A 66FE            	  1477:             bne.s *               * branch if Z clear
02:0000105C 08F00001A000    	  1478:             bset.b #1,0(a0,a2.w)      *
02:00001062 66FE            	  1479:             bne.s *               * branch if Z clear
02:00001064 08F00007A001    	  1480:             bset.b #7,1(a0,a2.w)      *
02:0000106A 66FE            	  1481:             bne.s *               * branch if Z clear
                            	  1482: *             EA = n(An,A.L)  - BYTE only
02:0000106C 08F00000A802    	  1483:             bset.b #0,2(a0,a2.l)
02:00001072 66FE            	  1484:             bne.s *               * branch if Z clear
02:00001074 08F00000A803    	  1485:             bset.b #0,3(a0,a2.l)      *
02:0000107A 66FE            	  1486:             bne.s *               * branch if Z clear
02:0000107C 08F00001A804    	  1487:             bset.b #1,4(a0,a2.l)      *
02:00001082 66FE            	  1488:             bne.s *               * branch if Z clear
02:00001084 307C0100        	  1489:             move.l #$00000100,a0      * point to memory to address 0x100
02:00001088 0C9841122C00    	  1490:             cmpi.l #$41122C00,(a0)+
02:0000108E 66FE            	  1491:             bne.s *               * branch if Z clear
02:00001090 0C9802800101    	  1492:             cmpi.l #$02800101,(a0)+
02:00001096 66FE            	  1493:             bne.s *
                            	  1494: 
                            	  1495: 
                            	  1496: 
                            	  1497: *             EA = x.W  - BYTE only
02:00001098 307C0100        	  1498:             move.l #$00000100,a0      * point to memory to address
02:0000109C 4218            	  1499:             move.b #$00,(a0)+         * populate test data
02:0000109E 08F800000100    	  1500:             bset.b #0,$0100
02:000010A4 66FE            	  1501:             bne.s *               * branch if Z clear
02:000010A6 08F800010100    	  1502:             bset.b #1,$0100           *
02:000010AC 66FE            	  1503:             bne.s *               * branch if Z clear
02:000010AE 307C0100        	  1504:             move.l #$00000100,a0      * point to memory to address 0x100
02:000010B2 0C180003        	  1505:             cmpi.b #$03,(a0)+
02:000010B6 66FE            	  1506:             bne.s *
                            	  1507: 
                            	  1508: 
                            	  1509: *             EA = x.L  - BYTE only
02:000010B8 207C0000F100    	  1510:             move.l #$F100,a0      * point to memory to address 0x100
02:000010BE 4210            	  1511:             move.b #$00,(a0)          * populate test data
02:000010C0 08F900000000F100	  1512:             bset.b #0,$F100
02:000010C8 66FE            	  1513:             bne.s *               * branch if Z clear
02:000010CA 08F900010000F100	  1514:             bset.b #1,$F100       *
02:000010D2 66FE            	  1515:             bne.s *               * branch if Z clear
02:000010D4 08F900020000F100	  1516:             bset.b #2,$F100       *
02:000010DC 66FE            	  1517:             bne.s *               * branch if Z clear
02:000010DE 207C0000F100    	  1518:             move.l #$F100,a0      * point to memory to address 0x100
02:000010E4 0C180007        	  1519:             cmpi.b #$07,(a0)+
02:000010E8 66FE            	  1520:             bne.s *
                            	  1521: 
                            	  1522: 
                            	  1523: * Bit Number.s Dynamic
                            	  1524: 
                            	  1525: *             EA = Dn  - LONG only
02:000010EA 7000            	  1526:             moveq  #$00000000,d0      * populate test data
02:000010EC 7A00            	  1527:             move.l #0,d5              * populate bit.s number to test
02:000010EE 7C01            	  1528:             move.l #1,d6              * populate bit.s number to test
02:000010F0 7E1F            	  1529:             move.l #31,d7              * populate bit.s number to test
                            	  1530: 
02:000010F2 0BC0            	  1531:             bset.l d5,d0
02:000010F4 66FE            	  1532:             bne.s *               * branch if Z clear
02:000010F6 0DC0            	  1533:             bset.l d6,d0              *
02:000010F8 66FE            	  1534:             bne.s *               * branch if Z clear
02:000010FA 0FC0            	  1535:             bset.l d7,d0             *
02:000010FC 66FE            	  1536:             bne.s *               * branch if Z clear
02:000010FE 0C8080000003    	  1537:             cmpi.l #$80000003,d0
02:00001104 66FE            	  1538:             bne.s *               * branch if Z clear
                            	  1539: 
                            	  1540: 
                            	  1541: *             EA = (An)  - BYTE only
02:00001106 7A00            	  1542:             move.l #0,d5              * populate bit.s number to test
02:00001108 7C01            	  1543:             move.l #1,d6              * populate bit.s number to test
02:0000110A 7E07            	  1544:             move.l #7,d7              * populate bit.s number to test
02:0000110C 307C0100        	  1545:             move.l #$00000100,a0      * point to memory to address 0x100
02:00001110 4210            	  1546:             move.b #$00,(a0)          * populate test data
02:00001112 0BD0            	  1547:             bset.b d5,(a0)
02:00001114 66FE            	  1548:             bne.s *               * branch if Z clear
02:00001116 0DD0            	  1549:             bset.b d6,(a0)            *
02:00001118 66FE            	  1550:             bne.s *               * branch if Z clear
02:0000111A 0FD0            	  1551:             bset.b d7,(a0)            *
02:0000111C 66FE            	  1552:             bne.s *               * branch if Z clear
02:0000111E 0C100083        	  1553:             cmpi.b #$83,(a0)
02:00001122 66FE            	  1554:             bne.s *               * branch if Z clear
                            	  1555: 
                            	  1556: 
                            	  1557: *             EA = (An)+  - BYTE only
02:00001124 307C0100        	  1558:             move.l #$00000100,a0      * point to memory to address 0x100
02:00001128 4218            	  1559:             move.b #$00,(a0)+         * populate test data
02:0000112A 4218            	  1560:             move.b #$00,(a0)+         * populate test data
02:0000112C 4218            	  1561:             move.b #$00,(a0)+         * populate test data
02:0000112E 307C0100        	  1562:             move.l #$00000100,a0      * point to memory to address 0x100
02:00001132 0BD8            	  1563:             bset.b d5,(a0)+
02:00001134 66FE            	  1564:             bne.s *               * branch if Z clear
02:00001136 0DD8            	  1565:             bset.b d6,(a0)+           *
02:00001138 66FE            	  1566:             bne.s *               * branch if Z clear
02:0000113A 0FD8            	  1567:             bset.b d7,(a0)+           *
02:0000113C 66FE            	  1568:             bne.s *               * branch if Z clear
02:0000113E 307C0100        	  1569:             move.l #$00000100,a0      * point to memory to address 0x100
02:00001142 0C180001        	  1570:             cmpi.b #$01,(a0)+
02:00001146 66FE            	  1571:             bne.s *               * branch if Z clear
02:00001148 0C180002        	  1572:             cmpi.b #$02,(a0)+
02:0000114C 66FE            	  1573:             bne.s *               * branch if Z clear
02:0000114E 0C180080        	  1574:             cmpi.b #$80,(a0)+
02:00001152 66FE            	  1575:             bne.s *               * branch if Z clear
                            	  1576: 
                            	  1577: *             EA = -(An)  - BYTE only
02:00001154 307C0100        	  1578:             move.l #$00000100,a0      * point to memory to address
02:00001158 4218            	  1579:             move.b #$00,(a0)+         * populate test data
02:0000115A 4218            	  1580:             move.b #$00,(a0)+         * populate test data
02:0000115C 4218            	  1581:             move.b #$00,(a0)+         * populate test data
02:0000115E 307C0103        	  1582:             move.l #$00000103,a0      * point to memory to address
02:00001162 0BE0            	  1583:             bset.b d5,-(a0)
02:00001164 66FE            	  1584:             bne.s *               * branch if Z clear
02:00001166 0DE0            	  1585:             bset.b d6,-(a0)           *
02:00001168 66FE            	  1586:             bne.s *               * branch if Z clear
02:0000116A 0FE0            	  1587:             bset.b d7,-(a0)           *
02:0000116C 66FE            	  1588:             bne.s *               * branch if Z clear
02:0000116E 307C0103        	  1589:             move.l #$00000103,a0      * point to memory to address 0x100
02:00001172 0C200001        	  1590:             cmpi.b #$01,-(a0)
02:00001176 66FE            	  1591:             bne.s *               * branch if Z clear
02:00001178 0C200002        	  1592:             cmpi.b #$02,-(a0)
02:0000117C 66FE            	  1593:             bne.s *               * branch if Z clear
02:0000117E 0C200080        	  1594:             cmpi.b #$80,-(a0)
02:00001182 66FE            	  1595:             bne.s *               * branch if Z clear
                            	  1596: 
                            	  1597: *             EA = n(An)  - BYTE only
02:00001184 307C0100        	  1598:             move.l #$00000100,a0      * point to memory to address
02:00001188 4218            	  1599:             move.b #$00,(a0)+         * populate test data
02:0000118A 4218            	  1600:             move.b #$00,(a0)+         * populate test data
02:0000118C 4218            	  1601:             move.b #$00,(a0)+         * populate test data
02:0000118E 307C0100        	  1602:             move.l #$00000100,a0      * point to memory to address
02:00001192 0BD0            	  1603:             bset.b d5,0(a0)
02:00001194 66FE            	  1604:             bne.s *               * branch if Z clear
02:00001196 0DE80001        	  1605:             bset.b d6,1(a0)           *
02:0000119A 66FE            	  1606:             bne.s *               * branch if Z clear
02:0000119C 0FE80002        	  1607:             bset.b d7,2(a0)           *
02:000011A0 66FE            	  1608:             bne.s *               * branch if Z clear
02:000011A2 307C0100        	  1609:             move.l #$00000100,a0      * point to memory to address 0x100
02:000011A6 0C180001        	  1610:             cmpi.b #$01,(a0)+
02:000011AA 66FE            	  1611:             bne.s *               * branch if Z clear
02:000011AC 0C180002        	  1612:             cmpi.b #$02,(a0)+
02:000011B0 66FE            	  1613:             bne.s *               * branch if Z clear
02:000011B2 0C180080        	  1614:             cmpi.b #$80,(a0)+
02:000011B6 66FE            	  1615:             bne.s *               * branch if Z clear
                            	  1616: 
                            	  1617: *             EA = n(An,R.W)  - BYTE only
02:000011B8 307C0100        	  1618:             move.l #$00000100,a0      * point to memory to address
02:000011BC 4218            	  1619:             move.b #$00,(a0)+         * populate test data
02:000011BE 4218            	  1620:             move.b #$00,(a0)+         * populate test data
02:000011C0 4218            	  1621:             move.b #$00,(a0)+         * populate test data
02:000011C2 4218            	  1622:             move.b #$00,(a0)+         * populate test data
02:000011C4 4218            	  1623:             move.b #$00,(a0)+         * populate test data
02:000011C6 4218            	  1624:             move.b #$00,(a0)+         * populate test data
02:000011C8 4218            	  1625:             move.b #$00,(a0)+         * populate test data
02:000011CA 4218            	  1626:             move.b #$00,(a0)+         * populate test data
02:000011CC 4218            	  1627:             move.b #$00,(a0)+         * populate test data
02:000011CE 4218            	  1628:             move.b #$00,(a0)+         * populate test data
02:000011D0 4218            	  1629:             move.b #$00,(a0)+         * populate test data
02:000011D2 4218            	  1630:             move.b #$00,(a0)+         * populate test data
02:000011D4 307C0100        	  1631:             move.l #$00000100,a0      * point to memory to address
02:000011D8 93C9            	  1632:             move.l #$00000000,a1      * point to memory to address
02:000011DA 347C0001        	  1633:             move.l #$00000001,a2      * point to memory to address
02:000011DE 7000            	  1634:             moveq  #$00000000,d0      * point to memory to address
02:000011E0 7201            	  1635:             moveq  #$00000001,d1      * point to memory to address
02:000011E2 0BF00000        	  1636:             bset.b d5,0(a0,d0.w)
02:000011E6 66FE            	  1637:             bne.s *               * branch if Z clear
02:000011E8 0DF01000        	  1638:             bset.b d6,0(a0,d1.w)      *
02:000011EC 66FE            	  1639:             bne.s *               * branch if Z clear
02:000011EE 0FF01001        	  1640:             bset.b d7,1(a0,d1.w)      *
02:000011F2 66FE            	  1641:             bne.s *               * branch if Z clear
                            	  1642: *             EA = n(An,R.L)  - BYTE only
02:000011F4 0BF00802        	  1643:             bset.b d5,2(a0,d0.l)
02:000011F8 66FE            	  1644:             bne.s *               * branch if Z clear
02:000011FA 0DF01803        	  1645:             bset.b d6,3(a0,d1.l)      *
02:000011FE 66FE            	  1646:             bne.s *               * branch if Z clear
02:00001200 0FF01804        	  1647:             bset.b d7,4(a0,d1.l)      *
02:00001204 66FE            	  1648:             bne.s *               * branch if Z clear
                            	  1649: *             EA = n(An,A.W)  - BYTE only
02:00001206 0BF09005        	  1650:             bset.b d5,5(a0,a1.w)
02:0000120A 66FE            	  1651:             bne.s *               * branch if Z clear
02:0000120C 0DF0A006        	  1652:             bset.b d6,6(a0,a2.w)      *
02:00001210 66FE            	  1653:             bne.s *               * branch if Z clear
02:00001212 0FF0A007        	  1654:             bset.b d7,7(a0,a2.w)      *
02:00001216 66FE            	  1655:             bne.s *               * branch if Z clear
                            	  1656: *             EA = n(An,A.L)  - BYTE only
02:00001218 0BF09808        	  1657:             bset.b d5,8(a0,a1.l)
02:0000121C 66FE            	  1658:             bne.s *               * branch if Z clear
02:0000121E 0DF0A809        	  1659:             bset.b d6,9(a0,a2.l)      *
02:00001222 66FE            	  1660:             bne.s *               * branch if Z clear
02:00001224 0FF0A80A        	  1661:             bset.b d7,10(a0,a2.l)      *
02:00001228 66FE            	  1662:             bne.s *               * branch if Z clear
02:0000122A 307C0100        	  1663:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000122E 0C9801028100    	  1664:             cmpi.l #$01028100,(a0)+
02:00001234 66FE            	  1665:             bne.s *               * branch if Z clear
02:00001236 0C9802810002    	  1666:             cmpi.l #$02810002,(a0)+
02:0000123C 66FE            	  1667:             bne.s *
                            	  1668: 
                            	  1669: 
                            	  1670: *             EA = x.W  - BYTE only
02:0000123E 307C0100        	  1671:             move.l #$00000100,a0      * point to memory to address
02:00001242 4218            	  1672:             move.b #$00,(a0)+         * populate test data
02:00001244 4218            	  1673:             move.b #$00,(a0)+         * populate test data
02:00001246 4218            	  1674:             move.b #$00,(a0)+         * populate test data
02:00001248 0BF80100        	  1675:             bset.b d5,$0100
02:0000124C 66FE            	  1676:             bne.s *               * branch if Z clear
02:0000124E 0DF80100        	  1677:             bset.b d6,$0100           *
02:00001252 66FE            	  1678:             bne.s *               * branch if Z clear
02:00001254 0FF80100        	  1679:             bset.b d7,$0100           *
02:00001258 66FE            	  1680:             bne.s *               * branch if Z clear
02:0000125A 307C0100        	  1681:             move.l #$00000100,a0      * point to memory to address
02:0000125E 0C180083        	  1682:             cmpi.b #$83,(a0)+
02:00001262 66FE            	  1683:             bne.s *               * branch if Z clear
                            	  1684: 
                            	  1685: *             EA = x.L  - BYTE only
02:00001264 207C0000F100    	  1686:             move.l #$F100,a0      * point to memory to address 0x100
02:0000126A 4218            	  1687:             move.b #$00,(a0)+         * populate test data
02:0000126C 4218            	  1688:             move.b #$00,(a0)+         * populate test data
02:0000126E 4218            	  1689:             move.b #$00,(a0)+         * populate test data
02:00001270 0BF90000F100    	  1690:             bset.b d5,$F100
02:00001276 66FE            	  1691:             bne.s *               * branch if Z clear
02:00001278 0DF90000F100    	  1692:             bset.b d6,$F100       *
02:0000127E 66FE            	  1693:             bne.s *               * branch if Z clear
02:00001280 0FF90000F100    	  1694:             bset.b d7,$F100       *
02:00001286 66FE            	  1695:             bne.s *               * branch if Z clear
02:00001288 207C0000F100    	  1696:             move.l #$F100,a0      * point to memory to address 0x100
02:0000128E 0C100083        	  1697:             cmpi.b #$83,(a0)
02:00001292 66FE            	  1698:             bne.s *               * branch if Z clear
                            	  1699: 
                            	  1700: 
02:00001294 4E75            	  1701:     rts
                            	  1702: 
                            	  1703: *-----------------------------------------------------------
                            	  1704: *-----------------------------------------------------------
                            	  1705: * OPCODE : MOVEP
                            	  1706: *-----------------------------------------------------------
                            	  1707: *-----------------------------------------------------------
                            	  1708: op_MOVEP:
                            	  1709: 
                            	  1710: * Dn --> x(An)
02:00001296 307C0100        	  1711:             move.l #$00000100,a0
02:0000129A 203C12345678    	  1712:             move.l #$12345678,d0
02:000012A0 223CAABBCCDD    	  1713:             move.l #$AABBCCDD,d1
02:000012A6 4290            	  1714:             move.l #0,(a0)
02:000012A8 42A80004        	  1715:             move.l #0,4(a0)
                            	  1716: 
02:000012AC 01880000        	  1717:             movep.w d0,0(a0)      * even offset
02:000012B0 03880001        	  1718:             movep.w d1,1(a0)      * odd offset
                            	  1719: 
02:000012B4 01C80004        	  1720:             movep.l d0,4(a0)      * even offset
02:000012B8 03C80005        	  1721:             movep.l d1,5(a0)      * odd offset
                            	  1722: 
02:000012BC 0C9056CC78DD    	  1723:             cmpi.l #$56CC78DD,(a0)
02:000012C2 66FE            	  1724:             bne.s *
02:000012C4 0CA812AA34BB0004	  1725:             cmpi.l #$12AA34BB,4(a0)
02:000012CC 66FE            	  1726:             bne.s *
02:000012CE 0CA856CC78DD0008	  1727:             cmpi.l #$56CC78DD,8(a0)
02:000012D6 66FE            	  1728:             bne.s *
                            	  1729: 
                            	  1730: 
                            	  1731: * x(An)--> Dn
02:000012D8 203C5A5A5A5A    	  1732:             move.l #$5a5a5a5a,d0
02:000012DE 223C5A5A5A5A    	  1733:             move.l #$5a5a5a5a,d1
02:000012E4 243C5A5A5A5A    	  1734:             move.l #$5a5a5a5a,d2
02:000012EA 263C5A5A5A5A    	  1735:             move.l #$5a5a5a5a,d3
                            	  1736: 
02:000012F0 01080000        	  1737:             movep.w 0(a0),d0      * even offset
02:000012F4 03080001        	  1738:             movep.w 1(a0),d1      * odd offset
                            	  1739: 
02:000012F8 05480004        	  1740:             movep.l 4(a0),d2      * even offset
02:000012FC 07480005        	  1741:             movep.l 5(a0),d3      * odd offset
                            	  1742: 
02:00001300 0C805A5A5678    	  1743:             cmpi.l #$5a5a5678,d0
02:00001306 66FE            	  1744:             bne.s *
02:00001308 0C815A5ACCDD    	  1745:             cmpi.l #$5a5aCCDD,d1
02:0000130E 66FE            	  1746:             bne.s *
02:00001310 0C8212345678    	  1747:             cmpi.l #$12345678,d2
02:00001316 66FE            	  1748:             bne.s *
02:00001318 0C83AABBCCDD    	  1749:             cmpi.l #$AABBCCDD,d3
02:0000131E 66FE            	  1750:             bne.s *
                            	  1751: 
02:00001320 4E75            	  1752:             rts
                            	  1753: 
                            	  1754: 
                            	  1755: 
                            	  1756: *-----------------------------------------------------------
                            	  1757: *-----------------------------------------------------------
                            	  1758: * OPCODE : BOOL_I
                            	  1759: *-----------------------------------------------------------
                            	  1760: *-----------------------------------------------------------
                            	  1761: op_BOOL_I:
                            	  1762: 
                            	  1763: *     Dn -- BYTE
02:00001322 203C12345678    	  1764:             move.l #$12345678,d0
02:00001328 44FC000F        	  1765:             move.w #$000F,CCR          * pre-set Flags
02:0000132C 000000FF        	  1766:             ori.b  #$FF,d0
02:00001330 0A00005A        	  1767:             eori.b #$5A,d0
02:00001334 020000F0        	  1768:             andi.b #$F0,d0
02:00001338 69FE            	  1769:             bvs.s *                       * Check V,C are cleared
02:0000133A 65FE            	  1770:             bcs.s *
02:0000133C 6AFE            	  1771:             bpl.s *                       * Verify if N flag is set
02:0000133E 4200            	  1772:             andi.b #$00,d0
02:00001340 6BFE            	  1773:             bmi.s *                       * Verify if N flag is cleared
02:00001342 66FE            	  1774:             bne.s *                       * Verify if Z flag is set
                            	  1775: 
                            	  1776: *     Dn -- WORD
02:00001344 223C12345678    	  1777:             move.l #$12345678,d1
02:0000134A 44FC000F        	  1778:             move.w #$000F,CCR          * pre-set Flags
02:0000134E 0041FFFF        	  1779:             ori.w  #$FFFF,d1
02:00001352 0A415A5A        	  1780:             eori.w #$5A5A,d1
02:00001356 0241F0F0        	  1781:             andi.w #$F0F0,d1
02:0000135A 69FE            	  1782:             bvs.s *                       * Check V,C are cleared
02:0000135C 65FE            	  1783:             bcs.s *
02:0000135E 6AFE            	  1784:             bpl.s *                       * Verify if N flag is set
02:00001360 4241            	  1785:             andi.w #$0000,d1
02:00001362 6BFE            	  1786:             bmi.s *                       * Verify if N flag is cleared
02:00001364 66FE            	  1787:             bne.s *                       * Verify if Z flag is set
                            	  1788: 
                            	  1789: *     Dn -- LONG
02:00001366 243C12345678    	  1790:             move.l #$12345678,d2
02:0000136C 44FC000F        	  1791:             move.w #$000F,CCR          * pre-set Flags
02:00001370 0082FFFFFFFF    	  1792:             ori.l  #$FFFFFFFF,d2
02:00001376 0A825A5A5A5A    	  1793:             eori.l #$5A5A5A5A,d2
02:0000137C 0282F0F0F0F0    	  1794:             andi.l #$F0F0F0F0,d2
02:00001382 69FE            	  1795:             bvs.s *                       * Check V,C are cleared
02:00001384 65FE            	  1796:             bcs.s *
02:00001386 6AFE            	  1797:             bpl.s *                       * Verify if N flag is set
02:00001388 4282            	  1798:             andi.l #$00000000,d2
02:0000138A 6BFE            	  1799:             bmi.s *                       * Verify if N flag is cleared
02:0000138C 66FE            	  1800:             bne.s *                       * Verify if Z flag is set
                            	  1801: 
                            	  1802: 
                            	  1803: *     (An) -- BYTE
02:0000138E 307C0100        	  1804:             move.l #$00000100,a0
02:00001392 20BC12345678    	  1805:             move.l #$12345678,(a0)
02:00001398 44FC000F        	  1806:             move.w #$000F,CCR          * pre-set Flags
02:0000139C 001000FF        	  1807:             ori.b  #$FF,(a0)
02:000013A0 0A10005A        	  1808:             eori.b #$5A,(a0)
02:000013A4 021000F0        	  1809:             andi.b #$F0,(a0)
02:000013A8 69FE            	  1810:             bvs.s *                       * Check V,C are cleared
02:000013AA 65FE            	  1811:             bcs.s *
02:000013AC 6AFE            	  1812:             bpl.s *                       * Verify if N flag is set
02:000013AE 4210            	  1813:             andi.b #$00,(a0)
02:000013B0 6BFE            	  1814:             bmi.s *                       * Verify if N flag is cleared
02:000013B2 66FE            	  1815:             bne.s *                       * Verify if Z flag is set
02:000013B4 4A10            	  1816:             cmpi.b #$00,(a0)
02:000013B6 66FE            	  1817:             bne.s *                       * Verify if Z flag is set
                            	  1818: 
                            	  1819: *     (An) -- WORD
02:000013B8 20BC12345678    	  1820:             move.l #$12345678,(a0)
02:000013BE 44FC000F        	  1821:             move.w #$000F,CCR          * pre-set Flags
02:000013C2 0050FFFF        	  1822:             ori.w  #$FFFF,(a0)
02:000013C6 0A505A5A        	  1823:             eori.w #$5A5A,(a0)
02:000013CA 0250F0F0        	  1824:             andi.w #$F0F0,(a0)
02:000013CE 69FE            	  1825:             bvs.s *                       * Check V,C are cleared
02:000013D0 65FE            	  1826:             bcs.s *
02:000013D2 6AFE            	  1827:             bpl.s *                       * Verify if N flag is set
02:000013D4 4250            	  1828:             andi.w #$0000,(a0)
02:000013D6 6BFE            	  1829:             bmi.s *                       * Verify if N flag is cleared
02:000013D8 66FE            	  1830:             bne.s *                       * Verify if Z flag is set
02:000013DA 4A50            	  1831:             cmpi.w #$00,(a0)
02:000013DC 66FE            	  1832:             bne.s *                       * Verify if Z flag is set
                            	  1833: 
                            	  1834: *     (An) -- LONG
02:000013DE 20BC12345678    	  1835:             move.l #$12345678,(a0)
02:000013E4 44FC000F        	  1836:             move.w #$000F,CCR          * pre-set Flags
02:000013E8 0090FFFFFFFF    	  1837:             ori.l  #$FFFFFFFF,(a0)
02:000013EE 0A905A5A5A5A    	  1838:             eori.l #$5A5A5A5A,(a0)
02:000013F4 0290F0F0F0F0    	  1839:             andi.l #$F0F0F0F0,(a0)
02:000013FA 69FE            	  1840:             bvs.s *                       * Check V,C are cleared
02:000013FC 65FE            	  1841:             bcs.s *
02:000013FE 6AFE            	  1842:             bpl.s *                       * Verify if N flag is set
02:00001400 4290            	  1843:             andi.l #$00000000,(a0)
02:00001402 6BFE            	  1844:             bmi.s *                       * Verify if N flag is cleared
02:00001404 66FE            	  1845:             bne.s *                       * Verify if Z flag is set
02:00001406 4A90            	  1846:             cmpi.l #$00,(a0)
02:00001408 66FE            	  1847:             bne.s *                       * Verify if Z flag is set
                            	  1848: 
                            	  1849: 
                            	  1850: 
                            	  1851: *     (An)+ -- BYTE
02:0000140A 307C0100        	  1852:             move.l #$00000100,a0
02:0000140E 20BC00A5FF88    	  1853:             move.l #$00A5FF88,(a0)
02:00001414 44FC000F        	  1854:             move.w #$000F,CCR          * pre-set Flags
                            	  1855: 
02:00001418 001800F5        	  1856:             ori.b  #$F5,(a0)+
02:0000141C 6AFE            	  1857:             bpl.s *                       * Verify if N flag is set
02:0000141E 67FE            	  1858:             beq.s *                       * Verify if Z flag is cleared
                            	  1859: 
02:00001420 4618            	  1860:             eori.b #$FF,(a0)+
02:00001422 6BFE            	  1861:             bmi.s *                       * Verify if N flag is cleared
02:00001424 67FE            	  1862:             beq.s *                       * Verify if Z flag is cleared
                            	  1863: 
02:00001426 021800AA        	  1864:             andi.b #$AA,(a0)+
02:0000142A 6AFE            	  1865:             bpl.s *                       * Verify if N flag is set
02:0000142C 67FE            	  1866:             beq.s *                       * Verify if Z flag is cleared
                            	  1867: 
02:0000142E 307C0100        	  1868:             move.l #$00000100,a0
02:00001432 0C90F55AAA88    	  1869:             cmpi.l #$F55AAA88,(a0)
02:00001438 66FE            	  1870:             bne.s *                       * Verify if Z flag is set
                            	  1871: 
                            	  1872: 
                            	  1873: *     (An)+ -- WORD
02:0000143A 307C0100        	  1874:             move.l #$00000100,a0
02:0000143E 327C0104        	  1875:             move.l #$00000104,a1
02:00001442 20BC00005A5A    	  1876:             move.l #$00005a5a,(a0)
02:00001448 22BC12345678    	  1877:             move.l #$12345678,(a1)
02:0000144E 44FC000F        	  1878:             move.w #$000F,CCR          * pre-set Flags
                            	  1879: 
02:00001452 00585678        	  1880:             ori.w  #$5678,(a0)+
02:00001456 6BFE            	  1881:             bmi.s *                       * Verify if N flag is cleared
02:00001458 67FE            	  1882:             beq.s *                       * Verify if Z flag is cleared
                            	  1883: 
02:0000145A 4658            	  1884:             eori.w #$FFFF,(a0)+
02:0000145C 6AFE            	  1885:             bpl.s *                       * Verify if N flag is set
02:0000145E 67FE            	  1886:             beq.s *                       * Verify if Z flag is cleared
                            	  1887: 
02:00001460 0258A55A        	  1888:             andi.w #$A55A,(a0)+
02:00001464 6BFE            	  1889:             bmi.s *                       * Verify if N flag is cleared
02:00001466 67FE            	  1890:             beq.s *                       * Verify if Z flag is cleared
                            	  1891: 
02:00001468 307C0100        	  1892:             move.l #$00000100,a0
02:0000146C 0C905678A5A5    	  1893:             cmpi.l #$5678a5a5,(a0)
02:00001472 307C0104        	  1894:             move.l #$00000104,a0
02:00001476 0C9000105678    	  1895:             cmpi.l #$00105678,(a0)
02:0000147C 66FE            	  1896:             bne.s *                       * Verify if Z flag is set
                            	  1897: 
                            	  1898: *     (An)+ -- LONG
02:0000147E 307C0100        	  1899:             move.l #$00000100,a0
02:00001482 4298            	  1900:             move.l #$00000000,(a0)+
02:00001484 20FC5A5A5A5A    	  1901:             move.l #$5a5a5a5a,(a0)+
02:0000148A 20FCFFFFFFFF    	  1902:             move.l #$FFFFFFFF,(a0)+
02:00001490 307C0100        	  1903:             move.l #$00000100,a0
02:00001494 44FC000F        	  1904:             move.w #$000F,CCR          * pre-set Flags
                            	  1905: 
02:00001498 009812345678    	  1906:             ori.l  #$12345678,(a0)+
02:0000149E 6BFE            	  1907:             bmi.s *                       * Verify if N flag is cleared
02:000014A0 67FE            	  1908:             beq.s *                       * Verify if Z flag is cleared
                            	  1909: 
02:000014A2 4698            	  1910:             eori.l #$FFFFFFFF,(a0)+
02:000014A4 6AFE            	  1911:             bpl.s *                       * Verify if N flag is set
02:000014A6 67FE            	  1912:             beq.s *                       * Verify if Z flag is cleared
                            	  1913: 
02:000014A8 0298A5A5A55A    	  1914:             andi.l #$A5A5A55A,(a0)+
02:000014AE 6AFE            	  1915:             bpl.s *                       * Verify if N flag is set
02:000014B0 67FE            	  1916:             beq.s *                       * Verify if Z flag is cleared
                            	  1917: 
02:000014B2 307C0100        	  1918:             move.l #$00000100,a0
02:000014B6 0C9812345678    	  1919:             cmpi.l #$12345678,(a0)+
02:000014BC 0C98A5A5A5A5    	  1920:             cmpi.l #$a5a5a5a5,(a0)+
02:000014C2 0C98A5A5A55A    	  1921:             cmpi.l #$a5a5a55a,(a0)+
02:000014C8 66FE            	  1922:             bne.s *                       * Verify if Z flag is set
                            	  1923: 
02:000014CA 4E75            	  1924:             rts
                            	  1925: 
                            	  1926: 
                            	  1927: *-----------------------------------------------------------
                            	  1928: *-----------------------------------------------------------
                            	  1929: * OPCODE : BSR
                            	  1930: *-----------------------------------------------------------
                            	  1931: *-----------------------------------------------------------
                            	  1932: 
                            	  1933: 
02:000014CC 223C11111111    	  1934: BSR_CLOSE1:     move.l #$11111111,d1
02:000014D2 4E75            	  1935:                 rts
                            	  1936: 
                            	  1937: 
                            	  1938: 
02:000014D4 61F6            	  1939: op_BSR:         bsr BSR_CLOSE1        * Negative 8-bit.s displacement
02:000014D6 612A            	  1940:                 bsr BSR_CLOSE2        * Positive 8-bit.s displacement
02:000014D8 6100EF20        	  1941:                 bsr.w BSR_FAR1          * Negative 16-bit.s displacement
02:000014DC 6100143E        	  1942:                 bsr.w BSR_FAR2          * Positive 16-bit.s displacement
                            	  1943: 
02:000014E0 0C8111111111    	  1944:                 cmpi.l #$11111111,d1
02:000014E6 66FE            	  1945:                 bne.s *
02:000014E8 0C8222222222    	  1946:                 cmpi.l #$22222222,d2
02:000014EE 66FE            	  1947:                 bne.s *
02:000014F0 0C8333333333    	  1948:                 cmpi.l #$33333333,d3
02:000014F6 66FE            	  1949:                 bne.s *
02:000014F8 0C8444444444    	  1950:                 cmpi.l #$44444444,d4
02:000014FE 66FE            	  1951:                 bne.s *
                            	  1952: 
02:00001500 4E75            	  1953:                 rts
                            	  1954: 
                            	  1955: 
02:00001502 243C22222222    	  1956: BSR_CLOSE2:     move.l #$22222222,d2
02:00001508 4E75            	  1957:                 rts
                            	  1958: 
                            	  1959: *-----------------------------------------------------------
                            	  1960: *-----------------------------------------------------------
                            	  1961: * OPCODE : op_CMP_I
                            	  1962: *-----------------------------------------------------------
                            	  1963: *-----------------------------------------------------------
                            	  1964: op_CMP_I:
                            	  1965: 
02:0000150A 307C0100        	  1966:             move.l #$00000100,a0
02:0000150E 20BC00000100    	  1967:             move.l #$00000100,(a0)
                            	  1968: 
                            	  1969: *     REGISTER - BYTE
02:00001514 7080            	  1970:             move.l #$FFFFFF80,d0
02:00001516 0C000080        	  1971:             cmpi.b #$80,d0
02:0000151A 66FE            	  1972:             bne.s *                       * Check Z Flag  beq/bne
02:0000151C 6BFE            	  1973:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000151E 65FE            	  1974:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001520 69FE            	  1975:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1976: 
02:00001522 223CFFFFF000    	  1977:             move.l #$FFFFF000,d1
02:00001528 4A01            	  1978:             cmpi.b #$00,d1
02:0000152A 66FE            	  1979:             bne.s *                       * Check Z Flag  beq/bne
02:0000152C 6BFE            	  1980:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000152E 65FE            	  1981:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001530 69FE            	  1982:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1983: 
02:00001532 7481D442        	  1984:             move.l #$FFFFFF02,d2
02:00001536 0C0200FF        	  1985:             cmpi.b #$FF,d2
02:0000153A 67FE            	  1986:             beq.s *                       * Check Z Flag  beq/bne
02:0000153C 6BFE            	  1987:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000153E 64FE            	  1988:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001540 69FE            	  1989:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1990: 
02:00001542 263CFFFFFF7F    	  1991:             move.l #$FFFFFF7F,d3
02:00001548 0C0300FF        	  1992:             cmpi.b #$FF,d3
02:0000154C 67FE            	  1993:             beq.s *                       * Check Z Flag  beq/bne
02:0000154E 6AFE            	  1994:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001550 64FE            	  1995:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001552 68FE            	  1996:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  1997: 
                            	  1998: 
                            	  1999: *     REGISTER - WORD
02:00001554 203CFFFF8000    	  2000:             move.l #$FFFF8000,d0
02:0000155A 0C408000        	  2001:             cmpi.w #$8000,d0
02:0000155E 66FE            	  2002:             bne.s *                       * Check Z Flag  beq/bne
02:00001560 6BFE            	  2003:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001562 65FE            	  2004:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001564 69FE            	  2005:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2006: 
02:00001566 223CFFF00000    	  2007:             move.l #$FFF00000,d1
02:0000156C 4A41            	  2008:             cmpi.w #$0000,d1
02:0000156E 66FE            	  2009:             bne.s *                       * Check Z Flag  beq/bne
02:00001570 6BFE            	  2010:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001572 65FE            	  2011:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001574 69FE            	  2012:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2013: 
02:00001576 243CFFFF0002    	  2014:             move.l #$FFFF0002,d2
02:0000157C 0C42FFFF        	  2015:             cmpi.w #$FFFF,d2
02:00001580 67FE            	  2016:             beq.s *                       * Check Z Flag  beq/bne
02:00001582 6BFE            	  2017:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001584 64FE            	  2018:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001586 69FE            	  2019:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2020: 
02:00001588 263CFFFF7FFF    	  2021:             move.l #$FFFF7FFF,d3
02:0000158E 0C43FFFF        	  2022:             cmpi.w #$FFFF,d3
02:00001592 67FE            	  2023:             beq.s *                       * Check Z Flag  beq/bne
02:00001594 6AFE            	  2024:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001596 64FE            	  2025:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001598 68FE            	  2026:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2027: 
                            	  2028: *     REGISTER - LONG
02:0000159A 203C80000000    	  2029:             move.l #$80000000,d0
02:000015A0 0C8080000000    	  2030:             cmpi.l #$80000000,d0
02:000015A6 66FE            	  2031:             bne.s *                       * Check Z Flag  beq/bne
02:000015A8 6BFE            	  2032:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015AA 65FE            	  2033:             bcs.s *                       * Check C Flag  bcc/bcs
02:000015AC 69FE            	  2034:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2035: 
02:000015AE 7200            	  2036:             moveq  #$00000000,d1
02:000015B0 4A81            	  2037:             cmpi.l #$00000000,d1
02:000015B2 66FE            	  2038:             bne.s *                       * Check Z Flag  beq/bne
02:000015B4 6BFE            	  2039:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015B6 65FE            	  2040:             bcs.s *                       * Check C Flag  bcc/bcs
02:000015B8 69FE            	  2041:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2042: 
02:000015BA 7402            	  2043:             moveq  #$00000002,d2
02:000015BC 0C82FFFFFFFF    	  2044:             cmpi.l #$FFFFFFFF,d2
02:000015C2 67FE            	  2045:             beq.s *                       * Check Z Flag  beq/bne
02:000015C4 6BFE            	  2046:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015C6 64FE            	  2047:             bcc.s *                       * Check C Flag  bcc/bcs
02:000015C8 69FE            	  2048:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2049: 
02:000015CA 263C7FFFFFFF    	  2050:             move.l #$7FFFFFFF,d3
02:000015D0 0C83FFFFFFFF    	  2051:             cmpi.l #$FFFFFFFF,d3
02:000015D6 67FE            	  2052:             beq.s *                       * Check Z Flag  beq/bne
02:000015D8 6AFE            	  2053:             bpl.s *                       * Check N Flag  bmi/bpl
02:000015DA 64FE            	  2054:             bcc.s *                       * Check C Flag  bcc/bcs
02:000015DC 68FE            	  2055:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2056: 
                            	  2057: 
                            	  2058: 
                            	  2059: 
                            	  2060: *     EA=x(An,Dn) - BYTE
02:000015DE 307C0100        	  2061:             move.l #$00000100,a0
02:000015E2 7E04            	  2062:             moveq  #$00000004,d7
                            	  2063: 
02:000015E4 21BCFFFFFF80700C	  2064:             move.l #$FFFFFF80,12(a0,d7)
02:000015EC 21BCFFFFFF80700C	  2065:             move.l #$FFFFFF80,12(a0,d7)
02:000015F4 0C300080700F    	  2066:             cmpi.b #$80,15(a0,d7)
02:000015FA 66FE            	  2067:             bne.s *                       * Check Z Flag  beq/bne
02:000015FC 6BFE            	  2068:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015FE 65FE            	  2069:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001600 69FE            	  2070:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2071: 
02:00001602 21BCFFFFF000700C	  2072:             move.l #$FFFFF000,12(a0,d7)
02:0000160A 4A30700F        	  2073:             cmpi.b #$00,15(a0,d7)
02:0000160E 66FE            	  2074:             bne.s *                       * Check Z Flag  beq/bne
02:00001610 6BFE            	  2075:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001612 65FE            	  2076:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001614 69FE            	  2077:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2078: 
02:00001616 21BCFFFFFF02700C	  2079:             move.l #$FFFFFF02,12(a0,d7)
02:0000161E 0C3000FF700F    	  2080:             cmpi.b #$FF,15(a0,d7)
02:00001624 67FE            	  2081:             beq.s *                       * Check Z Flag  beq/bne
02:00001626 6BFE            	  2082:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001628 64FE            	  2083:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000162A 69FE            	  2084:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2085: 
02:0000162C 21BCFFFFFF7F700C	  2086:             move.l #$FFFFFF7F,12(a0,d7)
02:00001634 0C3000FF700F    	  2087:             cmpi.b #$FF,15(a0,d7)
02:0000163A 67FE            	  2088:             beq.s *                       * Check Z Flag  beq/bne
02:0000163C 6AFE            	  2089:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000163E 64FE            	  2090:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001640 68FE            	  2091:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2092: 
                            	  2093: 
                            	  2094: *     EA=x(An,Dn) - WORD
02:00001642 21BCFFFF8000700C	  2095:             move.l #$FFFF8000,12(a0,d7)
02:0000164A 0C708000700E    	  2096:             cmpi.w #$8000,14(a0,d7)
02:00001650 66FE            	  2097:             bne.s *                       * Check Z Flag  beq/bne
02:00001652 6BFE            	  2098:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001654 65FE            	  2099:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001656 69FE            	  2100:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2101: 
02:00001658 21BCFFF00000700C	  2102:             move.l #$FFF00000,12(a0,d7)
02:00001660 4A70700E        	  2103:             cmpi.w #$0000,14(a0,d7)
02:00001664 66FE            	  2104:             bne.s *                       * Check Z Flag  beq/bne
02:00001666 6BFE            	  2105:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001668 65FE            	  2106:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000166A 69FE            	  2107:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2108: 
02:0000166C 21BCFFFF0002700C	  2109:             move.l #$FFFF0002,12(a0,d7)
02:00001674 0C70FFFF700E    	  2110:             cmpi.w #$FFFF,14(a0,d7)
02:0000167A 67FE            	  2111:             beq.s *                       * Check Z Flag  beq/bne
02:0000167C 6BFE            	  2112:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000167E 64FE            	  2113:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001680 69FE            	  2114:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2115: 
02:00001682 21BCFFFF7FFF700C	  2116:             move.l #$FFFF7FFF,12(a0,d7)
02:0000168A 0C70FFFF700E    	  2117:             cmpi.w #$FFFF,14(a0,d7)
02:00001690 67FE            	  2118:             beq.s *                       * Check Z Flag  beq/bne
02:00001692 6AFE            	  2119:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001694 64FE            	  2120:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001696 68FE            	  2121:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2122: 
                            	  2123: *     EA=x(An,Dn) - LONG
02:00001698 21BC80000000700C	  2124:             move.l #$80000000,12(a0,d7)
02:000016A0 0CB080000000700C	  2125:             cmpi.l #$80000000,12(a0,d7)
02:000016A8 66FE            	  2126:             bne.s *                       * Check Z Flag  beq/bne
02:000016AA 6BFE            	  2127:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016AC 65FE            	  2128:             bcs.s *                       * Check C Flag  bcc/bcs
02:000016AE 69FE            	  2129:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2130: 
02:000016B0 42B0700C        	  2131:             move.l #$00000000,12(a0,d7)
02:000016B4 4AB0700C        	  2132:             cmpi.l #$00000000,12(a0,d7)
02:000016B8 66FE            	  2133:             bne.s *                       * Check Z Flag  beq/bne
02:000016BA 6BFE            	  2134:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016BC 65FE            	  2135:             bcs.s *                       * Check C Flag  bcc/bcs
02:000016BE 69FE            	  2136:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2137: 
02:000016C0 21BC00000002700C	  2138:             move.l #$00000002,12(a0,d7)
02:000016C8 0CB0FFFFFFFF700C	  2139:             cmpi.l #$FFFFFFFF,12(a0,d7)
02:000016D0 67FE            	  2140:             beq.s *                       * Check Z Flag  beq/bne
02:000016D2 6BFE            	  2141:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016D4 64FE            	  2142:             bcc.s *                       * Check C Flag  bcc/bcs
02:000016D6 69FE            	  2143:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2144: 
02:000016D8 21BC7FFFFFFF700C	  2145:             move.l #$7FFFFFFF,12(a0,d7)
02:000016E0 0CB0FFFFFFFF700C	  2146:             cmpi.l #$FFFFFFFF,12(a0,d7)
02:000016E8 67FE            	  2147:             beq.s *                       * Check Z Flag  beq/bne
02:000016EA 6AFE            	  2148:             bpl.s *                       * Check N Flag  bmi/bpl
02:000016EC 64FE            	  2149:             bcc.s *                       * Check C Flag  bcc/bcs
02:000016EE 68FE            	  2150:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2151: 
                            	  2152: 
                            	  2153: 
                            	  2154: 
02:000016F0 4E75            	  2155:             rts
                            	  2156: 
                            	  2157: 
                            	  2158: 
                            	  2159: *-----------------------------------------------------------
                            	  2160: *-----------------------------------------------------------
                            	  2161: * OPCODE : ADD_I
                            	  2162: *-----------------------------------------------------------
                            	  2163: *-----------------------------------------------------------
                            	  2164: op_ADD_I:
                            	  2165: 
                            	  2166: *     EA = Dn  - Byte
02:000016F2 203C12345678    	  2167:             move.l #$12345678,d0      * populate test data
02:000016F8 06000000        	  2168:             addi.b #0,d0
02:000016FC 67FE            	  2169:             beq.s *                       * Check Z Flag  beq/bne
02:000016FE 6BFE            	  2170:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001700 65FE            	  2171:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001702 69FE            	  2172:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001704 06000010        	  2173:             addi.b #$10,d0
02:00001708 67FE            	  2174:             beq.s *                       * Check Z Flag  beq/bne
02:0000170A 6AFE            	  2175:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000170C 65FE            	  2176:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000170E 68FE            	  2177:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001710 060000A5        	  2178:             addi.b #$A5,d0
02:00001714 67FE            	  2179:             beq.s *                       * Check Z Flag  beq/bne
02:00001716 6BFE            	  2180:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001718 64FE            	  2181:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000171A 68FE            	  2182:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000171C 0C00002D        	  2183:             cmpi.b #$2D,d0
02:00001720 66FE            	  2184:             bne.s *                       * Check Z Flag  beq/bne
                            	  2185: 
                            	  2186: *     EA = Dn  - WORD
02:00001722 203C12345678    	  2187:             move.l #$12345678,d0      * populate test data
02:00001728 06400000        	  2188:             addi.w #0,d0
02:0000172C 67FE            	  2189:             beq.s *                       * Check Z Flag  beq/bne
02:0000172E 6BFE            	  2190:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001730 65FE            	  2191:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001732 69FE            	  2192:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001734 06407000        	  2193:             addi.w #$7000,d0
02:00001738 67FE            	  2194:             beq.s *                       * Check Z Flag  beq/bne
02:0000173A 6AFE            	  2195:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000173C 65FE            	  2196:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000173E 68FE            	  2197:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001740 0640A55A        	  2198:             addi.w #$A55A,d0
02:00001744 67FE            	  2199:             beq.s *                       * Check Z Flag  beq/bne
02:00001746 6BFE            	  2200:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001748 64FE            	  2201:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000174A 68FE            	  2202:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000174C 0C406BD2        	  2203:             cmpi.w #$6BD2,d0
02:00001750 66FE            	  2204:             bne.s *                       * Check Z Flag  beq/bne
                            	  2205: 
                            	  2206: *     EA = Dn  - LONG
02:00001752 203C12345678    	  2207:             move.l #$12345678,d0      * populate test data
02:00001758 068000000000    	  2208:             addi.l #0,d0
02:0000175E 67FE            	  2209:             beq.s *                       * Check Z Flag  beq/bne
02:00001760 6BFE            	  2210:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001762 65FE            	  2211:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001764 69FE            	  2212:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001766 0680F0000000    	  2213:             addi.l #$F0000000,d0
02:0000176C 67FE            	  2214:             beq.s *                       * Check Z Flag  beq/bne
02:0000176E 6BFE            	  2215:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001770 64FE            	  2216:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001772 69FE            	  2217:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001774 0680855AA55A    	  2218:             addi.l #$855AA55A,d0
02:0000177A 67FE            	  2219:             beq.s *                       * Check Z Flag  beq/bne
02:0000177C 6AFE            	  2220:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000177E 65FE            	  2221:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001780 69FE            	  2222:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001782 0680A0000000    	  2223:             addi.l #$A0000000,d0
02:00001788 68FE            	  2224:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000178A 0C80278EFBD2    	  2225:             cmpi.l #$278EFBD2,d0
02:00001790 66FE            	  2226:             bne.s *                       * Check Z Flag  beq/bne
                            	  2227: 
                            	  2228: 
                            	  2229: 
                            	  2230: *     EA = x.L  - Byte
02:00001792 207C0000F100    	  2231:             move.l #$F100,a0      * populate test data
02:00001798 20BC12345678    	  2232:             move.l #$12345678,(a0)     * populate test data
02:0000179E 063900000000F103	  2233:             addi.b #0,$F103
02:000017A6 67FE            	  2234:             beq.s *                       * Check Z Flag  beq/bne
02:000017A8 6BFE            	  2235:             bmi.s *                       * Check N Flag  bmi/bpl
02:000017AA 65FE            	  2236:             bcs.s *                       * Check C Flag  bcc/bcs
02:000017AC 69FE            	  2237:             bvs.s *                       * Check V Flag  bvc/bvs
02:000017AE 063900100000F103	  2238:             addi.b #$10,$F103
02:000017B6 67FE            	  2239:             beq.s *                       * Check Z Flag  beq/bne
02:000017B8 6AFE            	  2240:             bpl.s *                       * Check N Flag  bmi/bpl
02:000017BA 65FE            	  2241:             bcs.s *                       * Check C Flag  bcc/bcs
02:000017BC 68FE            	  2242:             bvc.s *                       * Check V Flag  bvc/bvs
02:000017BE 063900A50000F103	  2243:             addi.b #$A5,$F103
02:000017C6 67FE            	  2244:             beq.s *                       * Check Z Flag  beq/bne
02:000017C8 6BFE            	  2245:             bmi.s *                       * Check N Flag  bmi/bpl
02:000017CA 64FE            	  2246:             bcc.s *                       * Check C Flag  bcc/bcs
02:000017CC 68FE            	  2247:             bvc.s *                       * Check V Flag  bvc/bvs
02:000017CE 0C39002D0000F103	  2248:             cmpi.b #$2D,$F103
02:000017D6 66FE            	  2249:             bne.s *                       * Check Z Flag  beq/bne
                            	  2250: 
                            	  2251: *     EA = x.L- WORD
02:000017D8 207C0000F100    	  2252:             move.l #$F100,a0      * populate test data
02:000017DE 20BC12345678    	  2253:             move.l #$12345678,(a0)     * populate test data
02:000017E4 067900000000F100	  2254:             addi.w #0,$F100
02:000017EC 67FE            	  2255:             beq.s *                       * Check Z Flag  beq/bne
02:000017EE 6BFE            	  2256:             bmi.s *                       * Check N Flag  bmi/bpl
02:000017F0 65FE            	  2257:             bcs.s *                       * Check C Flag  bcc/bcs
02:000017F2 69FE            	  2258:             bvs.s *                       * Check V Flag  bvc/bvs
02:000017F4 067970000000F100	  2259:             addi.w #$7000,$F100
02:000017FC 67FE            	  2260:             beq.s *                       * Check Z Flag  beq/bne
02:000017FE 6AFE            	  2261:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001800 65FE            	  2262:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001802 68FE            	  2263:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001804 0679A55A0000F100	  2264:             addi.w #$A55A,$F100
02:0000180C 67FE            	  2265:             beq.s *                       * Check Z Flag  beq/bne
02:0000180E 6BFE            	  2266:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001810 64FE            	  2267:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001812 68FE            	  2268:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001814 0C79278E0000F100	  2269:             cmpi.w #$278E,$F100
02:0000181C 66FE            	  2270:             bne.s *                       * Check Z Flag  beq/bne
                            	  2271: 
                            	  2272: *     EA = x.L- LONG
02:0000181E 23FC123456780000	  2273:             move.l #$12345678,$F100  * populate test data
02:00001826 F100
02:00001828 06B9000000000000	  2274:             addi.l #0,$F100
02:00001830 F100
02:00001832 67FE            	  2275:             beq.s *                       * Check Z Flag  beq/bne
02:00001834 6BFE            	  2276:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001836 65FE            	  2277:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001838 69FE            	  2278:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000183A 06B9F00000000000	  2279:             addi.l #$F0000000,$F100
02:00001842 F100
02:00001844 67FE            	  2280:             beq.s *                       * Check Z Flag  beq/bne
02:00001846 6BFE            	  2281:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001848 64FE            	  2282:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000184A 69FE            	  2283:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000184C 06B9855AA55A0000	  2284:             addi.l #$855AA55A,$F100
02:00001854 F100
02:00001856 67FE            	  2285:             beq.s *                       * Check Z Flag  beq/bne
02:00001858 6AFE            	  2286:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000185A 65FE            	  2287:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000185C 69FE            	  2288:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000185E 06B9A00000000000	  2289:             addi.l #$A0000000,$F100
02:00001866 F100
02:00001868 68FE            	  2290:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000186A 0CB9278EFBD20000	  2291:             cmpi.l #$278EFBD2,$F100
02:00001872 F100
02:00001874 66FE            	  2292:             bne.s *                       * Check Z Flag  beq/bne
                            	  2293: 
02:00001876 4E75            	  2294:             rts
                            	  2295: 
                            	  2296: 
                            	  2297: *-----------------------------------------------------------
                            	  2298: *-----------------------------------------------------------
                            	  2299: * OPCODE : SUB_I
                            	  2300: *-----------------------------------------------------------
                            	  2301: *-----------------------------------------------------------
                            	  2302: op_SUB_I:
                            	  2303: 
                            	  2304: *     EA = Dn  - Byte
02:00001878 203C12345678    	  2305:             move.l #$12345678,d0      * populate test data
02:0000187E 04000000        	  2306:             subi.b #0,d0
02:00001882 67FE            	  2307:             beq.s *                       * Check Z Flag  beq/bne
02:00001884 6BFE            	  2308:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001886 65FE            	  2309:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001888 69FE            	  2310:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000188A 04000010        	  2311:             subi.b #$10,d0
02:0000188E 67FE            	  2312:             beq.s *                       * Check Z Flag  beq/bne
02:00001890 6BFE            	  2313:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001892 65FE            	  2314:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001894 69FE            	  2315:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001896 040000A5        	  2316:             subi.b #$A5,d0
02:0000189A 67FE            	  2317:             beq.s *                       * Check Z Flag  beq/bne
02:0000189C 6AFE            	  2318:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000189E 64FE            	  2319:             bcc.s *                       * Check C Flag  bcc/bcs
02:000018A0 68FE            	  2320:             bvc.s *                       * Check V Flag  bvc/bvs
02:000018A2 0C0000C3        	  2321:             cmpi.b #$C3,d0
02:000018A6 66FE            	  2322:             bne.s *                       * Check Z Flag  beq/bne
                            	  2323: 
                            	  2324: *     EA = Dn  - WORD
02:000018A8 203C12345678    	  2325:             move.l #$12345678,d0      * populate test data
02:000018AE 04400000        	  2326:             subi.w #0,d0
02:000018B2 67FE            	  2327:             beq.s *                       * Check Z Flag  beq/bne
02:000018B4 6BFE            	  2328:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018B6 65FE            	  2329:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018B8 69FE            	  2330:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018BA 04407000        	  2331:             subi.w #$7000,d0
02:000018BE 67FE            	  2332:             beq.s *                       * Check Z Flag  beq/bne
02:000018C0 6AFE            	  2333:             bpl.s *                       * Check N Flag  bmi/bpl
02:000018C2 64FE            	  2334:             bcc.s *                       * Check C Flag  bcc/bcs
02:000018C4 69FE            	  2335:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018C6 0440A55A        	  2336:             subi.w #$A55A,d0
02:000018CA 67FE            	  2337:             beq.s *                       * Check Z Flag  beq/bne
02:000018CC 6BFE            	  2338:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018CE 65FE            	  2339:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018D0 69FE            	  2340:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018D2 0C40411E        	  2341:             cmpi.w #$411E,d0
02:000018D6 66FE            	  2342:             bne.s *                       * Check Z Flag  beq/bne
                            	  2343: 
                            	  2344: *     EA = Dn  - LONG
02:000018D8 203C12345678    	  2345:             move.l #$12345678,d0      * populate test data
02:000018DE 048000000000    	  2346:             subi.l #0,d0
02:000018E4 67FE            	  2347:             beq.s *                       * Check Z Flag  beq/bne
02:000018E6 6BFE            	  2348:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018E8 65FE            	  2349:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018EA 69FE            	  2350:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018EC 0480F0000000    	  2351:             subi.l #$F0000000,d0
02:000018F2 67FE            	  2352:             beq.s *                       * Check Z Flag  beq/bne
02:000018F4 6BFE            	  2353:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018F6 64FE            	  2354:             bcc.s *                       * Check C Flag  bcc/bcs
02:000018F8 69FE            	  2355:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018FA 0480855AA55A    	  2356:             subi.l #$855AA55A,d0
02:00001900 67FE            	  2357:             beq.s *                       * Check Z Flag  beq/bne
02:00001902 6AFE            	  2358:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001904 64FE            	  2359:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001906 68FE            	  2360:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001908 0480A0000000    	  2361:             subi.l #$A0000000,d0
02:0000190E 69FE            	  2362:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001910 0C80FCD9B11E    	  2363:             cmpi.l #$FCD9B11E,d0
02:00001916 66FE            	  2364:             bne.s *                       * Check Z Flag  beq/bne
                            	  2365: 
                            	  2366: 
                            	  2367: 
                            	  2368: *     EA = x.L  - Byte
02:00001918 207C0000F100    	  2369:             move.l #$F100,a0      * populate test data
02:0000191E 20BC12345678    	  2370:             move.l #$12345678,(a0)     * populate test data
02:00001924 043900000000F103	  2371:             subi.b #0,$F103
02:0000192C 67FE            	  2372:             beq.s *                       * Check Z Flag  beq/bne
02:0000192E 6BFE            	  2373:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001930 65FE            	  2374:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001932 69FE            	  2375:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001934 043900100000F103	  2376:             subi.b #$10,$F103
02:0000193C 67FE            	  2377:             beq.s *                       * Check Z Flag  beq/bne
02:0000193E 6BFE            	  2378:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001940 65FE            	  2379:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001942 69FE            	  2380:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001944 043900A50000F103	  2381:             subi.b #$A5,$F103
02:0000194C 67FE            	  2382:             beq.s *                       * Check Z Flag  beq/bne
02:0000194E 6AFE            	  2383:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001950 64FE            	  2384:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001952 68FE            	  2385:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001954 0C3900C30000F103	  2386:             cmpi.b #$C3,$F103
02:0000195C 66FE            	  2387:             bne.s *                       * Check Z Flag  beq/bne
                            	  2388: 
                            	  2389: *     EA = x.L- WORD
02:0000195E 207C0000F100    	  2390:             move.l #$F100,a0      * populate test data
02:00001964 20BC12345678    	  2391:             move.l #$12345678,(a0)     * populate test data
02:0000196A 047900000000F100	  2392:             subi.w #0,$F100
02:00001972 67FE            	  2393:             beq.s *                       * Check Z Flag  beq/bne
02:00001974 6BFE            	  2394:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001976 65FE            	  2395:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001978 69FE            	  2396:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000197A 047970000000F100	  2397:             subi.w #$7000,$F100
02:00001982 67FE            	  2398:             beq.s *                       * Check Z Flag  beq/bne
02:00001984 6AFE            	  2399:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001986 64FE            	  2400:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001988 69FE            	  2401:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000198A 0479A55A0000F100	  2402:             subi.w #$A55A,$F100
02:00001992 67FE            	  2403:             beq.s *                       * Check Z Flag  beq/bne
02:00001994 6AFE            	  2404:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001996 64FE            	  2405:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001998 69FE            	  2406:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000199A 0C79FCDA0000F100	  2407:             cmpi.w #$FCDA,$F100
02:000019A2 66FE            	  2408:             bne.s *                       * Check Z Flag  beq/bne
                            	  2409: 
                            	  2410: *     EA = x.L- LONG
02:000019A4 23FC123456780000	  2411:             move.l #$12345678,$F100  * populate test data
02:000019AC F100
02:000019AE 04B9000000000000	  2412:             subi.l #0,$F100
02:000019B6 F100
02:000019B8 67FE            	  2413:             beq.s *                       * Check Z Flag  beq/bne
02:000019BA 6BFE            	  2414:             bmi.s *                       * Check N Flag  bmi/bpl
02:000019BC 65FE            	  2415:             bcs.s *                       * Check C Flag  bcc/bcs
02:000019BE 69FE            	  2416:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019C0 04B9F00000000000	  2417:             subi.l #$F0000000,$F100
02:000019C8 F100
02:000019CA 67FE            	  2418:             beq.s *                       * Check Z Flag  beq/bne
02:000019CC 6BFE            	  2419:             bmi.s *                       * Check N Flag  bmi/bpl
02:000019CE 64FE            	  2420:             bcc.s *                       * Check C Flag  bcc/bcs
02:000019D0 69FE            	  2421:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019D2 04B9855AA55A0000	  2422:             subi.l #$855AA55A,$F100
02:000019DA F100
02:000019DC 67FE            	  2423:             beq.s *                       * Check Z Flag  beq/bne
02:000019DE 6AFE            	  2424:             bpl.s *                       * Check N Flag  bmi/bpl
02:000019E0 64FE            	  2425:             bcc.s *                       * Check C Flag  bcc/bcs
02:000019E2 68FE            	  2426:             bvc.s *                       * Check V Flag  bvc/bvs
02:000019E4 04B9A00000000000	  2427:             subi.l #$A0000000,$F100
02:000019EC F100
02:000019EE 69FE            	  2428:             bvs.s *                       * Check V Flag  bvc/bvs
02:000019F0 0CB9FCD9B11E0000	  2429:             cmpi.l #$FCD9B11E,$F100
02:000019F8 F100
02:000019FA 66FE            	  2430:             bne.s *                       * Check Z Flag  beq/bne
                            	  2431: 
02:000019FC 4E75            	  2432:             rts
                            	  2433: 
                            	  2434: 
                            	  2435: 
                            	  2436: *-----------------------------------------------------------
                            	  2437: *-----------------------------------------------------------
                            	  2438: * OPCODE : MOVE
                            	  2439: *-----------------------------------------------------------
                            	  2440: *-----------------------------------------------------------
                            	  2441: op_MOVE:
02:000019FE 203C11223344    	  2442:             move.l #$11223344,d0
02:00001A04 223C55667788    	  2443:             move.l #$55667788,d1
02:00001A0A 243C8899AABB    	  2444:             move.l #$8899aabb,d2
02:00001A10 263CCCDDEEFF    	  2445:             move.l #$ccddeeff,d3
02:00001A16 7800            	  2446:             moveq  #$00000000,d4
02:00001A18 7A00            	  2447:             moveq  #$00000000,d5
02:00001A1A 7C00            	  2448:             moveq  #$00000000,d6
02:00001A1C 7E00            	  2449:             moveq  #$00000000,d7
02:00001A1E 207C44332211    	  2450:             move.l #$44332211,a0
02:00001A24 227C88776655    	  2451:             move.l #$88776655,a1
02:00001A2A 247CBBAA9988    	  2452:             move.l #$bbaa9988,a2
02:00001A30 267CFFEEDDCC    	  2453:             move.l #$ffeeddcc,a3
                            	  2454: 
02:00001A36 1800            	  2455:             move.b d0,d4              * BYTE - DATA REGISTER
02:00001A38 67FE            	  2456:             beq.s *                       * Check Z Flag  beq/bne
02:00001A3A 6BFE            	  2457:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A3C 0C8400000044    	  2458:             cmpi.l #$00000044,d4
02:00001A42 66FE            	  2459:             bne.s *                       * Check Z Flag  beq/bne
                            	  2460: 
02:00001A44 3A01            	  2461:             move.w d1,d5              * WORD - DATA REGISTER
02:00001A46 67FE            	  2462:             beq.s *                       * Check Z Flag  beq/bne
02:00001A48 6BFE            	  2463:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A4A 0C8500007788    	  2464:             cmpi.l #$00007788,d5
02:00001A50 66FE            	  2465:             bne.s *                       * Check Z Flag  beq/bne
                            	  2466: 
02:00001A52 2C02            	  2467:             move.l d2,d6              * LONG - DATA REGISTER
02:00001A54 67FE            	  2468:             beq.s *                       * Check Z Flag  beq/bne
02:00001A56 6AFE            	  2469:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001A58 0C868899AABB    	  2470:             cmpi.l #$8899aabb,d6
02:00001A5E 66FE            	  2471:             bne.s *                       * Check Z Flag  beq/bne
                            	  2472: 
02:00001A60 3A09            	  2473:             move.w a1,d5              * WORD - ADDRESS REGISTER
02:00001A62 67FE            	  2474:             beq.s *                       * Check Z Flag  beq/bne
02:00001A64 6BFE            	  2475:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A66 0C8500006655    	  2476:             cmpi.l #$00006655,d5
02:00001A6C 66FE            	  2477:             bne.s *                       * Check Z Flag  beq/bne
                            	  2478: 
02:00001A6E 2C0A            	  2479:             move.l a2,d6              * LONG - ADDRESS REGISTER
02:00001A70 67FE            	  2480:             beq.s *                       * Check Z Flag  beq/bne
02:00001A72 6AFE            	  2481:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001A74 0C86BBAA9988    	  2482:             cmpi.l #$bbaa9988,d6
02:00001A7A 66FE            	  2483:             bne.s *                       * Check Z Flag  beq/bne
                            	  2484: 
                            	  2485: 
02:00001A7C 3842            	  2486:             movea.w d2,a4             * WORD - ADDRESS REGISTER as SOURCE ## MOVEA
02:00001A7E B9C2            	  2487:             cmpa.l d2,a4
02:00001A80 67FE            	  2488:             beq.s *                       * Check Z Flag  beq/bne ## comopare fails because A4 was sign extended
                            	  2489: 
02:00001A82 2A41            	  2490:             movea.l d1,a5             * LONG - ADDRESS REGISTER as SOURCE ## MOVEA
02:00001A84 BBC1            	  2491:             cmpa.l d1,a5
02:00001A86 66FE            	  2492:             bne.s *                       * Check Z Flag  beq/bne
                            	  2493: 
                            	  2494: 
                            	  2495: 
                            	  2496: *   Too mamy EA combinations to test,so we focus on a few of the more complicted EA's
                            	  2497: 
02:00001A88 203C11223344    	  2498:             move.l #$11223344,d0
02:00001A8E 223C00010100    	  2499:             move.l #$00010100,d1
02:00001A94 243C8899AABB    	  2500:             move.l #$8899aabb,d2
02:00001A9A 7601            	  2501:             moveq  #$00000001,d3
02:00001A9C 7800            	  2502:             moveq  #$00000000,d4
02:00001A9E 7A00            	  2503:             moveq  #$00000000,d5
02:00001AA0 7C00            	  2504:             moveq  #$00000000,d6
02:00001AA2 7E00            	  2505:             moveq  #$00000000,d7
02:00001AA4 91C8            	  2506:             move.l #$00000000,a0
02:00001AA6 227C00010100    	  2507:             move.l #$00010100,a1
                            	  2508: 
                            	  2509: *     x(An,AL) --> x.L
02:00001AAC 11BC005A9804    	  2510:             move.b #$5A,4(a0,a1.l)    * BYTE
02:00001AB2 47F09804        	  2511:             lea 4(a0,a1.l),a3
02:00001AB6 13F0980400010105	  2512:             move.b 4(a0,a1.l),$00010105
02:00001ABE 67FE            	  2513:             beq.s *                       * Check Z Flag  beq/bne
02:00001AC0 6BFE            	  2514:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001AC2 0C30005A9805    	  2515:             cmpi.b #$5A,5(a0,a1.l)
02:00001AC8 66FE            	  2516:             bne.s *                       * Check Z Flag  beq/bne
                            	  2517: 
                            	  2518: *     x.L --> n(An,Dw)
02:00001ACA 11B9000101051007	  2519: MOVE2:      move.b  $00010105,7(a0,d1.w)    * BYTE
02:00001AD2 67FE            	  2520:             beq.s *                       * Check Z Flag  beq/bne
02:00001AD4 6BFE            	  2521:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001AD6 0C30005A1007    	  2522:             cmpi.b #$5A,7(a0,d1.w)
02:00001ADC 66FE            	  2523:             bne.s *                       * Check Z Flag  beq/bne
                            	  2524: 
                            	  2525: *     x(PC,Ds) --> x.w
02:00001ADE 11FB30660100    	  2526:             move.b  MOVE1(pc,d3.w),$0100 * BYTE
02:00001AE4 67FE            	  2527:             beq.s *                       * Check Z Flag  beq/bne
02:00001AE6 6AFE            	  2528:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001AE8 0C3900B900001ACB	  2529:             cmpi.b #$B9,1+MOVE2
02:00001AF0 66FE            	  2530:             bne.s *                       * Check Z Flag  beq/bne
                            	  2531: 
                            	  2532: *     #x -->    n(An,AL)
02:00001AF2 11BC00781007    	  2533:             move.b  #$78,7(a0,d1.w)    * BYTE
02:00001AF8 67FE            	  2534:             beq.s *                       * Check Z Flag  beq/bne
02:00001AFA 6BFE            	  2535:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001AFC 0C3000781007    	  2536:             cmpi.b #$78,7(a0,d1.w)
02:00001B02 66FE            	  2537:             bne.s *                       * Check Z Flag  beq/bne
                            	  2538: 
02:00001B04 203C11223344    	  2539:             move.l #$11223344,d0
02:00001B0A 223C00010100    	  2540:             move.l #$00010100,d1
02:00001B10 243C8899AABB    	  2541:             move.l #$8899aabb,d2
02:00001B16 7602            	  2542:             moveq  #$00000002,d3
02:00001B18 7800            	  2543:             moveq  #$00000000,d4
02:00001B1A 7A00            	  2544:             moveq  #$00000000,d5
02:00001B1C 7C00            	  2545:             moveq  #$00000000,d6
02:00001B1E 7E00            	  2546:             moveq  #$00000000,d7
02:00001B20 91C8            	  2547:             move.l #$00000000,a0
02:00001B22 227C00010100    	  2548:             move.l #$00010100,a1
                            	  2549: 
                            	  2550: *     x(An,AL) --> x.L
02:00001B28 31BC5A5A9804    	  2551:             move.w #$5A5A,4(a0,a1.l)    * WORD
02:00001B2E 49F09804        	  2552:             lea 4(a0,a1.l),a4
02:00001B32 33F0980400010104	  2553:             move.w 4(a0,a1.l),$00010104
02:00001B3A 67FE            	  2554:             beq.s *                       * Check Z Flag  beq/bne
02:00001B3C 6BFE            	  2555:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B3E 0C705A5A9804    	  2556:             cmpi.w #$5A5A,4(a0,a1.l)
02:00001B44 66FE            	  2557:             bne.s *                       * Check Z Flag  beq/bne
                            	  2558: 
                            	  2559: *     x.L --> n(An,Dw)
02:00001B46 31B9000101041006	  2560: MOVE1:      move.w  $00010104,6(a0,d1.w)    * WORD
02:00001B4E 67FE            	  2561:             beq.s *                       * Check Z Flag  beq/bne
02:00001B50 6BFE            	  2562:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B52 0C705A5A1006    	  2563:             cmpi.w #$5A5A,6(a0,d1.w)
02:00001B58 66FE            	  2564:             bne.s *                       * Check Z Flag  beq/bne
                            	  2565: 
                            	  2566: *     x(PC,Ds) --> x.w
02:00001B5A 31FB30EA0100    	  2567:             move.w  MOVE1(pc,d3),$0100 * WORD
02:00001B60 67FE            	  2568:             beq.s *                       * Check Z Flag  beq/bne
02:00001B62 6BFE            	  2569:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B64 0C7967FE00001B4E	  2570:             cmpi.w #$67FE,8+MOVE1
02:00001B6C 66FE            	  2571:             bne.s *                       * Check Z Flag  beq/bne
                            	  2572: 
                            	  2573: *     #x -->    n(An,AL)
02:00001B6E 31BC78781006    	  2574:             move.w  #$7878,6(a0,d1.w)    * WORD
02:00001B74 67FE            	  2575:             beq.s *                       * Check Z Flag  beq/bne
02:00001B76 6BFE            	  2576:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B78 0C7078781006    	  2577:             cmpi.w #$7878,6(a0,d1.w)
02:00001B7E 66FE            	  2578:             bne.s *                       * Check Z Flag  beq/bne
                            	  2579: 
                            	  2580: * ---
                            	  2581: 
02:00001B80 203C11223344    	  2582:             move.l #$11223344,d0
02:00001B86 223C00010100    	  2583:             move.l #$00010100,d1
02:00001B8C 243C8899AABB    	  2584:             move.l #$8899aabb,d2
02:00001B92 7602            	  2585:             moveq  #$00000002,d3
02:00001B94 7800            	  2586:             moveq  #$00000000,d4
02:00001B96 7A00            	  2587:             moveq  #$00000000,d5
02:00001B98 7C00            	  2588:             moveq  #$00000000,d6
02:00001B9A 7E00            	  2589:             moveq  #$00000000,d7
02:00001B9C 91C8            	  2590:             move.l #$00000000,a0
02:00001B9E 227C00010100    	  2591:             move.l #$00010100,a1
                            	  2592: 
                            	  2593: *     x(An,AL) --> x.L
02:00001BA4 21BC5A5A12349804	  2594:             move.l #$5A5A1234,4(a0,a1.l)    * LONG
02:00001BAC 49F09804        	  2595:             lea 4(a0,a1.l),a4
02:00001BB0 23F0980400010104	  2596:             move.l 4(a0,a1.l),$00010104
02:00001BB8 67FE            	  2597:             beq.s *                       * Check Z Flag  beq/bne
02:00001BBA 6BFE            	  2598:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001BBC 0CB05A5A12349804	  2599:             cmpi.l #$5A5A1234,4(a0,a1.l)
02:00001BC4 66FE            	  2600:             bne.s *                       * Check Z Flag  beq/bne
                            	  2601: 
                            	  2602: *     x.L --> n(An,Dw)
02:00001BC6 21B9000101041006	  2603: MOVE3:      move.l  $00010104,6(a0,d1.w)    * LONG
02:00001BCE 67FE            	  2604:             beq.s *                       * Check Z Flag  beq/bne
02:00001BD0 6BFE            	  2605:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001BD2 0CB05A5A12341006	  2606:             cmpi.l #$5A5A1234,6(a0,d1.w)
02:00001BDA 66FE            	  2607:             bne.s *                       * Check Z Flag  beq/bne
                            	  2608: 
                            	  2609: *     x(PC,Ds) --> x.w
02:00001BDC 21FB30E80100    	  2610:             move.l  MOVE3(pc,d3),$0100 * LONG
02:00001BE2 67FE            	  2611:             beq.s *                       * Check Z Flag  beq/bne
02:00001BE4 6BFE            	  2612:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001BE6 0CB967FE6BFE0000	  2613:             cmpi.l #$67FE6BFE,8+MOVE3
02:00001BEE 1BCE
02:00001BF0 66FE            	  2614:             bne.s *                       * Check Z Flag  beq/bne
                            	  2615: 
                            	  2616: *     #x -->    n(An,AL)
02:00001BF2 21BC787823231006	  2617:             move.l  #$78782323,6(a0,d1.w)    * LONG
02:00001BFA 67FE            	  2618:             beq.s *                       * Check Z Flag  beq/bne
02:00001BFC 6BFE            	  2619:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001BFE 0CB0787823231006	  2620:             cmpi.l #$78782323,6(a0,d1.w)
02:00001C06 66FE            	  2621:             bne.s *                       * Check Z Flag  beq/bne
                            	  2622: 
                            	  2623: 
02:00001C08 4E75            	  2624:          rts
                            	  2625: 
                            	  2626: 
                            	  2627: *-----------------------------------------------------------
                            	  2628: *-----------------------------------------------------------
                            	  2629: * OPCODE : MOVE_xxx_FLAGS
                            	  2630: *-----------------------------------------------------------
                            	  2631: *-----------------------------------------------------------
                            	  2632: op_MOVE_xxx_FLAGS:
                            	  2633: 
                            	  2634: *     Move_To_SR
                            	  2635: 
                            	  2636: *     Dn
                            	  2637: 
02:00001C0A 303C2FFF        	  2638:             move.w #$2FFF,d0
02:00001C0E 46C0            	  2639:             move.w d0,SR
02:00001C10 6AFE            	  2640:             bpl.s *           * branch if Z clear
02:00001C12 66FE            	  2641:             bne.s *           * branch if N clear
02:00001C14 68FE            	  2642:             bvc.s *           * branch if V clear
02:00001C16 64FE            	  2643:             bcc.s *           * branch if C clear
02:00001C18 303C2F00        	  2644:             move.w #$2F00,d0
02:00001C1C 44C0            	  2645:             move d0,CCR
02:00001C1E 67FE            	  2646:             beq.s *           * branch if Z set
02:00001C20 6BFE            	  2647:             bmi.s *           * branch if N set
02:00001C22 69FE            	  2648:             bvs.s *           * branch if V set
02:00001C24 65FE            	  2649:             bcs.s *           * branch if C set
                            	  2650: 
02:00001C26 303C2000        	  2651:             move.w #$2000,d0
02:00001C2A 46C0            	  2652:             move.w d0,SR
02:00001C2C 67FE            	  2653:             beq.s *           * branch if Z set
02:00001C2E 6BFE            	  2654:             bmi.s *           * branch if N set
02:00001C30 69FE            	  2655:             bvs.s *           * branch if V set
02:00001C32 65FE            	  2656:             bcs.s *           * branch if C set
                            	  2657: 
                            	  2658: *     (An)
02:00001C34 307C0100        	  2659:             move.l #$00000100,a0
02:00001C38 30BC2FFF        	  2660:             move.w #$2FFF,(a0)
02:00001C3C 46D0            	  2661:             move.w (a0),SR
02:00001C3E 6AFE            	  2662:             bpl.s *           * branch if Z clear
02:00001C40 66FE            	  2663:             bne.s *           * branch if N clear
02:00001C42 68FE            	  2664:             bvc.s *           * branch if V clear
02:00001C44 64FE            	  2665:             bcc.s *           * branch if C clear
                            	  2666: 
02:00001C46 30BC2000        	  2667:             move.w #$2000,(a0)
02:00001C4A 46D0            	  2668:             move.w (a0),SR
02:00001C4C 67FE            	  2669:             beq.s *           * branch if Z set
02:00001C4E 6BFE            	  2670:             bmi.s *           * branch if N set
02:00001C50 69FE            	  2671:             bvs.s *           * branch if V set
02:00001C52 65FE            	  2672:             bcs.s *           * branch if C set
                            	  2673: 
                            	  2674: *     (An)+
02:00001C54 307C0100        	  2675:             move.l #$00000100,a0
02:00001C58 30BC2FFF        	  2676:             move.w #$2FFF,(a0)
02:00001C5C 46D8            	  2677:             move.w (a0)+,SR
02:00001C5E 6AFE            	  2678:             bpl.s *           * branch if Z clear
02:00001C60 66FE            	  2679:             bne.s *           * branch if N clear
02:00001C62 68FE            	  2680:             bvc.s *           * branch if V clear
02:00001C64 64FE            	  2681:             bcc.s *           * branch if C clear
                            	  2682: 
02:00001C66 30BC2000        	  2683:             move.w #$2000,(a0)
02:00001C6A 46D8            	  2684:             move.w (a0)+,SR
02:00001C6C 67FE            	  2685:             beq.s *           * branch if Z set
02:00001C6E 6BFE            	  2686:             bmi.s *           * branch if N set
02:00001C70 69FE            	  2687:             bvs.s *           * branch if V set
02:00001C72 65FE            	  2688:             bcs.s *           * branch if C set
                            	  2689: 
                            	  2690: *     -(An)
02:00001C74 307C0102        	  2691:             move.l #$00000102,a0
02:00001C78 30BC2FFF        	  2692:             move.w #$2FFF,(a0)
02:00001C7C 46D8            	  2693:             move.w (a0)+,SR
02:00001C7E 6AFE            	  2694:             bpl.s *           * branch if Z clear
02:00001C80 66FE            	  2695:             bne.s *           * branch if N clear
02:00001C82 68FE            	  2696:             bvc.s *           * branch if V clear
02:00001C84 64FE            	  2697:             bcc.s *           * branch if C clear
                            	  2698: 
02:00001C86 30BC2000        	  2699:             move.w #$2000,(a0)
02:00001C8A 46D8            	  2700:             move.w (a0)+,SR
02:00001C8C 67FE            	  2701:             beq.s *           * branch if Z set
02:00001C8E 6BFE            	  2702:             bmi.s *           * branch if N set
02:00001C90 69FE            	  2703:             bvs.s *           * branch if V set
02:00001C92 65FE            	  2704:             bcs.s *           * branch if C set
                            	  2705: 
                            	  2706: *     n(An)
02:00001C94 307C0102        	  2707:             move.l #$00000102,a0
02:00001C98 317C2FFF0002    	  2708:             move.w #$2FFF,2(a0)
02:00001C9E 46E80002        	  2709:             move.w 2(a0),SR
02:00001CA2 6AFE            	  2710:             bpl.s *           * branch if Z clear
02:00001CA4 66FE            	  2711:             bne.s *           * branch if N clear
02:00001CA6 68FE            	  2712:             bvc.s *           * branch if V clear
02:00001CA8 64FE            	  2713:             bcc.s *           * branch if C clear
                            	  2714: 
02:00001CAA 317C20000002    	  2715:             move.w #$2000,2(a0)
02:00001CB0 46E80002        	  2716:             move.w 2(a0),SR
02:00001CB4 67FE            	  2717:             beq.s *           * branch if Z set
02:00001CB6 6BFE            	  2718:             bmi.s *           * branch if N set
02:00001CB8 69FE            	  2719:             bvs.s *           * branch if V set
02:00001CBA 65FE            	  2720:             bcs.s *           * branch if C set
                            	  2721: 
                            	  2722: *     n(An,Rn.l)
02:00001CBC 307C0100        	  2723:             move.l #$00000100,a0
02:00001CC0 7002            	  2724:             moveq  #$00000002,d0
02:00001CC2 31BC2FFF0802    	  2725:             move.w #$2FFF,2(a0,d0.l)
02:00001CC8 46F00802        	  2726:             move.w 2(a0,d0.l),SR
02:00001CCC 6AFE            	  2727:             bpl.s *           * branch if Z clear
02:00001CCE 66FE            	  2728:             bne.s *           * branch if N clear
02:00001CD0 68FE            	  2729:             bvc.s *           * branch if V clear
02:00001CD2 64FE            	  2730:             bcc.s *           * branch if C clear
                            	  2731: 
02:00001CD4 31BC20000802    	  2732:             move.w #$2000,2(a0,d0.l)
02:00001CDA 46F00802        	  2733:             move.w 2(a0,d0.l),SR
02:00001CDE 67FE            	  2734:             beq.s *           * branch if Z set
02:00001CE0 6BFE            	  2735:             bmi.s *           * branch if N set
02:00001CE2 69FE            	  2736:             bvs.s *           * branch if V set
02:00001CE4 65FE            	  2737:             bcs.s *           * branch if C set
                            	  2738: 
                            	  2739: *     x.W
02:00001CE6 31FC2FFF0100    	  2740:             move.w #$2FFF,$0100
02:00001CEC 46F80100        	  2741:             move.w $0100,SR
02:00001CF0 6AFE            	  2742:             bpl.s *           * branch if Z clear
02:00001CF2 66FE            	  2743:             bne.s *           * branch if N clear
02:00001CF4 68FE            	  2744:             bvc.s *           * branch if V clear
02:00001CF6 64FE            	  2745:             bcc.s *           * branch if C clear
                            	  2746: 
02:00001CF8 31FC20000100    	  2747:             move.w #$2000,$0100
02:00001CFE 46F80100        	  2748:             move.w $0100,SR
02:00001D02 67FE            	  2749:             beq.s *           * branch if Z set
02:00001D04 6BFE            	  2750:             bmi.s *           * branch if N set
02:00001D06 69FE            	  2751:             bvs.s *           * branch if V set
02:00001D08 65FE            	  2752:             bcs.s *           * branch if C set
                            	  2753: 
                            	  2754: *     x.L
02:00001D0A 33FC2FFF00010100	  2755:             move.w #$2FFF,$00010100
02:00001D12 46F900010100    	  2756:             move.w $00010100,SR
02:00001D18 6AFE            	  2757:             bpl.s *           * branch if Z clear
02:00001D1A 66FE            	  2758:             bne.s *           * branch if N clear
02:00001D1C 68FE            	  2759:             bvc.s *           * branch if V clear
02:00001D1E 64FE            	  2760:             bcc.s *           * branch if C clear
                            	  2761: 
02:00001D20 33FC200000010100	  2762: MOVE4:      move.w #$2000,$00010100
02:00001D28 46F900010100    	  2763:             move.w $00010100,SR
02:00001D2E 67FE            	  2764:             beq.s *           * branch if Z set
02:00001D30 6BFE            	  2765:             bmi.s *           * branch if N set
02:00001D32 69FE            	  2766:             bvs.s *           * branch if V set
02:00001D34 65FE            	  2767:             bcs.s *           * branch if C set
                            	  2768: 
                            	  2769: *     x(PC)
02:00001D36 46FAFFEA        	  2770:             move.w MOVE4+2(pc),SR
02:00001D3A 67FE            	  2771:             beq.s *           * branch if Z set
02:00001D3C 6BFE            	  2772:             bmi.s *           * branch if N set
02:00001D3E 69FE            	  2773:             bvs.s *           * branch if V set
02:00001D40 65FE            	  2774:             bcs.s *           * branch if C set
                            	  2775: 
                            	  2776: *     x(PC,d0.l)
02:00001D42 7000            	  2777:             moveq  #$00000000,d0
02:00001D44 46FB08DC        	  2778:             move.w MOVE4+2(pc,d0.l),SR
02:00001D48 67FE            	  2779:             beq.s *           * branch if Z set
02:00001D4A 6BFE            	  2780:             bmi.s *           * branch if N set
02:00001D4C 69FE            	  2781:             bvs.s *           * branch if V set
02:00001D4E 65FE            	  2782:             bcs.s *           * branch if C set
02:00001D50 44FB08D0        	  2783:             move MOVE4+2(pc,d0.l),CCR
02:00001D54 67FE            	  2784:             beq.s *           * branch if Z set
02:00001D56 6BFE            	  2785:             bmi.s *           * branch if N set
02:00001D58 69FE            	  2786:             bvs.s *           * branch if V set
02:00001D5A 65FE            	  2787:             bcs.s *           * branch if C set
                            	  2788: 
                            	  2789: *     #x
02:00001D5C 46FC2FFF        	  2790:             move.w #$2FFF,SR
02:00001D60 66FE            	  2791:             bne.s *           * branch if Z clear
02:00001D62 6AFE            	  2792:             bpl.s *           * branch if N clear
02:00001D64 68FE            	  2793:             bvc.s *           * branch if V clear
02:00001D66 64FE            	  2794:             bcc.s *           * branch if C clear
                            	  2795: 
                            	  2796: 
                            	  2797: 
                            	  2798: *  MOVE_From_SR
                            	  2799: 
                            	  2800: 
                            	  2801: 
                            	  2802: *     Dn
02:00001D68 46FC275A        	  2803:             move.w #$275A,SR          * Initial value
02:00001D6C 40C0            	  2804:             move.w SR,d0
02:00001D6E 0C40271A        	  2805:             cmpi.w #$271A,d0
                            	  2806: * The following fails because sr bits are implemented and non-zero so later code works.           
                            	  2807: *            bne.s *                   * branch if Z set
                            	  2808: 
                            	  2809: *     (An)
02:00001D72 307C0100        	  2810:             move.l #$00000100,a0
02:00001D76 46FC275A        	  2811:             move.w #$275A,SR          * Initial value
02:00001D7A 40D0            	  2812:             move.w SR,(a0)
02:00001D7C 0C50275A        	  2813:             cmpi.w #$275A,(a0)
02:00001D80 66FE            	  2814:             bne.s *                   * branch if Z set
                            	  2815: 
                            	  2816: *     (An)+
02:00001D82 307C0100        	  2817:             move.l #$00000100,a0
02:00001D86 46FC257A        	  2818:             move.w #$257A,SR          * Initial value
02:00001D8A 40D8            	  2819:             move.w SR,(a0)+
02:00001D8C 307C0100        	  2820:             move.l #$00000100,a0
02:00001D90 0C58257A        	  2821:             cmpi.w #$257A,(a0)+
02:00001D94 66FE            	  2822:             bne.s *                   * branch if Z set
                            	  2823: 
                            	  2824: *     -(An)
02:00001D96 307C0102        	  2825:             move.l #$00000102,a0
02:00001D9A 46FC2766        	  2826:             move.w #$2766,SR          * Initial value
02:00001D9E 40E0            	  2827:             move.w SR,-(a0)
02:00001DA0 307C0100        	  2828:             move.l #$00000100,a0
02:00001DA4 0C502766        	  2829:             cmpi.w #$2766,(a0)
02:00001DA8 66FE            	  2830:             bne.s *                   * branch if Z set
                            	  2831: 
                            	  2832: *     x(An)
02:00001DAA 307C0102        	  2833:             move.l #$00000102,a0
02:00001DAE 46FC2733        	  2834:             move.w #$2733,SR          * Initial value
02:00001DB2 40E80004        	  2835:             move.w SR,4(a0)
02:00001DB6 0C6827330004    	  2836:             cmpi.w #$2733,4(a0)
02:00001DBC 66FE            	  2837:             bne.s *                   * branch if Z set
                            	  2838: 
                            	  2839: *     x(An,rn)
02:00001DBE 307C0102        	  2840:             move.l #$00000102,a0
02:00001DC2 7004            	  2841:             moveq  #$00000004,d0
02:00001DC4 46FC275A        	  2842:             move.w #$275a,SR          * Initial value
02:00001DC8 40F00804        	  2843:             move.w SR,4(a0,d0.l)
02:00001DCC 0C70275A0804    	  2844:             cmpi.w #$275a,4(a0,d0.l)
02:00001DD2 66FE            	  2845:             bne.s *                   * branch if Z set
                            	  2846: 
                            	  2847: *     x.W
02:00001DD4 46FC2777        	  2848:             move.w #$2777,SR          * Initial value
02:00001DD8 40F80102        	  2849:             move.w SR,$0102
02:00001DDC 0C7827770102    	  2850:             cmpi.w #$2777,$0102
02:00001DE2 66FE            	  2851:             bne.s *                   * branch if Z set
                            	  2852: 
                            	  2853: *     x.L
02:00001DE4 46FC2777        	  2854:             move.w #$2777,SR          * Initial value
02:00001DE8 40F900010102    	  2855:             move.w SR,$10102
02:00001DEE 0C79277700010102	  2856:             cmpi.w #$2777,$10102
02:00001DF6 66FE            	  2857:             bne.s *                   * branch if Z set
                            	  2858: 
                            	  2859: 
                            	  2860: 
02:00001DF8 46FC2700        	  2861:             move.w #$2700,SR          * Put flags back to initial value
                            	  2862: 
02:00001DFC 4E75            	  2863:             rts
                            	  2864: 
                            	  2865: 
                            	  2866: *-----------------------------------------------------------
                            	  2867: *-----------------------------------------------------------
                            	  2868: * OPCODE : EXT
                            	  2869: *-----------------------------------------------------------
                            	  2870: *-----------------------------------------------------------
                            	  2871: op_EXT:
                            	  2872: 
02:00001DFE 707F            	  2873:             move.l #$0000007F,d0
02:00001E00 223C00008FFF    	  2874:             move.l #$00008FFF,d1
02:00001E06 7400            	  2875:             moveq  #$00000000,d2
                            	  2876: 
02:00001E08 4880            	  2877:             ext.w d0
02:00001E0A 6BFE            	  2878:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001E0C 67FE            	  2879:             beq.s *                   * Check Z Flag  beq/bne
02:00001E0E 0C800000007F    	  2880:             cmpi.l #$0000007F,d0
02:00001E14 66FE            	  2881:             bne.s *                   * branch if Z set
                            	  2882: 
02:00001E16 48C1            	  2883:             ext.l d1
02:00001E18 6AFE            	  2884:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001E1A 67FE            	  2885:             beq.s *                   * Check Z Flag  beq/bne
02:00001E1C 0C81FFFF8FFF    	  2886:             cmpi.l #$FFFF8FFF,d1
02:00001E22 66FE            	  2887:             bne.s *                   * branch if Z set
                            	  2888: 
02:00001E24 48C2            	  2889:             ext.l d2
02:00001E26 66FE            	  2890:             bne.s *                   * Check Z Flag  beq/bne
                            	  2891: 
                            	  2892: 
                            	  2893: 
02:00001E28 4E75            	  2894:             rts
                            	  2895: 
                            	  2896: 
                            	  2897: *-----------------------------------------------------------
                            	  2898: *-----------------------------------------------------------
                            	  2899: * OPCODE : SWAP
                            	  2900: *-----------------------------------------------------------
                            	  2901: *-----------------------------------------------------------
                            	  2902: op_SWAP:
                            	  2903: 
02:00001E2A 203C12345678    	  2904:             move.l #$12345678,d0
                            	  2905: 
02:00001E30 4840            	  2906:             swap d0
02:00001E32 6BFE            	  2907:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001E34 67FE            	  2908:             beq.s *                   * Check Z Flag  beq/bne
02:00001E36 0C8056781234    	  2909:             cmpi.l #$56781234,d0
02:00001E3C 66FE            	  2910:             bne.s *                   * branch if Z set
                            	  2911: 
                            	  2912: 
                            	  2913: 
02:00001E3E 4E75            	  2914:             rts
                            	  2915: 
                            	  2916: 
                            	  2917: *-----------------------------------------------------------
                            	  2918: *-----------------------------------------------------------
                            	  2919: * OPCODE : LEA_PEA
                            	  2920: *-----------------------------------------------------------
                            	  2921: *-----------------------------------------------------------
                            	  2922: op_LEAPEA:
                            	  2923: 
02:00001E40 207C00345678    	  2924:             move.l #$00345678,a0
02:00001E46 7800            	  2925:             moveq  #$00000000,d4
                            	  2926: 
                            	  2927: *     (An)
02:00001E48 4DD0            	  2928:             lea (a0),a6
02:00001E4A 200E            	  2929:             move.l a6,d0
02:00001E4C 0C8000345678    	  2930:             cmpi.l #$00345678,d0
02:00001E52 66FE            	  2931:             bne.s *                   * branch if Z set
02:00001E54 4850            	  2932:             pea (a0)
02:00001E56 0C9700345678    	  2933:             cmpi.l #$00345678,(a7)
02:00001E5C 66FE            	  2934:             bne.s *                   * branch if Z set
                            	  2935:             * This was without a specifier which the assembler defaulted to .w
02:00001E5E 588F            	  2936:             addq.l #4,a7            * Restore Stack Pointer
                            	  2937: 
                            	  2938: *     x(An)
02:00001E60 4DE80004        	  2939:             lea 4(a0),a6
02:00001E64 200E            	  2940:             move.l a6,d0
02:00001E66 0C800034567C    	  2941:             cmpi.l #$0034567C,d0
02:00001E6C 66FE            	  2942:             bne.s *                   * branch if Z set
02:00001E6E 48680004        	  2943:             pea 4(a0)
02:00001E72 0C970034567C    	  2944:             cmpi.l #$0034567C,(a7)
02:00001E78 66FE            	  2945:             bne.s *                   * branch if Z set
                            	  2946:             * This was without a specifier which the assembler defaulted to .w
02:00001E7A 588F            	  2947:             addq.l #4,a7            * Restore Stack Pointer
                            	  2948: 
                            	  2949: *     x(An,Dn.l)
02:00001E7C 4DF04004        	  2950:             lea 4(a0,d4),a6
02:00001E80 200E            	  2951:             move.l a6,d0
02:00001E82 0C800034567C    	  2952:             cmpi.l #$0034567C,d0
02:00001E88 66FE            	  2953:             bne.s *                   * branch if Z set
02:00001E8A 48704804        	  2954:             pea 4(a0,d4.l)
02:00001E8E 0C970034567C    	  2955:             cmpi.l #$0034567C,(a7)
02:00001E94 66FE            	  2956:             bne.s *                   * branch if Z set
                            	  2957:             * This was without a specifier which the assembler defaulted to .w
02:00001E96 588F            	  2958:             addq.l #4,a7            * Restore Stack Pointer
                            	  2959: 
                            	  2960: *     x.W
02:00001E98 4DF81234        	  2961:             lea $1234,a6
02:00001E9C 200E            	  2962:             move.l a6,d0
02:00001E9E 0C401234        	  2963:             cmpi.w #$1234,d0
02:00001EA2 66FE            	  2964:             bne.s *                   * branch if Z set
02:00001EA4 48781234        	  2965:             pea $1234
02:00001EA8 0C9700001234    	  2966:             cmpi.l #$00001234,(a7)
02:00001EAE 66FE            	  2967:             bne.s *                   * branch if Z set
                            	  2968:             * This was without a specifier which the assembler defaulted to .w
02:00001EB0 588F            	  2969:             addq.l #4,a7            * Restore Stack Pointer
                            	  2970: 
                            	  2971: *     x.L
02:00001EB2 4DF900345678    	  2972:             lea $00345678,a6
02:00001EB8 200E            	  2973:             move.l a6,d0
02:00001EBA B08E            	  2974:             cmp.l a6,d0
02:00001EBC 66FE            	  2975:             bne.s *                   * branch if Z set
02:00001EBE 487900345678    	  2976:             pea $00345678
02:00001EC4 0C9700345678    	  2977:             cmpi.l #$00345678,(a7)
02:00001ECA 66FE            	  2978:             bne.s *                   * branch if Z set
                            	  2979:             * This was without a specifier which the assembler defaulted to .w
02:00001ECC 588F            	  2980:             addq.l #4,a7            * Restore Stack Pointer
                            	  2981: 
                            	  2982: *     x(PC)
02:00001ECE 4DFA0008        	  2983:             lea LEA1(pc),a6
02:00001ED2 200E            	  2984:             move.l a6,d0
02:00001ED4 B08E            	  2985:             cmp.l a6,d0
02:00001ED6 66FE            	  2986:             bne.s *                   * branch if Z set
02:00001ED8 487AFFFE        	  2987: LEA1:       pea LEA1(pc)
02:00001EDC 0C970000241E    	  2988:             cmpi.l #$0000241E,(a7)
02:00001EE2 67FE            	  2989:             beq.s *                   * branch if Z clear
                            	  2990:             * This was without a specifier which the assembler defaulted to .w
02:00001EE4 588F            	  2991:             addq.l #4,a7              * Restore Stack Pointer
                            	  2992: 
                            	  2993: 
                            	  2994: 
                            	  2995: 
02:00001EE6 46FC2700        	  2996:             move.w #$2700,sr          * Put flags back to initial value
                            	  2997: 
02:00001EEA 4E75            	  2998:             rts
                            	  2999:  	
                            	  3000: 
                            	  3001: 
                            	  3002: *-----------------------------------------------------------
                            	  3003: *-----------------------------------------------------------
                            	  3004: * OPCODE : LEA_TAS
                            	  3005: *-----------------------------------------------------------
                            	  3006: *-----------------------------------------------------------
                            	  3007: op_TAS:
                            	  3008: 
                            	  3009: *     Test just one addressing mode
                            	  3010: 
02:00001EEC 307C0100        	  3011:             move.l #$00000100,a0
                            	  3012: 
                            	  3013: *     (An)
02:00001EF0 4210            	  3014:             move.b #$00,(a0)
02:00001EF2 6BFE            	  3015:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001EF4 66FE            	  3016:             bne.s *                   * Check Z Flag  beq/bne
02:00001EF6 4AD0            	  3017:             tas (a0)
02:00001EF8 0C100080        	  3018:             cmpi.b #$80,(a0)
02:00001EFC 66FE            	  3019:             bne.s *                   * branch if Z set
02:00001EFE 10BC00F5        	  3020:             move.b #$F5,(a0)
02:00001F02 4AD0            	  3021:             tas (a0)
02:00001F04 6AFE            	  3022:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F06 67FE            	  3023:             beq.s *                   * Check Z Flag  beq/bne
02:00001F08 4AD0            	  3024:             tas (a0)
02:00001F0A 0C1000F5        	  3025:             cmpi.b #$F5,(a0)
02:00001F0E 66FE            	  3026:             bne.s *                   * branch if Z set
                            	  3027: 
02:00001F10 4E75            	  3028:             rts
                            	  3029: 
                            	  3030: 
                            	  3031: *-----------------------------------------------------------
                            	  3032: *-----------------------------------------------------------
                            	  3033: * OPCODE : LEA_TST
                            	  3034: *-----------------------------------------------------------
                            	  3035: *-----------------------------------------------------------
                            	  3036: op_TST:
                            	  3037: 
                            	  3038: *     Test just one addressing mode
                            	  3039: 
02:00001F12 307C0100        	  3040:             move.l #$00000100,a0
                            	  3041: 
                            	  3042: *     (An) - BYTE
02:00001F16 4210            	  3043:             move.b #$00,(a0)
02:00001F18 4A10            	  3044:             tst.b (a0)
02:00001F1A 6BFE            	  3045:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F1C 66FE            	  3046:             bne.s *                   * Check Z Flag  beq/bne
02:00001F1E 10BC00F5        	  3047:             move.b #$F5,(a0)
02:00001F22 4A10            	  3048:             tst.b (a0)
02:00001F24 6AFE            	  3049:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F26 67FE            	  3050:             beq.s *                   * Check Z Flag  beq/bne
                            	  3051: 
                            	  3052: *     (An) - WORD
02:00001F28 4250            	  3053:             move.w #$0000,(a0)
02:00001F2A 4A50            	  3054:             tst.w (a0)
02:00001F2C 6BFE            	  3055:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F2E 66FE            	  3056:             bne.s *                   * Check Z Flag  beq/bne
02:00001F30 30BCF567        	  3057:             move.w #$F567,(a0)
02:00001F34 4A50            	  3058:             tst.w (a0)
02:00001F36 6AFE            	  3059:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F38 67FE            	  3060:             beq.s *                   * Check Z Flag  beq/bne
                            	  3061: 
                            	  3062: *     (An) - LONG
02:00001F3A 4290            	  3063:             move.l #$00000000,(a0)
02:00001F3C 4A90            	  3064:             tst.l (a0)
02:00001F3E 6BFE            	  3065:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F40 66FE            	  3066:             bne.s *                   * Check Z Flag  beq/bne
02:00001F42 20BCF56789AB    	  3067:             move.l #$F56789ab,(a0)
02:00001F48 4A90            	  3068:             tst.l (a0)
02:00001F4A 6AFE            	  3069:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F4C 67FE            	  3070:             beq.s *                   * Check Z Flag  beq/bne
                            	  3071: 
                            	  3072: 
02:00001F4E 4E75            	  3073:             rts
                            	  3074: 
                            	  3075: 
                            	  3076: *-----------------------------------------------------------
                            	  3077: *-----------------------------------------------------------
                            	  3078: * OPCODE : LINKS
                            	  3079: *-----------------------------------------------------------
                            	  3080: *-----------------------------------------------------------
                            	  3081: op_LINKS:
                            	  3082: 
02:00001F50 207C11223344    	  3083:             move.l #$11223344,a0
02:00001F56 203C11223344    	  3084:             move.l #$11223344,d0
02:00001F5C 4E500000        	  3085:             link a0,#$0
02:00001F60 0C9711223344    	  3086:             cmpi.l #$11223344,(a7)
                            	  3087: 
02:00001F66 4E58            	  3088:             unlk a0
02:00001F68 B1C0            	  3089:             cmp.l d0,a0
02:00001F6A 66FE            	  3090:             bne.s *                   * branch if Z set
                            	  3091: 
02:00001F6C 4E75            	  3092:             rts
                            	  3093: 
                            	  3094: *-----------------------------------------------------------
                            	  3095: *-----------------------------------------------------------
                            	  3096: * OPCODE : MOVE_USP
                            	  3097: *-----------------------------------------------------------
                            	  3098: *-----------------------------------------------------------
                            	  3099: op_MOVE_USP:
                            	  3100: 
02:00001F6E 207C11223344    	  3101:             move.l #$11223344,a0
02:00001F74 4E60            	  3102:             move a0,USP
02:00001F76 4E69            	  3103:             move USP,a1
02:00001F78 B3C8            	  3104:             cmp.l a0,a1
02:00001F7A 66FE            	  3105:             bne.s *                   * branch if Z set
                            	  3106: 
02:00001F7C 4E75            	  3107:             rts
                            	  3108: 
                            	  3109: 
                            	  3110: *-----------------------------------------------------------
                            	  3111: *-----------------------------------------------------------
                            	  3112: * OPCODE : CHK
                            	  3113: *-----------------------------------------------------------
                            	  3114: *-----------------------------------------------------------
                            	  3115: op_CHK:
02:00001F7E 303C1122        	  3116:             move.w #$1122,d0
02:00001F82 323C1122        	  3117:             move.w #$1122,d1
02:00001F86 4380            	  3118:             chk d0,d1
                            	  3119: 
02:00001F88 4E71            	  3120:             nop
02:00001F8A 4E71            	  3121:             nop
                            	  3122: 
02:00001F8C 323C1122        	  3123:             move.w #$1122,d1
02:00001F90 43BC1122        	  3124:             chk #$1122,d1
                            	  3125: 
02:00001F94 323C1122        	  3126:             move.w #$1122,d1
02:00001F98 43BC007A        	  3127:             chk #00122,d1
02:00001F9C BCBCEEEE0006    	  3128:             cmp.l #$EEEE0006,d6
02:00001FA2 66FE            	  3129:             bne.s *                   * branch if Z set
                            	  3130: 
02:00001FA4 303C1122        	  3131:             move.w #$1122,d0
02:00001FA8 323C8000        	  3132:             move.w #$8000,d1
02:00001FAC 4380            	  3133:             chk d0,d1
02:00001FAE BCBCEEEE0006    	  3134:             cmp.l #$EEEE0006,d6
02:00001FB4 66FE            	  3135:             bne.s *                   * branch if Z set
                            	  3136: 
02:00001FB6 4E75            	  3137:             rts
                            	  3138: 
                            	  3139: 
                            	  3140: *-----------------------------------------------------------
                            	  3141: *-----------------------------------------------------------
                            	  3142: * OPCODE : NEGS
                            	  3143: *-----------------------------------------------------------
                            	  3144: *-----------------------------------------------------------
                            	  3145: op_NEGS:
                            	  3146: 
                            	  3147: *     NOT - BYTE
02:00001FB8 307C0100        	  3148:             move.l #$00000100,a0
02:00001FBC 7000            	  3149:             moveq  #$00000000,d0
02:00001FBE 4600            	  3150:             not.b d0
02:00001FC0 6AFE            	  3151:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001FC2 67FE            	  3152:             beq.s *                   * Check Z Flag  beq/bne
02:00001FC4 4600            	  3153:             not.b d0
02:00001FC6 6BFE            	  3154:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001FC8 66FE            	  3155:             bne.s *                   * Check Z Flag  beq/bne
02:00001FCA 4A00            	  3156:             cmpi.b #$00,d0
02:00001FCC 66FE            	  3157:             bne.s *                   * Check Z Flag  beq/bne
02:00001FCE 10BC0080        	  3158:             move.b #$80,(a0)
02:00001FD2 4610            	  3159:             not.b (a0)
02:00001FD4 6BFE            	  3160:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001FD6 67FE            	  3161:             beq.s *                   * Check Z Flag  beq/bne
02:00001FD8 4610            	  3162:             not.b (a0)
02:00001FDA 6AFE            	  3163:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001FDC 67FE            	  3164:             beq.s *                   * Check Z Flag  beq/bne
02:00001FDE 0C100080        	  3165:             cmpi.b #$80,(a0)
02:00001FE2 66FE            	  3166:             bne.s *                   * Check Z Flag  beq/bne
                            	  3167: 
                            	  3168: *     NOT - WORD
02:00001FE4 307C0100        	  3169:             move.l #$00000100,a0
02:00001FE8 7000            	  3170:             moveq  #$00000000,d0
02:00001FEA 4640            	  3171:             not.w d0
02:00001FEC 6AFE            	  3172:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001FEE 67FE            	  3173:             beq.s *                   * Check Z Flag  beq/bne
02:00001FF0 4640            	  3174:             not.w d0
02:00001FF2 6BFE            	  3175:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001FF4 66FE            	  3176:             bne.s *                   * Check Z Flag  beq/bne
02:00001FF6 4A40            	  3177:             cmpi.w #$0000,d0
02:00001FF8 66FE            	  3178:             bne.s *                   * Check Z Flag  beq/bne
02:00001FFA 30BC5A5A        	  3179:             move.w #$5a5a,(a0)
02:00001FFE 4650            	  3180:             not.w (a0)
02:00002000 6AFE            	  3181:             bpl.s *                   * Check N Flag  bmi/bpl
02:00002002 67FE            	  3182:             beq.s *                   * Check Z Flag  beq/bne
02:00002004 4650            	  3183:             not.w (a0)
02:00002006 6BFE            	  3184:             bmi.s *                   * Check N Flag  bmi/bpl
02:00002008 67FE            	  3185:             beq.s *                   * Check Z Flag  beq/bne
02:0000200A 0C505A5A        	  3186:             cmpi.w #$5a5a,(a0)
02:0000200E 66FE            	  3187:             bne.s *                   * Check Z Flag  beq/bne
                            	  3188: 
                            	  3189: *     NOT - LONG
02:00002010 307C0100        	  3190:             move.l #$00000100,a0
02:00002014 7000            	  3191:             moveq  #$00000000,d0
02:00002016 4680            	  3192:             not.l d0
02:00002018 6AFE            	  3193:             bpl.s *                   * Check N Flag  bmi/bpl
02:0000201A 67FE            	  3194:             beq.s *                   * Check Z Flag  beq/bne
02:0000201C 4680            	  3195:             not.l d0
02:0000201E 6BFE            	  3196:             bmi.s *                   * Check N Flag  bmi/bpl
02:00002020 66FE            	  3197:             bne.s *                   * Check Z Flag  beq/bne
02:00002022 4A80            	  3198:             cmpi.l #$00000000,d0
02:00002024 66FE            	  3199:             bne.s *                   * Check Z Flag  beq/bne
02:00002026 20BC5A5A1234    	  3200:             move.l #$5a5a1234,(a0)
02:0000202C 4690            	  3201:             not.l (a0)
02:0000202E 6AFE            	  3202:             bpl.s *                   * Check N Flag  bmi/bpl
02:00002030 67FE            	  3203:             beq.s *                   * Check Z Flag  beq/bne
02:00002032 4690            	  3204:             not.l (a0)
02:00002034 6BFE            	  3205:             bmi.s *                   * Check N Flag  bmi/bpl
02:00002036 67FE            	  3206:             beq.s *                   * Check Z Flag  beq/bne
02:00002038 0C905A5A1234    	  3207:             cmpi.l #$5a5a1234,(a0)
02:0000203E 66FE            	  3208:             bne.s *                   * Check Z Flag  beq/bne
                            	  3209: 
                            	  3210: * -----
                            	  3211: 
                            	  3212: *     NEG - BYTE
02:00002040 307C0100        	  3213:             move.l #$00000100,a0
02:00002044 7000            	  3214:             moveq  #$00000000,d0
02:00002046 7240D241        	  3215:             move.l #$00000080,d1
02:0000204A 4400            	  3216:             neg.b d0
02:0000204C 6BFE            	  3217:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000204E 66FE            	  3218:             bne.s *                   * Check Z Flag  beq/bne 1
02:00002050 65FE            	  3219:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:00002052 69FE            	  3220:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002054 4401            	  3221:             neg.b d1
02:00002056 6AFE            	  3222:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002058 67FE            	  3223:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000205A 64FE            	  3224:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000205C 68FE            	  3225:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:0000205E 0C010080        	  3226:             cmpi.b #$80,d1
02:00002062 66FE            	  3227:             bne.s *                   * Check Z Flag  beq/bne
02:00002064 10BC007F        	  3228:             move.b #$7F,(a0)
02:00002068 4410            	  3229:             neg.b (a0)
02:0000206A 6AFE            	  3230:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:0000206C 67FE            	  3231:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000206E 64FE            	  3232:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002070 69FE            	  3233:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002072 10BC00F5        	  3234:             move.b #$F5,(a0)
02:00002076 4410            	  3235:             neg.b (a0)
02:00002078 6BFE            	  3236:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000207A 67FE            	  3237:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000207C 64FE            	  3238:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000207E 69FE            	  3239:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002080 0C10000B        	  3240:             cmpi.b #$0B,(a0)
02:00002084 66FE            	  3241:             bne.s *                   * Check Z Flag  beq/bne
                            	  3242: 
                            	  3243: * -----
                            	  3244: 
                            	  3245: *     NEG - WORD
02:00002086 307C0100        	  3246:             move.l #$00000100,a0
02:0000208A 7000            	  3247:             moveq  #$00000000,d0
02:0000208C 223C00008000    	  3248:             move.l #$00008000,d1
02:00002092 4440            	  3249:             neg.w d0
02:00002094 6BFE            	  3250:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002096 66FE            	  3251:             bne.s *                   * Check Z Flag  beq/bne 1
02:00002098 65FE            	  3252:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:0000209A 69FE            	  3253:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000209C 4441            	  3254:             neg.w d1
02:0000209E 6AFE            	  3255:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000020A0 67FE            	  3256:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020A2 64FE            	  3257:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020A4 68FE            	  3258:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:000020A6 0C418000        	  3259:             cmpi.w #$8000,d1
02:000020AA 66FE            	  3260:             bne.s *                   * Check Z Flag  beq/bne
02:000020AC 30BC7FFF        	  3261:             move.w #$7FFF,(a0)
02:000020B0 4450            	  3262:             neg.w (a0)
02:000020B2 6AFE            	  3263:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000020B4 67FE            	  3264:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020B6 64FE            	  3265:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020B8 69FE            	  3266:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020BA 30BCF578        	  3267:             move.w #$F578,(a0)
02:000020BE 4450            	  3268:             neg.w (a0)
02:000020C0 6BFE            	  3269:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000020C2 67FE            	  3270:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020C4 64FE            	  3271:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020C6 69FE            	  3272:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020C8 0C500A88        	  3273:             cmpi.w #$0A88,(a0)
02:000020CC 66FE            	  3274:             bne.s *                   * Check Z Flag  beq/bne
                            	  3275: 
                            	  3276: * -----
                            	  3277: 
                            	  3278: *     NEG - LONG
02:000020CE 307C0100        	  3279:             move.l #$00000100,a0
02:000020D2 7000            	  3280:             moveq  #$00000000,d0
02:000020D4 223C80000000    	  3281:             move.l #$80000000,d1
02:000020DA 4480            	  3282:             neg.l d0
02:000020DC 6BFE            	  3283:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000020DE 66FE            	  3284:             bne.s *                   * Check Z Flag  beq/bne 1
02:000020E0 65FE            	  3285:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:000020E2 69FE            	  3286:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020E4 4481            	  3287:             neg.l d1
02:000020E6 6AFE            	  3288:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000020E8 67FE            	  3289:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020EA 64FE            	  3290:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020EC 68FE            	  3291:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:000020EE 0C8180000000    	  3292:             cmpi.l #$80000000,d1
02:000020F4 66FE            	  3293:             bne.s *                   * Check Z Flag  beq/bne
02:000020F6 20BC7FFFFFFF    	  3294:             move.l #$7FFFFFFF,(a0)
02:000020FC 4490            	  3295:             neg.l (a0)
02:000020FE 6AFE            	  3296:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002100 67FE            	  3297:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002102 64FE            	  3298:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002104 69FE            	  3299:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002106 20BCF5781234    	  3300:             move.l #$F5781234,(a0)
02:0000210C 4490            	  3301:             neg.l (a0)
02:0000210E 6BFE            	  3302:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002110 67FE            	  3303:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002112 64FE            	  3304:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002114 69FE            	  3305:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002116 0C900A87EDCC    	  3306:             cmpi.l #$0A87EDCC,(a0)
02:0000211C 66FE            	  3307:             bne.s *                   * Check Z Flag  beq/bne
                            	  3308: 
                            	  3309: 
                            	  3310: * -----
                            	  3311: 
                            	  3312: *     NEGX - BYTE
02:0000211E 307C0100        	  3313:             move.l #$00000100,a0
02:00002122 7000            	  3314:             moveq  #$00000000,d0
02:00002124 7240D241        	  3315:             move.l #$00000080,d1
02:00002128 003C0010        	  3316:             ori.b #$10,CCR        * Set X Flag
02:0000212C 4000            	  3317:             negx.b d0
02:0000212E 6AFE            	  3318:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:00002130 67FE            	  3319:             beq.s *                   * Check Z Flag  beq/bne 1
02:00002132 64FE            	  3320:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:00002134 69FE            	  3321:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002136 023C00EF        	  3322:             andi.b #$EF,CCR       * Clear X Flag
02:0000213A 4000            	  3323:             negx.b d0
02:0000213C 6BFE            	  3324:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000213E 67FE            	  3325:             beq.s *                   * Check Z Flag  beq/bne 1
02:00002140 64FE            	  3326:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:00002142 69FE            	  3327:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002144 003C0010        	  3328:             ori.b #$10,CCR        * Set X Flag
02:00002148 4001            	  3329:             negx.b d1
02:0000214A 6BFE            	  3330:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:0000214C 67FE            	  3331:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000214E 64FE            	  3332:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002150 69FE            	  3333:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:00002152 0C01007F        	  3334:             cmpi.b #$7F,d1
02:00002156 66FE            	  3335:             bne.s *                   * Check Z Flag  beq/bne
02:00002158 023C00EF        	  3336:             andi.b #$EF,CCR       * Clear X Flag
02:0000215C 4001            	  3337:             negx.b d1
02:0000215E 6AFE            	  3338:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002160 67FE            	  3339:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002162 64FE            	  3340:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002164 69FE            	  3341:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:00002166 0C010081        	  3342:             cmpi.b #$81,d1
02:0000216A 66FE            	  3343:             bne.s *                   * Check Z Flag  beq/bne
02:0000216C 10BC007F        	  3344:             move.b #$7F,(a0)
02:00002170 003C0010        	  3345:             ori.b #$10,CCR        * Set X Flag
02:00002174 4010            	  3346:             negx.b (a0)
02:00002176 6AFE            	  3347:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002178 67FE            	  3348:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000217A 64FE            	  3349:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3350:             * I think overflow should happen here.
                            	  3351: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000217C 10BC007F        	  3352:             move.b #$7F,(a0)
02:00002180 023C00EF        	  3353:             andi.b #$EF,CCR       * Clear X Flag
02:00002184 4010            	  3354:             negx.b (a0)
02:00002186 6AFE            	  3355:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002188 67FE            	  3356:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000218A 64FE            	  3357:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000218C 69FE            	  3358:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000218E 10BC00F5        	  3359:             move.b #$F5,(a0)
02:00002192 003C0010        	  3360:             ori.b #$10,CCR        * Set X Flag
02:00002196 4010            	  3361:             negx.b (a0)
02:00002198 6BFE            	  3362:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000219A 67FE            	  3363:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000219C 64FE            	  3364:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000219E 69FE            	  3365:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021A0 0C10000A        	  3366:             cmpi.b #$0A,(a0)
02:000021A4 66FE            	  3367:             bne.s *                   * Check Z Flag  beq/bne
02:000021A6 023C00EF        	  3368:             andi.b #$EF,CCR       * Clear X Flag
02:000021AA 4010            	  3369:             negx.b (a0)
02:000021AC 6AFE            	  3370:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:000021AE 67FE            	  3371:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021B0 64FE            	  3372:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000021B2 69FE            	  3373:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021B4 0C1000F6        	  3374:             cmpi.b #$F6,(a0)
02:000021B8 66FE            	  3375:             bne.s *                   * Check Z Flag  beq/bne
                            	  3376: 
                            	  3377: 
                            	  3378: 
                            	  3379: * -----
                            	  3380: 
                            	  3381: *     NEGX - WORD
02:000021BA 307C0100        	  3382:             move.l #$00000100,a0
02:000021BE 7000            	  3383:             moveq  #$00000000,d0
02:000021C0 223C00008000    	  3384:             move.l #$00008000,d1
02:000021C6 003C0010        	  3385:             ori.b #$10,CCR        * Set X Flag
02:000021CA 4040            	  3386:             negx.w d0
02:000021CC 6AFE            	  3387:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:000021CE 67FE            	  3388:             beq.s *                   * Check Z Flag  beq/bne 1
02:000021D0 64FE            	  3389:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:000021D2 69FE            	  3390:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021D4 023C00EF        	  3391:             andi.b #$EF,CCR       * Clear X Flag
02:000021D8 4040            	  3392:             negx.w d0
02:000021DA 6BFE            	  3393:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000021DC 67FE            	  3394:             beq.s *                   * Check Z Flag  beq/bne 1
02:000021DE 64FE            	  3395:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:000021E0 69FE            	  3396:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021E2 003C0010        	  3397:             ori.b #$10,CCR        * Set X Flag
02:000021E6 4041            	  3398:             negx.w d1
02:000021E8 6BFE            	  3399:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:000021EA 67FE            	  3400:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021EC 64FE            	  3401:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000021EE 69FE            	  3402:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:000021F0 0C417FFF        	  3403:             cmpi.w #$7FFF,d1
02:000021F4 66FE            	  3404:             bne.s *                   * Check Z Flag  beq/bne
02:000021F6 023C00EF        	  3405:             andi.b #$EF,CCR       * Clear X Flag
02:000021FA 4041            	  3406:             negx.w d1
02:000021FC 6AFE            	  3407:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000021FE 67FE            	  3408:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002200 64FE            	  3409:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002202 69FE            	  3410:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:00002204 0C418001        	  3411:             cmpi.w #$8001,d1
02:00002208 66FE            	  3412:             bne.s *                   * Check Z Flag  beq/bne
02:0000220A 30BC7FFF        	  3413:             move.w #$7FFF,(a0)
02:0000220E 003C0010        	  3414:             ori.b #$10,CCR        * Set X Flag
02:00002212 4050            	  3415:             negx.w (a0)
02:00002214 6AFE            	  3416:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002216 67FE            	  3417:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002218 64FE            	  3418:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3419: ***            
                            	  3420: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000221A 30BCF567        	  3421:             move.w #$F567,(a0)
02:0000221E 023C00EF        	  3422:             andi.b #$EF,CCR       * Clear X Flag
02:00002222 4050            	  3423:             negx.w (a0)
02:00002224 6BFE            	  3424:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:00002226 67FE            	  3425:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002228 64FE            	  3426:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000222A 69FE            	  3427:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000222C 30BCF567        	  3428:             move.w #$F567,(a0)
02:00002230 003C0010        	  3429:             ori.b #$10,CCR        * Set X Flag
02:00002234 4050            	  3430:             negx.w (a0)
02:00002236 6BFE            	  3431:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002238 67FE            	  3432:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000223A 64FE            	  3433:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000223C 69FE            	  3434:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000223E 0C500A98        	  3435:             cmpi.w #$0A98,(a0)
02:00002242 66FE            	  3436:             bne.s *                   * Check Z Flag  beq/bne
02:00002244 023C00EF        	  3437:             andi.b #$EF,CCR       * Clear X Flag
02:00002248 4050            	  3438:             negx.w (a0)
02:0000224A 6AFE            	  3439:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:0000224C 67FE            	  3440:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000224E 64FE            	  3441:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002250 69FE            	  3442:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002252 0C50F568        	  3443:             cmpi.w #$F568,(a0)
02:00002256 66FE            	  3444:             bne.s *                   * Check Z Flag  beq/bne
                            	  3445: 
                            	  3446: 
                            	  3447: * -----
                            	  3448: 
                            	  3449: *     NEGX - LONG
02:00002258 307C0100        	  3450:             move.l #$00000100,a0
02:0000225C 7000            	  3451:             moveq  #$00000000,d0
02:0000225E 223C80000000    	  3452:             move.l #$80000000,d1
02:00002264 003C0010        	  3453:             ori.b #$10,CCR        * Set X Flag
02:00002268 4080            	  3454:             negx.l d0
02:0000226A 6AFE            	  3455:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:0000226C 67FE            	  3456:             beq.s *                   * Check Z Flag  beq/bne 1
02:0000226E 64FE            	  3457:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:00002270 69FE            	  3458:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002272 023C00EF        	  3459:             andi.b #$EF,CCR       * Clear X Flag
02:00002276 4080            	  3460:             negx.l d0
02:00002278 6BFE            	  3461:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000227A 67FE            	  3462:             beq.s *                   * Check Z Flag  beq/bne 1
02:0000227C 64FE            	  3463:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:0000227E 69FE            	  3464:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002280 003C0010        	  3465:             ori.b #$10,CCR        * Set X Flag
02:00002284 4081            	  3466:             negx.l d1
02:00002286 6BFE            	  3467:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:00002288 67FE            	  3468:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000228A 64FE            	  3469:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000228C 69FE            	  3470:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:0000228E 0C817FFFFFFF    	  3471:             cmpi.l #$7FFFFFFF,d1
02:00002294 66FE            	  3472:             bne.s *                   * Check Z Flag  beq/bne
02:00002296 023C00EF        	  3473:             andi.b #$EF,CCR       * Clear X Flag
02:0000229A 4081            	  3474:             negx.l d1
02:0000229C 6AFE            	  3475:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:0000229E 67FE            	  3476:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022A0 64FE            	  3477:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3478: ****            
                            	  3479: *            bvs.s *                   * Check V Flag  bvc/bvs 0
02:000022A2 0C8180000001    	  3480:             cmpi.l #$80000001,d1
02:000022A8 66FE            	  3481:             bne.s *                   * Check Z Flag  beq/bne
02:000022AA 20BC00007FFF    	  3482:             move.l #$7FFF,(a0)
02:000022B0 003C0010        	  3483:             ori.b #$10,CCR        * Set X Flag
02:000022B4 4090            	  3484:             negx.l (a0)
02:000022B6 6AFE            	  3485:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000022B8 67FE            	  3486:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022BA 64FE            	  3487:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3488: ****            
                            	  3489: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:000022BC 20BCF5671234    	  3490:             move.l #$F5671234,(a0)
02:000022C2 023C00EF        	  3491:             andi.b #$EF,CCR       * Clear X Flag
02:000022C6 4090            	  3492:             negx.l (a0)
02:000022C8 6BFE            	  3493:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:000022CA 67FE            	  3494:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022CC 64FE            	  3495:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000022CE 69FE            	  3496:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000022D0 20BCF5675678    	  3497:             move.l #$F5675678,(a0)
02:000022D6 003C0010        	  3498:             ori.b #$10,CCR        * Set X Flag
02:000022DA 4090            	  3499:             negx.l (a0)
02:000022DC 6BFE            	  3500:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000022DE 67FE            	  3501:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022E0 64FE            	  3502:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000022E2 69FE            	  3503:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000022E4 0C900A98A987    	  3504:             cmpi.l #$0A98A987,(a0)
02:000022EA 66FE            	  3505:             bne.s *                   * Check Z Flag  beq/bne
02:000022EC 023C00EF        	  3506:             andi.b #$EF,CCR       * Clear X Flag
02:000022F0 4090            	  3507:             negx.l (a0)
02:000022F2 6AFE            	  3508:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:000022F4 67FE            	  3509:             beq.s *                   * Check Z Flag  beq/bne 0
02:000022F6 64FE            	  3510:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000022F8 69FE            	  3511:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000022FA 0C90F5675679    	  3512:             cmpi.l #$F5675679,(a0)
02:00002300 66FE            	  3513:             bne.s *                   * Check Z Flag  beq/bne
                            	  3514: 
                            	  3515: 
                            	  3516: * -----
                            	  3517: 
                            	  3518: *     CLR - BYTE
02:00002302 307C0100        	  3519:             move.l #$00000100,a0
02:00002306 203C12345678    	  3520:             move.l #$12345678,d0
02:0000230C 223C12345678    	  3521:             move.l #$12345678,d1
02:00002312 243C12345678    	  3522:             move.l #$12345678,d2
02:00002318 283C12345600    	  3523:             move.l #$12345600,d4
02:0000231E 2A3C12340000    	  3524:             move.l #$12340000,d5
02:00002324 7C00            	  3525:             moveq  #$00000000,d6
                            	  3526: 
02:00002326 4200            	  3527:             clr.b d0
02:00002328 66FE            	  3528:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000232A 6BFE            	  3529:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000232C B880            	  3530:             cmp.l d0,d4
02:0000232E 66FE            	  3531:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3532: 
02:00002330 4241            	  3533:             clr.w d1
02:00002332 66FE            	  3534:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002334 6BFE            	  3535:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002336 BA81            	  3536:             cmp.l d1,d5
02:00002338 66FE            	  3537:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3538: 
02:0000233A 7400            	  3539:             clr.l d2
02:0000233C 66FE            	  3540:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000233E 6BFE            	  3541:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002340 BC82            	  3542:             cmp.l d2,d6
02:00002342 66FE            	  3543:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3544: 
02:00002344 4E75            	  3545:             rts
                            	  3546: 
                            	  3547: 
                            	  3548: 
                            	  3549: *-----------------------------------------------------------
                            	  3550: *-----------------------------------------------------------
                            	  3551: * OPCODE : MOVEM
                            	  3552: *-----------------------------------------------------------
                            	  3553: *-----------------------------------------------------------
                            	  3554: op_MOVEM:
                            	  3555: 
                            	  3556: *     WORD  Registers --> Memory
02:00002346 203C0000D0D0    	  3557:             move.l #$0000d0d0,d0
02:0000234C 223C0000D1D1    	  3558:             move.l #$0000d1d1,d1
02:00002352 243C0000D2D2    	  3559:             move.l #$0000d2d2,d2
02:00002358 263C0000D3D3    	  3560:             move.l #$0000d3d3,d3
02:0000235E 283C0000D4D4    	  3561:             move.l #$0000d4d4,d4
02:00002364 2A3C0000D5D5    	  3562:             move.l #$0000d5d5,d5
02:0000236A 2C3C0000D6D6    	  3563:             move.l #$0000d6d6,d6
02:00002370 2E3C0000D7D7    	  3564:             move.l #$0000d7d7,d7
02:00002376 307C0A0A        	  3565:             move.l #$00000a0a,a0
02:0000237A 327C1A1A        	  3566:             move.l #$00001a1a,a1
02:0000237E 347C2A2A        	  3567:             move.l #$00002a2a,a2
02:00002382 367C3A3A        	  3568:             move.l #$00003a3a,a3
02:00002386 387C4A4A        	  3569:             move.l #$00004a4a,a4
02:0000238A 3A7C5A5A        	  3570:             move.l #$00005a5a,a5
02:0000238E 3C7C6A6A        	  3571:             move.l #$00006a6a,a6
                            	  3572: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3573: 
02:00002392 48B8FFFF0100    	  3574:             movem.w D0-D7/A0-A7,$00000100
                            	  3575: 
02:00002398 307C0100        	  3576:             move.l #$00000100,a0
                            	  3577: 
02:0000239C B058            	  3578:             cmp.w (a0)+,d0
02:0000239E 66FE            	  3579:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023A0 B258            	  3580:             cmp.w (a0)+,d1
02:000023A2 66FE            	  3581:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023A4 B458            	  3582:             cmp.w (a0)+,d2
02:000023A6 66FE            	  3583:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023A8 B658            	  3584:             cmp.w (a0)+,d3
02:000023AA 66FE            	  3585:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023AC B858            	  3586:             cmp.w (a0)+,d4
02:000023AE 66FE            	  3587:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023B0 BA58            	  3588:             cmp.w (a0)+,d5
02:000023B2 66FE            	  3589:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023B4 BC58            	  3590:             cmp.w (a0)+,d6
02:000023B6 66FE            	  3591:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023B8 BE58            	  3592:             cmp.w (a0)+,d7
02:000023BA 66FE            	  3593:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3594: 
02:000023BC 0C580A0A        	  3595:             cmpi.w #$0A0A,(a0)+    * Because we are using a0 as a pointer
02:000023C0 66FE            	  3596:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3597: 
02:000023C2 B2D8            	  3598:             cmp.w (a0)+,a1
02:000023C4 66FE            	  3599:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023C6 B4D8            	  3600:             cmp.w (a0)+,a2
02:000023C8 66FE            	  3601:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023CA B6D8            	  3602:             cmp.w (a0)+,a3
02:000023CC 66FE            	  3603:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023CE B8D8            	  3604:             cmp.w (a0)+,a4
02:000023D0 66FE            	  3605:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023D2 BAD8            	  3606:             cmp.w (a0)+,a5
02:000023D4 66FE            	  3607:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023D6 BCD8            	  3608:             cmp.w (a0)+,a6
02:000023D8 66FE            	  3609:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3610: 
                            	  3611: 
                            	  3612: 
                            	  3613: 
                            	  3614: *     LONG  Registers --> Memory
02:000023DA 203CD0D0D0D0    	  3615:             move.l #$d0d0d0d0,d0
02:000023E0 223CD1D1D1D1    	  3616:             move.l #$d1d1d1d1,d1
02:000023E6 243CD2D2D2D2    	  3617:             move.l #$d2d2d2d2,d2
02:000023EC 263CD3D3D3D3    	  3618:             move.l #$d3d3d3d3,d3
02:000023F2 283CD4D4D4D4    	  3619:             move.l #$d4d4d4d4,d4
02:000023F8 2A3CD5D5D5D5    	  3620:             move.l #$d5d5d5d5,d5
02:000023FE 2C3CD6D6D6D6    	  3621:             move.l #$d6d6d6d6,d6
02:00002404 2E3CD7D7D7D7    	  3622:             move.l #$d7d7d7d7,d7
02:0000240A 207C0A0A0A0A    	  3623:             move.l #$0a0a0a0a,a0
02:00002410 227C1A1A1A1A    	  3624:             move.l #$1a1a1a1a,a1
02:00002416 247C2A2A2A2A    	  3625:             move.l #$2a2a2a2a,a2
02:0000241C 267C3A3A3A3A    	  3626:             move.l #$3a3a3a3a,a3
02:00002422 287C4A4A4A4A    	  3627:             move.l #$4a4a4a4a,a4
02:00002428 2A7C5A5A5A5A    	  3628:             move.l #$5a5a5a5a,a5
02:0000242E 2C7C6A6A6A6A    	  3629:             move.l #$6a6a6a6a,a6
                            	  3630: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3631: 
                            	  3632: 
02:00002434 48F8FFFF0120    	  3633:             movem.l D0-D7/A0-A7,$00000120
                            	  3634: 
02:0000243A 307C0120        	  3635:             move.l #$00000120,a0
                            	  3636: 
02:0000243E B098            	  3637:             cmp.l (a0)+,d0
02:00002440 66FE            	  3638:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002442 B298            	  3639:             cmp.l (a0)+,d1
02:00002444 66FE            	  3640:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002446 B498            	  3641:             cmp.l (a0)+,d2
02:00002448 66FE            	  3642:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000244A B698            	  3643:             cmp.l (a0)+,d3
02:0000244C 66FE            	  3644:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000244E B898            	  3645:             cmp.l (a0)+,d4
02:00002450 66FE            	  3646:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002452 BA98            	  3647:             cmp.l (a0)+,d5
02:00002454 66FE            	  3648:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002456 BC98            	  3649:             cmp.l (a0)+,d6
02:00002458 66FE            	  3650:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000245A BE98            	  3651:             cmp.l (a0)+,d7
02:0000245C 66FE            	  3652:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3653: 
02:0000245E 0C980A0A0A0A    	  3654:             cmpi.l #$0A0A0A0A,(a0)+    * Because we are using a0 as a pointer
02:00002464 66FE            	  3655:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3656: 
02:00002466 B3D8            	  3657:             cmp.l (a0)+,a1
02:00002468 66FE            	  3658:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000246A B5D8            	  3659:             cmp.l (a0)+,a2
02:0000246C 66FE            	  3660:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000246E B7D8            	  3661:             cmp.l (a0)+,a3
02:00002470 66FE            	  3662:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002472 B9D8            	  3663:             cmp.l (a0)+,a4
02:00002474 66FE            	  3664:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002476 BBD8            	  3665:             cmp.l (a0)+,a5
02:00002478 66FE            	  3666:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000247A BDD8            	  3667:             cmp.l (a0)+,a6
02:0000247C 66FE            	  3668:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3669: *      ----
                            	  3670: 
                            	  3671: 
                            	  3672: *     WORD  Registers --> Memory  -(An) EA Mode
02:0000247E 203C0000D0D0    	  3673:             move.l #$0000d0d0,d0
02:00002484 223C0000D1D1    	  3674:             move.l #$0000d1d1,d1
02:0000248A 243C0000D2D2    	  3675:             move.l #$0000d2d2,d2
02:00002490 263C0000D3D3    	  3676:             move.l #$0000d3d3,d3
02:00002496 283C0000D4D4    	  3677:             move.l #$0000d4d4,d4
02:0000249C 2A3C0000D5D5    	  3678:             move.l #$0000d5d5,d5
02:000024A2 2C3C0000D6D6    	  3679:             move.l #$0000d6d6,d6
02:000024A8 2E3C0000D7D7    	  3680:             move.l #$0000d7d7,d7
02:000024AE 307C0A0A        	  3681:             move.l #$00000a0a,a0
02:000024B2 327C1A1A        	  3682:             move.l #$00001a1a,a1
02:000024B6 347C2A2A        	  3683:             move.l #$00002a2a,a2
02:000024BA 367C3A3A        	  3684:             move.l #$00003a3a,a3
02:000024BE 387C4A4A        	  3685:             move.l #$00004a4a,a4
02:000024C2 3A7C5A5A        	  3686:             move.l #$00005a5a,a5
02:000024C6 3C7C6A6A        	  3687:             move.l #$00006a6a,a6
                            	  3688: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3689: 
02:000024CA 307C01A0        	  3690:             move.l #$000001A0,a0
02:000024CE 48A0FFFF        	  3691:             movem.w D0-D7/A0-A7,-(a0)
                            	  3692: 
02:000024D2 307C019E        	  3693:             move.l #$0000019E,a0
                            	  3694: 
02:000024D6 BCE0            	  3695:             cmp.w -(a0),a6
02:000024D8 66FE            	  3696:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024DA BAE0            	  3697:             cmp.w -(a0),a5
02:000024DC 66FE            	  3698:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024DE B8E0            	  3699:             cmp.w -(a0),a4
02:000024E0 66FE            	  3700:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024E2 B6E0            	  3701:             cmp.w -(a0),a3
02:000024E4 66FE            	  3702:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024E6 B4E0            	  3703:             cmp.w -(a0),a2
02:000024E8 66FE            	  3704:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024EA B2E0            	  3705:             cmp.w -(a0),a1
02:000024EC 66FE            	  3706:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024EE B0E0            	  3707:             cmp.w -(a0),a0
                            	  3708: *            bne.s *                   * Check Z Flag  beq/bne 0
02:000024F0 BE60            	  3709:             cmp.w -(a0),d7
02:000024F2 66FE            	  3710:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024F4 BC60            	  3711:             cmp.w -(a0),d6
02:000024F6 66FE            	  3712:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024F8 BA60            	  3713:             cmp.w -(a0),d5
02:000024FA 66FE            	  3714:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024FC B860            	  3715:             cmp.w -(a0),d4
02:000024FE 66FE            	  3716:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002500 B660            	  3717:             cmp.w -(a0),d3
02:00002502 66FE            	  3718:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002504 B460            	  3719:             cmp.w -(a0),d2
02:00002506 66FE            	  3720:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002508 B260            	  3721:             cmp.w -(a0),d1
02:0000250A 66FE            	  3722:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000250C B060            	  3723:             cmp.w -(a0),d0
02:0000250E 66FE            	  3724:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3725: 
                            	  3726: 
                            	  3727: 
                            	  3728: 
                            	  3729: *     LONG  Registers --> Memory   -(An) EA Mode
02:00002510 203CD0D0D0D0    	  3730:             move.l #$d0d0d0d0,d0
02:00002516 223CD1D1D1D1    	  3731:             move.l #$d1d1d1d1,d1
02:0000251C 243CD2D2D2D2    	  3732:             move.l #$d2d2d2d2,d2
02:00002522 263CD3D3D3D3    	  3733:             move.l #$d3d3d3d3,d3
02:00002528 283CD4D4D4D4    	  3734:             move.l #$d4d4d4d4,d4
02:0000252E 2A3CD5D5D5D5    	  3735:             move.l #$d5d5d5d5,d5
02:00002534 2C3CD6D6D6D6    	  3736:             move.l #$d6d6d6d6,d6
02:0000253A 2E3CD7D7D7D7    	  3737:             move.l #$d7d7d7d7,d7
02:00002540 207C0A0A0A0A    	  3738:             move.l #$0a0a0a0a,a0
02:00002546 227C1A1A1A1A    	  3739:             move.l #$1a1a1a1a,a1
02:0000254C 247C2A2A2A2A    	  3740:             move.l #$2a2a2a2a,a2
02:00002552 267C3A3A3A3A    	  3741:             move.l #$3a3a3a3a,a3
02:00002558 287C4A4A4A4A    	  3742:             move.l #$4a4a4a4a,a4
02:0000255E 2A7C5A5A5A5A    	  3743:             move.l #$5a5a5a5a,a5
02:00002564 2C7C6A6A6A6A    	  3744:             move.l #$6a6a6a6a,a6
                            	  3745: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3746: 
                            	  3747: 
02:0000256A 307C01A0        	  3748:             move.l #$000001A0,a0
02:0000256E 48E0FFFF        	  3749:             movem.l D0-D7/A0-A7,-(a0)
                            	  3750: 
02:00002572 307C019C        	  3751:             move.l #$0000019C,a0
                            	  3752: 
02:00002576 BDE0            	  3753:             cmp.l -(a0),a6
02:00002578 66FE            	  3754:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000257A BBE0            	  3755:             cmp.l -(a0),a5
02:0000257C 66FE            	  3756:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000257E B9E0            	  3757:             cmp.l -(a0),a4
02:00002580 66FE            	  3758:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002582 B7E0            	  3759:             cmp.l -(a0),a3
02:00002584 66FE            	  3760:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002586 B5E0            	  3761:             cmp.l -(a0),a2
02:00002588 66FE            	  3762:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000258A B3E0            	  3763:             cmp.l -(a0),a1
02:0000258C 66FE            	  3764:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000258E B1E0            	  3765:             cmp.l -(a0),a0
                            	  3766: *            bne.s *                   * Check Z Flag  beq/bne 0
02:00002590 BEA0            	  3767:             cmp.l -(a0),d7
02:00002592 66FE            	  3768:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002594 BCA0            	  3769:             cmp.l -(a0),d6
02:00002596 66FE            	  3770:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002598 BAA0            	  3771:             cmp.l -(a0),d5
02:0000259A 66FE            	  3772:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000259C B8A0            	  3773:             cmp.l -(a0),d4
02:0000259E 66FE            	  3774:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025A0 B6A0            	  3775:             cmp.l -(a0),d3
02:000025A2 66FE            	  3776:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025A4 B4A0            	  3777:             cmp.l -(a0),d2
02:000025A6 66FE            	  3778:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025A8 B2A0            	  3779:             cmp.l -(a0),d1
02:000025AA 66FE            	  3780:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025AC B0A0            	  3781:             cmp.l -(a0),d0
02:000025AE 66FE            	  3782:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3783: 
                            	  3784: 
                            	  3785: 
                            	  3786: *     ----
                            	  3787: 
                            	  3788: *     WORD - Memory --> Registers
02:000025B0 7000            	  3789:             moveq  #$00000000,d0
02:000025B2 7200            	  3790:             moveq  #$00000000,d1
02:000025B4 7400            	  3791:             moveq  #$00000000,d2
02:000025B6 7600            	  3792:             moveq  #$00000000,d3
02:000025B8 7800            	  3793:             moveq  #$00000000,d4
02:000025BA 7A00            	  3794:             moveq  #$00000000,d5
02:000025BC 7C00            	  3795:             moveq  #$00000000,d6
02:000025BE 7E00            	  3796:             moveq  #$00000000,d7
02:000025C0 91C8            	  3797:             move.l #$00000000,a0
02:000025C2 93C9            	  3798:             move.l #$00000000,a1
02:000025C4 95CA            	  3799:             move.l #$00000000,a2
02:000025C6 97CB            	  3800:             move.l #$00000000,a3
02:000025C8 99CC            	  3801:             move.l #$00000000,a4
02:000025CA 9BCD            	  3802:             move.l #$00000000,a5
02:000025CC 9DCE            	  3803:             move.l #$00000000,a6
                            	  3804: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3805: 
02:000025CE 4CB82A550100    	  3806:             movem.w $00000100,D0/D2/D4/D6/A1/A3/A5
                            	  3807: 
02:000025D4 B0BCFFFFD0D0    	  3808:             cmp.l #$FFFFD0D0,d0
02:000025DA 66FE            	  3809:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025DC B4BCFFFFD1D1    	  3810:             cmp.l #$FFFFD1D1,d2
02:000025E2 66FE            	  3811:             bne.s *                  * Check Z Flag  beq/bne 0
02:000025E4 B8BCFFFFD2D2    	  3812:             cmp.l #$FFFFD2D2,d4
02:000025EA 66FE            	  3813:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025EC BCBCFFFFD3D3    	  3814:             cmp.l #$FFFFD3D3,d6
02:000025F2 66FE            	  3815:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025F4 B2FCD4D4        	  3816:             cmp.l #$FFFFD4D4,a1
02:000025F8 66FE            	  3817:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025FA B6FCD5D5        	  3818:             cmp.l #$FFFFD5D5,a3
02:000025FE 66FE            	  3819:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002600 BAFCD6D6        	  3820:             cmp.l #$FFFFD6D6,a5
02:00002604 66FE            	  3821:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3822: 
                            	  3823: 
                            	  3824: *     LONG - Memory --> Registers
02:00002606 7000            	  3825:             moveq  #$00000000,d0
02:00002608 7200            	  3826:             moveq  #$00000000,d1
02:0000260A 7400            	  3827:             moveq  #$00000000,d2
02:0000260C 7600            	  3828:             moveq  #$00000000,d3
02:0000260E 7800            	  3829:             moveq  #$00000000,d4
02:00002610 7A00            	  3830:             moveq  #$00000000,d5
02:00002612 7C00            	  3831:             moveq  #$00000000,d6
02:00002614 7E00            	  3832:             moveq  #$00000000,d7
02:00002616 91C8            	  3833:             move.l #$00000000,a0
02:00002618 93C9            	  3834:             move.l #$00000000,a1
02:0000261A 95CA            	  3835:             move.l #$00000000,a2
02:0000261C 97CB            	  3836:             move.l #$00000000,a3
02:0000261E 99CC            	  3837:             move.l #$00000000,a4
02:00002620 9BCD            	  3838:             move.l #$00000000,a5
02:00002622 9DCE            	  3839:             move.l #$00000000,a6
                            	  3840: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3841: 
02:00002624 4CF82A550120    	  3842:             movem.l $00000120,D0/D2/D4/D6/A1/A3/A5
                            	  3843: 
02:0000262A B0BCD0D0D0D0    	  3844:             cmp.l #$D0D0D0D0,d0
02:00002630 66FE            	  3845:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002632 B4BCD1D1D1D1    	  3846:             cmp.l #$D1D1D1D1,d2
02:00002638 66FE            	  3847:             bne.s *                  * Check Z Flag  beq/bne 0
02:0000263A B8BCD2D2D2D2    	  3848:             cmp.l #$D2D2D2D2,d4
02:00002640 66FE            	  3849:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002642 BCBCD3D3D3D3    	  3850:             cmp.l #$D3D3D3D3,d6
02:00002648 66FE            	  3851:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000264A B3FCD4D4D4D4    	  3852:             cmp.l #$D4D4D4D4,a1
02:00002650 66FE            	  3853:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002652 B7FCD5D5D5D5    	  3854:             cmp.l #$D5D5D5D5,a3
02:00002658 66FE            	  3855:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000265A BBFCD6D6D6D6    	  3856:             cmp.l #$D6D6D6D6,a5
02:00002660 66FE            	  3857:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3858: 
02:00002662 4E75            	  3859:             rts
                            	  3860: 
                            	  3861: 
                            	  3862: *-----------------------------------------------------------
                            	  3863: *-----------------------------------------------------------
                            	  3864: * OPCODE : ABCD
                            	  3865: *-----------------------------------------------------------
                            	  3866: *-----------------------------------------------------------
                            	  3867: op_ABCD:
                            	  3868: 
                            	  3869: *     Test with X Flag CLEARED
02:00002664 307C0110        	  3870:                 move.l #$00000110,a0 * Address pointer-X
02:00002668 327C0120        	  3871:                 move.l #$00000120,a1 * Address pointer-Y
02:0000266C 7000            	  3872:                 moveq  #$00000000,d0 * BCD byte-X
02:0000266E 7200            	  3873:                 moveq  #$00000000,d1 * BCD byte-Y
02:00002670 7400            	  3874:                 moveq  #$00000000,d2
02:00002672 7600            	  3875:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:00002674 7800            	  3876:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:00002676 7A00            	  3877:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:00002678 2C3C00000099    	  3878:                 move.l #$00000099,d6 * Inner loop counter
02:0000267E 2E3C00000099    	  3879:                 move.l #$00000099,d7 * Outer loop counter
                            	  3880: 
02:00002684 2007            	  3881: ABCD_OUTER1:    move.l d7,d0
02:00002686 2206            	  3882: ABCD_INNER1:    move.l d6,d1
02:00002688 023C00EF        	  3883:                 andi.b #$EF,CCR     * Clear X Flag
02:0000268C 307C0110        	  3884:                 move.l #$00000110,a0 * Address pointer-X
02:00002690 327C0120        	  3885:                 move.l #$00000120,a1 * Address pointer-Y
02:00002694 1140FFFF        	  3886:                 move.b d0,-1(a0)
02:00002698 1341FFFF        	  3887:                 move.b d1,-1(a1)
                            	  3888: 
02:0000269C C300            	  3889:                 abcd d0,d1
02:0000269E 6402            	  3890:                 bcc.s ABCD_NO_C1          * Check C Flag  bcc/bcs 0
02:000026A0 5284            	  3891:                 add.l #1,d4
02:000026A2 DA81            	  3892: ABCD_NO_C1:     add.l d1,d5
                            	  3893: 
02:000026A4 C308            	  3894:                 abcd -(a0),-(a1)
02:000026A6 6402            	  3895:                 bcc.s ABCD_NO_C2          * Check C Flag  bcc/bcs 0
02:000026A8 5284            	  3896:                 add.l #1,d4
02:000026AA D611            	  3897: ABCD_NO_C2:     add.b (a1),d3
                            	  3898: 
                            	  3899: 
02:000026AC 51CEFFD8        	  3900:                 dbf d6,ABCD_INNER1
02:000026B0 2C3C00000099    	  3901:                 move.l #$00000099,d6
02:000026B6 51CFFFCC        	  3902:                 dbf d7,ABCD_OUTER1
02:000026BA 0C8400005AFC    	  3903:                 cmpi.l #$00005AFC,d4  * Check the cumulative results
02:000026C0 66FE            	  3904:                 bne.s *
02:000026C2 0C85001C9A34    	  3905:                 cmpi.l #$001C9A34,d5
02:000026C8 66FE            	  3906:                 bne.s *
02:000026CA 0C8300000034    	  3907:                 cmpi.l #$00000034,d3
02:000026D0 66FE            	  3908:                 bne.s *
                            	  3909: 
                            	  3910: *     Test with X Flag SET
02:000026D2 307C0110        	  3911:                 move.l #$00000110,a0 * Address pointer-X
02:000026D6 327C0120        	  3912:                 move.l #$00000120,a1 * Address pointer-Y
02:000026DA 7000            	  3913:                 moveq  #$00000000,d0 * BCD byte-X
02:000026DC 7200            	  3914:                 moveq  #$00000000,d1 * BCD byte-Y
02:000026DE 7400            	  3915:                 moveq  #$00000000,d2
02:000026E0 7600            	  3916:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:000026E2 7800            	  3917:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:000026E4 7A00            	  3918:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:000026E6 2C3C00000099    	  3919:                 move.l #$00000099,d6 * Inner loop counter
02:000026EC 2E3C00000099    	  3920:                 move.l #$00000099,d7 * Outer loop counter
                            	  3921: 
02:000026F2 2007            	  3922: ABCD_OUTER2:    move.l d7,d0
02:000026F4 2206            	  3923: ABCD_INNER2:    move.l d6,d1
02:000026F6 003C0010        	  3924:                 ori.b #$10,CCR      * Set X Flag
02:000026FA 307C0110        	  3925:                 move.l #$00000110,a0 * Address pointer-X
02:000026FE 327C0120        	  3926:                 move.l #$00000120,a1 * Address pointer-Y
02:00002702 1140FFFF        	  3927:                 move.b d0,-1(a0)
02:00002706 1341FFFF        	  3928:                 move.b d1,-1(a1)
                            	  3929: 
02:0000270A C300            	  3930:                 abcd d0,d1
02:0000270C 6402            	  3931:                 bcc.s ABCD_NO_C3          * Check C Flag  bcc/bcs 0
02:0000270E 5284            	  3932:                 add.l #1,d4
02:00002710 DA81            	  3933: ABCD_NO_C3:     add.l d1,d5
                            	  3934: 
02:00002712 C308            	  3935:                 abcd -(a0),-(a1)
02:00002714 6402            	  3936:                 bcc.s ABCD_NO_C4          * Check C Flag  bcc/bcs 0
02:00002716 5284            	  3937:                 add.l #1,d4
02:00002718 D611            	  3938: ABCD_NO_C4:     add.b (a1),d3
                            	  3939: 
                            	  3940: 
02:0000271A 51CEFFD8        	  3941:                 dbf d6,ABCD_INNER2
02:0000271E 2C3C00000099    	  3942:                 move.l #$00000099,d6
02:00002724 51CFFFCC        	  3943:                 dbf d7,ABCD_OUTER2
02:00002728 0C8400005B60    	  3944:                 cmpi.l #$00005B60,d4  * Check the cumulative results
02:0000272E 66FE            	  3945:                 bne.s *
02:00002730 0C85001CCFC8    	  3946:                 cmpi.l #$001CCFC8,d5
02:00002736 66FE            	  3947:                 bne.s *
02:00002738 0C8300000034    	  3948:                 cmpi.l #$00000034,d3
02:0000273E 66FE            	  3949:                 bne.s *
                            	  3950: 
                            	  3951: *             Quick check of Z Flag
02:00002740 4200            	  3952:                 move.b #$00,d0
02:00002742 4201            	  3953:                 move.b #$00,d1
02:00002744 44FC0000        	  3954:                 move #$00,CCR              * Set Z flag to 0
02:00002748 C101            	  3955:                 abcd d1,d0                  * Should NOT set Z Flag to 1
02:0000274A 67FE            	  3956:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3957: 
02:0000274C 103C0001        	  3958:                 move.b #$01,d0
02:00002750 4201            	  3959:                 move.b #$00,d1
02:00002752 44FC0004        	  3960:                 move #$04,CCR              * Set Z flag to 0
02:00002756 C101            	  3961:                 abcd d1,d0                  * Should NOT set Z Flag to 1
02:00002758 67FE            	  3962:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3963: 
02:0000275A 4E75            	  3964:                 rts
                            	  3965: 
                            	  3966: *-----------------------------------------------------------
                            	  3967: *-----------------------------------------------------------
                            	  3968: * OPCODE : SBCD
                            	  3969: *-----------------------------------------------------------
                            	  3970: *-----------------------------------------------------------
                            	  3971: op_SBCD:
                            	  3972: 
                            	  3973: *     Test with X Flag CLEARED
02:0000275C 307C0110        	  3974:                 move.l #$00000110,a0 * Address pointer-X
02:00002760 327C0120        	  3975:                 move.l #$00000120,a1 * Address pointer-Y
02:00002764 7000            	  3976:                 moveq  #$00000000,d0 * BCD byte-X
02:00002766 7200            	  3977:                 moveq  #$00000000,d1 * BCD byte-Y
02:00002768 7400            	  3978:                 moveq  #$00000000,d2
02:0000276A 7600            	  3979:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:0000276C 7800            	  3980:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:0000276E 7A00            	  3981:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:00002770 2C3C00000099    	  3982:                 move.l #$00000099,d6 * Inner loop counter
02:00002776 2E3C00000099    	  3983:                 move.l #$00000099,d7 * Outer loop counter
                            	  3984: 
02:0000277C 2007            	  3985: SBCD_OUTER1:    move.l d7,d0
02:0000277E 2206            	  3986: SBCD_INNER1:    move.l d6,d1
02:00002780 023C00EF        	  3987:                 andi.b #$EF,CCR     * Clear X Flag
02:00002784 307C0110        	  3988:                 move.l #$00000110,a0 * Address pointer-X
02:00002788 327C0120        	  3989:                 move.l #$00000120,a1 * Address pointer-Y
02:0000278C 1140FFFF        	  3990:                 move.b d0,-1(a0)
02:00002790 1341FFFF        	  3991:                 move.b d1,-1(a1)
                            	  3992: 
02:00002794 8300            	  3993:                 sbcd d0,d1
02:00002796 6402            	  3994:                 bcc.s SBCD_NO_C1          * Check C Flag  bcc/bcs 0
02:00002798 5284            	  3995:                 add.l #1,d4
02:0000279A DA81            	  3996: SBCD_NO_C1:     add.l d1,d5
                            	  3997: 
02:0000279C 8308            	  3998:                 sbcd -(a0),-(a1)
02:0000279E 6402            	  3999:                 bcc.s SBCD_NO_C2          * Check C Flag  bcc/bcs 0
02:000027A0 5284            	  4000:                 add.l #1,d4
02:000027A2 D611            	  4001: SBCD_NO_C2:     add.b (a1),d3
                            	  4002: 
                            	  4003: 
02:000027A4 51CEFFD8        	  4004:                 dbf d6,SBCD_INNER1
02:000027A8 2C3C00000099    	  4005:                 move.l #$00000099,d6
02:000027AE 51CFFFCC        	  4006:                 dbf d7,SBCD_OUTER1
02:000027B2 0C8400005C0A    	  4007:                 cmpi.l #$00005C0A,d4  * Check the cumulative results
02:000027B8 66FE            	  4008:                 bne.s *
02:000027BA 0C85001C459E    	  4009:                 cmpi.l #$001C459E,d5
02:000027C0 66FE            	  4010:                 bne.s *
02:000027C2 0C830000009E    	  4011:                 cmpi.l #$0000009E,d3
02:000027C8 66FE            	  4012:                 bne.s *
                            	  4013: 
                            	  4014: *     Test with X Flag SET
02:000027CA 307C0110        	  4015:                 move.l #$00000110,a0 * Address pointer-X
02:000027CE 327C0120        	  4016:                 move.l #$00000120,a1 * Address pointer-Y
02:000027D2 7000            	  4017:                 moveq  #$00000000,d0 * BCD byte-X
02:000027D4 7200            	  4018:                 moveq  #$00000000,d1 * BCD byte-Y
02:000027D6 7400            	  4019:                 moveq  #$00000000,d2
02:000027D8 7600            	  4020:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:000027DA 7800            	  4021:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:000027DC 7A00            	  4022:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:000027DE 2C3C00000099    	  4023:                 move.l #$00000099,d6 * Inner loop counter
02:000027E4 2E3C00000099    	  4024:                 move.l #$00000099,d7 * Outer loop counter
                            	  4025: 
02:000027EA 2007            	  4026: SBCD_OUTER2:    move.l d7,d0
02:000027EC 2206            	  4027: SBCD_INNER2:    move.l d6,d1
02:000027EE 003C0010        	  4028:                 ori.b #$10,CCR      * Set X Flag
02:000027F2 307C0110        	  4029:                 move.l #$00000110,a0 * Address pointer-X
02:000027F6 327C0120        	  4030:                 move.l #$00000120,a1 * Address pointer-Y
02:000027FA 1140FFFF        	  4031:                 move.b d0,-1(a0)
02:000027FE 1341FFFF        	  4032:                 move.b d1,-1(a1)
                            	  4033: 
02:00002802 8300            	  4034:                 sbcd d0,d1
02:00002804 6402            	  4035:                 bcc.s SBCD_NO_C3          * Check C Flag  bcc/bcs 0
02:00002806 5284            	  4036:                 add.l #1,d4
02:00002808 DA81            	  4037: SBCD_NO_C3:     add.l d1,d5
                            	  4038: 
02:0000280A 8308            	  4039:                 sbcd -(a0),-(a1)
02:0000280C 6402            	  4040:                 bcc.s SBCD_NO_C4          * Check C Flag  bcc/bcs 0
02:0000280E 5284            	  4041:                 add.l #1,d4
02:00002810 D611            	  4042: SBCD_NO_C4:     add.b (a1),d3
                            	  4043: 
02:00002812 51CEFFD8        	  4044:                 dbf d6,SBCD_INNER2
02:00002816 2C3C00000099    	  4045:                 move.l #$00000099,d6
02:0000281C 51CFFFCC        	  4046:                 dbf d7,SBCD_OUTER2
02:00002820 0C8400005CA4    	  4047:                 cmpi.l #$00005CA4,d4  * Check the cumulative results
02:00002826 66FE            	  4048:                 bne.s *
02:00002828 0C85001C5C66    	  4049:                 cmpi.l #$001C5C66,d5
02:0000282E 66FE            	  4050:                 bne.s *
02:00002830 0C830000009E    	  4051:                 cmpi.l #$0000009E,d3
02:00002836 66FE            	  4052:                 bne.s *
                            	  4053: 
                            	  4054: 
                            	  4055: *             Quick check of Z Flag
02:00002838 4200            	  4056:                 move.b #$00,d0
02:0000283A 4201            	  4057:                 move.b #$00,d1
02:0000283C 44FC0000        	  4058:                 move #$00,CCR              * Set Z flag to 0
02:00002840 8101            	  4059:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
02:00002842 67FE            	  4060:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4061: 
02:00002844 103C0001        	  4062:                 move.b #$01,d0
02:00002848 4201            	  4063:                 move.b #$00,d1
02:0000284A 44FC0004        	  4064:                 move #$04,CCR              * Set Z flag to 0
02:0000284E 8101            	  4065:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
02:00002850 67FE            	  4066:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4067: 
02:00002852 4E75            	  4068:                 rts
                            	  4069: 
                            	  4070: *-----------------------------------------------------------
                            	  4071: *-----------------------------------------------------------
                            	  4072: * OPCODE : NBCD
                            	  4073: *-----------------------------------------------------------
                            	  4074: *-----------------------------------------------------------
                            	  4075: op_NBCD:
                            	  4076: 
                            	  4077: *        NBCD to a  Register
                            	  4078: 
02:00002854 7000            	  4079:                 moveq  #$00000000,d0 * BCD byte
02:00002856 7200            	  4080:                 moveq  #$00000000,d1
02:00002858 7400            	  4081:                 moveq  #$00000000,d2
02:0000285A 7600            	  4082:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
02:0000285C 7800            	  4083:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:0000285E 7A00            	  4084:                 moveq  #$00000000,d5 * Cumulative BCD results
02:00002860 2C3C00000099    	  4085:                 move.l #$00000099,d6
02:00002866 2E3C00000099    	  4086:                 move.l #$00000099,d7 * Loop counter
                            	  4087: 
02:0000286C 2007            	  4088: NBCD_LOOP:      move.l d7,d0
02:0000286E 44FC0004        	  4089:                 move #$04,CCR        * Set Z flag to 0
                            	  4090: 
02:00002872 4800            	  4091:                 nbcd d0
                            	  4092: 
02:00002874 6402            	  4093:                 bcc.s NBCD_NO_C         * Check C Flag
02:00002876 5284            	  4094:                 add.l #1,d4
02:00002878 6602            	  4095: NBCD_NO_C:      bne.s NBCD_NO_Z         * Check Z Flag
02:0000287A 5283            	  4096:                 add.l #1,d3
02:0000287C DA80            	  4097: NBCD_NO_Z:      add.l d0,d5         * Add results into d5
                            	  4098: 
02:0000287E 51CFFFEC        	  4099:                 dbf d7,NBCD_LOOP
                            	  4100: 
02:00002882 0C8300000001    	  4101:                 cmpi.l #$00000001,d3  * Check the cumulative results
02:00002888 66FE            	  4102:                 bne.s *
02:0000288A 0C8400000099    	  4103:                 cmpi.l #$00000099,d4
02:00002890 66FE            	  4104:                 bne.s *
02:00002892 0C8500002E3B    	  4105:                 cmpi.l #$00002E3B,d5
02:00002898 66FE            	  4106:                 bne.s *
                            	  4107: 
                            	  4108: 
                            	  4109: *        NBCD to a memory location
                            	  4110: 
02:0000289A 7000            	  4111:                 moveq  #$00000000,d0 * BCD byte
02:0000289C 7200            	  4112:                 moveq  #$00000000,d1
02:0000289E 7400            	  4113:                 moveq  #$00000000,d2
02:000028A0 7600            	  4114:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
02:000028A2 7800            	  4115:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:000028A4 7A00            	  4116:                 moveq  #$00000000,d5 * Cumulative BCD results
02:000028A6 2C3C00000099    	  4117:                 move.l #$00000099,d6
02:000028AC 2E3C00000099    	  4118:                 move.l #$00000099,d7 * Loop counter
                            	  4119: 
02:000028B2 11C70100        	  4120: NBCD_LOOP1:     move.b d7,$00000100
02:000028B6 44FC0004        	  4121:                 move #$04,CCR        * Set Z flag to 0
                            	  4122: 
02:000028BA 48380100        	  4123:                 nbcd $00000100
02:000028BE 10380100        	  4124:                 move.b $00000100,d0
                            	  4125: 
02:000028C2 6402            	  4126:                 bcc.s NBCD_NO_C1        * Check C Flag
02:000028C4 5284            	  4127:                 add.l #1,d4
02:000028C6 6602            	  4128: NBCD_NO_C1:     bne.s NBCD_NO_Z1        * Check Z Flag
02:000028C8 5283            	  4129:                 add.l #1,d3
02:000028CA DA80            	  4130: NBCD_NO_Z1:     add.l d0,d5         * Add results into d5
                            	  4131: 
02:000028CC 51CFFFE4        	  4132:                 dbf d7,NBCD_LOOP1
                            	  4133: 
02:000028D0 0C8300000001    	  4134:                 cmpi.l #$00000001,d3  * Check the cumulative results
02:000028D6 66FE            	  4135:                 bne.s *
02:000028D8 4A84            	  4136:                 cmpi.l #$00000000,d4
02:000028DA 66FE            	  4137:                 bne.s *
02:000028DC 0C8500002E3B    	  4138:                 cmpi.l #$00002E3B,d5
02:000028E2 66FE            	  4139:                 bne.s *
                            	  4140: 
                            	  4141: 
02:000028E4 4E75            	  4142:                 rts
                            	  4143: 
                            	  4144: 
                            	  4145: 
                            	  4146: *-----------------------------------------------------------
                            	  4147: *-----------------------------------------------------------
                            	  4148: * OPCODE : TRAPV
                            	  4149: *-----------------------------------------------------------
                            	  4150: *-----------------------------------------------------------
                            	  4151: op_TRAPV:
                            	  4152: 
                            	  4153: *     TRAPV will set d0 to 12345678 if V flag is set
                            	  4154: 
02:000028E6 7000            	  4155:                 moveq  #$00000000,d0 * Clear d0
                            	  4156: 
02:000028E8 44FC0000        	  4157:                 move #$00,CCR        * Clear V flag
02:000028EC 4E76            	  4158:                 trapv
02:000028EE 4A80            	  4159:                 cmpi.l #$00000000,d0  * Check of d0 was updated (should not be_)
02:000028F0 66FE            	  4160:                 bne.s *
                            	  4161: 
02:000028F2 44FC0002        	  4162:                 move #$02,CCR        * Set V flag
02:000028F6 4E76            	  4163:                 trapv
02:000028F8 0C8012345678    	  4164:                 cmpi.l #$12345678,d0  * Check of d0 was updated (should not be_)
02:000028FE 66FE            	  4165:                 bne.s *
                            	  4166: 
                            	  4167: 
02:00002900 4E75            	  4168:                 rts
                            	  4169: 
                            	  4170: 
                            	  4171: 
                            	  4172: *-----------------------------------------------------------
                            	  4173: *-----------------------------------------------------------
                            	  4174: * OPCODE : RTR
                            	  4175: *-----------------------------------------------------------
                            	  4176: *-----------------------------------------------------------
                            	  4177: 
                            	  4178: op_RTR:
                            	  4179: 
                            	  4180: *     Leventhal claims only 5 LSB's are popped from the stack to the CCR
                            	  4181: 
02:00002902 41FA000A        	  4182:                 lea 		RTR_DONE,a0
02:00002906 2F08            	  4183:                 move.l 	a0,-(a7)     * push destination PC to the stack
02:00002908 3F3CFF15        	  4184:                 move.w 	#$FF15,-(a7)       * push flags=0xFFFF to the stack
02:0000290C 4E77            	  4185:                 rtr
                            	  4186: 
02:0000290E 40C0            	  4187: RTR_DONE:       move.w SR,d0
02:00002910 0240001F        	  4188:                 andi.w #$1F,d0
02:00002914 0C400015        	  4189:                 cmpi.w #$15,d0
02:00002918 66FE            	  4190:                 bne.s *
                            	  4191: 
02:0000291A 4E75            	  4192:                 rts
                            	  4193: 
                            	  4194: 
02:0000291C 283C44444444    	  4195: BSR_FAR2:       move.l #$44444444,d4
02:00002922 4E75            	  4196:                 rts
                            	  4197: 
                            	  4198: 
                            	  4199: *-----------------------------------------------------------
                            	  4200: *-----------------------------------------------------------
                            	  4201: * OPCODE : BCC
                            	  4202: *-----------------------------------------------------------
                            	  4203: *-----------------------------------------------------------
                            	  4204: 
02:00002924 44FC0000        	  4205: op_BCC:         move #$00,CCR
02:00002928 6202            	  4206:                 bhi.s BCC1            * Higher Than         C=0 AND Z=0
02:0000292A 60FE            	  4207:                 bra.s *
                            	  4208: 
02:0000292C 44FC0001        	  4209: BCC1:           move #$01,CCR
02:00002930 63000004        	  4210:                 bls.w BCC2            * Lower or Same       C=1 OR Z=1
02:00002934 60FE            	  4211:                 bra.s *
                            	  4212: 
02:00002936 44FC0000        	  4213: BCC2:           move #$00,CCR
02:0000293A 6402            	  4214:                 bcc.s BCC3            * Carry Clear         C=0
02:0000293C 60FE            	  4215:                 bra.s *
                            	  4216: 
02:0000293E 44FC0001        	  4217: BCC3:           move #$01,CCR
02:00002942 65000004        	  4218:                 bcs.w BCC4            * Carry Set           C=1
02:00002946 60FE            	  4219:                 bra.s *
                            	  4220: 
02:00002948 44FC0000        	  4221: BCC4:           move #$00,CCR
02:0000294C 6602            	  4222:                 bne.s BCC5            * Not Equal           Z=0
02:0000294E 60FE            	  4223:                 bra.s *
                            	  4224: 
02:00002950 44FC0004        	  4225: BCC5:           move #$04,CCR
02:00002954 67000004        	  4226:                 beq.w BCC6            * Equal               Z=1
02:00002958 60FE            	  4227:                 bra.s *
                            	  4228: 
02:0000295A 44FC0000        	  4229: BCC6:           move #$00,CCR
02:0000295E 6802            	  4230:                 bvc.s BCC7            * V Clear             V=0
02:00002960 60FE            	  4231:                 bra.s *
                            	  4232: 
02:00002962 44FC0002        	  4233: BCC7:           move #$02,CCR
02:00002966 69000004        	  4234:                 bvs.w BCC8            * V Set               V=1
02:0000296A 60FE            	  4235:                 bra.s *
                            	  4236: 
02:0000296C 44FC0000        	  4237: BCC8:           move #$00,CCR
02:00002970 6A02            	  4238:                 bpl.s BCC9            * Plus                N=0
02:00002972 60FE            	  4239:                 bra.s *
                            	  4240: 
02:00002974 44FC0008        	  4241: BCC9:           move #$08,CCR
02:00002978 6B000004        	  4242:                 bmi.w BCC10           * Minus               N=1
02:0000297C 60FE            	  4243:                 bra.s *
                            	  4244: 
02:0000297E 44FC0000        	  4245: BCC10:          move #$00,CCR
02:00002982 6C02            	  4246:                 bge.s BCC11           * Greater or Equal    N=V
02:00002984 60FE            	  4247:                 bra.s *
                            	  4248: 
02:00002986 44FC0002        	  4249: BCC11:          move #$02,CCR
02:0000298A 6D000004        	  4250:                 blt.w BCC12           * Less Than           N!=V
02:0000298E 60FE            	  4251:                 bra.s *
                            	  4252: 
02:00002990 44FC000A        	  4253: BCC12:          move #$0A,CCR
02:00002994 6E02            	  4254:                 bgt.s BCC13           * Greater Than        N=V  AND Z=0
02:00002996 60FE            	  4255:                 bra.s *
                            	  4256: 
02:00002998 44FC0006        	  4257: BCC13:          move #$06,CCR
02:0000299C 6F000004        	  4258:                 ble.w BCC14           * Less Than or Equal  N!=V AND Z=1
02:000029A0 60FE            	  4259:                 bra.s *
                            	  4260: 
                            	  4261: 
02:000029A2 4E75            	  4262: BCC14:          rts
                            	  4263: 
                            	  4264: 
                            	  4265: *-----------------------------------------------------------
                            	  4266: *-----------------------------------------------------------
                            	  4267: * OPCODE : DBCC
                            	  4268: *-----------------------------------------------------------
                            	  4269: *-----------------------------------------------------------
                            	  4270: 
02:000029A4 7003            	  4271: op_DBCC:        moveq  #$00000003,d0    * Loop counter
02:000029A6 7200            	  4272:                 moveq  #$00000000,d1    * Accumulator
02:000029A8 44FC0000        	  4273:                 move #$00,CCR
                            	  4274: 
02:000029AC 5201            	  4275: DBCC_LOOP1:     addi.b #$1,d1
02:000029AE 51C8FFFC        	  4276:                 dbf d0,DBCC_LOOP1
                            	  4277: 
02:000029B2 0C8100000004    	  4278:                 cmpi.l #$00000004,d1  * Check Accumulator results
02:000029B8 66FE            	  4279:                 bne.s *
                            	  4280: 
02:000029BA 5201            	  4281: DBCC_LOOP2:     addi.b #$1,d1
02:000029BC 54C8FFFC        	  4282:                 dbcc d0,DBCC_LOOP2    * Dont loop
                            	  4283: 
02:000029C0 0C8100000005    	  4284:                 cmpi.l #$00000005,d1  * Check Accumulator results
02:000029C6 66FE            	  4285:                 bne.s *
                            	  4286: 
02:000029C8 4E75            	  4287:                 rts
                            	  4288: 
                            	  4289: 
                            	  4290: *-----------------------------------------------------------
                            	  4291: *-----------------------------------------------------------
                            	  4292: * OPCODE : SCC
                            	  4293: *-----------------------------------------------------------
                            	  4294: *-----------------------------------------------------------
                            	  4295: 
02:000029CA 44FC0001        	  4296: op_SCC:         move #$01,CCR
02:000029CE 54F900010000    	  4297:                 scc $00010000                   * Clear the EA byte
02:000029D4 4A3900010000    	  4298:                 cmpi.b #$00,$00010000
02:000029DA 66FE            	  4299:                 bne.s *
                            	  4300: 
02:000029DC 44FC0000        	  4301:                 move #$00,CCR
02:000029E0 54F900010000    	  4302:                 scc $00010000                   * Set the EA byte to 0xFF
02:000029E6 0C3900FF00010000	  4303:                 cmpi.b #$FF,$00010000
02:000029EE 66FE            	  4304:                 bne.s *
                            	  4305: 
02:000029F0 54C0            	  4306: 								scc d0													* Test setting a data register
02:000029F2 0C0000FF        	  4307: 								cmpi.b #$FF,d0
02:000029F6 66FE            	  4308: 								bne.s *
02:000029F8 4E75            	  4309:                 rts
                            	  4310: 
                            	  4311: 
                            	  4312: 
                            	  4313: *-----------------------------------------------------------
                            	  4314: *-----------------------------------------------------------
                            	  4315: * OPCODE : ADDQ
                            	  4316: *-----------------------------------------------------------
                            	  4317: *-----------------------------------------------------------
                            	  4318: 
                            	  4319: op_ADDQ:
                            	  4320: 
                            	  4321: *     BYTE
02:000029FA 203C000000FF    	  4322:                 move.l #$000000FF,d0    * Loop counter
02:00002A00 7200            	  4323:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A02 7400            	  4324:                 moveq  #$00000000,d2    * Data results accumulator
02:00002A04 7600            	  4325:                 moveq  #$00000000,d3
02:00002A06 7800            	  4326:                 moveq  #$00000000,d4
02:00002A08 7A00            	  4327:                 moveq  #$00000000,d5
02:00002A0A 7C00            	  4328:                 moveq  #$00000000,d6
02:00002A0C 7E00            	  4329:                 moveq  #$00000000,d7
                            	  4330: 
02:00002A0E 5605            	  4331: ADDQ_LOOP1:     addq.b #3,d5
02:00002A10 40C6            	  4332:                 move.w SR,d6
02:00002A12 02860000001F    	  4333:                 andi.l #$1F,d6        * Isolate flags
02:00002A18 D286            	  4334:                 add.l d6,d1           * Copy flag results into accumulator
02:00002A1A D485            	  4335:                 add.l d5,d2           * Copy data results into data accumulator
02:00002A1C 51C8FFF0        	  4336:                 dbf d0,ADDQ_LOOP1
                            	  4337: 
02:00002A20 0C810000043D    	  4338:                 cmpi.l #$0000043D,d1
02:00002A26 66FE            	  4339:                 bne.s *
02:00002A28 0C8200007F80    	  4340:                 cmpi.l #$00007F80,d2
02:00002A2E 66FE            	  4341:                 bne.s *
                            	  4342: 
                            	  4343: 
                            	  4344: *     WORD
02:00002A30 203C000000FF    	  4345:                 move.l #$000000FF,d0    * Loop counter
02:00002A36 7200            	  4346:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A38 7400            	  4347:                 moveq  #$00000000,d2    * Data results accumulator
02:00002A3A 7600            	  4348:                 moveq  #$00000000,d3
02:00002A3C 7800            	  4349:                 moveq  #$00000000,d4
02:00002A3E 2A3C0000FFF0    	  4350:                 move.l #$0000FFF0,d5
02:00002A44 7C00            	  4351:                 moveq  #$00000000,d6
02:00002A46 7E00            	  4352:                 moveq  #$00000000,d7
02:00002A48 307C0100        	  4353:                 move.l #$00000100,a0
                            	  4354: 
02:00002A4C 5A45            	  4355: ADDQ_LOOP2:     addq.w #5,d5
02:00002A4E 40C6            	  4356:                 move.w SR,d6
02:00002A50 02860000001F    	  4357:                 andi.l #$1F,d6        * Isolate flags
02:00002A56 D286            	  4358:                 add.l d6,d1           * Copy flag results into accumulator
02:00002A58 D485            	  4359:                 add.l d5,d2           * Copy data results into data accumulator
02:00002A5A 51C8FFF0        	  4360:                 dbf d0,ADDQ_LOOP2
                            	  4361: 
02:00002A5E 0C8100000029    	  4362:                 cmpi.l #$00000029,d1
02:00002A64 66FE            	  4363:                 bne.s *
02:00002A66 0C8200057280    	  4364:                 cmpi.l #$00057280,d2
02:00002A6C 66FE            	  4365:                 bne.s *
                            	  4366: 
                            	  4367: 
                            	  4368: *     LONG
02:00002A6E 203C000000FF    	  4369:                 move.l #$000000FF,d0    * Loop counter
02:00002A74 7200            	  4370:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A76 7400            	  4371:                 moveq  #$00000000,d2    * Data results accumulator
02:00002A78 7600            	  4372:                 moveq  #$00000000,d3
02:00002A7A 7800            	  4373:                 moveq  #$00000000,d4
02:00002A7C 7AF0            	  4374:                 move.l #$FFFFFFF0,d5
02:00002A7E 7C00            	  4375:                 moveq  #$00000000,d6
02:00002A80 7E00            	  4376:                 moveq  #$00000000,d7
                            	  4377: 
02:00002A82 5285            	  4378: ADDQ_LOOP3:     addq.l #1,d5
02:00002A84 40C6            	  4379:                 move.w SR,d6
02:00002A86 02860000001F    	  4380:                 andi.l #$1F,d6        * Isolate flags
02:00002A8C D286            	  4381:                 add.l d6,d1           * Copy flag results into accumulator
02:00002A8E D485            	  4382:                 add.l d5,d2           * Copy data results into data accumulator
02:00002A90 51C8FFF0        	  4383:                 dbf d0,ADDQ_LOOP3
                            	  4384: 
02:00002A94 0C810000008D    	  4385:                 cmpi.l #$0000008D,d1
02:00002A9A 66FE            	  4386:                 bne.s *
02:00002A9C 0C8200007080    	  4387:                 cmpi.l #$00007080,d2
02:00002AA2 66FE            	  4388:                 bne.s *
                            	  4389: 
                            	  4390: *     Check that Flags are not updated for Address registers
02:00002AA4 207C0000FFFF    	  4391:                 move.l #$0000FFFF,a0
02:00002AAA 44FC0000        	  4392:                 move #$00,CCR         * Clear flags
02:00002AAE 5E48            	  4393:                 addq.w #$7,a0
02:00002AB0 65FE            	  4394:                 bcs.s *
                            	  4395: 
02:00002AB2 4E75            	  4396:                 rts
                            	  4397: 
                            	  4398: 
                            	  4399: 
                            	  4400: *-----------------------------------------------------------
                            	  4401: *-----------------------------------------------------------
                            	  4402: * OPCODE : SUBQ
                            	  4403: *-----------------------------------------------------------
                            	  4404: *-----------------------------------------------------------
                            	  4405: 
                            	  4406: op_SUBQ:
                            	  4407: 
                            	  4408: *     BYTE
02:00002AB4 203C000000FF    	  4409:                 move.l #$000000FF,d0    * Loop counter
02:00002ABA 7200            	  4410:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002ABC 243C00001234    	  4411:                 move.l #$00001234,d2    * Data results accumulator
02:00002AC2 7600            	  4412:                 moveq  #$00000000,d3
02:00002AC4 7800            	  4413:                 moveq  #$00000000,d4
02:00002AC6 7A12            	  4414:                 moveq  #$00000012,d5
02:00002AC8 7C00            	  4415:                 moveq  #$00000000,d6
02:00002ACA 7E00            	  4416:                 moveq  #$00000000,d7
                            	  4417: 
02:00002ACC 5305            	  4418: SUBQ_LOOP1:     subq.b #1,d5
02:00002ACE 40C6            	  4419:                 move.w SR,d6
02:00002AD0 02860000001F    	  4420:                 andi.l #$1F,d6        * Isolate flags
02:00002AD6 D286            	  4421:                 add.l d6,d1           * Copy flag results into accumulator
02:00002AD8 D485            	  4422:                 add.l d5,d2           * Copy data results into data accumulator
02:00002ADA 51C8FFF0        	  4423:                 dbf d0,SUBQ_LOOP1
                            	  4424: 
02:00002ADE 0C8100000417    	  4425:                 cmpi.l #$00000417,d1
02:00002AE4 66FE            	  4426:                 bne.s *
02:00002AE6 0C82000091B4    	  4427:                 cmpi.l #$000091B4,d2
02:00002AEC 66FE            	  4428:                 bne.s *
                            	  4429: 
                            	  4430: 
                            	  4431: *     WORD
02:00002AEE 203C000000FF    	  4432:                 move.l #$000000FF,d0    * Loop counter
02:00002AF4 7200            	  4433:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002AF6 7400            	  4434:                 moveq  #$00000000,d2    * Data results accumulator
02:00002AF8 7600            	  4435:                 moveq  #$00000000,d3
02:00002AFA 7800            	  4436:                 moveq  #$00000000,d4
02:00002AFC 7A02            	  4437:                 moveq  #$00000002,d5
02:00002AFE 7C00            	  4438:                 moveq  #$00000000,d6
02:00002B00 7E00            	  4439:                 moveq  #$00000000,d7
02:00002B02 307C0100        	  4440:                 move.l #$00000100,a0
                            	  4441: 
02:00002B06 5B45            	  4442: SUBQ_LOOP2:     subq.w #5,d5
02:00002B08 40C6            	  4443:                 move.w SR,d6
02:00002B0A 02860000001F    	  4444:                 andi.l #$1F,d6        * Isolate flags
02:00002B10 D286            	  4445:                 add.l d6,d1           * Copy flag results into accumulator
02:00002B12 D485            	  4446:                 add.l d5,d2           * Copy data results into data accumulator
02:00002B14 51C8FFF0        	  4447:                 dbf d0,SUBQ_LOOP2
                            	  4448: 
02:00002B18 0C8100000811    	  4449:                 cmpi.l #$00000811,d1
02:00002B1E 66FE            	  4450:                 bne.s *
02:00002B20 0C8200FD7F80    	  4451:                 cmpi.l #$00FD7F80,d2
02:00002B26 66FE            	  4452:                 bne.s *
                            	  4453: 
                            	  4454: 
                            	  4455: *     LONG
02:00002B28 203C000000FF    	  4456:                 move.l #$000000FF,d0    * Loop counter
02:00002B2E 7200            	  4457:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002B30 7400            	  4458:                 moveq  #$00000000,d2    * Data results accumulator
02:00002B32 7600            	  4459:                 moveq  #$00000000,d3
02:00002B34 7800            	  4460:                 moveq  #$00000000,d4
02:00002B36 7A07            	  4461:                 moveq  #$00000007,d5
02:00002B38 7C00            	  4462:                 moveq  #$00000000,d6
02:00002B3A 7E00            	  4463:                 moveq  #$00000000,d7
                            	  4464: 
02:00002B3C 5385            	  4465: SUBQ_LOOP3:     subq.l #1,d5
02:00002B3E 40C6            	  4466:                 move.w SR,d6
02:00002B40 02860000001F    	  4467:                 andi.l #$1F,d6        * Isolate flags
02:00002B46 D286            	  4468:                 add.l d6,d1           * Copy flag results into accumulator
02:00002B48 D485            	  4469:                 add.l d5,d2           * Copy data results into data accumulator
02:00002B4A 51C8FFF0        	  4470:                 dbf d0,SUBQ_LOOP3
                            	  4471: 
02:00002B4E 0C81000007DD    	  4472:                 cmpi.l #$000007DD,d1
02:00002B54 66FE            	  4473:                 bne.s *
02:00002B56 0C82FFFF8680    	  4474:                 cmpi.l #$FFFF8680,d2
02:00002B5C 66FE            	  4475:                 bne.s *
                            	  4476: 
                            	  4477: *     Check that Flags are not updated for Address registers
02:00002B5E 207C0001FFFF    	  4478:                 move.l #$0001FFFF,a0
02:00002B64 44FC0000        	  4479:                 move #$00,CCR         * Clear flags
02:00002B68 5F48            	  4480:                 subq.w #$7,a0
02:00002B6A 65FE            	  4481:                 bcs.s *
                            	  4482: 
02:00002B6C 4E75            	  4483:                 rts
                            	  4484: 
                            	  4485: 
                            	  4486: 
                            	  4487: 
                            	  4488: *-----------------------------------------------------------
                            	  4489: *-----------------------------------------------------------
                            	  4490: * OPCODE : MOVEQ
                            	  4491: *-----------------------------------------------------------
                            	  4492: *-----------------------------------------------------------
                            	  4493: 
                            	  4494: op_MOVEQ:
02:00002B6E 7000            	  4495:                 moveq  #$00000000,d0
02:00002B70 7000            	  4496:                 moveq #$0,d0
02:00002B72 66FE            	  4497:                 bne.s *
02:00002B74 4A80            	  4498:                 cmpi.l #$00000000,d0
02:00002B76 66FE            	  4499:                 bne.s *
                            	  4500: 
02:00002B78 7000            	  4501:                 moveq  #$00000000,d0
02:00002B7A 7080            	  4502:                 moveq #-128,d0
02:00002B7C 67FE            	  4503:                 beq.s *
02:00002B7E 6AFE            	  4504:                 bpl.s *
02:00002B80 0C80FFFFFF80    	  4505:                 cmpi.l #$FFFFFF80,d0
02:00002B86 66FE            	  4506:                 bne.s *
                            	  4507: 
                            	  4508: 
02:00002B88 4E75            	  4509:                 rts
                            	  4510: 
                            	  4511: 
                            	  4512: *-----------------------------------------------------------
                            	  4513: *-----------------------------------------------------------
                            	  4514: * OPCODE : DIVU
                            	  4515: *-----------------------------------------------------------
                            	  4516: *-----------------------------------------------------------
                            	  4517: 
                            	  4518: op_DIVU:
                            	  4519: 
02:00002B8A 203CA5A5A5A5    	  4520:                 move.l #$a5a5a5a5,d0        * Initial Numerator
02:00002B90 223C00005A5A    	  4521:                 move.l #$00005a5a,d1        * Initial Divisor
02:00002B96 243CA5A5A5A5    	  4522:                 move.l #$a5a5a5a5,d2
02:00002B9C 7600            	  4523:                 moveq  #$00000000,d3
02:00002B9E 7800            	  4524:                 moveq  #$00000000,d4        * Cumulative data results
02:00002BA0 7A00            	  4525:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002BA2 7C0E            	  4526:                 move.l #$0000000E,d6       * Inner loop counter
02:00002BA4 7E1E            	  4527:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4528: 
                            	  4529: 
02:00002BA6 80C1            	  4530: DIVU_OUTER1:    divu d1,d0               * !! Easy68K C not always cleared
02:00002BA8 40C3            	  4531:                 move.w SR,d3
02:00002BAA 02830000000C    	  4532:                 andi.l #$0C,d3            * Isolate flags
02:00002BB0 DA83            	  4533:                 add.l d3,d5               * Copy flag results into accumulator
02:00002BB2 D880            	  4534:                 add.l d0,d4               * Copy data results into data accumulator
02:00002BB4 E289            	  4535:                 lsr.l #$1,d1
                            	  4536: 
02:00002BB6 51CEFFEE        	  4537:                 dbf d6,DIVU_OUTER1
02:00002BBA E28A            	  4538:                 lsr.l #$1,d2
02:00002BBC 2002            	  4539:                 move.l d2,d0
02:00002BBE 223C00005A5A    	  4540:                 move.l #$00005a5a,d1       * Initial Divisor
02:00002BC4 7C0E            	  4541:                 move.l #$0000000E,d6       * Inner loop counter
02:00002BC6 51CFFFDE        	  4542:                 dbf d7,DIVU_OUTER1
                            	  4543: 
02:00002BCA 0C8492FEDB89    	  4544:                 cmpi.l #$92FEDB89,d4      * Check the data results
02:00002BD0 66FE            	  4545:                 bne.s *
                            	  4546: 
02:00002BD2 0C8500000110    	  4547:                 cmpi.l #$00000110,d5      * Check the Flag results
02:00002BD8 66FE            	  4548:                 bne.s *
                            	  4549: 
                            	  4550: 
02:00002BDA 4E75            	  4551:                 rts
                            	  4552: 
                            	  4553: 
                            	  4554: 
                            	  4555: *-----------------------------------------------------------
                            	  4556: *-----------------------------------------------------------
                            	  4557: * OPCODE : DIVS
                            	  4558: *-----------------------------------------------------------
                            	  4559: *-----------------------------------------------------------
                            	  4560: 
                            	  4561: op_DIVS:
                            	  4562: 
02:00002BDC 203CA5A5A5A5    	  4563:                 move.l #$a5a5a5a5,d0        * Initial Numerator
02:00002BE2 223C00005A5A    	  4564:                 move.l #$00005a5a,d1        * Initial Divisor
02:00002BE8 243CA5A5A5A5    	  4565:                 move.l #$a5a5a5a5,d2
02:00002BEE 7600            	  4566:                 moveq  #$00000000,d3
02:00002BF0 7800            	  4567:                 moveq  #$00000000,d4        * Cumulative data results
02:00002BF2 7A00            	  4568:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002BF4 7C0E            	  4569:                 move.l #$0000000E,d6       * Inner loop counter
02:00002BF6 7E1E            	  4570:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4571: 
                            	  4572: 
02:00002BF8 81C1            	  4573: DIVS_OUTER1:    divs d1,d0               * !! Easy68K C not always cleared
02:00002BFA 40C3            	  4574:                 move.w SR,d3
02:00002BFC 02830000000C    	  4575:                 andi.l #$0C,d3            * Isolate flags
02:00002C02 DA83            	  4576:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C04 D880            	  4577:                 add.l d0,d4               * Copy data results into data accumulator
02:00002C06 E289            	  4578:                 lsr.l #$1,d1
                            	  4579: 
02:00002C08 51CEFFEE        	  4580:                 dbf d6,DIVS_OUTER1
02:00002C0C E28A            	  4581:                 lsr.l #$1,d2
02:00002C0E 2002            	  4582:                 move.l d2,d0
02:00002C10 223C00005A5A    	  4583:                 move.l #$00005a5a,d1       * Initial Divisor
02:00002C16 7C0E            	  4584:                 move.l #$0000000E,d6       * Inner loop counter
02:00002C18 51CFFFDE        	  4585:                 dbf d7,DIVS_OUTER1
                            	  4586: 
02:00002C1C 0C844EC5D057    	  4587:                 cmpi.l #$4EC5D057,d4      * Check the data results
02:00002C22 66FE            	  4588:                 bne.s *
                            	  4589: 
02:00002C24 0C8500000038    	  4590:                 cmpi.l #$00000038,d5      * Check the Flag results
02:00002C2A 66FE            	  4591:                 bne.s *
                            	  4592: 
                            	  4593: 
02:00002C2C 4E75            	  4594:                 rts
                            	  4595: 
                            	  4596: 
                            	  4597: 
                            	  4598: *-----------------------------------------------------------
                            	  4599: *-----------------------------------------------------------
                            	  4600: * OPCODE : OR
                            	  4601: *-----------------------------------------------------------
                            	  4602: *-----------------------------------------------------------
                            	  4603: 
                            	  4604: op_OR:
                            	  4605: 
                            	  4606: *  * <EA> to Register
                            	  4607: 
02:00002C2E 203CA5A5A5A5    	  4608:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002C34 223C8167E123    	  4609:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002C3A 243CA5A5A5A5    	  4610:                 move.l #$a5a5a5a5,d2
02:00002C40 7600            	  4611:                 moveq  #$00000000,d3
02:00002C42 7800            	  4612:                 moveq  #$00000000,d4       * Cumulative data results
02:00002C44 7A00            	  4613:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002C46 7C1E            	  4614:                 move.l #$0000001E,d6       * Inner loop counter
02:00002C48 7E1E            	  4615:                 move.l #$0000001E,d7       * Outer loop counter
02:00002C4A 307C0100        	  4616:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4617: 
                            	  4618: 
                            	  4619: OR_OUTER1:
                            	  4620: 
                            	  4621: *     BYTE
02:00002C4E 2081            	  4622:                 move.l d1,(a0)
02:00002C50 8010            	  4623:                 or.b (a0),d0
02:00002C52 40C3            	  4624:                 move.w SR,d3
02:00002C54 02830000000C    	  4625:                 andi.l #$0C,d3            * Isolate flags
02:00002C5A DA83            	  4626:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C5C D880            	  4627:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4628: 
                            	  4629: *     WORD
02:00002C5E 2081            	  4630:                 move.l d1,(a0)
02:00002C60 8050            	  4631:                 or.w (a0),d0
02:00002C62 40C3            	  4632:                 move.w SR,d3
02:00002C64 02830000000C    	  4633:                 andi.l #$0C,d3            * Isolate flags
02:00002C6A DA83            	  4634:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C6C D880            	  4635:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4636: 
                            	  4637: *     LONG
02:00002C6E 2081            	  4638:                 move.l d1,(a0)
02:00002C70 8090            	  4639:                 or.l (a0),d0
02:00002C72 40C3            	  4640:                 move.w SR,d3
02:00002C74 02830000000F    	  4641:                 andi.l #$0F,d3            * Isolate flags
02:00002C7A DA83            	  4642:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C7C D880            	  4643:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4644: 
                            	  4645: 
02:00002C7E E289            	  4646:                 lsr.l #$1,d1
02:00002C80 51CEFFCC        	  4647:                 dbf d6,OR_OUTER1
02:00002C84 E28A            	  4648:                 lsr.l #$1,d2
02:00002C86 223C8167E123    	  4649:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002C8C 7C1E            	  4650:                 move.l #$0000001E,d6       * Inner loop counter
02:00002C8E 51CFFFBE        	  4651:                 dbf d7,OR_OUTER1
                            	  4652: 
02:00002C92 0C8476EAC803    	  4653:                 cmpi.l #$76EAC803,d4      * Check the data results
02:00002C98 66FE            	  4654:                 bne.s *
02:00002C9A 0C8500005A18    	  4655:                 cmpi.l #$00005A18,d5      * Check the Flag results
02:00002CA0 66FE            	  4656:                 bne.s *
                            	  4657: 
                            	  4658: 
                            	  4659: *  * Register to <EA>
                            	  4660: 
02:00002CA2 203C86738374    	  4661:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002CA8 223CFC55F2FE    	  4662:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002CAE 243C86738374    	  4663:                 move.l #$86738374,d2
02:00002CB4 7600            	  4664:                 moveq  #$00000000,d3
02:00002CB6 7800            	  4665:                 moveq  #$00000000,d4       * Cumulative data results
02:00002CB8 7A00            	  4666:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002CBA 7C1E            	  4667:                 move.l #$0000001E,d6       * Inner loop counter
02:00002CBC 7E1D            	  4668:                 move.l #$0000001D,d7       * Outer loop counter
02:00002CBE 307C0100        	  4669:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4670: 
                            	  4671: 
                            	  4672: OR_OUTER2:
                            	  4673: 
                            	  4674: *     BYTE
02:00002CC2 2080            	  4675:                 move.l d0,(a0)
02:00002CC4 8310            	  4676:                 or.b d1,(a0)
02:00002CC6 40C3            	  4677:                 move.w SR,d3
02:00002CC8 02830000000C    	  4678:                 andi.l #$0C,d3            * Isolate flags
02:00002CCE DA83            	  4679:                 add.l d3,d5               * Copy flag results into accumulator
02:00002CD0 D890            	  4680:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4681: 
                            	  4682: *     WORD
02:00002CD2 2080            	  4683:                 move.l d0,(a0)
02:00002CD4 8350            	  4684:                 or.w d1,(a0)
02:00002CD6 40C3            	  4685:                 move.w SR,d3
02:00002CD8 02830000000C    	  4686:                 andi.l #$0C,d3            * Isolate flags
02:00002CDE DA83            	  4687:                 add.l d3,d5               * Copy flag results into accumulator
02:00002CE0 D890            	  4688:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4689: 
                            	  4690: *     LONG
02:00002CE2 2080            	  4691:                 move.l d0,(a0)
02:00002CE4 8390            	  4692:                 or.l d1,(a0)
02:00002CE6 40C3            	  4693:                 move.w SR,d3
02:00002CE8 02830000000F    	  4694:                 andi.l #$0F,d3            * Isolate flags
02:00002CEE DA83            	  4695:                 add.l d3,d5               * Copy flag results into accumulator
02:00002CF0 D890            	  4696:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4697: 
                            	  4698: 
02:00002CF2 E289            	  4699:                 lsr.l #$1,d1
02:00002CF4 51CEFFCC        	  4700:                 dbf d6,OR_OUTER2
02:00002CF8 E28A            	  4701:                 lsr.l #$1,d2
02:00002CFA 223C8167E123    	  4702:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002D00 7C1E            	  4703:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D02 51CFFFBE        	  4704:                 dbf d7,OR_OUTER2
                            	  4705: 
02:00002D06 0C84FA82B9E4    	  4706:                 cmpi.l #$FA82B9E4,d4      * Check the data results
02:00002D0C 66FE            	  4707:                 bne.s *
02:00002D0E 0C8500005730    	  4708:                 cmpi.l #$00005730,d5      * Check the Flag results
02:00002D14 66FE            	  4709:                 bne.s *
                            	  4710: 
                            	  4711: 
02:00002D16 4E75            	  4712:                 rts
                            	  4713: 
                            	  4714: 
                            	  4715: 
                            	  4716: *-----------------------------------------------------------
                            	  4717: *-----------------------------------------------------------
                            	  4718: * OPCODE : AND
                            	  4719: *-----------------------------------------------------------
                            	  4720: *-----------------------------------------------------------
                            	  4721: 
                            	  4722: op_AND:
                            	  4723: 
                            	  4724: *  * <EA> to Register
                            	  4725: 
02:00002D18 203CA5A5A5A5    	  4726:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002D1E 223C8167E123    	  4727:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002D24 243CA5A5A5A5    	  4728:                 move.l #$a5a5a5a5,d2
02:00002D2A 7600            	  4729:                 moveq  #$00000000,d3
02:00002D2C 7800            	  4730:                 moveq  #$00000000,d4       * Cumulative data results
02:00002D2E 7A00            	  4731:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002D30 7C1E            	  4732:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D32 7E1E            	  4733:                 move.l #$0000001E,d7       * Outer loop counter
02:00002D34 307C0100        	  4734:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4735: 
                            	  4736: 
                            	  4737: AND_OUTER1:
                            	  4738: 
                            	  4739: *     BYTE
02:00002D38 2081            	  4740:                 move.l d1,(a0)
02:00002D3A C010            	  4741:                 and.b (a0),d0
02:00002D3C 40C3            	  4742:                 move.w sr,d3
02:00002D3E 02830000000C    	  4743:                 andi.l #$0C,d3            * Isolate flags
02:00002D44 DA83            	  4744:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D46 D880            	  4745:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4746: 
                            	  4747: *     WORD
02:00002D48 2081            	  4748:                 move.l d1,(a0)
02:00002D4A C050            	  4749:                 and.w (a0),d0
02:00002D4C 40C3            	  4750:                 move.w sr,d3
02:00002D4E 02830000000C    	  4751:                 andi.l #$0C,d3            * Isolate flags
02:00002D54 DA83            	  4752:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D56 D880            	  4753:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4754: 
                            	  4755: *     LONG
02:00002D58 2081            	  4756:                 move.l d1,(a0)
02:00002D5A C090            	  4757:                 and.l (a0),d0
02:00002D5C 40C3            	  4758:                 move.w sr,d3
02:00002D5E 02830000000F    	  4759:                 andi.l #$0F,d3            * Isolate flags
02:00002D64 DA83            	  4760:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D66 D880            	  4761:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4762: 
                            	  4763: 
02:00002D68 E289            	  4764:                 lsr.l #$1,d1
02:00002D6A 51CEFFCC        	  4765:                 dbf d6,AND_OUTER1
02:00002D6E E28A            	  4766:                 lsr.l #$1,d2
02:00002D70 223C8167E123    	  4767:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002D76 7C1E            	  4768:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D78 51CFFFBE        	  4769:                 dbf d7,AND_OUTER1
                            	  4770: 
02:00002D7C 0C84CF212883    	  4771:                 cmpi.l #$CF212883,d4      * Check the data results
02:00002D82 66FE            	  4772:                 bne.s *
02:00002D84 0C8500002D10    	  4773:                 cmpi.l #$00002D10,d5      * Check the Flag results
02:00002D8A 66FE            	  4774:                 bne.s *
                            	  4775: 
                            	  4776: 
                            	  4777: *  * Register to <EA>
                            	  4778: 
02:00002D8C 203C86738374    	  4779:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002D92 223CFC55F2FE    	  4780:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002D98 243C86738374    	  4781:                 move.l #$86738374,d2
02:00002D9E 7600            	  4782:                 moveq  #$00000000,d3
02:00002DA0 7800            	  4783:                 moveq  #$00000000,d4       * Cumulative data results
02:00002DA2 7A00            	  4784:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002DA4 7C1E            	  4785:                 move.l #$0000001E,d6       * Inner loop counter
02:00002DA6 7E1D            	  4786:                 move.l #$0000001D,d7       * Outer loop counter
02:00002DA8 307C0100        	  4787:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4788: 
                            	  4789: 
                            	  4790: AND_OUTER2:
                            	  4791: 
                            	  4792: *     BYTE
02:00002DAC 2080            	  4793:                 move.l d0,(a0)
02:00002DAE C310            	  4794:                 and.b d1,(a0)
02:00002DB0 40C3            	  4795:                 move.w sr,d3
02:00002DB2 02830000000C    	  4796:                 andi.l #$0C,d3            * Isolate flags
02:00002DB8 DA83            	  4797:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DBA D890            	  4798:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4799: 
                            	  4800: *     WORD
02:00002DBC 2080            	  4801:                 move.l d0,(a0)
02:00002DBE C350            	  4802:                 and.w d1,(a0)
02:00002DC0 40C3            	  4803:                 move.w sr,d3
02:00002DC2 02830000000C    	  4804:                 andi.l #$0C,d3            * Isolate flags
02:00002DC8 DA83            	  4805:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DCA D890            	  4806:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4807: 
                            	  4808: *     LONG
02:00002DCC 2080            	  4809:                 move.l d0,(a0)
02:00002DCE C390            	  4810:                 and.l d1,(a0)
02:00002DD0 40C3            	  4811:                 move.w sr,d3
02:00002DD2 02830000000F    	  4812:                 andi.l #$0F,d3            * Isolate flags
02:00002DD8 DA83            	  4813:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DDA D890            	  4814:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4815: 
                            	  4816: 
02:00002DDC E289            	  4817:                 lsr.l #$1,d1
02:00002DDE 51CEFFCC        	  4818:                 dbf d6,AND_OUTER2
02:00002DE2 E28A            	  4819:                 lsr.l #$1,d2
02:00002DE4 223C8167E123    	  4820:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002DEA 7C1E            	  4821:                 move.l #$0000001E,d6       * Inner loop counter
02:00002DEC 51CFFFBE        	  4822:                 dbf d7,AND_OUTER2
                            	  4823: 
02:00002DF0 0C844A3DE544    	  4824:                 cmpi.l #$4A3DE544,d4      * Check the data results
02:00002DF6 66FE            	  4825:                 bne.s *
02:00002DF8 0C85000018E8    	  4826:                 cmpi.l #$000018E8,d5      * Check the Flag results
02:00002DFE 66FE            	  4827:                 bne.s *
                            	  4828: 
                            	  4829: 
02:00002E00 4E75            	  4830:                 rts
                            	  4831: 
                            	  4832: 
                            	  4833: 
                            	  4834: *-----------------------------------------------------------
                            	  4835: *-----------------------------------------------------------
                            	  4836: * OPCODE : EOR
                            	  4837: *-----------------------------------------------------------
                            	  4838: *-----------------------------------------------------------
                            	  4839: 
                            	  4840: op_EOR:
                            	  4841: 
                            	  4842: *  * Register to <EA>
                            	  4843: 
02:00002E02 203C86738374    	  4844:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002E08 223CFC55F2FE    	  4845:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002E0E 243C86738374    	  4846:                 move.l #$86738374,d2
02:00002E14 7600            	  4847:                 moveq  #$00000000,d3
02:00002E16 7800            	  4848:                 moveq  #$00000000,d4       * Cumulative data results
02:00002E18 7A00            	  4849:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002E1A 7C1E            	  4850:                 move.l #$0000001E,d6       * Inner loop counter
02:00002E1C 7E1D            	  4851:                 move.l #$0000001D,d7       * Outer loop counter
02:00002E1E 307C0100        	  4852:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4853: 
                            	  4854: 
                            	  4855: EOR_OUTER2:
                            	  4856: 
                            	  4857: *     BYTE
02:00002E22 2080            	  4858:                 move.l d0,(a0)
02:00002E24 B310            	  4859:                 eor.b d1,(a0)
02:00002E26 40C3            	  4860:                 move.w sr,d3
02:00002E28 02830000000C    	  4861:                 andi.l #$0C,d3            * Isolate flags
02:00002E2E DA83            	  4862:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E30 D890            	  4863:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4864: 
                            	  4865: *     WORD
02:00002E32 2080            	  4866:                 move.l d0,(a0)
02:00002E34 B350            	  4867:                 eor.w d1,(a0)
02:00002E36 40C3            	  4868:                 move.w sr,d3
02:00002E38 02830000000C    	  4869:                 andi.l #$0C,d3            * Isolate flags
02:00002E3E DA83            	  4870:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E40 D890            	  4871:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4872: 
                            	  4873: *     LONG
02:00002E42 2080            	  4874:                 move.l d0,(a0)
02:00002E44 B390            	  4875:                 eor.l d1,(a0)
02:00002E46 40C3            	  4876:                 move.w sr,d3
02:00002E48 02830000000F    	  4877:                 andi.l #$0F,d3            * Isolate flags
02:00002E4E DA83            	  4878:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E50 D890            	  4879:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4880: 
                            	  4881: 
02:00002E52 E289            	  4882:                 lsr.l #$1,d1
02:00002E54 51CEFFCC        	  4883:                 dbf d6,EOR_OUTER2
02:00002E58 E28A            	  4884:                 lsr.l #$1,d2
02:00002E5A 223C8167E123    	  4885:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002E60 7C1E            	  4886:                 move.l #$0000001E,d6       * Inner loop counter
02:00002E62 51CFFFBE        	  4887:                 dbf d7,EOR_OUTER2
                            	  4888: 
02:00002E66 0C8455C5EB70    	  4889:                 cmpi.l #$55C5EB70,d4      * Check the data results
02:00002E6C 66FE            	  4890:                 bne.s *
02:00002E6E 0C8500004430    	  4891:                 cmpi.l #$00004430,d5      * Check the Flag results
02:00002E74 66FE            	  4892:                 bne.s *
                            	  4893: 
                            	  4894: 
02:00002E76 4E75            	  4895:                 rts
                            	  4896: 
                            	  4897: 
                            	  4898: *-----------------------------------------------------------
                            	  4899: *-----------------------------------------------------------
                            	  4900: * OPCODE : CMP
                            	  4901: *-----------------------------------------------------------
                            	  4902: *-----------------------------------------------------------
                            	  4903: 
                            	  4904: op_CMP:
                            	  4905: 
                            	  4906: 
                            	  4907: *  * <EA> to Register
                            	  4908: 
02:00002E78 203CA5A5A5A5    	  4909:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002E7E 223C8167E123    	  4910:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002E84 243CA5A5A5A5    	  4911:                 move.l #$a5a5a5a5,d2
02:00002E8A 7600            	  4912:                 moveq  #$00000000,d3
02:00002E8C 7800            	  4913:                 moveq  #$00000000,d4       * Cumulative data results
02:00002E8E 7A00            	  4914:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002E90 7C1E            	  4915:                 move.l #$0000001E,d6       * Inner loop counter
02:00002E92 7E1E            	  4916:                 move.l #$0000001E,d7       * Outer loop counter
02:00002E94 307C0100        	  4917:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4918: 
                            	  4919: 
                            	  4920: CMP_OUTER1:
                            	  4921: 
                            	  4922: *     BYTE
02:00002E98 2081            	  4923:                 move.l d1,(a0)
02:00002E9A B010            	  4924:                 cmp.b (a0),d0
02:00002E9C 40C3            	  4925:                 move.w sr,d3
02:00002E9E 02830000000F    	  4926:                 andi.l #$0F,d3            * Isolate flags
02:00002EA4 DA83            	  4927:                 add.l d3,d5               * Copy flag results into accumulator
02:00002EA6 D880            	  4928:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4929: 
                            	  4930: *     WORD
02:00002EA8 2081            	  4931:                 move.l d1,(a0)
02:00002EAA B050            	  4932:                 cmp.w (a0),d0
02:00002EAC 40C3            	  4933:                 move.w sr,d3
02:00002EAE 02830000000F    	  4934:                 andi.l #$0F,d3            * Isolate flags
02:00002EB4 DA83            	  4935:                 add.l d3,d5               * Copy flag results into accumulator
02:00002EB6 D880            	  4936:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4937: 
                            	  4938: *     LONG
02:00002EB8 2081            	  4939:                 move.l d1,(a0)
02:00002EBA B090            	  4940:                 cmp.l (a0),d0
02:00002EBC 40C3            	  4941:                 move.w sr,d3
02:00002EBE 02830000000F    	  4942:                 andi.l #$0F,d3            * Isolate flags
02:00002EC4 DA83            	  4943:                 add.l d3,d5               * Copy flag results into accumulator
02:00002EC6 D880            	  4944:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4945: 
                            	  4946: 
02:00002EC8 E289            	  4947:                 lsr.l #$1,d1
02:00002ECA 51CEFFCC        	  4948:                 dbf d6,CMP_OUTER1
02:00002ECE E28A            	  4949:                 lsr.l #$1,d2
02:00002ED0 223C8167E123    	  4950:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002ED6 7C1E            	  4951:                 move.l #$0000001E,d6       * Inner loop counter
02:00002ED8 51CFFFBE        	  4952:                 dbf d7,CMP_OUTER1
                            	  4953: 
02:00002EDC 0C847878712F    	  4954:                 cmpi.l #$7878712F,d4      * Check the data results
02:00002EE2 66FE            	  4955:                 bne.s *
02:00002EE4 0C8500005502    	  4956:                 cmpi.l #$00005502,d5      * Check the Flag results
02:00002EEA 66FE            	  4957:                 bne.s *
                            	  4958: 
                            	  4959: 
                            	  4960: 
02:00002EEC 4E75            	  4961:                 rts
                            	  4962: 
                            	  4963: 
                            	  4964: *-----------------------------------------------------------
                            	  4965: *-----------------------------------------------------------
                            	  4966: * OPCODE : CMPA
                            	  4967: *-----------------------------------------------------------
                            	  4968: *-----------------------------------------------------------
                            	  4969: 
                            	  4970: op_CMPA:
                            	  4971: 
                            	  4972: 
                            	  4973: *  * <EA> to Register
                            	  4974: 
02:00002EEE 207CA5A5A5A5    	  4975:                 move.l #$a5a5a5a5,a0       * Initial Data-X  Inner loop
02:00002EF4 223C8167E123    	  4976:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002EFA 243CA5A5A5A5    	  4977:                 move.l #$a5a5a5a5,d2
02:00002F00 7600            	  4978:                 moveq  #$00000000,d3
02:00002F02 7800            	  4979:                 moveq  #$00000000,d4       * Cumulative data results
02:00002F04 7A00            	  4980:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002F06 7C1E            	  4981:                 move.l #$0000001E,d6       * Inner loop counter
02:00002F08 7E1E            	  4982:                 move.l #$0000001E,d7       * Outer loop counter
02:00002F0A 327C0100        	  4983:                 move.l #$00000100,a1       * Address for memory EA operations
                            	  4984: 
                            	  4985: 
                            	  4986: CMPA_OUTER1:
                            	  4987: 
                            	  4988: 
                            	  4989: *     WORD
02:00002F0E 2281            	  4990:                 move.l d1,(a1)
02:00002F10 B0D1            	  4991:                 cmpa.w (a1),a0
02:00002F12 40C3            	  4992:                 move.w sr,d3
02:00002F14 02830000000F    	  4993:                 andi.l #$0F,d3            * Isolate flags
02:00002F1A DA83            	  4994:                 add.l d3,d5               * Copy flag results into accumulator
02:00002F1C D888            	  4995:                 add.l a0,d4               * Copy data results into data accumulator
                            	  4996: 
                            	  4997: *     LONG
02:00002F1E 2281            	  4998:                 move.l d1,(a1)
02:00002F20 B1D1            	  4999:                 cmpa.l (a1),a0
02:00002F22 40C3            	  5000:                 move.w sr,d3
02:00002F24 02830000000F    	  5001:                 andi.l #$0F,d3            * Isolate flags
02:00002F2A DA83            	  5002:                 add.l d3,d5               * Copy flag results into accumulator
02:00002F2C D888            	  5003:                 add.l a0,d4               * Copy data results into data accumulator
                            	  5004: 
                            	  5005: 
02:00002F2E E289            	  5006:                 lsr.l #$1,d1
02:00002F30 51CEFFDC        	  5007:                 dbf d6,CMPA_OUTER1
02:00002F34 E28A            	  5008:                 lsr.l #$1,d2
02:00002F36 223C8167E123    	  5009:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002F3C 7C1E            	  5010:                 move.l #$0000001E,d6       * Inner loop counter
02:00002F3E 51CFFFCE        	  5011:                 dbf d7,CMPA_OUTER1
                            	  5012: 
02:00002F42 0C84A5A5A0CA    	  5013:                 cmpi.l #$a5a5a0ca,d4      * Check the data results
02:00002F48 66FE            	  5014:                 bne.s *
02:00002F4A 0C8500003A7D    	  5015:                 cmpi.l #$00003A7D,d5      * Check the Flag results
02:00002F50 66FE            	  5016:                 bne.s *
                            	  5017: 
                            	  5018: 
02:00002F52 4E75            	  5019:                 rts
                            	  5020: 
                            	  5021: 
                            	  5022: 
                            	  5023: *-----------------------------------------------------------
                            	  5024: *-----------------------------------------------------------
                            	  5025: * OPCODE : CMPM
                            	  5026: *-----------------------------------------------------------
                            	  5027: *-----------------------------------------------------------
                            	  5028: 
                            	  5029: op_CMPM:
                            	  5030: 
02:00002F54 307C0100        	  5031:                 move.l #$00000100,a0       * Address for Data-X
02:00002F58 327C0200        	  5032:                 move.l #$00000200,a1       * Address for Data-Y
02:00002F5C 7000            	  5033:                 moveq  #$00000000,d0
02:00002F5E 7200            	  5034:                 moveq  #$00000000,d1
02:00002F60 7400            	  5035:                 moveq  #$00000000,d2
                            	  5036: 
02:00002F62 20FC11FF5580    	  5037:                 move.l #$11FF5580,(a0)+   * Populate test data
02:00002F68 20FC1111FFFF    	  5038:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:00002F6E 20FC33333333    	  5039:                 move.l #$33333333,(a0)+   * Populate test data
02:00002F74 20FC44444444    	  5040:                 move.l #$44444444,(a0)+   * Populate test data
                            	  5041: 
02:00002F7A 22FC80FF337F    	  5042:                 move.l #$80FF337F,(a1)+   * Populate test data
02:00002F80 22FCFFFF1111    	  5043:                 move.l #$FFFF1111,(a1)+   * Populate test data
02:00002F86 22FC33333333    	  5044:                 move.l #$33333333,(a1)+   * Populate test data
02:00002F8C 22FC44444444    	  5045:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5046: 
02:00002F92 307C0100        	  5047:                 move.l #$00000100,a0       * Address for Data-X
02:00002F96 327C0200        	  5048:                 move.l #$00000200,a1       * Address for Data-Y
02:00002F9A 7C0F            	  5049:                 move.l #$0000000F,d6       * Loop counter
                            	  5050: 
02:00002F9C B308            	  5051: CMPM_LOOP1:     cmpm.b (a0)+,(a1)+
02:00002F9E 40C3            	  5052:                 move.w sr,d3
02:00002FA0 02830000000F    	  5053:                 andi.l #$0F,d3            * Isolate flags
02:00002FA6 D083            	  5054:                 add.l d3,d0               * Copy flag results into accumulator
02:00002FA8 51CEFFF2        	  5055:                 dbf d6,CMPM_LOOP1
                            	  5056: 
                            	  5057: 
02:00002FAC 307C0100        	  5058:                 move.l #$00000100,a0       * Address for Data-X
02:00002FB0 327C0200        	  5059:                 move.l #$00000200,a1       * Address for Data-Y
02:00002FB4 7C07            	  5060:                 moveq  #$00000007,d6       * Loop counter
                            	  5061: 
02:00002FB6 B348            	  5062: CMPM_LOOP2:     cmpm.w (a0)+,(a1)+
02:00002FB8 40C3            	  5063:                 move.w sr,d3
02:00002FBA 02830000000F    	  5064:                 andi.l #$0F,d3            * Isolate flags
02:00002FC0 D283            	  5065:                 add.l d3,d1               * Copy flag results into accumulator
02:00002FC2 51CEFFF2        	  5066:                 dbf d6,CMPM_LOOP2
                            	  5067: 
                            	  5068: 
02:00002FC6 307C0100        	  5069:                 move.l #$00000100,a0       * Address for Data-X
02:00002FCA 327C0200        	  5070:                 move.l #$00000200,a1       * Address for Data-Y
02:00002FCE 7C03            	  5071:                 moveq  #$00000003,d6       * Loop counter
                            	  5072: 
02:00002FD0 B388            	  5073: CMPM_LOOP3:     cmpm.l (a0)+,(a1)+
02:00002FD2 40C3            	  5074:                 move.w sr,d3
02:00002FD4 02830000000F    	  5075:                 andi.l #$0F,d3            * Isolate flags
02:00002FDA D483            	  5076:                 add.l d3,d2               * Copy flag results into accumulator
02:00002FDC 51CEFFF2        	  5077:                 dbf d6,CMPM_LOOP3
                            	  5078: 
                            	  5079: 
02:00002FE0 0C800000004C    	  5080:                 cmpi.l #$0000004C,d0      * Check the data results
02:00002FE6 66FE            	  5081:                 bne.s *
02:00002FE8 0C8100000024    	  5082:                 cmpi.l #$00000024,d1
02:00002FEE 66FE            	  5083:                 bne.s *
02:00002FF0 0C8200000012    	  5084:                 cmpi.l #$00000012,d2
02:00002FF6 66FE            	  5085:                 bne.s *
                            	  5086: 
02:00002FF8 4E75            	  5087:                 rts
                            	  5088: 
                            	  5089: 
                            	  5090: *-----------------------------------------------------------
                            	  5091: *-----------------------------------------------------------
                            	  5092: * OPCODE : ADD
                            	  5093: *-----------------------------------------------------------
                            	  5094: *-----------------------------------------------------------
                            	  5095: 
                            	  5096: op_ADD:
                            	  5097: 
                            	  5098: 
                            	  5099: *  * <EA> to Register
02:00002FFA 203CA5A5A5A5    	  5100:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003000 223C8167E123    	  5101:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00003006 243CA5A5A5A5    	  5102:                 move.l #$a5a5a5a5,d2
02:0000300C 7600            	  5103:                 moveq  #$00000000,d3
02:0000300E 7800            	  5104:                 moveq  #$00000000,d4       * Cumulative data results
02:00003010 7A00            	  5105:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003012 7C1E            	  5106:                 move.l #$0000001E,d6       * Inner loop counter
02:00003014 7E1E            	  5107:                 move.l #$0000001E,d7       * Outer loop counter
02:00003016 307C0100        	  5108:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5109: 
                            	  5110: 
                            	  5111: ADD_OUTER1:
                            	  5112: 
                            	  5113: *     BYTE
02:0000301A 2081            	  5114:                 move.l d1,(a0)
02:0000301C D010            	  5115:                 add.b (a0),d0
02:0000301E 40C3            	  5116:                 move.w sr,d3
02:00003020 02830000001F    	  5117:                 andi.l #$1F,d3            * Isolate flags
02:00003026 DA83            	  5118:                 add.l d3,d5               * Copy flag results into accumulator
02:00003028 D880            	  5119:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5120: 
                            	  5121: *     WORD
02:0000302A 2081            	  5122:                 move.l d1,(a0)
02:0000302C D050            	  5123:                 add.w (a0),d0
02:0000302E 40C3            	  5124:                 move.w sr,d3
02:00003030 02830000000C    	  5125:                 andi.l #$0C,d3            * Isolate flags
02:00003036 DA83            	  5126:                 add.l d3,d5               * Copy flag results into accumulator
02:00003038 D880            	  5127:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5128: 
                            	  5129: *     LONG
02:0000303A 2081            	  5130:                 move.l d1,(a0)
02:0000303C D090            	  5131:                 add.l (a0),d0
02:0000303E 40C3            	  5132:                 move.w sr,d3
02:00003040 02830000000F    	  5133:                 andi.l #$0F,d3            * Isolate flags
02:00003046 DA83            	  5134:                 add.l d3,d5               * Copy flag results into accumulator
02:00003048 D880            	  5135:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5136: 
                            	  5137: 
02:0000304A E299            	  5138:                 ror.l #$1,d1
02:0000304C 51CEFFCC        	  5139:                 dbf d6,ADD_OUTER1
02:00003050 E29A            	  5140:                 ror.l #$1,d2
02:00003052 223C8167E123    	  5141:                 move.l #$8167E123,d1       * Initial Data-Y
02:00003058 7C1E            	  5142:                 move.l #$0000001E,d6       * Inner loop counter
02:0000305A 51CFFFBE        	  5143:                 dbf d7,ADD_OUTER1
                            	  5144: 
02:0000305E 0C8423ED428F    	  5145:                 cmpi.l #$23ED428F,d4      * Check the data results
02:00003064 66FE            	  5146:                 bne.s *
02:00003066 0C8500004C96    	  5147:                 cmpi.l #$00004C96,d5      * Check the Flag results
02:0000306C 66FE            	  5148:                 bne.s *
                            	  5149: 
                            	  5150: 
                            	  5151: *  * Register to <EA>
02:0000306E 203C86738374    	  5152:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00003074 223CFC55F2FE    	  5153:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:0000307A 243C86738374    	  5154:                 move.l #$86738374,d2
02:00003080 7600            	  5155:                 moveq  #$00000000,d3
02:00003082 7800            	  5156:                 moveq  #$00000000,d4       * Cumulative data results
02:00003084 7A00            	  5157:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003086 7C1E            	  5158:                 move.l #$0000001E,d6       * Inner loop counter
02:00003088 7E1D            	  5159:                 move.l #$0000001D,d7       * Outer loop counter
02:0000308A 307C0100        	  5160:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5161: 
                            	  5162: 
                            	  5163: ADD_OUTER2:
                            	  5164: 
                            	  5165: *     BYTE
02:0000308E 2080            	  5166:                 move.l d0,(a0)
02:00003090 D310            	  5167:                 add.b d1,(a0)
02:00003092 40C3            	  5168:                 move.w sr,d3
02:00003094 02830000000C    	  5169:                 andi.l #$0C,d3            * Isolate flags
02:0000309A DA83            	  5170:                 add.l d3,d5               * Copy flag results into accumulator
02:0000309C D890            	  5171:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5172: 
                            	  5173: *     WORD
02:0000309E 2080            	  5174:                 move.l d0,(a0)
02:000030A0 D350            	  5175:                 add.w d1,(a0)
02:000030A2 40C3            	  5176:                 move.w sr,d3
02:000030A4 02830000001F    	  5177:                 andi.l #$1F,d3            * Isolate flags
02:000030AA DA83            	  5178:                 add.l d3,d5               * Copy flag results into accumulator
02:000030AC D890            	  5179:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5180: 
                            	  5181: *     LONG
02:000030AE 2080            	  5182:                 move.l d0,(a0)
02:000030B0 D390            	  5183:                 add.l d1,(a0)
02:000030B2 40C3            	  5184:                 move.w sr,d3
02:000030B4 02830000000F    	  5185:                 andi.l #$0F,d3            * Isolate flags
02:000030BA DA83            	  5186:                 add.l d3,d5               * Copy flag results into accumulator
02:000030BC D890            	  5187:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5188: 
                            	  5189: 
02:000030BE E299            	  5190:                 ror.l #$1,d1
02:000030C0 51CEFFCC        	  5191:                 dbf d6,ADD_OUTER2
02:000030C4 E29A            	  5192:                 ror.l #$1,d2
02:000030C6 223C8167E123    	  5193:                 move.l #$8167E123,d1       * Initial Data-Y
02:000030CC 7C1E            	  5194:                 move.l #$0000001E,d6       * Inner loop counter
02:000030CE 51CFFFBE        	  5195:                 dbf d7,ADD_OUTER2
                            	  5196: 
02:000030D2 0C846701B884    	  5197:                 cmpi.l #$6701B884,d4      * Check the data results
02:000030D8 66FE            	  5198:                 bne.s *
02:000030DA 0C8500005467    	  5199:                 cmpi.l #$00005467,d5      * Check the Flag results
02:000030E0 66FE            	  5200:                 bne.s *
                            	  5201: 
02:000030E2 4E75            	  5202:                 rts
                            	  5203: 
                            	  5204: *-----------------------------------------------------------
                            	  5205: *-----------------------------------------------------------
                            	  5206: * OPCODE : SUB
                            	  5207: *-----------------------------------------------------------
                            	  5208: *-----------------------------------------------------------
                            	  5209: 
                            	  5210: op_SUB:
                            	  5211: 
                            	  5212: *  * <EA> to Register
02:000030E4 203CA5A5A5A5    	  5213:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:000030EA 223C8167E123    	  5214:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:000030F0 243CA5A5A5A5    	  5215:                 move.l #$a5a5a5a5,d2
02:000030F6 7600            	  5216:                 moveq  #$00000000,d3
02:000030F8 7800            	  5217:                 moveq  #$00000000,d4       * Cumulative data results
02:000030FA 7A00            	  5218:                 moveq  #$00000000,d5       * Cumulative flag results
02:000030FC 7C1E            	  5219:                 move.l #$0000001E,d6       * Inner loop counter
02:000030FE 7E1E            	  5220:                 move.l #$0000001E,d7       * Outer loop counter
02:00003100 307C0100        	  5221:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5222: 
                            	  5223: 
                            	  5224: SUB_OUTER1:
                            	  5225: 
                            	  5226: *     BYTE
02:00003104 2081            	  5227:                 move.l d1,(a0)
02:00003106 9010            	  5228:                 sub.b (a0),d0
02:00003108 40C3            	  5229:                 move.w sr,d3
02:0000310A 02830000001F    	  5230:                 andi.l #$1F,d3            * Isolate flags
02:00003110 DA83            	  5231:                 add.l d3,d5               * Copy flag results into accumulator
02:00003112 D880            	  5232:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5233: 
                            	  5234: *     WORD
02:00003114 2081            	  5235:                 move.l d1,(a0)
02:00003116 9050            	  5236:                 sub.w (a0),d0
02:00003118 40C3            	  5237:                 move.w sr,d3
02:0000311A 02830000000C    	  5238:                 andi.l #$0C,d3            * Isolate flags
02:00003120 DA83            	  5239:                 add.l d3,d5               * Copy flag results into accumulator
02:00003122 D880            	  5240:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5241: 
                            	  5242: *     LONG
02:00003124 2081            	  5243:                 move.l d1,(a0)
02:00003126 9090            	  5244:                 sub.l (a0),d0
02:00003128 40C3            	  5245:                 move.w sr,d3
02:0000312A 02830000000F    	  5246:                 andi.l #$0F,d3            * Isolate flags
02:00003130 DA83            	  5247:                 add.l d3,d5               * Copy flag results into accumulator
02:00003132 D880            	  5248:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5249: 
                            	  5250: 
02:00003134 E299            	  5251:                 ror.l #$1,d1
02:00003136 51CEFFCC        	  5252:                 dbf d6,SUB_OUTER1
02:0000313A E29A            	  5253:                 ror.l #$1,d2
02:0000313C 223C8167E123    	  5254:                 move.l #$8167E123,d1       * Initial Data-Y
02:00003142 7C1E            	  5255:                 move.l #$0000001E,d6       * Inner loop counter
02:00003144 51CFFFBE        	  5256:                 dbf d7,SUB_OUTER1
                            	  5257: 
02:00003148 0C841A8D14CF    	  5258:                 cmpi.l #$1A8D14CF,d4      * Check the data results
02:0000314E 66FE            	  5259:                 bne.s *
02:00003150 0C8500004FC4    	  5260:                 cmpi.l #$00004FC4,d5      * Check the Flag results
02:00003156 66FE            	  5261:                 bne.s *
                            	  5262: 
                            	  5263: 
                            	  5264: *  * Register to <EA>
02:00003158 203C86738374    	  5265:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:0000315E 223CFC55F2FE    	  5266:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00003164 243C86738374    	  5267:                 move.l #$86738374,d2
02:0000316A 7600            	  5268:                 moveq  #$00000000,d3
02:0000316C 7800            	  5269:                 moveq  #$00000000,d4       * Cumulative data results
02:0000316E 7A00            	  5270:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003170 7C1E            	  5271:                 move.l #$0000001E,d6       * Inner loop counter
02:00003172 7E1D            	  5272:                 move.l #$0000001D,d7       * Outer loop counter
02:00003174 307C0100        	  5273:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5274: 
                            	  5275: 
                            	  5276: SUB_OUTER2:
                            	  5277: 
                            	  5278: *     BYTE
02:00003178 2080            	  5279:                 move.l d0,(a0)
02:0000317A 9310            	  5280:                 sub.b d1,(a0)
02:0000317C 40C3            	  5281:                 move.w sr,d3
02:0000317E 02830000000C    	  5282:                 andi.l #$0C,d3            * Isolate flags
02:00003184 DA83            	  5283:                 add.l d3,d5               * Copy flag results into accumulator
02:00003186 D890            	  5284:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5285: 
                            	  5286: *     WORD
02:00003188 2080            	  5287:                 move.l d0,(a0)
02:0000318A 9350            	  5288:                 sub.w d1,(a0)
02:0000318C 40C3            	  5289:                 move.w sr,d3
02:0000318E 02830000001F    	  5290:                 andi.l #$1F,d3            * Isolate flags
02:00003194 DA83            	  5291:                 add.l d3,d5               * Copy flag results into accumulator
02:00003196 D890            	  5292:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5293: 
                            	  5294: *     LONG
02:00003198 2080            	  5295:                 move.l d0,(a0)
02:0000319A 9390            	  5296:                 sub.l d1,(a0)
02:0000319C 40C3            	  5297:                 move.w sr,d3
02:0000319E 02830000000F    	  5298:                 andi.l #$0F,d3            * Isolate flags
02:000031A4 DA83            	  5299:                 add.l d3,d5               * Copy flag results into accumulator
02:000031A6 D890            	  5300:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5301: 
                            	  5302: 
02:000031A8 E299            	  5303:                 ror.l #$1,d1
02:000031AA 51CEFFCC        	  5304:                 dbf d6,SUB_OUTER2
02:000031AE E29A            	  5305:                 ror.l #$1,d2
02:000031B0 223C8167E123    	  5306:                 move.l #$8167E123,d1       * Initial Data-Y
02:000031B6 7C1E            	  5307:                 move.l #$0000001E,d6       * Inner loop counter
02:000031B8 51CFFFBE        	  5308:                 dbf d7,SUB_OUTER2
                            	  5309: 
02:000031BC 0C8436D38BEC    	  5310:                 cmpi.l #$36D38BEC,d4      * Check the data results
02:000031C2 66FE            	  5311:                 bne.s *
02:000031C4 0C85000045A5    	  5312:                 cmpi.l #$000045A5,d5      * Check the Flag results
02:000031CA 66FE            	  5313:                 bne.s *
                            	  5314: 
                            	  5315: 
                            	  5316: 
                            	  5317: 
02:000031CC 4E75            	  5318:                 rts
                            	  5319: 
                            	  5320: 
                            	  5321: 
                            	  5322: *-----------------------------------------------------------
                            	  5323: *-----------------------------------------------------------
                            	  5324: * OPCODE : ADDA
                            	  5325: *-----------------------------------------------------------
                            	  5326: *-----------------------------------------------------------
                            	  5327: 
                            	  5328: op_ADDA:
                            	  5329: 
                            	  5330: *  * <EA> to Register
02:000031CE 203CA5A5A5A5    	  5331:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:000031D4 223C8167E123    	  5332:                 move.l #$8167E123,d1
02:000031DA 243CA5A5A5A5    	  5333:                 move.l #$a5a5a5a5,d2
02:000031E0 7600            	  5334:                 moveq  #$00000000,d3
02:000031E2 7800            	  5335:                 moveq  #$00000000,d4       * Cumulative data results
02:000031E4 7A00            	  5336:                 moveq  #$00000000,d5       * Cumulative flag results
02:000031E6 7C1E            	  5337:                 move.l #$0000001E,d6       * Inner loop counter
02:000031E8 7E1E            	  5338:                 move.l #$0000001E,d7       * Outer loop counter
02:000031EA 307C0100        	  5339:                 move.l #$00000100,a0       * Address for memory EA operations
02:000031EE 227C8167E123    	  5340:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5341: 
                            	  5342: ADDA_OUTER1:
                            	  5343: 
                            	  5344: *     WORD
                            	  5345: *                move.l d1,(a0)       * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5346: *                adda.w (a0),a1
                            	  5347: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5348: 
                            	  5349: *     LONG
02:000031F4 2081            	  5350:                 move.l d1,(a0)
02:000031F6 D3D0            	  5351:                 adda.l (a0),a1
02:000031F8 D889            	  5352:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5353: 
02:000031FA E299            	  5354:                 ror.l #$1,d1
02:000031FC 51CEFFF6        	  5355:                 dbf d6,ADDA_OUTER1
02:00003200 E299            	  5356:                 ror.l #$1,d1
02:00003202 2241            	  5357:                 move.l d1,a1
02:00003204 223C8167E123    	  5358:                 move.l #$8167E123,d1       * Initial Data-Y
02:0000320A 7C1E            	  5359:                 move.l #$0000001E,d6       * Inner loop counter
02:0000320C 51CFFFE6        	  5360:                 dbf d7,ADDA_OUTER1
                            	  5361: 
02:00003210 0C84AC04DB4C    	  5362:                 cmpi.l #$AC04DB4C,d4      * Check the data results
02:00003216 66FE            	  5363:                 bne.s *
                            	  5364: 
                            	  5365: 
02:00003218 4E75            	  5366:                 rts
                            	  5367: 
                            	  5368: 
                            	  5369: *-----------------------------------------------------------
                            	  5370: *-----------------------------------------------------------
                            	  5371: * OPCODE : SUBA
                            	  5372: *-----------------------------------------------------------
                            	  5373: *-----------------------------------------------------------
                            	  5374: 
                            	  5375: op_SUBA:
                            	  5376: 
                            	  5377: *  * <EA> to Register
02:0000321A 203CA5A5A5A5    	  5378:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003220 223C8167E123    	  5379:                 move.l #$8167E123,d1
02:00003226 243CA5A5A5A5    	  5380:                 move.l #$a5a5a5a5,d2
02:0000322C 7600            	  5381:                 moveq  #$00000000,d3
02:0000322E 7800            	  5382:                 moveq  #$00000000,d4       * Cumulative data results
02:00003230 7A00            	  5383:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003232 7C1E            	  5384:                 move.l #$0000001E,d6       * Inner loop counter
02:00003234 7E1E            	  5385:                 move.l #$0000001E,d7       * Outer loop counter
02:00003236 307C0100        	  5386:                 move.l #$00000100,a0       * Address for memory EA operations
02:0000323A 227C8167E123    	  5387:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5388: 
                            	  5389: SUBA_OUTER1:
                            	  5390: 
                            	  5391: *     WORD
                            	  5392: *                move.l d1,(a0) * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5393: *                suba.w (a0),a1
                            	  5394: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5395: 
                            	  5396: *     LONG
02:00003240 2081            	  5397:                 move.l d1,(a0)
02:00003242 93D0            	  5398:                 suba.l (a0),a1
02:00003244 D889            	  5399:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5400: 
02:00003246 E299            	  5401:                 ror.l #$1,d1
02:00003248 51CEFFF6        	  5402:                 dbf d6,SUBA_OUTER1
02:0000324C E299            	  5403:                 ror.l #$1,d1
02:0000324E 2241            	  5404:                 move.l d1,a1
02:00003250 223C8167E123    	  5405:                 move.l #$8167E123,d1       * Initial Data-Y
02:00003256 7C1E            	  5406:                 move.l #$0000001E,d6       * Inner loop counter
02:00003258 51CFFFE6        	  5407:                 dbf d7,SUBA_OUTER1
                            	  5408: 
02:0000325C 0C84E1E36D7A    	  5409:                 cmpi.l #$E1E36D7A,d4      * Check the data results
02:00003262 66FE            	  5410:                 bne.s *
                            	  5411: 
                            	  5412: 
02:00003264 4E75            	  5413:                 rts
                            	  5414: 
                            	  5415: 
                            	  5416: 
                            	  5417: *-----------------------------------------------------------
                            	  5418: *-----------------------------------------------------------
                            	  5419: * OPCODE : ADDX
                            	  5420: *-----------------------------------------------------------
                            	  5421: *-----------------------------------------------------------
                            	  5422: 
                            	  5423: op_ADDX:
                            	  5424: 
                            	  5425: 
                            	  5426: *  * Register to Register
02:00003266 203CA5A5A5A5    	  5427:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:0000326C 223C8167E123    	  5428:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00003272 243CA5A5A5A5    	  5429:                 move.l #$a5a5a5a5,d2
02:00003278 7600            	  5430:                 moveq  #$00000000,d3
02:0000327A 7800            	  5431:                 moveq  #$00000000,d4       * Cumulative data results
02:0000327C 7A00            	  5432:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000327E 7C1E            	  5433:                 move.l #$0000001E,d6       * Inner loop counter
02:00003280 7E1E            	  5434:                 move.l #$0000001E,d7       * Outer loop counter
02:00003282 307C0100        	  5435:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5436: 
                            	  5437: 
                            	  5438: ADDX_OUTER1:
                            	  5439: 
                            	  5440: *     BYTE
02:00003286 2002            	  5441:                 move.l d2,d0
02:00003288 D101            	  5442:                 addx.b d1,d0
02:0000328A 40C3            	  5443:                 move.w sr,d3
02:0000328C 02830000001F    	  5444:                 andi.l #$1F,d3            * Isolate flags
02:00003292 DA83            	  5445:                 add.l d3,d5               * Copy flag results into accumulator
02:00003294 D880            	  5446:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5447: 
                            	  5448: *     WORD
02:00003296 2002            	  5449:                 move.l d2,d0
02:00003298 D141            	  5450:                 addx.w d1,d0
02:0000329A 40C3            	  5451:                 move.w sr,d3
02:0000329C 02830000001F    	  5452:                 andi.l #$1F,d3            * Isolate flags
02:000032A2 DA83            	  5453:                 add.l d3,d5               * Copy flag results into accumulator
02:000032A4 D880            	  5454:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5455: 
                            	  5456: *     LONG
02:000032A6 2002            	  5457:                 move.l d2,d0
02:000032A8 D181            	  5458:                 addx.l d1,d0
02:000032AA 40C3            	  5459:                 move.w sr,d3
02:000032AC 02830000001F    	  5460:                 andi.l #$1F,d3            * Isolate flags
02:000032B2 DA83            	  5461:                 add.l d3,d5               * Copy flag results into accumulator
02:000032B4 D880            	  5462:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5463: 
02:000032B6 E299            	  5464:                 ror.l #$1,d1
02:000032B8 51CEFFCC        	  5465:                 dbf d6,ADDX_OUTER1
02:000032BC E29A            	  5466:                 ror.l #$1,d2
02:000032BE 223C8167E123    	  5467:                 move.l #$8167E123,d1       * Initial Data-Y
02:000032C4 7C1E            	  5468:                 move.l #$0000001E,d6       * Inner loop counter
02:000032C6 51CFFFBE        	  5469:                 dbf d7,ADDX_OUTER1
                            	  5470: 
02:000032CA 0C844E96A4D9    	  5471:                 cmpi.l #$4E96A4D9,d4      * Check the data results
02:000032D0 66FE            	  5472:                 bne.s *
02:000032D2 0C85000085CD    	  5473:                 cmpi.l #$000085CD,d5      * Check the Flag results
02:000032D8 66FE            	  5474:                 bne.s *
                            	  5475: 
                            	  5476: 
                            	  5477: 
                            	  5478: *     -(An),-(An)
                            	  5479: 
02:000032DA 7000            	  5480:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
02:000032DC 7200            	  5481:                 moveq  #$00000000,d1
02:000032DE 7400            	  5482:                 moveq  #$00000000,d2
02:000032E0 307C0100        	  5483:                 move.l #$00000100,a0       * Address for Data-X
02:000032E4 327C0200        	  5484:                 move.l #$00000200,a1       * Address for Data-Y
02:000032E8 20FC11FF5580    	  5485:                 move.l #$11FF5580,(a0)+   * Populate test data
02:000032EE 20FC1111FFFF    	  5486:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:000032F4 20FC33333333    	  5487:                 move.l #$33333333,(a0)+   * Populate test data
02:000032FA 20FC44444444    	  5488:                 move.l #$44444444,(a0)+   * Populate test data
02:00003300 22FC80FF337F    	  5489:                 move.l #$80FF337F,(a1)+   * Populate test data
02:00003306 22FCFFFF1111    	  5490:                 move.l #$FFFF1111,(a1)+   * Populate test data
02:0000330C 22FC33333333    	  5491:                 move.l #$33333333,(a1)+   * Populate test data
02:00003312 22FC44444444    	  5492:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5493: 
                            	  5494: 
02:00003318 7C0F            	  5495:                 move.l #$0000000F,d6       * Loop counter
                            	  5496: 
02:0000331A D308            	  5497: ADDX_LOOP3:     addx.b -(a0),-(a1)
02:0000331C 40C3            	  5498:                 move.w sr,d3
02:0000331E 02830000000F    	  5499:                 andi.l #$0F,d3            * Isolate flags
02:00003324 D083            	  5500:                 add.l d3,d0               * Copy flag results into accumulator
02:00003326 D211            	  5501:                 add.b (a1),d1
02:00003328 51CEFFF0        	  5502:                 dbf d6,ADDX_LOOP3
                            	  5503: 
                            	  5504: 
02:0000332C 307C0110        	  5505:                 move.l #$00000110,a0       * Address for Data-X
02:00003330 327C0210        	  5506:                 move.l #$00000210,a1       * Address for Data-Y
02:00003334 7C07            	  5507:                 moveq  #$00000007,d6       * Loop counter
                            	  5508: 
02:00003336 D348            	  5509: ADDX_LOOP4:     addx.w -(a0),-(a1)
02:00003338 40C3            	  5510:                 move.w sr,d3
02:0000333A 02830000000F    	  5511:                 andi.l #$0F,d3            * Isolate flags
02:00003340 D083            	  5512:                 add.l d3,d0               * Copy flag results into accumulator
02:00003342 D251            	  5513:                 add.w (a1),d1
02:00003344 51CEFFF0        	  5514:                 dbf d6,ADDX_LOOP4
                            	  5515: 
                            	  5516: 
02:00003348 307C0110        	  5517:                 move.l #$00000110,a0       * Address for Data-X
02:0000334C 327C0210        	  5518:                 move.l #$00000210,a1       * Address for Data-Y
02:00003350 7C03            	  5519:                 moveq  #$00000003,d6       * Loop counter
                            	  5520: 
02:00003352 D388            	  5521: ADDX_LOOP5:     addx.l -(a0),-(a1)
02:00003354 40C3            	  5522:                 move.w sr,d3
02:00003356 02830000000F    	  5523:                 andi.l #$0F,d3            * Isolate flags
02:0000335C D083            	  5524:                 add.l d3,d0               * Copy flag results into accumulator
02:0000335E D291            	  5525:                 add.l (a1),d1
02:00003360 51CEFFF0        	  5526:                 dbf d6,ADDX_LOOP5
                            	  5527: 
                            	  5528: 
02:00003364 0C8000000095    	  5529:                 cmpi.l #$00000095,d0      * Check the flag results
02:0000336A 66FE            	  5530:                 bne.s *
02:0000336C 0C81C812A682    	  5531:                 cmpi.l #$C812A682,d1      * Check the data results
02:00003372 66FE            	  5532:                 bne.s *
                            	  5533: 
02:00003374 4E75            	  5534:                 rts
                            	  5535: 
                            	  5536: 
                            	  5537: 
                            	  5538: 
                            	  5539: *-----------------------------------------------------------
                            	  5540: *-----------------------------------------------------------
                            	  5541: * OPCODE : SUBX
                            	  5542: *-----------------------------------------------------------
                            	  5543: *-----------------------------------------------------------
                            	  5544: 
                            	  5545: op_SUBX:
                            	  5546: 
                            	  5547: 
                            	  5548: *  * Register to Register
02:00003376 203CA5A5A5A5    	  5549:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:0000337C 223C8167E123    	  5550:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00003382 243CA5A5A5A5    	  5551:                 move.l #$a5a5a5a5,d2
02:00003388 7600            	  5552:                 moveq  #$00000000,d3
02:0000338A 7800            	  5553:                 moveq  #$00000000,d4       * Cumulative data results
02:0000338C 7A00            	  5554:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000338E 7C1E            	  5555:                 move.l #$0000001E,d6       * Inner loop counter
02:00003390 7E1E            	  5556:                 move.l #$0000001E,d7       * Outer loop counter
02:00003392 307C0100        	  5557:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5558: 
                            	  5559: 
                            	  5560: SUBX_OUTER1:
                            	  5561: 
                            	  5562: *     BYTE
02:00003396 2002            	  5563:                 move.l d2,d0
02:00003398 9101            	  5564:                 subx.b d1,d0
02:0000339A 40C3            	  5565:                 move.w sr,d3
02:0000339C 02830000001F    	  5566:                 andi.l #$1F,d3            * Isolate flags
02:000033A2 DA83            	  5567:                 add.l d3,d5               * Copy flag results into accumulator
02:000033A4 D880            	  5568:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5569: 
                            	  5570: *     WORD
02:000033A6 2002            	  5571:                 move.l d2,d0
02:000033A8 9141            	  5572:                 subx.w d1,d0
02:000033AA 40C3            	  5573:                 move.w sr,d3
02:000033AC 02830000001F    	  5574:                 andi.l #$1F,d3            * Isolate flags
02:000033B2 DA83            	  5575:                 add.l d3,d5               * Copy flag results into accumulator
02:000033B4 D880            	  5576:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5577: 
                            	  5578: *     LONG
02:000033B6 2002            	  5579:                 move.l d2,d0
02:000033B8 9181            	  5580:                 subx.l d1,d0
02:000033BA 40C3            	  5581:                 move.w sr,d3
02:000033BC 02830000001F    	  5582:                 andi.l #$1F,d3            * Isolate flags
02:000033C2 DA83            	  5583:                 add.l d3,d5               * Copy flag results into accumulator
02:000033C4 D880            	  5584:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5585: 
02:000033C6 E299            	  5586:                 ror.l #$1,d1
02:000033C8 51CEFFCC        	  5587:                 dbf d6,SUBX_OUTER1
02:000033CC E29A            	  5588:                 ror.l #$1,d2
02:000033CE 223C8167E123    	  5589:                 move.l #$8167E123,d1       * Initial Data-Y
02:000033D4 7C1E            	  5590:                 move.l #$0000001E,d6       * Inner loop counter
02:000033D6 51CFFFBE        	  5591:                 dbf d7,SUBX_OUTER1
                            	  5592: 
02:000033DA 0C84FCAA913E    	  5593:                 cmpi.l #$FCAA913E,d4      * Check the data results
02:000033E0 66FE            	  5594:                 bne.s *
02:000033E2 0C8500007E89    	  5595:                 cmpi.l #$00007E89,d5      * Check the Flag results
02:000033E8 66FE            	  5596:                 bne.s *
                            	  5597: 
                            	  5598: 
                            	  5599: 
                            	  5600: *     -(An),-(An)
                            	  5601: 
02:000033EA 7000            	  5602:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
02:000033EC 7200            	  5603:                 moveq  #$00000000,d1
02:000033EE 7400            	  5604:                 moveq  #$00000000,d2
02:000033F0 307C0100        	  5605:                 move.l #$00000100,a0       * Address for Data-X
02:000033F4 327C0200        	  5606:                 move.l #$00000200,a1       * Address for Data-Y
02:000033F8 20FC11FF5580    	  5607:                 move.l #$11FF5580,(a0)+   * Populate test data
02:000033FE 20FC1111FFFF    	  5608:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:00003404 20FC80FF337F    	  5609:                 move.l #$80FF337F,(a0)+   * Populate test data
02:0000340A 20FC44444444    	  5610:                 move.l #$44444444,(a0)+   * Populate test data
02:00003410 22FC80FF337F    	  5611:                 move.l #$80FF337F,(a1)+   * Populate test data
02:00003416 22FC1111FFFF    	  5612:                 move.l #$1111FFFF,(a1)+   * Populate test data
02:0000341C 22FC33333333    	  5613:                 move.l #$33333333,(a1)+   * Populate test data
02:00003422 22FC5580EECC    	  5614:                 move.l #$5580EECC,(a1)+   * Populate test data
                            	  5615: 
                            	  5616: 
02:00003428 7C0F            	  5617:                 move.l #$0000000F,d6       * Loop counter
                            	  5618: 
02:0000342A 9308            	  5619: SUBX_LOOP3:     subx.b -(a0),-(a1)
02:0000342C 40C3            	  5620:                 move.w sr,d3
02:0000342E 02830000000F    	  5621:                 andi.l #$0F,d3            * Isolate flags
02:00003434 D083            	  5622:                 add.l d3,d0               * Copy flag results into accumulator
02:00003436 D211            	  5623:                 add.b (a1),d1
02:00003438 51CEFFF0        	  5624:                 dbf d6,SUBX_LOOP3
                            	  5625: 
                            	  5626: 
02:0000343C 307C0110        	  5627:                 move.l #$00000110,a0       * Address for Data-X
02:00003440 327C0210        	  5628:                 move.l #$00000210,a1       * Address for Data-Y
02:00003444 7C07            	  5629:                 moveq  #$00000007,d6       * Loop counter
                            	  5630: 
02:00003446 9348            	  5631: SUBX_LOOP4:     subx.w -(a0),-(a1)
02:00003448 40C3            	  5632:                 move.w sr,d3
02:0000344A 02830000000F    	  5633:                 andi.l #$0F,d3            * Isolate flags
02:00003450 D083            	  5634:                 add.l d3,d0               * Copy flag results into accumulator
02:00003452 D251            	  5635:                 add.w (a1),d1
02:00003454 51CEFFF0        	  5636:                 dbf d6,SUBX_LOOP4
                            	  5637: 
                            	  5638: 
02:00003458 307C0110        	  5639:                 move.l #$00000110,a0       * Address for Data-X
02:0000345C 327C0210        	  5640:                 move.l #$00000210,a1       * Address for Data-Y
02:00003460 7C03            	  5641:                 moveq  #$00000003,d6       * Loop counter
                            	  5642: 
02:00003462 9388            	  5643: SUBX_LOOP5:     subx.l -(a0),-(a1)
02:00003464 40C3            	  5644:                 move.w sr,d3
02:00003466 02830000000F    	  5645:                 andi.l #$0F,d3            * Isolate flags
02:0000346C D083            	  5646:                 add.l d3,d0               * Copy flag results into accumulator
02:0000346E D291            	  5647:                 add.l (a1),d1
02:00003470 51CEFFF0        	  5648:                 dbf d6,SUBX_LOOP5
                            	  5649: 
                            	  5650: 
02:00003474 0C80000000B1    	  5651:                 cmpi.l #$000000B1,d0      * Check the flag results
02:0000347A 66FE            	  5652:                 bne.s *
02:0000347C 0C8162C6F417    	  5653:                 cmpi.l #$62C6F417,d1      * Check the data results
02:00003482 66FE            	  5654:                 bne.s *
                            	  5655: 
02:00003484 4E75            	  5656:                 rts
                            	  5657: 
                            	  5658: 
                            	  5659: *-----------------------------------------------------------
                            	  5660: *-----------------------------------------------------------
                            	  5661: * OPCODE : MULU
                            	  5662: *-----------------------------------------------------------
                            	  5663: *-----------------------------------------------------------
                            	  5664: 
                            	  5665: op_MULU:
                            	  5666: 
02:00003486 203CFE805501    	  5667:                 move.l #$FE805501,d0        * Initial
02:0000348C 223C5697EDB6    	  5668:                 move.l #$5697EDB6,d1        * Initial Y
02:00003492 243CFE805501    	  5669:                 move.l #$FE805501,d2
02:00003498 7600            	  5670:                 moveq  #$00000000,d3
02:0000349A 7800            	  5671:                 moveq  #$00000000,d4        * Cumulative data results
02:0000349C 7A00            	  5672:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000349E 7C0E            	  5673:                 move.l #$0000000E,d6       * Inner loop counter
02:000034A0 7E0E            	  5674:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5675: 
                            	  5676: 
02:000034A2 C0C1            	  5677: MULU_OUTER1:    mulu d1,d0
02:000034A4 40C3            	  5678:                 move.w sr,d3
02:000034A6 02830000000C    	  5679:                 andi.l #$0C,d3            * Isolate flags
02:000034AC DA83            	  5680:                 add.l d3,d5               * Copy flag results into accumulator
02:000034AE D880            	  5681:                 add.l d0,d4               * Copy data results into data accumulator
02:000034B0 E299            	  5682:                 ror.l #$1,d1
                            	  5683: 
02:000034B2 51CEFFEE        	  5684:                 dbf d6,MULU_OUTER1
02:000034B6 E29A            	  5685:                 ror.l #$1,d2
02:000034B8 2002            	  5686:                 move.l d2,d0
02:000034BA 7C0E            	  5687:                 move.l #$0000000E,d6       * Inner loop counter
02:000034BC 51CFFFE4        	  5688:                 dbf d7,MULU_OUTER1
                            	  5689: 
02:000034C0 0C8476FB988C    	  5690:                 cmpi.l #$76FB988C,d4      * Check the data results
02:000034C6 66FE            	  5691:                 bne.s *
                            	  5692: 
02:000034C8 0C8500000170    	  5693:                 cmpi.l #$00000170,d5      * Check the Flag results
02:000034CE 66FE            	  5694:                 bne.s *
                            	  5695: 
                            	  5696: 
02:000034D0 4E75            	  5697:                 rts
                            	  5698: 
                            	  5699: 
                            	  5700: *-----------------------------------------------------------
                            	  5701: *-----------------------------------------------------------
                            	  5702: * OPCODE : MULS
                            	  5703: *-----------------------------------------------------------
                            	  5704: *-----------------------------------------------------------
                            	  5705: 
                            	  5706: op_MULS:
                            	  5707: 
02:000034D2 203CFE805501    	  5708:                 move.l #$FE805501,d0        * Initial
02:000034D8 223C5697EDB6    	  5709:                 move.l #$5697EDB6,d1        * Initial Y
02:000034DE 243CFE805501    	  5710:                 move.l #$FE805501,d2
02:000034E4 7600            	  5711:                 moveq  #$00000000,d3
02:000034E6 7800            	  5712:                 moveq  #$00000000,d4        * Cumulative data results
02:000034E8 7A00            	  5713:                 moveq  #$00000000,d5       * Cumulative flag results
02:000034EA 7C0E            	  5714:                 move.l #$0000000E,d6       * Inner loop counter
02:000034EC 7E0E            	  5715:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5716: 
                            	  5717: 
02:000034EE C1C1            	  5718: MULS_OUTER1:    muls d1,d0
02:000034F0 40C3            	  5719:                 move.w sr,d3
02:000034F2 02830000000C    	  5720:                 andi.l #$0C,d3            * Isolate flags
02:000034F8 DA83            	  5721:                 add.l d3,d5               * Copy flag results into accumulator
02:000034FA D880            	  5722:                 add.l d0,d4               * Copy data results into data accumulator
02:000034FC E299            	  5723:                 ror.l #$1,d1
                            	  5724: 
02:000034FE 51CEFFEE        	  5725:                 dbf d6,MULS_OUTER1
02:00003502 E29A            	  5726:                 ror.l #$1,d2
02:00003504 2002            	  5727:                 move.l d2,d0
02:00003506 7C0E            	  5728:                 move.l #$0000000E,d6       * Inner loop counter
02:00003508 51CFFFE4        	  5729:                 dbf d7,MULS_OUTER1
                            	  5730: 
02:0000350C 0C84D4E2988C    	  5731:                 cmpi.l #$D4E2988C,d4      * Check the data results
02:00003512 66FE            	  5732:                 bne.s *
                            	  5733: 
02:00003514 0C85000003E0    	  5734:                 cmpi.l #$000003E0,d5      * Check the Flag results
02:0000351A 66FE            	  5735:                 bne.s *
                            	  5736: 
                            	  5737: 
02:0000351C 4E75            	  5738:                 rts
                            	  5739: 
                            	  5740: 
                            	  5741: 
                            	  5742: *-----------------------------------------------------------
                            	  5743: *-----------------------------------------------------------
                            	  5744: * OPCODE : EXG
                            	  5745: *-----------------------------------------------------------
                            	  5746: *-----------------------------------------------------------
                            	  5747: 
                            	  5748: op_EXG:
02:0000351E 223CD1D1D1D1    	  5749:                 move.l #$d1d1d1d1,d1
02:00003524 243CD2D2D2D2    	  5750:                 move.l #$d2d2d2d2,d2
02:0000352A 263CD3D3D3D3    	  5751:                 move.l #$d3d3d3d3,d3
02:00003530 227CA1A1A1A1    	  5752:                 move.l #$a1a1a1a1,a1
02:00003536 247CA2A2A2A2    	  5753:                 move.l #$a2a2a2a2,a2
02:0000353C 267CA3A3A3A3    	  5754:                 move.l #$a3a3a3a3,a3
                            	  5755: 
02:00003542 C342            	  5756:                 exg d1,d2
02:00003544 C34A            	  5757:                 exg a1,a2
02:00003546 C78B            	  5758:                 exg d3,a3
                            	  5759: 
02:00003548 0C81D2D2D2D2    	  5760:                 cmpi.l #$d2d2d2d2,d1      * Check the results
02:0000354E 66FE            	  5761:                 bne.s *
02:00003550 0C82D1D1D1D1    	  5762:                 cmpi.l #$d1d1d1d1,d2
02:00003556 66FE            	  5763:                 bne.s *
02:00003558 0C83A3A3A3A3    	  5764:                 cmpi.l #$a3a3a3a3,d3
02:0000355E 66FE            	  5765:                 bne.s *
                            	  5766: 
02:00003560 2209            	  5767:                 move.l a1,d1
02:00003562 240A            	  5768:                 move.l a2,d2
02:00003564 260B            	  5769:                 move.l a3,d3
                            	  5770: 
02:00003566 0C81A2A2A2A2    	  5771:                 cmpi.l #$a2a2a2a2,d1
02:0000356C 66FE            	  5772:                 bne.s *
02:0000356E 0C82A1A1A1A1    	  5773:                 cmpi.l #$a1a1a1a1,d2
02:00003574 66FE            	  5774:                 bne.s *
02:00003576 0C83D3D3D3D3    	  5775:                 cmpi.l #$d3d3d3d3,d3
02:0000357C 66FE            	  5776:                 bne.s *
                            	  5777: 
02:0000357E 4E75            	  5778:                 rts
                            	  5779: 
                            	  5780: 
                            	  5781: *-----------------------------------------------------------
                            	  5782: *-----------------------------------------------------------
                            	  5783: * OPCODE : ROx
                            	  5784: *-----------------------------------------------------------
                            	  5785: *-----------------------------------------------------------
                            	  5786: 
                            	  5787: *     Subroutine to check and accumulate the flags
02:00003580 40C3            	  5788: ROx_FLAGS:      move.w sr,d3
02:00003582 02830000000F    	  5789:                 andi.l #$0F,d3            * Isolate flags
02:00003588 DA83            	  5790:                 add.l d3,d5               * Copy flag results into accumulator
02:0000358A 4E75            	  5791:                 rts
                            	  5792: 
                            	  5793: op_ROx:
                            	  5794: 
                            	  5795: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  5796: 
                            	  5797: *        BYTE LEFT
02:0000358C 203C80018FF1    	  5798:                 move.l #$80018FF1,d0
02:00003592 7A00            	  5799:                 moveq  #$00000000,d5
02:00003594 7C11            	  5800:                 moveq  #$00000011,d6
                            	  5801: ROx_LOOP1:
02:00003596 ED38            	  5802:                 rol.b d6,d0
02:00003598 61E6            	  5803:                 bsr ROx_FLAGS
02:0000359A 51CEFFFA        	  5804:                 dbf d6,ROx_LOOP1
02:0000359E 0C8080018FE3    	  5805:                 cmpi.l #$80018FE3,d0
02:000035A4 66FE            	  5806:                 bne.s *
02:000035A6 0C850000006B    	  5807:                 cmpi.l #$0000006B,d5
02:000035AC 66FE            	  5808:                 bne.s *
                            	  5809: 
                            	  5810: *        BYTE RIGHT
02:000035AE 203C80018FF1    	  5811:                 move.l #$80018FF1,d0
02:000035B4 7C12            	  5812:                 moveq  #$00000012,d6
                            	  5813: ROx_LOOP2:
02:000035B6 EC38            	  5814:                 ror.b d6,d0
02:000035B8 61C6            	  5815:                 bsr ROx_FLAGS
02:000035BA 51CEFFFA        	  5816:                 dbf d6,ROx_LOOP2
02:000035BE 0C8080018F3E    	  5817:                 cmpi.l #$80018F3E,d0
02:000035C4 66FE            	  5818:                 bne.s *
02:000035C6 0C85000000C5    	  5819:                 cmpi.l #$000000C5,d5
02:000035CC 66FE            	  5820:                 bne.s *
                            	  5821: 
                            	  5822: 
                            	  5823: *        WORD LEFT
02:000035CE 203C80018FF1    	  5824:                 move.l #$80018FF1,d0
02:000035D4 7C13            	  5825:                 moveq  #$00000013,d6
                            	  5826: ROx_LOOP3:
02:000035D6 ED78            	  5827:                 rol.w d6,d0
02:000035D8 61A6            	  5828:                 bsr ROx_FLAGS
02:000035DA 51CEFFFA        	  5829:                 dbf d6,ROx_LOOP3
02:000035DE 0C80800163FC    	  5830:                 cmpi.l #$800163FC,d0
02:000035E4 66FE            	  5831:                 bne.s *
02:000035E6 0C8500000131    	  5832:                 cmpi.l #$00000131,d5
02:000035EC 66FE            	  5833:                 bne.s *
                            	  5834: 
                            	  5835: *        WORD RIGHT
02:000035EE 203C80018FF1    	  5836:                 move.l #$80018FF1,d0
02:000035F4 7C1E            	  5837:                 move.l #$0000001E,d6
                            	  5838: ROx_LOOP4:
02:000035F6 EC78            	  5839:                 ror.w d6,d0
02:000035F8 6186            	  5840:                 bsr ROx_FLAGS
02:000035FA 51CEFFFA        	  5841:                 dbf d6,ROx_LOOP4
02:000035FE 0C808001C7F8    	  5842:                 cmpi.l #$8001C7F8,d0
02:00003604 66FE            	  5843:                 bne.s *
02:00003606 0C85000001DB    	  5844:                 cmpi.l #$000001DB,d5
02:0000360C 66FE            	  5845:                 bne.s *
                            	  5846: 
                            	  5847: 
                            	  5848: *        LONG LEFT
02:0000360E 203C80018FF1    	  5849:                 move.l #$80018FF1,d0
02:00003614 7C15            	  5850:                 moveq  #$00000015,d6
                            	  5851: ROx_LOOP5:
02:00003616 EDB8            	  5852:                 rol.l d6,d0
02:00003618 6100FF66        	  5853:                 bsr ROx_FLAGS
02:0000361C 51CEFFF8        	  5854:                 dbf d6,ROx_LOOP5
02:00003620 0C8000C7F8C0    	  5855:                 cmpi.l #$00C7F8C0,d0
02:00003626 66FE            	  5856:                 bne.s *
02:00003628 0C850000021A    	  5857:                 cmpi.l #$0000021A,d5
02:0000362E 66FE            	  5858:                 bne.s *
                            	  5859: 
                            	  5860: *        LONG RIGHT
02:00003630 203C80018FF1    	  5861:                 move.l #$80018FF1,d0
02:00003636 7C16            	  5862:                 moveq  #$00000016,d6
                            	  5863: ROx_LOOP6:
02:00003638 ECB8            	  5864:                 ror.l d6,d0
02:0000363A 6100FF44        	  5865:                 bsr ROx_FLAGS
02:0000363E 51CEFFF8        	  5866:                 dbf d6,ROx_LOOP6
02:00003642 0C80000C7F8C    	  5867:                 cmpi.l #$000C7F8C,d0
02:00003648 66FE            	  5868:                 bne.s *
02:0000364A 0C8500000250    	  5869:                 cmpi.l #$00000250,d5
02:00003650 66FE            	  5870:                 bne.s *
                            	  5871: 
                            	  5872: 
                            	  5873: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  5874: 
02:00003652 203C80018FF1    	  5875:                 move.l #$80018FF1,d0
02:00003658 7A00            	  5876:                 moveq  #$00000000,d5
                            	  5877: 
                            	  5878: *        BYTE LEFT
02:0000365A E318            	  5879:                 rol.b #1,d0
02:0000365C 6100FF22        	  5880:                 bsr ROx_FLAGS
02:00003660 EB18            	  5881:                 rol.b #5,d0
02:00003662 6100FF1C        	  5882:                 bsr ROx_FLAGS
02:00003666 EF18            	  5883:                 rol.b #7,d0
02:00003668 6100FF16        	  5884:                 bsr ROx_FLAGS
02:0000366C E118            	  5885:                 rol.b #8,d0
02:0000366E 6100FF10        	  5886:                 bsr ROx_FLAGS
02:00003672 0C8080018F3E    	  5887:                 cmpi.l #$80018F3E,d0
02:00003678 66FE            	  5888:                 bne.s *
02:0000367A 0C8500000009    	  5889:                 cmpi.l #$00000009,d5
02:00003680 66FE            	  5890:                 bne.s *
                            	  5891: 
                            	  5892: *        BYTE RIGHT
02:00003682 E218            	  5893:                 ror.b #1,d0
02:00003684 6100FEFA        	  5894:                 bsr ROx_FLAGS
02:00003688 EA18            	  5895:                 ror.b #5,d0
02:0000368A 6100FEF4        	  5896:                 bsr ROx_FLAGS
02:0000368E EE18            	  5897:                 ror.b #7,d0
02:00003690 6100FEEE        	  5898:                 bsr ROx_FLAGS
02:00003694 E018            	  5899:                 ror.b #8,d0
02:00003696 6100FEE8        	  5900:                 bsr ROx_FLAGS
02:0000369A 0C8080018FF1    	  5901:                 cmpi.l #$80018FF1,d0
02:000036A0 66FE            	  5902:                 bne.s *
02:000036A2 0C8500000024    	  5903:                 cmpi.l #$00000024,d5
02:000036A8 66FE            	  5904:                 bne.s *
                            	  5905: 
                            	  5906: *        WORD LEFT
02:000036AA E358            	  5907:                 rol.w #1,d0
02:000036AC 6100FED2        	  5908:                 bsr ROx_FLAGS
02:000036B0 EB58            	  5909:                 rol.w #5,d0
02:000036B2 6100FECC        	  5910:                 bsr ROx_FLAGS
02:000036B6 EF58            	  5911:                 rol.w #7,d0
02:000036B8 6100FEC6        	  5912:                 bsr ROx_FLAGS
02:000036BC E158            	  5913:                 rol.w #8,d0
02:000036BE 6100FEC0        	  5914:                 bsr ROx_FLAGS
02:000036C2 0C808001FE31    	  5915:                 cmpi.l #$8001FE31,d0
02:000036C8 66FE            	  5916:                 bne.s *
02:000036CA 0C8500000037    	  5917:                 cmpi.l #$00000037,d5
02:000036D0 66FE            	  5918:                 bne.s *
                            	  5919: 
                            	  5920: *        WORD RIGHT
02:000036D2 E258            	  5921:                 ror.w #1,d0
02:000036D4 6100FEAA        	  5922:                 bsr ROx_FLAGS
02:000036D8 EA58            	  5923:                 ror.w #5,d0
02:000036DA 6100FEA4        	  5924:                 bsr ROx_FLAGS
02:000036DE EE58            	  5925:                 ror.w #7,d0
02:000036E0 6100FE9E        	  5926:                 bsr ROx_FLAGS
02:000036E4 E058            	  5927:                 ror.w #8,d0
02:000036E6 6100FE98        	  5928:                 bsr ROx_FLAGS
02:000036EA 0C8080018FF1    	  5929:                 cmpi.l #$80018FF1,d0
02:000036F0 66FE            	  5930:                 bne.s *
02:000036F2 0C850000005B    	  5931:                 cmpi.l #$0000005B,d5
02:000036F8 66FE            	  5932:                 bne.s *
                            	  5933: 
                            	  5934: *        LONG LEFT
02:000036FA E398            	  5935:                 rol.l #1,d0
02:000036FC 6100FE82        	  5936:                 bsr ROx_FLAGS
02:00003700 EB98            	  5937:                 rol.l #5,d0
02:00003702 6100FE7C        	  5938:                 bsr ROx_FLAGS
02:00003706 EF98            	  5939:                 rol.l #7,d0
02:00003708 6100FE76        	  5940:                 bsr ROx_FLAGS
02:0000370C E198            	  5941:                 rol.l #8,d0
02:0000370E 6100FE70        	  5942:                 bsr ROx_FLAGS
02:00003712 0C80FE300031    	  5943:                 cmpi.l #$FE300031,d0
02:00003718 66FE            	  5944:                 bne.s *
02:0000371A 0C8500000065    	  5945:                 cmpi.l #$00000065,d5
02:00003720 66FE            	  5946:                 bne.s *
                            	  5947: 
                            	  5948: *        LONG RIGHT
02:00003722 E298            	  5949:                 ror.l #1,d0
02:00003724 6100FE5A        	  5950:                 bsr ROx_FLAGS
02:00003728 EA98            	  5951:                 ror.l #5,d0
02:0000372A 6100FE54        	  5952:                 bsr ROx_FLAGS
02:0000372E EE98            	  5953:                 ror.l #7,d0
02:00003730 6100FE4E        	  5954:                 bsr ROx_FLAGS
02:00003734 E098            	  5955:                 ror.l #8,d0
02:00003736 6100FE48        	  5956:                 bsr ROx_FLAGS
02:0000373A 0C8080018FF1    	  5957:                 cmpi.l #$80018FF1,d0
02:00003740 66FE            	  5958:                 bne.s *
02:00003742 0C8500000080    	  5959:                 cmpi.l #$00000080,d5
02:00003748 66FE            	  5960:                 bne.s *
                            	  5961: 
                            	  5962: 
                            	  5963: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  5964: 
02:0000374A 7A00            	  5965:                 moveq  #$00000000,d5
02:0000374C 307C0100        	  5966:                 move.l #$00000100,a0
02:00003750 30BC8FF1        	  5967:                 move.w #$8FF1,(a0)
                            	  5968: 
                            	  5969: *        WORD LEFT
02:00003754 E7D0            	  5970:                 rol (a0)
02:00003756 6100FE28        	  5971:                 bsr ROx_FLAGS
02:0000375A E7D0            	  5972:                 rol (a0)
02:0000375C 6100FE22        	  5973:                 bsr ROx_FLAGS
02:00003760 E7D0            	  5974:                 rol (a0)
02:00003762 6100FE1C        	  5975:                 bsr ROx_FLAGS
02:00003766 E7D0            	  5976:                 rol (a0)
02:00003768 6100FE16        	  5977:                 bsr ROx_FLAGS
02:0000376C 3010            	  5978:                 move.w (a0),d0
02:0000376E 0C808001FF18    	  5979:                 cmpi.l #$8001FF18,d0
02:00003774 66FE            	  5980:                 bne.s *
02:00003776 0C8500000009    	  5981:                 cmpi.l #$00000009,d5
02:0000377C 66FE            	  5982:                 bne.s *
                            	  5983: 
                            	  5984: *        WORD RIGHT
02:0000377E E6D0            	  5985:                 ror (a0)
02:00003780 6100FDFE        	  5986:                 bsr ROx_FLAGS
02:00003784 E6D0            	  5987:                 ror (a0)
02:00003786 6100FDF8        	  5988:                 bsr ROx_FLAGS
02:0000378A E6D0            	  5989:                 ror (a0)
02:0000378C 6100FDF2        	  5990:                 bsr ROx_FLAGS
02:00003790 E6D0            	  5991:                 ror (a0)
02:00003792 6100FDEC        	  5992:                 bsr ROx_FLAGS
02:00003796 E6D0            	  5993:                 ror (a0)
02:00003798 6100FDE6        	  5994:                 bsr ROx_FLAGS
02:0000379C E6D0            	  5995:                 ror (a0)
02:0000379E 6100FDE0        	  5996:                 bsr ROx_FLAGS
02:000037A2 3010            	  5997:                 move.w (a0),d0
02:000037A4 0C80800163FC    	  5998:                 cmpi.l #$800163FC,d0
02:000037AA 66FE            	  5999:                 bne.s *
02:000037AC 0C850000001B    	  6000:                 cmpi.l #$0000001B,d5
02:000037B2 66FE            	  6001:                 bne.s *
                            	  6002: 
02:000037B4 4E75            	  6003:                 rts
                            	  6004: 
                            	  6005: 
                            	  6006: 
                            	  6007: *-----------------------------------------------------------
                            	  6008: *-----------------------------------------------------------
                            	  6009: * OPCODE : ROXx
                            	  6010: *-----------------------------------------------------------
                            	  6011: *-----------------------------------------------------------
                            	  6012: 
                            	  6013: *     Subroutine to check and accumulate the flags
02:000037B6 40C3            	  6014: ROXx_FLAGS:     move.w sr,d3
02:000037B8 02830000000F    	  6015:                 andi.l #$0F,d3            * Isolate flags
02:000037BE DA83            	  6016:                 add.l d3,d5               * Copy flag results into accumulator
02:000037C0 4E75            	  6017:                 rts
                            	  6018: 
                            	  6019: op_ROXx:
                            	  6020: 
                            	  6021: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6022: 
                            	  6023: *        BYTE LEFT
02:000037C2 203C80018FF1    	  6024:                 move.l #$80018FF1,d0
02:000037C8 7A00            	  6025:                 moveq  #$00000000,d5
02:000037CA 7C11            	  6026:                 moveq  #$00000011,d6
                            	  6027: ROXx_LOOP1:
02:000037CC ED30            	  6028:                 roxl.b d6,d0
02:000037CE 61E6            	  6029:                 bsr ROXx_FLAGS
02:000037D0 51CEFFFA        	  6030:                 dbf d6,ROXx_LOOP1
02:000037D4 0C8080018FD0    	  6031:                 cmpi.l #$80018FD0,d0
02:000037DA 66FE            	  6032:                 bne.s *
02:000037DC 0C8500000042    	  6033:                 cmpi.l #$00000042,d5
02:000037E2 66FE            	  6034:                 bne.s *
                            	  6035: 
                            	  6036: *        BYTE RIGHT
02:000037E4 203C80018FF1    	  6037:                 move.l #$80018FF1,d0
02:000037EA 7C12            	  6038:                 moveq  #$00000012,d6
                            	  6039: ROXx_LOOP2:
02:000037EC EC30            	  6040:                 roxr.b d6,d0
02:000037EE 61C6            	  6041:                 bsr ROXx_FLAGS
02:000037F0 51CEFFFA        	  6042:                 dbf d6,ROXx_LOOP2
02:000037F4 0C8080018F51    	  6043:                 cmpi.l #$80018F51,d0
02:000037FA 66FE            	  6044:                 bne.s *
02:000037FC 0C850000009C    	  6045:                 cmpi.l #$0000009C,d5
02:00003802 66FE            	  6046:                 bne.s *
                            	  6047: 
                            	  6048: 
                            	  6049: *        WORD LEFT
02:00003804 203C80018FF1    	  6050:                 move.l #$80018FF1,d0
02:0000380A 7C13            	  6051:                 moveq  #$00000013,d6
                            	  6052: ROXx_LOOP3:
02:0000380C ED70            	  6053:                 roxl.w d6,d0
02:0000380E 61A6            	  6054:                 bsr ROXx_FLAGS
02:00003810 51CEFFFA        	  6055:                 dbf d6,ROXx_LOOP3
02:00003814 0C8080013980    	  6056:                 cmpi.l #$80013980,d0
02:0000381A 66FE            	  6057:                 bne.s *
02:0000381C 0C85000000C9    	  6058:                 cmpi.l #$000000C9,d5
02:00003822 66FE            	  6059:                 bne.s *
                            	  6060: 
                            	  6061: *        WORD RIGHT
02:00003824 203C80018FF1    	  6062:                 move.l #$80018FF1,d0
02:0000382A 7C1E            	  6063:                 move.l #$0000001E,d6
                            	  6064: ROXx_LOOP4:
02:0000382C EC70            	  6065:                 roxr.w d6,d0
02:0000382E 6186            	  6066:                 bsr ROXx_FLAGS
02:00003830 51CEFFFA        	  6067:                 dbf d6,ROXx_LOOP4
02:00003834 0C8080010A1D    	  6068:                 cmpi.l #$80010A1D,d0
02:0000383A 66FE            	  6069:                 bne.s *
02:0000383C 0C850000014D    	  6070:                 cmpi.l #$0000014D,d5
02:00003842 66FE            	  6071:                 bne.s *
                            	  6072: 
                            	  6073: 
                            	  6074: *        LONG LEFT
02:00003844 203C80018FF1    	  6075:                 move.l #$80018FF1,d0
02:0000384A 7C15            	  6076:                 moveq  #$00000015,d6
                            	  6077: ROXx_LOOP5:
02:0000384C EDB0            	  6078:                 roxl.l d6,d0
02:0000384E 6100FF66        	  6079:                 bsr ROXx_FLAGS
02:00003852 51CEFFF8        	  6080:                 dbf d6,ROXx_LOOP5
02:00003856 0C80800185D0    	  6081:                 cmpi.l #$800185D0,d0
02:0000385C 66FE            	  6082:                 bne.s *
02:0000385E 0C85000001A1    	  6083:                 cmpi.l #$000001A1,d5
02:00003864 66FE            	  6084:                 bne.s *
                            	  6085: 
                            	  6086: *        LONG RIGHT
02:00003866 203C80018FF1    	  6087:                 move.l #$80018FF1,d0
02:0000386C 7C16            	  6088:                 moveq  #$00000016,d6
                            	  6089: ROXx_LOOP6:
02:0000386E ECB0            	  6090:                 roxr.l d6,d0
02:00003870 6100FF44        	  6091:                 bsr ROXx_FLAGS
02:00003874 51CEFFF8        	  6092:                 dbf d6,ROXx_LOOP6
02:00003878 0C80082D8200    	  6093:                 cmpi.l #$082D8200,d0
02:0000387E 66FE            	  6094:                 bne.s *
02:00003880 0C85000001DE    	  6095:                 cmpi.l #$000001DE,d5
02:00003886 66FE            	  6096:                 bne.s *
                            	  6097: 
                            	  6098: 
                            	  6099: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6100: 
02:00003888 203C80018FF1    	  6101:                 move.l #$80018FF1,d0
02:0000388E 7A00            	  6102:                 moveq  #$00000000,d5
                            	  6103: 
                            	  6104: *        BYTE LEFT
02:00003890 E310            	  6105:                 roxl.b #1,d0
02:00003892 6100FF22        	  6106:                 bsr ROXx_FLAGS
02:00003896 EB10            	  6107:                 roxl.b #5,d0
02:00003898 6100FF1C        	  6108:                 bsr ROXx_FLAGS
02:0000389C EF10            	  6109:                 roxl.b #7,d0
02:0000389E 6100FF16        	  6110:                 bsr ROXx_FLAGS
02:000038A2 E110            	  6111:                 roxl.b #8,d0
02:000038A4 6100FF10        	  6112:                 bsr ROXx_FLAGS
02:000038A8 0C8080018F09    	  6113:                 cmpi.l #$80018F09,d0
02:000038AE 66FE            	  6114:                 bne.s *
02:000038B0 0C850000000B    	  6115:                 cmpi.l #$0000000B,d5
02:000038B6 66FE            	  6116:                 bne.s *
                            	  6117: 
                            	  6118: *        BYTE RIGHT
02:000038B8 E210            	  6119:                 roxr.b #1,d0
02:000038BA 6100FEFA        	  6120:                 bsr ROXx_FLAGS
02:000038BE EA10            	  6121:                 roxr.b #5,d0
02:000038C0 6100FEF4        	  6122:                 bsr ROXx_FLAGS
02:000038C4 EE10            	  6123:                 roxr.b #7,d0
02:000038C6 6100FEEE        	  6124:                 bsr ROXx_FLAGS
02:000038CA E010            	  6125:                 roxr.b #8,d0
02:000038CC 6100FEE8        	  6126:                 bsr ROXx_FLAGS
02:000038D0 0C8080018F00    	  6127:                 cmpi.l #$80018F00,d0
02:000038D6 66FE            	  6128:                 bne.s *
02:000038D8 0C8500000015    	  6129:                 cmpi.l #$00000015,d5
02:000038DE 66FE            	  6130:                 bne.s *
                            	  6131: 
                            	  6132: *        WORD LEFT
02:000038E0 E350            	  6133:                 roxl.w #1,d0
02:000038E2 6100FED2        	  6134:                 bsr ROXx_FLAGS
02:000038E6 EB50            	  6135:                 roxl.w #5,d0
02:000038E8 6100FECC        	  6136:                 bsr ROXx_FLAGS
02:000038EC EF50            	  6137:                 roxl.w #7,d0
02:000038EE 6100FEC6        	  6138:                 bsr ROXx_FLAGS
02:000038F2 E150            	  6139:                 roxl.w #8,d0
02:000038F4 6100FEC0        	  6140:                 bsr ROXx_FLAGS
02:000038F8 0C808001B000    	  6141:                 cmpi.l #$8001B000,d0
02:000038FE 66FE            	  6142:                 bne.s *
02:00003900 0C8500000027    	  6143:                 cmpi.l #$00000027,d5
02:00003906 66FE            	  6144:                 bne.s *
                            	  6145: 
                            	  6146: *        WORD RIGHT
02:00003908 E250            	  6147:                 roxr.w #1,d0
02:0000390A 6100FEAA        	  6148:                 bsr ROXx_FLAGS
02:0000390E EA50            	  6149:                 roxr.w #5,d0
02:00003910 6100FEA4        	  6150:                 bsr ROXx_FLAGS
02:00003914 EE50            	  6151:                 roxr.w #7,d0
02:00003916 6100FE9E        	  6152:                 bsr ROXx_FLAGS
02:0000391A E050            	  6153:                 roxr.w #8,d0
02:0000391C 6100FE98        	  6154:                 bsr ROXx_FLAGS
02:00003920 0C8080010A00    	  6155:                 cmpi.l #$80010A00,d0
02:00003926 66FE            	  6156:                 bne.s *
02:00003928 0C8500000028    	  6157:                 cmpi.l #$00000028,d5
02:0000392E 66FE            	  6158:                 bne.s *
                            	  6159: 
                            	  6160: *        LONG LEFT
02:00003930 E390            	  6161:                 roxl.l #1,d0
02:00003932 6100FE82        	  6162:                 bsr ROXx_FLAGS
02:00003936 EB90            	  6163:                 roxl.l #5,d0
02:00003938 6100FE7C        	  6164:                 bsr ROXx_FLAGS
02:0000393C EF90            	  6165:                 roxl.l #7,d0
02:0000393E 6100FE76        	  6166:                 bsr ROXx_FLAGS
02:00003942 E190            	  6167:                 roxl.l #8,d0
02:00003944 6100FE70        	  6168:                 bsr ROXx_FLAGS
02:00003948 0C8040000010    	  6169:                 cmpi.l #$40000010,d0
02:0000394E 66FE            	  6170:                 bne.s *
02:00003950 0C850000002A    	  6171:                 cmpi.l #$0000002A,d5
02:00003956 66FE            	  6172:                 bne.s *
                            	  6173: 
                            	  6174: *        LONG RIGHT
02:00003958 E290            	  6175:                 roxr.l #1,d0
02:0000395A 6100FE5A        	  6176:                 bsr ROXx_FLAGS
02:0000395E EA90            	  6177:                 roxr.l #5,d0
02:00003960 6100FE54        	  6178:                 bsr ROXx_FLAGS
02:00003964 EE90            	  6179:                 roxr.l #7,d0
02:00003966 6100FE4E        	  6180:                 bsr ROXx_FLAGS
02:0000396A E090            	  6181:                 roxr.l #8,d0
02:0000396C 6100FE48        	  6182:                 bsr ROXx_FLAGS
02:00003970 0C8000010200    	  6183:                 cmpi.l #$00010200,d0
02:00003976 66FE            	  6184:                 bne.s *
02:00003978 0C8500000032    	  6185:                 cmpi.l #$00000032,d5
02:0000397E 66FE            	  6186:                 bne.s *
                            	  6187: 
                            	  6188: 
                            	  6189: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6190: 
02:00003980 7A00            	  6191:                 moveq  #$00000000,d5
02:00003982 307C0100        	  6192:                 move.l #$00000100,a0
02:00003986 30BC8FF1        	  6193:                 move.w #$8FF1,(a0)
                            	  6194: 
                            	  6195: *        WORD LEFT
02:0000398A E5D0            	  6196:                 roxl (a0)
02:0000398C 6100FE28        	  6197:                 bsr ROXx_FLAGS
02:00003990 E5D0            	  6198:                 roxl (a0)
02:00003992 6100FE22        	  6199:                 bsr ROXx_FLAGS
02:00003996 E5D0            	  6200:                 roxl (a0)
02:00003998 6100FE1C        	  6201:                 bsr ROXx_FLAGS
02:0000399C E5D0            	  6202:                 roxl (a0)
02:0000399E 6100FE16        	  6203:                 bsr ROXx_FLAGS
02:000039A2 3010            	  6204:                 move.w (a0),d0
02:000039A4 0C800001FF10    	  6205:                 cmpi.l #$0001FF10,d0
02:000039AA 66FE            	  6206:                 bne.s *
02:000039AC 0C8500000009    	  6207:                 cmpi.l #$00000009,d5
02:000039B2 66FE            	  6208:                 bne.s *
                            	  6209: 
                            	  6210: *        WORD RIGHT
02:000039B4 E4D0            	  6211:                 roxr (a0)
02:000039B6 6100FDFE        	  6212:                 bsr ROXx_FLAGS
02:000039BA E4D0            	  6213:                 roxr (a0)
02:000039BC 6100FDF8        	  6214:                 bsr ROXx_FLAGS
02:000039C0 E4D0            	  6215:                 roxr (a0)
02:000039C2 6100FDF2        	  6216:                 bsr ROXx_FLAGS
02:000039C6 E4D0            	  6217:                 roxr (a0)
02:000039C8 6100FDEC        	  6218:                 bsr ROXx_FLAGS
02:000039CC E4D0            	  6219:                 roxr (a0)
02:000039CE 6100FDE6        	  6220:                 bsr ROXx_FLAGS
02:000039D2 E4D0            	  6221:                 roxr (a0)
02:000039D4 6100FDE0        	  6222:                 bsr ROXx_FLAGS
02:000039D8 3010            	  6223:                 move.w (a0),d0
02:000039DA 0C80000103FC    	  6224:                 cmpi.l #$000103FC,d0
02:000039E0 66FE            	  6225:                 bne.s *
02:000039E2 0C850000000A    	  6226:                 cmpi.l #$0000000A,d5
02:000039E8 66FE            	  6227:                 bne.s *
                            	  6228: 
02:000039EA 4E75            	  6229:                 rts
                            	  6230: 
                            	  6231: 
                            	  6232: 
                            	  6233: 
                            	  6234: *-----------------------------------------------------------
                            	  6235: *-----------------------------------------------------------
                            	  6236: * OPCODE : SHIFTS
                            	  6237: *-----------------------------------------------------------
                            	  6238: *-----------------------------------------------------------
                            	  6239: 
                            	  6240: *     Subroutine to check and accumulate the flags
02:000039EC 40C3            	  6241: SHIFTS_FLAGS:   move.w sr,d3
02:000039EE 02830000000F    	  6242:                 andi.l #$0F,d3            * Isolate flags
02:000039F4 DA83            	  6243:                 add.l d3,d5               * Copy flag results into accumulator
02:000039F6 4E75            	  6244:                 rts
                            	  6245: 
                            	  6246: op_SHIFTS:
                            	  6247: 
                            	  6248: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6249: 
                            	  6250: *        BYTE LEFT
02:000039F8 203C80018F81    	  6251:                 move.l #$80018F81,d0
02:000039FE 7A00            	  6252:                 moveq  #$00000000,d5
02:00003A00 7C02            	  6253:                 moveq  #$00000002,d6
                            	  6254: SHIFTS_LOOP1:
02:00003A02 ED20            	  6255:                 asl.b d6,d0
02:00003A04 61E6            	  6256:                 bsr SHIFTS_FLAGS
02:00003A06 51CEFFFA        	  6257:                 dbf d6,SHIFTS_LOOP1
02:00003A0A 0C8080018F08    	  6258:                 cmpi.l #$80018F08,d0
02:00003A10 66FE            	  6259:                 bne.s *
02:00003A12 0C8500000002    	  6260:                 cmpi.l #$00000002,d5
02:00003A18 66FE            	  6261:                 bne.s *
                            	  6262: 
                            	  6263: *        BYTE RIGHT
02:00003A1A 203C80018F81    	  6264:                 move.l #$80018F81,d0
02:00003A20 7C02            	  6265:                 moveq  #$00000002,d6
                            	  6266: SHIFTS_LOOP2:
02:00003A22 EC20            	  6267:                 asr.b d6,d0
02:00003A24 61C6            	  6268:                 bsr SHIFTS_FLAGS
02:00003A26 51CEFFFA        	  6269:                 dbf d6,SHIFTS_LOOP2
02:00003A2A 0C8080018FF0    	  6270:                 cmpi.l #$80018FF0,d0
02:00003A30 66FE            	  6271:                 bne.s *
02:00003A32 0C850000001A    	  6272:                 cmpi.l #$0000001A,d5
02:00003A38 66FE            	  6273:                 bne.s *
                            	  6274: 
                            	  6275: 
                            	  6276: *        WORD LEFT
02:00003A3A 203C80018FF1    	  6277:                 move.l #$80018FF1,d0
02:00003A40 7C02            	  6278:                 moveq  #$00000002,d6
                            	  6279: SHIFTS_LOOP3:
02:00003A42 ED60            	  6280:                 asl.w d6,d0
02:00003A44 61A6            	  6281:                 bsr SHIFTS_FLAGS
02:00003A46 51CEFFFA        	  6282:                 dbf d6,SHIFTS_LOOP3
02:00003A4A 0C8080017F88    	  6283:                 cmpi.l #$80017F88,d0
02:00003A50 66FE            	  6284:                 bne.s *
02:00003A52 0C850000001C    	  6285:                 cmpi.l #$0000001C,d5
02:00003A58 66FE            	  6286:                 bne.s *
                            	  6287: 
                            	  6288: *        WORD RIGHT
02:00003A5A 203C80018FF1    	  6289:                 move.l #$80018FF1,d0
02:00003A60 7C02            	  6290:                 moveq  #$00000002,d6
                            	  6291: SHIFTS_LOOP4:
02:00003A62 EC60            	  6292:                 asr.w d6,d0
02:00003A64 6186            	  6293:                 bsr SHIFTS_FLAGS
02:00003A66 51CEFFFA        	  6294:                 dbf d6,SHIFTS_LOOP4
02:00003A6A 0C808001F1FE    	  6295:                 cmpi.l #$8001F1FE,d0
02:00003A70 66FE            	  6296:                 bne.s *
02:00003A72 0C8500000034    	  6297:                 cmpi.l #$00000034,d5
02:00003A78 66FE            	  6298:                 bne.s *
                            	  6299: 
                            	  6300: 
                            	  6301: *        LONG LEFT
02:00003A7A 203C80018FF1    	  6302:                 move.l #$80018FF1,d0
02:00003A80 7C02            	  6303:                 moveq  #$00000002,d6
                            	  6304: SHIFTS_LOOP5:
02:00003A82 EDA0            	  6305:                 asl.l d6,d0
02:00003A84 6100FF66        	  6306:                 bsr SHIFTS_FLAGS
02:00003A88 51CEFFF8        	  6307:                 dbf d6,SHIFTS_LOOP5
02:00003A8C 0C80000C7F88    	  6308:                 cmpi.l #$000C7F88,d0
02:00003A92 66FE            	  6309:                 bne.s *
02:00003A94 0C8500000036    	  6310:                 cmpi.l #$00000036,d5
02:00003A9A 66FE            	  6311:                 bne.s *
                            	  6312: 
                            	  6313: *        LONG RIGHT
02:00003A9C 203C80018FF1    	  6314:                 move.l #$80018FF1,d0
02:00003AA2 7C02            	  6315:                 moveq  #$00000002,d6
                            	  6316: SHIFTS_LOOP6:
02:00003AA4 ECA0            	  6317:                 asr.l d6,d0
02:00003AA6 6100FF44        	  6318:                 bsr SHIFTS_FLAGS
02:00003AAA 51CEFFF8        	  6319:                 dbf d6,SHIFTS_LOOP6
02:00003AAE 0C80F00031FE    	  6320:                 cmpi.l #$F00031FE,d0
02:00003AB4 66FE            	  6321:                 bne.s *
02:00003AB6 0C850000004E    	  6322:                 cmpi.l #$0000004E,d5
02:00003ABC 66FE            	  6323:                 bne.s *
                            	  6324: 
                            	  6325: 
                            	  6326: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6327: 
02:00003ABE 203C80018FF1    	  6328:                 move.l #$80018FF1,d0
02:00003AC4 7A00            	  6329:                 moveq  #$00000000,d5
                            	  6330: 
                            	  6331: *        BYTE LEFT
02:00003AC6 D000            	  6332:                 asl.b #1,d0
02:00003AC8 6100FF22        	  6333:                 bsr SHIFTS_FLAGS
02:00003ACC E500            	  6334:                 asl.b #2,d0
02:00003ACE 6100FF1C        	  6335:                 bsr SHIFTS_FLAGS
02:00003AD2 D000            	  6336:                 asl.b #1,d0
02:00003AD4 6100FF16        	  6337:                 bsr SHIFTS_FLAGS
02:00003AD8 E700            	  6338:                 asl.b #3,d0
02:00003ADA 6100FF10        	  6339:                 bsr SHIFTS_FLAGS
02:00003ADE 0C8080018F80    	  6340:                 cmpi.l #$80018F80,d0
02:00003AE4 66FE            	  6341:                 bne.s *
02:00003AE6 0C850000001F    	  6342:                 cmpi.l #$0000001F,d5
02:00003AEC 66FE            	  6343:                 bne.s *
                            	  6344: 
                            	  6345: *        BYTE RIGHT
02:00003AEE E200            	  6346:                 asr.b #1,d0
02:00003AF0 6100FEFA        	  6347:                 bsr SHIFTS_FLAGS
02:00003AF4 E400            	  6348:                 asr.b #2,d0
02:00003AF6 6100FEF4        	  6349:                 bsr SHIFTS_FLAGS
02:00003AFA E600            	  6350:                 asr.b #3,d0
02:00003AFC 6100FEEE        	  6351:                 bsr SHIFTS_FLAGS
02:00003B00 E200            	  6352:                 asr.b #1,d0
02:00003B02 6100FEE8        	  6353:                 bsr SHIFTS_FLAGS
02:00003B06 0C8080018FFF    	  6354:                 cmpi.l #$80018FFF,d0
02:00003B0C 66FE            	  6355:                 bne.s *
02:00003B0E 0C850000003F    	  6356:                 cmpi.l #$0000003F,d5
02:00003B14 66FE            	  6357:                 bne.s *
                            	  6358: 
                            	  6359: *        WORD LEFT
02:00003B16 D040            	  6360:                 asl.w #1,d0
02:00003B18 6100FED2        	  6361:                 bsr SHIFTS_FLAGS
02:00003B1C E540            	  6362:                 asl.w #2,d0
02:00003B1E 6100FECC        	  6363:                 bsr SHIFTS_FLAGS
02:00003B22 E740            	  6364:                 asl.w #3,d0
02:00003B24 6100FEC6        	  6365:                 bsr SHIFTS_FLAGS
02:00003B28 EB40            	  6366:                 asl.w #5,d0
02:00003B2A 6100FEC0        	  6367:                 bsr SHIFTS_FLAGS
02:00003B2E 0C808001F800    	  6368:                 cmpi.l #$8001F800,d0
02:00003B34 66FE            	  6369:                 bne.s *
02:00003B36 0C8500000056    	  6370:                 cmpi.l #$00000056,d5
02:00003B3C 66FE            	  6371:                 bne.s *
                            	  6372: 
                            	  6373: *        WORD RIGHT
02:00003B3E EA40            	  6374:                 asr.w #5,d0
02:00003B40 6100FEAA        	  6375:                 bsr SHIFTS_FLAGS
02:00003B44 E240            	  6376:                 asr.w #1,d0
02:00003B46 6100FEA4        	  6377:                 bsr SHIFTS_FLAGS
02:00003B4A E440            	  6378:                 asr.w #2,d0
02:00003B4C 6100FE9E        	  6379:                 bsr SHIFTS_FLAGS
02:00003B50 E840            	  6380:                 asr.w #4,d0
02:00003B52 6100FE98        	  6381:                 bsr SHIFTS_FLAGS
02:00003B56 0C808001FFFF    	  6382:                 cmpi.l #$8001FFFF,d0
02:00003B5C 66FE            	  6383:                 bne.s *
02:00003B5E 0C8500000077    	  6384:                 cmpi.l #$00000077,d5
02:00003B64 66FE            	  6385:                 bne.s *
                            	  6386: 
                            	  6387: *        LONG LEFT
02:00003B66 203C80018FF1    	  6388:                 move.l #$80018FF1,d0
02:00003B6C D080            	  6389:                 asl.l #1,d0
02:00003B6E 6100FE7C        	  6390:                 bsr SHIFTS_FLAGS
02:00003B72 E580            	  6391:                 asl.l #2,d0
02:00003B74 6100FE76        	  6392:                 bsr SHIFTS_FLAGS
02:00003B78 EF80            	  6393:                 asl.l #7,d0
02:00003B7A 6100FE70        	  6394:                 bsr SHIFTS_FLAGS
02:00003B7E E980            	  6395:                 asl.l #4,d0
02:00003B80 6100FE6A        	  6396:                 bsr SHIFTS_FLAGS
02:00003B84 0C8063FC4000    	  6397:                 cmpi.l #$63FC4000,d0
02:00003B8A 66FE            	  6398:                 bne.s *
02:00003B8C 0C850000007A    	  6399:                 cmpi.l #$0000007A,d5
02:00003B92 66FE            	  6400:                 bne.s *
                            	  6401: 
                            	  6402: *        LONG RIGHT
02:00003B94 203C80018FF1    	  6403:                 move.l #$80018FF1,d0
02:00003B9A E280            	  6404:                 asr.l #1,d0
02:00003B9C 6100FE4E        	  6405:                 bsr SHIFTS_FLAGS
02:00003BA0 EA80            	  6406:                 asr.l #5,d0
02:00003BA2 6100FE48        	  6407:                 bsr SHIFTS_FLAGS
02:00003BA6 EE80            	  6408:                 asr.l #7,d0
02:00003BA8 6100FE42        	  6409:                 bsr SHIFTS_FLAGS
02:00003BAC E080            	  6410:                 asr.l #8,d0
02:00003BAE 6100FE3C        	  6411:                 bsr SHIFTS_FLAGS
02:00003BB2 0C80FFFFFC00    	  6412:                 cmpi.l #$FFFFFC00,d0
02:00003BB8 66FE            	  6413:                 bne.s *
02:00003BBA 0C850000009C    	  6414:                 cmpi.l #$0000009C,d5
02:00003BC0 66FE            	  6415:                 bne.s *
                            	  6416: 
                            	  6417: 
                            	  6418: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6419: 
02:00003BC2 7A00            	  6420:                 moveq  #$00000000,d5
02:00003BC4 307C0100        	  6421:                 move.l #$00000100,a0
02:00003BC8 30BC8FF1        	  6422:                 move.w #$8FF1,(a0)
                            	  6423: 
                            	  6424: *        WORD LEFT
02:00003BCC E1D0            	  6425:                 asl  (a0)
02:00003BCE 6100FE1C        	  6426:                 bsr SHIFTS_FLAGS
02:00003BD2 E1D0            	  6427:                 asl  (a0)
02:00003BD4 6100FE16        	  6428:                 bsr SHIFTS_FLAGS
02:00003BD8 E1D0            	  6429:                 asl  (a0)
02:00003BDA 6100FE10        	  6430:                 bsr SHIFTS_FLAGS
02:00003BDE E1D0            	  6431:                 asl  (a0)
02:00003BE0 6100FE0A        	  6432:                 bsr SHIFTS_FLAGS
02:00003BE4 3010            	  6433:                 move.w (a0),d0
02:00003BE6 0C80FFFFFF10    	  6434:                 cmpi.l #$FFFFFF10,d0
02:00003BEC 66FE            	  6435:                 bne.s *
02:00003BEE 0C850000000D    	  6436:                 cmpi.l #$0000000D,d5
02:00003BF4 66FE            	  6437:                 bne.s *
                            	  6438: 
                            	  6439: *        WORD RIGHT
02:00003BF6 E0D0            	  6440:                 asr (a0)
02:00003BF8 6100FDF2        	  6441:                 bsr SHIFTS_FLAGS
02:00003BFC E0D0            	  6442:                 asr (a0)
02:00003BFE 6100FDEC        	  6443:                 bsr SHIFTS_FLAGS
02:00003C02 E0D0            	  6444:                 asr (a0)
02:00003C04 6100FDE6        	  6445:                 bsr SHIFTS_FLAGS
02:00003C08 E0D0            	  6446:                 asr (a0)
02:00003C0A 6100FDE0        	  6447:                 bsr SHIFTS_FLAGS
02:00003C0E E0D0            	  6448:                 asr (a0)
02:00003C10 6100FDDA        	  6449:                 bsr SHIFTS_FLAGS
02:00003C14 E0D0            	  6450:                 asr (a0)
02:00003C16 6100FDD4        	  6451:                 bsr SHIFTS_FLAGS
02:00003C1A 3010            	  6452:                 move.w (a0),d0
02:00003C1C 0C80FFFFFFFC    	  6453:                 cmpi.l #$FFFFFFFC,d0
02:00003C22 66FE            	  6454:                 bne.s *
02:00003C24 0C850000003E    	  6455:                 cmpi.l #$0000003E,d5
02:00003C2A 66FE            	  6456:                 bne.s *
                            	  6457: 
02:00003C2C 4E75            	  6458:                 rts
                            	  6459: 
                            	  6460: 
                            	  6461: 
                            	  6462: *-----------------------------------------------------------
                            	  6463: *-----------------------------------------------------------
                            	  6464: * OPCODE : SHIFTS2
                            	  6465: *-----------------------------------------------------------
                            	  6466: *-----------------------------------------------------------
                            	  6467: 
                            	  6468: *     Subroutine to check and accumulate the flags
02:00003C2E 40C3            	  6469: SHIFTS2_FLAGS:  move.w sr,d3
02:00003C30 02830000000F    	  6470:                 andi.l #$0F,d3            * Isolate flags
02:00003C36 DA83            	  6471:                 add.l d3,d5               * Copy flag results into accumulator
02:00003C38 4E75            	  6472:                 rts
                            	  6473: 
                            	  6474: op_SHIFTS2:
                            	  6475: 
                            	  6476: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6477: 
                            	  6478: *        BYTE LEFT
02:00003C3A 203C80018F81    	  6479:                 move.l #$80018F81,d0
02:00003C40 7A00            	  6480:                 moveq  #$00000000,d5
02:00003C42 7C02            	  6481:                 moveq  #$00000002,d6
                            	  6482: SHIFTS2_LOOP1:
02:00003C44 ED28            	  6483:                 lsl.b d6,d0
02:00003C46 61E6            	  6484:                 bsr SHIFTS2_FLAGS
02:00003C48 51CEFFFA        	  6485:                 dbf d6,SHIFTS2_LOOP1
02:00003C4C 0C8080018F08    	  6486:                 cmpi.l #$80018F08,d0
02:00003C52 66FE            	  6487:                 bne.s *
02:00003C54 4A85            	  6488:                 cmpi.l #$00000000,d5
02:00003C56 66FE            	  6489:                 bne.s *
                            	  6490: 
                            	  6491: *        BYTE RIGHT
02:00003C58 203C80018F81    	  6492:                 move.l #$80018F81,d0
02:00003C5E 7C02            	  6493:                 moveq  #$00000002,d6
                            	  6494: SHIFTS2_LOOP2:
02:00003C60 EC28            	  6495:                 lsr.b d6,d0
02:00003C62 61CA            	  6496:                 bsr SHIFTS2_FLAGS
02:00003C64 51CEFFFA        	  6497:                 dbf d6,SHIFTS2_LOOP2
02:00003C68 0C8080018F10    	  6498:                 cmpi.l #$80018F10,d0
02:00003C6E 66FE            	  6499:                 bne.s *
02:00003C70 4A85            	  6500:                 cmpi.l #$00000000,d5
02:00003C72 66FE            	  6501:                 bne.s *
                            	  6502: 
                            	  6503: 
                            	  6504: *        WORD LEFT
02:00003C74 203C80018FF1    	  6505:                 move.l #$80018FF1,d0
02:00003C7A 7C02            	  6506:                 moveq  #$00000002,d6
                            	  6507: SHIFTS2_LOOP3:
02:00003C7C ED68            	  6508:                 lsl.w d6,d0
02:00003C7E 61AE            	  6509:                 bsr SHIFTS2_FLAGS
02:00003C80 51CEFFFA        	  6510:                 dbf d6,SHIFTS2_LOOP3
02:00003C84 0C8080017F88    	  6511:                 cmpi.l #$80017F88,d0
02:00003C8A 66FE            	  6512:                 bne.s *
02:00003C8C 4A85            	  6513:                 cmpi.l #$00000000,d5
02:00003C8E 66FE            	  6514:                 bne.s *
                            	  6515: 
                            	  6516: *        WORD RIGHT
02:00003C90 203C80018FF1    	  6517:                 move.l #$80018FF1,d0
02:00003C96 7C02            	  6518:                 moveq  #$00000002,d6
                            	  6519: SHIFTS2_LOOP4:
02:00003C98 EC68            	  6520:                 lsr.w d6,d0
02:00003C9A 6192            	  6521:                 bsr SHIFTS2_FLAGS
02:00003C9C 51CEFFFA        	  6522:                 dbf d6,SHIFTS2_LOOP4
02:00003CA0 0C80800111FE    	  6523:                 cmpi.l #$800111FE,d0
02:00003CA6 66FE            	  6524:                 bne.s *
02:00003CA8 4A85            	  6525:                 cmpi.l #$00000000,d5
02:00003CAA 66FE            	  6526:                 bne.s *
                            	  6527: 
                            	  6528: 
                            	  6529: *        LONG LEFT
02:00003CAC 203C80018FF1    	  6530:                 move.l #$80018FF1,d0
02:00003CB2 7C02            	  6531:                 moveq  #$00000002,d6
                            	  6532: SHIFTS2_LOOP5:
02:00003CB4 EDA8            	  6533:                 lsl.l d6,d0
02:00003CB6 6100FF76        	  6534:                 bsr SHIFTS2_FLAGS
02:00003CBA 51CEFFF8        	  6535:                 dbf d6,SHIFTS2_LOOP5
02:00003CBE 0C80000C7F88    	  6536:                 cmpi.l #$000C7F88,d0
02:00003CC4 66FE            	  6537:                 bne.s *
02:00003CC6 4A85            	  6538:                 cmpi.l #$00000000,d5
02:00003CC8 66FE            	  6539:                 bne.s *
                            	  6540: 
                            	  6541: *        LONG RIGHT
02:00003CCA 203C80018FF1    	  6542:                 move.l #$80018FF1,d0
02:00003CD0 7C02            	  6543:                 moveq  #$00000002,d6
                            	  6544: SHIFTS2_LOOP6:
02:00003CD2 ECA8            	  6545:                 lsr.l d6,d0
02:00003CD4 6100FF58        	  6546:                 bsr SHIFTS2_FLAGS
02:00003CD8 51CEFFF8        	  6547:                 dbf d6,SHIFTS2_LOOP6
02:00003CDC 0C80100031FE    	  6548:                 cmpi.l #$100031FE,d0
02:00003CE2 66FE            	  6549:                 bne.s *
02:00003CE4 4A85            	  6550:                 cmpi.l #$00000000,d5
02:00003CE6 66FE            	  6551:                 bne.s *
                            	  6552: 
                            	  6553: 
                            	  6554: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6555: 
02:00003CE8 203C80018FF1    	  6556:                 move.l #$80018FF1,d0
02:00003CEE 7A00            	  6557:                 moveq  #$00000000,d5
                            	  6558: 
                            	  6559: *        BYTE LEFT
02:00003CF0 E308            	  6560:                 lsl.b #1,d0
02:00003CF2 6100FF3A        	  6561:                 bsr SHIFTS2_FLAGS
02:00003CF6 E508            	  6562:                 lsl.b #2,d0
02:00003CF8 6100FF34        	  6563:                 bsr SHIFTS2_FLAGS
02:00003CFC E308            	  6564:                 lsl.b #1,d0
02:00003CFE 6100FF2E        	  6565:                 bsr SHIFTS2_FLAGS
02:00003D02 E708            	  6566:                 lsl.b #3,d0
02:00003D04 6100FF28        	  6567:                 bsr SHIFTS2_FLAGS
02:00003D08 0C8080018F80    	  6568:                 cmpi.l #$80018F80,d0
02:00003D0E 66FE            	  6569:                 bne.s *
02:00003D10 0C850000001B    	  6570:                 cmpi.l #$0000001B,d5
02:00003D16 66FE            	  6571:                 bne.s *
                            	  6572: 
                            	  6573: *        BYTE RIGHT
02:00003D18 E208            	  6574:                 lsr.b #1,d0
02:00003D1A 6100FF12        	  6575:                 bsr SHIFTS2_FLAGS
02:00003D1E E408            	  6576:                 lsr.b #2,d0
02:00003D20 6100FF0C        	  6577:                 bsr SHIFTS2_FLAGS
02:00003D24 E608            	  6578:                 lsr.b #3,d0
02:00003D26 6100FF06        	  6579:                 bsr SHIFTS2_FLAGS
02:00003D2A E208            	  6580:                 lsr.b #1,d0
02:00003D2C 6100FF00        	  6581:                 bsr SHIFTS2_FLAGS
02:00003D30 0C8080018F01    	  6582:                 cmpi.l #$80018F01,d0
02:00003D36 66FE            	  6583:                 bne.s *
02:00003D38 0C850000001B    	  6584:                 cmpi.l #$0000001B,d5
02:00003D3E 66FE            	  6585:                 bne.s *
                            	  6586: 
                            	  6587: *        WORD LEFT
02:00003D40 E348            	  6588:                 lsl.w #1,d0
02:00003D42 6100FEEA        	  6589:                 bsr SHIFTS2_FLAGS
02:00003D46 E548            	  6590:                 lsl.w #2,d0
02:00003D48 6100FEE4        	  6591:                 bsr SHIFTS2_FLAGS
02:00003D4C E748            	  6592:                 lsl.w #3,d0
02:00003D4E 6100FEDE        	  6593:                 bsr SHIFTS2_FLAGS
02:00003D52 EB48            	  6594:                 lsl.w #5,d0
02:00003D54 6100FED8        	  6595:                 bsr SHIFTS2_FLAGS
02:00003D58 0C8080010800    	  6596:                 cmpi.l #$80010800,d0
02:00003D5E 66FE            	  6597:                 bne.s *
02:00003D60 0C8500000025    	  6598:                 cmpi.l #$00000025,d5
02:00003D66 66FE            	  6599:                 bne.s *
                            	  6600: 
                            	  6601: *        WORD RIGHT
02:00003D68 EA48            	  6602:                 lsr.w #5,d0
02:00003D6A 6100FEC2        	  6603:                 bsr SHIFTS2_FLAGS
02:00003D6E E248            	  6604:                 lsr.w #1,d0
02:00003D70 6100FEBC        	  6605:                 bsr SHIFTS2_FLAGS
02:00003D74 E448            	  6606:                 lsr.w #2,d0
02:00003D76 6100FEB6        	  6607:                 bsr SHIFTS2_FLAGS
02:00003D7A E848            	  6608:                 lsr.w #4,d0
02:00003D7C 6100FEB0        	  6609:                 bsr SHIFTS2_FLAGS
02:00003D80 0C8080010000    	  6610:                 cmpi.l #$80010000,d0
02:00003D86 66FE            	  6611:                 bne.s *
02:00003D88 0C850000002A    	  6612:                 cmpi.l #$0000002A,d5
02:00003D8E 66FE            	  6613:                 bne.s *
                            	  6614: 
                            	  6615: *        LONG LEFT
02:00003D90 203C80018FF1    	  6616:                 move.l #$80018FF1,d0
02:00003D96 E388            	  6617:                 lsl.l #1,d0
02:00003D98 6100FE94        	  6618:                 bsr SHIFTS2_FLAGS
02:00003D9C E588            	  6619:                 lsl.l #2,d0
02:00003D9E 6100FE8E        	  6620:                 bsr SHIFTS2_FLAGS
02:00003DA2 EF88            	  6621:                 lsl.l #7,d0
02:00003DA4 6100FE88        	  6622:                 bsr SHIFTS2_FLAGS
02:00003DA8 E988            	  6623:                 lsl.l #4,d0
02:00003DAA 6100FE82        	  6624:                 bsr SHIFTS2_FLAGS
02:00003DAE 0C8063FC4000    	  6625:                 cmpi.l #$63FC4000,d0
02:00003DB4 66FE            	  6626:                 bne.s *
02:00003DB6 0C850000002B    	  6627:                 cmpi.l #$0000002B,d5
02:00003DBC 66FE            	  6628:                 bne.s *
                            	  6629: 
                            	  6630: *        LONG RIGHT
02:00003DBE 203C80018FF1    	  6631:                 move.l #$80018FF1,d0
02:00003DC4 E288            	  6632:                 lsr.l #1,d0
02:00003DC6 6100FE66        	  6633:                 bsr SHIFTS2_FLAGS
02:00003DCA EA88            	  6634:                 lsr.l #5,d0
02:00003DCC 6100FE60        	  6635:                 bsr SHIFTS2_FLAGS
02:00003DD0 EE88            	  6636:                 lsr.l #7,d0
02:00003DD2 6100FE5A        	  6637:                 bsr SHIFTS2_FLAGS
02:00003DD6 E088            	  6638:                 lsr.l #8,d0
02:00003DD8 6100FE54        	  6639:                 bsr SHIFTS2_FLAGS
02:00003DDC 0C8000000400    	  6640:                 cmpi.l #$00000400,d0
02:00003DE2 66FE            	  6641:                 bne.s *
02:00003DE4 0C850000002D    	  6642:                 cmpi.l #$0000002D,d5
02:00003DEA 66FE            	  6643:                 bne.s *
                            	  6644: 
                            	  6645: 
                            	  6646: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6647: 
02:00003DEC 7A00            	  6648:                 moveq  #$00000000,d5
02:00003DEE 307C0100        	  6649:                 move.l #$00000100,a0
02:00003DF2 30BC8FF1        	  6650:                 move.w #$8FF1,(a0)
                            	  6651: 
                            	  6652: *        WORD LEFT
02:00003DF6 E3D0            	  6653:                 lsl  (a0)
02:00003DF8 6100FE34        	  6654:                 bsr SHIFTS2_FLAGS
02:00003DFC E3D0            	  6655:                 lsl  (a0)
02:00003DFE 6100FE2E        	  6656:                 bsr SHIFTS2_FLAGS
02:00003E02 E3D0            	  6657:                 lsl  (a0)
02:00003E04 6100FE28        	  6658:                 bsr SHIFTS2_FLAGS
02:00003E08 E3D0            	  6659:                 lsl  (a0)
02:00003E0A 6100FE22        	  6660:                 bsr SHIFTS2_FLAGS
02:00003E0E 3010            	  6661:                 move.w (a0),d0
02:00003E10 0C800000FF10    	  6662:                 cmpi.l #$0000FF10,d0
02:00003E16 66FE            	  6663:                 bne.s *
02:00003E18 0C8500000009    	  6664:                 cmpi.l #$00000009,d5
02:00003E1E 66FE            	  6665:                 bne.s *
                            	  6666: 
                            	  6667: *        WORD RIGHT
02:00003E20 E2D0            	  6668:                 lsr (a0)
02:00003E22 6100FE0A        	  6669:                 bsr SHIFTS2_FLAGS
02:00003E26 E2D0            	  6670:                 lsr (a0)
02:00003E28 6100FE04        	  6671:                 bsr SHIFTS2_FLAGS
02:00003E2C E2D0            	  6672:                 lsr (a0)
02:00003E2E 6100FDFE        	  6673:                 bsr SHIFTS2_FLAGS
02:00003E32 E2D0            	  6674:                 lsr (a0)
02:00003E34 6100FDF8        	  6675:                 bsr SHIFTS2_FLAGS
02:00003E38 E2D0            	  6676:                 lsr (a0)
02:00003E3A 6100FDF2        	  6677:                 bsr SHIFTS2_FLAGS
02:00003E3E E2D0            	  6678:                 lsr (a0)
02:00003E40 6100FDEC        	  6679:                 bsr SHIFTS2_FLAGS
02:00003E44 3010            	  6680:                 move.w (a0),d0
02:00003E46 0C80000003FC    	  6681:                 cmpi.l #$000003FC,d0
02:00003E4C 66FE            	  6682:                 bne.s *
02:00003E4E 0C850000000A    	  6683:                 cmpi.l #$0000000A,d5
02:00003E54 66FE            	  6684:                 bne.s *
                            	  6685: 
02:00003E56 4E75            	  6686:                 rts
                            	  6687: 
                            	  6688: ;-----------------------------------------------------------
                            	  6689: ;-----------------------------------------------------------
                            	  6690: ; OPCODE : BSR / RTS
                            	  6691: ;-----------------------------------------------------------
                            	  6692: ;-----------------------------------------------------------
                            	  6693: 
                            	  6694: ;t3_bsr:
                            	  6695: ;	moveq	#3,d3
                            	  6696: ;	rts
                            	  6697: 
                            	  6698: ;t1_bsr:
                            	  6699: ;	moveq	#1,d1
                            	  6700: ;	rts
                            	  6701: 
                            	  6702: ;op_bsr:
                            	  6703: ;	bsr			t1_bsr
                            	  6704: ;	bsr			t2_bsr
                            	  6705: ;	bsr.w		t3_bsr
                            	  6706: ;	bsr.w		t4_bsr
                            	  6707: ;	cmpi.l	#1,d1
                            	  6708: ;	bne			*
                            	  6709: ;	cmpi.l	#2,d2
                            	  6710: ;	bne			*
                            	  6711: ;	cmpi.l	#3,d3
                            	  6712: ;	bne			*
                            	  6713: ;	cmpi.l	#4,d4
                            	  6714: ;	bne			*
                            	  6715: ;	rts
                            	  6716: 
                            	  6717: ;t2_bsr:
                            	  6718: ;	moveq	#2,d2
                            	  6719: ;	rts
                            	  6720: 	
                            	  6721: ;t4_bsr:
                            	  6722: ;	moveq	#4,d4
                            	  6723: ;	rts
                            	  6724: *    END
                            	  6725:     
                            	  6726: 

Source: "boot.asm"
                            	   861: 	include "TinyBasicFlt.asm"

Source: "TinyBasicFlt.asm"
                            	     1: ******************************************************************
                            	     2: *								 *
                            	     3: *		Tiny Float BASIC for the Motorola MC68000		 *
                            	     4: *								 *
                            	     5: * Derived from Palo Alto Tiny BASIC as published in the May 1976 *
                            	     6: * issue of Dr. Dobb's Journal.  Adapted to the 68000 by:         *
                            	     7: *	Gordon Brandly						 *
                            	     8: *	12147 - 51 Street					 *
                            	     9: *	Edmonton AB  T5W 3G8					 *
                            	    10: *	Canada							 *
                            	    11: *	(updated mailing address for 1996)			 *
                            	    12: * Modified 2022 for the rf68000. Robert Finch
                            	    13: *								 *
                            	    14: * This version is for MEX68KECB Educational Computer Board I/O.  *
                            	    15: *								 *
                            	    16: ******************************************************************
                            	    17: *    Copyright (C) 1984 by Gordon Brandly. This program may be	 *
                            	    18: *    freely distributed for personal use only. All commercial	 *
                            	    19: *		       rights are reserved.			 *
                            	    20: ******************************************************************
                            	    21: 
                            	    22: * Vers. 1.0  1984/7/17	- Original version by Gordon Brandly
                            	    23: *	1.1  1984/12/9	- Addition of '$' print term by Marvin Lipford
                            	    24: *	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                            	    25: 
                            	    26: *	OPT	FRS,BRS 	forward ref.'s & branches default to short
                            	    27: 
                            	    28: ;CR	EQU	$0D		ASCII equates
                            	    29: ;LF	EQU	$0A
                            	    30: ;TAB	EQU	$09
                            	    31: ;CTRLC	EQU	$03
                            	    32: ;CTRLH	EQU	$08
                            	    33: ;CTRLS	EQU	$13
                            	    34: ;CTRLX	EQU	$18
                            	    35: 
                            	    36: BUFLEN	EQU	80		length of keyboard input buffer
                            	    37: 	CODE
                            	    38: *	ORG	$10000		first free address using Tutor
                            	    39: *
                            	    40: * Standard jump table. You can change these addresses if you are
                            	    41: * customizing this interpreter for a different environment.
                            	    42: *
02:00003E58 601E            	    43: START	BRA	CSTART		Cold Start entry point
02:00003E5A 606A            	    44: GOWARM	BRA	WSTART		Warm Start entry point
02:00003E5C 60000E4A        	    45: GOOUT	BRA OUTC		Jump to character-out routine
02:00003E60 60000E62        	    46: GOIN	BRA INC		Jump to character-in routine
02:00003E64 60000E7E        	    47: GOAUXO	BRA	AUXOUT		Jump to auxiliary-out routine
02:00003E68 60000E8A        	    48: GOAUXI	BRA	AUXIN		Jump to auxiliary-in routine
02:00003E6C 60000EA6        	    49: GOBYE	BRA	BYEBYE		Jump to monitor, DOS, etc.
                            	    50: *
                            	    51: * Modifiable system constants:
                            	    52: *
02:00003E70 00041000        	    53: TXTBGN	DC.L	$41000		beginning of program memory
02:00003E74 00047FF0        	    54: ENDMEM	DC.L	$47FF0		end of available memory
                            	    55: *
                            	    56: * The main interpreter starts here:
                            	    57: *
02:00003E78 2E7AFFFA        	    58: CSTART	MOVE.L	ENDMEM,SP	initialize stack pointer
02:00003E7C 23FC00004CB40000	    59: 	move.l	#OUTC1,OUTPTR
02:00003E84 4D78
02:00003E86 23FC00004CD00000	    60: 	move.l	#INC1,INPPTR
02:00003E8E 4D74
02:00003E90 23FC000000010004	    61: 	move.l #1,_fpTextIncr
02:00003E98 0094
02:00003E9A 4DFA0E86        	    62: 	LEA	INITMSG,A6	tell who we are
02:00003E9E 61000DFC        	    63: 	BSR	PRMESG
02:00003EA2 23FAFFCC00004DB4	    64: 	MOVE.L	TXTBGN,TXTUNF	init. end-of-program pointer
02:00003EAA 203AFFC8        	    65: 	MOVE.L	ENDMEM,D0	get address of end of memory
02:00003EAE 90BC00001000    	    66: 	SUB.L	#4096,D0	reserve 4K for the stack
02:00003EB4 23C000004DBC    	    67: 	MOVE.L	D0,STKLMT
02:00003EBA 90BC00000200    	    68: 	SUB.L	#512,D0 	reserve variable area (32 16 byte floats)
02:00003EC0 23C000004DB8    	    69: 	MOVE.L	D0,VARBGN
                            	    70: WSTART
02:00003EC6 7000            	    71: 	CLR.L	D0		initialize internal variables
02:00003EC8 23FC000000010004	    72: 	move.l #1,_fpTextIncr
02:00003ED0 0094
02:00003ED2 42B900004DB0    	    73: 	clr.l IRQROUT
02:00003ED8 23C000004D8C    	    74: 	MOVE.L	D0,LOPVAR
02:00003EDE 23C000004D84    	    75: 	MOVE.L	D0,STKGOS
02:00003EE4 23C000004D7C    	    76: 	MOVE.L	D0,CURRNT	current line number pointer = 0
02:00003EEA 2E7AFF88        	    77: 	MOVE.L	ENDMEM,SP	init S.P. again, just in case
02:00003EEE 4DFA0E5E        	    78: 	LEA	OKMSG,A6	display "OK"
02:00003EF2 61000DA8        	    79: 	bsr	PRMESG
                            	    80: ST3
02:00003EF6 103C003E        	    81: 	MOVE.B	#'>',D0         Prompt with a '>' and
02:00003EFA 61000AD0        	    82: 	bsr	GETLN		read a line.
02:00003EFE 61000D40        	    83: 	bsr	TOUPBUF 	convert to upper case
02:00003F02 2848            	    84: 	MOVE.L	A0,A4		save pointer to end of line
02:00003F04 41FA0EBA        	    85: 	LEA	BUFFER,A0	point to the beginning of line
02:00003F08 61000CE4        	    86: 	bsr	TSTNUM		is there a number there?
02:00003F0C 61000D28        	    87: 	bsr	IGNBLK		skip trailing blanks
02:00003F10 F2016080        	    88: 	FMOVE.L FP1,D1
02:00003F14 4A82            	    89: 	TST.L D2			; does line no. exist? (or nonzero?)
02:00003F16 670001CC        	    90: 	BEQ	DIRECT		; if not, it's a direct statement
02:00003F1A B2BC0000FFFF    	    91: 	CMP.L	#$FFFF,D1	see if line no. is <= 16 bits
02:00003F20 64000AA2        	    92: 	BCC	QHOW		if not, we've overflowed
02:00003F24 1101            	    93: 	MOVE.B	D1,-(A0)	store the binary line no.
02:00003F26 E059            	    94: 	ROR	#8,D1		(Kludge to store a word on a
02:00003F28 1101            	    95: 	MOVE.B	D1,-(A0)	possible byte boundary)
02:00003F2A E159            	    96: 	ROL	#8,D1
02:00003F2C 61000B3C        	    97: 	bsr	FNDLN		find this line in save area
02:00003F30 2A49            	    98: 	MOVE.L	A1,A5		save possible line pointer
02:00003F32 6614            	    99: 	BNE	ST4		if not found, insert
02:00003F34 61000B5A        	   100: 	bsr	FNDNXT		find the next line (into A1)
02:00003F38 244D            	   101: 	MOVE.L	A5,A2		pointer to line to be deleted
02:00003F3A 267A0E78        	   102: 	MOVE.L	TXTUNF,A3	points to top of save area
02:00003F3E 61000B60        	   103: 	bsr	MVUP		move up to delete
02:00003F42 23CA00004DB4    	   104: 	MOVE.L	A2,TXTUNF	update the end pointer
                            	   105: ST4
02:00003F48 200C            	   106: 	MOVE.L	A4,D0		calculate the length of new line
02:00003F4A 9088            	   107: 	SUB.L	A0,D0
02:00003F4C B0BC00000003    	   108: 	CMP.L	#3,D0		is it just a line no. & CR?
02:00003F52 67A2            	   109: 	BEQ	ST3		if so, it was just a delete
02:00003F54 267A0E5E        	   110: 	MOVE.L	TXTUNF,A3	compute new end
02:00003F58 2C4B            	   111: 	MOVE.L	A3,A6
02:00003F5A D7C0            	   112: 	ADD.L	D0,A3
02:00003F5C 203A0E5A        	   113: 	MOVE.L VARBGN,D0	see if there's enough room
02:00003F60 B08B            	   114: 	CMP.L	A3,D0
02:00003F62 63000A58        	   115: 	BLS	QSORRY		if not, say so
02:00003F66 23CB00004DB4    	   116: 	MOVE.L	A3,TXTUNF	if so, store new end position
02:00003F6C 224E            	   117: 	MOVE.L	A6,A1		points to old unfilled area
02:00003F6E 244D            	   118: 	MOVE.L	A5,A2		points to beginning of move area
02:00003F70 61000B38        	   119: 	bsr	MVDOWN		move things out of the way
02:00003F74 2248            	   120: 	MOVE.L	A0,A1		set up to do the insertion
02:00003F76 244D            	   121: 	MOVE.L	A5,A2
02:00003F78 264C            	   122: 	MOVE.L	A4,A3
02:00003F7A 61000B24        	   123: 	bsr	MVUP		do it
02:00003F7E 6000FF76        	   124: 	BRA	ST3		go back and get another line
                            	   125: 
                            	   126: 	even
                            	   127: 
                            	   128: *******************************************************************
                            	   129: *
                            	   130: * *** Tables *** DIRECT *** EXEC ***
                            	   131: *
                            	   132: * This section of the code tests a string against a table. When
                            	   133: * a match is found, control is transferred to the section of
                            	   134: * code according to the table.
                            	   135: *
                            	   136: * At 'EXEC', A0 should point to the string, A1 should point to
                            	   137: * the character table, and A2 should point to the execution
                            	   138: * table. At 'DIRECT', A0 should point to the string, A1 and
                            	   139: * A2 will be set up to point to TAB1 and TAB1_1, which are
                            	   140: * the tables of all direct and statement commands.
                            	   141: *
                            	   142: * A '.' in the string will terminate the test and the partial
                            	   143: * match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                            	   144: * 'PRIN.', or 'PRINT' will all match 'PRINT'.
                            	   145: *
                            	   146: * There are two tables: the character table and the execution
                            	   147: * table. The character table consists of any number of text items.
                            	   148: * Each item is a string of characters with the last character's
                            	   149: * high bit set to one. The execution table holds a 16-bit
                            	   150: * execution addresses that correspond to each entry in the
                            	   151: * character table.
                            	   152: *
                            	   153: * The end of the character table is a 0 byte which corresponds
                            	   154: * to the default routine in the execution table, which is
                            	   155: * executed if none of the other table items are matched.
                            	   156: *
                            	   157: * Character-matching tables:
                            	   158: TAB1
02:00003F82 3C434F          	   159: 	DC.B	'<CO',('M'+$80)
02:00003F85 CD
02:00003F86 3C434F          	   160: 	DC.B	'<CO',('N'+$80)
02:00003F89 CE
02:00003F8A 3E434F          	   161: 	DC.B	'>CO',('M'+$80)
02:00003F8D CD
02:00003F8E 3E434F          	   162: 	DC.B	'>CO',('N'+$80)
02:00003F91 CE
02:00003F92 3C3E434F        	   163: 	DC.B	'<>CO',('M'+$80)
02:00003F96 CD
02:00003F97 3C3E434F        	   164: 	DC.B	'<>CO',('N'+$80)
02:00003F9B CE
02:00003F9C 4C4953          	   165: 	DC.B	'LIS',('T'+$80)         Direct commands
02:00003F9F D4
02:00003FA0 4C4F41          	   166: 	DC.B	'LOA',('D'+$80)
02:00003FA3 C4
02:00003FA4 4E45            	   167: 	DC.B	'NE',('W'+$80)
02:00003FA6 D7
02:00003FA7 5255            	   168: 	DC.B	'RU',('N'+$80)
02:00003FA9 CE
02:00003FAA 534156          	   169: 	DC.B	'SAV',('E'+$80)
02:00003FAD C5
                            	   170: TAB2
02:00003FAE 4E4558          	   171: 	DC.B	'NEX',('T'+$80)         Direct / statement
02:00003FB1 D4
02:00003FB2 4C45            	   172: 	DC.B	'LE',('T'+$80)
02:00003FB4 D4
02:00003FB5 49              	   173: 	DC.B	'I',('F'+$80)
02:00003FB6 C6
02:00003FB7 474F54          	   174: 	DC.B	'GOT',('O'+$80)
02:00003FBA CF
02:00003FBB 474F5355        	   175: 	DC.B	'GOSU',('B'+$80)
02:00003FBF C2
02:00003FC0 5245545552      	   176: 	DC.B	'RETUR',('N'+$80)
02:00003FC5 CE
02:00003FC6 5245            	   177: 	DC.B	'RE',('M'+$80)
02:00003FC8 CD
02:00003FC9 464F            	   178: 	DC.B	'FO',('R'+$80)
02:00003FCB D2
02:00003FCC 494E5055        	   179: 	DC.B	'INPU',('T'+$80)
02:00003FD0 D4
02:00003FD1 5052494E        	   180: 	DC.B	'PRIN',('T'+$80)
02:00003FD5 D4
02:00003FD6 504F4B          	   181: 	DC.B	'POK',('E'+$80)
02:00003FD9 C5
02:00003FDA 53544F          	   182: 	DC.B	'STO',('P'+$80)
02:00003FDD D0
02:00003FDE 4259            	   183: 	DC.B	'BY',('E'+$80)
02:00003FE0 C5
02:00003FE1 43414C          	   184: 	DC.B	'CAL',('L'+$80)
02:00003FE4 CC
02:00003FE5 4F4E4952        	   185: 	DC.B	'ONIR',('Q'+$80)
02:00003FE9 D1
02:00003FEA 00              	   186: 	DC.B	0
                            	   187: TAB4
02:00003FEB 504545          	   188: 	DC.B	'PEE',('K'+$80)         Functions
02:00003FEE CB
02:00003FEF 524E            	   189: 	DC.B	'RN',('D'+$80)
02:00003FF1 C4
02:00003FF2 4142            	   190: 	DC.B	'AB',('S'+$80)
02:00003FF4 D3
02:00003FF5 53495A          	   191: 	DC.B	'SIZ',('E'+$80)
02:00003FF8 C5
02:00003FF9 544943          	   192: 	DC.B	'TIC',('K'+$80)
02:00003FFC CB
02:00003FFD 434F52454E      	   193: 	DC.B	'COREN',('O'+$80)
02:00004002 CF
02:00004003 00              	   194: 	DC.B	0
                            	   195: TAB5
02:00004004 54              	   196: 	DC.B	'T',('O'+$80)           "TO" in "FOR"
02:00004005 CF
02:00004006 00              	   197: 	DC.B	0
                            	   198: TAB6
02:00004007 535445          	   199: 	DC.B	'STE',('P'+$80)         "STEP" in "FOR"
02:0000400A D0
02:0000400B 00              	   200: 	DC.B	0
                            	   201: TAB8
02:0000400C 3E              	   202: 	DC.B	'>',('='+$80)           Relational operators
02:0000400D BD
02:0000400E 3C              	   203: 	DC.B	'<',('>'+$80)
02:0000400F BE
02:00004010 BE              	   204: 	DC.B	('>'+$80)
02:00004011 BD              	   205: 	DC.B	('='+$80)
02:00004012 3C              	   206: 	DC.B	'<',('='+$80)
02:00004013 BD
02:00004014 BC              	   207: 	DC.B	('<'+$80)
02:00004015 00              	   208: 	DC.B	0
02:00004016 00              	   209: 	DC.B	0	<- for aligning on a word boundary
                            	   210: TAB9
02:00004017 414E            	   211: 	DC.B	'AN',('D'+$80)
02:00004019 C4
02:0000401A 00              	   212: 	DC.B	0
                            	   213: TAB10
02:0000401B 4F              	   214: 	DC.B	'O',('R'+$80)
02:0000401C D2
02:0000401D 00              	   215: 	DC.B	0
02:0000401E 00              	   216: 	DC.B	0
                            	   217: 
                            	   218: ; Execution address tables:
                            	   219: 	align 2
                            	   220: TAB1_1	
02:00004020 00004134        	   221: 	DC.L	INCOM
02:00004024 00004126        	   222: 	DC.L	INCON
02:00004028 0000414C        	   223: 	DC.L	OUTCOM
02:0000402C 00004164        	   224: 	DC.L	OUTCON
02:00004030 00004142        	   225: 	DC.L	IOCOM
02:00004034 0000415A        	   226: 	DC.L	IOCON
02:00004038 00004254        	   227: 	DC.L	LIST			Direct commands
02:0000403C 000044EE        	   228: 	DC.L	LOAD
02:00004040 00004172        	   229: 	DC.L	NEW
02:00004044 00004186        	   230: 	DC.L	RUN
02:00004048 0000454E        	   231: 	DC.L	SAVE
                            	   232: TAB2_1
02:0000404C 000043D6        	   233: 	DC.L	NEXT			Direct / statement
02:00004050 000044DE        	   234: 	DC.L	LET
02:00004054 0000443E        	   235: 	DC.L	IF
02:00004058 00004204        	   236: 	DC.L	GOTO
02:0000405C 000042F6        	   237: 	DC.L	GOSUB
02:00004060 00004332        	   238: 	DC.L	RETURN
02:00004064 0000443C        	   239: 	DC.L	REM
02:00004068 0000435C        	   240: 	DC.L	FOR
02:0000406C 00004468        	   241: 	DC.L	INPUT
02:00004070 00004280        	   242: 	DC.L	PRINT
02:00004074 000045CC        	   243: 	DC.L	POKE
02:00004078 0000417E        	   244: 	DC.L	STOP
02:0000407C 00003E6C        	   245: 	DC.L	GOBYE
02:00004080 00004644        	   246: 	DC.L	CALL
02:00004084 0000421C        	   247: 	DC.L	ONIRQ
02:00004088 000044D8        	   248: 	DC.L	DEFLT
                            	   249: TAB4_1
02:0000408C 0000489A        	   250: 	DC.L	PEEK			Functions
02:00004090 000048EA        	   251: 	DC.L	RND
02:00004094 00004908        	   252: 	DC.L	ABS
02:00004098 00004912        	   253: 	DC.L	SIZE
02:0000409C 00004920        	   254: 	DC.L	TICK
02:000040A0 0000492A        	   255: 	DC.L	CORENO
02:000040A4 000047B6        	   256: 	DC.L	XP40
                            	   257: TAB5_1
02:000040A8 00004376        	   258: 	DC.L	FR1			"TO" in "FOR"
02:000040AC 0000497C        	   259: 	DC.L	QWHAT
                            	   260: TAB6_1
02:000040B0 0000438E        	   261: 	DC.L	FR2			"STEP" in "FOR"
02:000040B4 00004394        	   262: 	DC.L	FR3
                            	   263: TAB8_1
02:000040B8 000046C8        	   264: 	DC.L	XP11	>=		Relational operators
02:000040BC 000046D4        	   265: 	DC.L	XP12	<>
02:000040C0 000046E0        	   266: 	DC.L	XP13	>
02:000040C4 000046F8        	   267: 	DC.L	XP15	=
02:000040C8 000046EC        	   268: 	DC.L	XP14	<=
02:000040CC 00004706        	   269: 	DC.L	XP16	<
02:000040D0 00004724        	   270: 	DC.L	XP17
                            	   271: TAB9_1
02:000040D4 00004698        	   272: 	DC.L	XP_AND
02:000040D8 000046AE        	   273: 	DC.L	XP_ANDX
                            	   274: TAB10_1
02:000040DC 00004670        	   275: 	DC.L	XP_OR
02:000040E0 000046AE        	   276: 	DC.L	XP_ORX
                            	   277: 
                            	   278: 	even
                            	   279: 	
                            	   280: DIRECT
02:000040E4 43FAFE9C        	   281: 	LEA	TAB1,A1
02:000040E8 45FAFF36        	   282: 	LEA	TAB1_1,A2
                            	   283: EXEC
02:000040EC 61000B48        	   284: 	bsr	IGNBLK				; ignore leading blanks
02:000040F0 2648            	   285: 	MOVE.L A0,A3			; save the pointer
02:000040F2 4202            	   286: 	CLR.B	D2					; clear match flag
                            	   287: EXLP
02:000040F4 1018            	   288: 	MOVE.B (A0)+,D0	 	; get the program character
02:000040F6 1211            	   289: 	MOVE.B (A1),D1 		; get the table character
02:000040F8 6604            	   290: 	BNE	EXNGO					; If end of table,
02:000040FA 204B            	   291: 	MOVE.L A3,A0			; restore the text pointer and...
02:000040FC 6024            	   292: 	BRA	EXGO					; execute the default.
                            	   293: EXNGO
02:000040FE 1600            	   294: 	MOVE.B D0,D3		 	; Else check for period...
02:00004100 C602            	   295: 	AND.B	D2,D3				; and a match.
02:00004102 B63C002E        	   296: 	CMP.B	#'.',D3
02:00004106 671A            	   297: 	BEQ	EXGO					; if so, execute
02:00004108 C23C007F        	   298: 	AND.B	#$7F,D1 		; ignore the table's high bit
02:0000410C B200            	   299: 	CMP.B	D0,D1				; is there a match?
02:0000410E 670C            	   300: 	BEQ	EXMAT
02:00004110 588A            	   301: 	ADDQ.L #4,A2			; if not, try the next entry
02:00004112 204B            	   302: 	MOVE.L A3,A0			; reset the program pointer
02:00004114 4202            	   303: 	CLR.B	D2					; sorry, no match
                            	   304: EX1
02:00004116 4A19            	   305: 	TST.B	(A1)+				; get to the end of the entry
02:00004118 6AFC            	   306: 	BPL	EX1
02:0000411A 60D8            	   307: 	BRA	EXLP					; back for more matching
                            	   308: EXMAT
02:0000411C 74FF            	   309: 	MOVEQ	#-1,D2			; we've got a match so far
02:0000411E 4A19            	   310: 	TST.B	(A1)+				; end of table entry?
02:00004120 6AD2            	   311: 	BPL	EXLP					; if not, go back for more
                            	   312: EXGO
02:00004122 2652            	   313: 	MOVE.L (A2),A3		; execute the appropriate routine
02:00004124 4ED3            	   314: 	JMP	(A3)
                            	   315: 
                            	   316: *******************************************************************
                            	   317: * Console redirection
                            	   318: * <COM will redirect input to the COM port
                            	   319: * >COM will redirect output to the COM port
                            	   320: * <CON will redirect input to the console
                            	   321: * >CON will redirect output to the console
                            	   322: * <>COM will redirect input and output to the COM port
                            	   323: * <>CON will redirect input and output to the console
                            	   324: *******************************************************************
                            	   325: INCON
02:00004126 23FC00004CD00000	   326: 	move.l	#INC1,INPPTR
02:0000412E 4D74
02:00004130 600001BC        	   327: 	bra			FINISH
                            	   328: INCOM
02:00004134 23FC00004CF40000	   329: 	move.l	#AUXIN,INPPTR
02:0000413C 4D74
02:0000413E 600001AE        	   330: 	bra			FINISH
                            	   331: IOCOM
02:00004142 23FC00004CF40000	   332: 	move.l	#AUXIN,INPPTR
02:0000414A 4D74
                            	   333: OUTCOM
02:0000414C 23FC00004CE40000	   334: 	move.l	#AUXOUT,OUTPTR
02:00004154 4D78
02:00004156 60000196        	   335: 	bra			FINISH
                            	   336: IOCON
02:0000415A 23FC00004CD00000	   337: 	move.l	#INC1,INPPTR
02:00004162 4D74
                            	   338: OUTCON
02:00004164 23FC00004CB40000	   339: 	move.l	#OUTC1,OUTPTR
02:0000416C 4D78
02:0000416E 6000017E        	   340: 	bra			FINISH
                            	   341: 
                            	   342: *******************************************************************
                            	   343: *
                            	   344: * What follows is the code to execute direct and statement
                            	   345: * commands. Control is transferred to these points via the command
                            	   346: * table lookup code of 'DIRECT' and 'EXEC' in the last section.
                            	   347: * After the command is executed, control is transferred to other
                            	   348: * sections as follows:
                            	   349: *
                            	   350: * For 'LIST', 'NEW', and 'STOP': go back to the warm start point.
                            	   351: * For 'RUN': go execute the first stored line if any; else go
                            	   352: * back to the warm start point.
                            	   353: * For 'GOTO' and 'GOSUB': go execute the target line.
                            	   354: * For 'RETURN' and 'NEXT'; go back to saved return line.
                            	   355: * For all others: if 'CURRNT' is 0, go to warm start; else go
                            	   356: * execute next command. (This is done in 'FINISH'.)
                            	   357: *
                            	   358: *******************************************************************
                            	   359: *
                            	   360: * *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                            	   361: *
                            	   362: * 'NEW<CR>' sets TXTUNF to point to TXTBGN
                            	   363: *
                            	   364: * 'STOP<CR>' goes back to WSTART
                            	   365: *
                            	   366: * 'RUN<CR>' finds the first stored line, stores its address
                            	   367: * in CURRNT, and starts executing it. Note that only those
                            	   368: * commands in TAB2 are legal for a stored program.
                            	   369: *
                            	   370: * There are 3 more entries in 'RUN':
                            	   371: * 'RUNNXL' finds next line, stores it's address and executes it.
                            	   372: * 'RUNTSL' stores the address of this line and executes it.
                            	   373: * 'RUNSML' continues the execution on same line.
                            	   374: *
                            	   375: * 'GOTO expr<CR>' evaluates the expression, finds the target
                            	   376: * line, and jumps to 'RUNTSL' to do it.
                            	   377: *
02:00004172 610007F6        	   378: NEW	bsr	ENDCHK
02:00004176 23FAFCF800004DB4	   379: 	MOVE.L	TXTBGN,TXTUNF	set the end pointer
                            	   380: 
02:0000417E 610007EA        	   381: STOP	bsr	ENDCHK
02:00004182 6000FD42        	   382: 	BRA	WSTART
                            	   383: 
                            	   384: RUN
02:00004186 610007E2        	   385: 	bsr	ENDCHK
02:0000418A 207AFCE4        	   386: 	MOVE.L	TXTBGN,A0	set pointer to beginning
02:0000418E 23C800004D7C    	   387: 	MOVE.L	A0,CURRNT
                            	   388: 
                            	   389: RUNNXL
02:00004194 4AB900004D7C    	   390: 	TST.L	CURRNT		; executing a program?
02:0000419A 6700FD2A        	   391: 	beq	WSTART			; if not, we've finished a direct stat.
02:0000419E 4AB900004DB0    	   392: 	tst.l	IRQROUT		; are we handling IRQ's ?
02:000041A4 6738            	   393: 	beq	RUN1
02:000041A6 4A39000400A0    	   394: 	tst.b IRQFlag		; was there an IRQ ?
02:000041AC 6730            	   395: 	beq	RUN1
02:000041AE 4239000400A0    	   396: 	clr.b IRQFlag
                            	   397: 
                            	   398: 	; same code as GOSUB	
02:000041B4 4FEFFF80        	   399: 	sub.l #128,sp		; allocate storage for local variables
02:000041B8 23CF00004D80    	   400: 	move.l sp,STKFP
02:000041BE 6100092E        	   401: 	bsr	PUSHA				; save the current 'FOR' parameters
02:000041C2 2F08            	   402: 	MOVE.L A0,-(SP)	; save text pointer
02:000041C4 2F3A0BB6        	   403: 	MOVE.L CURRNT,-(SP)	found it, save old 'CURRNT'...
02:000041C8 2F3A0BBA        	   404: 	MOVE.L STKGOS,-(SP)	and 'STKGOS'
02:000041CC 42B900004D8C    	   405: 	CLR.L	LOPVAR		; load new values
02:000041D2 23CF00004D84    	   406: 	MOVE.L SP,STKGOS
                            	   407: 
02:000041D8 227A0BD6        	   408: 	move.l IRQROUT,a1
02:000041DC 600C            	   409: 	bra	RUNTSL
                            	   410: RUN1
02:000041DE 7200            	   411: 	CLR.L	D1			; else find the next line number
02:000041E0 2248            	   412: 	MOVE.L A0,A1
02:000041E2 61000894        	   413: 	bsr	FNDLNP
02:000041E6 6500FCDE        	   414: 	BCS	WSTART		; if we've fallen off the end, stop
                            	   415: 
                            	   416: RUNTSL
02:000041EA 23C900004D7C    	   417: 	MOVE.L	A1,CURRNT	set CURRNT to point to the line no.
02:000041F0 2049            	   418: 	MOVE.L	A1,A0		set the text pointer to
02:000041F2 5488            	   419: 	ADDQ.L	#2,A0		the start of the line text
                            	   420: 
                            	   421: RUNSML
02:000041F4 61000A94        	   422: 	bsr	CHKIO		see if a control-C was pressed
02:000041F8 43FAFDB4        	   423: 	LEA	TAB2,A1 	find command in TAB2
02:000041FC 45FAFE4E        	   424: 	LEA	TAB2_1,A2
02:00004200 6000FEEA        	   425: 	BRA	EXEC		and execute it
                            	   426: 
                            	   427: GOTO	
02:00004204 61000458        	   428: 	bsr	EXPR			; evaluate the following expression
02:00004208 61000760        	   429: 	bsr	ENDCHK		; must find end of line
02:0000420C F2006000        	   430: 	fmove.l fp0,d0
02:00004210 2200            	   431: 	move.l d0,d1
02:00004212 61000856        	   432: 	bsr	FNDLN			; find the target line
02:00004216 660007AC        	   433: 	bne	QHOW			; no such line no.
02:0000421A 60CE            	   434: 	bra	RUNTSL		; go do it
                            	   435: 
                            	   436: ;******************************************************************
                            	   437: ; ONIRQ <line number>
                            	   438: ; ONIRQ sets up an interrupt handler which acts like a specialized
                            	   439: ; subroutine call. ONIRQ is coded like a GOTO that never executes.
                            	   440: ;******************************************************************
                            	   441: 
                            	   442: ONIRQ:
02:0000421C 61000440        	   443: 	bsr	EXPR				; evaluate the following expression
02:00004220 61000748        	   444: 	bsr ENDCHK			; must find end of line
02:00004224 F2006000        	   445: 	fmove.l fp0,d0
02:00004228 2200            	   446: 	move.l d0,d1
02:0000422A 6100083E        	   447: 	bsr FNDLN				; find the target line
02:0000422E 660A            	   448: 	bne	ONIRQ1
02:00004230 42B900004DB0    	   449: 	clr.l IRQROUT
02:00004236 600000B6        	   450: 	bra	FINISH
                            	   451: ONIRQ1:
02:0000423A 23C900004DB0    	   452: 	move.l a1,IRQROUT
02:00004240 600000AC        	   453: 	jmp		FINISH
                            	   454: 
                            	   455: 
                            	   456: WAITIRQ:
02:00004244 61000A44        	   457: 	jsr	CHKIO				; see if a control-C was pressed
02:00004248 4A39000400A0    	   458: 	tst.b IRQFlag
02:0000424E 67F4            	   459: 	beq	WAITIRQ
02:00004250 6000009C        	   460: 	jmp	FINISH
                            	   461: 
                            	   462: *******************************************************************
                            	   463: *
                            	   464: * *** LIST *** PRINT ***
                            	   465: *
                            	   466: * LIST has two forms:
                            	   467: * 'LIST<CR>' lists all saved lines
                            	   468: * 'LIST #<CR>' starts listing at the line #
                            	   469: * Control-S pauses the listing, control-C stops it.
                            	   470: *
                            	   471: * PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                            	   472: * where '....' is a list of expressions, formats, back-arrows,
                            	   473: * and strings.	These items a separated by commas.
                            	   474: *
                            	   475: * A format is a pound sign followed by a number.  It controls
                            	   476: * the number of spaces the value of an expression is going to
                            	   477: * be printed in.  It stays effective for the rest of the print
                            	   478: * command unless changed by another format.  If no format is
                            	   479: * specified, 11 positions will be used.
                            	   480: *
                            	   481: * A string is quoted in a pair of single- or double-quotes.
                            	   482: *
                            	   483: * An underline (back-arrow) means generate a <CR> without a <LF>
                            	   484: *
                            	   485: * A <CR LF> is generated after the entire list has been printed
                            	   486: * or if the list is empty.  If the list ends with a semicolon,
                            	   487: * however, no <CR LF> is generated.
                            	   488: *
                            	   489: 
                            	   490: LIST	
02:00004254 61000998        	   491: 	bsr	TSTNUM		see if there's a line no.
02:00004258 61000710        	   492: 	bsr	ENDCHK		if not, we get a zero
02:0000425C 6100080C        	   493: 	bsr	FNDLN		find this or next line
02:00004260 6500008C        	   494: LS1	BCS	FINISH		warm start if we passed the end
02:00004264 61000952        	   495: 	bsr	PRTLN		print the line
02:00004268 61000A20        	   496: 	bsr	CHKIO		check for listing halt request
02:0000426C 670C            	   497: 	BEQ	LS3
02:0000426E B03C0013        	   498: 	CMP.B	#CTRLS,D0	pause the listing?
02:00004272 6606            	   499: 	BNE	LS3
02:00004274 61000A14        	   500: LS2	bsr	CHKIO		if so, wait for another keypress
02:00004278 67FA            	   501: 	BEQ	LS2
02:0000427A 610007FC        	   502: LS3	bsr	FNDLNP		find the next line
02:0000427E 60E0            	   503: 	BRA	LS1
                            	   504: 
02:00004280 383C000B        	   505: PRINT	MOVE	#11,D4		D4 = number of print spaces
02:00004284 61000950        	   506: 	bsr	TSTC		if null list and ":"
02:00004288 3A              	   507: 	DC.B	':',PR2-*
02:00004289 09
02:0000428A 61000EA2        	   508: 	bsr	CRLF		give CR-LF and continue
02:0000428E 6000FF64        	   509: 	BRA	RUNSML		execution on the same line
02:00004292 61000942        	   510: PR2	bsr	TSTC		if null list and <CR>
02:00004296 0D              	   511: 	DC.B	CR,PR0-*
02:00004297 09
02:00004298 61000E94        	   512: 	bsr	CRLF		also give CR-LF and
02:0000429C 6000FEF6        	   513: 	BRA	RUNNXL		execute the next line
02:000042A0 61000934        	   514: PR0	bsr	TSTC		else is it a format?
02:000042A4 23              	   515: 	DC.B	'#',PR1-*
02:000042A5 0B
02:000042A6 610003B6        	   516: 	bsr	EXPR		yes, evaluate expression
02:000042AA F2046000        	   517: 	FMOVE.L	FP0,D4		and save it as print width
02:000042AE 601A            	   518: 	BRA	PR3		look for more to print
02:000042B0 61000924        	   519: PR1	bsr	TSTC		is character expression? (MRL)
02:000042B4 24              	   520: 	DC.B	'$',PR4-*
02:000042B5 0F
02:000042B6 610003A6        	   521: 	bsr	EXPR		yep. Evaluate expression (MRL)
02:000042BA F2006000        	   522: 	FMOVE.L FP0,D0
02:000042BE 6100FB9C        	   523: 	BSR	GOOUT		print low byte (MRL)
02:000042C2 6006            	   524: 	BRA	PR3		look for more. (MRL)
02:000042C4 6100087A        	   525: PR4	bsr	QTSTG		is it a string?
02:000042C8 6012            	   526: 	BRA.S	PR8		if not, must be an expression
02:000042CA 6100090A        	   527: PR3	bsr	TSTC		if ",", go find next
02:000042CE 2C              	   528: 	DC.B	',',PR6-*
02:000042CF 07
02:000042D0 6100067E        	   529: 	bsr	FIN		in the list.
02:000042D4 60CA            	   530: 	BRA	PR0
02:000042D6 61000E56        	   531: PR6	bsr	CRLF		list ends here
02:000042DA 6012            	   532: 	BRA	FINISH
02:000042DC 3F04            	   533: PR8	MOVE	D4,-(SP)	save the width value
02:000042DE 6100037E        	   534: 	bsr	EXPR		evaluate the expression
02:000042E2 381F            	   535: 	MOVE	(SP)+,D4	restore the width
02:000042E4 F2000080        	   536: 	FMOVE.X FP0,FP1
                            	   537: ;	MOVE.L	D0,D1
02:000042E8 61000890        	   538: 	bsr	PRTNUM		print its value
02:000042EC 60DC            	   539: 	BRA	PR3		more to print?
                            	   540: 
02:000042EE 61000660        	   541: FINISH	bsr	FIN		Check end of command
02:000042F2 60000688        	   542: 	BRA	QWHAT		print "What?" if wrong
                            	   543: 
                            	   544: *
                            	   545: *******************************************************************
                            	   546: *
                            	   547: * *** GOSUB *** & RETURN ***
                            	   548: *
                            	   549: * 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                            	   550: * except that the current text pointer, stack pointer, etc. are
                            	   551: * saved so that execution can be continued after the subroutine
                            	   552: * 'RETURN's.  In order that 'GOSUB' can be nested (and even
                            	   553: * recursive), the save area must be stacked.  The stack pointer
                            	   554: * is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                            	   555: * If we are in the main routine, 'STKGOS' is zero (this was done
                            	   556: * in the initialization section of the interpreter), but we still
                            	   557: * save it as a flag for no further 'RETURN's.
                            	   558: *
                            	   559: * 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                            	   560: * returns the execution to the command after the most recent
                            	   561: * 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                            	   562: * a 'GOSUB' and is thus an error.
                            	   563: *
                            	   564: GOSUB:
02:000042F6 4FEFFF80        	   565: 	sub.l #128,sp		; allocate storage for local variables
02:000042FA 23CF00004D80    	   566: 	move.l sp,STKFP
02:00004300 610007EC        	   567: 	bsr	PUSHA		save the current 'FOR' parameters
02:00004304 61000358        	   568: 	bsr	EXPR		get line number
02:00004308 2F08            	   569: 	MOVE.L	A0,-(SP)	save text pointer
02:0000430A F2006000        	   570: 	FMOVE.L FP0,D0
02:0000430E F2016000        	   571: 	FMOVE.L	FP0,D1
02:00004312 61000756        	   572: 	bsr	FNDLN		find the target line
02:00004316 660006AE        	   573: 	BNE	AHOW		if not there, say "How?"
02:0000431A 2F3A0A60        	   574: 	MOVE.L	CURRNT,-(SP)	found it, save old 'CURRNT'...
02:0000431E 2F3A0A64        	   575: 	MOVE.L	STKGOS,-(SP)	and 'STKGOS'
02:00004322 42B900004D8C    	   576: 	CLR.L	LOPVAR		load new values
02:00004328 23CF00004D84    	   577: 	MOVE.L	SP,STKGOS
02:0000432E 6000FEBA        	   578: 	BRA	RUNTSL
                            	   579: 
                            	   580: RETURN:
02:00004332 61000636        	   581: 	bsr	ENDCHK		there should be just a <CR>
02:00004336 223A0A4C        	   582: 	MOVE.L	STKGOS,D1	get old stack pointer
02:0000433A 67000640        	   583: 	BEQ	QWHAT		if zero, it doesn't exist
02:0000433E 2E41            	   584: 	MOVE.L	D1,SP		else restore it
02:00004340 23DF00004D84    	   585: 	MOVE.L	(SP)+,STKGOS	and the old 'STKGOS'
02:00004346 23DF00004D7C    	   586: 	MOVE.L	(SP)+,CURRNT	and the old 'CURRNT'
02:0000434C 205F            	   587: 	MOVE.L	(SP)+,A0	and the old text pointer
02:0000434E 61000762        	   588: 	bsr	POPA		and the old 'FOR' parameters
02:00004352 2E7A0A2C        	   589: 	move.l STKFP,sp
02:00004356 4FEF0080        	   590: 	add.l #128,sp
02:0000435A 6092            	   591: 	BRA	FINISH		and we are back home
                            	   592: 
                            	   593: *******************************************************************
                            	   594: *
                            	   595: * *** FOR *** & NEXT ***
                            	   596: *
                            	   597: * 'FOR' has two forms:
                            	   598: * 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                            	   599: * The second form means the same thing as the first form with a
                            	   600: * STEP of positive 1.  The interpreter will find the variable 'var'
                            	   601: * and set its value to the current value of 'exp1'.  It also
                            	   602: * evaluates 'exp2' and 'exp1' and saves all these together with
                            	   603: * the text pointer, etc. in the 'FOR' save area, which consisits of
                            	   604: * 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                            	   605: * already something in the save area (indicated by a non-zero
                            	   606: * 'LOPVAR'), then the old save area is saved on the stack before
                            	   607: * the new values are stored.  The interpreter will then dig in the
                            	   608: * stack and find out if this same variable was used in another
                            	   609: * currently active 'FOR' loop.  If that is the case, then the old
                            	   610: * 'FOR' loop is deactivated. (i.e. purged from the stack)
                            	   611: *
                            	   612: * 'NEXT var' serves as the logical (not necessarily physical) end
                            	   613: * of the 'FOR' loop.  The control variable 'var' is checked with
                            	   614: * the 'LOPVAR'.  If they are not the same, the interpreter digs in
                            	   615: * the stack to find the right one and purges all those that didn't
                            	   616: * match.  Either way, it then adds the 'STEP' to that variable and
                            	   617: * checks the result with against the limit value.  If it is within
                            	   618: * the limit, control loops back to the command following the
                            	   619: * 'FOR'.  If it's outside the limit, the save area is purged and
                            	   620: * execution continues.
                            	   621: *
02:0000435C 61000790        	   622: FOR	bsr	PUSHA		save the old 'FOR' save area
02:00004360 610005D2        	   623: 	bsr	SETVAL		set the control variable
02:00004364 23CE00004D8C    	   624: 	MOVE.L	A6,LOPVAR	save its address
02:0000436A 43FAFC98        	   625: 	LEA	TAB5,A1 	use 'EXEC' to test for 'TO'
02:0000436E 45FAFD38        	   626: 	LEA	TAB5_1,A2
02:00004372 6000FD78        	   627: 	BRA	EXEC
                            	   628: FR1	
02:00004376 610002E6        	   629: 	bsr	EXPR		evaluate the limit
02:0000437A F239680000004D9C	   630: 	FMOVE.X	FP0,LOPLMT	save that
02:00004382 43FAFC83        	   631: 	LEA	TAB6,A1 	use 'EXEC' to look for the
02:00004386 45FAFD28        	   632: 	LEA	TAB6_1,A2	word 'STEP'
02:0000438A 6000FD60        	   633: 	BRA	EXEC
                            	   634: FR2
02:0000438E 610002CE        	   635: 	bsr	EXPR		found it, get the step value
02:00004392 6006            	   636: 	BRA	FR4
                            	   637: FR3
                            	   638: ;	MOVEQ	#1,D0		not found, step defaults to 1
02:00004394 F23C58000001    	   639: 	FMOVE.B #1,FP0	; not found, step defaults to 1
                            	   640: FR4
02:0000439A F239680000004D90	   641: 	FMOVE.X	FP0,LOPINC	save that too
                            	   642: FR5	
02:000043A2 23FA09D800004DA8	   643: 	MOVE.L	CURRNT,LOPLN	save address of current line number
02:000043AA 23C800004DAC    	   644: 	MOVE.L	A0,LOPPT	and text pointer
02:000043B0 2C4F            	   645: 	MOVE.L	SP,A6		dig into the stack to find 'LOPVAR'
02:000043B2 6004            	   646: 	BRA	FR7
                            	   647: FR6
02:000043B4 4DEE001A        	   648: 	ADD.L	#26,A6		look at next stack frame
                            	   649: FR7
02:000043B8 2016            	   650: 	MOVE.L	(A6),D0 	is it zero?
02:000043BA 6716            	   651: 	BEQ	FR8		if so, we're done
02:000043BC B0BA09CE        	   652: 	CMP.L	LOPVAR,D0	same as current LOPVAR?
02:000043C0 66F2            	   653: 	BNE	FR6		nope, look some more
02:000043C2 244F            	   654: 	MOVE.L	SP,A2		Else remove 5 long words from...
02:000043C4 224E            	   655: 	MOVE.L	A6,A1		inside the stack.
02:000043C6 47F8001A        	   656: 	LEA	26,A3
02:000043CA D7C9            	   657: 	ADD.L	A1,A3
02:000043CC 610006DC        	   658: 	bsr	MVDOWN
02:000043D0 2E4B            	   659: 	MOVE.L	A3,SP		set the SP 5 long words up
                            	   660: FR8
02:000043D2 6000FF1A        	   661: 	BRA	FINISH		and continue execution
                            	   662: 
                            	   663: NEXT	
02:000043D6 6100040C        	   664: 	bsr	TSTV		get address of variable
02:000043DA 650005A0        	   665: 	BCS	QWHAT		if no variable, say "What?"
02:000043DE 2240            	   666: 	MOVE.L	D0,A1		save variable's address
                            	   667: NX0
02:000043E0 203A09AA        	   668: 	MOVE.L	LOPVAR,D0	If 'LOPVAR' is zero, we never...
02:000043E4 67000596        	   669: 	BEQ	QWHAT		had a FOR loop, so say "What?"
02:000043E8 B3C0            	   670: 	CMP.L	D0,A1		else we check them
02:000043EA 6706            	   671: 	BEQ	NX3		OK, they agree
02:000043EC 610006C4        	   672: 	bsr	POPA		nope, let's see the next frame
02:000043F0 60EE            	   673: 	BRA	NX0
                            	   674: NX3	
02:000043F2 F2114800        	   675: 	FMOVE.X	(A1),FP0 	get control variable's value
02:000043F6 F23A50220996    	   676: 	FADD	LOPINC,FP0	add in loop increment
                            	   677: ;	BVS	QHOW		say "How?" for 32-bit overflow
02:000043FC F2116800        	   678: 	FMOVE.X	FP0,(A1) 	save control variable's new value
02:00004400 F23A48800998    	   679: 	FMOVE.X	LOPLMT,FP1	get loop's limit value
02:00004406 F23A503A0986    	   680: 	FTST LOPINC
02:0000440C F293000E        	   681: 	FBGE NX1				; branch if loop increment is positive
02:00004410 F2276800        	   682: 	FMOVE.X FP0,-(a7)	; exchange FP0,FP1
02:00004414 F2000400        	   683: 	FMOVE.X FP1,FP0
02:00004418 F21F4880        	   684: 	FMOVE.X (a7)+,FP1
                            	   685: NX1	
02:0000441C F20000B8        	   686: 	FCMP FP0,FP1		;	test against limit
02:00004420 F2940012        	   687: 	FBLT NX2				; branch if outside limit
02:00004424 23FA098200004D7C	   688: 	MOVE.L LOPLN,CURRNT	Within limit, go back to the...
02:0000442C 207A097E        	   689: 	MOVE.L LOPPT,A0	saved 'CURRNT' and text pointer.
02:00004430 6000FEBC        	   690: 	BRA	FINISH
                            	   691: NX2
02:00004434 6100067C        	   692: 	bsr	POPA		purge this loop
02:00004438 6000FEB4        	   693: 	BRA	FINISH
                            	   694: 
                            	   695: *
                            	   696: *******************************************************************
                            	   697: *
                            	   698: * *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                            	   699: *
                            	   700: * 'REM' can be followed by anything and is ignored by the
                            	   701: * interpreter.
                            	   702: *
                            	   703: * 'IF' is followed by an expression, as a condition and one or
                            	   704: * more commands (including other 'IF's) separated by colons.
                            	   705: * Note that the word 'THEN' is not used.  The interpreter evaluates
                            	   706: * the expression.  If it is non-zero, execution continues.  If it
                            	   707: * is zero, the commands that follow are ignored and execution
                            	   708: * continues on the next line.
                            	   709: *
                            	   710: * 'INPUT' is like the 'PRINT' command, and is followed by a list
                            	   711: * of items.  If the item is a string in single or double quotes,
                            	   712: * or is an underline (back arrow), it has the same effect as in
                            	   713: * 'PRINT'.  If an item is a variable, this variable name is
                            	   714: * printed out followed by a colon, then the interpreter waits for
                            	   715: * an expression to be typed in.  The variable is then set to the
                            	   716: * value of this expression.  If the variable is preceeded by a
                            	   717: * string (again in single or double quotes), the string will be
                            	   718: * displayed followed by a colon.  The interpreter the waits for an
                            	   719: * expression to be entered and sets the variable equal to the
                            	   720: * expression's value.  If the input expression is invalid, the
                            	   721: * interpreter will print "What?", "How?", or "Sorry" and reprint
                            	   722: * the prompt and redo the input.  The execution will not terminate
                            	   723: * unless you press control-C.  This is handled in 'INPERR'.
                            	   724: *
                            	   725: * 'LET' is followed by a list of items separated by commas.
                            	   726: * Each item consists of a variable, an equals sign, and an
                            	   727: * expression.  The interpreter evaluates the expression and sets
                            	   728: * the variable to that value.  The interpreter will also handle
                            	   729: * 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                            	   730: *
02:0000443C 600C            	   731: REM	BRA	IF2		skip the rest of the line
                            	   732: 
02:0000443E 6100021E        	   733: IF	bsr	EXPR		evaluate the expression
02:00004442 F200003A        	   734: IF1	FTST	FP0		is it zero?
02:00004446 F28EFDAC        	   735: 	FBNE	RUNSML		if not, continue
02:0000444A 2248            	   736: IF2	MOVE.L	A0,A1
02:0000444C 7200            	   737: 	CLR.L	D1
02:0000444E 61000642        	   738: 	bsr	FNDSKP		if so, skip the rest of the line
02:00004452 6400FD96        	   739: 	BCC	RUNTSL		and run the next line
02:00004456 6000FA6E        	   740: 	BRA	WSTART		if no next line, do a warm start
                            	   741: 
02:0000445A 2E7A092C        	   742: INPERR	MOVE.L	STKINP,SP	restore the old stack pointer
02:0000445E 23DF00004D7C    	   743: 	MOVE.L	(SP)+,CURRNT	and old 'CURRNT'
02:00004464 588F            	   744: 	ADDQ.L	#4,SP
02:00004466 205F            	   745: 	MOVE.L	(SP)+,A0	and old text pointer
                            	   746: 
02:00004468 2F08            	   747: INPUT	MOVE.L	A0,-(SP)	save in case of error
02:0000446A 610006D4        	   748: 	bsr	QTSTG		is next item a string?
02:0000446E 600A            	   749: 	BRA.S	IP2		nope
02:00004470 61000372        	   750: 	bsr	TSTV		yes, but is it followed by a variable?
02:00004474 6554            	   751: 	BCS	IP4		if not, branch
02:00004476 2440            	   752: 	MOVE.L	D0,A2		put away the variable's address
02:00004478 601A            	   753: 	BRA	IP3		if so, input to variable
02:0000447A 2F08            	   754: IP2	MOVE.L	A0,-(SP)	save for 'PRTSTG'
02:0000447C 61000366        	   755: 	bsr	TSTV		must be a variable now
02:00004480 650004FA        	   756: 	BCS	QWHAT		"What?" it isn't?
02:00004484 2440            	   757: 	MOVE.L	D0,A2		put away the variable's address
02:00004486 1410            	   758: 	MOVE.B	(A0),D2 	get ready for 'PRTSTG'
02:00004488 4200            	   759: 	CLR.B	D0
02:0000448A 1080            	   760: 	MOVE.B	D0,(A0)
02:0000448C 225F            	   761: 	MOVE.L	(SP)+,A1
02:0000448E 61000694        	   762: 	bsr	PRTSTG		print string as prompt
02:00004492 1082            	   763: 	MOVE.B	D2,(A0) 	restore text
02:00004494 2F08            	   764: IP3	MOVE.L	A0,-(SP)	save in case of error
02:00004496 2F3A08E4        	   765: 	MOVE.L	CURRNT,-(SP)	also save 'CURRNT'
02:0000449A 23FCFFFFFFFF0000	   766: 	MOVE.L	#-1,CURRNT	flag that we are in INPUT
02:000044A2 4D7C
02:000044A4 23CF00004D88    	   767: 	MOVE.L	SP,STKINP	save the stack pointer too
02:000044AA 2F0A            	   768: 	MOVE.L	A2,-(SP)	save the variable address
02:000044AC 103C003A        	   769: 	MOVE.B	#':',D0         print a colon first
02:000044B0 6100051A        	   770: 	bsr	GETLN		then get an input line
02:000044B4 41FA090A        	   771: 	LEA	BUFFER,A0	point to the buffer
02:000044B8 610001A4        	   772: 	bsr	EXPR		evaluate the input
02:000044BC 245F            	   773: 	MOVE.L	(SP)+,A2	restore the variable address
02:000044BE F2126800        	   774: 	FMOVE.X	FP0,(A2) 	save value in variable
02:000044C2 23DF00004D7C    	   775: 	MOVE.L	(SP)+,CURRNT	restore old 'CURRNT'
02:000044C8 205F            	   776: 	MOVE.L	(SP)+,A0	and the old text pointer
02:000044CA 588F            	   777: IP4	ADDQ.L	#4,SP		clean up the stack
02:000044CC 61000708        	   778: 	bsr	TSTC		is the next thing a comma?
02:000044D0 2C              	   779: 	DC.B	',',IP5-*
02:000044D1 03
02:000044D2 6094            	   780: 	BRA	INPUT		yes, more items
02:000044D4 6000FE18        	   781: IP5	BRA	FINISH
                            	   782: 
                            	   783: DEFLT
02:000044D8 0C10000D        	   784: 	CMP.B	#CR,(A0)	empty line is OK
02:000044DC 670C            	   785: 	BEQ	LT1		else it is 'LET'
                            	   786: 
                            	   787: LET
02:000044DE 61000454        	   788: 	bsr	SETVAL		 	; do the assignment
02:000044E2 610006F2        	   789: 	bsr	TSTC				; check for more 'LET' items
02:000044E6 2C              	   790: 	DC.B	',',LT1-*
02:000044E7 03
02:000044E8 60F4            	   791: 	BRA	LET
                            	   792: LT1
02:000044EA 6000FE02        	   793: 	BRA	FINISH			; until we are finished.
                            	   794: 
                            	   795: 
                            	   796: *******************************************************************
                            	   797: *
                            	   798: * *** LOAD *** & SAVE ***
                            	   799: *
                            	   800: * These two commands transfer a program to/from an auxiliary
                            	   801: * device such as a cassette, another computer, etc.  The program
                            	   802: * is converted to an easily-stored format: each line starts with
                            	   803: * a colon, the line no. as 4 hex digits, and the rest of the line.
                            	   804: * At the end, a line starting with an '@' sign is sent.  This
                            	   805: * format can be read back with a minimum of processing time by
                            	   806: * the 68000.
                            	   807: *
                            	   808: LOAD	
02:000044EE 207AF980        	   809: 	MOVE.L TXTBGN,A0	set pointer to start of prog. area
02:000044F2 103C000D        	   810: 	MOVE.B #CR,D0		For a CP/M host, tell it we're ready...
02:000044F6 6100F96C        	   811: 	BSR	GOAUXO		by sending a CR to finish PIP command.
                            	   812: LOD1	
02:000044FA 6100F96C        	   813: 	BSR	GOAUXI		look for start of line
02:000044FE 67FA            	   814: 	BEQ	LOD1
02:00004500 B03C0040        	   815: 	CMP.B	#'@',D0         end of program?
02:00004504 671E            	   816: 	BEQ	LODEND
02:00004506 B03C003A        	   817: 	CMP.B	#':',D0         if not, is it start of line?
02:0000450A 66EE            	   818: 	BNE	LOD1		if not, wait for it
02:0000450C 6120            	   819: 	BSR	GBYTE		get first byte of line no.
02:0000450E 10C1            	   820: 	MOVE.B	D1,(A0)+	store it
02:00004510 611C            	   821: 	BSR	GBYTE		get 2nd bye of line no.
02:00004512 10C1            	   822: 	MOVE.B	D1,(A0)+	store that, too
                            	   823: LOD2
02:00004514 6100F952        	   824: 	BSR	GOAUXI		get another text char.
02:00004518 67FA            	   825: 	BEQ	LOD2
02:0000451A 10C0            	   826: 	MOVE.B	D0,(A0)+	store it
02:0000451C B03C000D        	   827: 	CMP.B	#CR,D0		is it the end of the line?
02:00004520 66F2            	   828: 	BNE	LOD2		if not, go back for more
02:00004522 60D6            	   829: 	BRA	LOD1		if so, start a new line
                            	   830: LODEND
02:00004524 23C800004DB4    	   831: 	MOVE.L	A0,TXTUNF	set end-of program pointer
02:0000452A 6000F99A        	   832: 	BRA	WSTART		back to direct mode
                            	   833: 
                            	   834: GBYTE
02:0000452E 7401            	   835: 	MOVEQ	#1,D2		get two hex characters from auxiliary
02:00004530 7200            	   836: 	CLR.L	D1		and store them as a byte in D1
                            	   837: GBYTE1	
02:00004532 6100F934        	   838: 	BSR	GOAUXI		get a char.
02:00004536 67FA            	   839: 	BEQ	GBYTE1
02:00004538 B03C0041        	   840: 	CMP.B	#'A',D0
02:0000453C 6502            	   841: 	BCS	GBYTE2
02:0000453E 5F00            	   842: 	SUBQ.B	#7,D0		if greater than 9, adjust
                            	   843: GBYTE2
02:00004540 C03C000F        	   844: 	AND.B	#$F,D0		strip ASCII
02:00004544 E909            	   845: 	LSL.B	#4,D1		put nybble into the result
02:00004546 8200            	   846: 	OR.B	D0,D1
02:00004548 51CAFFE8        	   847: 	DBRA	D2,GBYTE1	get another char.
02:0000454C 4E75            	   848: 	RTS
                            	   849: 
                            	   850: SAVE
02:0000454E 207AF920        	   851: 	MOVE.L	TXTBGN,A0	set pointer to start of prog. area
02:00004552 227A0860        	   852: 	MOVE.L	TXTUNF,A1	set pointer to end of prog. area
                            	   853: SAVE1	
02:00004556 103C000D        	   854: 	MOVE.B	#CR,D0		send out a CR & LF (CP/M likes this)
02:0000455A 6100F908        	   855: 	BSR	GOAUXO
02:0000455E 103C000A        	   856: 	MOVE.B	#LF,D0
02:00004562 6100F900        	   857: 	BSR	GOAUXO
02:00004566 B3C8            	   858: 	CMP.L	A0,A1		are we finished?
02:00004568 631E            	   859: 	BLS	SAVEND
02:0000456A 103C003A        	   860: 	MOVE.B	#':',D0         if not, start a line
02:0000456E 6100F8F4        	   861: 	BSR	GOAUXO
02:00004572 1218            	   862: 	MOVE.B	(A0)+,D1	send first half of line no.
02:00004574 6136            	   863: 	BSR	PBYTE
02:00004576 1218            	   864: 	MOVE.B	(A0)+,D1	and send 2nd half
02:00004578 6132            	   865: 	BSR	PBYTE
                            	   866: SAVE2
02:0000457A 1018            	   867: 	MOVE.B	(A0)+,D0	get a text char.
02:0000457C B03C000D        	   868: 	CMP.B	#CR,D0		is it the end of the line?
02:00004580 67D4            	   869: 	BEQ	SAVE1		if so, send CR & LF and start new line
02:00004582 6100F8E0        	   870: 	BSR	GOAUXO		send it out
02:00004586 60F2            	   871: 	BRA	SAVE2		go back for more text
                            	   872: SAVEND
02:00004588 103C0040        	   873: 	MOVE.B	#'@',D0         send end-of-program indicator
02:0000458C 6100F8D6        	   874: 	BSR	GOAUXO
02:00004590 103C000D        	   875: 	MOVE.B	#CR,D0		followed by a CR & LF
02:00004594 6100F8CE        	   876: 	BSR	GOAUXO
02:00004598 103C000A        	   877: 	MOVE.B	#LF,D0
02:0000459C 6100F8C6        	   878: 	BSR	GOAUXO
02:000045A0 103C001A        	   879: 	MOVE.B	#$1A,D0 	and a control-Z to end the CP/M file
02:000045A4 6100F8BE        	   880: 	BSR	GOAUXO
02:000045A8 6000F91C        	   881: 	BRA	WSTART		then go do a warm start
                            	   882: 
02:000045AC 7401            	   883: PBYTE	MOVEQ	#1,D2		send two hex characters from D1's low byte
02:000045AE E919            	   884: PBYTE1	ROL.B	#4,D1		get the next nybble
02:000045B0 1001            	   885: 	MOVE.B	D1,D0
02:000045B2 C03C000F        	   886: 	AND.B	#$F,D0		strip off garbage
02:000045B6 D03C0030        	   887: 	ADD.B	#'0',D0         make it into ASCII
02:000045BA B03C0039        	   888: 	CMP.B	#'9',D0
02:000045BE 6302            	   889: 	BLS	PBYTE2
02:000045C0 5E00            	   890: 	ADDQ.B	#7,D0		adjust if greater than 9
02:000045C2 6100F8A0        	   891: PBYTE2	BSR	GOAUXO		send it out
02:000045C6 51CAFFE6        	   892: 	DBRA	D2,PBYTE1	then send the next nybble
02:000045CA 4E75            	   893: 	RTS
                            	   894: 
                            	   895: *
                            	   896: *******************************************************************
                            	   897: *
                            	   898: * *** POKE *** & CALL ***
                            	   899: *
                            	   900: * 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                            	   901: * address specified by 'expr1'.
                            	   902: *
                            	   903: * 'CALL expr' jumps to the machine language subroutine whose
                            	   904: * starting address is specified by 'expr'.  The subroutine can use
                            	   905: * all registers but must leave the stack the way it found it.
                            	   906: * The subroutine returns to the interpreter by executing an RTS.
                            	   907: *
                            	   908: POKE
02:000045CC 1E3C0042        	   909: 	move.b #'B',d7
02:000045D0 1210            	   910: 	move.b (a0),d1
02:000045D2 0C01002E        	   911: 	cmpi.b #'.',d1
02:000045D6 6620            	   912: 	bne .0001
02:000045D8 5248            	   913: 	addq #1,a0
02:000045DA 1210            	   914: 	move.b (a0),d1
02:000045DC 0C010042        	   915: 	cmpi.b #'B',d1
02:000045E0 6712            	   916: 	beq .0002
02:000045E2 0C010057        	   917: 	cmpi.b #'W',d1
02:000045E6 670C            	   918: 	beq .0002
02:000045E8 0C01004C        	   919: 	cmpi.b #'L',d1
02:000045EC 6706            	   920: 	beq .0002
02:000045EE 0C010046        	   921: 	cmpi.b #'F',d1
02:000045F2 664C            	   922: 	bne	PKER
                            	   923: .0002
02:000045F4 5248            	   924: 	addq #1,a0
02:000045F6 1E01            	   925: 	move.b d1,d7
                            	   926: .0001
02:000045F8 6164            	   927: 	BSR	EXPR		get the memory address
02:000045FA 610005DA        	   928: 	bsr	TSTC		it must be followed by a comma
02:000045FE 2C              	   929: 	DC.B	',',PKER-*
02:000045FF 41
02:00004600 F2276000        	   930: 	FMOVE.L	FP0,-(SP)	save the address
02:00004604 6158            	   931: 	BSR	EXPR		get the byte to be POKE'd
02:00004606 225F            	   932: 	MOVE.L	(SP)+,A1	get the address back
02:00004608 0C070042        	   933: 	CMPI.B #'B',D7
02:0000460C 6608            	   934: 	BNE .0003
02:0000460E F2117800        	   935: 	FMOVE.B	FP0,(A1) 	store the byte in memory
02:00004612 6000FCDA        	   936: 	BRA	FINISH
                            	   937: .0003
02:00004616 0C070057        	   938: 	CMPI.B #'W',d7
02:0000461A 6608            	   939: 	BNE .0004
02:0000461C F2117000        	   940: 	FMOVE.W FP0,(A1)
02:00004620 6000FCCC        	   941: 	BRA FINISH
                            	   942: .0004
02:00004624 0C07004C        	   943: 	CMPI.B #'L',D7
02:00004628 6608            	   944: 	BNE .0005
02:0000462A F2116000        	   945: 	FMOVE.L FP0,(A1)
02:0000462E 6000FCBE        	   946: 	BRA FINISH
                            	   947: .0005
02:00004632 0C070046        	   948: 	CMPI.B #'F',D7
02:00004636 6608            	   949: 	BNE .0006
02:00004638 F2116800        	   950: 	FMOVE.X FP0,(A1)
02:0000463C 6000FCB0        	   951: 	BRA FINISH
                            	   952: .0006
02:00004640 6000033A        	   953: PKER	BRA	QWHAT		if no comma, say "What?"
                            	   954: 
                            	   955: CALL	
02:00004644 6118            	   956: 	BSR	EXPR		get the subroutine's address
02:00004646 F200003A        	   957: 	FTST FP0			; make sure we got a valid address
02:0000464A 67000378        	   958: 	BEQ	QHOW		if not, say "How?"
02:0000464E 2F08            	   959: 	MOVE.L	A0,-(SP)	save the text pointer
02:00004650 F2006000        	   960: 	FMOVE.L	FP0,D0
02:00004654 2240            	   961: 	MOVE.L D0,A1
02:00004656 4E91            	   962: 	JSR	(A1)		jump to the subroutine
02:00004658 205F            	   963: 	MOVE.L	(SP)+,A0	restore the text pointer
02:0000465A 6000FC92        	   964: 	BRA	FINISH
                            	   965: 
                            	   966: *******************************************************************
                            	   967: *
                            	   968: * *** EXPR ***
                            	   969: *
                            	   970: * 'EXPR' evaluates arithmetical or logical expressions.
                            	   971: * <EXPR>::=<EXPR2>
                            	   972: *	   <EXPR2><rel.op.><EXPR2>
                            	   973: * where <rel.op.> is one of the operators in TAB8 and the result
                            	   974: * of these operations is 1 if true and 0 if false.
                            	   975: * <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                            	   976: * where () are optional and (... are optional repeats.
                            	   977: * <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                            	   978: * <EXPR4>::=<variable>
                            	   979: *	    <function>
                            	   980: *	    (<EXPR>)
                            	   981: * <EXPR> is recursive so that the variable '@' can have an <EXPR>
                            	   982: * as an index, functions can have an <EXPR> as arguments, and
                            	   983: * <EXPR4> can be an <EXPR> in parenthesis.
                            	   984: 
                            	   985: EXPR
                            	   986: EXPR_OR
02:0000465E 6126            	   987: 	BSR EXPR_AND
02:00004660 F2276800        	   988: 	FMOVE.X FP0,-(SP)
02:00004664 43FAF9B5        	   989: 	LEA TAB10,A1
02:00004668 45FAFA72        	   990: 	LEA TAB10_1,A2
02:0000466C 6000FA7E        	   991: 	BRA EXEC
                            	   992: 	
                            	   993: XP_OR
02:00004670 6114            	   994: 	BSR EXPR_AND
02:00004672 F21F4880        	   995: 	FMOVE.X (SP)+,FP1
02:00004676 F2016080        	   996: 	FMOVE.L FP1,D1
02:0000467A F2006000        	   997: 	FMOVE.L FP0,D0
02:0000467E 8081            	   998: 	OR.L D1,D0
02:00004680 F2004000        	   999: 	FMOVE.L D0,FP0
02:00004684 4E75            	  1000: 	RTS
                            	  1001: 	
                            	  1002: EXPR_AND
02:00004686 612C            	  1003: 	BSR EXPR_REL
02:00004688 F2276800        	  1004: 	FMOVE.X FP0,-(SP)
02:0000468C 43FAF989        	  1005: 	LEA TAB9,A1
02:00004690 45FAFA42        	  1006: 	LEA TAB9_1,A2
02:00004694 6000FA56        	  1007: 	BRA EXEC
                            	  1008: 
                            	  1009: XP_AND
02:00004698 611A            	  1010: 	BSR EXPR_REL
02:0000469A F21F4880        	  1011: 	FMOVE.X (SP)+,FP1
02:0000469E F2016080        	  1012: 	FMOVE.L FP1,D1
02:000046A2 F2006000        	  1013: 	FMOVE.L FP0,D0
02:000046A6 C081            	  1014: 	AND.L D1,D0
02:000046A8 F2004000        	  1015: 	FMOVE.L D0,FP0
02:000046AC 4E75            	  1016: 	RTS
                            	  1017: 	
                            	  1018: XP_ANDX
                            	  1019: XP_ORX
02:000046AE F21F4800        	  1020: 	FMOVE.X (SP)+,FP0
02:000046B2 4E75            	  1021: 	RTS
                            	  1022: 
                            	  1023: EXPR_REL
02:000046B4 61000084        	  1024: 	BSR	EXPR2
02:000046B8 F2276800        	  1025: 	FMOVE.X	FP0,-(SP)		; save <EXPR2> value
02:000046BC 43FAF94E        	  1026: 	LEA	TAB8,A1 				; look up a relational operator
02:000046C0 45FAF9F6        	  1027: 	LEA	TAB8_1,A2
02:000046C4 6000FA26        	  1028: 	BRA	EXEC		go do it
                            	  1029: 
                            	  1030: XP11
02:000046C8 F21F4800        	  1031: 	FMOVE.X (SP)+,FP0	
02:000046CC 615C            	  1032: 	BSR	XP18		is it ">="?
02:000046CE F2940044        	  1033: 	FBLT XPRT0		no, return D0=0
02:000046D2 6048            	  1034: 	BRA	XPRT1		else return D0=1
                            	  1035: 
                            	  1036: XP12
02:000046D4 F21F4800        	  1037: 	FMOVE.X (SP)+,FP0	
02:000046D8 6150            	  1038: 	BSR	XP18		is it "<>"?
02:000046DA F2810038        	  1039: 	FBEQ XPRT0		no, return D0=0
02:000046DE 603C            	  1040: 	BRA	XPRT1		else return D0=1
                            	  1041: 
                            	  1042: XP13
02:000046E0 F21F4800        	  1043: 	FMOVE.X (SP)+,FP0	
02:000046E4 6144            	  1044: 	BSR	XP18		is it ">"?
02:000046E6 F295002C        	  1045: 	FBLE XPRT0		no, return D0=0
02:000046EA 6030            	  1046: 	BRA	XPRT1		else return D0=1
                            	  1047: 
                            	  1048: XP14
02:000046EC F21F4800        	  1049: 	FMOVE.X (SP)+,FP0	
02:000046F0 6138            	  1050: 	BSR	XP18		is it "<="?
02:000046F2 F2920020        	  1051: 	FBGT XPRT0		no, return D0=0
02:000046F6 6024            	  1052: 	BRA	XPRT1		else return D0=1
                            	  1053: 
                            	  1054: XP15
02:000046F8 F21F4800        	  1055: 	FMOVE.X (SP)+,FP0	
02:000046FC 612C            	  1056: 	BSR	XP18		is it "="?
02:000046FE F28E0014        	  1057: 	FBNE XPRT0		if not, return D0=0
02:00004702 6018            	  1058: 	BRA	XPRT1		else return D0=1
                            	  1059: XP15RT
02:00004704 4E75            	  1060: 	RTS
                            	  1061: 
                            	  1062: XP16
02:00004706 F21F4800        	  1063: 	FMOVE.X (SP)+,FP0	
02:0000470A 611E            	  1064: 	BSR	XP18		is it "<"?
02:0000470C F2930006        	  1065: 	FBGE XPRT0		if not, return D0=0
02:00004710 600A            	  1066: 	BRA	XPRT1		else return D0=1
                            	  1067: XP16RT
02:00004712 4E75            	  1068: 	RTS
                            	  1069: 
                            	  1070: XPRT0
02:00004714 F23C58000000    	  1071: 	FMOVE.B #0,FP0	; return fp0 = 0 (false)
02:0000471A 4E75            	  1072: 	RTS
                            	  1073: 
                            	  1074: XPRT1	
02:0000471C F23C58000001    	  1075: 	FMOVE.B #1,FP0	; return fp0 = 1 (true)
02:00004722 4E75            	  1076: 	RTS
                            	  1077: 
                            	  1078: XP17								; it's not a rel. operator
02:00004724 F21F4800        	  1079: 	FMOVE.X (SP)+,FP0
02:00004728 4E75            	  1080: 	RTS								;		return FP0=<EXPR2>
                            	  1081: 
                            	  1082: XP18
02:0000472A F2276800        	  1083: 	FMOVE.X	FP0,-(SP)	; save <EXPR2> value
02:0000472E 610A            	  1084: 	BSR	EXPR2					; do second <EXPR2>
02:00004730 F21F4880        	  1085: 	FMOVE.X (SP)+,FP1	; get stacked value
02:00004734 F20000B8        	  1086: 	FCMP FP0,FP1			; compare with the first result
02:00004738 4E75            	  1087: 	RTS								; return the result
                            	  1088: 
                            	  1089: EXPR2
02:0000473A 6100049A        	  1090: 	bsr	TSTC		; negative sign?
02:0000473E 2D              	  1091: 	DC.B	'-',XP21-*
02:0000473F 09
02:00004740 F23C58000000    	  1092: 	FMOVE.B #0,FP0
02:00004746 6024            	  1093: 	BRA	XP26
                            	  1094: XP21	
02:00004748 6100048C        	  1095: 	bsr	TSTC		; positive sign? ignore it
02:0000474C 2B              	  1096: 	DC.B	'+',XP22-*
02:0000474D 01
                            	  1097: XP22
02:0000474E 6128            	  1098: 	BSR	EXPR3		; first <EXPR3>
                            	  1099: XP23
02:00004750 61000484        	  1100: 	bsr	TSTC		; add?
02:00004754 2B              	  1101: 	DC.B	'+',XP25-*
02:00004755 11
02:00004756 F2276800        	  1102: 	FMOVE.X FP0,-(SP)	; yes, save the value
02:0000475A 611C            	  1103: 	BSR	EXPR3					; get the second <EXPR3>
                            	  1104: XP24
02:0000475C F21F4880        	  1105: 	FMOVE.X (SP)+,FP1
02:00004760 F2000422        	  1106: 	FADD FP1,FP0			; add it to the first <EXPR3>
                            	  1107: ;	FBVS	QHOW		branch if there's an overflow
02:00004764 60EA            	  1108: 	BRA	XP23		else go back for more operations
                            	  1109: XP25
02:00004766 6100046E        	  1110: 	bsr	TSTC		subtract?
02:0000476A 2D              	  1111: 	DC.B	'-',XP42-*
02:0000476B 73
                            	  1112: XP26
02:0000476C F2276800        	  1113: 	FMOVE.X	FP0,-(SP)	; yes, save the result of 1st <EXPR3>
02:00004770 6106            	  1114: 	BSR	EXPR3					; get second <EXPR3>
02:00004772 F200001A        	  1115: 	FNEG FP0					; change its sign
02:00004776 60E4            	  1116: 	JMP	XP24					; and do an addition
                            	  1117: 
                            	  1118: EXPR3
02:00004778 6130            	  1119: 	BSR	EXPR4					; get first <EXPR4>
                            	  1120: XP31
02:0000477A 6100045A        	  1121: 	bsr	TSTC					; multiply?
02:0000477E 2A              	  1122: 	DC.B	'*',XP34-*
02:0000477F 11
02:00004780 F2276800        	  1123: 	FMOVE.X FP0,-(SP)	; yes, save that first result
02:00004784 6124            	  1124: 	BSR	EXPR4					; get second <EXPR4>
02:00004786 F21F4880        	  1125: 	FMOVE.X (SP)+,FP1
02:0000478A F2000423        	  1126: 	FMUL FP1,FP0			; multiply the two
02:0000478E 60EA            	  1127: 	BRA	XP31					; then look for more terms
                            	  1128: XP34
02:00004790 61000444        	  1129: 	bsr	TSTC		divide?
02:00004794 2F              	  1130: 	DC.B	'/',XP42-*
02:00004795 49
02:00004796 F2276800        	  1131: 	FMOVE.X FP0,-(SP)	; save result of 1st <EXPR4>
02:0000479A 610E            	  1132: 	BSR	EXPR4					; get second <EXPR4>
02:0000479C F2000080        	  1133: 	FMOVE.X FP0,FP1
02:000047A0 F21F4800        	  1134: 	FMOVE.X (SP)+,FP0
02:000047A4 F2000420        	  1135: 	FDIV FP1,FP0			; do the division
02:000047A8 60D0            	  1136: 	BRA	XP31					; go back for any more terms
                            	  1137: 
                            	  1138: EXPR4
02:000047AA 43FAF83F        	  1139: 	LEA	TAB4,A1 			; find possible function
02:000047AE 45FAF8DC        	  1140: 	LEA	TAB4_1,A2
02:000047B2 6000F938        	  1141: 	BRA	EXEC
                            	  1142: XP40
02:000047B6 612C            	  1143: 	BSR	TSTV					; nope, not a function
02:000047B8 6508            	  1144: 	BCS	XP41					; nor a variable
02:000047BA 2240            	  1145: 	MOVE.L	D0,A1			; A1 = variable address
02:000047BC F2114800        	  1146: 	FMOVE.X (A1),FP0	; if a variable, return its value in FP0
                            	  1147: EXP4RT
02:000047C0 4E75            	  1148: 	RTS
                            	  1149: XP41
02:000047C2 6100042A        	  1150: 	bsr	TSTNUM				; or is it a number?
02:000047C6 F2000400        	  1151: 	FMOVE.X FP1,FP0
02:000047CA 4A42            	  1152: 	TST.w	D2					; (if not, # of digits will be zero)
02:000047CC 66F2            	  1153: 	BNE	EXP4RT				; if so, return it in FP0
                            	  1154: PARN
02:000047CE 61000406        	  1155: 	bsr	TSTC					; else look for ( EXPR )
02:000047D2 28              	  1156: 	DC.B	'(',XP43-*
02:000047D3 0D
02:000047D4 6100FE88        	  1157: 	BSR	EXPR
02:000047D8 610003FC        	  1158: 	bsr	TSTC
02:000047DC 29              	  1159: 	DC.B	')',XP43-*
02:000047DD 03
                            	  1160: XP42	
02:000047DE 4E75            	  1161: 	RTS
                            	  1162: XP43
02:000047E0 6000019A        	  1163: 	BRA	QWHAT					; else say "What?"
                            	  1164: 
                            	  1165: 
                            	  1166: ; ===== Test for a valid variable name.  Returns Carry=1 if not
                            	  1167: ;	found, else returns Carry=0 and the address of the
                            	  1168: ;	variable in D0.
                            	  1169: 
                            	  1170: TSTV:
02:000047E4 61000450        	  1171: 	bsr	IGNBLK
02:000047E8 7000            	  1172: 	CLR.L	D0
02:000047EA 1010            	  1173: 	MOVE.B (A0),D0 	 	; look at the program text
02:000047EC 903C0040        	  1174: 	SUB.B	#'@',D0
02:000047F0 656A            	  1175: 	BCS	TSTVRT				; C=1: not a variable
02:000047F2 6632            	  1176: 	BNE	TV1						; branch if not "@" array
02:000047F4 5248            	  1177: 	ADDQ #1,A0				; If it is, it should be
02:000047F6 61D6            	  1178: 	BSR	PARN					; followed by (EXPR) as its index.
02:000047F8 D080            	  1179: 	ADD.L	D0,D0
02:000047FA 650001C8        	  1180: 	BCS	QHOW					; say "How?" if index is too big
02:000047FE D080            	  1181: 	ADD.L	D0,D0
02:00004800 650001C2        	  1182: 	BCS	QHOW
02:00004804 D080            	  1183: 	ADD.L	D0,D0
02:00004806 650001BC        	  1184: 	BCS	QHOW
02:0000480A D080            	  1185: 	ADD.L	D0,D0
02:0000480C 650001B6        	  1186: 	BCS	QHOW
02:00004810 2F00            	  1187: 	MOVE.L D0,-(SP)		; save the index
02:00004812 610000FE        	  1188: 	bsr	SIZE					; get amount of free memory
02:00004816 221F            	  1189: 	MOVE.L (SP)+,D1		; get back the index
02:00004818 B081            	  1190: 	CMP.L	D1,D0				; see if there's enough memory
02:0000481A 630001A0        	  1191: 	BLS	QSORRY				; if not, say "Sorry"
02:0000481E 203A0598        	  1192: 	MOVE.L VARBGN,D0	; put address of array element...
02:00004822 9081            	  1193: 	SUB.L	D1,D0				; into D0
02:00004824 4E75            	  1194: 	RTS
                            	  1195: TV1
02:00004826 B03C001B        	  1196: 	CMP.B	#27,D0			; if not @, is it A through Z?
02:0000482A 0A3C0001        	  1197: 	EOR	#1,CCR
02:0000482E 652C            	  1198: 	BCS	TSTVRT				; if not, set Carry and return
02:00004830 5248            	  1199: 	ADDQ #1,A0				; else bump the text pointer
02:00004832 0C00004C        	  1200: 	cmpi.b #'L',d0		; is it a local? L0 to L7
02:00004836 661C            	  1201: 	bne TV2
02:00004838 1010            	  1202: 	move.b (a0),d0
02:0000483A 0C000030        	  1203: 	cmpi.b #'0',d0
02:0000483E 6514            	  1204: 	blo TV2
02:00004840 0C000037        	  1205: 	cmpi.b #'7',d0
02:00004844 620E            	  1206: 	bhi TV2
02:00004846 903C0030        	  1207: 	sub.b #'0',d0
02:0000484A 5248            	  1208: 	addq #1,a0			; bump text pointer
02:0000484C E988            	  1209: 	lsl.l #4,d0			; *16 bytes per var
02:0000484E D0BA0530        	  1210: 	add.l STKFP,d0
02:00004852 4E75            	  1211: 	rts
                            	  1212: TV2
02:00004854 E988            	  1213: 	LSL.L #4,D0			; compute the variable's address
02:00004856 223A0560        	  1214: 	MOVE.L VARBGN,D1
02:0000485A D081            	  1215: 	ADD.L	D1,D0			; and return it in D0 with Carry=0
                            	  1216: TSTVRT
02:0000485C 4E75            	  1217: 	RTS
                            	  1218: 
                            	  1219: 
                            	  1220: * ===== Divide the 32 bit value in D0 by the 32 bit value in D1.
                            	  1221: *	Returns the 32 bit quotient in D0, remainder in D1.
                            	  1222: *
                            	  1223: DIV32
02:0000485E 4A81            	  1224: 	TST.L	D1		check for divide-by-zero
02:00004860 67000162        	  1225: 	BEQ	QHOW		if so, say "How?"
02:00004864 2401            	  1226: 	MOVE.L	D1,D2
02:00004866 2801            	  1227: 	MOVE.L	D1,D4
02:00004868 B184            	  1228: 	EOR.L	D0,D4		see if the signs are the same
02:0000486A 4A80            	  1229: 	TST.L	D0		take absolute value of D0
02:0000486C 6A02            	  1230: 	BPL	DIV1
02:0000486E 4480            	  1231: 	NEG.L	D0
02:00004870 4A81            	  1232: DIV1	TST.L	D1		take absolute value of D1
02:00004872 6A02            	  1233: 	BPL	DIV2
02:00004874 4481            	  1234: 	NEG.L	D1
02:00004876 761F            	  1235: DIV2	MOVEQ	#31,D3		iteration count for 32 bits
02:00004878 2200            	  1236: 	MOVE.L	D0,D1
02:0000487A 7000            	  1237: 	CLR.L	D0
02:0000487C D281            	  1238: DIV3	ADD.L	D1,D1		(This algorithm was translated from
02:0000487E D180            	  1239: 	ADDX.L	D0,D0		the divide routine in Ron Cain's
02:00004880 6708            	  1240: 	BEQ	DIV4		Small-C run time library.)
02:00004882 B082            	  1241: 	CMP.L	D2,D0
02:00004884 6B04            	  1242: 	BMI	DIV4
02:00004886 5281            	  1243: 	ADDQ.L	#1,D1
02:00004888 9082            	  1244: 	SUB.L	D2,D0
02:0000488A 51CBFFF0        	  1245: DIV4	DBRA	D3,DIV3
02:0000488E C141            	  1246: 	EXG	D0,D1		put rem. & quot. in proper registers
02:00004890 4A84            	  1247: 	TST.L	D4		were the signs the same?
02:00004892 6A04            	  1248: 	BPL	DIVRT
02:00004894 4480            	  1249: 	NEG.L	D0		if not, results are negative
02:00004896 4481            	  1250: 	NEG.L	D1
02:00004898 4E75            	  1251: DIVRT	RTS
                            	  1252: 
                            	  1253: *
                            	  1254: * ===== The PEEK function returns the byte stored at the address
                            	  1255: *	contained in the following expression.
                            	  1256: *
                            	  1257: PEEK
02:0000489A 1E3C0042        	  1258: 	MOVE.B #'B',d7
02:0000489E 1210            	  1259: 	MOVE.B (a0),d1
02:000048A0 0C01002E        	  1260: 	CMPI.B #'.',d1
02:000048A4 6604            	  1261: 	BNE .0001
02:000048A6 5248            	  1262: 	ADDQ #1,a0
02:000048A8 1E18            	  1263: 	move.b (a0)+,d7
                            	  1264: .0001
02:000048AA 6100FF22        	  1265: 	BSR	PARN		get the memory address
02:000048AE F2006000        	  1266: 	FMOVE.L FP0,D0
02:000048B2 2240            	  1267: 	MOVE.L D0,A1
02:000048B4 0C070042        	  1268: 	cmpi.b #'B',d7
02:000048B8 6608            	  1269: 	bne .0002
                            	  1270: .0005
02:000048BA 7000            	  1271: 	CLR.L	D0		upper 3 bytes will be zero
02:000048BC F2115800        	  1272: 	FMOVE.B	(A1),FP0 	get the addressed byte
02:000048C0 4E75            	  1273: 	RTS			and return it
                            	  1274: .0002
02:000048C2 0C070057        	  1275: 	cmpi.b #'W',d7
02:000048C6 6608            	  1276: 	bne .0003
02:000048C8 7000            	  1277: 	CLR.L d0
02:000048CA F2115000        	  1278: 	FMOVE.W	(A1),FP0 	get the addressed byte
02:000048CE 4E75            	  1279: 	RTS			and return it
                            	  1280: .0003
02:000048D0 0C07004C        	  1281: 	cmpi.b #'L',d7
02:000048D4 6608            	  1282: 	bne .0004
02:000048D6 7000            	  1283: 	CLR.L d0
02:000048D8 F2114000        	  1284: 	FMOVE.L	(A1),FP0 		; get the lword
02:000048DC 4E75            	  1285: 	RTS			and return it
                            	  1286: .0004
02:000048DE 0C070046        	  1287: 	cmpi.b #'F',d7
02:000048E2 66D6            	  1288: 	bne .0005
02:000048E4 F2114800        	  1289: 	FMOVE.X	(A1),FP0 		; get the addressed float
02:000048E8 4E75            	  1290: 	RTS			and return it
                            	  1291: 
                            	  1292: ; ===== The RND function returns a random number from 0 to
                            	  1293: ; the value of the following expression in fp0.
                            	  1294: 
                            	  1295: RND:
02:000048EA 6100FEE2        	  1296: 	bsr	PARN			; get the upper limit
02:000048EE F200003A        	  1297: 	ftst.x fp0		; it must be positive and non-zero
02:000048F2 F28100D0        	  1298: 	fbeq QHOW
02:000048F6 F29400CC        	  1299: 	fblt QHOW
02:000048FA F2000100        	  1300: 	fmove.x fp0,fp2
02:000048FE 7028            	  1301: 	moveq #40,d0	; function #40 get random float
02:00004900 4E4F            	  1302: 	trap #15
02:00004902 F2000823        	  1303: 	fmul.x fp2,fp0
02:00004906 4E75            	  1304: 	rts
                            	  1305: 
                            	  1306: ; ===== The ABS function returns an absolute value in D0.
                            	  1307: 
                            	  1308: ABS:	
02:00004908 6100FEC4        	  1309: 	bsr	PARN			; get the following expr.'s value
02:0000490C F2000018        	  1310: 	fabs.x fp0
02:00004910 4E75            	  1311: 	rts
                            	  1312: 
                            	  1313: ; ===== The SIZE function returns the size of free memory in D0.
                            	  1314: 
                            	  1315: SIZE:
02:00004912 203A04A4        	  1316: 	move.l VARBGN,d0		; get the number of free bytes...
02:00004916 90BA049C        	  1317: 	sub.l	 TXTUNF,d0		; between 'TXTUNF' and 'VARBGN'
02:0000491A F2004000        	  1318: 	fmove.l d0,fp0
02:0000491E 4E75            	  1319: 	rts									; return the number in d0/fp0
                            	  1320: 	
                            	  1321: ; ===== The TICK function returns the processor tick register in D0.
                            	  1322: 
                            	  1323: TICK:
02:00004920 4E7A0FF0        	  1324: 	movec tick,d0
02:00004924 F2004000        	  1325: 	fmove.l d0,fp0
02:00004928 4E75            	  1326: 	rts
                            	  1327: 
                            	  1328: ; ===== The CORENO function returns the core number in D0.
                            	  1329: 
                            	  1330: CORENO:
02:0000492A 4E7A0FE0        	  1331: 	movec coreno,d0
02:0000492E F2004000        	  1332: 	fmove.l d0,fp0
02:00004932 4E75            	  1333: 	rts
                            	  1334: 
                            	  1335: *******************************************************************
                            	  1336: *
                            	  1337: * *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                            	  1338: *
                            	  1339: * 'SETVAL' expects a variable, followed by an equal sign and then
                            	  1340: * an expression.  It evaluates the expression and sets the variable
                            	  1341: * to that value.
                            	  1342: *
                            	  1343: * 'FIN' checks the end of a command.  If it ended with ":",
                            	  1344: * execution continues.	If it ended with a CR, it finds the
                            	  1345: * the next line and continues from there.
                            	  1346: *
                            	  1347: * 'ENDCHK' checks if a command is ended with a CR. This is
                            	  1348: * required in certain commands, such as GOTO, RETURN, STOP, etc.
                            	  1349: *
                            	  1350: * 'ERROR' prints the string pointed to by A0. It then prints the
                            	  1351: * line pointed to by CURRNT with a "?" inserted at where the
                            	  1352: * old text pointer (should be on top of the stack) points to.
                            	  1353: * Execution of Tiny BASIC is stopped and a warm start is done.
                            	  1354: * If CURRNT is zero (indicating a direct command), the direct
                            	  1355: * command is not printed. If CURRNT is -1 (indicating
                            	  1356: * 'INPUT' command in progress), the input line is not printed
                            	  1357: * and execution is not terminated but continues at 'INPERR'.
                            	  1358: *
                            	  1359: * Related to 'ERROR' are the following:
                            	  1360: * 'QWHAT' saves text pointer on stack and gets "What?" message.
                            	  1361: * 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                            	  1362: * 'QSORRY' and 'ASORRY' do the same kind of thing.
                            	  1363: * 'QHOW' and 'AHOW' also do this for "How?".
                            	  1364: *
                            	  1365: SETVAL	
02:00004934 6100FEAE        	  1366: 	bsr	TSTV					; variable name?
02:00004938 6542            	  1367: 	bcs	QWHAT					; if not, say "What?"
02:0000493A 2F00            	  1368: 	move.l d0,-(sp)		; save the variable's address
02:0000493C 61000298        	  1369: 	bsr	TSTC					; get past the "=" sign
02:00004940 3D              	  1370: 	dc.b	'=',SV1-*
02:00004941 0D
02:00004942 6100FD1A        	  1371: 	bsr	EXPR					; evaluate the expression
02:00004946 2C5F            	  1372: 	move.l (sp)+,a6
02:00004948 F2166800        	  1373: 	fmove.x fp0,(a6) 	; and save its value in the variable
02:0000494C 4E75            	  1374: 	rts
                            	  1375: SV1
02:0000494E 602C            	  1376: 	bra	QWHAT					; if no "=" sign
                            	  1377: 
                            	  1378: FIN
02:00004950 61000284        	  1379: 	bsr	TSTC		*** FIN ***
02:00004954 3A              	  1380: 	DC.B	':',FI1-*
02:00004955 07
02:00004956 588F            	  1381: 	ADDQ.L	#4,SP		if ":", discard return address
02:00004958 6000F89A        	  1382: 	BRA	RUNSML		continue on the same line
                            	  1383: FI1
02:0000495C 61000278        	  1384: 	bsr	TSTC		not ":", is it a CR?
02:00004960 0D              	  1385: 	DC.B	CR,FI2-*
02:00004961 07
02:00004962 588F            	  1386: 	ADDQ.L	#4,SP		yes, purge return address
02:00004964 6000F82E        	  1387: 	BRA	RUNNXL		execute the next line
                            	  1388: FI2
02:00004968 4E75            	  1389: 	RTS			else return to the caller
                            	  1390: 
                            	  1391: ENDCHK
02:0000496A 610002CA        	  1392: 	bsr	IGNBLK
02:0000496E 0C10003A        	  1393: 	CMP.B #':',(a0)
02:00004972 6706            	  1394: 	BEQ ENDCHK1
02:00004974 0C10000D        	  1395: 	CMP.B	#CR,(A0)	does it end with a CR?
02:00004978 6602            	  1396: 	BNE	QWHAT		if not, say "WHAT?"
                            	  1397: ENDCHK1:
02:0000497A 4E75            	  1398: 	RTS
                            	  1399: 
02:0000497C 2F08            	  1400: QWHAT	MOVE.L	A0,-(SP)
02:0000497E 4DFA03DC        	  1401: AWHAT	LEA	WHTMSG,A6
02:00004982 61000318        	  1402: ERROR	bsr	PRMESG		display the error message
02:00004986 205F            	  1403: 	MOVE.L	(SP)+,A0	restore the text pointer
02:00004988 203A03F2        	  1404: 	MOVE.L	CURRNT,D0	get the current line number
02:0000498C 6700F538        	  1405: 	BEQ	WSTART		if zero, do a warm start
02:00004990 B0BCFFFFFFFF    	  1406: 	CMP.L	#-1,D0		is the line no. pointer = -1?
02:00004996 6700FAC2        	  1407: 	BEQ	INPERR		if so, redo input
02:0000499A 1F10            	  1408: 	MOVE.B	(A0),-(SP)	save the char. pointed to
02:0000499C 4210            	  1409: 	CLR.B	(A0)		put a zero where the error is
02:0000499E 227A03DC        	  1410: 	MOVE.L	CURRNT,A1	point to start of current line
02:000049A2 61000214        	  1411: 	bsr	PRTLN		display the line in error up to the 0
02:000049A6 109F            	  1412: 	MOVE.B	(SP)+,(A0)	restore the character
02:000049A8 103C003F        	  1413: 	MOVE.B	#'?',D0         display a "?"
02:000049AC 6100F4AE        	  1414: 	BSR	GOOUT
02:000049B0 4240            	  1415: 	CLR	D0
02:000049B2 5389            	  1416: 	SUBQ.L	#1,A1		point back to the error char.
02:000049B4 6100016E        	  1417: 	bsr	PRTSTG		display the rest of the line
02:000049B8 6000F50C        	  1418: 	BRA	WSTART		and do a warm start
02:000049BC 2F08            	  1419: QSORRY	MOVE.L	A0,-(SP)
02:000049BE 4DFA03A4        	  1420: ASORRY	LEA	SRYMSG,A6
02:000049C2 60BE            	  1421: 	BRA	ERROR
02:000049C4 2F08            	  1422: QHOW	MOVE.L	A0,-(SP)	Error: "How?"
02:000049C6 4DFA038D        	  1423: AHOW	LEA	HOWMSG,A6
02:000049CA 60B6            	  1424: 	BRA	ERROR
                            	  1425: *
                            	  1426: *******************************************************************
                            	  1427: *
                            	  1428: * *** GETLN *** FNDLN (& friends) ***
                            	  1429: *
                            	  1430: * 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                            	  1431: * the character in D0 (given by the caller), then it fills the
                            	  1432: * buffer and echos. It ignores LF's but still echos
                            	  1433: * them back. Control-H is used to delete the last character
                            	  1434: * entered (if there is one), and control-X is used to delete the
                            	  1435: * whole line and start over again. CR signals the end of a line,
                            	  1436: * and causes 'GETLN' to return.
                            	  1437: *
                            	  1438: * 'FNDLN' finds a line with a given line no. (in D1) in the
                            	  1439: * text save area.  A1 is used as the text pointer. If the line
                            	  1440: * is found, A1 will point to the beginning of that line
                            	  1441: * (i.e. the high byte of the line no.), and flags are NC & Z.
                            	  1442: * If that line is not there and a line with a higher line no.
                            	  1443: * is found, A1 points there and flags are NC & NZ. If we reached
                            	  1444: * the end of the text save area and cannot find the line, flags
                            	  1445: * are C & NZ.
                            	  1446: * 'FNDLN' will initialize A1 to the beginning of the text save
                            	  1447: * area to start the search. Some other entries of this routine
                            	  1448: * will not initialize A1 and do the search.
                            	  1449: * 'FNDLNP' will start with A1 and search for the line no.
                            	  1450: * 'FNDNXT' will bump A1 by 2, find a CR and then start search.
                            	  1451: * 'FNDSKP' uses A1 to find a CR, and then starts the search.
                            	  1452: *
                            	  1453: GETLN
02:000049CC 6100F48E        	  1454: 	BSR	GOOUT		display the prompt
02:000049D0 103C0020        	  1455: 	MOVE.B	#' ',D0         and a space
02:000049D4 6100F486        	  1456: 	BSR	GOOUT
02:000049D8 41FA03E6        	  1457: 	LEA	BUFFER,A0	A0 is the buffer pointer
                            	  1458: GL1
02:000049DC 610002AC        	  1459: 	bsr	CHKIO		check keyboard
02:000049E0 67FA            	  1460: 	BEQ	GL1		wait for a char. to come in
02:000049E2 B03C0008        	  1461: 	CMP.B	#CTRLH,D0	delete last character?
02:000049E6 6726            	  1462: 	BEQ	GL3		if so
02:000049E8 B03C0018        	  1463: 	CMP.B	#CTRLX,D0	delete the whole line?
02:000049EC 6744            	  1464: 	BEQ	GL4		if so
02:000049EE B03C000D        	  1465: 	CMP.B	#CR,D0		accept a CR
02:000049F2 6706            	  1466: 	BEQ	GL2
02:000049F4 B03C0020        	  1467: 	CMP.B	#' ',D0         if other control char., discard it
02:000049F8 65E2            	  1468: 	BCS	GL1
                            	  1469: GL2
02:000049FA 10C0            	  1470: 	MOVE.B	D0,(A0)+	save the char.
02:000049FC 6100F45E        	  1471: 	BSR	GOOUT		echo the char back out
02:00004A00 B03C000D        	  1472: 	CMP.B	#CR,D0		if it's a CR, end the line
02:00004A04 675C            	  1473: 	BEQ	GL7
02:00004A06 B1FC00004E0F    	  1474: 	CMP.L	#(BUFFER+BUFLEN-1),A0	any more room?
02:00004A0C 65CE            	  1475: 	BCS	GL1		yes: get some more, else delete last char.
                            	  1476: GL3
02:00004A0E 103C0008        	  1477: 	MOVE.B	#CTRLH,D0	delete a char. if possible
02:00004A12 6100F448        	  1478: 	BSR	GOOUT
02:00004A16 103C0020        	  1479: 	MOVE.B	#' ',D0
02:00004A1A 6100F440        	  1480: 	BSR	GOOUT
02:00004A1E B1FC00004DC0    	  1481: 	CMP.L	#BUFFER,A0	any char.'s left?
02:00004A24 63B6            	  1482: 	BLS	GL1		if not
02:00004A26 103C0008        	  1483: 	MOVE.B	#CTRLH,D0	if so, finish the BS-space-BS sequence
02:00004A2A 6100F430        	  1484: 	BSR	GOOUT
02:00004A2E 5388            	  1485: 	SUBQ.L	#1,A0		decrement the text pointer
02:00004A30 60AA            	  1486: 	BRA	GL1		back for more
                            	  1487: GL4
02:00004A32 2208            	  1488: 	MOVE.L	A0,D1		delete the whole line
02:00004A34 92BC00004DC0    	  1489: 	SUB.L	#BUFFER,D1	figure out how many backspaces we need
02:00004A3A 671E            	  1490: 	BEQ	GL6		if none needed, branch
02:00004A3C 5341            	  1491: 	SUBQ	#1,D1		adjust for DBRA
                            	  1492: GL5
02:00004A3E 103C0008        	  1493: 	MOVE.B	#CTRLH,D0	and display BS-space-BS sequences
02:00004A42 6100F418        	  1494: 	BSR	GOOUT
02:00004A46 103C0020        	  1495: 	MOVE.B	#' ',D0
02:00004A4A 6100F410        	  1496: 	BSR	GOOUT
02:00004A4E 103C0008        	  1497: 	MOVE.B	#CTRLH,D0
02:00004A52 6100F408        	  1498: 	BSR	GOOUT
02:00004A56 51C9FFE6        	  1499: 	DBRA	D1,GL5
                            	  1500: GL6
02:00004A5A 41FA0364        	  1501: 	LEA	BUFFER,A0	reinitialize the text pointer
02:00004A5E 6000FF7C        	  1502: 	BRA	GL1		and go back for more
                            	  1503: GL7
02:00004A62 103C000A        	  1504: 	MOVE.B	#LF,D0		echo a LF for the CR
02:00004A66 6000F3F4        	  1505: 	BRA	GOOUT
                            	  1506: 
                            	  1507: FNDLN
02:00004A6A B2BC0000FFFF    	  1508: 	CMP.L	#$FFFF,D1	line no. must be < 65535
02:00004A70 6400FF52        	  1509: 	BCC	QHOW
02:00004A74 227AF3FA        	  1510: 	MOVE.L	TXTBGN,A1	init. the text save pointer
                            	  1511: 
                            	  1512: FNDLNP
02:00004A78 247A033A        	  1513: 	MOVE.L	TXTUNF,A2	check if we passed the end
02:00004A7C 538A            	  1514: 	SUBQ.L	#1,A2
02:00004A7E B5C9            	  1515: 	CMP.L	A1,A2
02:00004A80 650C            	  1516: 	BCS	FNDRET		if so, return with Z=0 & C=1
02:00004A82 1411            	  1517: 	MOVE.B	(A1),D2	if not, get a line no.
02:00004A84 E14A            	  1518: 	LSL	#8,D2
02:00004A86 14290001        	  1519: 	MOVE.B	1(A1),D2
02:00004A8A B441            	  1520: 	CMP.W	D1,D2		is this the line we want?
02:00004A8C 6502            	  1521: 	BCS	FNDNXT		no, not there yet
                            	  1522: FNDRET
02:00004A8E 4E75            	  1523: 	RTS			return the cond. codes
                            	  1524: 
                            	  1525: FNDNXT
02:00004A90 5489            	  1526: 	ADDQ.L	#2,A1		find the next line
                            	  1527: 
                            	  1528: FNDSKP	
02:00004A92 0C19000D        	  1529: 	CMP.B	#CR,(A1)+	try to find a CR
02:00004A96 67E0            	  1530: 	BEQ		FNDLNP
02:00004A98 B3FA031A        	  1531: 	CMP.L	TXTUNF,A1
02:00004A9C 65F4            	  1532: 	BLO		FNDSKP
02:00004A9E 60D8            	  1533: 	BRA		FNDLNP		check if end of text
                            	  1534: 
                            	  1535: *
                            	  1536: *******************************************************************
                            	  1537: *
                            	  1538: * *** MVUP *** MVDOWN *** POPA *** PUSHA ***
                            	  1539: *
                            	  1540: * 'MVUP' moves a block up from where A1 points to where A2 points
                            	  1541: * until A1=A3
                            	  1542: *
                            	  1543: * 'MVDOWN' moves a block down from where A1 points to where A3
                            	  1544: * points until A1=A2
                            	  1545: *
                            	  1546: * 'POPA' restores the 'FOR' loop variable save area from the stack
                            	  1547: *
                            	  1548: * 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                            	  1549: *
02:00004AA0 B7C9            	  1550: MVUP	CMP.L	A1,A3		see the above description
02:00004AA2 6704            	  1551: 	BEQ	MVRET
02:00004AA4 14D9            	  1552: 	MOVE.B	(A1)+,(A2)+
02:00004AA6 60F8            	  1553: 	BRA	MVUP
02:00004AA8 4E75            	  1554: MVRET	RTS
                            	  1555: 
02:00004AAA B5C9            	  1556: MVDOWN	CMP.L	A1,A2		see the above description
02:00004AAC 67FA            	  1557: 	BEQ	MVRET
02:00004AAE 1721            	  1558: 	MOVE.B	-(A1),-(A3)
02:00004AB0 60F8            	  1559: 	BRA	MVDOWN
                            	  1560: 
02:00004AB2 2C5F            	  1561: POPA	MOVE.L	(SP)+,A6	A6 = return address
02:00004AB4 23DF00004D8C    	  1562: 	MOVE.L	(SP)+,LOPVAR	restore LOPVAR, but zero means no more
02:00004ABA 6730            	  1563: 	BEQ	PP1
02:00004ABC 23DF00004D98    	  1564: 	MOVE.L	(SP)+,LOPINC+8	if not zero, restore the rest
02:00004AC2 23DF00004D94    	  1565: 	MOVE.L	(SP)+,LOPINC+4
02:00004AC8 23DF00004D90    	  1566: 	MOVE.L	(SP)+,LOPINC
02:00004ACE 23DF00004DA4    	  1567: 	MOVE.L	(SP)+,LOPLMT+8
02:00004AD4 23DF00004DA0    	  1568: 	MOVE.L	(SP)+,LOPLMT+4
02:00004ADA 23DF00004D9C    	  1569: 	MOVE.L	(SP)+,LOPLMT
02:00004AE0 23DF00004DA8    	  1570: 	MOVE.L	(SP)+,LOPLN
02:00004AE6 23DF00004DAC    	  1571: 	MOVE.L	(SP)+,LOPPT
02:00004AEC 4ED6            	  1572: PP1	JMP	(A6)		return
                            	  1573: 
02:00004AEE 223A02CC        	  1574: PUSHA	MOVE.L	STKLMT,D1	Are we running out of stack room?
02:00004AF2 928F            	  1575: 	SUB.L	SP,D1
02:00004AF4 6400FEC6        	  1576: 	BCC	QSORRY		if so, say we're sorry
02:00004AF8 2C5F            	  1577: 	MOVE.L	(SP)+,A6	else get the return address
02:00004AFA 223A0290        	  1578: 	MOVE.L	LOPVAR,D1	save loop variables
02:00004AFE 6720            	  1579: 	BEQ	PU1		if LOPVAR is zero, that's all
02:00004B00 2F3A02AA        	  1580: 	MOVE.L	LOPPT,-(SP)	else save all the others
02:00004B04 2F3A02A2        	  1581: 	MOVE.L	LOPLN,-(SP)
02:00004B08 2F3A0292        	  1582: 	MOVE.L	LOPLMT,-(SP)
02:00004B0C 2F3A0292        	  1583: 	MOVE.L	LOPLMT+4,-(SP)
02:00004B10 2F3A0292        	  1584: 	MOVE.L	LOPLMT+8,-(SP)
02:00004B14 2F3A027A        	  1585: 	MOVE.L	LOPINC,-(SP)
02:00004B18 2F3A027A        	  1586: 	MOVE.L	LOPINC+4,-(SP)
02:00004B1C 2F3A027A        	  1587: 	MOVE.L	LOPINC+8,-(SP)
                            	  1588: PU1	
02:00004B20 2F01            	  1589: 	MOVE.L	D1,-(SP)
02:00004B22 4ED6            	  1590: 	JMP	(A6)		return
                            	  1591: 
                            	  1592: *
                            	  1593: *******************************************************************
                            	  1594: *
                            	  1595: * *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                            	  1596: *
                            	  1597: * 'PRTSTG' prints a string pointed to by A1. It stops printing
                            	  1598: * and returns to the caller when either a CR is printed or when
                            	  1599: * the next byte is the same as what was passed in D0 by the
                            	  1600: * caller.
                            	  1601: *
                            	  1602: * 'QTSTG' looks for an underline (back-arrow on some systems),
                            	  1603: * single-quote, or double-quote.  If none of these are found, returns
                            	  1604: * to the caller.  If underline, outputs a CR without a LF.  If single
                            	  1605: * or double quote, prints the quoted string and demands a matching
                            	  1606: * end quote.  After the printing, the next 2 bytes of the caller are
                            	  1607: * skipped over (usually a short branch instruction).
                            	  1608: *
                            	  1609: * 'PRTNUM' prints the 32 bit number in D1, leading blanks are added if
                            	  1610: * needed to pad the number of spaces to the number in D4.
                            	  1611: * However, if the number of digits is larger than the no. in
                            	  1612: * D4, all digits are printed anyway. Negative sign is also
                            	  1613: * printed and counted in, positive sign is not.
                            	  1614: *
                            	  1615: * 'PRTLN' prints the saved text line pointed to by A1
                            	  1616: * with line no. and all.
                            	  1617: *
02:00004B24 1200            	  1618: PRTSTG	MOVE.B	D0,D1		save the stop character
02:00004B26 1019            	  1619: PS1	MOVE.B	(A1)+,D0	get a text character
02:00004B28 B200            	  1620: 	CMP.B	D0,D1		same as stop character?
02:00004B2A 6712            	  1621: 	BEQ	PRTRET		if so, return
02:00004B2C 6100F32E        	  1622: 	BSR	GOOUT		display the char.
02:00004B30 B03C000D        	  1623: 	CMP.B	#CR,D0		is it a C.R.?
02:00004B34 66F0            	  1624: 	BNE	PS1		no, go back for more
02:00004B36 103C000A        	  1625: 	MOVE.B	#LF,D0		yes, add a L.F.
02:00004B3A 6100F320        	  1626: 	BSR	GOOUT
02:00004B3E 4E75            	  1627: PRTRET	RTS			then return
                            	  1628: 
02:00004B40 61000094        	  1629: QTSTG	bsr	TSTC		*** QTSTG ***
02:00004B44 22              	  1630: 	DC.B	'"',QT3-*
02:00004B45 19
02:00004B46 103C0022        	  1631: 	MOVE.B	#'"',D0         it is a "
02:00004B4A 2248            	  1632: QT1	MOVE.L	A0,A1
02:00004B4C 61D6            	  1633: 	BSR	PRTSTG		print until another
02:00004B4E 2049            	  1634: 	MOVE.L	A1,A0
02:00004B50 225F            	  1635: 	MOVE.L	(SP)+,A1	pop return address
02:00004B52 B03C000A        	  1636: 	CMP.B	#LF,D0		was last one a CR?
02:00004B56 6700F63C        	  1637: 	BEQ	RUNNXL		if so, run next line
02:00004B5A 5489            	  1638: QT2	ADDQ.L	#2,A1		skip 2 bytes on return
02:00004B5C 4ED1            	  1639: 	JMP	(A1)		return
02:00004B5E 6176            	  1640: QT3	bsr	TSTC		is it a single quote?
02:00004B60 27              	  1641: 	DC.B	'''',QT4-*
02:00004B61 07
02:00004B62 103C0027        	  1642: 	MOVE.B	#'''',D0        if so, do same as above
02:00004B66 60E2            	  1643: 	BRA	QT1
02:00004B68 616C            	  1644: QT4	bsr	TSTC		is it an underline?
02:00004B6A 5F              	  1645: 	DC.B	'_',QT5-*
02:00004B6B 0D
02:00004B6C 103C000D        	  1646: 	MOVE.B	#CR,D0		if so, output a CR without LF
02:00004B70 6100F2EA        	  1647: 	bsr	GOOUT
02:00004B74 225F            	  1648: 	MOVE.L	(SP)+,A1	pop return address
02:00004B76 60E2            	  1649: 	BRA	QT2
02:00004B78 4E75            	  1650: QT5	RTS			none of the above
                            	  1651: 
                            	  1652: PRTNUM:
02:00004B7A 4E52FFDC        	  1653: 	link a2,#-36
02:00004B7E 2179000400980020	  1654: 	move.l _canary,32(a0)
02:00004B86 48D7020F        	  1655: 	movem.l d0/d1/d2/d3/a1,(sp)
02:00004B8A F22F68000014    	  1656: 	fmove.x fp0,20(sp)
02:00004B90 F2000400        	  1657: 	fmove.x fp1,fp0					; fp0 = number to print
02:00004B94 43F900040520    	  1658: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
02:00004B9A 7027            	  1659: 	moveq #39,d0						; d0 = function #39 print float
02:00004B9C 2204            	  1660: 	move.l d4,d1						; d1 = width
02:00004B9E 2404            	  1661: 	move.l d4,d2						; d2 = precision max
02:00004BA0 7665            	  1662: 	moveq #'e',d3
02:00004BA2 4E4F            	  1663: 	trap #15
02:00004BA4 4CD7020F        	  1664: 	movem.l (sp),d0/d1/d2/d3/a1
02:00004BA8 F22F48000014    	  1665: 	fmove.x 20(sp),fp0
02:00004BAE A2A800030020    	  1666: 	cchk 32(a0)
02:00004BB4 4E5A            	  1667: 	unlk a2
02:00004BB6 4E75            	  1668: 	rts
                            	  1669: 
                            	  1670: PRTLN:
02:00004BB8 7200            	  1671: 	CLR.L	D1
02:00004BBA 1219            	  1672: 	MOVE.B	(A1)+,D1	get the binary line number
02:00004BBC E149            	  1673: 	LSL	#8,D1
02:00004BBE 1219            	  1674: 	MOVE.B	(A1)+,D1
02:00004BC0 F2015080        	  1675: 	FMOVE.W D1,FP1
02:00004BC4 7805            	  1676: 	MOVEQ	#5,D4		display a 5 digit line no.
02:00004BC6 61B2            	  1677: 	BSR	PRTNUM
02:00004BC8 103C0020        	  1678: 	MOVE.B	#' ',D0         followed by a blank
02:00004BCC 6100F28E        	  1679: 	BSR	GOOUT
02:00004BD0 4240            	  1680: 	CLR	D0		stop char. is a zero
02:00004BD2 6000FF50        	  1681: 	BRA	PRTSTG		display the rest of the line
                            	  1682: 
                            	  1683: 
                            	  1684: ; ===== Test text byte following the call to this subroutine. If it
                            	  1685: ; equals the byte pointed to by A0, return to the code following
                            	  1686: ; the call. If they are not equal, branch to the point
                            	  1687: ;	indicated by the offset byte following the text byte.
                            	  1688: 
                            	  1689: TSTC:
02:00004BD6 615E            	  1690: 	BSR	IGNBLK				; ignore leading blanks
02:00004BD8 225F            	  1691: 	MOVE.L (SP)+,A1		; get the return address
02:00004BDA 1219            	  1692: 	MOVE.B (A1)+,D1		; get the byte to compare
02:00004BDC B210            	  1693: 	CMP.B	(A0),D1 		;	is it = to what A0 points to?
02:00004BDE 6708            	  1694: 	BEQ	TC1						; if so
02:00004BE0 7200            	  1695: 	CLR.L	D1					; If not, add the second
02:00004BE2 1211            	  1696: 	MOVE.B (A1),D1 		; byte following the call to
02:00004BE4 D3C1            	  1697: 	ADD.L	D1,A1				; the return address.
02:00004BE6 4ED1            	  1698: 	JMP	(A1)					; jump to the routine
                            	  1699: TC1
02:00004BE8 5288            	  1700: 	ADDQ.L #1,A0			; if equal, bump text pointer
02:00004BEA 5289            	  1701: 	ADDQ.L #1,A1			; Skip the 2 bytes following
02:00004BEC 4ED1            	  1702: 	JMP	(A1)					; the call and continue.
                            	  1703: 
                            	  1704: 
                            	  1705: ; ===== See if the text pointed to by A0 is a number. If so,
                            	  1706: ;	return the number in FP1 and the number of digits in D2,
                            	  1707: ;	else return zero in FP1 and D2.
                            	  1708: ; If text is not a number, then A0 is not updated, otherwise
                            	  1709: ; A0 is advanced past the number. Note A0 is always updated
                            	  1710: ; past leading spaces.
                            	  1711: 
                            	  1712: TSTNUM
02:00004BEE 4E52FFE0        	  1713: 	link a2,#-32
02:00004BF2 2F7900040098001C	  1714: 	move.l _canary,28(sp)
02:00004BFA 48D70203        	  1715: 	movem.l d0/d1/a1,(sp)
02:00004BFE F22F68000010    	  1716: 	fmove.x fp0,16(sp)
02:00004C04 7029            	  1717: 	moveq #41,d0						; function #41, get float
02:00004C06 7201            	  1718: 	moveq #1,d1							; d1 = input stride
02:00004C08 2248            	  1719: 	move.l a0,a1						; a1 = pointer to input buffer
02:00004C0A 4E4F            	  1720: 	trap #15								; call BIOS get float function
02:00004C0C 2049            	  1721: 	move.l a1,a0						; set text pointer
02:00004C0E F2000080        	  1722: 	fmove.x fp0,fp1					; return expected in fp1
02:00004C12 4A41            	  1723: 	tst.w d1								; check if a number (digits > 0?)
02:00004C14 6706            	  1724: 	beq .0002
02:00004C16 7400            	  1725: 	clr.l d2								; d2.l = 0
02:00004C18 3401            	  1726: 	move.w d1,d2						; d2 = number of digits
02:00004C1A 6006            	  1727: 	bra .0001
                            	  1728: .0002											; not a number, return with orignal text pointer
02:00004C1C 7400            	  1729: 	moveq #0,d2							; d2 = 0
02:00004C1E F2024080        	  1730: 	fmove.l d2,fp1					; return a zero
                            	  1731: .0001
02:00004C22 4CD70203        	  1732: 	movem.l (sp),d0/d1/a1
02:00004C26 F22F48000010    	  1733: 	fmove.x 16(sp),fp0
02:00004C2C A2AF0003001C    	  1734: 	cchk 28(sp)
02:00004C32 4E5A            	  1735: 	unlk a2
02:00004C34 4E75            	  1736: 	rts
                            	  1737: 		
                            	  1738: ; ===== Skip over blanks in the text pointed to by A0.
                            	  1739: 
                            	  1740: IGNBLK
02:00004C36 0C180020        	  1741: 	CMP.B	#' ',(A0)+		; see if it's a space
02:00004C3A 67FA            	  1742: 	BEQ	IGNBLK					; if so, swallow it
02:00004C3C 5388            	  1743: 	SUBQ.L #1,A0				; decrement the text pointer
02:00004C3E 4E75            	  1744: 	RTS
                            	  1745: 
                            	  1746: *
                            	  1747: * ===== Convert the line of text in the input buffer to upper
                            	  1748: *	case (except for stuff between quotes).
                            	  1749: *
02:00004C40 41FA017E        	  1750: TOUPBUF LEA	BUFFER,A0	set up text pointer
02:00004C44 4201            	  1751: 	CLR.B	D1		clear quote flag
                            	  1752: TOUPB1	
02:00004C46 1018            	  1753: 	MOVE.B	(A0)+,D0	get the next text char.
02:00004C48 B03C000D        	  1754: 	CMP.B	#CR,D0		is it end of line?
02:00004C4C 6718            	  1755: 	BEQ	TOUPBRT 	if so, return
02:00004C4E B03C0022        	  1756: 	CMP.B	#'"',D0         a double quote?
02:00004C52 6714            	  1757: 	BEQ	DOQUO
02:00004C54 B03C0027        	  1758: 	CMP.B	#'''',D0        or a single quote?
02:00004C58 670E            	  1759: 	BEQ	DOQUO
02:00004C5A 4A01            	  1760: 	TST.B	D1		inside quotes?
02:00004C5C 66E8            	  1761: 	BNE	TOUPB1		if so, do the next one
02:00004C5E 6118            	  1762: 	BSR	TOUPPER 	convert to upper case
02:00004C60 1100            	  1763: 	MOVE.B	D0,-(A0)	store it
02:00004C62 5288            	  1764: 	ADDQ.L	#1,A0
02:00004C64 60E0            	  1765: 	BRA	TOUPB1		and go back for more
                            	  1766: TOUPBRT
02:00004C66 4E75            	  1767: 	RTS
                            	  1768: 
02:00004C68 4A01            	  1769: DOQUO	TST.B	D1		are we inside quotes?
02:00004C6A 6604            	  1770: 	BNE	DOQUO1
02:00004C6C 1200            	  1771: 	MOVE.B	D0,D1		if not, toggle inside-quotes flag
02:00004C6E 60D6            	  1772: 	BRA	TOUPB1
02:00004C70 B200            	  1773: DOQUO1	CMP.B	D0,D1		make sure we're ending proper quote
02:00004C72 66D2            	  1774: 	BNE	TOUPB1		if not, ignore it
02:00004C74 4201            	  1775: 	CLR.B	D1		else clear quote flag
02:00004C76 60CE            	  1776: 	BRA	TOUPB1
                            	  1777: 
                            	  1778: *
                            	  1779: * ===== Convert the character in D0 to upper case
                            	  1780: *
02:00004C78 B03C0061        	  1781: TOUPPER CMP.B	#'a',D0         is it < 'a'?
02:00004C7C 650A            	  1782: 	BCS	TOUPRET
02:00004C7E B03C007A        	  1783: 	CMP.B	#'z',D0         or > 'z'?
02:00004C82 6204            	  1784: 	BHI	TOUPRET
02:00004C84 903C0020        	  1785: 	SUB.B	#32,D0		if not, make it upper case
02:00004C88 4E75            	  1786: TOUPRET RTS
                            	  1787: 
                            	  1788: *
                            	  1789: * 'CHKIO' checks the input. If there's no input, it will return
                            	  1790: * to the caller with the Z flag set. If there is input, the Z
                            	  1791: * flag is cleared and the input byte is in D0. However, if a
                            	  1792: * control-C is read, 'CHKIO' will warm-start BASIC and will not
                            	  1793: * return to the caller.
                            	  1794: *
02:00004C8A 6100F1D4        	  1795: CHKIO	bsr	GOIN		get input if possible
02:00004C8E 670A            	  1796: 	BEQ	CHKRET		if Zero, no input
02:00004C90 B03C0003        	  1797: 	CMP.B	#CTRLC,D0	is it control-C?
02:00004C94 6604            	  1798: 	BNE	CHKRET		if not
02:00004C96 6000F22E        	  1799: 	BRA	WSTART		if so, do a warm start
02:00004C9A 4E75            	  1800: CHKRET	RTS
                            	  1801: 
                            	  1802: *
                            	  1803: * ===== Display a CR-LF sequence
                            	  1804: *
                            	  1805: ;CRLF	LEA	CLMSG,A6
                            	  1806: 
                            	  1807: *
                            	  1808: * ===== Display a zero-ended string pointed to by register A6
                            	  1809: *
02:00004C9C 101E            	  1810: PRMESG	MOVE.B	(A6)+,D0	get the char.
02:00004C9E 6706            	  1811: 	BEQ	PRMRET		if it's zero, we're done
02:00004CA0 6100F1BA        	  1812: 	BSR	GOOUT		else display it
02:00004CA4 60F6            	  1813: 	BRA	PRMESG
02:00004CA6 4E75            	  1814: PRMRET	RTS
                            	  1815: 
                            	  1816: ******************************************************
                            	  1817: * The following routines are the only ones that need *
                            	  1818: * to be changed for a different I/O environment.     *
                            	  1819: ******************************************************
                            	  1820: 
                            	  1821: *
                            	  1822: * ===== Output character to the console (Port 1) from register D0
                            	  1823: *	(Preserves all registers.)
                            	  1824: *
                            	  1825: OUTC
02:00004CA8 2F0E            	  1826: 	move.l	a6,-(a7)
02:00004CAA 2C7A00CC        	  1827: 	move.l	OUTPTR,a6
02:00004CAE 4E96            	  1828: 	jsr			(a6)
02:00004CB0 2C5F            	  1829: 	move.l	(a7)+,a6
02:00004CB2 4E75            	  1830: 	rts
                            	  1831: 
                            	  1832: OUTC1
02:00004CB4 48E7C000        	  1833: 	movem.l		d0/d1,-(a7)
02:00004CB8 2200            	  1834: 	move.l		d0,d1
02:00004CBA 7006            	  1835: 	moveq.l		#6,d0
02:00004CBC 4E4F            	  1836: 	trap			#15
02:00004CBE 4CDF0003        	  1837: 	movem.l		(a7)+,d0/d1
02:00004CC2 4E75            	  1838: 	rts
                            	  1839: 
                            	  1840: *OUTC	BTST	#1,$10040	is port 1 ready for a character?
                            	  1841: *	BEQ	OUTC		if not, wait for it
                            	  1842: *	MOVE.B	D0,$10042	out it goes.
                            	  1843: *	RTS
                            	  1844: 
                            	  1845: *
                            	  1846: * ===== Input a character from the console into register D0 (or
                            	  1847: *	return Zero status if there's no character available).
                            	  1848: *
                            	  1849: INC
02:00004CC4 2F0E            	  1850: 	move.l	a6,-(a7)
02:00004CC6 2C7A00AC        	  1851: 	move.l	INPPTR,a6
02:00004CCA 4E96            	  1852: 	jsr			(a6)
02:00004CCC 2C5F            	  1853: 	move.l	(a7)+,a6
02:00004CCE 4E75            	  1854: 	rts
                            	  1855: 
                            	  1856: INC1
02:00004CD0 2F01            	  1857: 	move.l	d1,-(a7)
02:00004CD2 7005            	  1858: 	moveq.l	#5,d0			* function 5 GetKey
02:00004CD4 4E4F            	  1859: 	trap		#15
02:00004CD6 2001            	  1860: 	move.l	d1,d0
02:00004CD8 221F            	  1861: 	move.l	(a7)+,d1
02:00004CDA 0C0000FF        	  1862: 	cmpi.b	#-1,d0
02:00004CDE 6602            	  1863: 	bne			.0001
02:00004CE0 4200            	  1864: 	clr.b		d0
                            	  1865: .0001:
02:00004CE2 4E75            	  1866: 	rts
                            	  1867: 
                            	  1868: *INC	BTST	#0,$10040	is character ready?
                            	  1869: *	BEQ	INCRET		if not, return Zero status
                            	  1870: *	MOVE.B	$10042,D0	else get the character
                            	  1871: *	AND.B	#$7F,D0 	zero out the high bit
                            	  1872: *INCRET	RTS
                            	  1873: 
                            	  1874: *
                            	  1875: * ===== Output character to the host (Port 2) from register D0
                            	  1876: *	(Preserves all registers.)
                            	  1877: *
                            	  1878: AUXOUT:
02:00004CE4 48E7C000        	  1879: 	movem.l	d0/d1,-(a7)
02:00004CE8 2200            	  1880: 	move.l	d0,d1
02:00004CEA 7022            	  1881: 	moveq		#34,d0
02:00004CEC 4E4F            	  1882: 	trap		#15
02:00004CEE 4CDF0003        	  1883: 	movem.l	(a7)+,d0/d1
02:00004CF2 4E75            	  1884: 	rts
                            	  1885: 
                            	  1886: *AUXOUT	BTST	#1,$10041	is port 2 ready for a character?
                            	  1887: *	BEQ	AUXOUT		if not, wait for it
                            	  1888: *	MOVE.B	D0,$10043	out it goes.
                            	  1889: *	RTS
                            	  1890: 
                            	  1891: *
                            	  1892: * ===== Input a character from the host into register D0 (or
                            	  1893: *	return Zero status if there's no character available).
                            	  1894: *
                            	  1895: AUXIN:
02:00004CF4 2F01            	  1896: 	move.l	d1,-(a7)
02:00004CF6 7024            	  1897: 	moveq		#36,d0				; serial get char from buffer
02:00004CF8 4E4F            	  1898: 	trap		#15
02:00004CFA 2001            	  1899: 	move.l	d1,d0
02:00004CFC 221F            	  1900: 	move.l	(a7)+,d1
02:00004CFE 0C40FFFF        	  1901: 	cmpi.w	#-1,d0
02:00004D02 670A            	  1902: 	beq			.0001
02:00004D04 0200007F        	  1903: 	andi.b	#$7F,d0				; clear high bit
02:00004D08 4880            	  1904: 	ext.w		d0						; return character in d0
02:00004D0A 48C0            	  1905: 	ext.l		d0
02:00004D0C 4E75            	  1906: 	rts
                            	  1907: .0001:
02:00004D0E 7000            	  1908: 	moveq		#0,d0					; return zf=1 if no character available
02:00004D10 4E75            	  1909: 	rts
                            	  1910: 
                            	  1911: ;AUXIN
                            	  1912: *AUXIN	BTST	#0,$10041	is character ready?
                            	  1913: *	BEQ	AXIRET		if not, return Zero status
                            	  1914: *	MOVE.B	$10043,D0	else get the character
                            	  1915: *	AND.B	#$7F,D0 	zero out the high bit
02:00004D12 4E75            	  1916: AXIRET	RTS
                            	  1917: 
                            	  1918: *
                            	  1919: * ===== Return to the resident monitor, operating system, etc.
                            	  1920: *
                            	  1921: BYEBYE	
02:00004D14 23FC000000080004	  1922: 	move.l #8,_fpTextIncr
02:00004D1C 0094
02:00004D1E 600011A2        	  1923: 	bra		Monitor
                            	  1924: ;	MOVE.B	#228,D7 	return to Tutor
                            	  1925: ;	TRAP	#14
                            	  1926: 
02:00004D22 0D              	  1927: INITMSG DC.B	CR,LF,'Finch''s MC68000 Tiny Float BASIC, v1.2',CR,LF,LF,0
02:00004D23 0A
02:00004D24 46696E6368277320
02:00004D2C 4D43363830303020
02:00004D34 54696E7920466C6F
02:00004D3C 6174204241534943
02:00004D44 2C2076312E32
02:00004D4A 0D
02:00004D4B 0A
02:00004D4C 0A
02:00004D4D 00
02:00004D4E 0D              	  1928: OKMSG	DC.B	CR,LF,'OK',CR,LF,0
02:00004D4F 0A
02:00004D50 4F4B
02:00004D52 0D
02:00004D53 0A
02:00004D54 00
02:00004D55 486F773F        	  1929: HOWMSG	DC.B	'How?',CR,LF,0
02:00004D59 0D
02:00004D5A 0A
02:00004D5B 00
02:00004D5C 576861743F      	  1930: WHTMSG	DC.B	'What?',CR,LF,0
02:00004D61 0D
02:00004D62 0A
02:00004D63 00
02:00004D64 536F7272792E    	  1931: SRYMSG	DC.B	'Sorry.'
02:00004D6A 0D              	  1932: CLMSG	DC.B	CR,LF,0
02:00004D6B 0A
02:00004D6C 00
02:00004D6D 00              	  1933: 	DC.B	0	<- for aligning on a word boundary
                            	  1934: LSTROM	EQU	*		end of possible ROM area
                            	  1935: *
                            	  1936: * Internal variables follow:
                            	  1937: *
                            	  1938: 	align 2
02:00004D70 00003E58        	  1939: RANPNT	DC.L	START		random number pointer
02:00004D74 00000000        	  1940: INPPTR	DS.L	1		input pointer
02:00004D78 00000000        	  1941: OUTPTR	DS.L	1 	output pointer
02:00004D7C 00000000        	  1942: CURRNT	DS.L	1		Current line pointer
02:00004D80 00000000        	  1943: STKFP		DS.L	1		; saves frame pointer
02:00004D84 00000000        	  1944: STKGOS	DS.L	1		Saves stack pointer in 'GOSUB'
02:00004D88 00000000        	  1945: STKINP	DS.L	1		Saves stack pointer during 'INPUT'
02:00004D8C 00000000        	  1946: LOPVAR	DS.L	1		'FOR' loop save area
02:00004D90 00000000        	  1947: LOPINC	DS.L	3		increment
02:00004D94 *
02:00004D9C 00000000        	  1948: LOPLMT	DS.L	3		limit
02:00004DA0 *
02:00004DA8 00000000        	  1949: LOPLN	DS.L	1		line number
02:00004DAC 00000000        	  1950: LOPPT	DS.L	1		text pointer
02:00004DB0 00000000        	  1951: IRQROUT	DS.L	1
02:00004DB4 00000000        	  1952: TXTUNF	DS.L	1		points to unfilled text area
02:00004DB8 00000000        	  1953: VARBGN	DS.L	1		points to variable area
02:00004DBC 00000000        	  1954: STKLMT	DS.L	1		holds lower limit for stack growth
02:00004DC0 00              	  1955: BUFFER	DS.B	BUFLEN		Keyboard input buffer
02:00004DC1 *
                            	  1956: TXT	EQU	*		Beginning of program area
                            	  1957: ;	END
                            	  1958: 

Source: "boot.asm"
                            	   862: 	include "..\Femtiki\source\kernel\Femtiki.x68"

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     1: 	include "..\Femtiki\const.x68"

Source: "..\Femtiki\const.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: TS_NONE			EQU		0
                            	    38: TS_READY		EQU		1
                            	    39: TS_DEAD			EQU		2
                            	    40: TS_MSGRDY		EQU		4
                            	    41: TS_WAITMSG	EQU		8
                            	    42: TS_TIMEOUT	EQU		16
                            	    43: TS_PREEMPT	EQU		32
                            	    44: TS_RUNNING	EQU		128
                            	    45: 
                            	    46: ; error codes
                            	    47: E_Ok		EQU		$00
                            	    48: E_Arg		EQU		$01
                            	    49: E_Func  EQU    $02
                            	    50: E_BadMbx	EQU		$04
                            	    51: E_QueFull	EQU		$05
                            	    52: E_NoThread	EQU		$06
                            	    53: E_NotAlloc	EQU		$09
                            	    54: E_NoMsg		EQU		$0b
                            	    55: E_Timeout	EQU		$10
                            	    56: E_BadAlarm	EQU		$11
                            	    57: E_NotOwner	EQU		$12
                            	    58: E_QueStrategy EQU		$13
                            	    59: E_DCBInUse	EQU		$19
                            	    60: ; Device driver errors
                            	    61: E_BadDevNum	EQU		$20
                            	    62: E_NoDev		EQU		$21
                            	    63: E_BadDevOp	EQU		$22
                            	    64: E_ReadError	EQU		$23
                            	    65: E_WriteError EQU		$24
                            	    66: E_BadBlockNum	EQU	$25
                            	    67: E_TooManyBlocks	EQU	$26
                            	    68: 
                            	    69: ; resource errors
                            	    70: E_NoMoreMbx	EQU		$40
                            	    71: E_NoMoreMsgBlks	EQU	$41
                            	    72: E_NoMoreAlarmBlks	EQU $44
                            	    73: E_NoMoreTCBs	EQU	$45
                            	    74: E_NoMem		EQU 12
                            	    75: 
                            	    76: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     2: 	include "..\Femtiki\config.x68"

Source: "..\Femtiki\config.x68"
                            	     1: MAX_TID		EQU		4095
                            	     2: NR_TCB		EQU		4096
                            	     3: NTASK     EQU   4096    ; number of threads allowed
                            	     4: LOG_TCBSZ	EQU		8
                            	     5: LOG_PGSZ	EQU		10
                            	     6: LOG_ACBSZ EQU   12
                            	     7: OSPAGES		EQU		16			; pages of memory dedicated to OS
                            	     8: PAGESZ    EQU   16384  	; size of a page of memory
                            	     9: MEMSZ     EQU   32768   ; pages
                            	    10: MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                            	    11: NR_MSG		EQU		21842		; number of messages available
                            	    12: NR_MBX		EQU		9792
                            	    13: 
                            	    14: 
                            	    15: 
                            	    16: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     3: 	include "..\Femtiki\types.x68"

Source: "..\Femtiki\types.x68"
                            	     1: ; Thread Control Block
                            	     2: TCBMagic    EQU		$0000
                            	     3: TCBRegs  		EQU   $0004		; register set storage area
                            	     4: TCBUSP			EQU		$0044
                            	     5: TCBSSP			EQU		$0048
                            	     6: TCBSR				EQU		$004C
                            	     7: TCBPC				EQU		$0050
                            	     8: TCBStatus		EQU		$0054
                            	     9: TCBPriority	EQU		$0055
                            	    10: TCBWaitMbx	EQU		$0056
                            	    11: TCBHasFocus EQU   $005A
                            	    12: TCBStackBot	EQU		$005C
                            	    13: TCBMsgD1		EQU		$0060
                            	    14: TCBMsgD2		EQU		$0064
                            	    15: TCBMsgD3		EQU		$0068
                            	    16: TCBStartTick	EQU	$006C
                            	    17: TCBEndTick	EQU		$0070
                            	    18: TCBTicks		EQU		$0074
                            	    19: TCBException	EQU	$0078
                            	    20: TCBNext			EQU		$007C
                            	    21: TCBPrev			EQU		$0080
                            	    22: TCBAffinity	EQU		$0084
                            	    23: TCBTimeout	EQU		$0088
                            	    24: TCBtid      EQU   $008C
                            	    25: TCBmid      EQU   $0090
                            	    26: TCBappid    EQU   $0094
                            	    27: TCBOpMode   EQU   $0098
                            	    28: TCBMbxNext  EQU   $009C
                            	    29: TCBMbxPrev  EQU   $00A0
                            	    30: TCBThreadNum  EQU   $00A4
                            	    31: TCBAcbNext	EQU		$00A8
                            	    32: TCBAcbPrev	EQU		$00AC
                            	    33: TCBhMailboxes	EQU		$00B0
                            	    34: TCBName			EQU		$00C0
                            	    35: TCB_SIZE		EQU		$0100
                            	    36: 
                            	    37: MBC_MAGIC		equ		0
                            	    38: MBX_OWNER		equ		4		; tid of owning task
                            	    39: MBX_LINK    equ   8
                            	    40: MBX_TQHEAD  equ   12   ; link field for free list shared with task queue head
                            	    41: MBX_TQTAIL  equ   16
                            	    42: MBX_MQHEAD	equ		20
                            	    43: MBX_MQTAIL	equ		24
                            	    44: MBX_SIZE		equ		32
                            	    45: 
                            	    46: MSG_MAGIC   equ   0
                            	    47: MSG_LINK	  equ		4
                            	    48: MSG_RETADR  equ   8
                            	    49: MSG_TGTADR  equ   12
                            	    50: MSG_TYPE    equ   16
                            	    51: MSG_D1		  equ		20
                            	    52: MSG_D2		  equ		24
                            	    53: MSG_D3		  equ		28
                            	    54: MSG_SIZE	  equ		32
                            	    55: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     4: 
                            	     5: 	code
                            	     6: 	even
                            	     7: ;------------------------------------------------------------------------------
                            	     8: ; Initialize the Femtiki OS.
                            	     9: ;------------------------------------------------------------------------------
                            	    10: 
                            	    11: FemtikiInit:
02:00004E10 203C20010000    	    12: 	move.l #tcbs,d0
02:00004E16 4E7B0013        	    13: 	movec d0,tcba
02:00004E1A 7000            	    14: 	moveq #0,d0
02:00004E1C 4E7B0012        	    15: 	movec d0,tr
02:00004E20 7007            	    16: 	moveq #7,d0
02:00004E22 41F900100320    	    17: 	lea readyQ,a0
                            	    18: .clearReadyQ
02:00004E28 4298            	    19: 	clr.l (a0)+
02:00004E2A 51C8FFFC        	    20: 	dbra d0,.clearReadyQ
02:00004E2E 42390010031C    	    21: 	clr.b QueueCycle
02:00004E34 4E7A0013        	    22: 	movec tcba,d0
02:00004E38 2040            	    23: 	move.l d0,a0
02:00004E3A 203C0003FFFF    	    24: 	move.l #TCB_SIZE*NR_TCB/4-1,d0
                            	    25: .clearTCBs
02:00004E40 4298            	    26: 	clr.l (a0)+
02:00004E42 51C8FFFC        	    27: 	dbra d0,.clearTCBs
                            	    28: FemtikiInitIRQ:
02:00004E46 43FA01F2        	    29: 	lea FemtikiTimerIRQ,a1						; Set timer IRQ vector to Femtiki
02:00004E4A 4E7A8801        	    30: 	movec vbr,a0
02:00004E4E 21490078        	    31: 	move.l a1,30*4(a0)								; vector #30
02:00004E52 4E75            	    32: 	rts
                            	    33: 
                            	    34: ;------------------------------------------------------------------------------
                            	    35: ; Operating system call dispatcher.
                            	    36: ; On entry, the task state has been saved including the system stack pointer,
                            	    37: ; in the task control block.
                            	    38: ;------------------------------------------------------------------------------
                            	    39: 
                            	    40: OSCallTable
02:00004E54 0000            	    41: 	dc.w		0
                            	    42: 
                            	    43: 	even
                            	    44: CallOS:
02:00004E56 2F08            	    45: 	move.l	a0,-(a7)
02:00004E58 207900100224    	    46: 	move.l	RunningTCB,a0
02:00004E5E 48E8FFFF0004    	    47: 	movem.l d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,TCBRegs(a0)
02:00004E64 225F            	    48: 	move.l	(a7)+,a1
02:00004E66 21490020        	    49: 	move.l	a1,32(a0)
02:00004E6A 4E7A9800        	    50: 	movec		usp,a1
02:00004E6E 21490044        	    51: 	move.l	a1,TCBUSP(a0)
02:00004E72 301F            	    52: 	move.w	(a7)+,d0					; pop the status register
02:00004E74 3140004C        	    53: 	move.w	d0,TCBSR(a0)			; save in TCB
02:00004E78 225F            	    54: 	move.l	(a7)+,a1					; pop the program counter
02:00004E7A 5489            	    55: 	lea	2(a1),a1							; increment past inline callno argument
02:00004E7C 21490050        	    56: 	move.l	a1,TCBPC(a0)			; save PC in TCB
02:00004E80 214F0048        	    57: 	move.l	a7,TCBSSP(a0)			; finally save SSP
02:00004E84 3029FFFE        	    58: 	move.w	-2(a1),d0					; d0 = call number
02:00004E88 E548            	    59: 	lsl.w		#2,d0							; make into table index
02:00004E8A 43FAFFC8        	    60: 	lea			OSCallTable,a1
02:00004E8E 22710000        	    61: 	move.l	(a1,d0.w),a1
02:00004E92 4E91            	    62: 	jsr			(a1)							; call the OS function
                            	    63: 	; Restore the thread context and return
02:00004E94 207900100224    	    64: 	move.l	RunningTCB,a0
02:00004E9A 2E780048        	    65: 	move.l	TCBSSP,a7
02:00004E9E 2F280050        	    66: 	move.l	TCBPC(a0),-(a7)		; setup the PC and the SR on the stack
02:00004EA2 3F28004C        	    67: 	move.w	TCBSR(a0),-(a7)		; prep for RTE
02:00004EA6 20380044        	    68: 	move.l	TCBUSP,d0					; restore user stack pointer
02:00004EAA 4E7B0800        	    69: 	movec		d0,usp
02:00004EAE 4CE800FF0004    	    70: 	movem.l	TCBRegs(a0),d0/d1/d2/d3/d4/d5/d6/d7
02:00004EB4 4CE87E00002C    	    71: 	movem.l TCBRegs+40(a0),a1/a2/a3/a4/a5/a6
02:00004EBA 20680024        	    72: 	move.l	TCBRegs+32(a0),a0
02:00004EBE 4E73            	    73: 	rte
                            	    74: 
                            	    75: ;------------------------------------------------------------------------------
                            	    76: ; Get a pointer to the currently running TCB.
                            	    77: ;------------------------------------------------------------------------------
                            	    78: 
                            	    79: GetRunningTCBPointer:
02:00004EC0 48E7C000        	    80: 	movem.l d0/d1,-(a7)
02:00004EC4 4E7A0012        	    81: 	movec tr,d0
02:00004EC8 028000000FFF    	    82: 	andi.l #MAX_TID,d0		; limit to # threads
02:00004ECE 4E7A1013        	    83: 	movec tcba,d1
02:00004ED2 E188            	    84: 	lsl.l #8,d0
02:00004ED4 D081            	    85: 	add.l d1,d0
02:00004ED6 2040            	    86: 	move.l d0,a0
02:00004ED8 4CDF0003        	    87: 	movem.l (a7)+,d0/d1
02:00004EDC 4E75            	    88: 	rts
                            	    89: 
                            	    90: ;------------------------------------------------------------------------------
                            	    91: ; Convert a TCB handle into a pointer.
                            	    92: ;------------------------------------------------------------------------------
                            	    93: 
                            	    94: TCBHandleToPointer:
02:00004EDE 2F01            	    95: 	move.l d1,-(a7)
02:00004EE0 028000000FFF    	    96: 	andi.l #MAX_TID,d0		; limit to # threads
02:00004EE6 4E7A1013        	    97: 	movec tcba,d1
02:00004EEA E188            	    98: 	lsl.l #8,d0
02:00004EEC D280            	    99: 	add.l d0,d1
02:00004EEE 2041            	   100: 	move.l d1,a0
02:00004EF0 E088            	   101: 	lsr.l #8,d0						; restore d0
02:00004EF2 221F            	   102: 	move.l (a7)+,d1
02:00004EF4 4E75            	   103: 	rts
                            	   104: 
                            	   105: ;------------------------------------------------------------------------------
                            	   106: ; Convert a TCB pointer into a handle.
                            	   107: ;------------------------------------------------------------------------------
                            	   108: 
                            	   109: PointerToTCBHandle:
02:00004EF6 2F01            	   110: 	move.l d1,-(a7)				; save d1
02:00004EF8 4E7A1013        	   111: 	movec tcba,d1
02:00004EFC 91C1            	   112: 	sub.l d1,a0
02:00004EFE 2008            	   113: 	move.l a0,d0
02:00004F00 E088            	   114: 	lsr.l #8,d0
02:00004F02 221F            	   115: 	move.l (a7)+,d1				; restore d1
02:00004F04 4E75            	   116: 	rts
                            	   117: 
                            	   118: ; ----------------------------------------------------------------------------
                            	   119: ; Select a thread to run. Relatively easy. All that needs to be done is to
                            	   120: ; keep popping the queue until a valid running task is found. There should
                            	   121: ; always be at least one thread in the queue.
                            	   122: ;
                            	   123: ; Modifies:
                            	   124: ;		none
                            	   125: ; Returns:
                            	   126: ;		d0 = handle of the next thread to run
                            	   127: ; ----------------------------------------------------------------------------
                            	   128: 
                            	   129: SelectThreadToRun:
                            	   130: .0001										; keep popping tasks from the readyQ until a valid one
02:00004F06 61000092        	   131: 	bsr	PopReadyQueue			; is found.
02:00004F0A 2048            	   132: 	move.l a0,a0					; tst.l a0
02:00004F0C 670C            	   133: 	beq	.0002
02:00004F0E 0C2800800054    	   134: 	cmpi.b #TS_RUNNING,TCBStatus(a0)	; ensure the thread is to be running
02:00004F14 66F0            	   135: 	bne	.0001													; if not, go get the next thread
02:00004F16 61DE            	   136: 	bsr PointerToTCBHandle
02:00004F18 6012            	   137: 	bra	InsertIntoReadyQueue					; insert thread back into queue
                            	   138: 	; Nothing in queues? There is supposed to be. Add the OS task to the queue.
                            	   139: .0002
02:00004F1A 4E7A8013        	   140: 	movec tcba,a0
02:00004F1E 117C00800054    	   141: 	move.b #TS_RUNNING,TCBStatus(a0)	; flag as RUNNING
02:00004F24 117C00040055    	   142: 	move.b #4,TCBPriority(a0)					; OS has normal priority
02:00004F2A 7000            	   143: 	moveq #0,d0												; fast pointer to handle
                            	   144: 	; fall through to insert
                            	   145: 
                            	   146: ; ----------------------------------------------------------------------------
                            	   147: ; Insert thread into ready queue. The thread is added at the tail of the 
                            	   148: ; queue. The queue is a doubly linked list.
                            	   149: ;
                            	   150: ; Parameters:
                            	   151: ;		d0 = TCB handle
                            	   152: ; Returns:
                            	   153: ;		d0 = TCB handle
                            	   154: ; ----------------------------------------------------------------------------
                            	   155: 
                            	   156: InsertIntoReadyQueue:
02:00004F2C 48E7C0F0        	   157: 	movem.l	d0/d1/a0/a1/a2/a3,-(a7)
02:00004F30 61AC            	   158: 	bsr TCBHandleToPointer
02:00004F32 7025            	   159: 	moveq #37,d0
02:00004F34 7207            	   160: 	moveq #TCB_SEMA,d1				; lock semaphore
02:00004F36 4E4F            	   161: 	trap #15
02:00004F38 20280055        	   162: 	move.l TCBPriority(a0),d0
02:00004F3C 02400007        	   163: 	andi.w #7,d0
02:00004F40 E548            	   164: 	lsl.w	#2,d0
02:00004F42 43F900100320    	   165: 	lea	readyQ,a1
02:00004F48 26712000        	   166: 	move.l (a1,d2.w),a3
02:00004F4C 6720            	   167: 	beq .qempty
02:00004F4E 246B0080        	   168: 	move.l TCBPrev(a3),a2
02:00004F52 214B007C        	   169: 	move.l a3,TCBNext(a0)
02:00004F56 214A0080        	   170: 	move.l a2,TCBPrev(a0)
02:00004F5A 206A007C        	   171: 	move.l TCBNext(a2),a0
02:00004F5E 206B0080        	   172: 	move.l TCBPrev(a3),a0
                            	   173: .xit:
02:00004F62 7026            	   174: 	moveq #38,d0
02:00004F64 7207            	   175: 	moveq #TCB_SEMA,d1				; unlock semaphore
02:00004F66 4E4F            	   176: 	trap #15
02:00004F68 4CDF0F03        	   177: 	movem.l	(a7)+,d0/d1/a0/a1/a2/a3
02:00004F6C 4E75            	   178: 	rts
                            	   179: .qempty
02:00004F6E 23880000        	   180: 	move.l a0,(a1,d0.w)
02:00004F72 2148007C        	   181: 	move.l a0,TCBNext(a0)
02:00004F76 21480080        	   182: 	move.l a0,TCBPrev(a0)
02:00004F7A 60E6            	   183: 	bra .xit
                            	   184: 
                            	   185: ; ----------------------------------------------------------------------------
                            	   186: ; Remove a thread from the ready queue. Simple. Just mark the thread as not
                            	   187: ; running and it will be removed automatically the next time it is switched
                            	   188: ; to.
                            	   189: ;
                            	   190: ; Parameters:
                            	   191: ;		d0 = TCB handle
                            	   192: ; Returns:
                            	   193: ;		none
                            	   194: ; ----------------------------------------------------------------------------
                            	   195: 
                            	   196: RemoveFromReadyQueue:
02:00004F7C 2F08            	   197: 	move.l a0,-(a7)											; save a0
02:00004F7E C0BC00000FFF    	   198: 	and.l #MAX_TID,d0										; limit to # of threads
02:00004F84 6100FF58        	   199: 	bsr TCBHandleToPointer							; a0 = pointer to TCB
02:00004F88 0228007F0054    	   200: 	andi.b #$7F,TCBStatus(a0)						; set status no longer running
02:00004F8E 205F            	   201: 	move.l (a7)+,a0											; restore a0
02:00004F90 4E75            	   202: 	rts	
                            	   203: 
                            	   204: ; ----------------------------------------------------------------------------
                            	   205: ; Register Usage
                            	   206: ;		d0 = queue counter
                            	   207: ;		d1 = index into list of queues
                            	   208: ;		a0 = pointer to list of queues
                            	   209: ;		a3 = pointer to TCB at head of queue
                            	   210: ; Parameters:
                            	   211: ;		none
                            	   212: ; Returns:
                            	   213: ;		a0 = pointer to TCB, NULL if none on list
                            	   214: ; ----------------------------------------------------------------------------
                            	   215: 
                            	   216: StartQ
02:00004F92 01              	   217: 	dc.b 1,2,3,4,1,5,6,7
02:00004F93 02
02:00004F94 03
02:00004F95 04
02:00004F96 01
02:00004F97 05
02:00004F98 06
02:00004F99 07
                            	   218: 
                            	   219: 	even
                            	   220: PopReadyQueue:
02:00004F9A 48E7C070        	   221: 	movem.l	d0/d1/a1/a2/a3,-(a7)
02:00004F9E 7025            	   222: 	moveq #37,d0
02:00004FA0 7207            	   223: 	moveq #TCB_SEMA,d1			; lock semaphore
02:00004FA2 4E4F            	   224: 	trap #15
02:00004FA4 7007            	   225: 	moveq #7,d0
                            	   226: 	; One in four tries pick a different priority to start searching from. 
02:00004FA6 12390010031C    	   227: 	move.b QueueCycle,d1		; increment Queue cycle counter
02:00004FAC 5201            	   228: 	addi.b #1,d1
02:00004FAE 02010007        	   229: 	andi.b #7,d1
02:00004FB2 13C10010031C    	   230: 	move.b d1,QueueCycle
02:00004FB8 6612            	   231: 	bne	.0001
02:00004FBA 43FAFFD6        	   232: 	lea StartQ,a1
02:00004FBE 4881            	   233: 	ext.w d1
02:00004FC0 12311000        	   234: 	move.b (a1,d1.w),d1
02:00004FC4 02410007        	   235: 	andi.w #7,d1						; limit to number of queues
02:00004FC8 E549            	   236: 	lsl.w #2,d1							; make into lword index
02:00004FCA 6002            	   237: 	bra .0002
                            	   238: .0001
02:00004FCC 7200            	   239: 	moveq #0,d1							; start at Queue #0
                            	   240: .0002
02:00004FCE 41F900100320    	   241: 	lea readyQ,a0						; a0 = pointer to list of ready queues
02:00004FD4 26701000        	   242: 	move.l (a0,d1.w),a3			; a3 = head of list
02:00004FD8 6732            	   243: 	beq .nextQ							; anything on list?, if not go next queue
02:00004FDA 226B007C        	   244: 	move.l TCBNext(a3),a1		; remove head of list from list
02:00004FDE B7C9            	   245: 	cmpa.l a1,a3						; removing last TCB?
02:00004FE0 6726            	   246: 	beq .removeLast
02:00004FE2 246B0080        	   247: 	move.l TCBPrev(a3),a2
02:00004FE6 24690080        	   248: 	move.l TCBPrev(a1),a2
02:00004FEA 226A007C        	   249: 	move.l TCBNext(a2),a1
                            	   250: .0003
02:00004FEE 21891000        	   251: 	move.l	a1,(a0,d1.w)		; reset head of list to next
                            	   252: .0004
02:00004FF2 204B            	   253: 	move.l a3,a0						; a0 = old head of list (returned)
02:00004FF4 2148007C        	   254: 	move.l a0,TCBNext(a0)		; point links back to self
02:00004FF8 21480080        	   255: 	move.l a0,TCBPrev(a0)
02:00004FFC 7026            	   256: 	moveq #38,d0
02:00004FFE 7207            	   257: 	moveq #TCB_SEMA,d1			; unlock semaphore
02:00005000 4E4F            	   258: 	trap #15
02:00005002 4CDF0E03        	   259: 	movem.l	(a7)+,d0/d1/a1/a2/a3
02:00005006 4E75            	   260: 	rts
                            	   261: .removeLast
02:00005008 93C9            	   262: 	move.l #0,a1						; set head to zero when removing last
02:0000500A 60E2            	   263: 	bra .0003
                            	   264: .nextQ
02:0000500C 5841            	   265: 	addi.w #4,d1						; increment queue number by lword
02:0000500E 0241001C        	   266: 	andi.w #$1C,d1					; limit to number of queues
02:00005012 51C8FFBA        	   267: 	dbra d0,.0002						; go back and check the next queue
02:00005016 60DA            	   268: 	bra	.0004								; return NULL pointer if nothing in any queue
                            	   269: 
                            	   270: ; ----------------------------------------------------------------------------
                            	   271: ; Update the IRQ live indicator on screen.
                            	   272: ; ----------------------------------------------------------------------------
                            	   273: 
                            	   274: UpdateIRQLive:
02:00005018 227900040004    	   275: 	move.l TextScr,a1					; a1 = screen address
02:0000501E 2411            	   276: 	move.l (a1),d2
02:00005020 E15A            	   277: 	rol.w	#8,d2								; reverse byte order of d2
02:00005022 4842            	   278: 	swap d2
02:00005024 E15A            	   279: 	rol.w	#8,d2
02:00005026 06010030        	   280: 	addi.b #'0',d1						; binary to ascii core number
02:0000502A D202            	   281: 	add.b	d2,d1
02:0000502C E159            	   282: 	rol.w	#8,d1								; put bytes back in order
02:0000502E 4841            	   283: 	swap d1
02:00005030 E159            	   284: 	rol.w	#8,d1
02:00005032 23410004        	   285: 	move.l d1,4(a1)						; update onscreen IRQ flag
02:00005036 5291            	   286: 	addi.l #1,(a1)						; flashy colors
02:00005038 4E75            	   287: 	rts
                            	   288: 
                            	   289: ; ----------------------------------------------------------------------------
                            	   290: ; Femtiki IRQ service routine. This is where a thread switch can occur so,
                            	   291: ; the thread context is saved and restored.
                            	   292: ; ----------------------------------------------------------------------------
                            	   293: 
                            	   294: FemtikiTimerIRQ:
02:0000503A 2F00            	   295: 	move.l d0,-(a7)
02:0000503C 2F08            	   296: 	move.l a0,-(a7)
02:0000503E 4E7A0012        	   297: 	movec tr,d0
02:00005042 6100FE9A        	   298: 	bsr TCBHandleToPointer				; a0 = pointer to TCB
02:00005046 48D0FFFF        	   299: 	movem.l #$FFFF,(a0)						; save all registers
02:0000504A 201F            	   300: 	move.l (a7)+,d0
02:0000504C 21400020        	   301: 	move.l d0,32(a0)							; save original a0 value
02:00005050 201F            	   302: 	move.l (a7)+,d0
02:00005052 2080            	   303: 	move.l d0,(a0)								; save original d0 value
02:00005054 2E7C00040BFC    	   304: 	move.l #TimerStack,a7					; reset stack pointer
02:0000505A 4E7A1FE0        	   305: 	movec	coreno,d1								; d1 = core number
02:0000505E 0C010002        	   306: 	cmpi.b #2,d1
02:00005062 660A            	   307: 	bne.s	.0002
02:00005064 23FC1D000000FD09	   308: 	move.l #$1D000000,PLIC+$14		; reset edge sense circuit
02:0000506C 0014
                            	   309: .0002
02:0000506E 61A8            	   310: 	bsr UpdateIRQLive							; Update IRQ live indicator
                            	   311: ;	bsr ReceiveMsg								; Check for RPC
02:00005070 6100FE4E        	   312: 	bsr GetRunningTCBPointer			; a0 = pointer to running TCB
02:00005074 4E7A0FF0        	   313: 	movec tick,d0									; Update time accounting
02:00005078 21400070        	   314: 	move.l d0,TCBEndTick(a0)			; compute number of ticks thread was running
02:0000507C 90A8006C        	   315: 	sub.l	TCBStartTick(a0),d0
02:00005080 D1A80074        	   316: 	add.l	d0,TCBTicks(a0)					; add to cumulative ticks
02:00005084 117C00200054    	   317: 	move.b #TS_PREEMPT,TCBStatus(a0)	; set thread status to PREEMPT
02:0000508A 6100FE7A        	   318: 	bsr	SelectThreadToRun					; d0 = TCB handle
02:0000508E 4E7B0012        	   319: 	movec d0,tr										; set running thread number in tr
02:00005092 6100FE2C        	   320: 	bsr GetRunningTCBPointer			; a0 = pointer to TCB
02:00005096 117C00800054    	   321: 	move.b #TS_RUNNING,TCBStatus(a0)	; set thread status to RUNNING
02:0000509C 4E7A0FF0        	   322: 	movec	tick,d0
02:000050A0 2140006C        	   323: 	move.l d0,TCBStartTick(a0)		; record starting tick
02:000050A4 4CD0FFFF        	   324: 	movem.l (a0),#$FFFF						; restore all registers
02:000050A8 4E73            	   325: 	rte														; and return
                            	   326: 

Source: "boot.asm"
                            	   863: 
                            	   864: ; -----------------------------------------------------------------------------
                            	   865: ; Gets the screen color in d0 and d1.
                            	   866: ; -----------------------------------------------------------------------------
                            	   867: 
                            	   868: get_screen_color:
02:000050AA 203900040084    	   869: 	move.l	fgColor,d0			; get foreground color
02:000050B0 EB80            	   870: 	asl.l		#5,d0						; shift into position
02:000050B2 008040000000    	   871: 	ori.l		#$40000000,d0		; set priority
02:000050B8 223900040088    	   872: 	move.l	bkColor,d1
02:000050BE E089            	   873: 	lsr.l		#8,d1
02:000050C0 E089            	   874: 	lsr.l		#8,d1
02:000050C2 02810000001F    	   875: 	andi.l	#31,d1					; mask off extra bits
02:000050C8 8081            	   876: 	or.l		d1,d0						; set background color bits in upper long word
02:000050CA 223900040088    	   877: 	move.l	bkColor,d1			; get background color
02:000050D0 E181            	   878: 	asl.l		#8,d1						; shift into position for display ram
02:000050D2 E181            	   879: 	asl.l		#8,d1
02:000050D4 4E75            	   880: 	rts
                            	   881: 
                            	   882: ; -----------------------------------------------------------------------------
                            	   883: ; -----------------------------------------------------------------------------
                            	   884: 
                            	   885: get_screen_address:
02:000050D6 207900040004    	   886: 	move.l	TextScr,a0
02:000050DC 4E75            	   887: 	rts
                            	   888: 	
                            	   889: ; -----------------------------------------------------------------------------
                            	   890: ; -----------------------------------------------------------------------------
                            	   891: 
                            	   892: clear_screen:
02:000050DE 48E7E080        	   893: 	movem.l	d0/d1/d2/a0,-(a7)
02:000050E2 4E7A0FE0        	   894: 	movec		coreno,d0
02:000050E6 4840            	   895: 	swap		d0	
02:000050E8 7205            	   896: 	moveq		#SCREEN_SEMA,d1
02:000050EA 6100B154        	   897: 	bsr			LockSemaphore
02:000050EE 61E6            	   898: 	bsr			get_screen_address	; a0 = pointer to screen area
02:000050F0 10390004008C    	   899: 	move.b	TextRows,d0					; d0 = rows
02:000050F6 14390004008D    	   900: 	move.b	TextCols,d2					; d2 = cols
02:000050FC 4880            	   901: 	ext.w		d0									; convert to word
02:000050FE 4882            	   902: 	ext.w		d2									; convert to word
02:00005100 C4C0            	   903: 	mulu		d0,d2								; d2 = number of character cells to clear
02:00005102 61A6            	   904: 	bsr			get_screen_color		; get the color bits
02:00005104 00410020        	   905: 	ori.w		#32,d1							; load space character
02:00005108 E159            	   906: 	rol.w		#8,d1								; swap endian, text controller expects little endian
02:0000510A 4841            	   907: 	swap		d1
02:0000510C E159            	   908: 	rol.w		#8,d1
02:0000510E E158            	   909: 	rol.w		#8,d0								; swap endian
02:00005110 4840            	   910: 	swap		d0
02:00005112 E158            	   911: 	rol.w		#8,d0
                            	   912: loop3:
02:00005114 20C1            	   913: 	move.l	d1,(a0)+						; copy char plus bkcolor to cell
02:00005116 20C0            	   914: 	move.l	d0,(a0)+					; copy fgcolor to cell
02:00005118 51CAFFFA        	   915: 	dbra		d2,loop3
02:0000511C 4E7A0FE0        	   916: 	movec		coreno,d0
02:00005120 4840            	   917: 	swap		d0	
02:00005122 7205            	   918: 	moveq		#SCREEN_SEMA,d1
02:00005124 6100B156        	   919: 	bsr			UnlockSemaphore
02:00005128 4CDF0107        	   920: 	movem.l	(a7)+,d0/d1/d2/a0
02:0000512C 4E75            	   921: 	rts
                            	   922: 
                            	   923: CRLF:
02:0000512E 2F01            	   924: 	move.l	d1,-(a7)
02:00005130 123C000D        	   925: 	move.b	#13,d1
02:00005134 6142            	   926: 	bsr			DisplayChar
02:00005136 123C000A        	   927: 	move.b	#10,d1
02:0000513A 613C            	   928: 	bsr			DisplayChar
02:0000513C 221F            	   929: 	move.l	(a7)+,d1
02:0000513E 4E75            	   930: 	rts
                            	   931: 
                            	   932: ;------------------------------------------------------------------------------
                            	   933: ;------------------------------------------------------------------------------
                            	   934: 
                            	   935: UpdateTextPos:
02:00005140 103900040000    	   936: 	move.b	CursorRow,d0		; compute screen location
02:00005146 0240007F        	   937: 	andi.w	#$7f,d0
02:0000514A 14390004008D    	   938: 	move.b	TextCols,d2
02:00005150 4882            	   939: 	ext.w		d2
02:00005152 C0C2            	   940: 	mulu.w	d2,d0
02:00005154 2600            	   941: 	move.l	d0,d3
02:00005156 143900040001    	   942: 	move.b	CursorCol,d2
02:0000515C 024200FF        	   943: 	andi.w	#$ff,d2
02:00005160 D042            	   944: 	add.w		d2,d0
02:00005162 33C000040002    	   945: 	move.w	d0,TextPos			; save cursor pos
02:00005168 4E75            	   946: 	rts
                            	   947: 
                            	   948: ;------------------------------------------------------------------------------
                            	   949: ; Calculate screen memory location from CursorRow,CursorCol.
                            	   950: ; Destroys d0,d2,a0
                            	   951: ;------------------------------------------------------------------------------
                            	   952: 
                            	   953: CalcScreenLoc:
02:0000516A 61D4            	   954: 	bsr			UpdateTextPos
02:0000516C 48C0            	   955: 	ext.l		d0								; make it into a long
02:0000516E E780            	   956: 	asl.l		#3,d0							; 8 bytes per char
02:00005170 6100FF64        	   957: 	bsr			get_screen_address
02:00005174 D1C0            	   958: 	add.l		d0,a0							; a0 = screen location
02:00005176 4E75            	   959: 	rts
                            	   960: 
                            	   961: ;------------------------------------------------------------------------------
                            	   962: ; Display a character on the screen
                            	   963: ; d1.b = char to display
                            	   964: ;------------------------------------------------------------------------------
                            	   965: 
                            	   966: DisplayChar:
02:00005178 48E77000        	   967: 	movem.l	d1/d2/d3,-(a7)
02:0000517C 4E7A2FE0        	   968: 	movec		coreno,d2
02:00005180 0C020002        	   969: 	cmpi.b	#2,d2
                            	   970: ;	bne.s		.0001
                            	   971: ;	bsr			SerialPutChar
                            	   972: .0001:
02:00005184 0281000000FF    	   973: 	andi.l	#$ff,d1				; zero out upper bytes of d1
02:0000518A 0C01000D        	   974: 	cmpi.b	#13,d1				; carriage return ?
02:0000518E 6610            	   975: 	bne			dccr
02:00005190 423900040001    	   976: 	clr.b		CursorCol			; just set cursor column to zero on a CR
                            	   977: dcx14:
02:00005196 610002AE        	   978: 	bsr			SyncCursor		; set position in text controller
                            	   979: dcx7:
02:0000519A 4CDF000E        	   980: 	movem.l	(a7)+,d1/d2/d3
02:0000519E 4E75            	   981: 	rts
                            	   982: dccr:
02:000051A0 0C010091        	   983: 	cmpi.b	#$91,d1			; cursor right ?
02:000051A4 6618            	   984: 	bne.s   dcx6
02:000051A6 14390004008D    	   985: 	move.b	TextCols,d2
02:000051AC 5302            	   986: 	sub.b		#1,d2
02:000051AE 943900040001    	   987: 	sub.b		CursorCol,d2
02:000051B4 67E4            	   988: 	beq.s		dcx7
02:000051B6 523900040001    	   989: 	addi.b	#1,CursorCol
02:000051BC 60D8            	   990: 	bra.s		dcx14
                            	   991: dcx6:
02:000051BE 0C010090        	   992: 	cmpi.b	#$90,d1			; cursor up ?
02:000051C2 6610            	   993: 	bne.s		dcx8
02:000051C4 4A3900040000    	   994: 	cmpi.b	#0,CursorRow
02:000051CA 67CE            	   995: 	beq.s		dcx7
02:000051CC 533900040000    	   996: 	subi.b	#1,CursorRow
02:000051D2 60C2            	   997: 	bra.s		dcx14
                            	   998: dcx8:
02:000051D4 0C010093        	   999: 	cmpi.b	#$93,d1			; cursor left?
02:000051D8 6610            	  1000: 	bne.s		dcx9
02:000051DA 4A3900040001    	  1001: 	cmpi.b	#0,CursorCol
02:000051E0 67B8            	  1002: 	beq.s		dcx7
02:000051E2 533900040001    	  1003: 	subi.b	#1,CursorCol
02:000051E8 60AC            	  1004: 	bra.s		dcx14
                            	  1005: dcx9:
02:000051EA 0C010092        	  1006: 	cmpi.b	#$92,d1			; cursor down ?
02:000051EE 6618            	  1007: 	bne.s		dcx10
02:000051F0 14390004008C    	  1008: 	move.b	TextRows,d2
02:000051F6 5302            	  1009: 	sub.b		#1,d2
02:000051F8 B43900040000    	  1010: 	cmp.b		CursorRow,d2
02:000051FE 679A            	  1011: 	beq.s		dcx7
02:00005200 523900040000    	  1012: 	addi.b	#1,CursorRow
02:00005206 608E            	  1013: 	bra.s		dcx14
                            	  1014: dcx10:
02:00005208 0C010094        	  1015: 	cmpi.b	#$94,d1			; cursor home ?
02:0000520C 661C            	  1016: 	bne.s		dcx11
02:0000520E 4A3900040001    	  1017: 	cmpi.b	#0,CursorCol
02:00005214 670A            	  1018: 	beq.s		dcx12
02:00005216 423900040001    	  1019: 	clr.b		CursorCol
02:0000521C 6000FF78        	  1020: 	bra			dcx14
                            	  1021: dcx12:
02:00005220 423900040000    	  1022: 	clr.b		CursorRow
02:00005226 6000FF6E        	  1023: 	bra			dcx14
                            	  1024: dcx11:
02:0000522A 48E7E080        	  1025: 	movem.l	d0/d1/d2/a0,-(a7)
02:0000522E 0C010099        	  1026: 	cmpi.b	#$99,d1			; delete ?
02:00005232 675C            	  1027: 	beq.s		doDelete
02:00005234 0C010008        	  1028: 	cmpi.b	#CTRLH,d1			; backspace ?
02:00005238 6748            	  1029: 	beq.s   doBackspace
02:0000523A 0C010018        	  1030: 	cmpi.b	#CTRLX,d1			; delete line ?
02:0000523E 6700008C        	  1031: 	beq			doCtrlX
02:00005242 0C01000A        	  1032: 	cmpi.b	#10,d1		; linefeed ?
02:00005246 6728            	  1033: 	beq.s		dclf
                            	  1034: 
                            	  1035: 	; regular char
02:00005248 6100FF20        	  1036: 	bsr			CalcScreenLoc	; a0 = screen location
02:0000524C 2401            	  1037: 	move.l	d1,d2					; d2 = char
02:0000524E 6100FE5A        	  1038: 	bsr			get_screen_color	; d0,d1 = color
02:00005252 8282            	  1039: 	or.l		d2,d1					; d1 = char + color
02:00005254 E159            	  1040: 	rol.w		#8,d1					; text controller expects little endian data
02:00005256 4841            	  1041: 	swap		d1
02:00005258 E159            	  1042: 	rol.w		#8,d1
02:0000525A 2081            	  1043: 	move.l	d1,(a0)
02:0000525C E158            	  1044: 	rol.w		#8,d0					; swap bytes
02:0000525E 4840            	  1045: 	swap		d0						; swap halfs
02:00005260 E158            	  1046: 	rol.w		#8,d0					; swap remaining bytes
02:00005262 21400004        	  1047: 	move.l	d0,4(a0)
02:00005266 61000088        	  1048: 	bsr			IncCursorPos
02:0000526A 610001DA        	  1049: 	bsr			SyncCursor
02:0000526E 6008            	  1050: 	bra			dcx4
                            	  1051: dclf:
02:00005270 6100009E        	  1052: 	bsr			IncCursorRow
                            	  1053: dcx16:
02:00005274 610001D0        	  1054: 	bsr			SyncCursor
                            	  1055: dcx4:
02:00005278 4CDF0107        	  1056: 	movem.l	(a7)+,d0/d1/d2/a0		; get back a0
02:0000527C 4CDF000E        	  1057: 	movem.l	(a7)+,d1/d2/d3
02:00005280 4E75            	  1058: 	rts
                            	  1059: 
                            	  1060: 	;---------------------------
                            	  1061: 	; CTRL-H: backspace
                            	  1062: 	;---------------------------
                            	  1063: doBackspace:
02:00005282 4A3900040001    	  1064: 	cmpi.b	#0,CursorCol		; if already at start of line
02:00005288 67EE            	  1065: 	beq.s   dcx4						; nothing to do
02:0000528A 533900040001    	  1066: 	subi.b	#1,CursorCol		; decrement column
                            	  1067: 
                            	  1068: 	;---------------------------
                            	  1069: 	; Delete key
                            	  1070: 	;---------------------------
                            	  1071: doDelete:
02:00005290 48E7C080        	  1072: 	movem.l	d0/d1/a0,-(a7)	; save off screen location
02:00005294 6100FED4        	  1073: 	bsr		  CalcScreenLoc		; a0 = screen location
02:00005298 103900040001    	  1074: 	move.b	CursorCol,d0
                            	  1075: .0001:
02:0000529E 20A80008        	  1076: 	move.l	8(a0),(a0)		; pull remaining characters on line over 1
02:000052A2 2168000C0004    	  1077: 	move.l	12(a0),4(a0)	; pull remaining characters on line over 1
02:000052A8 5088            	  1078: 	lea			8(a0),a0
02:000052AA 5200            	  1079: 	addi.b	#1,d0
02:000052AC B0390004008D    	  1080: 	cmp.b		TextCols,d0
02:000052B2 65EA            	  1081: 	blo.s		.0001
02:000052B4 6100FDF4        	  1082: 	bsr			get_screen_color
02:000052B8 323C0020        	  1083: 	move.w	#' ',d1				; terminate line with a space
02:000052BC E159            	  1084: 	rol.w		#8,d1
02:000052BE 4841            	  1085: 	swap		d1
02:000052C0 E159            	  1086: 	rol.w		#8,d1
02:000052C2 2141FFF8        	  1087: 	move.l	d1,-8(a0)
02:000052C6 4CDF0103        	  1088: 	movem.l	(a7)+,d0/d1/a0
02:000052CA 60A8            	  1089: 	bra.s		dcx16				; finished
                            	  1090: 
                            	  1091: 	;---------------------------
                            	  1092: 	; CTRL-X: erase line
                            	  1093: 	;---------------------------
                            	  1094: doCtrlX:
02:000052CC 423900040001    	  1095: 	clr.b		CursorCol			; Reset cursor to start of line
02:000052D2 10390004008D    	  1096: 	move.b	TextCols,d0			; and display TextCols number of spaces
02:000052D8 4880            	  1097: 	ext.w		d0
02:000052DA 48C0            	  1098: 	ext.l		d0
02:000052DC 123C0020        	  1099: 	move.b	#' ',d1				; d1 = space char
                            	  1100: .0001:
                            	  1101: 	; DisplayChar is called recursively here
                            	  1102: 	; It's safe to do because we know it won't recurse again due to the
                            	  1103: 	; fact we know the character being displayed is a space char
02:000052E0 6100FE96        	  1104: 	bsr		DisplayChar			
02:000052E4 5340            	  1105: 	subq	#1,d0
02:000052E6 66F8            	  1106: 	bne.s	.0001
02:000052E8 423900040001    	  1107: 	clr.b	CursorCol			; now really go back to start of line
02:000052EE 6084            	  1108: 	bra.s	dcx16				; we're done
                            	  1109: 
                            	  1110: ;------------------------------------------------------------------------------
                            	  1111: ; Increment the cursor position, scroll the screen if needed.
                            	  1112: ;------------------------------------------------------------------------------
                            	  1113: 
                            	  1114: IncCursorPos:
02:000052F0 527900040002    	  1115: 	addi.w	#1,TextCurpos
02:000052F6 523900040001    	  1116: 	addi.b	#1,CursorCol
02:000052FC 10390004008D    	  1117: 	move.b	TextCols,d0
02:00005302 B03900040001    	  1118: 	cmp.b		CursorCol,d0
02:00005308 6438            	  1119: 	bhs.s		icc1
02:0000530A 423900040001    	  1120: 	clr.b		CursorCol
                            	  1121: IncCursorRow:
02:00005310 523900040000    	  1122: 	addi.b	#1,CursorRow
02:00005316 10390004008C    	  1123: 	move.b	TextRows,d0
02:0000531C B03900040000    	  1124: 	cmp.b		CursorRow,d0
02:00005322 621E            	  1125: 	bhi.s		icc1
02:00005324 10390004008C    	  1126: 	move.b	TextRows,d0
02:0000532A 13C000040000    	  1127: 	move.b	d0,CursorRow		; in case CursorRow is way over
02:00005330 533900040000    	  1128: 	subi.b	#1,CursorRow
02:00005336 4880            	  1129: 	ext.w		d0
02:00005338 D040            	  1130: 	asl.w		#1,d0
02:0000533A 917900040002    	  1131: 	sub.w		d0,TextCurpos
02:00005340 6102            	  1132: 	bsr			ScrollUp
                            	  1133: icc1:
02:00005342 4E75            	  1134: 	rts
                            	  1135: 
                            	  1136: ;------------------------------------------------------------------------------
                            	  1137: ; Scroll screen up.
                            	  1138: ;------------------------------------------------------------------------------
                            	  1139: 
                            	  1140: ScrollUp:
02:00005344 48E7C084        	  1141: 	movem.l	d0/d1/a0/a5,-(a7)		; save off some regs
02:00005348 4E7A0FE0        	  1142: 	movec		coreno,d0
02:0000534C 4840            	  1143: 	swap		d0	
02:0000534E 7205            	  1144: 	moveq		#SCREEN_SEMA,d1
02:00005350 6100AEEE        	  1145: 	bsr			LockSemaphore
02:00005354 6100FD80        	  1146: 	bsr			get_screen_address
02:00005358 2A48            	  1147: 	move.l	a0,a5								; a5 = pointer to text screen
                            	  1148: .0003:								
02:0000535A 10390004008D    	  1149: 	move.b	TextCols,d0					; d0 = columns
02:00005360 12390004008C    	  1150: 	move.b	TextRows,d1					; d1 = rows
02:00005366 4880            	  1151: 	ext.w		d0									; make cols into a word value
02:00005368 4881            	  1152: 	ext.w		d1									; make rows into a word value
02:0000536A E740            	  1153: 	asl.w		#3,d0								; make into cell index
02:0000536C 41F50000        	  1154: 	lea			0(a5,d0.w),a0				; a0 = pointer to second row of text screen
02:00005370 E648            	  1155: 	lsr.w		#3,d0								; get back d0
02:00005372 5341            	  1156: 	subq		#1,d1								; number of rows-1
02:00005374 C0C1            	  1157: 	mulu		d1,d0								; d0 = count of characters to move
                            	  1158: .0001:
02:00005376 2AD8            	  1159: 	move.l	(a0)+,(a5)+					; each char is 64 bits
02:00005378 2AD8            	  1160: 	move.l	(a0)+,(a5)+	
02:0000537A 51C8FFFA        	  1161: 	dbra		d0,.0001
02:0000537E 4E7A0FE0        	  1162: 	movec		coreno,d0
02:00005382 4840            	  1163: 	swap		d0	
02:00005384 7205            	  1164: 	moveq		#SCREEN_SEMA,d1
02:00005386 6100AEF4        	  1165: 	bsr			UnlockSemaphore
02:0000538A 4CDF2103        	  1166: 	movem.l	(a7)+,d0/d1/a0/a5
                            	  1167: 	; Fall through into blanking out last line
                            	  1168: 
                            	  1169: ;------------------------------------------------------------------------------
                            	  1170: ; Blank out the last line on the screen.
                            	  1171: ;------------------------------------------------------------------------------
                            	  1172: 
                            	  1173: BlankLastLine:
02:0000538E 48E7E080        	  1174: 	movem.l	d0/d1/d2/a0,-(a7)
02:00005392 4E7A0FE0        	  1175: 	movec		coreno,d0
02:00005396 4840            	  1176: 	swap		d0	
02:00005398 7205            	  1177: 	moveq		#SCREEN_SEMA,d1
02:0000539A 6100AEA4        	  1178: 	bsr			LockSemaphore
02:0000539E 6100FD36        	  1179: 	bsr			get_screen_address
02:000053A2 10390004008C    	  1180: 	move.b	TextRows,d0					; d0 = rows
02:000053A8 12390004008D    	  1181: 	move.b	TextCols,d1					; d1 = columns
02:000053AE 4880            	  1182: 	ext.w		d0
02:000053B0 4881            	  1183: 	ext.w		d1
02:000053B2 5340            	  1184: 	subq		#1,d0								; last row = #rows-1
02:000053B4 C0C1            	  1185: 	mulu		d1,d0								; d0 = index of last line
02:000053B6 E748            	  1186: 	lsl.w		#3,d0								; *8 bytes per char
02:000053B8 41F00000        	  1187: 	lea			(a0,d0.w),a0				; point a0 to last row
02:000053BC 14390004008D    	  1188: 	move.b	TextCols,d2					; number of text cells to clear
02:000053C2 4882            	  1189: 	ext.w		d2
02:000053C4 5342            	  1190: 	subi.w	#1,d2								; count must be one less than desired
02:000053C6 6100FCE2        	  1191: 	bsr			get_screen_color		; d0,d1 = screen color
02:000053CA 323C0020        	  1192: 	move.w	#32,d1							; set the character for display in low 16 bits
02:000053CE 61001AE4        	  1193: 	bsr			rbo									; reverse the byte order
02:000053D2 E158            	  1194: 	rol.w		#8,d0
02:000053D4 4840            	  1195: 	swap		d0
02:000053D6 E158            	  1196: 	rol.w		#8,d0
                            	  1197: .0001:
02:000053D8 20C0            	  1198: 	move.l	d0,(a0)+
02:000053DA 20C1            	  1199: 	move.l	d1,(a0)+
02:000053DC 51CAFFFA        	  1200: 	dbra		d2,.0001
02:000053E0 4E7A0FE0        	  1201: 	movec		coreno,d0
02:000053E4 4840            	  1202: 	swap		d0	
02:000053E6 7205            	  1203: 	moveq		#SCREEN_SEMA,d1
02:000053E8 6100AE92        	  1204: 	bsr			UnlockSemaphore
02:000053EC 4CDF0107        	  1205: 	movem.l	(a7)+,d0/d1/d2/a0
02:000053F0 4E75            	  1206: 	rts
                            	  1207: 
                            	  1208: ;------------------------------------------------------------------------------
                            	  1209: ; Display a string on the screen.
                            	  1210: ;------------------------------------------------------------------------------
                            	  1211: 
                            	  1212: DisplayString:
02:000053F2 48E7C040        	  1213: 	movem.l	d0/d1/a1,-(a7)
                            	  1214: dspj1:
02:000053F6 7200            	  1215: 	clr.l		d1						; clear upper bits of d1
02:000053F8 1219            	  1216: 	move.b	(a1)+,d1			; move string char into d1
02:000053FA 6706            	  1217: 	beq.s		dsret					; is it end of string ?
02:000053FC 6100FD7A        	  1218: 	bsr			DisplayChar		; display character
02:00005400 60F4            	  1219: 	bra.s		dspj1					; go back for next character
                            	  1220: dsret:
02:00005402 4CDF0203        	  1221: 	movem.l	(a7)+,d0/d1/a1
02:00005406 4E75            	  1222: 	rts
                            	  1223: 
                            	  1224: ;------------------------------------------------------------------------------
                            	  1225: ; Display a string on the screen followed by carriage return / linefeed.
                            	  1226: ;------------------------------------------------------------------------------
                            	  1227: 
                            	  1228: DisplayStringCRLF:
02:00005408 61E8            	  1229: 	bsr		DisplayString
02:0000540A 6000FD22        	  1230: 	bra		CRLF
                            	  1231: 
                            	  1232: ;------------------------------------------------------------------------------
                            	  1233: ; Display a string on the screen limited to 255 chars max.
                            	  1234: ;------------------------------------------------------------------------------
                            	  1235: 
                            	  1236: DisplayStringLimited:
02:0000540E 48E7E040        	  1237: 	movem.l	d0/d1/d2/a1,-(a7)
02:00005412 3401            	  1238: 	move.w	d1,d2					; d2 = max count
02:00005414 024200FF        	  1239: 	andi.w	#$00FF,d2			; limit to 255 chars
02:00005418 600A            	  1240: 	bra.s		.0003					; enter loop at bottom
                            	  1241: .0001:
02:0000541A 7200            	  1242: 	clr.l		d1						; clear upper bits of d1
02:0000541C 1219            	  1243: 	move.b	(a1)+,d1			; move string char into d1
02:0000541E 6708            	  1244: 	beq.s		.0002					; is it end of string ?
02:00005420 6100FD56        	  1245: 	bsr			DisplayChar		; display character
                            	  1246: .0003:
02:00005424 51CAFFF4        	  1247: 	dbra		d2,.0001			; go back for next character
                            	  1248: .0002:
02:00005428 4CDF0207        	  1249: 	movem.l	(a7)+,d0/d1/d2/a1
02:0000542C 4E75            	  1250: 	rts
                            	  1251: 
                            	  1252: DisplayStringLimitedCRLF:
02:0000542E 61DE            	  1253: 	bsr		DisplayStringLimited
02:00005430 6000FCFC        	  1254: 	bra		CRLF
                            	  1255: 	
                            	  1256: ;------------------------------------------------------------------------------
                            	  1257: ; Set cursor position to top left of screen.
                            	  1258: ;
                            	  1259: ; Parameters:
                            	  1260: ;		<none>
                            	  1261: ; Returns:
                            	  1262: ;		<none>
                            	  1263: ; Registers Affected:
                            	  1264: ;		<none>
                            	  1265: ;------------------------------------------------------------------------------
                            	  1266: 
                            	  1267: HomeCursor:
02:00005434 423900040000    	  1268: 	clr.b		CursorRow
02:0000543A 423900040001    	  1269: 	clr.b		CursorCol
02:00005440 427900040002    	  1270: 	clr.w		TextPos
                            	  1271: 	; fall through
                            	  1272: 
                            	  1273: ;------------------------------------------------------------------------------
                            	  1274: ; SyncCursor:
                            	  1275: ;
                            	  1276: ; Sync the hardware cursor's position to the text cursor position but only for
                            	  1277: ; the core with the IO focus.
                            	  1278: ;
                            	  1279: ; Parameters:
                            	  1280: ;		<none>
                            	  1281: ; Returns:
                            	  1282: ;		<none>
                            	  1283: ; Registers Affected:
                            	  1284: ;		<none>
                            	  1285: ;------------------------------------------------------------------------------
                            	  1286: 
                            	  1287: SyncCursor:
02:00005446 48E7A000        	  1288: 	movem.l	d0/d2,-(a7)
02:0000544A 6100FCF4        	  1289: 	bsr			UpdateTextPos
02:0000544E 4E7A2FE0        	  1290: 	movec		coreno,d2
02:00005452 B43900100000    	  1291: 	cmp.b		IOFocus,d2
02:00005458 6610            	  1292: 	bne.s		.0001
02:0000545A 5542            	  1293: 	subi.w	#2,d2						; factor in location of screen in controller
02:0000545C C4FC0800        	  1294: 	mulu		#2048,d2				; 2048 cells per screen
02:00005460 D042            	  1295: 	add.w		d2,d0
02:00005462 E158            	  1296: 	rol.w		#8,d0						; swap byte order
02:00005464 33C0FD03FF24    	  1297: 	move.w	d0,TEXTREG+$24
                            	  1298: .0001:	
02:0000546A 4CDF0005        	  1299: 	movem.l	(a7)+,d0/d2
02:0000546E 4E75            	  1300: 	rts
                            	  1301: 
                            	  1302: ;==============================================================================
                            	  1303: ; TRAP #15 handler
                            	  1304: ;
                            	  1305: ; Parameters:
                            	  1306: ;		d0.w = function number to perform
                            	  1307: ;==============================================================================
                            	  1308: 
                            	  1309: TRAP15:
02:00005470 48E78080        	  1310: 	movem.l	d0/a0,-(a7)
02:00005474 41FA0012        	  1311: 	lea			T15DispatchTable,a0
02:00005478 E580            	  1312: 	asl.l		#2,d0
02:0000547A 20700000        	  1313: 	move.l	(a0,d0.w),a0
02:0000547E 4E90            	  1314: 	jsr			(a0)
02:00005480 4CDF0101        	  1315: 	movem.l	(a7)+,d0/a0
02:00005484 4E73            	  1316: 	rte
                            	  1317: 
                            	  1318: 		align	2
                            	  1319: T15DispatchTable:
02:00005488 0000542E        	  1320: 	dc.l	DisplayStringLimitedCRLF
02:0000548C 0000540E        	  1321: 	dc.l	DisplayStringLimited
02:00005490 0000556A        	  1322: 	dc.l	StubRout
02:00005494 0000556A        	  1323: 	dc.l	StubRout
02:00005498 0000556A        	  1324: 	dc.l	StubRout
02:0000549C 000057BE        	  1325: 	dc.l	GetKey
02:000054A0 00005178        	  1326: 	dc.l	DisplayChar
02:000054A4 000057B2        	  1327: 	dc.l	CheckForKey
02:000054A8 0000556A        	  1328: 	dc.l	StubRout
02:000054AC 0000556A        	  1329: 	dc.l	StubRout
                            	  1330: 	; 10
02:000054B0 0000556A        	  1331: 	dc.l	StubRout
02:000054B4 00005534        	  1332: 	dc.l	Cursor1
02:000054B8 000057AA        	  1333: 	dc.l	SetKeyboardEcho
02:000054BC 00005408        	  1334: 	dc.l	DisplayStringCRLF
02:000054C0 000053F2        	  1335: 	dc.l	DisplayString
02:000054C4 0000556A        	  1336: 	dc.l	StubRout
02:000054C8 0000556A        	  1337: 	dc.l	StubRout
02:000054CC 0000556A        	  1338: 	dc.l	StubRout
02:000054D0 0000556A        	  1339: 	dc.l	StubRout
02:000054D4 0000556A        	  1340: 	dc.l	StubRout
                            	  1341: 	; 20
02:000054D8 0000556A        	  1342: 	dc.l	StubRout
02:000054DC 0000556A        	  1343: 	dc.l	StubRout
02:000054E0 0000556A        	  1344: 	dc.l	StubRout
02:000054E4 0000556A        	  1345: 	dc.l	StubRout
02:000054E8 0000556A        	  1346: 	dc.l	StubRout
02:000054EC 0000556A        	  1347: 	dc.l	StubRout
02:000054F0 0000556A        	  1348: 	dc.l	StubRout
02:000054F4 0000556A        	  1349: 	dc.l	StubRout
02:000054F8 0000556A        	  1350: 	dc.l	StubRout
02:000054FC 0000556A        	  1351: 	dc.l	StubRout
                            	  1352: 	; 30
02:00005500 0000556A        	  1353: 	dc.l	StubRout
02:00005504 0000556A        	  1354: 	dc.l	StubRout
02:00005508 0000557E        	  1355: 	dc.l	rotate_iofocus
02:0000550C 00006F9E        	  1356: 	dc.l	SerialPeekCharDirect
02:00005510 00006FB8        	  1357: 	dc.l	SerialPutChar
02:00005514 00006F66        	  1358: 	dc.l	SerialPeekChar
02:00005518 00006EEE        	  1359: 	dc.l	SerialGetChar
02:0000551C 00000298        	  1360: 	dc.l	T15LockSemaphore
02:00005520 0000029E        	  1361: 	dc.l	T15UnlockSemaphore
02:00005524 00007424        	  1362: 	dc.l	prtflt
                            	  1363: 	; 40
02:00005528 000001E6        	  1364: 	dc.l  _GetRand
02:0000552C 000002A4        	  1365: 	dc.l	T15GetFloat
02:00005530 000002B2        	  1366: 	dc.l	T15Abort
                            	  1367: 
                            	  1368: ;------------------------------------------------------------------------------
                            	  1369: ; Cursor positioning / Clear screen
                            	  1370: ; - out of range settings are ignored
                            	  1371: ;
                            	  1372: ; Parameters:
                            	  1373: ;		d1.w cursor position, bits 0 to 7 are row, bits 8 to 15 are column.
                            	  1374: ;	Returns:
                            	  1375: ;		none
                            	  1376: ;------------------------------------------------------------------------------
                            	  1377: 
                            	  1378: Cursor1:
02:00005534 2F01            	  1379: 	move.l		d1,-(a7)
02:00005536 0C41FF00        	  1380: 	cmpi.w		#$FF00,d1
02:0000553A 6608            	  1381: 	bne.s			.0002
02:0000553C 6100FBA0        	  1382: 	bsr				clear_screen
02:00005540 6000FEF2        	  1383: 	bra				HomeCursor
                            	  1384: .0002:
02:00005544 B2390004008C    	  1385: 	cmp.b			TextRows,d1		; if cursor pos out of range, ignore setting
02:0000554A 6406            	  1386: 	bhs.s			.0003
02:0000554C 13C100040000    	  1387: 	move.b		d1,CursorRow
                            	  1388: .0003:
02:00005552 E059            	  1389: 	ror.w			#8,d1
02:00005554 B2390004008D    	  1390: 	cmp.b			TextCols,d1
02:0000555A 6406            	  1391: 	bhs.s			.0001
02:0000555C 13C100040001    	  1392: 	move.b		d1,CursorCol
                            	  1393: .0001:
02:00005562 6100FEE2        	  1394: 	bsr				SyncCursor		; update hardware cursor
02:00005566 221F            	  1395: 	move.l		(a7)+,d1
02:00005568 4E75            	  1396: 	rts
                            	  1397: 
                            	  1398: ;------------------------------------------------------------------------------
                            	  1399: ; Stub routine for unimplemented functionality.
                            	  1400: ;------------------------------------------------------------------------------
                            	  1401: 
                            	  1402: StubRout:
02:0000556A 4E75            	  1403: 	rts
                            	  1404: 
                            	  1405: ;------------------------------------------------------------------------------
                            	  1406: ; Select a specific IO focus.
                            	  1407: ;------------------------------------------------------------------------------
                            	  1408: 
                            	  1409: select_iofocus:
02:0000556C 0C010002        	  1410: 	cmpi.b	#2,d1
02:00005570 650A            	  1411: 	blo.s		.0001
02:00005572 0C010009        	  1412: 	cmpi.b	#9,d1
02:00005576 6204            	  1413: 	bhi.s		.0001
02:00005578 2001            	  1414: 	move.l	d1,d0
02:0000557A 6014            	  1415: 	bra.s		select_focus1
                            	  1416: .0001:
02:0000557C 4E75            	  1417: 	rts
                            	  1418: 
                            	  1419: ;------------------------------------------------------------------------------
                            	  1420: ; Rotate the IO focus, done when ALT-Tab is pressed.
                            	  1421: ;
                            	  1422: ; Modifies:
                            	  1423: ;		d0, IOFocus BIOS variable
                            	  1424: ;------------------------------------------------------------------------------
                            	  1425: 
                            	  1426: rotate_iofocus:
02:0000557E 103900100000    	  1427: 	move.b	IOFocus,d0				; d0 = focus, we can trash d0
02:00005584 5200            	  1428: 	add.b		#1,d0							; increment the focus
02:00005586 B03C0009        	  1429: 	cmp.b		#9,d0							; limit to 2 to 9
02:0000558A 6304            	  1430: 	bls.s		.0001
02:0000558C 103C0002        	  1431: 	move.b	#2,d0
                            	  1432: .0001:
                            	  1433: select_focus1:
02:00005590 13C000100000    	  1434: 	move.b	d0,IOFocus				; set IO focus
02:00005596 5500            	  1435: 	subi.b	#2,d0							; screen is 0 to 7, focus is 2 to 9
02:00005598 4880            	  1436: 	ext.w		d0								; make into long value
02:0000559A C0FC0800        	  1437: 	mulu		#2048,d0					; * 2048	cells per screen
02:0000559E E158            	  1438: 	rol.w		#8,d0							; swap byte order
02:000055A0 33C0FD03FF28    	  1439: 	move.w	d0,TEXTREG+$28		; update screen address in text controller
02:000055A6 6000FE9E        	  1440: 	bra			SyncCursor				; set cursor position
                            	  1441: 
                            	  1442: ;==============================================================================
                            	  1443: ; PLIC - platform level interrupt controller
                            	  1444: ;
                            	  1445: ; Register layout:
                            	  1446: ;   bits 0 to 7  = cause code to issue (vector number)
                            	  1447: ;   bits 8 to 11 = irq level to issue
                            	  1448: ;   bit 16 = irq enable
                            	  1449: ;   bit 17 = edge sensitivity
                            	  1450: ;   bit 18 = 0=vpa, 1=inta
                            	  1451: ;		bit 24 to 29 target core
                            	  1452: ;
                            	  1453: ; Note byte order must be reversed for PLIC.
                            	  1454: ;==============================================================================
                            	  1455: 
                            	  1456: init_plic:
02:000055AA 41F9FD090000    	  1457: 	lea		PLIC,a0						; a0 points to PLIC
02:000055B0 43E800F4        	  1458: 	lea		$80+4*29(a0),a1		; point to timer registers (29)
02:000055B4 22BC0006033F    	  1459: 	move.l	#$0006033F,(a1)	; initialize, core=63,edge sensitive,enabled,irq6,vpa
02:000055BA 5889            	  1460: 	lea			4(a1),a1				; point to keyboard registers (30)
02:000055BC 22BC3C060502    	  1461: 	move.l	#$3C060502,(a1)	; core=2,level sensitive,enabled,irq6,inta
02:000055C2 5889            	  1462: 	lea			4(a1),a1				; point to nmi button register (31)
02:000055C4 22BC00070302    	  1463: 	move.l	#$00070302,(a1)	; initialize, core=2,edge sensitive,enabled,irq7,vpa
02:000055CA 43E800C0        	  1464: 	lea		$80+4*16(a0),a1		; a1 points to ACIA register
02:000055CE 22BC3D030502    	  1465: 	move.l	#$3D030502,(a1)	; core=2,level sensitive,enabled,irq3,inta	
02:000055D4 43E80090        	  1466: 	lea		$80+4*4(a0),a1		; a1 points to io_bitmap irq
02:000055D8 22BC3B060702    	  1467: 	move.l	#$3B060702,(a1)	; core=2,edge sensitive,enabled,irq6,inta	
02:000055DE 4E75            	  1468: 	rts
                            	  1469: 
                            	  1470: ;==============================================================================
                            	  1471: ; Keyboard stuff
                            	  1472: ;
                            	  1473: ; KeyState2_
                            	  1474: ; 876543210
                            	  1475: ; ||||||||+ = shift
                            	  1476: ; |||||||+- = alt
                            	  1477: ; ||||||+-- = control
                            	  1478: ; |||||+--- = numlock
                            	  1479: ; ||||+---- = capslock
                            	  1480: ; |||+----- = scrolllock
                            	  1481: ; ||+------ =
                            	  1482: ; |+------- = 
                            	  1483: ; +-------- = extended
                            	  1484: ;
                            	  1485: ;==============================================================================
                            	  1486: 
                            	  1487: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1488: ; Get ID - get the keyboards identifier code.
                            	  1489: ;
                            	  1490: ; Parameters: none
                            	  1491: ; Returns: d = $AB83, $00 on fail
                            	  1492: ; Modifies: d, KeybdID updated
                            	  1493: ; Stack Space: 2 words
                            	  1494: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1495: 
                            	  1496: KeybdGetID:
02:000055E0 323C00F2        	  1497: 	move.w	#$F2,d1
02:000055E4 61000494        	  1498: 	bsr			KeybdSendByte
02:000055E8 6100019A        	  1499: 	bsr			KeybdWaitTx
02:000055EC 61000176        	  1500: 	bsr			KeybdRecvByte
02:000055F0 08010007        	  1501: 	btst		#7,d1
02:000055F4 6624            	  1502: 	bne			kgnotKbd
02:000055F6 0C0100AB        	  1503: 	cmpi.b	#$AB,d1
02:000055FA 661E            	  1504: 	bne			kgnotKbd
02:000055FC 61000166        	  1505: 	bsr			KeybdRecvByte
02:00005600 08010007        	  1506: 	btst		#7,d1
02:00005604 6614            	  1507: 	bne			kgnotKbd
02:00005606 0C010083        	  1508: 	cmpi.b	#$83,d1
02:0000560A 660E            	  1509: 	bne			kgnotKbd
02:0000560C 223C0000AB83    	  1510: 	move.l	#$AB83,d1
                            	  1511: kgid1:
02:00005612 33C100100016    	  1512: 	move.w	d1,KeybdID
02:00005618 4E75            	  1513: 	rts
                            	  1514: kgnotKbd:
02:0000561A 7200            	  1515: 	moveq		#0,d1
02:0000561C 60F4            	  1516: 	bra			kgid1
                            	  1517: 
                            	  1518: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1519: ; Set the LEDs on the keyboard.
                            	  1520: ;
                            	  1521: ; Parameters:
                            	  1522: ;		d1.b = LED state
                            	  1523: ;	Modifies:
                            	  1524: ;		none
                            	  1525: ; Returns:
                            	  1526: ;		none
                            	  1527: ; Stack Space:
                            	  1528: ;		1 long word
                            	  1529: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1530: 
                            	  1531: KeybdSetLED:
02:0000561E 2F01            	  1532: 	move.l	d1,-(a7)
02:00005620 123C00ED        	  1533: 	move.b	#$ED,d1
02:00005624 61000454        	  1534: 	bsr			KeybdSendByte
02:00005628 6100015A        	  1535: 	bsr			KeybdWaitTx
02:0000562C 61000136        	  1536: 	bsr			KeybdRecvByte
02:00005630 4A01            	  1537: 	tst.b		d1
02:00005632 6B12            	  1538: 	bmi			.0001
02:00005634 0C0100FA        	  1539: 	cmpi.b	#$FA,d1
02:00005638 2217            	  1540: 	move.l	(a7),d1
02:0000563A 6100043E        	  1541: 	bsr			KeybdSendByte
02:0000563E 61000144        	  1542: 	bsr			KeybdWaitTx
02:00005642 61000120        	  1543: 	bsr			KeybdRecvByte
                            	  1544: .0001:
02:00005646 221F            	  1545: 	move.l	(a7)+,d1
02:00005648 4E75            	  1546: 	rts
                            	  1547: 
                            	  1548: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1549: ; Initialize the keyboard.
                            	  1550: ;
                            	  1551: ; Parameters:
                            	  1552: ;		none
                            	  1553: ;	Modifies:
                            	  1554: ;		none
                            	  1555: ; Returns:
                            	  1556: ;		none
                            	  1557: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1558: 
                            	  1559: _KeybdInit:
                            	  1560: KeybdInit:
                            	  1561: ;	movem.l	d0/d1/d3/a1,-(a7)
02:0000564A 42390010000F    	  1562: 	clr.b	_KeyState1		; records key up/down state
02:00005650 423900100010    	  1563: 	clr.b	_KeyState2		; records shift,ctrl,alt state
02:00005656 4E75            	  1564: 	rts
                            	  1565: 
02:00005658 61000444        	  1566: 	bsr			Wait300ms
02:0000565C 610000EC        	  1567: 	bsr			_KeybdGetStatus	; wait for response from keyboard
02:00005660 4A01            	  1568: 	tst.b		d1
02:00005662 6A0C            	  1569: 	bpl			.0001					; is input buffer full ? no, branch
02:00005664 610000EE        	  1570: 	bsr			_KeybdGetScancode
02:00005668 0C0100AA        	  1571: 	cmpi.b	#$AA,d1				; keyboard Okay
02:0000566C 6700008A        	  1572: 	beq			kbdi0005
                            	  1573: .0001:
02:00005670 760A            	  1574: 	moveq		#10,d3
                            	  1575: kbdi0002:
02:00005672 6100040E        	  1576: 	bsr			Wait10ms
02:00005676 4239FD0FFE01    	  1577: 	clr.b		KEYBD+1				; clear receive register (write $00 to status reg)
02:0000567C 72FF            	  1578: 	moveq		#-1,d1				; send reset code to keyboard
02:0000567E 13C1FD0FFE01    	  1579: 	move.b	d1,KEYBD+1		; write $FF to status reg to clear TX state
02:00005684 610003F4        	  1580: 	bsr			KeybdSendByte	; now write ($FF) to transmit register for reset
02:00005688 610000FA        	  1581: 	bsr			KeybdWaitTx		; wait until no longer busy
02:0000568C 4A81            	  1582: 	tst.l		d1
02:0000568E 6B000082        	  1583: 	bmi			kbdiXmitBusy
02:00005692 610000D0        	  1584: 	bsr			KeybdRecvByte	; look for an ACK ($FA)
02:00005696 0C0100FA        	  1585: 	cmpi.b	#$FA,d1
02:0000569A 6604            	  1586: 	bne			.0001
02:0000569C 610000C6        	  1587: 	bsr			KeybdRecvByte	; look for BAT completion code ($AA)
                            	  1588: .0001:
02:000056A0 0C0100FC        	  1589: 	cmpi.b	#$FC,d1				; reset error ?
02:000056A4 672A            	  1590: 	beq			kbdiTryAgain
02:000056A6 0C0100AA        	  1591: 	cmpi.b	#$AA,d1				; reset complete okay ?
02:000056AA 6624            	  1592: 	bne			kbdiTryAgain
                            	  1593: 
                            	  1594: 	; After a reset, scan code set #2 should be active
                            	  1595: .config:
02:000056AC 323C00F0        	  1596: 	move.w	#$F0,d1			; send scan code select
02:000056B0 13C1FD0FFF00    	  1597: 	move.b	d1,leds
02:000056B6 610003C2        	  1598: 	bsr			KeybdSendByte
02:000056BA 610000C8        	  1599: 	bsr			KeybdWaitTx
02:000056BE 4A81            	  1600: 	tst.l		d1
02:000056C0 6B50            	  1601: 	bmi			kbdiXmitBusy
02:000056C2 610000A0        	  1602: 	bsr			KeybdRecvByte	; wait for response from keyboard
02:000056C6 4A41            	  1603: 	tst.w		d1
02:000056C8 6B06            	  1604: 	bmi			kbdiTryAgain
02:000056CA 0C0100FA        	  1605: 	cmpi.b	#$FA,d1				; ACK
02:000056CE 670E            	  1606: 	beq			kbdi0004
                            	  1607: kbdiTryAgain:
02:000056D0 51CBFFA0        	  1608: 	dbra		d3,kbdi0002
                            	  1609: .keybdErr:
02:000056D4 43FA004A        	  1610: 	lea			msgBadKeybd,a1
02:000056D8 6100FD2E        	  1611: 	bsr			DisplayStringCRLF
02:000056DC 601E            	  1612: 	bra			ledxit
                            	  1613: kbdi0004:
02:000056DE 7202            	  1614: 	moveq		#2,d1			; select scan code set #2
02:000056E0 61000398        	  1615: 	bsr			KeybdSendByte
02:000056E4 6100009E        	  1616: 	bsr			KeybdWaitTx
02:000056E8 4A81            	  1617: 	tst.l		d1
02:000056EA 6B26            	  1618: 	bmi			kbdiXmitBusy
02:000056EC 6176            	  1619: 	bsr			KeybdRecvByte	; wait for response from keyboard
02:000056EE 4A41            	  1620: 	tst.w		d1
02:000056F0 6BDE            	  1621: 	bmi			kbdiTryAgain
02:000056F2 0C0100FA        	  1622: 	cmpi.b	#$FA,d1
02:000056F6 66D8            	  1623: 	bne			kbdiTryAgain
                            	  1624: kbdi0005:
02:000056F8 6100FEE6        	  1625: 	bsr			KeybdGetID
                            	  1626: ledxit:
02:000056FC 7207            	  1627: 	moveq		#$07,d1
02:000056FE 6100FF1E        	  1628: 	bsr			KeybdSetLED
02:00005702 6100039A        	  1629: 	bsr			Wait300ms
02:00005706 7200            	  1630: 	moveq		#$00,d1
02:00005708 6100FF14        	  1631: 	bsr			KeybdSetLED
02:0000570C 4CDF020B        	  1632: 	movem.l	(a7)+,d0/d1/d3/a1
02:00005710 4E75            	  1633: 	rts
                            	  1634: kbdiXmitBusy:
02:00005712 43FA001B        	  1635: 	lea			msgXmitBusy,a1
02:00005716 6100FCF0        	  1636: 	bsr			DisplayStringCRLF
02:0000571A 4CDF020B        	  1637: 	movem.l	(a7)+,d0/d1/d3/a1
02:0000571E 4E75            	  1638: 	rts
                            	  1639: 	
                            	  1640: msgBadKeybd:
02:00005720 4B6579626F617264	  1641: 	dc.b		"Keyboard error",0
02:00005728 206572726F72
02:0000572E 00
                            	  1642: msgXmitBusy:
02:0000572F 4B6579626F617264	  1643: 	dc.b		"Keyboard transmitter stuck",0
02:00005737 207472616E736D69
02:0000573F 7474657220737475
02:00005747 636B
02:00005749 00
                            	  1644: 
                            	  1645: 	even
                            	  1646: _KeybdGetStatus:
02:0000574A 7200            	  1647: 	moveq		#0,d1
02:0000574C 1239FD0FFE01    	  1648: 	move.b	KEYBD+1,d1
02:00005752 4E75            	  1649: 	rts
                            	  1650: 
                            	  1651: ; Get the scancode from the keyboard port
                            	  1652: 
                            	  1653: _KeybdGetScancode:
02:00005754 7200            	  1654: 	moveq		#0,d1
02:00005756 1239FD0FFE00    	  1655: 	move.b	KEYBD,d1				; get the scan code
02:0000575C 4239FD0FFE01    	  1656: 	move.b	#0,KEYBD+1			; clear receive register
02:00005762 4E75            	  1657: 	rts
                            	  1658: 
                            	  1659: ; Recieve a byte from the keyboard, used after a command is sent to the
                            	  1660: ; keyboard in order to wait for a response.
                            	  1661: ;
                            	  1662: KeybdRecvByte:
02:00005764 2F03            	  1663: 	move.l	d3,-(a7)
02:00005766 363C0064        	  1664: 	move.w	#100,d3		; wait up to 1s
                            	  1665: .0003:
02:0000576A 61DE            	  1666: 	bsr			_KeybdGetStatus	; wait for response from keyboard
02:0000576C 4A01            	  1667: 	tst.b		d1
02:0000576E 6B0E            	  1668: 	bmi			.0004			; is input buffer full ? yes, branch
02:00005770 61000310        	  1669: 	bsr			Wait10ms	; wait a bit
02:00005774 51CBFFF4        	  1670: 	dbra		d3,.0003	; go back and try again
02:00005778 261F            	  1671: 	move.l	(a7)+,d3
02:0000577A 72FF            	  1672: 	moveq		#-1,d1		; return -1
02:0000577C 4E75            	  1673: 	rts
                            	  1674: .0004:
02:0000577E 61D4            	  1675: 	bsr			_KeybdGetScancode
02:00005780 261F            	  1676: 	move.l	(a7)+,d3
02:00005782 4E75            	  1677: 	rts
                            	  1678: 
                            	  1679: 
                            	  1680: ; Wait until the keyboard transmit is complete
                            	  1681: ; Returns -1 if timedout, 0 if transmit completed
                            	  1682: ;
                            	  1683: KeybdWaitTx:
02:00005784 48E73000        	  1684: 	movem.l	d2/d3,-(a7)
02:00005788 7664            	  1685: 	moveq		#100,d3		; wait a max of 1s
                            	  1686: .0001:
02:0000578A 61BE            	  1687: 	bsr			_KeybdGetStatus
02:0000578C 08010006        	  1688: 	btst		#6,d1				; check for transmit complete bit
02:00005790 6610            	  1689: 	bne	    .0002				; branch if bit set
02:00005792 610002EE        	  1690: 	bsr			Wait10ms		; delay a little bit
02:00005796 51CBFFF2        	  1691: 	dbra		d3,.0001		; go back and try again
02:0000579A 4CDF000C        	  1692: 	movem.l	(a7)+,d2/d3
02:0000579E 72FF            	  1693: 	moveq		#-1,d1			; return -1
02:000057A0 4E75            	  1694: 	rts
                            	  1695: .0002:
02:000057A2 4CDF000C        	  1696: 	movem.l	(a7)+,d2/d3
02:000057A6 7200            	  1697: 	moveq	#0,d1		; return 0
02:000057A8 4E75            	  1698: 	rts
                            	  1699: 
                            	  1700: ;------------------------------------------------------------------------------
                            	  1701: ; d1.b 0=echo off, non-zero = echo on
                            	  1702: ;------------------------------------------------------------------------------
                            	  1703: 
                            	  1704: SetKeyboardEcho:
02:000057AA 13C10004000C    	  1705: 	move.b	d1,KeybdEcho
02:000057B0 4E75            	  1706: 	rts
                            	  1707: 
                            	  1708: ;------------------------------------------------------------------------------
                            	  1709: ; Get key pending status into d1.b
                            	  1710: ;
                            	  1711: ; Returns:
                            	  1712: ;		d1.b = 1 if a key is available, otherwise zero.
                            	  1713: ;------------------------------------------------------------------------------
                            	  1714: 
                            	  1715: CheckForKey:
02:000057B2 7200            	  1716: 	moveq.l	#0,d1					; clear high order bits
                            	  1717: ;	move.b	KEYBD+1,d1		; get keyboard port status
                            	  1718: ;	smi.b		d1						; set true/false
                            	  1719: ;	andi.b	#1,d1					; return true (1) if key available, 0 otherwise
02:000057B4 4A3900100013    	  1720: 	tst.b		_KeybdCnt
02:000057BA 56C1            	  1721: 	sne.b		d1
02:000057BC 4E75            	  1722: 	rts
                            	  1723: 
                            	  1724: ;------------------------------------------------------------------------------
                            	  1725: ; GetKey
                            	  1726: ; 	Get a character from the keyboard. 
                            	  1727: ;
                            	  1728: ; Modifies:
                            	  1729: ;		d1
                            	  1730: ; Returns:
                            	  1731: ;		d1 = -1 if no key available or not in focus, otherwise key
                            	  1732: ;------------------------------------------------------------------------------
                            	  1733: 
                            	  1734: GetKey:
02:000057BE 2F00            	  1735: 	move.l	d0,-(a7)					; push d0
02:000057C0 123900100000    	  1736: 	move.b	IOFocus,d1				; Check if the core has the IO focus
02:000057C6 4E7A0FE0        	  1737: 	movec.l	coreno,d0
02:000057CA B200            	  1738: 	cmp.b		d0,d1
02:000057CC 6622            	  1739: 	bne.s		.0004							; go return no key available, if not in focus
02:000057CE 6132            	  1740: 	bsr			KeybdGetCharNoWait	; get a character
02:000057D0 4A81            	  1741: 	tst.l		d1						; was a key available?
02:000057D2 6B1C            	  1742: 	bmi.s		.0004
02:000057D4 4A390004000C    	  1743: 	tst.b		KeybdEcho					; is keyboard echo on ?
02:000057DA 6710            	  1744: 	beq.s		.0003							; no echo, just return the key
02:000057DC 0C01000D        	  1745: 	cmpi.b	#CR,d1						; convert CR keystroke into CRLF
02:000057E0 6606            	  1746: 	bne.s		.0005
02:000057E2 6100F94A        	  1747: 	bsr			CRLF
02:000057E6 6004            	  1748: 	bra.s		.0003
                            	  1749: .0005:
02:000057E8 6100F98E        	  1750: 	bsr			DisplayChar
                            	  1751: .0003:
02:000057EC 201F            	  1752: 	move.l	(a7)+,d0					; pop d0
02:000057EE 4E75            	  1753: 	rts												; return key
                            	  1754: ; Return -1 indicating no char was available
                            	  1755: .0004:
02:000057F0 201F            	  1756: 	move.l	(a7)+,d0					; pop d0
02:000057F2 72FF            	  1757: 	moveq		#-1,d1						; return no key available
02:000057F4 4E75            	  1758: 	rts
                            	  1759: 
                            	  1760: CheckForCtrlC:
02:000057F6 610A            	  1761: 	bsr			KeybdGetCharNoWait
02:000057F8 0C010003        	  1762: 	cmpi.b	#CTRLC,d1
02:000057FC 670006C4        	  1763: 	beq			Monitor
02:00005800 4E75            	  1764: 	rts
                            	  1765: 
                            	  1766: ;------------------------------------------------------------------------------
                            	  1767: ;------------------------------------------------------------------------------
                            	  1768: 
                            	  1769: KeybdGetCharNoWait:
02:00005802 42390004000D    	  1770: 	clr.b	KeybdWaitFlag
02:00005808 6008            	  1771: 	bra		KeybdGetChar
                            	  1772: 
                            	  1773: KeybdGetCharWait:
02:0000580A 13FC00FF0004000D	  1774: 	move.b	#-1,KeybdWaitFlag
                            	  1775: 
                            	  1776: KeybdGetChar:
02:00005812 48E7B080        	  1777: 	movem.l	d0/d2/d3/a0,-(a7)
                            	  1778: .0003:
02:00005816 4E7A0FE0        	  1779: 	movec		coreno,d0
02:0000581A 4840            	  1780: 	swap		d0
02:0000581C 7203            	  1781: 	moveq		#KEYBD_SEMA,d1
02:0000581E 6100AA20        	  1782: 	bsr			LockSemaphore
02:00005822 143900100013    	  1783: 	move.b	_KeybdCnt,d2		; get count of buffered scan codes
02:00005828 673E            	  1784: 	beq.s		.0015						;
02:0000582A 143900100011    	  1785: 	move.b	_KeybdHead,d2		; d2 = buffer head
02:00005830 4882            	  1786: 	ext.w		d2
02:00005832 41F900100020    	  1787: 	lea			_KeybdBuf,a0		; a0 = pointer to keyboard buffer
02:00005838 7200            	  1788: 	clr.l		d1
02:0000583A 12302000        	  1789: 	move.b	(a0,d2.w),d1		; d1 = scan code from buffer
02:0000583E 5202            	  1790: 	addi.b	#1,d2						; increment keyboard head index
02:00005840 0202001F        	  1791: 	andi.b	#31,d2					; and wrap around at buffer size
02:00005844 13C200100011    	  1792: 	move.b	d2,_KeybdHead
02:0000584A 533900100013    	  1793: 	subi.b	#1,_KeybdCnt		; decrement count of scan codes in buffer
02:00005850 C342            	  1794: 	exg			d1,d2						; save scancode value in d2
02:00005852 4E7A0FE0        	  1795: 	movec		coreno,d0
02:00005856 4840            	  1796: 	swap		d0
02:00005858 7203            	  1797: 	moveq		#KEYBD_SEMA,d1
02:0000585A 6100AA20        	  1798: 	bsr			UnlockSemaphore
02:0000585E C541            	  1799: 	exg			d2,d1						; restore scancode value
02:00005860 6026            	  1800: 	bra			.0001						; go process scan code
                            	  1801: .0014:
02:00005862 6100FEE6        	  1802: 	bsr		_KeybdGetStatus		; check keyboard status for key available
02:00005866 6B1C            	  1803: 	bmi		.0006							; yes, go process
                            	  1804: .0015:
02:00005868 4E7A0FE0        	  1805: 	movec		coreno,d0
02:0000586C 4840            	  1806: 	swap		d0
02:0000586E 7203            	  1807: 	moveq		#KEYBD_SEMA,d1
02:00005870 6100AA0A        	  1808: 	bsr			UnlockSemaphore
02:00005874 4A390004000D    	  1809: 	tst.b		KeybdWaitFlag			; are we willing to wait for a key ?
02:0000587A 6B9A            	  1810: 	bmi			.0003							; yes, branch back
02:0000587C 4CDF010D        	  1811: 	movem.l	(a7)+,d0/d2/d3/a0
02:00005880 72FF            	  1812: 	moveq		#-1,d1						; flag no char available
02:00005882 4E75            	  1813: 	rts
                            	  1814: .0006:
02:00005884 6100FECE        	  1815: 	bsr		_KeybdGetScancode
                            	  1816: .0001:
02:00005888 33FC0001FD0FFF00	  1817: 	move.w	#1,leds
02:00005890 B23C00F0        	  1818: 	cmp.b	#SC_KEYUP,d1
02:00005894 670000C0        	  1819: 	beq		.doKeyup
02:00005898 B23C00E0        	  1820: 	cmp.b	#SC_EXTEND,d1
02:0000589C 670000C4        	  1821: 	beq		.doExtend
02:000058A0 B23C0014        	  1822: 	cmp.b	#SC_CTRL,d1
02:000058A4 670000C8        	  1823: 	beq		.doCtrl
02:000058A8 B23C0012        	  1824: 	cmp.b	#SC_LSHIFT,d1
02:000058AC 6700012A        	  1825: 	beq		.doShift
02:000058B0 B23C0059        	  1826: 	cmp.b	#SC_RSHIFT,d1
02:000058B4 67000122        	  1827: 	beq		.doShift
02:000058B8 B23C0077        	  1828: 	cmp.b	#SC_NUMLOCK,d1
02:000058BC 67000142        	  1829: 	beq		.doNumLock
02:000058C0 B23C0058        	  1830: 	cmp.b	#SC_CAPSLOCK,d1
02:000058C4 67000148        	  1831: 	beq		.doCapsLock
02:000058C8 B23C007E        	  1832: 	cmp.b	#SC_SCROLLLOCK,d1
02:000058CC 6700014E        	  1833: 	beq		.doScrollLock
02:000058D0 B23C0011        	  1834: 	cmp.b   #SC_ALT,d1
02:000058D4 670000C0        	  1835: 	beq     .doAlt
02:000058D8 14390010000F    	  1836: 	move.b	_KeyState1,d2			; check key up/down
02:000058DE 42390010000F    	  1837: 	move.b	#0,_KeyState1			; clear keyup status
02:000058E4 4A02            	  1838: 	tst.b	d2
02:000058E6 6600FF2E        	  1839: 	bne	    .0003					; ignore key up
02:000058EA B23C000D        	  1840: 	cmp.b   #SC_TAB,d1
02:000058EE 670000CE        	  1841: 	beq     .doTab
                            	  1842: .0013:
02:000058F2 143900100010    	  1843: 	move.b	_KeyState2,d2
02:000058F8 6A1A            	  1844: 	bpl		.0010					; is it extended code ?
02:000058FA C43C007F        	  1845: 	and.b	#$7F,d2					; clear extended bit
02:000058FE 13C200100010    	  1846: 	move.b	d2,_KeyState2
02:00005904 42390010000F    	  1847: 	move.b	#0,_KeyState1			; clear keyup
02:0000590A 41FA04C0        	  1848: 	lea		_keybdExtendedCodes,a0
02:0000590E 12301000        	  1849: 	move.b	(a0,d1.w),d1
02:00005912 6034            	  1850: 	bra		.0008
                            	  1851: .0010:
02:00005914 08020002        	  1852: 	btst	#2,d2					; is it CTRL code ?
02:00005918 670E            	  1853: 	beq		.0009
02:0000591A C27C007F        	  1854: 	and.w	#$7F,d1
02:0000591E 41FA042C        	  1855: 	lea		_keybdControlCodes,a0
02:00005922 12301000        	  1856: 	move.b	(a0,d1.w),d1
02:00005926 6020            	  1857: 	bra		.0008
                            	  1858: .0009:
02:00005928 08020000        	  1859: 	btst	#0,d2					; is it shift down ?
02:0000592C 670A            	  1860: 	beq  	.0007
02:0000592E 41FA031C        	  1861: 	lea		_shiftedScanCodes,a0
02:00005932 12301000        	  1862: 	move.b	(a0,d1.w),d1
02:00005936 6010            	  1863: 	bra		.0008
                            	  1864: .0007:
02:00005938 41FA0212        	  1865: 	lea		_unshiftedScanCodes,a0
02:0000593C 12301000        	  1866: 	move.b	(a0,d1.w),d1
02:00005940 33FC0202FD0FFF00	  1867: 	move.w	#$0202,leds
                            	  1868: .0008:
02:00005948 33FC0303FD0FFF00	  1869: 	move.w	#$0303,leds
02:00005950 4CDF010D        	  1870: 	movem.l	(a7)+,d0/d2/d3/a0
02:00005954 4E75            	  1871: 	rts
                            	  1872: .doKeyup:
02:00005956 13FC00FF0010000F	  1873: 	move.b	#-1,_KeyState1
02:0000595E 6000FEB6        	  1874: 	bra		.0003
                            	  1875: .doExtend:
02:00005962 0039008000100010	  1876: 	or.b	#$80,_KeyState2
02:0000596A 6000FEAA        	  1877: 	bra		.0003
                            	  1878: .doCtrl:
02:0000596E 12390010000F    	  1879: 	move.b	_KeyState1,d1
02:00005974 42390010000F    	  1880: 	clr.b	_KeyState1
02:0000597A 4A01            	  1881: 	tst.b	d1
02:0000597C 6A0C            	  1882: 	bpl.s	.0004
02:0000597E 08B9000200100010	  1883: 	bclr	#2,_KeyState2
02:00005986 6000FE8E        	  1884: 	bra		.0003
                            	  1885: .0004:
02:0000598A 08F9000200100010	  1886: 	bset	#2,_KeyState2
02:00005992 6000FE82        	  1887: 	bra		.0003
                            	  1888: .doAlt:
02:00005996 12390010000F    	  1889: 	move.b	_KeyState1,d1
02:0000599C 42390010000F    	  1890: 	clr.b	_KeyState1
02:000059A2 4A01            	  1891: 	tst.b	d1
02:000059A4 6A0C            	  1892: 	bpl		.0011
02:000059A6 08B9000100100010	  1893: 	bclr	#1,_KeyState2
02:000059AE 6000FE66        	  1894: 	bra		.0003
                            	  1895: .0011:
02:000059B2 08F9000100100010	  1896: 	bset	#1,_KeyState2
02:000059BA 6000FE5A        	  1897: 	bra		.0003
                            	  1898: .doTab:
02:000059BE 2F01            	  1899: 	move.l	d1,-(a7)
02:000059C0 123900100010    	  1900:   move.b  _KeyState2,d1
02:000059C6 08010001        	  1901:   btst	#1,d1                 ; is ALT down ?
02:000059CA 6706            	  1902:   beq     .0012
                            	  1903: ;    	inc     _iof_switch
02:000059CC 221F            	  1904:   move.l	(a7)+,d1
02:000059CE 6000FE46        	  1905:   bra     .0003
                            	  1906: .0012:
02:000059D2 221F            	  1907:   move.l	(a7)+,d1
02:000059D4 6000FF1C        	  1908:   bra     .0013
                            	  1909: .doShift:
02:000059D8 12390010000F    	  1910: 	move.b	_KeyState1,d1
02:000059DE 42390010000F    	  1911: 	clr.b	_KeyState1
02:000059E4 4A01            	  1912: 	tst.b	d1
02:000059E6 6A0C            	  1913: 	bpl.s	.0005
02:000059E8 08B9000000100010	  1914: 	bclr	#0,_KeyState2
02:000059F0 6000FE24        	  1915: 	bra		.0003
                            	  1916: .0005:
02:000059F4 08F9000000100010	  1917: 	bset	#0,_KeyState2
02:000059FC 6000FE18        	  1918: 	bra		.0003
                            	  1919: .doNumLock:
02:00005A00 0879000400100010	  1920: 	bchg	#4,_KeyState2
02:00005A08 6120            	  1921: 	bsr		KeybdSetLEDStatus
02:00005A0A 6000FE0A        	  1922: 	bra		.0003
                            	  1923: .doCapsLock:
02:00005A0E 0879000500100010	  1924: 	bchg	#5,_KeyState2
02:00005A16 6112            	  1925: 	bsr		KeybdSetLEDStatus
02:00005A18 6000FDFC        	  1926: 	bra		.0003
                            	  1927: .doScrollLock:
02:00005A1C 0879000600100010	  1928: 	bchg	#6,_KeyState2
02:00005A24 6104            	  1929: 	bsr		KeybdSetLEDStatus
02:00005A26 6000FDEE        	  1930: 	bra		.0003
                            	  1931: 
                            	  1932: KeybdSetLEDStatus:
02:00005A2A 48E73000        	  1933: 	movem.l	d2/d3,-(a7)
02:00005A2E 42390010000E    	  1934: 	clr.b		KeybdLEDs
02:00005A34 0839000400100010	  1935: 	btst		#4,_KeyState2
02:00005A3C 6708            	  1936: 	beq.s		.0002
02:00005A3E 13FC00020010000E	  1937: 	move.b	#2,KeybdLEDs
                            	  1938: .0002:
02:00005A46 0839000500100010	  1939: 	btst		#5,_KeyState2
02:00005A4E 6708            	  1940: 	beq.s		.0003
02:00005A50 08F900020010000E	  1941: 	bset		#2,KeybdLEDs
                            	  1942: .0003:
02:00005A58 0839000600100010	  1943: 	btst		#6,_KeyState2
02:00005A60 6708            	  1944: 	beq.s		.0004
02:00005A62 08F900000010000E	  1945: 	bset		#0,KeybdLEDs
                            	  1946: .0004:
02:00005A6A 12390010000E    	  1947: 	move.b	KeybdLEDs,d1
02:00005A70 6100FBAC        	  1948: 	bsr			KeybdSetLED
02:00005A74 4CDF000C        	  1949: 	movem.l	(a7)+,d2/d3
02:00005A78 4E75            	  1950: 	rts
                            	  1951: 
                            	  1952: KeybdSendByte:
02:00005A7A 13C1FD0FFE00    	  1953: 	move.b	d1,KEYBD
02:00005A80 4E75            	  1954: 	rts
                            	  1955: 	
                            	  1956: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1957: ; Wait for 10 ms
                            	  1958: ;
                            	  1959: ; Parameters: none
                            	  1960: ; Returns: none
                            	  1961: ; Modifies: none
                            	  1962: ; Stack Space: 2 long words
                            	  1963: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1964: 
                            	  1965: Wait10ms:
02:00005A82 48E7C000        	  1966: 	movem.l	d0/d1,-(a7)
02:00005A86 4E7A0FF0        	  1967: 	movec		tick,d0
02:00005A8A 068000061A80    	  1968: 	addi.l	#400000,d0			; 400,000 cycles at 40MHz
                            	  1969: .0001:
02:00005A90 4E7A1FF0        	  1970: 	movec		tick,d1
02:00005A94 B081            	  1971: 	cmp.l		d1,d0
02:00005A96 62F8            	  1972: 	bhi			.0001
02:00005A98 4CDF0003        	  1973: 	movem.l	(a7)+,d0/d1
02:00005A9C 4E75            	  1974: 	rts
                            	  1975: 
                            	  1976: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1977: ; Wait for 300 ms
                            	  1978: ;
                            	  1979: ; Parameters: none
                            	  1980: ; Returns: none
                            	  1981: ; Modifies: none
                            	  1982: ; Stack Space: 2 long words
                            	  1983: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1984: 
                            	  1985: Wait300ms:
02:00005A9E 48E7C000        	  1986: 	movem.l	d0/d1,-(a7)
02:00005AA2 4E7A0FF0        	  1987: 	movec		tick,d0
02:00005AA6 068000B71B00    	  1988: 	addi.l	#12000000,d0			; 12,000,000 cycles at 40MHz
                            	  1989: .0001:
02:00005AAC 4E7A1FF0        	  1990: 	movec		tick,d1
02:00005AB0 B081            	  1991: 	cmp.l		d1,d0
02:00005AB2 62F8            	  1992: 	bhi			.0001
02:00005AB4 4CDF0003        	  1993: 	movem.l	(a7)+,d0/d1
02:00005AB8 4E75            	  1994: 	rts
                            	  1995: 
                            	  1996: ;--------------------------------------------------------------------------
                            	  1997: ; Keyboard IRQ routine.
                            	  1998: ;
                            	  1999: ; Returns:
                            	  2000: ; 	d1 = -1 if keyboard routine handled interrupt, otherwise positive.
                            	  2001: ;--------------------------------------------------------------------------
                            	  2002: 
                            	  2003: KeybdIRQ:
02:00005ABA 46FC2600        	  2004: 	move.w	#$2600,sr					; disable lower interrupts
02:00005ABE 48E7C080        	  2005: 	movem.l	d0/d1/a0,-(a7)
02:00005AC2 6100FC86        	  2006: 	bsr			_KeybdGetStatus		; check if keyboard
02:00005AC6 4A01            	  2007: 	tst.b		d1
02:00005AC8 6A7C            	  2008: 	bpl			.0001							; branch if not keyboard
02:00005ACA 4E7A0FE0        	  2009: 	movec		coreno,d0
02:00005ACE 4840            	  2010: 	swap		d0
02:00005AD0 7203            	  2011: 	moveq		#KEYBD_SEMA,d1
02:00005AD2 6100A76C        	  2012: 	bsr			LockSemaphore
02:00005AD6 0839000100100010	  2013: 	btst		#1,_KeyState2			; Is Alt down?
02:00005ADE 6728            	  2014: 	beq.s		.0003
02:00005AE0 1039FD0FFE00    	  2015: 	move.b	KEYBD,d0					; get scan code
02:00005AE6 0C00000D        	  2016: 	cmpi.b	#SC_TAB,d0				; is Alt-Tab?
02:00005AEA 661C            	  2017: 	bne.s		.0003
02:00005AEC 6100FC66        	  2018: 	bsr			_KeybdGetScancode	; grab the scan code (clears interrupt)
02:00005AF0 6100FA8C        	  2019: 	bsr			rotate_iofocus
02:00005AF4 423900100011    	  2020: 	clr.b		_KeybdHead				; clear keyboard buffer
02:00005AFA 423900100012    	  2021: 	clr.b		_KeybdTail
02:00005B00 423900100013    	  2022: 	clr.b		_KeybdCnt
02:00005B06 6032            	  2023: 	bra			.0002							; do not store Alt-Tab
                            	  2024: .0003:
                            	  2025: 	; Insert keyboard scan code into raw keyboard buffer
02:00005B08 6100FC4A        	  2026: 	bsr			_KeybdGetScancode	; grab the scan code (clears interrupt)
02:00005B0C 0C39002000100013	  2027: 	cmpi.b	#32,_KeybdCnt			; see if keyboard buffer full
02:00005B14 6424            	  2028: 	bhs.s		.0002
02:00005B16 103900100012    	  2029: 	move.b	_KeybdTail,d0			; keyboard buffer not full, add to tail
02:00005B1C 4880            	  2030: 	ext.w		d0
02:00005B1E 41F900100020    	  2031: 	lea			_KeybdBuf,a0			; a0 = pointer to buffer
02:00005B24 11810000        	  2032: 	move.b	d1,(a0,d0.w)			; put scancode in buffer
02:00005B28 5200            	  2033: 	addi.b	#1,d0							; increment tail index
02:00005B2A 0200001F        	  2034: 	andi.b	#31,d0						; wrap at buffer limit
02:00005B2E 13C000100012    	  2035: 	move.b	d0,_KeybdTail			; update tail index
02:00005B34 523900100013    	  2036: 	addi.b	#1,_KeybdCnt			; increment buffer count
                            	  2037: .0002:
02:00005B3A 4E7A0FE0        	  2038: 	movec		coreno,d0
02:00005B3E 4840            	  2039: 	swap		d0
02:00005B40 7203            	  2040: 	moveq		#KEYBD_SEMA,d1
02:00005B42 6100A738        	  2041: 	bsr			UnlockSemaphore
                            	  2042: .0001:
02:00005B46 4CDF0103        	  2043: 	movem.l	(a7)+,d0/d1/a0		; return
02:00005B4A 4E73            	  2044: 	rte
                            	  2045: 
                            	  2046: ;--------------------------------------------------------------------------
                            	  2047: ; PS2 scan codes to ascii conversion tables.
                            	  2048: ;--------------------------------------------------------------------------
                            	  2049: ;
                            	  2050: _unshiftedScanCodes:
02:00005B4C 2E              	  2051: 	dc.b	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
02:00005B4D A9
02:00005B4E 2E
02:00005B4F A5
02:00005B50 A3
02:00005B51 A1
02:00005B52 A2
02:00005B53 AC
02:00005B54 2E              	  2052: 	dc.b	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
02:00005B55 AA
02:00005B56 A8
02:00005B57 A6
02:00005B58 A4
02:00005B59 09
02:00005B5A 60
02:00005B5B 2E
02:00005B5C 2E              	  2053: 	dc.b	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
02:00005B5D 2E
02:00005B5E 2E
02:00005B5F 2E
02:00005B60 2E
02:00005B61 71
02:00005B62 31
02:00005B63 2E
02:00005B64 2E              	  2054: 	dc.b	$2e,$2e,$7a,$73,$61,$77,$32,$2e
02:00005B65 2E
02:00005B66 7A
02:00005B67 73
02:00005B68 61
02:00005B69 77
02:00005B6A 32
02:00005B6B 2E
02:00005B6C 2E              	  2055: 	dc.b	$2e,$63,$78,$64,$65,$34,$33,$2e
02:00005B6D 63
02:00005B6E 78
02:00005B6F 64
02:00005B70 65
02:00005B71 34
02:00005B72 33
02:00005B73 2E
02:00005B74 2E              	  2056: 	dc.b	$2e,$20,$76,$66,$74,$72,$35,$2e
02:00005B75 20
02:00005B76 76
02:00005B77 66
02:00005B78 74
02:00005B79 72
02:00005B7A 35
02:00005B7B 2E
02:00005B7C 2E              	  2057: 	dc.b	$2e,$6e,$62,$68,$67,$79,$36,$2e
02:00005B7D 6E
02:00005B7E 62
02:00005B7F 68
02:00005B80 67
02:00005B81 79
02:00005B82 36
02:00005B83 2E
02:00005B84 2E              	  2058: 	dc.b	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
02:00005B85 2E
02:00005B86 6D
02:00005B87 6A
02:00005B88 75
02:00005B89 37
02:00005B8A 38
02:00005B8B 2E
02:00005B8C 2E              	  2059: 	dc.b	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
02:00005B8D 2C
02:00005B8E 6B
02:00005B8F 69
02:00005B90 6F
02:00005B91 30
02:00005B92 39
02:00005B93 2E
02:00005B94 2E              	  2060: 	dc.b	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
02:00005B95 2E
02:00005B96 2F
02:00005B97 6C
02:00005B98 3B
02:00005B99 70
02:00005B9A 2D
02:00005B9B 2E
02:00005B9C 2E              	  2061: 	dc.b	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
02:00005B9D 2E
02:00005B9E 27
02:00005B9F 2E
02:00005BA0 5B
02:00005BA1 3D
02:00005BA2 2E
02:00005BA3 2E
02:00005BA4 AD              	  2062: 	dc.b	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
02:00005BA5 2E
02:00005BA6 0D
02:00005BA7 5D
02:00005BA8 2E
02:00005BA9 5C
02:00005BAA 2E
02:00005BAB 2E
02:00005BAC 2E              	  2063: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:00005BAD 2E
02:00005BAE 2E
02:00005BAF 2E
02:00005BB0 2E
02:00005BB1 2E
02:00005BB2 08
02:00005BB3 2E
02:00005BB4 2E              	  2064: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
02:00005BB5 95
02:00005BB6 2E
02:00005BB7 93
02:00005BB8 94
02:00005BB9 2E
02:00005BBA 2E
02:00005BBB 2E
02:00005BBC 98              	  2065: 	dc.b	$98,$7f,$92,$2e,$91,$90,$1b,$af
02:00005BBD 7F
02:00005BBE 92
02:00005BBF 2E
02:00005BC0 91
02:00005BC1 90
02:00005BC2 1B
02:00005BC3 AF
02:00005BC4 AB              	  2066: 	dc.b	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
02:00005BC5 2E
02:00005BC6 97
02:00005BC7 2E
02:00005BC8 2E
02:00005BC9 96
02:00005BCA AE
02:00005BCB 2E
                            	  2067: 
02:00005BCC 2E              	  2068: 	dc.b	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
02:00005BCD 2E
02:00005BCE 2E
02:00005BCF A7
02:00005BD0 2E
02:00005BD1 2E
02:00005BD2 2E
02:00005BD3 2E
02:00005BD4 2E              	  2069: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005BD5 2E
02:00005BD6 2E
02:00005BD7 2E
02:00005BD8 2E
02:00005BD9 2E
02:00005BDA 2E
02:00005BDB 2E
02:00005BDC 2E              	  2070: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005BDD 2E
02:00005BDE 2E
02:00005BDF 2E
02:00005BE0 2E
02:00005BE1 2E
02:00005BE2 2E
02:00005BE3 2E
02:00005BE4 2E              	  2071: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005BE5 2E
02:00005BE6 2E
02:00005BE7 2E
02:00005BE8 2E
02:00005BE9 2E
02:00005BEA 2E
02:00005BEB 2E
02:00005BEC 2E              	  2072: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005BED 2E
02:00005BEE 2E
02:00005BEF 2E
02:00005BF0 2E
02:00005BF1 2E
02:00005BF2 2E
02:00005BF3 2E
02:00005BF4 2E              	  2073: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005BF5 2E
02:00005BF6 2E
02:00005BF7 2E
02:00005BF8 2E
02:00005BF9 2E
02:00005BFA 2E
02:00005BFB 2E
02:00005BFC 2E              	  2074: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005BFD 2E
02:00005BFE 2E
02:00005BFF 2E
02:00005C00 2E
02:00005C01 2E
02:00005C02 2E
02:00005C03 2E
02:00005C04 2E              	  2075: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005C05 2E
02:00005C06 2E
02:00005C07 2E
02:00005C08 2E
02:00005C09 2E
02:00005C0A 2E
02:00005C0B 2E
02:00005C0C 2E              	  2076: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005C0D 2E
02:00005C0E 2E
02:00005C0F 2E
02:00005C10 2E
02:00005C11 2E
02:00005C12 2E
02:00005C13 2E
02:00005C14 2E              	  2077: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005C15 2E
02:00005C16 2E
02:00005C17 2E
02:00005C18 2E
02:00005C19 2E
02:00005C1A 2E
02:00005C1B 2E
02:00005C1C 2E              	  2078: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005C1D 2E
02:00005C1E 2E
02:00005C1F 2E
02:00005C20 2E
02:00005C21 2E
02:00005C22 2E
02:00005C23 2E
02:00005C24 2E              	  2079: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005C25 2E
02:00005C26 2E
02:00005C27 2E
02:00005C28 2E
02:00005C29 2E
02:00005C2A 2E
02:00005C2B 2E
02:00005C2C 2E              	  2080: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005C2D 2E
02:00005C2E 2E
02:00005C2F 2E
02:00005C30 2E
02:00005C31 2E
02:00005C32 2E
02:00005C33 2E
02:00005C34 2E              	  2081: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005C35 2E
02:00005C36 2E
02:00005C37 2E
02:00005C38 2E
02:00005C39 2E
02:00005C3A 2E
02:00005C3B 2E
02:00005C3C 2E              	  2082: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005C3D 2E
02:00005C3E 2E
02:00005C3F 2E
02:00005C40 2E
02:00005C41 2E
02:00005C42 2E
02:00005C43 2E
02:00005C44 2E              	  2083: 	dc.b	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
02:00005C45 2E
02:00005C46 FA
02:00005C47 2E
02:00005C48 2E
02:00005C49 2E
02:00005C4A 2E
02:00005C4B 2E
                            	  2084: 
                            	  2085: _shiftedScanCodes:
02:00005C4C 2E              	  2086: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005C4D 2E
02:00005C4E 2E
02:00005C4F 2E
02:00005C50 2E
02:00005C51 2E
02:00005C52 2E
02:00005C53 2E
02:00005C54 2E              	  2087: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
02:00005C55 2E
02:00005C56 2E
02:00005C57 2E
02:00005C58 2E
02:00005C59 09
02:00005C5A 7E
02:00005C5B 2E
02:00005C5C 2E              	  2088: 	dc.b	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
02:00005C5D 2E
02:00005C5E 2E
02:00005C5F 2E
02:00005C60 2E
02:00005C61 51
02:00005C62 21
02:00005C63 2E
02:00005C64 2E              	  2089: 	dc.b	$2e,$2e,$5a,$53,$41,$57,$40,$2e
02:00005C65 2E
02:00005C66 5A
02:00005C67 53
02:00005C68 41
02:00005C69 57
02:00005C6A 40
02:00005C6B 2E
02:00005C6C 2E              	  2090: 	dc.b	$2e,$43,$58,$44,$45,$24,$23,$2e
02:00005C6D 43
02:00005C6E 58
02:00005C6F 44
02:00005C70 45
02:00005C71 24
02:00005C72 23
02:00005C73 2E
02:00005C74 2E              	  2091: 	dc.b	$2e,$20,$56,$46,$54,$52,$25,$2e
02:00005C75 20
02:00005C76 56
02:00005C77 46
02:00005C78 54
02:00005C79 52
02:00005C7A 25
02:00005C7B 2E
02:00005C7C 2E              	  2092: 	dc.b	$2e,$4e,$42,$48,$47,$59,$5e,$2e
02:00005C7D 4E
02:00005C7E 42
02:00005C7F 48
02:00005C80 47
02:00005C81 59
02:00005C82 5E
02:00005C83 2E
02:00005C84 2E              	  2093: 	dc.b	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
02:00005C85 2E
02:00005C86 4D
02:00005C87 4A
02:00005C88 55
02:00005C89 26
02:00005C8A 2A
02:00005C8B 2E
02:00005C8C 2E              	  2094: 	dc.b	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
02:00005C8D 3C
02:00005C8E 4B
02:00005C8F 49
02:00005C90 4F
02:00005C91 29
02:00005C92 28
02:00005C93 2E
02:00005C94 2E              	  2095: 	dc.b	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
02:00005C95 3E
02:00005C96 3F
02:00005C97 4C
02:00005C98 3A
02:00005C99 50
02:00005C9A 5F
02:00005C9B 2E
02:00005C9C 2E              	  2096: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
02:00005C9D 2E
02:00005C9E 22
02:00005C9F 2E
02:00005CA0 7B
02:00005CA1 2B
02:00005CA2 2E
02:00005CA3 2E
02:00005CA4 2E              	  2097: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
02:00005CA5 2E
02:00005CA6 0D
02:00005CA7 7D
02:00005CA8 2E
02:00005CA9 7C
02:00005CAA 2E
02:00005CAB 2E
02:00005CAC 2E              	  2098: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:00005CAD 2E
02:00005CAE 2E
02:00005CAF 2E
02:00005CB0 2E
02:00005CB1 2E
02:00005CB2 08
02:00005CB3 2E
02:00005CB4 2E              	  2099: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005CB5 2E
02:00005CB6 2E
02:00005CB7 2E
02:00005CB8 2E
02:00005CB9 2E
02:00005CBA 2E
02:00005CBB 2E
02:00005CBC 2E              	  2100: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
02:00005CBD 7F
02:00005CBE 2E
02:00005CBF 2E
02:00005CC0 2E
02:00005CC1 2E
02:00005CC2 1B
02:00005CC3 2E
02:00005CC4 2E              	  2101: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005CC5 2E
02:00005CC6 2E
02:00005CC7 2E
02:00005CC8 2E
02:00005CC9 2E
02:00005CCA 2E
02:00005CCB 2E
                            	  2102: 
02:00005CCC 2E              	  2103: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005CCD 2E
02:00005CCE 2E
02:00005CCF 2E
02:00005CD0 2E
02:00005CD1 2E
02:00005CD2 2E
02:00005CD3 2E
02:00005CD4 2E              	  2104: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005CD5 2E
02:00005CD6 2E
02:00005CD7 2E
02:00005CD8 2E
02:00005CD9 2E
02:00005CDA 2E
02:00005CDB 2E
02:00005CDC 2E              	  2105: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005CDD 2E
02:00005CDE 2E
02:00005CDF 2E
02:00005CE0 2E
02:00005CE1 2E
02:00005CE2 2E
02:00005CE3 2E
02:00005CE4 2E              	  2106: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005CE5 2E
02:00005CE6 2E
02:00005CE7 2E
02:00005CE8 2E
02:00005CE9 2E
02:00005CEA 2E
02:00005CEB 2E
02:00005CEC 2E              	  2107: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005CED 2E
02:00005CEE 2E
02:00005CEF 2E
02:00005CF0 2E
02:00005CF1 2E
02:00005CF2 2E
02:00005CF3 2E
02:00005CF4 2E              	  2108: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005CF5 2E
02:00005CF6 2E
02:00005CF7 2E
02:00005CF8 2E
02:00005CF9 2E
02:00005CFA 2E
02:00005CFB 2E
02:00005CFC 2E              	  2109: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005CFD 2E
02:00005CFE 2E
02:00005CFF 2E
02:00005D00 2E
02:00005D01 2E
02:00005D02 2E
02:00005D03 2E
02:00005D04 2E              	  2110: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005D05 2E
02:00005D06 2E
02:00005D07 2E
02:00005D08 2E
02:00005D09 2E
02:00005D0A 2E
02:00005D0B 2E
02:00005D0C 2E              	  2111: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005D0D 2E
02:00005D0E 2E
02:00005D0F 2E
02:00005D10 2E
02:00005D11 2E
02:00005D12 2E
02:00005D13 2E
02:00005D14 2E              	  2112: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005D15 2E
02:00005D16 2E
02:00005D17 2E
02:00005D18 2E
02:00005D19 2E
02:00005D1A 2E
02:00005D1B 2E
02:00005D1C 2E              	  2113: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005D1D 2E
02:00005D1E 2E
02:00005D1F 2E
02:00005D20 2E
02:00005D21 2E
02:00005D22 2E
02:00005D23 2E
02:00005D24 2E              	  2114: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005D25 2E
02:00005D26 2E
02:00005D27 2E
02:00005D28 2E
02:00005D29 2E
02:00005D2A 2E
02:00005D2B 2E
02:00005D2C 2E              	  2115: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005D2D 2E
02:00005D2E 2E
02:00005D2F 2E
02:00005D30 2E
02:00005D31 2E
02:00005D32 2E
02:00005D33 2E
02:00005D34 2E              	  2116: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005D35 2E
02:00005D36 2E
02:00005D37 2E
02:00005D38 2E
02:00005D39 2E
02:00005D3A 2E
02:00005D3B 2E
02:00005D3C 2E              	  2117: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005D3D 2E
02:00005D3E 2E
02:00005D3F 2E
02:00005D40 2E
02:00005D41 2E
02:00005D42 2E
02:00005D43 2E
02:00005D44 2E              	  2118: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005D45 2E
02:00005D46 2E
02:00005D47 2E
02:00005D48 2E
02:00005D49 2E
02:00005D4A 2E
02:00005D4B 2E
                            	  2119: 
                            	  2120: ; control
                            	  2121: _keybdControlCodes:
02:00005D4C 2E              	  2122: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005D4D 2E
02:00005D4E 2E
02:00005D4F 2E
02:00005D50 2E
02:00005D51 2E
02:00005D52 2E
02:00005D53 2E
02:00005D54 2E              	  2123: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
02:00005D55 2E
02:00005D56 2E
02:00005D57 2E
02:00005D58 2E
02:00005D59 09
02:00005D5A 7E
02:00005D5B 2E
02:00005D5C 2E              	  2124: 	dc.b	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
02:00005D5D 2E
02:00005D5E 2E
02:00005D5F 2E
02:00005D60 2E
02:00005D61 11
02:00005D62 21
02:00005D63 2E
02:00005D64 2E              	  2125: 	dc.b	$2e,$2e,$1a,$13,$01,$17,$40,$2e
02:00005D65 2E
02:00005D66 1A
02:00005D67 13
02:00005D68 01
02:00005D69 17
02:00005D6A 40
02:00005D6B 2E
02:00005D6C 2E              	  2126: 	dc.b	$2e,$03,$18,$04,$05,$24,$23,$2e
02:00005D6D 03
02:00005D6E 18
02:00005D6F 04
02:00005D70 05
02:00005D71 24
02:00005D72 23
02:00005D73 2E
02:00005D74 2E              	  2127: 	dc.b	$2e,$20,$16,$06,$14,$12,$25,$2e
02:00005D75 20
02:00005D76 16
02:00005D77 06
02:00005D78 14
02:00005D79 12
02:00005D7A 25
02:00005D7B 2E
02:00005D7C 2E              	  2128: 	dc.b	$2e,$0e,$02,$08,$07,$19,$5e,$2e
02:00005D7D 0E
02:00005D7E 02
02:00005D7F 08
02:00005D80 07
02:00005D81 19
02:00005D82 5E
02:00005D83 2E
02:00005D84 2E              	  2129: 	dc.b	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
02:00005D85 2E
02:00005D86 0D
02:00005D87 0A
02:00005D88 15
02:00005D89 26
02:00005D8A 2A
02:00005D8B 2E
02:00005D8C 2E              	  2130: 	dc.b	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
02:00005D8D 3C
02:00005D8E 0B
02:00005D8F 09
02:00005D90 0F
02:00005D91 29
02:00005D92 28
02:00005D93 2E
02:00005D94 2E              	  2131: 	dc.b	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
02:00005D95 3E
02:00005D96 3F
02:00005D97 0C
02:00005D98 3A
02:00005D99 10
02:00005D9A 5F
02:00005D9B 2E
02:00005D9C 2E              	  2132: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
02:00005D9D 2E
02:00005D9E 22
02:00005D9F 2E
02:00005DA0 7B
02:00005DA1 2B
02:00005DA2 2E
02:00005DA3 2E
02:00005DA4 2E              	  2133: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
02:00005DA5 2E
02:00005DA6 0D
02:00005DA7 7D
02:00005DA8 2E
02:00005DA9 7C
02:00005DAA 2E
02:00005DAB 2E
02:00005DAC 2E              	  2134: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:00005DAD 2E
02:00005DAE 2E
02:00005DAF 2E
02:00005DB0 2E
02:00005DB1 2E
02:00005DB2 08
02:00005DB3 2E
02:00005DB4 2E              	  2135: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005DB5 2E
02:00005DB6 2E
02:00005DB7 2E
02:00005DB8 2E
02:00005DB9 2E
02:00005DBA 2E
02:00005DBB 2E
02:00005DBC 2E              	  2136: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
02:00005DBD 7F
02:00005DBE 2E
02:00005DBF 2E
02:00005DC0 2E
02:00005DC1 2E
02:00005DC2 1B
02:00005DC3 2E
02:00005DC4 2E              	  2137: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005DC5 2E
02:00005DC6 2E
02:00005DC7 2E
02:00005DC8 2E
02:00005DC9 2E
02:00005DCA 2E
02:00005DCB 2E
                            	  2138: 
                            	  2139: _keybdExtendedCodes:
02:00005DCC 2E              	  2140: 	dc.b	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
02:00005DCD 2E
02:00005DCE 2E
02:00005DCF 2E
02:00005DD0 A3
02:00005DD1 A1
02:00005DD2 A2
02:00005DD3 2E
02:00005DD4 2E              	  2141: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005DD5 2E
02:00005DD6 2E
02:00005DD7 2E
02:00005DD8 2E
02:00005DD9 2E
02:00005DDA 2E
02:00005DDB 2E
02:00005DDC 2E              	  2142: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005DDD 2E
02:00005DDE 2E
02:00005DDF 2E
02:00005DE0 2E
02:00005DE1 2E
02:00005DE2 2E
02:00005DE3 2E
02:00005DE4 2E              	  2143: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005DE5 2E
02:00005DE6 2E
02:00005DE7 2E
02:00005DE8 2E
02:00005DE9 2E
02:00005DEA 2E
02:00005DEB 2E
02:00005DEC 2E              	  2144: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005DED 2E
02:00005DEE 2E
02:00005DEF 2E
02:00005DF0 2E
02:00005DF1 2E
02:00005DF2 2E
02:00005DF3 2E
02:00005DF4 2E              	  2145: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005DF5 2E
02:00005DF6 2E
02:00005DF7 2E
02:00005DF8 2E
02:00005DF9 2E
02:00005DFA 2E
02:00005DFB 2E
02:00005DFC 2E              	  2146: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005DFD 2E
02:00005DFE 2E
02:00005DFF 2E
02:00005E00 2E
02:00005E01 2E
02:00005E02 2E
02:00005E03 2E
02:00005E04 2E              	  2147: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005E05 2E
02:00005E06 2E
02:00005E07 2E
02:00005E08 2E
02:00005E09 2E
02:00005E0A 2E
02:00005E0B 2E
02:00005E0C 2E              	  2148: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005E0D 2E
02:00005E0E 2E
02:00005E0F 2E
02:00005E10 2E
02:00005E11 2E
02:00005E12 2E
02:00005E13 2E
02:00005E14 2E              	  2149: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005E15 2E
02:00005E16 2E
02:00005E17 2E
02:00005E18 2E
02:00005E19 2E
02:00005E1A 2E
02:00005E1B 2E
02:00005E1C 2E              	  2150: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005E1D 2E
02:00005E1E 2E
02:00005E1F 2E
02:00005E20 2E
02:00005E21 2E
02:00005E22 2E
02:00005E23 2E
02:00005E24 2E              	  2151: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005E25 2E
02:00005E26 2E
02:00005E27 2E
02:00005E28 2E
02:00005E29 2E
02:00005E2A 2E
02:00005E2B 2E
02:00005E2C 2E              	  2152: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005E2D 2E
02:00005E2E 2E
02:00005E2F 2E
02:00005E30 2E
02:00005E31 2E
02:00005E32 2E
02:00005E33 2E
02:00005E34 2E              	  2153: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
02:00005E35 95
02:00005E36 2E
02:00005E37 93
02:00005E38 94
02:00005E39 2E
02:00005E3A 2E
02:00005E3B 2E
02:00005E3C 98              	  2154: 	dc.b	$98,$99,$92,$2e,$91,$90,$2e,$2e
02:00005E3D 99
02:00005E3E 92
02:00005E3F 2E
02:00005E40 91
02:00005E41 90
02:00005E42 2E
02:00005E43 2E
02:00005E44 2E              	  2155: 	dc.b	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
02:00005E45 2E
02:00005E46 97
02:00005E47 2E
02:00005E48 2E
02:00005E49 96
02:00005E4A 2E
02:00005E4B 2E
                            	  2156: 
                            	  2157: ;==============================================================================
                            	  2158: ;==============================================================================
                            	  2159: ; Monitor
                            	  2160: ;==============================================================================
                            	  2161: ;==============================================================================
                            	  2162: 
                            	  2163: cmdString:
02:00005E4C BF              	  2164: 	dc.b	'?'+$80						; ? display help
02:00005E4D CC              	  2165: 	dc.b	'L'+$80						; L load S19 file
02:00005E4E 46              	  2166: 	dc.b	'F','B'+$80				; FB fill with byte
02:00005E4F C2
02:00005E50 46              	  2167: 	dc.b	'F','W'+$80				; FW fill with wyde
02:00005E51 D7
02:00005E52 46              	  2168: 	dc.b	'F','L'+$80				; FL fill with long wyde
02:00005E53 CC
02:00005E54 42              	  2169: 	dc.b	'B','A'+$80				; BA start Tiny Basic
02:00005E55 C1
02:00005E56 42              	  2170: 	dc.b	'B','R'+$80				; BR breakpoint
02:00005E57 D2
02:00005E58 44              	  2171: 	dc.b	'D','R'+$80				; DR dump registers
02:00005E59 D2
02:00005E5A C4              	  2172: 	dc.b	'D'+$80						; D dump memory
02:00005E5B CA              	  2173: 	dc.b	'J'+$80						; J jump to code
02:00005E5C BA              	  2174: 	dc.b	':'+$80						; : edit memory
02:00005E5D 434C            	  2175: 	dc.b	"CL",'S'+$80			; CLS clear screen
02:00005E5F D3
02:00005E60 434F52          	  2176: 	dc.b	"COR",'E'+$80			; CORE <n> switch to core
02:00005E63 C5
02:00005E64 5446            	  2177: 	dc.b	"TF",'P'+$80			; TFP test fp
02:00005E66 D0
02:00005E67 5447            	  2178: 	dc.b  "TG",'F'+$80			; TGF test get float
02:00005E69 C6
02:00005E6A 545241          	  2179: 	dc.b  "TRA",'M'+$80			; TRAM test RAM
02:00005E6D CD
02:00005E6E 54              	  2180: 	dc.b	'T','R'+$80				; TR test serial receive
02:00005E6F D2
02:00005E70 D4              	  2181: 	dc.b	'T'+$80						; T test CPU
02:00005E71 D3              	  2182: 	dc.b	'S'+$80						; S send serial
02:00005E72 52455345        	  2183: 	dc.b	"RESE",'T'+$80		; RESET <n>
02:00005E76 D4
02:00005E77 434C4F43        	  2184: 	dc.b	"CLOC",'K'+$80		; CLOCK <n>
02:00005E7B CB
02:00005E7C D2              	  2185: 	dc.b	'R'+$80						; R receive serial
                            	  2186: 
                            	  2187: 	align	2
                            	  2188: cmdTable:
02:00005E80 60EA            	  2189: 	dc.w	cmdHelp
02:00005E82 6C98            	  2190: 	dc.w	cmdLoadS19
02:00005E84 6374            	  2191: 	dc.w	cmdFillB
02:00005E86 6398            	  2192: 	dc.w	cmdFillW
02:00005E88 63BC            	  2193: 	dc.w	cmdFillL
02:00005E8A 5F7C            	  2194: 	dc.w	cmdTinyBasic
02:00005E8C 5F58            	  2195: 	dc.w	cmdBreakpoint
02:00005E8E 64EE            	  2196: 	dc.w	cmdDumpRegs
02:00005E90 6460            	  2197: 	dc.w	cmdDumpMemory
02:00005E92 6452            	  2198: 	dc.w	cmdJump
02:00005E94 63F2            	  2199: 	dc.w	cmdEditMemory
02:00005E96 5F90            	  2200: 	dc.w	cmdClearScreen
02:00005E98 5F9C            	  2201: 	dc.w	cmdCore
02:00005E9A 5FC0            	  2202: 	dc.w  cmdTestFP
02:00005E9C 604C            	  2203: 	dc.w	cmdTestGF
02:00005E9E 6BDE            	  2204: 	dc.w  cmdTestRAM
02:00005EA0 6598            	  2205: 	dc.w	cmdTestSerialReceive
02:00005EA2 5F80            	  2206: 	dc.w	cmdTestCPU
02:00005EA4 6310            	  2207: 	dc.w	cmdSendSerial
02:00005EA6 6098            	  2208: 	dc.w	cmdReset
02:00005EA8 607A            	  2209: 	dc.w	cmdClock
02:00005EAA 6340            	  2210: 	dc.w	cmdReceiveSerial	
02:00005EAC 5EC2            	  2211: 	dc.w	cmdMonitor
                            	  2212: 
                            	  2213: ; Get a word from screen memory and swap byte order
                            	  2214: 
                            	  2215: FromScreen:
02:00005EAE 2210            	  2216: 	move.l	(a0),d1
02:00005EB0 61001002        	  2217: 	bsr			rbo
02:00005EB4 5088            	  2218: 	lea			8(a0),a0	; increment screen pointer
02:00005EB6 4E75            	  2219: 	rts
                            	  2220: 
                            	  2221: StartMon:
02:00005EB8 427900040202    	  2222: 	clr.w		NumSetBreakpoints
02:00005EBE 610014D0        	  2223: 	bsr			ClearBreakpointList
                            	  2224: cmdMonitor:
                            	  2225: Monitor:
                            	  2226: 	; Reset the stack pointer on each entry into the monitor
02:00005EC2 2E7C00040FFC    	  2227: 	move.l	#$40FFC,sp	; reset core's stack
02:00005EC8 46FC2200        	  2228: 	move.w	#$2200,sr		; enable level 2 and higher interrupts
02:00005ECC 4E7A0FE0        	  2229: 	movec		coreno,d0
02:00005ED0 4840            	  2230: 	swap		d0
02:00005ED2 7201            	  2231: 	moveq		#1,d1
02:00005ED4 6100A3A6        	  2232: 	bsr			UnlockSemaphore
02:00005ED8 42390004000C    	  2233: 	clr.b		KeybdEcho		; turn off keyboard echo
                            	  2234: PromptLn:
02:00005EDE 6100F24E        	  2235: 	bsr			CRLF
02:00005EE2 123C0024        	  2236: 	move.b	#'$',d1
02:00005EE6 6100F290        	  2237: 	bsr			DisplayChar
                            	  2238: 
                            	  2239: ; Get characters until a CR is keyed
                            	  2240: ;
                            	  2241: Prompt3:
02:00005EEA 6100F8D2        	  2242: 	bsr			GetKey
02:00005EEE 0C0100FF        	  2243: 	cmpi.b	#-1,d1
02:00005EF2 67F6            	  2244: 	beq.s		Prompt3
02:00005EF4 0C01000D        	  2245: 	cmpi.b	#CR,d1
02:00005EF8 6706            	  2246: 	beq.s		Prompt1
02:00005EFA 6100F27C        	  2247: 	bsr			DisplayChar
02:00005EFE 60EA            	  2248: 	bra.s		Prompt3
                            	  2249: 
                            	  2250: ; Process the screen line that the CR was keyed on
                            	  2251: 
                            	  2252: Prompt1:
02:00005F00 423900040001    	  2253: 	clr.b		CursorCol			; go back to the start of the line
02:00005F06 6100F262        	  2254: 	bsr			CalcScreenLoc	; a0 = screen memory location
                            	  2255: .0001:
02:00005F0A 61A2            	  2256: 	bsr			FromScreen		; grab character off screen
02:00005F0C 0C010024        	  2257: 	cmpi.b	#'$',d1				; skip over '$' prompt character
02:00005F10 67F8            	  2258: 	beq.s		.0001
                            	  2259: 	
                            	  2260: ; Dispatch based on command string
                            	  2261: 
                            	  2262: cmdDispatch:
02:00005F12 45FAFF38        	  2263: 	lea			cmdString,a2
02:00005F16 7800            	  2264: 	clr.l		d4						; command counter
02:00005F18 5188            	  2265: 	lea			-8(a0),a0			; backup a character
02:00005F1A 2648            	  2266: 	move.l	a0,a3					; a3 = start of command on screen
                            	  2267: .checkNextCmd:
02:00005F1C 6190            	  2268: 	bsr			FromScreen		; d1 = char from input screen
02:00005F1E 1A1A            	  2269: 	move.b	(a2)+,d5
02:00005F20 BB01            	  2270: 	eor.b		d5,d1					; does it match with command string?
02:00005F22 67F8            	  2271: 	beq.s		.checkNextCmd	; If it does, keep matching for longest match
02:00005F24 0C010080        	  2272: 	cmpi.b	#$80,d1				; didn't match, was it the end of the command?
02:00005F28 6724            	  2273: 	beq.s		.foundCmd
02:00005F2A 4A2AFFFF        	  2274: 	tst.b		-1(a2)				; was end of table hit?
02:00005F2E 6712            	  2275: 	beq.s		.endOfTable
02:00005F30 5444            	  2276: 	addi.w	#2,d4					; increment command counter
02:00005F32 204B            	  2277: 	move.l	a3,a0					; reset input pointer
02:00005F34 4A2AFFFF        	  2278: 	tst.b		-1(a2)				; were we at the end of the command?
02:00005F38 6BE2            	  2279: 	bmi.s		.checkNextCmd	; if were at end continue, otherwise scan for enf of cmd
                            	  2280: .scanToEndOfCmd
02:00005F3A 4A1A            	  2281: 	tst.b		(a2)+					; scan to end of command
02:00005F3C 6704            	  2282: 	beq.s		.endOfTable
02:00005F3E 6AFA            	  2283: 	bpl.s		.scanToEndOfCmd
02:00005F40 6BDA            	  2284: 	bmi.s		.checkNextCmd
                            	  2285: .endOfTable
02:00005F42 43FA0306        	  2286: 	lea			msgUnknownCmd,a1
02:00005F46 6100F4C0        	  2287: 	bsr			DisplayStringCRLF
02:00005F4A 6000FF76        	  2288: 	bra			Monitor
                            	  2289: .foundCmd:
02:00005F4E 43FAFF30        	  2290: 	lea			cmdTable,a1		; a1 = pointer to command address table
02:00005F52 32714000        	  2291: 	move.w	(a1,d4.w),a1	; fetch command routine address from table
02:00005F56 4ED1            	  2292: 	jmp			(a1)					; go execute command
                            	  2293: 
                            	  2294: cmdBreakpoint:
02:00005F58 61000486        	  2295: 	bsr			ignBlanks
02:00005F5C 6100FF50        	  2296: 	bsr			FromScreen
02:00005F60 0C01002B        	  2297: 	cmpi.b	#'+',d1
02:00005F64 67001338        	  2298: 	beq			ArmBreakpoint
02:00005F68 0C01002D        	  2299: 	cmpi.b	#'-',d1
02:00005F6C 670013AE        	  2300: 	beq			DisarmBreakpoint
02:00005F70 0C01004C        	  2301: 	cmpi.b	#'L',d1
02:00005F74 670013FA        	  2302: 	beq			ListBreakpoints
02:00005F78 6000FF48        	  2303: 	bra			Monitor
                            	  2304: 
                            	  2305: cmdTinyBasic:
02:00005F7C 6000DEFA        	  2306: 	bra			CSTART
                            	  2307: 
                            	  2308: cmdTestCPU:
02:00005F80 6100A394        	  2309: 	bsr			cpu_test
02:00005F84 43FA164E        	  2310: 	lea			msg_test_done,a1
02:00005F88 6100F47E        	  2311: 	bsr			DisplayStringCRLF
02:00005F8C 6000FF34        	  2312: 	bra			Monitor
                            	  2313: 
                            	  2314: cmdClearScreen:
02:00005F90 61000F1C        	  2315: 	bsr			ClearScreen
02:00005F94 6100F49E        	  2316: 	bsr			HomeCursor
02:00005F98 6000FF28        	  2317: 	bra			Monitor
                            	  2318: 
                            	  2319: cmdCore:
02:00005F9C 61000442        	  2320: 	bsr			ignBlanks
02:00005FA0 6100FF0C        	  2321: 	bsr			FromScreen
02:00005FA4 0C010032        	  2322: 	cmpi.b	#'2',d1					; check range
02:00005FA8 6500FF18        	  2323: 	blo			Monitor
02:00005FAC 0C010039        	  2324: 	cmpi.b	#'9',d1
02:00005FB0 6200FF10        	  2325: 	bhi			Monitor
02:00005FB4 04010030        	  2326: 	subi.b	#'0',d1					; convert ascii to binary
02:00005FB8 6100F5B2        	  2327: 	bsr			select_iofocus
02:00005FBC 6000FF04        	  2328: 	bra			Monitor
                            	  2329: 
                            	  2330: cmdTestFP:
02:00005FC0 7029            	  2331: 	moveq #41,d0						; function #41, get float
02:00005FC2 7208            	  2332: 	moveq #8,d1							; d1 = input stride
02:00005FC4 2248            	  2333: 	move.l a0,a1						; a1 = pointer to input buffer
02:00005FC6 4E4F            	  2334: 	trap #15
02:00005FC8 2049            	  2335: 	move.l a1,a0
02:00005FCA F2000200        	  2336: 	fmove.x fp0,fp4
02:00005FCE 61000410        	  2337: 	bsr ignBlanks
02:00005FD2 6100FEDA        	  2338: 	bsr FromScreen
02:00005FD6 1E01            	  2339: 	move.b d1,d7
02:00005FD8 7029            	  2340: 	moveq #41,d0						; function #41, get float
02:00005FDA 7208            	  2341: 	move.l #8,d1						; d1 = input stride
02:00005FDC 2248            	  2342: 	move.l a0,a1						; a1 = pointer to input buffer
02:00005FDE 4E4F            	  2343: 	trap #15
02:00005FE0 2049            	  2344: 	move.l a1,a0
02:00005FE2 F2000100        	  2345: 	fmove.x fp0,fp2
02:00005FE6 6100F146        	  2346: 	bsr CRLF
                            	  2347: ;	moveq #39,d0
                            	  2348: ;	moveq #40,d1
                            	  2349: ;	moveq #30,d2
                            	  2350: ;	moveq #'e',d3
                            	  2351: ;	trap #15
                            	  2352: ;	bsr CRLF
02:00005FEA F2396A00000402C0	  2353: 	fmove.x fp4,fpBuf
02:00005FF2 F2396900000402D0	  2354: 	fmove.x fp2,fpBuf+16
02:00005FFA 0C07002B        	  2355: 	cmpi.b #'+',d7
02:00005FFE 6606            	  2356: 	bne .0001
02:00006000 F2000A22        	  2357: 	fadd fp2,fp4
02:00006004 6022            	  2358: 	bra .0002
                            	  2359: .0001
02:00006006 0C07002D        	  2360: 	cmpi.b #'-',d7
02:0000600A 6606            	  2361: 	bne .0003
02:0000600C F2000A28        	  2362: 	fsub fp2,fp4
02:00006010 6016            	  2363: 	bra .0002
                            	  2364: .0003
02:00006012 0C07002A        	  2365: 	cmpi.b #'*',d7
02:00006016 6606            	  2366: 	bne .0004
02:00006018 F2000A23        	  2367: 	fmul fp2,fp4
02:0000601C 600A            	  2368: 	bra .0002
                            	  2369: .0004
02:0000601E 0C07002F        	  2370: 	cmpi.b #'/',d7
02:00006022 6620            	  2371: 	bne .0005
02:00006024 F2000A20        	  2372: 	fdiv fp2,fp4
                            	  2373: 	bra .0002
                            	  2374: .0002
02:00006028 F2396A00000402E0	  2375: 	fmove.x fp4,fpBuf+32
02:00006030 F2001000        	  2376: 	fmove.x fp4,fp0
02:00006034 43F900040520    	  2377: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
02:0000603A 7027            	  2378: 	moveq #39,d0						; function #39 print float
02:0000603C 7228            	  2379: 	moveq #40,d1						; width
02:0000603E 741E            	  2380: 	moveq #30,d2						; precision
02:00006040 7665            	  2381: 	moveq #'e',d3
02:00006042 4E4F            	  2382: 	trap #15
                            	  2383: .0005
02:00006044 6100F0E8        	  2384: 	bsr CRLF
02:00006048 6000FE78        	  2385: 	bra Monitor
                            	  2386: 
                            	  2387: cmdTestGF:
02:0000604C 6100F0E0        	  2388: 	bsr CRLF
02:00006050 7029            	  2389: 	moveq #41,d0						; function #41, get float
02:00006052 7208            	  2390: 	move.l #8,d1						; d1 = input stride
02:00006054 2248            	  2391: 	move.l a0,a1						; a1 = pointer to input buffer
02:00006056 4E4F            	  2392: 	trap #15
02:00006058 F2396800000402E0	  2393: 	fmove.x fp0,fpBuf+32
02:00006060 43F900040520    	  2394: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
02:00006066 7027            	  2395: 	moveq #39,d0
02:00006068 7228            	  2396: 	moveq #40,d1
02:0000606A 741E            	  2397: 	moveq #30,d2
02:0000606C 7665            	  2398: 	moveq #'e',d3
02:0000606E 4E4F            	  2399: 	trap #15
02:00006070 2049            	  2400: 	move.l a1,a0
02:00006072 6100F0BA        	  2401: 	bsr CRLF
02:00006076 6000FE4A        	  2402: 	bra Monitor
                            	  2403: 		
                            	  2404: ;-------------------------------------------------------------------------------
                            	  2405: ; CLOCK <n>
                            	  2406: ;    Set the clock register to n which will turn off or on clocks to the CPUs.
                            	  2407: ;-------------------------------------------------------------------------------
                            	  2408: 
                            	  2409: cmdClock:
02:0000607A 61000364        	  2410: 	bsr			ignBlanks
02:0000607E 61000538        	  2411: 	bsr			GetHexNumber
02:00006082 4A00            	  2412: 	tst.b		d0							; was there a number?
02:00006084 6700FE3C        	  2413: 	beq			Monitor
02:00006088 00400004        	  2414: 	ori.w		#4,d0						; primary core's clock cannot be turned off
02:0000608C E159            	  2415: 	rol.w		#8,d1						; switch byte order
02:0000608E 33C1FD0FFC02    	  2416: 	move.w	d1,RST_REG+2
02:00006094 6000FE2C        	  2417: 	bra			Monitor
                            	  2418: 
                            	  2419: ;-------------------------------------------------------------------------------
                            	  2420: ; RESET <n>
                            	  2421: ;    Reset the specified core. Resetting the core automatically turns on the 
                            	  2422: ; core's clock.
                            	  2423: ;-------------------------------------------------------------------------------
                            	  2424: 
                            	  2425: cmdReset:
02:00006098 61000346        	  2426: 	bsr			ignBlanks
02:0000609C 6100FE10        	  2427: 	bsr			FromScreen
02:000060A0 0C010032        	  2428: 	cmpi.b	#'2',d1					; check range
02:000060A4 6500FE1C        	  2429: 	blo			Monitor
02:000060A8 0C010039        	  2430: 	cmpi.b	#'9',d1
02:000060AC 6200FE14        	  2431: 	bhi			Monitor
02:000060B0 04010030        	  2432: 	subi.b	#'0',d1					; convert ascii to binary
02:000060B4 E349            	  2433: 	lsl.w		#1,d1						; make into index
02:000060B6 43FA0012        	  2434: 	lea			tblPow2,a1
02:000060BA 32311000        	  2435: 	move.w	(a1,d1.w),d1
02:000060BE E159            	  2436: 	rol.w		#8,d1						; reverse byte order
02:000060C0 33C1FD0FFC00    	  2437: 	move.w	d1,RST_REG
02:000060C6 6000FDFA        	  2438: 	bra			Monitor
                            	  2439: 
                            	  2440: tblPow2:
02:000060CA 0001            	  2441: 	dc.w		1
02:000060CC 0002            	  2442: 	dc.w		2
02:000060CE 0004            	  2443: 	dc.w		4
02:000060D0 0008            	  2444: 	dc.w		8
02:000060D2 0010            	  2445: 	dc.w		16
02:000060D4 0020            	  2446: 	dc.w		32
02:000060D6 0040            	  2447: 	dc.w		64
02:000060D8 0080            	  2448: 	dc.w		128
02:000060DA 0100            	  2449: 	dc.w		256
02:000060DC 0200            	  2450: 	dc.w		512
02:000060DE 0400            	  2451: 	dc.w		1024
02:000060E0 0800            	  2452: 	dc.w		2048
02:000060E2 1000            	  2453: 	dc.w		4096
02:000060E4 2000            	  2454: 	dc.w		8192
02:000060E6 4000            	  2455: 	dc.w		16384
02:000060E8 8000            	  2456: 	dc.w		32768
                            	  2457: 	even
                            	  2458: 	
                            	  2459: cmdHelp:
                            	  2460: DisplayHelp:
02:000060EA 43FA000A        	  2461: 	lea			HelpMsg,a1
02:000060EE 6100F302        	  2462: 	bsr			DisplayString
02:000060F2 6000FDCE        	  2463: 	bra			Monitor
                            	  2464: 
                            	  2465: HelpMsg:
02:000060F6 3F203D2044697370	  2466: 	dc.b	"? = Display help",LF,CR
02:000060FE 6C61792068656C70
02:00006106 0A
02:00006107 0D
02:00006108 434F5245206E203D	  2467: 	dc.b  "CORE n = switch to core n, n = 2 to 7",LF,CR
02:00006110 2073776974636820
02:00006118 746F20636F726520
02:00006120 6E2C206E203D2032
02:00006128 20746F2037
02:0000612D 0A
02:0000612E 0D
02:0000612F 5245534554206E20	  2468: 	dc.b  "RESET n = reset core n",LF,CR
02:00006137 3D20726573657420
02:0000613F 636F7265206E
02:00006145 0A
02:00006146 0D
02:00006147 434C53203D20636C	  2469: 	dc.b	"CLS = clear screen",LF,CR
02:0000614F 6561722073637265
02:00006157 656E
02:00006159 0A
02:0000615A 0D
02:0000615B 3A203D2045646974	  2470: 	dc.b	": = Edit memory bytes",LF,CR
02:00006163 206D656D6F727920
02:0000616B 6279746573
02:00006170 0A
02:00006171 0D
02:00006172 4642203D2046696C	  2471: 	dc.b	"FB = Fill memory bytes, FW, FL",LF,CR
02:0000617A 6C206D656D6F7279
02:00006182 2062797465732C20
02:0000618A 46572C20464C
02:00006190 0A
02:00006191 0D
02:00006192 4C203D204C6F6164	  2472: 	dc.b	"L = Load S19 file",LF,CR
02:0000619A 205331392066696C
02:000061A2 65
02:000061A3 0A
02:000061A4 0D
02:000061A5 44203D2044756D70	  2473: 	dc.b	"D = Dump memory, DR = dump registers",LF,CR
02:000061AD 206D656D6F72792C
02:000061B5 204452203D206475
02:000061BD 6D70207265676973
02:000061C5 74657273
02:000061C9 0A
02:000061CA 0D
02:000061CB 4241203D20737461	  2474: 	dc.b	"BA = start tiny basic",LF,CR
02:000061D3 72742074696E7920
02:000061DB 6261736963
02:000061E0 0A
02:000061E1 0D
02:000061E2 4252203D20736574	  2475: 	dc.b  "BR = set breakpoint",LF,CR
02:000061EA 20627265616B706F
02:000061F2 696E74
02:000061F5 0A
02:000061F6 0D
02:000061F7 4A203D204A756D70	  2476: 	dc.b	"J = Jump to code",LF,CR
02:000061FF 20746F20636F6465
02:00006207 0A
02:00006208 0D
02:00006209 53203D2073656E64	  2477: 	dc.b  "S = send to serial port",LF,CR
02:00006211 20746F2073657269
02:00006219 616C20706F7274
02:00006220 0A
02:00006221 0D
02:00006222 54203D2063707520	  2478: 	dc.b	"T = cpu test program",LF,CR
02:0000622A 746573742070726F
02:00006232 6772616D
02:00006236 0A
02:00006237 0D
02:00006238 5452414D203D2074	  2479: 	dc.b	"TRAM = test RAM",LF,CR,0
02:00006240 6573742052414D
02:00006247 0A
02:00006248 0D
02:00006249 00
                            	  2480: 
                            	  2481: msgUnknownCmd:
02:0000624A 636F6D6D616E6420	  2482: 	dc.b	"command unknown",0
02:00006252 756E6B6E6F776E
02:00006259 00
                            	  2483: 
                            	  2484: msgHello:
02:0000625A 0A              	  2485: 	dc.b	LF,CR,"Hello World!",LF,CR,0
02:0000625B 0D
02:0000625C 48656C6C6F20576F
02:00006264 726C6421
02:00006268 0A
02:00006269 0D
02:0000626A 00
                            	  2486: 	even
                            	  2487: 
                            	  2488: ;------------------------------------------------------------------------------
                            	  2489: ; This routine borrowed from Gordo's Tiny Basic interpreter.
                            	  2490: ; Used to fetch a command line. (Not currently used).
                            	  2491: ;
                            	  2492: ; d0.b	- command prompt
                            	  2493: ;------------------------------------------------------------------------------
                            	  2494: 
                            	  2495: GetCmdLine:
02:0000626C 6100EF0A        	  2496: 		bsr		DisplayChar		; display prompt
02:00006270 103C0020        	  2497: 		move.b	#' ',d0
02:00006274 6100EF02        	  2498: 		bsr		DisplayChar
02:00006278 41F900040040    	  2499: 		lea		CmdBuf,a0
                            	  2500: .0001:
02:0000627E 6100F53E        	  2501: 		bsr		GetKey
02:00006282 B03C0008        	  2502: 		cmp.b	#CTRLH,d0
02:00006286 6728            	  2503: 		beq.s	.0003
02:00006288 B03C0018        	  2504: 		cmp.b	#CTRLX,d0
02:0000628C 6746            	  2505: 		beq.s	.0004
02:0000628E B03C000D        	  2506: 		cmp.b	#CR,d0
02:00006292 6706            	  2507: 		beq.s	.0002
02:00006294 B03C0020        	  2508: 		cmp.b	#' ',d0
02:00006298 65E4            	  2509: 		bcs.s	.0001
                            	  2510: .0002:
02:0000629A 1080            	  2511: 		move.b	d0,(a0)
02:0000629C 5088            	  2512: 		lea			8(a0),a0
02:0000629E 6100EED8        	  2513: 		bsr		DisplayChar
02:000062A2 B03C000D        	  2514: 		cmp.b	#CR,d0
02:000062A6 675E            	  2515: 		beq		.0007
02:000062A8 B1FC0004007F    	  2516: 		cmp.l	#CmdBufEnd-1,a0
02:000062AE 65CE            	  2517: 		bcs.s	.0001
                            	  2518: .0003:
02:000062B0 103C0008        	  2519: 		move.b	#CTRLH,d0
02:000062B4 6100EEC2        	  2520: 		bsr		DisplayChar
02:000062B8 103C0020        	  2521: 		move.b	#' ',d0
02:000062BC 6100EEBA        	  2522: 		bsr		DisplayChar
02:000062C0 B1FC00040040    	  2523: 		cmp.l	#CmdBuf,a0
02:000062C6 63B6            	  2524: 		bls.s	.0001
02:000062C8 103C0008        	  2525: 		move.b	#CTRLH,d0
02:000062CC 6100EEAA        	  2526: 		bsr		DisplayChar
02:000062D0 5388            	  2527: 		subq.l	#1,a0
02:000062D2 60AA            	  2528: 		bra.s	.0001
                            	  2529: .0004:
02:000062D4 2208            	  2530: 		move.l	a0,d1
02:000062D6 92BC00040040    	  2531: 		sub.l	#CmdBuf,d1
02:000062DC 671E            	  2532: 		beq.s	.0006
02:000062DE 5341            	  2533: 		subq	#1,d1
                            	  2534: .0005:
02:000062E0 103C0008        	  2535: 		move.b	#CTRLH,d0
02:000062E4 6100EE92        	  2536: 		bsr		DisplayChar
02:000062E8 103C0020        	  2537: 		move.b	#' ',d0
02:000062EC 6100EE8A        	  2538: 		bsr		DisplayChar
02:000062F0 103C0008        	  2539: 		move.b	#CTRLH,d0
02:000062F4 6100EE82        	  2540: 		bsr		DisplayChar
02:000062F8 51C9FFE6        	  2541: 		dbra	d1,.0005
                            	  2542: .0006:
02:000062FC 41F900040040    	  2543: 		lea		CmdBuf,a0
02:00006302 6000FF7A        	  2544: 		bra		.0001
                            	  2545: .0007:
02:00006306 103C000A        	  2546: 		move.b	#LF,d0
02:0000630A 6100EE6C        	  2547: 		bsr		DisplayChar
02:0000630E 4E75            	  2548: 		rts
                            	  2549: 
                            	  2550: ;------------------------------------------------------------------------------
                            	  2551: ; S <address> <length>
                            	  2552: ; Send data buffer to serial port
                            	  2553: ; S 40000 40
                            	  2554: ;------------------------------------------------------------------------------
                            	  2555: 
                            	  2556: cmdSendSerial:
02:00006310 610000CE        	  2557: 	bsr			ignBlanks
02:00006314 610002A2        	  2558: 	bsr			GetHexNumber
02:00006318 6700FBA8        	  2559: 	beq			Monitor
02:0000631C 2C01            	  2560: 	move.l	d1,d6					; d6 points to buffer
02:0000631E 610000C0        	  2561: 	bsr			ignBlanks
02:00006322 61000294        	  2562: 	bsr			GetHexNumber
02:00006326 6602            	  2563: 	bne.s		.0003
02:00006328 7210            	  2564: 	moveq		#16,d1
                            	  2565: .0003:
02:0000632A 2246            	  2566: 	move.l	d6,a1					; a1 points to buffer
02:0000632C 2401            	  2567: 	move.l	d1,d2					; d2 = count of bytes to send
02:0000632E 6008            	  2568: 	bra.s		.0002					; enter loop at bottom
                            	  2569: .0001:
02:00006330 1219            	  2570: 	move.b	(a1)+,d1
02:00006332 303C0022        	  2571: 	move.w	#34,d0				; serial putchar
02:00006336 4E4F            	  2572: 	trap		#15
                            	  2573: .0002:
02:00006338 51CAFFF6        	  2574: 	dbra		d2,.0001
02:0000633C 6000FB84        	  2575: 	bra			Monitor
                            	  2576: 		
                            	  2577: ;------------------------------------------------------------------------------
                            	  2578: ; R <address> <length>
                            	  2579: ; Send data buffer to serial port
                            	  2580: ; R 10000 40
                            	  2581: ;------------------------------------------------------------------------------
                            	  2582: 
                            	  2583: cmdReceiveSerial:
02:00006340 6100009E        	  2584: 	bsr			ignBlanks
02:00006344 61000272        	  2585: 	bsr			GetHexNumber
02:00006348 6700FB78        	  2586: 	beq			Monitor
02:0000634C 2C01            	  2587: 	move.l	d1,d6					; d6 points to buffer
02:0000634E 61000090        	  2588: 	bsr			ignBlanks
02:00006352 61000264        	  2589: 	bsr			GetHexNumber
02:00006356 6602            	  2590: 	bne.s		.0003
02:00006358 7210            	  2591: 	moveq		#16,d1
                            	  2592: .0003:
02:0000635A 2246            	  2593: 	move.l	d6,a1					; a1 points to buffer
02:0000635C 2401            	  2594: 	move.l	d1,d2					; d2 = count of bytes to send
02:0000635E 600C            	  2595: 	bra.s		.0002					; enter loop at bottom
                            	  2596: .0001:
02:00006360 303C0024        	  2597: 	move.w	#36,d0				; serial peek char
02:00006364 4E4F            	  2598: 	trap		#15
02:00006366 4A81            	  2599: 	tst.l		d1
02:00006368 6BF6            	  2600: 	bmi.s		.0001
02:0000636A 12C1            	  2601: 	move.b	d1,(a1)+
                            	  2602: .0002:
02:0000636C 51CAFFF2        	  2603: 	dbra		d2,.0001
02:00006370 6000FB50        	  2604: 	bra			Monitor
                            	  2605: 		
                            	  2606: ;------------------------------------------------------------------------------
                            	  2607: ; Fill memory
                            	  2608: ;
                            	  2609: ; FB = fill bytes		FB 00000010 100 FF	; fill starting at 10 for 256 bytes
                            	  2610: ; FW = fill words
                            	  2611: ; FL = fill longs
                            	  2612: ; F = fill bytes
                            	  2613: ;------------------------------------------------------------------------------
                            	  2614: 
                            	  2615: cmdFillB:
02:00006374 616A            	  2616: 	bsr			ignBlanks
02:00006376 61000240        	  2617: 	bsr			GetHexNumber
02:0000637A 2241            	  2618: 	move.l	d1,a1					; a1 = start
02:0000637C 6162            	  2619: 	bsr			ignBlanks
02:0000637E 61000238        	  2620: 	bsr			GetHexNumber
02:00006382 2601            	  2621: 	move.l	d1,d3					; d3 = count
02:00006384 6700FB3C        	  2622: 	beq			Monitor
02:00006388 6156            	  2623: 	bsr			ignBlanks
02:0000638A 6100022C        	  2624: 	bsr			GetHexNumber	; fill value
                            	  2625: .fmem:
02:0000638E 12C1            	  2626: 	move.b	d1,(a1)+
02:00006390 5383            	  2627: 	sub.l		#1,d3
02:00006392 66FA            	  2628: 	bne.s		.fmem
02:00006394 6000FB2C        	  2629: 	bra			Monitor
                            	  2630: 	
                            	  2631: cmdFillW:
02:00006398 6146            	  2632: 	bsr			ignBlanks
02:0000639A 6100021C        	  2633: 	bsr			GetHexNumber
02:0000639E 2241            	  2634: 	move.l	d1,a1					; a1 = start
02:000063A0 613E            	  2635: 	bsr			ignBlanks
02:000063A2 61000214        	  2636: 	bsr			GetHexNumber
02:000063A6 2601            	  2637: 	move.l	d1,d3					; d3 = count
02:000063A8 6700FB18        	  2638: 	beq			Monitor
02:000063AC 6132            	  2639: 	bsr			ignBlanks
02:000063AE 61000208        	  2640: 	bsr			GetHexNumber	; fill value
                            	  2641: .fmem:
02:000063B2 32C1            	  2642: 	move.w	d1,(a1)+
02:000063B4 5383            	  2643: 	sub.l		#1,d3
02:000063B6 66FA            	  2644: 	bne.s		.fmem
02:000063B8 6000FB08        	  2645: 	bra			Monitor
                            	  2646: 	
                            	  2647: cmdFillL:
02:000063BC 6122            	  2648: 	bsr			ignBlanks
02:000063BE 610001F8        	  2649: 	bsr			GetHexNumber
02:000063C2 2241            	  2650: 	move.l	d1,a1					; a1 = start
02:000063C4 611A            	  2651: 	bsr			ignBlanks
02:000063C6 610001F0        	  2652: 	bsr			GetHexNumber
02:000063CA 2601            	  2653: 	move.l	d1,d3					; d3 = count
02:000063CC 6700FAF4        	  2654: 	beq			Monitor
02:000063D0 610E            	  2655: 	bsr			ignBlanks
02:000063D2 610001E4        	  2656: 	bsr			GetHexNumber	; fill value
                            	  2657: .fmem:
02:000063D6 22C1            	  2658: 	move.l	d1,(a1)+
02:000063D8 5383            	  2659: 	sub.l		#1,d3
02:000063DA 66FA            	  2660: 	bne.s		.fmem
02:000063DC 6000FAE4        	  2661: 	bra			Monitor
                            	  2662: 	
                            	  2663: ;------------------------------------------------------------------------------
                            	  2664: ; Modifies:
                            	  2665: ;	a0	- text pointer
                            	  2666: ;------------------------------------------------------------------------------
                            	  2667: 
                            	  2668: ignBlanks:
02:000063E0 2F01            	  2669: 	move.l	d1,-(a7)
                            	  2670: .0001:
02:000063E2 6100FACA        	  2671: 	bsr			FromScreen
02:000063E6 0C010020        	  2672: 	cmpi.b	#' ',d1
02:000063EA 67F6            	  2673: 	beq.s		.0001
02:000063EC 5188            	  2674: 	lea			-8(a0),a0
02:000063EE 221F            	  2675: 	move.l	(a7)+,d1
02:000063F0 4E75            	  2676: 	rts
                            	  2677: 
                            	  2678: ;------------------------------------------------------------------------------
                            	  2679: ; Edit memory byte.
                            	  2680: ;    Bytes are built into long words in case the memory is only longword
                            	  2681: ; accessible.
                            	  2682: ;------------------------------------------------------------------------------
                            	  2683: 
                            	  2684: cmdEditMemory:
02:000063F2 61EC            	  2685: 	bsr			ignBlanks
02:000063F4 610001C2        	  2686: 	bsr			GetHexNumber
02:000063F8 2241            	  2687: 	move.l	d1,a1
                            	  2688: edtmem1:
02:000063FA 7400            	  2689: 	clr.l		d2
02:000063FC 61E2            	  2690: 	bsr			ignBlanks
02:000063FE 610001B8        	  2691: 	bsr			GetHexNumber
02:00006402 1401            	  2692: 	move.b	d1,d2
                            	  2693: ;	move.b	d1,(a1)+
02:00006404 61DA            	  2694: 	bsr			ignBlanks
02:00006406 610001B0        	  2695: 	bsr			GetHexNumber
02:0000640A E18A            	  2696: 	lsl.l		#8,d2
02:0000640C 1401            	  2697: 	move.b	d1,d2
                            	  2698: ;	move.b	d1,(a1)+
02:0000640E 61D0            	  2699: 	bsr			ignBlanks
02:00006410 610001A6        	  2700: 	bsr			GetHexNumber
02:00006414 E18A            	  2701: 	lsl.l		#8,d2
02:00006416 1401            	  2702: 	move.b	d1,d2
                            	  2703: ;	move.b	d1,(a1)+
02:00006418 61C6            	  2704: 	bsr			ignBlanks
02:0000641A 6100019C        	  2705: 	bsr			GetHexNumber
02:0000641E E18A            	  2706: 	lsl.l		#8,d2
02:00006420 1401            	  2707: 	move.b	d1,d2
02:00006422 22C2            	  2708: 	move.l	d2,(a1)+
                            	  2709: ;	move.b	d1,(a1)+
02:00006424 7400            	  2710: 	clr.l		d2
02:00006426 61B8            	  2711: 	bsr			ignBlanks
02:00006428 6100018E        	  2712: 	bsr			GetHexNumber
02:0000642C 1401            	  2713: 	move.b	d1,d2
                            	  2714: ;	move.b	d1,(a1)+
02:0000642E 61B0            	  2715: 	bsr			ignBlanks
02:00006430 61000186        	  2716: 	bsr			GetHexNumber
02:00006434 E18A            	  2717: 	lsl.l		#8,d2
02:00006436 1401            	  2718: 	move.b	d1,d2
                            	  2719: ;	move.b	d1,(a1)+
02:00006438 61A6            	  2720: 	bsr			ignBlanks
02:0000643A 6100017C        	  2721: 	bsr			GetHexNumber
02:0000643E E18A            	  2722: 	lsl.l		#8,d2
02:00006440 1401            	  2723: 	move.b	d1,d2
                            	  2724: ;	move.b	d1,(a1)+
02:00006442 619C            	  2725: 	bsr			ignBlanks
02:00006444 61000172        	  2726: 	bsr			GetHexNumber
02:00006448 E18A            	  2727: 	lsl.l		#8,d2
02:0000644A 1401            	  2728: 	move.b	d1,d2
                            	  2729: ;	move.b	d1,(a1)+
02:0000644C 22C2            	  2730: 	move.l	d2,(a1)+
02:0000644E 6000FA72        	  2731: 	bra			Monitor
                            	  2732: 
                            	  2733: ;------------------------------------------------------------------------------
                            	  2734: ; Execute code at the specified address.
                            	  2735: ;------------------------------------------------------------------------------
                            	  2736: 
                            	  2737: cmdJump:
                            	  2738: ExecuteCode:
02:00006452 618C            	  2739: 	bsr			ignBlanks
02:00006454 61000162        	  2740: 	bsr			GetHexNumber
02:00006458 2041            	  2741: 	move.l	d1,a0
02:0000645A 4E90            	  2742: 	jsr			(a0)
02:0000645C 6000FA64        	  2743: 	bra     Monitor
                            	  2744: 
                            	  2745: ;------------------------------------------------------------------------------
                            	  2746: ; Do a memory dump of the requested location.
                            	  2747: ; D 0800 0850
                            	  2748: ;------------------------------------------------------------------------------
                            	  2749: 
                            	  2750: cmdDumpMemory:
02:00006460 6100FF7E        	  2751: 	bsr			ignBlanks
02:00006464 61000152        	  2752: 	bsr			GetHexNumber
02:00006468 6700FA58        	  2753: 	beq			Monitor			; was there a number ? no, other garbage, just ignore
02:0000646C 2601            	  2754: 	move.l	d1,d3				; save off start of range
02:0000646E 6100FF70        	  2755: 	bsr			ignBlanks
02:00006472 61000144        	  2756: 	bsr			GetHexNumber
02:00006476 6608            	  2757: 	bne.s		DumpMem1
02:00006478 2203            	  2758: 	move.l	d3,d1
02:0000647A 068100000040    	  2759: 	addi.l	#64,d1			; no end specified, just dump 64 bytes
                            	  2760: DumpMem1:
02:00006480 2043            	  2761: 	move.l	d3,a0
02:00006482 2241            	  2762: 	move.l	d1,a1
02:00006484 6100ECA8        	  2763: 	bsr			CRLF
                            	  2764: .0001:
02:00006488 B3C8            	  2765: 	cmpa.l	a0,a1
02:0000648A 6300FA36        	  2766: 	bls			Monitor
02:0000648E 6102            	  2767: 	bsr			DisplayMem
02:00006490 60F6            	  2768: 	bra.s		.0001
                            	  2769: 
                            	  2770: ;------------------------------------------------------------------------------
                            	  2771: ; Display memory dump in a format suitable for edit.
                            	  2772: ;
                            	  2773: ;	:12345678 00 11 22 33 44 55 66 77  "........"
                            	  2774: ;
                            	  2775: ; Modifies:
                            	  2776: ;		d1,d2,a0
                            	  2777: ;------------------------------------------------------------------------------
                            	  2778: 
                            	  2779: DisplayMem:
02:00006492 123C003A        	  2780: 	move.b	#':',d1
02:00006496 6100ECE0        	  2781: 	bsr			DisplayChar
02:0000649A 2208            	  2782: 	move.l	a0,d1
02:0000649C 610006F6        	  2783: 	bsr			DisplayTetra
02:000064A0 7407            	  2784: 	moveq		#7,d2
                            	  2785: dspmem1:
02:000064A2 123C0020        	  2786: 	move.b	#' ',d1
02:000064A6 6100ECD0        	  2787: 	bsr			DisplayChar
02:000064AA 1218            	  2788: 	move.b	(a0)+,d1
02:000064AC 610006F2        	  2789: 	bsr			DisplayByte
02:000064B0 51CAFFF0        	  2790: 	dbra		d2,dspmem1
02:000064B4 610006C4        	  2791: 	bsr			DisplayTwoSpaces
02:000064B8 123C0022        	  2792: 	move.b	#34,d1
02:000064BC 6100ECBA        	  2793: 	bsr			DisplayChar
02:000064C0 5188            	  2794: 	lea			-8(a0),a0
02:000064C2 7407            	  2795: 	moveq		#7,d2
                            	  2796: .0002:	
02:000064C4 1218            	  2797: 	move.b	(a0)+,d1
02:000064C6 B23C0020        	  2798: 	cmp.b		#' ',d1
02:000064CA 6506            	  2799: 	blo.s		.0003
02:000064CC B23C007F        	  2800: 	cmp.b		#127,d1
02:000064D0 6304            	  2801: 	bls.s		.0001
                            	  2802: .0003:
02:000064D2 123C002E        	  2803: 	move.b	#'.',d1
                            	  2804: .0001:
02:000064D6 6100ECA0        	  2805: 	bsr			DisplayChar
02:000064DA 51CAFFE8        	  2806: 	dbra		d2,.0002
02:000064DE 123C0022        	  2807: 	move.b	#34,d1
02:000064E2 6100EC94        	  2808: 	bsr			DisplayChar
02:000064E6 6100F30E        	  2809: 	bsr			CheckForCtrlC
02:000064EA 6000EC42        	  2810: 	bra			CRLF
                            	  2811: 
                            	  2812: ;------------------------------------------------------------------------------
                            	  2813: ; Dump Registers
                            	  2814: ;    The dump is in a format that allows the register value to be edited.
                            	  2815: ;
                            	  2816: ; RegD0 12345678
                            	  2817: ; RegD1 77777777
                            	  2818: ;	... etc
                            	  2819: ;------------------------------------------------------------------------------
                            	  2820: 
                            	  2821: cmdDumpRegs:
02:000064EE 6100EC3E        	  2822: 	bsr			CRLF
02:000064F2 303C000F        	  2823: 	move.w	#15,d0					; number of registers-1
02:000064F6 41FA007A        	  2824: 	lea			msg_reglist,a0	;
02:000064FA 43FA0072        	  2825: 	lea			msg_regs,a1
02:000064FE 45F900040100    	  2826: 	lea			Regsave,a2			; a2 points to register save area
                            	  2827: .0001:
02:00006504 6100EEEC        	  2828: 	bsr			DisplayString
02:00006508 1218            	  2829: 	move.b	(a0)+,d1
02:0000650A 6100EC6C        	  2830: 	bsr			DisplayChar
02:0000650E 1218            	  2831: 	move.b	(a0)+,d1
02:00006510 6100EC66        	  2832: 	bsr			DisplayChar
02:00006514 61000676        	  2833: 	bsr			DisplaySpace
02:00006518 221A            	  2834: 	move.l	(a2)+,d1
02:0000651A 61000678        	  2835: 	bsr			DisplayTetra
02:0000651E 6100EC0E        	  2836: 	bsr			CRLF
02:00006522 51C8FFE0        	  2837: 	dbra		d0,.0001
02:00006526 6100EECA        	  2838: 	bsr			DisplayString
02:0000652A 1218            	  2839: 	move.b	(a0)+,d1
02:0000652C 6100EC4A        	  2840: 	bsr			DisplayChar
02:00006530 1218            	  2841: 	move.b	(a0)+,d1
02:00006532 6100EC44        	  2842: 	bsr			DisplayChar
02:00006536 61000654        	  2843: 	bsr			DisplaySpace
02:0000653A 223900040144    	  2844: 	move.l	Regsave+$44,d1
02:00006540 61000652        	  2845: 	bsr			DisplayTetra
02:00006544 6100EBE8        	  2846: 	bsr			CRLF
02:00006548 6100EEA8        	  2847: 	bsr			DisplayString
02:0000654C 1218            	  2848: 	move.b	(a0)+,d1
02:0000654E 6100EC28        	  2849: 	bsr			DisplayChar
02:00006552 1218            	  2850: 	move.b	(a0)+,d1
02:00006554 6100EC22        	  2851: 	bsr			DisplayChar
02:00006558 61000632        	  2852: 	bsr			DisplaySpace
02:0000655C 323900040140    	  2853: 	move.w	Regsave+$40,d1
02:00006562 61000636        	  2854: 	bsr			DisplayWyde
02:00006566 6100EBC6        	  2855: 	bsr			CRLF
02:0000656A 6000F956        	  2856: 	bra			Monitor
                            	  2857: 
                            	  2858: msg_regs:
02:0000656E 526567          	  2859: 	dc.b	"Reg",0
02:00006571 00
                            	  2860: msg_reglist:
02:00006572 4430443144324433	  2861: 	dc.b	"D0D1D2D3D4D5D6D7A0A1A2A3A4A5A6A7PCSR",0
02:0000657A 4434443544364437
02:00006582 4130413141324133
02:0000658A 4134413541364137
02:00006592 50435352
02:00006596 00
                            	  2862: 
                            	  2863: 	align	1
                            	  2864: 
                            	  2865: ;------------------------------------------------------------------------------
                            	  2866: ;------------------------------------------------------------------------------
                            	  2867: 
                            	  2868: cmdTestSerialReceive:
                            	  2869: .0002:
02:00006598 7024            	  2870: 	moveq		#36,d0				; serial get char from buffer
02:0000659A 4E4F            	  2871: 	trap		#15
                            	  2872: ;	bsr			SerialPeekCharDirect
02:0000659C 4A41            	  2873: 	tst.w		d1
02:0000659E 6B0A            	  2874: 	bmi.s		.0001
02:000065A0 0C01001A        	  2875: 	cmpi.b	#CTRLZ,d1
02:000065A4 670A            	  2876: 	beq			.0003
02:000065A6 6100EBD0        	  2877: 	bsr			DisplayChar
                            	  2878: .0001:	
02:000065AA 6100F24A        	  2879: 	bsr			CheckForCtrlC
02:000065AE 60E8            	  2880: 	bra			.0002
                            	  2881: .0003:
02:000065B0 6100F098        	  2882: 	bsr			_KeybdInit
02:000065B4 6000F90C        	  2883: 	bra			Monitor
                            	  2884: 
                            	  2885: ;------------------------------------------------------------------------------
                            	  2886: ; Get a hexidecimal number. Maximum of eight digits.
                            	  2887: ;
                            	  2888: ; Returns:
                            	  2889: ;		d0 = number of digits
                            	  2890: ;		d1 = value of number
                            	  2891: ;		zf = number of digits == 0
                            	  2892: ;------------------------------------------------------------------------------
                            	  2893: 
                            	  2894: GetHexNumber:
02:000065B8 2F02            	  2895: 	move.l	d2,-(a7)
02:000065BA 7400            	  2896: 	clr.l		d2
02:000065BC 7000            	  2897: 	moveq		#0,d0
                            	  2898: .0002
02:000065BE 6100F8EE        	  2899: 	bsr			FromScreen
02:000065C2 6100057C        	  2900: 	bsr			AsciiToHexNybble
02:000065C6 0C0100FF        	  2901: 	cmpi.b	#$ff,d1
02:000065CA 6712            	  2902: 	beq.s		.0001
02:000065CC E98A            	  2903: 	lsl.l		#4,d2
02:000065CE 02810000000F    	  2904: 	andi.l	#$0f,d1
02:000065D4 8481            	  2905: 	or.l		d1,d2
02:000065D6 5240            	  2906: 	addq		#1,d0
02:000065D8 0C000008        	  2907: 	cmpi.b	#8,d0
02:000065DC 65E0            	  2908: 	blo.s		.0002
                            	  2909: .0001
02:000065DE 2202            	  2910: 	move.l	d2,d1
02:000065E0 241F            	  2911: 	move.l	(a7)+,d2
02:000065E2 4A00            	  2912: 	tst.b		d0
02:000065E4 4E75            	  2913: 	rts	
                            	  2914: 
                            	  2915: GetDecNumber:
02:000065E6 48E73000        	  2916: 	movem.l d2/d3,-(a7)
02:000065EA 7400            	  2917: 	clr.l d2
02:000065EC 7000            	  2918: 	clr.l d0
                            	  2919: .0002
02:000065EE 6100F8BE        	  2920: 	bsr FromScreen					; grab a character off the screen
02:000065F2 6100054C        	  2921: 	bsr	AsciiToHexNybble		; convert to an ascii nybble
02:000065F6 0C0100FF        	  2922: 	cmpi.b #$ff,d1
02:000065FA 6718            	  2923: 	beq.s	.0001
02:000065FC 02810000000F    	  2924: 	andi.l #$0F,d1					; d1 = 0 to 9
02:00006602 2602            	  2925: 	move.l d2,d3						; d3 = current number
02:00006604 D683            	  2926: 	add.l d3,d3							; d3*2
02:00006606 E78A            	  2927: 	lsl.l #3,d2							; current number * 8
02:00006608 D483            	  2928: 	add.l d3,d2							; current number * 10
02:0000660A D481            	  2929: 	add.l d1,d2							; add in new digit
02:0000660C 5240            	  2930: 	addq #1,d0							; increment number of digits
02:0000660E 0C000009        	  2931: 	cmpi.b #9,d0						; make sure 9 or fewer
02:00006612 65DA            	  2932: 	blo .0002
                            	  2933: .0001
02:00006614 2202            	  2934: 	move.l d2,d1						; return number in d1
02:00006616 4CDF000C        	  2935: 	movem.l (a7)+,d2/d3
02:0000661A 4A00            	  2936: 	tst.b d0
02:0000661C 4E75            	  2937: 	rts
                            	  2938: 	
                            	  2939: 	include "FloatToString.asm"

Source: "FloatToString.asm"
                            	     1: 	code
                            	     2: ;==============================================================================
                            	     3: ; Decimal-Floating point to string conversion routine.
                            	     4: ;
                            	     5: ; Modifies
                            	     6: ;		_fpWork work area
                            	     7: ; Register Usage:
                            	     8: ; 	fp0 = input decimal-float to convert
                            	     9: ;		fp1 = constant holder, 1.0, 10.0
                            	    10: ;		fp2 = 1.0e<fp0 exponent> value for conversion
                            	    11: ;		fp3 = holds digit value during significand conversion
                            	    12: ; 	a0 = pointer to string buffer, updated to point to NULL at end of string
                            	    13: ;		a1 = pointer to "Nan" or "Inf" message string
                            	    14: ;		d0 = temporary
                            	    15: ;		d1 = digit value during exponent, significand conversion
                            	    16: ; 	d6 = exponent
                            	    17: ;==============================================================================
                            	    18: 	align 4
02:00006620 25FF0000        	    19: _dfOne	dc.l $25ff0000,$00000000,$00000000
02:00006624 00000000
02:00006628 00000000
02:0000662C 2600C000        	    20: _dfTen	dc.l $2600C000,$00000000,$00000000
02:00006630 00000000
02:00006634 00000000
02:00006638 2606DDFA        	    21: _dfMil  dc.l $2606DDFA,$1C000000,$00000000
02:0000663C 1C000000
02:00006640 00000000
                            	    22: 
02:00006644 4E614E          	    23: _msgNan	dc.b "NaN",0
02:00006647 00
02:00006648 496E66          	    24: _msgInf dc.b "Inf",0
02:0000664B 00
                            	    25: 	even
                            	    26: 
                            	    27: ;------------------------------------------------------------------------------
                            	    28: ; Check for the special Nan and infinity values. Output the appropriate string.
                            	    29: ;
                            	    30: ; Modifies
                            	    31: ;		_fpWork area
                            	    32: ;		a0
                            	    33: ; Parameters:
                            	    34: ;		fp0 = dbl
                            	    35: ;------------------------------------------------------------------------------
                            	    36: 
                            	    37: _CheckNan:
02:0000664C 4E52FFF4        	    38: 	link a2,#-12
02:00006650 48D70201        	    39: 	movem.l d0/a1,(sp)
02:00006654 2F79000400980008	    40: 	move.l _canary,8(sp)
02:0000665C F239680000040600	    41: 	fmove.x fp0,_fpWork
02:00006664 103900040600    	    42: 	move.b _fpWork,d0				; get sign+combo
02:0000666A 0200007C        	    43: 	andi.b #$7C,d0					; mask for combo bits
02:0000666E 0C00007C        	    44: 	cmpi.b #$7C,d0					; is it the Nan combo?
02:00006672 6606            	    45: 	bne .notNan
02:00006674 43FAFFCE        	    46: 	lea _msgNan,a1					; output "Nan"
02:00006678 600A            	    47: 	bra .outStr
                            	    48: .notNan
02:0000667A 0C000078        	    49: 	cmpi.b #$78,d0					; is it infinity combo?
02:0000667E 661E            	    50: 	bne .notInf
02:00006680 43FAFFC6        	    51: 	lea _msgInf,a1
                            	    52: .outStr
02:00006684 10D9            	    53: 	move.b (a1)+,(a0)+			; output "Inf"
02:00006686 10D9            	    54: 	move.b (a1)+,(a0)+
02:00006688 10D9            	    55: 	move.b (a1)+,(a0)+
02:0000668A 4210            	    56: 	clr.b (a0)
02:0000668C 4CD70201        	    57: 	movem.l (sp),d0/a1
02:00006690 A2AF00030008    	    58: 	cchk 8(sp)
02:00006696 4E5A            	    59: 	unlk a2
02:00006698 003C0001        	    60: 	ori #1,ccr							; set carry and return
02:0000669C 4E75            	    61: 	rts
                            	    62: .notInf
02:0000669E 4CD70201        	    63: 	movem.l (sp),d0/a1
02:000066A2 A2AF00030008    	    64: 	cchk 8(sp)
02:000066A8 4E5A            	    65: 	unlk a2
02:000066AA 023C00FE        	    66: 	andi #$FE,ccr						; clear carry and return
02:000066AE 4E75            	    67: 	rts
                            	    68: 
                            	    69: ;------------------------------------------------------------------------------
                            	    70: ; Check for a zero value. Output a single "0" if zero,
                            	    71: ;
                            	    72: ; Modifies:
                            	    73: ;		a0
                            	    74: ; Parameters:
                            	    75: ;		fp0 = dbl
                            	    76: ;------------------------------------------------------------------------------
                            	    77: 
                            	    78: _CheckZero:
02:000066B0 F200003A        	    79: 	ftst fp0								; check if number is zero
02:000066B4 F28E000E        	    80: 	fbne .0003
02:000066B8 10FC0030        	    81: 	move.b #'0',(a0)+				; if zero output "0"
02:000066BC 4210            	    82: 	clr.b (a0)
02:000066BE 003C0004        	    83: 	ori #4,ccr							; set zf
02:000066C2 4E75            	    84: 	rts
                            	    85: .0003
02:000066C4 023C00FB        	    86: 	andi #$FB,ccr						; clear zf
02:000066C8 4E75            	    87: 	rts
                            	    88: 
                            	    89: ;------------------------------------------------------------------------------
                            	    90: ; Check for a negative number. This includes Nans and Infinities. Output a "-"
                            	    91: ; if negative.
                            	    92: ;
                            	    93: ;	Modifies
                            	    94: ;		a0
                            	    95: ; Parameters:
                            	    96: ;		fp0 = dbl
                            	    97: ;------------------------------------------------------------------------------
                            	    98: 
                            	    99: _CheckNegative:
02:000066CA F200003A        	   100: 	ftst fp0								; is number negative?
02:000066CE F293000A        	   101: 	fbge .0002
02:000066D2 10FC002D        	   102: 	move.b #'-',(a0)+				; yes, output '-'
02:000066D6 F200001A        	   103: 	fneg fp0								; make fp0 positive
                            	   104: .0002
02:000066DA 4E75            	   105: 	rts
                            	   106: 
                            	   107: ;------------------------------------------------------------------------------
                            	   108: ; Make the input value larger so that digits may appear before the decimal
                            	   109: ; point.
                            	   110: ;
                            	   111: ; Modifies:
                            	   112: ;		fp0,fp1,d6
                            	   113: ; Parameters:
                            	   114: ;		fp0 = dbl
                            	   115: ;------------------------------------------------------------------------------
                            	   116: 
                            	   117: ;	if (dbl < 1.0) {
                            	   118: ;		while (dbl < 1.0) {
                            	   119: ;			dbl *= 1000000.0;
                            	   120: ;			exp -= 6;  
                            	   121: ;		}
                            	   122: ;	}
                            	   123: 
                            	   124: _MakeBig:
02:000066DC F23C50800001    	   125: 	fmove.w #1,fp1
                            	   126: .0002
02:000066E2 F2000438        	   127: 	fcmp fp1,fp0						; is fp0 > 1?
02:000066E6 F293000E        	   128: 	fbge .0001							; yes, return
02:000066EA F23C402600000006	   129: 	fscale.l #6,fp0					; multiply fp0 by a million
02:000066F2 5D46            	   130: 	subi.w #6,d6						; decrement exponent by six
02:000066F4 60EC            	   131: 	bra .0002								; keep trying until number is > 1
                            	   132: .0001
02:000066F6 4E75            	   133: 	rts
                            	   134: 	
                            	   135: ;------------------------------------------------------------------------------
                            	   136: ;	Create a number dbl2 on the same order of magnitude as dbl, but
                            	   137: ;	less than dbl. The number will be 1.0e<dbl's exponent>
                            	   138: ;
                            	   139: ; Modifies:
                            	   140: ;		d6,fp2
                            	   141: ; Parameters:
                            	   142: ;		fp0 = dbl
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: ;	// The following is similar to using log10() and pow() functions.
                            	   146: ;	// Now dbl is >= 1.0
                            	   147: ;	// Create a number dbl2 on the same order of magnitude as dbl, but
                            	   148: ;	// less than dbl.
                            	   149: ;	dbl2 = 1.0;
                            	   150: ;	dbla = dbl2;
                            	   151: ;	if (dbl > dbl2) {	// dbl > 1.0 ?
                            	   152: ;		while (dbl2 <= dbl) {
                            	   153: ;			dbla = dbl2;
                            	   154: ;			dbl2 *= 10.0;	// increase power of 10
                            	   155: ;			exp++;
                            	   156: ;		}
                            	   157: ;		// The above loop goes one too far, we want the last value less
                            	   158: ;		// than dbl.
                            	   159: ;		dbl2 = dbla;
                            	   160: ;		exp--;
                            	   161: ;	}
                            	   162: 
                            	   163: _LessThanDbl:
02:000066F8 F23C51000001    	   164: 	fmove.w #1,fp2			; setup fp2 = 1
02:000066FE F2000838        	   165: 	fcmp fp2,fp0				; if (dbl > dbl2)
02:00006702 F295001E        	   166: 	fble .0004
                            	   167: .0006
02:00006706 F2000138        	   168: 	fcmp fp0,fp2				; while (dbl2 <= dbl)
02:0000670A F292000C        	   169: 	fbgt .0005
02:0000670E F23C51260001    	   170: 	fscale.w #1,fp2			; dbl2 *= 10 (increase exponent by one)
02:00006714 5246            	   171: 	addi.w #1,d6				; exp++
02:00006716 60EE            	   172: 	bra .0006
                            	   173: .0005
02:00006718 F23C4126FFFFFFFF	   174: 	fscale.l #-1,fp2		; dbl2 /= 10 (decrease exponent by one)
02:00006720 5346            	   175: 	subi.w #1,d6				; exp--;
                            	   176: .0004	
                            	   177: ;	fmove.x fp0,_fpWork	; debugging
                            	   178: ;	fmove.x fp2,_fpWork+12
02:00006722 4E75            	   179: 	rts
                            	   180: 
                            	   181: ;------------------------------------------------------------------------------
                            	   182: ; Compute the number of digits before the decimal point.
                            	   183: ;
                            	   184: ; Modifies:
                            	   185: ;		d0,d6,_digits_before_decpt
                            	   186: ; Parameters:
                            	   187: ;		d6 = exponent
                            	   188: ;------------------------------------------------------------------------------
                            	   189: 
                            	   190: ; if (exp >= 0 && exp < 6) {
                            	   191: ;   digits_before_decpt = exp+1;
                            	   192: ;		exp = 0;
                            	   193: ;	}
                            	   194: ;	else if (exp >= -7)
                            	   195: ;		digits_before_decpt = 1;
                            	   196: ;	else
                            	   197: ;		digits_before_decpt = -1;
                            	   198: 
                            	   199: _ComputeDigitsBeforeDecpt:
02:00006724 2F00            	   200: 	move.l d0,-(a7)
02:00006726 4A46            	   201: 	tst.w d6
02:00006728 6B16            	   202: 	bmi .0007
02:0000672A 0C460006        	   203: 	cmpi.w #6,d6
02:0000672E 6C10            	   204: 	bge .0007
02:00006730 3006            	   205: 	move.w d6,d0
02:00006732 5240            	   206: 	addi.w #1,d0
02:00006734 33C000040510    	   207: 	move.w d0,_digits_before_decpt	
02:0000673A 4246            	   208: 	clr.w d6
02:0000673C 201F            	   209: 	move.l (a7)+,d0
02:0000673E 4E75            	   210: 	rts
                            	   211: .0007
02:00006740 0C46FFF9        	   212: 	cmpi.w #-7,d6
02:00006744 6D0C            	   213: 	blt .0009
02:00006746 33FC000100040510	   214: 	move.w #1,_digits_before_decpt
02:0000674E 201F            	   215: 	move.l (a7)+,d0
02:00006750 4E75            	   216: 	rts
                            	   217: .0009
02:00006752 33FCFFFF00040510	   218: 	move.w #-1,_digits_before_decpt
02:0000675A 201F            	   219: 	move.l (a7)+,d0
02:0000675C 4E75            	   220: 	rts
                            	   221: 
                            	   222: ;------------------------------------------------------------------------------
                            	   223: ;	Spit out a leading zero before the decimal point for a small number.
                            	   224: ;
                            	   225: ; Modifies:
                            	   226: ;		a0
                            	   227: ; Parameters:
                            	   228: ;		d6 = exponent
                            	   229: ;------------------------------------------------------------------------------
                            	   230: 
                            	   231: ;  if (exp < -7) {
                            	   232: ;		 buf[ndx] = '0';
                            	   233: ;		 ndx++;
                            	   234: ;    buf[ndx] = '.';
                            	   235: ;    ndx++;
                            	   236: ;  }
                            	   237: 
                            	   238: _LeadingZero:
02:0000675E 0C46FFF9        	   239: 	cmpi.w #-7,d6
02:00006762 6C08            	   240: 	bge .0010
02:00006764 10FC0030        	   241: 	move.b #'0',(a0)+
02:00006768 10FC002E        	   242: 	move.b #'.',(a0)+
                            	   243: .0010
02:0000676C 4E75            	   244: 	rts
                            	   245: 
                            	   246: ;------------------------------------------------------------------------------
                            	   247: ; Extract the digits of the significand.
                            	   248: ;
                            	   249: ; Modifies:
                            	   250: ;		_precision variable
                            	   251: ; Register Usage
                            	   252: ;		d0 = counter
                            	   253: ;		d1 = digit
                            	   254: ;		fp0 = dbl
                            	   255: ;		fp2 = dbl2
                            	   256: ;		fp3 = digit as decimal float
                            	   257: ;		fp7 = dbla
                            	   258: ; Parameters:
                            	   259: ;		fp0, fp2
                            	   260: ;------------------------------------------------------------------------------
                            	   261: 
                            	   262: ;	// Now loop processing one digit at a time.
                            	   263: ;  for (nn = 0; nn < 25 && precision > 0; nn++) {
                            	   264: ;    digit = 0;
                            	   265: ;		dbla = dbl;
                            	   266: ;		// dbl is on the same order of magnitude as dbl2 so
                            	   267: ;		// a repeated subtract can be used to find the digit.
                            	   268: ;    while (dbl >= dbl2) {
                            	   269: ;      dbl -= dbl2;
                            	   270: ;      digit++;
                            	   271: ;    }
                            	   272: ;    buf[ndx] = digit + '0';
                            	   273: ;		// Now go back and perform just a single subtract and
                            	   274: ;		// a multiply to find out how much to reduce dbl by.
                            	   275: ;		// This should improve the accuracy
                            	   276: ;		if (digit > 2)
                            	   277: ;			dbl = dbla - dbl2 * digit;
                            	   278: ;    ndx++;
                            	   279: ;    digits_before_decpt--;
                            	   280: ;    if (digits_before_decpt==0) {
                            	   281: ;			buf[ndx] = '.';
                            	   282: ;			ndx++;
                            	   283: ;    }
                            	   284: ;    else if (digits_before_decpt < 0)
                            	   285: ;      precision--;
                            	   286: ;		// Shift the next digit to be tested into position.
                            	   287: ;    dbl *= 10.0;
                            	   288: ;  }
                            	   289: 	
                            	   290: _SpitOutDigits:
02:0000676E 4E52FFE8        	   291: 	link a2,#-24
02:00006772 2F79000400980014	   292: 	move.l _canary,20(sp)
02:0000677A F2176B80        	   293: 	fmove.x fp7,(sp)
02:0000677E 48EF0003000C    	   294: 	movem.l d0/d1,12(sp)
02:00006784 303C0018        	   295: 	move.w #24,d0			; d0 = nn
                            	   296: .0017	
02:00006788 4AB900040514    	   297: 	tst.l _precision
02:0000678E 6F46            	   298: 	ble .0011
02:00006790 7200            	   299: 	moveq #0,d1				; digit = 0
02:00006792 F2000380        	   300: 	fmove fp0,fp7			; dbla = dbl
                            	   301: .0013
02:00006796 F2000838        	   302: 	fcmp fp2,fp0
02:0000679A F294000A        	   303: 	fblt .0012
02:0000679E F2000828        	   304: 	fsub fp2,fp0			; dbl -= dbl2
02:000067A2 5201            	   305: 	addi.b #1,d1			; digit++
02:000067A4 60F0            	   306: 	bra .0013
                            	   307: .0012
02:000067A6 06010030        	   308: 	addi.b #'0',d1		; convert digit to ascii
02:000067AA 10C1            	   309: 	move.b d1,(a0)+		; and store
02:000067AC 04010030        	   310: 	subi.b #'0',d1		; d1 = binary digit again
                            	   311: ;	cmpi.b #2,d1
                            	   312: ;	ble .0014
                            	   313: 
                            	   314: ;	ext.w d1
                            	   315: ;	ext.l d1
                            	   316: ;	fmove.l d1,fp3		; fp3 = digit
                            	   317: ;	fmul fp2,fp3			; fp3 = dbl2 * digit
                            	   318: ;	fmove fp7,fp0
                            	   319: ;	fsub fp3,fp0			; dbl = dbla - dbl2 * digit
                            	   320: .0014
02:000067B0 537900040510    	   321: 	subi.w #1,_digits_before_decpt
02:000067B6 6604            	   322: 	bne .0015
02:000067B8 10FC002E        	   323: 	move.b #'.',(a0)+
                            	   324: .0015
02:000067BC 4A7900040510    	   325: 	tst.w _digits_before_decpt
02:000067C2 6C06            	   326: 	bge .0016
02:000067C4 53B900040514    	   327: 	subi.l #1,_precision
                            	   328: .0016
02:000067CA F23C4126FFFFFFFF	   329: 	fscale.l #-1,fp2		; dbl *= 10.0
02:000067D2 51C8FFB4        	   330: 	dbra d0,.0017
                            	   331: .0011
02:000067D6 4CEF0003000C    	   332: 	movem.l 12(sp),d0/d1
02:000067DC F2174B80        	   333: 	fmove.x (sp),fp7
02:000067E0 A2AF00030014    	   334: 	cchk 20(sp)
02:000067E6 4E5A            	   335: 	unlk a2
02:000067E8 4E75            	   336: 	rts
                            	   337: 
                            	   338: ;------------------------------------------------------------------------------
                            	   339: ; If the number ends in a decimal point, trim off the point.
                            	   340: ;
                            	   341: ; Registers Modified:
                            	   342: ;		none
                            	   343: ; Parameters:
                            	   344: ;		a0 = pointer to end of number
                            	   345: ; Returns:
                            	   346: ;		a0 = updated to point just past last digit.
                            	   347: ;------------------------------------------------------------------------------
                            	   348: 
                            	   349: _TrimTrailingPoint:
02:000067EA 0C28002EFFFF    	   350: 	cmpi.b #'.',-1(a0)
02:000067F0 6604            	   351: 	bne .0001
02:000067F2 4220            	   352: 	clr.b -(a0)
02:000067F4 4E75            	   353: 	rts
                            	   354: .0001
02:000067F6 0C10002E        	   355: 	cmpi.b #'.',(a0)
02:000067FA 660A            	   356: 	bne .0002
02:000067FC 4A280001        	   357: 	cmpi.b #0,1(a0)
02:00006800 6604            	   358: 	bne .0002
02:00006802 4210            	   359: 	clr.b (a0)
02:00006804 5348            	   360: 	subq #1,a0
                            	   361: .0002
02:00006806 4E75            	   362: 	rts
                            	   363: 	
                            	   364: ;------------------------------------------------------------------------------
                            	   365: ; If the number ends in .0 get rid of the .0
                            	   366: ;
                            	   367: ; Registers Modified:
                            	   368: ;		none
                            	   369: ; Parameters:
                            	   370: ;		a0 = pointer to last digits of number
                            	   371: ; Returns:
                            	   372: ;		a0 = updated to point just past last digit.
                            	   373: ;------------------------------------------------------------------------------
                            	   374: 
                            	   375: _TrimDotZero:
02:00006808 4A10            	   376: 	tst.b (a0)
02:0000680A 6616            	   377: 	bne .0004
02:0000680C 0C280030FFFF    	   378: 	cmpi.b #'0',-1(a0)
02:00006812 660E            	   379: 	bne .0004
02:00006814 0C28002EFFFE    	   380: 	cmpi.b #'.',-2(a0)
02:0000681A 6606            	   381: 	bne .0004
02:0000681C 4228FFFE        	   382: 	clr.b -2(a0)
02:00006820 5548            	   383: 	subq #2,a0
                            	   384: .0004
02:00006822 4E75            	   385: 	rts
                            	   386: 
                            	   387: ;------------------------------------------------------------------------------
                            	   388: ; Trim trailing zeros from the number. Generally there is no need to display
                            	   389: ; trailing zeros.
                            	   390: ; Turns a number like 652.000000000000000000000 into 650.0
                            	   391: ;
                            	   392: ; Registers Modified:
                            	   393: ;		none
                            	   394: ; Parameters:
                            	   395: ;		a0 = pointer to last digits of number
                            	   396: ; Returns:
                            	   397: ;		a0 = updated to point just past last digit.
                            	   398: ;------------------------------------------------------------------------------
                            	   399: 
                            	   400: ;	// Trim trailing zeros from the number
                            	   401: ;  do {
                            	   402: ;      ndx--;
                            	   403: ;  } while(buf[ndx]=='0');
                            	   404: ;  ndx++;
                            	   405: 
                            	   406: _TrimTrailingZeros:
                            	   407: .0018	
02:00006824 0C200030        	   408: 	cmpi.b #'0',-(a0)		; if the last digit was a zero, backup
02:00006828 67FA            	   409: 	beq .0018
02:0000682A 5248            	   410: 	addq #1,a0					; now advance by one
02:0000682C 4210            	   411: 	move.b #0,(a0)			; NULL terminate string
02:0000682E 4E75            	   412: 	rts
                            	   413: 
                            	   414: ;------------------------------------------------------------------------------
                            	   415: ; Output 'e+' or 'e-'
                            	   416: ;
                            	   417: ; Registers Modified:
                            	   418: ;		d6.w (if negative)
                            	   419: ; Parameters:
                            	   420: ;		a0 = pointer to last digits of number
                            	   421: ; Returns:
                            	   422: ;		a0 = updated to point just past '+' or '-'.
                            	   423: ;------------------------------------------------------------------------------
                            	   424: 
                            	   425: ;	// Spit out +/-E
                            	   426: ;  buf[ndx] = E;
                            	   427: ;  ndx++;
                            	   428: ;  if (exp < 0) {
                            	   429: ;    buf[ndx]='-';
                            	   430: ;    ndx++;
                            	   431: ;    exp = -exp;
                            	   432: ;  }
                            	   433: ;  else {
                            	   434: ;		buf[ndx]='+';
                            	   435: ;		ndx++;
                            	   436: ;  }
                            	   437: 
                            	   438: _SpitOutE:	
02:00006830 10F90004050C    	   439: 	move.b _E,(a0)+
02:00006836 4A46            	   440: 	tst.w d6
02:00006838 6C08            	   441: 	bge .0021
02:0000683A 10FC002D        	   442: 	move.b #'-',(a0)+
02:0000683E 4446            	   443: 	neg.w d6
02:00006840 6004            	   444: 	bra .0022
                            	   445: .0021
02:00006842 10FC002B        	   446: 	move.b #'+',(a0)+
                            	   447: .0022
02:00006846 4E75            	   448: 	rts
                            	   449: 
                            	   450: ;------------------------------------------------------------------------------
                            	   451: ; Extract a single digit of the exponent. Extract works from the leftmost digit
                            	   452: ; to the rightmost.
                            	   453: ;
                            	   454: ; Register Usage
                            	   455: ;		d2 = history of zeros
                            	   456: ;		d3 = digit
                            	   457: ; Modifies
                            	   458: ;		d2,d6,a0
                            	   459: ; Parameter
                            	   460: ; 	d1.w = power of ten
                            	   461: ;		d6.w = exponent
                            	   462: ;------------------------------------------------------------------------------
                            	   463: 
                            	   464: _ExtExpDigit:
02:00006848 2F03            	   465: 	move.l d3,-(a7)
02:0000684A 48C6            	   466: 	ext.l d6				; make d6 a long
02:0000684C 8CC1            	   467: 	divu d1,d6			; divide by power of ten
02:0000684E 1606            	   468: 	move.b d6,d3		; d3 = quotient (0 to 9)
02:00006850 4846            	   469: 	swap d6					; d6 = remainder, setup for next digit
02:00006852 8403            	   470: 	or.b d3,d2
02:00006854 4A03            	   471: 	tst.b d3
02:00006856 6604            	   472: 	bne .0003
02:00006858 4A02            	   473: 	tst.b d2	
02:0000685A 6706            	   474: 	beq .0004
                            	   475: .0003
02:0000685C 06030030        	   476: 	addi.b #'0',d3	; convert to ascii
02:00006860 10C3            	   477: 	move.b d3,(a0)+
                            	   478: .0004
02:00006862 261F            	   479: 	move.l (a7)+,d3
02:00006864 4E75            	   480: 	rts
                            	   481: 
                            	   482: ;------------------------------------------------------------------------------
                            	   483: ; Extract all the digits of the exponent.
                            	   484: ;
                            	   485: ; Register Usage
                            	   486: ;		d1 = power of 10
                            	   487: ;		d2 = history of zeros
                            	   488: ; Parameters
                            	   489: ;		a0 = pointer to string buffer
                            	   490: ;		d6 = exponent
                            	   491: ;------------------------------------------------------------------------------
                            	   492: 
                            	   493: ;	// If the number is times 10^0 don't output the exponent
                            	   494: ;  if (exp==0) {
                            	   495: ;    buf[ndx]='\0';
                            	   496: ;    goto prt;
                            	   497: ;  }
                            	   498: 
                            	   499: _ExtExpDigits:
02:00006866 2F01            	   500: 	move.l d1,-(a7)
02:00006868 4A46            	   501: 	tst.w d6							; is exponent zero?
02:0000686A 671C            	   502: 	beq .0002
02:0000686C 61C2            	   503: 	bsr _SpitOutE					; exponent is non-zero e+
02:0000686E 4202            	   504: 	clr.b d2							; d2 = history of zeros
02:00006870 323C03E8        	   505: 	move.w #1000,d1
02:00006874 61D2            	   506: 	bsr _ExtExpDigit
02:00006876 323C0064        	   507: 	move.w #100,d1
02:0000687A 61CC            	   508: 	bsr _ExtExpDigit
02:0000687C 323C000A        	   509: 	move.w #10,d1
02:00006880 61C6            	   510: 	bsr _ExtExpDigit
02:00006882 323C0001        	   511: 	move.w #1,d1
02:00006886 61C0            	   512: 	bsr _ExtExpDigit
                            	   513: .0002:
02:00006888 221F            	   514: 	move.l (a7)+,d1
02:0000688A 4210            	   515: 	move.b #0,(a0)				; NULL terminate string
02:0000688C 4E75            	   516: 	rts										; and return
                            	   517: 
                            	   518: ;------------------------------------------------------------------------------
                            	   519: ; Pad the left side of the output string.
                            	   520: ;
                            	   521: ; Modifies:
                            	   522: ;		d0,d1,d2,d3
                            	   523: ;------------------------------------------------------------------------------
                            	   524: 
                            	   525: ;  // pad left
                            	   526: ;  if (width > 0) {
                            	   527: ;    if (ndx < width) {
                            	   528: ;      for (nn = 39; nn >= width-ndx; nn--)
                            	   529: ;        buf[nn] = buf[nn-(width-ndx)];
                            	   530: ;      for (; nn >= 0; nn--)
                            	   531: ;        buf[nn] = ' ';
                            	   532: ;    }
                            	   533: ;  }
                            	   534: 	
                            	   535: _PadLeft:
02:0000688E 48E7F000        	   536: 	movem.l d0/d1/d2/d3,-(a7)
02:00006892 4A3900040508    	   537: 	tst.b _width
02:00006898 6F3E            	   538: 	ble .0041
02:0000689A 2008            	   539: 	move.l a0,d0
02:0000689C 90BC00040520    	   540: 	sub.l #_fpBuf,d0	; d0 = ndx
02:000068A2 B03900040508    	   541: 	cmp.b _width,d0
02:000068A8 6C2E            	   542: 	bge .0041
02:000068AA 323C0031        	   543: 	move.w #49,d1			; d1 = nn
                            	   544: .0040
02:000068AE 143900040508    	   545: 	move.b _width,d2
02:000068B4 4882            	   546: 	ext.w d2
02:000068B6 9440            	   547: 	sub.w d0,d2				; d2 = width-ndx
02:000068B8 B242            	   548: 	cmp.w d2,d1
02:000068BA 6D0E            	   549: 	blt .0039
02:000068BC 3601            	   550: 	move.w d1,d3			; d3 = nn
02:000068BE 9642            	   551: 	sub.w d2,d3				; d3 = nn-(width-ndx)
02:000068C0 11B030001000    	   552: 	move.b (a0,d3.w),(a0,d1.w)
02:000068C6 5341            	   553: 	subi.w #1,d1
02:000068C8 60E4            	   554: 	bra .0040
                            	   555: .0039
02:000068CA 4A41            	   556: 	tst.w d1
02:000068CC 6B0A            	   557: 	bmi .0041
02:000068CE 11BC00201000    	   558: 	move.b #' ',(a0,d1.w)
02:000068D4 5341            	   559: 	subi.w #1,d1
02:000068D6 60F2            	   560: 	bra .0039
                            	   561: .0041
02:000068D8 4CDF000F        	   562: 	movem.l (a7)+,d0/d1/d2/d3
02:000068DC 4E75            	   563: 	rts
                            	   564: 
                            	   565: ;------------------------------------------------------------------------------
                            	   566: ; Pad the right side of the output string.
                            	   567: ;
                            	   568: ; Parameters:
                            	   569: ;		a0 = pointer to end of string
                            	   570: ; Modifies:
                            	   571: ;		none
                            	   572: ; Returns:
                            	   573: ;		none
                            	   574: ;------------------------------------------------------------------------------
                            	   575: 
                            	   576: ;  // pad right
                            	   577: ;  if (width < 0) {
                            	   578: ;    width = -width;
                            	   579: ;    while (ndx < width) {
                            	   580: ;      buf[ndx]=' ';
                            	   581: ;      ndx++;
                            	   582: ;    }
                            	   583: ;    buf[ndx]='\0';
                            	   584: ;  }
                            	   585: ;  return (ndx);
                            	   586: 
                            	   587: _PadRight:
02:000068DE 2F00            	   588: 	move.l d0,-(a7)
02:000068E0 4A3900040508    	   589: 	tst.b _width
02:000068E6 6A24            	   590: 	bpl .0042
02:000068E8 443900040508    	   591: 	neg.b _width
02:000068EE 2008            	   592: 	move.l a0,d0
02:000068F0 90BC00040520    	   593: 	sub.l #_fpBuf,d0	; d0 = ndx
                            	   594: .0044
02:000068F6 B03900040508    	   595: 	cmp.b _width,d0
02:000068FC 6C0A            	   596: 	bge .0043
02:000068FE 11BC00200000    	   597: 	move.b #' ',(a0,d0.w)
02:00006904 5240            	   598: 	addi.w #1,d0
02:00006906 60EE            	   599: 	bra .0044
                            	   600: .0043
02:00006908 42300000        	   601: 	move.b #0,(a0,d0.w)
                            	   602: .0042
02:0000690C 201F            	   603: 	move.l (a7)+,d0
02:0000690E 4E75            	   604: 	rts
                            	   605: 
                            	   606: ;------------------------------------------------------------------------------
                            	   607: ; Output a string representation of a decimal floating point number to a 
                            	   608: ; buffer.
                            	   609: ;
                            	   610: ; Register Usage
                            	   611: ;		a0 = pointer to string buffer
                            	   612: ;		d6 = exponent
                            	   613: ; Modifies:
                            	   614: ;		a0 = points to end of string
                            	   615: ; Parameters:
                            	   616: ;		fp0 = number to convert
                            	   617: ; Returns:
                            	   618: ;		none
                            	   619: ;------------------------------------------------------------------------------
                            	   620: 
                            	   621: _FloatToString:
02:00006910 2F06            	   622: 	move.l d6,-(a7)
02:00006912 6100FDB6        	   623: 	bsr _CheckNegative			; is number negative?
02:00006916 6100FD98        	   624: 	bsr _CheckZero					; check for zero
02:0000691A 6732            	   625: 	beq .0001								; branch since already output "0"
02:0000691C 6100FD2E        	   626: 	bsr _CheckNan						; check for Nan or infinity
02:00006920 652C            	   627: 	bcs .0001								; branch if nan/inf string output
                            	   628: 	; Now the fun begins
02:00006922 7C00            	   629: 	clr.l d6								; exponent = 0
02:00006924 6100FDB6        	   630: 	bsr _MakeBig
02:00006928 6100FDCE        	   631: 	bsr _LessThanDbl
02:0000692C 6100FDF6        	   632: 	bsr _ComputeDigitsBeforeDecpt
02:00006930 6100FE2C        	   633: 	bsr _LeadingZero
02:00006934 6100FE38        	   634: 	bsr _SpitOutDigits
02:00006938 6100FEEA        	   635: 	bsr _TrimTrailingZeros
02:0000693C 6100FEAC        	   636: 	bsr _TrimTrailingPoint
02:00006940 6100FEC6        	   637: 	bsr _TrimDotZero
02:00006944 6100FF20        	   638: 	bsr _ExtExpDigits				; extract exponent digits
02:00006948 6100FF44        	   639: 	bsr _PadLeft						; pad the number to the left or right
02:0000694C 6190            	   640: 	bsr _PadRight
                            	   641: .0001
02:0000694E 2C1F            	   642: 	move.l (a7)+,d6
02:00006950 4E75            	   643: 	rts
                            	   644: 
                            	   645: 

Source: "boot.asm"
                            	  2940: 	include "GetFloat.asm"

Source: "GetFloat.asm"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;
                            	    37: ; Get a floating point number
                            	    38: ;
                            	    39: _GetFloatGetChar:
02:00006952 1210            	    40: 	move.b (a0),d1
02:00006954 D1C0            	    41: 	add.l d0,a0
02:00006956 4E75            	    42: 	rts
                            	    43: _GetFloatIgnBlanks:
                            	    44: .0001
02:00006958 61F8            	    45: 	bsr _GetFloatGetChar
02:0000695A 0C010020        	    46: 	cmpi.b #' ',d1
02:0000695E 67F8            	    47: 	beq .0001
                            	    48: _GetFloatBackupChar:
02:00006960 91C0            	    49: 	sub.l d0,a0
02:00006962 4E75            	    50: 	rts
                            	    51: 
                            	    52: ;-------------------------------------------------------------------------------
                            	    53: ; Get fractional part of a number, 25 digits max, into a float register.
                            	    54: ;
                            	    55: ; Register Usage:
                            	    56: ;		d1 = digit from input screen
                            	    57: ;		d4 = digit count
                            	    58: ;		d6 = digit scaling factor
                            	    59: ;		fp1 = digit as float number
                            	    60: ; Returns:
                            	    61: ;		fp0 = fraction
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: _GetFraction:
02:00006964 4E52FFE4        	    65: 	link a2,#-28
02:00006968 2F79000400980018	    66: 	move.l _canary,24(sp)
02:00006970 48D70052        	    67: 	movem.l d1/d4/d6,(sp)
02:00006974 F22F6880000C    	    68: 	fmove.x fp1,12(sp)
02:0000697A 7C00            	    69: 	clr.l d6							; d6 = scale factor
02:0000697C F23C50000000    	    70: 	fmove.w #0,fp0				; fract = 0.0
02:00006982 7818            	    71: 	moveq #24,d4
                            	    72: .0002
02:00006984 61CC            	    73: 	bsr _GetFloatGetChar
02:00006986 0C010030        	    74: 	cmpi.b #'0',d1
02:0000698A 6520            	    75: 	blo .0001
02:0000698C 0C010039        	    76: 	cmpi.b #'9',d1				; make sure between 0 and 9
02:00006990 621A            	    77: 	bhi .0001
02:00006992 04010030        	    78: 	subi.b #'0',d1
02:00006996 F23C50260001    	    79: 	fscale.w #1,fp0				; fract * 10.0
02:0000699C 5246            	    80: 	addq #1,d6						; record scaling
02:0000699E F2015880        	    81: 	fmove.b d1,fp1				; fp1 = digit
02:000069A2 F2000422        	    82: 	fadd fp1,fp0					; fract += digit
02:000069A6 5245            	    83: 	addq.w #1,d5					; increment number of digits in number
02:000069A8 51CCFFDA        	    84: 	dbra d4,.0002
                            	    85: .0001
02:000069AC 61B2            	    86: 	bsr _GetFloatBackupChar
02:000069AE 4446            	    87: 	neg d6
02:000069B0 F2064026        	    88: 	fscale.l d6,fp0				; fract /= scale
02:000069B4 4CD70052        	    89: 	movem.l (sp),d1/d4/d6
02:000069B8 F22F4880000C    	    90: 	fmove.x 12(sp),fp1
02:000069BE A2AF00030018    	    91: 	cchk 24(sp)
02:000069C4 4E5A            	    92: 	unlk a2
02:000069C6 4E75            	    93: 	rts
                            	    94: 
                            	    95: ;-------------------------------------------------------------------------------
                            	    96: ; Get exponent part of a number, 4 digits max, into a float register.
                            	    97: ;
                            	    98: ; Register Usage:
                            	    99: ;		d1 = digit from input screen
                            	   100: ;		d2 = exponent
                            	   101: ;		d3 = temp, number times 2
                            	   102: ;		d4 = digit counter
                            	   103: ; Parameters:
                            	   104: ;		fp0 = float number
                            	   105: ; Returns:
                            	   106: ;		fp0 = float number with exponent factored in
                            	   107: ;-------------------------------------------------------------------------------
                            	   108: 
                            	   109: _GetExponent:
02:000069C8 4E52FFE0        	   110: 	link a2,#-32
02:000069CC 2F7900040098001C	   111: 	move.l _canary,28(sp)
02:000069D4 48D7001E        	   112: 	movem.l d1/d2/d3/d4,(sp)
02:000069D8 F22F69000010    	   113: 	fmove.x fp2,16(sp)
02:000069DE 7400            	   114: 	clr.l d2							; d2 = number = 0
02:000069E0 F23C51000000    	   115: 	fmove.w #0,fp2				; fp2 = exp = 0.0
02:000069E6 7601            	   116: 	moveq #1,d3						; d3 = exscale = 1
02:000069E8 6100FF68        	   117: 	bsr _GetFloatGetChar
02:000069EC 0C01002D        	   118: 	cmpi.b #'-',d1
02:000069F0 6608            	   119: 	bne .0001
02:000069F2 4483            	   120: 	neg.l d3							; exscale = -1
                            	   121: .0006
02:000069F4 6100FF62        	   122: 	bsr _GetFloatIgnBlanks
02:000069F8 600A            	   123: 	bra .0002
                            	   124: .0001
02:000069FA 0C01002B        	   125: 	cmpi.b #'+',d1
02:000069FE 67F4            	   126: 	beq .0006
02:00006A00 6100FF5E        	   127: 	bsr _GetFloatBackupChar
                            	   128: .0002	
02:00006A04 7803            	   129: 	moveq #3,d4						; d4 = max 4 digits
                            	   130: .0004
02:00006A06 6100FF4A        	   131: 	bsr _GetFloatGetChar	; d1 = digit char
02:00006A0A 0C010030        	   132: 	cmpi.b #'0',d1
02:00006A0E 651E            	   133: 	blo .0003
02:00006A10 0C010039        	   134: 	cmpi.b #'9',d1				; ensure between 0 and 9
02:00006A14 6218            	   135: 	bhi .0003
02:00006A16 04010030        	   136: 	subi.b #'0',d1
02:00006A1A D482            	   137: 	add.l d2,d2						; number *2
02:00006A1C 2602            	   138: 	move.l d2,d3
02:00006A1E E58A            	   139: 	lsl.l #2,d2						; number *8
02:00006A20 D483            	   140: 	add.l d3,d2						; number *10	
02:00006A22 4881            	   141: 	ext.w d1
02:00006A24 48C1            	   142: 	ext.l d1
02:00006A26 D481            	   143: 	add.l d1,d2						; number + digit
02:00006A28 5245            	   144: 	addq.w #1,d5					; increment number of digits in number
02:00006A2A 51CCFFDA        	   145: 	dbra d4,.0004
                            	   146: .0003
02:00006A2E 6100FF30        	   147: 	bsr _GetFloatBackupChar	; backup a character
02:00006A32 C4C3            	   148: 	mulu d3,d2						; *1 or *-1
02:00006A34 48C2            	   149: 	ext.l d2
02:00006A36 F2024126        	   150: 	fscale.l d2,fp2				; exp * exmul
02:00006A3A F2000823        	   151: 	fmul fp2,fp0					; rval *= exp
02:00006A3E 4CD7001E        	   152: 	movem.l (sp),d1/d2/d3/d4
02:00006A42 F22F49000010    	   153: 	fmove.x 16(sp),fp2
02:00006A48 A2AF0003001C    	   154: 	cchk 28(sp)
02:00006A4E 4E5A            	   155: 	unlk a2
02:00006A50 4E75            	   156: 	rts	
                            	   157: 
                            	   158: ;-------------------------------------------------------------------------------
                            	   159: ; Get an integer number, positive or negative, 25 digits max, into a float
                            	   160: ; register.
                            	   161: ;
                            	   162: ; Register Usage:
                            	   163: ;		d1 = digit from input screen
                            	   164: ;		d2 = digit down counter
                            	   165: ;		d3 = sign of number '+' or '-'
                            	   166: ;		fp1 = digit
                            	   167: ; Modifies:
                            	   168: ;		a0,fp0
                            	   169: ; Returns:
                            	   170: ;		a0 = updated buffer pointer
                            	   171: ;		fp0 = integer number
                            	   172: ;-------------------------------------------------------------------------------
                            	   173: 
                            	   174: _GetInteger:
02:00006A52 4E52FFE4        	   175: 	link a2,#-28
02:00006A56 2F79000400980018	   176: 	move.l _canary,24(sp)
02:00006A5E 48D7000E        	   177: 	movem.l d1/d2/d3,(sp)
02:00006A62 F22F6880000C    	   178: 	fmove.x fp1,12(sp)
02:00006A68 F23C50000000    	   179: 	fmove.w #0,fp0
02:00006A6E 7418            	   180: 	moveq #24,d2					; d2 = digit count (25 max)
02:00006A70 6100FEE6        	   181: 	bsr _GetFloatIgnBlanks
02:00006A74 6100FEDC        	   182: 	bsr _GetFloatGetChar	; get the sign of the number
02:00006A78 0C01002B        	   183: 	cmpi.b #'+',d1
02:00006A7C 670A            	   184: 	beq .0002
                            	   185: .0003
02:00006A7E 0C01002D        	   186: 	cmpi.b #'-',d1
02:00006A82 6608            	   187: 	bne .0004
02:00006A84 1E3C002D        	   188: 	move.b #'-',d7
                            	   189: .0002
02:00006A88 6100FEC8        	   190: 	bsr _GetFloatGetChar
                            	   191: .0004
02:00006A8C 0C010030        	   192: 	cmpi.b #'0',d1				; only characters 0 to 9 valid
02:00006A90 651E            	   193: 	blo .0001
02:00006A92 0C010039        	   194: 	cmpi.b #'9',d1
02:00006A96 6218            	   195: 	bhi .0001
02:00006A98 04010030        	   196: 	subi.b #'0',d1
02:00006A9C F23C50260001    	   197: 	fscale.w #1,fp0				; number *10
02:00006AA2 F2015880        	   198: 	fmove.b d1,fp1				; fp1 = digit
02:00006AA6 F2000422        	   199: 	fadd fp1,fp0
02:00006AAA 5245            	   200: 	addq.w #1,d5
02:00006AAC 51CAFFDA        	   201: 	dbra d2,.0002
                            	   202: .0001
02:00006AB0 6100FEAE        	   203: 	bsr _GetFloatBackupChar
02:00006AB4 4CD7000E        	   204: 	movem.l (sp),d1/d2/d3
02:00006AB8 F22F4880000C    	   205: 	fmove.x 12(sp),fp1
02:00006ABE A2AF00030018    	   206: 	cchk 24(sp)
02:00006AC4 4E5A            	   207: 	unlk a2
02:00006AC6 4E75            	   208: 	rts
                            	   209: 		
                            	   210: ;-------------------------------------------------------------------------------
                            	   211: ; Get a floating point number off the input screen.
                            	   212: ;
                            	   213: ; Parameters:
                            	   214: ;		a0 = pointer to buffer containing string
                            	   215: ;		d0 = stride of buffer (increment / decrement amount)
                            	   216: ; Register Usage:
                            	   217: ;		d1 = character from input screen
                            	   218: ;		d5.lo = number of digits in number, d5.hi = number of characters fetched
                            	   219: ; Returns:
                            	   220: ;		fp0 = number
                            	   221: ;		a0 = updated buffer pointer
                            	   222: ;		d0 = length of number >0 if a number
                            	   223: ;-------------------------------------------------------------------------------
                            	   224: 
                            	   225: _GetFloat:
02:00006AC8 4E52FFE0        	   226: 	link a2,#-32
02:00006ACC 2F7900040098001C	   227: 	move.l _canary,28(sp)
02:00006AD4 48D702A2        	   228: 	movem.l d1/d5/d7/a1,(sp)
02:00006AD8 F22F69000010    	   229: 	fmove.x fp2,16(sp)
02:00006ADE 7A00            	   230: 	clr.l d5
02:00006AE0 1E3C002B        	   231: 	move.b #'+',d7				; assume a positive number
02:00006AE4 2248            	   232: 	move.l a0,a1					; a1 = copy of pointer to buffer
02:00006AE6 6100FF6A        	   233: 	bsr _GetInteger				; rval = integer
02:00006AEA F2000100        	   234: 	fmove.x fp0,fp2
02:00006AEE 6100FE62        	   235: 	bsr _GetFloatGetChar
02:00006AF2 0C01002E        	   236: 	cmpi.b #'.',d1
02:00006AF6 6706            	   237: 	beq .0004
                            	   238: .0005
02:00006AF8 6100FE66        	   239: 	bsr _GetFloatBackupChar
02:00006AFC 601C            	   240: 	bra .0002
                            	   241: .0004
02:00006AFE 6100FE64        	   242: 	bsr _GetFraction
02:00006B02 F2000822        	   243: 	fadd fp2,fp0					; rval += fraction
02:00006B06 6100FE4A        	   244: 	bsr _GetFloatGetChar
02:00006B0A 0C010065        	   245: 	cmpi.b #'e',d1				; accept either 'e' or 'E' indicating exponent
02:00006B0E 6706            	   246: 	beq .0001
02:00006B10 0C010045        	   247: 	cmpi.b #'E',d1
02:00006B14 66E2            	   248: 	bne .0005
                            	   249: .0001
02:00006B16 6100FEB0        	   250: 	bsr _GetExponent			; factor exponent into fp0
                            	   251: .0002
02:00006B1A 0C07002D        	   252: 	cmpi.b #'-',d7				; adjust number for sign
02:00006B1E 6604            	   253: 	bne .0003
02:00006B20 F200001A        	   254: 	fneg fp0
                            	   255: .0003
02:00006B24 93C8            	   256: 	suba.l a0,a1					; compute number of characters fetched
02:00006B26 3009            	   257: 	move.w a1,d0					; move it to d0.hi
02:00006B28 4840            	   258: 	swap d0
02:00006B2A 3005            	   259: 	move.w d5,d0					; return digit/character count in d0 (non zero for a number)
02:00006B2C 4CD702A2        	   260: 	movem.l (sp),d1/d5/d7/a1
02:00006B30 F22F49000010    	   261: 	fmove.x 16(sp),fp2
02:00006B36 A2AF0003001C    	   262: 	cchk 28(sp)
02:00006B3C 4E5A            	   263: 	unlk a2
02:00006B3E 4E75            	   264: 	rts	
                            	   265: 
                            	   266: 		

Source: "boot.asm"
                            	  2941: 
                            	  2942: ;------------------------------------------------------------------------------
                            	  2943: ; Convert ASCII character in the range '0' to '9', 'a' tr 'f' or 'A' to 'F'
                            	  2944: ; to a hex nybble.
                            	  2945: ;------------------------------------------------------------------------------
                            	  2946: 
                            	  2947: AsciiToHexNybble:
02:00006B40 0C010030        	  2948: 	cmpi.b	#'0',d1
02:00006B44 6530            	  2949: 	blo.s		gthx3
02:00006B46 0C010039        	  2950: 	cmpi.b	#'9',d1
02:00006B4A 6206            	  2951: 	bhi.s		gthx5
02:00006B4C 04010030        	  2952: 	subi.b	#'0',d1
02:00006B50 4E75            	  2953: 	rts
                            	  2954: gthx5:
02:00006B52 0C010041        	  2955: 	cmpi.b	#'A',d1
02:00006B56 651E            	  2956: 	blo.s		gthx3
02:00006B58 0C010046        	  2957: 	cmpi.b	#'F',d1
02:00006B5C 6206            	  2958: 	bhi.s		gthx6
02:00006B5E 060100C9        	  2959: 	addi.b	#10-'A',d1
02:00006B62 4E75            	  2960: 	rts
                            	  2961: gthx6:
02:00006B64 0C010061        	  2962: 	cmpi.b	#'a',d1
02:00006B68 650C            	  2963: 	blo.s		gthx3
02:00006B6A 0C010066        	  2964: 	cmpi.b	#'f',d1
02:00006B6E 6206            	  2965: 	bhi.s		gthx3
02:00006B70 060100A9        	  2966: 	addi.b	#10-'a',d1
02:00006B74 4E75            	  2967: 	rts
                            	  2968: gthx3:
02:00006B76 72FF            	  2969: 	moveq	#-1,d1		; not a hex number
02:00006B78 4E75            	  2970: 	rts
                            	  2971: 
                            	  2972: ;------------------------------------------------------------------------------
                            	  2973: ;------------------------------------------------------------------------------
                            	  2974: 
                            	  2975: DisplayTwoSpaces:
02:00006B7A 2F01            	  2976: 	move.l	d1,-(a7)
02:00006B7C 123C0020        	  2977: 	move.b	#' ',d1
02:00006B80 6100E5F6        	  2978: 	bsr			DisplayChar
                            	  2979: dspspc1:
02:00006B84 6100E5F2        	  2980: 	bsr			DisplayChar
02:00006B88 221F            	  2981: 	move.l	(a7)+,d1
02:00006B8A 4E75            	  2982: 	rts
                            	  2983: 
                            	  2984: DisplaySpace:
02:00006B8C 2F01            	  2985: 	move.l	d1,-(a7)
02:00006B8E 123C0020        	  2986: 	move.b	#' ',d1
02:00006B92 60F0            	  2987: 	bra			dspspc1
                            	  2988: 
                            	  2989: ;------------------------------------------------------------------------------
                            	  2990: ; Display the 32 bit word in D1.L
                            	  2991: ;------------------------------------------------------------------------------
                            	  2992: 
                            	  2993: DisplayTetra:
02:00006B94 4841            	  2994: 	swap	d1
02:00006B96 6102            	  2995: 	bsr		DisplayWyde
02:00006B98 4841            	  2996: 	swap	d1
                            	  2997: 
                            	  2998: ;------------------------------------------------------------------------------
                            	  2999: ; Display the byte in D1.W
                            	  3000: ;------------------------------------------------------------------------------
                            	  3001: 
                            	  3002: DisplayWyde:
02:00006B9A E059            	  3003: 	ror.w		#8,d1
02:00006B9C 6102            	  3004: 	bsr			DisplayByte
02:00006B9E E159            	  3005: 	rol.w		#8,d1
                            	  3006: 
                            	  3007: ;------------------------------------------------------------------------------
                            	  3008: ; Display the byte in D1.B
                            	  3009: ;------------------------------------------------------------------------------
                            	  3010: 
                            	  3011: DisplayByte:
02:00006BA0 E819            	  3012: 	ror.b		#4,d1
02:00006BA2 6102            	  3013: 	bsr			DisplayNybble
02:00006BA4 E919            	  3014: 	rol.b		#4,d1
                            	  3015: 
                            	  3016: ;------------------------------------------------------------------------------
                            	  3017: ; Display nybble in D1.B
                            	  3018: ;------------------------------------------------------------------------------
                            	  3019: 
                            	  3020: DisplayNybble:
02:00006BA6 2F01            	  3021: 	move.l	d1,-(a7)
02:00006BA8 0201000F        	  3022: 	andi.b	#$F,d1
02:00006BAC 06010030        	  3023: 	addi.b	#'0',d1
02:00006BB0 0C010039        	  3024: 	cmpi.b	#'9',d1
02:00006BB4 6302            	  3025: 	bls.s		.0001
02:00006BB6 5E01            	  3026: 	addi.b	#7,d1
                            	  3027: .0001:
02:00006BB8 6100E5BE        	  3028: 	bsr			DisplayChar
02:00006BBC 221F            	  3029: 	move.l	(a7)+,d1
02:00006BBE 4E75            	  3030: 	rts
                            	  3031: 
                            	  3032: ;------------------------------------------------------------------------------
                            	  3033: ;------------------------------------------------------------------------------
                            	  3034: ;
                            	  3035: ;DisplayHexNumber:
                            	  3036: ;	move.w	#$A6A6,leds		; diagnostics
                            	  3037: ;	move.l	#VDGREG,a6
                            	  3038: ;	move.w	#7,d2		; number-1 of digits to display
                            	  3039: ;disphnum1:
                            	  3040: ;	move.b	d1,d0		; get digit into d0.b
                            	  3041: ;	andi.w	#$0f,d0
                            	  3042: ;	cmpi.w	#$09,d0
                            	  3043: ;	bls.s	disphnum2
                            	  3044: ;	addi.w	#7,d0
                            	  3045: ;disphnum2:
                            	  3046: ;	addi.w	#$30,d0	; convert to display char
                            	  3047: ;	move.w	d2,d3		; char count into d3
                            	  3048: ;	asl.w	#3,d3		; scale * 8
                            	  3049: ;disphnum3:
                            	  3050: ;	move.w	$42C(a6),d4			; read character queue index into d4
                            	  3051: ;	cmp.w	#28,d4					; allow up 28 entries to be in progress
                            	  3052: ;	bhs.s	disphnum3				; branch if too many chars queued
                            	  3053: ;	ext.w	d0						; zero out high order bits
                            	  3054: ;	move.w	d0,$420(a6)			; set char code
                            	  3055: ;	move.w	#WHITE,$422(a6)		; set fg color
                            	  3056: ;	move.w	#DARK_BLUE,$424(a6)	; set bk color
                            	  3057: ;	move.w	d3,$426(a6)			; set x pos
                            	  3058: ;	move.w	#8,$428(a6)			; set y pos
                            	  3059: ;	move.w	#$0707,$42A(a6)		; set font x,y extent
                            	  3060: ;	move.w	#0,$42E(a6)			; pulse character queue write signal
                            	  3061: ;	ror.l	#4,d1					; rot to next digit
                            	  3062: ;	dbeq	d2,disphnum1
                            	  3063: ;	jmp		(a5)
                            	  3064: 
                            	  3065: ;===============================================================================
                            	  3066: ;    Perform ram test. (Uses checkerboard testing).
                            	  3067: ; 
                            	  3068: ;    Local ram, which does not get tested, is used for the stack.
                            	  3069: ;===============================================================================
                            	  3070: 
                            	  3071: DisplayAddr:
02:00006BC0 2208            	  3072: 	move.l a0,d1
02:00006BC2 E089            	  3073: 	lsr.l #8,d1
02:00006BC4 E089            	  3074: 	lsr.l #8,d1
02:00006BC6 E889            	  3075: 	lsr.l #4,d1
02:00006BC8 04410200        	  3076: 	subi.w #512,d1
02:00006BCC A2C10000        	  3077: 	bin2bcd d1
02:00006BD0 61C8            	  3078: 	bsr	DisplayWyde
02:00006BD2 123C000D        	  3079: 	move.b #CR,d1
02:00006BD6 6000E5A0        	  3080: 	bra DisplayChar
02:00006BDA 08000083        	  3081: 	btst #$83,d0
                            	  3082: 	
                            	  3083: cmdTestRAM:
                            	  3084: ramtest:
02:00006BDE 33FCA5A5FD0FFF00	  3085: 	move.w	#$A5A5,leds		; diagnostics
02:00006BE6 263CAAAAAAAA    	  3086:   move.l #$aaaaaaaa,d3
02:00006BEC 283C55555555    	  3087:   move.l #$55555555,d4
02:00006BF2 612C            	  3088:   bsr ramtest0
                            	  3089:   ; switch checkerboard pattern and repeat test.
02:00006BF4 C744            	  3090:   exg d3,d4
02:00006BF6 6128            	  3091:   bsr ramtest0
                            	  3092: 	; Save last ram address in end of memory pointer.
                            	  3093: rmtst5:
02:00006BF8 7025            	  3094: 	moveq #37,d0					; lock semaphore
02:00006BFA 7206            	  3095: 	moveq #MEMORY_SEMA,d1
02:00006BFC 4E4F            	  3096: 	trap #15
02:00006BFE 23C800100004    	  3097:   move.l a0,memend
                            	  3098: 	; Create very first memory block.
02:00006C04 41E8FFF4        	  3099:   suba.l #12,a0
02:00006C08 23C820000004    	  3100:   move.l a0,$20000004		; length of block
02:00006C0E 23FC465245452000	  3101:   move.l #$46524545,$20000000
02:00006C16 0000
02:00006C18 7026            	  3102: 	moveq #38,d0					; unlock semaphore
02:00006C1A 7206            	  3103: 	moveq #MEMORY_SEMA,d1
02:00006C1C 4E4F            	  3104: 	trap #15
02:00006C1E 4E75            	  3105:   rts
                            	  3106: 
                            	  3107: ramtest0:
02:00006C20 2003            	  3108: 	move.l d3,d0
02:00006C22 207C20000000    	  3109:   movea.l #$20000000,a0
                            	  3110: ;-----------------------------------------------------------
                            	  3111: ;   Write checkerboard pattern to ram then read it back to
                            	  3112: ; find the highest usable ram address (maybe). This address
                            	  3113: ; must be lower than the start of the rom (0xe00000).
                            	  3114: ;-----------------------------------------------------------
                            	  3115: ramtest1:
02:00006C28 20C3            	  3116:   move.l d3,(a0)+
02:00006C2A 20C4            	  3117:   move.l d4,(a0)+
02:00006C2C 2208            	  3118:   move.l a0,d1
02:00006C2E 4A41            	  3119:   tst.w	d1
02:00006C30 6606            	  3120:   bne.s rmtst1
02:00006C32 618C            	  3121:   bsr DisplayAddr
02:00006C34 6100EBC0        	  3122:   bsr CheckForCtrlC
                            	  3123: rmtst1:
02:00006C38 B1FC3FFFFFF8    	  3124:   cmpa.l #$3FFFFFF8,a0
02:00006C3E 65E8            	  3125:   blo.s ramtest1
02:00006C40 6100E4EC        	  3126:   bsr	CRLF
                            	  3127: ;------------------------------------------------------
                            	  3128: ;   Save maximum useable address for later comparison.
                            	  3129: ;------------------------------------------------------
                            	  3130: ramtest6:
02:00006C44 33FCA7A7FD0FFF00	  3131: 	move.w	#$A7A7,leds		; diagnostics
02:00006C4C 2448            	  3132:   movea.l a0,a2
02:00006C4E 207C20000000    	  3133:   movea.l #$20000000,a0
                            	  3134: ;--------------------------------------------
                            	  3135: ;   Read back checkerboard pattern from ram.
                            	  3136: ;--------------------------------------------
                            	  3137: ramtest2
02:00006C54 2A18            	  3138:   move.l (a0)+,d5
02:00006C56 2C18            	  3139:   move.l (a0)+,d6
02:00006C58 B1CA            	  3140:   cmpa.l a2,a0
02:00006C5A 643A            	  3141:   bhs.s	ramtest3
02:00006C5C 2208            	  3142:   move.l a0,d1
02:00006C5E 4A41            	  3143:   tst.w	d1
02:00006C60 6608            	  3144:   bne.s	rmtst2
02:00006C62 6100FF5C        	  3145:   bsr	DisplayAddr
02:00006C66 6100EB8E        	  3146: 	bsr CheckForCtrlC
                            	  3147: rmtst2
02:00006C6A BA83            	  3148:   cmp.l d3,d5
02:00006C6C 6604            	  3149:   bne.s rmtst3
02:00006C6E BC84            	  3150:   cmp.l d4,d6
02:00006C70 67E2            	  3151:   beq.s ramtest2
                            	  3152: ;----------------------------------
                            	  3153: ; Report error in ram.
                            	  3154: ;----------------------------------
                            	  3155: rmtst3
02:00006C72 6100E4BA        	  3156: 	bsr CRLF
02:00006C76 7245            	  3157: 	moveq	#'E',d1
02:00006C78 6100E4FE        	  3158: 	bsr DisplayChar
02:00006C7C 6100FF0E        	  3159: 	bsr DisplaySpace
02:00006C80 2208            	  3160: 	move.l a0,d1
02:00006C82 6100FF10        	  3161: 	bsr DisplayTetra
02:00006C86 6100FF04        	  3162: 	bsr DisplaySpace
02:00006C8A 2205            	  3163: 	move.l d5,d1
02:00006C8C 6100FF06        	  3164: 	bsr DisplayTetra
02:00006C90 6100EB64        	  3165: 	bsr CheckForCtrlC
02:00006C94 60BE            	  3166: 	bra ramtest2
                            	  3167: ramtest3
02:00006C96 4E75            	  3168: 	rts
                            	  3169: 
                            	  3170: ;==============================================================================
                            	  3171: ; Load an S19 format file
                            	  3172: ;==============================================================================
                            	  3173: 
                            	  3174: cmdLoadS19:
02:00006C98 6100E494        	  3175: 	bsr			CRLF
02:00006C9C 6012            	  3176: 	bra			ProcessRec
                            	  3177: NextRec:
02:00006C9E 610001DC        	  3178: 	bsr			sGetChar
02:00006CA2 0C01000A        	  3179: 	cmpi.b	#LF,d1
02:00006CA6 66F6            	  3180: 	bne			NextRec
02:00006CA8 123C002E        	  3181: 	move.b	#'.',d1
02:00006CAC 6100E4CA        	  3182: 	bsr			DisplayChar
                            	  3183: ProcessRec:
02:00006CB0 6100EB44        	  3184: 	bsr			CheckForCtrlC	; check for CTRL-C once per record
02:00006CB4 610001C6        	  3185: 	bsr			sGetChar
02:00006CB8 0C01000D        	  3186: 	cmpi.b	#CR,d1
02:00006CBC 67F2            	  3187: 	beq.s		ProcessRec
02:00006CBE 423900100150    	  3188: 	clr.b		S19Checksum
02:00006CC4 1801            	  3189: 	move.b	d1,d4
02:00006CC6 0C04001A        	  3190: 	cmpi.b	#CTRLZ,d4			; CTRL-Z ?
02:00006CCA 6700F1F6        	  3191: 	beq			Monitor
02:00006CCE 0C040053        	  3192: 	cmpi.b	#'S',d4				; All records must begin with an 'S'
02:00006CD2 66CA            	  3193: 	bne.s		NextRec
02:00006CD4 610001A6        	  3194: 	bsr			sGetChar
02:00006CD8 1801            	  3195: 	move.b	d1,d4
02:00006CDA 0C040030        	  3196: 	cmpi.b	#'0',d4				; Record type must be between '0' and '9'
02:00006CDE 65BE            	  3197: 	blo.s		NextRec
02:00006CE0 0C040039        	  3198: 	cmpi.b	#'9',d4				; d4 = record type
02:00006CE4 62B8            	  3199: 	bhi.s		NextRec
02:00006CE6 61000194        	  3200: 	bsr			sGetChar			; get byte count for record
02:00006CEA 6100FE54        	  3201: 	bsr			AsciiToHexNybble
02:00006CEE 1401            	  3202: 	move.b	d1,d2
02:00006CF0 6100018A        	  3203: 	bsr			sGetChar
02:00006CF4 6100FE4A        	  3204: 	bsr			AsciiToHexNybble
02:00006CF8 E90A            	  3205: 	lsl.b		#4,d2
02:00006CFA 8202            	  3206: 	or.b		d2,d1					; d1 = byte count
02:00006CFC 1601            	  3207: 	move.b	d1,d3					; d3 = byte count
02:00006CFE D73900100150    	  3208: 	add.b		d3,S19Checksum
02:00006D04 0C040030        	  3209: 	cmpi.b	#'0',d4				; manufacturer ID record, ignore
02:00006D08 6794            	  3210: 	beq			NextRec
02:00006D0A 0C040031        	  3211: 	cmpi.b	#'1',d4
02:00006D0E 670000A2        	  3212: 	beq			ProcessS1
02:00006D12 0C040032        	  3213: 	cmpi.b	#'2',d4
02:00006D16 6700009E        	  3214: 	beq			ProcessS2
02:00006D1A 0C040033        	  3215: 	cmpi.b	#'3',d4
02:00006D1E 6700009A        	  3216: 	beq			ProcessS3
02:00006D22 0C040035        	  3217: 	cmpi.b	#'5',d4				; record count record, ignore
02:00006D26 6700FF76        	  3218: 	beq			NextRec
02:00006D2A 0C040037        	  3219: 	cmpi.b	#'7',d4
02:00006D2E 6700008E        	  3220: 	beq			ProcessS7
02:00006D32 0C040038        	  3221: 	cmpi.b	#'8',d4
02:00006D36 67000096        	  3222: 	beq			ProcessS8
02:00006D3A 0C040039        	  3223: 	cmpi.b	#'9',d4
02:00006D3E 6700009E        	  3224: 	beq			ProcessS9
02:00006D42 6000FF5A        	  3225: 	bra			NextRec
                            	  3226: 
                            	  3227: pcssxa:
02:00006D46 2209            	  3228: 	move.l	a1,d1
02:00006D48 6100FE4A        	  3229: 	bsr			DisplayTetra
02:00006D4C 123C000D        	  3230: 	move.b	#CR,d1
02:00006D50 6100E426        	  3231: 	bsr			DisplayChar
02:00006D54 024300FF        	  3232: 	andi.w	#$ff,d3
02:00006D58 5343            	  3233: 	subi.w	#1,d3			; one less for dbra
                            	  3234: .0001:
02:00006D5A 7400            	  3235: 	clr.l		d2
02:00006D5C 6100011E        	  3236: 	bsr			sGetChar
02:00006D60 6100FDDE        	  3237: 	bsr			AsciiToHexNybble
02:00006D64 E98A            	  3238: 	lsl.l		#4,d2
02:00006D66 8401            	  3239: 	or.b		d1,d2
02:00006D68 61000112        	  3240: 	bsr			sGetChar
02:00006D6C 6100FDD2        	  3241: 	bsr			AsciiToHexNybble
02:00006D70 E98A            	  3242: 	lsl.l		#4,d2
02:00006D72 8401            	  3243: 	or.b		d1,d2
02:00006D74 D53900100150    	  3244: 	add.b		d2,S19Checksum
02:00006D7A 12C2            	  3245: 	move.b	d2,(a1)+			; move byte to memory
02:00006D7C 51CBFFDC        	  3246: 	dbra		d3,.0001
                            	  3247: 	; Get the checksum byte
02:00006D80 7400            	  3248: 	clr.l		d2
02:00006D82 610000F8        	  3249: 	bsr			sGetChar
02:00006D86 6100FDB8        	  3250: 	bsr			AsciiToHexNybble
02:00006D8A E98A            	  3251: 	lsl.l		#4,d2
02:00006D8C 8401            	  3252: 	or.b		d1,d2
02:00006D8E 610000EC        	  3253: 	bsr			sGetChar
02:00006D92 6100FDAC        	  3254: 	bsr			AsciiToHexNybble
02:00006D96 E98A            	  3255: 	lsl.l		#4,d2
02:00006D98 8401            	  3256: 	or.b		d1,d2
02:00006D9A 4602            	  3257: 	eor.b		#$FF,d2
02:00006D9C B43900100150    	  3258: 	cmp.b		S19Checksum,d2
02:00006DA2 6700FEFA        	  3259: 	beq			NextRec
02:00006DA6 123C0045        	  3260: 	move.b	#'E',d1
02:00006DAA 6100E3CC        	  3261: 	bsr			DisplayChar
02:00006DAE 6000FEEE        	  3262: 	bra			NextRec
                            	  3263: 
                            	  3264: ProcessS1:
02:00006DB2 613A            	  3265: 	bsr			S19Get16BitAddress
02:00006DB4 6090            	  3266: 	bra			pcssxa
                            	  3267: ProcessS2:
02:00006DB6 6144            	  3268: 	bsr			S19Get24BitAddress
02:00006DB8 608C            	  3269: 	bra			pcssxa
                            	  3270: ProcessS3:
02:00006DBA 614C            	  3271: 	bsr			S19Get32BitAddress
02:00006DBC 6088            	  3272: 	bra			pcssxa
                            	  3273: ProcessS7:
02:00006DBE 6148            	  3274: 	bsr			S19Get32BitAddress
02:00006DC0 23C900040008    	  3275: 	move.l	a1,S19StartAddress
02:00006DC6 6100E882        	  3276: 	bsr			_KeybdInit
02:00006DCA 6000F0F6        	  3277: 	bra			Monitor
                            	  3278: ProcessS8:
02:00006DCE 612C            	  3279: 	bsr			S19Get24BitAddress
02:00006DD0 23C900040008    	  3280: 	move.l	a1,S19StartAddress
02:00006DD6 6100E872        	  3281: 	bsr			_KeybdInit
02:00006DDA 6000F0E6        	  3282: 	bra			Monitor
                            	  3283: ProcessS9:
02:00006DDE 610E            	  3284: 	bsr			S19Get16BitAddress
02:00006DE0 23C900040008    	  3285: 	move.l	a1,S19StartAddress
02:00006DE6 6100E862        	  3286: 	bsr			_KeybdInit
02:00006DEA 6000F0D6        	  3287: 	bra			Monitor
                            	  3288: 
                            	  3289: S19Get16BitAddress:
02:00006DEE 7400            	  3290: 	clr.l		d2
02:00006DF0 6100008A        	  3291: 	bsr			sGetChar
02:00006DF4 6100FD4A        	  3292: 	bsr			AsciiToHexNybble
02:00006DF8 1401            	  3293: 	move.b	d1,d2
02:00006DFA 603E            	  3294: 	bra			S1932b
                            	  3295: 
                            	  3296: S19Get24BitAddress:
02:00006DFC 7400            	  3297: 	clr.l		d2
02:00006DFE 617C            	  3298: 	bsr			sGetChar
02:00006E00 6100FD3E        	  3299: 	bsr			AsciiToHexNybble
02:00006E04 1401            	  3300: 	move.b	d1,d2
02:00006E06 601E            	  3301: 	bra			S1932a
                            	  3302: 
                            	  3303: S19Get32BitAddress:
02:00006E08 7400            	  3304: 	clr.l		d2
02:00006E0A 6170            	  3305: 	bsr			sGetChar
02:00006E0C 6100FD32        	  3306: 	bsr			AsciiToHexNybble
02:00006E10 1401            	  3307: 	move.b	d1,d2
02:00006E12 6168            	  3308: 	bsr			sGetChar
02:00006E14 6100FD2A        	  3309: 	bsr			AsciiToHexNybble
02:00006E18 E98A            	  3310: 	lsl.l		#4,d2
02:00006E1A 8401            	  3311: 	or.b		d1,d2
02:00006E1C 615E            	  3312: 	bsr			sGetChar
02:00006E1E 6100FD20        	  3313: 	bsr			AsciiToHexNybble
02:00006E22 E98A            	  3314: 	lsl.l		#4,d2
02:00006E24 8401            	  3315: 	or.b		d1,d2
                            	  3316: S1932a:
02:00006E26 6154            	  3317: 	bsr			sGetChar
02:00006E28 6100FD16        	  3318: 	bsr			AsciiToHexNybble
02:00006E2C E98A            	  3319: 	lsl.l		#4,d2
02:00006E2E 8401            	  3320: 	or.b		d1,d2
02:00006E30 614A            	  3321: 	bsr			sGetChar
02:00006E32 6100FD0C        	  3322: 	bsr			AsciiToHexNybble
02:00006E36 E98A            	  3323: 	lsl.l		#4,d2
02:00006E38 8401            	  3324: 	or.b		d1,d2
                            	  3325: S1932b:
02:00006E3A 6140            	  3326: 	bsr			sGetChar
02:00006E3C 6100FD02        	  3327: 	bsr			AsciiToHexNybble
02:00006E40 E98A            	  3328: 	lsl.l		#4,d2
02:00006E42 8401            	  3329: 	or.b		d1,d2
02:00006E44 6136            	  3330: 	bsr			sGetChar
02:00006E46 6100FCF8        	  3331: 	bsr			AsciiToHexNybble
02:00006E4A E98A            	  3332: 	lsl.l		#4,d2
02:00006E4C 8401            	  3333: 	or.b		d1,d2
02:00006E4E 612C            	  3334: 	bsr			sGetChar
02:00006E50 6100FCEE        	  3335: 	bsr			AsciiToHexNybble
02:00006E54 E98A            	  3336: 	lsl.l		#4,d2
02:00006E56 8401            	  3337: 	or.b		d1,d2
02:00006E58 7800            	  3338: 	clr.l		d4
02:00006E5A 2242            	  3339: 	move.l	d2,a1
                            	  3340: 	; Add bytes from address value to checksum
02:00006E5C D53900100150    	  3341: 	add.b		d2,S19Checksum
02:00006E62 E08A            	  3342: 	lsr.l		#8,d2
02:00006E64 D53900100150    	  3343: 	add.b		d2,S19Checksum
02:00006E6A E08A            	  3344: 	lsr.l		#8,d2
02:00006E6C D53900100150    	  3345: 	add.b		d2,S19Checksum
02:00006E72 E08A            	  3346: 	lsr.l		#8,d2
02:00006E74 D53900100150    	  3347: 	add.b		d2,S19Checksum
02:00006E7A 4E75            	  3348: 	rts
                            	  3349: 
                            	  3350: ;------------------------------------------------------------------------------
                            	  3351: ; Get a character from auxillary input. Waiting for a character is limited to
                            	  3352: ; 32000 tries. If a character is not available within the limit, then a return
                            	  3353: ; to the monitor is done.
                            	  3354: ;
                            	  3355: ;	Parameters:
                            	  3356: ;		none
                            	  3357: ; Returns:
                            	  3358: ;		d1 = character from receive buffer or -1 if no char available
                            	  3359: ;------------------------------------------------------------------------------
                            	  3360: 
                            	  3361: sGetChar:
02:00006E7C 48E7A000        	  3362: 	movem.l	d0/d2,-(a7)
02:00006E80 343C7D00        	  3363: 	move.w	#32000,d2
                            	  3364: .0001:
02:00006E84 7024            	  3365: 	moveq		#36,d0				; serial get char from buffer
02:00006E86 4E4F            	  3366: 	trap		#15
02:00006E88 4A41            	  3367: 	tst.w		d1						; was there a char available?
02:00006E8A 6A10            	  3368: 	bpl.s		.0002
02:00006E8C 51CAFFF6        	  3369: 	dbra		d2,.0001			; no - try again
02:00006E90 4CDF0005        	  3370: 	movem.l	(a7)+,d0/d2
                            	  3371: .0003:
02:00006E94 6100E7B4        	  3372: 	bsr			_KeybdInit
02:00006E98 6000F028        	  3373: 	bra			Monitor				; ran out of tries
                            	  3374: .0002:
02:00006E9C 4CDF0005        	  3375: 	movem.l	(a7)+,d0/d2
02:00006EA0 0C01001A        	  3376: 	cmpi.b	#CTRLZ,d1			; receive end of file?
02:00006EA4 67EE            	  3377: 	beq			.0003
02:00006EA6 4E75            	  3378: 	rts
                            	  3379: 
                            	  3380: AudioInputTest:
02:00006EA8 4E75            	  3381: 	rts
                            	  3382: BouncingBalls:
02:00006EAA 4E75            	  3383: 	rts
                            	  3384: GraphicsDemo:
02:00006EAC 4E75            	  3385: 	rts
                            	  3386: ClearScreen:
02:00006EAE 6000E22E        	  3387: 	bra		clear_screen
02:00006EB2 4E75            	  3388: 	rts
                            	  3389: 
                            	  3390: ;------------------------------------------------------------------------------
                            	  3391: ; Reverse the order of bytes in d1.
                            	  3392: ;------------------------------------------------------------------------------
                            	  3393: 
                            	  3394: rbo:
02:00006EB4 E159            	  3395: 	rol.w		#8,d1
02:00006EB6 4841            	  3396: 	swap		d1
02:00006EB8 E159            	  3397: 	rol.w		#8,d1
02:00006EBA 4E75            	  3398: 	rts
                            	  3399: 
                            	  3400: ;==============================================================================
                            	  3401: ; Serial I/O routines
                            	  3402: ;==============================================================================
                            	  3403: 
                            	  3404: ;------------------------------------------------------------------------------
                            	  3405: ; Initialize the serial port an enhanced 6551 circuit.
                            	  3406: ;
                            	  3407: ; Select internal baud rate clock divider for 9600 baud
                            	  3408: ; Reset fifos, set threshold to 3/4 full on transmit and 3/4 empty on receive
                            	  3409: ; Note that the byte order is swapped.
                            	  3410: ;------------------------------------------------------------------------------
                            	  3411: 
                            	  3412: SerialInit:
02:00006EBC 427900100162    	  3413: 	clr.w		SerHeadRcv					; clear receive buffer indexes
02:00006EC2 427900100160    	  3414: 	clr.w		SerTailRcv
02:00006EC8 423900100164    	  3415: 	clr.b		SerRcvXon						; and Xon,Xoff flags
02:00006ECE 423900100165    	  3416: 	clr.b		SerRcvXoff
02:00006ED4 203C09000000    	  3417: 	move.l	#$09000000,d0				; dtr,rts active, rxint enabled, no parity
02:00006EDA 23C0FD060008    	  3418: 	move.l	d0,ACIA+ACIA_CMD
                            	  3419: ;	move.l	#$1E00F700,d0				; fifos enabled
02:00006EE0 203C1E000000    	  3420: 	move.l	#$1E000000,d0				; fifos disabled
02:00006EE6 23C0FD06000C    	  3421: 	move.l	d0,ACIA+ACIA_CTRL
02:00006EEC 4E75            	  3422: 	rts
                            	  3423: ;	move.l	#$0F000000,d0				; transmit a break for a while
                            	  3424: ;	move.l	d0,ACIA+ACIA_CMD
                            	  3425: ;	move.l	#300000,d2					; wait 100 ms
                            	  3426: ;	bra			.0001
                            	  3427: ;.0003:
                            	  3428: ;	swap		d2
                            	  3429: ;.0001:
                            	  3430: ;	nop
                            	  3431: ;	dbra		d2,.0001
                            	  3432: ;.0002:
                            	  3433: ;	swap		d2
                            	  3434: ;	dbra		d2,.0003
                            	  3435: ;	move.l	#$07000000,d0				; clear break
                            	  3436: ;	move.l	d0,ACIA+ACIA_CMD
                            	  3437: ;	rts
                            	  3438: 	
                            	  3439: ;------------------------------------------------------------------------------
                            	  3440: ; SerialGetChar
                            	  3441: ;
                            	  3442: ; Check the serial port buffer to see if there's a char available. If there's
                            	  3443: ; a char available then return it. If the buffer is almost empty then send an
                            	  3444: ; XON.
                            	  3445: ;
                            	  3446: ; Stack Space:
                            	  3447: ;		2 long words
                            	  3448: ; Parameters:
                            	  3449: ;		none
                            	  3450: ; Modifies:
                            	  3451: ;		d0,a0
                            	  3452: ; Returns:
                            	  3453: ;		d1 = character or -1
                            	  3454: ;------------------------------------------------------------------------------
                            	  3455: 
                            	  3456: SerialGetChar:
02:00006EEE 2F02            	  3457: 	move.l		d2,-(a7)
02:00006EF0 4E7A0FE0        	  3458: 	movec			coreno,d0
02:00006EF4 4840            	  3459: 	swap			d0
02:00006EF6 7202            	  3460: 	moveq			#SERIAL_SEMA,d1
02:00006EF8 61009346        	  3461: 	bsr				LockSemaphore
02:00006EFC 610000DE        	  3462: 	bsr				SerialRcvCount			; check number of chars in receive buffer
02:00006F00 0C400008        	  3463: 	cmpi.w		#8,d0								; less than 8?
02:00006F04 621C            	  3464: 	bhi				.sgc2
02:00006F06 4A3900100164    	  3465: 	tst.b			SerRcvXon						; skip sending XON if already sent
02:00006F0C 6614            	  3466: 	bne	  		.sgc2            		; XON already sent?
02:00006F0E 123C0011        	  3467: 	move.b		#XON,d1							; if <8 send an XON
02:00006F12 423900100165    	  3468: 	clr.b			SerRcvXoff					; clear XOFF status
02:00006F18 13C100100164    	  3469: 	move.b		d1,SerRcvXon				; flag so we don't send it multiple times
02:00006F1E 61000098        	  3470: 	bsr				SerialPutChar				; send it
                            	  3471: .sgc2:
02:00006F22 323900100162    	  3472: 	move.w		SerHeadRcv,d1				; check if anything is in buffer
02:00006F28 B27900100160    	  3473: 	cmp.w			SerTailRcv,d1
02:00006F2E 6720            	  3474: 	beq				.NoChars						; no?
02:00006F30 41F900101000    	  3475: 	lea				SerRcvBuf,a0
02:00006F36 12301000        	  3476: 	move.b		(a0,d1.w),d1				; get byte from buffer
02:00006F3A 527900100162    	  3477: 	addi.w		#1,SerHeadRcv
02:00006F40 02790FFF00100162	  3478: 	andi.w		#$FFF,SerHeadRcv		; 4k wrap around
02:00006F48 0281000000FF    	  3479: 	andi.l		#$FF,d1
02:00006F4E 6002            	  3480: 	bra				.Xit
                            	  3481: .NoChars:
02:00006F50 72FF            	  3482: 	moveq			#-1,d1
                            	  3483: .Xit:
02:00006F52 C342            	  3484: 	exg				d1,d2
02:00006F54 4E7A0FE0        	  3485: 	movec			coreno,d0
02:00006F58 4840            	  3486: 	swap			d0
02:00006F5A 7202            	  3487: 	moveq			#SERIAL_SEMA,d1
02:00006F5C 6100931E        	  3488: 	bsr				UnlockSemaphore
02:00006F60 C541            	  3489: 	exg				d2,d1
02:00006F62 241F            	  3490: 	move.l		(a7)+,d2
02:00006F64 4E75            	  3491: 	rts
                            	  3492: 
                            	  3493: ;------------------------------------------------------------------------------
                            	  3494: ; SerialPeekChar
                            	  3495: ;
                            	  3496: ; Check the serial port buffer to see if there's a char available. If there's
                            	  3497: ; a char available then return it. But don't update the buffer indexes. No need
                            	  3498: ; to send an XON here.
                            	  3499: ;
                            	  3500: ; Stack Space:
                            	  3501: ;		0 words
                            	  3502: ; Parameters:
                            	  3503: ;		none
                            	  3504: ; Modifies:
                            	  3505: ;		d0,d2,a0
                            	  3506: ; Returns:
                            	  3507: ;		d1 = character or -1
                            	  3508: ;------------------------------------------------------------------------------
                            	  3509: 
                            	  3510: SerialPeekChar:
02:00006F66 4E7A0FE0        	  3511: 	movec		coreno,d0
02:00006F6A 4840            	  3512: 	swap		d0
02:00006F6C 7202            	  3513: 	moveq		#SERIAL_SEMA,d1
02:00006F6E 610092D0        	  3514: 	bsr			LockSemaphore
02:00006F72 343900100162    	  3515: 	move.w	SerHeadRcv,d2		; check if anything is in buffer
02:00006F78 B47900100160    	  3516: 	cmp.w		SerTailRcv,d2
02:00006F7E 670C            	  3517: 	beq			.NoChars				; no?
02:00006F80 41F900101000    	  3518: 	lea			SerRcvBuf,a0
02:00006F86 14302000        	  3519: 	move.b	(a0,d2.w),d2		; get byte from buffer
02:00006F8A 6002            	  3520: 	bra			.Xit
                            	  3521: .NoChars:
02:00006F8C 74FF            	  3522: 	moveq		#-1,d2
                            	  3523: .Xit:
02:00006F8E 4E7A0FE0        	  3524: 	movec		coreno,d0
02:00006F92 4840            	  3525: 	swap		d0
02:00006F94 7202            	  3526: 	moveq		#SERIAL_SEMA,d1
02:00006F96 610092A8        	  3527: 	bsr			LockSemaphore
02:00006F9A 3202            	  3528: 	move		d2,d1
02:00006F9C 4E75            	  3529: 	rts
                            	  3530: 
                            	  3531: ;------------------------------------------------------------------------------
                            	  3532: ; SerialPeekChar
                            	  3533: ;		Get a character directly from the I/O port. This bypasses the input
                            	  3534: ; buffer.
                            	  3535: ;
                            	  3536: ; Stack Space:
                            	  3537: ;		0 words
                            	  3538: ; Parameters:
                            	  3539: ;		none
                            	  3540: ; Modifies:
                            	  3541: ;		d
                            	  3542: ; Returns:
                            	  3543: ;		d1 = character or -1
                            	  3544: ;------------------------------------------------------------------------------
                            	  3545: 
                            	  3546: SerialPeekCharDirect:
02:00006F9E 1239FD060004    	  3547: 	move.b	ACIA+ACIA_STAT,d1	; get serial status
02:00006FA4 08010003        	  3548: 	btst		#3,d1							; look for Rx not empty
02:00006FA8 670A            	  3549: 	beq.s		.0001
02:00006FAA 7200            	  3550: 	moveq.l	#0,d1							; clear upper bits of return value
02:00006FAC 1239FD060000    	  3551: 	move.b	ACIA+ACIA_RX,d1		; get data from ACIA
02:00006FB2 4E75            	  3552: 	rts												; return
                            	  3553: .0001:
02:00006FB4 72FF            	  3554: 	moveq		#-1,d1
02:00006FB6 4E75            	  3555: 	rts
                            	  3556: 
                            	  3557: ;------------------------------------------------------------------------------
                            	  3558: ; SerialPutChar
                            	  3559: ;    Put a character to the serial transmitter. This routine blocks until the
                            	  3560: ; transmitter is empty. 
                            	  3561: ;
                            	  3562: ; Stack Space
                            	  3563: ;		0 words
                            	  3564: ; Parameters:
                            	  3565: ;		d1.b = character to put
                            	  3566: ; Modifies:
                            	  3567: ;		none
                            	  3568: ;------------------------------------------------------------------------------
                            	  3569: 
                            	  3570: SerialPutChar:
02:00006FB8 48E7C000        	  3571: 	movem.l	d0/d1,-(a7)				; push d0,d1
                            	  3572: .0001:
02:00006FBC 1039FD060004    	  3573: 	move.b	ACIA+ACIA_STAT,d0	; wait until the uart indicates tx empty
02:00006FC2 08000004        	  3574: 	btst		#4,d0							; bit #4 of the status reg
02:00006FC6 67F4            	  3575: 	beq.s		.0001			    		; branch if transmitter is not empty
02:00006FC8 13C1FD060000    	  3576: 	move.b	d1,ACIA+ACIA_TX		; send the byte
02:00006FCE 4CDF0003        	  3577: 	movem.l	(a7)+,d0/d1				; pop d0,d1
02:00006FD2 4E75            	  3578: 	rts
                            	  3579: 	
                            	  3580: ;------------------------------------------------------------------------------
                            	  3581: ; Reverse the order of bytes in d1.
                            	  3582: ;------------------------------------------------------------------------------
                            	  3583: 
                            	  3584: SerialRbo:
02:00006FD4 E159            	  3585: 	rol.w		#8,d1
02:00006FD6 4841            	  3586: 	swap		d1
02:00006FD8 E159            	  3587: 	rol.w		#8,d1
02:00006FDA 4E75            	  3588: 	rts
                            	  3589: 
                            	  3590: ;------------------------------------------------------------------------------
                            	  3591: ; Calculate number of character in input buffer
                            	  3592: ;
                            	  3593: ; Returns:
                            	  3594: ;		d0 = number of bytes in buffer.
                            	  3595: ;------------------------------------------------------------------------------
                            	  3596: 
                            	  3597: SerialRcvCount:
02:00006FDC 303900100160    	  3598: 	move.w	SerTailRcv,d0
02:00006FE2 907900100162    	  3599: 	sub.w		SerHeadRcv,d0
02:00006FE8 6C10            	  3600: 	bge			.0001
02:00006FEA 303C1000        	  3601: 	move.w	#$1000,d0
02:00006FEE 907900100162    	  3602: 	sub.w		SerHeadRcv,d0
02:00006FF4 D07900100160    	  3603: 	add.w		SerTailRcv,d0
                            	  3604: .0001:
02:00006FFA 4E75            	  3605: 	rts
                            	  3606: 
                            	  3607: ;------------------------------------------------------------------------------
                            	  3608: ; Serial IRQ routine
                            	  3609: ;
                            	  3610: ; Keeps looping as long as it finds characters in the ACIA recieve buffer/fifo.
                            	  3611: ; Received characters are buffered. If the buffer becomes full, new characters
                            	  3612: ; will be lost.
                            	  3613: ;
                            	  3614: ; Parameters:
                            	  3615: ;		none
                            	  3616: ; Modifies:
                            	  3617: ;		none
                            	  3618: ; Returns:
                            	  3619: ;		d1 = -1 if IRQ handled, otherwise zero
                            	  3620: ;------------------------------------------------------------------------------
                            	  3621: 
                            	  3622: SerialIRQ:
02:00006FFC 46FC2300        	  3623: 	move.w	#$2300,sr						; disable lower level IRQs
02:00007000 48E7E080        	  3624: 	movem.l	d0/d1/d2/a0,-(a7)
02:00007004 4E7A0FE0        	  3625: 	movec		coreno,d0
02:00007008 4840            	  3626: 	swap		d0
02:0000700A 7202            	  3627: 	moveq		#SERIAL_SEMA,d1
02:0000700C 61009232        	  3628: 	bsr			LockSemaphore
                            	  3629: sirqNxtByte:
02:00007010 1239FD060004    	  3630: 	move.b	ACIA+ACIA_STAT,d1		; check the status
02:00007016 08010003        	  3631: 	btst		#3,d1								; bit 3 = rx full
02:0000701A 6756            	  3632: 	beq			notRxInt
02:0000701C 1239FD060000    	  3633: 	move.b	ACIA+ACIA_RX,d1
                            	  3634: sirq0001:
02:00007022 303900100160    	  3635: 	move.w	SerTailRcv,d0				; check if recieve buffer full
02:00007028 5240            	  3636: 	addi.w	#1,d0
02:0000702A 02400FFF        	  3637: 	andi.w	#$FFF,d0
02:0000702E B07900100162    	  3638: 	cmp.w		SerHeadRcv,d0
02:00007034 673C            	  3639: 	beq			sirqRxFull
02:00007036 33C000100160    	  3640: 	move.w	d0,SerTailRcv				; update tail pointer
02:0000703C 5340            	  3641: 	subi.w	#1,d0								; backup
02:0000703E 02400FFF        	  3642: 	andi.w	#$FFF,d0
02:00007042 41F900101000    	  3643: 	lea			SerRcvBuf,a0				; a0 = buffer address
02:00007048 11810000        	  3644: 	move.b	d1,(a0,d0.w)				; store recieved byte in buffer
02:0000704C 4A3900100165    	  3645: 	tst.b		SerRcvXoff					; check if xoff already sent
02:00007052 66BC            	  3646: 	bne			sirqNxtByte
02:00007054 6186            	  3647: 	bsr			SerialRcvCount			; if more than 4080 chars in buffer
02:00007056 0C400FF0        	  3648: 	cmpi.w	#4080,d0
02:0000705A 65B4            	  3649: 	blo			sirqNxtByte
02:0000705C 123C0013        	  3650: 	move.b	#XOFF,d1						; send an XOFF
02:00007060 423900100164    	  3651: 	clr.b		SerRcvXon						; clear XON status
02:00007066 13C100100165    	  3652: 	move.b	d1,SerRcvXoff				; set XOFF status
02:0000706C 6100FF4A        	  3653: 	bsr			SerialPutChar				; send XOFF
02:00007070 609E            	  3654: 	bra			sirqNxtByte     		; check the status for another byte
                            	  3655: sirqRxFull:
                            	  3656: notRxInt:
02:00007072 4E7A0FE0        	  3657: 	movec		coreno,d0
02:00007076 4840            	  3658: 	swap		d0
02:00007078 7202            	  3659: 	moveq		#SERIAL_SEMA,d1
02:0000707A 61009200        	  3660: 	bsr			UnlockSemaphore
02:0000707E 4CDF0107        	  3661: 	movem.l	(a7)+,d0/d1/d2/a0
02:00007082 4E73            	  3662: 	rte
                            	  3663: 
                            	  3664: nmeSerial:
02:00007084 53657269616C    	  3665: 	dc.b		"Serial",0
02:0000708A 00
                            	  3666: 
                            	  3667: ;===============================================================================
                            	  3668: ; Generic I2C routines
                            	  3669: ;===============================================================================
                            	  3670: 
                            	  3671: 	even
                            	  3672: ; i2c
                            	  3673: i2c_setup:
                            	  3674: ;		lea		I2C,a6				
                            	  3675: ;		move.w	#19,I2C_PREL(a6)	; setup prescale for 400kHz clock
                            	  3676: ;		move.w	#0,I2C_PREH(a6)
                            	  3677: init_i2c:
02:0000708C 4DF9FD069000    	  3678: 	lea	I2C2,a6				
02:00007092 1CBC0013        	  3679: 	move.b #19,I2C_PREL(a6)	; setup prescale for 400kHz clock, 40MHz master
02:00007096 422E0001        	  3680: 	move.b #0,I2C_PREH(a6)
02:0000709A 4E75            	  3681: 	rts
                            	  3682: 
                            	  3683: ; Wait for I2C transfer to complete
                            	  3684: ;
                            	  3685: ; Parameters
                            	  3686: ; 	a6 - I2C controller base address
                            	  3687: 
                            	  3688: i2c_wait_tip:
02:0000709C 2F00            	  3689: 	move.l d0,-(a7)
                            	  3690: .0001				
02:0000709E 102E0004        	  3691: 	move.b I2C_STAT(a6),d0		; wait for tip to clear
02:000070A2 08000001        	  3692: 	btst #1,d0
02:000070A6 66F6            	  3693: 	bne.s	.0001
02:000070A8 201F            	  3694: 	move.l (a7)+,d0
02:000070AA 4E75            	  3695: 	rts
                            	  3696: 
                            	  3697: ; Parameters
                            	  3698: ;	d0.b - data to transmit
                            	  3699: ;	d1.b - command value
                            	  3700: ;	a6	 - I2C controller base address
                            	  3701: ;
                            	  3702: i2c_wr_cmd:
02:000070AC 1D400003        	  3703: 	move.b d0,I2C_TXR(a6)
02:000070B0 1D410004        	  3704: 	move.b d1,I2C_CMD(a6)
02:000070B4 61E6            	  3705: 	bsr	i2c_wait_tip
02:000070B6 102E0004        	  3706: 	move.b I2C_STAT(a6),d0
02:000070BA 4E75            	  3707: 	rts
                            	  3708: 
                            	  3709: i2c_xmit1:
02:000070BC 2F00            	  3710: 	move.l d0,-(a7)
02:000070BE 1D7C00010002    	  3711: 	move.b #1,I2C_CTRL(a6)		; enable the core
02:000070C4 7076            	  3712: 	moveq	#$76,d0				; set slave address = %0111011
02:000070C6 323C0090        	  3713: 	move.w #$90,d1				; set STA, WR
02:000070CA 61E0            	  3714: 	bsr i2c_wr_cmd
02:000070CC 610C            	  3715: 	bsr	i2c_wait_rx_nack
02:000070CE 201F            	  3716: 	move.l (a7)+,d0
02:000070D0 323C0050        	  3717: 	move.w #$50,d1				; set STO, WR
02:000070D4 61D6            	  3718: 	bsr i2c_wr_cmd
02:000070D6 61000002        	  3719: 	bsr	i2c_wait_rx_nack
                            	  3720: 
                            	  3721: i2c_wait_rx_nack:
02:000070DA 2F00            	  3722: 	move.l d0,-(a7)
                            	  3723: .0001						
02:000070DC 102E0004        	  3724: 	move.b I2C_STAT(a6),d0		; wait for RXack = 0
02:000070E0 08000007        	  3725: 	btst #7,d0
02:000070E4 66F6            	  3726: 	bne.s	.0001
02:000070E6 201F            	  3727: 	move.l (a7)+,d0
02:000070E8 4E75            	  3728: 	rts
                            	  3729: 
                            	  3730: ;===============================================================================
                            	  3731: ; Realtime clock routines
                            	  3732: ;===============================================================================
                            	  3733: 
                            	  3734: rtc_read:
02:000070EA 2C7CFD069000    	  3735: 	movea.l	#I2C2,a6
02:000070F0 4BF900100200    	  3736: 	lea	RTCBuf,a5
02:000070F6 1D7C00800002    	  3737: 	move.b	#$80,I2C_CTRL(a6)	; enable I2C
02:000070FC 103C00DE        	  3738: 	move.b	#$DE,d0				; read address, write op
02:00007100 123C0090        	  3739: 	move.b	#$90,d1				; STA + wr bit
02:00007104 61A6            	  3740: 	bsr	i2c_wr_cmd
02:00007106 4A00            	  3741: 	tst.b	d0
02:00007108 6B66            	  3742: 	bmi	.rxerr
02:0000710A 4200            	  3743: 	move.b #$00,d0				; address zero
02:0000710C 123C0010        	  3744: 	move.b #$10,d1				; wr bit
02:00007110 619A            	  3745: 	bsr	i2c_wr_cmd
02:00007112 4A00            	  3746: 	tst.b	d0
02:00007114 6B5A            	  3747: 	bmi	.rxerr
02:00007116 103C00DF        	  3748: 	move.b #$DF,d0				; read address, read op
02:0000711A 123C0090        	  3749: 	move.b #$90,d1				; STA + wr bit
02:0000711E 618C            	  3750: 	bsr i2c_wr_cmd
02:00007120 4A00            	  3751: 	tst.b	d0
02:00007122 6B4C            	  3752: 	bmi	.rxerr
                            	  3753: 		
02:00007124 343C0020        	  3754: 	move.w #$20,d2
                            	  3755: .0001
02:00007128 1D7C00200004    	  3756: 	move.b #$20,I2C_CMD(a6)	; rd bit
02:0000712E 6100FF6C        	  3757: 	bsr	i2c_wait_tip
02:00007132 61A6            	  3758: 	bsr	i2c_wait_rx_nack
02:00007134 102E0004        	  3759: 	move.b I2C_STAT(a6),d0
02:00007138 4A00            	  3760: 	tst.b	d0
02:0000713A 6B34            	  3761: 	bmi	.rxerr
02:0000713C 102E0003        	  3762: 	move.b I2C_RXR(a6),d0
02:00007140 1B802000        	  3763: 	move.b d0,(a5,d2.w)
02:00007144 5242            	  3764: 	addi.w #1,d2
02:00007146 0C42005F        	  3765: 	cmpi.w #$5F,d2
02:0000714A 66DC            	  3766: 	bne	.0001
02:0000714C 1D7C00680004    	  3767: 	move.b #$68,I2C_CMD(a6)	; STO, rd bit + nack
02:00007152 6100FF48        	  3768: 	bsr i2c_wait_tip
02:00007156 6182            	  3769: 	bsr i2c_wait_rx_nack
02:00007158 102E0004        	  3770: 	move.b I2C_STAT(a6),d0
02:0000715C 4A00            	  3771: 	tst.b	d0
02:0000715E 6B10            	  3772: 	bmi	.rxerr
02:00007160 102E0003        	  3773: 	move.b I2C_RXR(a6),d0
02:00007164 1B802000        	  3774: 	move.b d0,(a5,d2.w)
02:00007168 422E0002        	  3775: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
02:0000716C 7000            	  3776: 	moveq	#0,d0
02:0000716E 4E75            	  3777: 	rts
                            	  3778: .rxerr
02:00007170 422E0002        	  3779: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
02:00007174 4E75            	  3780: 	rts
                            	  3781: 
                            	  3782: rtc_write:
02:00007176 2C7CFD069000    	  3783: 	movea.l	#I2C2,a6
02:0000717C 4BF900100200    	  3784: 	lea	RTCBuf,a5
02:00007182 1D7C00800002    	  3785: 	move.b #$80,I2C_CTRL(a6)	; enable I2C
02:00007188 103C00DE        	  3786: 	move.b #$DE,d0				; read address, write op
02:0000718C 123C0090        	  3787: 	move.b #$90,d1				; STA + wr bit
02:00007190 6100FF1A        	  3788: 	bsr	i2c_wr_cmd
02:00007194 4A00            	  3789: 	tst.b	d0
02:00007196 6B42            	  3790: 	bmi	.rxerr
02:00007198 4200            	  3791: 	move.b #$00,d0				; address zero
02:0000719A 123C0010        	  3792: 	move.b #$10,d1				; wr bit
02:0000719E 6100FF0C        	  3793: 	bsr	i2c_wr_cmd
02:000071A2 4A00            	  3794: 	tst.b	d0
02:000071A4 6B34            	  3795: 	bmi	.rxerr
02:000071A6 343C0020        	  3796: 	move.w #$20,d2
                            	  3797: .0001
02:000071AA 10352000        	  3798: 	move.b (a5,d2.w),d0
02:000071AE 123C0010        	  3799: 	move.b #$10,d1
02:000071B2 6100FEF8        	  3800: 	bsr	i2c_wr_cmd
02:000071B6 4A00            	  3801: 	tst.b	d0
02:000071B8 6B20            	  3802: 	bmi	.rxerr
02:000071BA 5242            	  3803: 	addi.w #1,d2
02:000071BC 0C42005F        	  3804: 	cmpi.w #$5F,d2
02:000071C0 66E8            	  3805: 	bne.s	.0001
02:000071C2 10352000        	  3806: 	move.b (a5,d2.w),d0
02:000071C6 123C0050        	  3807: 	move.b #$50,d1				; STO, wr bit
02:000071CA 6100FEE0        	  3808: 	bsr	i2c_wr_cmd
02:000071CE 4A00            	  3809: 	tst.b	d0
02:000071D0 6B08            	  3810: 	bmi	.rxerr
02:000071D2 422E0002        	  3811: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
02:000071D6 7000            	  3812: 	moveq	#0,d0
02:000071D8 4E75            	  3813: 	rts
                            	  3814: .rxerr:
02:000071DA 422E0002        	  3815: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
02:000071DE 4E75            	  3816: 	rts
                            	  3817: 
                            	  3818: msgRtcReadFail:
02:000071E0 5254432072656164	  3819: 	dc.b	"RTC read/write failed.",$0A,$0D,$00
02:000071E8 2F77726974652066
02:000071F0 61696C65642E
02:000071F6 0A
02:000071F7 0D
02:000071F8 00
                            	  3820: 
                            	  3821: 	even
                            	  3822: 
                            	  3823: ;------------------------------------------------------------------------------
                            	  3824: ;------------------------------------------------------------------------------
                            	  3825: 	even
                            	  3826: 
                            	  3827: bus_err:
                            	  3828: .0001:
02:000071FA 4E71            	  3829: 	nop
02:000071FC 60FC            	  3830: 	bra			.0001
                            	  3831: 
                            	  3832: trap3:
                            	  3833: 	; First save all registers
02:000071FE 48F9FFFF00040100	  3834: 	movem.l		d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
02:00007206 33DF00040140    	  3835: 	move.w		(a7)+,Regsave+$40
02:0000720C 23DF00040144    	  3836: 	move.l		(a7)+,Regsave+$44
02:00007212 2E7C00040FFC    	  3837: 	move.l		#$40FFC,a7			; reset stack pointer
02:00007218 46FC2500        	  3838: 	move.w		#$2500,sr				; enable interrupts
02:0000721C 303900040202    	  3839: 	move.w		NumSetBreakpoints,d0
02:00007222 5340            	  3840: 	subi.w		#1,d0
02:00007224 41F900040220    	  3841: 	lea				Breakpoints,a0
02:0000722A 223900040144    	  3842: 	move.l		Regsave+$44,d1
                            	  3843: .0001:
02:00007230 B298            	  3844: 	cmp.l			(a0)+,d1
02:00007232 6708            	  3845: 	beq.s			ProcessBreakpoint
02:00007234 51C8FFFA        	  3846: 	dbra			d0,.0001
02:00007238 6000EC88        	  3847: 	bra				Monitor					; not a breakpoint
                            	  3848: ProcessBreakpoint:
02:0000723C 6104            	  3849: 	bsr				DisarmAllBreakpoints
02:0000723E 6000F2AE        	  3850: 	bra				cmdDumpRegs
                            	  3851: 
                            	  3852: ;------------------------------------------------------------------------------
                            	  3853: ; DisarmAllBreakpoints, used when entering the monitor.
                            	  3854: ;------------------------------------------------------------------------------
                            	  3855: 
                            	  3856: DisarmAllBreakpoints:
02:00007242 48E780E0        	  3857: 	movem.l	d0/a0/a1/a2,-(a7)			; stack some regs
02:00007246 303900040202    	  3858: 	move.w	NumSetBreakpoints,d0	; d0 = number of breakpoints that are set
02:0000724C 0C400008        	  3859: 	cmpi.w	#numBreakpoints,d0		; check for valid number
02:00007250 641A            	  3860: 	bhs.s		.0001
02:00007252 45F900040220    	  3861: 	lea			Breakpoints,a2				; a2 = pointer to breakpoint address table
02:00007258 41F900040280    	  3862: 	lea			BreakpointWords,a0		; a0 = pointer to breakpoint instruction word table
02:0000725E 6004            	  3863: 	bra.s		.0003									; enter loop at bottom
                            	  3864: .0002:
02:00007260 225A            	  3865: 	move.l	(a2)+,a1							; a1 = address of breakpoint
02:00007262 3298            	  3866: 	move.w	(a0)+,(a1)						; copy instruction word back to code
                            	  3867: .0003:
02:00007264 51C8FFFA        	  3868: 	dbra		d0,.0002
02:00007268 4CDF0701        	  3869: 	movem.l	(a7)+,d0/a0/a1/a2			; restore regs
                            	  3870: .0001:
02:0000726C 4E75            	  3871: 	rts	
                            	  3872: 
                            	  3873: ;------------------------------------------------------------------------------
                            	  3874: ; ArmAllBreakpoints, used when entering the monitor.
                            	  3875: ;------------------------------------------------------------------------------
                            	  3876: 
                            	  3877: ArmAllBreakpoints:
02:0000726E 48E780E0        	  3878: 	movem.l		d0/a0/a1/a2,-(a7)			; stack some regs
02:00007272 303900040202    	  3879: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:00007278 0C400008        	  3880: 	cmpi.w		#numBreakpoints,d0		; is the number valid?
02:0000727C 641E            	  3881: 	bhs.s			.0001
02:0000727E 45F900040220    	  3882: 	lea				Breakpoints,a2				; a2 = pointer to breakpoint address table
02:00007284 41F900040280    	  3883: 	lea				BreakpointWords,a0		; a0 = pointer to instruction word table
02:0000728A 6008            	  3884: 	bra.s			.0003									; enter loop at bottom
                            	  3885: .0002:
02:0000728C 225A            	  3886: 	move.l		(a2)+,a1							; a1 = address of breakpoint
02:0000728E 3091            	  3887: 	move.w		(a1),(a0)							; copy instruction word to table
02:00007290 30FC4E43        	  3888: 	move.w		#$4E43,(a0)+					; set instruction = TRAP3
                            	  3889: .0003:
02:00007294 51C8FFF6        	  3890: 	dbra			d0,.0002
02:00007298 4CDF0701        	  3891: 	movem.l		(a7)+,d0/a0/a1/a2			; restore regs
                            	  3892: .0001:
02:0000729C 4E75            	  3893: 	rts	
                            	  3894: 
                            	  3895: ;------------------------------------------------------------------------------
                            	  3896: ;------------------------------------------------------------------------------
                            	  3897: 
                            	  3898: ArmBreakpoint:
02:0000729E 48E7E0E0        	  3899: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
02:000072A2 303900040202    	  3900: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:000072A8 0C400008        	  3901: 	cmpi.w		#numBreakpoints,d0		; check if too many
02:000072AC 645A            	  3902: 	bhs.s			.0001
02:000072AE 527900040202    	  3903: 	addi.w		#1,NumSetBreakpoints	; increment number of breakpoints
02:000072B4 2400            	  3904: 	move.l		d0,d2
02:000072B6 6100F128        	  3905: 	bsr				ignBlanks
02:000072BA 6100F2FC        	  3906: 	bsr				GetHexNumber
02:000072BE 6748            	  3907: 	beq.s			.0001									; was there an address?
02:000072C0 08010000        	  3908: 	btst			#0,d1									; address value must be even
02:000072C4 6642            	  3909: 	bne.s			.0001
                            	  3910: 	; See if the breakpoint is in the table already
02:000072C6 43F900040220    	  3911: 	lea				Breakpoints,a1				; a1 points to breakpoint table
02:000072CC 343C0007        	  3912: 	move.w		#numBreakpoints-1,d2
                            	  3913: .0002:
02:000072D0 B299            	  3914: 	cmp.l			(a1)+,d1
02:000072D2 673A            	  3915: 	beq.s			.0003									; breakpoint is in table already
02:000072D4 51CAFFFA        	  3916: 	dbra			d2,.0002
                            	  3917: 	; Add breakpoint to table
                            	  3918: 	; Search for empty entry
02:000072D8 43F900040220    	  3919: 	lea				Breakpoints,a1				; a1 = pointer to breakpoint address table
02:000072DE 4242            	  3920: 	clr.w			d2										; d2 = count
                            	  3921: .0006:
02:000072E0 4A91            	  3922: 	tst.l			(a1)									; is the entry empty?
02:000072E2 670C            	  3923: 	beq.s			.0005									; branch if found empty entry
02:000072E4 5889            	  3924: 	lea				4(a1),a1							; point to next entry
02:000072E6 5242            	  3925: 	addi.w		#1,d2									; increment count
02:000072E8 0C420008        	  3926: 	cmpi.w		#numBreakpoints,d2		; safety: check against max number
02:000072EC 65F2            	  3927: 	blo.s			.0006
02:000072EE 6018            	  3928: 	bra.s			.0001									; what? no empty entries found, table corrupt?
                            	  3929: .0005:
02:000072F0 E542            	  3930: 	asl.w			#2,d2									; d2 = long word index
02:000072F2 23812000        	  3931: 	move.l		d1,(a1,d2.w)					; move breakpoint address to table
02:000072F6 2441            	  3932: 	move.l		d1,a2
02:000072F8 E24A            	  3933: 	lsr.w			#1,d2									; d2 = word index
                            	  3934: .0004:
02:000072FA 43F900040280    	  3935: 	lea				BreakpointWords,a1
02:00007300 33922000        	  3936: 	move.w		(a2),(a1,d2.w)				; copy instruction word to table
02:00007304 34BC4E43        	  3937: 	move.w		#$4E43,(a2)						; replace word with TRAP3
                            	  3938: .0001:
02:00007308 4CDF0707        	  3939: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
02:0000730C 4E75            	  3940: 	rts
                            	  3941: .0003:
02:0000730E 2469FFFC        	  3942: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
02:00007312 0C524E43        	  3943: 	cmpi.w		#$4E43,(a2)						; see if breakpoint already armed
02:00007316 67F0            	  3944: 	beq.s			.0001
02:00007318 D482            	  3945: 	asl.l			#1,d2									; d2 = word index
02:0000731A 60DE            	  3946: 	bra.s			.0004
                            	  3947: 
                            	  3948: 
                            	  3949: ;------------------------------------------------------------------------------
                            	  3950: ;------------------------------------------------------------------------------
                            	  3951: 
                            	  3952: DisarmBreakpoint:
02:0000731C 48E7E0E0        	  3953: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
02:00007320 303900040202    	  3954: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:00007326 0C400008        	  3955: 	cmpi.w		#numBreakpoints,d0		; check if too many
02:0000732A 623E            	  3956: 	bhi.s			.0001
02:0000732C 2400            	  3957: 	move.l		d0,d2
02:0000732E 6100F0B0        	  3958: 	bsr				ignBlanks
02:00007332 6100F284        	  3959: 	bsr				GetHexNumber
02:00007336 6732            	  3960: 	beq.s			.0001									; was there an address?
02:00007338 08010000        	  3961: 	btst			#0,d1									; address value must be even
02:0000733C 662C            	  3962: 	bne.s			.0001
                            	  3963: 	; See if the breakpoint is in the table already
02:0000733E 43F900040220    	  3964: 	lea				Breakpoints,a1				; a1 points to breakpoint table
02:00007344 5342            	  3965: 	subi.w		#1,d2
                            	  3966: .0002:
02:00007346 B299            	  3967: 	cmp.l			(a1)+,d1
02:00007348 6706            	  3968: 	beq.s			.0003									; breakpoint is in table already
02:0000734A 51CAFFFA        	  3969: 	dbra			d2,.0002
02:0000734E 601A            	  3970: 	bra				.0001									; breakpoint was not in table
                            	  3971: .0003:
                            	  3972: 	; Remove breakpoint from table
02:00007350 537900040202    	  3973: 	subi.w		#1,NumSetBreakpoints	; decrement number of breakpoints
02:00007356 2469FFFC        	  3974: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
02:0000735A 42A9FFFC        	  3975: 	clr.l			-4(a1)								; empty out breakpoint
02:0000735E 43F900040280    	  3976: 	lea				BreakpointWords,a1
02:00007364 D482            	  3977: 	asl.l			#1,d2									; d2 = word index
02:00007366 34B12000        	  3978: 	move.w		(a1,d2.w),(a2)				; copy instruction from table back to code
                            	  3979: .0001:
02:0000736A 4CDF0707        	  3980: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
02:0000736E 4E75            	  3981: 	rts
                            	  3982: 
                            	  3983: ;------------------------------------------------------------------------------
                            	  3984: ;------------------------------------------------------------------------------
                            	  3985: 
                            	  3986: ListBreakpoints:
02:00007370 6100DDBC        	  3987: 	bsr			CRLF
02:00007374 343C0008        	  3988: 	move.w	#numBreakpoints,d2
02:00007378 43F900040220    	  3989: 	lea			Breakpoints,a1
                            	  3990: .0001:
02:0000737E 2219            	  3991: 	move.l	(a1)+,d1
02:00007380 6100F812        	  3992: 	bsr			DisplayTetra
02:00007384 6100DDA8        	  3993: 	bsr			CRLF
02:00007388 51CAFFF4        	  3994: 	dbra		d2,.0001
02:0000738C 6000EB34        	  3995: 	bra			Monitor
                            	  3996: 
                            	  3997: ;------------------------------------------------------------------------------
                            	  3998: ;------------------------------------------------------------------------------
                            	  3999: 
                            	  4000: ClearBreakpointList:
02:00007390 343C0008        	  4001: 	move.w	#numBreakpoints,d2
02:00007394 43F900040220    	  4002: 	lea			Breakpoints,a1
                            	  4003: .0001:
02:0000739A 4299            	  4004: 	clr.l		(a1)+
02:0000739C 51CAFFFC        	  4005: 	dbra		d2,.0001
02:000073A0 4E75            	  4006: 	rts
                            	  4007: 
                            	  4008: ;------------------------------------------------------------------------------
                            	  4009: ; SendMsg
                            	  4010: ; 00100xy0
                            	  4011: ;
                            	  4012: ; Parameters:
                            	  4013: ;		d1 = target core number
                            	  4014: ;		d2 = argument 1
                            	  4015: ;		d3 = argument 2
                            	  4016: ;		d4 = argument 3
                            	  4017: ;
                            	  4018: ;------------------------------------------------------------------------------
                            	  4019: 
                            	  4020: SendMsg:
02:000073A2 48E70440        	  4021: 	movem.l	d5/a1,-(a7)
02:000073A6 E149            	  4022: 	lsl.w		#8,d1
02:000073A8 4E7A5FE0        	  4023: 	movec		coreno,d5
02:000073AC E94D            	  4024: 	lsl.w		#4,d5
02:000073AE 8245            	  4025: 	or.w		d5,d1
02:000073B0 43F900100000    	  4026: 	lea			$00100000,a1
02:000073B6 4AB11000        	  4027: 	tst.l		0(a1,d1.w)
02:000073BA 661C            	  4028: 	bne			.msgFull
02:000073BC 4E7A5FE0        	  4029: 	movec		coreno,d5
02:000073C0 23851000        	  4030: 	move.l	d5,0(a1,d1.w)
02:000073C4 23821004        	  4031: 	move.l	d2,4(a1,d1.w)
02:000073C8 23831008        	  4032: 	move.l	d3,8(a1,d1.w)
02:000073CC 2384100C        	  4033: 	move.l	d4,12(a1,d1.w)
02:000073D0 4CDF0220        	  4034: 	movem.l	(a7)+,d5/a1
02:000073D4 7200            	  4035: 	moveq		#0,d1
02:000073D6 4E75            	  4036: 	rts
                            	  4037: .msgFull:
02:000073D8 4CDF0220        	  4038: 	movem.l	(a7)+,d5/a1
02:000073DC 72FF            	  4039: 	moveq		#-1,d1
02:000073DE 4E75            	  4040: 	rts
                            	  4041: 
                            	  4042: ;------------------------------------------------------------------------------
                            	  4043: ; ReceiveMsg
                            	  4044: ;		Scan the message table for messages and dispatch them.
                            	  4045: ; 00100xy0
                            	  4046: ;
                            	  4047: ; Parameters:
                            	  4048: ;------------------------------------------------------------------------------
                            	  4049: 
                            	  4050: ReceiveMsg:
02:000073E0 48E77F40        	  4051: 	movem.l		d1/d2/d3/d4/d5/d6/d7/a1,-(a7)
02:000073E4 43F900100000    	  4052: 	lea				$00100000,a1
02:000073EA 4E7A5FE0        	  4053: 	movec			coreno,d5
02:000073EE E14D            	  4054: 	lsl.w			#8,d5
02:000073F0 7C02            	  4055: 	moveq			#2,d6
                            	  4056: .nextCore:
02:000073F2 3E06            	  4057: 	move.w		d6,d7
02:000073F4 E94F            	  4058: 	lsl.w			#4,d7
02:000073F6 DE45            	  4059: 	add.w			d5,d7
02:000073F8 4AB17000        	  4060: 	tst.l			0(a1,d7.w)			; Is there a message from core d6?
02:000073FC 6716            	  4061: 	beq				.noMsg
02:000073FE 22317000        	  4062: 	move.l		0(a1,d7.w),d1
02:00007402 24317004        	  4063: 	move.l		4(a1,d7.w),d2
02:00007406 26317008        	  4064: 	move.l		8(a1,d7.w),d3
02:0000740A 2831700C        	  4065: 	move.l		12(a1,d7.w),d4
02:0000740E 42B17000        	  4066: 	clr.l			0(a1,d7.w)			; indicate message was received
02:00007412 610E            	  4067: 	bsr				DispatchMsg
                            	  4068: .noMsg:
02:00007414 5246            	  4069: 	addq			#1,d6
02:00007416 BC7C0009        	  4070: 	cmp.w			#9,d6
02:0000741A 63D6            	  4071: 	bls				.nextCore
02:0000741C 4CDF02FE        	  4072: 	movem.l		(a7)+,d1/d2/d3/d4/d5/d6/d7/a1
02:00007420 4E75            	  4073: 	rts
                            	  4074: 
                            	  4075: ;------------------------------------------------------------------------------
                            	  4076: ;------------------------------------------------------------------------------
                            	  4077: 
                            	  4078: DispatchMsg:
02:00007422 4E75            	  4079: 	rts
                            	  4080: 
                            	  4081: ;------------------------------------------------------------------------------
                            	  4082: ; Trap #15, function 39 - convert floating-point to string and display
                            	  4083: ;
                            	  4084: ; Parameters
                            	  4085: ;		a0 = pointer to buffer
                            	  4086: ;		fp0 = number to print
                            	  4087: ;		d1 = width of print field
                            	  4088: ;		d2 = precision
                            	  4089: ;		d3 = 'E' or 'e'
                            	  4090: ;------------------------------------------------------------------------------
                            	  4091: 
                            	  4092: prtflt:
02:00007424 48E7F240        	  4093: 	movem.l d0/d1/d2/d3/d6/a1,-(a7)
                            	  4094: ;	fmove.x fp0,-(a7)
02:00007428 2049            	  4095: 	move.l a1,a0						; a0 = pointer to buffer to use
02:0000742A 13C100040508    	  4096: 	move.b d1,_width
02:00007430 23C200040514    	  4097: 	move.l d2,_precision
02:00007436 13C30004050C    	  4098: 	move.b d3,_E
02:0000743C 6100F4D2        	  4099: 	bsr _FloatToString
02:00007440 6100DFB0        	  4100: 	bsr DisplayString
                            	  4101: ;	fmove.x (a7)+,fp0
02:00007444 4CDF024F        	  4102: 	movem.l (a7)+,d0/d1/d2/d3/d6/a1
02:00007448 4E75            	  4103: 	rts
                            	  4104: 
                            	  4105: ;==============================================================================
                            	  4106: ;==============================================================================
                            	  4107: ;------------------------------------------------------------------------------
                            	  4108: ;------------------------------------------------------------------------------
                            	  4109: 
                            	  4110: InitIRQ:
02:0000744A 7006            	  4111: 	moveq		#6,d0
02:0000744C 41FAE66C        	  4112: 	lea			KeybdIRQ,a0
02:00007450 610C            	  4113: 	bsr			InstallIRQ
02:00007452 41FA003A        	  4114: 	lea			TickIRQ,a0
02:00007456 6106            	  4115: 	bsr			InstallIRQ
02:00007458 7003            	  4116: 	moveq		#3,d0
02:0000745A 41FAFBA0        	  4117: 	lea			SerialIRQ,a0
                            	  4118: 	; fall through
                            	  4119: 
                            	  4120: ;------------------------------------------------------------------------------
                            	  4121: ; Install an IRQ handler.
                            	  4122: ;
                            	  4123: ; Parameters:
                            	  4124: ;		d0 = IRQ level
                            	  4125: ;		a0 = pointer to IRQ routine
                            	  4126: ; Returns:
                            	  4127: ;		d1 = -1 if successfully added, 0 otherwise
                            	  4128: ;		nf = 1, zf = 0 if successfully added, otherwise nf = 0, zf = 1
                            	  4129: ;------------------------------------------------------------------------------
                            	  4130: 
                            	  4131: InstallIRQ:
02:0000745E 2F00            	  4132: 	move.l	d0,-(a7)					; save working register
02:00007460 43F80400        	  4133: 	lea			InstalledIRQ,a1		; a1 points to installed IRQ list
02:00007464 EB48            	  4134: 	lsl.w		#5,d0							; multiply by 8 long words per IRQ level
                            	  4135: .nextSpot:
02:00007466 B1F10000        	  4136: 	cmpa.l	(a1,d0.w),a0			; Is the IRQ already installed?
02:0000746A 6716            	  4137: 	beq.s		.found
02:0000746C 4AB10000        	  4138: 	tst.l		(a1,d0.w)					; test for an empty spot
02:00007470 670C            	  4139: 	beq.s		.foundSpot
02:00007472 5840            	  4140: 	addi.w	#4,d0							; increment to next slot
02:00007474 3200            	  4141: 	move.w	d0,d1
02:00007476 0241001F        	  4142: 	andi.w	#$1F,d1						; check to see if spots exhausted
02:0000747A 670C            	  4143: 	beq.s		.noEmpties
02:0000747C 60E8            	  4144: 	bra.s		.nextSpot
                            	  4145: .foundSpot:
02:0000747E 23880000        	  4146: 	move.l	a0,(a1,d0.w)			; add IRQ routine to table
                            	  4147: .found:
02:00007482 201F            	  4148: 	move.l	(a7)+,d0
02:00007484 72FF            	  4149: 	moveq		#-1,d1						; return success
02:00007486 4E75            	  4150: 	rts
                            	  4151: .noEmpties:
02:00007488 201F            	  4152: 	move.l	(a7)+,d0
02:0000748A 7200            	  4153: 	moveq		#0,d1							; return failed to add
02:0000748C 4E75            	  4154: 	rts
                            	  4155: 	
                            	  4156: 
                            	  4157: ;------------------------------------------------------------------------------
                            	  4158: ;------------------------------------------------------------------------------
                            	  4159: 
                            	  4160: TickIRQ:
02:0000748E 46FC2600        	  4161: 	move.w	#$2600,sr					; disable lower level IRQs
02:00007492 48E76080        	  4162: 	movem.l	d1/d2/a0,-(a7)
02:00007496 13FC0001000400A0	  4163: 	move.b #1,IRQFlag
                            	  4164: 	; ToDo: detect a tick interrupt
                            	  4165: ;	move.l	PLIC+$00,d1
                            	  4166: ;	rol.l		#8,d1
                            	  4167: ;	cmpi.b	#29,d1
                            	  4168: ;	bne.s		.notTick
02:0000749E 4E7A1FE0        	  4169: 	movec		coreno,d1					; d1 = core number
02:000074A2 0C010002        	  4170: 	cmpi.b	#2,d1
02:000074A6 660A            	  4171: 	bne.s		.0001
02:000074A8 23FC1D000000FD09	  4172: 	move.l	#$1D000000,PLIC+$14	; reset edge sense circuit
02:000074B0 0014
                            	  4173: .0001:	
02:000074B2 207900040004    	  4174: 	move.l	TextScr,a0				; a0 = screen address
02:000074B8 2410            	  4175: 	move.l	(a0),d2
02:000074BA E15A            	  4176: 	rol.w		#8,d2							; reverse byte order of d2
02:000074BC 4842            	  4177: 	swap		d2
02:000074BE E15A            	  4178: 	rol.w		#8,d2
02:000074C0 06010030        	  4179: 	addi.b	#'0',d1						; binary to ascii core number
02:000074C4 D202            	  4180: 	add.b		d2,d1
02:000074C6 E159            	  4181: 	rol.w		#8,d1							; put bytes back in order
02:000074C8 4841            	  4182: 	swap		d1
02:000074CA E159            	  4183: 	rol.w		#8,d1
02:000074CC 21410004        	  4184: 	move.l	d1,4(a0)					; update onscreen IRQ flag
02:000074D0 5290            	  4185: 	addi.l	#1,(a0)						; flashy colors
                            	  4186: ; addi.l	#1,40(a0)					; nice effect
02:000074D2 6100FF0C        	  4187: 	bsr			ReceiveMsg
02:000074D6 4CDF0106        	  4188: 	movem.l	(a7)+,d1/d2/a0
02:000074DA 4E73            	  4189: 	rte
                            	  4190: ;.notTick:
                            	  4191: ;	movem.l	(a7)+,d1/a0
                            	  4192: ;	rte
                            	  4193: ;------------------------------------------------------------------------------
                            	  4194: ;------------------------------------------------------------------------------
                            	  4195: 
                            	  4196: irq3_rout:
02:000074DC 48E7C0C0        	  4197: 	movem.l	d0/d1/a0/a1,-(a7)
02:000074E0 41F80460        	  4198: 	lea			InstalledIRQ+8*4*3,a0
02:000074E4 6008            	  4199: 	bra			irq_rout
                            	  4200: 
                            	  4201: irq6_rout:
02:000074E6 48E7C0C0        	  4202: 	movem.l	d0/d1/a0/a1,-(a7)
02:000074EA 41F804C0        	  4203: 	lea			InstalledIRQ+8*4*6,a0
                            	  4204: irq_rout:
02:000074EE 7007            	  4205: 	moveq		#7,d0
                            	  4206: .nextHandler:
02:000074F0 2258            	  4207: 	move.l	(a0)+,a1
02:000074F2 6706            	  4208: 	beq.s		.0003
02:000074F4 4E91            	  4209: 	jsr			(a1)
02:000074F6 4A81            	  4210: 	tst.l		d1								; was IRQ handled?
02:000074F8 6B04            	  4211: 	bmi.s		.0002							; first one to return handled quits loop
                            	  4212: .0003:
02:000074FA 51C8FFF4        	  4213: 	dbra		d0,.nextHandler
                            	  4214: .0002:
02:000074FE 4CDF0303        	  4215: 	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  4216: 
                            	  4217: SpuriousIRQ:
02:00007502 4E73            	  4218: 	rte
                            	  4219: 
                            	  4220: ;	bsr			KeybdIRQ
                            	  4221: ;	tst.l		d1								; handled by KeybdIRQ?
                            	  4222: ;	bmi.s		.0002							; if yes, go return
                            	  4223: ;.0001:
                            	  4224: ;	move.l	#$1D000000,PLIC+$14	; reset edge sense circuit
                            	  4225: ;	move.l	TextScr,a0				; a0 = screen address
                            	  4226: ;	addi.l	#1,40(a0)					; update onscreen IRQ flag
                            	  4227: ;.0002:	
                            	  4228: ;	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  4229: ;	rte
                            	  4230: 
                            	  4231: nmi_rout:
02:00007504 48E7C080        	  4232: 	movem.l	d0/d1/a0,-(a7)
02:00007508 123C004E        	  4233: 	move.b	#'N',d1
02:0000750C 6100DC6A        	  4234: 	bsr			DisplayChar
02:00007510 4CDF0103        	  4235: 	movem.l	(a7)+,d0/d1/a0		; return
02:00007514 4E73            	  4236: 	rte
                            	  4237: 
                            	  4238: brdisp_trap:
02:00007516 48F9FFFF00040100	  4239: 	movem.l	d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
02:0000751E 33DF00040140    	  4240: 	move.w	(a7)+,Regsave+$40
02:00007524 23DF00040144    	  4241: 	move.l	(a7)+,Regsave+$44
02:0000752A 2E7C00040FFC    	  4242: 	move.l	#$40FFC,a7			; reset stack pointer
02:00007530 46FC2500        	  4243: 	move.w	#$2500,sr				; enable interrupts
02:00007534 43FA008C        	  4244: 	lea			msg_bad_branch_disp,a1
02:00007538 6100DEB8        	  4245: 	bsr			DisplayString
02:0000753C 6100F64E        	  4246: 	bsr			DisplaySpace
02:00007540 223900040144    	  4247: 	move.l	Regsave+$44,d1	; exception address
02:00007546 6100F64C        	  4248: 	bsr			DisplayTetra		; and display it
                            	  4249: ;	move.l	(sp)+,d1				; pop format word 68010 mode only
02:0000754A 6000EFA2        	  4250: 	bra			cmdDumpRegs
                            	  4251: 
                            	  4252: illegal_trap:
02:0000754E 544F            	  4253: 	addq		#2,sp						; get rid of sr
02:00007550 221F            	  4254: 	move.l	(sp)+,d1				; pop exception address
02:00007552 6100F640        	  4255: 	bsr			DisplayTetra		; and display it
02:00007556 43FA0058        	  4256: 	lea			msg_illegal,a1	; followed by message
02:0000755A 6100DE96        	  4257: 	bsr			DisplayString
                            	  4258: .0001:
02:0000755E 60FE            	  4259: 	bra			.0001
02:00007560 6000E960        	  4260: 	bra			Monitor
                            	  4261: 	
                            	  4262: io_irq:
02:00007564 544F            	  4263: 	addq #2,sp
02:00007566 221F            	  4264: 	move.l (sp)+,d1
02:00007568 6100F62A        	  4265: 	bsr DisplayTetra
02:0000756C 43FA0076        	  4266: 	lea msg_io_access,a1
02:00007570 6100DE80        	  4267: 	bsr DisplayString
02:00007574 6000EF78        	  4268: 	bra cmdDumpRegs
                            	  4269: 
                            	  4270: ; -----------------------------------------------------------------------------
                            	  4271: ; -----------------------------------------------------------------------------
                            	  4272: 
                            	  4273: msg_start:
02:00007578 46656D74696B6920	  4274: 	dc.b	"Femtiki rf68k Multi-core OS Starting",LF,CR,0
02:00007580 726636386B204D75
02:00007588 6C74692D636F7265
02:00007590 204F532053746172
02:00007598 74696E67
02:0000759C 0A
02:0000759D 0D
02:0000759E 00
                            	  4275: ;	dc.b	"rf68k System Starting",CR,LF,0
                            	  4276: msg_core_start:
02:0000759F 20636F7265207374	  4277: 	dc.b	" core starting",CR,LF,0
02:000075A7 617274696E67
02:000075AD 0D
02:000075AE 0A
02:000075AF 00
                            	  4278: msg_illegal:
02:000075B0 20696C6C6567616C	  4279: 	dc.b	" illegal opcode",CR,LF,0
02:000075B8 206F70636F6465
02:000075BF 0D
02:000075C0 0A
02:000075C1 00
                            	  4280: msg_bad_branch_disp:
02:000075C2 206272616E636820	  4281: 	dc.b	" branch selfref: ",0
02:000075CA 73656C667265663A
02:000075D2 20
02:000075D3 00
                            	  4282: msg_test_done:
02:000075D4 2043505520746573	  4283: 	dc.b	" CPU test done.",0
02:000075DC 7420646F6E652E
02:000075E3 00
                            	  4284: msg_io_access
02:000075E4 20756E7065726D69	  4285: 	dc.b " unpermitted access to I/O",0
02:000075EC 7474656420616363
02:000075F4 65737320746F2049
02:000075FC 2F4F
02:000075FE 00
                            	  4286: msgChk
02:000075FF 20636865636B2066	  4287: 	dc.b " check failed",0
02:00007607 61696C6564
02:0000760C 00
                            	  4288: msgStackCanary
02:0000760D 20737461636B2063	  4289: 	dc.b " stack canary overwritten",0
02:00007615 616E617279206F76
02:0000761D 6572777269747465
02:00007625 6E
02:00007626 00
                            	  4290: 


Symbols by name:
ABCD_INNER1                     02:00002686
ABCD_INNER2                     02:000026F4
ABCD_NO_C1                      02:000026A2
ABCD_NO_C2                      02:000026AA
ABCD_NO_C3                      02:00002710
ABCD_NO_C4                      02:00002718
ABCD_OUTER1                     02:00002684
ABCD_OUTER2                     02:000026F2
ABS                             02:00004908
ACIA                             E:FD060000
ACIA_CMD                         E:00000008
ACIA_CTRL                        E:0000000C
ACIA_RX                          E:00000000
ACIA_STAT                        E:00000004
ACIA_TX                          E:00000000
ADDA_OUTER1                     02:000031F4
ADDQ_LOOP1                      02:00002A0E
ADDQ_LOOP2                      02:00002A4C
ADDQ_LOOP3                      02:00002A82
ADDX_LOOP3                      02:0000331A
ADDX_LOOP4                      02:00003336
ADDX_LOOP5                      02:00003352
ADDX_OUTER1                     02:00003286
ADD_OUTER1                      02:0000301A
ADD_OUTER2                      02:0000308E
AHOW                            02:000049C6
ALL_DONE                        02:000003F8
AND_OUTER1                      02:00002D38
AND_OUTER2                      02:00002DAC
ASORRY                          02:000049BE
AUXIN                           02:00004CF4
AUXOUT                          02:00004CE4
AWHAT                           02:0000497E
AXIRET                          02:00004D12
ArmAllBreakpoints               02:0000726E
ArmBreakpoint                   02:0000729E
AsciiToHexNybble                02:00006B40
AudioInputTest                  02:00006EA8
BCC1                            02:0000292C
BCC10                           02:0000297E
BCC11                           02:00002986
BCC12                           02:00002990
BCC13                           02:00002998
BCC14                           02:000029A2
BCC2                            02:00002936
BCC3                            02:0000293E
BCC4                            02:00002948
BCC5                            02:00002950
BCC6                            02:0000295A
BCC7                            02:00002962
BCC8                            02:0000296C
BCC9                            02:00002974
BSR_CLOSE1                      02:000014CC
BSR_CLOSE2                      02:00001502
BSR_FAR1                        02:000003FA
BSR_FAR2                        02:0000291C
BUFFER                          02:00004DC0
BUFLEN                           E:00000050
BYEBYE                          02:00004D14
BlankLastLine                   02:0000538E
BouncingBalls                   02:00006EAA
BreakpointWords                  E:00040280
Breakpoints                      E:00040220
CALL                            02:00004644
CHKIO                           02:00004C8A
CHKRET                          02:00004C9A
CLMSG                           02:00004D6A
CMPA_OUTER1                     02:00002F0E
CMPM_LOOP1                      02:00002F9C
CMPM_LOOP2                      02:00002FB6
CMPM_LOOP3                      02:00002FD0
CMP_OUTER1                      02:00002E98
CORENO                          02:0000492A
CR                               E:0000000D
CRLF                            02:0000512E
CSTART                          02:00003E78
CTRLC                            E:00000003
CTRLH                            E:00000008
CTRLS                            E:00000013
CTRLX                            E:00000018
CTRLZ                            E:0000001A
CURRNT                          02:00004D7C
CalcScreenLoc                   02:0000516A
CallOS                          02:00004E56
CheckForCtrlC                   02:000057F6
CheckForKey                     02:000057B2
ClearBreakpointList             02:00007390
ClearScreen                     02:00006EAE
CmdBuf                           E:00040040
CmdBufEnd                        E:00040080
Cursor1                         02:00005534
CursorCol                        E:00040001
CursorRow                        E:00040000
DBCC_LOOP1                      02:000029AC
DBCC_LOOP2                      02:000029BA
DEFLT                           02:000044D8
DIRECT                          02:000040E4
DIV1                            02:00004870
DIV2                            02:00004876
DIV3                            02:0000487C
DIV32                           02:0000485E
DIV4                            02:0000488A
DIVRT                           02:00004898
DIVS_OUTER1                     02:00002BF8
DIVU_OUTER1                     02:00002BA6
DOQUO                           02:00004C68
DOQUO1                          02:00004C70
Delay3s                         02:000002D6
Delay3s2                        02:000002FA
DisarmAllBreakpoints            02:00007242
DisarmBreakpoint                02:0000731C
DispatchMsg                     02:00007422
DisplayAddr                     02:00006BC0
DisplayByte                     02:00006BA0
DisplayChar                     02:00005178
DisplayHelp                     02:000060EA
DisplayMem                      02:00006492
DisplayNybble                   02:00006BA6
DisplaySpace                    02:00006B8C
DisplayString                   02:000053F2
DisplayStringCRLF               02:00005408
DisplayStringLimited            02:0000540E
DisplayStringLimitedCRLF        02:0000542E
DisplayTetra                    02:00006B94
DisplayTwoSpaces                02:00006B7A
DisplayWyde                     02:00006B9A
DumpMem1                        02:00006480
ENDCHK                          02:0000496A
ENDCHK1                         02:0000497A
ENDMEM                          02:00003E74
EOR_OUTER2                      02:00002E22
ERROR                           02:00004982
EX1                             02:00004116
EXCEPTION_6                     02:00000402
EXCEPTION_7                     02:0000040A
EXEC                            02:000040EC
EXGO                            02:00004122
EXLP                            02:000040F4
EXMAT                           02:0000411C
EXNGO                           02:000040FE
EXP4RT                          02:000047C0
EXPR                            02:0000465E
EXPR2                           02:0000473A
EXPR3                           02:00004778
EXPR4                           02:000047AA
EXPR_AND                        02:00004686
EXPR_OR                         02:0000465E
EXPR_REL                        02:000046B4
ExecuteCode                     02:00006452
FI1                             02:0000495C
FI2                             02:00004968
FIN                             02:00004950
FINISH                          02:000042EE
FNDLN                           02:00004A6A
FNDLNP                          02:00004A78
FNDNXT                          02:00004A90
FNDRET                          02:00004A8E
FNDSKP                          02:00004A92
FOR                             02:0000435C
FR1                             02:00004376
FR2                             02:0000438E
FR3                             02:00004394
FR4                             02:0000439A
FR5                             02:000043A2
FR6                             02:000043B4
FR7                             02:000043B8
FR8                             02:000043D2
FemtikiInit                     02:00004E10
FemtikiInitIRQ                  02:00004E46
FemtikiTimerIRQ                 02:0000503A
ForceUnlockSemaphore            02:00000262
FromScreen                      02:00005EAE
GBYTE                           02:0000452E
GBYTE1                          02:00004532
GBYTE2                          02:00004540
GETLN                           02:000049CC
GL1                             02:000049DC
GL2                             02:000049FA
GL3                             02:00004A0E
GL4                             02:00004A32
GL5                             02:00004A3E
GL6                             02:00004A5A
GL7                             02:00004A62
GOAUXI                          02:00003E68
GOAUXO                          02:00003E64
GOBYE                           02:00003E6C
GOIN                            02:00003E60
GOOUT                           02:00003E5C
GOSUB                           02:000042F6
GOTO                            02:00004204
GOWARM                          02:00003E5A
GetCmdLine                      02:0000626C
GetDecNumber                    02:000065E6
GetHexNumber                    02:000065B8
GetKey                          02:000057BE
GetRunningTCBPointer            02:00004EC0
GraphicsDemo                    02:00006EAC
HAS_MMU                          E:00000000
HOWMSG                          02:00004D55
HelpMsg                         02:000060F6
HomeCursor                      02:00005434
I2C2                             E:FD069000
I2C_CMD                          E:00000004
I2C_CTRL                         E:00000002
I2C_PREH                         E:00000001
I2C_PREL                         E:00000000
I2C_RXR                          E:00000003
I2C_STAT                         E:00000004
I2C_TXR                          E:00000003
IF                              02:0000443E
IF1                             02:00004442
IF2                             02:0000444A
IGNBLK                          02:00004C36
INC                             02:00004CC4
INC1                            02:00004CD0
INCOM                           02:00004134
INCON                           02:00004126
INITMSG                         02:00004D22
INPERR                          02:0000445A
INPPTR                          02:00004D74
INPUT                           02:00004468
IOCOM                           02:00004142
IOCON                           02:0000415A
IOFocus                          E:00100000
IP2                             02:0000447A
IP3                             02:00004494
IP4                             02:000044CA
IP5                             02:000044D4
IRQFlag                          E:000400A0
IRQROUT                         02:00004DB0
IncCursorPos                    02:000052F0
IncCursorRow                    02:00005310
InitIOPBitmap                   02:00000126
InitIRQ                         02:0000744A
InitRand                        02:00000176
InitSemaphores                  02:0000021A
InsertIntoReadyQueue            02:00004F2C
InstallIRQ                      02:0000745E
InstalledIRQ                     A:00000400
KEYBD                            E:FD0FFE00
KEYBD_SEMA                       E:00000003
KeybdEcho                        E:0004000C
KeybdGetChar                    02:00005812
KeybdGetCharNoWait              02:00005802
KeybdGetCharWait                02:0000580A
KeybdGetID                      02:000055E0
KeybdID                          E:00100016
KeybdIRQ                        02:00005ABA
KeybdInit                       02:0000564A
KeybdLEDs                        E:0010000E
KeybdRecvByte                   02:00005764
KeybdSendByte                   02:00005A7A
KeybdSetLED                     02:0000561E
KeybdSetLEDStatus               02:00005A2A
KeybdWaitFlag                    E:0004000D
KeybdWaitTx                     02:00005784
LEA1                            02:00001ED8
LET                             02:000044DE
LF                               E:0000000A
LIST                            02:00004254
LOAD                            02:000044EE
LOD1                            02:000044FA
LOD2                            02:00004514
LODEND                          02:00004524
LOPINC                          02:00004D90
LOPLMT                          02:00004D9C
LOPLN                           02:00004DA8
LOPPT                           02:00004DAC
LOPVAR                          02:00004D8C
LS1                             02:00004260
LS2                             02:00004274
LS3                             02:0000427A
LSTROM                          02:00004D6E
LT1                             02:000044EA
ListBreakpoints                 02:00007370
LockSemaphore                   02:00000240
MAX_TID                          E:00000FFF
MEMORY_SEMA                      E:00000006
MMU                              E:FDC00000
MOVE1                           02:00001B46
MOVE2                           02:00001ACA
MOVE3                           02:00001BC6
MOVE4                           02:00001D20
MULS_OUTER1                     02:000034EE
MULU_OUTER1                     02:000034A2
MVDOWN                          02:00004AAA
MVRET                           02:00004AA8
MVUP                            02:00004AA0
Monitor                         02:00005EC2
NBCD_LOOP                       02:0000286C
NBCD_LOOP1                      02:000028B2
NBCD_NO_C                       02:00002878
NBCD_NO_C1                      02:000028C6
NBCD_NO_Z                       02:0000287C
NBCD_NO_Z1                      02:000028CA
NEW                             02:00004172
NEXT                            02:000043D6
NR_TCB                           E:00001000
NX0                             02:000043E0
NX1                             02:0000441C
NX2                             02:00004434
NX3                             02:000043F2
NextRec                         02:00006C9E
NumSetBreakpoints                E:00040202
OKMSG                           02:00004D4E
ONIRQ                           02:0000421C
ONIRQ1                          02:0000423A
OR_OUTER1                       02:00002C4E
OR_OUTER2                       02:00002CC2
OSCallTable                     02:00004E54
OUTC                            02:00004CA8
OUTC1                           02:00004CB4
OUTCOM                          02:0000414C
OUTCON                          02:00004164
OUTPTR                          02:00004D78
PARN                            02:000047CE
PBYTE                           02:000045AC
PBYTE1                          02:000045AE
PBYTE2                          02:000045C2
PEEK                            02:0000489A
PKER                            02:00004640
PLIC                             E:FD090000
POKE                            02:000045CC
POPA                            02:00004AB2
PP1                             02:00004AEC
PR0                             02:000042A0
PR1                             02:000042B0
PR2                             02:00004292
PR3                             02:000042CA
PR4                             02:000042C4
PR6                             02:000042D6
PR8                             02:000042DC
PRINT                           02:00004280
PRMESG                          02:00004C9C
PRMRET                          02:00004CA6
PRTLN                           02:00004BB8
PRTNUM                          02:00004B7A
PRTRET                          02:00004B3E
PRTSTG                          02:00004B24
PS1                             02:00004B26
PU1                             02:00004B20
PUSHA                           02:00004AEE
PointerToTCBHandle              02:00004EF6
PopReadyQueue                   02:00004F9A
ProcessBreakpoint               02:0000723C
ProcessRec                      02:00006CB0
ProcessS1                       02:00006DB2
ProcessS2                       02:00006DB6
ProcessS3                       02:00006DBA
ProcessS7                       02:00006DBE
ProcessS8                       02:00006DCE
ProcessS9                       02:00006DDE
Prompt1                         02:00005F00
Prompt3                         02:00005EEA
PromptLn                        02:00005EDE
QHOW                            02:000049C4
QSORRY                          02:000049BC
QT1                             02:00004B4A
QT2                             02:00004B5A
QT3                             02:00004B5E
QT4                             02:00004B68
QT5                             02:00004B78
QTSTG                           02:00004B40
QWHAT                           02:0000497C
QueueCycle                       E:0010031C
RAND_MW                          E:FD0FFD0C
RAND_MZ                          E:FD0FFD08
RAND_NUM                         E:FD0FFD00
RAND_SEMA                        E:00000004
RAND_STRM                        E:FD0FFD04
RANPNT                          02:00004D70
REM                             02:0000443C
RETURN                          02:00004332
RND                             02:000048EA
ROXx_FLAGS                      02:000037B6
ROXx_LOOP1                      02:000037CC
ROXx_LOOP2                      02:000037EC
ROXx_LOOP3                      02:0000380C
ROXx_LOOP4                      02:0000382C
ROXx_LOOP5                      02:0000384C
ROXx_LOOP6                      02:0000386E
ROx_FLAGS                       02:00003580
ROx_LOOP1                       02:00003596
ROx_LOOP2                       02:000035B6
ROx_LOOP3                       02:000035D6
ROx_LOOP4                       02:000035F6
ROx_LOOP5                       02:00003616
ROx_LOOP6                       02:00003638
RST_REG                          E:FD0FFC00
RTCBuf                           E:00100200
RTR_DONE                        02:0000290E
RUN                             02:00004186
RUN1                            02:000041DE
RUNNXL                          02:00004194
RUNSML                          02:000041F4
RUNTSL                          02:000041EA
RandGetNum                      02:000001B6
RandInit                        02:00000176
RandWait                        02:00000204
ReceiveMsg                      02:000073E0
Regsave                          E:00040100
RemoveFromReadyQueue            02:00004F7C
RunningTCB                       E:00100224
S1932a                          02:00006E26
S1932b                          02:00006E3A
S19Checksum                      E:00100150
S19Get16BitAddress              02:00006DEE
S19Get24BitAddress              02:00006DFC
S19Get32BitAddress              02:00006E08
S19StartAddress                  E:00040008
SAVE                            02:0000454E
SAVE1                           02:00004556
SAVE2                           02:0000457A
SAVEND                          02:00004588
SBCD_INNER1                     02:0000277E
SBCD_INNER2                     02:000027EC
SBCD_NO_C1                      02:0000279A
SBCD_NO_C2                      02:000027A2
SBCD_NO_C3                      02:00002808
SBCD_NO_C4                      02:00002810
SBCD_OUTER1                     02:0000277C
SBCD_OUTER2                     02:000027EA
SCREEN_SEMA                      E:00000005
SC_ALT                           E:00000011
SC_CAPSLOCK                      E:00000058
SC_CTRL                          E:00000014
SC_EXTEND                        E:000000E0
SC_KEYUP                         E:000000F0
SC_LSHIFT                        E:00000012
SC_NUMLOCK                       E:00000077
SC_RSHIFT                        E:00000059
SC_SCROLLLOCK                    E:0000007E
SC_TAB                           E:0000000D
SERIAL_SEMA                      E:00000002
SETVAL                          02:00004934
SHIFTS2_FLAGS                   02:00003C2E
SHIFTS2_LOOP1                   02:00003C44
SHIFTS2_LOOP2                   02:00003C60
SHIFTS2_LOOP3                   02:00003C7C
SHIFTS2_LOOP4                   02:00003C98
SHIFTS2_LOOP5                   02:00003CB4
SHIFTS2_LOOP6                   02:00003CD2
SHIFTS_FLAGS                    02:000039EC
SHIFTS_LOOP1                    02:00003A02
SHIFTS_LOOP2                    02:00003A22
SHIFTS_LOOP3                    02:00003A42
SHIFTS_LOOP4                    02:00003A62
SHIFTS_LOOP5                    02:00003A82
SHIFTS_LOOP6                    02:00003AA4
SIZE                            02:00004912
SRYMSG                          02:00004D64
ST3                             02:00003EF6
ST4                             02:00003F48
START                           02:00003E58
STKFP                           02:00004D80
STKGOS                          02:00004D84
STKINP                          02:00004D88
STKLMT                          02:00004DBC
STOP                            02:0000417E
SUBA_OUTER1                     02:00003240
SUBQ_LOOP1                      02:00002ACC
SUBQ_LOOP2                      02:00002B06
SUBQ_LOOP3                      02:00002B3C
SUBX_LOOP3                      02:0000342A
SUBX_LOOP4                      02:00003446
SUBX_LOOP5                      02:00003462
SUBX_OUTER1                     02:00003396
SUB_OUTER1                      02:00003104
SUB_OUTER2                      02:00003178
SV1                             02:0000494E
ScrollUp                        02:00005344
SelectThreadToRun               02:00004F06
SendMsg                         02:000073A2
SerHeadRcv                       E:00100162
SerRcvBuf                        E:00101000
SerRcvXoff                       E:00100165
SerRcvXon                        E:00100164
SerTailRcv                       E:00100160
SerialGetChar                   02:00006EEE
SerialIRQ                       02:00006FFC
SerialInit                      02:00006EBC
SerialPeekChar                  02:00006F66
SerialPeekCharDirect            02:00006F9E
SerialPutChar                   02:00006FB8
SerialRbo                       02:00006FD4
SerialRcvCount                  02:00006FDC
SetKeyboardEcho                 02:000057AA
SpuriousIRQ                     02:00007502
StartMon                        02:00005EB8
StartQ                          02:00004F92
StubRout                        02:0000556A
SyncCursor                      02:00005446
T15Abort                        02:000002B2
T15DispatchTable                02:00005488
T15GetFloat                     02:000002A4
T15LockSemaphore                02:00000298
T15UnlockSemaphore              02:0000029E
TAB1                            02:00003F82
TAB10                           02:0000401B
TAB10_1                         02:000040DC
TAB1_1                          02:00004020
TAB2                            02:00003FAE
TAB2_1                          02:0000404C
TAB4                            02:00003FEB
TAB4_1                          02:0000408C
TAB5                            02:00004004
TAB5_1                          02:000040A8
TAB6                            02:00004007
TAB6_1                          02:000040B0
TAB8                            02:0000400C
TAB8_1                          02:000040B8
TAB9                            02:00004017
TAB9_1                          02:000040D4
TC1                             02:00004BE8
TCBEndTick                       E:00000070
TCBHandleToPointer              02:00004EDE
TCBNext                          E:0000007C
TCBPC                            E:00000050
TCBPrev                          E:00000080
TCBPriority                      E:00000055
TCBRegs                          E:00000004
TCBSR                            E:0000004C
TCBSSP                           E:00000048
TCBStartTick                     E:0000006C
TCBStatus                        E:00000054
TCBTicks                         E:00000074
TCBUSP                           E:00000044
TCB_SEMA                         E:00000007
TCB_SIZE                         E:00000100
TEXTREG                          E:FD03FF00
TICK                            02:00004920
TOUPB1                          02:00004C46
TOUPBRT                         02:00004C66
TOUPBUF                         02:00004C40
TOUPPER                         02:00004C78
TOUPRET                         02:00004C88
TRAP15                          02:00005470
TSTC                            02:00004BD6
TSTNUM                          02:00004BEE
TSTV                            02:000047E4
TSTVRT                          02:0000485C
TS_PREEMPT                       E:00000020
TS_RUNNING                       E:00000080
TV1                             02:00004826
TV2                             02:00004854
TXT                             02:00004E10
TXTBGN                          02:00003E70
TXTUNF                          02:00004DB4
TextCols                         E:0004008D
TextCurpos                       E:00040002
TextPos                          E:00040002
TextRows                         E:0004008C
TextScr                          E:00040004
TickIRQ                         02:0000748E
TimerStack                       E:00040BFC
UnlockSemaphore                 02:0000027C
UpdateIRQLive                   02:00005018
UpdateTextPos                   02:00005140
VARBGN                          02:00004DB8
WAITIRQ                         02:00004244
WHTMSG                          02:00004D5C
WSTART                          02:00003EC6
Wait10ms                        02:00005A82
Wait300ms                       02:00005A9E
XOFF                             E:00000013
XON                              E:00000011
XP11                            02:000046C8
XP12                            02:000046D4
XP13                            02:000046E0
XP14                            02:000046EC
XP15                            02:000046F8
XP15RT                          02:00004704
XP16                            02:00004706
XP16RT                          02:00004712
XP17                            02:00004724
XP18                            02:0000472A
XP21                            02:00004748
XP22                            02:0000474E
XP23                            02:00004750
XP24                            02:0000475C
XP25                            02:00004766
XP26                            02:0000476C
XP31                            02:0000477A
XP34                            02:00004790
XP40                            02:000047B6
XP41                            02:000047C2
XP42                            02:000047DE
XP43                            02:000047E0
XPRT0                           02:00004714
XPRT1                           02:0000471C
XP_AND                          02:00004698
XP_ANDX                         02:000046AE
XP_OR                           02:00004670
XP_ORX                          02:000046AE
_CheckNan                       02:0000664C
_CheckNegative                  02:000066CA
_CheckZero                      02:000066B0
_ComputeDigitsBeforeDecpt       02:00006724
_E                               E:0004050C
_ExtExpDigit                    02:00006848
_ExtExpDigits                   02:00006866
_FloatToString                  02:00006910
_GetExponent                    02:000069C8
_GetFloat                       02:00006AC8
_GetFloatBackupChar             02:00006960
_GetFloatGetChar                02:00006952
_GetFloatIgnBlanks              02:00006958
_GetFraction                    02:00006964
_GetInteger                     02:00006A52
_GetRand                        02:000001E6
_KeyState1                       E:0010000F
_KeyState2                       E:00100010
_KeybdBuf                        E:00100020
_KeybdCnt                        E:00100013
_KeybdGetScancode               02:00005754
_KeybdGetStatus                 02:0000574A
_KeybdHead                       E:00100011
_KeybdInit                      02:0000564A
_KeybdTail                       E:00100012
_LeadingZero                    02:0000675E
_LessThanDbl                    02:000066F8
_MakeBig                        02:000066DC
_PadLeft                        02:0000688E
_PadRight                       02:000068DE
_SpitOutDigits                  02:0000676E
_SpitOutE                       02:00006830
_TrimDotZero                    02:00006808
_TrimTrailingPoint              02:000067EA
_TrimTrailingZeros              02:00006824
_canary                          E:00040098
_dfMil                          02:00006638
_dfOne                          02:00006620
_dfTen                          02:0000662C
_digits_before_decpt             E:00040510
_fpBuf                           E:00040520
_fpTextIncr                      E:00040094
_fpWork                          E:00040600
_keybdControlCodes              02:00005D4C
_keybdExtendedCodes             02:00005DCC
_msgInf                         02:00006648
_msgNan                         02:00006644
_precision                       E:00040514
_shiftedScanCodes               02:00005C4C
_unshiftedScanCodes             02:00005B4C
_width                           E:00040508
bkColor                          E:00040088
brdisp_trap                     02:00007516
bus_err                         02:000071FA
chk_exception                   02:000002C2
clear_screen                    02:000050DE
cmdBreakpoint                   02:00005F58
cmdClearScreen                  02:00005F90
cmdClock                        02:0000607A
cmdCore                         02:00005F9C
cmdDispatch                     02:00005F12
cmdDumpMemory                   02:00006460
cmdDumpRegs                     02:000064EE
cmdEditMemory                   02:000063F2
cmdFillB                        02:00006374
cmdFillL                        02:000063BC
cmdFillW                        02:00006398
cmdHelp                         02:000060EA
cmdJump                         02:00006452
cmdLoadS19                      02:00006C98
cmdMonitor                      02:00005EC2
cmdReceiveSerial                02:00006340
cmdReset                        02:00006098
cmdSendSerial                   02:00006310
cmdString                       02:00005E4C
cmdTable                        02:00005E80
cmdTestCPU                      02:00005F80
cmdTestFP                       02:00005FC0
cmdTestGF                       02:0000604C
cmdTestRAM                      02:00006BDE
cmdTestSerialReceive            02:00006598
cmdTinyBasic                    02:00005F7C
cpu_test                        02:00000316
dccr                            02:000051A0
dclf                            02:00005270
dcx10                           02:00005208
dcx11                           02:0000522A
dcx12                           02:00005220
dcx14                           02:00005196
dcx16                           02:00005274
dcx4                            02:00005278
dcx6                            02:000051BE
dcx7                            02:0000519A
dcx8                            02:000051D4
dcx9                            02:000051EA
dly3s1                          02:000002E6
dly3s2                          02:000002E4
doBackspace                     02:00005282
doCtrlX                         02:000052CC
doDelete                        02:00005290
do_nothing                      02:00000120
dspj1                           02:000053F6
dspmem1                         02:000064A2
dspspc1                         02:00006B84
dsret                           02:00005402
edtmem1                         02:000063FA
fgColor                          E:00040084
fpBuf                            E:000402C0
get_screen_address              02:000050D6
get_screen_color                02:000050AA
gthx3                           02:00006B76
gthx5                           02:00006B52
gthx6                           02:00006B64
i2c_setup                       02:0000708C
i2c_wait_rx_nack                02:000070DA
i2c_wait_tip                    02:0000709C
i2c_wr_cmd                      02:000070AC
i2c_xmit1                       02:000070BC
icc1                            02:00005342
ignBlanks                       02:000063E0
illegal_trap                    02:0000754E
init_i2c                        02:0000708C
init_plic                       02:000055AA
io_irq                          02:00007564
irq3_rout                       02:000074DC
irq6_rout                       02:000074E6
irq_rout                        02:000074EE
kbdi0002                        02:00005672
kbdi0004                        02:000056DE
kbdi0005                        02:000056F8
kbdiTryAgain                    02:000056D0
kbdiXmitBusy                    02:00005712
kgid1                           02:00005612
kgnotKbd                        02:0000561A
leds                             E:FD0FFF00
ledxit                          02:000056FC
loop1                           02:000000F2
loop2                           02:000000F0
loop3                           02:00005114
memend                           E:00100004
msgBadKeybd                     02:00005720
msgChk                          02:000075FF
msgHello                        02:0000625A
msgRtcReadFail                  02:000071E0
msgStackCanary                  02:0000760D
msgUnknownCmd                   02:0000624A
msgXmitBusy                     02:0000572F
msg_bad_branch_disp             02:000075C2
msg_core_start                  02:0000759F
msg_illegal                     02:000075B0
msg_io_access                   02:000075E4
msg_reglist                     02:00006572
msg_regs                        02:0000656E
msg_start                       02:00007578
msg_test_done                   02:000075D4
nmeSerial                       02:00007084
nmi_rout                        02:00007504
notRxInt                        02:00007072
numBreakpoints                   E:00000008
op_ABCD                         02:00002664
op_ADD                          02:00002FFA
op_ADDA                         02:000031CE
op_ADDQ                         02:000029FA
op_ADDX                         02:00003266
op_ADD_I                        02:000016F2
op_AND                          02:00002D18
op_ANDI_TO_CCR                  02:000004A2
op_ANDI_TO_SR                   02:000004C8
op_BCC                          02:00002924
op_BCHG                         02:00000898
op_BCLR                         02:00000C00
op_BOOL_I                       02:00001322
op_BSET                         02:00000F4E
op_BSR                          02:000014D4
op_BTST                         02:000004EE
op_BTST0                        02:00000678
op_BTST1                        02:00000684
op_BTST10                       02:000006CC
op_BTST11                       02:000006D4
op_BTST12                       02:000006DA
op_BTST2                        02:0000068C
op_BTST20                       02:00000832
op_BTST21                       02:0000083C
op_BTST22                       02:00000842
op_BTST23                       02:00000848
op_BTST24                       02:0000084E
op_BTST25                       02:00000854
op_BTST26                       02:0000085A
op_BTST27                       02:00000860
op_BTST28                       02:00000866
op_BTST29                       02:0000086C
op_BTST3                        02:00000694
op_BTST30                       02:00000872
op_BTST31                       02:00000878
op_BTST32                       02:0000087C
op_BTST4                        02:0000069C
op_BTST5                        02:000006A4
op_BTST6                        02:000006AC
op_BTST7                        02:000006B4
op_BTST8                        02:000006BC
op_BTST9                        02:000006C4
op_CHK                          02:00001F7E
op_CMP                          02:00002E78
op_CMPA                         02:00002EEE
op_CMPM                         02:00002F54
op_CMP_I                        02:0000150A
op_DBCC                         02:000029A4
op_DIVS                         02:00002BDC
op_DIVU                         02:00002B8A
op_EOR                          02:00002E02
op_EORI_TO_CCR                  02:00000456
op_EORI_TO_SR                   02:0000047C
op_EXG                          02:0000351E
op_EXT                          02:00001DFE
op_LEAPEA                       02:00001E40
op_LINKS                        02:00001F50
op_MOVE                         02:000019FE
op_MOVEM                        02:00002346
op_MOVEP                        02:00001296
op_MOVEQ                        02:00002B6E
op_MOVE_USP                     02:00001F6E
op_MOVE_xxx_FLAGS               02:00001C0A
op_MULS                         02:000034D2
op_MULU                         02:00003486
op_NBCD                         02:00002854
op_NEGS                         02:00001FB8
op_OR                           02:00002C2E
op_ORI_TO_CCR                   02:00000412
op_ORI_TO_SR                    02:00000434
op_ROXx                         02:000037C2
op_ROx                          02:0000358C
op_RTR                          02:00002902
op_SBCD                         02:0000275C
op_SCC                          02:000029CA
op_SHIFTS                       02:000039F8
op_SHIFTS2                      02:00003C3A
op_SUB                          02:000030E4
op_SUBA                         02:0000321A
op_SUBQ                         02:00002AB4
op_SUBX                         02:00003376
op_SUB_I                        02:00001878
op_SWAP                         02:00001E2A
op_TAS                          02:00001EEC
op_TRAPV                        02:000028E6
op_TST                          02:00001F12
pcssxa                          02:00006D46
prtflt                          02:00007424
ramtest                         02:00006BDE
ramtest0                        02:00006C20
ramtest1                        02:00006C28
ramtest2                        02:00006C54
ramtest3                        02:00006C96
ramtest6                        02:00006C44
rbo                             02:00006EB4
readyQ                           E:00100320
rmtst1                          02:00006C38
rmtst2                          02:00006C6A
rmtst3                          02:00006C72
rmtst5                          02:00006BF8
rotate_iofocus                  02:0000557E
rtc_read                        02:000070EA
rtc_write                       02:00007176
sGetChar                        02:00006E7C
select_focus1                   02:00005590
select_iofocus                  02:0000556C
semamem                          E:FD050000
sirq0001                        02:00007022
sirqNxtByte                     02:00007010
sirqRxFull                      02:00007072
start                           02:00000000
start_other                     02:00000104
tblPow2                         02:000060CA
tcbs                             E:20010000
trap3                           02:000071FE

Symbols by value:
FD03FF00 TEXTREG
FD050000 semamem
FD060000 ACIA
FD069000 I2C2
FD090000 PLIC
FD0FFC00 RST_REG
FD0FFD00 RAND_NUM
FD0FFD04 RAND_STRM
FD0FFD08 RAND_MZ
FD0FFD0C RAND_MW
FD0FFE00 KEYBD
FD0FFF00 leds
FDC00000 MMU
00000000 ACIA_TX
00000000 I2C_PREL
00000000 HAS_MMU
00000000 start
00000000 ACIA_RX
00000001 I2C_PREH
00000002 SERIAL_SEMA
00000002 I2C_CTRL
00000003 CTRLC
00000003 KEYBD_SEMA
00000003 I2C_TXR
00000003 I2C_RXR
00000004 TCBRegs
00000004 RAND_SEMA
00000004 ACIA_STAT
00000004 I2C_STAT
00000004 I2C_CMD
00000005 SCREEN_SEMA
00000006 MEMORY_SEMA
00000007 TCB_SEMA
00000008 CTRLH
00000008 numBreakpoints
00000008 ACIA_CMD
0000000A LF
0000000C ACIA_CTRL
0000000D CR
0000000D SC_TAB
00000011 XON
00000011 SC_ALT
00000012 SC_LSHIFT
00000013 CTRLS
00000013 XOFF
00000014 SC_CTRL
00000018 CTRLX
0000001A CTRLZ
00000020 TS_PREEMPT
00000044 TCBUSP
00000048 TCBSSP
0000004C TCBSR
00000050 TCBPC
00000050 BUFLEN
00000054 TCBStatus
00000055 TCBPriority
00000058 SC_CAPSLOCK
00000059 SC_RSHIFT
0000006C TCBStartTick
00000070 TCBEndTick
00000074 TCBTicks
00000077 SC_NUMLOCK
0000007C TCBNext
0000007E SC_SCROLLLOCK
00000080 TCBPrev
00000080 TS_RUNNING
000000E0 SC_EXTEND
000000F0 loop2
000000F0 SC_KEYUP
000000F2 loop1
00000100 TCB_SIZE
00000104 start_other
00000120 do_nothing
00000126 InitIOPBitmap
00000176 InitRand
00000176 RandInit
000001B6 RandGetNum
000001E6 _GetRand
00000204 RandWait
0000021A InitSemaphores
00000240 LockSemaphore
00000262 ForceUnlockSemaphore
0000027C UnlockSemaphore
00000298 T15LockSemaphore
0000029E T15UnlockSemaphore
000002A4 T15GetFloat
000002B2 T15Abort
000002C2 chk_exception
000002D6 Delay3s
000002E4 dly3s2
000002E6 dly3s1
000002FA Delay3s2
00000316 cpu_test
000003F8 ALL_DONE
000003FA BSR_FAR1
00000400 InstalledIRQ
00000402 EXCEPTION_6
0000040A EXCEPTION_7
00000412 op_ORI_TO_CCR
00000434 op_ORI_TO_SR
00000456 op_EORI_TO_CCR
0000047C op_EORI_TO_SR
000004A2 op_ANDI_TO_CCR
000004C8 op_ANDI_TO_SR
000004EE op_BTST
00000678 op_BTST0
00000684 op_BTST1
0000068C op_BTST2
00000694 op_BTST3
0000069C op_BTST4
000006A4 op_BTST5
000006AC op_BTST6
000006B4 op_BTST7
000006BC op_BTST8
000006C4 op_BTST9
000006CC op_BTST10
000006D4 op_BTST11
000006DA op_BTST12
00000832 op_BTST20
0000083C op_BTST21
00000842 op_BTST22
00000848 op_BTST23
0000084E op_BTST24
00000854 op_BTST25
0000085A op_BTST26
00000860 op_BTST27
00000866 op_BTST28
0000086C op_BTST29
00000872 op_BTST30
00000878 op_BTST31
0000087C op_BTST32
00000898 op_BCHG
00000C00 op_BCLR
00000F4E op_BSET
00000FFF MAX_TID
00001000 NR_TCB
00001296 op_MOVEP
00001322 op_BOOL_I
000014CC BSR_CLOSE1
000014D4 op_BSR
00001502 BSR_CLOSE2
0000150A op_CMP_I
000016F2 op_ADD_I
00001878 op_SUB_I
000019FE op_MOVE
00001ACA MOVE2
00001B46 MOVE1
00001BC6 MOVE3
00001C0A op_MOVE_xxx_FLAGS
00001D20 MOVE4
00001DFE op_EXT
00001E2A op_SWAP
00001E40 op_LEAPEA
00001ED8 LEA1
00001EEC op_TAS
00001F12 op_TST
00001F50 op_LINKS
00001F6E op_MOVE_USP
00001F7E op_CHK
00001FB8 op_NEGS
00002346 op_MOVEM
00002664 op_ABCD
00002684 ABCD_OUTER1
00002686 ABCD_INNER1
000026A2 ABCD_NO_C1
000026AA ABCD_NO_C2
000026F2 ABCD_OUTER2
000026F4 ABCD_INNER2
00002710 ABCD_NO_C3
00002718 ABCD_NO_C4
0000275C op_SBCD
0000277C SBCD_OUTER1
0000277E SBCD_INNER1
0000279A SBCD_NO_C1
000027A2 SBCD_NO_C2
000027EA SBCD_OUTER2
000027EC SBCD_INNER2
00002808 SBCD_NO_C3
00002810 SBCD_NO_C4
00002854 op_NBCD
0000286C NBCD_LOOP
00002878 NBCD_NO_C
0000287C NBCD_NO_Z
000028B2 NBCD_LOOP1
000028C6 NBCD_NO_C1
000028CA NBCD_NO_Z1
000028E6 op_TRAPV
00002902 op_RTR
0000290E RTR_DONE
0000291C BSR_FAR2
00002924 op_BCC
0000292C BCC1
00002936 BCC2
0000293E BCC3
00002948 BCC4
00002950 BCC5
0000295A BCC6
00002962 BCC7
0000296C BCC8
00002974 BCC9
0000297E BCC10
00002986 BCC11
00002990 BCC12
00002998 BCC13
000029A2 BCC14
000029A4 op_DBCC
000029AC DBCC_LOOP1
000029BA DBCC_LOOP2
000029CA op_SCC
000029FA op_ADDQ
00002A0E ADDQ_LOOP1
00002A4C ADDQ_LOOP2
00002A82 ADDQ_LOOP3
00002AB4 op_SUBQ
00002ACC SUBQ_LOOP1
00002B06 SUBQ_LOOP2
00002B3C SUBQ_LOOP3
00002B6E op_MOVEQ
00002B8A op_DIVU
00002BA6 DIVU_OUTER1
00002BDC op_DIVS
00002BF8 DIVS_OUTER1
00002C2E op_OR
00002C4E OR_OUTER1
00002CC2 OR_OUTER2
00002D18 op_AND
00002D38 AND_OUTER1
00002DAC AND_OUTER2
00002E02 op_EOR
00002E22 EOR_OUTER2
00002E78 op_CMP
00002E98 CMP_OUTER1
00002EEE op_CMPA
00002F0E CMPA_OUTER1
00002F54 op_CMPM
00002F9C CMPM_LOOP1
00002FB6 CMPM_LOOP2
00002FD0 CMPM_LOOP3
00002FFA op_ADD
0000301A ADD_OUTER1
0000308E ADD_OUTER2
000030E4 op_SUB
00003104 SUB_OUTER1
00003178 SUB_OUTER2
000031CE op_ADDA
000031F4 ADDA_OUTER1
0000321A op_SUBA
00003240 SUBA_OUTER1
00003266 op_ADDX
00003286 ADDX_OUTER1
0000331A ADDX_LOOP3
00003336 ADDX_LOOP4
00003352 ADDX_LOOP5
00003376 op_SUBX
00003396 SUBX_OUTER1
0000342A SUBX_LOOP3
00003446 SUBX_LOOP4
00003462 SUBX_LOOP5
00003486 op_MULU
000034A2 MULU_OUTER1
000034D2 op_MULS
000034EE MULS_OUTER1
0000351E op_EXG
00003580 ROx_FLAGS
0000358C op_ROx
00003596 ROx_LOOP1
000035B6 ROx_LOOP2
000035D6 ROx_LOOP3
000035F6 ROx_LOOP4
00003616 ROx_LOOP5
00003638 ROx_LOOP6
000037B6 ROXx_FLAGS
000037C2 op_ROXx
000037CC ROXx_LOOP1
000037EC ROXx_LOOP2
0000380C ROXx_LOOP3
0000382C ROXx_LOOP4
0000384C ROXx_LOOP5
0000386E ROXx_LOOP6
000039EC SHIFTS_FLAGS
000039F8 op_SHIFTS
00003A02 SHIFTS_LOOP1
00003A22 SHIFTS_LOOP2
00003A42 SHIFTS_LOOP3
00003A62 SHIFTS_LOOP4
00003A82 SHIFTS_LOOP5
00003AA4 SHIFTS_LOOP6
00003C2E SHIFTS2_FLAGS
00003C3A op_SHIFTS2
00003C44 SHIFTS2_LOOP1
00003C60 SHIFTS2_LOOP2
00003C7C SHIFTS2_LOOP3
00003C98 SHIFTS2_LOOP4
00003CB4 SHIFTS2_LOOP5
00003CD2 SHIFTS2_LOOP6
00003E58 START
00003E5A GOWARM
00003E5C GOOUT
00003E60 GOIN
00003E64 GOAUXO
00003E68 GOAUXI
00003E6C GOBYE
00003E70 TXTBGN
00003E74 ENDMEM
00003E78 CSTART
00003EC6 WSTART
00003EF6 ST3
00003F48 ST4
00003F82 TAB1
00003FAE TAB2
00003FEB TAB4
00004004 TAB5
00004007 TAB6
0000400C TAB8
00004017 TAB9
0000401B TAB10
00004020 TAB1_1
0000404C TAB2_1
0000408C TAB4_1
000040A8 TAB5_1
000040B0 TAB6_1
000040B8 TAB8_1
000040D4 TAB9_1
000040DC TAB10_1
000040E4 DIRECT
000040EC EXEC
000040F4 EXLP
000040FE EXNGO
00004116 EX1
0000411C EXMAT
00004122 EXGO
00004126 INCON
00004134 INCOM
00004142 IOCOM
0000414C OUTCOM
0000415A IOCON
00004164 OUTCON
00004172 NEW
0000417E STOP
00004186 RUN
00004194 RUNNXL
000041DE RUN1
000041EA RUNTSL
000041F4 RUNSML
00004204 GOTO
0000421C ONIRQ
0000423A ONIRQ1
00004244 WAITIRQ
00004254 LIST
00004260 LS1
00004274 LS2
0000427A LS3
00004280 PRINT
00004292 PR2
000042A0 PR0
000042B0 PR1
000042C4 PR4
000042CA PR3
000042D6 PR6
000042DC PR8
000042EE FINISH
000042F6 GOSUB
00004332 RETURN
0000435C FOR
00004376 FR1
0000438E FR2
00004394 FR3
0000439A FR4
000043A2 FR5
000043B4 FR6
000043B8 FR7
000043D2 FR8
000043D6 NEXT
000043E0 NX0
000043F2 NX3
0000441C NX1
00004434 NX2
0000443C REM
0000443E IF
00004442 IF1
0000444A IF2
0000445A INPERR
00004468 INPUT
0000447A IP2
00004494 IP3
000044CA IP4
000044D4 IP5
000044D8 DEFLT
000044DE LET
000044EA LT1
000044EE LOAD
000044FA LOD1
00004514 LOD2
00004524 LODEND
0000452E GBYTE
00004532 GBYTE1
00004540 GBYTE2
0000454E SAVE
00004556 SAVE1
0000457A SAVE2
00004588 SAVEND
000045AC PBYTE
000045AE PBYTE1
000045C2 PBYTE2
000045CC POKE
00004640 PKER
00004644 CALL
0000465E EXPR
0000465E EXPR_OR
00004670 XP_OR
00004686 EXPR_AND
00004698 XP_AND
000046AE XP_ANDX
000046AE XP_ORX
000046B4 EXPR_REL
000046C8 XP11
000046D4 XP12
000046E0 XP13
000046EC XP14
000046F8 XP15
00004704 XP15RT
00004706 XP16
00004712 XP16RT
00004714 XPRT0
0000471C XPRT1
00004724 XP17
0000472A XP18
0000473A EXPR2
00004748 XP21
0000474E XP22
00004750 XP23
0000475C XP24
00004766 XP25
0000476C XP26
00004778 EXPR3
0000477A XP31
00004790 XP34
000047AA EXPR4
000047B6 XP40
000047C0 EXP4RT
000047C2 XP41
000047CE PARN
000047DE XP42
000047E0 XP43
000047E4 TSTV
00004826 TV1
00004854 TV2
0000485C TSTVRT
0000485E DIV32
00004870 DIV1
00004876 DIV2
0000487C DIV3
0000488A DIV4
00004898 DIVRT
0000489A PEEK
000048EA RND
00004908 ABS
00004912 SIZE
00004920 TICK
0000492A CORENO
00004934 SETVAL
0000494E SV1
00004950 FIN
0000495C FI1
00004968 FI2
0000496A ENDCHK
0000497A ENDCHK1
0000497C QWHAT
0000497E AWHAT
00004982 ERROR
000049BC QSORRY
000049BE ASORRY
000049C4 QHOW
000049C6 AHOW
000049CC GETLN
000049DC GL1
000049FA GL2
00004A0E GL3
00004A32 GL4
00004A3E GL5
00004A5A GL6
00004A62 GL7
00004A6A FNDLN
00004A78 FNDLNP
00004A8E FNDRET
00004A90 FNDNXT
00004A92 FNDSKP
00004AA0 MVUP
00004AA8 MVRET
00004AAA MVDOWN
00004AB2 POPA
00004AEC PP1
00004AEE PUSHA
00004B20 PU1
00004B24 PRTSTG
00004B26 PS1
00004B3E PRTRET
00004B40 QTSTG
00004B4A QT1
00004B5A QT2
00004B5E QT3
00004B68 QT4
00004B78 QT5
00004B7A PRTNUM
00004BB8 PRTLN
00004BD6 TSTC
00004BE8 TC1
00004BEE TSTNUM
00004C36 IGNBLK
00004C40 TOUPBUF
00004C46 TOUPB1
00004C66 TOUPBRT
00004C68 DOQUO
00004C70 DOQUO1
00004C78 TOUPPER
00004C88 TOUPRET
00004C8A CHKIO
00004C9A CHKRET
00004C9C PRMESG
00004CA6 PRMRET
00004CA8 OUTC
00004CB4 OUTC1
00004CC4 INC
00004CD0 INC1
00004CE4 AUXOUT
00004CF4 AUXIN
00004D12 AXIRET
00004D14 BYEBYE
00004D22 INITMSG
00004D4E OKMSG
00004D55 HOWMSG
00004D5C WHTMSG
00004D64 SRYMSG
00004D6A CLMSG
00004D6E LSTROM
00004D70 RANPNT
00004D74 INPPTR
00004D78 OUTPTR
00004D7C CURRNT
00004D80 STKFP
00004D84 STKGOS
00004D88 STKINP
00004D8C LOPVAR
00004D90 LOPINC
00004D9C LOPLMT
00004DA8 LOPLN
00004DAC LOPPT
00004DB0 IRQROUT
00004DB4 TXTUNF
00004DB8 VARBGN
00004DBC STKLMT
00004DC0 BUFFER
00004E10 TXT
00004E10 FemtikiInit
00004E46 FemtikiInitIRQ
00004E54 OSCallTable
00004E56 CallOS
00004EC0 GetRunningTCBPointer
00004EDE TCBHandleToPointer
00004EF6 PointerToTCBHandle
00004F06 SelectThreadToRun
00004F2C InsertIntoReadyQueue
00004F7C RemoveFromReadyQueue
00004F92 StartQ
00004F9A PopReadyQueue
00005018 UpdateIRQLive
0000503A FemtikiTimerIRQ
000050AA get_screen_color
000050D6 get_screen_address
000050DE clear_screen
00005114 loop3
0000512E CRLF
00005140 UpdateTextPos
0000516A CalcScreenLoc
00005178 DisplayChar
00005196 dcx14
0000519A dcx7
000051A0 dccr
000051BE dcx6
000051D4 dcx8
000051EA dcx9
00005208 dcx10
00005220 dcx12
0000522A dcx11
00005270 dclf
00005274 dcx16
00005278 dcx4
00005282 doBackspace
00005290 doDelete
000052CC doCtrlX
000052F0 IncCursorPos
00005310 IncCursorRow
00005342 icc1
00005344 ScrollUp
0000538E BlankLastLine
000053F2 DisplayString
000053F6 dspj1
00005402 dsret
00005408 DisplayStringCRLF
0000540E DisplayStringLimited
0000542E DisplayStringLimitedCRLF
00005434 HomeCursor
00005446 SyncCursor
00005470 TRAP15
00005488 T15DispatchTable
00005534 Cursor1
0000556A StubRout
0000556C select_iofocus
0000557E rotate_iofocus
00005590 select_focus1
000055AA init_plic
000055E0 KeybdGetID
00005612 kgid1
0000561A kgnotKbd
0000561E KeybdSetLED
0000564A _KeybdInit
0000564A KeybdInit
00005672 kbdi0002
000056D0 kbdiTryAgain
000056DE kbdi0004
000056F8 kbdi0005
000056FC ledxit
00005712 kbdiXmitBusy
00005720 msgBadKeybd
0000572F msgXmitBusy
0000574A _KeybdGetStatus
00005754 _KeybdGetScancode
00005764 KeybdRecvByte
00005784 KeybdWaitTx
000057AA SetKeyboardEcho
000057B2 CheckForKey
000057BE GetKey
000057F6 CheckForCtrlC
00005802 KeybdGetCharNoWait
0000580A KeybdGetCharWait
00005812 KeybdGetChar
00005A2A KeybdSetLEDStatus
00005A7A KeybdSendByte
00005A82 Wait10ms
00005A9E Wait300ms
00005ABA KeybdIRQ
00005B4C _unshiftedScanCodes
00005C4C _shiftedScanCodes
00005D4C _keybdControlCodes
00005DCC _keybdExtendedCodes
00005E4C cmdString
00005E80 cmdTable
00005EAE FromScreen
00005EB8 StartMon
00005EC2 Monitor
00005EC2 cmdMonitor
00005EDE PromptLn
00005EEA Prompt3
00005F00 Prompt1
00005F12 cmdDispatch
00005F58 cmdBreakpoint
00005F7C cmdTinyBasic
00005F80 cmdTestCPU
00005F90 cmdClearScreen
00005F9C cmdCore
00005FC0 cmdTestFP
0000604C cmdTestGF
0000607A cmdClock
00006098 cmdReset
000060CA tblPow2
000060EA DisplayHelp
000060EA cmdHelp
000060F6 HelpMsg
0000624A msgUnknownCmd
0000625A msgHello
0000626C GetCmdLine
00006310 cmdSendSerial
00006340 cmdReceiveSerial
00006374 cmdFillB
00006398 cmdFillW
000063BC cmdFillL
000063E0 ignBlanks
000063F2 cmdEditMemory
000063FA edtmem1
00006452 cmdJump
00006452 ExecuteCode
00006460 cmdDumpMemory
00006480 DumpMem1
00006492 DisplayMem
000064A2 dspmem1
000064EE cmdDumpRegs
0000656E msg_regs
00006572 msg_reglist
00006598 cmdTestSerialReceive
000065B8 GetHexNumber
000065E6 GetDecNumber
00006620 _dfOne
0000662C _dfTen
00006638 _dfMil
00006644 _msgNan
00006648 _msgInf
0000664C _CheckNan
000066B0 _CheckZero
000066CA _CheckNegative
000066DC _MakeBig
000066F8 _LessThanDbl
00006724 _ComputeDigitsBeforeDecpt
0000675E _LeadingZero
0000676E _SpitOutDigits
000067EA _TrimTrailingPoint
00006808 _TrimDotZero
00006824 _TrimTrailingZeros
00006830 _SpitOutE
00006848 _ExtExpDigit
00006866 _ExtExpDigits
0000688E _PadLeft
000068DE _PadRight
00006910 _FloatToString
00006952 _GetFloatGetChar
00006958 _GetFloatIgnBlanks
00006960 _GetFloatBackupChar
00006964 _GetFraction
000069C8 _GetExponent
00006A52 _GetInteger
00006AC8 _GetFloat
00006B40 AsciiToHexNybble
00006B52 gthx5
00006B64 gthx6
00006B76 gthx3
00006B7A DisplayTwoSpaces
00006B84 dspspc1
00006B8C DisplaySpace
00006B94 DisplayTetra
00006B9A DisplayWyde
00006BA0 DisplayByte
00006BA6 DisplayNybble
00006BC0 DisplayAddr
00006BDE ramtest
00006BDE cmdTestRAM
00006BF8 rmtst5
00006C20 ramtest0
00006C28 ramtest1
00006C38 rmtst1
00006C44 ramtest6
00006C54 ramtest2
00006C6A rmtst2
00006C72 rmtst3
00006C96 ramtest3
00006C98 cmdLoadS19
00006C9E NextRec
00006CB0 ProcessRec
00006D46 pcssxa
00006DB2 ProcessS1
00006DB6 ProcessS2
00006DBA ProcessS3
00006DBE ProcessS7
00006DCE ProcessS8
00006DDE ProcessS9
00006DEE S19Get16BitAddress
00006DFC S19Get24BitAddress
00006E08 S19Get32BitAddress
00006E26 S1932a
00006E3A S1932b
00006E7C sGetChar
00006EA8 AudioInputTest
00006EAA BouncingBalls
00006EAC GraphicsDemo
00006EAE ClearScreen
00006EB4 rbo
00006EBC SerialInit
00006EEE SerialGetChar
00006F66 SerialPeekChar
00006F9E SerialPeekCharDirect
00006FB8 SerialPutChar
00006FD4 SerialRbo
00006FDC SerialRcvCount
00006FFC SerialIRQ
00007010 sirqNxtByte
00007022 sirq0001
00007072 sirqRxFull
00007072 notRxInt
00007084 nmeSerial
0000708C init_i2c
0000708C i2c_setup
0000709C i2c_wait_tip
000070AC i2c_wr_cmd
000070BC i2c_xmit1
000070DA i2c_wait_rx_nack
000070EA rtc_read
00007176 rtc_write
000071E0 msgRtcReadFail
000071FA bus_err
000071FE trap3
0000723C ProcessBreakpoint
00007242 DisarmAllBreakpoints
0000726E ArmAllBreakpoints
0000729E ArmBreakpoint
0000731C DisarmBreakpoint
00007370 ListBreakpoints
00007390 ClearBreakpointList
000073A2 SendMsg
000073E0 ReceiveMsg
00007422 DispatchMsg
00007424 prtflt
0000744A InitIRQ
0000745E InstallIRQ
0000748E TickIRQ
000074DC irq3_rout
000074E6 irq6_rout
000074EE irq_rout
00007502 SpuriousIRQ
00007504 nmi_rout
00007516 brdisp_trap
0000754E illegal_trap
00007564 io_irq
00007578 msg_start
0000759F msg_core_start
000075B0 msg_illegal
000075C2 msg_bad_branch_disp
000075D4 msg_test_done
000075E4 msg_io_access
000075FF msgChk
0000760D msgStackCanary
00040000 CursorRow
00040001 CursorCol
00040002 TextCurpos
00040002 TextPos
00040004 TextScr
00040008 S19StartAddress
0004000C KeybdEcho
0004000D KeybdWaitFlag
00040040 CmdBuf
00040080 CmdBufEnd
00040084 fgColor
00040088 bkColor
0004008C TextRows
0004008D TextCols
00040094 _fpTextIncr
00040098 _canary
000400A0 IRQFlag
00040100 Regsave
00040202 NumSetBreakpoints
00040220 Breakpoints
00040280 BreakpointWords
000402C0 fpBuf
00040508 _width
0004050C _E
00040510 _digits_before_decpt
00040514 _precision
00040520 _fpBuf
00040600 _fpWork
00040BFC TimerStack
00100000 IOFocus
00100004 memend
0010000E KeybdLEDs
0010000F _KeyState1
00100010 _KeyState2
00100011 _KeybdHead
00100012 _KeybdTail
00100013 _KeybdCnt
00100016 KeybdID
00100020 _KeybdBuf
00100150 S19Checksum
00100160 SerTailRcv
00100162 SerHeadRcv
00100164 SerRcvXon
00100165 SerRcvXoff
00100200 RTCBuf
00100224 RunningTCB
0010031C QueueCycle
00100320 readyQ
00101000 SerRcvBuf
20010000 tcbs

Sections:
00: "CODE" (0-DE1D)
01: "DATA" (0-700)


Source: "boot.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022-2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;-------------------------------------------------------------------------------
                            	    37: ;
                            	    38: ; system memory map
                            	    39: ;
                            	    40: ;
                            	    41: ; 00000000 +----------------+      <+
                            	    42: ;          | startup sp,pc  | 8 B   |
                            	    43: ; 00000008 +----------------+       |
                            	    44: ;					 |    vectors     | pair shared+
                            	    45: ; 00000400 +----------------+       |
                            	    46: ;					 |   bios mem     |       |
                            	    47: ; 00001000 +----------------+       |
                            	    48: ;					 |   bios code    |       |
                            	    49: ; 00020000 +----------------+      <+
                            	    50: ;					 |    unused      |
                            	    51: ; 00040000 +----------------+
                            	    52: ;					 |   local ram    |
                            	    53: ; 00048000 +----------------+
                            	    54: ;					 |    unused      |
                            	    55: ; 00100000 +----------------+
                            	    56: ;					 |   global ram   |
                            	    57: ; 00101000 +----------------+
                            	    58: ;					 | serial rcvbuf  |
                            	    59: ; 00102000 +----------------+
                            	    60: ;          | serial xmitbuf |
                            	    61: ; 00103000 +----------------+
                            	    62: ;					 |    unused      |
                            	    63: ; 40000000 +----------------+
                            	    64: ;          |                |
                            	    65: ;          |                |
                            	    66: ;          |                |
                            	    67: ;          :  dram memory   : 1GB MB
                            	    68: ;          |                |
                            	    69: ;          |                |
                            	    70: ;          |                |
                            	    71: ; 80000000 +----------------+
                            	    72: ;          |                |
                            	    73: ;          |                |
                            	    74: ;          |                |
                            	    75: ;          :  dram memory   : 1GB MB
                            	    76: ;          |     mirror     |
                            	    77: ;          |                |
                            	    78: ;          |                |
                            	    79: ; C0000000 +----------------+
                            	    80: ;          |                |
                            	    81: ;          :     unused     :
                            	    82: ;          |                |
                            	    83: ; FD000000 +----------------+
                            	    84: ;          |                |
                            	    85: ;          :    I/O area    : 1.0 M
                            	    86: ;          |                |
                            	    87: ; FFE00000 +----------------+
                            	    88: ;          |                |
                            	    89: ;          :     unused     :
                            	    90: ;          |                |
                            	    91: ; FFFFFFFF +----------------+
                            	    92: ;
                            	    93: ;-------------------------------------------------------------------------------
                            	    94: ;
                            	    95: HAS_MMU equ 0
                            	    96: NCORES equ 4
                            	    97: TEXTCOL equ 52
                            	    98: TEXTROW	equ	32
                            	    99: VIDEO_X equ 1368
                            	   100: VIDEO_Y equ 768
                            	   101: 
                            	   102: CTRLC	EQU		$03
                            	   103: CTRLH	EQU		$08
                            	   104: CTRLS	EQU		$13
                            	   105: CTRLX	EQU		$18
                            	   106: CTRLZ	EQU		$1A
                            	   107: LF		EQU		$0A
                            	   108: CR		EQU		$0D
                            	   109: XON		EQU		$11
                            	   110: XOFF	EQU		$13
                            	   111: EOT		EQU		$04
                            	   112: BLANK EQU		$20
                            	   113: 
                            	   114: SC_F12  EQU    $07
                            	   115: SC_C    EQU    $21
                            	   116: SC_T    EQU    $2C
                            	   117: SC_Z    EQU    $1A
                            	   118: SC_KEYUP	EQU		$F0
                            	   119: SC_EXTEND   EQU		$E0
                            	   120: SC_CTRL		EQU		$14
                            	   121: SC_RSHIFT	EQU		$59
                            	   122: SC_NUMLOCK	EQU		$77
                            	   123: SC_SCROLLLOCK	EQU	$7E
                            	   124: SC_CAPSLOCK		EQU	$58
                            	   125: SC_ALT		EQU		$11
                            	   126: SC_LSHIFT	EQU		$12
                            	   127: SC_DEL		EQU		$71		; extend
                            	   128: SC_LCTRL	EQU		$58
                            	   129: SC_TAB      EQU		$0D
                            	   130: 
                            	   131: 	include "..\Femtiki\device.x68"

Source: "..\Femtiki\device.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ; the following constant is used to scramble device handles. The device handle
                            	    38: ; (address) is rotated 16 bits then xor'd with this value.
                            	    39: 
                            	    40: DEV_HMASH	equ $56791123
                            	    41: 
                            	    42: DEV_INIT equ 0
                            	    43: DEV_STAT equ 1
                            	    44: DEV_PUTCHAR equ 2
                            	    45: DEV_PUTBUF equ 3
                            	    46: DEV_GETCHAR equ 4
                            	    47: DEV_GETBUF equ 5
                            	    48: DEV_SET_INPOS equ 6
                            	    49: DEV_SET_OUTPOS equ 7
                            	    50: DEV_GETCHAR_DIRECT equ 8
                            	    51: DEV_PEEKCHAR equ 9
                            	    52: DEV_PEEKCHAR_DIRECT equ 10
                            	    53: DEV_PUTCHAR_DIRECT equ 11
                            	    54: DEV_CLEAR equ 12
                            	    55: DEV_SWAPBUF equ 13
                            	    56: DEV_SETBUF1 equ 14
                            	    57: DEV_SETBUF2 equ 15
                            	    58: DEV_GETBUF1 equ 16
                            	    59: DEV_GETBUF2 equ 17
                            	    60: DEV_WRITEAT equ 18
                            	    61: DEV_SETUNIT equ 19
                            	    62: DEV_GET_DIMEN equ 20
                            	    63: DEV_GET_COLOR equ 21
                            	    64: DEV_GET_INPOS equ 22
                            	    65: DEV_GET_OUTPOS equ 23
                            	    66: DEV_GET_OUTPTR equ 24
                            	    67: DEV_SET_COLOR equ 25
                            	    68: DEV_SET_COLOR123 equ 26
                            	    69: DEV_PLOT_POINT equ 27
                            	    70: DEV_DRAW_LINE equ 28
                            	    71: DEV_DRAW_TRIANGLE equ 29
                            	    72: DEV_DRAW_RECTANGLE equ 30
                            	    73: DEV_DRAW_CURVE equ 31
                            	    74: DEV_SET_DIMEN equ 32
                            	    75: DEV_SET_COLOR_DEPTH equ 33
                            	    76: DEV_SET_DESTBUF equ 34
                            	    77: DEV_SET_DISPBUF equ 35
                            	    78: 
                            	    79: 
                            	    80: DCB_MAGIC equ	0			; 'DCB'
                            	    81: DCB_NAME	equ 4			; 15 chars+NULL
                            	    82: DCB_CMDPROC	equ 24	; 8 byte pointer to command processor
                            	    83: DCB_OUTPOSX equ 32
                            	    84: DCB_OUTPOSY equ 36
                            	    85: DCB_OUTPOSZ equ 40
                            	    86: DCB_INPOSX equ 44
                            	    87: DCB_INPOSY equ 48
                            	    88: DCB_INPOSZ equ 52
                            	    89: DCB_INBUFPTR equ 56
                            	    90: DCB_OUTBUFPTR equ 60
                            	    91: DCB_INBUFSIZE equ 64
                            	    92: DCB_OUTBUFSIZE equ 68
                            	    93: DCB_INDIMX equ 72
                            	    94: DCB_INDIMY equ 76
                            	    95: DCB_INDIMZ equ 80
                            	    96: DCB_OUTDIMX equ 84
                            	    97: DCB_OUTDIMY equ 88
                            	    98: DCB_OUTDIMZ equ 92
                            	    99: DCB_BKCOLOR equ 96
                            	   100: DCB_FGCOLOR equ 100
                            	   101: DCB_OPCODE equ 104
                            	   102: DCB_LASTERC equ 108
                            	   103: DCB_INBUFPTR2 equ 112
                            	   104: DCB_OUTBUFPTR2 equ 116
                            	   105: DCB_INBUFSIZE2 equ 120
                            	   106: DCB_OUTBUFSIZE2 equ 124
                            	   107: DCB_UNIT equ 128
                            	   108: DCB_SIZE equ 132
                            	   109: 
                            	   110: ;Standard Devices are:
                            	   111: 
                            	   112: ;#		Device					Standard name
                            	   113: 
                            	   114: ;0		NULL device 			NUL		(OS built-in)
                            	   115: ;1		Keyboard (sequential)	KBD		(OS built-in, ReadOnly)
                            	   116: ;2		Video (sequential)		VID		(OS built-in, WriteOnly)
                            	   117: ;3		Printer (parallel 1)	LPT		(OS built-in)
                            	   118: ;4		Printer (parallel 2)	LPT2	(OS built-in)
                            	   119: ;5		RS-232 1				COM1	(OS built-in)
                            	   120: ;6		RS-232 2				COM2	(OS built-in)
                            	   121: ;7		RS-232 3				COM3	(OS built-in)
                            	   122: ;8		RS-232 4				COM4	(OS built-in)
                            	   123: ;9
                            	   124: ;10		Floppy					FD0 	(OS built-in)
                            	   125: ;11		Floppy					FD1 	(OS built-in)
                            	   126: ;12		Hard disk				HD0 	(OS built-in)
                            	   127: ;13		Hard disk				HD1 	(OS built-in)
                            	   128: ;14
                            	   129: ;15
                            	   130: ;16
                            	   131: ;17
                            	   132: ;18
                            	   133: ;19
                            	   134: ;20
                            	   135: ;21
                            	   136: ;22
                            	   137: ;23
                            	   138: 

Source: "boot.x68"
                            	   132: 	include "..\Femtiki\FemtikiTop.x68"

Source: "..\Femtiki\FemtikiTop.x68"
                            	     1: 	include "..\Femtiki\const.x68"

Source: "..\Femtiki\const.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: TS_NONE			EQU		0
                            	    38: TS_READY		EQU		1
                            	    39: TS_DEAD			EQU		2
                            	    40: TS_MSGRDY		EQU		4
                            	    41: TS_WAITMSG	EQU		8
                            	    42: TS_TIMEOUT	EQU		16
                            	    43: TS_PREEMPT	EQU		32
                            	    44: TS_RUNNING	EQU		128
                            	    45: 
                            	    46: ; error codes
                            	    47: E_Ok		EQU		$00
                            	    48: E_Arg		EQU		$01
                            	    49: E_Func  EQU    $02
                            	    50: E_BadMbx	EQU		$04
                            	    51: E_QueFull	EQU		$05
                            	    52: E_NoThread	EQU		$06
                            	    53: E_NotAlloc	EQU		$09
                            	    54: E_NotSupported EQU $0A
                            	    55: E_NoMsg		EQU		$0b
                            	    56: E_Timeout	EQU		$10
                            	    57: E_BadAlarm	EQU		$11
                            	    58: E_NotOwner	EQU		$12
                            	    59: E_QueStrategy EQU		$13
                            	    60: E_DCBInUse	EQU		$19
                            	    61: ; Device driver errors
                            	    62: E_BadDevNum	EQU		$20
                            	    63: E_NoDev		EQU		$21
                            	    64: E_BadDevOp	EQU		$22
                            	    65: E_ReadError	EQU		$23
                            	    66: E_WriteError EQU		$24
                            	    67: E_BadBlockNum	EQU	$25
                            	    68: E_TooManyBlocks	EQU	$26
                            	    69: E_InitErr EQU $27
                            	    70: 
                            	    71: ; resource errors
                            	    72: E_NoMoreMbx	EQU		$40
                            	    73: E_NoMoreMsgBlks	EQU	$41
                            	    74: E_NoMoreAlarmBlks	EQU $44
                            	    75: E_NoMoreTCBs	EQU	$45
                            	    76: E_NoMem		EQU 12
                            	    77: 
                            	    78: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     2: 	include "..\Femtiki\config.x68"

Source: "..\Femtiki\config.x68"
                            	     1: MAX_TID		EQU		4095
                            	     2: NR_TCB		EQU		4096
                            	     3: NTASK     EQU   4096    ; number of threads allowed
                            	     4: LOG_TCBSZ	EQU		8
                            	     5: LOG_PGSZ	EQU		10
                            	     6: LOG_ACBSZ EQU   12
                            	     7: OSPAGES		EQU		16			; pages of memory dedicated to OS
                            	     8: PAGESZ    EQU   16384  	; size of a page of memory
                            	     9: MEMSZ     EQU   32768   ; pages
                            	    10: MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                            	    11: NR_MSG		EQU		21842		; number of messages available
                            	    12: NR_MBX		EQU		9792
                            	    13: 
                            	    14: 
                            	    15: 
                            	    16: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     3: 	include "..\Femtiki\types.x68"

Source: "..\Femtiki\types.x68"
                            	     1: ; Thread Control Block
                            	     2: TCBMagic    EQU		$0000
                            	     3: TCBRegs  		EQU   $0004		; register set storage area
                            	     4: TCBUSP			EQU		$0044
                            	     5: TCBSSP			EQU		$0048
                            	     6: TCBSR				EQU		$004C
                            	     7: TCBPC				EQU		$0050
                            	     8: TCBStatus		EQU		$0054
                            	     9: TCBPriority	EQU		$0055
                            	    10: TCBWaitMbx	EQU		$0056
                            	    11: TCBHasFocus EQU   $005A
                            	    12: TCBStackBot	EQU		$005C
                            	    13: TCBMsgD1		EQU		$0060
                            	    14: TCBMsgD2		EQU		$0064
                            	    15: TCBMsgD3		EQU		$0068
                            	    16: TCBStartTick	EQU	$006C
                            	    17: TCBEndTick	EQU		$0070
                            	    18: TCBTicks		EQU		$0074
                            	    19: TCBException	EQU	$0078
                            	    20: TCBNext			EQU		$007C
                            	    21: TCBPrev			EQU		$0080
                            	    22: TCBAffinityBase	EQU	$0082
                            	    23: TCBAffinity	EQU		$0084
                            	    24: TCBTimeout	EQU		$0088
                            	    25: TCBtid      EQU   $008C
                            	    26: TCBmid      EQU   $0090
                            	    27: TCBappid    EQU   $0094
                            	    28: TCBOpMode   EQU   $0098
                            	    29: TCBMbxNext  EQU   $009C
                            	    30: TCBMbxPrev  EQU   $00A0
                            	    31: TCBThreadNum  EQU   $00A4
                            	    32: TCBAcbNext	EQU		$00A8
                            	    33: TCBAcbPrev	EQU		$00AC
                            	    34: TCBhMailboxes	EQU		$00B0
                            	    35: TCBName			EQU		$00C0
                            	    36: TCB_SIZE		EQU		$0100
                            	    37: 
                            	    38: MBX_MAGIC		equ		0
                            	    39: MBX_OWNER		equ		4		; tid of owning task
                            	    40: MBX_LINK    equ   8
                            	    41: MBX_TQHEAD  equ   12   ; link field for free list shared with task queue head
                            	    42: MBX_TQTAIL  equ   16
                            	    43: MBX_MQHEAD	equ		20
                            	    44: MBX_MQTAIL	equ		24
                            	    45: MBX_SIZE		equ		32
                            	    46: 
                            	    47: MSG_MAGIC   equ   0
                            	    48: MSG_LINK	  equ		4
                            	    49: MSG_RETADR  equ   8
                            	    50: MSG_TGTADR  equ   12
                            	    51: MSG_TYPE    equ   16
                            	    52: MSG_D1		  equ		20
                            	    53: MSG_D2		  equ		24
                            	    54: MSG_D3		  equ		28
                            	    55: MSG_SIZE	  equ		32
                            	    56: 
                            	    57: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     4: 
                            	     5: 	include "..\Femtiki\source\kernel\Femtiki_vars.x68"

Source: "..\Femtiki\source\kernel\Femtiki_vars.x68"
                            	     1: 
                            	     2: PAMShareCounts	EQU	$20000000	; one byte for each physical page of memory
                            	     3: tcbs						EQU	$20010000	; 4095*256 = 1MB
                            	     4: tcbs_end				EQU	$20020000
                            	     5: messages				EQU	$20020000	; 32*8192 (680*16=21760 messages)
                            	     6: messages_end		EQU	$20060000
                            	     7: mailboxes				EQU	$20060000
                            	     8: mailboxes_end		EQU	$20078000	;	12*8192 (816*12=9792 mailboxes)
                            	     9: acbs						EQU	$20080000	; 32*2*8192 =512kB
                            	    10: acbs_end				EQU	$20100000
                            	    11: 
                            	    12: 
                            	    13: sys_stacks			EQU	$DF0000
                            	    14: 
                            	    15: FemtikiVars			EQU	$00100200
                            	    16: PAMLastAllocate2	EQU		$00100218
                            	    17: RunningAID		EQU		$00100220
                            	    18: RunningTCB			EQU		$00100224
                            	    19: ACBPtrs				EQU		$00100228
                            	    20: MidStackBottoms	EQU		$00100264
                            	    21: FemtikiInited	EQU		$00100284
                            	    22: missed_ticks	EQU		$00100288
                            	    23: IOFocusList		EQU		$0010028C
                            	    24: IOFocusID			EQU		$001002AC
                            	    25: iof_switch		EQU		$001002AD
                            	    26: nMessage			EQU		$001002AE
                            	    27: nMailbox			EQU		$001002B0
                            	    28: hKeybdMbx			EQU		$001002BA
                            	    29: hFocusSwitchMbx		EQU		$001002BC
                            	    30: BIOS_RespMbx	EQU		$001002BE
                            	    31: hasUltraHighPriorityTasks	EQU		$001002C0
                            	    32: im_save				EQU		$001002C2
                            	    33: sp_tmp				EQU		$001002C4
                            	    34: startQNdx			EQU		$001002C6
                            	    35: NPAGES				EQU		$001002D8
                            	    36: syspages			EQU		$001002DA
                            	    37: mmu_FreeMaps	EQU		$001002E0
                            	    38: mmu_entries		EQU		$00100300
                            	    39: freelist			EQU		$00100302
                            	    40: hSearchMap		EQU		$00100304
                            	    41: OSActive			EQU		$00100305
                            	    42: FreeACB				EQU		$00100308
                            	    43: FreeTCB				EQU		$0010030C
                            	    44: FreeMSG				EQU		$00100310
                            	    45: FreeMBX				EQU		$00100314
                            	    46: TimeoutList		EQU		$00100318
                            	    47: QueueCycle    EQU   $0010031C
                            	    48: readyQ				EQU		$00100320		; 32 bytes per queue per core, 2 cores for now
                            	    49: readyQEnd			EQU		$00100360
                            	    50: FemtikiVars_end	EQU	$00100400
                            	    51: 
                            	    52: ;gc_stack		rmb		512
                            	    53: ;gc_pc				fcdw		0
                            	    54: ;gc_omapno		fcw			0
                            	    55: ;gc_mapno		fcw			0
                            	    56: ;gc_dl				fcw			0
                            	    57: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     6: 	code
                            	     7: 	even
                            	     8: 	include "..\Femtiki\source\kernel\tcb.x68"

Source: "..\Femtiki\source\kernel\tcb.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;------------------------------------------------------------------------------
                            	    38: ; Initialize variables related to TCBs.
                            	    39: ;------------------------------------------------------------------------------
                            	    40: 
                            	    41: TCBInit:
00:00000000 41F920010000    	    42: 	lea tcbs,a0
00:00000006 4E7B8013        	    43: 	movec a0,tcba
00:0000000A 700F            	    44: 	moveq #2*8-1,d0		; 2 cores, 32 bytes (8 lwords) per queue
00:0000000C 72FF            	    45: 	moveq #-1,d1			; value to set
00:0000000E 41F900100320    	    46: 	lea readyQ,a0			; clear out ready queue
                            	    47: .0001
00:00000014 20C1            	    48: 	move.l d1,(a0)+
00:00000016 51C8FFFC        	    49: 	dbra d0,.0001
00:0000001A 203C0003FFFF    	    50: 	move.l #TCB_SIZE*NR_TCB/4-1,d0
                            	    51: .clearTCBs
00:00000020 4298            	    52: 	clr.l (a0)+
00:00000022 51C8FFFC        	    53: 	dbra d0,.clearTCBs
00:00000026 4E75            	    54: 	rts
                            	    55: 
                            	    56: ;------------------------------------------------------------------------------
                            	    57: ; Convert a TCB handle into a pointer.
                            	    58: ;
                            	    59: ; Parameters:
                            	    60: ;		d0 = TCB handle
                            	    61: ; Returns:
                            	    62: ;		a0 = pointer to TCB
                            	    63: ;------------------------------------------------------------------------------
                            	    64: 
                            	    65: TCBHandleToPointer:
00:00000028 2F01            	    66: 	move.l d1,-(a7)
00:0000002A 028000000FFF    	    67: 	andi.l #MAX_TID,d0		; limit to # threads
00:00000030 4E7A1013        	    68: 	movec tcba,d1
00:00000034 E188            	    69: 	lsl.l #8,d0
00:00000036 D280            	    70: 	add.l d0,d1
00:00000038 2041            	    71: 	move.l d1,a0
00:0000003A E088            	    72: 	lsr.l #8,d0						; restore d0
00:0000003C 221F            	    73: 	move.l (a7)+,d1
00:0000003E 4E75            	    74: 	rts
                            	    75: 
                            	    76: ;------------------------------------------------------------------------------
                            	    77: ; Convert a TCB pointer into a handle.
                            	    78: ;
                            	    79: ; Parameters:
                            	    80: ;		a0 = TCB pointer
                            	    81: ; Returns:
                            	    82: ;		d0 = TCB handle
                            	    83: ;------------------------------------------------------------------------------
                            	    84: 
                            	    85: TCBPointerToHandle:
00:00000040 2F01            	    86: 	move.l d1,-(a7)				; save d1
00:00000042 4E7A1013        	    87: 	movec tcba,d1
00:00000046 91C1            	    88: 	sub.l d1,a0
00:00000048 2008            	    89: 	move.l a0,d0
00:0000004A E088            	    90: 	lsr.l #8,d0
00:0000004C 221F            	    91: 	move.l (a7)+,d1				; restore d1
00:0000004E 4E75            	    92: 	rts
                            	    93: 
                            	    94: ;------------------------------------------------------------------------------
                            	    95: ; Internal TCB allocation function.
                            	    96: ;
                            	    97: ; Parameters:
                            	    98: ;		none
                            	    99: ; Returns:
                            	   100: ;		d0 = handle for allocated TCB, NULL if none available
                            	   101: ;------------------------------------------------------------------------------
                            	   102: 
                            	   103: TCBIAlloc:
00:00000050 30390010030C    	   104: 	move.w FreeTCB,d0				; d1 = Free handle
00:00000056 6714            	   105: 	beq .0001
00:00000058 2F08            	   106: 	move.l a0,-(sp)
00:0000005A 61CC            	   107: 	bsr TCBHandleToPointer	; convert to pointer
00:0000005C 3228007C        	   108: 	move.w TCBNext(a0),d1		; d1 = next on free list
00:00000060 33C10010030C    	   109: 	move.w d1,FreeTCB				; update head of free list
00:00000066 61D8            	   110: 	bsr TCBPointerToHandle	; convert pointer to handle
00:00000068 205F            	   111: 	move.l (sp)+,a0
00:0000006A 4E75            	   112: 	rts
                            	   113: 	; Here there was no free TCB available. Return a NULL
                            	   114: .0001
00:0000006C 4E75            	   115: 	rts
                            	   116: 	
                            	   117: ;------------------------------------------------------------------------------
                            	   118: ; TCB allocation function. Locks the system semaphore during allocation.
                            	   119: ;
                            	   120: ; Parameters:
                            	   121: ;		none
                            	   122: ; Returns:
                            	   123: ;		d0 = handle for allocated TCB, NULL if none available
                            	   124: ;		d1 = E_Ok
                            	   125: ;------------------------------------------------------------------------------
                            	   126: 
                            	   127: TCBAlloc:
00:0000006E 61000326        	   128: 	bsr LockSysSemaphore
00:00000072 61DC            	   129: 	bsr	TCBIAlloc
00:00000074 61000330        	   130: 	bsr UnlockSysSemaphore
00:00000078 7200            	   131: 	moveq #E_Ok,d1
00:0000007A 4E75            	   132: 	rts
                            	   133: 	
                            	   134: ;------------------------------------------------------------------------------
                            	   135: ; Internal TCB free function.
                            	   136: ;
                            	   137: ; Modifies:
                            	   138: ;		none
                            	   139: ; Parameters:
                            	   140: ;		d0 = handle to TCB
                            	   141: ; Returns:
                            	   142: ;		d0 = handle to TCB
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: TCBIFree:
00:0000007C 2F08            	   146: 	move.l a0,-(sp)
00:0000007E 61A8            	   147: 	bsr TCBHandleToPointer
00:00000080 31790010030C007C	   148: 	move.w FreeTCB,TCBNext(a0)
00:00000088 33C00010030C    	   149: 	move.w d0,FreeTCB
00:0000008E 205F            	   150: 	move.l (sp)+,a0
00:00000090 4E75            	   151: 	rts
                            	   152: 
                            	   153: ;------------------------------------------------------------------------------
                            	   154: ; TCB free function. Locks the system sempaphore while freeing.
                            	   155: ;
                            	   156: ; Modifies:
                            	   157: ;		none
                            	   158: ; Parameters:
                            	   159: ;		d0 = handle to TCB
                            	   160: ; Returns:
                            	   161: ;		d0 = handle to TCB
                            	   162: ;		d1 = E_Ok
                            	   163: ;------------------------------------------------------------------------------
                            	   164: 
                            	   165: TCBFree:
00:00000092 61000302        	   166: 	bsr LockSysSemaphore
00:00000096 61E4            	   167: 	bsr TCBIFree
00:00000098 6100030C        	   168: 	bsr UnlockSysSemaphore
00:0000009C 7200            	   169: 	moveq #E_Ok,d1
00:0000009E 4E75            	   170: 	rts
                            	   171: 
                            	   172: ;------------------------------------------------------------------------------
                            	   173: ; Given an affinity, chose the core number to run on.
                            	   174: ;
                            	   175: ; Parameters:
                            	   176: ;		a0 = pointer to TCB
                            	   177: ;	Returns:
                            	   178: ;		d0 = core number to run on
                            	   179: ;------------------------------------------------------------------------------
                            	   180: 
                            	   181: TCBAffineChose:
00:000000A0 48E75000        	   182: 	movem.l d1/d3,-(sp)
00:000000A4 363C001F        	   183: 	move.w #31,d3										; limit number of bit selects to 32
00:000000A8 12280082        	   184: 	move.b TCBAffinityBase(a0),d1		; d1 = starting bit
00:000000AC 20280084        	   185: 	move.l TCBAffinity(a0),d0				; d0 = affinity mask
                            	   186: .0002
00:000000B0 0300            	   187: 	btst.l d1,d0										; is bit d1 set?
00:000000B2 6610            	   188: 	bne .0001												; if set, exit loop
00:000000B4 5241            	   189: 	addq #1,d1
00:000000B6 51CBFFF8        	   190: 	dbra d3,.0002
                            	   191: 	; no bits set? How?
00:000000BA 117C00020082    	   192: 	move.b #2,TCBAffinityBase(a0)
00:000000C0 7000            	   193: 	moveq #0,d0											; just return core #2 (0)
00:000000C2 4E75            	   194: 	rts
                            	   195: .0001
00:000000C4 1001            	   196: 	move.b d1,d0
00:000000C6 5500            	   197: 	subi.b #2,d0										; cores start at #2
00:000000C8 4880            	   198: 	ext.w d0
00:000000CA 48C0            	   199: 	ext.l d0
00:000000CC 5241            	   200: 	addq #1,d1											; increment bit selection for next time
00:000000CE 11410082        	   201: 	move.b d1,TCBAffinityBase(a0)		; and store in TCB
00:000000D2 4CDF000A        	   202: 	movem.l (sp)+,d1/d3
00:000000D6 4E75            	   203: 	rts
                            	   204: 
                            	   205: ;------------------------------------------------------------------------------
                            	   206: ; Insert thread into ready queue. The thread is added at the tail of the 
                            	   207: ; queue. The queue is a doubly linked list.
                            	   208: ;
                            	   209: ; Stack Space:
                            	   210: ;		8 lwords
                            	   211: ; Modifies:
                            	   212: ;		none
                            	   213: ; Parameters:
                            	   214: ;		d0 = thread id to insert
                            	   215: ; Returns:
                            	   216: ;		d0 = TCB handle
                            	   217: ; ----------------------------------------------------------------------------
                            	   218: 
                            	   219: TCBInsertIntoReadyQueue:
00:000000D8 48E770F0        	   220: 	movem.l d1-d3/a0-a3,-(sp)
00:000000DC 2400            	   221: 	move.l d0,d2											; d2 = thread to insert
00:000000DE 6100FF48        	   222: 	bsr TCBHandleToPointer
00:000000E2 2648            	   223: 	move.l a0,a3											; a3 = TCB pointer of thread to insert
00:000000E4 610002B0        	   224: 	bsr LockSysSemaphore
00:000000E8 002800800054    	   225: 	ori.b #TS_RUNNING,TCBStatus(a0)
00:000000EE 61B0            	   226: 	bsr TCBAffineChose								; Chose which cores queue to use
00:000000F0 EB88            	   227: 	lsl.l #5,d0												; 32 bytes per readyQ head/tail per core
00:000000F2 7200            	   228: 	clr.l d1
00:000000F4 12280055        	   229: 	move.b TCBPriority(a0),d1					; d1 = priority
00:000000F8 028100000007    	   230: 	andi.l #7,d1
00:000000FE E589            	   231: 	lsl.l #2,d1												; 4 bytes per priority level
00:00000100 D280            	   232: 	add.l d0,d1												; add in base queue
00:00000102 D2BC00100320    	   233: 	add.l #readyQ,d1									; add in start of ready queues
00:00000108 2241            	   234: 	move.l d1,a1
00:0000010A 30290004        	   235: 	move.w 4(a1),d0										; d0 = tail entry
00:0000010E 3600            	   236: 	move.w d0,d3											; d3 = tail entry
00:00000110 4A40            	   237: 	tst.w d0
00:00000112 6D20            	   238: 	blt .qempty
00:00000114 6100FF12        	   239: 	bsr TCBHandleToPointer						; a0 = pointer to tail
00:00000118 2448            	   240: 	move.l a0,a2
00:0000011A 2038007C        	   241: 	move.l TCBNext,d0
00:0000011E 6100FF08        	   242: 	bsr TCBHandleToPointer						; a0 = tail->next
00:00000122 21420080        	   243: 	move.l d2,TCBPrev(a0)							; tail->next->prev = new entry
00:00000126 2542007C        	   244: 	move.l d2,TCBNext(a2)							; tail->next = new entry
00:0000012A 2740007C        	   245: 	move.l d0,TCBNext(a3)							; new entry->next = tail->next
00:0000012E 27430080        	   246: 	move.l d3,TCBPrev(a3)							; new entry->prev = tail
00:00000132 6012            	   247: 	bra .0002
                            	   248: .qempty
00:00000134 4A51            	   249: 	tst.w (a1)												; check if there is a list head
00:00000136 6C0E            	   250: 	bge .0002													; head with no tail -> list corrupt
00:00000138 33420004        	   251: 	move.w d2,4(a1)										; head and tail equal new entry
00:0000013C 3282            	   252: 	move.w d2,(a1)
00:0000013E 3742007C        	   253: 	move.w d2,TCBNext(a3)							; next and prev of new entry point to self
00:00000142 37420080        	   254: 	move.w d2,TCBPrev(a3)
                            	   255: 	; Head but no tail, list corrupt?
                            	   256: .0002
00:00000146 6100025E        	   257: 	bsr UnlockSysSemaphore
00:0000014A 4CDF0F0E        	   258: 	movem.l (sp)+,d1-d3/a0-a3
00:0000014E 4E75            	   259: 	rts
                            	   260: 
                            	   261: ;------------------------------------------------------------------------------
                            	   262: ; Remove a thread from the ready queue. Actual removal is not done here, it
                            	   263: ; is done the next time the thread is selected to run. Just mark the thread as
                            	   264: ; not running.
                            	   265: ;
                            	   266: ; Parameters:
                            	   267: ;		d0 = thread id to remove
                            	   268: ; Returns:
                            	   269: ;		none
                            	   270: ; -----------------------------------------------------------------------------
                            	   271: 
                            	   272: TCBRemoveFromReadyQueue:
00:00000150 4A40            	   273: 	cmpi.w #0,d0
00:00000152 6D1C            	   274: 	blt .0001
00:00000154 028000000FFF    	   275: 	andi.l #MAX_TID,d0									; limit to # of threads
00:0000015A 2F08            	   276: 	move.l a0,-(sp)
00:0000015C 6100FECA        	   277: 	bsr	TCBHandleToPointer
00:00000160 61000234        	   278: 	bsr LockSysSemaphore
00:00000164 0228007F0054    	   279: 	andi.b #TS_RUNNING^$FF,TCBStatus(a0)
00:0000016A 6100023A        	   280: 	bsr UnlockSysSemaphore
00:0000016E 205F            	   281: 	move.l (sp)+,a0
                            	   282: .0001
00:00000170 4E75            	   283: 	rts
                            	   284: 	
                            	   285: ; ----------------------------------------------------------------------------
                            	   286: ; Register Usage
                            	   287: ;		d0 = temporary
                            	   288: ;		d1 = index into list of queues
                            	   289: ;		d2 = index to queue set
                            	   290: ;		d4 = queue counter, goes from 7 down to 0
                            	   291: ;		d5 = temporary
                            	   292: ;		d6 = next on list
                            	   293: ;		a0 = temporary pointer to TCB
                            	   294: ;		a1 = pointer to queue
                            	   295: ;		a2 = pointer to old head of list
                            	   296: ;		a3 = pointer to TCB at head of queue
                            	   297: ; Modifies:
                            	   298: ;		none
                            	   299: ; Parameters:
                            	   300: ;		none
                            	   301: ; Returns:
                            	   302: ;		a0 = pointer to TCB, NULL if none on list
                            	   303: ;		d0 = TCB handle
                            	   304: ; ----------------------------------------------------------------------------
                            	   305: 
                            	   306: StartQ
00:00000172 01              	   307: 	dc.b 1,2,3,4,1,5,6,7
00:00000173 02
00:00000174 03
00:00000175 04
00:00000176 01
00:00000177 05
00:00000178 06
00:00000179 07
                            	   308: 
                            	   309: 	even
                            	   310: TCBPopReadyQueue:
00:0000017A 48E77E70        	   311: 	movem.l	d1-d6/a1-a3,-(a7)
00:0000017E 4E7A2FE0        	   312: 	movec coreno,d2					; select the queue set based on the core number
00:00000182 5502            	   313: 	subi.b #2,d2						; cores start at #2
00:00000184 EB8A            	   314: 	lsl.l #5,d2							; d2 = index to queue set, 32 bytes per queue set
00:00000186 7807            	   315: 	moveq #7,d4							; d4 = queue count
00:00000188 6100020C        	   316: 	bsr LockSysSemaphore
                            	   317: 	; One in four tries pick a different priority to start searching from. 
00:0000018C 12390010031C    	   318: 	move.b QueueCycle,d1		; increment Queue cycle counter
00:00000192 5201            	   319: 	addi.b #1,d1
00:00000194 02010007        	   320: 	andi.b #7,d1
00:00000198 13C10010031C    	   321: 	move.b d1,QueueCycle
00:0000019E 6612            	   322: 	bne	.0001
00:000001A0 43FAFFD0        	   323: 	lea StartQ,a1
00:000001A4 4881            	   324: 	ext.w d1
00:000001A6 12311000        	   325: 	move.b (a1,d1.w),d1
00:000001AA 02410007        	   326: 	andi.w #7,d1						; limit to number of queues
00:000001AE E549            	   327: 	lsl.w #2,d1							; make into lword index
00:000001B0 6002            	   328: 	bra .0002
                            	   329: .0001
00:000001B2 7200            	   330: 	moveq #0,d1							; start at Queue #0
                            	   331: .0002
00:000001B4 43F900100320    	   332: 	lea readyQ,a1						; a1 = pointer to list of ready queues
00:000001BA D3C2            	   333: 	add.l d2,a1							; a1 = pointer to queue set
00:000001BC 36311000        	   334: 	move.w (a1,d1.w),d3			; d3 = old head of list
00:000001C0 6D4E            	   335: 	blt .nextQ							; anything on list?, if not go next queue
00:000001C2 3003            	   336: 	move.w d3,d0						; d0 = old head of list
00:000001C4 6100FE62        	   337: 	bsr TCBHandleToPointer
00:000001C8 2448            	   338: 	move.l a0,a2						; a2 = pointer to old head of list
00:000001CA 3A2A007C        	   339: 	move.w TCBNext(a2),d5		; remove head of list from list
00:000001CE BA80            	   340: 	cmp.l d0,d5							; removing last TCB?
00:000001D0 6736            	   341: 	beq .removeLast
00:000001D2 3C05            	   342: 	move.w d5,d6						; d6 = next on list
00:000001D4 3005            	   343: 	move.w d5,d0						; d0 = next on list
00:000001D6 6100FE50        	   344: 	bsr TCBHandleToPointer	; a0 = pointer to next TCB on list
00:000001DA 3A2A0080        	   345: 	move.w TCBPrev(a2),d5		; d5 = previous TCB from head
00:000001DE 31450080        	   346: 	move.w d5,TCBPrev(a0)		; next->prev = head->prev
00:000001E2 3005            	   347: 	move.w d5,d0
00:000001E4 6100FE42        	   348: 	bsr TCBHandleToPointer	; a0 = pointer to previous TCB from head
00:000001E8 3146007C        	   349: 	move.w d6,TCBNext(a0)		; head->prev->next = next
                            	   350: .0003
00:000001EC 33861000        	   351: 	move.w d6,(a1,d1.w)			; reset head of list to next
00:000001F0 3543007C        	   352: 	move.w d3,TCBNext(a2)		; point links back to self
00:000001F4 35430080        	   353: 	move.w d3,TCBPrev(a2)
00:000001F8 3003            	   354: 	move.w d3,d0						; return handle in d0
00:000001FA 48C0            	   355: 	ext.l d0
00:000001FC 204A            	   356: 	move.l a2,a0						; return pointer in a0
                            	   357: .0004
00:000001FE 610001A6        	   358: 	bsr UnlockSysSemaphore
00:00000202 4CDF0E7E        	   359: 	movem.l	(a7)+,d1-d6/a1-a3
00:00000206 4E75            	   360: 	rts
                            	   361: .removeLast
00:00000208 7CFF            	   362: 	moveq #-1,d6						; set head to negative when removing last
00:0000020A 33861002        	   363: 	move.w d6,2(a1,d1.w)		; tail = negative
00:0000020E 60DC            	   364: 	bra .0003
                            	   365: .nextQ
00:00000210 5841            	   366: 	addi.w #4,d1						; increment queue number by lword
00:00000212 0241001C        	   367: 	andi.w #$1C,d1					; limit to number of queues
00:00000216 51CCFF9C        	   368: 	dbra d4,.0002						; go back and check the next queue
00:0000021A 70FF            	   369: 	moveq #-1,d0						; return handle < 0 if nothing in any queue
00:0000021C 91C8            	   370: 	suba.l a0,a0						; and NULL pointer
00:0000021E 60DE            	   371: 	bra	.0004								; return NULL pointer if nothing in any queue
                            	   372: 
                            	   373: ;------------------------------------------------------------------------------
                            	   374: ; Remove a thread from the timeout list.
                            	   375: ; Called when a mailbox is freed and a thread is waiting at the
                            	   376: ; mailbox.
                            	   377: ;
                            	   378: ; Parameters:
                            	   379: ;		B = task id to remove
                            	   380: ; Modifies:
                            	   381: ;		none
                            	   382: ; Returns:
                            	   383: ;		none
                            	   384: ;------------------------------------------------------------------------------
                            	   385: 	if 0
                            	   386: RemoveFromTimeoutList:
                            	   387: 	pshs	d,w,x,y,u
                            	   388: 	cmpb	TimeoutList			; head of list?
                            	   389: 	beq		0001f
                            	   390: 	lbsr	TCBHandleToPointer
                            	   391: 	tfr		d,x
                            	   392: 	ldb		TCBNext,x
                            	   393: 	clra
                            	   394: 	tfr		d,u
                            	   395: 	ldf		TCBPrev,x
                            	   396: 	lbsr	TCBHandleToPointer
                            	   397: 	tfr		d,y
                            	   398: 	stf		TCBPrev,y
                            	   399: 	tfr		f,b
                            	   400: 	clra
                            	   401: 	lbsr	TCBHandleToPointer
                            	   402: 	tfr		d,y
                            	   403: 	tfr		u,d
                            	   404: 	stb		TCBNext,y
                            	   405: 	bra		0002f
                            	   406: 	; Removing from head of timeout list
                            	   407: 0001:
                            	   408: 	lbsr	TCBHandleToPointer
                            	   409: 	tfr		d,x
                            	   410: 	ldb		TCBNext,x
                            	   411: 	stb		TimeoutList		; set new head of list
                            	   412: 	clra
                            	   413: 	lbsr	TCBHandleToPointer
                            	   414: 	tfr		d,y
                            	   415: 	clrb
                            	   416: 	stb		TCBPrev,y			; next->prev = NULL
                            	   417: 0002:
                            	   418: 	clrd
                            	   419: 	std		TCBNext,x			; next = NULL
                            	   420: 	std		TCBPrev,x			; prev = NULL
                            	   421: 	puls	d,w,x,y,u,pc
                            	   422: 	
                            	   423: ;// ----------------------------------------------------------------------------
                            	   424: ;// Pop the top entry from the timeout list.
                            	   425: ;// ----------------------------------------------------------------------------
                            	   426: ;
                            	   427: ;hTCB PopTimeoutList()
                            	   428: ;{
                            	   429: ;    TCB *p;
                            	   430: ;    hTCB h;
                            	   431: ;
                            	   432: ;    h = TimeoutList;
                            	   433: ;    if (TimeoutList > 0 && TimeoutList < NR_TCB) {
                            	   434: ;        TimeoutList = tcbs[TimeoutList].next;
                            	   435: ;        if (TimeoutList >= 0 && TimeoutList < NR_TCB) {
                            	   436: ;            tcbs[TimeoutList].prev = h->prev;
                            	   437: ;            h->prev->next = TimeoutList;
                            	   438: ;        }
                            	   439: ;    }
                            	   440: ;    return h;
                            	   441: ;}
                            	   442: ;
                            	   443: ; Returns:
                            	   444: ;		B = task at top of list
                            	   445: ;
                            	   446: 
                            	   447: PopTimeoutList:
                            	   448: 	pshs	w,x,y
                            	   449: 	ldb		TimeoutList
                            	   450: 	pshs	b
                            	   451: 	beq		0001f
                            	   452: 	cmpb	#NR_TCB
                            	   453: 	bhs		0001f
                            	   454: 	bsr		TCBHandleToPointer
                            	   455: 	tfr		d,x
                            	   456: 	ldb		TCBNext,x
                            	   457: 	tfr		b,f
                            	   458: 	lde		TCBPrev,x
                            	   459: 	stb		TimeoutList
                            	   460: 	beq		0001f
                            	   461: 	cmpb	#NR_TCB
                            	   462: 	bhs		0001f
                            	   463: 	bsr		TCBHandleToPointer
                            	   464: 	tfr		d,y
                            	   465: 	ste		TCBPrev,y
                            	   466: 	tfr		e,b
                            	   467: 	bsr		TCBHandleToPointer
                            	   468: 	tfr		d,y
                            	   469: 	stf		TCBNext,y
                            	   470: 	clr		TCBPrev,x
                            	   471: 	clr		TCBNext,x
                            	   472: 0001:
                            	   473: 	puls	b
                            	   474: 	puls	x,y,w,pc
                            	   475: 
                            	   476: ; ----------------------------------------------------------------------------
                            	   477: ; ----------------------------------------------------------------------------
                            	   478: DispTwoSpace:
                            	   479: 	bsr	DispSpace
                            	   480: DispSpace:
                            	   481: 	ldb		#' '
                            	   482: 	swi
                            	   483: 	fcb		MF_OUTCH
                            	   484: 	rts
                            	   485: 
                            	   486: DumpTCBs:
                            	   487: 	swi
                            	   488: 	fcb		MF_CRLF
                            	   489: 	ldb		#1
                            	   490: 0002:
                            	   491: 	lbsr	TCBHandleToPointer
                            	   492: 	tfr		d,x
                            	   493: 	ldb		TCBtid,x
                            	   494: 	swi
                            	   495: 	fcb		MF_DisplayByteAsHex
                            	   496: 	bsr		DispSpace
                            	   497: 	ldb		TCBStatus,x
                            	   498: 	swi
                            	   499: 	fcb		MF_DisplayByteAsHex
                            	   500: 	bsr		DispTwoSpace
                            	   501: 	swi
                            	   502: 	fcb		MF_CRLF
                            	   503: 	ldb		TCBNext,x
                            	   504: 	beq		0001f
                            	   505: 	bra		0002b
                            	   506: 0001:
                            	   507: 	rts
                            	   508: 	
                            	   509: fcb	"TID Stat"
                            	   510: 	endif
                            	   511: 
                            	   512: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     9: 	include "..\Femtiki\source\kernel\Femtiki.x68"

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     1: 	code
                            	     2: 	even
                            	     3: ;------------------------------------------------------------------------------
                            	     4: ; Initialize the Femtiki OS.
                            	     5: ;------------------------------------------------------------------------------
                            	     6: 
                            	     7: FemtikiInit:
00:00000220 7000            	     8: 	moveq #0,d0
00:00000222 4E7B0012        	     9: 	movec d0,tr
00:00000226 6100FDD8        	    10: 	bsr TCBInit
00:0000022A 42390010031C    	    11: 	clr.b QueueCycle
                            	    12: FemtikiInitIRQ:
00:00000230 43FA00DC        	    13: 	lea FemtikiTimerIRQ,a1						; Set timer IRQ vector to Femtiki
00:00000234 4E7A8801        	    14: 	movec vbr,a0
00:00000238 21490078        	    15: 	move.l a1,30*4(a0)								; vector #30
00:0000023C 4E75            	    16: 	rts
                            	    17: 
                            	    18: ;------------------------------------------------------------------------------
                            	    19: ; Operating system call dispatcher.
                            	    20: ; On entry, the task state has been saved including the system stack pointer,
                            	    21: ; in the task control block.
                            	    22: ;------------------------------------------------------------------------------
                            	    23: 
                            	    24: OSCallTable
00:0000023E 0000            	    25: 	dc.w		0
                            	    26: 
                            	    27: 	even
                            	    28: CallOS:
00:00000240 2F08            	    29: 	move.l	a0,-(a7)
00:00000242 207900100224    	    30: 	move.l	RunningTCB,a0
00:00000248 48E8FFFF0004    	    31: 	movem.l d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,TCBRegs(a0)
00:0000024E 225F            	    32: 	move.l	(a7)+,a1
00:00000250 21490020        	    33: 	move.l	a1,32(a0)
00:00000254 4E7A9800        	    34: 	movec		usp,a1
00:00000258 21490044        	    35: 	move.l	a1,TCBUSP(a0)
00:0000025C 301F            	    36: 	move.w	(a7)+,d0					; pop the status register
00:0000025E 3140004C        	    37: 	move.w	d0,TCBSR(a0)			; save in TCB
00:00000262 225F            	    38: 	move.l	(a7)+,a1					; pop the program counter
00:00000264 5489            	    39: 	lea	2(a1),a1							; increment past inline callno argument
00:00000266 21490050        	    40: 	move.l	a1,TCBPC(a0)			; save PC in TCB
00:0000026A 214F0048        	    41: 	move.l	a7,TCBSSP(a0)			; finally save SSP
00:0000026E 3029FFFE        	    42: 	move.w	-2(a1),d0					; d0 = call number
00:00000272 E548            	    43: 	lsl.w		#2,d0							; make into table index
00:00000274 43FAFFC8        	    44: 	lea			OSCallTable,a1
00:00000278 22710000        	    45: 	move.l	(a1,d0.w),a1
00:0000027C 4E91            	    46: 	jsr			(a1)							; call the OS function
                            	    47: 	; Restore the thread context and return
00:0000027E 207900100224    	    48: 	move.l	RunningTCB,a0
00:00000284 2E780048        	    49: 	move.l	TCBSSP,a7
00:00000288 2F280050        	    50: 	move.l	TCBPC(a0),-(a7)		; setup the PC and the SR on the stack
00:0000028C 3F28004C        	    51: 	move.w	TCBSR(a0),-(a7)		; prep for RTE
00:00000290 20380044        	    52: 	move.l	TCBUSP,d0					; restore user stack pointer
00:00000294 4E7B0800        	    53: 	movec		d0,usp
00:00000298 4CE800FF0004    	    54: 	movem.l	TCBRegs(a0),d0/d1/d2/d3/d4/d5/d6/d7
00:0000029E 4CE87E00002C    	    55: 	movem.l TCBRegs+40(a0),a1/a2/a3/a4/a5/a6
00:000002A4 20680024        	    56: 	move.l	TCBRegs+32(a0),a0
00:000002A8 4E73            	    57: 	rte
                            	    58: 
                            	    59: ;------------------------------------------------------------------------------
                            	    60: ; Get a pointer to the currently running TCB.
                            	    61: ;
                            	    62: ; Returns:
                            	    63: ;		a0 = pointer to running TCB
                            	    64: ;------------------------------------------------------------------------------
                            	    65: 
                            	    66: GetRunningTCBPointer:
00:000002AA 48E7C000        	    67: 	movem.l d0/d1,-(a7)
00:000002AE 4E7A0012        	    68: 	movec tr,d0
00:000002B2 6100FD74        	    69: 	bsr TCBHandleToPointer
00:000002B6 028000000FFF    	    70: 	andi.l #MAX_TID,d0		; limit to # threads
00:000002BC 4CDF0003        	    71: 	movem.l (a7)+,d0/d1
00:000002C0 4E75            	    72: 	rts
                            	    73: 
                            	    74: ; ----------------------------------------------------------------------------
                            	    75: ; Select a thread to run. Relatively easy. All that needs to be done is to
                            	    76: ; keep popping the queue until a valid running task is found. There should
                            	    77: ; always be at least one thread in the queue.
                            	    78: ;
                            	    79: ; Modifies:
                            	    80: ;		none
                            	    81: ; Returns:
                            	    82: ;		d0 = handle of the next thread to run
                            	    83: ; ----------------------------------------------------------------------------
                            	    84: 
                            	    85: SelectThreadToRun:
                            	    86: .0001										; keep popping tasks from the readyQ until a valid one
00:000002C2 6100FEB6        	    87: 	bsr	TCBPopReadyQueue	; is found.
00:000002C6 4A40            	    88: 	tst.w d0
00:000002C8 6B0C            	    89: 	bmi	.0002
00:000002CA 0C2800800054    	    90: 	cmpi.b #TS_RUNNING,TCBStatus(a0)	; ensure the thread is to be running
00:000002D0 66F0            	    91: 	bne	.0001													; if not, go get the next thread
00:000002D2 6000FE04        	    92: 	bra	TCBInsertIntoReadyQueue				; insert thread back into queue
                            	    93: 	; Nothing in queues? There is supposed to be. Add the OS task to the queue.
                            	    94: .0002
00:000002D6 4E7A8013        	    95: 	movec tcba,a0
00:000002DA 117C00800054    	    96: 	move.b #TS_RUNNING,TCBStatus(a0)	; flag as RUNNING
00:000002E0 117C00040055    	    97: 	move.b #4,TCBPriority(a0)					; OS has normal priority
00:000002E6 7000            	    98: 	moveq #0,d0												; fast pointer to handle
00:000002E8 6000FDEE        	    99: 	bra TCBInsertIntoReadyQueue
                            	   100: 
                            	   101: ; ----------------------------------------------------------------------------
                            	   102: ; Update the IRQ live indicator on screen.
                            	   103: ; ----------------------------------------------------------------------------
                            	   104: 
                            	   105: UpdateIRQLive:
00:000002EC 227900040004    	   106: 	move.l TextScr,a1					; a1 = screen address
00:000002F2 2411            	   107: 	move.l (a1),d2
00:000002F4 E15A            	   108: 	rol.w	#8,d2								; reverse byte order of d2
00:000002F6 4842            	   109: 	swap d2
00:000002F8 E15A            	   110: 	rol.w	#8,d2
00:000002FA 06010030        	   111: 	addi.b #'0',d1						; binary to ascii core number
00:000002FE D202            	   112: 	add.b	d2,d1
00:00000300 E159            	   113: 	rol.w	#8,d1								; put bytes back in order
00:00000302 4841            	   114: 	swap d1
00:00000304 E159            	   115: 	rol.w	#8,d1
00:00000306 23410004        	   116: 	move.l d1,4(a1)						; update onscreen IRQ flag
00:0000030A 5291            	   117: 	addi.l #1,(a1)						; flashy colors
00:0000030C 4E75            	   118: 	rts
                            	   119: 
                            	   120: ; ----------------------------------------------------------------------------
                            	   121: ; Femtiki IRQ service routine. This is where a thread switch can occur so,
                            	   122: ; the thread context is saved and restored.
                            	   123: ; ----------------------------------------------------------------------------
                            	   124: 
                            	   125: FemtikiTimerIRQ:
00:0000030E 46FC2600        	   126: 	move.w #$2600,sr							; disable lower level IRQs
00:00000312 2F00            	   127: 	move.l d0,-(a7)
00:00000314 2F08            	   128: 	move.l a0,-(a7)
00:00000316 6192            	   129: 	bsr GetRunningTCBPointer			; a0 = pointer to running TCB
00:00000318 48E8FFFF0004    	   130: 	movem.l #$FFFF,TCBRegs(a0)		; save all registers
00:0000031E 201F            	   131: 	move.l (a7)+,d0
00:00000320 21400020        	   132: 	move.l d0,32(a0)							; save original a0 value
00:00000324 201F            	   133: 	move.l (a7)+,d0
00:00000326 2080            	   134: 	move.l d0,(a0)								; save original d0 value
00:00000328 4E7A0800        	   135: 	movec usp,d0									; save user stack pointer
00:0000032C 21400044        	   136: 	move.l d0,TCBUSP(a0)
00:00000330 2E7C00041BFC    	   137: 	move.l #TimerStack,a7					; reset stack pointer
00:00000336 4E7A1FE0        	   138: 	movec	coreno,d1								; d1 = core number
00:0000033A 0C010002        	   139: 	cmpi.b #2,d1
00:0000033E 6612            	   140: 	bne.s	.0002
00:00000340 23FC1D000000FD26	   141: 	move.l #$1D000000,PLIC+$14		; reset edge sense circuit
00:00000348 0014
00:0000034A 13FC0001000400A0	   142: 	move.b #1,IRQFlag							; set IRQ flag for TinyBasic shell
                            	   143: .0002
00:00000352 6198            	   144: 	bsr UpdateIRQLive							; Update IRQ live indicator
                            	   145: ;	bsr ReceiveMsg								; Check for RPC
00:00000354 4E7A0FF0        	   146: 	movec tick,d0									; Update time accounting
00:00000358 21400070        	   147: 	move.l d0,TCBEndTick(a0)			; compute number of ticks thread was running
00:0000035C 90A8006C        	   148: 	sub.l	TCBStartTick(a0),d0
00:00000360 D1A80074        	   149: 	add.l	d0,TCBTicks(a0)					; add to cumulative ticks
00:00000364 117C00200054    	   150: 	move.b #TS_PREEMPT,TCBStatus(a0)	; set thread status to PREEMPT
00:0000036A 6100FF56        	   151: 	bsr	SelectThreadToRun					; d0 = TCB handle
00:0000036E 4E7B0012        	   152: 	movec d0,tr										; set running thread number in tr
00:00000372 6100FF36        	   153: 	bsr GetRunningTCBPointer			; a0 = pointer to TCB
00:00000376 117C00800054    	   154: 	move.b #TS_RUNNING,TCBStatus(a0)	; set thread status to RUNNING
00:0000037C 4E7A0FF0        	   155: 	movec	tick,d0
00:00000380 2140006C        	   156: 	move.l d0,TCBStartTick(a0)		; record starting tick
00:00000384 20280044        	   157: 	move.l TCBUSP(a0),d0					; restore user stack pointer
00:00000388 4E7B0800        	   158: 	movec d0,usp
00:0000038C 4CE8FFFF0004    	   159: 	movem.l TCBRegs(a0),#$FFFF		; restore all registers
00:00000392 504F            	   160: 	addq #8,sp										; "pop" d0/a0, saved stack pointer is off by 8
00:00000394 4E73            	   161: 	rte														; and return
                            	   162: 
                            	   163: 	include "..\Femtiki\source\kernel\Semaphore.x68"

Source: "..\Femtiki\source\kernel\Semaphore.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;-------------------------------------------------------------------------------
                            	    38: ; Lock the system semaphore. Call the BIOS.
                            	    39: ;
                            	    40: ; Parameters:
                            	    41: ;		none
                            	    42: ; Returns:
                            	    43: ;		none
                            	    44: ;-------------------------------------------------------------------------------
                            	    45: 
                            	    46: LockSysSemaphore:
00:00000396 48E7C000        	    47: 	movem.l d0/d1,-(sp)
00:0000039A 7025            	    48: 	moveq #37,d0				; lock semaphore
00:0000039C 7208            	    49: 	moveq #FMTK_SEMA,d1
00:0000039E 4E4F            	    50: 	trap #15
00:000003A0 4CDF0003        	    51: 	movem.l (sp)+,d0/d1
00:000003A4 4E75            	    52: 	rts
                            	    53: 
                            	    54: 
                            	    55: ;-------------------------------------------------------------------------------
                            	    56: ; Unlock the system semaphore.
                            	    57: ;
                            	    58: ; Parameters:
                            	    59: ;		none
                            	    60: ; Returns:
                            	    61: ;		none
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: UnlockSysSemaphore:
00:000003A6 48E7C000        	    65: 	movem.l d0/d1,-(sp)
00:000003AA 7026            	    66: 	moveq #38,d0				; unlock semaphore
00:000003AC 7208            	    67: 	moveq #FMTK_SEMA,d1
00:000003AE 4E4F            	    68: 	trap #15
00:000003B0 4CDF0003        	    69: 	movem.l (sp)+,d0/d1
00:000003B4 4E75            	    70: 	rts
                            	    71: 
                            	    72: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	   164: 
                            	   165: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	    10: 

Source: "boot.x68"
                            	   133: 
                            	   134: DDATA EQU $FFFFFFF0     ; DS.L    3
                            	   135: HISPC EQU $FFFFFFFC     ; DS.L    1
                            	   136: SCREEN_FORMAT = 1
                            	   137: 
                            	   138: 	if HAS_MMU
                            	   139: TEXTREG		EQU	$1E3FF00	; virtual addresses
                            	   140: txtscreen	EQU	$1E00000
                            	   141: semamem		EQU	$1E50000
                            	   142: ACIA			EQU	$1E60000
                            	   143: ACIA_RX		EQU	0
                            	   144: ACIA_TX		EQU	0
                            	   145: ACIA_STAT	EQU	4
                            	   146: ACIA_CMD	EQU	8
                            	   147: ACIA_CTRL	EQU	12
                            	   148: I2C2 			equ $01E69010
                            	   149: I2C_PREL 	equ 0
                            	   150: I2C_PREH 	equ 1
                            	   151: I2C_CTRL 	equ 2
                            	   152: I2C_RXR 	equ 3
                            	   153: I2C_TXR 	equ 3
                            	   154: I2C_CMD 	equ 4
                            	   155: I2C_STAT 	equ 4
                            	   156: PLIC			EQU	$1E90000
                            	   157: MMU				EQU $FDC00000	; physical address
                            	   158: leds			EQU	$1EFFF00	; virtual addresses
                            	   159: keybd			EQU	$1EFFE00
                            	   160: KEYBD			EQU	$1EFFE00
                            	   161: RAND			EQU	$1EFFD00
                            	   162: RAND_NUM	EQU	$1EFFD00
                            	   163: RAND_STRM	EQU	$1EFFD04
                            	   164: RAND_MZ		EQU $1EFFD08
                            	   165: RAND_MW		EQU	$1EFFD0C
                            	   166: RST_REG		EQU	$1EFFC00
                            	   167: IO_BITMAP	EQU $1F00000
                            	   168: 	else
                            	   169: TEXTREG		EQU	$FD080000
                            	   170: txtscreen	EQU	$FD000000
                            	   171: MMU				EQU $FDC00000	; physical address
                            	   172: RST_REG		EQU	$FDFF0000
                            	   173: RAND			EQU	$FDFF4010
                            	   174: RAND_NUM	EQU	$FDFF4010
                            	   175: RAND_STRM	EQU	$FDFF4014
                            	   176: RAND_MZ		EQU $FDFF4018
                            	   177: RAND_MW		EQU	$FDFF401C
                            	   178: keybd			EQU	$FDFF8000
                            	   179: KEYBD			EQU	$FDFF8000
                            	   180: leds			EQU	$FDFFC000
                            	   181: ACIA			EQU	$FDFE0010
                            	   182: I2C2 			equ $FDFE4000
                            	   183: IO_BITMAP	EQU $FDE00000
                            	   184: FRAMEBUF	EQU	$FD208000
                            	   185: GFXACCEL	EQU	$FD210000
                            	   186: PSG				EQU $FD240000
                            	   187: I2C1 			equ $FD250000
                            	   188: ADAU1761 	equ $FD254000
                            	   189: PLIC			equ	$FD260000
                            	   190: SPI_MASTER1	equ	$FD280000
                            	   191: SPI_MASTER2	equ $FD284000
                            	   192: COPPER		equ $FD288000
                            	   193: semamem		equ	$FD300000
                            	   194: 
                            	   195: ACIA_RX		equ	0
                            	   196: ACIA_TX		equ	0
                            	   197: ACIA_STAT	equ	4
                            	   198: ACIA_CMD	equ	8
                            	   199: ACIA_CTRL	equ	12
                            	   200: I2C_PREL 	equ 0
                            	   201: I2C_PREH 	equ 1
                            	   202: I2C_CTRL 	equ 2
                            	   203: I2C_RXR 	equ 3
                            	   204: I2C_TXR 	equ 3
                            	   205: I2C_CMD 	equ 4
                            	   206: I2C_STAT 	equ 4
                            	   207: 
                            	   208: 	endif
                            	   209: 
                            	   210: SERIAL_SEMA	EQU	2
                            	   211: KEYBD_SEMA	EQU	3
                            	   212: RAND_SEMA		EQU	4
                            	   213: SCREEN_SEMA	EQU	5
                            	   214: MEMORY_SEMA EQU 6
                            	   215: TCB_SEMA 		EQU	7
                            	   216: FMTK_SEMA		EQU	8
                            	   217: 
                            	   218: macIRQ_proc	macro arg1
                            	   219: 	dc.l IRQ_proc\1
                            	   220: endm
                            	   221: 
                            	   222: macIRQ_proc_label	macro arg1
                            	   223: IRQ_proc\1:
                            	   224: endm
                            	   225: 
                            	   226: macHmash macro arg1
                            	   227: 	swap \1
                            	   228: 	eori.l #DEV_HMASH,\1
                            	   229: endm
                            	   230: 
                            	   231: macUnhmash macro arg1
                            	   232: 	eori.l #DEV_HMASH,\1
                            	   233: 	swap \1
                            	   234: endm
                            	   235: 
                            	   236: 	data
                            	   237: 	; 0
01:00000000 00040FFC        	   238: 	dc.l		$00040FFC
01:00000004 000003B8        	   239: 	dc.l		start
01:00000008 00009C4A        	   240: 	dc.l		bus_err
01:0000000C 0000A028        	   241: 	dc.l		addr_err
01:00000010 0000A076        	   242: 	dc.l		illegal_trap		* ILLEGAL instruction
01:00000014 00000000        	   243: 	dc.l		0
01:00000018 00002638        	   244: 	dc.l		chk_exception		; CHK
01:0000001C 0000277C        	   245: 	dc.l		EXCEPTION_7			* TRAPV
01:00000020 00000000        	   246: 	dc.l		0
01:00000024 00000000        	   247: 	dc.l		0
                            	   248: 	
                            	   249: 	; 10
01:00000028 00000000        	   250: 	dc.l		0
01:0000002C 00000000        	   251: 	dc.l		0
01:00000030 00000000        	   252: 	dc.l		0
01:00000034 00000000        	   253: 	dc.l		0
01:00000038 00000000        	   254: 	dc.l		0
01:0000003C 00000000        	   255: 	dc.l		0
01:00000040 00000000        	   256: 	dc.l		0
01:00000044 00000000        	   257: 	dc.l		0
01:00000048 00000000        	   258: 	dc.l		0
01:0000004C 00000000        	   259: 	dc.l		0
                            	   260: 	
                            	   261: 	; 20
01:00000050 00000000        	   262: 	dc.l		0
01:00000054 00000000        	   263: 	dc.l		0
01:00000058 00000000        	   264: 	dc.l		0
01:0000005C 00000000        	   265: 	dc.l		0
01:00000060 0000A014        	   266: 	dc.l		SpuriousIRQ
01:00000064 00000000        	   267: 	dc.l		0
01:00000068 00000000        	   268: 	dc.l		0
01:0000006C 00009FE2        	   269: 	dc.l		irq3_rout
01:00000070 00000000        	   270: 	dc.l		0
01:00000074 00000000        	   271: 	dc.l		0
                            	   272: 	
                            	   273: 	; 30
01:00000078 00009FA0        	   274: 	dc.l		TickIRQ						; IRQ 30 - timer / keyboard
01:0000007C 0000A016        	   275: 	dc.l		nmi_rout
01:00000080 00009F04        	   276: 	dc.l		io_trap						; TRAP zero
01:00000084 00000000        	   277: 	dc.l		0
01:00000088 00000000        	   278: 	dc.l		0
01:0000008C 00009C64        	   279: 	dc.l		trap3							; breakpoint
01:00000090 00000000        	   280: 	dc.l		0
01:00000094 00000000        	   281: 	dc.l		0
01:00000098 00000000        	   282: 	dc.l		0
01:0000009C 00000000        	   283: 	dc.l		0
                            	   284: 
                            	   285: 	; 40
01:000000A0 00000000        	   286: 	dc.l		0
01:000000A4 00000000        	   287: 	dc.l		0
01:000000A8 00000000        	   288: 	dc.l		0
01:000000AC 00000000        	   289: 	dc.l		0
01:000000B0 00000000        	   290: 	dc.l		0
01:000000B4 00000000        	   291: 	dc.l		0
01:000000B8 00000000        	   292: 	dc.l		0
01:000000BC 00007B4A        	   293: 	dc.l		TRAP15
01:000000C0 00000000        	   294: 	dc.l		0
01:000000C4 00000000        	   295: 	dc.l		0
                            	   296: 
                            	   297: 	; 50	
01:000000C8 00000000        	   298: 	dc.l		0
01:000000CC 00000000        	   299: 	dc.l		0
01:000000D0 00000000        	   300: 	dc.l		0
01:000000D4 00000000        	   301: 	dc.l		0
01:000000D8 00000000        	   302: 	dc.l		0
01:000000DC 00000000        	   303: 	dc.l		0
01:000000E0 00000000        	   304: 	dc.l		0
01:000000E4 00000000        	   305: 	dc.l		0
01:000000E8 00000000        	   306: 	dc.l		0
01:000000EC 0000A08C        	   307: 	dc.l		io_irq
                            	   308: 
                            	   309: 	; 60
01:000000F0 00000B9E        	   310: 	dc.l		KeybdIRQ
01:000000F4 000017F8        	   311: 	dc.l		SerialIRQ
01:000000F8 00000000        	   312: 	dc.l		0
01:000000FC 0000A03E        	   313: 	dc.l		brdisp_trap
                            	   314: 	
                            	   315: 	; 64
                            	   316: 
                            	   317: IRQ_trampolines:
                            	   318: ;	rept 192
                            	   319: ;	macIRQ_proc REPTN
                            	   320: ;	endr
                            	   321: 
                            	   322: 	org			$400
                            	   323: 
                            	   324: irq_list_tbl:
                            	   325: 	rept 192
                            	   326: 	dc.l 0
                            	   327: 	dc.l 0
                            	   328: 	endr
01:00000400 00000000        	     1R 	dc.l 0
01:00000404 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000408 00000000        	     1R 	dc.l 0
01:0000040C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000410 00000000        	     1R 	dc.l 0
01:00000414 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000418 00000000        	     1R 	dc.l 0
01:0000041C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000420 00000000        	     1R 	dc.l 0
01:00000424 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000428 00000000        	     1R 	dc.l 0
01:0000042C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000430 00000000        	     1R 	dc.l 0
01:00000434 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000438 00000000        	     1R 	dc.l 0
01:0000043C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000440 00000000        	     1R 	dc.l 0
01:00000444 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000448 00000000        	     1R 	dc.l 0
01:0000044C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000450 00000000        	     1R 	dc.l 0
01:00000454 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000458 00000000        	     1R 	dc.l 0
01:0000045C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000460 00000000        	     1R 	dc.l 0
01:00000464 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000468 00000000        	     1R 	dc.l 0
01:0000046C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000470 00000000        	     1R 	dc.l 0
01:00000474 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000478 00000000        	     1R 	dc.l 0
01:0000047C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000480 00000000        	     1R 	dc.l 0
01:00000484 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000488 00000000        	     1R 	dc.l 0
01:0000048C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000490 00000000        	     1R 	dc.l 0
01:00000494 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000498 00000000        	     1R 	dc.l 0
01:0000049C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004A0 00000000        	     1R 	dc.l 0
01:000004A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004A8 00000000        	     1R 	dc.l 0
01:000004AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004B0 00000000        	     1R 	dc.l 0
01:000004B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004B8 00000000        	     1R 	dc.l 0
01:000004BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004C0 00000000        	     1R 	dc.l 0
01:000004C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004C8 00000000        	     1R 	dc.l 0
01:000004CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004D0 00000000        	     1R 	dc.l 0
01:000004D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004D8 00000000        	     1R 	dc.l 0
01:000004DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004E0 00000000        	     1R 	dc.l 0
01:000004E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004E8 00000000        	     1R 	dc.l 0
01:000004EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004F0 00000000        	     1R 	dc.l 0
01:000004F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004F8 00000000        	     1R 	dc.l 0
01:000004FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000500 00000000        	     1R 	dc.l 0
01:00000504 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000508 00000000        	     1R 	dc.l 0
01:0000050C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000510 00000000        	     1R 	dc.l 0
01:00000514 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000518 00000000        	     1R 	dc.l 0
01:0000051C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000520 00000000        	     1R 	dc.l 0
01:00000524 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000528 00000000        	     1R 	dc.l 0
01:0000052C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000530 00000000        	     1R 	dc.l 0
01:00000534 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000538 00000000        	     1R 	dc.l 0
01:0000053C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000540 00000000        	     1R 	dc.l 0
01:00000544 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000548 00000000        	     1R 	dc.l 0
01:0000054C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000550 00000000        	     1R 	dc.l 0
01:00000554 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000558 00000000        	     1R 	dc.l 0
01:0000055C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000560 00000000        	     1R 	dc.l 0
01:00000564 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000568 00000000        	     1R 	dc.l 0
01:0000056C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000570 00000000        	     1R 	dc.l 0
01:00000574 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000578 00000000        	     1R 	dc.l 0
01:0000057C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000580 00000000        	     1R 	dc.l 0
01:00000584 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000588 00000000        	     1R 	dc.l 0
01:0000058C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000590 00000000        	     1R 	dc.l 0
01:00000594 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000598 00000000        	     1R 	dc.l 0
01:0000059C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005A0 00000000        	     1R 	dc.l 0
01:000005A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005A8 00000000        	     1R 	dc.l 0
01:000005AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005B0 00000000        	     1R 	dc.l 0
01:000005B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005B8 00000000        	     1R 	dc.l 0
01:000005BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005C0 00000000        	     1R 	dc.l 0
01:000005C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005C8 00000000        	     1R 	dc.l 0
01:000005CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005D0 00000000        	     1R 	dc.l 0
01:000005D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005D8 00000000        	     1R 	dc.l 0
01:000005DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005E0 00000000        	     1R 	dc.l 0
01:000005E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005E8 00000000        	     1R 	dc.l 0
01:000005EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005F0 00000000        	     1R 	dc.l 0
01:000005F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005F8 00000000        	     1R 	dc.l 0
01:000005FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000600 00000000        	     1R 	dc.l 0
01:00000604 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000608 00000000        	     1R 	dc.l 0
01:0000060C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000610 00000000        	     1R 	dc.l 0
01:00000614 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000618 00000000        	     1R 	dc.l 0
01:0000061C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000620 00000000        	     1R 	dc.l 0
01:00000624 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000628 00000000        	     1R 	dc.l 0
01:0000062C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000630 00000000        	     1R 	dc.l 0
01:00000634 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000638 00000000        	     1R 	dc.l 0
01:0000063C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000640 00000000        	     1R 	dc.l 0
01:00000644 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000648 00000000        	     1R 	dc.l 0
01:0000064C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000650 00000000        	     1R 	dc.l 0
01:00000654 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000658 00000000        	     1R 	dc.l 0
01:0000065C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000660 00000000        	     1R 	dc.l 0
01:00000664 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000668 00000000        	     1R 	dc.l 0
01:0000066C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000670 00000000        	     1R 	dc.l 0
01:00000674 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000678 00000000        	     1R 	dc.l 0
01:0000067C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000680 00000000        	     1R 	dc.l 0
01:00000684 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000688 00000000        	     1R 	dc.l 0
01:0000068C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000690 00000000        	     1R 	dc.l 0
01:00000694 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000698 00000000        	     1R 	dc.l 0
01:0000069C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006A0 00000000        	     1R 	dc.l 0
01:000006A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006A8 00000000        	     1R 	dc.l 0
01:000006AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006B0 00000000        	     1R 	dc.l 0
01:000006B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006B8 00000000        	     1R 	dc.l 0
01:000006BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006C0 00000000        	     1R 	dc.l 0
01:000006C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006C8 00000000        	     1R 	dc.l 0
01:000006CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006D0 00000000        	     1R 	dc.l 0
01:000006D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006D8 00000000        	     1R 	dc.l 0
01:000006DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006E0 00000000        	     1R 	dc.l 0
01:000006E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006E8 00000000        	     1R 	dc.l 0
01:000006EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006F0 00000000        	     1R 	dc.l 0
01:000006F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006F8 00000000        	     1R 	dc.l 0
01:000006FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000700 00000000        	     1R 	dc.l 0
01:00000704 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000708 00000000        	     1R 	dc.l 0
01:0000070C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000710 00000000        	     1R 	dc.l 0
01:00000714 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000718 00000000        	     1R 	dc.l 0
01:0000071C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000720 00000000        	     1R 	dc.l 0
01:00000724 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000728 00000000        	     1R 	dc.l 0
01:0000072C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000730 00000000        	     1R 	dc.l 0
01:00000734 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000738 00000000        	     1R 	dc.l 0
01:0000073C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000740 00000000        	     1R 	dc.l 0
01:00000744 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000748 00000000        	     1R 	dc.l 0
01:0000074C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000750 00000000        	     1R 	dc.l 0
01:00000754 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000758 00000000        	     1R 	dc.l 0
01:0000075C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000760 00000000        	     1R 	dc.l 0
01:00000764 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000768 00000000        	     1R 	dc.l 0
01:0000076C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000770 00000000        	     1R 	dc.l 0
01:00000774 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000778 00000000        	     1R 	dc.l 0
01:0000077C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000780 00000000        	     1R 	dc.l 0
01:00000784 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000788 00000000        	     1R 	dc.l 0
01:0000078C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000790 00000000        	     1R 	dc.l 0
01:00000794 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000798 00000000        	     1R 	dc.l 0
01:0000079C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007A0 00000000        	     1R 	dc.l 0
01:000007A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007A8 00000000        	     1R 	dc.l 0
01:000007AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007B0 00000000        	     1R 	dc.l 0
01:000007B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007B8 00000000        	     1R 	dc.l 0
01:000007BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007C0 00000000        	     1R 	dc.l 0
01:000007C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007C8 00000000        	     1R 	dc.l 0
01:000007CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007D0 00000000        	     1R 	dc.l 0
01:000007D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007D8 00000000        	     1R 	dc.l 0
01:000007DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007E0 00000000        	     1R 	dc.l 0
01:000007E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007E8 00000000        	     1R 	dc.l 0
01:000007EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007F0 00000000        	     1R 	dc.l 0
01:000007F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007F8 00000000        	     1R 	dc.l 0
01:000007FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000800 00000000        	     1R 	dc.l 0
01:00000804 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000808 00000000        	     1R 	dc.l 0
01:0000080C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000810 00000000        	     1R 	dc.l 0
01:00000814 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000818 00000000        	     1R 	dc.l 0
01:0000081C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000820 00000000        	     1R 	dc.l 0
01:00000824 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000828 00000000        	     1R 	dc.l 0
01:0000082C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000830 00000000        	     1R 	dc.l 0
01:00000834 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000838 00000000        	     1R 	dc.l 0
01:0000083C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000840 00000000        	     1R 	dc.l 0
01:00000844 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000848 00000000        	     1R 	dc.l 0
01:0000084C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000850 00000000        	     1R 	dc.l 0
01:00000854 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000858 00000000        	     1R 	dc.l 0
01:0000085C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000860 00000000        	     1R 	dc.l 0
01:00000864 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000868 00000000        	     1R 	dc.l 0
01:0000086C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000870 00000000        	     1R 	dc.l 0
01:00000874 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000878 00000000        	     1R 	dc.l 0
01:0000087C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000880 00000000        	     1R 	dc.l 0
01:00000884 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000888 00000000        	     1R 	dc.l 0
01:0000088C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000890 00000000        	     1R 	dc.l 0
01:00000894 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000898 00000000        	     1R 	dc.l 0
01:0000089C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008A0 00000000        	     1R 	dc.l 0
01:000008A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008A8 00000000        	     1R 	dc.l 0
01:000008AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008B0 00000000        	     1R 	dc.l 0
01:000008B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008B8 00000000        	     1R 	dc.l 0
01:000008BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008C0 00000000        	     1R 	dc.l 0
01:000008C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008C8 00000000        	     1R 	dc.l 0
01:000008CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008D0 00000000        	     1R 	dc.l 0
01:000008D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008D8 00000000        	     1R 	dc.l 0
01:000008DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008E0 00000000        	     1R 	dc.l 0
01:000008E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008E8 00000000        	     1R 	dc.l 0
01:000008EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008F0 00000000        	     1R 	dc.l 0
01:000008F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008F8 00000000        	     1R 	dc.l 0
01:000008FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000900 00000000        	     1R 	dc.l 0
01:00000904 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000908 00000000        	     1R 	dc.l 0
01:0000090C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000910 00000000        	     1R 	dc.l 0
01:00000914 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000918 00000000        	     1R 	dc.l 0
01:0000091C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000920 00000000        	     1R 	dc.l 0
01:00000924 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000928 00000000        	     1R 	dc.l 0
01:0000092C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000930 00000000        	     1R 	dc.l 0
01:00000934 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000938 00000000        	     1R 	dc.l 0
01:0000093C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000940 00000000        	     1R 	dc.l 0
01:00000944 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000948 00000000        	     1R 	dc.l 0
01:0000094C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000950 00000000        	     1R 	dc.l 0
01:00000954 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000958 00000000        	     1R 	dc.l 0
01:0000095C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000960 00000000        	     1R 	dc.l 0
01:00000964 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000968 00000000        	     1R 	dc.l 0
01:0000096C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000970 00000000        	     1R 	dc.l 0
01:00000974 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000978 00000000        	     1R 	dc.l 0
01:0000097C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000980 00000000        	     1R 	dc.l 0
01:00000984 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000988 00000000        	     1R 	dc.l 0
01:0000098C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000990 00000000        	     1R 	dc.l 0
01:00000994 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000998 00000000        	     1R 	dc.l 0
01:0000099C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009A0 00000000        	     1R 	dc.l 0
01:000009A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009A8 00000000        	     1R 	dc.l 0
01:000009AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009B0 00000000        	     1R 	dc.l 0
01:000009B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009B8 00000000        	     1R 	dc.l 0
01:000009BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009C0 00000000        	     1R 	dc.l 0
01:000009C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009C8 00000000        	     1R 	dc.l 0
01:000009CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009D0 00000000        	     1R 	dc.l 0
01:000009D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009D8 00000000        	     1R 	dc.l 0
01:000009DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009E0 00000000        	     1R 	dc.l 0
01:000009E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009E8 00000000        	     1R 	dc.l 0
01:000009EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009F0 00000000        	     1R 	dc.l 0
01:000009F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009F8 00000000        	     1R 	dc.l 0
01:000009FC 00000000        	     2R 	dc.l 0
                            	     3R 	
                            	   329: 
                            	   330: 	org			$A00
                            	   331: 
                            	   332: ;-------------------------------------------------------------------------------
                            	   333: ;-------------------------------------------------------------------------------
                            	   334: 
                            	   335: ; BIOS variables which must be local (not shared) to each core
                            	   336: 
                            	   337: CursorRow	equ		$40000
                            	   338: CursorCol	equ		$40001
                            	   339: TextPos		equ		$40002
                            	   340: TextCurpos	equ	$40002
                            	   341: TextScr			equ	$40004
                            	   342: S19StartAddress	equ	$40008
                            	   343: KeybdEcho		equ	$4000C
                            	   344: KeybdWaitFlag	equ	$4000D
                            	   345: CmdBuf			equ $40040
                            	   346: CmdBufEnd		equ	$40080
                            	   347: fgColor			equ	$40084
                            	   348: bkColor			equ	$40088
                            	   349: TextRows		equ	$4008C
                            	   350: TextCols		equ	$4008D
                            	   351: _fpTextIncr	equ $40094
                            	   352: _canary			equ $40098
                            	   353: tickcnt			equ $4009C
                            	   354: IRQFlag			equ $400A0
                            	   355: InputDevice	equ $400A4
                            	   356: OutputDevice	equ $400A8
                            	   357: Regsave			equ	$40100
                            	   358: numBreakpoints	equ		8
                            	   359: BreakpointFlag	equ		$40200
                            	   360: NumSetBreakpoints	equ	$40202	; to $40203
                            	   361: Breakpoints			equ		$40220	; to $40240
                            	   362: BreakpointWords	equ		$40280	; to $402A0
                            	   363: fpBuf       equ $402C0
                            	   364: ;RunningTCB  equ $40300
                            	   365: _exp equ $40500
                            	   366: _digit equ $40504
                            	   367: _width equ $40508
                            	   368: _E equ $4050C
                            	   369: _digits_before_decpt equ $40510
                            	   370: _precision equ $40514
                            	   371: _fpBuf equ $40520	; to $40560
                            	   372: _fpWork equ $40600
                            	   373: _dasmbuf	equ	$40800
                            	   374: OFFSET equ $40880
                            	   375: pen_color equ $40890
                            	   376: gr_x equ $40894
                            	   377: gr_y equ $40898
                            	   378: gr_width equ $4089C
                            	   379: gr_height equ $408A0
                            	   380: gr_bitmap_screen equ $408A4
                            	   381: gr_raster_op equ $408A8
                            	   382: gr_double_buffer equ $408AC
                            	   383: gr_bitmap_buffer equ $408B0
                            	   384: sys_switches equ $408B8
                            	   385: gfxaccel_ctrl equ $408C0
                            	   386: m_z equ $408D0
                            	   387: m_w equ $408D4
                            	   388: next_m_z equ $408D8
                            	   389: next_m_w equ $408DC
                            	   390: TimeBuf equ $408E0
                            	   391: EightPixels equ $40100000	; to $40200020
                            	   392: 
                            	   393: null_dcb equ $0040A00		; 0
                            	   394: keybd_dcb equ null_dcb+DCB_SIZE	; 1
                            	   395: textvid_dcb equ keybd_dcb+DCB_SIZE	; 2
                            	   396: err_dcb equ textvid_dcb+DCB_SIZE		; 3
                            	   397: serial_dcb equ err_dcb+DCB_SIZE*2		; 5
                            	   398: framebuf_dcb equ serial_dcb+DCB_SIZE	; 6
                            	   399: gfxaccel_dcb equ framebuf_dcb+DCB_SIZE	; 7
                            	   400: rtc_dcb equ gfxaccel_dcb+DCB_SIZE		; 8
                            	   401: 
                            	   402: spi_buff equ $0042000
                            	   403: 
                            	   404: TimerStack	equ	$41BFC
                            	   405: 
                            	   406: ; Keyboard buffer is in shared memory
                            	   407: IOFocus			EQU	$00100000
                            	   408: memend			equ $00100004
                            	   409: KeybdLEDs		equ	$0010000E
                            	   410: _KeyState1	equ	$0010000F
                            	   411: _KeyState2	equ	$00100010
                            	   412: _KeybdHead	equ	$00100011
                            	   413: _KeybdTail	equ	$00100012
                            	   414: _KeybdCnt		equ	$00100013
                            	   415: KeybdID			equ	$00100018
                            	   416: _Keybd_tick	equ $0001001C
                            	   417: _KeybdBuf		equ	$00100020
                            	   418: _KeybdOBuf	equ	$00100080
                            	   419: S19Checksum	equ	$00100150
                            	   420: SerTailRcv	equ	$00100160
                            	   421: SerHeadRcv	equ	$00100162
                            	   422: SerRcvXon		equ	$00100164
                            	   423: SerRcvXoff	equ	$00100165
                            	   424: SerTailXmit	equ	$00100166
                            	   425: SerHeadXmit	equ	$00100168
                            	   426: SerXmitXoff	equ	$0010016A
                            	   427: SerRcvBuf		equ	$00101000
                            	   428: SerXmitBuf	equ	$00102000
                            	   429: RTCBuf			equ $00100200	; to $0010023F
                            	   430: 
                            	   431: 	code
                            	   432: 	align		2
                            	   433: start:
                            	   434: ;	fadd (a0)+,fp2
00:000003B8 13FC0001FDFFC000	   435: 	move.b #1,leds
00:000003C0 46FC2700        	   436: 	move.w #$2700,sr					; enable level 6 and higher interrupts
00:000003C4 7000            	   437: 	moveq #0,d0								; set address space zero
00:000003C6 4E7B0003        	   438: 	movec d0,asid
                            	   439: 	; Setup circuit select signals
00:000003CA 203CFDC00000    	   440: 	move.l #MMU,d0
00:000003D0 4E7B0014        	   441: 	movec d0,mmus
                            	   442: 	if HAS_MMU
                            	   443: 		move.l #$01F00000,d0			; set virtual address for iop bitmap
                            	   444: 		movec d0,iops
                            	   445: 		move.l #$01E00000,d0			; set virtual address for io block
                            	   446: 		movec d0,ios
                            	   447: 	else
00:000003D4 203CFD100000    	   448: 		move.l #$FD100000,d0			; set virtual address for iop bitmap
00:000003DA 4E7B0016        	   449: 		movec d0,iops
00:000003DE 203CFD000000    	   450: 		move.l #$FD000000,d0			; set virtual address for io block
00:000003E4 4E7B0015        	   451: 		movec d0,ios
                            	   452: 	endif
                            	   453: ;	move.l $4000000C,d0
00:000003E8 13FC0002FDFFC000	   454: 	move.b #2,leds
00:000003F0 4E7A0FE0        	   455: 	movec coreno,d0							; set initial value of thread register
00:000003F4 4840            	   456: 	swap d0											; coreno in high eight bits
00:000003F6 E188            	   457: 	lsl.l #8,d0
00:000003F8 4E7B0012        	   458: 	movec d0,tr
                            	   459: 	; Prepare local variable storage
00:000003FC 303C03FF        	   460: 	move.w #1023,d0						; 1024 longs to clear
00:00000400 41F900040000    	   461: 	lea	$40000,a0							; non shared local memory address
                            	   462: .0111:
00:00000406 4298            	   463: 	clr.l	(a0)+								; clear the memory area
00:00000408 51C8FFFC        	   464: 	dbra d0,.0111
00:0000040C 13FC0005FDFFC000	   465: 	move.b #5,leds
00:00000414 13FC0001000400A4	   466: 	move.b #1,InputDevice			; select keyboard input
00:0000041C 13FC0002000400A8	   467: 	move.b #2,OutputDevice		; select text screen output
00:00000424 61000BB6        	   468: 	bsr setup_textvid
00:00000428 13FC0003FDFFC000	   469: 	move.b #3,leds
00:00000430 61000112        	   470: 	bsr setup_null
00:00000434 13FC0004FDFFC000	   471: 	move.b #4,leds
00:0000043C 6100014E        	   472: 	bsr setup_keybd
00:00000440 13FC0006FDFFC000	   473: 	move.b #6,leds
00:00000448 6100114E        	   474: 	bsr setup_serial
00:0000044C 13FC0007FDFFC000	   475: 	move.b #7,leds
00:00000454 4E7A0FE0        	   476: 	movec.l	coreno,d0					; get core number
00:00000458 0C000002        	   477: 	cmpi.b #2,d0
00:0000045C 660000BA        	   478: 	bne	start_other
00:00000460 610014FA        	   479: 	bsr setup_framebuf
00:00000464 13FC0008FDFFC000	   480: 	move.b #8,leds
00:0000046C 610019EE        	   481: 	bsr setup_gfxaccel
00:00000470 13FC0009FDFFC000	   482: 	move.b #9,leds
00:00000478 42B9000408B8    	   483: 	clr.l sys_switches
00:0000047E 4DF9FDFE4000    	   484: 	lea I2C2,a6
00:00000484 4EB900009A7A    	   485: 	bsr i2c_setup
00:0000048A 4DF9FD250000    	   486: 	lea I2C1,a6
00:00000490 4EB900009A7A    	   487: 	bsr i2c_setup
                            	   488: ;	lea SPI_MASTER1,a1
                            	   489: ;	bsr spi_setup
                            	   490: ;	lea SPI_MASTER2,a1
                            	   491: ;	bsr spi_setup
00:00000496 4E7A0FE0        	   492: 	movec.l	coreno,d0					; get core number
00:0000049A 13C000100000    	   493: 	move.b d0,IOFocus					; Set the IO focus in global memory
                            	   494: 	if HAS_MMU
                            	   495: 		bsr InitMMU							; Can't access anything till this is done'
                            	   496: 	endif
00:000004A0 61001F6A        	   497: 	bsr	InitIOPBitmap					; not going to get far without this
00:000004A4 610020E2        	   498: 	bsr	InitSemaphores
00:000004A8 61001FAE        	   499: 	bsr	InitRand
00:000004AC 61002014        	   500: 	bsr RandGetNum
00:000004B0 0281FFFFFF00    	   501: 	andi.l #$FFFFFF00,d1
00:000004B6 23C100040098    	   502: 	move.l d1,_canary
00:000004BC 4E7B1020        	   503: 	movec d1,canary
00:000004C0 61001ED2        	   504: 	bsr AudioTestOn
00:000004C4 61002186        	   505: 	bsr Delay3s
00:000004C8 61001F12        	   506: 	bsr AudioTestOff
                            	   507: ;	bsr	Delay3s						; give devices time to reset
                            	   508: ;	moveq #2,d7					; device 2
                            	   509: ;	moveq #DEV_CLEAR,d6	; clear
                            	   510: ;	trap #0
                            	   511: ;	bsr	textvid_clear
                            	   512: 
00:000004CC 6100020A        	   513: 	bsr	_KeybdInit
                            	   514: ;	bsr	InitIRQ
00:000004D0 61001182        	   515: 	bsr	SerialInit
                            	   516: ;	bsr init_i2c
                            	   517: ;	bsr rtc_read
                            	   518: 
                            	   519: 	; Write startup message to screen
                            	   520: 
00:000004D4 43F90000A0A0    	   521: 	lea	msg_start,a1
00:000004DA 61007630        	   522: 	bsr	DisplayString
                            	   523: ;	bsr	FemtikiInit
00:000004DE 4E7A0FE0        	   524: 	movec	coreno,d0
00:000004E2 4840            	   525: 	swap d0
00:000004E4 7201            	   526: 	moveq	#1,d1
00:000004E6 61002102        	   527: 	bsr	UnlockSemaphore	; allow another cpu access
00:000004EA 7200            	   528: 	moveq	#0,d1
00:000004EC 610020FC        	   529: 	bsr	UnlockSemaphore	; allow other cpus to proceed
00:000004F0 33FCA4A4FDFFC000	   530: 	move.w #$A4A4,leds			; diagnostics
00:000004F8 61007B44        	   531: 	bsr	init_plic				; initialize platform level interrupt controller
00:000004FC 60007C54        	   532: 	bra	StartMon
00:00000500 6100218A        	   533: 	bsr	cpu_test
                            	   534: ;	lea	brdisp_trap,a0	; set brdisp trap vector
                            	   535: ;	move.l	a0,64*4
                            	   536: 
                            	   537: loop2:
00:00000504 70FF            	   538: 	move.l	#-1,d0
                            	   539: loop1:
00:00000506 2200            	   540: 	move.l	d0,d1
00:00000508 E089            	   541: 	lsr.l		#8,d1
00:0000050A E089            	   542: 	lsr.l		#8,d1
00:0000050C 13C1FDFFC000    	   543: 	move.b	d1,leds
00:00000512 51C8FFF2        	   544: 	dbra		d0,loop1
00:00000516 60EC            	   545: 	bra			loop2
                            	   546: 
                            	   547: start_other:
00:00000518 61002156        	   548: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:0000051C 61002152        	   549: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:00000520 6100214E        	   550: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:00000524 7E02            	   551: 	move.l #2,d7
00:00000526 7C0C            	   552: 	move.l #DEV_CLEAR,d6
00:00000528 4E40            	   553: 	trap #0
00:0000052A 4E7A1FE0        	   554: 	movec		coreno,d1
00:0000052E 4EB900009590    	   555: 	bsr			DisplayByte
00:00000534 43F90000A0C7    	   556: 	lea			msg_core_start,a1
00:0000053A 610075D0        	   557: 	bsr			DisplayString
                            	   558: ;	bsr			FemtikiInitIRQ
                            	   559: do_nothing:	
00:0000053E 60007C12        	   560: 	bra			StartMon
00:00000542 60FA            	   561: 	bra			do_nothing
                            	   562: 
                            	   563: ;------------------------------------------------------------------------------
                            	   564: ; Initialize the MMU to allow thread #0 access to IO
                            	   565: ;------------------------------------------------------------------------------
                            	   566: 	if HAS_MMU
                            	   567: 	align 2
                            	   568: mmu_adrtbl:	; virtual address[24:16], physical address[31:16] bytes reversed!
                            	   569: 	dc.l	$0010,$10000300	; global scratch pad
                            	   570: 	dc.l	$01E0,$00FD0300	
                            	   571: 	dc.l	$01E1,$01FD0300
                            	   572: 	dc.l	$01E2,$02FD0300
                            	   573: 	dc.l  $01E3,$03FD0300
                            	   574: 	dc.l	$01E5,$05FD0300
                            	   575: 	dc.l	$01E6,$06FD0300
                            	   576: 	dc.l	$01E9,$09FD0300
                            	   577: 	dc.l	$01EF,$0FFD0300
                            	   578: 	dc.l	$01F0,$10FD0300
                            	   579: 	dc.l  $01FF,$FFFF0300	; all ones output for IRQ ack needed
                            	   580: 
                            	   581: 	even
                            	   582: InitMMU:
                            	   583: 	lea MMU+8,a0				; first 128kB is local RAM
                            	   584: 	move.l #$32000,d2		; map all pages to DRAM
                            	   585: 	move.l #510,d0			; then override for IO later
                            	   586: .0002
                            	   587: 	move.l d2,d1
                            	   588: 	bsr rbo
                            	   589: 	move.l d1,(a0)+
                            	   590: 	addi.w #1,d2				; increment DRAM page number
                            	   591: 	dbra d0,.0002
                            	   592: 	lea MMU,a0					; now program IO access
                            	   593: 	lea mmu_adrtbl,a1
                            	   594: 	moveq #10,d0
                            	   595: .0001
                            	   596: 	move.l (a1)+,d2
                            	   597: 	lsl.l #2,d2
                            	   598: 	move.l (a1)+,(a0,d2.w)
                            	   599: 	dbra d0,.0001
                            	   600: 	rts	
                            	   601: 	endif
                            	   602: 
                            	   603: ;------------------------------------------------------------------------------
                            	   604: ; Device drivers
                            	   605: ;------------------------------------------------------------------------------
                            	   606: 
                            	   607: 	include "null.x68"

Source: "null.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;------------------------------------------------------------------------------
                            	    38: ;------------------------------------------------------------------------------
                            	    39: ; Setup the NULL device
                            	    40: ;------------------------------------------------------------------------------
                            	    41: ;------------------------------------------------------------------------------
                            	    42: 
                            	    43: setup_null:
                            	    44: null_init:
00:00000544 48E780C0        	    45: 	movem.l d0/a0/a1,-(a7)
00:00000548 7020            	    46: 	moveq #32,d0
00:0000054A 41F900040A00    	    47: 	lea.l null_dcb,a0
                            	    48: .0001:
00:00000550 4298            	    49: 	clr.l (a0)+
00:00000552 51C8FFFC        	    50: 	dbra d0,.0001
00:00000556 23FC444342200004	    51: 	move.l #$44434220,null_dcb+DCB_MAGIC				; 'DCB'
00:0000055E 0A00
00:00000560 23FC4E554C4C0004	    52: 	move.l #$4E554C4C,null_dcb+DCB_NAME					; 'NULL'
00:00000568 0A04
00:0000056A 23FC000005880004	    53: 	move.l #null_cmdproc,null_dcb+DCB_CMDPROC
00:00000572 0A18
00:00000574 43F900040A00    	    54: 	lea.l null_dcb+DCB_MAGIC,a1
00:0000057A 61007590        	    55: 	jsr DisplayString
00:0000057E 61007572        	    56: 	jsr CRLF
00:00000582 4CDF0301        	    57: 	movem.l (a7)+,d0/a0/a1
                            	    58: null_ret:
00:00000586 4E75            	    59: 	rts
                            	    60: 
                            	    61: null_cmdproc:
00:00000588 7000            	    62: 	moveq #E_Ok,d0
00:0000058A 4E75            	    63: 	rts
                            	    64: 
                            	    65: 

Source: "boot.x68"
                            	   608: 	include "keybd.x68"

Source: "keybd.x68"
                            	     1: ;==============================================================================
                            	     2: ; Keyboard stuff
                            	     3: ;
                            	     4: ; KeyState2_
                            	     5: ; 876543210
                            	     6: ; ||||||||+ = shift
                            	     7: ; |||||||+- = alt
                            	     8: ; ||||||+-- = control
                            	     9: ; |||||+--- = numlock
                            	    10: ; ||||+---- = capslock
                            	    11: ; |||+----- = scrolllock
                            	    12: ; ||+------ =
                            	    13: ; |+------- = 
                            	    14: ; +-------- = extended
                            	    15: ;
                            	    16: ;==============================================================================
                            	    17: 
                            	    18: ;------------------------------------------------------------------------------
                            	    19: ; Setup the Keyboard device
                            	    20: ;------------------------------------------------------------------------------
                            	    21: setup_keybd:
                            	    22: keybd_init:
00:0000058C 48E780C0        	    23: 	movem.l d0/a0/a1,-(a7)
00:00000590 7020            	    24: 	moveq #32,d0
00:00000592 41F900040A84    	    25: 	lea.l keybd_dcb,a0
                            	    26: .0001:
00:00000598 4298            	    27: 	clr.l (a0)+
00:0000059A 51C8FFFC        	    28: 	dbra d0,.0001
00:0000059E 23FC444342200004	    29: 	move.l #$44434220,keybd_dcb+DCB_MAGIC				; 'DCB '
00:000005A6 0A84
00:000005A8 23FC4B4244000004	    30: 	move.l #$4B424400,keybd_dcb+DCB_NAME				; 'KBD'
00:000005B0 0A88
00:000005B2 23FC000006300004	    31: 	move.l #keybd_cmdproc,keybd_dcb+DCB_CMDPROC
00:000005BA 0A9C
00:000005BC 23FC001000200004	    32: 	move.l #_KeybdBuf,keybd_dcb+DCB_INBUFPTR
00:000005C4 0ABC
00:000005C6 23FC001000800004	    33: 	move.l #_KeybdOBuf,keybd_dcb+DCB_OUTBUFPTR
00:000005CE 0AC0
00:000005D0 23FC000000200004	    34: 	move.l #32,keybd_dcb+DCB_INBUFSIZE
00:000005D8 0AC4
00:000005DA 23FC000000200004	    35: 	move.l #32,keybd_dcb+DCB_OUTBUFSIZE
00:000005E2 0AC8
00:000005E4 423900040AD8    	    36: 	clr.b keybd_dcb+DCB_OUTDIMX	; set rows and columns
00:000005EA 423900040ADC    	    37: 	clr.b keybd_dcb+DCB_OUTDIMY
00:000005F0 423900040ACC    	    38: 	clr.b keybd_dcb+DCB_INDIMX		; set rows and columns
00:000005F6 423900040AD0    	    39: 	clr.b keybd_dcb+DCB_INDIMY
                            	    40: ;	bsr KeybdInit
00:000005FC 43F900040A84    	    41: 	lea.l keybd_dcb+DCB_MAGIC,a1
00:00000602 61007508        	    42: 	jsr DisplayString
00:00000606 610074EA        	    43: 	jsr CRLF
00:0000060A 4CDF0301        	    44: 	movem.l (a7)+,d0/a0/a1
00:0000060E 4E75            	    45: 	rts
                            	    46: 
                            	    47: 	align 2
                            	    48: KBD_CMDTBL:
00:00000610 0000058C        	    49: 	dc.l keybd_init				; 0
00:00000614 00000652        	    50: 	dc.l keybd_stat
00:00000618 0000065A        	    51: 	dc.l keybd_putchar
00:0000061C 0000066A        	    52: 	dc.l keybd_putbuf
00:00000620 00000662        	    53: 	dc.l keybd_getchar
00:00000624 0000066A        	    54: 	dc.l keybd_getbuf
00:00000628 0000066A        	    55: 	dc.l keybd_set_inpos
00:0000062C 0000066A        	    56: 	dc.l keybd_set_outpos
                            	    57: 
                            	    58: keybd_cmdproc:
00:00000630 0C060008        	    59: 	cmpi.b #8,d6
00:00000634 6418            	    60: 	bhs.s .0001
00:00000636 48E70280        	    61: 	movem.l d6/a0,-(a7)
00:0000063A E506            	    62: 	asl.b #2,d6
00:0000063C 4886            	    63: 	ext.w d6
00:0000063E 41FAFFD0        	    64: 	lea KBD_CMDTBL,a0
00:00000642 20706000        	    65: 	move.l (a0,d6.w),a0
00:00000646 4E90            	    66: 	jsr (a0)
00:00000648 4CDF0140        	    67: 	movem.l (a7)+,d6/a0
00:0000064C 4E75            	    68: 	rts
                            	    69: .0001:
00:0000064E 7002            	    70: 	moveq #E_Func,d0
00:00000650 4E75            	    71: 	rts
                            	    72: 
                            	    73: keybd_stat:
00:00000652 61000196        	    74: 	bsr _KeybdGetStatus
00:00000656 7000            	    75: 	moveq #E_Ok,d0
00:00000658 4E75            	    76: 	rts
                            	    77: 
                            	    78: keybd_putchar:
00:0000065A 61000502        	    79: 	bsr KeybdSendByte
00:0000065E 7000            	    80: 	moveq #E_Ok,d0
00:00000660 4E75            	    81: 	rts
                            	    82: 
                            	    83: keybd_getchar:
00:00000662 61000234        	    84: 	bsr GetKey
00:00000666 7000            	    85: 	moveq #E_Ok,d0
00:00000668 4E75            	    86: 	rts
                            	    87: 
                            	    88: keybd_putbuf:
                            	    89: keybd_getbuf:
                            	    90: keybd_set_inpos:
                            	    91: keybd_set_outpos:
00:0000066A 700A            	    92: 	moveq #E_NotSupported,d0
00:0000066C 4E75            	    93: 	rts
                            	    94: 
                            	    95: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	    96: ; Get ID - get the keyboards identifier code.
                            	    97: ;
                            	    98: ; Parameters: none
                            	    99: ; Returns: d = $AB83, $00 on fail
                            	   100: ; Modifies: d, KeybdID updated
                            	   101: ; Stack Space: 2 words
                            	   102: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   103: 
                            	   104: KeybdGetID:
00:0000066E 323C00F2        	   105: 	move.w	#$F2,d1
00:00000672 610004EA        	   106: 	bsr			KeybdSendByte
00:00000676 610001E6        	   107: 	bsr			KeybdWaitTx
00:0000067A 610001C0        	   108: 	bsr			KeybdRecvByte
00:0000067E 08010007        	   109: 	btst		#7,d1
00:00000682 6624            	   110: 	bne			kgnotKbd
00:00000684 0C0100AB        	   111: 	cmpi.b	#$AB,d1
00:00000688 661E            	   112: 	bne			kgnotKbd
00:0000068A 610001B0        	   113: 	bsr			KeybdRecvByte
00:0000068E 08010007        	   114: 	btst		#7,d1
00:00000692 6614            	   115: 	bne			kgnotKbd
00:00000694 0C010083        	   116: 	cmpi.b	#$83,d1
00:00000698 660E            	   117: 	bne			kgnotKbd
00:0000069A 223C0000AB83    	   118: 	move.l	#$AB83,d1
                            	   119: kgid1:
00:000006A0 33C100100018    	   120: 	move.w	d1,KeybdID
00:000006A6 4E75            	   121: 	rts
                            	   122: kgnotKbd:
00:000006A8 7200            	   123: 	moveq		#0,d1
00:000006AA 60F4            	   124: 	bra			kgid1
                            	   125: 
                            	   126: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   127: ; Set the LEDs on the keyboard.
                            	   128: ;
                            	   129: ; Parameters:
                            	   130: ;		d1.b = LED state
                            	   131: ;	Modifies:
                            	   132: ;		none
                            	   133: ; Returns:
                            	   134: ;		none
                            	   135: ; Stack Space:
                            	   136: ;		1 long word
                            	   137: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   138: 
                            	   139: KeybdSetLED:
00:000006AC 2F01            	   140: 	move.l	d1,-(a7)
00:000006AE 123C00ED        	   141: 	move.b	#$ED,d1
00:000006B2 610004AA        	   142: 	bsr			KeybdSendByte
00:000006B6 610001A6        	   143: 	bsr			KeybdWaitTx
00:000006BA 61000180        	   144: 	bsr			KeybdRecvByte
00:000006BE 4A01            	   145: 	tst.b		d1
00:000006C0 6B12            	   146: 	bmi			.0001
00:000006C2 0C0100FA        	   147: 	cmpi.b	#$FA,d1
00:000006C6 2217            	   148: 	move.l	(a7),d1
00:000006C8 61000494        	   149: 	bsr			KeybdSendByte
00:000006CC 61000190        	   150: 	bsr			KeybdWaitTx
00:000006D0 6100016A        	   151: 	bsr			KeybdRecvByte
                            	   152: .0001:
00:000006D4 221F            	   153: 	move.l	(a7)+,d1
00:000006D6 4E75            	   154: 	rts
                            	   155: 
                            	   156: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   157: ; Initialize the keyboard.
                            	   158: ;
                            	   159: ; Parameters:
                            	   160: ;		none
                            	   161: ;	Modifies:
                            	   162: ;		none
                            	   163: ; Returns:
                            	   164: ;		none
                            	   165: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   166: 
                            	   167: _KeybdInit:
                            	   168: KeybdInit:
                            	   169: ;	movem.l	d0/d1/d3/a1,-(a7)
00:000006D8 42390010000F    	   170: 	clr.b	_KeyState1		; records key up/down state
00:000006DE 423900100010    	   171: 	clr.b	_KeyState2		; records shift,ctrl,alt state
00:000006E4 4E75            	   172: 	rts
                            	   173: 
00:000006E6 6100049A        	   174: 	bsr			Wait300ms
00:000006EA 610000FE        	   175: 	bsr			_KeybdGetStatus	; wait for response from keyboard
00:000006EE 4A01            	   176: 	tst.b		d1
00:000006F0 6A10            	   177: 	bpl			.0001					; is input buffer full ? no, branch
00:000006F2 61000114        	   178: 	bsr	_KeybdGetScancode
00:000006F6 6100012E        	   179: 	bsr _KeybdClearIRQ
00:000006FA 0C0100AA        	   180: 	cmpi.b	#$AA,d1				; keyboard Okay
00:000006FE 67000098        	   181: 	beq			kbdi0005
                            	   182: .0001:
00:00000702 760A            	   183: 	moveq		#10,d3
                            	   184: kbdi0002:
00:00000704 61000460        	   185: 	bsr			Wait10ms
00:00000708 4239FDFF8001    	   186: 	clr.b		KEYBD+1				; clear receive register (write $00 to status reg)
00:0000070E 61001CF8        	   187: 	bsr net_delay
00:00000712 72FF            	   188: 	moveq		#-1,d1				; send reset code to keyboard
00:00000714 13C1FDFF8001    	   189: 	move.b	d1,KEYBD+1		; write $FF to status reg to clear TX state
00:0000071A 61001CEC        	   190: 	bsr net_delay
00:0000071E 6100043E        	   191: 	bsr			KeybdSendByte	; now write ($FF) to transmit register for reset
00:00000722 6100013A        	   192: 	bsr			KeybdWaitTx		; wait until no longer busy
00:00000726 4A81            	   193: 	tst.l		d1
00:00000728 6B000088        	   194: 	bmi			kbdiXmitBusy
00:0000072C 6100010E        	   195: 	bsr			KeybdRecvByte	; look for an ACK ($FA)
00:00000730 0C0100FA        	   196: 	cmpi.b	#$FA,d1
00:00000734 6604            	   197: 	bne			.0001
00:00000736 61000104        	   198: 	bsr			KeybdRecvByte	; look for BAT completion code ($AA)
                            	   199: .0001:
00:0000073A 0C0100FC        	   200: 	cmpi.b	#$FC,d1				; reset error ?
00:0000073E 672E            	   201: 	beq			kbdiTryAgain
00:00000740 0C0100AA        	   202: 	cmpi.b	#$AA,d1				; reset complete okay ?
00:00000744 6628            	   203: 	bne			kbdiTryAgain
                            	   204: 
                            	   205: 	; After a reset, scan code set #2 should be active
                            	   206: .config:
00:00000746 323C00F0        	   207: 	move.w	#$F0,d1			; send scan code select
00:0000074A 13C1FDFFC000    	   208: 	move.b	d1,leds
00:00000750 61001CB6        	   209: 	bsr net_delay
00:00000754 61000408        	   210: 	bsr			KeybdSendByte
00:00000758 61000104        	   211: 	bsr			KeybdWaitTx
00:0000075C 4A81            	   212: 	tst.l		d1
00:0000075E 6B52            	   213: 	bmi			kbdiXmitBusy
00:00000760 610000DA        	   214: 	bsr			KeybdRecvByte	; wait for response from keyboard
00:00000764 4A41            	   215: 	tst.w		d1
00:00000766 6B06            	   216: 	bmi			kbdiTryAgain
00:00000768 0C0100FA        	   217: 	cmpi.b	#$FA,d1				; ACK
00:0000076C 670E            	   218: 	beq			kbdi0004
                            	   219: kbdiTryAgain:
00:0000076E 51CBFF94        	   220: 	dbra		d3,kbdi0002
                            	   221: .keybdErr:
00:00000772 43FA004C        	   222: 	lea			msgBadKeybd,a1
00:00000776 610073AA        	   223: 	bsr			DisplayStringCRLF
00:0000077A 6020            	   224: 	bra			ledxit
                            	   225: kbdi0004:
00:0000077C 7202            	   226: 	moveq		#2,d1			; select scan code set #2
00:0000077E 610003DE        	   227: 	bsr			KeybdSendByte
00:00000782 610000DA        	   228: 	bsr			KeybdWaitTx
00:00000786 4A81            	   229: 	tst.l		d1
00:00000788 6B28            	   230: 	bmi			kbdiXmitBusy
00:0000078A 610000B0        	   231: 	bsr			KeybdRecvByte	; wait for response from keyboard
00:0000078E 4A41            	   232: 	tst.w		d1
00:00000790 6BDC            	   233: 	bmi			kbdiTryAgain
00:00000792 0C0100FA        	   234: 	cmpi.b	#$FA,d1
00:00000796 66D6            	   235: 	bne			kbdiTryAgain
                            	   236: kbdi0005:
00:00000798 6100FED4        	   237: 	bsr			KeybdGetID
                            	   238: ledxit:
00:0000079C 7207            	   239: 	moveq		#$07,d1
00:0000079E 6100FF0C        	   240: 	bsr			KeybdSetLED
00:000007A2 610003DE        	   241: 	bsr			Wait300ms
00:000007A6 7200            	   242: 	moveq		#$00,d1
00:000007A8 6100FF02        	   243: 	bsr			KeybdSetLED
00:000007AC 4CDF020B        	   244: 	movem.l	(a7)+,d0/d1/d3/a1
00:000007B0 4E75            	   245: 	rts
                            	   246: kbdiXmitBusy:
00:000007B2 43FA001B        	   247: 	lea			msgXmitBusy,a1
00:000007B6 6100736A        	   248: 	bsr			DisplayStringCRLF
00:000007BA 4CDF020B        	   249: 	movem.l	(a7)+,d0/d1/d3/a1
00:000007BE 4E75            	   250: 	rts
                            	   251: 	
                            	   252: msgBadKeybd:
00:000007C0 4B6579626F617264	   253: 	dc.b		"Keyboard error",0
00:000007C8 206572726F72
00:000007CE 00
                            	   254: msgXmitBusy:
00:000007CF 4B6579626F617264	   255: 	dc.b		"Keyboard transmitter stuck",0
00:000007D7 207472616E736D69
00:000007DF 7474657220737475
00:000007E7 636B
00:000007E9 00
                            	   256: 
                            	   257: 	even
                            	   258: _KeybdGetStatus:
00:000007EA 4E7A1FE0        	   259: 	movec coreno,d1
00:000007EE 0C010002        	   260: 	cmpi.b #2,d1
00:000007F2 660A            	   261: 	bne .0001
00:000007F4 7200            	   262: 	moveq	#0,d1
00:000007F6 1239FDFF8001    	   263: 	move.b KEYBD+1,d1
00:000007FC 4E75            	   264: 	rts
                            	   265: .0001:
00:000007FE 7200            	   266: 	moveq #0,d1
00:00000800 1239FDFF8003    	   267: 	move.b KEYBD+3,d1
00:00000806 4E75            	   268: 	rts
                            	   269: 
                            	   270: ; Get the scancode from the keyboard port
                            	   271: 
                            	   272: _KeybdGetScancode:
00:00000808 4E7A1FE0        	   273: 	movec coreno,d1
00:0000080C 0C010002        	   274: 	cmpi.b #2,d1
00:00000810 660A            	   275: 	bne .0001
00:00000812 7200            	   276: 	moveq		#0,d1
00:00000814 1239FDFF8000    	   277: 	move.b	KEYBD,d1				; get the scan code
00:0000081A 4E75            	   278: 	rts
                            	   279: .0001:
00:0000081C 7200            	   280: 	moveq #0,d1
00:0000081E 1239FDFF8002    	   281: 	move.b KEYBD+2,d1
00:00000824 4E75            	   282: 	rts
                            	   283: 
                            	   284: _KeybdClearIRQ:
00:00000826 2F01            	   285: 	move.l d1,-(a7)
00:00000828 4E7A1FE0        	   286: 	movec coreno,d1
00:0000082C 0C010002        	   287: 	cmpi.b #2,d1
00:00000830 6606            	   288: 	bne .0001
00:00000832 4239FDFF8001    	   289: 	move.b	#0,KEYBD+1			; clear receive register
                            	   290: .0001:
00:00000838 221F            	   291: 	move.l (a7)+,d1
00:0000083A 4E75            	   292: 	rts
                            	   293: 
                            	   294: ; Recieve a byte from the keyboard, used after a command is sent to the
                            	   295: ; keyboard in order to wait for a response.
                            	   296: ;
                            	   297: KeybdRecvByte:
00:0000083C 2F03            	   298: 	move.l	d3,-(a7)
00:0000083E 363C0064        	   299: 	move.w	#100,d3		; wait up to 1s
                            	   300: .0003:
00:00000842 61A6            	   301: 	bsr			_KeybdGetStatus	; wait for response from keyboard
00:00000844 4A01            	   302: 	tst.b		d1
00:00000846 6B0E            	   303: 	bmi			.0004			; is input buffer full ? yes, branch
00:00000848 6100031C        	   304: 	bsr			Wait10ms	; wait a bit
00:0000084C 51CBFFF4        	   305: 	dbra		d3,.0003	; go back and try again
00:00000850 261F            	   306: 	move.l	(a7)+,d3
00:00000852 72FF            	   307: 	moveq		#-1,d1		; return -1
00:00000854 4E75            	   308: 	rts
                            	   309: .0004:
00:00000856 61B0            	   310: 	bsr	_KeybdGetScancode
00:00000858 61CC            	   311: 	bsr _KeybdClearIRQ
00:0000085A 261F            	   312: 	move.l	(a7)+,d3
00:0000085C 4E75            	   313: 	rts
                            	   314: 
                            	   315: 
                            	   316: ; Wait until the keyboard transmit is complete
                            	   317: ; Returns -1 if timedout, 0 if transmit completed
                            	   318: ;
                            	   319: KeybdWaitTx:
00:0000085E 48E73000        	   320: 	movem.l	d2/d3,-(a7)
00:00000862 7664            	   321: 	moveq		#100,d3		; wait a max of 1s
                            	   322: .0001:
00:00000864 6184            	   323: 	bsr	_KeybdGetStatus
00:00000866 08010006        	   324: 	btst #6,d1				; check for transmit complete bit
00:0000086A 6610            	   325: 	bne	.0002					; branch if bit set
00:0000086C 610002F8        	   326: 	bsr	Wait10ms			; delay a little bit
00:00000870 51CBFFF2        	   327: 	dbra d3,.0001			; go back and try again
00:00000874 4CDF000C        	   328: 	movem.l	(a7)+,d2/d3
00:00000878 72FF            	   329: 	moveq	#-1,d1			; return -1
00:0000087A 4E75            	   330: 	rts
                            	   331: .0002:
00:0000087C 4CDF000C        	   332: 	movem.l	(a7)+,d2/d3
00:00000880 7200            	   333: 	moveq	#0,d1		; return 0
00:00000882 4E75            	   334: 	rts
                            	   335: 
                            	   336: ;------------------------------------------------------------------------------
                            	   337: ; d1.b 0=echo off, non-zero = echo on
                            	   338: ;------------------------------------------------------------------------------
                            	   339: 
                            	   340: SetKeyboardEcho:
00:00000884 13C10004000C    	   341: 	move.b	d1,KeybdEcho
00:0000088A 4E75            	   342: 	rts
                            	   343: 
                            	   344: ;------------------------------------------------------------------------------
                            	   345: ; Get key pending status into d1.b
                            	   346: ;
                            	   347: ; Returns:
                            	   348: ;		d1.b = 1 if a key is available, otherwise zero.
                            	   349: ;------------------------------------------------------------------------------
                            	   350: 
                            	   351: CheckForKey:
00:0000088C 7200            	   352: 	moveq.l	#0,d1					; clear high order bits
                            	   353: ;	move.b	KEYBD+1,d1		; get keyboard port status
                            	   354: ;	smi.b		d1						; set true/false
                            	   355: ;	andi.b	#1,d1					; return true (1) if key available, 0 otherwise
00:0000088E 4A3900100013    	   356: 	tst.b	_KeybdCnt
00:00000894 56C1            	   357: 	sne.b	d1
00:00000896 4E75            	   358: 	rts
                            	   359: 
                            	   360: ;------------------------------------------------------------------------------
                            	   361: ; GetKey
                            	   362: ; 	Get a character from the keyboard. 
                            	   363: ;
                            	   364: ; Modifies:
                            	   365: ;		d1
                            	   366: ; Returns:
                            	   367: ;		d1 = -1 if no key available or not in focus, otherwise key
                            	   368: ;------------------------------------------------------------------------------
                            	   369: 
                            	   370: GetKey:
00:00000898 2F00            	   371: 	move.l	d0,-(a7)					; push d0
00:0000089A 123900100000    	   372: 	move.b	IOFocus,d1				; Check if the core has the IO focus
00:000008A0 4E7A0FE0        	   373: 	movec.l	coreno,d0
00:000008A4 B200            	   374: 	cmp.b	d0,d1
00:000008A6 6624            	   375: 	bne.s	.0004								; go return no key available, if not in focus
00:000008A8 6138            	   376: 	bsr	KeybdGetCharNoWait		; get a character
00:000008AA 4A81            	   377: 	tst.l	d1									; was a key available?
00:000008AC 6B1E            	   378: 	bmi.s	.0004
00:000008AE 4A390004000C    	   379: 	tst.b	KeybdEcho						; is keyboard echo on ?
00:000008B4 6712            	   380: 	beq.s	.0003								; no echo, just return the key
00:000008B6 0C01000D        	   381: 	cmpi.b #CR,d1							; convert CR keystroke into CRLF
00:000008BA 6606            	   382: 	bne.s	.0005
00:000008BC 61007234        	   383: 	bsr	CRLF
00:000008C0 6006            	   384: 	bra.s	.0003
                            	   385: .0005:
00:000008C2 4EB900009F2A    	   386: 	bsr	OutputChar
                            	   387: .0003:
00:000008C8 201F            	   388: 	move.l (a7)+,d0						; pop d0
00:000008CA 4E75            	   389: 	rts												; return key
                            	   390: ; Return -1 indicating no char was available
                            	   391: .0004:
00:000008CC 201F            	   392: 	move.l (a7)+,d0						; pop d0
00:000008CE 72FF            	   393: 	moveq	#-1,d1							; return no key available
00:000008D0 4E75            	   394: 	rts
                            	   395: 
                            	   396: ;------------------------------------------------------------------------------
                            	   397: ; Check for the cntrl-C keyboard sequence. Abort running routine and drop
                            	   398: ; back into the monitor.
                            	   399: ;------------------------------------------------------------------------------
                            	   400: 
                            	   401: _CheckForCtrlC:
                            	   402: CheckForCtrlC:
00:000008D2 2F01            	   403: 	move.l d1,-(a7)
00:000008D4 610C            	   404: 	bsr	KeybdGetCharNoWait
00:000008D6 0C010003        	   405: 	cmpi.b #CTRLC,d1
00:000008DA 67007880        	   406: 	beq	Monitor
00:000008DE 221F            	   407: 	move.l (a7)+,d1
00:000008E0 4E75            	   408: 	rts
                            	   409: 
                            	   410: ;------------------------------------------------------------------------------
                            	   411: ;------------------------------------------------------------------------------
                            	   412: 
                            	   413: KeybdGetCharNoWait:
00:000008E2 42390004000D    	   414: 	clr.b	KeybdWaitFlag
00:000008E8 6008            	   415: 	bra	KeybdGetChar
                            	   416: 
                            	   417: KeybdGetCharWait:
00:000008EA 13FC00FF0004000D	   418: 	move.b #-1,KeybdWaitFlag
                            	   419: 
                            	   420: KeybdGetChar:
00:000008F2 48E7B080        	   421: 	movem.l	d0/d2/d3/a0,-(a7)
                            	   422: .0003:
00:000008F6 4E7A0FE0        	   423: 	movec	coreno,d0
00:000008FA 4840            	   424: 	swap d0
00:000008FC 7203            	   425: 	moveq	#KEYBD_SEMA,d1
00:000008FE 61001CAE        	   426: 	bsr	LockSemaphore
00:00000902 143900100013    	   427: 	move.b	_KeybdCnt,d2		; get count of buffered scan codes
00:00000908 673E            	   428: 	beq.s		.0015						;
00:0000090A 143900100011    	   429: 	move.b	_KeybdHead,d2		; d2 = buffer head
00:00000910 4882            	   430: 	ext.w		d2
00:00000912 41F900100020    	   431: 	lea			_KeybdBuf,a0		; a0 = pointer to keyboard buffer
00:00000918 7200            	   432: 	clr.l		d1
00:0000091A 12302000        	   433: 	move.b	(a0,d2.w),d1		; d1 = scan code from buffer
00:0000091E 5202            	   434: 	addi.b	#1,d2						; increment keyboard head index
00:00000920 0202001F        	   435: 	andi.b	#31,d2					; and wrap around at buffer size
00:00000924 13C200100011    	   436: 	move.b	d2,_KeybdHead
00:0000092A 533900100013    	   437: 	subi.b	#1,_KeybdCnt		; decrement count of scan codes in buffer
00:00000930 C342            	   438: 	exg			d1,d2						; save scancode value in d2
00:00000932 4E7A0FE0        	   439: 	movec		coreno,d0
00:00000936 4840            	   440: 	swap		d0
00:00000938 7203            	   441: 	moveq		#KEYBD_SEMA,d1
00:0000093A 61001CAE        	   442: 	bsr			UnlockSemaphore
00:0000093E C541            	   443: 	exg			d2,d1						; restore scancode value
00:00000940 602A            	   444: 	bra			.0001						; go process scan code
                            	   445: .0014:
00:00000942 6100FEA6        	   446: 	bsr		_KeybdGetStatus		; check keyboard status for key available
00:00000946 6B1C            	   447: 	bmi		.0006							; yes, go process
                            	   448: .0015:
00:00000948 4E7A0FE0        	   449: 	movec		coreno,d0
00:0000094C 4840            	   450: 	swap		d0
00:0000094E 7203            	   451: 	moveq		#KEYBD_SEMA,d1
00:00000950 61001C98        	   452: 	bsr			UnlockSemaphore
00:00000954 4A390004000D    	   453: 	tst.b		KeybdWaitFlag			; are we willing to wait for a key ?
00:0000095A 6B9A            	   454: 	bmi			.0003							; yes, branch back
00:0000095C 4CDF010D        	   455: 	movem.l	(a7)+,d0/d2/d3/a0
00:00000960 72FF            	   456: 	moveq		#-1,d1						; flag no char available
00:00000962 4E75            	   457: 	rts
                            	   458: .0006:
00:00000964 6100FEA2        	   459: 	bsr	_KeybdGetScancode
00:00000968 6100FEBC        	   460: 	bsr _KeybdClearIRQ
                            	   461: .0001:
00:0000096C 33FC0001FDFFC000	   462: 	move.w	#1,leds
00:00000974 B23C00F0        	   463: 	cmp.b	#SC_KEYUP,d1
00:00000978 670000C0        	   464: 	beq		.doKeyup
00:0000097C B23C00E0        	   465: 	cmp.b	#SC_EXTEND,d1
00:00000980 670000C4        	   466: 	beq		.doExtend
00:00000984 B23C0014        	   467: 	cmp.b	#SC_CTRL,d1
00:00000988 670000C8        	   468: 	beq		.doCtrl
00:0000098C B23C0012        	   469: 	cmp.b	#SC_LSHIFT,d1
00:00000990 6700012A        	   470: 	beq		.doShift
00:00000994 B23C0059        	   471: 	cmp.b	#SC_RSHIFT,d1
00:00000998 67000122        	   472: 	beq		.doShift
00:0000099C B23C0077        	   473: 	cmp.b	#SC_NUMLOCK,d1
00:000009A0 67000142        	   474: 	beq		.doNumLock
00:000009A4 B23C0058        	   475: 	cmp.b	#SC_CAPSLOCK,d1
00:000009A8 67000148        	   476: 	beq		.doCapsLock
00:000009AC B23C007E        	   477: 	cmp.b	#SC_SCROLLLOCK,d1
00:000009B0 6700014E        	   478: 	beq		.doScrollLock
00:000009B4 B23C0011        	   479: 	cmp.b   #SC_ALT,d1
00:000009B8 670000C0        	   480: 	beq     .doAlt
00:000009BC 14390010000F    	   481: 	move.b	_KeyState1,d2			; check key up/down
00:000009C2 42390010000F    	   482: 	move.b	#0,_KeyState1			; clear keyup status
00:000009C8 4A02            	   483: 	tst.b	d2
00:000009CA 6600FF2A        	   484: 	bne	    .0003					; ignore key up
00:000009CE B23C000D        	   485: 	cmp.b   #SC_TAB,d1
00:000009D2 670000CE        	   486: 	beq     .doTab
                            	   487: .0013:
00:000009D6 143900100010    	   488: 	move.b	_KeyState2,d2
00:000009DC 6A1A            	   489: 	bpl		.0010					; is it extended code ?
00:000009DE C43C007F        	   490: 	and.b	#$7F,d2					; clear extended bit
00:000009E2 13C200100010    	   491: 	move.b	d2,_KeyState2
00:000009E8 42390010000F    	   492: 	move.b	#0,_KeyState1			; clear keyup
00:000009EE 41FA04E4        	   493: 	lea		_keybdExtendedCodes,a0
00:000009F2 12301000        	   494: 	move.b	(a0,d1.w),d1
00:000009F6 6034            	   495: 	bra		.0008
                            	   496: .0010:
00:000009F8 08020002        	   497: 	btst	#2,d2					; is it CTRL code ?
00:000009FC 670E            	   498: 	beq		.0009
00:000009FE C27C007F        	   499: 	and.w	#$7F,d1
00:00000A02 41FA0450        	   500: 	lea		_keybdControlCodes,a0
00:00000A06 12301000        	   501: 	move.b	(a0,d1.w),d1
00:00000A0A 6020            	   502: 	bra		.0008
                            	   503: .0009:
00:00000A0C 08020000        	   504: 	btst	#0,d2					; is it shift down ?
00:00000A10 670A            	   505: 	beq  	.0007
00:00000A12 41FA0340        	   506: 	lea		_shiftedScanCodes,a0
00:00000A16 12301000        	   507: 	move.b	(a0,d1.w),d1
00:00000A1A 6010            	   508: 	bra		.0008
                            	   509: .0007:
00:00000A1C 41FA0236        	   510: 	lea		_unshiftedScanCodes,a0
00:00000A20 12301000        	   511: 	move.b	(a0,d1.w),d1
00:00000A24 33FC0202FDFFC000	   512: 	move.w	#$0202,leds
                            	   513: .0008:
00:00000A2C 33FC0303FDFFC000	   514: 	move.w	#$0303,leds
00:00000A34 4CDF010D        	   515: 	movem.l	(a7)+,d0/d2/d3/a0
00:00000A38 4E75            	   516: 	rts
                            	   517: .doKeyup:
00:00000A3A 13FC00FF0010000F	   518: 	move.b	#-1,_KeyState1
00:00000A42 6000FEB2        	   519: 	bra		.0003
                            	   520: .doExtend:
00:00000A46 0039008000100010	   521: 	or.b	#$80,_KeyState2
00:00000A4E 6000FEA6        	   522: 	bra		.0003
                            	   523: .doCtrl:
00:00000A52 12390010000F    	   524: 	move.b	_KeyState1,d1
00:00000A58 42390010000F    	   525: 	clr.b	_KeyState1
00:00000A5E 4A01            	   526: 	tst.b	d1
00:00000A60 6A0C            	   527: 	bpl.s	.0004
00:00000A62 08B9000200100010	   528: 	bclr	#2,_KeyState2
00:00000A6A 6000FE8A        	   529: 	bra		.0003
                            	   530: .0004:
00:00000A6E 08F9000200100010	   531: 	bset	#2,_KeyState2
00:00000A76 6000FE7E        	   532: 	bra		.0003
                            	   533: .doAlt:
00:00000A7A 12390010000F    	   534: 	move.b	_KeyState1,d1
00:00000A80 42390010000F    	   535: 	clr.b	_KeyState1
00:00000A86 4A01            	   536: 	tst.b	d1
00:00000A88 6A0C            	   537: 	bpl		.0011
00:00000A8A 08B9000100100010	   538: 	bclr	#1,_KeyState2
00:00000A92 6000FE62        	   539: 	bra		.0003
                            	   540: .0011:
00:00000A96 08F9000100100010	   541: 	bset	#1,_KeyState2
00:00000A9E 6000FE56        	   542: 	bra		.0003
                            	   543: .doTab:
00:00000AA2 2F01            	   544: 	move.l	d1,-(a7)
00:00000AA4 123900100010    	   545:   move.b  _KeyState2,d1
00:00000AAA 08010001        	   546:   btst	#1,d1                 ; is ALT down ?
00:00000AAE 6706            	   547:   beq     .0012
                            	   548: ;    	inc     _iof_switch
00:00000AB0 221F            	   549:   move.l	(a7)+,d1
00:00000AB2 6000FE42        	   550:   bra     .0003
                            	   551: .0012:
00:00000AB6 221F            	   552:   move.l	(a7)+,d1
00:00000AB8 6000FF1C        	   553:   bra     .0013
                            	   554: .doShift:
00:00000ABC 12390010000F    	   555: 	move.b	_KeyState1,d1
00:00000AC2 42390010000F    	   556: 	clr.b	_KeyState1
00:00000AC8 4A01            	   557: 	tst.b	d1
00:00000ACA 6A0C            	   558: 	bpl.s	.0005
00:00000ACC 08B9000000100010	   559: 	bclr	#0,_KeyState2
00:00000AD4 6000FE20        	   560: 	bra		.0003
                            	   561: .0005:
00:00000AD8 08F9000000100010	   562: 	bset	#0,_KeyState2
00:00000AE0 6000FE14        	   563: 	bra		.0003
                            	   564: .doNumLock:
00:00000AE4 0879000400100010	   565: 	bchg	#4,_KeyState2
00:00000AEC 6120            	   566: 	bsr		KeybdSetLEDStatus
00:00000AEE 6000FE06        	   567: 	bra		.0003
                            	   568: .doCapsLock:
00:00000AF2 0879000500100010	   569: 	bchg	#5,_KeyState2
00:00000AFA 6112            	   570: 	bsr		KeybdSetLEDStatus
00:00000AFC 6000FDF8        	   571: 	bra		.0003
                            	   572: .doScrollLock:
00:00000B00 0879000600100010	   573: 	bchg	#6,_KeyState2
00:00000B08 6104            	   574: 	bsr		KeybdSetLEDStatus
00:00000B0A 6000FDEA        	   575: 	bra		.0003
                            	   576: 
                            	   577: KeybdSetLEDStatus:
00:00000B0E 48E73000        	   578: 	movem.l	d2/d3,-(a7)
00:00000B12 42390010000E    	   579: 	clr.b		KeybdLEDs
00:00000B18 0839000400100010	   580: 	btst		#4,_KeyState2
00:00000B20 6708            	   581: 	beq.s		.0002
00:00000B22 13FC00020010000E	   582: 	move.b	#2,KeybdLEDs
                            	   583: .0002:
00:00000B2A 0839000500100010	   584: 	btst		#5,_KeyState2
00:00000B32 6708            	   585: 	beq.s		.0003
00:00000B34 08F900020010000E	   586: 	bset		#2,KeybdLEDs
                            	   587: .0003:
00:00000B3C 0839000600100010	   588: 	btst		#6,_KeyState2
00:00000B44 6708            	   589: 	beq.s		.0004
00:00000B46 08F900000010000E	   590: 	bset		#0,KeybdLEDs
                            	   591: .0004:
00:00000B4E 12390010000E    	   592: 	move.b	KeybdLEDs,d1
00:00000B54 6100FB56        	   593: 	bsr			KeybdSetLED
00:00000B58 4CDF000C        	   594: 	movem.l	(a7)+,d2/d3
00:00000B5C 4E75            	   595: 	rts
                            	   596: 
                            	   597: KeybdSendByte:
00:00000B5E 13C1FDFF8000    	   598: 	move.b d1,KEYBD
00:00000B64 4E75            	   599: 	rts
                            	   600: 	
                            	   601: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   602: ; Wait for 10 ms
                            	   603: ;
                            	   604: ; Parameters: none
                            	   605: ; Returns: none
                            	   606: ; Modifies: none
                            	   607: ; Stack Space: 2 long words
                            	   608: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   609: 
                            	   610: Wait10ms:
00:00000B66 48E7C000        	   611: 	movem.l	d0/d1,-(a7)
00:00000B6A 4E7A0FF0        	   612: 	movec	tick,d0
00:00000B6E 068000061A80    	   613: 	addi.l #400000,d0			; 400,000 cycles at 40MHz
                            	   614: .0001:
00:00000B74 4E7A1FF0        	   615: 	movec	tick,d1
00:00000B78 B081            	   616: 	cmp.l	d1,d0
00:00000B7A 62F8            	   617: 	bhi	.0001
00:00000B7C 4CDF0003        	   618: 	movem.l	(a7)+,d0/d1
00:00000B80 4E75            	   619: 	rts
                            	   620: 
                            	   621: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   622: ; Wait for 300 ms
                            	   623: ;
                            	   624: ; Parameters: none
                            	   625: ; Returns: none
                            	   626: ; Modifies: none
                            	   627: ; Stack Space: 2 long words
                            	   628: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   629: 
                            	   630: Wait300ms:
00:00000B82 48E7C000        	   631: 	movem.l	d0/d1,-(a7)
00:00000B86 4E7A0FF0        	   632: 	movec		tick,d0
00:00000B8A 068000B71B00    	   633: 	addi.l	#12000000,d0			; 12,000,000 cycles at 40MHz
                            	   634: .0001:
00:00000B90 4E7A1FF0        	   635: 	movec		tick,d1
00:00000B94 B081            	   636: 	cmp.l		d1,d0
00:00000B96 62F8            	   637: 	bhi			.0001
00:00000B98 4CDF0003        	   638: 	movem.l	(a7)+,d0/d1
00:00000B9C 4E75            	   639: 	rts
                            	   640: 
                            	   641: ;--------------------------------------------------------------------------
                            	   642: ; Keyboard IRQ routine.
                            	   643: ; - only core 2 processes keyboard interrupts.
                            	   644: ; - the keyboard buffer is in shared global scratchpad space.
                            	   645: ;
                            	   646: ; Returns:
                            	   647: ; 	d1 = -1 if keyboard routine handled interrupt, otherwise positive.
                            	   648: ;--------------------------------------------------------------------------
                            	   649: 
                            	   650: KeybdIRQ:
00:00000B9E 46FC2600        	   651: 	move.w #$2600,sr					; disable lower interrupts
00:00000BA2 48E7C080        	   652: 	movem.l	d0/d1/a0,-(a7)
00:00000BA6 46B9FD000000    	   653: 	eori.l #-1,$FD000000
00:00000BAC 7200            	   654: 	moveq	#0,d1								; check if keyboard IRQ
00:00000BAE 1239FDFF8001    	   655: 	move.b KEYBD+1,d1					; get status reg
00:00000BB4 4A01            	   656: 	tst.b	d1
00:00000BB6 6A000096        	   657: 	bpl	.0001									; branch if not keyboard
00:00000BBA 4E7A0FE0        	   658: 	movec	coreno,d0
00:00000BBE 4840            	   659: 	swap d0
00:00000BC0 7203            	   660: 	moveq	#KEYBD_SEMA,d1
00:00000BC2 610019EA        	   661: 	bsr LockSemaphore
00:00000BC6 1239FDFF8000    	   662: 	move.b KEYBD,d1						; get scan code
00:00000BCC 4239FDFF8001    	   663: 	clr.b KEYBD+1							; clear status register (clears IRQ AND scancode)
00:00000BD2 0839000100100010	   664: 	btst #1,_KeyState2				; Is Alt down?
00:00000BDA 6738            	   665: 	beq.s	.0003
00:00000BDC 0C01000D        	   666: 	cmpi.b #SC_TAB,d1					; is Alt-Tab?
00:00000BE0 6632            	   667: 	bne.s	.0003
00:00000BE2 4E7A0FF0        	   668: 	movec tick,d0
00:00000BE6 90B90001001C    	   669: 	sub.l _Keybd_tick,d0
00:00000BEC B0BC0000000A    	   670: 	cmp.l #10,d0							; has it been 10 or more ticks?
                            	   671: ;	blo.s .0002
00:00000BF2 4E7A0FF0        	   672: 	movec tick,d0							; update tick of last ALT-Tab
00:00000BF6 23C00001001C    	   673: 	move.l d0,_Keybd_tick
00:00000BFC 61007410        	   674: 	bsr	rotate_iofocus
00:00000C00 423900100011    	   675: 	clr.b	_KeybdHead					; clear keyboard buffer
00:00000C06 423900100012    	   676: 	clr.b	_KeybdTail
00:00000C0C 423900100013    	   677: 	clr.b	_KeybdCnt
00:00000C12 602E            	   678: 	bra	.0002									; do not store Alt-Tab
                            	   679: .0003:
                            	   680: 	; Insert keyboard scan code into raw keyboard buffer
00:00000C14 0C39002000100013	   681: 	cmpi.b #32,_KeybdCnt			; see if keyboard buffer full
00:00000C1C 6424            	   682: 	bhs.s	.0002
00:00000C1E 103900100012    	   683: 	move.b _KeybdTail,d0			; keyboard buffer not full, add to tail
00:00000C24 4880            	   684: 	ext.w	d0
00:00000C26 41F900100020    	   685: 	lea	_KeybdBuf,a0					; a0 = pointer to buffer
00:00000C2C 11810000        	   686: 	move.b d1,(a0,d0.w)				; put scancode in buffer
00:00000C30 5200            	   687: 	addi.b #1,d0							; increment tail index
00:00000C32 0200001F        	   688: 	andi.b #31,d0							; wrap at buffer limit
00:00000C36 13C000100012    	   689: 	move.b d0,_KeybdTail			; update tail index
00:00000C3C 523900100013    	   690: 	addi.b #1,_KeybdCnt				; increment buffer count
                            	   691: .0002:
00:00000C42 4E7A0FE0        	   692: 	movec	coreno,d0
00:00000C46 4840            	   693: 	swap d0
00:00000C48 7203            	   694: 	moveq	#KEYBD_SEMA,d1
00:00000C4A 6100199E        	   695: 	bsr	UnlockSemaphore
                            	   696: .0001:
00:00000C4E 4CDF0103        	   697: 	movem.l	(a7)+,d0/d1/a0		; return
00:00000C52 4E73            	   698: 	rte
                            	   699: 
                            	   700: ;--------------------------------------------------------------------------
                            	   701: ; PS2 scan codes to ascii conversion tables.
                            	   702: ;--------------------------------------------------------------------------
                            	   703: ;
                            	   704: _unshiftedScanCodes:
00:00000C54 2E              	   705: 	dc.b	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
00:00000C55 A9
00:00000C56 2E
00:00000C57 A5
00:00000C58 A3
00:00000C59 A1
00:00000C5A A2
00:00000C5B AC
00:00000C5C 2E              	   706: 	dc.b	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
00:00000C5D AA
00:00000C5E A8
00:00000C5F A6
00:00000C60 A4
00:00000C61 09
00:00000C62 60
00:00000C63 2E
00:00000C64 2E              	   707: 	dc.b	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
00:00000C65 2E
00:00000C66 2E
00:00000C67 2E
00:00000C68 2E
00:00000C69 71
00:00000C6A 31
00:00000C6B 2E
00:00000C6C 2E              	   708: 	dc.b	$2e,$2e,$7a,$73,$61,$77,$32,$2e
00:00000C6D 2E
00:00000C6E 7A
00:00000C6F 73
00:00000C70 61
00:00000C71 77
00:00000C72 32
00:00000C73 2E
00:00000C74 2E              	   709: 	dc.b	$2e,$63,$78,$64,$65,$34,$33,$2e
00:00000C75 63
00:00000C76 78
00:00000C77 64
00:00000C78 65
00:00000C79 34
00:00000C7A 33
00:00000C7B 2E
00:00000C7C 2E              	   710: 	dc.b	$2e,$20,$76,$66,$74,$72,$35,$2e
00:00000C7D 20
00:00000C7E 76
00:00000C7F 66
00:00000C80 74
00:00000C81 72
00:00000C82 35
00:00000C83 2E
00:00000C84 2E              	   711: 	dc.b	$2e,$6e,$62,$68,$67,$79,$36,$2e
00:00000C85 6E
00:00000C86 62
00:00000C87 68
00:00000C88 67
00:00000C89 79
00:00000C8A 36
00:00000C8B 2E
00:00000C8C 2E              	   712: 	dc.b	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
00:00000C8D 2E
00:00000C8E 6D
00:00000C8F 6A
00:00000C90 75
00:00000C91 37
00:00000C92 38
00:00000C93 2E
00:00000C94 2E              	   713: 	dc.b	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
00:00000C95 2C
00:00000C96 6B
00:00000C97 69
00:00000C98 6F
00:00000C99 30
00:00000C9A 39
00:00000C9B 2E
00:00000C9C 2E              	   714: 	dc.b	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
00:00000C9D 2E
00:00000C9E 2F
00:00000C9F 6C
00:00000CA0 3B
00:00000CA1 70
00:00000CA2 2D
00:00000CA3 2E
00:00000CA4 2E              	   715: 	dc.b	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
00:00000CA5 2E
00:00000CA6 27
00:00000CA7 2E
00:00000CA8 5B
00:00000CA9 3D
00:00000CAA 2E
00:00000CAB 2E
00:00000CAC AD              	   716: 	dc.b	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
00:00000CAD 2E
00:00000CAE 0D
00:00000CAF 5D
00:00000CB0 2E
00:00000CB1 5C
00:00000CB2 2E
00:00000CB3 2E
00:00000CB4 2E              	   717: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:00000CB5 2E
00:00000CB6 2E
00:00000CB7 2E
00:00000CB8 2E
00:00000CB9 2E
00:00000CBA 08
00:00000CBB 2E
00:00000CBC 2E              	   718: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
00:00000CBD 95
00:00000CBE 2E
00:00000CBF 93
00:00000CC0 94
00:00000CC1 2E
00:00000CC2 2E
00:00000CC3 2E
00:00000CC4 98              	   719: 	dc.b	$98,$7f,$92,$2e,$91,$90,$1b,$af
00:00000CC5 7F
00:00000CC6 92
00:00000CC7 2E
00:00000CC8 91
00:00000CC9 90
00:00000CCA 1B
00:00000CCB AF
00:00000CCC AB              	   720: 	dc.b	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
00:00000CCD 2E
00:00000CCE 97
00:00000CCF 2E
00:00000CD0 2E
00:00000CD1 96
00:00000CD2 AE
00:00000CD3 2E
                            	   721: 
00:00000CD4 2E              	   722: 	dc.b	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
00:00000CD5 2E
00:00000CD6 2E
00:00000CD7 A7
00:00000CD8 2E
00:00000CD9 2E
00:00000CDA 2E
00:00000CDB 2E
00:00000CDC 2E              	   723: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CDD 2E
00:00000CDE 2E
00:00000CDF 2E
00:00000CE0 2E
00:00000CE1 2E
00:00000CE2 2E
00:00000CE3 2E
00:00000CE4 2E              	   724: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CE5 2E
00:00000CE6 2E
00:00000CE7 2E
00:00000CE8 2E
00:00000CE9 2E
00:00000CEA 2E
00:00000CEB 2E
00:00000CEC 2E              	   725: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CED 2E
00:00000CEE 2E
00:00000CEF 2E
00:00000CF0 2E
00:00000CF1 2E
00:00000CF2 2E
00:00000CF3 2E
00:00000CF4 2E              	   726: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CF5 2E
00:00000CF6 2E
00:00000CF7 2E
00:00000CF8 2E
00:00000CF9 2E
00:00000CFA 2E
00:00000CFB 2E
00:00000CFC 2E              	   727: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CFD 2E
00:00000CFE 2E
00:00000CFF 2E
00:00000D00 2E
00:00000D01 2E
00:00000D02 2E
00:00000D03 2E
00:00000D04 2E              	   728: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D05 2E
00:00000D06 2E
00:00000D07 2E
00:00000D08 2E
00:00000D09 2E
00:00000D0A 2E
00:00000D0B 2E
00:00000D0C 2E              	   729: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D0D 2E
00:00000D0E 2E
00:00000D0F 2E
00:00000D10 2E
00:00000D11 2E
00:00000D12 2E
00:00000D13 2E
00:00000D14 2E              	   730: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D15 2E
00:00000D16 2E
00:00000D17 2E
00:00000D18 2E
00:00000D19 2E
00:00000D1A 2E
00:00000D1B 2E
00:00000D1C 2E              	   731: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D1D 2E
00:00000D1E 2E
00:00000D1F 2E
00:00000D20 2E
00:00000D21 2E
00:00000D22 2E
00:00000D23 2E
00:00000D24 2E              	   732: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D25 2E
00:00000D26 2E
00:00000D27 2E
00:00000D28 2E
00:00000D29 2E
00:00000D2A 2E
00:00000D2B 2E
00:00000D2C 2E              	   733: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D2D 2E
00:00000D2E 2E
00:00000D2F 2E
00:00000D30 2E
00:00000D31 2E
00:00000D32 2E
00:00000D33 2E
00:00000D34 2E              	   734: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D35 2E
00:00000D36 2E
00:00000D37 2E
00:00000D38 2E
00:00000D39 2E
00:00000D3A 2E
00:00000D3B 2E
00:00000D3C 2E              	   735: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D3D 2E
00:00000D3E 2E
00:00000D3F 2E
00:00000D40 2E
00:00000D41 2E
00:00000D42 2E
00:00000D43 2E
00:00000D44 2E              	   736: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D45 2E
00:00000D46 2E
00:00000D47 2E
00:00000D48 2E
00:00000D49 2E
00:00000D4A 2E
00:00000D4B 2E
00:00000D4C 2E              	   737: 	dc.b	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
00:00000D4D 2E
00:00000D4E FA
00:00000D4F 2E
00:00000D50 2E
00:00000D51 2E
00:00000D52 2E
00:00000D53 2E
                            	   738: 
                            	   739: _shiftedScanCodes:
00:00000D54 2E              	   740: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D55 2E
00:00000D56 2E
00:00000D57 2E
00:00000D58 2E
00:00000D59 2E
00:00000D5A 2E
00:00000D5B 2E
00:00000D5C 2E              	   741: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
00:00000D5D 2E
00:00000D5E 2E
00:00000D5F 2E
00:00000D60 2E
00:00000D61 09
00:00000D62 7E
00:00000D63 2E
00:00000D64 2E              	   742: 	dc.b	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
00:00000D65 2E
00:00000D66 2E
00:00000D67 2E
00:00000D68 2E
00:00000D69 51
00:00000D6A 21
00:00000D6B 2E
00:00000D6C 2E              	   743: 	dc.b	$2e,$2e,$5a,$53,$41,$57,$40,$2e
00:00000D6D 2E
00:00000D6E 5A
00:00000D6F 53
00:00000D70 41
00:00000D71 57
00:00000D72 40
00:00000D73 2E
00:00000D74 2E              	   744: 	dc.b	$2e,$43,$58,$44,$45,$24,$23,$2e
00:00000D75 43
00:00000D76 58
00:00000D77 44
00:00000D78 45
00:00000D79 24
00:00000D7A 23
00:00000D7B 2E
00:00000D7C 2E              	   745: 	dc.b	$2e,$20,$56,$46,$54,$52,$25,$2e
00:00000D7D 20
00:00000D7E 56
00:00000D7F 46
00:00000D80 54
00:00000D81 52
00:00000D82 25
00:00000D83 2E
00:00000D84 2E              	   746: 	dc.b	$2e,$4e,$42,$48,$47,$59,$5e,$2e
00:00000D85 4E
00:00000D86 42
00:00000D87 48
00:00000D88 47
00:00000D89 59
00:00000D8A 5E
00:00000D8B 2E
00:00000D8C 2E              	   747: 	dc.b	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
00:00000D8D 2E
00:00000D8E 4D
00:00000D8F 4A
00:00000D90 55
00:00000D91 26
00:00000D92 2A
00:00000D93 2E
00:00000D94 2E              	   748: 	dc.b	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
00:00000D95 3C
00:00000D96 4B
00:00000D97 49
00:00000D98 4F
00:00000D99 29
00:00000D9A 28
00:00000D9B 2E
00:00000D9C 2E              	   749: 	dc.b	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
00:00000D9D 3E
00:00000D9E 3F
00:00000D9F 4C
00:00000DA0 3A
00:00000DA1 50
00:00000DA2 5F
00:00000DA3 2E
00:00000DA4 2E              	   750: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
00:00000DA5 2E
00:00000DA6 22
00:00000DA7 2E
00:00000DA8 7B
00:00000DA9 2B
00:00000DAA 2E
00:00000DAB 2E
00:00000DAC 2E              	   751: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
00:00000DAD 2E
00:00000DAE 0D
00:00000DAF 7D
00:00000DB0 2E
00:00000DB1 7C
00:00000DB2 2E
00:00000DB3 2E
00:00000DB4 2E              	   752: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:00000DB5 2E
00:00000DB6 2E
00:00000DB7 2E
00:00000DB8 2E
00:00000DB9 2E
00:00000DBA 08
00:00000DBB 2E
00:00000DBC 2E              	   753: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DBD 2E
00:00000DBE 2E
00:00000DBF 2E
00:00000DC0 2E
00:00000DC1 2E
00:00000DC2 2E
00:00000DC3 2E
00:00000DC4 2E              	   754: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
00:00000DC5 7F
00:00000DC6 2E
00:00000DC7 2E
00:00000DC8 2E
00:00000DC9 2E
00:00000DCA 1B
00:00000DCB 2E
00:00000DCC 2E              	   755: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DCD 2E
00:00000DCE 2E
00:00000DCF 2E
00:00000DD0 2E
00:00000DD1 2E
00:00000DD2 2E
00:00000DD3 2E
                            	   756: 
00:00000DD4 2E              	   757: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DD5 2E
00:00000DD6 2E
00:00000DD7 2E
00:00000DD8 2E
00:00000DD9 2E
00:00000DDA 2E
00:00000DDB 2E
00:00000DDC 2E              	   758: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DDD 2E
00:00000DDE 2E
00:00000DDF 2E
00:00000DE0 2E
00:00000DE1 2E
00:00000DE2 2E
00:00000DE3 2E
00:00000DE4 2E              	   759: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DE5 2E
00:00000DE6 2E
00:00000DE7 2E
00:00000DE8 2E
00:00000DE9 2E
00:00000DEA 2E
00:00000DEB 2E
00:00000DEC 2E              	   760: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DED 2E
00:00000DEE 2E
00:00000DEF 2E
00:00000DF0 2E
00:00000DF1 2E
00:00000DF2 2E
00:00000DF3 2E
00:00000DF4 2E              	   761: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DF5 2E
00:00000DF6 2E
00:00000DF7 2E
00:00000DF8 2E
00:00000DF9 2E
00:00000DFA 2E
00:00000DFB 2E
00:00000DFC 2E              	   762: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DFD 2E
00:00000DFE 2E
00:00000DFF 2E
00:00000E00 2E
00:00000E01 2E
00:00000E02 2E
00:00000E03 2E
00:00000E04 2E              	   763: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E05 2E
00:00000E06 2E
00:00000E07 2E
00:00000E08 2E
00:00000E09 2E
00:00000E0A 2E
00:00000E0B 2E
00:00000E0C 2E              	   764: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E0D 2E
00:00000E0E 2E
00:00000E0F 2E
00:00000E10 2E
00:00000E11 2E
00:00000E12 2E
00:00000E13 2E
00:00000E14 2E              	   765: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E15 2E
00:00000E16 2E
00:00000E17 2E
00:00000E18 2E
00:00000E19 2E
00:00000E1A 2E
00:00000E1B 2E
00:00000E1C 2E              	   766: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E1D 2E
00:00000E1E 2E
00:00000E1F 2E
00:00000E20 2E
00:00000E21 2E
00:00000E22 2E
00:00000E23 2E
00:00000E24 2E              	   767: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E25 2E
00:00000E26 2E
00:00000E27 2E
00:00000E28 2E
00:00000E29 2E
00:00000E2A 2E
00:00000E2B 2E
00:00000E2C 2E              	   768: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E2D 2E
00:00000E2E 2E
00:00000E2F 2E
00:00000E30 2E
00:00000E31 2E
00:00000E32 2E
00:00000E33 2E
00:00000E34 2E              	   769: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E35 2E
00:00000E36 2E
00:00000E37 2E
00:00000E38 2E
00:00000E39 2E
00:00000E3A 2E
00:00000E3B 2E
00:00000E3C 2E              	   770: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E3D 2E
00:00000E3E 2E
00:00000E3F 2E
00:00000E40 2E
00:00000E41 2E
00:00000E42 2E
00:00000E43 2E
00:00000E44 2E              	   771: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E45 2E
00:00000E46 2E
00:00000E47 2E
00:00000E48 2E
00:00000E49 2E
00:00000E4A 2E
00:00000E4B 2E
00:00000E4C 2E              	   772: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E4D 2E
00:00000E4E 2E
00:00000E4F 2E
00:00000E50 2E
00:00000E51 2E
00:00000E52 2E
00:00000E53 2E
                            	   773: 
                            	   774: ; control
                            	   775: _keybdControlCodes:
00:00000E54 2E              	   776: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E55 2E
00:00000E56 2E
00:00000E57 2E
00:00000E58 2E
00:00000E59 2E
00:00000E5A 2E
00:00000E5B 2E
00:00000E5C 2E              	   777: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
00:00000E5D 2E
00:00000E5E 2E
00:00000E5F 2E
00:00000E60 2E
00:00000E61 09
00:00000E62 7E
00:00000E63 2E
00:00000E64 2E              	   778: 	dc.b	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
00:00000E65 2E
00:00000E66 2E
00:00000E67 2E
00:00000E68 2E
00:00000E69 11
00:00000E6A 21
00:00000E6B 2E
00:00000E6C 2E              	   779: 	dc.b	$2e,$2e,$1a,$13,$01,$17,$40,$2e
00:00000E6D 2E
00:00000E6E 1A
00:00000E6F 13
00:00000E70 01
00:00000E71 17
00:00000E72 40
00:00000E73 2E
00:00000E74 2E              	   780: 	dc.b	$2e,$03,$18,$04,$05,$24,$23,$2e
00:00000E75 03
00:00000E76 18
00:00000E77 04
00:00000E78 05
00:00000E79 24
00:00000E7A 23
00:00000E7B 2E
00:00000E7C 2E              	   781: 	dc.b	$2e,$20,$16,$06,$14,$12,$25,$2e
00:00000E7D 20
00:00000E7E 16
00:00000E7F 06
00:00000E80 14
00:00000E81 12
00:00000E82 25
00:00000E83 2E
00:00000E84 2E              	   782: 	dc.b	$2e,$0e,$02,$08,$07,$19,$5e,$2e
00:00000E85 0E
00:00000E86 02
00:00000E87 08
00:00000E88 07
00:00000E89 19
00:00000E8A 5E
00:00000E8B 2E
00:00000E8C 2E              	   783: 	dc.b	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
00:00000E8D 2E
00:00000E8E 0D
00:00000E8F 0A
00:00000E90 15
00:00000E91 26
00:00000E92 2A
00:00000E93 2E
00:00000E94 2E              	   784: 	dc.b	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
00:00000E95 3C
00:00000E96 0B
00:00000E97 09
00:00000E98 0F
00:00000E99 29
00:00000E9A 28
00:00000E9B 2E
00:00000E9C 2E              	   785: 	dc.b	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
00:00000E9D 3E
00:00000E9E 3F
00:00000E9F 0C
00:00000EA0 3A
00:00000EA1 10
00:00000EA2 5F
00:00000EA3 2E
00:00000EA4 2E              	   786: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
00:00000EA5 2E
00:00000EA6 22
00:00000EA7 2E
00:00000EA8 7B
00:00000EA9 2B
00:00000EAA 2E
00:00000EAB 2E
00:00000EAC 2E              	   787: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
00:00000EAD 2E
00:00000EAE 0D
00:00000EAF 7D
00:00000EB0 2E
00:00000EB1 7C
00:00000EB2 2E
00:00000EB3 2E
00:00000EB4 2E              	   788: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:00000EB5 2E
00:00000EB6 2E
00:00000EB7 2E
00:00000EB8 2E
00:00000EB9 2E
00:00000EBA 08
00:00000EBB 2E
00:00000EBC 2E              	   789: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EBD 2E
00:00000EBE 2E
00:00000EBF 2E
00:00000EC0 2E
00:00000EC1 2E
00:00000EC2 2E
00:00000EC3 2E
00:00000EC4 2E              	   790: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
00:00000EC5 7F
00:00000EC6 2E
00:00000EC7 2E
00:00000EC8 2E
00:00000EC9 2E
00:00000ECA 1B
00:00000ECB 2E
00:00000ECC 2E              	   791: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000ECD 2E
00:00000ECE 2E
00:00000ECF 2E
00:00000ED0 2E
00:00000ED1 2E
00:00000ED2 2E
00:00000ED3 2E
                            	   792: 
                            	   793: _keybdExtendedCodes:
00:00000ED4 2E              	   794: 	dc.b	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
00:00000ED5 2E
00:00000ED6 2E
00:00000ED7 2E
00:00000ED8 A3
00:00000ED9 A1
00:00000EDA A2
00:00000EDB 2E
00:00000EDC 2E              	   795: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EDD 2E
00:00000EDE 2E
00:00000EDF 2E
00:00000EE0 2E
00:00000EE1 2E
00:00000EE2 2E
00:00000EE3 2E
00:00000EE4 2E              	   796: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EE5 2E
00:00000EE6 2E
00:00000EE7 2E
00:00000EE8 2E
00:00000EE9 2E
00:00000EEA 2E
00:00000EEB 2E
00:00000EEC 2E              	   797: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EED 2E
00:00000EEE 2E
00:00000EEF 2E
00:00000EF0 2E
00:00000EF1 2E
00:00000EF2 2E
00:00000EF3 2E
00:00000EF4 2E              	   798: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EF5 2E
00:00000EF6 2E
00:00000EF7 2E
00:00000EF8 2E
00:00000EF9 2E
00:00000EFA 2E
00:00000EFB 2E
00:00000EFC 2E              	   799: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EFD 2E
00:00000EFE 2E
00:00000EFF 2E
00:00000F00 2E
00:00000F01 2E
00:00000F02 2E
00:00000F03 2E
00:00000F04 2E              	   800: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000F05 2E
00:00000F06 2E
00:00000F07 2E
00:00000F08 2E
00:00000F09 2E
00:00000F0A 2E
00:00000F0B 2E
00:00000F0C 2E              	   801: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000F0D 2E
00:00000F0E 2E
00:00000F0F 2E
00:00000F10 2E
00:00000F11 2E
00:00000F12 2E
00:00000F13 2E
00:00000F14 2E              	   802: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000F15 2E
00:00000F16 2E
00:00000F17 2E
00:00000F18 2E
00:00000F19 2E
00:00000F1A 2E
00:00000F1B 2E
00:00000F1C 2E              	   803: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000F1D 2E
00:00000F1E 2E
00:00000F1F 2E
00:00000F20 2E
00:00000F21 2E
00:00000F22 2E
00:00000F23 2E
00:00000F24 2E              	   804: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000F25 2E
00:00000F26 2E
00:00000F27 2E
00:00000F28 2E
00:00000F29 2E
00:00000F2A 2E
00:00000F2B 2E
00:00000F2C 2E              	   805: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000F2D 2E
00:00000F2E 2E
00:00000F2F 2E
00:00000F30 2E
00:00000F31 2E
00:00000F32 2E
00:00000F33 2E
00:00000F34 2E              	   806: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000F35 2E
00:00000F36 2E
00:00000F37 2E
00:00000F38 2E
00:00000F39 2E
00:00000F3A 2E
00:00000F3B 2E
00:00000F3C 2E              	   807: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
00:00000F3D 95
00:00000F3E 2E
00:00000F3F 93
00:00000F40 94
00:00000F41 2E
00:00000F42 2E
00:00000F43 2E
00:00000F44 98              	   808: 	dc.b	$98,$99,$92,$2e,$91,$90,$2e,$2e
00:00000F45 99
00:00000F46 92
00:00000F47 2E
00:00000F48 91
00:00000F49 90
00:00000F4A 2E
00:00000F4B 2E
00:00000F4C 2E              	   809: 	dc.b	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
00:00000F4D 2E
00:00000F4E 97
00:00000F4F 2E
00:00000F50 2E
00:00000F51 96
00:00000F52 2E
00:00000F53 2E
                            	   810: 
                            	   811: 

Source: "boot.x68"
                            	   609: 	include "textvid.x68"

Source: "textvid.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;------------------------------------------------------------------------------
                            	    38: ;------------------------------------------------------------------------------
                            	    39: ; Setup the text video device
                            	    40: ; stdout = text screen controller
                            	    41: ;------------------------------------------------------------------------------
                            	    42: ;------------------------------------------------------------------------------
                            	    43: 
                            	    44: TBLE macro arg1
                            	    45: 	dc.l (\1)
                            	    46: endm
                            	    47: 
                            	    48: 	code
                            	    49: 	even
                            	    50: 
                            	    51: 	align 2
                            	    52: TEXTVID_CMDTBL:
                            	    53: 	TBLE textvid_init					; 0
00:00000F54 00001034        	     1M 	dc.l (textvid_init)
                            	    54: 	TBLE textvid_stat
00:00000F58 000010DC        	     1M 	dc.l (textvid_stat)
                            	    55: 	TBLE textvid_putchar
00:00000F5C 00001286        	     1M 	dc.l (textvid_putchar)
                            	    56: 	TBLE textvid_putbuf
00:00000F60 000010E8        	     1M 	dc.l (textvid_putbuf)
                            	    57: 	TBLE textvid_getchar
00:00000F64 000010E0        	     1M 	dc.l (textvid_getchar)
                            	    58: 	TBLE textvid_getbuf
00:00000F68 000010E8        	     1M 	dc.l (textvid_getbuf)
                            	    59: 	TBLE textvid_set_inpos
00:00000F6C 00001102        	     1M 	dc.l (textvid_set_inpos)
                            	    60: 	TBLE textvid_set_outpos
00:00000F70 00001118        	     1M 	dc.l (textvid_set_outpos)
                            	    61: 	TBLE textvid_stub
00:00000F74 000010E8        	     1M 	dc.l (textvid_stub)
                            	    62: 	TBLE textvid_stub
00:00000F78 000010E8        	     1M 	dc.l (textvid_stub)
                            	    63: 	TBLE textvid_stub				; 10
00:00000F7C 000010E8        	     1M 	dc.l (textvid_stub)
                            	    64: 	TBLE textvid_stub
00:00000F80 000010E8        	     1M 	dc.l (textvid_stub)
                            	    65: 	TBLE textvid_clear
00:00000F84 000011C4        	     1M 	dc.l (textvid_clear)
                            	    66: 	TBLE textvid_stub
00:00000F88 000010E8        	     1M 	dc.l (textvid_stub)
                            	    67: 	TBLE textvid_stub
00:00000F8C 000010E8        	     1M 	dc.l (textvid_stub)
                            	    68: 	TBLE textvid_stub
00:00000F90 000010E8        	     1M 	dc.l (textvid_stub)
                            	    69: 	TBLE textvid_getbuf1
00:00000F94 0000117A        	     1M 	dc.l (textvid_getbuf1)
                            	    70: 	TBLE textvid_stub
00:00000F98 000010E8        	     1M 	dc.l (textvid_stub)
                            	    71: 	TBLE textvid_stub
00:00000F9C 000010E8        	     1M 	dc.l (textvid_stub)
                            	    72: 	TBLE textvid_set_unit
00:00000FA0 0000118A        	     1M 	dc.l (textvid_set_unit)
                            	    73: 	TBLE textvid_get_dimen	; 20
00:00000FA4 00001194        	     1M 	dc.l (textvid_get_dimen)
                            	    74: 	TBLE textvid_get_color
00:00000FA8 0000116A        	     1M 	dc.l (textvid_get_color)
                            	    75: 	TBLE textvid_get_inpos
00:00000FAC 000010EC        	     1M 	dc.l (textvid_get_inpos)
                            	    76: 	TBLE textvid_get_outpos
00:00000FB0 0000112E        	     1M 	dc.l (textvid_get_outpos)
                            	    77: 	TBLE textvid_get_outptr
00:00000FB4 00001144        	     1M 	dc.l (textvid_get_outptr)
                            	    78: 
                            	    79: 	code
                            	    80: 	even
                            	    81: textvid_cmdproc:
00:00000FB8 0C060019        	    82: 	cmpi.b #25,d6
00:00000FBC 641A            	    83: 	bhs.s .0001
00:00000FBE 48E70280        	    84: 	movem.l d6/a0,-(a7)
00:00000FC2 4886            	    85: 	ext.w d6
00:00000FC4 48C6            	    86: 	ext.l d6
00:00000FC6 E54E            	    87: 	lsl.w #2,d6
00:00000FC8 41FAFF8A        	    88: 	lea TEXTVID_CMDTBL,a0
00:00000FCC 20706000        	    89: 	move.l (a0,d6.w),a0
00:00000FD0 4E90            	    90: 	jsr (a0)
00:00000FD2 4CDF0140        	    91: 	movem.l (a7)+,d6/a0
00:00000FD6 4E75            	    92: 	rts
                            	    93: .0001:
00:00000FD8 7002            	    94: 	moveq #E_Func,d0
00:00000FDA 4E75            	    95: 	rts
                            	    96: 
                            	    97: setup_textvid:
00:00000FDC 48E780C0        	    98: 	movem.l d0/a0/a1,-(a7)
00:00000FE0 7020            	    99: 	moveq #32,d0
00:00000FE2 41F900040B08    	   100: 	lea.l textvid_dcb,a0
                            	   101: .0001:
00:00000FE8 4298            	   102: 	clr.l (a0)+
00:00000FEA 51C8FFFC        	   103: 	dbra d0,.0001
00:00000FEE 23FC444342200004	   104: 	move.l #$44434220,textvid_dcb+DCB_MAGIC				; 'DCB '
00:00000FF6 0B08
00:00000FF8 23FC544558540004	   105: 	move.l #$54455854,textvid_dcb+DCB_NAME				; 'TEXTVID'
00:00001000 0B0C
00:00001002 23FC564944000004	   106: 	move.l #$56494400,textvid_dcb+DCB_NAME+4			;
00:0000100A 0B10
00:0000100C 23FC00000FB80004	   107: 	move.l #textvid_cmdproc,textvid_dcb+DCB_CMDPROC
00:00001014 0B20
00:00001016 611C            	   108: 	bsr textvid_init
00:00001018 61001632        	   109: 	jsr Delay3s
00:0000101C 610001A6        	   110: 	bsr textvid_clear
00:00001020 43F900040B08    	   111: 	lea.l textvid_dcb+DCB_MAGIC,a1
00:00001026 61006AE4        	   112: 	jsr DisplayString
00:0000102A 61006AC6        	   113: 	jsr CRLF
00:0000102E 4CDF0301        	   114: 	movem.l (a7)+,d0/a0/a1
00:00001032 4E75            	   115: 	rts
                            	   116: 
                            	   117: textvid_init:
00:00001034 2F00            	   118: 	move.l d0,-(a7)
                            	   119: 	if (SCREEN_FORMAT==1)
00:00001036 23FC000000FF0004	   120: 		move.l #$0000ff,fgColor		; set foreground / background color (white)
00:0000103E 0084
00:00001040 23FC000000020004	   121: 		move.l #$000002,bkColor		; medium blue
00:00001048 0088
00:0000104A 23FC000000FF0004	   122: 		move.l #$0000ff,textvid_dcb+DCB_FGCOLOR
00:00001052 0B6C
00:00001054 23FC000000020004	   123: 		move.l #$000002,textvid_dcb+DCB_BKCOLOR		; medium blue
00:0000105C 0B68
                            	   124: 	else
                            	   125: 		move.l #$1fffff,fgColor		; set foreground / background color (white)
                            	   126: 		move.l #$00003f,bkColor		; medium blue
                            	   127: 		move.l #$1fffff,textvid_dcb+DCB_FGCOLOR		; set foreground / background color (white)
                            	   128: 		move.l #$00003f,textvid_dcb+DCB_BKCOLOR		; medium blue
                            	   129: 	endif
00:0000105E 4E7A0FE0        	   130: 	movec.l	coreno,d0					; get core number (2 to 9)
00:00001062 5500            	   131: 	subi.b #2,d0							; adjust (0 to 7)
                            	   132: 	if (SCREEN_FORMAT==1)
00:00001064 C0FC2000        	   133: 		mulu #8192,d0						; compute screen location
                            	   134: 	else
                            	   135: 		mulu #16384,d0						; compute screen location
                            	   136: 	endif
                            	   137: 	if HAS_MMU
                            	   138: 		addi.l #$01E00000,d0
                            	   139: 	else
00:00001068 0680FD000000    	   140: 		addi.l #$FD000000,d0
                            	   141: 	endif
00:0000106E 23C000040B40    	   142: 	move.l d0,textvid_dcb+DCB_INBUFPTR
00:00001074 23C000040B44    	   143: 	move.l d0,textvid_dcb+DCB_OUTBUFPTR
00:0000107A 23C000040004    	   144: 	move.l d0,TextScr
                            	   145: 	if (SCREEN_FORMAT==1)
00:00001080 23FC000020000004	   146: 		move.l #8192,textvid_dcb+DCB_INBUFSIZE
00:00001088 0B48
00:0000108A 23FC000020000004	   147: 		move.l #8192,textvid_dcb+DCB_OUTBUFSIZE
00:00001092 0B4C
                            	   148: 	else
                            	   149: 		move.l #16384,textvid_dcb+DCB_INBUFSIZE
                            	   150: 		move.l #16384,textvid_dcb+DCB_OUTBUFSIZE
                            	   151: 	endif
00:00001094 23FC000000340004	   152: 	move.l #TEXTCOL,textvid_dcb+DCB_OUTDIMX	; set rows and columns
00:0000109C 0B5C
00:0000109E 23FC000000200004	   153: 	move.l #TEXTROW,textvid_dcb+DCB_OUTDIMY
00:000010A6 0B60
00:000010A8 23FC000000340004	   154: 	move.l #TEXTCOL,textvid_dcb+DCB_INDIMX		; set rows and columns
00:000010B0 0B50
00:000010B2 23FC000000200004	   155: 	move.l #TEXTROW,textvid_dcb+DCB_INDIMY
00:000010BA 0B54
00:000010BC 13FC00340004008D	   156: 	move.b #TEXTCOL,TextCols				; set rows and columns
00:000010C4 13FC00200004008C	   157: 	move.b #TEXTROW,TextRows
00:000010CC 42B900040B28    	   158: 	clr.l textvid_dcb+DCB_OUTPOSX
00:000010D2 42B900040B2C    	   159: 	clr.l textvid_dcb+DCB_OUTPOSY
00:000010D8 201F            	   160: 	move.l (a7)+,d0
00:000010DA 4E75            	   161: 	rts
                            	   162: 
                            	   163: textvid_stat:
00:000010DC 7000            	   164: 	moveq #E_Ok,d0
00:000010DE 4E75            	   165: 	rts
                            	   166: 
                            	   167: textvid_getchar:
00:000010E0 61007066        	   168: 	bsr FromScreen
00:000010E4 7000            	   169: 	moveq #E_Ok,d0
00:000010E6 4E75            	   170: 	rts
                            	   171: 
                            	   172: textvid_putbuf:
                            	   173: textvid_getbuf:
                            	   174: textvid_stub:
00:000010E8 700A            	   175: 	moveq #E_NotSupported,d0
00:000010EA 4E75            	   176: 	rts
                            	   177: 
                            	   178: textvid_get_inpos:
00:000010EC 223900040B34    	   179: 	move.l textvid_dcb+DCB_INPOSX,d1
00:000010F2 243900040B38    	   180: 	move.l textvid_dcb+DCB_INPOSY,d2
00:000010F8 263900040B3C    	   181: 	move.l textvid_dcb+DCB_INPOSZ,d3
00:000010FE 7000            	   182: 	move.l #E_Ok,d0
00:00001100 4E75            	   183: 	rts
                            	   184: 
                            	   185: textvid_set_inpos:
00:00001102 23C100040B34    	   186: 	move.l d1,textvid_dcb+DCB_INPOSX
00:00001108 23C200040B38    	   187: 	move.l d2,textvid_dcb+DCB_INPOSY
00:0000110E 23C300040B3C    	   188: 	move.l d3,textvid_dcb+DCB_INPOSZ
00:00001114 7000            	   189: 	move.l #E_Ok,d0
00:00001116 4E75            	   190: 	rts
                            	   191: 
                            	   192: textvid_set_outpos:
00:00001118 23C100040B28    	   193: 	move.l d1,textvid_dcb+DCB_OUTPOSX
00:0000111E 23C200040B2C    	   194: 	move.l d2,textvid_dcb+DCB_OUTPOSY
00:00001124 23C300040B30    	   195: 	move.l d3,textvid_dcb+DCB_OUTPOSZ
00:0000112A 7000            	   196: 	move.l #E_Ok,d0
00:0000112C 4E75            	   197: 	rts
                            	   198: 
                            	   199: textvid_get_outpos:
00:0000112E 223900040B28    	   200: 	move.l textvid_dcb+DCB_OUTPOSX,d1
00:00001134 243900040B2C    	   201: 	move.l textvid_dcb+DCB_OUTPOSY,d2
00:0000113A 263900040B30    	   202: 	move.l textvid_dcb+DCB_OUTPOSZ,d3
00:00001140 7000            	   203: 	move.l #E_Ok,d0
00:00001142 4E75            	   204: 	rts
                            	   205: 
                            	   206: textvid_get_outptr:
00:00001144 2F02            	   207: 	move.l d2,-(a7)
00:00001146 223900040B28    	   208: 	move.l textvid_dcb+DCB_OUTPOSX,d1
00:0000114C 203900040B2C    	   209: 	move.l textvid_dcb+DCB_OUTPOSY,d0
00:00001152 243900040B5C    	   210: 	move.l textvid_dcb+DCB_OUTDIMX,d2
00:00001158 C0C2            	   211: 	mulu d2,d0
00:0000115A D280            	   212: 	add.l d0,d1
                            	   213: 	if (SCREEN_FORMAT==1)
00:0000115C E589            	   214: 		lsl.l #2,d1
                            	   215: 	else
                            	   216: 		lsl.l #3,d1
                            	   217: 	endif
00:0000115E D2B900040B44    	   218: 	add.l textvid_dcb+DCB_OUTBUFPTR,d1
00:00001164 241F            	   219: 	move.l (a7)+,d2
00:00001166 7000            	   220: 	move.l #E_Ok,d0
00:00001168 4E75            	   221: 	rts
                            	   222: 
                            	   223: textvid_get_color:
00:0000116A 223900040B6C    	   224: 	move.l textvid_dcb+DCB_FGCOLOR,d1
00:00001170 243900040B68    	   225: 	move.l textvid_dcb+DCB_BKCOLOR,d2
00:00001176 7000            	   226: 	move.l #E_Ok,d0
00:00001178 4E75            	   227: 	rts
                            	   228: 
                            	   229: textvid_getbuf1:
00:0000117A 223900040B44    	   230: 	move.l textvid_dcb+DCB_OUTBUFPTR,d1
00:00001180 243900040B4C    	   231: 	move.l textvid_dcb+DCB_OUTBUFSIZE,d2
00:00001186 7000            	   232: 	move.l #E_Ok,d0
00:00001188 4E75            	   233: 	rts
                            	   234: 
                            	   235: textvid_set_unit:
00:0000118A 23C100040B88    	   236: 	move.l d1,textvid_dcb+DCB_UNIT
00:00001190 7000            	   237: 	move.l #E_Ok,d0
00:00001192 4E75            	   238: 	rts
                            	   239: 
                            	   240: textvid_get_dimen:
00:00001194 4A00            	   241: 	cmpi.b #0,d0
00:00001196 6616            	   242: 	bne.s .0001
00:00001198 223900040B5C    	   243: 	move.l textvid_dcb+DCB_OUTDIMX,d1
00:0000119E 243900040B60    	   244: 	move.l textvid_dcb+DCB_OUTDIMY,d2
00:000011A4 263900040B64    	   245: 	move.l textvid_dcb+DCB_OUTDIMZ,d3
00:000011AA 7000            	   246: 	move.l #E_Ok,d0
00:000011AC 4E75            	   247: 	rts
                            	   248: .0001:
00:000011AE 223900040B50    	   249: 	move.l textvid_dcb+DCB_INDIMX,d1
00:000011B4 243900040B54    	   250: 	move.l textvid_dcb+DCB_INDIMY,d2
00:000011BA 263900040B58    	   251: 	move.l textvid_dcb+DCB_INDIMZ,d3
00:000011C0 7000            	   252: 	move.l #E_Ok,d0
00:000011C2 4E75            	   253: 	rts
                            	   254: 
                            	   255: ; -----------------------------------------------------------------------------
                            	   256: ; -----------------------------------------------------------------------------
                            	   257: 
                            	   258: textvid_clear:
00:000011C4 23FCFFFFFFFFFDFF	   259: 	move.l #$FFFFFFFF,leds
00:000011CC C000
00:000011CE 48E77880        	   260: 	movem.l	d1/d2/d3/d4/a0,-(a7)
00:000011D2 4E7A0FE0        	   261: 	movec	coreno,d0
00:000011D6 4840            	   262: 	swap d0	
                            	   263: ;	moveq		#SCREEN_SEMA,d1
                            	   264: ;	bsr			LockSemaphore
00:000011D8 223900040B44    	   265: 	move.l textvid_dcb+DCB_OUTBUFPTR,d1
00:000011DE 243900040B4C    	   266: 	move.l textvid_dcb+DCB_OUTBUFSIZE,d2
00:000011E4 23FCFEFEFEFEFDFF	   267: 	move.l #$FEFEFEFE,leds
00:000011EC C000
00:000011EE 2041            	   268: 	move.l d1,a0								; a0 = pointer to screen area
00:000011F0 2802            	   269: 	move.l d2,d4
                            	   270: 	if (SCREEN_FORMAT==1)
00:000011F2 E48C            	   271: 		lsr.l #2,d4									; number of cells to clear
                            	   272: 	else
                            	   273: 		lsr.l #3,d4									; number of cells to clear
                            	   274: 	endif
00:000011F4 223900040B6C    	   275: 	move.l textvid_dcb+DCB_FGCOLOR,d1
00:000011FA 243900040B68    	   276: 	move.l textvid_dcb+DCB_BKCOLOR,d2
00:00001200 23FCFDFDFDFDFDFF	   277: 	move.l #$FDFDFDFD,leds
00:00001208 C000
                            	   278: ;	bsr	get_screen_color				; get the color bits
                            	   279: 	if (SCREEN_FORMAT==1)
00:0000120A 48C1            	   280: 		ext.l d1
00:0000120C E189            	   281: 		lsl.l #8,d1
00:0000120E 48C2            	   282: 		ext.l d2									; clear high order bits
00:00001210 8481            	   283: 		or.l d1,d2								; forground color in bits 24 to 31
00:00001212 4842            	   284: 		swap d2										; color in bits 16 to 23
00:00001214 00420020        	   285: 		ori.w #32,d2							; insert character to display (space)
00:00001218 E15A            	   286: 		rol.w #8,d2								; reverse byte order
00:0000121A 4842            	   287: 		swap d2
00:0000121C E15A            	   288: 		rol.w #8,d2
                            	   289: loop3:
00:0000121E 20C2            	   290: 		move.l d2,(a0)+						; copy to cell
                            	   291: 	else
                            	   292: 		lsl.l #5,d1								; high order background color bits go in bits 0 to 4
                            	   293: 		move.l d2,d3
                            	   294: 		swap d3
                            	   295: 		andi.l #$1f,d3
                            	   296: 		or.l d3,d1
                            	   297: 		; we want bkcolor in bits 16 to 32
                            	   298: 		; char in bits 0 to 15
                            	   299: 		swap d2										; color in bits 16 to 32
                            	   300: 		move.w #32,d2							; load space character
                            	   301: 		rol.w	#8,d2								; swap endian, text controller expects little endian
                            	   302: 		swap d2
                            	   303: 		rol.w	#8,d2
                            	   304: 		rol.w	#8,d0								; swap endian
                            	   305: 		swap d0
                            	   306: 		rol.w	#8,d0
                            	   307: loop3:
                            	   308: 		move.l d2,(a0)+						; copy char plus bkcolor to cell
                            	   309: 		move.l d1,(a0)+						; copy fgcolor to cell
                            	   310: 	endif
00:00001220 51CCFFFC        	   311: 	dbra d4,loop3
00:00001224 4E7A0FE0        	   312: 	movec coreno,d0
00:00001228 4840            	   313: 	swap d0	
                            	   314: ;	moveq #SCREEN_SEMA,d1
                            	   315: ;	bsr UnlockSemaphore
00:0000122A 23FCFCFCFCFCFDFF	   316: 	move.l #$FCFCFCFC,leds
00:00001232 C000
00:00001234 4CDF011E        	   317: 	movem.l (a7)+,d1/d2/d3/d4/a0
00:00001238 7000            	   318: 	move.l #E_Ok,d0
00:0000123A 4E75            	   319: 	rts
                            	   320: 
                            	   321: ; -----------------------------------------------------------------------------
                            	   322: ; Gets the screen color in d0 and d1. Setup already to be able to insert
                            	   323: ; character code.
                            	   324: ; -----------------------------------------------------------------------------
                            	   325: 
                            	   326: get_screen_color:
00:0000123C 2F02            	   327: 	move.l d2,-(a7)
00:0000123E 223900040B6C    	   328: 	move.l textvid_dcb+DCB_FGCOLOR,d1
00:00001244 243900040B68    	   329: 	move.l textvid_dcb+DCB_BKCOLOR,d2
                            	   330: 	if (SCREEN_FORMAT==1)
00:0000124A E189            	   331: 		lsl.l #8,d1							; foreground color in bits 8 to 15
00:0000124C 024200FF        	   332: 		andi.w #$ff,d2
00:00001250 8242            	   333: 		or.w d2,d1							; background color in bits 0 to 7
00:00001252 4841            	   334: 		swap d1									; foreground color in bits 24 to 31, bk in 16 to 23
00:00001254 4241            	   335: 		move.w #0,d1						; clear character
00:00001256 2001            	   336: 		move.l d1,d0
                            	   337: 	else
                            	   338: 		asl.l	#5,d1							; shift into position
                            	   339: 		ori.l	#$40000000,d1			; set priority
                            	   340: 		move.l d2,d0
                            	   341: 		lsr.l	#8,d2
                            	   342: 		lsr.l	#8,d2
                            	   343: 		andi.l #31,d2						; mask off extra bits
                            	   344: 		or.l d2,d1							; set background color bits in upper long word
                            	   345: 		asl.l	#8,d0							; shift into position for display ram
                            	   346: 		asl.l	#8,d0
                            	   347: 	endif
00:00001258 241F            	   348: 	move.l (a7)+,d2
00:0000125A 4E75            	   349: 	rts
                            	   350: 
                            	   351: ;------------------------------------------------------------------------------
                            	   352: ; Calculate screen memory location from CursorRow,CursorCol.
                            	   353: ; Destroys d0,d2,a0
                            	   354: ;------------------------------------------------------------------------------
                            	   355: 
                            	   356: CalcScreenLoc:
00:0000125C 48E7C400        	   357: 	movem.l d0/d1/d5,-(a7)
00:00001260 203900040B28    	   358: 	move.l textvid_dcb+DCB_OUTPOSX,d0
00:00001266 2A3900040B2C    	   359: 	move.l textvid_dcb+DCB_OUTPOSY,d5
00:0000126C 223900040B5C    	   360: 	move.l textvid_dcb+DCB_OUTDIMX,d1
00:00001272 CAC1            	   361: 	mulu d1,d5							; y * num cols
00:00001274 D085            	   362: 	add.l d5,d0							; plus x
                            	   363: 	if (SCREEN_FORMAT==1)
00:00001276 E580            	   364: 		asl.l #2,d0							; 4 bytes per char
                            	   365: 	else
                            	   366: 		asl.l	#3,d0							; 8 bytes per char
                            	   367: 	endif
00:00001278 207900040B44    	   368: 	move.l textvid_dcb+DCB_OUTBUFPTR,a0
00:0000127E D1C0            	   369: 	add.l	d0,a0								; a0 = screen location
00:00001280 4CDF0023        	   370: 	movem.l (a7)+,d0/d1/d5
00:00001284 4E75            	   371: 	rts
                            	   372: 
                            	   373: ;------------------------------------------------------------------------------
                            	   374: ; Display a character on the screen
                            	   375: ; Parameters:
                            	   376: ; 	d1.b = char to display
                            	   377: ;------------------------------------------------------------------------------
                            	   378: 
                            	   379: textvid_putchar:
00:00001286 48E77000        	   380: 	movem.l	d1/d2/d3,-(a7)
00:0000128A 4E7A2FE0        	   381: 	movec	coreno,d2
00:0000128E 0C020002        	   382: 	cmpi.b #2,d2
                            	   383: ;	bne.s		.0001
                            	   384: ;	bsr			SerialPutChar
                            	   385: .0001:
00:00001292 0281000000FF    	   386: 	andi.l #$ff,d1				; zero out upper bytes of d1
00:00001298 0C01000D        	   387: 	cmpi.b #13,d1				; carriage return ?
00:0000129C 6612            	   388: 	bne.s	dccr
00:0000129E 42B900040B28    	   389: 	clr.l	textvid_dcb+DCB_OUTPOSX	; just set cursor column to zero on a CR
                            	   390: dcx14:
00:000012A4 6100024E        	   391: 	bsr	SyncCursor				; set position in text controller
                            	   392: dcx7:
00:000012A8 4CDF000E        	   393: 	movem.l	(a7)+,d1/d2/d3
00:000012AC 7000            	   394: 	moveq #E_Ok,d0
00:000012AE 4E75            	   395: 	rts
                            	   396: dccr:
00:000012B0 0C010091        	   397: 	cmpi.b #$91,d1			; cursor right ?
00:000012B4 6618            	   398: 	bne.s dcx6
00:000012B6 243900040B5C    	   399: 	move.l textvid_dcb+DCB_OUTDIMX,d2
00:000012BC 5382            	   400: 	subq.l #1,d2
00:000012BE 94B900040B28    	   401: 	sub.l	textvid_dcb+DCB_OUTPOSX,d2
00:000012C4 67E2            	   402: 	beq.s	dcx7
00:000012C6 52B900040B28    	   403: 	addq.l #1,textvid_dcb+DCB_OUTPOSX
00:000012CC 60D6            	   404: 	bra.s dcx14
                            	   405: dcx6:
00:000012CE 0C010090        	   406: 	cmpi.b #$90,d1			; cursor up ?
00:000012D2 6610            	   407: 	bne.s	dcx8
00:000012D4 4AB900040B2C    	   408: 	tst.l textvid_dcb+DCB_OUTPOSY
00:000012DA 67CC            	   409: 	beq.s	dcx7
00:000012DC 53B900040B2C    	   410: 	subq.l #1,textvid_dcb+DCB_OUTPOSY
00:000012E2 60C0            	   411: 	bra.s	dcx14
                            	   412: dcx8:
00:000012E4 0C010093        	   413: 	cmpi.b #$93,d1			; cursor left?
00:000012E8 6610            	   414: 	bne.s	dcx9
00:000012EA 4AB900040B28    	   415: 	tst.l textvid_dcb+DCB_OUTPOSX
00:000012F0 67B6            	   416: 	beq.s	dcx7
00:000012F2 53B900040B28    	   417: 	subq.l #1,textvid_dcb+DCB_OUTPOSX
00:000012F8 60AA            	   418: 	bra.s	dcx14
                            	   419: dcx9:
00:000012FA 0C010092        	   420: 	cmpi.b #$92,d1			; cursor down ?
00:000012FE 6618            	   421: 	bne.s	dcx10
00:00001300 243900040B60    	   422: 	move.l textvid_dcb+DCB_OUTDIMY,d2
00:00001306 5382            	   423: 	subq.l #1,d2
00:00001308 B4B900040B2C    	   424: 	cmp.l	textvid_dcb+DCB_OUTPOSY,d2
00:0000130E 6798            	   425: 	beq.s	dcx7
00:00001310 52B900040B2C    	   426: 	addq.l #1,textvid_dcb+DCB_OUTPOSY
00:00001316 608C            	   427: 	bra.s	dcx14
                            	   428: dcx10:
00:00001318 0C010094        	   429: 	cmpi.b #$94,d1			; cursor home ?
00:0000131C 661C            	   430: 	bne.s	dcx11
00:0000131E 4AB900040B28    	   431: 	tst.l	textvid_dcb+DCB_OUTPOSX
00:00001324 670A            	   432: 	beq.s	dcx12
00:00001326 42B900040B28    	   433: 	clr.l	textvid_dcb+DCB_OUTPOSX
00:0000132C 6000FF76        	   434: 	bra	dcx14
                            	   435: dcx12:
00:00001330 42B900040B2C    	   436: 	clr.l	textvid_dcb+DCB_OUTPOSY
00:00001336 6000FF6C        	   437: 	bra	dcx14
                            	   438: dcx11:
00:0000133A 48E70080        	   439: 	movem.l	a0,-(a7)
00:0000133E 0C010099        	   440: 	cmpi.b #$99,d1				; delete ?
00:00001342 6760            	   441: 	beq.s	doDelete
00:00001344 0C010008        	   442: 	cmpi.b #CTRLH,d1			; backspace ?
00:00001348 674C            	   443: 	beq.s doBackspace
00:0000134A 0C010018        	   444: 	cmpi.b #CTRLX,d1			; delete line ?
00:0000134E 6700008A        	   445: 	beq	doCtrlX
00:00001352 0C01000A        	   446: 	cmpi.b #10,d1					; linefeed ?
00:00001356 672C            	   447: 	beq.s dclf
                            	   448: 
                            	   449: 	; regular char
00:00001358 23FCFFFFFFFFFDFF	   450: 	move.l #$FFFFFFFF,leds
00:00001360 C000
00:00001362 6100FEF8        	   451: 	bsr	CalcScreenLoc			; a0 = screen location
00:00001366 23FCFFFFFFFEFDFF	   452: 	move.l #$FFFFFFFE,leds
00:0000136E C000
00:00001370 2401            	   453: 	move.l d1,d2					; d2 = char
00:00001372 6100FEC8        	   454: 	bsr get_screen_color	; d0,d1 = color
00:00001376 8082            	   455: 	or.l d2,d0						; d0 = char + color
00:00001378 E158            	   456: 	rol.w	#8,d0						; swap bytes - text controller expects little endian data
00:0000137A 4840            	   457: 	swap d0								; swap halfs
00:0000137C E158            	   458: 	rol.w	#8,d0						; swap remaining bytes
                            	   459: 	if (SCREEN_FORMAT==1)
00:0000137E 20C0            	   460: 		move.l d0,(a0)+
                            	   461: 	else
                            	   462: 		move.l d0,(a0)+
                            	   463: 		rol.w	#8,d1					; swap bytes
                            	   464: 		swap d1							; swap halfs
                            	   465: 		rol.w	#8,d1					; swap remaining bytes
                            	   466: 		move.l d1,(a0)
                            	   467: 	endif
00:00001380 617C            	   468: 	bsr	IncCursorPos
00:00001382 6004            	   469: 	bra	dcx16
                            	   470: dclf:
00:00001384 61000092        	   471: 	bsr IncCursorRow
                            	   472: dcx16:
00:00001388 6100016A        	   473: 	bsr	SyncCursor
                            	   474: dcx4:
00:0000138C 205F            	   475: 	movem.l	(a7)+,a0			; get back a0
00:0000138E 4CDF000E        	   476: 	movem.l	(a7)+,d1/d2/d3
00:00001392 7000            	   477: 	moveq #E_Ok,d0
00:00001394 4E75            	   478: 	rts
                            	   479: 
                            	   480: 	;---------------------------
                            	   481: 	; CTRL-H: backspace
                            	   482: 	;---------------------------
                            	   483: doBackspace:
00:00001396 4AB900040B28    	   484: 	tst.l	textvid_dcb+DCB_OUTPOSX		; if already at start of line
00:0000139C 67EE            	   485: 	beq.s dcx4						; nothing to do
00:0000139E 53B900040B28    	   486: 	subq.l #1,textvid_dcb+DCB_OUTPOSX		; decrement column
                            	   487: 
                            	   488: 	;---------------------------
                            	   489: 	; Delete key
                            	   490: 	;---------------------------
                            	   491: doDelete:
00:000013A4 48E7C080        	   492: 	movem.l	d0/d1/a0,-(a7)	; save off screen location
00:000013A8 6100FEB2        	   493: 	bsr	CalcScreenLoc				; a0 = screen location
00:000013AC 203900040B28    	   494: 	move.l textvid_dcb+DCB_OUTPOSX,d0
                            	   495: .0001:
                            	   496: 	if (SCREEN_FORMAT==1)
00:000013B2 20A80004        	   497: 		move.l 4(a0),(a0)				; pull remaining characters on line over 1
00:000013B6 5888            	   498: 		adda.l #4,a0
                            	   499: 	else
                            	   500: 		move.l 8(a0),(a0)				; pull remaining characters on line over 1
                            	   501: 		move.l 12(a0),4(a0)
                            	   502: 		adda.l #8,a0
                            	   503: 	endif
00:000013B8 5280            	   504: 	addq.l #1,d0
00:000013BA B0B900040B5C    	   505: 	cmp.l	textvid_dcb+DCB_OUTDIMX,d0
00:000013C0 65F0            	   506: 	blo.s	.0001
00:000013C2 6100FE78        	   507: 	bsr	get_screen_color
                            	   508: 	if (SCREEN_FORMAT==1)
00:000013C6 303C0020        	   509: 		move.w #' ',d0
00:000013CA E158            	   510: 		rol.w	#8,d0
00:000013CC 4840            	   511: 		swap d0
00:000013CE E158            	   512: 		rol.w	#8,d0
00:000013D0 2140FFFC        	   513: 		move.l d0,-4(a0)
                            	   514: 	else
                            	   515: 		move.w #' ',d0					; terminate line with a space
                            	   516: 		rol.w	#8,d0
                            	   517: 		swap d0
                            	   518: 		rol.w	#8,d0
                            	   519: 		move.l d0,-8(a0)
                            	   520: 	endif
00:000013D4 4CDF0103        	   521: 	movem.l	(a7)+,d0/d1/a0
00:000013D8 60AE            	   522: 	bra.s		dcx16				; finished
                            	   523: 
                            	   524: 	;---------------------------
                            	   525: 	; CTRL-X: erase line
                            	   526: 	;---------------------------
                            	   527: doCtrlX:
00:000013DA 42B900040B28    	   528: 	clr.l	textvid_dcb+DCB_OUTPOSX			; Reset cursor to start of line
00:000013E0 203900040B5C    	   529: 	move.l textvid_dcb+DCB_OUTDIMX,d0	; and display TextCols number of spaces
00:000013E6 4880            	   530: 	ext.w	d0
00:000013E8 48C0            	   531: 	ext.l	d0
00:000013EA 123C0020        	   532: 	move.b #' ',d1			; d1 = space char
                            	   533: .0001:
                            	   534: 	; textvid_putchar is called recursively here
                            	   535: 	; It's safe to do because we know it won't recurse again due to the
                            	   536: 	; fact we know the character being displayed is a space char
00:000013EE 6100FE96        	   537: 	bsr	textvid_putchar
00:000013F2 5340            	   538: 	subq #1,d0
00:000013F4 66F8            	   539: 	bne.s	.0001
00:000013F6 42B900040B28    	   540: 	clr.l	textvid_dcb+DCB_OUTPOSX			; now really go back to start of line
00:000013FC 608A            	   541: 	bra	dcx16						; we're done
                            	   542: 
                            	   543: ;------------------------------------------------------------------------------
                            	   544: ; Increment the cursor position, scroll the screen if needed.
                            	   545: ;------------------------------------------------------------------------------
                            	   546: 
                            	   547: IncCursorPos:
00:000013FE 52B900040B28    	   548: 	addq.l #1,textvid_dcb+DCB_OUTPOSX
00:00001404 203900040B5C    	   549: 	move.l textvid_dcb+DCB_OUTDIMX,d0
00:0000140A B0B900040B28    	   550: 	cmp.l	textvid_dcb+DCB_OUTPOSX,d0
00:00001410 642E            	   551: 	bhs.s	icc1
00:00001412 42B900040B28    	   552: 	clr.l textvid_dcb+DCB_OUTPOSX
                            	   553: IncCursorRow:
00:00001418 52B900040B2C    	   554: 	addq.l #1,textvid_dcb+DCB_OUTPOSY
00:0000141E 203900040B60    	   555: 	move.l textvid_dcb+DCB_OUTDIMY,d0
00:00001424 B0B900040B2C    	   556: 	cmp.l textvid_dcb+DCB_OUTPOSY,d0
00:0000142A 6214            	   557: 	bhi.s	icc1
00:0000142C 203900040B60    	   558: 	move.l textvid_dcb+DCB_OUTDIMY,d0
00:00001432 23C000040B2C    	   559: 	move.l d0,textvid_dcb+DCB_OUTPOSY		; in case CursorRow is way over
00:00001438 53B900040B2C    	   560: 	subq.l #1,textvid_dcb+DCB_OUTPOSY
00:0000143E 6102            	   561: 	bsr	ScrollUp
                            	   562: icc1:
00:00001440 4E75            	   563: 	rts
                            	   564: 
                            	   565: ;------------------------------------------------------------------------------
                            	   566: ; Scroll screen up.
                            	   567: ;------------------------------------------------------------------------------
                            	   568: 
                            	   569: ScrollUp:
00:00001442 48E7C084        	   570: 	movem.l	d0/d1/a0/a5,-(a7)		; save off some regs
00:00001446 4E7A0FE0        	   571: 	movec	coreno,d0
00:0000144A 4840            	   572: 	swap d0	
00:0000144C 7205            	   573: 	moveq	#SCREEN_SEMA,d1
00:0000144E 6100115E        	   574: 	bsr	LockSemaphore
00:00001452 207900040B44    	   575: 	move.l textvid_dcb+DCB_OUTBUFPTR,a0
00:00001458 2A48            	   576: 	move.l a0,a5								; a5 = pointer to text screen
                            	   577: .0003:								
00:0000145A 203900040B5C    	   578: 	move.l textvid_dcb+DCB_OUTDIMX,d0					; d0 = columns
00:00001460 223900040B60    	   579: 	move.l textvid_dcb+DCB_OUTDIMY,d1					; d1 = rows
                            	   580: 	if (SCREEN_FORMAT==1)
00:00001466 E580            	   581: 		asl.l	#2,d0								; make into cell index
                            	   582: 	else
                            	   583: 		asl.l	#3,d0								; make into cell index
                            	   584: 	endif
00:00001468 41F50800        	   585: 	lea	0(a5,d0.l),a0						; a0 = pointer to second row of text screen
                            	   586: 	if (SCREEN_FORMAT==1)
00:0000146C E488            	   587: 		lsr.l	#2,d0								; get back d0
                            	   588: 	else
                            	   589: 		lsr.l	#3,d0								; get back d0
                            	   590: 	endif
00:0000146E 5381            	   591: 	subq.l #1,d1									; number of rows-1
00:00001470 C0C1            	   592: 	mulu d1,d0									; d0 = count of characters to move
                            	   593: 	if (SCREEN_FORMAT==1)
                            	   594: 	else
                            	   595: 		add.l d0,d0									; d0*2 2 longs per char
                            	   596: 	endif
                            	   597: .0001:
00:00001472 2AD8            	   598: 	move.l (a0)+,(a5)+
00:00001474 51C8FFFC        	   599: 	dbra d0,.0001
00:00001478 4E7A0FE0        	   600: 	movec coreno,d0
00:0000147C 4840            	   601: 	swap d0	
00:0000147E 7205            	   602: 	moveq #SCREEN_SEMA,d1
00:00001480 61001168        	   603: 	bsr UnlockSemaphore
00:00001484 4CDF2103        	   604: 	movem.l (a7)+,d0/d1/a0/a5
                            	   605: 	; Fall through into blanking out last line
                            	   606: 
                            	   607: ;------------------------------------------------------------------------------
                            	   608: ; Blank out the last line on the screen.
                            	   609: ;------------------------------------------------------------------------------
                            	   610: 
                            	   611: BlankLastLine:
00:00001488 48E7E080        	   612: 	movem.l	d0/d1/d2/a0,-(a7)
00:0000148C 4E7A0FE0        	   613: 	movec	coreno,d0
00:00001490 4840            	   614: 	swap d0	
00:00001492 7205            	   615: 	moveq	#SCREEN_SEMA,d1
00:00001494 61001118        	   616: 	bsr	LockSemaphore
00:00001498 207900040B44    	   617: 	move.l textvid_dcb+DCB_OUTBUFPTR,a0
00:0000149E 203900040B5C    	   618: 	move.l textvid_dcb+DCB_OUTDIMX,d0					; d0 = columns
00:000014A4 223900040B60    	   619: 	move.l textvid_dcb+DCB_OUTDIMY,d1					; d1 = rows
00:000014AA 5341            	   620: 	subq #1,d1									; last row = #rows-1
00:000014AC C0C1            	   621: 	mulu d1,d0									; d0 = index of last line
                            	   622: 	if (SCREEN_FORMAT==1)
00:000014AE E588            	   623: 		lsl.l	#2,d0								; *4 bytes per char
                            	   624: 	else
                            	   625: 		lsl.l	#3,d0								; *8 bytes per char
                            	   626: 	endif
00:000014B0 41F00800        	   627: 	lea	(a0,d0.l),a0						; point a0 to last row
00:000014B4 243900040B5C    	   628: 	move.l textvid_dcb+DCB_OUTDIMX,d2					; number of text cells to clear
00:000014BA 5382            	   629: 	subq.l #1,d2								; count must be one less than desired
00:000014BC 6100FD7E        	   630: 	bsr	get_screen_color				; d0,d1 = screen color
                            	   631: 	if (SCREEN_FORMAT==1)
00:000014C0 303C0020        	   632: 		move.w #32,d0
                            	   633: 	else
                            	   634: 		move.w #32,d0								; set the character for display in low 16 bits
                            	   635: 	endif
00:000014C4 E158            	   636: 	rol.w	#8,d0
00:000014C6 4840            	   637: 	swap d0
00:000014C8 E158            	   638: 	rol.w	#8,d0
                            	   639: .0001:
                            	   640: 	if (SCREEN_FORMAT==1)
00:000014CA 20C0            	   641: 		move.l d0,(a0)+
                            	   642: 	else
                            	   643: 		move.l d0,(a0)+
                            	   644: 		bsr rbo
                            	   645: 		move.l d1,(a0)+
                            	   646: 	endif
00:000014CC 51CAFFFC        	   647: 	dbra d2,.0001
00:000014D0 4E7A0FE0        	   648: 	movec	coreno,d0
00:000014D4 4840            	   649: 	swap d0	
00:000014D6 7205            	   650: 	moveq #SCREEN_SEMA,d1
00:000014D8 61001110        	   651: 	bsr UnlockSemaphore
00:000014DC 4CDF0107        	   652: 	movem.l	(a7)+,d0/d1/d2/a0
00:000014E0 4E75            	   653: 	rts
                            	   654: 
                            	   655: ;------------------------------------------------------------------------------
                            	   656: ; Set cursor position to top left of screen.
                            	   657: ;
                            	   658: ; Parameters:
                            	   659: ;		<none>
                            	   660: ; Returns:
                            	   661: ;		<none>
                            	   662: ; Registers Affected:
                            	   663: ;		<none>
                            	   664: ;------------------------------------------------------------------------------
                            	   665: 
                            	   666: HomeCursor:
00:000014E2 42B900040B28    	   667: 	clr.l textvid_dcb+DCB_OUTPOSX
00:000014E8 42B900040B2C    	   668: 	clr.l textvid_dcb+DCB_OUTPOSY
00:000014EE 42B900040B30    	   669: 	clr.l textvid_dcb+DCB_OUTPOSZ
                            	   670: 	; fall through
                            	   671: 
                            	   672: ;------------------------------------------------------------------------------
                            	   673: ; SyncCursor:
                            	   674: ;
                            	   675: ; Sync the hardware cursor's position to the text cursor position but only for
                            	   676: ; the core with the IO focus.
                            	   677: ;
                            	   678: ; Parameters:
                            	   679: ;		<none>
                            	   680: ; Returns:
                            	   681: ;		<none>
                            	   682: ; Registers Affected:
                            	   683: ;		<none>
                            	   684: ;------------------------------------------------------------------------------
                            	   685: 
                            	   686: SyncCursor:
00:000014F4 23FCFFFFFFFDFDFF	   687: 	move.l #$FFFFFFFD,leds
00:000014FC C000
00:000014FE 48E7E000        	   688: 	movem.l	d0/d1/d2,-(a7)
00:00001502 4E7A0FE0        	   689: 	movec	coreno,d0
00:00001506 B03900100000    	   690: 	cmp.b	IOFocus,d0
00:0000150C 6622            	   691: 	bne.s .0001
00:0000150E 203900040B28    	   692: 	move.l textvid_dcb+DCB_OUTPOSX,d0
00:00001514 223900040B2C    	   693: 	move.l textvid_dcb+DCB_OUTPOSY,d1
00:0000151A 243900040B5C    	   694: 	move.l textvid_dcb+DCB_OUTDIMX,d2
00:00001520 C4C1            	   695: 	mulu d1,d2
00:00001522 D480            	   696: 	add.l d0,d2
00:00001524 E15A            	   697: 	rol.w	#8,d2					; swap byte order
00:00001526 4842            	   698: 	swap d2
00:00001528 E15A            	   699: 	rol.w #8,d2
00:0000152A 23C2FD080024    	   700: 	move.l d2,TEXTREG+$24
                            	   701: .0001:	
00:00001530 4CDF0007        	   702: 	movem.l	(a7)+,d0/d1/d2
00:00001534 4E75            	   703: 	rts
                            	   704: 
                            	   705: 

Source: "boot.x68"
                            	   610: 	include "err.x68"

Source: "err.x68"
                            	     1: ;------------------------------------------------------------------------------
                            	     2: ;------------------------------------------------------------------------------
                            	     3: ; Setup the err device
                            	     4: ;------------------------------------------------------------------------------
                            	     5: ;------------------------------------------------------------------------------
                            	     6: 
                            	     7: setup_err:
                            	     8: err_init:
00:00001536 7020            	     9: 	moveq #32,d0
00:00001538 41F900040B8C    	    10: 	lea.l err_dcb,a0
                            	    11: .0001:
00:0000153E 4298            	    12: 	clr.l (a0)+
00:00001540 51C8FFFC        	    13: 	dbra d0,.0001
00:00001544 23FC204243440004	    14: 	move.l #$20424344,err_dcb+DCB_MAGIC				; 'DCB'
00:0000154C 0B8C
00:0000154E 23FC4C4C554E0004	    15: 	move.l #$4C4C554E,err_dcb+DCB_NAME					; 'err'
00:00001556 0B90
00:00001558 23FC000015640004	    16: 	move.l #err_cmdproc,err_dcb+DCB_CMDPROC
00:00001560 0BA4
                            	    17: err_ret:
00:00001562 4E75            	    18: 	rts
                            	    19: 
                            	    20: err_cmdproc:
00:00001564 7000            	    21: 	moveq #E_Ok,d0
00:00001566 4E75            	    22: 	rts
                            	    23: 
                            	    24: 

Source: "boot.x68"
                            	   611: 	include "serial.x68"

Source: "serial.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;==============================================================================
                            	    38: ; Serial I/O routines
                            	    39: ;==============================================================================
                            	    40: 
                            	    41: 	code
                            	    42: 	align 2
                            	    43: COM_CMDTBL:
00:00001568 00001598        	    44: 	dc.l serial_init
00:0000156C 0000161E        	    45: 	dc.l serial_stat
00:00001570 00001622        	    46: 	dc.l serial_putchar
00:00001574 00001650        	    47: 	dc.l serial_putbuf
00:00001578 0000162A        	    48: 	dc.l serial_getchar
00:0000157C 00001650        	    49: 	dc.l serial_getbuf
00:00001580 00001650        	    50: 	dc.l serial_set_inpos
00:00001584 00001650        	    51: 	dc.l serial_set_outpos
00:00001588 00001630        	    52: 	dc.l serial_getchar_direct
00:0000158C 00001638        	    53: 	dc.l serial_peek_char
00:00001590 00001640        	    54: 	dc.l serial_peek_char_direct
00:00001594 00001648        	    55: 	dc.l serial_putchar_direct
                            	    56: 
                            	    57: ;------------------------------------------------------------------------------
                            	    58: ; Setup the console device
                            	    59: ; stdout = text screen controller
                            	    60: ;------------------------------------------------------------------------------
                            	    61: 	even
                            	    62: 
                            	    63: serial_init:
                            	    64: setup_serial:
00:00001598 48E780C0        	    65: 	movem.l d0/a0/a1,-(a7)
00:0000159C 701F            	    66: 	moveq #31,d0
00:0000159E 41F900040C94    	    67: 	lea.l serial_dcb,a0
                            	    68: .0001:
00:000015A4 4298            	    69: 	clr.l (a0)+
00:000015A6 51C8FFFC        	    70: 	dbra d0,.0001
00:000015AA 23FC444342200004	    71: 	move.l #$44434220,serial_dcb+DCB_MAGIC			; 'DCB'
00:000015B2 0C94
00:000015B4 23FC434F4D000004	    72: 	move.l #$434F4D00,serial_dcb+DCB_NAME				; 'COM'
00:000015BC 0C98
00:000015BE 23FC000015FC0004	    73: 	move.l #serial_cmdproc,serial_dcb+DCB_CMDPROC
00:000015C6 0CAC
00:000015C8 23FC001010000004	    74: 	move.l #SerRcvBuf,serial_dcb+DCB_INBUFPTR
00:000015D0 0CCC
00:000015D2 23FC001020000004	    75: 	move.l #SerXmitBuf,serial_dcb+DCB_OUTBUFPTR
00:000015DA 0CD0
00:000015DC 23FC000010000004	    76: 	move.l #4096,serial_dcb+DCB_INBUFSIZE
00:000015E4 0CD4
00:000015E6 616C            	    77: 	bsr SerialInit
00:000015E8 43F900040C94    	    78: 	lea.l serial_dcb,a1
00:000015EE 6100651C        	    79: 	jsr DisplayString
00:000015F2 610064FE        	    80: 	jsr CRLF
00:000015F6 4CDF0301        	    81: 	movem.l (a7)+,d0/a0/a1
00:000015FA 4E75            	    82: 	rts
                            	    83: 
                            	    84: serial_cmdproc:
00:000015FC 0C06000C        	    85: 	cmpi.b #12,d6
00:00001600 6418            	    86: 	bhs.s .0001
00:00001602 48E70280        	    87: 	movem.l d6/a0,-(a7)
00:00001606 4886            	    88: 	ext.w d6
00:00001608 E54E            	    89: 	lsl.w #2,d6
00:0000160A 41FAFF5C        	    90: 	lea COM_CMDTBL,a0
00:0000160E 20706000        	    91: 	move.l (a0,d6.w),a0
00:00001612 4E90            	    92: 	jsr (a0)
00:00001614 4CDF0140        	    93: 	movem.l (a7)+,d6/a0
00:00001618 4E75            	    94: 	rts
                            	    95: .0001:
00:0000161A 7002            	    96: 	moveq #E_Func,d0
00:0000161C 4E75            	    97: 	rts
                            	    98: 
                            	    99: serial_stat:
00:0000161E 7000            	   100: 	moveq #E_Ok,d0
00:00001620 4E75            	   101: 	rts
                            	   102: 
                            	   103: serial_putchar:
00:00001622 61000134        	   104: 	bsr SerialPutChar
00:00001626 7000            	   105: 	moveq #E_Ok,d0
00:00001628 4E75            	   106: 	rts
                            	   107: 
                            	   108: serial_getchar:
00:0000162A 615E            	   109: 	bsr SerialGetChar
00:0000162C 7000            	   110: 	moveq #E_Ok,d0
00:0000162E 4E75            	   111: 	rts
                            	   112: 
                            	   113: serial_getchar_direct:
00:00001630 6100010C        	   114: 	bsr SerialPeekCharDirect
00:00001634 7000            	   115: 	moveq #E_Ok,d0
00:00001636 4E75            	   116: 	rts
                            	   117: 
                            	   118: serial_peek_char:
00:00001638 610000C8        	   119: 	bsr SerialPeekChar
00:0000163C 7000            	   120: 	moveq #E_Ok,d0
00:0000163E 4E75            	   121: 	rts
                            	   122: 
                            	   123: serial_peek_char_direct:
00:00001640 610000FC        	   124: 	bsr SerialPeekCharDirect
00:00001644 7000            	   125: 	moveq #E_Ok,d0
00:00001646 4E75            	   126: 	rts
                            	   127: 
                            	   128: serial_putchar_direct:
00:00001648 61000172        	   129: 	bsr SerialPutCharDirect
00:0000164C 7000            	   130: 	moveq #E_Ok,d0
00:0000164E 4E75            	   131: 	rts
                            	   132: 
                            	   133: serial_putbuf:
                            	   134: serial_getbuf:
                            	   135: serial_set_inpos:
                            	   136: serial_set_outpos:
00:00001650 700A            	   137: 	moveq #E_NotSupported,d0
00:00001652 4E75            	   138: 	rts
                            	   139: 
                            	   140: ;------------------------------------------------------------------------------
                            	   141: ; Initialize the serial port an enhanced 6551 circuit.
                            	   142: ;
                            	   143: ; Select internal baud rate clock divider for 9600 baud
                            	   144: ; Reset fifos, set threshold to 3/4 full on transmit and 3/4 empty on receive
                            	   145: ; Note that the byte order is swapped.
                            	   146: ;------------------------------------------------------------------------------
                            	   147: 
                            	   148: SerialInit:
00:00001654 427900100162    	   149: 	clr.w		SerHeadRcv					; clear receive buffer indexes
00:0000165A 427900100160    	   150: 	clr.w		SerTailRcv
00:00001660 427900100168    	   151: 	clr.w		SerHeadXmit					; clear transmit buffer indexes
00:00001666 427900100166    	   152: 	clr.w		SerTailXmit
00:0000166C 423900100164    	   153: 	clr.b		SerRcvXon						; and Xon,Xoff flags
00:00001672 423900100165    	   154: 	clr.b		SerRcvXoff
00:00001678 7009            	   155: 	move.l	#$00000009,d0				; dtr,rts active, rxint enabled, no parity
00:0000167A 23C0FDFE0018    	   156: 	move.l	d0,ACIA+ACIA_CMD
                            	   157: ;	move.l	#$1E00F700,d0				; fifos enabled
00:00001680 701E            	   158: 	move.l	#$0000001E,d0				; fifos disabled
00:00001682 23C0FDFE001C    	   159: 	move.l	d0,ACIA+ACIA_CTRL
00:00001688 4E75            	   160: 	rts
                            	   161: ;	move.l	#$0F000000,d0				; transmit a break for a while
                            	   162: ;	move.l	d0,ACIA+ACIA_CMD
                            	   163: ;	move.l	#300000,d2					; wait 100 ms
                            	   164: ;	bra			.0001
                            	   165: ;.0003:
                            	   166: ;	swap		d2
                            	   167: ;.0001:
                            	   168: ;	nop
                            	   169: ;	dbra		d2,.0001
                            	   170: ;.0002:
                            	   171: ;	swap		d2
                            	   172: ;	dbra		d2,.0003
                            	   173: ;	move.l	#$07000000,d0				; clear break
                            	   174: ;	move.l	d0,ACIA+ACIA_CMD
                            	   175: ;	rts
                            	   176: 	
                            	   177: ;------------------------------------------------------------------------------
                            	   178: ; SerialGetChar
                            	   179: ;
                            	   180: ; Check the serial port buffer to see if there's a char available. If there's
                            	   181: ; a char available then return it. If the buffer is almost empty then send an
                            	   182: ; XON.
                            	   183: ;
                            	   184: ; Stack Space:
                            	   185: ;		2 long words
                            	   186: ; Parameters:
                            	   187: ;		none
                            	   188: ; Modifies:
                            	   189: ;		d0,a0
                            	   190: ; Returns:
                            	   191: ;		d1 = character or -1
                            	   192: ;------------------------------------------------------------------------------
                            	   193: 
                            	   194: SerialGetChar:
00:0000168A 2F02            	   195: 	move.l		d2,-(a7)
00:0000168C 4E7A0FE0        	   196: 	movec			coreno,d0
00:00001690 4840            	   197: 	swap			d0
00:00001692 7202            	   198: 	moveq			#SERIAL_SEMA,d1
00:00001694 61000F18        	   199: 	bsr				LockSemaphore
00:00001698 6100013E        	   200: 	bsr				SerialRcvCount			; check number of chars in receive buffer
00:0000169C 0C400008        	   201: 	cmpi.w		#8,d0								; less than 8?
00:000016A0 621C            	   202: 	bhi				.sgc2
00:000016A2 4A3900100164    	   203: 	tst.b			SerRcvXon						; skip sending XON if already sent
00:000016A8 6614            	   204: 	bne	  		.sgc2            		; XON already sent?
00:000016AA 123C0011        	   205: 	move.b		#XON,d1							; if <8 send an XON
00:000016AE 423900100165    	   206: 	clr.b			SerRcvXoff					; clear XOFF status
00:000016B4 13C100100164    	   207: 	move.b		d1,SerRcvXon				; flag so we don't send it multiple times
00:000016BA 6100009C        	   208: 	bsr				SerialPutChar				; send it
                            	   209: .sgc2
00:000016BE 323900100162    	   210: 	move.w		SerHeadRcv,d1				; check if anything is in buffer
00:000016C4 B27900100160    	   211: 	cmp.w			SerTailRcv,d1
00:000016CA 6720            	   212: 	beq				.NoChars						; no?
00:000016CC 41F900101000    	   213: 	lea				SerRcvBuf,a0
00:000016D2 12301000        	   214: 	move.b		(a0,d1.w),d1				; get byte from buffer
00:000016D6 527900100162    	   215: 	addi.w		#1,SerHeadRcv
00:000016DC 02790FFF00100162	   216: 	andi.w		#$FFF,SerHeadRcv		; 4k wrap around
00:000016E4 0281000000FF    	   217: 	andi.l		#$FF,d1
00:000016EA 6002            	   218: 	bra				.Xit
                            	   219: .NoChars
00:000016EC 72FF            	   220: 	moveq			#-1,d1
                            	   221: .Xit
00:000016EE C342            	   222: 	exg				d1,d2
00:000016F0 4E7A0FE0        	   223: 	movec			coreno,d0
00:000016F4 4840            	   224: 	swap			d0
00:000016F6 7202            	   225: 	moveq			#SERIAL_SEMA,d1
00:000016F8 61000EF0        	   226: 	bsr				UnlockSemaphore
00:000016FC C541            	   227: 	exg				d2,d1
00:000016FE 241F            	   228: 	move.l		(a7)+,d2
00:00001700 4E75            	   229: 	rts
                            	   230: 
                            	   231: ;------------------------------------------------------------------------------
                            	   232: ; SerialPeekChar
                            	   233: ;
                            	   234: ; Check the serial port buffer to see if there's a char available. If there's
                            	   235: ; a char available then return it. But don't update the buffer indexes. No need
                            	   236: ; to send an XON here.
                            	   237: ;
                            	   238: ; Stack Space:
                            	   239: ;		1 long word
                            	   240: ; Parameters:
                            	   241: ;		none
                            	   242: ; Modifies:
                            	   243: ;		d0,a0
                            	   244: ; Returns:
                            	   245: ;		d1 = character or -1
                            	   246: ;------------------------------------------------------------------------------
                            	   247: 
                            	   248: SerialPeekChar:
00:00001702 2F02            	   249: 	move.l d2,-(a7)
00:00001704 4E7A0FE0        	   250: 	movec	coreno,d0
00:00001708 4840            	   251: 	swap d0
00:0000170A 7202            	   252: 	moveq	#SERIAL_SEMA,d1
00:0000170C 61000EA0        	   253: 	bsr	LockSemaphore
00:00001710 343900100162    	   254: 	move.w SerHeadRcv,d2		; check if anything is in buffer
00:00001716 B47900100160    	   255: 	cmp.w	SerTailRcv,d2
00:0000171C 670C            	   256: 	beq	.NoChars				; no?
00:0000171E 41F900101000    	   257: 	lea	SerRcvBuf,a0
00:00001724 14302000        	   258: 	move.b (a0,d2.w),d2		; get byte from buffer
00:00001728 6002            	   259: 	bra	.Xit
                            	   260: .NoChars
00:0000172A 74FF            	   261: 	moveq	#-1,d2
                            	   262: .Xit
00:0000172C 4E7A0FE0        	   263: 	movec	coreno,d0
00:00001730 4840            	   264: 	swap d0
00:00001732 7202            	   265: 	moveq	#SERIAL_SEMA,d1
00:00001734 61000EB4        	   266: 	bsr	UnlockSemaphore
00:00001738 2202            	   267: 	move.l	d2,d1
00:0000173A 241F            	   268: 	move.l (a7)+,d2
00:0000173C 4E75            	   269: 	rts
                            	   270: 
                            	   271: ;------------------------------------------------------------------------------
                            	   272: ; SerialPeekChar
                            	   273: ;		Get a character directly from the I/O port. This bypasses the input
                            	   274: ; buffer.
                            	   275: ;
                            	   276: ; Stack Space:
                            	   277: ;		0 words
                            	   278: ; Parameters:
                            	   279: ;		none
                            	   280: ; Modifies:
                            	   281: ;		d
                            	   282: ; Returns:
                            	   283: ;		d1 = character or -1
                            	   284: ;------------------------------------------------------------------------------
                            	   285: 
                            	   286: SerialPeekCharDirect:
00:0000173E 1239FDFE0014    	   287: 	move.b	ACIA+ACIA_STAT,d1	; get serial status
00:00001744 08010003        	   288: 	btst		#3,d1							; look for Rx not empty
00:00001748 670A            	   289: 	beq.s		.0001
00:0000174A 7200            	   290: 	moveq.l	#0,d1							; clear upper bits of return value
00:0000174C 1239FDFE0010    	   291: 	move.b	ACIA+ACIA_RX,d1		; get data from ACIA
00:00001752 4E75            	   292: 	rts												; return
                            	   293: .0001
00:00001754 72FF            	   294: 	moveq		#-1,d1
00:00001756 4E75            	   295: 	rts
                            	   296: 
                            	   297: ;------------------------------------------------------------------------------
                            	   298: ; SerialPutChar
                            	   299: ;		If there is a transmit buffer, adds the character to the transmit buffer
                            	   300: ; if it can, otherwise will wait for a byte to be freed up in the transmit
                            	   301: ; buffer (blocks).
                            	   302: ;		If there is no transmit buffer, put a character to the directly to the
                            	   303: ; serial transmitter. This routine blocks until the transmitter is empty. 
                            	   304: ;
                            	   305: ; Stack Space
                            	   306: ;		4 long words
                            	   307: ; Parameters:
                            	   308: ;		d1.b = character to put
                            	   309: ; Modifies:
                            	   310: ;		none
                            	   311: ;------------------------------------------------------------------------------
                            	   312: 
                            	   313: SerialPutChar:
                            	   314: .0004
00:00001758 4A7900040CD8    	   315: 	tst.w serial_dcb+DCB_OUTBUFSIZE	; buffered output?
00:0000175E 675C            	   316: 	beq.s SerialPutCharDirect
00:00001760 48E7E080        	   317: 	movem.l d0/d1/d2/a0,-(a7)
00:00001764 4E7A0FE0        	   318: 	movec	coreno,d0
00:00001768 4840            	   319: 	swap d0
00:0000176A 7202            	   320: 	moveq	#SERIAL_SEMA,d1
00:0000176C 61000E40        	   321: 	bsr	LockSemaphore
00:00001770 303900100166    	   322: 	move.w SerTailXmit,d0
00:00001776 3400            	   323: 	move.w d0,d2
00:00001778 5240            	   324: 	addi.w #1,d0
00:0000177A B07900040CD8    	   325: 	cmp.w serial_dcb+DCB_OUTBUFSIZE,d0
00:00001780 6502            	   326: 	blo.s .0002
00:00001782 4240            	   327: 	clr.w d0
                            	   328: .0002
00:00001784 B07900100168    	   329: 	cmp.w SerHeadXmit,d0			; Is Xmit buffer full?
00:0000178A 660E            	   330: 	bne.s .0003
00:0000178C 4E7A0FE0        	   331: 	movec	coreno,d0						; buffer full, unlock semaphore and wait
00:00001790 4840            	   332: 	swap d0
00:00001792 7202            	   333: 	moveq	#SERIAL_SEMA,d1
00:00001794 61000E54        	   334: 	bsr	UnlockSemaphore
00:00001798 60BE            	   335: 	bra.s .0004
                            	   336: .0003
00:0000179A 33C000100166    	   337: 	move.w d0,SerTailXmit			; update tail pointer
00:000017A0 41F900102000    	   338: 	lea SerXmitBuf,a0
00:000017A6 11812000        	   339: 	move.b d1,(a0,d2.w)				; store byte in Xmit buffer
00:000017AA 4E7A0FE0        	   340: 	movec	coreno,d0						; unlock semaphore
00:000017AE 4840            	   341: 	swap d0
00:000017B0 7202            	   342: 	moveq	#SERIAL_SEMA,d1
00:000017B2 61000E36        	   343: 	bsr	UnlockSemaphore
00:000017B6 4CDF0107        	   344: 	movem.l (a7)+,d0/d1/d2/a0
00:000017BA 4E75            	   345: 	rts
                            	   346: 
                            	   347: SerialPutCharDirect:
00:000017BC 48E7C000        	   348: 	movem.l	d0/d1,-(a7)							; push d0,d1
                            	   349: .0001
00:000017C0 1039FDFE0014    	   350: 	move.b ACIA+ACIA_STAT,d0	; wait until the uart indicates tx empty
00:000017C6 08000004        	   351: 	btst #4,d0								; bit #4 of the status reg
00:000017CA 67F4            	   352: 	beq.s	.0001			    			; branch if transmitter is not empty
00:000017CC 13C1FDFE0010    	   353: 	move.b d1,ACIA+ACIA_TX		; send the byte
00:000017D2 4CDF0003        	   354: 	movem.l	(a7)+,d0/d1				; pop d0,d1
00:000017D6 4E75            	   355: 	rts
                            	   356: 	
                            	   357: ;------------------------------------------------------------------------------
                            	   358: ; Calculate number of character in input buffer
                            	   359: ;
                            	   360: ; Returns:
                            	   361: ;		d0 = number of bytes in buffer.
                            	   362: ;------------------------------------------------------------------------------
                            	   363: 
                            	   364: SerialRcvCount:
00:000017D8 303900100160    	   365: 	move.w	SerTailRcv,d0
00:000017DE 907900100162    	   366: 	sub.w		SerHeadRcv,d0
00:000017E4 6C10            	   367: 	bge.s		.0001
00:000017E6 303C1000        	   368: 	move.w	#$1000,d0
00:000017EA 907900100162    	   369: 	sub.w		SerHeadRcv,d0
00:000017F0 D07900100160    	   370: 	add.w		SerTailRcv,d0
                            	   371: .0001
00:000017F6 4E75            	   372: 	rts
                            	   373: 
                            	   374: ;------------------------------------------------------------------------------
                            	   375: ; Serial IRQ routine
                            	   376: ;
                            	   377: ; Keeps looping as long as it finds characters in the ACIA recieve buffer/fifo.
                            	   378: ; Received characters are buffered. If the buffer becomes full, new characters
                            	   379: ; will be lost.
                            	   380: ;
                            	   381: ; Parameters:
                            	   382: ;		none
                            	   383: ; Modifies:
                            	   384: ;		none
                            	   385: ; Returns:
                            	   386: ;		d1 = -1 if IRQ handled, otherwise zero
                            	   387: ;------------------------------------------------------------------------------
                            	   388: 
                            	   389: SerialIRQ:
00:000017F8 46FC2300        	   390: 	move.w	#$2300,sr						; disable lower level IRQs
00:000017FC 48E7E080        	   391: 	movem.l	d0/d1/d2/a0,-(a7)
00:00001800 41F9FD0000C8    	   392: 	lea $FD000000+(TEXTCOL-2)*4,a0			; display field address
00:00001806 2410            	   393: 	move.l (a0),d2						; get char from screen
00:00001808 0A82000000FF    	   394: 	eori.l #$000000FF,d2
00:0000180E 2082            	   395: 	move.l d2,(a0)						; update onscreen IRQ flag
00:00001810 4E7A0FE0        	   396: 	movec	coreno,d0
00:00001814 4840            	   397: 	swap d0
00:00001816 7202            	   398: 	moveq	#SERIAL_SEMA,d1
00:00001818 61000D94        	   399: 	bsr	LockSemaphore
                            	   400: sirqNxtByte
00:0000181C 1239FDFE0014    	   401: 	move.b ACIA+ACIA_STAT,d1		; check the status
00:00001822 08010003        	   402: 	btst #3,d1									; bit 3 = rx full
00:00001826 6758            	   403: 	beq	notRxInt
00:00001828 1239FDFE0010    	   404: 	move.b ACIA+ACIA_RX,d1
                            	   405: sirq0001
00:0000182E 303900100160    	   406: 	move.w SerTailRcv,d0				; check if recieve buffer full
00:00001834 5240            	   407: 	addi.w #1,d0
00:00001836 02400FFF        	   408: 	andi.w #$FFF,d0
00:0000183A B07900100162    	   409: 	cmp.w	SerHeadRcv,d0
00:00001840 673E            	   410: 	beq	sirqRxFull
00:00001842 33C000100160    	   411: 	move.w d0,SerTailRcv				; update tail pointer
00:00001848 5340            	   412: 	subi.w #1,d0								; backup
00:0000184A 02400FFF        	   413: 	andi.w #$FFF,d0
00:0000184E 41F900101000    	   414: 	lea	SerRcvBuf,a0						; a0 = buffer address
00:00001854 11810000        	   415: 	move.b d1,(a0,d0.w)					; store recieved byte in buffer
00:00001858 4A3900100165    	   416: 	tst.b	SerRcvXoff						; check if xoff already sent
00:0000185E 66BC            	   417: 	bne	sirqNxtByte
00:00001860 6100FF76        	   418: 	bsr	SerialRcvCount					; if more than 4080 chars in buffer
00:00001864 0C400FF0        	   419: 	cmpi.w #4080,d0
00:00001868 65B2            	   420: 	blo	sirqNxtByte
00:0000186A 123C0013        	   421: 	move.b #XOFF,d1							; send an XOFF
00:0000186E 423900100164    	   422: 	clr.b	SerRcvXon							; clear XON status
00:00001874 13C100100165    	   423: 	move.b d1,SerRcvXoff				; set XOFF status
00:0000187A 6100FEDC        	   424: 	bsr	SerialPutChar						; send XOFF
00:0000187E 609C            	   425: 	bra	sirqNxtByte     				; check the status for another byte
                            	   426: sirqRxFull
                            	   427: notRxInt
00:00001880 08010004        	   428: 	btst #4,d1									; TX empty?
00:00001884 6748            	   429: 	beq.s notTxInt
00:00001886 4A390010016A    	   430: 	tst.b SerXmitXoff						; and allowed to send?
00:0000188C 6640            	   431: 	bne.s sirqXmitOff
00:0000188E 4AB900040CD8    	   432: 	tst.l serial_dcb+DCB_OUTBUFSIZE	; Is there a buffer being transmitted?
00:00001894 6738            	   433: 	beq.s notTxInt
00:00001896 303900100168    	   434: 	move.w SerHeadXmit,d0
00:0000189C B07900100166    	   435: 	cmp.w SerTailXmit,d0
00:000018A2 672A            	   436: 	beq.s sirqTxEmpty
00:000018A4 41F900102000    	   437: 	lea SerXmitBuf,a0
00:000018AA 12300000        	   438: 	move.b (a0,d0.w),d1
00:000018AE 13C1FDFE0010    	   439: 	move.b d1,ACIA+ACIA_TX			; transmit character
00:000018B4 527900100168    	   440: 	addi.w #1,SerHeadXmit				; advance head index
00:000018BA 303900040CD8    	   441: 	move.w serial_dcb+DCB_OUTBUFSIZE,d0
00:000018C0 B07900100168    	   442: 	cmp.w SerHeadXmit,d0
00:000018C6 6206            	   443: 	bhi.s sirq0002
00:000018C8 427900100168    	   444: 	clr.w SerHeadXmit						; wrap around
                            	   445: sirq0002
                            	   446: sirqXmitOff
                            	   447: sirqTxEmpty
                            	   448: notTxInt
00:000018CE 4E7A0FE0        	   449: 	movec	coreno,d0
00:000018D2 4840            	   450: 	swap d0
00:000018D4 7202            	   451: 	moveq	#SERIAL_SEMA,d1
00:000018D6 61000D12        	   452: 	bsr	UnlockSemaphore
00:000018DA 4CDF0107        	   453: 	movem.l	(a7)+,d0/d1/d2/a0
00:000018DE 4E73            	   454: 	rte
                            	   455: 
                            	   456: nmeSerial:
00:000018E0 53657269616C    	   457: 	dc.b		"Serial",0
00:000018E6 00
                            	   458: 
                            	   459: 

Source: "boot.x68"
                            	   612: 	include "framebuf.x68"

Source: "framebuf.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: FB_CTA macro arg1
                            	    38: 	dc.w ((\1-FRAMEBUF_CMDTBL)>>2)
                            	    39: endm
                            	    40: 
                            	    41: FRAMEBUF_CTRL equ 0
                            	    42: FRAMEBUF_PAGE1_ADDR equ 2*8
                            	    43: FRAMEBUF_PAGE2_ADDR equ 3*8
                            	    44: FRAMEBUF_BMPSIZE_X equ 13*8
                            	    45: FRAMEBUF_BMPSIZE_Y equ 13*8+4
                            	    46: FRAMEBUF_WINDOW_DIMEN	equ	15*8
                            	    47: FRAMEBUF_COLOR_COMP	equ 19*8
                            	    48: FRAMEBUF_PRGB equ 20*8
                            	    49: FRAMEBUF_COLOR equ 21*8
                            	    50: FRAMEBUF_PPS equ 22*8
                            	    51: 
                            	    52: ;------------------------------------------------------------------------------
                            	    53: ;------------------------------------------------------------------------------
                            	    54: ; Video frame buffer
                            	    55: ;------------------------------------------------------------------------------
                            	    56: ;------------------------------------------------------------------------------
                            	    57: 	code
                            	    58: 	even
                            	    59: 	align 2
                            	    60: FRAMEBUF_CMDTBL:
                            	    61: 	FB_CTA framebuf_init				; 0
00:000018E8 003A            	     1M 	dc.w ((framebuf_init-FRAMEBUF_CMDTBL)>>2)
                            	    62: 	FB_CTA framebuf_stat
00:000018EA 0065            	     1M 	dc.w ((framebuf_stat-FRAMEBUF_CMDTBL)>>2)
                            	    63: 	FB_CTA framebuf_putchar
00:000018EC 0065            	     1M 	dc.w ((framebuf_putchar-FRAMEBUF_CMDTBL)>>2)
                            	    64: 	FB_CTA framebuf_putbuf
00:000018EE 0095            	     1M 	dc.w ((framebuf_putbuf-FRAMEBUF_CMDTBL)>>2)
                            	    65: 	FB_CTA framebuf_getchar
00:000018F0 0065            	     1M 	dc.w ((framebuf_getchar-FRAMEBUF_CMDTBL)>>2)
                            	    66: 	FB_CTA framebuf_getbuf
00:000018F2 0095            	     1M 	dc.w ((framebuf_getbuf-FRAMEBUF_CMDTBL)>>2)
                            	    67: 	FB_CTA framebuf_set_inpos
00:000018F4 0066            	     1M 	dc.w ((framebuf_set_inpos-FRAMEBUF_CMDTBL)>>2)
                            	    68: 	FB_CTA framebuf_set_outpos
00:000018F6 006A            	     1M 	dc.w ((framebuf_set_outpos-FRAMEBUF_CMDTBL)>>2)
                            	    69: 	FB_CTA framebuf_stub
00:000018F8 0095            	     1M 	dc.w ((framebuf_stub-FRAMEBUF_CMDTBL)>>2)
                            	    70: 	FB_CTA framebuf_stub
00:000018FA 0095            	     1M 	dc.w ((framebuf_stub-FRAMEBUF_CMDTBL)>>2)
                            	    71: 	FB_CTA framebuf_stub				; 10
00:000018FC 0095            	     1M 	dc.w ((framebuf_stub-FRAMEBUF_CMDTBL)>>2)
                            	    72: 	FB_CTA framebuf_stub
00:000018FE 0095            	     1M 	dc.w ((framebuf_stub-FRAMEBUF_CMDTBL)>>2)
                            	    73: 	FB_CTA framebuf_clear
00:00001900 010B            	     1M 	dc.w ((framebuf_clear-FRAMEBUF_CMDTBL)>>2)
                            	    74: 	FB_CTA framebuf_swapbuf
00:00001902 007A            	     1M 	dc.w ((framebuf_swapbuf-FRAMEBUF_CMDTBL)>>2)
                            	    75: 	FB_CTA framebuf_setbuf1
00:00001904 0072            	     1M 	dc.w ((framebuf_setbuf1-FRAMEBUF_CMDTBL)>>2)
                            	    76: 	FB_CTA framebuf_setbuf2
00:00001906 0076            	     1M 	dc.w ((framebuf_setbuf2-FRAMEBUF_CMDTBL)>>2)
                            	    77: 	FB_CTA framebuf_getbuf1
00:00001908 006E            	     1M 	dc.w ((framebuf_getbuf1-FRAMEBUF_CMDTBL)>>2)
                            	    78: 	FB_CTA framebuf_getbuf2
00:0000190A 0070            	     1M 	dc.w ((framebuf_getbuf2-FRAMEBUF_CMDTBL)>>2)
                            	    79: 	FB_CTA framebuf_writeat
00:0000190C 00C2            	     1M 	dc.w ((framebuf_writeat-FRAMEBUF_CMDTBL)>>2)
                            	    80: 	FB_CTA framebuf_set_unit
00:0000190E 0092            	     1M 	dc.w ((framebuf_set_unit-FRAMEBUF_CMDTBL)>>2)
                            	    81: 	FB_CTA framebuf_get_dimen	; 20
00:00001910 009D            	     1M 	dc.w ((framebuf_get_dimen-FRAMEBUF_CMDTBL)>>2)
                            	    82: 	FB_CTA framebuf_get_color
00:00001912 0099            	     1M 	dc.w ((framebuf_get_color-FRAMEBUF_CMDTBL)>>2)
                            	    83: 	FB_CTA framebuf_stub
00:00001914 0095            	     1M 	dc.w ((framebuf_stub-FRAMEBUF_CMDTBL)>>2)
                            	    84: 	FB_CTA framebuf_stub
00:00001916 0095            	     1M 	dc.w ((framebuf_stub-FRAMEBUF_CMDTBL)>>2)
                            	    85: 	FB_CTA framebuf_stub
00:00001918 0095            	     1M 	dc.w ((framebuf_stub-FRAMEBUF_CMDTBL)>>2)
                            	    86: 	FB_CTA framebuf_stub
00:0000191A 0095            	     1M 	dc.w ((framebuf_stub-FRAMEBUF_CMDTBL)>>2)
                            	    87: 	FB_CTA framebuf_stub
00:0000191C 0095            	     1M 	dc.w ((framebuf_stub-FRAMEBUF_CMDTBL)>>2)
                            	    88: 	FB_CTA framebuf_stub
00:0000191E 0095            	     1M 	dc.w ((framebuf_stub-FRAMEBUF_CMDTBL)>>2)
                            	    89: 	FB_CTA framebuf_stub
00:00001920 0095            	     1M 	dc.w ((framebuf_stub-FRAMEBUF_CMDTBL)>>2)
                            	    90: 	FB_CTA framebuf_stub
00:00001922 0095            	     1M 	dc.w ((framebuf_stub-FRAMEBUF_CMDTBL)>>2)
                            	    91: 	FB_CTA framebuf_stub			; 30
00:00001924 0095            	     1M 	dc.w ((framebuf_stub-FRAMEBUF_CMDTBL)>>2)
                            	    92: 	FB_CTA framebuf_stub
00:00001926 0095            	     1M 	dc.w ((framebuf_stub-FRAMEBUF_CMDTBL)>>2)
                            	    93: 	FB_CTA framebuf_set_dimen
00:00001928 00A9            	     1M 	dc.w ((framebuf_set_dimen-FRAMEBUF_CMDTBL)>>2)
                            	    94: 	FB_CTA framebuf_set_color_depth
00:0000192A 0096            	     1M 	dc.w ((framebuf_set_color_depth-FRAMEBUF_CMDTBL)>>2)
                            	    95: 	FB_CTA framebuf_set_destbuf
00:0000192C 0065            	     1M 	dc.w ((framebuf_set_destbuf-FRAMEBUF_CMDTBL)>>2)
                            	    96: 	FB_CTA framebuf_set_dispbuf
00:0000192E 008F            	     1M 	dc.w ((framebuf_set_dispbuf-FRAMEBUF_CMDTBL)>>2)
                            	    97: 
                            	    98: 	code
                            	    99: 	even
                            	   100: framebuf_cmdproc:
00:00001930 0C060024        	   101: 	cmpi.b #36,d6
00:00001934 6420            	   102: 	bhs.s .0001
00:00001936 48E70280        	   103: 	movem.l d6/a0,-(a7)
00:0000193A 4886            	   104: 	ext.w d6
00:0000193C 48C6            	   105: 	ext.l d6
00:0000193E E54E            	   106: 	lsl.w #2,d6
00:00001940 41FAFFA6        	   107: 	lea.l FRAMEBUF_CMDTBL(pc),a0
00:00001944 3C306000        	   108: 	move.w (a0,d6.w),d6
00:00001948 48C6            	   109: 	ext.l d6
00:0000194A E58E            	   110: 	lsl.l #2,d6
00:0000194C D1C6            	   111: 	add.l d6,a0
00:0000194E 4E90            	   112: 	jsr (a0)
00:00001950 4CDF0140        	   113: 	movem.l (a7)+,d6/a0
00:00001954 4E75            	   114: 	rts
                            	   115: .0001:
00:00001956 7002            	   116: 	moveq #E_Func,d0
00:00001958 4E75            	   117: 	rts
                            	   118: 
                            	   119: 	align 2
                            	   120: setup_framebuf:
00:0000195C 48E780C0        	   121: 	movem.l d0/a0/a1,-(a7)
00:00001960 7020            	   122: 	moveq #32,d0
00:00001962 41F900040D18    	   123: 	lea.l framebuf_dcb,a0
                            	   124: .0001:
00:00001968 4298            	   125: 	clr.l (a0)+
00:0000196A 51C8FFFC        	   126: 	dbra d0,.0001
00:0000196E 23FC444342200004	   127: 	move.l #$44434220,framebuf_dcb+DCB_MAGIC			; 'DCB '
00:00001976 0D18
00:00001978 23FC4652414D0004	   128: 	move.l #$4652414D,framebuf_dcb+DCB_NAME				; 'FRAMEBUF'
00:00001980 0D1C
00:00001982 23FC425546000004	   129: 	move.l #$42554600,framebuf_dcb+DCB_NAME+4
00:0000198A 0D20
00:0000198C 23FC000019300004	   130: 	move.l #framebuf_cmdproc,framebuf_dcb+DCB_CMDPROC
00:00001994 0D30
00:00001996 7000            	   131: 	move.l #$00000000,d0
00:00001998 23C000040D50    	   132: 	move.l d0,framebuf_dcb+DCB_INBUFPTR
00:0000199E 23C000040D54    	   133: 	move.l d0,framebuf_dcb+DCB_OUTBUFPTR
00:000019A4 23FC004000000004	   134: 	move.l #$00400000,framebuf_dcb+DCB_INBUFSIZE
00:000019AC 0D58
00:000019AE 23FC004000000004	   135: 	move.l #$00400000,framebuf_dcb+DCB_OUTBUFSIZE
00:000019B6 0D5C
00:000019B8 43F900040D18    	   136: 	lea.l framebuf_dcb+DCB_MAGIC,a1
00:000019BE 6100614C        	   137: 	jsr DisplayString
00:000019C2 6100612E        	   138: 	jsr CRLF
00:000019C6 6108            	   139: 	bsr framebuf_init
00:000019C8 4CDF0301        	   140: 	movem.l (a7)+,d0/a0/a1
00:000019CC 4E75            	   141: 	rts
                            	   142: 
                            	   143: 	align 2
                            	   144: framebuf_init:
00:000019D0 13FC0001FD208000	   145: 	move.b #1,FRAMEBUF+0		; turn on frame buffer
00:000019D8 23FC00002AAAFD20	   146: 	move.l #$00002AAA,FRAMEBUF+FRAMEBUF_COLOR_COMP	; 2-10-10-10 color
00:000019E0 8098
00:000019E2 13FC0011FD208002	   147: 	move.b #$11,FRAMEBUF+2	; hres 1:1 vres 1:1
00:000019EA 23FC0F000063FD20	   148: 	move.l #$0F000063,FRAMEBUF+4		; burst length, burst interval
00:000019F2 8004
00:000019F4 23FC3FFFFFFF0004	   149: 	move.l #$3fffffff,framebuf_dcb+DCB_FGCOLOR	; white
00:000019FC 0D7C
00:000019FE 23FC000000FF0004	   150: 	move.l #$000000ff,framebuf_dcb+DCB_BKCOLOR	; medium blue
00:00001A06 0D78
00:00001A08 42B900040D38    	   151: 	clr.l framebuf_dcb+DCB_OUTPOSX
00:00001A0E 42B900040D3C    	   152: 	clr.l framebuf_dcb+DCB_OUTPOSY
00:00001A14 42B900040D44    	   153: 	clr.l framebuf_dcb+DCB_INPOSX
00:00001A1A 42B900040D48    	   154: 	clr.l framebuf_dcb+DCB_INPOSY
00:00001A20 13FC000100040D80	   155: 	move.b #1,framebuf_dcb+DCB_OPCODE	; raster op = copy
00:00001A28 33FC032000040D6C	   156: 	move.w #800,framebuf_dcb+DCB_OUTDIMX		; set rows and columns
00:00001A30 33FC025800040D70	   157: 	move.w #600,framebuf_dcb+DCB_OUTDIMY
00:00001A38 33FC032000040D60	   158: 	move.w #800,framebuf_dcb+DCB_INDIMX			; set rows and columns
00:00001A40 33FC025800040D64	   159: 	move.w #600,framebuf_dcb+DCB_INDIMY
00:00001A48 42B900040D50    	   160: 	move.l #$00000000,framebuf_dcb+DCB_INBUFPTR
00:00001A4E 23FC004000000004	   161: 	move.l #$00400000,framebuf_dcb+DCB_INBUFPTR2
00:00001A56 0D88
00:00001A58 42B900040D54    	   162: 	move.l #$00000000,framebuf_dcb+DCB_OUTBUFPTR
00:00001A5E 23FC002000000004	   163: 	move.l #$00200000,framebuf_dcb+DCB_OUTBUFPTR2
00:00001A66 0D8C
00:00001A68 42B9FD208010    	   164: 	move.l #$00000000,FRAMEBUF+FRAMEBUF_PAGE1_ADDR	; base addr 1
00:00001A6E 23FC00200000FD20	   165: 	move.l #$00200000,FRAMEBUF+FRAMEBUF_PAGE2_ADDR	; base addr 2
00:00001A76 8018
00:00001A78 4E75            	   166: 	rts
                            	   167: 
                            	   168: 	align 2
                            	   169: framebuf_stat:
                            	   170: framebuf_putchar:
                            	   171: framebuf_getchar:
                            	   172: framebuf_set_destbuf:
00:00001A7C 4E75            	   173: 	rts
                            	   174: 
                            	   175: 	align 2
                            	   176: framebuf_set_inpos:
00:00001A80 23C100040D44    	   177: 	move.l d1,framebuf_dcb+DCB_INPOSX
00:00001A86 23C200040D48    	   178: 	move.l d2,framebuf_dcb+DCB_INPOSY
00:00001A8C 4E75            	   179: 	rts
                            	   180: 	align 2
                            	   181: framebuf_set_outpos:
00:00001A90 23C100040D38    	   182: 	move.l d1,framebuf_dcb+DCB_OUTPOSX
00:00001A96 23C200040D3C    	   183: 	move.l d2,framebuf_dcb+DCB_OUTPOSY
00:00001A9C 4E75            	   184: 	rts
                            	   185: 
                            	   186: 	align 2
                            	   187: framebuf_getbuf1:
00:00001AA0 223900040D54    	   188: 	move.l framebuf_dcb+DCB_OUTBUFPTR,d1
00:00001AA6 4E75            	   189: 	rts
                            	   190: 	align 2
                            	   191: framebuf_getbuf2:
00:00001AA8 223900040D8C    	   192: 	move.l framebuf_dcb+DCB_OUTBUFPTR2,d1
00:00001AAE 4E75            	   193: 	rts
                            	   194: 	align 2
                            	   195: framebuf_setbuf1:
00:00001AB0 23C100040D54    	   196: 	move.l d1,framebuf_dcb+DCB_OUTBUFPTR
00:00001AB6 23C200040D5C    	   197: 	move.l d2,framebuf_dcb+DCB_OUTBUFSIZE
00:00001ABC 4E75            	   198: 	rts
                            	   199: 	align 2
                            	   200: framebuf_setbuf2:
00:00001AC0 23C100040D8C    	   201: 	move.l d1,framebuf_dcb+DCB_OUTBUFPTR2
00:00001AC6 23C200040D94    	   202: 	move.l d2,framebuf_dcb+DCB_OUTBUFSIZE2
00:00001ACC 4E75            	   203: 	rts
                            	   204: 
                            	   205: 	align 2
                            	   206: framebuf_swapbuf:
00:00001AD0 48E76000        	   207: 	movem.l d1/d2,-(a7)
00:00001AD4 1239FD208003    	   208: 	move.b FRAMEBUF+3,d1
00:00001ADA 0A010001        	   209: 	eor.b #1,d1
00:00001ADE 13C1FD208003    	   210: 	move.b d1,FRAMEBUF+3					; page flip
00:00001AE4 243900040D54    	   211: 	move.l framebuf_dcb+DCB_OUTBUFPTR,d2
00:00001AEA 203900040D8C    	   212: 	move.l framebuf_dcb+DCB_OUTBUFPTR2,d0
00:00001AF0 23C200040D8C    	   213: 	move.l d2,framebuf_dcb+DCB_OUTBUFPTR2
00:00001AF6 23C000040D54    	   214: 	move.l d0,framebuf_dcb+DCB_OUTBUFPTR
00:00001AFC 23C0FD210110    	   215: 	move.l d0,GFXACCEL+16+256
00:00001B02 243900040D50    	   216: 	move.l framebuf_dcb+DCB_INBUFPTR,d2
00:00001B08 203900040D88    	   217: 	move.l framebuf_dcb+DCB_INBUFPTR2,d0
00:00001B0E 23C200040D88    	   218: 	move.l d2,framebuf_dcb+DCB_INBUFPTR2
00:00001B14 23C000040D50    	   219: 	move.l d0,framebuf_dcb+DCB_INBUFPTR
00:00001B1A 4CDF0006        	   220: 	movem.l (a7)+,d1/d2
00:00001B1E 7000            	   221: 	move.l #E_Ok,d0
00:00001B20 4E75            	   222: 	rts
                            	   223: 
                            	   224: 	align 2
                            	   225: framebuf_set_dispbuf:
00:00001B24 13C1FD208003    	   226: 	move.b d1,FRAMEBUF+3					; set display page
00:00001B2A 7000            	   227: 	move.l #E_Ok,d0
00:00001B2C 4E75            	   228: 	rts
                            	   229: 
                            	   230: 	align 2
                            	   231: framebuf_set_unit:
00:00001B30 23C100040D98    	   232: 	move.l d1,framebuf_dcb+DCB_UNIT
00:00001B36 7000            	   233: 	move.l #E_Ok,d0
00:00001B38 4E75            	   234: 	rts
                            	   235: 
                            	   236: 	align 2
                            	   237: framebuf_getbuf:
                            	   238: framebuf_putbuf:
                            	   239: framebuf_stub:
00:00001B3C 700A            	   240: 	moveq #E_NotSupported,d0
00:00001B3E 4E75            	   241: 	rts
                            	   242: 
                            	   243: 	align 2
                            	   244: framebuf_set_color_depth:
00:00001B40 23C1FD208098    	   245: 	move.l d1,FRAMEBUF+FRAMEBUF_COLOR_COMP
00:00001B46 7000            	   246: 	move.l #E_Ok,d0
00:00001B48 4E75            	   247: 	rts
                            	   248: 	
                            	   249: 	align 2
                            	   250: framebuf_get_color:
00:00001B4C 223900040D7C    	   251: 	move.l framebuf_dcb+DCB_FGCOLOR,d1
00:00001B52 243900040D78    	   252: 	move.l framebuf_dcb+DCB_BKCOLOR,d2
00:00001B58 7000            	   253: 	move.l #E_Ok,d0
00:00001B5A 4E75            	   254: 	rts
                            	   255: 
                            	   256: 	align 2
                            	   257: framebuf_get_dimen:
00:00001B5C 4A00            	   258: 	cmpi.b #0,d0
00:00001B5E 6616            	   259: 	bne.s .0001
00:00001B60 223900040D6C    	   260: 	move.l framebuf_dcb+DCB_OUTDIMX,d1
00:00001B66 243900040D70    	   261: 	move.l framebuf_dcb+DCB_OUTDIMY,d2
00:00001B6C 263900040D74    	   262: 	move.l framebuf_dcb+DCB_OUTDIMZ,d3
00:00001B72 7000            	   263: 	move.l #E_Ok,d0
00:00001B74 4E75            	   264: 	rts
                            	   265: .0001:
00:00001B76 223900040D60    	   266: 	move.l framebuf_dcb+DCB_INDIMX,d1
00:00001B7C 243900040D64    	   267: 	move.l framebuf_dcb+DCB_INDIMY,d2
00:00001B82 263900040D68    	   268: 	move.l framebuf_dcb+DCB_INDIMZ,d3
00:00001B88 7000            	   269: 	move.l #E_Ok,d0
00:00001B8A 4E75            	   270: 	rts
                            	   271: 
                            	   272: 	align 2
                            	   273: framebuf_set_dimen:
00:00001B8C 4A00            	   274: 	cmpi.b #0,d0
00:00001B8E 6622            	   275: 	bne.s .0001
00:00001B90 23C100040D6C    	   276: 	move.l d1,framebuf_dcb+DCB_OUTDIMX
00:00001B96 23C200040D70    	   277: 	move.l d2,framebuf_dcb+DCB_OUTDIMY
00:00001B9C 23C300040D74    	   278: 	move.l d3,framebuf_dcb+DCB_OUTDIMZ
00:00001BA2 23C1FD208068    	   279: 	move.l d1,FRAMEBUF+FRAMEBUF_BMPSIZE_X
00:00001BA8 23C2FD20806C    	   280: 	move.l d2,FRAMEBUF+FRAMEBUF_BMPSIZE_Y
00:00001BAE 7000            	   281: 	move.l #E_Ok,d0
00:00001BB0 4E75            	   282: 	rts
                            	   283: .0001:
00:00001BB2 0C000001        	   284: 	cmpi.b #1,d0
00:00001BB6 6616            	   285: 	bne.s .0002
00:00001BB8 23C100040D60    	   286: 	move.l d1,framebuf_dcb+DCB_INDIMX
00:00001BBE 23C200040D64    	   287: 	move.l d2,framebuf_dcb+DCB_INDIMY
00:00001BC4 23C300040D68    	   288: 	move.l d3,framebuf_dcb+DCB_INDIMZ
00:00001BCA 7000            	   289: 	move.l #E_Ok,d0
00:00001BCC 4E75            	   290: 	rts
                            	   291: .0002:
00:00001BCE 0C000002        	   292: 	cmpi.b #2,d0		; set window dimensions
00:00001BD2 6616            	   293: 	bne.s .0003
00:00001BD4 48E76000        	   294: 	movem.l d1/d2,-(a7)
00:00001BD8 48C2            	   295: 	ext.l d2
00:00001BDA 4842            	   296: 	swap d2
00:00001BDC 48C1            	   297: 	ext.l d1
00:00001BDE 8282            	   298: 	or.l d2,d1
00:00001BE0 23C1FD208078    	   299: 	move.l d1,FRAMEBUF+FRAMEBUF_WINDOW_DIMEN
00:00001BE6 4CDF0006        	   300: 	movem.l (a7)+,d1/d2
                            	   301: .0003:
00:00001BEA 7000            	   302: 	move.l #E_Ok,d0
00:00001BEC 4E75            	   303: 	rts
                            	   304: 
                            	   305: 
                            	   306: ;---------------------------------------------------------------------
                            	   307: ; The following uses point plot hardware built into the frame buffer.
                            	   308: ; It is assumed that previous commands have finished already.
                            	   309: ; It may take a few dozen clocks for a command to complete. As long
                            	   310: ; as this routine is not called to fast in succession it should be
                            	   311: ; okay.
                            	   312: ;---------------------------------------------------------------------
                            	   313: 
                            	   314: 	align 2
                            	   315: framebuf_writeat:
                            	   316: plot:
00:00001BF0 606A            	   317: 	bra plot_sw
00:00001BF2 48E76080        	   318: 	movem.l d1/d2/a0,-(a7)
00:00001BF6 207CFD208000    	   319: 	move.l #FRAMEBUF,a0
                            	   320: .0001:
                            	   321: ;	tst.b 40(a0)				; wait for any previous command to finish
                            	   322: ;	bne.s .0001										; Then set:
00:00001BFC 31410020        	   323: 	move.w d1,32(a0)							; pixel x co-ord
00:00001C00 31420022        	   324: 	move.w d2,34(a0)							; pixel y co-ord
00:00001C04 317900040D7C002C	   325: 	move.w framebuf_dcb+DCB_FGCOLOR,44(a0)	; pixel color
00:00001C0C 117900040D800029	   326: 	move.b framebuf_dcb+DCB_OPCODE,41(a0)	; set raster operation
00:00001C14 117C00020028    	   327: 	move.b #2,40(a0)							; point plot command
00:00001C1A 4CDF0106        	   328: 	movem.l (a7)+,d1/d2/a0
00:00001C1E 4E75            	   329: 	rts
                            	   330: 
                            	   331: ;-------------------------------------------
                            	   332: ; In case of lacking hardware plot
                            	   333: ;-------------------------------------------
                            	   334: 	align 2
                            	   335: plottbl:
00:00001C20 00001CCE        	   336: 	dc.l plot_black
00:00001C24 00001CC0        	   337: 	dc.l plot_copy
00:00001C28 00001CC0        	   338: 	dc.l plot_copy
00:00001C2C 00001CAC        	   339: 	dc.l plot_and
00:00001C30 00001C82        	   340: 	dc.l plot_or
00:00001C34 00001C96        	   341: 	dc.l plot_xor
00:00001C38 00001CC0        	   342: 	dc.l plot_copy
00:00001C3C 00001CC0        	   343: 	dc.l plot_copy
00:00001C40 00001CC0        	   344: 	dc.l plot_copy
00:00001C44 00001CC0        	   345: 	dc.l plot_copy
00:00001C48 00001CC0        	   346: 	dc.l plot_copy
00:00001C4C 00001CC0        	   347: 	dc.l plot_copy
00:00001C50 00001CC0        	   348: 	dc.l plot_copy
00:00001C54 00001CC0        	   349: 	dc.l plot_copy
00:00001C58 00001CD8        	   350: 	dc.l plot_white
                            	   351: 
                            	   352: 	align 2
                            	   353: plot_sw:
00:00001C5C 48E778C0        	   354: 	movem.l d1/d2/d3/d4/a0/a1,-(a7)
00:00001C60 C4F900040D6C    	   355: 	mulu framebuf_dcb+DCB_OUTDIMX,d2	; multiply y by screen width
                            	   356: ;	move.l d1,d3
                            	   357: ;	andi.l #30,d3
                            	   358: ;	moveq #30,d4
                            	   359: ;	sub.l d4,d3
                            	   360: ;	andi.l #$FFFFFFE0,d1
                            	   361: ;	or.l d3,d1
00:00001C66 48C1            	   362: 	ext.l d1											; clear high-order word of x
00:00001C68 D481            	   363: 	add.l d1,d2										; add in x co-ord
00:00001C6A D482            	   364: 	add.l d2,d2										; *2 for 16 BPP
00:00001C6C 207900040D8C    	   365: 	move.l framebuf_dcb+DCB_OUTBUFPTR2,a0		; where the draw occurs
00:00001C72 163900040D80    	   366: 	move.b framebuf_dcb+DCB_OPCODE,d3				; raster operation
00:00001C78 4883            	   367: 	ext.w d3
00:00001C7A E54B            	   368: 	lsl.w #2,d3
00:00001C7C 227B30A2        	   369: 	move.l plottbl(pc,d3.w),a1
00:00001C80 4ED1            	   370: 	jmp (a1)
                            	   371: plot_or:
00:00001C82 38302800        	   372: 	move.w (a0,d2.l),d4	
00:00001C86 887900040D7C    	   373: 	or.w framebuf_dcb+DCB_FGCOLOR,d4
00:00001C8C 31842800        	   374: 	move.w d4,(a0,d2.l)
00:00001C90 4CDF031E        	   375: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001C94 4E75            	   376: 	rts
                            	   377: plot_xor:
00:00001C96 38302800        	   378: 	move.w (a0,d2.l),d4
00:00001C9A 363900040D7C    	   379: 	move.w framebuf_dcb+DCB_FGCOLOR,d3	
00:00001CA0 B744            	   380: 	eor.w d3,d4
00:00001CA2 31842800        	   381: 	move.w d4,(a0,d2.l)
00:00001CA6 4CDF031E        	   382: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001CAA 4E75            	   383: 	rts
                            	   384: plot_and:
00:00001CAC 38302800        	   385: 	move.w (a0,d2.l),d4	
00:00001CB0 C87900040D7C    	   386: 	and.w framebuf_dcb+DCB_FGCOLOR,d4
00:00001CB6 31842800        	   387: 	move.w d4,(a0,d2.l)
00:00001CBA 4CDF031E        	   388: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001CBE 4E75            	   389: 	rts
                            	   390: plot_copy:
00:00001CC0 31B900040D7C2800	   391: 	move.w framebuf_dcb+DCB_FGCOLOR,(a0,d2.l)
00:00001CC8 4CDF031E        	   392: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001CCC 4E75            	   393: 	rts
                            	   394: plot_black:
00:00001CCE 42702800        	   395: 	clr.w (a0,d2.l)
00:00001CD2 4CDF031E        	   396: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001CD6 4E75            	   397: 	rts
                            	   398: plot_white:
00:00001CD8 31BCFF7F2800    	   399: 	move.w #$FF7F,(a0,d2.l)
00:00001CDE 4CDF031E        	   400: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001CE2 4E75            	   401: 	rts
                            	   402: 
                            	   403: 
                            	   404: 	align 2
                            	   405: clear_graphics_screen:
                            	   406: ;	move.l #0,d1
                            	   407: ;	bsr gfxaccel_set_color
                            	   408: ;	move.l #0,d1
                            	   409: ;	move.l #0,d2
                            	   410: ;	move.l #1920<<16,d3
                            	   411: ;	move.l #1080<<16,d4
                            	   412: ;	bsr gfxaccel_draw_rectangle
00:00001CE4 2A3C00100800    	   413: 	move.l #VIDEO_X*VIDEO_Y,d5		; compute number of strips to write
00:00001CEA E68D            	   414: 	lsr.l #3,d5						; 8 pixels per strip
                            	   415: ;	move.l framebuf_dcb+DCB_OUTBUFPTR,a4
00:00001CEC 287C40000000    	   416: 	move.l #$40000000,a4
00:00001CF2 42B97FFFFFF8    	   417: 	move.l #0,$7FFFFFF8		; burst length of zero
00:00001CF8 6002            	   418: 	bra.s .0001
                            	   419: .0002:
00:00001CFA 4845            	   420: 	swap d5
                            	   421: .0001:
00:00001CFC 220C            	   422: 	move.l a4,d1
00:00001CFE 23C17FFFFFF4    	   423: 	move.l d1,$7FFFFFF4		; target address
00:00001D04 42B97FFFFFFC    	   424: 	move.l #0,$7FFFFFFC		; value to write
00:00001D0A 49EC0020        	   425: 	lea.l 32(a4),a4
00:00001D0E 51CDFFEC        	   426: 	dbra d5,.0001
                            	   427: ;	swap d5
                            	   428: ;	dbra d5,.0002
00:00001D12 4E75            	   429: 	rts
                            	   430: 
                            	   431: 
                            	   432: ; Clears the page opposite to the display page
                            	   433: 
                            	   434: 	align 2
                            	   435: framebuf_clear:
00:00001D14 F2276800        	   436: 	fmove.x fp0,-(a7)
00:00001D18 F2276880        	   437: 	fmove.x fp1,-(a7)
00:00001D1C 48E76880        	   438: 	movem.l d1/d2/d4/a0,-(a7)
00:00001D20 1239FD208003    	   439: 	move.b FRAMEBUF+3,d1		; get displayed page
00:00001D26 0C010001        	   440: 	cmpi.b #1,d1
00:00001D2A 6608            	   441: 	bne.s .0001
00:00001D2C 207900040D54    	   442: 	move.l framebuf_dcb+DCB_OUTBUFPTR,a0		; where the draw occurs
00:00001D32 6006            	   443: 	bra.s .0002
                            	   444: .0001
00:00001D34 207900040D8C    	   445: 	move.l framebuf_dcb+DCB_OUTBUFPTR2,a0		; where the draw occurs
                            	   446: .0002
00:00001D3A 223900040D6C    	   447: 	move.l framebuf_dcb+DCB_OUTDIMX,d1
00:00001D40 243900040D70    	   448: 	move.l framebuf_dcb+DCB_OUTDIMY,d2
00:00001D46 C4C1            	   449: 	mulu d1,d2							; d2 = X dimen * Y dimen = number of pixels
00:00001D48 2239FD2080B0    	   450: 	move.l FRAMEBUF+FRAMEBUF_PPS,d1
00:00001D4E 024103FF        	   451: 	andi.w #$3ff,d1					; extract pixels per strip
00:00001D52 48C1            	   452: 	ext.l d1
00:00001D54 2801            	   453: 	move.l d1,d4						; d4.w = pixels per strip
00:00001D56 D484            	   454: 	add.l d4,d2							; round number of pixels on screen up a strip
00:00001D58 F2024000        	   455: 	fmove.l d2,fp0					; number might be too big for divu
00:00001D5C F2044080        	   456: 	fmove.l d4,fp1					; so use float divider
00:00001D60 F2000420        	   457: 	fdiv fp1,fp0						; fp0 = screen size / pixels per strip
00:00001D64 F2006000        	   458: 	fmove.l fp0,d0					; d0 = number of strips to set
00:00001D68 223900040D7C    	   459: 	move.l framebuf_dcb+DCB_FGCOLOR,d1
00:00001D6E 2801            	   460: 	move.l d1,d4
00:00001D70 42B97FFFFFF8    	   461: 	move.l #0,$7FFFFFF8			; set burst length zero
00:00001D76 6002            	   462: 	bra.s .loop
                            	   463: .loop2:
00:00001D78 4840            	   464: 	swap d0
                            	   465: .loop:
00:00001D7A 2208            	   466: 	move.l a0,d1
00:00001D7C 23C17FFFFFF4    	   467: 	move.l d1,$7FFFFFF4			; set destination address
00:00001D82 23C47FFFFFFC    	   468: 	move.l d4,$7FFFFFFC			; write value (color) to use and trigger write op
00:00001D88 41E80020        	   469: 	lea 32(a0),a0						; advance pointer
00:00001D8C 51C8FFEC        	   470: 	dbra d0,.loop
00:00001D90 4840            	   471: 	swap d0
00:00001D92 51C8FFE4        	   472: 	dbra d0,.loop2
00:00001D96 4CDF0116        	   473: 	movem.l (a7)+,d1/d2/d4/a0
00:00001D9A F21F4880        	   474: 	fmove.x (a7)+,fp1
00:00001D9E F21F4800        	   475: 	fmove.x (a7)+,fp0
00:00001DA2 7000            	   476: 	move.l #E_Ok,d0
00:00001DA4 4E75            	   477: 	rts
                            	   478: 
                            	   479: ; The following code using bursts of 1k pixels did not work (hardware).
                            	   480: ;
                            	   481: ;clear_bitmap_screen2:
                            	   482: ;	move.l gr_bitmap_screen,a0
                            	   483: ;clear_bitmap_screen3:
                            	   484: ;	movem.l d0/d2/a0,-(a7)
                            	   485: ;	move.l #$3F3F3F3F,$BFFFFFF4	; 32x64 byte burst
                            	   486: ;	move.w pen_color,d0
                            	   487: ;	swap d0
                            	   488: ;	move.w pen_color,d0
                            	   489: ;	move.w gr_width,d2		; calc. number of pixels on screen
                            	   490: ;	mulu gr_height,d2
                            	   491: ;	add.l #1023,d2				; rounding up
                            	   492: ;	lsr.l #8,d2						; divide by 1024 pixel update
                            	   493: ;	lsr.l #2,d2
                            	   494: ;.0001:
                            	   495: ;	move.l a0,$BFFFFFF8		; write update address
                            	   496: ;	add.l #2048,a0				; update pointer
                            	   497: ;	move.l d0,$BFFFFFFC		; trigger burst write of 2048 bytes
                            	   498: ;	dbra d2,.0001
                            	   499: ;	movem.l (a7)+,d0/d2/a0
                            	   500: ;	rts
                            	   501: 
                            	   502: ; More conventional but slow way of clearing the screen.
                            	   503: ;
                            	   504: ;clear_bitmap_screen:
                            	   505: ;	move.l gr_bitmap_screen,a0
                            	   506: ;clear_bitmap_screen1:
                            	   507: ;	movem.l d0/d2/a0,-(a7)
                            	   508: ;	move.w pen_color,d0
                            	   509: ;	swap d0
                            	   510: ;	move.w pen_color,d0
                            	   511: ;	move.w gr_width,d2		; calc. number of pixels on screen
                            	   512: ;	mulu gr_height,d2			; 800x600 = 480000
                            	   513: ;	bra.s .0001
                            	   514: ;.0002:
                            	   515: ;	swap d2
                            	   516: ;.0001:
                            	   517: ;	move.l d0,(a0)+
                            	   518: ;	dbra d2,.0001
                            	   519: ;	swap d2
                            	   520: ;	dbra d2,.0002
                            	   521: ;	movem.l (a7)+,d0/d2/a0
                            	   522: ;	rts
                            	   523: 
                            	   524: 

Source: "boot.x68"
                            	   613: 	include "gfxaccel.x68"

Source: "gfxaccel.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: GFX_CTRL		equ	$00
                            	    38: GFX_STATUS	equ $04
                            	    39: GFX_TARGET_BASE		equ $10
                            	    40: GFX_TARGET_SIZE_X	equ $14
                            	    41: GFX_TARGET_SIZE_Y equ $18
                            	    42: GFX_DEST_PIXEL_X  equ $38
                            	    43: GFX_DEST_PIXEL_Y  equ $3c
                            	    44: GFX_DEST_PIXEL_Z  equ $40
                            	    45: GFX_CLIP_PIXEL0_X	equ $74
                            	    46: GFX_CLIP_PIXEL0_Y	equ $78
                            	    47: GFX_CLIP_PIXEL1_X	equ $7C
                            	    48: GFX_CLIP_PIXEL1_Y	equ $80
                            	    49: GFX_COLOR0	equ $84
                            	    50: GFX_COLOR1	equ $88
                            	    51: GFX_COLOR2	equ $8C
                            	    52: GFX_TARGET_X0	equ $B0
                            	    53: GFX_TARGET_Y0 equ $B4
                            	    54: GFX_TARGET_X1	equ $B8
                            	    55: GFX_TARGET_Y1	equ $BC
                            	    56: GFX_COLOR_COMP equ $D0
                            	    57: GFX_PPS equ $D4
                            	    58: 
                            	    59: ;------------------------------------------------------------------------------
                            	    60: ;------------------------------------------------------------------------------
                            	    61: ; Graphics accelerator
                            	    62: ;------------------------------------------------------------------------------
                            	    63: ;------------------------------------------------------------------------------
                            	    64: 	align 2
                            	    65: GFXACCEL_CMDTBL:
00:00001DA8 00001EE6        	    66: 	dc.l gfxaccel_init				; 0
00:00001DAC 00001F48        	    67: 	dc.l gfxaccel_stat
00:00001DB0 00001F56        	    68: 	dc.l gfxaccel_putchar
00:00001DB4 00001F56        	    69: 	dc.l gfxaccel_putbuf
00:00001DB8 00001F56        	    70: 	dc.l gfxaccel_getchar
00:00001DBC 00001F56        	    71: 	dc.l gfxaccel_getbuf
00:00001DC0 00001F56        	    72: 	dc.l gfxaccel_set_inpos
00:00001DC4 00001F56        	    73: 	dc.l gfxaccel_set_outpos
00:00001DC8 00001F56        	    74: 	dc.l gfxaccel_stub
00:00001DCC 00001F56        	    75: 	dc.l gfxaccel_stub
00:00001DD0 00001F56        	    76: 	dc.l gfxaccel_stub				; 10
00:00001DD4 00001F56        	    77: 	dc.l gfxaccel_stub
00:00001DD8 00001FBA        	    78: 	dc.l gfxaccel_clear
00:00001DDC 00001F56        	    79: 	dc.l gfxaccel_swapbuf
00:00001DE0 00001F56        	    80: 	dc.l gfxaccel_setbuf1
00:00001DE4 00001F56        	    81: 	dc.l gfxaccel_setbuf2
00:00001DE8 00001F56        	    82: 	dc.l gfxaccel_getbuf1
00:00001DEC 00001F56        	    83: 	dc.l gfxaccel_getbuf2
00:00001DF0 00001F56        	    84: 	dc.l gfxaccel_writeat
00:00001DF4 00001F56        	    85: 	dc.l gfxaccel_set_unit
00:00001DF8 00001F56        	    86: 	dc.l gfxaccel_get_dimen	; 20
00:00001DFC 00002060        	    87: 	dc.l gfxaccel_get_color
00:00001E00 00001F56        	    88: 	dc.l gfxaccel_get_inpos
00:00001E04 00001F56        	    89: 	dc.l gfxaccel_get_outpos
00:00001E08 00001F56        	    90: 	dc.l gfxaccel_get_outptr
00:00001E0C 0000206E        	    91: 	dc.l gfxaccel_set_color
00:00001E10 0000208E        	    92: 	dc.l gfxaccel_set_color123
00:00001E14 00002136        	    93: 	dc.l gfxaccel_plot_point
00:00001E18 00002188        	    94: 	dc.l gfxaccel_draw_line
00:00001E1C 00002258        	    95: 	dc.l gfxaccel_draw_triangle
00:00001E20 000021F0        	    96: 	dc.l gfxaccel_draw_rectangle	;30
00:00001E24 000022E0        	    97: 	dc.l gfxaccel_draw_curve
00:00001E28 00001F5A        	    98: 	dc.l gfxaccel_set_dimen
00:00001E2C 0000204E        	    99: 	dc.l gfxaccel_set_color_depth
00:00001E30 00001F8E        	   100: 	dc.l gfxaccel_set_destbuf
00:00001E34 00001F56        	   101: 	dc.l gfxaccel_set_dispbuf
                            	   102: 
                            	   103: 	code
                            	   104: 	even
                            	   105: 
                            	   106: gfxaccel_cmdproc:
00:00001E38 0C060024        	   107: 	cmpi.b #36,d6
00:00001E3C 641A            	   108: 	bhs.s .0001
00:00001E3E 48E70280        	   109: 	movem.l d6/a0,-(a7)
00:00001E42 4886            	   110: 	ext.w d6
00:00001E44 48C6            	   111: 	ext.l d6
00:00001E46 E54E            	   112: 	lsl.w #2,d6
00:00001E48 41FAFF5E        	   113: 	lea.l GFXACCEL_CMDTBL,a0
00:00001E4C 20706000        	   114: 	move.l (a0,d6.w),a0
00:00001E50 4E90            	   115: 	jsr (a0)
00:00001E52 4CDF0140        	   116: 	movem.l (a7)+,d6/a0
00:00001E56 4E75            	   117: 	rts
                            	   118: .0001:
00:00001E58 7002            	   119: 	moveq #E_Func,d0
00:00001E5A 4E75            	   120: 	rts
                            	   121: 
                            	   122: setup_gfxaccel:
00:00001E5C 48E780C0        	   123: 	movem.l d0/a0/a1,-(a7)
00:00001E60 7020            	   124: 	moveq #32,d0
00:00001E62 41F900040D9C    	   125: 	lea.l gfxaccel_dcb,a0
                            	   126: .0001:
00:00001E68 4298            	   127: 	clr.l (a0)+
00:00001E6A 51C8FFFC        	   128: 	dbra d0,.0001
00:00001E6E 23FC444342200004	   129: 	move.l #$44434220,gfxaccel_dcb+DCB_MAGIC			; 'DCB'
00:00001E76 0D9C
00:00001E78 23FC474658410004	   130: 	move.l #$47465841,gfxaccel_dcb+DCB_NAME				; 'GFXACCEL'
00:00001E80 0DA0
00:00001E82 23FC4343454C0004	   131: 	move.l #$4343454C,gfxaccel_dcb+DCB_NAME+4
00:00001E8A 0DA4
00:00001E8C 23FC00001E380004	   132: 	move.l #gfxaccel_cmdproc,gfxaccel_dcb+DCB_CMDPROC
00:00001E94 0DB4
00:00001E96 7000            	   133: 	move.l #$00000000,d0
00:00001E98 23C000040DD4    	   134: 	move.l d0,gfxaccel_dcb+DCB_INBUFPTR
00:00001E9E 23C000040DD8    	   135: 	move.l d0,gfxaccel_dcb+DCB_OUTBUFPTR
00:00001EA4 D0BC00400000    	   136: 	add.l #$400000,d0
00:00001EAA 23C000040E0C    	   137: 	move.l d0,gfxaccel_dcb+DCB_INBUFPTR2
00:00001EB0 23C000040E10    	   138: 	move.l d0,gfxaccel_dcb+DCB_OUTBUFPTR2
00:00001EB6 23FC004000000004	   139: 	move.l #$00400000,gfxaccel_dcb+DCB_INBUFSIZE
00:00001EBE 0DDC
00:00001EC0 23FC004000000004	   140: 	move.l #$00400000,gfxaccel_dcb+DCB_OUTBUFSIZE
00:00001EC8 0DE0
00:00001ECA 23FC88880000FD21	   141: 	move.l #$88880000,GFXACCEL+GFX_COLOR_COMP
00:00001ED2 00D0
00:00001ED4 43F900040D9C    	   142: 	lea.l gfxaccel_dcb+DCB_MAGIC,a1
00:00001EDA 61005C30        	   143: 	jsr DisplayString
00:00001EDE 61005C12        	   144: 	jsr CRLF
00:00001EE2 4CDF0301        	   145: 	movem.l (a7)+,d0/a0/a1
                            	   146: 
                            	   147: gfxaccel_init:
00:00001EE6 2F01            	   148: 	move.l d1,-(a7)
00:00001EE8 720A            	   149: 	moveq #10,d1
00:00001EEA 6100047A        	   150: 	bsr gfxaccel_wait
00:00001EEE 7200            	   151: 	move.l #0,d1
00:00001EF0 23C1000408C0    	   152: 	move.l d1,gfxaccel_ctrl
00:00001EF6 61007934        	   153: 	bsr rbo
00:00001EFA 23C1FD210000    	   154: 	move.l d1,GFXACCEL+GFX_CTRL
00:00001F00 7200            	   155: 	move.l #$00000000,d1
00:00001F02 61007928        	   156: 	bsr rbo
00:00001F06 23C1FD210010    	   157: 	move.l d1,GFXACCEL+GFX_TARGET_BASE	; base draw address
00:00001F0C 223C00000320    	   158: 	move.l #800,d1
00:00001F12 61007918        	   159: 	bsr rbo
00:00001F16 23C1FD210014    	   160: 	move.l d1,GFXACCEL+GFX_TARGET_SIZE_X	; render target x dimension
00:00001F1C 23C1FD2100B8    	   161: 	move.l d1,GFXACCEL+GFX_TARGET_X1
00:00001F22 223C00000258    	   162: 	move.l #600,d1
00:00001F28 61007902        	   163: 	bsr rbo
00:00001F2C 23C1FD210018    	   164: 	move.l d1,GFXACCEL+GFX_TARGET_SIZE_Y	; render target y dimension
00:00001F32 23C1FD2100BC    	   165: 	move.l d1,GFXACCEL+GFX_TARGET_Y1
00:00001F38 42B9FD2100B0    	   166: 	move.l #0,GFXACCEL+GFX_TARGET_X0
00:00001F3E 42B9FD2100B4    	   167: 	move.l #0,GFXACCEL+GFX_TARGET_Y0
00:00001F44 221F            	   168: 	move.l (a7)+,d1
00:00001F46 4E75            	   169: 	rts
                            	   170: 
                            	   171: gfxaccel_stat:
00:00001F48 2239FD210004    	   172: 	move.l GFXACCEL+GFX_STATUS,d1
00:00001F4E 610078DC        	   173: 	bsr rbo
00:00001F52 7000            	   174: 	moveq #E_Ok,d0
00:00001F54 4E75            	   175: 	rts
                            	   176: 
                            	   177: gfxaccel_putchar:
                            	   178: gfxaccel_getchar:
                            	   179: gfxaccel_putbuf:
                            	   180: gfxaccel_getbuf:
                            	   181: gfxaccel_set_inpos:
                            	   182: gfxaccel_set_outpos:
                            	   183: gfxaccel_stub:
                            	   184: gfxaccel_swapbuf:
                            	   185: gfxaccel_setbuf1:
                            	   186: gfxaccel_setbuf2:
                            	   187: gfxaccel_getbuf1:
                            	   188: gfxaccel_getbuf2:
                            	   189: gfxaccel_writeat:
                            	   190: gfxaccel_set_unit:
                            	   191: gfxaccel_get_dimen:
                            	   192: gfxaccel_get_inpos:
                            	   193: gfxaccel_get_outpos:
                            	   194: gfxaccel_get_outptr:
                            	   195: gfxaccel_set_dispbuf:
00:00001F56 700A            	   196: 	move.l #E_NotSupported,d0
00:00001F58 4E75            	   197: 	rts
                            	   198: 
                            	   199: gfxaccel_set_dimen:
00:00001F5A 2F01            	   200: 	move.l d1,-(a7)
00:00001F5C 2001            	   201: 	move.l d1,d0
00:00001F5E 7206            	   202: 	moveq #6,d1
00:00001F60 61000404        	   203: 	bsr gfxaccel_wait					; wait for an open slot
00:00001F64 2200            	   204: 	move.l d0,d1
00:00001F66 610078C4        	   205: 	bsr rbo
00:00001F6A 23C1FD210014    	   206: 	move.l d1,GFXACCEL+GFX_TARGET_SIZE_X	; render target x dimension
00:00001F70 23C1FD2100B8    	   207: 	move.l d1,GFXACCEL+GFX_TARGET_X1
00:00001F76 2202            	   208: 	move.l d2,d1
00:00001F78 610078B2        	   209: 	bsr rbo
00:00001F7C 23C1FD210018    	   210: 	move.l d1,GFXACCEL+GFX_TARGET_SIZE_Y	; render target y dimension
00:00001F82 23C1FD2100BC    	   211: 	move.l d1,GFXACCEL+GFX_TARGET_Y1
00:00001F88 221F            	   212: 	move.l (a7)+,d1
00:00001F8A 7000            	   213: 	moveq #E_Ok,d0
00:00001F8C 4E75            	   214: 	rts
                            	   215: 
                            	   216: gfxaccel_set_destbuf:
00:00001F8E 2001            	   217: 	move.l d1,d0
00:00001F90 7203            	   218: 	moveq #3,d1
00:00001F92 610003D2        	   219: 	bsr gfxaccel_wait					; wait for an open slot
00:00001F96 0C000001        	   220: 	cmpi.b #1,d0
00:00001F9A 6608            	   221: 	bne.s .0001
00:00001F9C 223900040E10    	   222: 	move.l gfxaccel_dcb+DCB_OUTBUFPTR2,d1
00:00001FA2 6006            	   223: 	bra.s .0002
                            	   224: .0001:
00:00001FA4 223900040DD8    	   225: 	move.l gfxaccel_dcb+DCB_OUTBUFPTR,d1
                            	   226: .0002:
00:00001FAA 61007880        	   227: 	bsr rbo
00:00001FAE 23C1FD210010    	   228: 	move.l d1,GFXACCEL+GFX_TARGET_BASE
00:00001FB4 2200            	   229: 	move.l d0,d1
00:00001FB6 7000            	   230: 	move.l #E_Ok,d0
00:00001FB8 4E75            	   231: 	rts
                            	   232: 
                            	   233: ; Clears destination buffer
                            	   234: 
                            	   235: gfxaccel_clear:
00:00001FBA F2276800        	   236: 	fmove.x fp0,-(a7)
00:00001FBE F2276880        	   237: 	fmove.x fp1,-(a7)
00:00001FC2 48E76880        	   238: 	movem.l d1/d2/d4/a0,-(a7)
00:00001FC6 2239FD210014    	   239: 	move.l GFXACCEL+GFX_TARGET_SIZE_X,d1
00:00001FCC 6100785E        	   240: 	bsr rbo
00:00001FD0 2401            	   241: 	move.l d1,d2
00:00001FD2 2239FD210018    	   242: 	move.l GFXACCEL+GFX_TARGET_SIZE_Y,d1
00:00001FD8 61007852        	   243: 	bsr rbo
00:00001FDC C4C1            	   244: 	mulu d1,d2							; d2 = X dimen * Y dimen = number of pixels
00:00001FDE 2239FD2100D4    	   245: 	move.l GFXACCEL+GFX_PPS,d1	; d1 = pixels per strip reg
00:00001FE4 61007846        	   246: 	bsr rbo
00:00001FE8 024103FF        	   247: 	andi.w #$3ff,d1					; extract pixels per strip
00:00001FEC 48C1            	   248: 	ext.l d1
00:00001FEE 2801            	   249: 	move.l d1,d4						; d4.w = pixels per strip
00:00001FF0 D484            	   250: 	add.l d4,d2							; round number of pixels on screen up a strip
00:00001FF2 F2024000        	   251: 	fmove.l d2,fp0					; number might be too big for divu
00:00001FF6 F2044080        	   252: 	fmove.l d4,fp1					; so use float divider
00:00001FFA F2000420        	   253: 	fdiv fp1,fp0						; fp0 = screen size / pixels per strip
00:00001FFE F2006000        	   254: 	fmove.l fp0,d0					; d0 = number of strips to set
00:00002002 2839FD210084    	   255: 	move.l GFXACCEL+GFX_COLOR0,d4
00:00002008 2239FD210010    	   256: 	move.l GFXACCEL+GFX_TARGET_BASE,d1
00:0000200E 6100781C        	   257: 	bsr rbo
00:00002012 2041            	   258: 	move.l d1,a0
00:00002014 42B97FFFFFF8    	   259: 	move.l #0,$7FFFFFF8			; set burst length zero
00:0000201A 6002            	   260: 	bra.s .loop
                            	   261: .loop2:
00:0000201C 4840            	   262: 	swap d0
                            	   263: .loop:
00:0000201E 2208            	   264: 	move.l a0,d1
00:00002020 6100780A        	   265: 	bsr rbo
00:00002024 23C17FFFFFF4    	   266: 	move.l d1,$7FFFFFF4			; set destination address
00:0000202A 23C47FFFFFFC    	   267: 	move.l d4,$7FFFFFFC			; write value (color) to use and trigger write op
00:00002030 41E80020        	   268: 	lea 32(a0),a0						; advance pointer
00:00002034 51C8FFE8        	   269: 	dbra d0,.loop
00:00002038 4840            	   270: 	swap d0
00:0000203A 51C8FFE0        	   271: 	dbra d0,.loop2
00:0000203E 4CDF0116        	   272: 	movem.l (a7)+,d1/d2/d4/a0
00:00002042 F21F4880        	   273: 	fmove.x (a7)+,fp1
00:00002046 F21F4800        	   274: 	fmove.x (a7)+,fp0
00:0000204A 7000            	   275: 	move.l #E_Ok,d0
00:0000204C 4E75            	   276: 	rts
                            	   277: 
                            	   278: 
                            	   279: gfxaccel_set_color_depth:
00:0000204E 2200            	   280: 	move.l d0,d1
00:00002050 610077DA        	   281: 	bsr rbo
00:00002054 23C1FD2100D0    	   282: 	move.l d1,GFXACCEL+GFX_COLOR_COMP
00:0000205A 2200            	   283: 	move.l d0,d1
00:0000205C 7000            	   284: 	moveq #E_Ok,d0
00:0000205E 4E75            	   285: 	rts
                            	   286: 	
                            	   287: gfxaccel_get_color:
00:00002060 2239FD210084    	   288: 	move.l GFXACCEL+GFX_COLOR0,d1
00:00002066 610077C4        	   289: 	bsr rbo
00:0000206A 7000            	   290: 	moveq #E_Ok,d0
00:0000206C 4E75            	   291: 	rts
                            	   292: 
                            	   293: gfxaccel_set_color:
00:0000206E 48E75000        	   294: 	movem.l d1/d3,-(a7)
00:00002072 2601            	   295: 	move.l d1,d3
00:00002074 7203            	   296: 	moveq #3,d1
00:00002076 610002EE        	   297: 	bsr gfxaccel_wait					; wait for an open slot
00:0000207A 2203            	   298: 	move.l d3,d1
00:0000207C 610077AE        	   299: 	bsr rbo
00:00002080 23C1FD210084    	   300: 	move.l d1,GFXACCEL+GFX_COLOR0
00:00002086 4CDF000A        	   301: 	movem.l (a7)+,d1/d3
00:0000208A 7000            	   302: 	moveq #E_Ok,d0
00:0000208C 4E75            	   303: 	rts
                            	   304: 
                            	   305: gfxaccel_set_color123:
00:0000208E 48E74800        	   306: 	movem.l d1/d4,-(a7)
00:00002092 2801            	   307: 	move.l d1,d4
00:00002094 7205            	   308: 	moveq #5,d1
00:00002096 610002CE        	   309: 	bsr gfxaccel_wait					; wait for an open slot
00:0000209A 2204            	   310: 	move.l d4,d1
00:0000209C 6100778E        	   311: 	bsr rbo
00:000020A0 23C1FD210084    	   312: 	move.l d1,GFXACCEL+GFX_COLOR0
00:000020A6 2202            	   313: 	move.l d2,d1
00:000020A8 61007782        	   314: 	bsr rbo
00:000020AC 23C1FD210088    	   315: 	move.l d1,GFXACCEL+GFX_COLOR1
00:000020B2 2203            	   316: 	move.l d3,d1
00:000020B4 61007776        	   317: 	bsr rbo
00:000020B8 23C1FD21008C    	   318: 	move.l d1,GFXACCEL+GFX_COLOR2
00:000020BE 4CDF0012        	   319: 	movem.l (a7)+,d1/d4
00:000020C2 7000            	   320: 	moveq #E_Ok,d0
00:000020C4 4E75            	   321: 	rts
                            	   322: 
                            	   323: gfxaccel_clip_rect:
00:000020C6 48E74400        	   324: 	movem.l d1/d5,-(a7)
00:000020CA 2A01            	   325: 	move.l d1,d5
00:000020CC 7206            	   326: 	moveq #6,d1
00:000020CE 61000296        	   327: 	bsr gfxaccel_wait					; wait for an open slot
00:000020D2 2205            	   328: 	move.l d5,d1
00:000020D4 61007756        	   329: 	bsr rbo
00:000020D8 23C1FD210074    	   330: 	move.l d1,GFXACCEL+GFX_CLIP_PIXEL0_X
00:000020DE 2202            	   331: 	move.l d2,d1
00:000020E0 6100774A        	   332: 	bsr rbo
00:000020E4 23C1FD210078    	   333: 	move.l d1,GFXACCEL+GFX_CLIP_PIXEL0_Y
00:000020EA 2203            	   334: 	move.l d3,d1
00:000020EC 6100773E        	   335: 	bsr rbo
00:000020F0 23C1FD21007C    	   336: 	move.l d1,GFXACCEL+GFX_CLIP_PIXEL1_X
00:000020F6 2204            	   337: 	move.l d4,d1
00:000020F8 61007732        	   338: 	bsr rbo
00:000020FC 23C1FD210080    	   339: 	move.l d1,GFXACCEL+GFX_CLIP_PIXEL1_Y
00:00002102 4CDF0022        	   340: 	movem.l (a7)+,d1/d5
00:00002106 7000            	   341: 	moveq #E_Ok,d0
00:00002108 4E75            	   342: 	rts
                            	   343: 
                            	   344: ; Parameters:
                            	   345: ;		d2.b = active point to set
                            	   346: ;
                            	   347: gfxaccel_set_active_point:
00:0000210A 4882            	   348: 	ext.w d2
00:0000210C 48C2            	   349: 	ext.l d2
00:0000210E 4842            	   350: 	swap d2													; point number in bits 16,17
00:00002110 2239000408C0    	   351: 	move.l gfxaccel_ctrl,d1
00:00002116 0281FFF8FFFF    	   352: 	andi.l #$FFF8FFFF,d1						; clear point number bits
00:0000211C 8282            	   353: 	or.l d2,d1											; set the point number bits
00:0000211E 008100040000    	   354: 	ori.l #$00040000,d1							; set active point
00:00002124 23C1000408C0    	   355: 	move.l d1,gfxaccel_ctrl
00:0000212A 61007700        	   356: 	bsr rbo
00:0000212E 23C1FD210000    	   357: 	move.l d1,GFXACCEL+GFX_CTRL
00:00002134 4E75            	   358: 	rts
                            	   359: 
                            	   360: ; Graphics accelerator expects that co-ordinates are in 16.16 format.
                            	   361: ; 
                            	   362: gfxaccel_plot_point:
00:00002136 48E74400        	   363: 	movem.l d1/d5,-(a7)
00:0000213A 2A01            	   364: 	move.l d1,d5
00:0000213C 7206            	   365: 	moveq #6,d1
00:0000213E 61000226        	   366: 	bsr gfxaccel_wait								; wait for an open slot
00:00002142 2205            	   367: 	move.l d5,d1
00:00002144 610076E6        	   368: 	bsr rbo
00:00002148 23C1FD210038    	   369: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:0000214E 2202            	   370: 	move.l d2,d1
00:00002150 610076DA        	   371: 	bsr rbo
00:00002154 23C1FD21003C    	   372: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:0000215A 2203            	   373: 	move.l d3,d1
00:0000215C 610076CE        	   374: 	bsr rbo
00:00002160 23C1FD210040    	   375: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Z
00:00002166 4242            	   376: 	move.w #0,d2										; point 0
00:00002168 61A0            	   377: 	bsr gfxaccel_set_active_point
00:0000216A 2239000408C0    	   378: 	move.l gfxaccel_ctrl,d1
00:00002170 008100000080    	   379: 	ori.l #$00000080,d1							; point write, bit will clear automatically
00:00002176 610076B4        	   380: 	bsr rbo
00:0000217A 23C1FD210000    	   381: 	move.l d1,GFXACCEL+GFX_CTRL
00:00002180 4CDF0022        	   382: 	movem.l (a7)+,d1/d5
00:00002184 7000            	   383: 	moveq #E_Ok,d0
00:00002186 4E75            	   384: 	rts
                            	   385: 
                            	   386: gfxaccel_draw_line:
00:00002188 48E76400        	   387: 	movem.l d1/d2/d5,-(a7)
00:0000218C 2A01            	   388: 	move.l d1,d5
00:0000218E 7209            	   389: 	moveq #9,d1
00:00002190 610001D4        	   390: 	bsr gfxaccel_wait								; wait for an open slot
00:00002194 2205            	   391: 	move.l d5,d1
00:00002196 61007694        	   392: 	bsr rbo
00:0000219A 23C1FD210038    	   393: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:000021A0 2202            	   394: 	move.l d2,d1
00:000021A2 61007688        	   395: 	bsr rbo
00:000021A6 23C1FD21003C    	   396: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:000021AC 4242            	   397: 	move.w #0,d2										; point 0
00:000021AE 6100FF5A        	   398: 	bsr gfxaccel_set_active_point
00:000021B2 2203            	   399: 	move.l d3,d1
00:000021B4 61007676        	   400: 	bsr rbo
00:000021B8 23C1FD210038    	   401: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:000021BE 2204            	   402: 	move.l d4,d1
00:000021C0 6100766A        	   403: 	bsr rbo
00:000021C4 23C1FD21003C    	   404: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:000021CA 343C0001        	   405: 	move.w #1,d2										; point 1
00:000021CE 6100FF3A        	   406: 	bsr gfxaccel_set_active_point
00:000021D2 2239000408C0    	   407: 	move.l gfxaccel_ctrl,d1					; get the control reg
00:000021D8 008100000200    	   408: 	ori.l #$00000200,d1							; trigger draw line
00:000021DE 6100764C        	   409: 	bsr rbo
00:000021E2 23C1FD210000    	   410: 	move.l d1,GFXACCEL+GFX_CTRL
00:000021E8 4CDF0026        	   411: 	movem.l (a7)+,d1/d2/d5
00:000021EC 7000            	   412: 	moveq #E_Ok,d0
00:000021EE 4E75            	   413: 	rts
                            	   414: 
                            	   415: ; Draw a rectangle in the currently selected color
                            	   416: ;
                            	   417: ; Parameters:
                            	   418: ;		d1 	- x0 pos
                            	   419: ;		d2	- y0 pos
                            	   420: ;		d3	- x1 pos
                            	   421: ;		d4	- y1 pos
                            	   422: 
                            	   423: gfxaccel_draw_rectangle:
00:000021F0 48E76400        	   424: 	movem.l d1/d2/d5,-(a7)
00:000021F4 2A01            	   425: 	move.l d1,d5
00:000021F6 7209            	   426: 	moveq #9,d1
00:000021F8 6100016C        	   427: 	bsr gfxaccel_wait								; wait for an open slot
00:000021FC 2205            	   428: 	move.l d5,d1
00:000021FE 6100762C        	   429: 	bsr rbo
00:00002202 23C1FD210038    	   430: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:00002208 2202            	   431: 	move.l d2,d1
00:0000220A 61007620        	   432: 	bsr rbo
00:0000220E 23C1FD21003C    	   433: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:00002214 4242            	   434: 	move.w #0,d2										; point 0
00:00002216 6100FEF2        	   435: 	bsr gfxaccel_set_active_point
00:0000221A 2203            	   436: 	move.l d3,d1
00:0000221C 6100760E        	   437: 	bsr rbo
00:00002220 23C1FD210038    	   438: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:00002226 2204            	   439: 	move.l d4,d1
00:00002228 61007602        	   440: 	bsr rbo
00:0000222C 23C1FD21003C    	   441: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:00002232 343C0001        	   442: 	move.w #1,d2										; point 1
00:00002236 6100FED2        	   443: 	bsr gfxaccel_set_active_point
00:0000223A 2239000408C0    	   444: 	move.l gfxaccel_ctrl,d1					; get the control reg
00:00002240 008100000100    	   445: 	ori.l #$00000100,d1							; trigger draw rectangle
00:00002246 610075E4        	   446: 	bsr rbo
00:0000224A 23C1FD210000    	   447: 	move.l d1,GFXACCEL+GFX_CTRL
00:00002250 4CDF0026        	   448: 	movem.l (a7)+,d1/d2/d5
00:00002254 7000            	   449: 	moveq #E_Ok,d0
00:00002256 4E75            	   450: 	rts
                            	   451: 
                            	   452: ; Draw a triangle in the currently selected color
                            	   453: ;
                            	   454: ; Parameters:
                            	   455: ;		d1 	- x0 pos
                            	   456: ;		d2	- y0 pos
                            	   457: ;		d3	- x1 pos
                            	   458: ;		d4	- y1 pos
                            	   459: ;	  d5	- x2 pos
                            	   460: ;		d0	- y2 pos
                            	   461: 
                            	   462: gfxaccel_draw_triangle:
00:00002258 48E76100        	   463: 	movem.l d1/d2/d7,-(a7)
00:0000225C 2E01            	   464: 	move.l d1,d7
00:0000225E 720C            	   465: 	moveq #12,d1
00:00002260 61000104        	   466: 	bsr gfxaccel_wait								; wait for an open slot
00:00002264 2207            	   467: 	move.l d7,d1
00:00002266 610075C4        	   468: 	bsr rbo
00:0000226A 23C1FD210038    	   469: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:00002270 2202            	   470: 	move.l d2,d1
00:00002272 610075B8        	   471: 	bsr rbo
00:00002276 23C1FD21003C    	   472: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:0000227C 4242            	   473: 	move.w #0,d2										; point 0
00:0000227E 6100FE8A        	   474: 	bsr gfxaccel_set_active_point
00:00002282 2203            	   475: 	move.l d3,d1
00:00002284 610075A6        	   476: 	bsr rbo
00:00002288 23C1FD210038    	   477: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:0000228E 2204            	   478: 	move.l d4,d1
00:00002290 6100759A        	   479: 	bsr rbo
00:00002294 23C1FD21003C    	   480: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:0000229A 343C0001        	   481: 	move.w #1,d2										; point 1
00:0000229E 6100FE6A        	   482: 	bsr gfxaccel_set_active_point
00:000022A2 2205            	   483: 	move.l d5,d1
00:000022A4 61007586        	   484: 	bsr rbo
00:000022A8 23C1FD210038    	   485: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:000022AE 2200            	   486: 	move.l d0,d1
00:000022B0 6100757A        	   487: 	bsr rbo
00:000022B4 23C1FD21003C    	   488: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:000022BA 343C0002        	   489: 	move.w #2,d2										; point 2
00:000022BE 6100FE4A        	   490: 	bsr gfxaccel_set_active_point
00:000022C2 2239000408C0    	   491: 	move.l gfxaccel_ctrl,d1					; get the control reg
00:000022C8 008100000400    	   492: 	ori.l #$00000400,d1							; trigger draw triangle
00:000022CE 6100755C        	   493: 	bsr rbo
00:000022D2 23C1FD210000    	   494: 	move.l d1,GFXACCEL+GFX_CTRL
00:000022D8 4CDF0086        	   495: 	movem.l (a7)+,d1/d2/d7
00:000022DC 7000            	   496: 	moveq #E_Ok,d0
00:000022DE 4E75            	   497: 	rts
                            	   498: 
                            	   499: gfxaccel_draw_curve:
00:000022E0 48E76100        	   500: 	movem.l d1/d2/d7,-(a7)
00:000022E4 2E01            	   501: 	move.l d1,d7
00:000022E6 720C            	   502: 	moveq #12,d1
00:000022E8 617C            	   503: 	bsr gfxaccel_wait								; wait for an open slot
00:000022EA 2207            	   504: 	move.l d7,d1
00:000022EC 6100753E        	   505: 	bsr rbo
00:000022F0 23C1FD210038    	   506: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:000022F6 2202            	   507: 	move.l d2,d1
00:000022F8 61007532        	   508: 	bsr rbo
00:000022FC 23C1FD21003C    	   509: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:00002302 4242            	   510: 	move.w #0,d2										; point 0
00:00002304 6100FE04        	   511: 	bsr gfxaccel_set_active_point
00:00002308 2203            	   512: 	move.l d3,d1
00:0000230A 61007520        	   513: 	bsr rbo
00:0000230E 23C1FD210038    	   514: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:00002314 2204            	   515: 	move.l d4,d1
00:00002316 61007514        	   516: 	bsr rbo
00:0000231A 23C1FD21003C    	   517: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:00002320 343C0001        	   518: 	move.w #1,d2										; point 1
00:00002324 6100FDE4        	   519: 	bsr gfxaccel_set_active_point
00:00002328 2205            	   520: 	move.l d5,d1
00:0000232A 61007500        	   521: 	bsr rbo
00:0000232E 23C1FD210038    	   522: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:00002334 2206            	   523: 	move.l d6,d1
00:00002336 610074F4        	   524: 	bsr rbo
00:0000233A 23C1FD21003C    	   525: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:00002340 343C0002        	   526: 	move.w #2,d2										; point 2
00:00002344 6100FDC4        	   527: 	bsr gfxaccel_set_active_point
00:00002348 2239000408C0    	   528: 	move.l gfxaccel_ctrl,d1					; get the control reg
00:0000234E 008100001C00    	   529: 	ori.l #$00001C00,d1							; trigger draw curve+triangle+interp
00:00002354 610074D6        	   530: 	bsr rbo
00:00002358 23C1FD210000    	   531: 	move.l d1,GFXACCEL+GFX_CTRL
00:0000235E 4CDF0086        	   532: 	movem.l (a7)+,d1/d2/d7
00:00002362 7000            	   533: 	moveq #E_Ok,d0
00:00002364 4E75            	   534: 	rts
                            	   535: 
                            	   536: ; Waits until the specified number of queue slots are available.
                            	   537: ;
                            	   538: ; Parameters:
                            	   539: ;		d1 = number of queue slots required
                            	   540: 
                            	   541: gfxaccel_wait:
00:00002366 48E77000        	   542: 	movem.l d1/d2/d3,-(a7)
00:0000236A 2401            	   543: 	move.l d1,d2
00:0000236C 2601            	   544: 	move.l d1,d3
                            	   545: .0001:
00:0000236E 2239FD210004    	   546: 	move.l GFXACCEL+GFX_STATUS,d1
00:00002374 610074B6        	   547: 	bsr rbo
00:00002378 08010000        	   548: 	btst.l #0,d1			; first check busy bit
00:0000237C 66F0            	   549: 	bne.s .0001
00:0000237E 4841            	   550: 	swap d1
00:00002380 48C1            	   551: 	ext.l d1
00:00002382 2403            	   552: 	move.l d3,d2
00:00002384 D481            	   553: 	add.l d1,d2
00:00002386 0C82000007F8    	   554: 	cmpi.l #2040,d2
00:0000238C 62E0            	   555: 	bhi.s .0001
00:0000238E 4CDF000E        	   556: 	movem.l (a7)+,d1/d2/d3
00:00002392 4E75            	   557: 	rts
                            	   558: 

Source: "boot.x68"
                            	   614: 	include "audio.x68"

Source: "audio.x68"
                            	     1: ;===============================================================================
                            	     2: ;===============================================================================
                            	     3: ;	Registers
                            	     4: ;  00      -------- --ffffff ffffffff ffffffff     freq [21:0]
                            	     5: ;  04      -------- --pppppp pppppppp pppppppp     pulse width
                            	     6: ;	08	    R------- ----oooo trsg-ef- vvvvvv-- 	test, ringmod, sync, gate, filter, output, voice type
                            	     7: ;  0C      ---aaaaa aaaaaaaa aaaaaaaa aaaaaaaa     attack
                            	     8: ;  10      --dddddd dddddddd dddddddd dddddddd     decay
                            	     9: ;  14      -------- -------- -------- ssssssss     sustain / wave volume
                            	    10: ;  18      aaaaaaaa rrrrrrrr rrrrrrrr rrrrrrrr     release / wave table buffer length
                            	    11: ;  1C      aaaaaaaa aaaaaaaa aaaaaaaa aaa-----     wave table base address
                            	    12: ;											vvvvv
                            	    13: ;											wnpst
                            	    14: ;  20-3C   Voice #2
                            	    15: ;  40-5C   Voice #3
                            	    16: ;  60-7C   Voice #4
                            	    17: ;  80-9C   Voice #5
                            	    18: ;  A0-BC   Voice #6
                            	    19: ;  C0-DC   Voice #7
                            	    20: ;  E0-FC   Voice #8
                            	    21: ; 100-11C	Input
                            	    22: ;
                            	    23: ;	...
                            	    24: ;	120     -------- -------- -------- ----vvvv   volume (0-15)
                            	    25: ;	124     nnnnnnnn nnnnnnnn nnnnnnnn nnnnnnnn   osc3 oscillator 3
                            	    26: ;	128     -------- -------- -------- nnnnnnnn   env[3] envelope 3
                            	    27: ;  12C     -sss-sss -sss-sss -sss-sss -sss-sss   env state
                            	    28: ;  130     ----oooo -------- RRRRRRRR RRRRRRRR   filter sample rate clock divider, output
                            	    29: ;	134			-------- -------- -------i oooooooo		interrupt enable
                            	    30: ;	138			-------- -------- -------i oooooooo		interrupt occurred
                            	    31: ;	13C			-------- -------- -------i oooooooo		playback ended
                            	    32: ;	140			-------- -------- -------i oooooooo		channel sync
                            	    33: ;
                            	    34: ;  180-1F8   -------- -------- s---kkkk kkkkkkkk   filter coefficients
                            	    35: ;
                            	    36: 
                            	    37: PSG_FREQ equ $00
                            	    38: PSG_VOICE_TYPE equ $04
                            	    39: PSG_CTRL equ $05
                            	    40: PSG_OUTPUT_SEL equ $06
                            	    41: PSG_SUSTAIN equ $14
                            	    42: PSG_MASTER_VOLUME equ $120
                            	    43: 
                            	    44: AudioTestOn:
00:00002394 43F9FD240000    	    45: 	lea PSG,a1
00:0000239A 7407            	    46: 	moveq #7,d2													; eight output channels
00:0000239C 7600            	    47: 	moveq #0,d3
                            	    48: .0001
00:0000239E 223C000064AA    	    49: 	move.l #25770,d1
00:000023A4 61007486        	    50: 	bsr rbo
00:000023A8 23813000        	    51: 	move.l d1,PSG_FREQ(a1,d3.w)					; 600 Hz
00:000023AC 13BC00043004    	    52: 	move.b #4,PSG_VOICE_TYPE(a1,d3.w)		; triangle wave
00:000023B2 13BC00103005    	    53: 	move.b #16,PSG_CTRL(a1,d3.w)				; gate on, no envelope generator
00:000023B8 13BC000F3006    	    54: 	move.b #15,PSG_OUTPUT_SEL(a1,d3.w)	; output to all four output channels
00:000023BE 13BC00FF3014    	    55: 	move.b #255,PSG_SUSTAIN(a1,d3.w)		; max sustain level
00:000023C4 D67C0020        	    56: 	add.w #32,d3												; 32 bytes per channel
00:000023C8 51CAFFD4        	    57: 	dbra d2,.0001
00:000023CC 137C000C0120    	    58: 	move.b #12,PSG_MASTER_VOLUME(a1)		; volume 3/4 max
00:000023D2 13FC0003FD254000	    59: 	move.b #3,ADAU1761									; turn on audio interface
00:000023DA 4E75            	    60: 	rts
                            	    61: 
                            	    62: AudioTestOff:
00:000023DC 43F9FD240000    	    63: 	lea PSG,a1
00:000023E2 7407            	    64: 	moveq #7,d2													; eight output channels
00:000023E4 7600            	    65: 	moveq #0,d3
                            	    66: .0001
00:000023E6 42313006        	    67: 	move.b #0,PSG_OUTPUT_SEL(a1,d3.w)		; turn off output to all channels
00:000023EA D67C0020        	    68: 	add.w #32,d3												; 32 bytes per channel
00:000023EE 51CAFFF6        	    69: 	dbra d2,.0001
00:000023F2 42290120        	    70: 	move.b #0,PSG_MASTER_VOLUME(a1)
00:000023F6 4239FD254000    	    71: 	move.b #0,ADAU1761									; turn off audio interface
00:000023FC 4E75            	    72: 	rts
                            	    73: 

Source: "boot.x68"
                            	   615: 
                            	   616: ;------------------------------------------------------------------------------
                            	   617: ;------------------------------------------------------------------------------
                            	   618: ;------------------------------------------------------------------------------
                            	   619: 
                            	   620: GlobalReadLong:
00:000023FE 2210            	   621: 		move.l (a0),d1
00:00002400 4E75            	   622: 		rts
00:00002402 6004            	   623: 		bra nd1
                            	   624: GlobalWriteLong:
00:00002404 2081            	   625: 		move.l d1,(a0)
00:00002406 4E75            	   626: 		rts
                            	   627: net_delay:
                            	   628: 		bra nd1
                            	   629: nd1	bra nd2
                            	   630: nd2 bra nd3
                            	   631: nd3 bra nd4
00:00002408 4E71            	   632: nd4	nop
00:0000240A 4E75            	   633: 		rts
                            	   634: 	
                            	   635: 
                            	   636: ;------------------------------------------------------------------------------
                            	   637: ; The IO bitmap needs to be initialized to allow access to IO.
                            	   638: ;------------------------------------------------------------------------------
                            	   639: 
                            	   640: InitIOPBitmap:
00:0000240C 7600            	   641: 	moveq #0,d3				; d3 = asid value
00:0000240E 303C003F        	   642: 	move.w #63,d0			; 64 bitmaps to setup
00:00002412 4E7A8016        	   643: 	movec iops,a0			; a0 = IOP bitmap address
00:00002416 2248            	   644: 	movea.l a0,a1			; a1 = table address
                            	   645: .0004
00:00002418 4A03            	   646: 	tst.b d3
00:0000241A 57C1            	   647: 	seq d1						; set entire bitmap for asid 0, otherwise clear entire bitmap
00:0000241C 4881            	   648: 	ext.w	d1					; make into a long value
00:0000241E 48C1            	   649: 	ext.l d1
00:00002420 383C007F        	   650: 	move.w #127,d4
                            	   651: .0001
00:00002424 22C1            	   652: 	move.l d1,(a1)+		; set or clear entire table
00:00002426 51CCFFFC        	   653: 	dbra d4,.0001
00:0000242A 72FF            	   654: 	moveq #-1,d1
00:0000242C 214100A0        	   655: 	move.l d1,160(a0)	; all io address spaces have access to semaphores
00:00002430 214100A4        	   656: 	move.l d1,164(a0)
00:00002434 214100A8        	   657: 	move.l d1,168(a0)
00:00002438 214100AC        	   658: 	move.l d1,172(a0)
00:0000243C 214101FC        	   659: 	move.l d1,508(a0)	; all io address spaces access random # generator
00:00002440 4840            	   660: 	swap d0
00:00002442 303C001F        	   661: 	move.w #31,d0			; 32 long words for the screen area per bitmap
                            	   662: .0003
00:00002446 20C1            	   663: 	move.l d1,(a0)+		; all cores have access to a screen
00:00002448 51C8FFFC        	   664: 	dbra d0,.0003
00:0000244C 4840            	   665: 	swap d0
00:0000244E 5203            	   666: 	addi.b #1,d3			; do next address space
00:00002450 2049            	   667: 	movea.l a1,a0			; a0 points to area for next address space
00:00002452 51C8FFC4        	   668: 	dbra d0,.0004
00:00002456 4E75            	   669: 	rts	
                            	   670: 	
                            	   671: ;------------------------------------------------------------------------------
                            	   672: ; RandInit
                            	   673: ; 	Initialize random number generator.
                            	   674: ;
                            	   675: ; Modifies:
                            	   676: ;		none
                            	   677: ; Parameters:
                            	   678: ;		none
                            	   679: ;	Returns:
                            	   680: ;		none
                            	   681: ;------------------------------------------------------------------------------
                            	   682: 
                            	   683: InitRand:
                            	   684: RandInit:
00:00002458 23FC123456780004	   685: 	move.l #$12345678,m_z		; initialize to some value
00:00002460 08D0
00:00002462 23FC987654320004	   686: 	move.l #$98765432,m_w
00:0000246A 08D4
00:0000246C 23FC828354380004	   687: 	move.l #$82835438,next_m_z
00:00002474 08D8
00:00002476 23FC087237460004	   688: 	move.l #$08723746,next_m_w
00:0000247E 08DC
00:00002480 48E7C000        	   689: 	movem.l	d0/d1,-(a7)
00:00002484 7025            	   690: 	moveq #37,d0								; lock semaphore
00:00002486 7204            	   691: 	moveq	#RAND_SEMA,d1
00:00002488 4E4F            	   692: 	trap #15
00:0000248A 4E7A0FE0        	   693: 	movec coreno,d0							; d0 = core number
00:0000248E 5580            	   694: 	sub.l #2,d0									; make 0 to 9
00:00002490 ED88            	   695: 	lsl.l	#6,d0									; allow 64 streams per core
00:00002492 23C0FDFF4014    	   696: 	move.l d0,RAND_STRM					; select the stream
00:00002498 23FC12345678FDFF	   697: 	move.l #$12345678,RAND_MZ		; initialize to some value
00:000024A0 4018
00:000024A2 23FC98765432FDFF	   698: 	move.l #$98765432,RAND_MW
00:000024AA 401C
00:000024AC 23FC2E5BF271FDFF	   699: 	move.l #777777777,RAND_NUM	; generate first number
00:000024B4 4010
00:000024B6 7026            	   700: 	moveq #38,d0								; unlock semaphore
00:000024B8 7204            	   701: 	moveq	#RAND_SEMA,d1
00:000024BA 4E4F            	   702: 	trap #15
00:000024BC 4CDF0003        	   703: 	movem.l	(a7)+,d0/d1
00:000024C0 4E75            	   704: 	rts
                            	   705: 
                            	   706: ;------------------------------------------------------------------------------
                            	   707: ; Returns
                            	   708: ;		d1 = random integer
                            	   709: ;------------------------------------------------------------------------------
                            	   710: 
                            	   711: RandGetNum:
00:000024C2 48E7A000        	   712: 	movem.l	d0/d2,-(a7)
00:000024C6 7204            	   713: 	moveq #RAND_SEMA,d1
00:000024C8 6100013C        	   714: 	bsr T15LockSemaphore
00:000024CC 4E7A0FE0        	   715: 	movec	coreno,d0
00:000024D0 5580            	   716: 	sub.l #2,d0									; make 0 to 9
00:000024D2 ED88            	   717: 	lsl.l	#6,d0
00:000024D4 23C0FDFF4014    	   718: 	move.l d0,RAND_STRM					; select the stream
00:000024DA 2439FDFF4010    	   719: 	move.l RAND_NUM,d2					; d2 = random number
00:000024E0 23C2FDFF4010    	   720: 	move.l d2,RAND_NUM		 		  ; generate next number
00:000024E6 61000124        	   721: 	bsr T15UnlockSemaphore
00:000024EA 2202            	   722: 	move.l d2,d1
00:000024EC 4CDF0005        	   723: 	movem.l	(a7)+,d0/d2
00:000024F0 4E75            	   724: 	rts
                            	   725: 
                            	   726: prng:
00:000024F2 2F02            	   727: 	move.l d2,-(a7)
00:000024F4 2239000408D0    	   728: 	move.l m_z,d1
00:000024FA 2401            	   729: 	move.l d1,d2
00:000024FC C2FC1B39        	   730: 	mulu #6969,d1
00:00002500 4842            	   731: 	swap d2
00:00002502 48C2            	   732: 	ext.l d2
00:00002504 D481            	   733: 	add.l d1,d2
00:00002506 23C2000408D8    	   734: 	move.l d2,next_m_z
                            	   735: 
00:0000250C 2239000408D4    	   736: 	move.l m_w,d1
00:00002512 2401            	   737: 	move.l d1,d2
00:00002514 C2FC4650        	   738: 	mulu #18000,d1
00:00002518 4842            	   739: 	swap d2
00:0000251A 48C2            	   740: 	ext.l d2
00:0000251C D481            	   741: 	add.l d1,d2
00:0000251E 23C2000408DC    	   742: 	move.l d2,next_m_w
                            	   743: 	
00:00002524 2239000408D0    	   744: 	move.l m_z,d1
00:0000252A 4841            	   745: 	swap d1
00:0000252C 4241            	   746: 	clr.w d1
00:0000252E D2B9000408D4    	   747: 	add.l m_w,d1
00:00002534 23F9000408D80004	   748: 	move.l next_m_z,m_z
00:0000253C 08D0
00:0000253E 23F9000408DC0004	   749: 	move.l next_m_w,m_w
00:00002546 08D4
00:00002548 241F            	   750: 	move.l (a7)+,d2
00:0000254A 4E75            	   751: 	rts
                            	   752: 	
                            	   753: ;------------------------------------------------------------------------------
                            	   754: ; Modifies:
                            	   755: ;		none
                            	   756: ; Returns
                            	   757: ;		fp0 = random float between 0 and 1.
                            	   758: ;------------------------------------------------------------------------------
                            	   759: 
                            	   760: _GetRand:
00:0000254C 2F01            	   761: 	move.l d1,-(sp)
00:0000254E F2276880        	   762: 	fmove.x fp1,-(sp)
00:00002552 6100FF6E        	   763: 	bsr RandGetNum
00:00002556 E289            	   764: 	lsr.l #1,d1									; make number between 0 and 2^31
00:00002558 F2014000        	   765: 	fmove.l d1,fp0
00:0000255C F23C40807FFFFFFF	   766: 	fmove.l #$7FFFFFFF,fp1			; divide by 2^31
00:00002564 F2000420        	   767: 	fdiv fp1,fp0
00:00002568 F21F4880        	   768: 	fmove.x (sp)+,fp1
00:0000256C 221F            	   769: 	move.l (sp)+,d1
00:0000256E 4E75            	   770: 	rts
                            	   771: 
                            	   772: ;------------------------------------------------------------------------------
                            	   773: ; RandWait
                            	   774: ;    Wait some random number of clock cycles before returning.
                            	   775: ;------------------------------------------------------------------------------
                            	   776: 
                            	   777: RandWait:
00:00002570 48E7C000        	   778: 	movem.l	d0/d1,-(a7)
00:00002574 6100FF4C        	   779: 	bsr			RandGetNum
00:00002578 0241000F        	   780: 	andi.w	#15,d1
                            	   781: .0001:
00:0000257C 4E71            	   782: 	nop
00:0000257E 51C9FFFC        	   783: 	dbra		d1,.0001
00:00002582 4CDF0003        	   784: 	movem.l	(a7)+,d0/d1
00:00002586 4E75            	   785: 	rts
                            	   786: 
                            	   787: ;------------------------------------------------------------------------------
                            	   788: ; Initialize semaphores
                            	   789: ; - all semaphores are set to unlocked except the first one, which is locked
                            	   790: ; for core #2.
                            	   791: ;
                            	   792: ; Parameters:
                            	   793: ;		<none>
                            	   794: ; Modifies:
                            	   795: ;		<none>
                            	   796: ; Returns:
                            	   797: ;		<none>
                            	   798: ;------------------------------------------------------------------------------
                            	   799: 
                            	   800: InitSemaphores:
00:00002588 48E74080        	   801: 	movem.l	d1/a0,-(a7)
00:0000258C 41F9FD300000    	   802: 	lea			semamem,a0
00:00002592 217C000200002000	   803: 	move.l	#$20000,$2000(a0)	; lock the first semaphore for core #2, thread #0
00:0000259A 323C00FE        	   804: 	move.w	#254,d1
                            	   805: .0001:
00:0000259E 5888            	   806: 	lea			4(a0),a0
00:000025A0 42A82000        	   807: 	clr.l		$2000(a0)					; write zeros to unlock
00:000025A4 51C9FFF8        	   808: 	dbra		d1,.0001
00:000025A8 4CDF0102        	   809: 	movem.l	(a7)+,d1/a0
00:000025AC 4E75            	   810: 	rts
                            	   811: 
                            	   812: ; -----------------------------------------------------------------------------
                            	   813: ; Parameters:
                            	   814: ;		d1 semaphore number
                            	   815: ;
                            	   816: ; Side Effects:
                            	   817: ;		increments semaphore, saturates at 255
                            	   818: ;
                            	   819: ; Returns:	
                            	   820: ; 	z flag set if semaphore was zero
                            	   821: ; -----------------------------------------------------------------------------
                            	   822: 
                            	   823: ;IncrementSemaphore:
                            	   824: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   825: ;	lea			semamem,a0			; point to semaphore memory
                            	   826: ;	ext.w		d1							; make d1 word value
                            	   827: ;	asl.w		#4,d1						; align to memory
                            	   828: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   829: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   830: ;	rts
                            	   831: 	
                            	   832: ; -----------------------------------------------------------------------------
                            	   833: ; Parameters:
                            	   834: ;		d1 semaphore number
                            	   835: ;
                            	   836: ; Side Effects:
                            	   837: ;		decrements semaphore, saturates at zero
                            	   838: ;
                            	   839: ; Returns:	
                            	   840: ; 	z flag set if semaphore was zero
                            	   841: ; -----------------------------------------------------------------------------
                            	   842: 
                            	   843: ;DecrementSemaphore:
                            	   844: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   845: ;	lea			semamem,a0			; point to semaphore memory
                            	   846: ;	andi.w	#255,d1					; make d1 word value
                            	   847: ;	asl.w		#4,d1						; align to memory
                            	   848: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   849: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   850: ;	rts
                            	   851: 
                            	   852: ; -----------------------------------------------------------------------------
                            	   853: ; Lock a semaphore
                            	   854: ;
                            	   855: ; Parameters:
                            	   856: ;		d0 = key
                            	   857: ;		d1 = semaphore number
                            	   858: ; -----------------------------------------------------------------------------
                            	   859: 
                            	   860: LockSemaphore:
00:000025AE 4E75            	   861: 	rts
00:000025B0 48E74080        	   862: 	movem.l	d1/a0,-(a7)			; save registers
00:000025B4 41F9FD300000    	   863: 	lea			semamem,a0			; point to semaphore memory lock area
00:000025BA 024100FF        	   864: 	andi.w	#255,d1					; make d1 word value
00:000025BE E549            	   865: 	lsl.w		#2,d1						; align to memory
                            	   866: .0001
00:000025C0 21801000        	   867: 	move.l	d0,(a0,d1.w)		; try and write the semaphore
00:000025C4 B0B01000        	   868: 	cmp.l		(a0,d1.w),d0		; did it lock?
00:000025C8 66F6            	   869: 	bne.s		.0001						; no, try again
00:000025CA 4CDF0102        	   870: 	movem.l	(a7)+,a0/d1			; restore regs
00:000025CE 4E75            	   871: 	rts
                            	   872: 	
                            	   873: ; -----------------------------------------------------------------------------
                            	   874: ; Unlocks a semaphore even if not the owner.
                            	   875: ;
                            	   876: ; Parameters:
                            	   877: ;		d1 semaphore number
                            	   878: ; -----------------------------------------------------------------------------
                            	   879: 
                            	   880: ForceUnlockSemaphore:
00:000025D0 48E74080        	   881: 	movem.l	d1/a0,-(a7)				; save registers
00:000025D4 41F9FD303000    	   882: 	lea			semamem+$3000,a0	; point to semaphore memory read/write area
00:000025DA 024100FF        	   883: 	andi.w	#255,d1						; make d1 word value
00:000025DE E549            	   884: 	lsl.w		#2,d1							; align to memory
00:000025E0 42B01000        	   885: 	clr.l		(a0,d1.w)					; write zero to unlock
00:000025E4 4CDF0102        	   886: 	movem.l	(a7)+,a0/d1				; restore regs
00:000025E8 4E75            	   887: 	rts
                            	   888: 
                            	   889: ; -----------------------------------------------------------------------------
                            	   890: ; Unlocks a semaphore. Must be the owner to have effect.
                            	   891: ; Three cases:
                            	   892: ;	1) the owner, the semaphore will be reset to zero
                            	   893: ;	2) not the owner, the write will be ignored
                            	   894: ; 3) already unlocked, the write will be ignored
                            	   895: ;
                            	   896: ; Parameters:
                            	   897: ;		d0 = key
                            	   898: ;		d1 = semaphore number
                            	   899: ; -----------------------------------------------------------------------------
                            	   900: 
                            	   901: UnlockSemaphore:
00:000025EA 60E4            	   902: 	bra ForceUnlockSemaphore
00:000025EC 48E74080        	   903: 	movem.l	d1/a0,-(a7)				; save registers
00:000025F0 41F9FD301000    	   904: 	lea			semamem+$1000,a0	; point to semaphore memory unlock area
00:000025F6 024100FF        	   905: 	andi.w	#255,d1						; make d1 word value
00:000025FA E549            	   906: 	lsl.w		#2,d1							; align to memory
00:000025FC 21801000        	   907: 	move.l	d0,(a0,d1.w)			; write matching value to unlock
00:00002600 4CDF0102        	   908: 	movem.l	(a7)+,a0/d1				; restore regs
00:00002604 4E75            	   909: 	rts
                            	   910: 
                            	   911: ; -----------------------------------------------------------------------------
                            	   912: ; Parameters:
                            	   913: ;		d1 = semaphore to lock / unlock
                            	   914: ; -----------------------------------------------------------------------------
                            	   915: 
                            	   916: T15LockSemaphore:	
00:00002606 4E7A0012        	   917: 	movec tr,d0
00:0000260A 60A2            	   918: 	bra LockSemaphore
                            	   919: 
                            	   920: T15UnlockSemaphore:
00:0000260C 4E7A0012        	   921: 	movec tr,d0
00:00002610 60D8            	   922: 	bra UnlockSemaphore
                            	   923: 
                            	   924: ; Parameters:
                            	   925: ; 	a1 = pointer to input text
                            	   926: ; 	d1 = input stride (how many bytes to advance per character)
                            	   927: ; Returns:
                            	   928: ;		a1 = updated text pointer
                            	   929: ;		d1 = number of digits in number
                            	   930: ;		fp0 = float number
                            	   931: 
                            	   932: T15GetFloat:
00:00002612 48E78080        	   933: 	movem.l d0/a0,-(a7)
00:00002616 2049            	   934: 	move.l a1,a0
00:00002618 2001            	   935: 	move.l d1,d0
00:0000261A 61006E9C        	   936: 	bsr _GetFloat
00:0000261E 2248            	   937: 	move.l a0,a1
00:00002620 2200            	   938: 	move.l d0,d1
00:00002622 4CDF0101        	   939: 	movem.l (a7)+,d0/a0
00:00002626 4E75            	   940: 	rts
                            	   941: 
                            	   942: T15Abort:
00:00002628 61006F66        	   943: 	bsr DisplayByte
00:0000262C 43FA7B14        	   944: 	lea msgStackCanary,a1
00:00002630 610054F0        	   945: 	bsr DisplayStringCRLF
00:00002634 60005B26        	   946: 	bra Monitor
                            	   947: 
                            	   948: chk_exception:
00:00002638 222F0002        	   949: 	move.l 2(sp),d1
00:0000263C 61006F46        	   950: 	bsr DisplayTetra
00:00002640 43FA7AF2        	   951: 	lea msgChk,a1
00:00002644 610054DC        	   952: 	bsr DisplayStringCRLF
00:00002648 60005B12        	   953: 	bra Monitor
                            	   954: 
                            	   955: ; -----------------------------------------------------------------------------
                            	   956: ; Delay for a few seconds to allow some I/O reset operations to take place.
                            	   957: ; -----------------------------------------------------------------------------
                            	   958: 
                            	   959: Delay3s:
00:0000264C 203C002DC6C0    	   960: 	move.l	#3000000,d0		; this should take a few seconds to loop
00:00002652 41F9FDFFC000    	   961: 	lea			leds,a0				; a0 = address of LED output register
00:00002658 6002            	   962: 	bra			dly3s1				; branch to the loop
                            	   963: dly3s2:	
00:0000265A 4840            	   964: 	swap		d0						; loop is larger than 16-bits
                            	   965: dly3s1:
00:0000265C 2200            	   966: 	move.l	d0,d1					; the counter cycles fast, so use upper bits for display
00:0000265E E199            	   967: 	rol.l		#8,d1					; could use swap here, but lets test rol
00:00002660 E199            	   968: 	rol.l		#8,d1
00:00002662 1081            	   969: 	move.b	d1,(a0)				; set the LEDs
00:00002664 51C8FFF6        	   970: 	dbra		d0,dly3s1			; decrement and branch back
00:00002668 4840            	   971: 	swap		d0
00:0000266A 51C8FFEE        	   972: 	dbra		d0,dly3s2
00:0000266E 4E75            	   973: 	rts
                            	   974: 
                            	   975: Delay3s2:
00:00002670 4E7A0FE0        	   976: 	movec		coreno,d0			; vary delay by core to stagger startup
00:00002674 E188            	   977: 	lsl.l		#8,d0
00:00002676 0680002DC6C0    	   978: 	addi.l	#3000000,d0		; this should take a few seconds to loop
00:0000267C 6002            	   979: 	bra			.0001					; branch to the loop
                            	   980: .0002	
00:0000267E 4840            	   981: 	swap		d0						; loop is larger than 16-bits
                            	   982: .0001
00:00002680 51C8FFFE        	   983: 	dbra		d0,.0001			; decrement and branch back
00:00002684 4840            	   984: 	swap		d0
00:00002686 51C8FFF6        	   985: 	dbra		d0,.0002
00:0000268A 4E75            	   986: 	rts
                            	   987: 
                            	   988: 	include "cputest.x68"

Source: "cputest.x68"
                            	     1: ;; @name cputest.s Tests 68000 cpu
                            	     2: ;
                            	     3: ; Based on https://github.com/MicroCoreLabs/Projects/blob/master/MCL68/MC68000_Test_Code/MC68000_test_all_opcodes.X68
                            	     4: ;
                            	     5: ; Converted into a CD-i system ROM image by CD-i Fan:
                            	     6: ; - comment lines must start in first column
                            	     7: ; - replaced org instructions by suitable rept
                            	     8: ; - copy vectors to low memory at startup
                            	     9: ; - replaced jsr/jmp by bsr/bra for position independence
                            	    10: ; - replaced move.l by moveq whenever possible
                            	    11: ; - converted branches to short form whenever possible (e.g. beq => beq.s)
                            	    12: ; - added immediate suffix to opcodes where required (e.g. and => andi)
                            	    13: ; The last three modifications are required to make the test work;
                            	    14: ; apparently the original assembler was somewhat smarter then
                            	    15: ; the Microware OS-9 assembler and did this automatically.
                            	    16: ;
                            	    17: ; In some cases the opcodes of the test are used as test data!
                            	    18: ;
                            	    19: ; Original file header follows.
                            	    20: ;
                            	    21: ;  File Name   :  MCL68 Opcode Tests
                            	    22: ;  Used on     :
                            	    23: ;  Author      :  Ted Fried, MicroCore Labs
                            	    24: ;  Creation    :  7/14/2020
                            	    25: ;
                            	    26: ;   Description:
                            	    27: ;   ============
                            	    28: ;
                            	    29: ;  Program to test all of the Motorola 68000's opcodes.
                            	    30: ;
                            	    31: ;  If failures are detected, the code will immediately loop on itself.
                            	    32: ;  All addressing modes, data sizes, and opcode combinations are tested.
                            	    33: ;
                            	    34: ;  This code was developed using the Easy68K simulator where all tests passed!
                            	    35: ;
                            	    36: ;------------------------------------------------------------------------
                            	    37: ;
                            	    38: ; Modification History:
                            	    39: ; =====================
                            	    40: ;
                            	    41: ; Revision 1 7/14/2020
                            	    42: ; Initial revision
                            	    43: ;
                            	    44: ;
                            	    45: ;------------------------------------------------------------------------
                            	    46: ;
                            	    47: ; Copyright (c) 2020 Ted Fried
                            	    48: ;
                            	    49: ; Permission is hereby granted, free of charge, to any person obtaining a copy
                            	    50: ; of this software and associated documentation files (the "Software"), to deal
                            	    51: ; in the Software without restriction, including without limitation the rights
                            	    52: ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                            	    53: ; copies of the Software, and to permit persons to whom the Software is
                            	    54: ; furnished to do so, subject to the following conditions:
                            	    55: ;
                            	    56: ; The above copyright notice and this permission notice shall be included in all
                            	    57: ; copies or substantial portions of the Software.
                            	    58: ;
                            	    59: ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            	    60: ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            	    61: ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            	    62: ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            	    63: ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                            	    64: ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                            	    65: ; SOFTWARE.
                            	    66: 
                            	    67: ; Modified for rf68000 project (c) 2022 Robert Finch
                            	    68: 
                            	    69: ;	data
                            	    70: ;	dc.l		$0001FFFC						; top of local ram area
                            	    71: ;	dc.l		start
                            	    72: 
                            	    73: ;    org $1000												; code starts at $400 in local ram
                            	    74: *start:
                            	    75: ;	move.l	$FFFFFFE0,d0		; get core number
                            	    76: ;	cmpi.b	#2,d0
                            	    77: ;	bne			do_nothing
                            	    78: 
                            	    79: ;	lea			EXCEPTION_6,a0	; check exception vector
                            	    80: ;	move.l	a0,6*4
                            	    81: ;	lea			EXCEPTION_7,a0	; TRAPV exception vector
                            	    82: ;	move.l	a0,7*4
                            	    83: 
                            	    84: cpu_test:
00:0000268C 610000F6        	    85: 	bsr	op_ORI_TO_CCR
00:00002690 61000114        	    86: 	bsr	op_ORI_TO_SR
00:00002694 61000132        	    87: 	bsr	op_EORI_TO_CCR
00:00002698 61000154        	    88: 	bsr	op_EORI_TO_SR
00:0000269C 61000176        	    89: 	bsr	op_ANDI_TO_CCR
00:000026A0 61000198        	    90: 	bsr	op_ANDI_TO_SR
00:000026A4 610001BA        	    91: 	bsr	op_BTST
00:000026A8 61000560        	    92: 	bsr	op_BCHG
00:000026AC 610008C4        	    93: 	bsr	op_BCLR
00:000026B0 61000C0E        	    94: 	bsr	op_BSET
00:000026B4 61000F52        	    95: 	bsr op_MOVEP
00:000026B8 61000FDA        	    96: 	bsr op_BOOL_I
00:000026BC 610011BE        	    97: 	bsr op_CMP_I
00:000026C0 610013A2        	    98: 	bsr op_ADD_I
00:000026C4 61001524        	    99: 	bsr op_SUB_I
00:000026C8 610016A6        	   100: 	bsr op_MOVE
00:000026CC 610018AE        	   101: 	bsr op_MOVE_xxx_FLAGS
00:000026D0 61001A9E        	   102: 	bsr op_EXT
00:000026D4 61001AC6        	   103: 	bsr op_SWAP
00:000026D8 61001AD8        	   104: 	bsr op_LEAPEA
00:000026DC 61001B80        	   105: 	bsr op_TAS
00:000026E0 61001BA2        	   106: 	bsr op_TST
00:000026E4 61001BDC        	   107: 	bsr op_LINKS
00:000026E8 61001BF6        	   108: 	bsr op_MOVE_USP
00:000026EC 61001C02        	   109: 	bsr op_CHK
00:000026F0 61001C48        	   110: 	bsr op_NEGS
00:000026F4 61001FD2        	   111: 	bsr op_MOVEM
                            	   112: ;	bsr op_ABCD
                            	   113: ;	bsr op_SBCD
                            	   114: ;	bsr op_NBCD
00:000026F8 6100256E        	   115: 	bsr op_TRAPV
00:000026FC 61002586        	   116: 	bsr op_RTR
00:00002700 61001144        	   117: 	bsr op_BSR
00:00002704 610025A0        	   118: 	bsr op_BCC
00:00002708 6100261C        	   119: 	bsr op_DBCC
00:0000270C 6100263E        	   120: 	bsr op_SCC
00:00002710 6100266A        	   121: 	bsr op_ADDQ
00:00002714 61002720        	   122: 	bsr op_SUBQ
00:00002718 610027D6        	   123: 	bsr op_MOVEQ
                            	   124: ;	bsr op_DIVU
                            	   125: ;	bsr op_DIVS
00:0000271C 61002892        	   126: 	bsr op_OR
00:00002720 61002978        	   127: 	bsr op_AND
00:00002724 61002A5E        	   128: 	bsr op_EOR
00:00002728 61002AD0        	   129: 	bsr op_CMP
00:0000272C 61002B42        	   130: 	bsr op_CMPA
00:00002730 61002BA4        	   131: 	bsr op_CMPM
00:00002734 61002C46        	   132: 	bsr op_ADD
00:00002738 61002D2C        	   133: 	bsr op_SUB
00:0000273C 61002E12        	   134: 	bsr op_ADDA
00:00002740 61002E5A        	   135: 	bsr op_SUBA
00:00002744 61002EA2        	   136: 	bsr op_ADDX	
00:00002748 61002FAE        	   137: 	bsr op_SUBX
00:0000274C 610030BA        	   138: 	bsr op_MULU
00:00002750 61003102        	   139: 	bsr op_MULS
00:00002754 6100314A        	   140: 	bsr op_EXG
00:00002758 610031B4        	   141: 	bsr op_ROx
00:0000275C 610033E6        	   142: 	bsr op_ROXx
00:00002760 61003618        	   143: 	bsr op_SHIFTS
00:00002764 61003856        	   144: 	bsr op_SHIFTS2
                            	   145: 
00:00002768 4E75            	   146: 	rts
                            	   147: 	bra ALL_DONE
                            	   148: 
                            	   149: * Loop here when all tests pass
                            	   150: *
                            	   151: 
00:0000276A 60FE            	   152: ALL_DONE: bra.s ALL_DONE
                            	   153: 
00:0000276C 263C33333333    	   154: BSR_FAR1:       move.l #$33333333,d3
00:00002772 4E75            	   155:                 rts
                            	   156: 
                            	   157: ;	moveq		#-1,d0
                            	   158: ;	move.l	d0,$FD0FFF00
                            	   159: ;do_nothing:
                            	   160: ;	bra			*		
                            	   161: 
                            	   162: 
                            	   163: ;' Exception Vector = 6   CHK Instruction
                            	   164: ;
                            	   165: ;	align	4
                            	   166: EXCEPTION_6:
00:00002774 2C3CEEEE0006    	   167: 	move.l #$EEEE0006,d6      * Set d6 to the exception vector
00:0000277A 4E73            	   168: 	rte
                            	   169: 
                            	   170: ; Exception Vector = 7   TRAPV Instruction
                            	   171: ;
                            	   172: ;	align	4
                            	   173: EXCEPTION_7:
00:0000277C 203C12345678    	   174: 	move.l #$12345678,d0      * Set d6 to the exception vector
00:00002782 4E73            	   175: 	rte
                            	   176: 
                            	   177: ;-----------------------------------------------------------
                            	   178: ;-----------------------------------------------------------
                            	   179: ; OPCODE : ORI_TO_CCR
                            	   180: ;-----------------------------------------------------------
                            	   181: ;-----------------------------------------------------------
                            	   182: op_ORI_TO_CCR:
                            	   183: 
00:00002784 003C00FF        	   184:     ori.b #$FF,CCR
00:00002788 6AFE            	   185:     bpl.s *                   ; branch if Z clear
00:0000278A 66FE            	   186:     bne.s *                   ; branch if N clear
00:0000278C 68FE            	   187:     bvc.s *                   ; branch if V clear
00:0000278E 64FE            	   188:     bcc.s *                   ; branch if C clear
                            	   189: 
00:00002790 44FC0000        	   190:     move #$00,CCR
00:00002794 003C0000        	   191:     ori.b #$00,CCR
00:00002798 67FE            	   192:     beq.s *                   ; branch if Z set
00:0000279A 6BFE            	   193:     bmi.s *                   ; branch if N set
00:0000279C 69FE            	   194:     bvs.s *                   ; branch if V set
00:0000279E 65FE            	   195:     bcs.s *                   ; branch if C set
                            	   196: 
00:000027A0 46FC2700        	   197:     move.w #$2700,SR          ; Put flags back to initial value
                            	   198: 
00:000027A4 4E75            	   199:     rts
                            	   200: 
                            	   201: ;-----------------------------------------------------------
                            	   202: ;-----------------------------------------------------------
                            	   203: ; OPCODE : ORI_TO_SR
                            	   204: ;-----------------------------------------------------------
                            	   205: ;-----------------------------------------------------------
                            	   206: 
                            	   207: op_ORI_TO_SR:
                            	   208: 
00:000027A6 007C2FFF        	   209:     ori.w #$2FFF,SR
00:000027AA 6AFE            	   210:     bpl.s *                   * branch if Z clear
00:000027AC 66FE            	   211:     bne.s *                   * branch if N clear
00:000027AE 68FE            	   212:     bvc.s *                   * branch if V clear
00:000027B0 64FE            	   213:     bcc.s *                   * branch if C clear
                            	   214: 
00:000027B2 46FC2000        	   215:     move.w #$2000,SR
00:000027B6 007C0000        	   216:     ori.w #$0000,SR
00:000027BA 67FE            	   217:     beq.s *                   * branch if Z set
00:000027BC 6BFE            	   218:     bmi.s *                   * branch if N set
00:000027BE 69FE            	   219:     bvs.s *                   * branch if V set
00:000027C0 65FE            	   220:     bcs.s *                   * branch if C set
                            	   221: 
00:000027C2 46FC2700        	   222:     move.w #$2700,sr         * Put flags back to initial value
                            	   223: 
00:000027C6 4E75            	   224:     rts
                            	   225: ; 
                            	   226: ;-----------------------------------------------------------
                            	   227: ;-----------------------------------------------------------
                            	   228: ; OPCODE : EORI_TO_CCR
                            	   229: ;-----------------------------------------------------------
                            	   230: ;-----------------------------------------------------------
                            	   231: op_EORI_TO_CCR:
                            	   232: 
00:000027C8 44FC0000        	   233:     move #$00,CCR
00:000027CC 0A3C00FF        	   234:     eori.b #$FF,CCR
00:000027D0 6AFE            	   235:     bpl.s *                   ; branch if Z clear
00:000027D2 66FE            	   236:     bne.s *                   ; branch if N clear
00:000027D4 68FE            	   237:     bvc.s *                   ; branch if V clear
00:000027D6 64FE            	   238:     bcc.s *                   ; branch if C clear
                            	   239: 
00:000027D8 44FC0000        	   240:     move #$00,CCR
00:000027DC 0A3C0000        	   241:     eori.b #$00,CCR
00:000027E0 67FE            	   242:     beq.s *                   ; branch if Z set
00:000027E2 6BFE            	   243:     bmi.s *                   ; branch if N set
00:000027E4 69FE            	   244:     bvs.s *                   ; branch if V set
00:000027E6 65FE            	   245:     bcs.s *                   ; branch if C set
                            	   246: 
00:000027E8 46FC2700        	   247:     move.w #$2700,sr           ; Put flags back to initial value
                            	   248: 
00:000027EC 4E75            	   249:     rts
                            	   250: 
                            	   251: 
                            	   252: 
                            	   253: *-----------------------------------------------------------
                            	   254: *-----------------------------------------------------------
                            	   255: * OPCODE : EORI_TO_SR
                            	   256: *-----------------------------------------------------------
                            	   257: *-----------------------------------------------------------
                            	   258: op_EORI_TO_SR:
                            	   259: 
00:000027EE 46FC2000        	   260:     move.w #$2000,SR
00:000027F2 0A7C0FFF        	   261:     eori.w #$0FFF,SR
00:000027F6 6AFE            	   262:     bpl.s *                   * branch if Z clear
00:000027F8 66FE            	   263:     bne.s *                   * branch if N clear
00:000027FA 68FE            	   264:     bvc.s *                   * branch if V clear
00:000027FC 64FE            	   265:     bcc.s *                   * branch if C clear
                            	   266: 
00:000027FE 46FC2000        	   267:     move.w #$2000,SR
00:00002802 0A7C0000        	   268:     eori.w #$0000,SR
00:00002806 67FE            	   269:     beq.s *                   * branch if Z set
00:00002808 6BFE            	   270:     bmi.s *                   * branch if N set
00:0000280A 69FE            	   271:     bvs.s *                   * branch if V set
00:0000280C 65FE            	   272:     bcs.s *                   * branch if C set
                            	   273: 
00:0000280E 46FC2700        	   274:     move.w #$2700,sr          * Put flags back to initial value
                            	   275: 
00:00002812 4E75            	   276:     rts
                            	   277: 
                            	   278: 
                            	   279: 
                            	   280: *-----------------------------------------------------------
                            	   281: *-----------------------------------------------------------
                            	   282: * OPCODE : ANDI_TO_CCR
                            	   283: *-----------------------------------------------------------
                            	   284: *-----------------------------------------------------------
                            	   285: op_ANDI_TO_CCR:
                            	   286: 
00:00002814 44FC00FF        	   287:     move #$FF,CCR
00:00002818 023C00FF        	   288:     andi.b #$FF,CCR
00:0000281C 6AFE            	   289:     bpl.s *                   * branch if Z clear
00:0000281E 66FE            	   290:     bne.s *                   * branch if N clear
00:00002820 68FE            	   291:     bvc.s *                   * branch if V clear
00:00002822 64FE            	   292:     bcc.s *                   * branch if C clear
                            	   293: 
00:00002824 44FC00FF        	   294:     move #$FF,CCR
00:00002828 023C0000        	   295:     andi.b #$00,CCR
00:0000282C 67FE            	   296:     beq.s *                   * branch if Z set
00:0000282E 6BFE            	   297:     bmi.s *                   * branch if N set
00:00002830 69FE            	   298:     bvs.s *                   * branch if V set
00:00002832 65FE            	   299:     bcs.s *                   * branch if C set
                            	   300: 
00:00002834 46FC2700        	   301:     move #$2700,SR           * Put flags back to initial value
                            	   302: 
00:00002838 4E75            	   303:     rts
                            	   304: 
                            	   305: 
                            	   306: 
                            	   307: *-----------------------------------------------------------
                            	   308: *-----------------------------------------------------------
                            	   309: * OPCODE : ANDI_TO_SR
                            	   310: *-----------------------------------------------------------
                            	   311: *-----------------------------------------------------------
                            	   312: op_ANDI_TO_SR:
00:0000283A 46FC20FF        	   313:     move.w #$20FF,SR
00:0000283E 027CFFFF        	   314:     andi.w #$FFFF,SR
00:00002842 6AFE            	   315:     bpl.s *                   * branch if Z clear
00:00002844 66FE            	   316:     bne.s *                   * branch if N clear
00:00002846 68FE            	   317:     bvc.s *                   * branch if V clear
00:00002848 64FE            	   318:     bcc.s *                   * branch if C clear
                            	   319: 
00:0000284A 46FC20FF        	   320:     move.w #$20FF,SR
00:0000284E 027CFF00        	   321:     andi.w #$FF00,SR
00:00002852 67FE            	   322:     beq.s *                   * branch if Z set
00:00002854 6BFE            	   323:     bmi.s *                   * branch if N set
00:00002856 69FE            	   324:     bvs.s *                   * branch if V set
00:00002858 65FE            	   325:     bcs.s *                   * branch if C set
                            	   326: 
00:0000285A 46FC2700        	   327:     move.w #$2700,sr           * Put flags back to initial value
                            	   328: 
00:0000285E 4E75            	   329:     rts
                            	   330: 
                            	   331: 
                            	   332: *-----------------------------------------------------------
                            	   333: *-----------------------------------------------------------
                            	   334: * OPCODE : BTST
                            	   335: *-----------------------------------------------------------
                            	   336: *-----------------------------------------------------------
                            	   337: op_BTST:
                            	   338: 
                            	   339: *  Bit Number.s Static
                            	   340: 
                            	   341: *             EA = Dn  - LONG only
00:00002860 203C80000001    	   342:             move.l #$80000001,d0      * populate test data
00:00002866 08000000        	   343:             btst.l #0,d0
00:0000286A 67FE            	   344:             beq.s *               * branch if Z set
00:0000286C 08000001        	   345:             btst.l #1,d0              *
00:00002870 66FE            	   346:             bne.s *               * branch if Z clear
00:00002872 0800001F        	   347:             btst.l #31,d0             *
00:00002876 67FE            	   348:             beq.s *               * branch if Z set
                            	   349: 
                            	   350: 
                            	   351: *             EA = (An)  - BYTE only
00:00002878 307C0100        	   352:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000287C 10BC0081        	   353:             move.b #$81,(a0)          * populate test data
00:00002880 1210            	   354:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00002882 08100000        	   355:             btst.b #0,(a0)
00:00002886 67FE            	   356:             beq.s *               * branch if Z set
00:00002888 08100001        	   357:             btst.b #1,(a0)            *
00:0000288C 66FE            	   358:             bne.s *               * branch if Z clear
00:0000288E 08100007        	   359:             btst.b #7,(a0)            *
00:00002892 67FE            	   360:             beq.s *               * branch if Z set
                            	   361: 
                            	   362: 
                            	   363: *             EA = (An)+  - BYTE only
00:00002894 307C0100        	   364:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002898 10FC0001        	   365:             move.b #$01,(a0)+         * populate test data
00:0000289C 10FC00FC        	   366:             move.b #$FC,(a0)+         * populate test data
00:000028A0 10FC0080        	   367:             move.b #$80,(a0)+         * populate test data
00:000028A4 307C0100        	   368:             move.l #$00000100,a0      * point to memory to address 0x100
00:000028A8 08180000        	   369:             btst.b #0,(a0)+
00:000028AC 67FE            	   370:             beq.s *               * branch if Z set
00:000028AE 08180001        	   371:             btst.b #1,(a0)+           *
00:000028B2 66FE            	   372:             bne.s *               * branch if Z clear
00:000028B4 08180007        	   373:             btst.b #7,(a0)+           *
00:000028B8 67FE            	   374:             beq.s *               * branch if Z set
                            	   375: 
                            	   376: 
                            	   377: *             EA = -(An)  - BYTE only
00:000028BA 307C0100        	   378:             move.l #$00000100,a0      * point to memory to address
00:000028BE 10FC0080        	   379:             move.b #$80,(a0)+         * populate test data
00:000028C2 10FC00FC        	   380:             move.b #$FC,(a0)+         * populate test data
00:000028C6 10FC0001        	   381:             move.b #$01,(a0)+         * populate test data
00:000028CA 307C0103        	   382:             move.l #$00000103,a0      * point to memory to address
00:000028CE 08200000        	   383:             btst.b #0,-(a0)
00:000028D2 67FE            	   384:             beq.s *               * branch if Z set
00:000028D4 08200001        	   385:             btst.b #1,-(a0)           *
00:000028D8 66FE            	   386:             bne.s *               * branch if Z clear
00:000028DA 08200007        	   387:             btst.b #7,-(a0)           *
00:000028DE 67FE            	   388:             beq.s *               * branch if Z set
                            	   389: 
                            	   390: 
                            	   391: *             EA = n(An)  - BYTE only
00:000028E0 307C0100        	   392:             move.l #$00000100,a0      * point to memory to address
00:000028E4 10FC0001        	   393:             move.b #$01,(a0)+         * populate test data
00:000028E8 10FC00FC        	   394:             move.b #$FC,(a0)+         * populate test data
00:000028EC 10FC0080        	   395:             move.b #$80,(a0)+         * populate test data
00:000028F0 307C0100        	   396:             move.l #$00000100,a0      * point to memory to address
00:000028F4 08100000        	   397:             btst.b #0,0(a0)
00:000028F8 67FE            	   398:             beq.s *               * branch if Z set
00:000028FA 082800010001    	   399:             btst.b #1,1(a0)           *
00:00002900 66FE            	   400:             bne.s *               * branch if Z clear
00:00002902 082800070002    	   401:             btst.b #7,2(a0)           *
00:00002908 67FE            	   402:             beq.s *               * branch if Z set
                            	   403: 
                            	   404: 
                            	   405: *             EA = n(An,R.W)  - BYTE only
00:0000290A 307C0100        	   406:             move.l #$00000100,a0      * point to memory to address
00:0000290E 93C9            	   407:             move.l #$00000000,a1      * point to memory to address
00:00002910 347C0001        	   408:             move.l #$00000001,a2      * point to memory to address
00:00002914 7000            	   409:             moveq  #$00000000,d0      * point to memory to address
00:00002916 7201            	   410:             moveq  #$00000001,d1      * point to memory to address
00:00002918 083000000000    	   411:             btst.b #0,0(a0,d0.w)
00:0000291E 67FE            	   412:             beq.s *               * branch if Z set
00:00002920 083000011000    	   413:             btst.b #1,0(a0,d1.w)      *
00:00002926 66FE            	   414:             bne.s *               * branch if Z clear
00:00002928 083000071001    	   415:             btst.b #7,1(a0,d1.w)      *
00:0000292E 67FE            	   416:             beq.s *               * branch if Z set
                            	   417: *             EA = n(An,R.L)  - BYTE only
00:00002930 083000000800    	   418:             btst.b #0,0(a0,d0.l)
00:00002936 67FE            	   419:             beq.s *               * branch if Z set
00:00002938 083000011800    	   420:             btst.b #1,0(a0,d1.l)      *
00:0000293E 66FE            	   421:             bne.s *               * branch if Z clear
00:00002940 083000071801    	   422:             btst.b #7,1(a0,d1.l)      *
00:00002946 67FE            	   423:             beq.s *               * branch if Z set
                            	   424: *             EA = n(An,A.W)  - BYTE only
00:00002948 083000009000    	   425:             btst.b #0,0(a0,a1.w)
00:0000294E 67FE            	   426:             beq.s *               * branch if Z set
00:00002950 08300001A000    	   427:             btst.b #1,0(a0,a2.w)      *
00:00002956 66FE            	   428:             bne.s *               * branch if Z clear
00:00002958 08300007A001    	   429:             btst.b #7,1(a0,a2.w)      *
00:0000295E 67FE            	   430:             beq.s *               * branch if Z set
                            	   431: *             EA = n(An,A.L)  - BYTE only
00:00002960 083000009800    	   432:             btst.b #0,0(a0,a1.l)
00:00002966 67FE            	   433:             beq.s *               * branch if Z set
00:00002968 08300001A800    	   434:             btst.b #1,0(a0,a2.l)      *
00:0000296E 66FE            	   435:             bne.s *               * branch if Z clear
00:00002970 08300007A801    	   436:             btst.b #7,1(a0,a2.l)      *
00:00002976 67FE            	   437:             beq.s *               * branch if Z set
                            	   438: 
                            	   439: 
                            	   440: *             EA = x.W  - BYTE only
00:00002978 083800000100    	   441:             btst.b #0,$0100
00:0000297E 67FE            	   442:             beq.s *               * branch if Z set
00:00002980 083800010101    	   443:             btst.b #1,$0101           *
00:00002986 66FE            	   444:             bne.s *               * branch if Z clear
00:00002988 083800070102    	   445:             btst.b #7,$0102           *
00:0000298E 67FE            	   446:             beq.s *               * branch if Z set
                            	   447: 
                            	   448: 
                            	   449: *             EA = x.L  - BYTE only
00:00002990 207C0000F100    	   450:             move.l #$F100,a0      * point to memory to address 0x100
00:00002996 10FC0001        	   451:             move.b #$01,(a0)+         * populate test data
00:0000299A 10FC00FC        	   452:             move.b #$FC,(a0)+         * populate test data
00:0000299E 10FC0080        	   453:             move.b #$80,(a0)+         * populate test data
00:000029A2 083900000000F100	   454:             btst.b #0,$F100
00:000029AA 67FE            	   455:             beq.s *               * branch if Z set
00:000029AC 083900010000F101	   456:             btst.b #1,$F101       *
00:000029B4 66FE            	   457:             bne.s *               * branch if Z clear
00:000029B6 083900070000F102	   458:             btst.b #7,$F102       *
00:000029BE 67FE            	   459:             beq.s *               * branch if Z set
                            	   460: 
                            	   461: 
                            	   462: *             EA = x(PC)  - BYTE only
00:000029C0 4BFAFE9E        	   463:             lea op_BTST(pc),a5
00:000029C4 083A0000FE98    	   464:             btst.b #0,op_BTST(pc)
00:000029CA 66FE            	   465:             bne.s *               * branch if Z clear
00:000029CC 083A0003001A    	   466:             btst.b #3,op_BTST0(pc)     *
00:000029D2 67FE            	   467:             beq.s *               * branch if Z set
00:000029D4 083A00060074    	   468:             btst.b #6,op_BTST12(pc)    *
00:000029DA 67FE            	   469:             beq.s *               * branch if Z set
                            	   470: 
                            	   471: 
                            	   472: *             EA = n(PC,R.W)  - BYTE only
00:000029DC 307C0100        	   473:             move.l #$00000100,a0      * point to memory to address
00:000029E0 93C9            	   474:             move.l #$00000000,a1      * point to memory to address
00:000029E2 347C0001        	   475:             move.l #$00000001,a2      * point to memory to address
00:000029E6 7000            	   476:             moveq  #$00000000,d0      * point to memory to address
00:000029E8 7201            	   477:             moveq  #$00000001,d1      * point to memory to address
                            	   478: 
00:000029EA 083B000000FC    	   479: op_BTST0:   btst.b #0,op_BTST0(pc,d0.w)
00:000029F0 66FE            	   480:             bne.s *               * branch if Z clear
                            	   481: 
00:000029F2 4BFB1002        	   482:             lea op_BTST1(pc,d1.w),a5
00:000029F6 083B000110FC    	   483: op_BTST1:   btst.b #1,op_BTST1(pc,d1.w)      *
00:000029FC 67FE            	   484:             beq.s *               * branch if Z set
00:000029FE 083B000710FC    	   485: op_BTST2:   btst.b #7,op_BTST2(pc,d1.w)      *
00:00002A04 66FE            	   486:             bne.s *               * branch if Z clear
                            	   487: *             EA = n(PC,R.L)  - BYTE only
00:00002A06 083B000008FC    	   488: op_BTST3:   btst.b #0,op_BTST3(pc,d0.l)
00:00002A0C 66FE            	   489:             bne.s *               * branch if Z clear
00:00002A0E 083B000118FC    	   490: op_BTST4:   btst.b #1,op_BTST4(pc,d1.l)      *
00:00002A14 67FE            	   491:             beq.s *               * branch if Z set
00:00002A16 083B000718FC    	   492: op_BTST5:   btst.b #7,op_BTST5(pc,d1.l)      *
00:00002A1C 66FE            	   493:             bne.s *               * branch if Z clear
                            	   494: *             EA = n(PC,A.W)  - BYTE only
00:00002A1E 083B000090FC    	   495: op_BTST6    btst.b #0,op_BTST6(pc,a1.w)
00:00002A24 66FE            	   496:             bne.s *               * branch if Z clear
00:00002A26 083B0001A0FC    	   497: op_BTST7:   btst.b #1,op_BTST7(pc,a2.w)      *
00:00002A2C 67FE            	   498:             beq.s *               * branch if Z set
00:00002A2E 083B0007A0FC    	   499: op_BTST8:   btst.b #7,op_BTST8(pc,a2.w)      *
00:00002A34 66FE            	   500:             bne.s *               * branch if Z clear
                            	   501: *             EA = n(PC,A.L)  - BYTE only
00:00002A36 083B000098FC    	   502: op_BTST9:   btst.b #0,op_BTST9(pc,a1.l)
00:00002A3C 66FE            	   503:             bne.s *               * branch if Z clear
00:00002A3E 083B0001A8FC    	   504: op_BTST10:  btst.b #1,op_BTST10(pc,a2.l)      *
00:00002A44 67FE            	   505:             beq.s *               * branch if Z set
00:00002A46 083B0007A8FC    	   506: op_BTST11:  btst.b #7,op_BTST11(pc,a2.l)      *
00:00002A4C 66FE            	   507: op_BTST12:  bne.s *               * branch if Z clear
                            	   508: 
                            	   509: 
                            	   510: 
                            	   511: * Bit Number.s Dynamic
                            	   512: 
                            	   513: *             EA = Dn  - LONG only
00:00002A4E 203C80000001    	   514:             move.l #$80000001,d0      * populate test data
00:00002A54 7A00            	   515:             move.l #0,d5              * populate bit.s number to test
00:00002A56 7C01            	   516:             move.l #1,d6              * populate bit.s number to test
00:00002A58 7E1F            	   517:             move.l #31,d7              * populate bit.s number to test
                            	   518: 
00:00002A5A 0B00            	   519:             btst.l d5,d0
00:00002A5C 67FE            	   520:             beq.s *               * branch if Z set
00:00002A5E 0D00            	   521:             btst.l d6,d0              *
00:00002A60 66FE            	   522:             bne.s *               * branch if Z clear
00:00002A62 0F00            	   523:             btst.l d7,d0             *
00:00002A64 67FE            	   524:             beq.s *               * branch if Z set
                            	   525: 
                            	   526: 
                            	   527: *             EA = (An)  - BYTE only
00:00002A66 7A00            	   528:             move.l #0,d5              * populate bit.s number to test
00:00002A68 7C01            	   529:             move.l #1,d6              * populate bit.s number to test
00:00002A6A 7E07            	   530:             move.l #7,d7              * populate bit.s number to test
00:00002A6C 307C0100        	   531:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002A70 10BC0081        	   532:             move.b #$81,(a0)          * populate test data
00:00002A74 1210            	   533:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00002A76 0B10            	   534:             btst.b d5,(a0)
00:00002A78 67FE            	   535:             beq.s *               * branch if Z set
00:00002A7A 0D10            	   536:             btst.b d6,(a0)            *
00:00002A7C 66FE            	   537:             bne.s *               * branch if Z clear
00:00002A7E 0F10            	   538:             btst.b d7,(a0)            *
00:00002A80 67FE            	   539:             beq.s *               * branch if Z set
                            	   540: 
                            	   541: * ---
                            	   542: 
                            	   543: 
                            	   544: *             EA = (An)+  - BYTE only
00:00002A82 307C0100        	   545:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002A86 10FC0001        	   546:             move.b #$01,(a0)+         * populate test data
00:00002A8A 10FC00FC        	   547:             move.b #$FC,(a0)+         * populate test data
00:00002A8E 10FC0080        	   548:             move.b #$80,(a0)+         * populate test data
00:00002A92 307C0100        	   549:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002A96 0B18            	   550:             btst.b d5,(a0)+
00:00002A98 67FE            	   551:             beq.s *               * branch if Z set
00:00002A9A 0D18            	   552:             btst.b d6,(a0)+           *
00:00002A9C 66FE            	   553:             bne.s *               * branch if Z clear
00:00002A9E 0F18            	   554:             btst.b d7,(a0)+           *
00:00002AA0 67FE            	   555:             beq.s *               * branch if Z set
                            	   556: 
                            	   557: 
                            	   558: *             EA = -(An)  - BYTE only
00:00002AA2 307C0100        	   559:             move.l #$00000100,a0      * point to memory to address
00:00002AA6 10FC0080        	   560:             move.b #$80,(a0)+         * populate test data
00:00002AAA 10FC00FC        	   561:             move.b #$FC,(a0)+         * populate test data
00:00002AAE 10FC0001        	   562:             move.b #$01,(a0)+         * populate test data
00:00002AB2 307C0103        	   563:             move.l #$00000103,a0      * point to memory to address
00:00002AB6 0B20            	   564:             btst.b d5,-(a0)
00:00002AB8 67FE            	   565:             beq.s *               * branch if Z set
00:00002ABA 0D20            	   566:             btst.b d6,-(a0)           *
00:00002ABC 66FE            	   567:             bne.s *               * branch if Z clear
00:00002ABE 0F20            	   568:             btst.b d7,-(a0)           *
00:00002AC0 67FE            	   569:             beq.s *               * branch if Z set
                            	   570: 
                            	   571: 
                            	   572: *             EA = n(An)  - BYTE only
00:00002AC2 307C0100        	   573:             move.l #$00000100,a0      * point to memory to address
00:00002AC6 10FC0001        	   574:             move.b #$01,(a0)+         * populate test data
00:00002ACA 10FC00FC        	   575:             move.b #$FC,(a0)+         * populate test data
00:00002ACE 10FC0080        	   576:             move.b #$80,(a0)+         * populate test data
00:00002AD2 307C0100        	   577:             move.l #$00000100,a0      * point to memory to address
00:00002AD6 0B10            	   578:             btst.b d5,0(a0)
00:00002AD8 67FE            	   579:             beq.s *               * branch if Z set
00:00002ADA 0D280001        	   580:             btst.b d6,1(a0)           *
00:00002ADE 66FE            	   581:             bne.s *               * branch if Z clear
00:00002AE0 0F280002        	   582:             btst.b d7,2(a0)           *
00:00002AE4 67FE            	   583:             beq.s *               * branch if Z set
                            	   584: 
                            	   585: 
                            	   586: *             EA = n(An,R.W)  - BYTE only
00:00002AE6 307C0100        	   587:             move.l #$00000100,a0      * point to memory to address
00:00002AEA 93C9            	   588:             move.l #$00000000,a1      * point to memory to address
00:00002AEC 347C0001        	   589:             move.l #$00000001,a2      * point to memory to address
00:00002AF0 7000            	   590:             moveq  #$00000000,d0      * point to memory to address
00:00002AF2 7201            	   591:             moveq  #$00000001,d1      * point to memory to address
00:00002AF4 0B300000        	   592:             btst.b d5,0(a0,d0.w)
00:00002AF8 67FE            	   593:             beq.s *               * branch if Z set
00:00002AFA 0D301000        	   594:             btst.b d6,0(a0,d1.w)      *
00:00002AFE 66FE            	   595:             bne.s *               * branch if Z clear
00:00002B00 0F301001        	   596:             btst.b d7,1(a0,d1.w)      *
00:00002B04 67FE            	   597:             beq.s *               * branch if Z set
                            	   598: *             EA = n(An,R.L)  - BYTE only
00:00002B06 0B300800        	   599:             btst.b d5,0(a0,d0.l)
00:00002B0A 67FE            	   600:             beq.s *               * branch if Z set
00:00002B0C 0D301800        	   601:             btst.b d6,0(a0,d1.l)      *
00:00002B10 66FE            	   602:             bne.s *               * branch if Z clear
00:00002B12 0F301801        	   603:             btst.b d7,1(a0,d1.l)      *
00:00002B16 67FE            	   604:             beq.s *               * branch if Z set
                            	   605: *             EA = n(An,A.W)  - BYTE only
00:00002B18 0B309000        	   606:             btst.b d5,0(a0,a1.w)
00:00002B1C 67FE            	   607:             beq.s *               * branch if Z set
00:00002B1E 0D30A000        	   608:             btst.b d6,0(a0,a2.w)      *
00:00002B22 66FE            	   609:             bne.s *               * branch if Z clear
00:00002B24 0F30A001        	   610:             btst.b d7,1(a0,a2.w)      *
00:00002B28 67FE            	   611:             beq.s *               * branch if Z set
                            	   612: *             EA = n(An,A.L)  - BYTE only
00:00002B2A 0B309800        	   613:             btst.b d5,0(a0,a1.l)
00:00002B2E 67FE            	   614:             beq.s *               * branch if Z set
00:00002B30 0D30A800        	   615:             btst.b d6,0(a0,a2.l)      *
00:00002B34 66FE            	   616:             bne.s *               * branch if Z clear
00:00002B36 0F30A801        	   617:             btst.b d7,1(a0,a2.l)      *
00:00002B3A 67FE            	   618:             beq.s *               * branch if Z set
                            	   619: 
                            	   620: 
                            	   621: *             EA = x.W  - BYTE only
00:00002B3C 0B380100        	   622:             btst.b d5,$0100
00:00002B40 67FE            	   623:             beq.s *               * branch if Z set
00:00002B42 0D380101        	   624:             btst.b d6,$0101           *
00:00002B46 66FE            	   625:             bne.s *               * branch if Z clear
00:00002B48 0F380102        	   626:             btst.b d7,$0102           *
00:00002B4C 67FE            	   627:             beq.s *               * branch if Z set
                            	   628: 
                            	   629: 
                            	   630: *             EA = x.L  - BYTE only
00:00002B4E 207C0000F100    	   631:             move.l #$F100,a0      * point to memory to address 0x100
00:00002B54 10FC0001        	   632:             move.b #$01,(a0)+         * populate test data
00:00002B58 10FC00FC        	   633:             move.b #$FC,(a0)+         * populate test data
00:00002B5C 10FC0080        	   634:             move.b #$80,(a0)+         * populate test data
00:00002B60 0B390000F100    	   635:             btst.b d5,$F100
00:00002B66 67FE            	   636:             beq.s *               * branch if Z set
00:00002B68 0D390000F101    	   637:             btst.b d6,$F101       *
00:00002B6E 66FE            	   638:             bne.s *               * branch if Z clear
00:00002B70 0F390000F102    	   639:             btst.b d7,$F102       *
00:00002B76 67FE            	   640:             beq.s *               * branch if Z set
                            	   641: 
                            	   642: 
                            	   643: *             EA = x(PC)  - BYTE only
00:00002B78 7C03            	   644:             move.l #3,d6              * populate bit.s number to test
00:00002B7A 7E06            	   645:             move.l #6,d7              * populate bit.s number to test
00:00002B7C 4BFAFCE2        	   646:             lea op_BTST(pc),a5
00:00002B80 0B3AFCDE        	   647:             btst.b d5,op_BTST(pc)
00:00002B84 66FE            	   648:             bne.s *               * branch if Z clear
00:00002B86 0D3AFE62        	   649:             btst.b d6,op_BTST0(pc)     *
00:00002B8A 67FE            	   650:             beq.s *               * branch if Z set
00:00002B8C 0F3AFEBE        	   651:             btst.b d7,op_BTST12(pc)    *
00:00002B90 67FE            	   652:             beq.s *               * branch if Z set
                            	   653: 
                            	   654: 
                            	   655: *             EA = n(PC,R.W)  - BYTE only
00:00002B92 307C0100        	   656:             move.l #$00000100,a0      * point to memory to address
00:00002B96 93C9            	   657:             move.l #$00000000,a1      * point to memory to address
00:00002B98 347C0001        	   658:             move.l #$00000001,a2      * point to memory to address
00:00002B9C 7000            	   659:             moveq  #$00000000,d0      * point to memory to address
00:00002B9E 7201            	   660:             moveq  #$00000001,d1      * point to memory to address
00:00002BA0 7C01            	   661:             move.l #1,d6              * populate bit.s number to test
00:00002BA2 7E07            	   662:             move.l #7,d7              * populate bit.s number to test
                            	   663: 
00:00002BA4 0B3B00FE        	   664: op_BTST20:  btst.b d5,op_BTST20(pc,d0.w)
00:00002BA8 67FE            	   665:             beq.s *               * branch if Z set
00:00002BAA 4BFB1002        	   666:             lea op_BTST21(pc,d1.w),a5
00:00002BAE 0D3B10FE        	   667: op_BTST21:  btst.b d6,op_BTST21(pc,d1.w)      *
00:00002BB2 67FE            	   668:             beq.s *               * branch if Z set
00:00002BB4 0F3B10FE        	   669: op_BTST22:  btst.b d7,op_BTST22(pc,d1.w)      *
00:00002BB8 66FE            	   670:             bne.s *               * branch if Z clear
                            	   671: *             EA = n(PC,R.L)  - BYTE only
00:00002BBA 0B3B08FE        	   672: op_BTST23:  btst.b d5,op_BTST23(pc,d0.l)
00:00002BBE 67FE            	   673:             beq.s *               * branch if Z set
00:00002BC0 0D3B18FE        	   674: op_BTST24: btst.b d6,op_BTST24(pc,d1.l)      *
00:00002BC4 67FE            	   675:             beq.s *               * branch if Z set
00:00002BC6 0F3B18FE        	   676: op_BTST25  btst.b d7,op_BTST25(pc,d1.l)      *
00:00002BCA 66FE            	   677:             bne.s *               * branch if Z clear
                            	   678: *             EA = n(PC,A.W)  - BYTE only
00:00002BCC 0B3B90FE        	   679: op_BTST26   btst.b d5,op_BTST26(pc,a1.w)
00:00002BD0 67FE            	   680:             beq.s *               * branch if Z set
00:00002BD2 0D3BA0FE        	   681: op_BTST27:  btst.b d6,op_BTST27(pc,a2.w)      *
00:00002BD6 67FE            	   682:             beq.s *               * branch if Z set
00:00002BD8 0F3BA0FE        	   683: op_BTST28:  btst.b d7,op_BTST28(pc,a2.w)      *
00:00002BDC 66FE            	   684:             bne.s *               * branch if Z clear
                            	   685: *             EA = n(PC,A.L)  - BYTE only
00:00002BDE 0B3B98FE        	   686: op_BTST29:  btst.b d5,op_BTST29(pc,a1.l)
00:00002BE2 67FE            	   687:             beq.s *               * branch if Z set
00:00002BE4 0D3BA8FE        	   688: op_BTST30:  btst.b d6,op_BTST30(pc,a2.l)      *
00:00002BE8 67FE            	   689:             beq.s *               * branch if Z set
00:00002BEA 0F3BA8FE        	   690: op_BTST31:  btst.b d7,op_BTST31(pc,a2.l)      *
00:00002BEE 66FE            	   691: op_BTST32:  bne.s *               * branch if Z clear
                            	   692: 
                            	   693: *             EA = #x  - BYTE only
                            	   694: 
00:00002BF0 7A00            	   695:             move.l #0,d5              * populate bit.s number to test
00:00002BF2 7C03            	   696:             move.l #3,d6              * populate bit.s number to test
00:00002BF4 7E07            	   697:             move.l #7,d7              * populate bit.s number to test
                            	   698: 
00:00002BF6 0B3C0088        	   699:             btst.b d5,#$88
00:00002BFA 66FE            	   700:             bne.s *               * branch if Z clear
00:00002BFC 0D3C0088        	   701:             btst.b d6,#$88
00:00002C00 67FE            	   702:             beq.s *               * branch if Z set
00:00002C02 0F3C0088        	   703:             btst.b d7,#$88
00:00002C06 67FE            	   704:             beq.s *               * branch if Z set
                            	   705: 
                            	   706: 
00:00002C08 4E75            	   707:     rts
                            	   708: 
                            	   709: *-----------------------------------------------------------
                            	   710: *-----------------------------------------------------------
                            	   711: * OPCODE : BCHG
                            	   712: *-----------------------------------------------------------
                            	   713: *-----------------------------------------------------------
                            	   714: op_BCHG:
                            	   715: 
                            	   716: 
                            	   717: *  Bit Number.s Static
                            	   718: 
                            	   719: *             EA = Dn  - LONG only
00:00002C0A 203C80000001    	   720:             move.l #$80000001,d0      * populate test data
00:00002C10 08400000        	   721:             bchg.l #0,d0
00:00002C14 67FE            	   722:             beq.s *               * branch if Z set
00:00002C16 08400001        	   723:             bchg.l #1,d0              *
00:00002C1A 66FE            	   724:             bne.s *               * branch if Z clear
00:00002C1C 0840001F        	   725:             bchg.l #31,d0             *
00:00002C20 67FE            	   726:             beq.s *               * branch if Z set
00:00002C22 0C8000000002    	   727:             cmpi.l #$00000002,d0
00:00002C28 66FE            	   728:             bne.s *               * branch if Z clear
                            	   729: 
                            	   730: 
                            	   731: *             EA = (An)  - BYTE only
00:00002C2A 307C0100        	   732:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002C2E 10BC0081        	   733:             move.b #$81,(a0)          * populate test data
00:00002C32 1210            	   734:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00002C34 08500000        	   735:             bchg.b #0,(a0)
00:00002C38 67FE            	   736:             beq.s *               * branch if Z set
00:00002C3A 08500001        	   737:             bchg.b #1,(a0)            *
00:00002C3E 66FE            	   738:             bne.s *               * branch if Z clear
00:00002C40 08500007        	   739:             bchg.b #7,(a0)            *
00:00002C44 67FE            	   740:             beq.s *               * branch if Z set
00:00002C46 0C100002        	   741:             cmpi.b #$02,(a0)
00:00002C4A 66FE            	   742:             bne.s *               * branch if Z clear
                            	   743: 
                            	   744: *             EA = (An)+  - BYTE only
00:00002C4C 307C0100        	   745:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002C50 10FC0001        	   746:             move.b #$01,(a0)+         * populate test data
00:00002C54 10FC00FC        	   747:             move.b #$FC,(a0)+         * populate test data
00:00002C58 10FC0080        	   748:             move.b #$80,(a0)+         * populate test data
00:00002C5C 307C0100        	   749:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002C60 08580000        	   750:             bchg.b #0,(a0)+
00:00002C64 67FE            	   751:             beq.s *               * branch if Z set
00:00002C66 08580001        	   752:             bchg.b #1,(a0)+           *
00:00002C6A 66FE            	   753:             bne.s *               * branch if Z clear
00:00002C6C 08580007        	   754:             bchg.b #7,(a0)+           *
00:00002C70 67FE            	   755:             beq.s *               * branch if Z set
00:00002C72 307C0100        	   756:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002C76 4A18            	   757:             cmpi.b #$00,(a0)+
00:00002C78 66FE            	   758:             bne.s *               * branch if Z clear
00:00002C7A 0C1800FE        	   759:             cmpi.b #$FE,(a0)+
00:00002C7E 66FE            	   760:             bne.s *               * branch if Z clear
00:00002C80 4A18            	   761:             cmpi.b #$00,(a0)+
00:00002C82 66FE            	   762:             bne.s *               * branch if Z clear
                            	   763: 
                            	   764: *             EA = -(An)  - BYTE only
00:00002C84 307C0100        	   765:             move.l #$00000100,a0      * point to memory to address
00:00002C88 10FC0080        	   766:             move.b #$80,(a0)+         * populate test data
00:00002C8C 10FC00FC        	   767:             move.b #$FC,(a0)+         * populate test data
00:00002C90 10FC0001        	   768:             move.b #$01,(a0)+         * populate test data
00:00002C94 307C0103        	   769:             move.l #$00000103,a0      * point to memory to address
00:00002C98 08600000        	   770:             bchg.b #0,-(a0)
00:00002C9C 67FE            	   771:             beq.s *               * branch if Z set
00:00002C9E 08600001        	   772:             bchg.b #1,-(a0)           *
00:00002CA2 66FE            	   773:             bne.s *               * branch if Z clear
00:00002CA4 08600007        	   774:             bchg.b #7,-(a0)           *
00:00002CA8 67FE            	   775:             beq.s *               * branch if Z set
00:00002CAA 307C0103        	   776:             move.l #$00000103,a0      * point to memory to address 0x100
00:00002CAE 4A20            	   777:             cmpi.b #$00,-(a0)
00:00002CB0 66FE            	   778:             bne.s *               * branch if Z clear
00:00002CB2 0C2000FE        	   779:             cmpi.b #$FE,-(a0)
00:00002CB6 66FE            	   780:             bne.s *               * branch if Z clear
00:00002CB8 4A20            	   781:             cmpi.b #$00,-(a0)
00:00002CBA 66FE            	   782:             bne.s *               * branch if Z clear
                            	   783: 
                            	   784: 
                            	   785: *             EA = n(An)  - BYTE only
00:00002CBC 307C0100        	   786:             move.l #$00000100,a0      * point to memory to address
00:00002CC0 10FC0001        	   787:             move.b #$01,(a0)+         * populate test data
00:00002CC4 10FC00FC        	   788:             move.b #$FC,(a0)+         * populate test data
00:00002CC8 10FC0080        	   789:             move.b #$80,(a0)+         * populate test data
00:00002CCC 307C0100        	   790:             move.l #$00000100,a0      * point to memory to address
00:00002CD0 08500000        	   791:             bchg.b #0,0(a0)
00:00002CD4 67FE            	   792:             beq.s *               * branch if Z set
00:00002CD6 086800010001    	   793:             bchg.b #1,1(a0)           *
00:00002CDC 66FE            	   794:             bne.s *               * branch if Z clear
00:00002CDE 086800070002    	   795:             bchg.b #7,2(a0)           *
00:00002CE4 67FE            	   796:             beq.s *               * branch if Z set
00:00002CE6 307C0100        	   797:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002CEA 4A18            	   798:             cmpi.b #$00,(a0)+
00:00002CEC 66FE            	   799:             bne.s *               * branch if Z clear
00:00002CEE 0C1800FE        	   800:             cmpi.b #$FE,(a0)+
00:00002CF2 66FE            	   801:             bne.s *               * branch if Z clear
00:00002CF4 4A18            	   802:             cmpi.b #$00,(a0)+
00:00002CF6 66FE            	   803:             bne.s *               * branch if Z clear
                            	   804: 
                            	   805: 
                            	   806: *             EA = n(An,D.W)  - BYTE only
00:00002CF8 307C0100        	   807:             move.l #$00000100,a0      * point to memory to address
00:00002CFC 93C9            	   808:             move.l #$00000000,a1      * point to memory to address
00:00002CFE 347C0001        	   809:             move.l #$00000001,a2      * point to memory to address
00:00002D02 7000            	   810:             moveq  #$00000000,d0      * point to memory to address
00:00002D04 7201            	   811:             moveq  #$00000001,d1      * point to memory to address
00:00002D06 087000000000    	   812:             bchg.b #0,0(a0,d0.w)
00:00002D0C 66FE            	   813:             bne.s *               * branch if Z clear
00:00002D0E 087000011000    	   814:             bchg.b #1,0(a0,d1.w)      *
00:00002D14 67FE            	   815:             beq.s *               * branch if Z set
00:00002D16 087000071001    	   816:             bchg.b #7,1(a0,d1.w)      *
00:00002D1C 66FE            	   817:             bne.s *               * branch if Z clear
                            	   818: *             EA = n(An,D.L)  - BYTE only
00:00002D1E 087000000800    	   819:             bchg.b #0,0(a0,d0.l)
00:00002D24 67FE            	   820:             beq.s *               * branch if Z set
00:00002D26 087000011800    	   821:             bchg.b #1,0(a0,d1.l)      *
00:00002D2C 66FE            	   822:             bne.s *               * branch if Z clear
00:00002D2E 087000071801    	   823:             bchg.b #7,1(a0,d1.l)      *
00:00002D34 67FE            	   824:             beq.s *               * branch if Z set
                            	   825: *             EA = n(An,A.W)  - BYTE only
00:00002D36 087000009000    	   826:             bchg.b #0,0(a0,a1.w)
00:00002D3C 66FE            	   827:             bne.s *               * branch if Z clear
00:00002D3E 08700001A000    	   828:             bchg.b #1,0(a0,a2.w)      *
00:00002D44 67FE            	   829:             beq.s *               * branch if Z set
00:00002D46 08700007A001    	   830:             bchg.b #7,1(a0,a2.w)      *
00:00002D4C 66FE            	   831:             bne.s *               * branch if Z clear
                            	   832: *             EA = n(An,A.L)  - BYTE only
00:00002D4E 087000009800    	   833:             bchg.b #0,0(a0,a1.l)
00:00002D54 67FE            	   834:             beq.s *               * branch if Z set
00:00002D56 08700001A800    	   835:             bchg.b #1,0(a0,a2.l)      *
00:00002D5C 66FE            	   836:             bne.s *               * branch if Z clear
00:00002D5E 08700007A801    	   837:             bchg.b #7,1(a0,a2.l)      *
00:00002D64 67FE            	   838:             beq.s *               * branch if Z set
00:00002D66 307C0100        	   839:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002D6A 4A18            	   840:             cmpi.b #$00,(a0)+
00:00002D6C 66FE            	   841:             bne.s *               * branch if Z clear
00:00002D6E 0C1800FE        	   842:             cmpi.b #$FE,(a0)+
00:00002D72 66FE            	   843:             bne.s *               * branch if Z clear
00:00002D74 4A18            	   844:             cmpi.b #$00,(a0)+
00:00002D76 66FE            	   845:             bne.s *               * branch if Z clear
                            	   846: 
                            	   847: 
                            	   848: *             EA = x.W  - BYTE only
00:00002D78 087800000100    	   849:             bchg.b #0,$0100
00:00002D7E 66FE            	   850:             bne.s *               * branch if Z clear
00:00002D80 087800010101    	   851:             bchg.b #1,$0101           *
00:00002D86 67FE            	   852:             beq.s *               * branch if Z set
00:00002D88 087800070102    	   853:             bchg.b #7,$0102           *
00:00002D8E 66FE            	   854:             bne.s *               * branch if Z clear
00:00002D90 307C0100        	   855:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002D94 0C180001        	   856:             cmpi.b #$01,(a0)+
00:00002D98 66FE            	   857:             bne.s *               * branch if Z clear
00:00002D9A 0C1800FC        	   858:             cmpi.b #$FC,(a0)+
00:00002D9E 66FE            	   859:             bne.s *               * branch if Z clear
00:00002DA0 0C180080        	   860:             cmpi.b #$80,(a0)+
00:00002DA4 66FE            	   861:             bne.s *               * branch if Z clear
                            	   862: 
                            	   863: *             EA = x.L  - BYTE only
00:00002DA6 207C0000F100    	   864:             move.l #$F100,a0      * point to memory to address 0x100
00:00002DAC 10FC0001        	   865:             move.b #$01,(a0)+         * populate test data
00:00002DB0 10FC00FC        	   866:             move.b #$FC,(a0)+         * populate test data
00:00002DB4 10FC0080        	   867:             move.b #$80,(a0)+         * populate test data
00:00002DB8 087900000000F100	   868:             bchg.b #0,$F100
00:00002DC0 67FE            	   869:             beq.s *               * branch if Z set
00:00002DC2 087900010000F101	   870:             bchg.b #1,$F101       *
00:00002DCA 66FE            	   871:             bne.s *               * branch if Z clear
00:00002DCC 087900070000F102	   872:             bchg.b #7,$F102       *
00:00002DD4 67FE            	   873:             beq.s *               * branch if Z set
00:00002DD6 307C0100        	   874:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002DDA 0C180001        	   875:             cmpi.b #$01,(a0)+
00:00002DDE 66FE            	   876:             bne.s *               * branch if Z clear
00:00002DE0 0C1800FC        	   877:             cmpi.b #$FC,(a0)+
00:00002DE4 66FE            	   878:             bne.s *               * branch if Z clear
00:00002DE6 0C180080        	   879:             cmpi.b #$80,(a0)+
00:00002DEA 66FE            	   880:             bne.s *               * branch if Z clear
                            	   881: 
                            	   882: 
                            	   883: * Bit Number.s Dynamic
                            	   884: 
                            	   885: *             EA = Dn  - LONG only
00:00002DEC 203C80000001    	   886:             move.l #$80000001,d0      * populate test data
00:00002DF2 7A00            	   887:             move.l #0,d5              * populate bit.s number to test
00:00002DF4 7C01            	   888:             move.l #1,d6              * populate bit.s number to test
00:00002DF6 7E1F            	   889:             move.l #31,d7              * populate bit.s number to test
                            	   890: 
00:00002DF8 0B40            	   891:             bchg.l d5,d0
00:00002DFA 67FE            	   892:             beq.s *               * branch if Z set
00:00002DFC 0D40            	   893:             bchg.l d6,d0              *
00:00002DFE 66FE            	   894:             bne.s *               * branch if Z clear
00:00002E00 0F40            	   895:             bchg.l d7,d0             *
00:00002E02 67FE            	   896:             beq.s *               * branch if Z set
00:00002E04 0C8000000002    	   897:             cmpi.l #$00000002,d0
00:00002E0A 66FE            	   898:             bne.s *               * branch if Z clear
                            	   899: 
                            	   900: 
                            	   901: *             EA = (An)  - BYTE only
00:00002E0C 7A00            	   902:             move.l #0,d5              * populate bit.s number to test
00:00002E0E 7C01            	   903:             move.l #1,d6              * populate bit.s number to test
00:00002E10 7E07            	   904:             move.l #7,d7              * populate bit.s number to test
00:00002E12 307C0100        	   905:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002E16 10BC0081        	   906:             move.b #$81,(a0)          * populate test data
00:00002E1A 1210            	   907:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00002E1C 0B50            	   908:             bchg.b d5,(a0)
00:00002E1E 67FE            	   909:             beq.s *               * branch if Z set
00:00002E20 0D50            	   910:             bchg.b d6,(a0)            *
00:00002E22 66FE            	   911:             bne.s *               * branch if Z clear
00:00002E24 0F50            	   912:             bchg.b d7,(a0)            *
00:00002E26 67FE            	   913:             beq.s *               * branch if Z set
00:00002E28 0C100002        	   914:             cmpi.b #$02,(a0)
00:00002E2C 66FE            	   915:             bne.s *               * branch if Z clear
                            	   916: 
                            	   917: 
                            	   918: *             EA = (An)+  - BYTE only
00:00002E2E 307C0100        	   919:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002E32 10FC0001        	   920:             move.b #$01,(a0)+         * populate test data
00:00002E36 10FC00FC        	   921:             move.b #$FC,(a0)+         * populate test data
00:00002E3A 10FC0080        	   922:             move.b #$80,(a0)+         * populate test data
00:00002E3E 307C0100        	   923:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002E42 0B58            	   924:             bchg.b d5,(a0)+
00:00002E44 67FE            	   925:             beq.s *               * branch if Z set
00:00002E46 0D58            	   926:             bchg.b d6,(a0)+           *
00:00002E48 66FE            	   927:             bne.s *               * branch if Z clear
00:00002E4A 0F58            	   928:             bchg.b d7,(a0)+           *
00:00002E4C 67FE            	   929:             beq.s *               * branch if Z set
00:00002E4E 307C0100        	   930:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002E52 4A18            	   931:             cmpi.b #$00,(a0)+
00:00002E54 66FE            	   932:             bne.s *               * branch if Z clear
00:00002E56 0C1800FE        	   933:             cmpi.b #$FE,(a0)+
00:00002E5A 66FE            	   934:             bne.s *               * branch if Z clear
00:00002E5C 4A18            	   935:             cmpi.b #$00,(a0)+
00:00002E5E 66FE            	   936:             bne.s *               * branch if Z clear
                            	   937: 
                            	   938: *             EA = -(An)  - BYTE only
00:00002E60 307C0100        	   939:             move.l #$00000100,a0      * point to memory to address
00:00002E64 10FC0080        	   940:             move.b #$80,(a0)+         * populate test data
00:00002E68 10FC00FC        	   941:             move.b #$FC,(a0)+         * populate test data
00:00002E6C 10FC0001        	   942:             move.b #$01,(a0)+         * populate test data
00:00002E70 307C0103        	   943:             move.l #$00000103,a0      * point to memory to address
00:00002E74 0B60            	   944:             bchg.b d5,-(a0)
00:00002E76 67FE            	   945:             beq.s *               * branch if Z set
00:00002E78 0D60            	   946:             bchg.b d6,-(a0)           *
00:00002E7A 66FE            	   947:             bne.s *               * branch if Z clear
00:00002E7C 0F60            	   948:             bchg.b d7,-(a0)           *
00:00002E7E 67FE            	   949:             beq.s *               * branch if Z set
00:00002E80 307C0103        	   950:             move.l #$00000103,a0      * point to memory to address 0x100
00:00002E84 4A20            	   951:             cmpi.b #$00,-(a0)
00:00002E86 66FE            	   952:             bne.s *               * branch if Z clear
00:00002E88 0C2000FE        	   953:             cmpi.b #$FE,-(a0)
00:00002E8C 66FE            	   954:             bne.s *               * branch if Z clear
00:00002E8E 4A20            	   955:             cmpi.b #$00,-(a0)
00:00002E90 66FE            	   956:             bne.s *               * branch if Z clear
                            	   957: 
                            	   958: *             EA = n(An)  - BYTE only
00:00002E92 307C0100        	   959:             move.l #$00000100,a0      * point to memory to address
00:00002E96 10FC0001        	   960:             move.b #$01,(a0)+         * populate test data
00:00002E9A 10FC00FC        	   961:             move.b #$FC,(a0)+         * populate test data
00:00002E9E 10FC0080        	   962:             move.b #$80,(a0)+         * populate test data
00:00002EA2 307C0100        	   963:             move.l #$00000100,a0      * point to memory to address
00:00002EA6 0B50            	   964:             bchg.b d5,0(a0)
00:00002EA8 67FE            	   965:             beq.s *               * branch if Z set
00:00002EAA 0D680001        	   966:             bchg.b d6,1(a0)           *
00:00002EAE 66FE            	   967:             bne.s *               * branch if Z clear
00:00002EB0 0F680002        	   968:             bchg.b d7,2(a0)           *
00:00002EB4 67FE            	   969:             beq.s *               * branch if Z set
00:00002EB6 307C0100        	   970:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002EBA 4A18            	   971:             cmpi.b #$00,(a0)+
00:00002EBC 66FE            	   972:             bne.s *               * branch if Z clear
00:00002EBE 0C1800FE        	   973:             cmpi.b #$FE,(a0)+
00:00002EC2 66FE            	   974:             bne.s *               * branch if Z clear
00:00002EC4 4A18            	   975:             cmpi.b #$00,(a0)+
00:00002EC6 66FE            	   976:             bne.s *               * branch if Z clear
                            	   977: 
                            	   978: *             EA = n(An,R.W)  - BYTE only
00:00002EC8 307C0100        	   979:             move.l #$00000100,a0      * point to memory to address
00:00002ECC 93C9            	   980:             move.l #$00000000,a1      * point to memory to address
00:00002ECE 347C0001        	   981:             move.l #$00000001,a2      * point to memory to address
00:00002ED2 7000            	   982:             moveq  #$00000000,d0      * point to memory to address
00:00002ED4 7201            	   983:             moveq  #$00000001,d1      * point to memory to address
00:00002ED6 0B700000        	   984:             bchg.b d5,0(a0,d0.w)
00:00002EDA 66FE            	   985:             bne.s *               * branch if Z clear
00:00002EDC 0D701000        	   986:             bchg.b d6,0(a0,d1.w)      *
00:00002EE0 67FE            	   987:             beq.s *               * branch if Z set
00:00002EE2 0F701001        	   988:             bchg.b d7,1(a0,d1.w)      *
00:00002EE6 66FE            	   989:             bne.s *               * branch if Z clear
                            	   990: *             EA = n(An,R.L)  - BYTE only
00:00002EE8 0B700800        	   991:             bchg.b d5,0(a0,d0.l)
00:00002EEC 67FE            	   992:             beq.s *               * branch if Z set
00:00002EEE 0D701800        	   993:             bchg.b d6,0(a0,d1.l)      *
00:00002EF2 66FE            	   994:             bne.s *               * branch if Z clear
00:00002EF4 0F701801        	   995:             bchg.b d7,1(a0,d1.l)      *
00:00002EF8 67FE            	   996:             beq.s *               * branch if Z set
                            	   997: *             EA = n(An,A.W)  - BYTE only
00:00002EFA 0B709000        	   998:             bchg.b d5,0(a0,a1.w)
00:00002EFE 66FE            	   999:             bne.s *               * branch if Z clear
00:00002F00 0D70A000        	  1000:             bchg.b d6,0(a0,a2.w)      *
00:00002F04 67FE            	  1001:             beq.s *               * branch if Z set
00:00002F06 0F70A001        	  1002:             bchg.b d7,1(a0,a2.w)      *
00:00002F0A 66FE            	  1003:             bne.s *               * branch if Z clear
                            	  1004: *             EA = n(An,A.L)  - BYTE only
00:00002F0C 0B709800        	  1005:             bchg.b d5,0(a0,a1.l)
00:00002F10 67FE            	  1006:             beq.s *               * branch if Z set
00:00002F12 0D70A800        	  1007:             bchg.b d6,0(a0,a2.l)      *
00:00002F16 66FE            	  1008:             bne.s *               * branch if Z clear
00:00002F18 0F70A801        	  1009:             bchg.b d7,1(a0,a2.l)      *
00:00002F1C 67FE            	  1010:             beq.s *               * branch if Z set
00:00002F1E 4A18            	  1011:             cmpi.b #$00,(a0)+
00:00002F20 66FE            	  1012:             bne.s *               * branch if Z clear
                            	  1013: 
                            	  1014: *             EA = x.W  - BYTE only
00:00002F22 0B780100        	  1015:             bchg.b d5,$0100
00:00002F26 66FE            	  1016:             bne.s *               * branch if Z clear
00:00002F28 0D780101        	  1017:             bchg.b d6,$0101           *
00:00002F2C 67FE            	  1018:             beq.s *               * branch if Z set
00:00002F2E 0F780102        	  1019:             bchg.b d7,$0102           *
00:00002F32 66FE            	  1020:             bne.s *               * branch if Z clear
00:00002F34 0C1800FC        	  1021:             cmpi.b #$FC,(a0)+
00:00002F38 66FE            	  1022:             bne.s *               * branch if Z clear
                            	  1023: 
                            	  1024: *             EA = x.L  - BYTE only
00:00002F3A 207C0000F100    	  1025:             move.l #$F100,a0      * point to memory to address 0x100
00:00002F40 10FC0001        	  1026:             move.b #$01,(a0)+         * populate test data
00:00002F44 10FC00FC        	  1027:             move.b #$FC,(a0)+         * populate test data
00:00002F48 10FC0080        	  1028:             move.b #$80,(a0)+         * populate test data
00:00002F4C 0B790000F100    	  1029:             bchg.b d5,$F100
00:00002F52 67FE            	  1030:             beq.s *               * branch if Z set
00:00002F54 0D790000F101    	  1031:             bchg.b d6,$F101       *
00:00002F5A 66FE            	  1032:             bne.s *               * branch if Z clear
00:00002F5C 0F790000F102    	  1033:             bchg.b d7,$F102       *
00:00002F62 67FE            	  1034:             beq.s *               * branch if Z set
00:00002F64 207C0000F101    	  1035:             move.l #$F101,a0      * point to memory to address 0x100
00:00002F6A 0C1000FE        	  1036:             cmpi.b #$FE,(a0)
00:00002F6E 66FE            	  1037:             bne.s *               * branch if Z clear
                            	  1038: 
                            	  1039: 
00:00002F70 4E75            	  1040:     rts
                            	  1041: 
                            	  1042: *-----------------------------------------------------------
                            	  1043: *-----------------------------------------------------------
                            	  1044: * OPCODE : BCLR
                            	  1045: *-----------------------------------------------------------
                            	  1046: *-----------------------------------------------------------
                            	  1047: op_BCLR:
                            	  1048: 
                            	  1049: 
                            	  1050: *  Bit Number.s Static
                            	  1051: 
                            	  1052: *             EA = Dn  - LONG only
00:00002F72 203CFF0000FF    	  1053:             move.l #$FF0000FF,d0      * populate test data
00:00002F78 08800000        	  1054:             bclr.l #0,d0
00:00002F7C 67FE            	  1055:             beq.s *               * branch if Z set
00:00002F7E 08800001        	  1056:             bclr.l #1,d0              *
00:00002F82 67FE            	  1057:             beq.s *               * branch if Z set
00:00002F84 0880000F        	  1058:             bclr.l #15,d0             *
00:00002F88 66FE            	  1059:             bne.s *               * branch if Z clear
00:00002F8A 0880001F        	  1060:             bclr.l #31,d0             *
00:00002F8E 67FE            	  1061:             beq.s *               * branch if Z set
00:00002F90 0C807F0000FC    	  1062:             cmpi.l #$7F0000FC,d0
00:00002F96 66FE            	  1063:             bne.s *               * branch if Z clear
                            	  1064: 
                            	  1065: 
                            	  1066: *             EA = (An)  - BYTE only
00:00002F98 307C0100        	  1067:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002F9C 10BC000F        	  1068:             move.b #$0F,(a0)          * populate test data
00:00002FA0 08900000        	  1069:             bclr.b #0,(a0)
00:00002FA4 67FE            	  1070:             beq.s *               * branch if Z set
00:00002FA6 08900007        	  1071:             bclr.b #7,(a0)            *
00:00002FAA 66FE            	  1072:             bne.s *               * branch if Z clear
00:00002FAC 0C10000E        	  1073:             cmpi.b #$0E,(a0)
00:00002FB0 66FE            	  1074:             bne.s *               * branch if Z clear
                            	  1075: 
                            	  1076: *             EA = (An)+  - BYTE only
00:00002FB2 307C0100        	  1077:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002FB6 10FC0001        	  1078:             move.b #$01,(a0)+         * populate test data
00:00002FBA 4218            	  1079:             move.b #$00,(a0)+         * populate test data
00:00002FBC 307C0100        	  1080:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002FC0 08980000        	  1081:             bclr.b #0,(a0)+
00:00002FC4 67FE            	  1082:             beq.s *               * branch if Z set
00:00002FC6 08980001        	  1083:             bclr.b #1,(a0)+           *
00:00002FCA 66FE            	  1084:             bne.s *               * branch if Z clear
00:00002FCC 307C0100        	  1085:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002FD0 4A18            	  1086:             cmpi.b #$00,(a0)+
00:00002FD2 66FE            	  1087:             bne.s *               * branch if Z clear
00:00002FD4 4A18            	  1088:             cmpi.b #$00,(a0)+
00:00002FD6 66FE            	  1089:             bne.s *               * branch if Z clear
                            	  1090: 
                            	  1091: 
                            	  1092: *             EA = -(An)  - BYTE only
00:00002FD8 307C0100        	  1093:             move.l #$00000100,a0      * point to memory to address
00:00002FDC 10FC0001        	  1094:             move.b #$01,(a0)+         * populate test data
00:00002FE0 10FC0080        	  1095:             move.b #$80,(a0)+         * populate test data
00:00002FE4 08A00007        	  1096:             bclr.b #7,-(a0)
00:00002FE8 67FE            	  1097:             beq.s *               * branch if Z set
00:00002FEA 08A00000        	  1098:             bclr.b #0,-(a0)           *
00:00002FEE 67FE            	  1099:             beq.s *               * branch if Z set
00:00002FF0 307C0102        	  1100:             move.l #$00000102,a0      * point to memory to address 0x100
00:00002FF4 4A20            	  1101:             cmpi.b #$00,-(a0)
00:00002FF6 66FE            	  1102:             bne.s *               * branch if Z clear
00:00002FF8 4A20            	  1103:             cmpi.b #$00,-(a0)
00:00002FFA 66FE            	  1104:             bne.s *               * branch if Z clear
                            	  1105: 
                            	  1106: 
                            	  1107: *             EA = n(An)  - BYTE only
00:00002FFC 307C0100        	  1108:             move.l #$00000100,a0      * point to memory to address
00:00003000 10FC00FF        	  1109:             move.b #$FF,(a0)+         * populate test data
00:00003004 10FC00FF        	  1110:             move.b #$FF,(a0)+         * populate test data
00:00003008 307C0100        	  1111:             move.l #$00000100,a0      * point to memory to address
00:0000300C 08900000        	  1112:             bclr.b #0,0(a0)
00:00003010 67FE            	  1113:             beq.s *               * branch if Z set
00:00003012 08A800040001    	  1114:             bclr.b #4,1(a0)           *
00:00003018 67FE            	  1115:             beq.s *               * branch if Z set
00:0000301A 307C0100        	  1116:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000301E 0C1800FE        	  1117:             cmpi.b #$FE,(a0)+
00:00003022 66FE            	  1118:             bne.s *               * branch if Z clear
00:00003024 0C1800EF        	  1119:             cmpi.b #$EF,(a0)+
00:00003028 66FE            	  1120:             bne.s *               * branch if Z clear
                            	  1121: 
                            	  1122: 
                            	  1123: *             EA = n(An,D.W)  - BYTE only
00:0000302A 307C0100        	  1124:             move.l #$00000100,a0      * point to memory to address
00:0000302E 93C9            	  1125:             move.l #$00000000,a1      * point to memory to address
00:00003030 347C0001        	  1126:             move.l #$00000001,a2      * point to memory to address
00:00003034 7000            	  1127:             moveq  #$00000000,d0      * point to memory to address
00:00003036 7201            	  1128:             moveq  #$00000001,d1      * point to memory to address
00:00003038 10FC00FF        	  1129:             move.b #$FF,(a0)+         * populate test data
00:0000303C 10FC00FF        	  1130:             move.b #$FF,(a0)+         * populate test data
00:00003040 307C0100        	  1131:             move.l #$00000100,a0      * point to memory to address
00:00003044 08B000000000    	  1132:             bclr.b #0,0(a0,d0.w)
00:0000304A 67FE            	  1133:             beq.s *               * branch if Z set
00:0000304C 08B000011000    	  1134:             bclr.b #1,0(a0,d1.w)      *
00:00003052 67FE            	  1135:             beq.s *               * branch if Z set
00:00003054 08B000021001    	  1136:             bclr.b #2,1(a0,d1.w)      *
00:0000305A 66FE            	  1137:             bne.s *               * branch if Z clear
                            	  1138: *             EA = n(An,D.L)  - BYTE only
00:0000305C 08B000030800    	  1139:             bclr.b #3,0(a0,d0.l)
00:00003062 67FE            	  1140:             beq.s *               * branch if Z set
00:00003064 08B000041800    	  1141:             bclr.b #4,0(a0,d1.l)      *
00:0000306A 67FE            	  1142:             beq.s *               * branch if Z set
00:0000306C 08B000051801    	  1143:             bclr.b #5,1(a0,d1.l)      *
00:00003072 66FE            	  1144:             bne.s *               * branch if Z clear
                            	  1145: *             EA = n(An,A.W)  - BYTE only
00:00003074 08B000069000    	  1146:             bclr.b #6,0(a0,a1.w)
00:0000307A 67FE            	  1147:             beq.s *               * branch if Z set
00:0000307C 08B00001A000    	  1148:             bclr.b #1,0(a0,a2.w)      *
00:00003082 66FE            	  1149:             bne.s *               * branch if Z clear
00:00003084 08B00007A001    	  1150:             bclr.b #7,1(a0,a2.w)      *
00:0000308A 67FE            	  1151:             beq.s *               * branch if Z set
                            	  1152: *             EA = n(An,A.L)  - BYTE only
00:0000308C 08B000009800    	  1153:             bclr.b #0,0(a0,a1.l)
00:00003092 66FE            	  1154:             bne.s *               * branch if Z clear
00:00003094 08B00000A800    	  1155:             bclr.b #0,0(a0,a2.l)      *
00:0000309A 67FE            	  1156:             beq.s *               * branch if Z set
00:0000309C 08B00001A801    	  1157:             bclr.b #1,1(a0,a2.l)      *
00:000030A2 66FE            	  1158:             bne.s *               * branch if Z clear
00:000030A4 307C0100        	  1159:             move.l #$00000100,a0      * point to memory to address 0x100
00:000030A8 0C1800B6        	  1160:             cmpi.b #$B6,(a0)+
00:000030AC 66FE            	  1161:             bne.s *               * branch if Z clear
00:000030AE 0C1800EC        	  1162:             cmpi.b #$EC,(a0)+
00:000030B2 66FE            	  1163:             bne.s *               * branch if Z clear
00:000030B4 0C180059        	  1164:             cmpi.b #$59,(a0)+
00:000030B8 67FE            	  1165:             beq.s *               * branch if Z set
                            	  1166: 
                            	  1167: 
                            	  1168: *             EA = x.W  - BYTE only
00:000030BA 307C0100        	  1169:             move.l #$00000100,a0      * point to memory to address
00:000030BE 10FC00FF        	  1170:             move.b #$FF,(a0)+         * populate test data
00:000030C2 08B800000100    	  1171:             bclr.b #0,$0100
00:000030C8 67FE            	  1172:             beq.s *               * branch if Z set
00:000030CA 08B800010100    	  1173:             bclr.b #1,$0100           *
00:000030D0 67FE            	  1174:             beq.s *               * branch if Z set
00:000030D2 307C0100        	  1175:             move.l #$00000100,a0      * point to memory to address 0x100
00:000030D6 0C1800FC        	  1176:             cmpi.b #$FC,(a0)+
00:000030DA 66FE            	  1177:             bne.s *               * branch if Z clear
                            	  1178: 
                            	  1179: 
                            	  1180: *             EA = x.L  - BYTE only
00:000030DC 207C0000F100    	  1181:             move.l #$F100,a0      * point to memory to address 0x100
00:000030E2 10BC00FF        	  1182:             move.b #$FF,(a0)          * populate test data
00:000030E6 08B900000000F100	  1183:             bclr.b #0,$F100
00:000030EE 67FE            	  1184:             beq.s *               * branch if Z set
00:000030F0 08B900010000F100	  1185:             bclr.b #1,$F100       *
00:000030F8 67FE            	  1186:             beq.s *               * branch if Z set
00:000030FA 08B900020000F100	  1187:             bclr.b #2,$F100       *
00:00003102 67FE            	  1188:             beq.s *               * branch if Z set
00:00003104 207C0000F100    	  1189:             move.l #$F100,a0      * point to memory to address 0x100
00:0000310A 0C1800F8        	  1190:             cmpi.b #$F8,(a0)+
00:0000310E 66FE            	  1191:             bne.s *               * branch if Z clear
                            	  1192: 
                            	  1193: 
                            	  1194: * Bit Number.s Dynamic
                            	  1195: 
                            	  1196: *             EA = Dn  - LONG only
00:00003110 203CFF00FF00    	  1197:             move.l #$FF00FF00,d0      * populate test data
00:00003116 7A00            	  1198:             move.l #0,d5              * populate bit.s number to test
00:00003118 7C01            	  1199:             move.l #1,d6              * populate bit.s number to test
00:0000311A 7E1F            	  1200:             move.l #31,d7              * populate bit.s number to test
                            	  1201: 
00:0000311C 0B80            	  1202:             bclr.l d5,d0
00:0000311E 66FE            	  1203:             bne.s *               * branch if Z clear
00:00003120 0D80            	  1204:             bclr.l d6,d0              *
00:00003122 66FE            	  1205:             bne.s *               * branch if Z clear
00:00003124 0F80            	  1206:             bclr.l d7,d0             *
00:00003126 67FE            	  1207:             beq.s *               * branch if Z set
00:00003128 0C807F00FF00    	  1208:             cmpi.l #$7F00FF00,d0
00:0000312E 66FE            	  1209:             bne.s *               * branch if Z clear
                            	  1210: 
                            	  1211: 
                            	  1212: *             EA = (An)  - BYTE only
00:00003130 7A00            	  1213:             move.l #0,d5              * populate bit.s number to test
00:00003132 7C01            	  1214:             move.l #1,d6              * populate bit.s number to test
00:00003134 7E07            	  1215:             move.l #7,d7              * populate bit.s number to test
00:00003136 307C0100        	  1216:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000313A 10BC0081        	  1217:             move.b #$81,(a0)          * populate test data
00:0000313E 0B90            	  1218:             bclr.b d5,(a0)
00:00003140 67FE            	  1219:             beq.s *               * branch if Z set
00:00003142 0D90            	  1220:             bclr.b d6,(a0)            *
00:00003144 66FE            	  1221:             bne.s *               * branch if Z clear
00:00003146 0F90            	  1222:             bclr.b d7,(a0)            *
00:00003148 67FE            	  1223:             beq.s *               * branch if Z set
00:0000314A 4A10            	  1224:             cmpi.b #$00,(a0)
00:0000314C 66FE            	  1225:             bne.s *               * branch if Z clear
                            	  1226: 
                            	  1227: 
                            	  1228: *             EA = (An)+  - BYTE only
00:0000314E 307C0100        	  1229:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003152 10FC0001        	  1230:             move.b #$01,(a0)+         * populate test data
00:00003156 10FC00FC        	  1231:             move.b #$FC,(a0)+         * populate test data
00:0000315A 10FC0080        	  1232:             move.b #$80,(a0)+         * populate test data
00:0000315E 307C0100        	  1233:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003162 0B98            	  1234:             bclr.b d5,(a0)+
00:00003164 67FE            	  1235:             beq.s *               * branch if Z set
00:00003166 0D98            	  1236:             bclr.b d6,(a0)+           *
00:00003168 66FE            	  1237:             bne.s *               * branch if Z clear
00:0000316A 0F98            	  1238:             bclr.b d7,(a0)+           *
00:0000316C 67FE            	  1239:             beq.s *               * branch if Z set
00:0000316E 307C0100        	  1240:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003172 4A18            	  1241:             cmpi.b #$00,(a0)+
00:00003174 66FE            	  1242:             bne.s *               * branch if Z clear
00:00003176 0C1800FC        	  1243:             cmpi.b #$FC,(a0)+
00:0000317A 66FE            	  1244:             bne.s *               * branch if Z clear
00:0000317C 4A18            	  1245:             cmpi.b #$00,(a0)+
00:0000317E 66FE            	  1246:             bne.s *               * branch if Z clear
                            	  1247: 
                            	  1248: *             EA = -(An)  - BYTE only
00:00003180 307C0100        	  1249:             move.l #$00000100,a0      * point to memory to address
00:00003184 10FC0080        	  1250:             move.b #$80,(a0)+         * populate test data
00:00003188 10FC00FC        	  1251:             move.b #$FC,(a0)+         * populate test data
00:0000318C 10FC0001        	  1252:             move.b #$01,(a0)+         * populate test data
00:00003190 307C0103        	  1253:             move.l #$00000103,a0      * point to memory to address
00:00003194 0BA0            	  1254:             bclr.b d5,-(a0)
00:00003196 67FE            	  1255:             beq.s *               * branch if Z set
00:00003198 0DA0            	  1256:             bclr.b d6,-(a0)           *
00:0000319A 66FE            	  1257:             bne.s *               * branch if Z clear
00:0000319C 0FA0            	  1258:             bclr.b d7,-(a0)           *
00:0000319E 67FE            	  1259:             beq.s *               * branch if Z set
00:000031A0 307C0103        	  1260:             move.l #$00000103,a0      * point to memory to address 0x100
00:000031A4 4A20            	  1261:             cmpi.b #$00,-(a0)
00:000031A6 66FE            	  1262:             bne.s *               * branch if Z clear
00:000031A8 0C2000FC        	  1263:             cmpi.b #$FC,-(a0)
00:000031AC 66FE            	  1264:             bne.s *               * branch if Z clear
00:000031AE 4A20            	  1265:             cmpi.b #$00,-(a0)
00:000031B0 66FE            	  1266:             bne.s *               * branch if Z clear
                            	  1267: 
                            	  1268: *             EA = n(An)  - BYTE only
00:000031B2 307C0100        	  1269:             move.l #$00000100,a0      * point to memory to address
00:000031B6 10FC0001        	  1270:             move.b #$01,(a0)+         * populate test data
00:000031BA 10FC00FC        	  1271:             move.b #$FC,(a0)+         * populate test data
00:000031BE 10FC0080        	  1272:             move.b #$80,(a0)+         * populate test data
00:000031C2 307C0100        	  1273:             move.l #$00000100,a0      * point to memory to address
00:000031C6 0B90            	  1274:             bclr.b d5,0(a0)
00:000031C8 67FE            	  1275:             beq.s *               * branch if Z set
00:000031CA 0DA80001        	  1276:             bclr.b d6,1(a0)           *
00:000031CE 66FE            	  1277:             bne.s *               * branch if Z clear
00:000031D0 0FA80002        	  1278:             bclr.b d7,2(a0)           *
00:000031D4 67FE            	  1279:             beq.s *               * branch if Z set
00:000031D6 307C0100        	  1280:             move.l #$00000100,a0      * point to memory to address 0x100
00:000031DA 4A18            	  1281:             cmpi.b #$00,(a0)+
00:000031DC 66FE            	  1282:             bne.s *               * branch if Z clear
00:000031DE 0C1800FC        	  1283:             cmpi.b #$FC,(a0)+
00:000031E2 66FE            	  1284:             bne.s *               * branch if Z clear
00:000031E4 4A18            	  1285:             cmpi.b #$00,(a0)+
00:000031E6 66FE            	  1286:             bne.s *               * branch if Z clear
                            	  1287: 
                            	  1288: *             EA = n(An,R.W)  - BYTE only
00:000031E8 307C0100        	  1289:             move.l #$00000100,a0      * point to memory to address
00:000031EC 10FC00FF        	  1290:             move.b #$FF,(a0)+         * populate test data
00:000031F0 10FC00FF        	  1291:             move.b #$FF,(a0)+         * populate test data
00:000031F4 10FC00FF        	  1292:             move.b #$FF,(a0)+         * populate test data
00:000031F8 307C0103        	  1293:             move.l #$00000103,a0      * point to memory to address
00:000031FC 307C0100        	  1294:             move.l #$00000100,a0      * point to memory to address
00:00003200 93C9            	  1295:             move.l #$00000000,a1      * point to memory to address
00:00003202 347C0001        	  1296:             move.l #$00000001,a2      * point to memory to address
00:00003206 7000            	  1297:             moveq  #$00000000,d0      * point to memory to address
00:00003208 7201            	  1298:             moveq  #$00000001,d1      * point to memory to address
00:0000320A 0BB00000        	  1299:             bclr.b d5,0(a0,d0.w)
00:0000320E 67FE            	  1300:             beq.s *               * branch if Z set
00:00003210 0DB01000        	  1301:             bclr.b d6,0(a0,d1.w)      *
00:00003214 67FE            	  1302:             beq.s *               * branch if Z set
00:00003216 0FB01001        	  1303:             bclr.b d7,1(a0,d1.w)      *
00:0000321A 67FE            	  1304:             beq.s *               * branch if Z set
                            	  1305: *             EA = n(An,R.L)  - BYTE only
00:0000321C 0BB00800        	  1306:             bclr.b d5,0(a0,d0.l)
00:00003220 66FE            	  1307:             bne.s *               * branch if Z clear
00:00003222 0DB01800        	  1308:             bclr.b d6,0(a0,d1.l)      *
00:00003226 66FE            	  1309:             bne.s *               * branch if Z clear
00:00003228 0FB01801        	  1310:             bclr.b d7,1(a0,d1.l)      *
00:0000322C 66FE            	  1311:             bne.s *               * branch if Z clear
                            	  1312: *             EA = n(An,A.W)  - BYTE only
00:0000322E 0BB09000        	  1313:             bclr.b d5,0(a0,a1.w)
00:00003232 66FE            	  1314:             bne.s *               * branch if Z clear
00:00003234 0DB0A000        	  1315:             bclr.b d6,0(a0,a2.w)      *
00:00003238 66FE            	  1316:             bne.s *               * branch if Z clear
00:0000323A 0FB0A001        	  1317:             bclr.b d7,1(a0,a2.w)      *
00:0000323E 66FE            	  1318:             bne.s *               * branch if Z clear
                            	  1319: *             EA = n(An,A.L)  - BYTE only
00:00003240 0BB09800        	  1320:             bclr.b d5,0(a0,a1.l)
00:00003244 66FE            	  1321:             bne.s *               * branch if Z clear
00:00003246 0DB0A800        	  1322:             bclr.b d6,0(a0,a2.l)      *
00:0000324A 66FE            	  1323:             bne.s *               * branch if Z clear
00:0000324C 0FB0A801        	  1324:             bclr.b d7,1(a0,a2.l)      *
00:00003250 66FE            	  1325:             bne.s *               * branch if Z clear
00:00003252 307C0100        	  1326:             move.l #$00000100,a0      * point to memory to address
00:00003256 0C1000FE        	  1327:             cmpi.b #$FE,(a0)
00:0000325A 66FE            	  1328:             bne.s *               * branch if Z clear
                            	  1329: 
                            	  1330: *             EA = x.W  - BYTE only
00:0000325C 307C0100        	  1331:             move.l #$00000100,a0      * point to memory to address
00:00003260 10FC00FF        	  1332:             move.b #$FF,(a0)+         * populate test data
00:00003264 10FC00FF        	  1333:             move.b #$FF,(a0)+         * populate test data
00:00003268 10FC00FF        	  1334:             move.b #$FF,(a0)+         * populate test data
00:0000326C 0BB80100        	  1335:             bclr.b d5,$0100
00:00003270 67FE            	  1336:             beq.s *               * branch if Z set
00:00003272 0DB80101        	  1337:             bclr.b d6,$0101           *
00:00003276 67FE            	  1338:             beq.s *               * branch if Z set
00:00003278 0FB80102        	  1339:             bclr.b d7,$0102           *
00:0000327C 67FE            	  1340:             beq.s *               * branch if Z set
00:0000327E 307C0100        	  1341:             move.l #$00000100,a0      * point to memory to address
00:00003282 0C1800FE        	  1342:             cmpi.b #$FE,(a0)+
00:00003286 66FE            	  1343:             bne.s *               * branch if Z clear
                            	  1344: 
                            	  1345: *             EA = x.L  - BYTE only
00:00003288 207C0000F100    	  1346:             move.l #$F100,a0      * point to memory to address 0x100
00:0000328E 10FC0001        	  1347:             move.b #$01,(a0)+         * populate test data
00:00003292 10FC00FC        	  1348:             move.b #$FC,(a0)+         * populate test data
00:00003296 10FC0080        	  1349:             move.b #$80,(a0)+         * populate test data
00:0000329A 0BB90000F100    	  1350:             bclr.b d5,$F100
00:000032A0 67FE            	  1351:             beq.s *               * branch if Z set
00:000032A2 0DB90000F101    	  1352:             bclr.b d6,$F101       *
00:000032A8 66FE            	  1353:             bne.s *               * branch if Z clear
00:000032AA 0FB90000F102    	  1354:             bclr.b d7,$F102       *
00:000032B0 67FE            	  1355:             beq.s *               * branch if Z set
00:000032B2 207C0000F101    	  1356:             move.l #$F101,a0      * point to memory to address 0x100
00:000032B8 0C1000FC        	  1357:             cmpi.b #$FC,(a0)
00:000032BC 66FE            	  1358:             bne.s *               * branch if Z clear
                            	  1359: 
                            	  1360: 
                            	  1361: 
00:000032BE 4E75            	  1362:     rts
                            	  1363: 
                            	  1364: *-----------------------------------------------------------
                            	  1365: *-----------------------------------------------------------
                            	  1366: * OPCODE : BSET
                            	  1367: *-----------------------------------------------------------
                            	  1368: *-----------------------------------------------------------
                            	  1369: op_BSET:
                            	  1370: 
                            	  1371: 
                            	  1372: *  Bit Number.s Static
                            	  1373: 
                            	  1374: *             EA = Dn  - LONG only
00:000032C0 7000            	  1375:             moveq  #$00000000,d0      * populate test data
00:000032C2 08C00000        	  1376:             bset.l #0,d0
00:000032C6 66FE            	  1377:             bne.s *               * branch if Z clear
00:000032C8 08C00001        	  1378:             bset.l #1,d0              *
00:000032CC 66FE            	  1379:             bne.s *               * branch if Z clear
00:000032CE 08C0000F        	  1380:             bset.l #15,d0             *
00:000032D2 66FE            	  1381:             bne.s *               * branch if Z clear
00:000032D4 08C0001F        	  1382:             bset.l #31,d0             *
00:000032D8 66FE            	  1383:             bne.s *               * branch if Z clear
00:000032DA 0C8080008003    	  1384:             cmpi.l #$80008003,d0
00:000032E0 66FE            	  1385:             bne.s *               * branch if Z clear
                            	  1386: 
                            	  1387: 
                            	  1388: *             EA = (An)  - BYTE only
00:000032E2 307C0100        	  1389:             move.l #$00000100,a0      * point to memory to address 0x100
00:000032E6 4210            	  1390:             move.b #$00,(a0)          * populate test data
00:000032E8 08D00000        	  1391:             bset.b #0,(a0)
00:000032EC 66FE            	  1392:             bne.s *               * branch if Z clear
00:000032EE 08D00007        	  1393:             bset.b #7,(a0)            *
00:000032F2 66FE            	  1394:             bne.s *               * branch if Z clear
00:000032F4 0C100081        	  1395:             cmpi.b #$81,(a0)
00:000032F8 66FE            	  1396:             bne.s *               * branch if Z clear
                            	  1397: 
                            	  1398: *             EA = (An)+  - BYTE only
00:000032FA 307C0100        	  1399:             move.l #$00000100,a0      * point to memory to address 0x100
00:000032FE 4218            	  1400:             move.b #$00,(a0)+         * populate test data
00:00003300 4218            	  1401:             move.b #$00,(a0)+         * populate test data
00:00003302 307C0100        	  1402:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003306 08D80000        	  1403:             bset.b #0,(a0)+
00:0000330A 66FE            	  1404:             bne.s *               * branch if Z clear
00:0000330C 08D80001        	  1405:             bset.b #1,(a0)+           *
00:00003310 66FE            	  1406:             bne.s *               * branch if Z clear
00:00003312 307C0100        	  1407:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003316 0C180001        	  1408:             cmpi.b #$01,(a0)+
00:0000331A 66FE            	  1409:             bne.s *               * branch if Z clear
00:0000331C 0C180002        	  1410:             cmpi.b #$02,(a0)+
00:00003320 66FE            	  1411:             bne.s *               * branch if Z clear
                            	  1412: 
                            	  1413: 
                            	  1414: *             EA = -(An)  - BYTE only
00:00003322 307C0100        	  1415:             move.l #$00000100,a0      * point to memory to address
00:00003326 4218            	  1416:             move.b #$00,(a0)+         * populate test data
00:00003328 4218            	  1417:             move.b #$00,(a0)+         * populate test data
00:0000332A 08E00007        	  1418:             bset.b #7,-(a0)
00:0000332E 66FE            	  1419:             bne.s *               * branch if Z clear
00:00003330 08E00000        	  1420:             bset.b #0,-(a0)           *
00:00003334 66FE            	  1421:             bne.s *               * branch if Z clear
00:00003336 307C0102        	  1422:             move.l #$00000102,a0      * point to memory to address 0x100
00:0000333A 0C200080        	  1423:             cmpi.b #$80,-(a0)
00:0000333E 66FE            	  1424:             bne.s *               * branch if Z clear
00:00003340 0C200001        	  1425:             cmpi.b #$01,-(a0)
00:00003344 66FE            	  1426:             bne.s *               * branch if Z clear
                            	  1427: 
                            	  1428: 
                            	  1429: *             EA = n(An)  - BYTE only
00:00003346 307C0100        	  1430:             move.l #$00000100,a0      * point to memory to address
00:0000334A 4218            	  1431:             move.b #$00,(a0)+         * populate test data
00:0000334C 4218            	  1432:             move.b #$00,(a0)+         * populate test data
00:0000334E 307C0100        	  1433:             move.l #$00000100,a0      * point to memory to address
00:00003352 08D00000        	  1434:             bset.b #0,0(a0)
00:00003356 66FE            	  1435:             bne.s *               * branch if Z clear
00:00003358 08E800040001    	  1436:             bset.b #4,1(a0)           *
00:0000335E 66FE            	  1437:             bne.s *               * branch if Z clear
00:00003360 307C0100        	  1438:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003364 0C180001        	  1439:             cmpi.b #$01,(a0)+
00:00003368 66FE            	  1440:             bne.s *               * branch if Z clear
00:0000336A 0C180010        	  1441:             cmpi.b #$10,(a0)+
00:0000336E 66FE            	  1442:             bne.s *               * branch if Z clear
                            	  1443: 
                            	  1444: 
                            	  1445: *             EA = n(An,D.W)  - BYTE only
00:00003370 307C0100        	  1446:             move.l #$00000100,a0      * point to memory to address
00:00003374 93C9            	  1447:             move.l #$00000000,a1      * point to memory to address
00:00003376 347C0004        	  1448:             move.l #$00000004,a2      * point to memory to address
00:0000337A 7000            	  1449:             moveq  #$00000000,d0      * point to memory to address
00:0000337C 7201            	  1450:             moveq  #$00000001,d1      * point to memory to address
00:0000337E 4218            	  1451:             move.b #$00,(a0)+         * populate test data
00:00003380 4218            	  1452:             move.b #$00,(a0)+         * populate test data
00:00003382 4218            	  1453:             move.b #$00,(a0)+         * populate test data
00:00003384 4218            	  1454:             move.b #$00,(a0)+         * populate test data
00:00003386 4218            	  1455:             move.b #$00,(a0)+         * populate test data
00:00003388 4218            	  1456:             move.b #$00,(a0)+         * populate test data
00:0000338A 4218            	  1457:             move.b #$00,(a0)+         * populate test data
00:0000338C 4218            	  1458:             move.b #$00,(a0)+         * populate test data
00:0000338E 4218            	  1459:             move.b #$00,(a0)+         * populate test data
00:00003390 4218            	  1460:             move.b #$00,(a0)+         * populate test data
00:00003392 307C0100        	  1461:             move.l #$00000100,a0      * point to memory to address
00:00003396 08F000000000    	  1462:             bset.b #0,0(a0,d0.w)
00:0000339C 66FE            	  1463:             bne.s *               * branch if Z clear
00:0000339E 08F000011000    	  1464:             bset.b #1,0(a0,d1.w)      *
00:000033A4 66FE            	  1465:             bne.s *               * branch if Z clear
00:000033A6 08F000021001    	  1466:             bset.b #2,1(a0,d1.w)      *
00:000033AC 66FE            	  1467:             bne.s *               * branch if Z clear
                            	  1468: *             EA = n(An,D.L)  - BYTE only
00:000033AE 08F000030802    	  1469:             bset.b #3,2(a0,d0.l)
00:000033B4 66FE            	  1470:             bne.s *               * branch if Z clear
00:000033B6 08F000041800    	  1471:             bset.b #4,0(a0,d1.l)      *
00:000033BC 66FE            	  1472:             bne.s *               * branch if Z clear
00:000033BE 08F000051801    	  1473:             bset.b #5,1(a0,d1.l)      *
00:000033C4 66FE            	  1474:             bne.s *               * branch if Z clear
                            	  1475: *             EA = n(An,A.W)  - BYTE only
00:000033C6 08F000069000    	  1476:             bset.b #6,0(a0,a1.w)
00:000033CC 66FE            	  1477:             bne.s *               * branch if Z clear
00:000033CE 08F00001A000    	  1478:             bset.b #1,0(a0,a2.w)      *
00:000033D4 66FE            	  1479:             bne.s *               * branch if Z clear
00:000033D6 08F00007A001    	  1480:             bset.b #7,1(a0,a2.w)      *
00:000033DC 66FE            	  1481:             bne.s *               * branch if Z clear
                            	  1482: *             EA = n(An,A.L)  - BYTE only
00:000033DE 08F00000A802    	  1483:             bset.b #0,2(a0,a2.l)
00:000033E4 66FE            	  1484:             bne.s *               * branch if Z clear
00:000033E6 08F00000A803    	  1485:             bset.b #0,3(a0,a2.l)      *
00:000033EC 66FE            	  1486:             bne.s *               * branch if Z clear
00:000033EE 08F00001A804    	  1487:             bset.b #1,4(a0,a2.l)      *
00:000033F4 66FE            	  1488:             bne.s *               * branch if Z clear
00:000033F6 307C0100        	  1489:             move.l #$00000100,a0      * point to memory to address 0x100
00:000033FA 0C9841122C00    	  1490:             cmpi.l #$41122C00,(a0)+
00:00003400 66FE            	  1491:             bne.s *               * branch if Z clear
00:00003402 0C9802800101    	  1492:             cmpi.l #$02800101,(a0)+
00:00003408 66FE            	  1493:             bne.s *
                            	  1494: 
                            	  1495: 
                            	  1496: 
                            	  1497: *             EA = x.W  - BYTE only
00:0000340A 307C0100        	  1498:             move.l #$00000100,a0      * point to memory to address
00:0000340E 4218            	  1499:             move.b #$00,(a0)+         * populate test data
00:00003410 08F800000100    	  1500:             bset.b #0,$0100
00:00003416 66FE            	  1501:             bne.s *               * branch if Z clear
00:00003418 08F800010100    	  1502:             bset.b #1,$0100           *
00:0000341E 66FE            	  1503:             bne.s *               * branch if Z clear
00:00003420 307C0100        	  1504:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003424 0C180003        	  1505:             cmpi.b #$03,(a0)+
00:00003428 66FE            	  1506:             bne.s *
                            	  1507: 
                            	  1508: 
                            	  1509: *             EA = x.L  - BYTE only
00:0000342A 207C0000F100    	  1510:             move.l #$F100,a0      * point to memory to address 0x100
00:00003430 4210            	  1511:             move.b #$00,(a0)          * populate test data
00:00003432 08F900000000F100	  1512:             bset.b #0,$F100
00:0000343A 66FE            	  1513:             bne.s *               * branch if Z clear
00:0000343C 08F900010000F100	  1514:             bset.b #1,$F100       *
00:00003444 66FE            	  1515:             bne.s *               * branch if Z clear
00:00003446 08F900020000F100	  1516:             bset.b #2,$F100       *
00:0000344E 66FE            	  1517:             bne.s *               * branch if Z clear
00:00003450 207C0000F100    	  1518:             move.l #$F100,a0      * point to memory to address 0x100
00:00003456 0C180007        	  1519:             cmpi.b #$07,(a0)+
00:0000345A 66FE            	  1520:             bne.s *
                            	  1521: 
                            	  1522: 
                            	  1523: * Bit Number.s Dynamic
                            	  1524: 
                            	  1525: *             EA = Dn  - LONG only
00:0000345C 7000            	  1526:             moveq  #$00000000,d0      * populate test data
00:0000345E 7A00            	  1527:             move.l #0,d5              * populate bit.s number to test
00:00003460 7C01            	  1528:             move.l #1,d6              * populate bit.s number to test
00:00003462 7E1F            	  1529:             move.l #31,d7              * populate bit.s number to test
                            	  1530: 
00:00003464 0BC0            	  1531:             bset.l d5,d0
00:00003466 66FE            	  1532:             bne.s *               * branch if Z clear
00:00003468 0DC0            	  1533:             bset.l d6,d0              *
00:0000346A 66FE            	  1534:             bne.s *               * branch if Z clear
00:0000346C 0FC0            	  1535:             bset.l d7,d0             *
00:0000346E 66FE            	  1536:             bne.s *               * branch if Z clear
00:00003470 0C8080000003    	  1537:             cmpi.l #$80000003,d0
00:00003476 66FE            	  1538:             bne.s *               * branch if Z clear
                            	  1539: 
                            	  1540: 
                            	  1541: *             EA = (An)  - BYTE only
00:00003478 7A00            	  1542:             move.l #0,d5              * populate bit.s number to test
00:0000347A 7C01            	  1543:             move.l #1,d6              * populate bit.s number to test
00:0000347C 7E07            	  1544:             move.l #7,d7              * populate bit.s number to test
00:0000347E 307C0100        	  1545:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003482 4210            	  1546:             move.b #$00,(a0)          * populate test data
00:00003484 0BD0            	  1547:             bset.b d5,(a0)
00:00003486 66FE            	  1548:             bne.s *               * branch if Z clear
00:00003488 0DD0            	  1549:             bset.b d6,(a0)            *
00:0000348A 66FE            	  1550:             bne.s *               * branch if Z clear
00:0000348C 0FD0            	  1551:             bset.b d7,(a0)            *
00:0000348E 66FE            	  1552:             bne.s *               * branch if Z clear
00:00003490 0C100083        	  1553:             cmpi.b #$83,(a0)
00:00003494 66FE            	  1554:             bne.s *               * branch if Z clear
                            	  1555: 
                            	  1556: 
                            	  1557: *             EA = (An)+  - BYTE only
00:00003496 307C0100        	  1558:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000349A 4218            	  1559:             move.b #$00,(a0)+         * populate test data
00:0000349C 4218            	  1560:             move.b #$00,(a0)+         * populate test data
00:0000349E 4218            	  1561:             move.b #$00,(a0)+         * populate test data
00:000034A0 307C0100        	  1562:             move.l #$00000100,a0      * point to memory to address 0x100
00:000034A4 0BD8            	  1563:             bset.b d5,(a0)+
00:000034A6 66FE            	  1564:             bne.s *               * branch if Z clear
00:000034A8 0DD8            	  1565:             bset.b d6,(a0)+           *
00:000034AA 66FE            	  1566:             bne.s *               * branch if Z clear
00:000034AC 0FD8            	  1567:             bset.b d7,(a0)+           *
00:000034AE 66FE            	  1568:             bne.s *               * branch if Z clear
00:000034B0 307C0100        	  1569:             move.l #$00000100,a0      * point to memory to address 0x100
00:000034B4 0C180001        	  1570:             cmpi.b #$01,(a0)+
00:000034B8 66FE            	  1571:             bne.s *               * branch if Z clear
00:000034BA 0C180002        	  1572:             cmpi.b #$02,(a0)+
00:000034BE 66FE            	  1573:             bne.s *               * branch if Z clear
00:000034C0 0C180080        	  1574:             cmpi.b #$80,(a0)+
00:000034C4 66FE            	  1575:             bne.s *               * branch if Z clear
                            	  1576: 
                            	  1577: *             EA = -(An)  - BYTE only
00:000034C6 307C0100        	  1578:             move.l #$00000100,a0      * point to memory to address
00:000034CA 4218            	  1579:             move.b #$00,(a0)+         * populate test data
00:000034CC 4218            	  1580:             move.b #$00,(a0)+         * populate test data
00:000034CE 4218            	  1581:             move.b #$00,(a0)+         * populate test data
00:000034D0 307C0103        	  1582:             move.l #$00000103,a0      * point to memory to address
00:000034D4 0BE0            	  1583:             bset.b d5,-(a0)
00:000034D6 66FE            	  1584:             bne.s *               * branch if Z clear
00:000034D8 0DE0            	  1585:             bset.b d6,-(a0)           *
00:000034DA 66FE            	  1586:             bne.s *               * branch if Z clear
00:000034DC 0FE0            	  1587:             bset.b d7,-(a0)           *
00:000034DE 66FE            	  1588:             bne.s *               * branch if Z clear
00:000034E0 307C0103        	  1589:             move.l #$00000103,a0      * point to memory to address 0x100
00:000034E4 0C200001        	  1590:             cmpi.b #$01,-(a0)
00:000034E8 66FE            	  1591:             bne.s *               * branch if Z clear
00:000034EA 0C200002        	  1592:             cmpi.b #$02,-(a0)
00:000034EE 66FE            	  1593:             bne.s *               * branch if Z clear
00:000034F0 0C200080        	  1594:             cmpi.b #$80,-(a0)
00:000034F4 66FE            	  1595:             bne.s *               * branch if Z clear
                            	  1596: 
                            	  1597: *             EA = n(An)  - BYTE only
00:000034F6 307C0100        	  1598:             move.l #$00000100,a0      * point to memory to address
00:000034FA 4218            	  1599:             move.b #$00,(a0)+         * populate test data
00:000034FC 4218            	  1600:             move.b #$00,(a0)+         * populate test data
00:000034FE 4218            	  1601:             move.b #$00,(a0)+         * populate test data
00:00003500 307C0100        	  1602:             move.l #$00000100,a0      * point to memory to address
00:00003504 0BD0            	  1603:             bset.b d5,0(a0)
00:00003506 66FE            	  1604:             bne.s *               * branch if Z clear
00:00003508 0DE80001        	  1605:             bset.b d6,1(a0)           *
00:0000350C 66FE            	  1606:             bne.s *               * branch if Z clear
00:0000350E 0FE80002        	  1607:             bset.b d7,2(a0)           *
00:00003512 66FE            	  1608:             bne.s *               * branch if Z clear
00:00003514 307C0100        	  1609:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003518 0C180001        	  1610:             cmpi.b #$01,(a0)+
00:0000351C 66FE            	  1611:             bne.s *               * branch if Z clear
00:0000351E 0C180002        	  1612:             cmpi.b #$02,(a0)+
00:00003522 66FE            	  1613:             bne.s *               * branch if Z clear
00:00003524 0C180080        	  1614:             cmpi.b #$80,(a0)+
00:00003528 66FE            	  1615:             bne.s *               * branch if Z clear
                            	  1616: 
                            	  1617: *             EA = n(An,R.W)  - BYTE only
00:0000352A 307C0100        	  1618:             move.l #$00000100,a0      * point to memory to address
00:0000352E 4218            	  1619:             move.b #$00,(a0)+         * populate test data
00:00003530 4218            	  1620:             move.b #$00,(a0)+         * populate test data
00:00003532 4218            	  1621:             move.b #$00,(a0)+         * populate test data
00:00003534 4218            	  1622:             move.b #$00,(a0)+         * populate test data
00:00003536 4218            	  1623:             move.b #$00,(a0)+         * populate test data
00:00003538 4218            	  1624:             move.b #$00,(a0)+         * populate test data
00:0000353A 4218            	  1625:             move.b #$00,(a0)+         * populate test data
00:0000353C 4218            	  1626:             move.b #$00,(a0)+         * populate test data
00:0000353E 4218            	  1627:             move.b #$00,(a0)+         * populate test data
00:00003540 4218            	  1628:             move.b #$00,(a0)+         * populate test data
00:00003542 4218            	  1629:             move.b #$00,(a0)+         * populate test data
00:00003544 4218            	  1630:             move.b #$00,(a0)+         * populate test data
00:00003546 307C0100        	  1631:             move.l #$00000100,a0      * point to memory to address
00:0000354A 93C9            	  1632:             move.l #$00000000,a1      * point to memory to address
00:0000354C 347C0001        	  1633:             move.l #$00000001,a2      * point to memory to address
00:00003550 7000            	  1634:             moveq  #$00000000,d0      * point to memory to address
00:00003552 7201            	  1635:             moveq  #$00000001,d1      * point to memory to address
00:00003554 0BF00000        	  1636:             bset.b d5,0(a0,d0.w)
00:00003558 66FE            	  1637:             bne.s *               * branch if Z clear
00:0000355A 0DF01000        	  1638:             bset.b d6,0(a0,d1.w)      *
00:0000355E 66FE            	  1639:             bne.s *               * branch if Z clear
00:00003560 0FF01001        	  1640:             bset.b d7,1(a0,d1.w)      *
00:00003564 66FE            	  1641:             bne.s *               * branch if Z clear
                            	  1642: *             EA = n(An,R.L)  - BYTE only
00:00003566 0BF00802        	  1643:             bset.b d5,2(a0,d0.l)
00:0000356A 66FE            	  1644:             bne.s *               * branch if Z clear
00:0000356C 0DF01803        	  1645:             bset.b d6,3(a0,d1.l)      *
00:00003570 66FE            	  1646:             bne.s *               * branch if Z clear
00:00003572 0FF01804        	  1647:             bset.b d7,4(a0,d1.l)      *
00:00003576 66FE            	  1648:             bne.s *               * branch if Z clear
                            	  1649: *             EA = n(An,A.W)  - BYTE only
00:00003578 0BF09005        	  1650:             bset.b d5,5(a0,a1.w)
00:0000357C 66FE            	  1651:             bne.s *               * branch if Z clear
00:0000357E 0DF0A006        	  1652:             bset.b d6,6(a0,a2.w)      *
00:00003582 66FE            	  1653:             bne.s *               * branch if Z clear
00:00003584 0FF0A007        	  1654:             bset.b d7,7(a0,a2.w)      *
00:00003588 66FE            	  1655:             bne.s *               * branch if Z clear
                            	  1656: *             EA = n(An,A.L)  - BYTE only
00:0000358A 0BF09808        	  1657:             bset.b d5,8(a0,a1.l)
00:0000358E 66FE            	  1658:             bne.s *               * branch if Z clear
00:00003590 0DF0A809        	  1659:             bset.b d6,9(a0,a2.l)      *
00:00003594 66FE            	  1660:             bne.s *               * branch if Z clear
00:00003596 0FF0A80A        	  1661:             bset.b d7,10(a0,a2.l)      *
00:0000359A 66FE            	  1662:             bne.s *               * branch if Z clear
00:0000359C 307C0100        	  1663:             move.l #$00000100,a0      * point to memory to address 0x100
00:000035A0 0C9801028100    	  1664:             cmpi.l #$01028100,(a0)+
00:000035A6 66FE            	  1665:             bne.s *               * branch if Z clear
00:000035A8 0C9802810002    	  1666:             cmpi.l #$02810002,(a0)+
00:000035AE 66FE            	  1667:             bne.s *
                            	  1668: 
                            	  1669: 
                            	  1670: *             EA = x.W  - BYTE only
00:000035B0 307C0100        	  1671:             move.l #$00000100,a0      * point to memory to address
00:000035B4 4218            	  1672:             move.b #$00,(a0)+         * populate test data
00:000035B6 4218            	  1673:             move.b #$00,(a0)+         * populate test data
00:000035B8 4218            	  1674:             move.b #$00,(a0)+         * populate test data
00:000035BA 0BF80100        	  1675:             bset.b d5,$0100
00:000035BE 66FE            	  1676:             bne.s *               * branch if Z clear
00:000035C0 0DF80100        	  1677:             bset.b d6,$0100           *
00:000035C4 66FE            	  1678:             bne.s *               * branch if Z clear
00:000035C6 0FF80100        	  1679:             bset.b d7,$0100           *
00:000035CA 66FE            	  1680:             bne.s *               * branch if Z clear
00:000035CC 307C0100        	  1681:             move.l #$00000100,a0      * point to memory to address
00:000035D0 0C180083        	  1682:             cmpi.b #$83,(a0)+
00:000035D4 66FE            	  1683:             bne.s *               * branch if Z clear
                            	  1684: 
                            	  1685: *             EA = x.L  - BYTE only
00:000035D6 207C0000F100    	  1686:             move.l #$F100,a0      * point to memory to address 0x100
00:000035DC 4218            	  1687:             move.b #$00,(a0)+         * populate test data
00:000035DE 4218            	  1688:             move.b #$00,(a0)+         * populate test data
00:000035E0 4218            	  1689:             move.b #$00,(a0)+         * populate test data
00:000035E2 0BF90000F100    	  1690:             bset.b d5,$F100
00:000035E8 66FE            	  1691:             bne.s *               * branch if Z clear
00:000035EA 0DF90000F100    	  1692:             bset.b d6,$F100       *
00:000035F0 66FE            	  1693:             bne.s *               * branch if Z clear
00:000035F2 0FF90000F100    	  1694:             bset.b d7,$F100       *
00:000035F8 66FE            	  1695:             bne.s *               * branch if Z clear
00:000035FA 207C0000F100    	  1696:             move.l #$F100,a0      * point to memory to address 0x100
00:00003600 0C100083        	  1697:             cmpi.b #$83,(a0)
00:00003604 66FE            	  1698:             bne.s *               * branch if Z clear
                            	  1699: 
                            	  1700: 
00:00003606 4E75            	  1701:     rts
                            	  1702: 
                            	  1703: *-----------------------------------------------------------
                            	  1704: *-----------------------------------------------------------
                            	  1705: * OPCODE : MOVEP
                            	  1706: *-----------------------------------------------------------
                            	  1707: *-----------------------------------------------------------
                            	  1708: op_MOVEP:
                            	  1709: 
                            	  1710: * Dn --> x(An)
00:00003608 307C0100        	  1711:             move.l #$00000100,a0
00:0000360C 203C12345678    	  1712:             move.l #$12345678,d0
00:00003612 223CAABBCCDD    	  1713:             move.l #$AABBCCDD,d1
00:00003618 4290            	  1714:             move.l #0,(a0)
00:0000361A 42A80004        	  1715:             move.l #0,4(a0)
                            	  1716: 
00:0000361E 01880000        	  1717:             movep.w d0,0(a0)      * even offset
00:00003622 03880001        	  1718:             movep.w d1,1(a0)      * odd offset
                            	  1719: 
00:00003626 01C80004        	  1720:             movep.l d0,4(a0)      * even offset
00:0000362A 03C80005        	  1721:             movep.l d1,5(a0)      * odd offset
                            	  1722: 
00:0000362E 0C9056CC78DD    	  1723:             cmpi.l #$56CC78DD,(a0)
00:00003634 66FE            	  1724:             bne.s *
00:00003636 0CA812AA34BB0004	  1725:             cmpi.l #$12AA34BB,4(a0)
00:0000363E 66FE            	  1726:             bne.s *
00:00003640 0CA856CC78DD0008	  1727:             cmpi.l #$56CC78DD,8(a0)
00:00003648 66FE            	  1728:             bne.s *
                            	  1729: 
                            	  1730: 
                            	  1731: * x(An)--> Dn
00:0000364A 203C5A5A5A5A    	  1732:             move.l #$5a5a5a5a,d0
00:00003650 223C5A5A5A5A    	  1733:             move.l #$5a5a5a5a,d1
00:00003656 243C5A5A5A5A    	  1734:             move.l #$5a5a5a5a,d2
00:0000365C 263C5A5A5A5A    	  1735:             move.l #$5a5a5a5a,d3
                            	  1736: 
00:00003662 01080000        	  1737:             movep.w 0(a0),d0      * even offset
00:00003666 03080001        	  1738:             movep.w 1(a0),d1      * odd offset
                            	  1739: 
00:0000366A 05480004        	  1740:             movep.l 4(a0),d2      * even offset
00:0000366E 07480005        	  1741:             movep.l 5(a0),d3      * odd offset
                            	  1742: 
00:00003672 0C805A5A5678    	  1743:             cmpi.l #$5a5a5678,d0
00:00003678 66FE            	  1744:             bne.s *
00:0000367A 0C815A5ACCDD    	  1745:             cmpi.l #$5a5aCCDD,d1
00:00003680 66FE            	  1746:             bne.s *
00:00003682 0C8212345678    	  1747:             cmpi.l #$12345678,d2
00:00003688 66FE            	  1748:             bne.s *
00:0000368A 0C83AABBCCDD    	  1749:             cmpi.l #$AABBCCDD,d3
00:00003690 66FE            	  1750:             bne.s *
                            	  1751: 
00:00003692 4E75            	  1752:             rts
                            	  1753: 
                            	  1754: 
                            	  1755: 
                            	  1756: *-----------------------------------------------------------
                            	  1757: *-----------------------------------------------------------
                            	  1758: * OPCODE : BOOL_I
                            	  1759: *-----------------------------------------------------------
                            	  1760: *-----------------------------------------------------------
                            	  1761: op_BOOL_I:
                            	  1762: 
                            	  1763: *     Dn -- BYTE
00:00003694 203C12345678    	  1764:             move.l #$12345678,d0
00:0000369A 44FC000F        	  1765:             move.w #$000F,CCR          * pre-set Flags
00:0000369E 000000FF        	  1766:             ori.b  #$FF,d0
00:000036A2 0A00005A        	  1767:             eori.b #$5A,d0
00:000036A6 020000F0        	  1768:             andi.b #$F0,d0
00:000036AA 69FE            	  1769:             bvs.s *                       * Check V,C are cleared
00:000036AC 65FE            	  1770:             bcs.s *
00:000036AE 6AFE            	  1771:             bpl.s *                       * Verify if N flag is set
00:000036B0 4200            	  1772:             andi.b #$00,d0
00:000036B2 6BFE            	  1773:             bmi.s *                       * Verify if N flag is cleared
00:000036B4 66FE            	  1774:             bne.s *                       * Verify if Z flag is set
                            	  1775: 
                            	  1776: *     Dn -- WORD
00:000036B6 223C12345678    	  1777:             move.l #$12345678,d1
00:000036BC 44FC000F        	  1778:             move.w #$000F,CCR          * pre-set Flags
00:000036C0 0041FFFF        	  1779:             ori.w  #$FFFF,d1
00:000036C4 0A415A5A        	  1780:             eori.w #$5A5A,d1
00:000036C8 0241F0F0        	  1781:             andi.w #$F0F0,d1
00:000036CC 69FE            	  1782:             bvs.s *                       * Check V,C are cleared
00:000036CE 65FE            	  1783:             bcs.s *
00:000036D0 6AFE            	  1784:             bpl.s *                       * Verify if N flag is set
00:000036D2 4241            	  1785:             andi.w #$0000,d1
00:000036D4 6BFE            	  1786:             bmi.s *                       * Verify if N flag is cleared
00:000036D6 66FE            	  1787:             bne.s *                       * Verify if Z flag is set
                            	  1788: 
                            	  1789: *     Dn -- LONG
00:000036D8 243C12345678    	  1790:             move.l #$12345678,d2
00:000036DE 44FC000F        	  1791:             move.w #$000F,CCR          * pre-set Flags
00:000036E2 0082FFFFFFFF    	  1792:             ori.l  #$FFFFFFFF,d2
00:000036E8 0A825A5A5A5A    	  1793:             eori.l #$5A5A5A5A,d2
00:000036EE 0282F0F0F0F0    	  1794:             andi.l #$F0F0F0F0,d2
00:000036F4 69FE            	  1795:             bvs.s *                       * Check V,C are cleared
00:000036F6 65FE            	  1796:             bcs.s *
00:000036F8 6AFE            	  1797:             bpl.s *                       * Verify if N flag is set
00:000036FA 4282            	  1798:             andi.l #$00000000,d2
00:000036FC 6BFE            	  1799:             bmi.s *                       * Verify if N flag is cleared
00:000036FE 66FE            	  1800:             bne.s *                       * Verify if Z flag is set
                            	  1801: 
                            	  1802: 
                            	  1803: *     (An) -- BYTE
00:00003700 307C0100        	  1804:             move.l #$00000100,a0
00:00003704 20BC12345678    	  1805:             move.l #$12345678,(a0)
00:0000370A 44FC000F        	  1806:             move.w #$000F,CCR          * pre-set Flags
00:0000370E 001000FF        	  1807:             ori.b  #$FF,(a0)
00:00003712 0A10005A        	  1808:             eori.b #$5A,(a0)
00:00003716 021000F0        	  1809:             andi.b #$F0,(a0)
00:0000371A 69FE            	  1810:             bvs.s *                       * Check V,C are cleared
00:0000371C 65FE            	  1811:             bcs.s *
00:0000371E 6AFE            	  1812:             bpl.s *                       * Verify if N flag is set
00:00003720 4210            	  1813:             andi.b #$00,(a0)
00:00003722 6BFE            	  1814:             bmi.s *                       * Verify if N flag is cleared
00:00003724 66FE            	  1815:             bne.s *                       * Verify if Z flag is set
00:00003726 4A10            	  1816:             cmpi.b #$00,(a0)
00:00003728 66FE            	  1817:             bne.s *                       * Verify if Z flag is set
                            	  1818: 
                            	  1819: *     (An) -- WORD
00:0000372A 20BC12345678    	  1820:             move.l #$12345678,(a0)
00:00003730 44FC000F        	  1821:             move.w #$000F,CCR          * pre-set Flags
00:00003734 0050FFFF        	  1822:             ori.w  #$FFFF,(a0)
00:00003738 0A505A5A        	  1823:             eori.w #$5A5A,(a0)
00:0000373C 0250F0F0        	  1824:             andi.w #$F0F0,(a0)
00:00003740 69FE            	  1825:             bvs.s *                       * Check V,C are cleared
00:00003742 65FE            	  1826:             bcs.s *
00:00003744 6AFE            	  1827:             bpl.s *                       * Verify if N flag is set
00:00003746 4250            	  1828:             andi.w #$0000,(a0)
00:00003748 6BFE            	  1829:             bmi.s *                       * Verify if N flag is cleared
00:0000374A 66FE            	  1830:             bne.s *                       * Verify if Z flag is set
00:0000374C 4A50            	  1831:             cmpi.w #$00,(a0)
00:0000374E 66FE            	  1832:             bne.s *                       * Verify if Z flag is set
                            	  1833: 
                            	  1834: *     (An) -- LONG
00:00003750 20BC12345678    	  1835:             move.l #$12345678,(a0)
00:00003756 44FC000F        	  1836:             move.w #$000F,CCR          * pre-set Flags
00:0000375A 0090FFFFFFFF    	  1837:             ori.l  #$FFFFFFFF,(a0)
00:00003760 0A905A5A5A5A    	  1838:             eori.l #$5A5A5A5A,(a0)
00:00003766 0290F0F0F0F0    	  1839:             andi.l #$F0F0F0F0,(a0)
00:0000376C 69FE            	  1840:             bvs.s *                       * Check V,C are cleared
00:0000376E 65FE            	  1841:             bcs.s *
00:00003770 6AFE            	  1842:             bpl.s *                       * Verify if N flag is set
00:00003772 4290            	  1843:             andi.l #$00000000,(a0)
00:00003774 6BFE            	  1844:             bmi.s *                       * Verify if N flag is cleared
00:00003776 66FE            	  1845:             bne.s *                       * Verify if Z flag is set
00:00003778 4A90            	  1846:             cmpi.l #$00,(a0)
00:0000377A 66FE            	  1847:             bne.s *                       * Verify if Z flag is set
                            	  1848: 
                            	  1849: 
                            	  1850: 
                            	  1851: *     (An)+ -- BYTE
00:0000377C 307C0100        	  1852:             move.l #$00000100,a0
00:00003780 20BC00A5FF88    	  1853:             move.l #$00A5FF88,(a0)
00:00003786 44FC000F        	  1854:             move.w #$000F,CCR          * pre-set Flags
                            	  1855: 
00:0000378A 001800F5        	  1856:             ori.b  #$F5,(a0)+
00:0000378E 6AFE            	  1857:             bpl.s *                       * Verify if N flag is set
00:00003790 67FE            	  1858:             beq.s *                       * Verify if Z flag is cleared
                            	  1859: 
00:00003792 4618            	  1860:             eori.b #$FF,(a0)+
00:00003794 6BFE            	  1861:             bmi.s *                       * Verify if N flag is cleared
00:00003796 67FE            	  1862:             beq.s *                       * Verify if Z flag is cleared
                            	  1863: 
00:00003798 021800AA        	  1864:             andi.b #$AA,(a0)+
00:0000379C 6AFE            	  1865:             bpl.s *                       * Verify if N flag is set
00:0000379E 67FE            	  1866:             beq.s *                       * Verify if Z flag is cleared
                            	  1867: 
00:000037A0 307C0100        	  1868:             move.l #$00000100,a0
00:000037A4 0C90F55AAA88    	  1869:             cmpi.l #$F55AAA88,(a0)
00:000037AA 66FE            	  1870:             bne.s *                       * Verify if Z flag is set
                            	  1871: 
                            	  1872: 
                            	  1873: *     (An)+ -- WORD
00:000037AC 307C0100        	  1874:             move.l #$00000100,a0
00:000037B0 327C0104        	  1875:             move.l #$00000104,a1
00:000037B4 20BC00005A5A    	  1876:             move.l #$00005a5a,(a0)
00:000037BA 22BC12345678    	  1877:             move.l #$12345678,(a1)
00:000037C0 44FC000F        	  1878:             move.w #$000F,CCR          * pre-set Flags
                            	  1879: 
00:000037C4 00585678        	  1880:             ori.w  #$5678,(a0)+
00:000037C8 6BFE            	  1881:             bmi.s *                       * Verify if N flag is cleared
00:000037CA 67FE            	  1882:             beq.s *                       * Verify if Z flag is cleared
                            	  1883: 
00:000037CC 4658            	  1884:             eori.w #$FFFF,(a0)+
00:000037CE 6AFE            	  1885:             bpl.s *                       * Verify if N flag is set
00:000037D0 67FE            	  1886:             beq.s *                       * Verify if Z flag is cleared
                            	  1887: 
00:000037D2 0258A55A        	  1888:             andi.w #$A55A,(a0)+
00:000037D6 6BFE            	  1889:             bmi.s *                       * Verify if N flag is cleared
00:000037D8 67FE            	  1890:             beq.s *                       * Verify if Z flag is cleared
                            	  1891: 
00:000037DA 307C0100        	  1892:             move.l #$00000100,a0
00:000037DE 0C905678A5A5    	  1893:             cmpi.l #$5678a5a5,(a0)
00:000037E4 307C0104        	  1894:             move.l #$00000104,a0
00:000037E8 0C9000105678    	  1895:             cmpi.l #$00105678,(a0)
00:000037EE 66FE            	  1896:             bne.s *                       * Verify if Z flag is set
                            	  1897: 
                            	  1898: *     (An)+ -- LONG
00:000037F0 307C0100        	  1899:             move.l #$00000100,a0
00:000037F4 4298            	  1900:             move.l #$00000000,(a0)+
00:000037F6 20FC5A5A5A5A    	  1901:             move.l #$5a5a5a5a,(a0)+
00:000037FC 20FCFFFFFFFF    	  1902:             move.l #$FFFFFFFF,(a0)+
00:00003802 307C0100        	  1903:             move.l #$00000100,a0
00:00003806 44FC000F        	  1904:             move.w #$000F,CCR          * pre-set Flags
                            	  1905: 
00:0000380A 009812345678    	  1906:             ori.l  #$12345678,(a0)+
00:00003810 6BFE            	  1907:             bmi.s *                       * Verify if N flag is cleared
00:00003812 67FE            	  1908:             beq.s *                       * Verify if Z flag is cleared
                            	  1909: 
00:00003814 4698            	  1910:             eori.l #$FFFFFFFF,(a0)+
00:00003816 6AFE            	  1911:             bpl.s *                       * Verify if N flag is set
00:00003818 67FE            	  1912:             beq.s *                       * Verify if Z flag is cleared
                            	  1913: 
00:0000381A 0298A5A5A55A    	  1914:             andi.l #$A5A5A55A,(a0)+
00:00003820 6AFE            	  1915:             bpl.s *                       * Verify if N flag is set
00:00003822 67FE            	  1916:             beq.s *                       * Verify if Z flag is cleared
                            	  1917: 
00:00003824 307C0100        	  1918:             move.l #$00000100,a0
00:00003828 0C9812345678    	  1919:             cmpi.l #$12345678,(a0)+
00:0000382E 0C98A5A5A5A5    	  1920:             cmpi.l #$a5a5a5a5,(a0)+
00:00003834 0C98A5A5A55A    	  1921:             cmpi.l #$a5a5a55a,(a0)+
00:0000383A 66FE            	  1922:             bne.s *                       * Verify if Z flag is set
                            	  1923: 
00:0000383C 4E75            	  1924:             rts
                            	  1925: 
                            	  1926: 
                            	  1927: *-----------------------------------------------------------
                            	  1928: *-----------------------------------------------------------
                            	  1929: * OPCODE : BSR
                            	  1930: *-----------------------------------------------------------
                            	  1931: *-----------------------------------------------------------
                            	  1932: 
                            	  1933: 
00:0000383E 223C11111111    	  1934: BSR_CLOSE1:     move.l #$11111111,d1
00:00003844 4E75            	  1935:                 rts
                            	  1936: 
                            	  1937: 
                            	  1938: 
00:00003846 61F6            	  1939: op_BSR:         bsr BSR_CLOSE1        * Negative 8-bit.s displacement
00:00003848 612A            	  1940:                 bsr BSR_CLOSE2        * Positive 8-bit.s displacement
00:0000384A 6100EF20        	  1941:                 bsr.w BSR_FAR1          * Negative 16-bit.s displacement
00:0000384E 6100144E        	  1942:                 bsr.w BSR_FAR2          * Positive 16-bit.s displacement
                            	  1943: 
00:00003852 0C8111111111    	  1944:                 cmpi.l #$11111111,d1
00:00003858 66FE            	  1945:                 bne.s *
00:0000385A 0C8222222222    	  1946:                 cmpi.l #$22222222,d2
00:00003860 66FE            	  1947:                 bne.s *
00:00003862 0C8333333333    	  1948:                 cmpi.l #$33333333,d3
00:00003868 66FE            	  1949:                 bne.s *
00:0000386A 0C8444444444    	  1950:                 cmpi.l #$44444444,d4
00:00003870 66FE            	  1951:                 bne.s *
                            	  1952: 
00:00003872 4E75            	  1953:                 rts
                            	  1954: 
                            	  1955: 
00:00003874 243C22222222    	  1956: BSR_CLOSE2:     move.l #$22222222,d2
00:0000387A 4E75            	  1957:                 rts
                            	  1958: 
                            	  1959: *-----------------------------------------------------------
                            	  1960: *-----------------------------------------------------------
                            	  1961: * OPCODE : op_CMP_I
                            	  1962: *-----------------------------------------------------------
                            	  1963: *-----------------------------------------------------------
                            	  1964: op_CMP_I:
                            	  1965: 
00:0000387C 307C0100        	  1966:             move.l #$00000100,a0
00:00003880 20BC00000100    	  1967:             move.l #$00000100,(a0)
                            	  1968: 
                            	  1969: *     REGISTER - BYTE
00:00003886 7080            	  1970:             move.l #$FFFFFF80,d0
00:00003888 0C000080        	  1971:             cmpi.b #$80,d0
00:0000388C 66FE            	  1972:             bne.s *                       * Check Z Flag  beq/bne
00:0000388E 6BFE            	  1973:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003890 65FE            	  1974:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003892 69FE            	  1975:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1976: 
00:00003894 223CFFFFF000    	  1977:             move.l #$FFFFF000,d1
00:0000389A 4A01            	  1978:             cmpi.b #$00,d1
00:0000389C 66FE            	  1979:             bne.s *                       * Check Z Flag  beq/bne
00:0000389E 6BFE            	  1980:             bmi.s *                       * Check N Flag  bmi/bpl
00:000038A0 65FE            	  1981:             bcs.s *                       * Check C Flag  bcc/bcs
00:000038A2 69FE            	  1982:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1983: 
00:000038A4 7481D442        	  1984:             move.l #$FFFFFF02,d2
00:000038A8 0C0200FF        	  1985:             cmpi.b #$FF,d2
00:000038AC 67FE            	  1986:             beq.s *                       * Check Z Flag  beq/bne
00:000038AE 6BFE            	  1987:             bmi.s *                       * Check N Flag  bmi/bpl
00:000038B0 64FE            	  1988:             bcc.s *                       * Check C Flag  bcc/bcs
00:000038B2 69FE            	  1989:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1990: 
00:000038B4 263CFFFFFF7F    	  1991:             move.l #$FFFFFF7F,d3
00:000038BA 0C0300FF        	  1992:             cmpi.b #$FF,d3
00:000038BE 67FE            	  1993:             beq.s *                       * Check Z Flag  beq/bne
00:000038C0 6AFE            	  1994:             bpl.s *                       * Check N Flag  bmi/bpl
00:000038C2 64FE            	  1995:             bcc.s *                       * Check C Flag  bcc/bcs
00:000038C4 68FE            	  1996:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  1997: 
                            	  1998: 
                            	  1999: *     REGISTER - WORD
00:000038C6 203CFFFF8000    	  2000:             move.l #$FFFF8000,d0
00:000038CC 0C408000        	  2001:             cmpi.w #$8000,d0
00:000038D0 66FE            	  2002:             bne.s *                       * Check Z Flag  beq/bne
00:000038D2 6BFE            	  2003:             bmi.s *                       * Check N Flag  bmi/bpl
00:000038D4 65FE            	  2004:             bcs.s *                       * Check C Flag  bcc/bcs
00:000038D6 69FE            	  2005:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2006: 
00:000038D8 223CFFF00000    	  2007:             move.l #$FFF00000,d1
00:000038DE 4A41            	  2008:             cmpi.w #$0000,d1
00:000038E0 66FE            	  2009:             bne.s *                       * Check Z Flag  beq/bne
00:000038E2 6BFE            	  2010:             bmi.s *                       * Check N Flag  bmi/bpl
00:000038E4 65FE            	  2011:             bcs.s *                       * Check C Flag  bcc/bcs
00:000038E6 69FE            	  2012:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2013: 
00:000038E8 243CFFFF0002    	  2014:             move.l #$FFFF0002,d2
00:000038EE 0C42FFFF        	  2015:             cmpi.w #$FFFF,d2
00:000038F2 67FE            	  2016:             beq.s *                       * Check Z Flag  beq/bne
00:000038F4 6BFE            	  2017:             bmi.s *                       * Check N Flag  bmi/bpl
00:000038F6 64FE            	  2018:             bcc.s *                       * Check C Flag  bcc/bcs
00:000038F8 69FE            	  2019:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2020: 
00:000038FA 263CFFFF7FFF    	  2021:             move.l #$FFFF7FFF,d3
00:00003900 0C43FFFF        	  2022:             cmpi.w #$FFFF,d3
00:00003904 67FE            	  2023:             beq.s *                       * Check Z Flag  beq/bne
00:00003906 6AFE            	  2024:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003908 64FE            	  2025:             bcc.s *                       * Check C Flag  bcc/bcs
00:0000390A 68FE            	  2026:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2027: 
                            	  2028: *     REGISTER - LONG
00:0000390C 203C80000000    	  2029:             move.l #$80000000,d0
00:00003912 0C8080000000    	  2030:             cmpi.l #$80000000,d0
00:00003918 66FE            	  2031:             bne.s *                       * Check Z Flag  beq/bne
00:0000391A 6BFE            	  2032:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000391C 65FE            	  2033:             bcs.s *                       * Check C Flag  bcc/bcs
00:0000391E 69FE            	  2034:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2035: 
00:00003920 7200            	  2036:             moveq  #$00000000,d1
00:00003922 4A81            	  2037:             cmpi.l #$00000000,d1
00:00003924 66FE            	  2038:             bne.s *                       * Check Z Flag  beq/bne
00:00003926 6BFE            	  2039:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003928 65FE            	  2040:             bcs.s *                       * Check C Flag  bcc/bcs
00:0000392A 69FE            	  2041:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2042: 
00:0000392C 7402            	  2043:             moveq  #$00000002,d2
00:0000392E 0C82FFFFFFFF    	  2044:             cmpi.l #$FFFFFFFF,d2
00:00003934 67FE            	  2045:             beq.s *                       * Check Z Flag  beq/bne
00:00003936 6BFE            	  2046:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003938 64FE            	  2047:             bcc.s *                       * Check C Flag  bcc/bcs
00:0000393A 69FE            	  2048:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2049: 
00:0000393C 263C7FFFFFFF    	  2050:             move.l #$7FFFFFFF,d3
00:00003942 0C83FFFFFFFF    	  2051:             cmpi.l #$FFFFFFFF,d3
00:00003948 67FE            	  2052:             beq.s *                       * Check Z Flag  beq/bne
00:0000394A 6AFE            	  2053:             bpl.s *                       * Check N Flag  bmi/bpl
00:0000394C 64FE            	  2054:             bcc.s *                       * Check C Flag  bcc/bcs
00:0000394E 68FE            	  2055:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2056: 
                            	  2057: 
                            	  2058: 
                            	  2059: 
                            	  2060: *     EA=x(An,Dn) - BYTE
00:00003950 307C0100        	  2061:             move.l #$00000100,a0
00:00003954 7E04            	  2062:             moveq  #$00000004,d7
                            	  2063: 
00:00003956 21BCFFFFFF80700C	  2064:             move.l #$FFFFFF80,12(a0,d7)
00:0000395E 21BCFFFFFF80700C	  2065:             move.l #$FFFFFF80,12(a0,d7)
00:00003966 0C300080700F    	  2066:             cmpi.b #$80,15(a0,d7)
00:0000396C 66FE            	  2067:             bne.s *                       * Check Z Flag  beq/bne
00:0000396E 6BFE            	  2068:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003970 65FE            	  2069:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003972 69FE            	  2070:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2071: 
00:00003974 21BCFFFFF000700C	  2072:             move.l #$FFFFF000,12(a0,d7)
00:0000397C 4A30700F        	  2073:             cmpi.b #$00,15(a0,d7)
00:00003980 66FE            	  2074:             bne.s *                       * Check Z Flag  beq/bne
00:00003982 6BFE            	  2075:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003984 65FE            	  2076:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003986 69FE            	  2077:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2078: 
00:00003988 21BCFFFFFF02700C	  2079:             move.l #$FFFFFF02,12(a0,d7)
00:00003990 0C3000FF700F    	  2080:             cmpi.b #$FF,15(a0,d7)
00:00003996 67FE            	  2081:             beq.s *                       * Check Z Flag  beq/bne
00:00003998 6BFE            	  2082:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000399A 64FE            	  2083:             bcc.s *                       * Check C Flag  bcc/bcs
00:0000399C 69FE            	  2084:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2085: 
00:0000399E 21BCFFFFFF7F700C	  2086:             move.l #$FFFFFF7F,12(a0,d7)
00:000039A6 0C3000FF700F    	  2087:             cmpi.b #$FF,15(a0,d7)
00:000039AC 67FE            	  2088:             beq.s *                       * Check Z Flag  beq/bne
00:000039AE 6AFE            	  2089:             bpl.s *                       * Check N Flag  bmi/bpl
00:000039B0 64FE            	  2090:             bcc.s *                       * Check C Flag  bcc/bcs
00:000039B2 68FE            	  2091:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2092: 
                            	  2093: 
                            	  2094: *     EA=x(An,Dn) - WORD
00:000039B4 21BCFFFF8000700C	  2095:             move.l #$FFFF8000,12(a0,d7)
00:000039BC 0C708000700E    	  2096:             cmpi.w #$8000,14(a0,d7)
00:000039C2 66FE            	  2097:             bne.s *                       * Check Z Flag  beq/bne
00:000039C4 6BFE            	  2098:             bmi.s *                       * Check N Flag  bmi/bpl
00:000039C6 65FE            	  2099:             bcs.s *                       * Check C Flag  bcc/bcs
00:000039C8 69FE            	  2100:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2101: 
00:000039CA 21BCFFF00000700C	  2102:             move.l #$FFF00000,12(a0,d7)
00:000039D2 4A70700E        	  2103:             cmpi.w #$0000,14(a0,d7)
00:000039D6 66FE            	  2104:             bne.s *                       * Check Z Flag  beq/bne
00:000039D8 6BFE            	  2105:             bmi.s *                       * Check N Flag  bmi/bpl
00:000039DA 65FE            	  2106:             bcs.s *                       * Check C Flag  bcc/bcs
00:000039DC 69FE            	  2107:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2108: 
00:000039DE 21BCFFFF0002700C	  2109:             move.l #$FFFF0002,12(a0,d7)
00:000039E6 0C70FFFF700E    	  2110:             cmpi.w #$FFFF,14(a0,d7)
00:000039EC 67FE            	  2111:             beq.s *                       * Check Z Flag  beq/bne
00:000039EE 6BFE            	  2112:             bmi.s *                       * Check N Flag  bmi/bpl
00:000039F0 64FE            	  2113:             bcc.s *                       * Check C Flag  bcc/bcs
00:000039F2 69FE            	  2114:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2115: 
00:000039F4 21BCFFFF7FFF700C	  2116:             move.l #$FFFF7FFF,12(a0,d7)
00:000039FC 0C70FFFF700E    	  2117:             cmpi.w #$FFFF,14(a0,d7)
00:00003A02 67FE            	  2118:             beq.s *                       * Check Z Flag  beq/bne
00:00003A04 6AFE            	  2119:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003A06 64FE            	  2120:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003A08 68FE            	  2121:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2122: 
                            	  2123: *     EA=x(An,Dn) - LONG
00:00003A0A 21BC80000000700C	  2124:             move.l #$80000000,12(a0,d7)
00:00003A12 0CB080000000700C	  2125:             cmpi.l #$80000000,12(a0,d7)
00:00003A1A 66FE            	  2126:             bne.s *                       * Check Z Flag  beq/bne
00:00003A1C 6BFE            	  2127:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A1E 65FE            	  2128:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003A20 69FE            	  2129:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2130: 
00:00003A22 42B0700C        	  2131:             move.l #$00000000,12(a0,d7)
00:00003A26 4AB0700C        	  2132:             cmpi.l #$00000000,12(a0,d7)
00:00003A2A 66FE            	  2133:             bne.s *                       * Check Z Flag  beq/bne
00:00003A2C 6BFE            	  2134:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A2E 65FE            	  2135:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003A30 69FE            	  2136:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2137: 
00:00003A32 21BC00000002700C	  2138:             move.l #$00000002,12(a0,d7)
00:00003A3A 0CB0FFFFFFFF700C	  2139:             cmpi.l #$FFFFFFFF,12(a0,d7)
00:00003A42 67FE            	  2140:             beq.s *                       * Check Z Flag  beq/bne
00:00003A44 6BFE            	  2141:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A46 64FE            	  2142:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003A48 69FE            	  2143:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2144: 
00:00003A4A 21BC7FFFFFFF700C	  2145:             move.l #$7FFFFFFF,12(a0,d7)
00:00003A52 0CB0FFFFFFFF700C	  2146:             cmpi.l #$FFFFFFFF,12(a0,d7)
00:00003A5A 67FE            	  2147:             beq.s *                       * Check Z Flag  beq/bne
00:00003A5C 6AFE            	  2148:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003A5E 64FE            	  2149:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003A60 68FE            	  2150:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2151: 
                            	  2152: 
                            	  2153: 
                            	  2154: 
00:00003A62 4E75            	  2155:             rts
                            	  2156: 
                            	  2157: 
                            	  2158: 
                            	  2159: *-----------------------------------------------------------
                            	  2160: *-----------------------------------------------------------
                            	  2161: * OPCODE : ADD_I
                            	  2162: *-----------------------------------------------------------
                            	  2163: *-----------------------------------------------------------
                            	  2164: op_ADD_I:
                            	  2165: 
                            	  2166: *     EA = Dn  - Byte
00:00003A64 203C12345678    	  2167:             move.l #$12345678,d0      * populate test data
00:00003A6A 06000000        	  2168:             addi.b #0,d0
00:00003A6E 67FE            	  2169:             beq.s *                       * Check Z Flag  beq/bne
00:00003A70 6BFE            	  2170:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A72 65FE            	  2171:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003A74 69FE            	  2172:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003A76 06000010        	  2173:             addi.b #$10,d0
00:00003A7A 67FE            	  2174:             beq.s *                       * Check Z Flag  beq/bne
00:00003A7C 6AFE            	  2175:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003A7E 65FE            	  2176:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003A80 68FE            	  2177:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003A82 060000A5        	  2178:             addi.b #$A5,d0
00:00003A86 67FE            	  2179:             beq.s *                       * Check Z Flag  beq/bne
00:00003A88 6BFE            	  2180:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A8A 64FE            	  2181:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003A8C 68FE            	  2182:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003A8E 0C00002D        	  2183:             cmpi.b #$2D,d0
00:00003A92 66FE            	  2184:             bne.s *                       * Check Z Flag  beq/bne
                            	  2185: 
                            	  2186: *     EA = Dn  - WORD
00:00003A94 203C12345678    	  2187:             move.l #$12345678,d0      * populate test data
00:00003A9A 06400000        	  2188:             addi.w #0,d0
00:00003A9E 67FE            	  2189:             beq.s *                       * Check Z Flag  beq/bne
00:00003AA0 6BFE            	  2190:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003AA2 65FE            	  2191:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003AA4 69FE            	  2192:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003AA6 06407000        	  2193:             addi.w #$7000,d0
00:00003AAA 67FE            	  2194:             beq.s *                       * Check Z Flag  beq/bne
00:00003AAC 6AFE            	  2195:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003AAE 65FE            	  2196:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003AB0 68FE            	  2197:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003AB2 0640A55A        	  2198:             addi.w #$A55A,d0
00:00003AB6 67FE            	  2199:             beq.s *                       * Check Z Flag  beq/bne
00:00003AB8 6BFE            	  2200:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003ABA 64FE            	  2201:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003ABC 68FE            	  2202:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003ABE 0C406BD2        	  2203:             cmpi.w #$6BD2,d0
00:00003AC2 66FE            	  2204:             bne.s *                       * Check Z Flag  beq/bne
                            	  2205: 
                            	  2206: *     EA = Dn  - LONG
00:00003AC4 203C12345678    	  2207:             move.l #$12345678,d0      * populate test data
00:00003ACA 068000000000    	  2208:             addi.l #0,d0
00:00003AD0 67FE            	  2209:             beq.s *                       * Check Z Flag  beq/bne
00:00003AD2 6BFE            	  2210:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003AD4 65FE            	  2211:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003AD6 69FE            	  2212:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003AD8 0680F0000000    	  2213:             addi.l #$F0000000,d0
00:00003ADE 67FE            	  2214:             beq.s *                       * Check Z Flag  beq/bne
00:00003AE0 6BFE            	  2215:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003AE2 64FE            	  2216:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003AE4 69FE            	  2217:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003AE6 0680855AA55A    	  2218:             addi.l #$855AA55A,d0
00:00003AEC 67FE            	  2219:             beq.s *                       * Check Z Flag  beq/bne
00:00003AEE 6AFE            	  2220:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003AF0 65FE            	  2221:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003AF2 69FE            	  2222:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003AF4 0680A0000000    	  2223:             addi.l #$A0000000,d0
00:00003AFA 68FE            	  2224:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003AFC 0C80278EFBD2    	  2225:             cmpi.l #$278EFBD2,d0
00:00003B02 66FE            	  2226:             bne.s *                       * Check Z Flag  beq/bne
                            	  2227: 
                            	  2228: 
                            	  2229: 
                            	  2230: *     EA = x.L  - Byte
00:00003B04 207C0000F100    	  2231:             move.l #$F100,a0      * populate test data
00:00003B0A 20BC12345678    	  2232:             move.l #$12345678,(a0)     * populate test data
00:00003B10 063900000000F103	  2233:             addi.b #0,$F103
00:00003B18 67FE            	  2234:             beq.s *                       * Check Z Flag  beq/bne
00:00003B1A 6BFE            	  2235:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003B1C 65FE            	  2236:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003B1E 69FE            	  2237:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003B20 063900100000F103	  2238:             addi.b #$10,$F103
00:00003B28 67FE            	  2239:             beq.s *                       * Check Z Flag  beq/bne
00:00003B2A 6AFE            	  2240:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003B2C 65FE            	  2241:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003B2E 68FE            	  2242:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003B30 063900A50000F103	  2243:             addi.b #$A5,$F103
00:00003B38 67FE            	  2244:             beq.s *                       * Check Z Flag  beq/bne
00:00003B3A 6BFE            	  2245:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003B3C 64FE            	  2246:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003B3E 68FE            	  2247:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003B40 0C39002D0000F103	  2248:             cmpi.b #$2D,$F103
00:00003B48 66FE            	  2249:             bne.s *                       * Check Z Flag  beq/bne
                            	  2250: 
                            	  2251: *     EA = x.L- WORD
00:00003B4A 207C0000F100    	  2252:             move.l #$F100,a0      * populate test data
00:00003B50 20BC12345678    	  2253:             move.l #$12345678,(a0)     * populate test data
00:00003B56 067900000000F100	  2254:             addi.w #0,$F100
00:00003B5E 67FE            	  2255:             beq.s *                       * Check Z Flag  beq/bne
00:00003B60 6BFE            	  2256:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003B62 65FE            	  2257:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003B64 69FE            	  2258:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003B66 067970000000F100	  2259:             addi.w #$7000,$F100
00:00003B6E 67FE            	  2260:             beq.s *                       * Check Z Flag  beq/bne
00:00003B70 6AFE            	  2261:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003B72 65FE            	  2262:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003B74 68FE            	  2263:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003B76 0679A55A0000F100	  2264:             addi.w #$A55A,$F100
00:00003B7E 67FE            	  2265:             beq.s *                       * Check Z Flag  beq/bne
00:00003B80 6BFE            	  2266:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003B82 64FE            	  2267:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003B84 68FE            	  2268:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003B86 0C79278E0000F100	  2269:             cmpi.w #$278E,$F100
00:00003B8E 66FE            	  2270:             bne.s *                       * Check Z Flag  beq/bne
                            	  2271: 
                            	  2272: *     EA = x.L- LONG
00:00003B90 23FC123456780000	  2273:             move.l #$12345678,$F100  * populate test data
00:00003B98 F100
00:00003B9A 06B9000000000000	  2274:             addi.l #0,$F100
00:00003BA2 F100
00:00003BA4 67FE            	  2275:             beq.s *                       * Check Z Flag  beq/bne
00:00003BA6 6BFE            	  2276:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003BA8 65FE            	  2277:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003BAA 69FE            	  2278:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003BAC 06B9F00000000000	  2279:             addi.l #$F0000000,$F100
00:00003BB4 F100
00:00003BB6 67FE            	  2280:             beq.s *                       * Check Z Flag  beq/bne
00:00003BB8 6BFE            	  2281:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003BBA 64FE            	  2282:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003BBC 69FE            	  2283:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003BBE 06B9855AA55A0000	  2284:             addi.l #$855AA55A,$F100
00:00003BC6 F100
00:00003BC8 67FE            	  2285:             beq.s *                       * Check Z Flag  beq/bne
00:00003BCA 6AFE            	  2286:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003BCC 65FE            	  2287:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003BCE 69FE            	  2288:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003BD0 06B9A00000000000	  2289:             addi.l #$A0000000,$F100
00:00003BD8 F100
00:00003BDA 68FE            	  2290:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003BDC 0CB9278EFBD20000	  2291:             cmpi.l #$278EFBD2,$F100
00:00003BE4 F100
00:00003BE6 66FE            	  2292:             bne.s *                       * Check Z Flag  beq/bne
                            	  2293: 
00:00003BE8 4E75            	  2294:             rts
                            	  2295: 
                            	  2296: 
                            	  2297: *-----------------------------------------------------------
                            	  2298: *-----------------------------------------------------------
                            	  2299: * OPCODE : SUB_I
                            	  2300: *-----------------------------------------------------------
                            	  2301: *-----------------------------------------------------------
                            	  2302: op_SUB_I:
                            	  2303: 
                            	  2304: *     EA = Dn  - Byte
00:00003BEA 203C12345678    	  2305:             move.l #$12345678,d0      * populate test data
00:00003BF0 04000000        	  2306:             subi.b #0,d0
00:00003BF4 67FE            	  2307:             beq.s *                       * Check Z Flag  beq/bne
00:00003BF6 6BFE            	  2308:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003BF8 65FE            	  2309:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003BFA 69FE            	  2310:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003BFC 04000010        	  2311:             subi.b #$10,d0
00:00003C00 67FE            	  2312:             beq.s *                       * Check Z Flag  beq/bne
00:00003C02 6BFE            	  2313:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003C04 65FE            	  2314:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003C06 69FE            	  2315:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003C08 040000A5        	  2316:             subi.b #$A5,d0
00:00003C0C 67FE            	  2317:             beq.s *                       * Check Z Flag  beq/bne
00:00003C0E 6AFE            	  2318:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003C10 64FE            	  2319:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003C12 68FE            	  2320:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003C14 0C0000C3        	  2321:             cmpi.b #$C3,d0
00:00003C18 66FE            	  2322:             bne.s *                       * Check Z Flag  beq/bne
                            	  2323: 
                            	  2324: *     EA = Dn  - WORD
00:00003C1A 203C12345678    	  2325:             move.l #$12345678,d0      * populate test data
00:00003C20 04400000        	  2326:             subi.w #0,d0
00:00003C24 67FE            	  2327:             beq.s *                       * Check Z Flag  beq/bne
00:00003C26 6BFE            	  2328:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003C28 65FE            	  2329:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003C2A 69FE            	  2330:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003C2C 04407000        	  2331:             subi.w #$7000,d0
00:00003C30 67FE            	  2332:             beq.s *                       * Check Z Flag  beq/bne
00:00003C32 6AFE            	  2333:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003C34 64FE            	  2334:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003C36 69FE            	  2335:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003C38 0440A55A        	  2336:             subi.w #$A55A,d0
00:00003C3C 67FE            	  2337:             beq.s *                       * Check Z Flag  beq/bne
00:00003C3E 6BFE            	  2338:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003C40 65FE            	  2339:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003C42 69FE            	  2340:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003C44 0C40411E        	  2341:             cmpi.w #$411E,d0
00:00003C48 66FE            	  2342:             bne.s *                       * Check Z Flag  beq/bne
                            	  2343: 
                            	  2344: *     EA = Dn  - LONG
00:00003C4A 203C12345678    	  2345:             move.l #$12345678,d0      * populate test data
00:00003C50 048000000000    	  2346:             subi.l #0,d0
00:00003C56 67FE            	  2347:             beq.s *                       * Check Z Flag  beq/bne
00:00003C58 6BFE            	  2348:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003C5A 65FE            	  2349:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003C5C 69FE            	  2350:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003C5E 0480F0000000    	  2351:             subi.l #$F0000000,d0
00:00003C64 67FE            	  2352:             beq.s *                       * Check Z Flag  beq/bne
00:00003C66 6BFE            	  2353:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003C68 64FE            	  2354:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003C6A 69FE            	  2355:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003C6C 0480855AA55A    	  2356:             subi.l #$855AA55A,d0
00:00003C72 67FE            	  2357:             beq.s *                       * Check Z Flag  beq/bne
00:00003C74 6AFE            	  2358:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003C76 64FE            	  2359:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003C78 68FE            	  2360:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003C7A 0480A0000000    	  2361:             subi.l #$A0000000,d0
00:00003C80 69FE            	  2362:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003C82 0C80FCD9B11E    	  2363:             cmpi.l #$FCD9B11E,d0
00:00003C88 66FE            	  2364:             bne.s *                       * Check Z Flag  beq/bne
                            	  2365: 
                            	  2366: 
                            	  2367: 
                            	  2368: *     EA = x.L  - Byte
00:00003C8A 207C0000F100    	  2369:             move.l #$F100,a0      * populate test data
00:00003C90 20BC12345678    	  2370:             move.l #$12345678,(a0)     * populate test data
00:00003C96 043900000000F103	  2371:             subi.b #0,$F103
00:00003C9E 67FE            	  2372:             beq.s *                       * Check Z Flag  beq/bne
00:00003CA0 6BFE            	  2373:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003CA2 65FE            	  2374:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003CA4 69FE            	  2375:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003CA6 043900100000F103	  2376:             subi.b #$10,$F103
00:00003CAE 67FE            	  2377:             beq.s *                       * Check Z Flag  beq/bne
00:00003CB0 6BFE            	  2378:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003CB2 65FE            	  2379:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003CB4 69FE            	  2380:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003CB6 043900A50000F103	  2381:             subi.b #$A5,$F103
00:00003CBE 67FE            	  2382:             beq.s *                       * Check Z Flag  beq/bne
00:00003CC0 6AFE            	  2383:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003CC2 64FE            	  2384:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003CC4 68FE            	  2385:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003CC6 0C3900C30000F103	  2386:             cmpi.b #$C3,$F103
00:00003CCE 66FE            	  2387:             bne.s *                       * Check Z Flag  beq/bne
                            	  2388: 
                            	  2389: *     EA = x.L- WORD
00:00003CD0 207C0000F100    	  2390:             move.l #$F100,a0      * populate test data
00:00003CD6 20BC12345678    	  2391:             move.l #$12345678,(a0)     * populate test data
00:00003CDC 047900000000F100	  2392:             subi.w #0,$F100
00:00003CE4 67FE            	  2393:             beq.s *                       * Check Z Flag  beq/bne
00:00003CE6 6BFE            	  2394:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003CE8 65FE            	  2395:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003CEA 69FE            	  2396:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003CEC 047970000000F100	  2397:             subi.w #$7000,$F100
00:00003CF4 67FE            	  2398:             beq.s *                       * Check Z Flag  beq/bne
00:00003CF6 6AFE            	  2399:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003CF8 64FE            	  2400:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003CFA 69FE            	  2401:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003CFC 0479A55A0000F100	  2402:             subi.w #$A55A,$F100
00:00003D04 67FE            	  2403:             beq.s *                       * Check Z Flag  beq/bne
00:00003D06 6AFE            	  2404:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003D08 64FE            	  2405:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003D0A 69FE            	  2406:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003D0C 0C79FCDA0000F100	  2407:             cmpi.w #$FCDA,$F100
00:00003D14 66FE            	  2408:             bne.s *                       * Check Z Flag  beq/bne
                            	  2409: 
                            	  2410: *     EA = x.L- LONG
00:00003D16 23FC123456780000	  2411:             move.l #$12345678,$F100  * populate test data
00:00003D1E F100
00:00003D20 04B9000000000000	  2412:             subi.l #0,$F100
00:00003D28 F100
00:00003D2A 67FE            	  2413:             beq.s *                       * Check Z Flag  beq/bne
00:00003D2C 6BFE            	  2414:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003D2E 65FE            	  2415:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003D30 69FE            	  2416:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003D32 04B9F00000000000	  2417:             subi.l #$F0000000,$F100
00:00003D3A F100
00:00003D3C 67FE            	  2418:             beq.s *                       * Check Z Flag  beq/bne
00:00003D3E 6BFE            	  2419:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003D40 64FE            	  2420:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003D42 69FE            	  2421:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003D44 04B9855AA55A0000	  2422:             subi.l #$855AA55A,$F100
00:00003D4C F100
00:00003D4E 67FE            	  2423:             beq.s *                       * Check Z Flag  beq/bne
00:00003D50 6AFE            	  2424:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003D52 64FE            	  2425:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003D54 68FE            	  2426:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003D56 04B9A00000000000	  2427:             subi.l #$A0000000,$F100
00:00003D5E F100
00:00003D60 69FE            	  2428:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003D62 0CB9FCD9B11E0000	  2429:             cmpi.l #$FCD9B11E,$F100
00:00003D6A F100
00:00003D6C 66FE            	  2430:             bne.s *                       * Check Z Flag  beq/bne
                            	  2431: 
00:00003D6E 4E75            	  2432:             rts
                            	  2433: 
                            	  2434: 
                            	  2435: 
                            	  2436: *-----------------------------------------------------------
                            	  2437: *-----------------------------------------------------------
                            	  2438: * OPCODE : MOVE
                            	  2439: *-----------------------------------------------------------
                            	  2440: *-----------------------------------------------------------
                            	  2441: op_MOVE:
00:00003D70 203C11223344    	  2442:             move.l #$11223344,d0
00:00003D76 223C55667788    	  2443:             move.l #$55667788,d1
00:00003D7C 243C8899AABB    	  2444:             move.l #$8899aabb,d2
00:00003D82 263CCCDDEEFF    	  2445:             move.l #$ccddeeff,d3
00:00003D88 7800            	  2446:             moveq  #$00000000,d4
00:00003D8A 7A00            	  2447:             moveq  #$00000000,d5
00:00003D8C 7C00            	  2448:             moveq  #$00000000,d6
00:00003D8E 7E00            	  2449:             moveq  #$00000000,d7
00:00003D90 207C44332211    	  2450:             move.l #$44332211,a0
00:00003D96 227C88776655    	  2451:             move.l #$88776655,a1
00:00003D9C 247CBBAA9988    	  2452:             move.l #$bbaa9988,a2
00:00003DA2 267CFFEEDDCC    	  2453:             move.l #$ffeeddcc,a3
                            	  2454: 
00:00003DA8 1800            	  2455:             move.b d0,d4              * BYTE - DATA REGISTER
00:00003DAA 67FE            	  2456:             beq.s *                       * Check Z Flag  beq/bne
00:00003DAC 6BFE            	  2457:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003DAE 0C8400000044    	  2458:             cmpi.l #$00000044,d4
00:00003DB4 66FE            	  2459:             bne.s *                       * Check Z Flag  beq/bne
                            	  2460: 
00:00003DB6 3A01            	  2461:             move.w d1,d5              * WORD - DATA REGISTER
00:00003DB8 67FE            	  2462:             beq.s *                       * Check Z Flag  beq/bne
00:00003DBA 6BFE            	  2463:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003DBC 0C8500007788    	  2464:             cmpi.l #$00007788,d5
00:00003DC2 66FE            	  2465:             bne.s *                       * Check Z Flag  beq/bne
                            	  2466: 
00:00003DC4 2C02            	  2467:             move.l d2,d6              * LONG - DATA REGISTER
00:00003DC6 67FE            	  2468:             beq.s *                       * Check Z Flag  beq/bne
00:00003DC8 6AFE            	  2469:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003DCA 0C868899AABB    	  2470:             cmpi.l #$8899aabb,d6
00:00003DD0 66FE            	  2471:             bne.s *                       * Check Z Flag  beq/bne
                            	  2472: 
00:00003DD2 3A09            	  2473:             move.w a1,d5              * WORD - ADDRESS REGISTER
00:00003DD4 67FE            	  2474:             beq.s *                       * Check Z Flag  beq/bne
00:00003DD6 6BFE            	  2475:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003DD8 0C8500006655    	  2476:             cmpi.l #$00006655,d5
00:00003DDE 66FE            	  2477:             bne.s *                       * Check Z Flag  beq/bne
                            	  2478: 
00:00003DE0 2C0A            	  2479:             move.l a2,d6              * LONG - ADDRESS REGISTER
00:00003DE2 67FE            	  2480:             beq.s *                       * Check Z Flag  beq/bne
00:00003DE4 6AFE            	  2481:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003DE6 0C86BBAA9988    	  2482:             cmpi.l #$bbaa9988,d6
00:00003DEC 66FE            	  2483:             bne.s *                       * Check Z Flag  beq/bne
                            	  2484: 
                            	  2485: 
00:00003DEE 3842            	  2486:             movea.w d2,a4             * WORD - ADDRESS REGISTER as SOURCE ## MOVEA
00:00003DF0 B9C2            	  2487:             cmpa.l d2,a4
00:00003DF2 67FE            	  2488:             beq.s *                       * Check Z Flag  beq/bne ## comopare fails because A4 was sign extended
                            	  2489: 
00:00003DF4 2A41            	  2490:             movea.l d1,a5             * LONG - ADDRESS REGISTER as SOURCE ## MOVEA
00:00003DF6 BBC1            	  2491:             cmpa.l d1,a5
00:00003DF8 66FE            	  2492:             bne.s *                       * Check Z Flag  beq/bne
                            	  2493: 
                            	  2494: 
                            	  2495: 
                            	  2496: *   Too mamy EA combinations to test,so we focus on a few of the more complicted EA's
                            	  2497: 
00:00003DFA 203C11223344    	  2498:             move.l #$11223344,d0
00:00003E00 223C00010100    	  2499:             move.l #$00010100,d1
00:00003E06 243C8899AABB    	  2500:             move.l #$8899aabb,d2
00:00003E0C 7601            	  2501:             moveq  #$00000001,d3
00:00003E0E 7800            	  2502:             moveq  #$00000000,d4
00:00003E10 7A00            	  2503:             moveq  #$00000000,d5
00:00003E12 7C00            	  2504:             moveq  #$00000000,d6
00:00003E14 7E00            	  2505:             moveq  #$00000000,d7
00:00003E16 91C8            	  2506:             move.l #$00000000,a0
00:00003E18 227C00010100    	  2507:             move.l #$00010100,a1
                            	  2508: 
                            	  2509: *     x(An,AL) --> x.L
00:00003E1E 11BC005A9804    	  2510:             move.b #$5A,4(a0,a1.l)    * BYTE
00:00003E24 47F09804        	  2511:             lea 4(a0,a1.l),a3
00:00003E28 13F0980400010105	  2512:             move.b 4(a0,a1.l),$00010105
00:00003E30 67FE            	  2513:             beq.s *                       * Check Z Flag  beq/bne
00:00003E32 6BFE            	  2514:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003E34 0C30005A9805    	  2515:             cmpi.b #$5A,5(a0,a1.l)
00:00003E3A 66FE            	  2516:             bne.s *                       * Check Z Flag  beq/bne
                            	  2517: 
                            	  2518: *     x.L --> n(An,Dw)
00:00003E3C 11B9000101051007	  2519: MOVE2:      move.b  $00010105,7(a0,d1.w)    * BYTE
00:00003E44 67FE            	  2520:             beq.s *                       * Check Z Flag  beq/bne
00:00003E46 6BFE            	  2521:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003E48 0C30005A1007    	  2522:             cmpi.b #$5A,7(a0,d1.w)
00:00003E4E 66FE            	  2523:             bne.s *                       * Check Z Flag  beq/bne
                            	  2524: 
                            	  2525: *     x(PC,Ds) --> x.w
00:00003E50 11FB30660100    	  2526:             move.b  MOVE1(pc,d3.w),$0100 * BYTE
00:00003E56 67FE            	  2527:             beq.s *                       * Check Z Flag  beq/bne
00:00003E58 6AFE            	  2528:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003E5A 0C3900B900003E3D	  2529:             cmpi.b #$B9,1+MOVE2
00:00003E62 66FE            	  2530:             bne.s *                       * Check Z Flag  beq/bne
                            	  2531: 
                            	  2532: *     #x -->    n(An,AL)
00:00003E64 11BC00781007    	  2533:             move.b  #$78,7(a0,d1.w)    * BYTE
00:00003E6A 67FE            	  2534:             beq.s *                       * Check Z Flag  beq/bne
00:00003E6C 6BFE            	  2535:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003E6E 0C3000781007    	  2536:             cmpi.b #$78,7(a0,d1.w)
00:00003E74 66FE            	  2537:             bne.s *                       * Check Z Flag  beq/bne
                            	  2538: 
00:00003E76 203C11223344    	  2539:             move.l #$11223344,d0
00:00003E7C 223C00010100    	  2540:             move.l #$00010100,d1
00:00003E82 243C8899AABB    	  2541:             move.l #$8899aabb,d2
00:00003E88 7602            	  2542:             moveq  #$00000002,d3
00:00003E8A 7800            	  2543:             moveq  #$00000000,d4
00:00003E8C 7A00            	  2544:             moveq  #$00000000,d5
00:00003E8E 7C00            	  2545:             moveq  #$00000000,d6
00:00003E90 7E00            	  2546:             moveq  #$00000000,d7
00:00003E92 91C8            	  2547:             move.l #$00000000,a0
00:00003E94 227C00010100    	  2548:             move.l #$00010100,a1
                            	  2549: 
                            	  2550: *     x(An,AL) --> x.L
00:00003E9A 31BC5A5A9804    	  2551:             move.w #$5A5A,4(a0,a1.l)    * WORD
00:00003EA0 49F09804        	  2552:             lea 4(a0,a1.l),a4
00:00003EA4 33F0980400010104	  2553:             move.w 4(a0,a1.l),$00010104
00:00003EAC 67FE            	  2554:             beq.s *                       * Check Z Flag  beq/bne
00:00003EAE 6BFE            	  2555:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003EB0 0C705A5A9804    	  2556:             cmpi.w #$5A5A,4(a0,a1.l)
00:00003EB6 66FE            	  2557:             bne.s *                       * Check Z Flag  beq/bne
                            	  2558: 
                            	  2559: *     x.L --> n(An,Dw)
00:00003EB8 31B9000101041006	  2560: MOVE1:      move.w  $00010104,6(a0,d1.w)    * WORD
00:00003EC0 67FE            	  2561:             beq.s *                       * Check Z Flag  beq/bne
00:00003EC2 6BFE            	  2562:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003EC4 0C705A5A1006    	  2563:             cmpi.w #$5A5A,6(a0,d1.w)
00:00003ECA 66FE            	  2564:             bne.s *                       * Check Z Flag  beq/bne
                            	  2565: 
                            	  2566: *     x(PC,Ds) --> x.w
00:00003ECC 31FB30EA0100    	  2567:             move.w  MOVE1(pc,d3),$0100 * WORD
00:00003ED2 67FE            	  2568:             beq.s *                       * Check Z Flag  beq/bne
00:00003ED4 6BFE            	  2569:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003ED6 0C7967FE00003EC0	  2570:             cmpi.w #$67FE,8+MOVE1
00:00003EDE 66FE            	  2571:             bne.s *                       * Check Z Flag  beq/bne
                            	  2572: 
                            	  2573: *     #x -->    n(An,AL)
00:00003EE0 31BC78781006    	  2574:             move.w  #$7878,6(a0,d1.w)    * WORD
00:00003EE6 67FE            	  2575:             beq.s *                       * Check Z Flag  beq/bne
00:00003EE8 6BFE            	  2576:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003EEA 0C7078781006    	  2577:             cmpi.w #$7878,6(a0,d1.w)
00:00003EF0 66FE            	  2578:             bne.s *                       * Check Z Flag  beq/bne
                            	  2579: 
                            	  2580: * ---
                            	  2581: 
00:00003EF2 203C11223344    	  2582:             move.l #$11223344,d0
00:00003EF8 223C00010100    	  2583:             move.l #$00010100,d1
00:00003EFE 243C8899AABB    	  2584:             move.l #$8899aabb,d2
00:00003F04 7602            	  2585:             moveq  #$00000002,d3
00:00003F06 7800            	  2586:             moveq  #$00000000,d4
00:00003F08 7A00            	  2587:             moveq  #$00000000,d5
00:00003F0A 7C00            	  2588:             moveq  #$00000000,d6
00:00003F0C 7E00            	  2589:             moveq  #$00000000,d7
00:00003F0E 91C8            	  2590:             move.l #$00000000,a0
00:00003F10 227C00010100    	  2591:             move.l #$00010100,a1
                            	  2592: 
                            	  2593: *     x(An,AL) --> x.L
00:00003F16 21BC5A5A12349804	  2594:             move.l #$5A5A1234,4(a0,a1.l)    * LONG
00:00003F1E 49F09804        	  2595:             lea 4(a0,a1.l),a4
00:00003F22 23F0980400010104	  2596:             move.l 4(a0,a1.l),$00010104
00:00003F2A 67FE            	  2597:             beq.s *                       * Check Z Flag  beq/bne
00:00003F2C 6BFE            	  2598:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003F2E 0CB05A5A12349804	  2599:             cmpi.l #$5A5A1234,4(a0,a1.l)
00:00003F36 66FE            	  2600:             bne.s *                       * Check Z Flag  beq/bne
                            	  2601: 
                            	  2602: *     x.L --> n(An,Dw)
00:00003F38 21B9000101041006	  2603: MOVE3:      move.l  $00010104,6(a0,d1.w)    * LONG
00:00003F40 67FE            	  2604:             beq.s *                       * Check Z Flag  beq/bne
00:00003F42 6BFE            	  2605:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003F44 0CB05A5A12341006	  2606:             cmpi.l #$5A5A1234,6(a0,d1.w)
00:00003F4C 66FE            	  2607:             bne.s *                       * Check Z Flag  beq/bne
                            	  2608: 
                            	  2609: *     x(PC,Ds) --> x.w
00:00003F4E 21FB30E80100    	  2610:             move.l  MOVE3(pc,d3),$0100 * LONG
00:00003F54 67FE            	  2611:             beq.s *                       * Check Z Flag  beq/bne
00:00003F56 6BFE            	  2612:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003F58 0CB967FE6BFE0000	  2613:             cmpi.l #$67FE6BFE,8+MOVE3
00:00003F60 3F40
00:00003F62 66FE            	  2614:             bne.s *                       * Check Z Flag  beq/bne
                            	  2615: 
                            	  2616: *     #x -->    n(An,AL)
00:00003F64 21BC787823231006	  2617:             move.l  #$78782323,6(a0,d1.w)    * LONG
00:00003F6C 67FE            	  2618:             beq.s *                       * Check Z Flag  beq/bne
00:00003F6E 6BFE            	  2619:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003F70 0CB0787823231006	  2620:             cmpi.l #$78782323,6(a0,d1.w)
00:00003F78 66FE            	  2621:             bne.s *                       * Check Z Flag  beq/bne
                            	  2622: 
                            	  2623: 
00:00003F7A 4E75            	  2624:          rts
                            	  2625: 
                            	  2626: 
                            	  2627: *-----------------------------------------------------------
                            	  2628: *-----------------------------------------------------------
                            	  2629: * OPCODE : MOVE_xxx_FLAGS
                            	  2630: *-----------------------------------------------------------
                            	  2631: *-----------------------------------------------------------
                            	  2632: op_MOVE_xxx_FLAGS:
                            	  2633: 
                            	  2634: *     Move_To_SR
                            	  2635: 
                            	  2636: *     Dn
                            	  2637: 
00:00003F7C 303C2FFF        	  2638:             move.w #$2FFF,d0
00:00003F80 46C0            	  2639:             move.w d0,SR
00:00003F82 6AFE            	  2640:             bpl.s *           * branch if Z clear
00:00003F84 66FE            	  2641:             bne.s *           * branch if N clear
00:00003F86 68FE            	  2642:             bvc.s *           * branch if V clear
00:00003F88 64FE            	  2643:             bcc.s *           * branch if C clear
00:00003F8A 303C2F00        	  2644:             move.w #$2F00,d0
00:00003F8E 44C0            	  2645:             move d0,CCR
00:00003F90 67FE            	  2646:             beq.s *           * branch if Z set
00:00003F92 6BFE            	  2647:             bmi.s *           * branch if N set
00:00003F94 69FE            	  2648:             bvs.s *           * branch if V set
00:00003F96 65FE            	  2649:             bcs.s *           * branch if C set
                            	  2650: 
00:00003F98 303C2000        	  2651:             move.w #$2000,d0
00:00003F9C 46C0            	  2652:             move.w d0,SR
00:00003F9E 67FE            	  2653:             beq.s *           * branch if Z set
00:00003FA0 6BFE            	  2654:             bmi.s *           * branch if N set
00:00003FA2 69FE            	  2655:             bvs.s *           * branch if V set
00:00003FA4 65FE            	  2656:             bcs.s *           * branch if C set
                            	  2657: 
                            	  2658: *     (An)
00:00003FA6 307C0100        	  2659:             move.l #$00000100,a0
00:00003FAA 30BC2FFF        	  2660:             move.w #$2FFF,(a0)
00:00003FAE 46D0            	  2661:             move.w (a0),SR
00:00003FB0 6AFE            	  2662:             bpl.s *           * branch if Z clear
00:00003FB2 66FE            	  2663:             bne.s *           * branch if N clear
00:00003FB4 68FE            	  2664:             bvc.s *           * branch if V clear
00:00003FB6 64FE            	  2665:             bcc.s *           * branch if C clear
                            	  2666: 
00:00003FB8 30BC2000        	  2667:             move.w #$2000,(a0)
00:00003FBC 46D0            	  2668:             move.w (a0),SR
00:00003FBE 67FE            	  2669:             beq.s *           * branch if Z set
00:00003FC0 6BFE            	  2670:             bmi.s *           * branch if N set
00:00003FC2 69FE            	  2671:             bvs.s *           * branch if V set
00:00003FC4 65FE            	  2672:             bcs.s *           * branch if C set
                            	  2673: 
                            	  2674: *     (An)+
00:00003FC6 307C0100        	  2675:             move.l #$00000100,a0
00:00003FCA 30BC2FFF        	  2676:             move.w #$2FFF,(a0)
00:00003FCE 46D8            	  2677:             move.w (a0)+,SR
00:00003FD0 6AFE            	  2678:             bpl.s *           * branch if Z clear
00:00003FD2 66FE            	  2679:             bne.s *           * branch if N clear
00:00003FD4 68FE            	  2680:             bvc.s *           * branch if V clear
00:00003FD6 64FE            	  2681:             bcc.s *           * branch if C clear
                            	  2682: 
00:00003FD8 30BC2000        	  2683:             move.w #$2000,(a0)
00:00003FDC 46D8            	  2684:             move.w (a0)+,SR
00:00003FDE 67FE            	  2685:             beq.s *           * branch if Z set
00:00003FE0 6BFE            	  2686:             bmi.s *           * branch if N set
00:00003FE2 69FE            	  2687:             bvs.s *           * branch if V set
00:00003FE4 65FE            	  2688:             bcs.s *           * branch if C set
                            	  2689: 
                            	  2690: *     -(An)
00:00003FE6 307C0102        	  2691:             move.l #$00000102,a0
00:00003FEA 30BC2FFF        	  2692:             move.w #$2FFF,(a0)
00:00003FEE 46D8            	  2693:             move.w (a0)+,SR
00:00003FF0 6AFE            	  2694:             bpl.s *           * branch if Z clear
00:00003FF2 66FE            	  2695:             bne.s *           * branch if N clear
00:00003FF4 68FE            	  2696:             bvc.s *           * branch if V clear
00:00003FF6 64FE            	  2697:             bcc.s *           * branch if C clear
                            	  2698: 
00:00003FF8 30BC2000        	  2699:             move.w #$2000,(a0)
00:00003FFC 46D8            	  2700:             move.w (a0)+,SR
00:00003FFE 67FE            	  2701:             beq.s *           * branch if Z set
00:00004000 6BFE            	  2702:             bmi.s *           * branch if N set
00:00004002 69FE            	  2703:             bvs.s *           * branch if V set
00:00004004 65FE            	  2704:             bcs.s *           * branch if C set
                            	  2705: 
                            	  2706: *     n(An)
00:00004006 307C0102        	  2707:             move.l #$00000102,a0
00:0000400A 317C2FFF0002    	  2708:             move.w #$2FFF,2(a0)
00:00004010 46E80002        	  2709:             move.w 2(a0),SR
00:00004014 6AFE            	  2710:             bpl.s *           * branch if Z clear
00:00004016 66FE            	  2711:             bne.s *           * branch if N clear
00:00004018 68FE            	  2712:             bvc.s *           * branch if V clear
00:0000401A 64FE            	  2713:             bcc.s *           * branch if C clear
                            	  2714: 
00:0000401C 317C20000002    	  2715:             move.w #$2000,2(a0)
00:00004022 46E80002        	  2716:             move.w 2(a0),SR
00:00004026 67FE            	  2717:             beq.s *           * branch if Z set
00:00004028 6BFE            	  2718:             bmi.s *           * branch if N set
00:0000402A 69FE            	  2719:             bvs.s *           * branch if V set
00:0000402C 65FE            	  2720:             bcs.s *           * branch if C set
                            	  2721: 
                            	  2722: *     n(An,Rn.l)
00:0000402E 307C0100        	  2723:             move.l #$00000100,a0
00:00004032 7002            	  2724:             moveq  #$00000002,d0
00:00004034 31BC2FFF0802    	  2725:             move.w #$2FFF,2(a0,d0.l)
00:0000403A 46F00802        	  2726:             move.w 2(a0,d0.l),SR
00:0000403E 6AFE            	  2727:             bpl.s *           * branch if Z clear
00:00004040 66FE            	  2728:             bne.s *           * branch if N clear
00:00004042 68FE            	  2729:             bvc.s *           * branch if V clear
00:00004044 64FE            	  2730:             bcc.s *           * branch if C clear
                            	  2731: 
00:00004046 31BC20000802    	  2732:             move.w #$2000,2(a0,d0.l)
00:0000404C 46F00802        	  2733:             move.w 2(a0,d0.l),SR
00:00004050 67FE            	  2734:             beq.s *           * branch if Z set
00:00004052 6BFE            	  2735:             bmi.s *           * branch if N set
00:00004054 69FE            	  2736:             bvs.s *           * branch if V set
00:00004056 65FE            	  2737:             bcs.s *           * branch if C set
                            	  2738: 
                            	  2739: *     x.W
00:00004058 31FC2FFF0100    	  2740:             move.w #$2FFF,$0100
00:0000405E 46F80100        	  2741:             move.w $0100,SR
00:00004062 6AFE            	  2742:             bpl.s *           * branch if Z clear
00:00004064 66FE            	  2743:             bne.s *           * branch if N clear
00:00004066 68FE            	  2744:             bvc.s *           * branch if V clear
00:00004068 64FE            	  2745:             bcc.s *           * branch if C clear
                            	  2746: 
00:0000406A 31FC20000100    	  2747:             move.w #$2000,$0100
00:00004070 46F80100        	  2748:             move.w $0100,SR
00:00004074 67FE            	  2749:             beq.s *           * branch if Z set
00:00004076 6BFE            	  2750:             bmi.s *           * branch if N set
00:00004078 69FE            	  2751:             bvs.s *           * branch if V set
00:0000407A 65FE            	  2752:             bcs.s *           * branch if C set
                            	  2753: 
                            	  2754: *     x.L
00:0000407C 33FC2FFF00010100	  2755:             move.w #$2FFF,$00010100
00:00004084 46F900010100    	  2756:             move.w $00010100,SR
00:0000408A 6AFE            	  2757:             bpl.s *           * branch if Z clear
00:0000408C 66FE            	  2758:             bne.s *           * branch if N clear
00:0000408E 68FE            	  2759:             bvc.s *           * branch if V clear
00:00004090 64FE            	  2760:             bcc.s *           * branch if C clear
                            	  2761: 
00:00004092 33FC200000010100	  2762: MOVE4:      move.w #$2000,$00010100
00:0000409A 46F900010100    	  2763:             move.w $00010100,SR
00:000040A0 67FE            	  2764:             beq.s *           * branch if Z set
00:000040A2 6BFE            	  2765:             bmi.s *           * branch if N set
00:000040A4 69FE            	  2766:             bvs.s *           * branch if V set
00:000040A6 65FE            	  2767:             bcs.s *           * branch if C set
                            	  2768: 
                            	  2769: *     x(PC)
00:000040A8 46FAFFEA        	  2770:             move.w MOVE4+2(pc),SR
00:000040AC 67FE            	  2771:             beq.s *           * branch if Z set
00:000040AE 6BFE            	  2772:             bmi.s *           * branch if N set
00:000040B0 69FE            	  2773:             bvs.s *           * branch if V set
00:000040B2 65FE            	  2774:             bcs.s *           * branch if C set
                            	  2775: 
                            	  2776: *     x(PC,d0.l)
00:000040B4 7000            	  2777:             moveq  #$00000000,d0
00:000040B6 46FB08DC        	  2778:             move.w MOVE4+2(pc,d0.l),SR
00:000040BA 67FE            	  2779:             beq.s *           * branch if Z set
00:000040BC 6BFE            	  2780:             bmi.s *           * branch if N set
00:000040BE 69FE            	  2781:             bvs.s *           * branch if V set
00:000040C0 65FE            	  2782:             bcs.s *           * branch if C set
00:000040C2 44FB08D0        	  2783:             move MOVE4+2(pc,d0.l),CCR
00:000040C6 67FE            	  2784:             beq.s *           * branch if Z set
00:000040C8 6BFE            	  2785:             bmi.s *           * branch if N set
00:000040CA 69FE            	  2786:             bvs.s *           * branch if V set
00:000040CC 65FE            	  2787:             bcs.s *           * branch if C set
                            	  2788: 
                            	  2789: *     #x
00:000040CE 46FC2FFF        	  2790:             move.w #$2FFF,SR
00:000040D2 66FE            	  2791:             bne.s *           * branch if Z clear
00:000040D4 6AFE            	  2792:             bpl.s *           * branch if N clear
00:000040D6 68FE            	  2793:             bvc.s *           * branch if V clear
00:000040D8 64FE            	  2794:             bcc.s *           * branch if C clear
                            	  2795: 
                            	  2796: 
                            	  2797: 
                            	  2798: *  MOVE_From_SR
                            	  2799: 
                            	  2800: 
                            	  2801: 
                            	  2802: *     Dn
00:000040DA 46FC275A        	  2803:             move.w #$275A,SR          * Initial value
00:000040DE 40C0            	  2804:             move.w SR,d0
00:000040E0 0C40271A        	  2805:             cmpi.w #$271A,d0
                            	  2806: * The following fails because sr bits are implemented and non-zero so later code works.           
                            	  2807: *            bne.s *                   * branch if Z set
                            	  2808: 
                            	  2809: *     (An)
00:000040E4 307C0100        	  2810:             move.l #$00000100,a0
00:000040E8 46FC275A        	  2811:             move.w #$275A,SR          * Initial value
00:000040EC 40D0            	  2812:             move.w SR,(a0)
00:000040EE 0C50275A        	  2813:             cmpi.w #$275A,(a0)
00:000040F2 66FE            	  2814:             bne.s *                   * branch if Z set
                            	  2815: 
                            	  2816: *     (An)+
00:000040F4 307C0100        	  2817:             move.l #$00000100,a0
00:000040F8 46FC257A        	  2818:             move.w #$257A,SR          * Initial value
00:000040FC 40D8            	  2819:             move.w SR,(a0)+
00:000040FE 307C0100        	  2820:             move.l #$00000100,a0
00:00004102 0C58257A        	  2821:             cmpi.w #$257A,(a0)+
00:00004106 66FE            	  2822:             bne.s *                   * branch if Z set
                            	  2823: 
                            	  2824: *     -(An)
00:00004108 307C0102        	  2825:             move.l #$00000102,a0
00:0000410C 46FC2766        	  2826:             move.w #$2766,SR          * Initial value
00:00004110 40E0            	  2827:             move.w SR,-(a0)
00:00004112 307C0100        	  2828:             move.l #$00000100,a0
00:00004116 0C502766        	  2829:             cmpi.w #$2766,(a0)
00:0000411A 66FE            	  2830:             bne.s *                   * branch if Z set
                            	  2831: 
                            	  2832: *     x(An)
00:0000411C 307C0102        	  2833:             move.l #$00000102,a0
00:00004120 46FC2733        	  2834:             move.w #$2733,SR          * Initial value
00:00004124 40E80004        	  2835:             move.w SR,4(a0)
00:00004128 0C6827330004    	  2836:             cmpi.w #$2733,4(a0)
00:0000412E 66FE            	  2837:             bne.s *                   * branch if Z set
                            	  2838: 
                            	  2839: *     x(An,rn)
00:00004130 307C0102        	  2840:             move.l #$00000102,a0
00:00004134 7004            	  2841:             moveq  #$00000004,d0
00:00004136 46FC275A        	  2842:             move.w #$275a,SR          * Initial value
00:0000413A 40F00804        	  2843:             move.w SR,4(a0,d0.l)
00:0000413E 0C70275A0804    	  2844:             cmpi.w #$275a,4(a0,d0.l)
00:00004144 66FE            	  2845:             bne.s *                   * branch if Z set
                            	  2846: 
                            	  2847: *     x.W
00:00004146 46FC2777        	  2848:             move.w #$2777,SR          * Initial value
00:0000414A 40F80102        	  2849:             move.w SR,$0102
00:0000414E 0C7827770102    	  2850:             cmpi.w #$2777,$0102
00:00004154 66FE            	  2851:             bne.s *                   * branch if Z set
                            	  2852: 
                            	  2853: *     x.L
00:00004156 46FC2777        	  2854:             move.w #$2777,SR          * Initial value
00:0000415A 40F900010102    	  2855:             move.w SR,$10102
00:00004160 0C79277700010102	  2856:             cmpi.w #$2777,$10102
00:00004168 66FE            	  2857:             bne.s *                   * branch if Z set
                            	  2858: 
                            	  2859: 
                            	  2860: 
00:0000416A 46FC2700        	  2861:             move.w #$2700,SR          * Put flags back to initial value
                            	  2862: 
00:0000416E 4E75            	  2863:             rts
                            	  2864: 
                            	  2865: 
                            	  2866: *-----------------------------------------------------------
                            	  2867: *-----------------------------------------------------------
                            	  2868: * OPCODE : EXT
                            	  2869: *-----------------------------------------------------------
                            	  2870: *-----------------------------------------------------------
                            	  2871: op_EXT:
                            	  2872: 
00:00004170 707F            	  2873:             move.l #$0000007F,d0
00:00004172 223C00008FFF    	  2874:             move.l #$00008FFF,d1
00:00004178 7400            	  2875:             moveq  #$00000000,d2
                            	  2876: 
00:0000417A 4880            	  2877:             ext.w d0
00:0000417C 6BFE            	  2878:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000417E 67FE            	  2879:             beq.s *                   * Check Z Flag  beq/bne
00:00004180 0C800000007F    	  2880:             cmpi.l #$0000007F,d0
00:00004186 66FE            	  2881:             bne.s *                   * branch if Z set
                            	  2882: 
00:00004188 48C1            	  2883:             ext.l d1
00:0000418A 6AFE            	  2884:             bpl.s *                   * Check N Flag  bmi/bpl
00:0000418C 67FE            	  2885:             beq.s *                   * Check Z Flag  beq/bne
00:0000418E 0C81FFFF8FFF    	  2886:             cmpi.l #$FFFF8FFF,d1
00:00004194 66FE            	  2887:             bne.s *                   * branch if Z set
                            	  2888: 
00:00004196 48C2            	  2889:             ext.l d2
00:00004198 66FE            	  2890:             bne.s *                   * Check Z Flag  beq/bne
                            	  2891: 
                            	  2892: 
                            	  2893: 
00:0000419A 4E75            	  2894:             rts
                            	  2895: 
                            	  2896: 
                            	  2897: *-----------------------------------------------------------
                            	  2898: *-----------------------------------------------------------
                            	  2899: * OPCODE : SWAP
                            	  2900: *-----------------------------------------------------------
                            	  2901: *-----------------------------------------------------------
                            	  2902: op_SWAP:
                            	  2903: 
00:0000419C 203C12345678    	  2904:             move.l #$12345678,d0
                            	  2905: 
00:000041A2 4840            	  2906:             swap d0
00:000041A4 6BFE            	  2907:             bmi.s *                   * Check N Flag  bmi/bpl
00:000041A6 67FE            	  2908:             beq.s *                   * Check Z Flag  beq/bne
00:000041A8 0C8056781234    	  2909:             cmpi.l #$56781234,d0
00:000041AE 66FE            	  2910:             bne.s *                   * branch if Z set
                            	  2911: 
                            	  2912: 
                            	  2913: 
00:000041B0 4E75            	  2914:             rts
                            	  2915: 
                            	  2916: 
                            	  2917: *-----------------------------------------------------------
                            	  2918: *-----------------------------------------------------------
                            	  2919: * OPCODE : LEA_PEA
                            	  2920: *-----------------------------------------------------------
                            	  2921: *-----------------------------------------------------------
                            	  2922: op_LEAPEA:
                            	  2923: 
00:000041B2 207C00345678    	  2924:             move.l #$00345678,a0
00:000041B8 7800            	  2925:             moveq  #$00000000,d4
                            	  2926: 
                            	  2927: *     (An)
00:000041BA 4DD0            	  2928:             lea (a0),a6
00:000041BC 200E            	  2929:             move.l a6,d0
00:000041BE 0C8000345678    	  2930:             cmpi.l #$00345678,d0
00:000041C4 66FE            	  2931:             bne.s *                   * branch if Z set
00:000041C6 4850            	  2932:             pea (a0)
00:000041C8 0C9700345678    	  2933:             cmpi.l #$00345678,(a7)
00:000041CE 66FE            	  2934:             bne.s *                   * branch if Z set
                            	  2935:             * This was without a specifier which the assembler defaulted to .w
00:000041D0 588F            	  2936:             addq.l #4,a7            * Restore Stack Pointer
                            	  2937: 
                            	  2938: *     x(An)
00:000041D2 4DE80004        	  2939:             lea 4(a0),a6
00:000041D6 200E            	  2940:             move.l a6,d0
00:000041D8 0C800034567C    	  2941:             cmpi.l #$0034567C,d0
00:000041DE 66FE            	  2942:             bne.s *                   * branch if Z set
00:000041E0 48680004        	  2943:             pea 4(a0)
00:000041E4 0C970034567C    	  2944:             cmpi.l #$0034567C,(a7)
00:000041EA 66FE            	  2945:             bne.s *                   * branch if Z set
                            	  2946:             * This was without a specifier which the assembler defaulted to .w
00:000041EC 588F            	  2947:             addq.l #4,a7            * Restore Stack Pointer
                            	  2948: 
                            	  2949: *     x(An,Dn.l)
00:000041EE 4DF04004        	  2950:             lea 4(a0,d4),a6
00:000041F2 200E            	  2951:             move.l a6,d0
00:000041F4 0C800034567C    	  2952:             cmpi.l #$0034567C,d0
00:000041FA 66FE            	  2953:             bne.s *                   * branch if Z set
00:000041FC 48704804        	  2954:             pea 4(a0,d4.l)
00:00004200 0C970034567C    	  2955:             cmpi.l #$0034567C,(a7)
00:00004206 66FE            	  2956:             bne.s *                   * branch if Z set
                            	  2957:             * This was without a specifier which the assembler defaulted to .w
00:00004208 588F            	  2958:             addq.l #4,a7            * Restore Stack Pointer
                            	  2959: 
                            	  2960: *     x.W
00:0000420A 4DF81234        	  2961:             lea $1234,a6
00:0000420E 200E            	  2962:             move.l a6,d0
00:00004210 0C401234        	  2963:             cmpi.w #$1234,d0
00:00004214 66FE            	  2964:             bne.s *                   * branch if Z set
00:00004216 48781234        	  2965:             pea $1234
00:0000421A 0C9700001234    	  2966:             cmpi.l #$00001234,(a7)
00:00004220 66FE            	  2967:             bne.s *                   * branch if Z set
                            	  2968:             * This was without a specifier which the assembler defaulted to .w
00:00004222 588F            	  2969:             addq.l #4,a7            * Restore Stack Pointer
                            	  2970: 
                            	  2971: *     x.L
00:00004224 4DF900345678    	  2972:             lea $00345678,a6
00:0000422A 200E            	  2973:             move.l a6,d0
00:0000422C B08E            	  2974:             cmp.l a6,d0
00:0000422E 66FE            	  2975:             bne.s *                   * branch if Z set
00:00004230 487900345678    	  2976:             pea $00345678
00:00004236 0C9700345678    	  2977:             cmpi.l #$00345678,(a7)
00:0000423C 66FE            	  2978:             bne.s *                   * branch if Z set
                            	  2979:             * This was without a specifier which the assembler defaulted to .w
00:0000423E 588F            	  2980:             addq.l #4,a7            * Restore Stack Pointer
                            	  2981: 
                            	  2982: *     x(PC)
00:00004240 4DFA0008        	  2983:             lea LEA1(pc),a6
00:00004244 200E            	  2984:             move.l a6,d0
00:00004246 B08E            	  2985:             cmp.l a6,d0
00:00004248 66FE            	  2986:             bne.s *                   * branch if Z set
00:0000424A 487AFFFE        	  2987: LEA1:       pea LEA1(pc)
00:0000424E 0C970000241E    	  2988:             cmpi.l #$0000241E,(a7)
00:00004254 67FE            	  2989:             beq.s *                   * branch if Z clear
                            	  2990:             * This was without a specifier which the assembler defaulted to .w
00:00004256 588F            	  2991:             addq.l #4,a7              * Restore Stack Pointer
                            	  2992: 
                            	  2993: 
                            	  2994: 
                            	  2995: 
00:00004258 46FC2700        	  2996:             move.w #$2700,sr          * Put flags back to initial value
                            	  2997: 
00:0000425C 4E75            	  2998:             rts
                            	  2999:  	
                            	  3000: 
                            	  3001: 
                            	  3002: *-----------------------------------------------------------
                            	  3003: *-----------------------------------------------------------
                            	  3004: * OPCODE : LEA_TAS
                            	  3005: *-----------------------------------------------------------
                            	  3006: *-----------------------------------------------------------
                            	  3007: op_TAS:
                            	  3008: 
                            	  3009: *     Test just one addressing mode
                            	  3010: 
00:0000425E 307C0100        	  3011:             move.l #$00000100,a0
                            	  3012: 
                            	  3013: *     (An)
00:00004262 4210            	  3014:             move.b #$00,(a0)
00:00004264 6BFE            	  3015:             bmi.s *                   * Check N Flag  bmi/bpl
00:00004266 66FE            	  3016:             bne.s *                   * Check Z Flag  beq/bne
00:00004268 4AD0            	  3017:             tas (a0)
00:0000426A 0C100080        	  3018:             cmpi.b #$80,(a0)
00:0000426E 66FE            	  3019:             bne.s *                   * branch if Z set
00:00004270 10BC00F5        	  3020:             move.b #$F5,(a0)
00:00004274 4AD0            	  3021:             tas (a0)
00:00004276 6AFE            	  3022:             bpl.s *                   * Check N Flag  bmi/bpl
00:00004278 67FE            	  3023:             beq.s *                   * Check Z Flag  beq/bne
00:0000427A 4AD0            	  3024:             tas (a0)
00:0000427C 0C1000F5        	  3025:             cmpi.b #$F5,(a0)
00:00004280 66FE            	  3026:             bne.s *                   * branch if Z set
                            	  3027: 
00:00004282 4E75            	  3028:             rts
                            	  3029: 
                            	  3030: 
                            	  3031: *-----------------------------------------------------------
                            	  3032: *-----------------------------------------------------------
                            	  3033: * OPCODE : LEA_TST
                            	  3034: *-----------------------------------------------------------
                            	  3035: *-----------------------------------------------------------
                            	  3036: op_TST:
                            	  3037: 
                            	  3038: *     Test just one addressing mode
                            	  3039: 
00:00004284 307C0100        	  3040:             move.l #$00000100,a0
                            	  3041: 
                            	  3042: *     (An) - BYTE
00:00004288 4210            	  3043:             move.b #$00,(a0)
00:0000428A 4A10            	  3044:             tst.b (a0)
00:0000428C 6BFE            	  3045:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000428E 66FE            	  3046:             bne.s *                   * Check Z Flag  beq/bne
00:00004290 10BC00F5        	  3047:             move.b #$F5,(a0)
00:00004294 4A10            	  3048:             tst.b (a0)
00:00004296 6AFE            	  3049:             bpl.s *                   * Check N Flag  bmi/bpl
00:00004298 67FE            	  3050:             beq.s *                   * Check Z Flag  beq/bne
                            	  3051: 
                            	  3052: *     (An) - WORD
00:0000429A 4250            	  3053:             move.w #$0000,(a0)
00:0000429C 4A50            	  3054:             tst.w (a0)
00:0000429E 6BFE            	  3055:             bmi.s *                   * Check N Flag  bmi/bpl
00:000042A0 66FE            	  3056:             bne.s *                   * Check Z Flag  beq/bne
00:000042A2 30BCF567        	  3057:             move.w #$F567,(a0)
00:000042A6 4A50            	  3058:             tst.w (a0)
00:000042A8 6AFE            	  3059:             bpl.s *                   * Check N Flag  bmi/bpl
00:000042AA 67FE            	  3060:             beq.s *                   * Check Z Flag  beq/bne
                            	  3061: 
                            	  3062: *     (An) - LONG
00:000042AC 4290            	  3063:             move.l #$00000000,(a0)
00:000042AE 4A90            	  3064:             tst.l (a0)
00:000042B0 6BFE            	  3065:             bmi.s *                   * Check N Flag  bmi/bpl
00:000042B2 66FE            	  3066:             bne.s *                   * Check Z Flag  beq/bne
00:000042B4 20BCF56789AB    	  3067:             move.l #$F56789ab,(a0)
00:000042BA 4A90            	  3068:             tst.l (a0)
00:000042BC 6AFE            	  3069:             bpl.s *                   * Check N Flag  bmi/bpl
00:000042BE 67FE            	  3070:             beq.s *                   * Check Z Flag  beq/bne
                            	  3071: 
                            	  3072: 
00:000042C0 4E75            	  3073:             rts
                            	  3074: 
                            	  3075: 
                            	  3076: *-----------------------------------------------------------
                            	  3077: *-----------------------------------------------------------
                            	  3078: * OPCODE : LINKS
                            	  3079: *-----------------------------------------------------------
                            	  3080: *-----------------------------------------------------------
                            	  3081: op_LINKS:
                            	  3082: 
00:000042C2 207C11223344    	  3083:             move.l #$11223344,a0
00:000042C8 203C11223344    	  3084:             move.l #$11223344,d0
00:000042CE 4E500000        	  3085:             link a0,#$0
00:000042D2 0C9711223344    	  3086:             cmpi.l #$11223344,(a7)
                            	  3087: 
00:000042D8 4E58            	  3088:             unlk a0
00:000042DA B1C0            	  3089:             cmp.l d0,a0
00:000042DC 66FE            	  3090:             bne.s *                   * branch if Z set
                            	  3091: 
00:000042DE 4E75            	  3092:             rts
                            	  3093: 
                            	  3094: *-----------------------------------------------------------
                            	  3095: *-----------------------------------------------------------
                            	  3096: * OPCODE : MOVE_USP
                            	  3097: *-----------------------------------------------------------
                            	  3098: *-----------------------------------------------------------
                            	  3099: op_MOVE_USP:
                            	  3100: 
00:000042E0 207C11223344    	  3101:             move.l #$11223344,a0
00:000042E6 4E60            	  3102:             move a0,USP
00:000042E8 4E69            	  3103:             move USP,a1
00:000042EA B3C8            	  3104:             cmp.l a0,a1
00:000042EC 66FE            	  3105:             bne.s *                   * branch if Z set
                            	  3106: 
00:000042EE 4E75            	  3107:             rts
                            	  3108: 
                            	  3109: 
                            	  3110: *-----------------------------------------------------------
                            	  3111: *-----------------------------------------------------------
                            	  3112: * OPCODE : CHK
                            	  3113: *-----------------------------------------------------------
                            	  3114: *-----------------------------------------------------------
                            	  3115: 
                            	  3116: op_CHK:
                            	  3117: 
00:000042F0 20780018        	  3118: 	move.l 6*4,a0							; get check vector
00:000042F4 21FC000027740018	  3119: 	move.l #EXCEPTION_6,6*4		; set vector
00:000042FC 303C1122        	  3120: 	move.w #$1122,d0
00:00004300 323C1122        	  3121: 	move.w #$1122,d1
00:00004304 4380            	  3122: 	chk d0,d1
                            	  3123: 
00:00004306 4E71            	  3124: 	nop
00:00004308 4E71            	  3125: 	nop
                            	  3126: 
00:0000430A 323C1122        	  3127: 	move.w #$1122,d1
00:0000430E 43BC1122        	  3128: 	chk #$1122,d1
                            	  3129: 
00:00004312 323C1122        	  3130: 	move.w #$1122,d1
00:00004316 43BC007A        	  3131: 	chk #00122,d1
00:0000431A BCBCEEEE0006    	  3132: 	cmp.l #$EEEE0006,d6
00:00004320 66FE            	  3133: 	bne.s *                   ; branch if Z set
                            	  3134: 
00:00004322 303C1122        	  3135: 	move.w #$1122,d0
00:00004326 323C8000        	  3136: 	move.w #$8000,d1
00:0000432A 4380            	  3137: 	chk d0,d1
00:0000432C BCBCEEEE0006    	  3138: 	cmp.l #$EEEE0006,d6
00:00004332 66FE            	  3139: 	bne.s *                   ; branch if Z set
                            	  3140: 
00:00004334 21C80018        	  3141: 	move.l a0,6*4							; restore old vector
00:00004338 4E75            	  3142: 	rts
                            	  3143: 
                            	  3144: 
                            	  3145: *-----------------------------------------------------------
                            	  3146: *-----------------------------------------------------------
                            	  3147: * OPCODE : NEGS
                            	  3148: *-----------------------------------------------------------
                            	  3149: *-----------------------------------------------------------
                            	  3150: op_NEGS:
                            	  3151: 
                            	  3152: *     NOT - BYTE
00:0000433A 307C0100        	  3153:             move.l #$00000100,a0
00:0000433E 7000            	  3154:             moveq  #$00000000,d0
00:00004340 4600            	  3155:             not.b d0
00:00004342 6AFE            	  3156:             bpl.s *                   * Check N Flag  bmi/bpl
00:00004344 67FE            	  3157:             beq.s *                   * Check Z Flag  beq/bne
00:00004346 4600            	  3158:             not.b d0
00:00004348 6BFE            	  3159:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000434A 66FE            	  3160:             bne.s *                   * Check Z Flag  beq/bne
00:0000434C 4A00            	  3161:             cmpi.b #$00,d0
00:0000434E 66FE            	  3162:             bne.s *                   * Check Z Flag  beq/bne
00:00004350 10BC0080        	  3163:             move.b #$80,(a0)
00:00004354 4610            	  3164:             not.b (a0)
00:00004356 6BFE            	  3165:             bmi.s *                   * Check N Flag  bmi/bpl
00:00004358 67FE            	  3166:             beq.s *                   * Check Z Flag  beq/bne
00:0000435A 4610            	  3167:             not.b (a0)
00:0000435C 6AFE            	  3168:             bpl.s *                   * Check N Flag  bmi/bpl
00:0000435E 67FE            	  3169:             beq.s *                   * Check Z Flag  beq/bne
00:00004360 0C100080        	  3170:             cmpi.b #$80,(a0)
00:00004364 66FE            	  3171:             bne.s *                   * Check Z Flag  beq/bne
                            	  3172: 
                            	  3173: *     NOT - WORD
00:00004366 307C0100        	  3174:             move.l #$00000100,a0
00:0000436A 7000            	  3175:             moveq  #$00000000,d0
00:0000436C 4640            	  3176:             not.w d0
00:0000436E 6AFE            	  3177:             bpl.s *                   * Check N Flag  bmi/bpl
00:00004370 67FE            	  3178:             beq.s *                   * Check Z Flag  beq/bne
00:00004372 4640            	  3179:             not.w d0
00:00004374 6BFE            	  3180:             bmi.s *                   * Check N Flag  bmi/bpl
00:00004376 66FE            	  3181:             bne.s *                   * Check Z Flag  beq/bne
00:00004378 4A40            	  3182:             cmpi.w #$0000,d0
00:0000437A 66FE            	  3183:             bne.s *                   * Check Z Flag  beq/bne
00:0000437C 30BC5A5A        	  3184:             move.w #$5a5a,(a0)
00:00004380 4650            	  3185:             not.w (a0)
00:00004382 6AFE            	  3186:             bpl.s *                   * Check N Flag  bmi/bpl
00:00004384 67FE            	  3187:             beq.s *                   * Check Z Flag  beq/bne
00:00004386 4650            	  3188:             not.w (a0)
00:00004388 6BFE            	  3189:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000438A 67FE            	  3190:             beq.s *                   * Check Z Flag  beq/bne
00:0000438C 0C505A5A        	  3191:             cmpi.w #$5a5a,(a0)
00:00004390 66FE            	  3192:             bne.s *                   * Check Z Flag  beq/bne
                            	  3193: 
                            	  3194: *     NOT - LONG
00:00004392 307C0100        	  3195:             move.l #$00000100,a0
00:00004396 7000            	  3196:             moveq  #$00000000,d0
00:00004398 4680            	  3197:             not.l d0
00:0000439A 6AFE            	  3198:             bpl.s *                   * Check N Flag  bmi/bpl
00:0000439C 67FE            	  3199:             beq.s *                   * Check Z Flag  beq/bne
00:0000439E 4680            	  3200:             not.l d0
00:000043A0 6BFE            	  3201:             bmi.s *                   * Check N Flag  bmi/bpl
00:000043A2 66FE            	  3202:             bne.s *                   * Check Z Flag  beq/bne
00:000043A4 4A80            	  3203:             cmpi.l #$00000000,d0
00:000043A6 66FE            	  3204:             bne.s *                   * Check Z Flag  beq/bne
00:000043A8 20BC5A5A1234    	  3205:             move.l #$5a5a1234,(a0)
00:000043AE 4690            	  3206:             not.l (a0)
00:000043B0 6AFE            	  3207:             bpl.s *                   * Check N Flag  bmi/bpl
00:000043B2 67FE            	  3208:             beq.s *                   * Check Z Flag  beq/bne
00:000043B4 4690            	  3209:             not.l (a0)
00:000043B6 6BFE            	  3210:             bmi.s *                   * Check N Flag  bmi/bpl
00:000043B8 67FE            	  3211:             beq.s *                   * Check Z Flag  beq/bne
00:000043BA 0C905A5A1234    	  3212:             cmpi.l #$5a5a1234,(a0)
00:000043C0 66FE            	  3213:             bne.s *                   * Check Z Flag  beq/bne
                            	  3214: 
                            	  3215: * -----
                            	  3216: 
                            	  3217: *     NEG - BYTE
00:000043C2 307C0100        	  3218:             move.l #$00000100,a0
00:000043C6 7000            	  3219:             moveq  #$00000000,d0
00:000043C8 7240D241        	  3220:             move.l #$00000080,d1
00:000043CC 4400            	  3221:             neg.b d0
00:000043CE 6BFE            	  3222:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000043D0 66FE            	  3223:             bne.s *                   * Check Z Flag  beq/bne 1
00:000043D2 65FE            	  3224:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:000043D4 69FE            	  3225:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000043D6 4401            	  3226:             neg.b d1
00:000043D8 6AFE            	  3227:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000043DA 67FE            	  3228:             beq.s *                   * Check Z Flag  beq/bne 0
00:000043DC 64FE            	  3229:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000043DE 68FE            	  3230:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:000043E0 0C010080        	  3231:             cmpi.b #$80,d1
00:000043E4 66FE            	  3232:             bne.s *                   * Check Z Flag  beq/bne
00:000043E6 10BC007F        	  3233:             move.b #$7F,(a0)
00:000043EA 4410            	  3234:             neg.b (a0)
00:000043EC 6AFE            	  3235:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000043EE 67FE            	  3236:             beq.s *                   * Check Z Flag  beq/bne 0
00:000043F0 64FE            	  3237:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000043F2 69FE            	  3238:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000043F4 10BC00F5        	  3239:             move.b #$F5,(a0)
00:000043F8 4410            	  3240:             neg.b (a0)
00:000043FA 6BFE            	  3241:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000043FC 67FE            	  3242:             beq.s *                   * Check Z Flag  beq/bne 0
00:000043FE 64FE            	  3243:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004400 69FE            	  3244:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004402 0C10000B        	  3245:             cmpi.b #$0B,(a0)
00:00004406 66FE            	  3246:             bne.s *                   * Check Z Flag  beq/bne
                            	  3247: 
                            	  3248: * -----
                            	  3249: 
                            	  3250: *     NEG - WORD
00:00004408 307C0100        	  3251:             move.l #$00000100,a0
00:0000440C 7000            	  3252:             moveq  #$00000000,d0
00:0000440E 223C00008000    	  3253:             move.l #$00008000,d1
00:00004414 4440            	  3254:             neg.w d0
00:00004416 6BFE            	  3255:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004418 66FE            	  3256:             bne.s *                   * Check Z Flag  beq/bne 1
00:0000441A 65FE            	  3257:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:0000441C 69FE            	  3258:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000441E 4441            	  3259:             neg.w d1
00:00004420 6AFE            	  3260:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004422 67FE            	  3261:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004424 64FE            	  3262:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004426 68FE            	  3263:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:00004428 0C418000        	  3264:             cmpi.w #$8000,d1
00:0000442C 66FE            	  3265:             bne.s *                   * Check Z Flag  beq/bne
00:0000442E 30BC7FFF        	  3266:             move.w #$7FFF,(a0)
00:00004432 4450            	  3267:             neg.w (a0)
00:00004434 6AFE            	  3268:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004436 67FE            	  3269:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004438 64FE            	  3270:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000443A 69FE            	  3271:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000443C 30BCF578        	  3272:             move.w #$F578,(a0)
00:00004440 4450            	  3273:             neg.w (a0)
00:00004442 6BFE            	  3274:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004444 67FE            	  3275:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004446 64FE            	  3276:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004448 69FE            	  3277:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000444A 0C500A88        	  3278:             cmpi.w #$0A88,(a0)
00:0000444E 66FE            	  3279:             bne.s *                   * Check Z Flag  beq/bne
                            	  3280: 
                            	  3281: * -----
                            	  3282: 
                            	  3283: *     NEG - LONG
00:00004450 307C0100        	  3284:             move.l #$00000100,a0
00:00004454 7000            	  3285:             moveq  #$00000000,d0
00:00004456 223C80000000    	  3286:             move.l #$80000000,d1
00:0000445C 4480            	  3287:             neg.l d0
00:0000445E 6BFE            	  3288:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004460 66FE            	  3289:             bne.s *                   * Check Z Flag  beq/bne 1
00:00004462 65FE            	  3290:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:00004464 69FE            	  3291:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004466 4481            	  3292:             neg.l d1
00:00004468 6AFE            	  3293:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:0000446A 67FE            	  3294:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000446C 64FE            	  3295:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000446E 68FE            	  3296:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:00004470 0C8180000000    	  3297:             cmpi.l #$80000000,d1
00:00004476 66FE            	  3298:             bne.s *                   * Check Z Flag  beq/bne
00:00004478 20BC7FFFFFFF    	  3299:             move.l #$7FFFFFFF,(a0)
00:0000447E 4490            	  3300:             neg.l (a0)
00:00004480 6AFE            	  3301:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004482 67FE            	  3302:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004484 64FE            	  3303:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004486 69FE            	  3304:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004488 20BCF5781234    	  3305:             move.l #$F5781234,(a0)
00:0000448E 4490            	  3306:             neg.l (a0)
00:00004490 6BFE            	  3307:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004492 67FE            	  3308:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004494 64FE            	  3309:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004496 69FE            	  3310:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004498 0C900A87EDCC    	  3311:             cmpi.l #$0A87EDCC,(a0)
00:0000449E 66FE            	  3312:             bne.s *                   * Check Z Flag  beq/bne
                            	  3313: 
                            	  3314: 
                            	  3315: * -----
                            	  3316: 
                            	  3317: *     NEGX - BYTE
00:000044A0 307C0100        	  3318:             move.l #$00000100,a0
00:000044A4 7000            	  3319:             moveq  #$00000000,d0
00:000044A6 7240D241        	  3320:             move.l #$00000080,d1
00:000044AA 003C0010        	  3321:             ori.b #$10,CCR        * Set X Flag
00:000044AE 4000            	  3322:             negx.b d0
00:000044B0 6AFE            	  3323:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:000044B2 67FE            	  3324:             beq.s *                   * Check Z Flag  beq/bne 1
00:000044B4 64FE            	  3325:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:000044B6 69FE            	  3326:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000044B8 023C00EF        	  3327:             andi.b #$EF,CCR       * Clear X Flag
00:000044BC 4000            	  3328:             negx.b d0
00:000044BE 6BFE            	  3329:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000044C0 67FE            	  3330:             beq.s *                   * Check Z Flag  beq/bne 1
00:000044C2 64FE            	  3331:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:000044C4 69FE            	  3332:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000044C6 003C0010        	  3333:             ori.b #$10,CCR        * Set X Flag
00:000044CA 4001            	  3334:             negx.b d1
00:000044CC 6BFE            	  3335:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:000044CE 67FE            	  3336:             beq.s *                   * Check Z Flag  beq/bne 0
00:000044D0 64FE            	  3337:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000044D2 69FE            	  3338:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:000044D4 0C01007F        	  3339:             cmpi.b #$7F,d1
00:000044D8 66FE            	  3340:             bne.s *                   * Check Z Flag  beq/bne
00:000044DA 023C00EF        	  3341:             andi.b #$EF,CCR       * Clear X Flag
00:000044DE 4001            	  3342:             negx.b d1
00:000044E0 6AFE            	  3343:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000044E2 67FE            	  3344:             beq.s *                   * Check Z Flag  beq/bne 0
00:000044E4 64FE            	  3345:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000044E6 69FE            	  3346:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:000044E8 0C010081        	  3347:             cmpi.b #$81,d1
00:000044EC 66FE            	  3348:             bne.s *                   * Check Z Flag  beq/bne
00:000044EE 10BC007F        	  3349:             move.b #$7F,(a0)
00:000044F2 003C0010        	  3350:             ori.b #$10,CCR        * Set X Flag
00:000044F6 4010            	  3351:             negx.b (a0)
00:000044F8 6AFE            	  3352:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000044FA 67FE            	  3353:             beq.s *                   * Check Z Flag  beq/bne 0
00:000044FC 64FE            	  3354:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3355:             * I think overflow should happen here.
                            	  3356: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:000044FE 10BC007F        	  3357:             move.b #$7F,(a0)
00:00004502 023C00EF        	  3358:             andi.b #$EF,CCR       * Clear X Flag
00:00004506 4010            	  3359:             negx.b (a0)
00:00004508 6AFE            	  3360:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:0000450A 67FE            	  3361:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000450C 64FE            	  3362:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000450E 69FE            	  3363:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004510 10BC00F5        	  3364:             move.b #$F5,(a0)
00:00004514 003C0010        	  3365:             ori.b #$10,CCR        * Set X Flag
00:00004518 4010            	  3366:             negx.b (a0)
00:0000451A 6BFE            	  3367:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:0000451C 67FE            	  3368:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000451E 64FE            	  3369:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004520 69FE            	  3370:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004522 0C10000A        	  3371:             cmpi.b #$0A,(a0)
00:00004526 66FE            	  3372:             bne.s *                   * Check Z Flag  beq/bne
00:00004528 023C00EF        	  3373:             andi.b #$EF,CCR       * Clear X Flag
00:0000452C 4010            	  3374:             negx.b (a0)
00:0000452E 6AFE            	  3375:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:00004530 67FE            	  3376:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004532 64FE            	  3377:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004534 69FE            	  3378:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004536 0C1000F6        	  3379:             cmpi.b #$F6,(a0)
00:0000453A 66FE            	  3380:             bne.s *                   * Check Z Flag  beq/bne
                            	  3381: 
                            	  3382: 
                            	  3383: 
                            	  3384: * -----
                            	  3385: 
                            	  3386: *     NEGX - WORD
00:0000453C 307C0100        	  3387:             move.l #$00000100,a0
00:00004540 7000            	  3388:             moveq  #$00000000,d0
00:00004542 223C00008000    	  3389:             move.l #$00008000,d1
00:00004548 003C0010        	  3390:             ori.b #$10,CCR        * Set X Flag
00:0000454C 4040            	  3391:             negx.w d0
00:0000454E 6AFE            	  3392:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:00004550 67FE            	  3393:             beq.s *                   * Check Z Flag  beq/bne 1
00:00004552 64FE            	  3394:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:00004554 69FE            	  3395:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004556 023C00EF        	  3396:             andi.b #$EF,CCR       * Clear X Flag
00:0000455A 4040            	  3397:             negx.w d0
00:0000455C 6BFE            	  3398:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:0000455E 67FE            	  3399:             beq.s *                   * Check Z Flag  beq/bne 1
00:00004560 64FE            	  3400:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:00004562 69FE            	  3401:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004564 003C0010        	  3402:             ori.b #$10,CCR        * Set X Flag
00:00004568 4041            	  3403:             negx.w d1
00:0000456A 6BFE            	  3404:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:0000456C 67FE            	  3405:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000456E 64FE            	  3406:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004570 69FE            	  3407:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:00004572 0C417FFF        	  3408:             cmpi.w #$7FFF,d1
00:00004576 66FE            	  3409:             bne.s *                   * Check Z Flag  beq/bne
00:00004578 023C00EF        	  3410:             andi.b #$EF,CCR       * Clear X Flag
00:0000457C 4041            	  3411:             negx.w d1
00:0000457E 6AFE            	  3412:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004580 67FE            	  3413:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004582 64FE            	  3414:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004584 69FE            	  3415:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:00004586 0C418001        	  3416:             cmpi.w #$8001,d1
00:0000458A 66FE            	  3417:             bne.s *                   * Check Z Flag  beq/bne
00:0000458C 30BC7FFF        	  3418:             move.w #$7FFF,(a0)
00:00004590 003C0010        	  3419:             ori.b #$10,CCR        * Set X Flag
00:00004594 4050            	  3420:             negx.w (a0)
00:00004596 6AFE            	  3421:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004598 67FE            	  3422:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000459A 64FE            	  3423:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3424: ***            
                            	  3425: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000459C 30BCF567        	  3426:             move.w #$F567,(a0)
00:000045A0 023C00EF        	  3427:             andi.b #$EF,CCR       * Clear X Flag
00:000045A4 4050            	  3428:             negx.w (a0)
00:000045A6 6BFE            	  3429:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:000045A8 67FE            	  3430:             beq.s *                   * Check Z Flag  beq/bne 0
00:000045AA 64FE            	  3431:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000045AC 69FE            	  3432:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000045AE 30BCF567        	  3433:             move.w #$F567,(a0)
00:000045B2 003C0010        	  3434:             ori.b #$10,CCR        * Set X Flag
00:000045B6 4050            	  3435:             negx.w (a0)
00:000045B8 6BFE            	  3436:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000045BA 67FE            	  3437:             beq.s *                   * Check Z Flag  beq/bne 0
00:000045BC 64FE            	  3438:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000045BE 69FE            	  3439:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000045C0 0C500A98        	  3440:             cmpi.w #$0A98,(a0)
00:000045C4 66FE            	  3441:             bne.s *                   * Check Z Flag  beq/bne
00:000045C6 023C00EF        	  3442:             andi.b #$EF,CCR       * Clear X Flag
00:000045CA 4050            	  3443:             negx.w (a0)
00:000045CC 6AFE            	  3444:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:000045CE 67FE            	  3445:             beq.s *                   * Check Z Flag  beq/bne 0
00:000045D0 64FE            	  3446:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000045D2 69FE            	  3447:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000045D4 0C50F568        	  3448:             cmpi.w #$F568,(a0)
00:000045D8 66FE            	  3449:             bne.s *                   * Check Z Flag  beq/bne
                            	  3450: 
                            	  3451: 
                            	  3452: * -----
                            	  3453: 
                            	  3454: *     NEGX - LONG
00:000045DA 307C0100        	  3455:             move.l #$00000100,a0
00:000045DE 7000            	  3456:             moveq  #$00000000,d0
00:000045E0 223C80000000    	  3457:             move.l #$80000000,d1
00:000045E6 003C0010        	  3458:             ori.b #$10,CCR        * Set X Flag
00:000045EA 4080            	  3459:             negx.l d0
00:000045EC 6AFE            	  3460:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:000045EE 67FE            	  3461:             beq.s *                   * Check Z Flag  beq/bne 1
00:000045F0 64FE            	  3462:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:000045F2 69FE            	  3463:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000045F4 023C00EF        	  3464:             andi.b #$EF,CCR       * Clear X Flag
00:000045F8 4080            	  3465:             negx.l d0
00:000045FA 6BFE            	  3466:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000045FC 67FE            	  3467:             beq.s *                   * Check Z Flag  beq/bne 1
00:000045FE 64FE            	  3468:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:00004600 69FE            	  3469:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004602 003C0010        	  3470:             ori.b #$10,CCR        * Set X Flag
00:00004606 4081            	  3471:             negx.l d1
00:00004608 6BFE            	  3472:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:0000460A 67FE            	  3473:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000460C 64FE            	  3474:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000460E 69FE            	  3475:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:00004610 0C817FFFFFFF    	  3476:             cmpi.l #$7FFFFFFF,d1
00:00004616 66FE            	  3477:             bne.s *                   * Check Z Flag  beq/bne
00:00004618 023C00EF        	  3478:             andi.b #$EF,CCR       * Clear X Flag
00:0000461C 4081            	  3479:             negx.l d1
00:0000461E 6AFE            	  3480:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004620 67FE            	  3481:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004622 64FE            	  3482:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3483: ****            
                            	  3484: *            bvs.s *                   * Check V Flag  bvc/bvs 0
00:00004624 0C8180000001    	  3485:             cmpi.l #$80000001,d1
00:0000462A 66FE            	  3486:             bne.s *                   * Check Z Flag  beq/bne
00:0000462C 20BC00007FFF    	  3487:             move.l #$7FFF,(a0)
00:00004632 003C0010        	  3488:             ori.b #$10,CCR        * Set X Flag
00:00004636 4090            	  3489:             negx.l (a0)
00:00004638 6AFE            	  3490:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:0000463A 67FE            	  3491:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000463C 64FE            	  3492:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3493: ****            
                            	  3494: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000463E 20BCF5671234    	  3495:             move.l #$F5671234,(a0)
00:00004644 023C00EF        	  3496:             andi.b #$EF,CCR       * Clear X Flag
00:00004648 4090            	  3497:             negx.l (a0)
00:0000464A 6BFE            	  3498:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:0000464C 67FE            	  3499:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000464E 64FE            	  3500:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004650 69FE            	  3501:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004652 20BCF5675678    	  3502:             move.l #$F5675678,(a0)
00:00004658 003C0010        	  3503:             ori.b #$10,CCR        * Set X Flag
00:0000465C 4090            	  3504:             negx.l (a0)
00:0000465E 6BFE            	  3505:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004660 67FE            	  3506:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004662 64FE            	  3507:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004664 69FE            	  3508:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004666 0C900A98A987    	  3509:             cmpi.l #$0A98A987,(a0)
00:0000466C 66FE            	  3510:             bne.s *                   * Check Z Flag  beq/bne
00:0000466E 023C00EF        	  3511:             andi.b #$EF,CCR       * Clear X Flag
00:00004672 4090            	  3512:             negx.l (a0)
00:00004674 6AFE            	  3513:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:00004676 67FE            	  3514:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004678 64FE            	  3515:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000467A 69FE            	  3516:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000467C 0C90F5675679    	  3517:             cmpi.l #$F5675679,(a0)
00:00004682 66FE            	  3518:             bne.s *                   * Check Z Flag  beq/bne
                            	  3519: 
                            	  3520: 
                            	  3521: * -----
                            	  3522: 
                            	  3523: *     CLR - BYTE
00:00004684 307C0100        	  3524:             move.l #$00000100,a0
00:00004688 203C12345678    	  3525:             move.l #$12345678,d0
00:0000468E 223C12345678    	  3526:             move.l #$12345678,d1
00:00004694 243C12345678    	  3527:             move.l #$12345678,d2
00:0000469A 283C12345600    	  3528:             move.l #$12345600,d4
00:000046A0 2A3C12340000    	  3529:             move.l #$12340000,d5
00:000046A6 7C00            	  3530:             moveq  #$00000000,d6
                            	  3531: 
00:000046A8 4200            	  3532:             clr.b d0
00:000046AA 66FE            	  3533:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046AC 6BFE            	  3534:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000046AE B880            	  3535:             cmp.l d0,d4
00:000046B0 66FE            	  3536:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3537: 
00:000046B2 4241            	  3538:             clr.w d1
00:000046B4 66FE            	  3539:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046B6 6BFE            	  3540:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000046B8 BA81            	  3541:             cmp.l d1,d5
00:000046BA 66FE            	  3542:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3543: 
00:000046BC 7400            	  3544:             clr.l d2
00:000046BE 66FE            	  3545:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046C0 6BFE            	  3546:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000046C2 BC82            	  3547:             cmp.l d2,d6
00:000046C4 66FE            	  3548:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3549: 
00:000046C6 4E75            	  3550:             rts
                            	  3551: 
                            	  3552: 
                            	  3553: 
                            	  3554: *-----------------------------------------------------------
                            	  3555: *-----------------------------------------------------------
                            	  3556: * OPCODE : MOVEM
                            	  3557: *-----------------------------------------------------------
                            	  3558: *-----------------------------------------------------------
                            	  3559: op_MOVEM:
                            	  3560: 
                            	  3561: *     WORD  Registers --> Memory
00:000046C8 203C0000D0D0    	  3562:             move.l #$0000d0d0,d0
00:000046CE 223C0000D1D1    	  3563:             move.l #$0000d1d1,d1
00:000046D4 243C0000D2D2    	  3564:             move.l #$0000d2d2,d2
00:000046DA 263C0000D3D3    	  3565:             move.l #$0000d3d3,d3
00:000046E0 283C0000D4D4    	  3566:             move.l #$0000d4d4,d4
00:000046E6 2A3C0000D5D5    	  3567:             move.l #$0000d5d5,d5
00:000046EC 2C3C0000D6D6    	  3568:             move.l #$0000d6d6,d6
00:000046F2 2E3C0000D7D7    	  3569:             move.l #$0000d7d7,d7
00:000046F8 307C0A0A        	  3570:             move.l #$00000a0a,a0
00:000046FC 327C1A1A        	  3571:             move.l #$00001a1a,a1
00:00004700 347C2A2A        	  3572:             move.l #$00002a2a,a2
00:00004704 367C3A3A        	  3573:             move.l #$00003a3a,a3
00:00004708 387C4A4A        	  3574:             move.l #$00004a4a,a4
00:0000470C 3A7C5A5A        	  3575:             move.l #$00005a5a,a5
00:00004710 3C7C6A6A        	  3576:             move.l #$00006a6a,a6
                            	  3577: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3578: 
00:00004714 48B8FFFF0100    	  3579:             movem.w D0-D7/A0-A7,$00000100
                            	  3580: 
00:0000471A 307C0100        	  3581:             move.l #$00000100,a0
                            	  3582: 
00:0000471E B058            	  3583:             cmp.w (a0)+,d0
00:00004720 66FE            	  3584:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004722 B258            	  3585:             cmp.w (a0)+,d1
00:00004724 66FE            	  3586:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004726 B458            	  3587:             cmp.w (a0)+,d2
00:00004728 66FE            	  3588:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000472A B658            	  3589:             cmp.w (a0)+,d3
00:0000472C 66FE            	  3590:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000472E B858            	  3591:             cmp.w (a0)+,d4
00:00004730 66FE            	  3592:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004732 BA58            	  3593:             cmp.w (a0)+,d5
00:00004734 66FE            	  3594:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004736 BC58            	  3595:             cmp.w (a0)+,d6
00:00004738 66FE            	  3596:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000473A BE58            	  3597:             cmp.w (a0)+,d7
00:0000473C 66FE            	  3598:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3599: 
00:0000473E 0C580A0A        	  3600:             cmpi.w #$0A0A,(a0)+    * Because we are using a0 as a pointer
00:00004742 66FE            	  3601:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3602: 
00:00004744 B2D8            	  3603:             cmp.w (a0)+,a1
00:00004746 66FE            	  3604:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004748 B4D8            	  3605:             cmp.w (a0)+,a2
00:0000474A 66FE            	  3606:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000474C B6D8            	  3607:             cmp.w (a0)+,a3
00:0000474E 66FE            	  3608:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004750 B8D8            	  3609:             cmp.w (a0)+,a4
00:00004752 66FE            	  3610:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004754 BAD8            	  3611:             cmp.w (a0)+,a5
00:00004756 66FE            	  3612:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004758 BCD8            	  3613:             cmp.w (a0)+,a6
00:0000475A 66FE            	  3614:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3615: 
                            	  3616: 
                            	  3617: 
                            	  3618: 
                            	  3619: *     LONG  Registers --> Memory
00:0000475C 203CD0D0D0D0    	  3620:             move.l #$d0d0d0d0,d0
00:00004762 223CD1D1D1D1    	  3621:             move.l #$d1d1d1d1,d1
00:00004768 243CD2D2D2D2    	  3622:             move.l #$d2d2d2d2,d2
00:0000476E 263CD3D3D3D3    	  3623:             move.l #$d3d3d3d3,d3
00:00004774 283CD4D4D4D4    	  3624:             move.l #$d4d4d4d4,d4
00:0000477A 2A3CD5D5D5D5    	  3625:             move.l #$d5d5d5d5,d5
00:00004780 2C3CD6D6D6D6    	  3626:             move.l #$d6d6d6d6,d6
00:00004786 2E3CD7D7D7D7    	  3627:             move.l #$d7d7d7d7,d7
00:0000478C 207C0A0A0A0A    	  3628:             move.l #$0a0a0a0a,a0
00:00004792 227C1A1A1A1A    	  3629:             move.l #$1a1a1a1a,a1
00:00004798 247C2A2A2A2A    	  3630:             move.l #$2a2a2a2a,a2
00:0000479E 267C3A3A3A3A    	  3631:             move.l #$3a3a3a3a,a3
00:000047A4 287C4A4A4A4A    	  3632:             move.l #$4a4a4a4a,a4
00:000047AA 2A7C5A5A5A5A    	  3633:             move.l #$5a5a5a5a,a5
00:000047B0 2C7C6A6A6A6A    	  3634:             move.l #$6a6a6a6a,a6
                            	  3635: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3636: 
                            	  3637: 
00:000047B6 48F8FFFF0120    	  3638:             movem.l D0-D7/A0-A7,$00000120
                            	  3639: 
00:000047BC 307C0120        	  3640:             move.l #$00000120,a0
                            	  3641: 
00:000047C0 B098            	  3642:             cmp.l (a0)+,d0
00:000047C2 66FE            	  3643:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047C4 B298            	  3644:             cmp.l (a0)+,d1
00:000047C6 66FE            	  3645:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047C8 B498            	  3646:             cmp.l (a0)+,d2
00:000047CA 66FE            	  3647:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047CC B698            	  3648:             cmp.l (a0)+,d3
00:000047CE 66FE            	  3649:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047D0 B898            	  3650:             cmp.l (a0)+,d4
00:000047D2 66FE            	  3651:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047D4 BA98            	  3652:             cmp.l (a0)+,d5
00:000047D6 66FE            	  3653:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047D8 BC98            	  3654:             cmp.l (a0)+,d6
00:000047DA 66FE            	  3655:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047DC BE98            	  3656:             cmp.l (a0)+,d7
00:000047DE 66FE            	  3657:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3658: 
00:000047E0 0C980A0A0A0A    	  3659:             cmpi.l #$0A0A0A0A,(a0)+    * Because we are using a0 as a pointer
00:000047E6 66FE            	  3660:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3661: 
00:000047E8 B3D8            	  3662:             cmp.l (a0)+,a1
00:000047EA 66FE            	  3663:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047EC B5D8            	  3664:             cmp.l (a0)+,a2
00:000047EE 66FE            	  3665:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047F0 B7D8            	  3666:             cmp.l (a0)+,a3
00:000047F2 66FE            	  3667:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047F4 B9D8            	  3668:             cmp.l (a0)+,a4
00:000047F6 66FE            	  3669:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047F8 BBD8            	  3670:             cmp.l (a0)+,a5
00:000047FA 66FE            	  3671:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047FC BDD8            	  3672:             cmp.l (a0)+,a6
00:000047FE 66FE            	  3673:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3674: *      ----
                            	  3675: 
                            	  3676: 
                            	  3677: *     WORD  Registers --> Memory  -(An) EA Mode
00:00004800 203C0000D0D0    	  3678:             move.l #$0000d0d0,d0
00:00004806 223C0000D1D1    	  3679:             move.l #$0000d1d1,d1
00:0000480C 243C0000D2D2    	  3680:             move.l #$0000d2d2,d2
00:00004812 263C0000D3D3    	  3681:             move.l #$0000d3d3,d3
00:00004818 283C0000D4D4    	  3682:             move.l #$0000d4d4,d4
00:0000481E 2A3C0000D5D5    	  3683:             move.l #$0000d5d5,d5
00:00004824 2C3C0000D6D6    	  3684:             move.l #$0000d6d6,d6
00:0000482A 2E3C0000D7D7    	  3685:             move.l #$0000d7d7,d7
00:00004830 307C0A0A        	  3686:             move.l #$00000a0a,a0
00:00004834 327C1A1A        	  3687:             move.l #$00001a1a,a1
00:00004838 347C2A2A        	  3688:             move.l #$00002a2a,a2
00:0000483C 367C3A3A        	  3689:             move.l #$00003a3a,a3
00:00004840 387C4A4A        	  3690:             move.l #$00004a4a,a4
00:00004844 3A7C5A5A        	  3691:             move.l #$00005a5a,a5
00:00004848 3C7C6A6A        	  3692:             move.l #$00006a6a,a6
                            	  3693: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3694: 
00:0000484C 307C01A0        	  3695:             move.l #$000001A0,a0
00:00004850 48A0FFFF        	  3696:             movem.w D0-D7/A0-A7,-(a0)
                            	  3697: 
00:00004854 307C019E        	  3698:             move.l #$0000019E,a0
                            	  3699: 
00:00004858 BCE0            	  3700:             cmp.w -(a0),a6
00:0000485A 66FE            	  3701:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000485C BAE0            	  3702:             cmp.w -(a0),a5
00:0000485E 66FE            	  3703:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004860 B8E0            	  3704:             cmp.w -(a0),a4
00:00004862 66FE            	  3705:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004864 B6E0            	  3706:             cmp.w -(a0),a3
00:00004866 66FE            	  3707:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004868 B4E0            	  3708:             cmp.w -(a0),a2
00:0000486A 66FE            	  3709:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000486C B2E0            	  3710:             cmp.w -(a0),a1
00:0000486E 66FE            	  3711:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004870 B0E0            	  3712:             cmp.w -(a0),a0
                            	  3713: *            bne.s *                   * Check Z Flag  beq/bne 0
00:00004872 BE60            	  3714:             cmp.w -(a0),d7
00:00004874 66FE            	  3715:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004876 BC60            	  3716:             cmp.w -(a0),d6
00:00004878 66FE            	  3717:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000487A BA60            	  3718:             cmp.w -(a0),d5
00:0000487C 66FE            	  3719:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000487E B860            	  3720:             cmp.w -(a0),d4
00:00004880 66FE            	  3721:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004882 B660            	  3722:             cmp.w -(a0),d3
00:00004884 66FE            	  3723:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004886 B460            	  3724:             cmp.w -(a0),d2
00:00004888 66FE            	  3725:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000488A B260            	  3726:             cmp.w -(a0),d1
00:0000488C 66FE            	  3727:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000488E B060            	  3728:             cmp.w -(a0),d0
00:00004890 66FE            	  3729:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3730: 
                            	  3731: 
                            	  3732: 
                            	  3733: 
                            	  3734: *     LONG  Registers --> Memory   -(An) EA Mode
00:00004892 203CD0D0D0D0    	  3735:             move.l #$d0d0d0d0,d0
00:00004898 223CD1D1D1D1    	  3736:             move.l #$d1d1d1d1,d1
00:0000489E 243CD2D2D2D2    	  3737:             move.l #$d2d2d2d2,d2
00:000048A4 263CD3D3D3D3    	  3738:             move.l #$d3d3d3d3,d3
00:000048AA 283CD4D4D4D4    	  3739:             move.l #$d4d4d4d4,d4
00:000048B0 2A3CD5D5D5D5    	  3740:             move.l #$d5d5d5d5,d5
00:000048B6 2C3CD6D6D6D6    	  3741:             move.l #$d6d6d6d6,d6
00:000048BC 2E3CD7D7D7D7    	  3742:             move.l #$d7d7d7d7,d7
00:000048C2 207C0A0A0A0A    	  3743:             move.l #$0a0a0a0a,a0
00:000048C8 227C1A1A1A1A    	  3744:             move.l #$1a1a1a1a,a1
00:000048CE 247C2A2A2A2A    	  3745:             move.l #$2a2a2a2a,a2
00:000048D4 267C3A3A3A3A    	  3746:             move.l #$3a3a3a3a,a3
00:000048DA 287C4A4A4A4A    	  3747:             move.l #$4a4a4a4a,a4
00:000048E0 2A7C5A5A5A5A    	  3748:             move.l #$5a5a5a5a,a5
00:000048E6 2C7C6A6A6A6A    	  3749:             move.l #$6a6a6a6a,a6
                            	  3750: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3751: 
                            	  3752: 
00:000048EC 307C01A0        	  3753:             move.l #$000001A0,a0
00:000048F0 48E0FFFF        	  3754:             movem.l D0-D7/A0-A7,-(a0)
                            	  3755: 
00:000048F4 307C019C        	  3756:             move.l #$0000019C,a0
                            	  3757: 
00:000048F8 BDE0            	  3758:             cmp.l -(a0),a6
00:000048FA 66FE            	  3759:             bne.s *                   * Check Z Flag  beq/bne 0
00:000048FC BBE0            	  3760:             cmp.l -(a0),a5
00:000048FE 66FE            	  3761:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004900 B9E0            	  3762:             cmp.l -(a0),a4
00:00004902 66FE            	  3763:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004904 B7E0            	  3764:             cmp.l -(a0),a3
00:00004906 66FE            	  3765:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004908 B5E0            	  3766:             cmp.l -(a0),a2
00:0000490A 66FE            	  3767:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000490C B3E0            	  3768:             cmp.l -(a0),a1
00:0000490E 66FE            	  3769:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004910 B1E0            	  3770:             cmp.l -(a0),a0
                            	  3771: *            bne.s *                   * Check Z Flag  beq/bne 0
00:00004912 BEA0            	  3772:             cmp.l -(a0),d7
00:00004914 66FE            	  3773:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004916 BCA0            	  3774:             cmp.l -(a0),d6
00:00004918 66FE            	  3775:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000491A BAA0            	  3776:             cmp.l -(a0),d5
00:0000491C 66FE            	  3777:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000491E B8A0            	  3778:             cmp.l -(a0),d4
00:00004920 66FE            	  3779:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004922 B6A0            	  3780:             cmp.l -(a0),d3
00:00004924 66FE            	  3781:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004926 B4A0            	  3782:             cmp.l -(a0),d2
00:00004928 66FE            	  3783:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000492A B2A0            	  3784:             cmp.l -(a0),d1
00:0000492C 66FE            	  3785:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000492E B0A0            	  3786:             cmp.l -(a0),d0
00:00004930 66FE            	  3787:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3788: 
                            	  3789: 
                            	  3790: 
                            	  3791: *     ----
                            	  3792: 
                            	  3793: *     WORD - Memory --> Registers
00:00004932 7000            	  3794:             moveq  #$00000000,d0
00:00004934 7200            	  3795:             moveq  #$00000000,d1
00:00004936 7400            	  3796:             moveq  #$00000000,d2
00:00004938 7600            	  3797:             moveq  #$00000000,d3
00:0000493A 7800            	  3798:             moveq  #$00000000,d4
00:0000493C 7A00            	  3799:             moveq  #$00000000,d5
00:0000493E 7C00            	  3800:             moveq  #$00000000,d6
00:00004940 7E00            	  3801:             moveq  #$00000000,d7
00:00004942 91C8            	  3802:             move.l #$00000000,a0
00:00004944 93C9            	  3803:             move.l #$00000000,a1
00:00004946 95CA            	  3804:             move.l #$00000000,a2
00:00004948 97CB            	  3805:             move.l #$00000000,a3
00:0000494A 99CC            	  3806:             move.l #$00000000,a4
00:0000494C 9BCD            	  3807:             move.l #$00000000,a5
00:0000494E 9DCE            	  3808:             move.l #$00000000,a6
                            	  3809: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3810: 
00:00004950 4CB82A550100    	  3811:             movem.w $00000100,D0/D2/D4/D6/A1/A3/A5
                            	  3812: 
00:00004956 B0BCFFFFD0D0    	  3813:             cmp.l #$FFFFD0D0,d0
00:0000495C 66FE            	  3814:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000495E B4BCFFFFD1D1    	  3815:             cmp.l #$FFFFD1D1,d2
00:00004964 66FE            	  3816:             bne.s *                  * Check Z Flag  beq/bne 0
00:00004966 B8BCFFFFD2D2    	  3817:             cmp.l #$FFFFD2D2,d4
00:0000496C 66FE            	  3818:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000496E BCBCFFFFD3D3    	  3819:             cmp.l #$FFFFD3D3,d6
00:00004974 66FE            	  3820:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004976 B2FCD4D4        	  3821:             cmp.l #$FFFFD4D4,a1
00:0000497A 66FE            	  3822:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000497C B6FCD5D5        	  3823:             cmp.l #$FFFFD5D5,a3
00:00004980 66FE            	  3824:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004982 BAFCD6D6        	  3825:             cmp.l #$FFFFD6D6,a5
00:00004986 66FE            	  3826:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3827: 
                            	  3828: 
                            	  3829: *     LONG - Memory --> Registers
00:00004988 7000            	  3830:             moveq  #$00000000,d0
00:0000498A 7200            	  3831:             moveq  #$00000000,d1
00:0000498C 7400            	  3832:             moveq  #$00000000,d2
00:0000498E 7600            	  3833:             moveq  #$00000000,d3
00:00004990 7800            	  3834:             moveq  #$00000000,d4
00:00004992 7A00            	  3835:             moveq  #$00000000,d5
00:00004994 7C00            	  3836:             moveq  #$00000000,d6
00:00004996 7E00            	  3837:             moveq  #$00000000,d7
00:00004998 91C8            	  3838:             move.l #$00000000,a0
00:0000499A 93C9            	  3839:             move.l #$00000000,a1
00:0000499C 95CA            	  3840:             move.l #$00000000,a2
00:0000499E 97CB            	  3841:             move.l #$00000000,a3
00:000049A0 99CC            	  3842:             move.l #$00000000,a4
00:000049A2 9BCD            	  3843:             move.l #$00000000,a5
00:000049A4 9DCE            	  3844:             move.l #$00000000,a6
                            	  3845: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3846: 
00:000049A6 4CF82A550120    	  3847:             movem.l $00000120,D0/D2/D4/D6/A1/A3/A5
                            	  3848: 
00:000049AC B0BCD0D0D0D0    	  3849:             cmp.l #$D0D0D0D0,d0
00:000049B2 66FE            	  3850:             bne.s *                   * Check Z Flag  beq/bne 0
00:000049B4 B4BCD1D1D1D1    	  3851:             cmp.l #$D1D1D1D1,d2
00:000049BA 66FE            	  3852:             bne.s *                  * Check Z Flag  beq/bne 0
00:000049BC B8BCD2D2D2D2    	  3853:             cmp.l #$D2D2D2D2,d4
00:000049C2 66FE            	  3854:             bne.s *                   * Check Z Flag  beq/bne 0
00:000049C4 BCBCD3D3D3D3    	  3855:             cmp.l #$D3D3D3D3,d6
00:000049CA 66FE            	  3856:             bne.s *                   * Check Z Flag  beq/bne 0
00:000049CC B3FCD4D4D4D4    	  3857:             cmp.l #$D4D4D4D4,a1
00:000049D2 66FE            	  3858:             bne.s *                   * Check Z Flag  beq/bne 0
00:000049D4 B7FCD5D5D5D5    	  3859:             cmp.l #$D5D5D5D5,a3
00:000049DA 66FE            	  3860:             bne.s *                   * Check Z Flag  beq/bne 0
00:000049DC BBFCD6D6D6D6    	  3861:             cmp.l #$D6D6D6D6,a5
00:000049E2 66FE            	  3862:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3863: 
00:000049E4 4E75            	  3864:             rts
                            	  3865: 
                            	  3866: 
                            	  3867: *-----------------------------------------------------------
                            	  3868: *-----------------------------------------------------------
                            	  3869: * OPCODE : ABCD
                            	  3870: *-----------------------------------------------------------
                            	  3871: *-----------------------------------------------------------
                            	  3872: op_ABCD:
                            	  3873: 
                            	  3874: *     Test with X Flag CLEARED
00:000049E6 307C0110        	  3875:                 move.l #$00000110,a0 * Address pointer-X
00:000049EA 327C0120        	  3876:                 move.l #$00000120,a1 * Address pointer-Y
00:000049EE 7000            	  3877:                 moveq  #$00000000,d0 * BCD byte-X
00:000049F0 7200            	  3878:                 moveq  #$00000000,d1 * BCD byte-Y
00:000049F2 7400            	  3879:                 moveq  #$00000000,d2
00:000049F4 7600            	  3880:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:000049F6 7800            	  3881:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:000049F8 7A00            	  3882:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:000049FA 2C3C00000099    	  3883:                 move.l #$00000099,d6 * Inner loop counter
00:00004A00 2E3C00000099    	  3884:                 move.l #$00000099,d7 * Outer loop counter
                            	  3885: 
00:00004A06 2007            	  3886: ABCD_OUTER1:    move.l d7,d0
00:00004A08 2206            	  3887: ABCD_INNER1:    move.l d6,d1
00:00004A0A 023C00EF        	  3888:                 andi.b #$EF,CCR     * Clear X Flag
00:00004A0E 307C0110        	  3889:                 move.l #$00000110,a0 * Address pointer-X
00:00004A12 327C0120        	  3890:                 move.l #$00000120,a1 * Address pointer-Y
00:00004A16 1140FFFF        	  3891:                 move.b d0,-1(a0)
00:00004A1A 1341FFFF        	  3892:                 move.b d1,-1(a1)
                            	  3893: 
00:00004A1E C300            	  3894:                 abcd d0,d1
00:00004A20 6402            	  3895:                 bcc.s ABCD_NO_C1          * Check C Flag  bcc/bcs 0
00:00004A22 5284            	  3896:                 add.l #1,d4
00:00004A24 DA81            	  3897: ABCD_NO_C1:     add.l d1,d5
                            	  3898: 
00:00004A26 C308            	  3899:                 abcd -(a0),-(a1)
00:00004A28 6402            	  3900:                 bcc.s ABCD_NO_C2          * Check C Flag  bcc/bcs 0
00:00004A2A 5284            	  3901:                 add.l #1,d4
00:00004A2C D611            	  3902: ABCD_NO_C2:     add.b (a1),d3
                            	  3903: 
                            	  3904: 
00:00004A2E 51CEFFD8        	  3905:                 dbf d6,ABCD_INNER1
00:00004A32 2C3C00000099    	  3906:                 move.l #$00000099,d6
00:00004A38 51CFFFCC        	  3907:                 dbf d7,ABCD_OUTER1
00:00004A3C 0C8400005AFC    	  3908:                 cmpi.l #$00005AFC,d4  * Check the cumulative results
00:00004A42 66FE            	  3909:                 bne.s *
00:00004A44 0C85001C9A34    	  3910:                 cmpi.l #$001C9A34,d5
00:00004A4A 66FE            	  3911:                 bne.s *
00:00004A4C 0C8300000034    	  3912:                 cmpi.l #$00000034,d3
00:00004A52 66FE            	  3913:                 bne.s *
                            	  3914: 
                            	  3915: *     Test with X Flag SET
00:00004A54 307C0110        	  3916:                 move.l #$00000110,a0 * Address pointer-X
00:00004A58 327C0120        	  3917:                 move.l #$00000120,a1 * Address pointer-Y
00:00004A5C 7000            	  3918:                 moveq  #$00000000,d0 * BCD byte-X
00:00004A5E 7200            	  3919:                 moveq  #$00000000,d1 * BCD byte-Y
00:00004A60 7400            	  3920:                 moveq  #$00000000,d2
00:00004A62 7600            	  3921:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00004A64 7800            	  3922:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00004A66 7A00            	  3923:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00004A68 2C3C00000099    	  3924:                 move.l #$00000099,d6 * Inner loop counter
00:00004A6E 2E3C00000099    	  3925:                 move.l #$00000099,d7 * Outer loop counter
                            	  3926: 
00:00004A74 2007            	  3927: ABCD_OUTER2:    move.l d7,d0
00:00004A76 2206            	  3928: ABCD_INNER2:    move.l d6,d1
00:00004A78 003C0010        	  3929:                 ori.b #$10,CCR      * Set X Flag
00:00004A7C 307C0110        	  3930:                 move.l #$00000110,a0 * Address pointer-X
00:00004A80 327C0120        	  3931:                 move.l #$00000120,a1 * Address pointer-Y
00:00004A84 1140FFFF        	  3932:                 move.b d0,-1(a0)
00:00004A88 1341FFFF        	  3933:                 move.b d1,-1(a1)
                            	  3934: 
00:00004A8C C300            	  3935:                 abcd d0,d1
00:00004A8E 6402            	  3936:                 bcc.s ABCD_NO_C3          * Check C Flag  bcc/bcs 0
00:00004A90 5284            	  3937:                 add.l #1,d4
00:00004A92 DA81            	  3938: ABCD_NO_C3:     add.l d1,d5
                            	  3939: 
00:00004A94 C308            	  3940:                 abcd -(a0),-(a1)
00:00004A96 6402            	  3941:                 bcc.s ABCD_NO_C4          * Check C Flag  bcc/bcs 0
00:00004A98 5284            	  3942:                 add.l #1,d4
00:00004A9A D611            	  3943: ABCD_NO_C4:     add.b (a1),d3
                            	  3944: 
                            	  3945: 
00:00004A9C 51CEFFD8        	  3946:                 dbf d6,ABCD_INNER2
00:00004AA0 2C3C00000099    	  3947:                 move.l #$00000099,d6
00:00004AA6 51CFFFCC        	  3948:                 dbf d7,ABCD_OUTER2
00:00004AAA 0C8400005B60    	  3949:                 cmpi.l #$00005B60,d4  * Check the cumulative results
00:00004AB0 66FE            	  3950:                 bne.s *
00:00004AB2 0C85001CCFC8    	  3951:                 cmpi.l #$001CCFC8,d5
00:00004AB8 66FE            	  3952:                 bne.s *
00:00004ABA 0C8300000034    	  3953:                 cmpi.l #$00000034,d3
00:00004AC0 66FE            	  3954:                 bne.s *
                            	  3955: 
                            	  3956: *             Quick check of Z Flag
00:00004AC2 4200            	  3957:                 move.b #$00,d0
00:00004AC4 4201            	  3958:                 move.b #$00,d1
00:00004AC6 44FC0000        	  3959:                 move #$00,CCR              * Set Z flag to 0
00:00004ACA C101            	  3960:                 abcd d1,d0                  * Should NOT set Z Flag to 1
00:00004ACC 67FE            	  3961:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3962: 
00:00004ACE 103C0001        	  3963:                 move.b #$01,d0
00:00004AD2 4201            	  3964:                 move.b #$00,d1
00:00004AD4 44FC0004        	  3965:                 move #$04,CCR              * Set Z flag to 0
00:00004AD8 C101            	  3966:                 abcd d1,d0                  * Should NOT set Z Flag to 1
00:00004ADA 67FE            	  3967:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3968: 
00:00004ADC 4E75            	  3969:                 rts
                            	  3970: 
                            	  3971: *-----------------------------------------------------------
                            	  3972: *-----------------------------------------------------------
                            	  3973: * OPCODE : SBCD
                            	  3974: *-----------------------------------------------------------
                            	  3975: *-----------------------------------------------------------
                            	  3976: op_SBCD:
                            	  3977: 
                            	  3978: *     Test with X Flag CLEARED
00:00004ADE 307C0110        	  3979:                 move.l #$00000110,a0 * Address pointer-X
00:00004AE2 327C0120        	  3980:                 move.l #$00000120,a1 * Address pointer-Y
00:00004AE6 7000            	  3981:                 moveq  #$00000000,d0 * BCD byte-X
00:00004AE8 7200            	  3982:                 moveq  #$00000000,d1 * BCD byte-Y
00:00004AEA 7400            	  3983:                 moveq  #$00000000,d2
00:00004AEC 7600            	  3984:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00004AEE 7800            	  3985:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00004AF0 7A00            	  3986:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00004AF2 2C3C00000099    	  3987:                 move.l #$00000099,d6 * Inner loop counter
00:00004AF8 2E3C00000099    	  3988:                 move.l #$00000099,d7 * Outer loop counter
                            	  3989: 
00:00004AFE 2007            	  3990: SBCD_OUTER1:    move.l d7,d0
00:00004B00 2206            	  3991: SBCD_INNER1:    move.l d6,d1
00:00004B02 023C00EF        	  3992:                 andi.b #$EF,CCR     * Clear X Flag
00:00004B06 307C0110        	  3993:                 move.l #$00000110,a0 * Address pointer-X
00:00004B0A 327C0120        	  3994:                 move.l #$00000120,a1 * Address pointer-Y
00:00004B0E 1140FFFF        	  3995:                 move.b d0,-1(a0)
00:00004B12 1341FFFF        	  3996:                 move.b d1,-1(a1)
                            	  3997: 
00:00004B16 8300            	  3998:                 sbcd d0,d1
00:00004B18 6402            	  3999:                 bcc.s SBCD_NO_C1          * Check C Flag  bcc/bcs 0
00:00004B1A 5284            	  4000:                 add.l #1,d4
00:00004B1C DA81            	  4001: SBCD_NO_C1:     add.l d1,d5
                            	  4002: 
00:00004B1E 8308            	  4003:                 sbcd -(a0),-(a1)
00:00004B20 6402            	  4004:                 bcc.s SBCD_NO_C2          * Check C Flag  bcc/bcs 0
00:00004B22 5284            	  4005:                 add.l #1,d4
00:00004B24 D611            	  4006: SBCD_NO_C2:     add.b (a1),d3
                            	  4007: 
                            	  4008: 
00:00004B26 51CEFFD8        	  4009:                 dbf d6,SBCD_INNER1
00:00004B2A 2C3C00000099    	  4010:                 move.l #$00000099,d6
00:00004B30 51CFFFCC        	  4011:                 dbf d7,SBCD_OUTER1
00:00004B34 0C8400005C0A    	  4012:                 cmpi.l #$00005C0A,d4  * Check the cumulative results
00:00004B3A 66FE            	  4013:                 bne.s *
00:00004B3C 0C85001C459E    	  4014:                 cmpi.l #$001C459E,d5
00:00004B42 66FE            	  4015:                 bne.s *
00:00004B44 0C830000009E    	  4016:                 cmpi.l #$0000009E,d3
00:00004B4A 66FE            	  4017:                 bne.s *
                            	  4018: 
                            	  4019: *     Test with X Flag SET
00:00004B4C 307C0110        	  4020:                 move.l #$00000110,a0 * Address pointer-X
00:00004B50 327C0120        	  4021:                 move.l #$00000120,a1 * Address pointer-Y
00:00004B54 7000            	  4022:                 moveq  #$00000000,d0 * BCD byte-X
00:00004B56 7200            	  4023:                 moveq  #$00000000,d1 * BCD byte-Y
00:00004B58 7400            	  4024:                 moveq  #$00000000,d2
00:00004B5A 7600            	  4025:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00004B5C 7800            	  4026:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00004B5E 7A00            	  4027:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00004B60 2C3C00000099    	  4028:                 move.l #$00000099,d6 * Inner loop counter
00:00004B66 2E3C00000099    	  4029:                 move.l #$00000099,d7 * Outer loop counter
                            	  4030: 
00:00004B6C 2007            	  4031: SBCD_OUTER2:    move.l d7,d0
00:00004B6E 2206            	  4032: SBCD_INNER2:    move.l d6,d1
00:00004B70 003C0010        	  4033:                 ori.b #$10,CCR      * Set X Flag
00:00004B74 307C0110        	  4034:                 move.l #$00000110,a0 * Address pointer-X
00:00004B78 327C0120        	  4035:                 move.l #$00000120,a1 * Address pointer-Y
00:00004B7C 1140FFFF        	  4036:                 move.b d0,-1(a0)
00:00004B80 1341FFFF        	  4037:                 move.b d1,-1(a1)
                            	  4038: 
00:00004B84 8300            	  4039:                 sbcd d0,d1
00:00004B86 6402            	  4040:                 bcc.s SBCD_NO_C3          * Check C Flag  bcc/bcs 0
00:00004B88 5284            	  4041:                 add.l #1,d4
00:00004B8A DA81            	  4042: SBCD_NO_C3:     add.l d1,d5
                            	  4043: 
00:00004B8C 8308            	  4044:                 sbcd -(a0),-(a1)
00:00004B8E 6402            	  4045:                 bcc.s SBCD_NO_C4          * Check C Flag  bcc/bcs 0
00:00004B90 5284            	  4046:                 add.l #1,d4
00:00004B92 D611            	  4047: SBCD_NO_C4:     add.b (a1),d3
                            	  4048: 
00:00004B94 51CEFFD8        	  4049:                 dbf d6,SBCD_INNER2
00:00004B98 2C3C00000099    	  4050:                 move.l #$00000099,d6
00:00004B9E 51CFFFCC        	  4051:                 dbf d7,SBCD_OUTER2
00:00004BA2 0C8400005CA4    	  4052:                 cmpi.l #$00005CA4,d4  * Check the cumulative results
00:00004BA8 66FE            	  4053:                 bne.s *
00:00004BAA 0C85001C5C66    	  4054:                 cmpi.l #$001C5C66,d5
00:00004BB0 66FE            	  4055:                 bne.s *
00:00004BB2 0C830000009E    	  4056:                 cmpi.l #$0000009E,d3
00:00004BB8 66FE            	  4057:                 bne.s *
                            	  4058: 
                            	  4059: 
                            	  4060: *             Quick check of Z Flag
00:00004BBA 4200            	  4061:                 move.b #$00,d0
00:00004BBC 4201            	  4062:                 move.b #$00,d1
00:00004BBE 44FC0000        	  4063:                 move #$00,CCR              * Set Z flag to 0
00:00004BC2 8101            	  4064:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
00:00004BC4 67FE            	  4065:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4066: 
00:00004BC6 103C0001        	  4067:                 move.b #$01,d0
00:00004BCA 4201            	  4068:                 move.b #$00,d1
00:00004BCC 44FC0004        	  4069:                 move #$04,CCR              * Set Z flag to 0
00:00004BD0 8101            	  4070:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
00:00004BD2 67FE            	  4071:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4072: 
00:00004BD4 4E75            	  4073:                 rts
                            	  4074: 
                            	  4075: *-----------------------------------------------------------
                            	  4076: *-----------------------------------------------------------
                            	  4077: * OPCODE : NBCD
                            	  4078: *-----------------------------------------------------------
                            	  4079: *-----------------------------------------------------------
                            	  4080: op_NBCD:
                            	  4081: 
                            	  4082: *        NBCD to a  Register
                            	  4083: 
00:00004BD6 7000            	  4084:                 moveq  #$00000000,d0 * BCD byte
00:00004BD8 7200            	  4085:                 moveq  #$00000000,d1
00:00004BDA 7400            	  4086:                 moveq  #$00000000,d2
00:00004BDC 7600            	  4087:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
00:00004BDE 7800            	  4088:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00004BE0 7A00            	  4089:                 moveq  #$00000000,d5 * Cumulative BCD results
00:00004BE2 2C3C00000099    	  4090:                 move.l #$00000099,d6
00:00004BE8 2E3C00000099    	  4091:                 move.l #$00000099,d7 * Loop counter
                            	  4092: 
00:00004BEE 2007            	  4093: NBCD_LOOP:      move.l d7,d0
00:00004BF0 44FC0004        	  4094:                 move #$04,CCR        * Set Z flag to 0
                            	  4095: 
00:00004BF4 4800            	  4096:                 nbcd d0
                            	  4097: 
00:00004BF6 6402            	  4098:                 bcc.s NBCD_NO_C         * Check C Flag
00:00004BF8 5284            	  4099:                 add.l #1,d4
00:00004BFA 6602            	  4100: NBCD_NO_C:      bne.s NBCD_NO_Z         * Check Z Flag
00:00004BFC 5283            	  4101:                 add.l #1,d3
00:00004BFE DA80            	  4102: NBCD_NO_Z:      add.l d0,d5         * Add results into d5
                            	  4103: 
00:00004C00 51CFFFEC        	  4104:                 dbf d7,NBCD_LOOP
                            	  4105: 
00:00004C04 0C8300000001    	  4106:                 cmpi.l #$00000001,d3  * Check the cumulative results
00:00004C0A 66FE            	  4107:                 bne.s *
00:00004C0C 0C8400000099    	  4108:                 cmpi.l #$00000099,d4
00:00004C12 66FE            	  4109:                 bne.s *
00:00004C14 0C8500002E3B    	  4110:                 cmpi.l #$00002E3B,d5
00:00004C1A 66FE            	  4111:                 bne.s *
                            	  4112: 
                            	  4113: 
                            	  4114: *        NBCD to a memory location
                            	  4115: 
00:00004C1C 7000            	  4116:                 moveq  #$00000000,d0 * BCD byte
00:00004C1E 7200            	  4117:                 moveq  #$00000000,d1
00:00004C20 7400            	  4118:                 moveq  #$00000000,d2
00:00004C22 7600            	  4119:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
00:00004C24 7800            	  4120:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00004C26 7A00            	  4121:                 moveq  #$00000000,d5 * Cumulative BCD results
00:00004C28 2C3C00000099    	  4122:                 move.l #$00000099,d6
00:00004C2E 2E3C00000099    	  4123:                 move.l #$00000099,d7 * Loop counter
                            	  4124: 
00:00004C34 11C70100        	  4125: NBCD_LOOP1:     move.b d7,$00000100
00:00004C38 44FC0004        	  4126:                 move #$04,CCR        * Set Z flag to 0
                            	  4127: 
00:00004C3C 48380100        	  4128:                 nbcd $00000100
00:00004C40 10380100        	  4129:                 move.b $00000100,d0
                            	  4130: 
00:00004C44 6402            	  4131:                 bcc.s NBCD_NO_C1        * Check C Flag
00:00004C46 5284            	  4132:                 add.l #1,d4
00:00004C48 6602            	  4133: NBCD_NO_C1:     bne.s NBCD_NO_Z1        * Check Z Flag
00:00004C4A 5283            	  4134:                 add.l #1,d3
00:00004C4C DA80            	  4135: NBCD_NO_Z1:     add.l d0,d5         * Add results into d5
                            	  4136: 
00:00004C4E 51CFFFE4        	  4137:                 dbf d7,NBCD_LOOP1
                            	  4138: 
00:00004C52 0C8300000001    	  4139:                 cmpi.l #$00000001,d3  * Check the cumulative results
00:00004C58 66FE            	  4140:                 bne.s *
00:00004C5A 4A84            	  4141:                 cmpi.l #$00000000,d4
00:00004C5C 66FE            	  4142:                 bne.s *
00:00004C5E 0C8500002E3B    	  4143:                 cmpi.l #$00002E3B,d5
00:00004C64 66FE            	  4144:                 bne.s *
                            	  4145: 
                            	  4146: 
00:00004C66 4E75            	  4147:                 rts
                            	  4148: 
                            	  4149: 
                            	  4150: 
                            	  4151: *-----------------------------------------------------------
                            	  4152: *-----------------------------------------------------------
                            	  4153: * OPCODE : TRAPV
                            	  4154: *-----------------------------------------------------------
                            	  4155: *-----------------------------------------------------------
                            	  4156: op_TRAPV:
                            	  4157: 
                            	  4158: *     TRAPV will set d0 to 12345678 if V flag is set
                            	  4159: 
00:00004C68 7000            	  4160:                 moveq  #$00000000,d0 * Clear d0
                            	  4161: 
00:00004C6A 44FC0000        	  4162:                 move #$00,CCR        * Clear V flag
00:00004C6E 4E76            	  4163:                 trapv
00:00004C70 4A80            	  4164:                 cmpi.l #$00000000,d0  * Check of d0 was updated (should not be_)
00:00004C72 66FE            	  4165:                 bne.s *
                            	  4166: 
00:00004C74 44FC0002        	  4167:                 move #$02,CCR        * Set V flag
00:00004C78 4E76            	  4168:                 trapv
00:00004C7A 0C8012345678    	  4169:                 cmpi.l #$12345678,d0  * Check of d0 was updated (should not be_)
00:00004C80 66FE            	  4170:                 bne.s *
                            	  4171: 
                            	  4172: 
00:00004C82 4E75            	  4173:                 rts
                            	  4174: 
                            	  4175: 
                            	  4176: 
                            	  4177: *-----------------------------------------------------------
                            	  4178: *-----------------------------------------------------------
                            	  4179: * OPCODE : RTR
                            	  4180: *-----------------------------------------------------------
                            	  4181: *-----------------------------------------------------------
                            	  4182: 
                            	  4183: op_RTR:
                            	  4184: 
                            	  4185: *     Leventhal claims only 5 LSB's are popped from the stack to the CCR
                            	  4186: 
00:00004C84 41FA000A        	  4187:                 lea 		RTR_DONE,a0
00:00004C88 2F08            	  4188:                 move.l 	a0,-(a7)     * push destination PC to the stack
00:00004C8A 3F3CFF15        	  4189:                 move.w 	#$FF15,-(a7)       * push flags=0xFFFF to the stack
00:00004C8E 4E77            	  4190:                 rtr
                            	  4191: 
00:00004C90 40C0            	  4192: RTR_DONE:       move.w SR,d0
00:00004C92 0240001F        	  4193:                 andi.w #$1F,d0
00:00004C96 0C400015        	  4194:                 cmpi.w #$15,d0
00:00004C9A 66FE            	  4195:                 bne.s *
                            	  4196: 
00:00004C9C 4E75            	  4197:                 rts
                            	  4198: 
                            	  4199: 
00:00004C9E 283C44444444    	  4200: BSR_FAR2:       move.l #$44444444,d4
00:00004CA4 4E75            	  4201:                 rts
                            	  4202: 
                            	  4203: 
                            	  4204: *-----------------------------------------------------------
                            	  4205: *-----------------------------------------------------------
                            	  4206: * OPCODE : BCC
                            	  4207: *-----------------------------------------------------------
                            	  4208: *-----------------------------------------------------------
                            	  4209: 
00:00004CA6 44FC0000        	  4210: op_BCC:         move #$00,CCR
00:00004CAA 6202            	  4211:                 bhi.s BCC1            * Higher Than         C=0 AND Z=0
00:00004CAC 60FE            	  4212:                 bra.s *
                            	  4213: 
00:00004CAE 44FC0001        	  4214: BCC1:           move #$01,CCR
00:00004CB2 63000004        	  4215:                 bls.w BCC2            * Lower or Same       C=1 OR Z=1
00:00004CB6 60FE            	  4216:                 bra.s *
                            	  4217: 
00:00004CB8 44FC0000        	  4218: BCC2:           move #$00,CCR
00:00004CBC 6402            	  4219:                 bcc.s BCC3            * Carry Clear         C=0
00:00004CBE 60FE            	  4220:                 bra.s *
                            	  4221: 
00:00004CC0 44FC0001        	  4222: BCC3:           move #$01,CCR
00:00004CC4 65000004        	  4223:                 bcs.w BCC4            * Carry Set           C=1
00:00004CC8 60FE            	  4224:                 bra.s *
                            	  4225: 
00:00004CCA 44FC0000        	  4226: BCC4:           move #$00,CCR
00:00004CCE 6602            	  4227:                 bne.s BCC5            * Not Equal           Z=0
00:00004CD0 60FE            	  4228:                 bra.s *
                            	  4229: 
00:00004CD2 44FC0004        	  4230: BCC5:           move #$04,CCR
00:00004CD6 67000004        	  4231:                 beq.w BCC6            * Equal               Z=1
00:00004CDA 60FE            	  4232:                 bra.s *
                            	  4233: 
00:00004CDC 44FC0000        	  4234: BCC6:           move #$00,CCR
00:00004CE0 6802            	  4235:                 bvc.s BCC7            * V Clear             V=0
00:00004CE2 60FE            	  4236:                 bra.s *
                            	  4237: 
00:00004CE4 44FC0002        	  4238: BCC7:           move #$02,CCR
00:00004CE8 69000004        	  4239:                 bvs.w BCC8            * V Set               V=1
00:00004CEC 60FE            	  4240:                 bra.s *
                            	  4241: 
00:00004CEE 44FC0000        	  4242: BCC8:           move #$00,CCR
00:00004CF2 6A02            	  4243:                 bpl.s BCC9            * Plus                N=0
00:00004CF4 60FE            	  4244:                 bra.s *
                            	  4245: 
00:00004CF6 44FC0008        	  4246: BCC9:           move #$08,CCR
00:00004CFA 6B000004        	  4247:                 bmi.w BCC10           * Minus               N=1
00:00004CFE 60FE            	  4248:                 bra.s *
                            	  4249: 
00:00004D00 44FC0000        	  4250: BCC10:          move #$00,CCR
00:00004D04 6C02            	  4251:                 bge.s BCC11           * Greater or Equal    N=V
00:00004D06 60FE            	  4252:                 bra.s *
                            	  4253: 
00:00004D08 44FC0002        	  4254: BCC11:          move #$02,CCR
00:00004D0C 6D000004        	  4255:                 blt.w BCC12           * Less Than           N!=V
00:00004D10 60FE            	  4256:                 bra.s *
                            	  4257: 
00:00004D12 44FC000A        	  4258: BCC12:          move #$0A,CCR
00:00004D16 6E02            	  4259:                 bgt.s BCC13           * Greater Than        N=V  AND Z=0
00:00004D18 60FE            	  4260:                 bra.s *
                            	  4261: 
00:00004D1A 44FC0006        	  4262: BCC13:          move #$06,CCR
00:00004D1E 6F000004        	  4263:                 ble.w BCC14           * Less Than or Equal  N!=V AND Z=1
00:00004D22 60FE            	  4264:                 bra.s *
                            	  4265: 
                            	  4266: 
00:00004D24 4E75            	  4267: BCC14:          rts
                            	  4268: 
                            	  4269: 
                            	  4270: *-----------------------------------------------------------
                            	  4271: *-----------------------------------------------------------
                            	  4272: * OPCODE : DBCC
                            	  4273: *-----------------------------------------------------------
                            	  4274: *-----------------------------------------------------------
                            	  4275: 
00:00004D26 7003            	  4276: op_DBCC:        moveq  #$00000003,d0    * Loop counter
00:00004D28 7200            	  4277:                 moveq  #$00000000,d1    * Accumulator
00:00004D2A 44FC0000        	  4278:                 move #$00,CCR
                            	  4279: 
00:00004D2E 5201            	  4280: DBCC_LOOP1:     addi.b #$1,d1
00:00004D30 51C8FFFC        	  4281:                 dbf d0,DBCC_LOOP1
                            	  4282: 
00:00004D34 0C8100000004    	  4283:                 cmpi.l #$00000004,d1  * Check Accumulator results
00:00004D3A 66FE            	  4284:                 bne.s *
                            	  4285: 
00:00004D3C 5201            	  4286: DBCC_LOOP2:     addi.b #$1,d1
00:00004D3E 54C8FFFC        	  4287:                 dbcc d0,DBCC_LOOP2    * Dont loop
                            	  4288: 
00:00004D42 0C8100000005    	  4289:                 cmpi.l #$00000005,d1  * Check Accumulator results
00:00004D48 66FE            	  4290:                 bne.s *
                            	  4291: 
00:00004D4A 4E75            	  4292:                 rts
                            	  4293: 
                            	  4294: 
                            	  4295: *-----------------------------------------------------------
                            	  4296: *-----------------------------------------------------------
                            	  4297: * OPCODE : SCC
                            	  4298: *-----------------------------------------------------------
                            	  4299: *-----------------------------------------------------------
                            	  4300: 
00:00004D4C 44FC0001        	  4301: op_SCC:         move #$01,CCR
00:00004D50 54F900010000    	  4302:                 scc $00010000                   * Clear the EA byte
00:00004D56 4A3900010000    	  4303:                 cmpi.b #$00,$00010000
00:00004D5C 66FE            	  4304:                 bne.s *
                            	  4305: 
00:00004D5E 44FC0000        	  4306:                 move #$00,CCR
00:00004D62 54F900010000    	  4307:                 scc $00010000                   * Set the EA byte to 0xFF
00:00004D68 0C3900FF00010000	  4308:                 cmpi.b #$FF,$00010000
00:00004D70 66FE            	  4309:                 bne.s *
                            	  4310: 
00:00004D72 54C0            	  4311: 								scc d0													* Test setting a data register
00:00004D74 0C0000FF        	  4312: 								cmpi.b #$FF,d0
00:00004D78 66FE            	  4313: 								bne.s *
00:00004D7A 4E75            	  4314:                 rts
                            	  4315: 
                            	  4316: 
                            	  4317: 
                            	  4318: *-----------------------------------------------------------
                            	  4319: *-----------------------------------------------------------
                            	  4320: * OPCODE : ADDQ
                            	  4321: *-----------------------------------------------------------
                            	  4322: *-----------------------------------------------------------
                            	  4323: 
                            	  4324: op_ADDQ:
                            	  4325: 
                            	  4326: *     BYTE
00:00004D7C 203C000000FF    	  4327:                 move.l #$000000FF,d0    * Loop counter
00:00004D82 7200            	  4328:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004D84 7400            	  4329:                 moveq  #$00000000,d2    * Data results accumulator
00:00004D86 7600            	  4330:                 moveq  #$00000000,d3
00:00004D88 7800            	  4331:                 moveq  #$00000000,d4
00:00004D8A 7A00            	  4332:                 moveq  #$00000000,d5
00:00004D8C 7C00            	  4333:                 moveq  #$00000000,d6
00:00004D8E 7E00            	  4334:                 moveq  #$00000000,d7
                            	  4335: 
00:00004D90 5605            	  4336: ADDQ_LOOP1:     addq.b #3,d5
00:00004D92 40C6            	  4337:                 move.w SR,d6
00:00004D94 02860000001F    	  4338:                 andi.l #$1F,d6        * Isolate flags
00:00004D9A D286            	  4339:                 add.l d6,d1           * Copy flag results into accumulator
00:00004D9C D485            	  4340:                 add.l d5,d2           * Copy data results into data accumulator
00:00004D9E 51C8FFF0        	  4341:                 dbf d0,ADDQ_LOOP1
                            	  4342: 
00:00004DA2 0C810000043D    	  4343:                 cmpi.l #$0000043D,d1
00:00004DA8 66FE            	  4344:                 bne.s *
00:00004DAA 0C8200007F80    	  4345:                 cmpi.l #$00007F80,d2
00:00004DB0 66FE            	  4346:                 bne.s *
                            	  4347: 
                            	  4348: 
                            	  4349: *     WORD
00:00004DB2 203C000000FF    	  4350:                 move.l #$000000FF,d0    * Loop counter
00:00004DB8 7200            	  4351:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004DBA 7400            	  4352:                 moveq  #$00000000,d2    * Data results accumulator
00:00004DBC 7600            	  4353:                 moveq  #$00000000,d3
00:00004DBE 7800            	  4354:                 moveq  #$00000000,d4
00:00004DC0 2A3C0000FFF0    	  4355:                 move.l #$0000FFF0,d5
00:00004DC6 7C00            	  4356:                 moveq  #$00000000,d6
00:00004DC8 7E00            	  4357:                 moveq  #$00000000,d7
00:00004DCA 307C0100        	  4358:                 move.l #$00000100,a0
                            	  4359: 
00:00004DCE 5A45            	  4360: ADDQ_LOOP2:     addq.w #5,d5
00:00004DD0 40C6            	  4361:                 move.w SR,d6
00:00004DD2 02860000001F    	  4362:                 andi.l #$1F,d6        * Isolate flags
00:00004DD8 D286            	  4363:                 add.l d6,d1           * Copy flag results into accumulator
00:00004DDA D485            	  4364:                 add.l d5,d2           * Copy data results into data accumulator
00:00004DDC 51C8FFF0        	  4365:                 dbf d0,ADDQ_LOOP2
                            	  4366: 
00:00004DE0 0C8100000029    	  4367:                 cmpi.l #$00000029,d1
00:00004DE6 66FE            	  4368:                 bne.s *
00:00004DE8 0C8200057280    	  4369:                 cmpi.l #$00057280,d2
00:00004DEE 66FE            	  4370:                 bne.s *
                            	  4371: 
                            	  4372: 
                            	  4373: *     LONG
00:00004DF0 203C000000FF    	  4374:                 move.l #$000000FF,d0    * Loop counter
00:00004DF6 7200            	  4375:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004DF8 7400            	  4376:                 moveq  #$00000000,d2    * Data results accumulator
00:00004DFA 7600            	  4377:                 moveq  #$00000000,d3
00:00004DFC 7800            	  4378:                 moveq  #$00000000,d4
00:00004DFE 7AF0            	  4379:                 move.l #$FFFFFFF0,d5
00:00004E00 7C00            	  4380:                 moveq  #$00000000,d6
00:00004E02 7E00            	  4381:                 moveq  #$00000000,d7
                            	  4382: 
00:00004E04 5285            	  4383: ADDQ_LOOP3:     addq.l #1,d5
00:00004E06 40C6            	  4384:                 move.w SR,d6
00:00004E08 02860000001F    	  4385:                 andi.l #$1F,d6        * Isolate flags
00:00004E0E D286            	  4386:                 add.l d6,d1           * Copy flag results into accumulator
00:00004E10 D485            	  4387:                 add.l d5,d2           * Copy data results into data accumulator
00:00004E12 51C8FFF0        	  4388:                 dbf d0,ADDQ_LOOP3
                            	  4389: 
00:00004E16 0C810000008D    	  4390:                 cmpi.l #$0000008D,d1
00:00004E1C 66FE            	  4391:                 bne.s *
00:00004E1E 0C8200007080    	  4392:                 cmpi.l #$00007080,d2
00:00004E24 66FE            	  4393:                 bne.s *
                            	  4394: 
                            	  4395: *     Check that Flags are not updated for Address registers
00:00004E26 207C0000FFFF    	  4396:                 move.l #$0000FFFF,a0
00:00004E2C 44FC0000        	  4397:                 move #$00,CCR         * Clear flags
00:00004E30 5E48            	  4398:                 addq.w #$7,a0
00:00004E32 65FE            	  4399:                 bcs.s *
                            	  4400: 
00:00004E34 4E75            	  4401:                 rts
                            	  4402: 
                            	  4403: 
                            	  4404: 
                            	  4405: *-----------------------------------------------------------
                            	  4406: *-----------------------------------------------------------
                            	  4407: * OPCODE : SUBQ
                            	  4408: *-----------------------------------------------------------
                            	  4409: *-----------------------------------------------------------
                            	  4410: 
                            	  4411: op_SUBQ:
                            	  4412: 
                            	  4413: *     BYTE
00:00004E36 203C000000FF    	  4414:                 move.l #$000000FF,d0    * Loop counter
00:00004E3C 7200            	  4415:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004E3E 243C00001234    	  4416:                 move.l #$00001234,d2    * Data results accumulator
00:00004E44 7600            	  4417:                 moveq  #$00000000,d3
00:00004E46 7800            	  4418:                 moveq  #$00000000,d4
00:00004E48 7A12            	  4419:                 moveq  #$00000012,d5
00:00004E4A 7C00            	  4420:                 moveq  #$00000000,d6
00:00004E4C 7E00            	  4421:                 moveq  #$00000000,d7
                            	  4422: 
00:00004E4E 5305            	  4423: SUBQ_LOOP1:     subq.b #1,d5
00:00004E50 40C6            	  4424:                 move.w SR,d6
00:00004E52 02860000001F    	  4425:                 andi.l #$1F,d6        * Isolate flags
00:00004E58 D286            	  4426:                 add.l d6,d1           * Copy flag results into accumulator
00:00004E5A D485            	  4427:                 add.l d5,d2           * Copy data results into data accumulator
00:00004E5C 51C8FFF0        	  4428:                 dbf d0,SUBQ_LOOP1
                            	  4429: 
00:00004E60 0C8100000417    	  4430:                 cmpi.l #$00000417,d1
00:00004E66 66FE            	  4431:                 bne.s *
00:00004E68 0C82000091B4    	  4432:                 cmpi.l #$000091B4,d2
00:00004E6E 66FE            	  4433:                 bne.s *
                            	  4434: 
                            	  4435: 
                            	  4436: *     WORD
00:00004E70 203C000000FF    	  4437:                 move.l #$000000FF,d0    * Loop counter
00:00004E76 7200            	  4438:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004E78 7400            	  4439:                 moveq  #$00000000,d2    * Data results accumulator
00:00004E7A 7600            	  4440:                 moveq  #$00000000,d3
00:00004E7C 7800            	  4441:                 moveq  #$00000000,d4
00:00004E7E 7A02            	  4442:                 moveq  #$00000002,d5
00:00004E80 7C00            	  4443:                 moveq  #$00000000,d6
00:00004E82 7E00            	  4444:                 moveq  #$00000000,d7
00:00004E84 307C0100        	  4445:                 move.l #$00000100,a0
                            	  4446: 
00:00004E88 5B45            	  4447: SUBQ_LOOP2:     subq.w #5,d5
00:00004E8A 40C6            	  4448:                 move.w SR,d6
00:00004E8C 02860000001F    	  4449:                 andi.l #$1F,d6        * Isolate flags
00:00004E92 D286            	  4450:                 add.l d6,d1           * Copy flag results into accumulator
00:00004E94 D485            	  4451:                 add.l d5,d2           * Copy data results into data accumulator
00:00004E96 51C8FFF0        	  4452:                 dbf d0,SUBQ_LOOP2
                            	  4453: 
00:00004E9A 0C8100000811    	  4454:                 cmpi.l #$00000811,d1
00:00004EA0 66FE            	  4455:                 bne.s *
00:00004EA2 0C8200FD7F80    	  4456:                 cmpi.l #$00FD7F80,d2
00:00004EA8 66FE            	  4457:                 bne.s *
                            	  4458: 
                            	  4459: 
                            	  4460: *     LONG
00:00004EAA 203C000000FF    	  4461:                 move.l #$000000FF,d0    * Loop counter
00:00004EB0 7200            	  4462:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004EB2 7400            	  4463:                 moveq  #$00000000,d2    * Data results accumulator
00:00004EB4 7600            	  4464:                 moveq  #$00000000,d3
00:00004EB6 7800            	  4465:                 moveq  #$00000000,d4
00:00004EB8 7A07            	  4466:                 moveq  #$00000007,d5
00:00004EBA 7C00            	  4467:                 moveq  #$00000000,d6
00:00004EBC 7E00            	  4468:                 moveq  #$00000000,d7
                            	  4469: 
00:00004EBE 5385            	  4470: SUBQ_LOOP3:     subq.l #1,d5
00:00004EC0 40C6            	  4471:                 move.w SR,d6
00:00004EC2 02860000001F    	  4472:                 andi.l #$1F,d6        * Isolate flags
00:00004EC8 D286            	  4473:                 add.l d6,d1           * Copy flag results into accumulator
00:00004ECA D485            	  4474:                 add.l d5,d2           * Copy data results into data accumulator
00:00004ECC 51C8FFF0        	  4475:                 dbf d0,SUBQ_LOOP3
                            	  4476: 
00:00004ED0 0C81000007DD    	  4477:                 cmpi.l #$000007DD,d1
00:00004ED6 66FE            	  4478:                 bne.s *
00:00004ED8 0C82FFFF8680    	  4479:                 cmpi.l #$FFFF8680,d2
00:00004EDE 66FE            	  4480:                 bne.s *
                            	  4481: 
                            	  4482: *     Check that Flags are not updated for Address registers
00:00004EE0 207C0001FFFF    	  4483:                 move.l #$0001FFFF,a0
00:00004EE6 44FC0000        	  4484:                 move #$00,CCR         * Clear flags
00:00004EEA 5F48            	  4485:                 subq.w #$7,a0
00:00004EEC 65FE            	  4486:                 bcs.s *
                            	  4487: 
00:00004EEE 4E75            	  4488:                 rts
                            	  4489: 
                            	  4490: 
                            	  4491: 
                            	  4492: 
                            	  4493: *-----------------------------------------------------------
                            	  4494: *-----------------------------------------------------------
                            	  4495: * OPCODE : MOVEQ
                            	  4496: *-----------------------------------------------------------
                            	  4497: *-----------------------------------------------------------
                            	  4498: 
                            	  4499: op_MOVEQ:
00:00004EF0 7000            	  4500:                 moveq  #$00000000,d0
00:00004EF2 7000            	  4501:                 moveq #$0,d0
00:00004EF4 66FE            	  4502:                 bne.s *
00:00004EF6 4A80            	  4503:                 cmpi.l #$00000000,d0
00:00004EF8 66FE            	  4504:                 bne.s *
                            	  4505: 
00:00004EFA 7000            	  4506:                 moveq  #$00000000,d0
00:00004EFC 7080            	  4507:                 moveq #-128,d0
00:00004EFE 67FE            	  4508:                 beq.s *
00:00004F00 6AFE            	  4509:                 bpl.s *
00:00004F02 0C80FFFFFF80    	  4510:                 cmpi.l #$FFFFFF80,d0
00:00004F08 66FE            	  4511:                 bne.s *
                            	  4512: 
                            	  4513: 
00:00004F0A 4E75            	  4514:                 rts
                            	  4515: 
                            	  4516: 
                            	  4517: *-----------------------------------------------------------
                            	  4518: *-----------------------------------------------------------
                            	  4519: * OPCODE : DIVU
                            	  4520: *-----------------------------------------------------------
                            	  4521: *-----------------------------------------------------------
                            	  4522: 
                            	  4523: op_DIVU:
                            	  4524: 
00:00004F0C 203CA5A5A5A5    	  4525:                 move.l #$a5a5a5a5,d0        * Initial Numerator
00:00004F12 223C00005A5A    	  4526:                 move.l #$00005a5a,d1        * Initial Divisor
00:00004F18 243CA5A5A5A5    	  4527:                 move.l #$a5a5a5a5,d2
00:00004F1E 7600            	  4528:                 moveq  #$00000000,d3
00:00004F20 7800            	  4529:                 moveq  #$00000000,d4        * Cumulative data results
00:00004F22 7A00            	  4530:                 moveq  #$00000000,d5       * Cumulative flag results
00:00004F24 7C0E            	  4531:                 move.l #$0000000E,d6       * Inner loop counter
00:00004F26 7E1E            	  4532:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4533: 
                            	  4534: 
00:00004F28 80C1            	  4535: DIVU_OUTER1:    divu d1,d0               * !! Easy68K C not always cleared
00:00004F2A 40C3            	  4536:                 move.w SR,d3
00:00004F2C 02830000000C    	  4537:                 andi.l #$0C,d3            * Isolate flags
00:00004F32 DA83            	  4538:                 add.l d3,d5               * Copy flag results into accumulator
00:00004F34 D880            	  4539:                 add.l d0,d4               * Copy data results into data accumulator
00:00004F36 E289            	  4540:                 lsr.l #$1,d1
                            	  4541: 
00:00004F38 51CEFFEE        	  4542:                 dbf d6,DIVU_OUTER1
00:00004F3C E28A            	  4543:                 lsr.l #$1,d2
00:00004F3E 2002            	  4544:                 move.l d2,d0
00:00004F40 223C00005A5A    	  4545:                 move.l #$00005a5a,d1       * Initial Divisor
00:00004F46 7C0E            	  4546:                 move.l #$0000000E,d6       * Inner loop counter
00:00004F48 51CFFFDE        	  4547:                 dbf d7,DIVU_OUTER1
                            	  4548: 
00:00004F4C 0C8492FEDB89    	  4549:                 cmpi.l #$92FEDB89,d4      * Check the data results
00:00004F52 66FE            	  4550:                 bne.s *
                            	  4551: 
00:00004F54 0C8500000110    	  4552:                 cmpi.l #$00000110,d5      * Check the Flag results
00:00004F5A 66FE            	  4553:                 bne.s *
                            	  4554: 
                            	  4555: 
00:00004F5C 4E75            	  4556:                 rts
                            	  4557: 
                            	  4558: 
                            	  4559: 
                            	  4560: *-----------------------------------------------------------
                            	  4561: *-----------------------------------------------------------
                            	  4562: * OPCODE : DIVS
                            	  4563: *-----------------------------------------------------------
                            	  4564: *-----------------------------------------------------------
                            	  4565: 
                            	  4566: op_DIVS:
                            	  4567: 
00:00004F5E 203CA5A5A5A5    	  4568: 	move.l #$a5a5a5a5,d0        * Initial Numerator
00:00004F64 223C00005A5A    	  4569: 	move.l #$00005a5a,d1        * Initial Divisor
00:00004F6A 243CA5A5A5A5    	  4570: 	move.l #$a5a5a5a5,d2
00:00004F70 7600            	  4571: 	moveq  #$00000000,d3
00:00004F72 7800            	  4572: 	moveq  #$00000000,d4        * Cumulative data results
00:00004F74 7A00            	  4573: 	moveq  #$00000000,d5       * Cumulative flag results
00:00004F76 7C0E            	  4574: 	move.l #$0000000E,d6       * Inner loop counter
00:00004F78 7E1E            	  4575: 	move.l #$0000001E,d7       * Outer loop counter
                            	  4576: 
                            	  4577: DIVS_OUTER1:
00:00004F7A 81C1            	  4578: 	divs d1,d0               * !! Easy68K C not always cleared
00:00004F7C 40C3            	  4579: 	move.w SR,d3
00:00004F7E 02830000000C    	  4580: 	andi.l #$0C,d3            * Isolate flags
00:00004F84 DA83            	  4581: 	add.l d3,d5               * Copy flag results into accumulator
00:00004F86 D880            	  4582: 	add.l d0,d4               * Copy data results into data accumulator
00:00004F88 E289            	  4583: 	lsr.l #$1,d1
                            	  4584: 
00:00004F8A 51CEFFEE        	  4585: 	dbf d6,DIVS_OUTER1
00:00004F8E E28A            	  4586: 	lsr.l #$1,d2
00:00004F90 2002            	  4587: 	move.l d2,d0
00:00004F92 223C00005A5A    	  4588: 	move.l #$00005a5a,d1       * Initial Divisor
00:00004F98 7C0E            	  4589: 	move.l #$0000000E,d6       * Inner loop counter
00:00004F9A 51CFFFDE        	  4590: 	dbf d7,DIVS_OUTER1
                            	  4591: 
00:00004F9E 0C844EC5D057    	  4592: 	cmpi.l #$4EC5D057,d4      * Check the data results
00:00004FA4 66FE            	  4593: 	bne.s *
                            	  4594: 
00:00004FA6 0C8500000038    	  4595: 	cmpi.l #$00000038,d5      * Check the Flag results
00:00004FAC 66FE            	  4596: 	bne.s *
00:00004FAE 4E75            	  4597: 	rts
                            	  4598: 
                            	  4599: 
                            	  4600: *-----------------------------------------------------------
                            	  4601: *-----------------------------------------------------------
                            	  4602: * OPCODE : OR
                            	  4603: *-----------------------------------------------------------
                            	  4604: *-----------------------------------------------------------
                            	  4605: 
                            	  4606: op_OR:
                            	  4607: 
                            	  4608: *  * <EA> to Register
                            	  4609: 
00:00004FB0 203CA5A5A5A5    	  4610:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00004FB6 223C8167E123    	  4611:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00004FBC 243CA5A5A5A5    	  4612:                 move.l #$a5a5a5a5,d2
00:00004FC2 7600            	  4613:                 moveq  #$00000000,d3
00:00004FC4 7800            	  4614:                 moveq  #$00000000,d4       * Cumulative data results
00:00004FC6 7A00            	  4615:                 moveq  #$00000000,d5       * Cumulative flag results
00:00004FC8 7C1E            	  4616:                 move.l #$0000001E,d6       * Inner loop counter
00:00004FCA 7E1E            	  4617:                 move.l #$0000001E,d7       * Outer loop counter
00:00004FCC 307C0100        	  4618:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4619: 
                            	  4620: 
                            	  4621: OR_OUTER1:
                            	  4622: 
                            	  4623: *     BYTE
00:00004FD0 2081            	  4624:                 move.l d1,(a0)
00:00004FD2 8010            	  4625:                 or.b (a0),d0
00:00004FD4 40C3            	  4626:                 move.w SR,d3
00:00004FD6 02830000000C    	  4627:                 andi.l #$0C,d3            * Isolate flags
00:00004FDC DA83            	  4628:                 add.l d3,d5               * Copy flag results into accumulator
00:00004FDE D880            	  4629:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4630: 
                            	  4631: *     WORD
00:00004FE0 2081            	  4632:                 move.l d1,(a0)
00:00004FE2 8050            	  4633:                 or.w (a0),d0
00:00004FE4 40C3            	  4634:                 move.w SR,d3
00:00004FE6 02830000000C    	  4635:                 andi.l #$0C,d3            * Isolate flags
00:00004FEC DA83            	  4636:                 add.l d3,d5               * Copy flag results into accumulator
00:00004FEE D880            	  4637:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4638: 
                            	  4639: *     LONG
00:00004FF0 2081            	  4640:                 move.l d1,(a0)
00:00004FF2 8090            	  4641:                 or.l (a0),d0
00:00004FF4 40C3            	  4642:                 move.w SR,d3
00:00004FF6 02830000000F    	  4643:                 andi.l #$0F,d3            * Isolate flags
00:00004FFC DA83            	  4644:                 add.l d3,d5               * Copy flag results into accumulator
00:00004FFE D880            	  4645:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4646: 
                            	  4647: 
00:00005000 E289            	  4648:                 lsr.l #$1,d1
00:00005002 51CEFFCC        	  4649:                 dbf d6,OR_OUTER1
00:00005006 E28A            	  4650:                 lsr.l #$1,d2
00:00005008 223C8167E123    	  4651:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000500E 7C1E            	  4652:                 move.l #$0000001E,d6       * Inner loop counter
00:00005010 51CFFFBE        	  4653:                 dbf d7,OR_OUTER1
                            	  4654: 
00:00005014 0C8476EAC803    	  4655:                 cmpi.l #$76EAC803,d4      * Check the data results
00:0000501A 66FE            	  4656:                 bne.s *
00:0000501C 0C8500005A18    	  4657:                 cmpi.l #$00005A18,d5      * Check the Flag results
00:00005022 66FE            	  4658:                 bne.s *
                            	  4659: 
                            	  4660: 
                            	  4661: *  * Register to <EA>
                            	  4662: 
00:00005024 203C86738374    	  4663:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:0000502A 223CFC55F2FE    	  4664:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:00005030 243C86738374    	  4665:                 move.l #$86738374,d2
00:00005036 7600            	  4666:                 moveq  #$00000000,d3
00:00005038 7800            	  4667:                 moveq  #$00000000,d4       * Cumulative data results
00:0000503A 7A00            	  4668:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000503C 7C1E            	  4669:                 move.l #$0000001E,d6       * Inner loop counter
00:0000503E 7E1D            	  4670:                 move.l #$0000001D,d7       * Outer loop counter
00:00005040 307C0100        	  4671:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4672: 
                            	  4673: 
                            	  4674: OR_OUTER2:
                            	  4675: 
                            	  4676: *     BYTE
00:00005044 2080            	  4677:                 move.l d0,(a0)
00:00005046 8310            	  4678:                 or.b d1,(a0)
00:00005048 40C3            	  4679:                 move.w SR,d3
00:0000504A 02830000000C    	  4680:                 andi.l #$0C,d3            * Isolate flags
00:00005050 DA83            	  4681:                 add.l d3,d5               * Copy flag results into accumulator
00:00005052 D890            	  4682:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4683: 
                            	  4684: *     WORD
00:00005054 2080            	  4685:                 move.l d0,(a0)
00:00005056 8350            	  4686:                 or.w d1,(a0)
00:00005058 40C3            	  4687:                 move.w SR,d3
00:0000505A 02830000000C    	  4688:                 andi.l #$0C,d3            * Isolate flags
00:00005060 DA83            	  4689:                 add.l d3,d5               * Copy flag results into accumulator
00:00005062 D890            	  4690:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4691: 
                            	  4692: *     LONG
00:00005064 2080            	  4693:                 move.l d0,(a0)
00:00005066 8390            	  4694:                 or.l d1,(a0)
00:00005068 40C3            	  4695:                 move.w SR,d3
00:0000506A 02830000000F    	  4696:                 andi.l #$0F,d3            * Isolate flags
00:00005070 DA83            	  4697:                 add.l d3,d5               * Copy flag results into accumulator
00:00005072 D890            	  4698:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4699: 
                            	  4700: 
00:00005074 E289            	  4701:                 lsr.l #$1,d1
00:00005076 51CEFFCC        	  4702:                 dbf d6,OR_OUTER2
00:0000507A E28A            	  4703:                 lsr.l #$1,d2
00:0000507C 223C8167E123    	  4704:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005082 7C1E            	  4705:                 move.l #$0000001E,d6       * Inner loop counter
00:00005084 51CFFFBE        	  4706:                 dbf d7,OR_OUTER2
                            	  4707: 
00:00005088 0C84FA82B9E4    	  4708:                 cmpi.l #$FA82B9E4,d4      * Check the data results
00:0000508E 66FE            	  4709:                 bne.s *
00:00005090 0C8500005730    	  4710:                 cmpi.l #$00005730,d5      * Check the Flag results
00:00005096 66FE            	  4711:                 bne.s *
                            	  4712: 
                            	  4713: 
00:00005098 4E75            	  4714:                 rts
                            	  4715: 
                            	  4716: 
                            	  4717: 
                            	  4718: *-----------------------------------------------------------
                            	  4719: *-----------------------------------------------------------
                            	  4720: * OPCODE : AND
                            	  4721: *-----------------------------------------------------------
                            	  4722: *-----------------------------------------------------------
                            	  4723: 
                            	  4724: op_AND:
                            	  4725: 
                            	  4726: *  * <EA> to Register
                            	  4727: 
00:0000509A 203CA5A5A5A5    	  4728:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000050A0 223C8167E123    	  4729:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:000050A6 243CA5A5A5A5    	  4730:                 move.l #$a5a5a5a5,d2
00:000050AC 7600            	  4731:                 moveq  #$00000000,d3
00:000050AE 7800            	  4732:                 moveq  #$00000000,d4       * Cumulative data results
00:000050B0 7A00            	  4733:                 moveq  #$00000000,d5       * Cumulative flag results
00:000050B2 7C1E            	  4734:                 move.l #$0000001E,d6       * Inner loop counter
00:000050B4 7E1E            	  4735:                 move.l #$0000001E,d7       * Outer loop counter
00:000050B6 307C0100        	  4736:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4737: 
                            	  4738: 
                            	  4739: AND_OUTER1:
                            	  4740: 
                            	  4741: *     BYTE
00:000050BA 2081            	  4742:                 move.l d1,(a0)
00:000050BC C010            	  4743:                 and.b (a0),d0
00:000050BE 40C3            	  4744:                 move.w sr,d3
00:000050C0 02830000000C    	  4745:                 andi.l #$0C,d3            * Isolate flags
00:000050C6 DA83            	  4746:                 add.l d3,d5               * Copy flag results into accumulator
00:000050C8 D880            	  4747:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4748: 
                            	  4749: *     WORD
00:000050CA 2081            	  4750:                 move.l d1,(a0)
00:000050CC C050            	  4751:                 and.w (a0),d0
00:000050CE 40C3            	  4752:                 move.w sr,d3
00:000050D0 02830000000C    	  4753:                 andi.l #$0C,d3            * Isolate flags
00:000050D6 DA83            	  4754:                 add.l d3,d5               * Copy flag results into accumulator
00:000050D8 D880            	  4755:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4756: 
                            	  4757: *     LONG
00:000050DA 2081            	  4758:                 move.l d1,(a0)
00:000050DC C090            	  4759:                 and.l (a0),d0
00:000050DE 40C3            	  4760:                 move.w sr,d3
00:000050E0 02830000000F    	  4761:                 andi.l #$0F,d3            * Isolate flags
00:000050E6 DA83            	  4762:                 add.l d3,d5               * Copy flag results into accumulator
00:000050E8 D880            	  4763:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4764: 
                            	  4765: 
00:000050EA E289            	  4766:                 lsr.l #$1,d1
00:000050EC 51CEFFCC        	  4767:                 dbf d6,AND_OUTER1
00:000050F0 E28A            	  4768:                 lsr.l #$1,d2
00:000050F2 223C8167E123    	  4769:                 move.l #$8167E123,d1       * Initial Data-Y
00:000050F8 7C1E            	  4770:                 move.l #$0000001E,d6       * Inner loop counter
00:000050FA 51CFFFBE        	  4771:                 dbf d7,AND_OUTER1
                            	  4772: 
00:000050FE 0C84CF212883    	  4773:                 cmpi.l #$CF212883,d4      * Check the data results
00:00005104 66FE            	  4774:                 bne.s *
00:00005106 0C8500002D10    	  4775:                 cmpi.l #$00002D10,d5      * Check the Flag results
00:0000510C 66FE            	  4776:                 bne.s *
                            	  4777: 
                            	  4778: 
                            	  4779: *  * Register to <EA>
                            	  4780: 
00:0000510E 203C86738374    	  4781:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:00005114 223CFC55F2FE    	  4782:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:0000511A 243C86738374    	  4783:                 move.l #$86738374,d2
00:00005120 7600            	  4784:                 moveq  #$00000000,d3
00:00005122 7800            	  4785:                 moveq  #$00000000,d4       * Cumulative data results
00:00005124 7A00            	  4786:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005126 7C1E            	  4787:                 move.l #$0000001E,d6       * Inner loop counter
00:00005128 7E1D            	  4788:                 move.l #$0000001D,d7       * Outer loop counter
00:0000512A 307C0100        	  4789:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4790: 
                            	  4791: 
                            	  4792: AND_OUTER2:
                            	  4793: 
                            	  4794: *     BYTE
00:0000512E 2080            	  4795:                 move.l d0,(a0)
00:00005130 C310            	  4796:                 and.b d1,(a0)
00:00005132 40C3            	  4797:                 move.w sr,d3
00:00005134 02830000000C    	  4798:                 andi.l #$0C,d3            * Isolate flags
00:0000513A DA83            	  4799:                 add.l d3,d5               * Copy flag results into accumulator
00:0000513C D890            	  4800:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4801: 
                            	  4802: *     WORD
00:0000513E 2080            	  4803:                 move.l d0,(a0)
00:00005140 C350            	  4804:                 and.w d1,(a0)
00:00005142 40C3            	  4805:                 move.w sr,d3
00:00005144 02830000000C    	  4806:                 andi.l #$0C,d3            * Isolate flags
00:0000514A DA83            	  4807:                 add.l d3,d5               * Copy flag results into accumulator
00:0000514C D890            	  4808:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4809: 
                            	  4810: *     LONG
00:0000514E 2080            	  4811:                 move.l d0,(a0)
00:00005150 C390            	  4812:                 and.l d1,(a0)
00:00005152 40C3            	  4813:                 move.w sr,d3
00:00005154 02830000000F    	  4814:                 andi.l #$0F,d3            * Isolate flags
00:0000515A DA83            	  4815:                 add.l d3,d5               * Copy flag results into accumulator
00:0000515C D890            	  4816:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4817: 
                            	  4818: 
00:0000515E E289            	  4819:                 lsr.l #$1,d1
00:00005160 51CEFFCC        	  4820:                 dbf d6,AND_OUTER2
00:00005164 E28A            	  4821:                 lsr.l #$1,d2
00:00005166 223C8167E123    	  4822:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000516C 7C1E            	  4823:                 move.l #$0000001E,d6       * Inner loop counter
00:0000516E 51CFFFBE        	  4824:                 dbf d7,AND_OUTER2
                            	  4825: 
00:00005172 0C844A3DE544    	  4826:                 cmpi.l #$4A3DE544,d4      * Check the data results
00:00005178 66FE            	  4827:                 bne.s *
00:0000517A 0C85000018E8    	  4828:                 cmpi.l #$000018E8,d5      * Check the Flag results
00:00005180 66FE            	  4829:                 bne.s *
                            	  4830: 
                            	  4831: 
00:00005182 4E75            	  4832:                 rts
                            	  4833: 
                            	  4834: 
                            	  4835: 
                            	  4836: *-----------------------------------------------------------
                            	  4837: *-----------------------------------------------------------
                            	  4838: * OPCODE : EOR
                            	  4839: *-----------------------------------------------------------
                            	  4840: *-----------------------------------------------------------
                            	  4841: 
                            	  4842: op_EOR:
                            	  4843: 
                            	  4844: *  * Register to <EA>
                            	  4845: 
00:00005184 203C86738374    	  4846:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:0000518A 223CFC55F2FE    	  4847:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:00005190 243C86738374    	  4848:                 move.l #$86738374,d2
00:00005196 7600            	  4849:                 moveq  #$00000000,d3
00:00005198 7800            	  4850:                 moveq  #$00000000,d4       * Cumulative data results
00:0000519A 7A00            	  4851:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000519C 7C1E            	  4852:                 move.l #$0000001E,d6       * Inner loop counter
00:0000519E 7E1D            	  4853:                 move.l #$0000001D,d7       * Outer loop counter
00:000051A0 307C0100        	  4854:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4855: 
                            	  4856: 
                            	  4857: EOR_OUTER2:
                            	  4858: 
                            	  4859: *     BYTE
00:000051A4 2080            	  4860:                 move.l d0,(a0)
00:000051A6 B310            	  4861:                 eor.b d1,(a0)
00:000051A8 40C3            	  4862:                 move.w sr,d3
00:000051AA 02830000000C    	  4863:                 andi.l #$0C,d3            * Isolate flags
00:000051B0 DA83            	  4864:                 add.l d3,d5               * Copy flag results into accumulator
00:000051B2 D890            	  4865:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4866: 
                            	  4867: *     WORD
00:000051B4 2080            	  4868:                 move.l d0,(a0)
00:000051B6 B350            	  4869:                 eor.w d1,(a0)
00:000051B8 40C3            	  4870:                 move.w sr,d3
00:000051BA 02830000000C    	  4871:                 andi.l #$0C,d3            * Isolate flags
00:000051C0 DA83            	  4872:                 add.l d3,d5               * Copy flag results into accumulator
00:000051C2 D890            	  4873:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4874: 
                            	  4875: *     LONG
00:000051C4 2080            	  4876:                 move.l d0,(a0)
00:000051C6 B390            	  4877:                 eor.l d1,(a0)
00:000051C8 40C3            	  4878:                 move.w sr,d3
00:000051CA 02830000000F    	  4879:                 andi.l #$0F,d3            * Isolate flags
00:000051D0 DA83            	  4880:                 add.l d3,d5               * Copy flag results into accumulator
00:000051D2 D890            	  4881:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4882: 
                            	  4883: 
00:000051D4 E289            	  4884:                 lsr.l #$1,d1
00:000051D6 51CEFFCC        	  4885:                 dbf d6,EOR_OUTER2
00:000051DA E28A            	  4886:                 lsr.l #$1,d2
00:000051DC 223C8167E123    	  4887:                 move.l #$8167E123,d1       * Initial Data-Y
00:000051E2 7C1E            	  4888:                 move.l #$0000001E,d6       * Inner loop counter
00:000051E4 51CFFFBE        	  4889:                 dbf d7,EOR_OUTER2
                            	  4890: 
00:000051E8 0C8455C5EB70    	  4891:                 cmpi.l #$55C5EB70,d4      * Check the data results
00:000051EE 66FE            	  4892:                 bne.s *
00:000051F0 0C8500004430    	  4893:                 cmpi.l #$00004430,d5      * Check the Flag results
00:000051F6 66FE            	  4894:                 bne.s *
                            	  4895: 
                            	  4896: 
00:000051F8 4E75            	  4897:                 rts
                            	  4898: 
                            	  4899: 
                            	  4900: *-----------------------------------------------------------
                            	  4901: *-----------------------------------------------------------
                            	  4902: * OPCODE : CMP
                            	  4903: *-----------------------------------------------------------
                            	  4904: *-----------------------------------------------------------
                            	  4905: 
                            	  4906: op_CMP:
                            	  4907: 
                            	  4908: 
                            	  4909: *  * <EA> to Register
                            	  4910: 
00:000051FA 203CA5A5A5A5    	  4911:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00005200 223C8167E123    	  4912:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00005206 243CA5A5A5A5    	  4913:                 move.l #$a5a5a5a5,d2
00:0000520C 7600            	  4914:                 moveq  #$00000000,d3
00:0000520E 7800            	  4915:                 moveq  #$00000000,d4       * Cumulative data results
00:00005210 7A00            	  4916:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005212 7C1E            	  4917:                 move.l #$0000001E,d6       * Inner loop counter
00:00005214 7E1E            	  4918:                 move.l #$0000001E,d7       * Outer loop counter
00:00005216 307C0100        	  4919:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4920: 
                            	  4921: 
                            	  4922: CMP_OUTER1:
                            	  4923: 
                            	  4924: *     BYTE
00:0000521A 2081            	  4925:                 move.l d1,(a0)
00:0000521C B010            	  4926:                 cmp.b (a0),d0
00:0000521E 40C3            	  4927:                 move.w sr,d3
00:00005220 02830000000F    	  4928:                 andi.l #$0F,d3            * Isolate flags
00:00005226 DA83            	  4929:                 add.l d3,d5               * Copy flag results into accumulator
00:00005228 D880            	  4930:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4931: 
                            	  4932: *     WORD
00:0000522A 2081            	  4933:                 move.l d1,(a0)
00:0000522C B050            	  4934:                 cmp.w (a0),d0
00:0000522E 40C3            	  4935:                 move.w sr,d3
00:00005230 02830000000F    	  4936:                 andi.l #$0F,d3            * Isolate flags
00:00005236 DA83            	  4937:                 add.l d3,d5               * Copy flag results into accumulator
00:00005238 D880            	  4938:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4939: 
                            	  4940: *     LONG
00:0000523A 2081            	  4941:                 move.l d1,(a0)
00:0000523C B090            	  4942:                 cmp.l (a0),d0
00:0000523E 40C3            	  4943:                 move.w sr,d3
00:00005240 02830000000F    	  4944:                 andi.l #$0F,d3            * Isolate flags
00:00005246 DA83            	  4945:                 add.l d3,d5               * Copy flag results into accumulator
00:00005248 D880            	  4946:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4947: 
                            	  4948: 
00:0000524A E289            	  4949:                 lsr.l #$1,d1
00:0000524C 51CEFFCC        	  4950:                 dbf d6,CMP_OUTER1
00:00005250 E28A            	  4951:                 lsr.l #$1,d2
00:00005252 223C8167E123    	  4952:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005258 7C1E            	  4953:                 move.l #$0000001E,d6       * Inner loop counter
00:0000525A 51CFFFBE        	  4954:                 dbf d7,CMP_OUTER1
                            	  4955: 
00:0000525E 0C847878712F    	  4956:                 cmpi.l #$7878712F,d4      * Check the data results
00:00005264 66FE            	  4957:                 bne.s *
00:00005266 0C8500005502    	  4958:                 cmpi.l #$00005502,d5      * Check the Flag results
00:0000526C 66FE            	  4959:                 bne.s *
                            	  4960: 
                            	  4961: 
                            	  4962: 
00:0000526E 4E75            	  4963:                 rts
                            	  4964: 
                            	  4965: 
                            	  4966: *-----------------------------------------------------------
                            	  4967: *-----------------------------------------------------------
                            	  4968: * OPCODE : CMPA
                            	  4969: *-----------------------------------------------------------
                            	  4970: *-----------------------------------------------------------
                            	  4971: 
                            	  4972: op_CMPA:
                            	  4973: 
                            	  4974: 
                            	  4975: *  * <EA> to Register
                            	  4976: 
00:00005270 207CA5A5A5A5    	  4977:                 move.l #$a5a5a5a5,a0       * Initial Data-X  Inner loop
00:00005276 223C8167E123    	  4978:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:0000527C 243CA5A5A5A5    	  4979:                 move.l #$a5a5a5a5,d2
00:00005282 7600            	  4980:                 moveq  #$00000000,d3
00:00005284 7800            	  4981:                 moveq  #$00000000,d4       * Cumulative data results
00:00005286 7A00            	  4982:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005288 7C1E            	  4983:                 move.l #$0000001E,d6       * Inner loop counter
00:0000528A 7E1E            	  4984:                 move.l #$0000001E,d7       * Outer loop counter
00:0000528C 327C0100        	  4985:                 move.l #$00000100,a1       * Address for memory EA operations
                            	  4986: 
                            	  4987: 
                            	  4988: CMPA_OUTER1:
                            	  4989: 
                            	  4990: 
                            	  4991: *     WORD
00:00005290 2281            	  4992:                 move.l d1,(a1)
00:00005292 B0D1            	  4993:                 cmpa.w (a1),a0
00:00005294 40C3            	  4994:                 move.w sr,d3
00:00005296 02830000000F    	  4995:                 andi.l #$0F,d3            * Isolate flags
00:0000529C DA83            	  4996:                 add.l d3,d5               * Copy flag results into accumulator
00:0000529E D888            	  4997:                 add.l a0,d4               * Copy data results into data accumulator
                            	  4998: 
                            	  4999: *     LONG
00:000052A0 2281            	  5000:                 move.l d1,(a1)
00:000052A2 B1D1            	  5001:                 cmpa.l (a1),a0
00:000052A4 40C3            	  5002:                 move.w sr,d3
00:000052A6 02830000000F    	  5003:                 andi.l #$0F,d3            * Isolate flags
00:000052AC DA83            	  5004:                 add.l d3,d5               * Copy flag results into accumulator
00:000052AE D888            	  5005:                 add.l a0,d4               * Copy data results into data accumulator
                            	  5006: 
                            	  5007: 
00:000052B0 E289            	  5008:                 lsr.l #$1,d1
00:000052B2 51CEFFDC        	  5009:                 dbf d6,CMPA_OUTER1
00:000052B6 E28A            	  5010:                 lsr.l #$1,d2
00:000052B8 223C8167E123    	  5011:                 move.l #$8167E123,d1       * Initial Data-Y
00:000052BE 7C1E            	  5012:                 move.l #$0000001E,d6       * Inner loop counter
00:000052C0 51CFFFCE        	  5013:                 dbf d7,CMPA_OUTER1
                            	  5014: 
00:000052C4 0C84A5A5A0CA    	  5015:                 cmpi.l #$a5a5a0ca,d4      * Check the data results
00:000052CA 66FE            	  5016:                 bne.s *
00:000052CC 0C8500003A7D    	  5017:                 cmpi.l #$00003A7D,d5      * Check the Flag results
00:000052D2 66FE            	  5018:                 bne.s *
                            	  5019: 
                            	  5020: 
00:000052D4 4E75            	  5021:                 rts
                            	  5022: 
                            	  5023: 
                            	  5024: 
                            	  5025: *-----------------------------------------------------------
                            	  5026: *-----------------------------------------------------------
                            	  5027: * OPCODE : CMPM
                            	  5028: *-----------------------------------------------------------
                            	  5029: *-----------------------------------------------------------
                            	  5030: 
                            	  5031: op_CMPM:
                            	  5032: 
00:000052D6 307C0100        	  5033:                 move.l #$00000100,a0       * Address for Data-X
00:000052DA 327C0200        	  5034:                 move.l #$00000200,a1       * Address for Data-Y
00:000052DE 7000            	  5035:                 moveq  #$00000000,d0
00:000052E0 7200            	  5036:                 moveq  #$00000000,d1
00:000052E2 7400            	  5037:                 moveq  #$00000000,d2
                            	  5038: 
00:000052E4 20FC11FF5580    	  5039:                 move.l #$11FF5580,(a0)+   * Populate test data
00:000052EA 20FC1111FFFF    	  5040:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:000052F0 20FC33333333    	  5041:                 move.l #$33333333,(a0)+   * Populate test data
00:000052F6 20FC44444444    	  5042:                 move.l #$44444444,(a0)+   * Populate test data
                            	  5043: 
00:000052FC 22FC80FF337F    	  5044:                 move.l #$80FF337F,(a1)+   * Populate test data
00:00005302 22FCFFFF1111    	  5045:                 move.l #$FFFF1111,(a1)+   * Populate test data
00:00005308 22FC33333333    	  5046:                 move.l #$33333333,(a1)+   * Populate test data
00:0000530E 22FC44444444    	  5047:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5048: 
00:00005314 307C0100        	  5049:                 move.l #$00000100,a0       * Address for Data-X
00:00005318 327C0200        	  5050:                 move.l #$00000200,a1       * Address for Data-Y
00:0000531C 7C0F            	  5051:                 move.l #$0000000F,d6       * Loop counter
                            	  5052: 
00:0000531E B308            	  5053: CMPM_LOOP1:     cmpm.b (a0)+,(a1)+
00:00005320 40C3            	  5054:                 move.w sr,d3
00:00005322 02830000000F    	  5055:                 andi.l #$0F,d3            * Isolate flags
00:00005328 D083            	  5056:                 add.l d3,d0               * Copy flag results into accumulator
00:0000532A 51CEFFF2        	  5057:                 dbf d6,CMPM_LOOP1
                            	  5058: 
                            	  5059: 
00:0000532E 307C0100        	  5060:                 move.l #$00000100,a0       * Address for Data-X
00:00005332 327C0200        	  5061:                 move.l #$00000200,a1       * Address for Data-Y
00:00005336 7C07            	  5062:                 moveq  #$00000007,d6       * Loop counter
                            	  5063: 
00:00005338 B348            	  5064: CMPM_LOOP2:     cmpm.w (a0)+,(a1)+
00:0000533A 40C3            	  5065:                 move.w sr,d3
00:0000533C 02830000000F    	  5066:                 andi.l #$0F,d3            * Isolate flags
00:00005342 D283            	  5067:                 add.l d3,d1               * Copy flag results into accumulator
00:00005344 51CEFFF2        	  5068:                 dbf d6,CMPM_LOOP2
                            	  5069: 
                            	  5070: 
00:00005348 307C0100        	  5071:                 move.l #$00000100,a0       * Address for Data-X
00:0000534C 327C0200        	  5072:                 move.l #$00000200,a1       * Address for Data-Y
00:00005350 7C03            	  5073:                 moveq  #$00000003,d6       * Loop counter
                            	  5074: 
00:00005352 B388            	  5075: CMPM_LOOP3:     cmpm.l (a0)+,(a1)+
00:00005354 40C3            	  5076:                 move.w sr,d3
00:00005356 02830000000F    	  5077:                 andi.l #$0F,d3            * Isolate flags
00:0000535C D483            	  5078:                 add.l d3,d2               * Copy flag results into accumulator
00:0000535E 51CEFFF2        	  5079:                 dbf d6,CMPM_LOOP3
                            	  5080: 
                            	  5081: 
00:00005362 0C800000004C    	  5082:                 cmpi.l #$0000004C,d0      * Check the data results
00:00005368 66FE            	  5083:                 bne.s *
00:0000536A 0C8100000024    	  5084:                 cmpi.l #$00000024,d1
00:00005370 66FE            	  5085:                 bne.s *
00:00005372 0C8200000012    	  5086:                 cmpi.l #$00000012,d2
00:00005378 66FE            	  5087:                 bne.s *
                            	  5088: 
00:0000537A 4E75            	  5089:                 rts
                            	  5090: 
                            	  5091: 
                            	  5092: *-----------------------------------------------------------
                            	  5093: *-----------------------------------------------------------
                            	  5094: * OPCODE : ADD
                            	  5095: *-----------------------------------------------------------
                            	  5096: *-----------------------------------------------------------
                            	  5097: 
                            	  5098: op_ADD:
                            	  5099: 
                            	  5100: 
                            	  5101: *  * <EA> to Register
00:0000537C 203CA5A5A5A5    	  5102:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00005382 223C8167E123    	  5103:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00005388 243CA5A5A5A5    	  5104:                 move.l #$a5a5a5a5,d2
00:0000538E 7600            	  5105:                 moveq  #$00000000,d3
00:00005390 7800            	  5106:                 moveq  #$00000000,d4       * Cumulative data results
00:00005392 7A00            	  5107:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005394 7C1E            	  5108:                 move.l #$0000001E,d6       * Inner loop counter
00:00005396 7E1E            	  5109:                 move.l #$0000001E,d7       * Outer loop counter
00:00005398 307C0100        	  5110:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5111: 
                            	  5112: 
                            	  5113: ADD_OUTER1:
                            	  5114: 
                            	  5115: *     BYTE
00:0000539C 2081            	  5116:                 move.l d1,(a0)
00:0000539E D010            	  5117:                 add.b (a0),d0
00:000053A0 40C3            	  5118:                 move.w sr,d3
00:000053A2 02830000001F    	  5119:                 andi.l #$1F,d3            * Isolate flags
00:000053A8 DA83            	  5120:                 add.l d3,d5               * Copy flag results into accumulator
00:000053AA D880            	  5121:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5122: 
                            	  5123: *     WORD
00:000053AC 2081            	  5124:                 move.l d1,(a0)
00:000053AE D050            	  5125:                 add.w (a0),d0
00:000053B0 40C3            	  5126:                 move.w sr,d3
00:000053B2 02830000000C    	  5127:                 andi.l #$0C,d3            * Isolate flags
00:000053B8 DA83            	  5128:                 add.l d3,d5               * Copy flag results into accumulator
00:000053BA D880            	  5129:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5130: 
                            	  5131: *     LONG
00:000053BC 2081            	  5132:                 move.l d1,(a0)
00:000053BE D090            	  5133:                 add.l (a0),d0
00:000053C0 40C3            	  5134:                 move.w sr,d3
00:000053C2 02830000000F    	  5135:                 andi.l #$0F,d3            * Isolate flags
00:000053C8 DA83            	  5136:                 add.l d3,d5               * Copy flag results into accumulator
00:000053CA D880            	  5137:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5138: 
                            	  5139: 
00:000053CC E299            	  5140:                 ror.l #$1,d1
00:000053CE 51CEFFCC        	  5141:                 dbf d6,ADD_OUTER1
00:000053D2 E29A            	  5142:                 ror.l #$1,d2
00:000053D4 223C8167E123    	  5143:                 move.l #$8167E123,d1       * Initial Data-Y
00:000053DA 7C1E            	  5144:                 move.l #$0000001E,d6       * Inner loop counter
00:000053DC 51CFFFBE        	  5145:                 dbf d7,ADD_OUTER1
                            	  5146: 
00:000053E0 0C8423ED428F    	  5147:                 cmpi.l #$23ED428F,d4      * Check the data results
00:000053E6 66FE            	  5148:                 bne.s *
00:000053E8 0C8500004C96    	  5149:                 cmpi.l #$00004C96,d5      * Check the Flag results
00:000053EE 66FE            	  5150:                 bne.s *
                            	  5151: 
                            	  5152: 
                            	  5153: *  * Register to <EA>
00:000053F0 203C86738374    	  5154:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:000053F6 223CFC55F2FE    	  5155:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:000053FC 243C86738374    	  5156:                 move.l #$86738374,d2
00:00005402 7600            	  5157:                 moveq  #$00000000,d3
00:00005404 7800            	  5158:                 moveq  #$00000000,d4       * Cumulative data results
00:00005406 7A00            	  5159:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005408 7C1E            	  5160:                 move.l #$0000001E,d6       * Inner loop counter
00:0000540A 7E1D            	  5161:                 move.l #$0000001D,d7       * Outer loop counter
00:0000540C 307C0100        	  5162:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5163: 
                            	  5164: 
                            	  5165: ADD_OUTER2:
                            	  5166: 
                            	  5167: *     BYTE
00:00005410 2080            	  5168:                 move.l d0,(a0)
00:00005412 D310            	  5169:                 add.b d1,(a0)
00:00005414 40C3            	  5170:                 move.w sr,d3
00:00005416 02830000000C    	  5171:                 andi.l #$0C,d3            * Isolate flags
00:0000541C DA83            	  5172:                 add.l d3,d5               * Copy flag results into accumulator
00:0000541E D890            	  5173:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5174: 
                            	  5175: *     WORD
00:00005420 2080            	  5176:                 move.l d0,(a0)
00:00005422 D350            	  5177:                 add.w d1,(a0)
00:00005424 40C3            	  5178:                 move.w sr,d3
00:00005426 02830000001F    	  5179:                 andi.l #$1F,d3            * Isolate flags
00:0000542C DA83            	  5180:                 add.l d3,d5               * Copy flag results into accumulator
00:0000542E D890            	  5181:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5182: 
                            	  5183: *     LONG
00:00005430 2080            	  5184:                 move.l d0,(a0)
00:00005432 D390            	  5185:                 add.l d1,(a0)
00:00005434 40C3            	  5186:                 move.w sr,d3
00:00005436 02830000000F    	  5187:                 andi.l #$0F,d3            * Isolate flags
00:0000543C DA83            	  5188:                 add.l d3,d5               * Copy flag results into accumulator
00:0000543E D890            	  5189:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5190: 
                            	  5191: 
00:00005440 E299            	  5192:                 ror.l #$1,d1
00:00005442 51CEFFCC        	  5193:                 dbf d6,ADD_OUTER2
00:00005446 E29A            	  5194:                 ror.l #$1,d2
00:00005448 223C8167E123    	  5195:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000544E 7C1E            	  5196:                 move.l #$0000001E,d6       * Inner loop counter
00:00005450 51CFFFBE        	  5197:                 dbf d7,ADD_OUTER2
                            	  5198: 
00:00005454 0C846701B884    	  5199:                 cmpi.l #$6701B884,d4      * Check the data results
00:0000545A 66FE            	  5200:                 bne.s *
00:0000545C 0C8500005467    	  5201:                 cmpi.l #$00005467,d5      * Check the Flag results
00:00005462 66FE            	  5202:                 bne.s *
                            	  5203: 
00:00005464 4E75            	  5204:                 rts
                            	  5205: 
                            	  5206: *-----------------------------------------------------------
                            	  5207: *-----------------------------------------------------------
                            	  5208: * OPCODE : SUB
                            	  5209: *-----------------------------------------------------------
                            	  5210: *-----------------------------------------------------------
                            	  5211: 
                            	  5212: op_SUB:
                            	  5213: 
                            	  5214: *  * <EA> to Register
00:00005466 203CA5A5A5A5    	  5215:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:0000546C 223C8167E123    	  5216:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00005472 243CA5A5A5A5    	  5217:                 move.l #$a5a5a5a5,d2
00:00005478 7600            	  5218:                 moveq  #$00000000,d3
00:0000547A 7800            	  5219:                 moveq  #$00000000,d4       * Cumulative data results
00:0000547C 7A00            	  5220:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000547E 7C1E            	  5221:                 move.l #$0000001E,d6       * Inner loop counter
00:00005480 7E1E            	  5222:                 move.l #$0000001E,d7       * Outer loop counter
00:00005482 307C0100        	  5223:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5224: 
                            	  5225: 
                            	  5226: SUB_OUTER1:
                            	  5227: 
                            	  5228: *     BYTE
00:00005486 2081            	  5229:                 move.l d1,(a0)
00:00005488 9010            	  5230:                 sub.b (a0),d0
00:0000548A 40C3            	  5231:                 move.w sr,d3
00:0000548C 02830000001F    	  5232:                 andi.l #$1F,d3            * Isolate flags
00:00005492 DA83            	  5233:                 add.l d3,d5               * Copy flag results into accumulator
00:00005494 D880            	  5234:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5235: 
                            	  5236: *     WORD
00:00005496 2081            	  5237:                 move.l d1,(a0)
00:00005498 9050            	  5238:                 sub.w (a0),d0
00:0000549A 40C3            	  5239:                 move.w sr,d3
00:0000549C 02830000000C    	  5240:                 andi.l #$0C,d3            * Isolate flags
00:000054A2 DA83            	  5241:                 add.l d3,d5               * Copy flag results into accumulator
00:000054A4 D880            	  5242:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5243: 
                            	  5244: *     LONG
00:000054A6 2081            	  5245:                 move.l d1,(a0)
00:000054A8 9090            	  5246:                 sub.l (a0),d0
00:000054AA 40C3            	  5247:                 move.w sr,d3
00:000054AC 02830000000F    	  5248:                 andi.l #$0F,d3            * Isolate flags
00:000054B2 DA83            	  5249:                 add.l d3,d5               * Copy flag results into accumulator
00:000054B4 D880            	  5250:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5251: 
                            	  5252: 
00:000054B6 E299            	  5253:                 ror.l #$1,d1
00:000054B8 51CEFFCC        	  5254:                 dbf d6,SUB_OUTER1
00:000054BC E29A            	  5255:                 ror.l #$1,d2
00:000054BE 223C8167E123    	  5256:                 move.l #$8167E123,d1       * Initial Data-Y
00:000054C4 7C1E            	  5257:                 move.l #$0000001E,d6       * Inner loop counter
00:000054C6 51CFFFBE        	  5258:                 dbf d7,SUB_OUTER1
                            	  5259: 
00:000054CA 0C841A8D14CF    	  5260:                 cmpi.l #$1A8D14CF,d4      * Check the data results
00:000054D0 66FE            	  5261:                 bne.s *
00:000054D2 0C8500004FC4    	  5262:                 cmpi.l #$00004FC4,d5      * Check the Flag results
00:000054D8 66FE            	  5263:                 bne.s *
                            	  5264: 
                            	  5265: 
                            	  5266: *  * Register to <EA>
00:000054DA 203C86738374    	  5267:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:000054E0 223CFC55F2FE    	  5268:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:000054E6 243C86738374    	  5269:                 move.l #$86738374,d2
00:000054EC 7600            	  5270:                 moveq  #$00000000,d3
00:000054EE 7800            	  5271:                 moveq  #$00000000,d4       * Cumulative data results
00:000054F0 7A00            	  5272:                 moveq  #$00000000,d5       * Cumulative flag results
00:000054F2 7C1E            	  5273:                 move.l #$0000001E,d6       * Inner loop counter
00:000054F4 7E1D            	  5274:                 move.l #$0000001D,d7       * Outer loop counter
00:000054F6 307C0100        	  5275:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5276: 
                            	  5277: 
                            	  5278: SUB_OUTER2:
                            	  5279: 
                            	  5280: *     BYTE
00:000054FA 2080            	  5281:                 move.l d0,(a0)
00:000054FC 9310            	  5282:                 sub.b d1,(a0)
00:000054FE 40C3            	  5283:                 move.w sr,d3
00:00005500 02830000000C    	  5284:                 andi.l #$0C,d3            * Isolate flags
00:00005506 DA83            	  5285:                 add.l d3,d5               * Copy flag results into accumulator
00:00005508 D890            	  5286:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5287: 
                            	  5288: *     WORD
00:0000550A 2080            	  5289:                 move.l d0,(a0)
00:0000550C 9350            	  5290:                 sub.w d1,(a0)
00:0000550E 40C3            	  5291:                 move.w sr,d3
00:00005510 02830000001F    	  5292:                 andi.l #$1F,d3            * Isolate flags
00:00005516 DA83            	  5293:                 add.l d3,d5               * Copy flag results into accumulator
00:00005518 D890            	  5294:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5295: 
                            	  5296: *     LONG
00:0000551A 2080            	  5297:                 move.l d0,(a0)
00:0000551C 9390            	  5298:                 sub.l d1,(a0)
00:0000551E 40C3            	  5299:                 move.w sr,d3
00:00005520 02830000000F    	  5300:                 andi.l #$0F,d3            * Isolate flags
00:00005526 DA83            	  5301:                 add.l d3,d5               * Copy flag results into accumulator
00:00005528 D890            	  5302:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5303: 
                            	  5304: 
00:0000552A E299            	  5305:                 ror.l #$1,d1
00:0000552C 51CEFFCC        	  5306:                 dbf d6,SUB_OUTER2
00:00005530 E29A            	  5307:                 ror.l #$1,d2
00:00005532 223C8167E123    	  5308:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005538 7C1E            	  5309:                 move.l #$0000001E,d6       * Inner loop counter
00:0000553A 51CFFFBE        	  5310:                 dbf d7,SUB_OUTER2
                            	  5311: 
00:0000553E 0C8436D38BEC    	  5312:                 cmpi.l #$36D38BEC,d4      * Check the data results
00:00005544 66FE            	  5313:                 bne.s *
00:00005546 0C85000045A5    	  5314:                 cmpi.l #$000045A5,d5      * Check the Flag results
00:0000554C 66FE            	  5315:                 bne.s *
                            	  5316: 
                            	  5317: 
                            	  5318: 
                            	  5319: 
00:0000554E 4E75            	  5320:                 rts
                            	  5321: 
                            	  5322: 
                            	  5323: 
                            	  5324: *-----------------------------------------------------------
                            	  5325: *-----------------------------------------------------------
                            	  5326: * OPCODE : ADDA
                            	  5327: *-----------------------------------------------------------
                            	  5328: *-----------------------------------------------------------
                            	  5329: 
                            	  5330: op_ADDA:
                            	  5331: 
                            	  5332: *  * <EA> to Register
00:00005550 203CA5A5A5A5    	  5333:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00005556 223C8167E123    	  5334:                 move.l #$8167E123,d1
00:0000555C 243CA5A5A5A5    	  5335:                 move.l #$a5a5a5a5,d2
00:00005562 7600            	  5336:                 moveq  #$00000000,d3
00:00005564 7800            	  5337:                 moveq  #$00000000,d4       * Cumulative data results
00:00005566 7A00            	  5338:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005568 7C1E            	  5339:                 move.l #$0000001E,d6       * Inner loop counter
00:0000556A 7E1E            	  5340:                 move.l #$0000001E,d7       * Outer loop counter
00:0000556C 307C0100        	  5341:                 move.l #$00000100,a0       * Address for memory EA operations
00:00005570 227C8167E123    	  5342:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5343: 
                            	  5344: ADDA_OUTER1:
                            	  5345: 
                            	  5346: *     WORD
                            	  5347: *                move.l d1,(a0)       * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5348: *                adda.w (a0),a1
                            	  5349: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5350: 
                            	  5351: *     LONG
00:00005576 2081            	  5352:                 move.l d1,(a0)
00:00005578 D3D0            	  5353:                 adda.l (a0),a1
00:0000557A D889            	  5354:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5355: 
00:0000557C E299            	  5356:                 ror.l #$1,d1
00:0000557E 51CEFFF6        	  5357:                 dbf d6,ADDA_OUTER1
00:00005582 E299            	  5358:                 ror.l #$1,d1
00:00005584 2241            	  5359:                 move.l d1,a1
00:00005586 223C8167E123    	  5360:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000558C 7C1E            	  5361:                 move.l #$0000001E,d6       * Inner loop counter
00:0000558E 51CFFFE6        	  5362:                 dbf d7,ADDA_OUTER1
                            	  5363: 
00:00005592 0C84AC04DB4C    	  5364:                 cmpi.l #$AC04DB4C,d4      * Check the data results
00:00005598 66FE            	  5365:                 bne.s *
                            	  5366: 
                            	  5367: 
00:0000559A 4E75            	  5368:                 rts
                            	  5369: 
                            	  5370: 
                            	  5371: *-----------------------------------------------------------
                            	  5372: *-----------------------------------------------------------
                            	  5373: * OPCODE : SUBA
                            	  5374: *-----------------------------------------------------------
                            	  5375: *-----------------------------------------------------------
                            	  5376: 
                            	  5377: op_SUBA:
                            	  5378: 
                            	  5379: *  * <EA> to Register
00:0000559C 203CA5A5A5A5    	  5380:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000055A2 223C8167E123    	  5381:                 move.l #$8167E123,d1
00:000055A8 243CA5A5A5A5    	  5382:                 move.l #$a5a5a5a5,d2
00:000055AE 7600            	  5383:                 moveq  #$00000000,d3
00:000055B0 7800            	  5384:                 moveq  #$00000000,d4       * Cumulative data results
00:000055B2 7A00            	  5385:                 moveq  #$00000000,d5       * Cumulative flag results
00:000055B4 7C1E            	  5386:                 move.l #$0000001E,d6       * Inner loop counter
00:000055B6 7E1E            	  5387:                 move.l #$0000001E,d7       * Outer loop counter
00:000055B8 307C0100        	  5388:                 move.l #$00000100,a0       * Address for memory EA operations
00:000055BC 227C8167E123    	  5389:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5390: 
                            	  5391: SUBA_OUTER1:
                            	  5392: 
                            	  5393: *     WORD
                            	  5394: *                move.l d1,(a0) * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5395: *                suba.w (a0),a1
                            	  5396: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5397: 
                            	  5398: *     LONG
00:000055C2 2081            	  5399:                 move.l d1,(a0)
00:000055C4 93D0            	  5400:                 suba.l (a0),a1
00:000055C6 D889            	  5401:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5402: 
00:000055C8 E299            	  5403:                 ror.l #$1,d1
00:000055CA 51CEFFF6        	  5404:                 dbf d6,SUBA_OUTER1
00:000055CE E299            	  5405:                 ror.l #$1,d1
00:000055D0 2241            	  5406:                 move.l d1,a1
00:000055D2 223C8167E123    	  5407:                 move.l #$8167E123,d1       * Initial Data-Y
00:000055D8 7C1E            	  5408:                 move.l #$0000001E,d6       * Inner loop counter
00:000055DA 51CFFFE6        	  5409:                 dbf d7,SUBA_OUTER1
                            	  5410: 
00:000055DE 0C84E1E36D7A    	  5411:                 cmpi.l #$E1E36D7A,d4      * Check the data results
00:000055E4 66FE            	  5412:                 bne.s *
                            	  5413: 
                            	  5414: 
00:000055E6 4E75            	  5415:                 rts
                            	  5416: 
                            	  5417: 
                            	  5418: 
                            	  5419: *-----------------------------------------------------------
                            	  5420: *-----------------------------------------------------------
                            	  5421: * OPCODE : ADDX
                            	  5422: *-----------------------------------------------------------
                            	  5423: *-----------------------------------------------------------
                            	  5424: 
                            	  5425: op_ADDX:
                            	  5426: 
                            	  5427: 
                            	  5428: *  * Register to Register
00:000055E8 203CA5A5A5A5    	  5429:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000055EE 223C8167E123    	  5430:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:000055F4 243CA5A5A5A5    	  5431:                 move.l #$a5a5a5a5,d2
00:000055FA 7600            	  5432:                 moveq  #$00000000,d3
00:000055FC 7800            	  5433:                 moveq  #$00000000,d4       * Cumulative data results
00:000055FE 7A00            	  5434:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005600 7C1E            	  5435:                 move.l #$0000001E,d6       * Inner loop counter
00:00005602 7E1E            	  5436:                 move.l #$0000001E,d7       * Outer loop counter
00:00005604 307C0100        	  5437:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5438: 
                            	  5439: 
                            	  5440: ADDX_OUTER1:
                            	  5441: 
                            	  5442: *     BYTE
00:00005608 2002            	  5443:                 move.l d2,d0
00:0000560A D101            	  5444:                 addx.b d1,d0
00:0000560C 40C3            	  5445:                 move.w sr,d3
00:0000560E 02830000001F    	  5446:                 andi.l #$1F,d3            * Isolate flags
00:00005614 DA83            	  5447:                 add.l d3,d5               * Copy flag results into accumulator
00:00005616 D880            	  5448:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5449: 
                            	  5450: *     WORD
00:00005618 2002            	  5451:                 move.l d2,d0
00:0000561A D141            	  5452:                 addx.w d1,d0
00:0000561C 40C3            	  5453:                 move.w sr,d3
00:0000561E 02830000001F    	  5454:                 andi.l #$1F,d3            * Isolate flags
00:00005624 DA83            	  5455:                 add.l d3,d5               * Copy flag results into accumulator
00:00005626 D880            	  5456:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5457: 
                            	  5458: *     LONG
00:00005628 2002            	  5459:                 move.l d2,d0
00:0000562A D181            	  5460:                 addx.l d1,d0
00:0000562C 40C3            	  5461:                 move.w sr,d3
00:0000562E 02830000001F    	  5462:                 andi.l #$1F,d3            * Isolate flags
00:00005634 DA83            	  5463:                 add.l d3,d5               * Copy flag results into accumulator
00:00005636 D880            	  5464:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5465: 
00:00005638 E299            	  5466:                 ror.l #$1,d1
00:0000563A 51CEFFCC        	  5467:                 dbf d6,ADDX_OUTER1
00:0000563E E29A            	  5468:                 ror.l #$1,d2
00:00005640 223C8167E123    	  5469:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005646 7C1E            	  5470:                 move.l #$0000001E,d6       * Inner loop counter
00:00005648 51CFFFBE        	  5471:                 dbf d7,ADDX_OUTER1
                            	  5472: 
00:0000564C 0C844E96A4D9    	  5473:                 cmpi.l #$4E96A4D9,d4      * Check the data results
00:00005652 66FE            	  5474:                 bne.s *
00:00005654 0C85000085CD    	  5475:                 cmpi.l #$000085CD,d5      * Check the Flag results
00:0000565A 66FE            	  5476:                 bne.s *
                            	  5477: 
                            	  5478: 
                            	  5479: 
                            	  5480: *     -(An),-(An)
                            	  5481: 
00:0000565C 7000            	  5482:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
00:0000565E 7200            	  5483:                 moveq  #$00000000,d1
00:00005660 7400            	  5484:                 moveq  #$00000000,d2
00:00005662 307C0100        	  5485:                 move.l #$00000100,a0       * Address for Data-X
00:00005666 327C0200        	  5486:                 move.l #$00000200,a1       * Address for Data-Y
00:0000566A 20FC11FF5580    	  5487:                 move.l #$11FF5580,(a0)+   * Populate test data
00:00005670 20FC1111FFFF    	  5488:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:00005676 20FC33333333    	  5489:                 move.l #$33333333,(a0)+   * Populate test data
00:0000567C 20FC44444444    	  5490:                 move.l #$44444444,(a0)+   * Populate test data
00:00005682 22FC80FF337F    	  5491:                 move.l #$80FF337F,(a1)+   * Populate test data
00:00005688 22FCFFFF1111    	  5492:                 move.l #$FFFF1111,(a1)+   * Populate test data
00:0000568E 22FC33333333    	  5493:                 move.l #$33333333,(a1)+   * Populate test data
00:00005694 22FC44444444    	  5494:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5495: 
                            	  5496: 
00:0000569A 7C0F            	  5497:                 move.l #$0000000F,d6       * Loop counter
                            	  5498: 
00:0000569C D308            	  5499: ADDX_LOOP3:     addx.b -(a0),-(a1)
00:0000569E 40C3            	  5500:                 move.w sr,d3
00:000056A0 02830000000F    	  5501:                 andi.l #$0F,d3            * Isolate flags
00:000056A6 D083            	  5502:                 add.l d3,d0               * Copy flag results into accumulator
00:000056A8 D211            	  5503:                 add.b (a1),d1
00:000056AA 51CEFFF0        	  5504:                 dbf d6,ADDX_LOOP3
                            	  5505: 
                            	  5506: 
00:000056AE 307C0110        	  5507:                 move.l #$00000110,a0       * Address for Data-X
00:000056B2 327C0210        	  5508:                 move.l #$00000210,a1       * Address for Data-Y
00:000056B6 7C07            	  5509:                 moveq  #$00000007,d6       * Loop counter
                            	  5510: 
00:000056B8 D348            	  5511: ADDX_LOOP4:     addx.w -(a0),-(a1)
00:000056BA 40C3            	  5512:                 move.w sr,d3
00:000056BC 02830000000F    	  5513:                 andi.l #$0F,d3            * Isolate flags
00:000056C2 D083            	  5514:                 add.l d3,d0               * Copy flag results into accumulator
00:000056C4 D251            	  5515:                 add.w (a1),d1
00:000056C6 51CEFFF0        	  5516:                 dbf d6,ADDX_LOOP4
                            	  5517: 
                            	  5518: 
00:000056CA 307C0110        	  5519:                 move.l #$00000110,a0       * Address for Data-X
00:000056CE 327C0210        	  5520:                 move.l #$00000210,a1       * Address for Data-Y
00:000056D2 7C03            	  5521:                 moveq  #$00000003,d6       * Loop counter
                            	  5522: 
00:000056D4 D388            	  5523: ADDX_LOOP5:     addx.l -(a0),-(a1)
00:000056D6 40C3            	  5524:                 move.w sr,d3
00:000056D8 02830000000F    	  5525:                 andi.l #$0F,d3            * Isolate flags
00:000056DE D083            	  5526:                 add.l d3,d0               * Copy flag results into accumulator
00:000056E0 D291            	  5527:                 add.l (a1),d1
00:000056E2 51CEFFF0        	  5528:                 dbf d6,ADDX_LOOP5
                            	  5529: 
                            	  5530: 
00:000056E6 0C8000000095    	  5531:                 cmpi.l #$00000095,d0      * Check the flag results
00:000056EC 66FE            	  5532:                 bne.s *
00:000056EE 0C81C812A682    	  5533:                 cmpi.l #$C812A682,d1      * Check the data results
00:000056F4 66FE            	  5534:                 bne.s *
                            	  5535: 
00:000056F6 4E75            	  5536:                 rts
                            	  5537: 
                            	  5538: 
                            	  5539: 
                            	  5540: 
                            	  5541: *-----------------------------------------------------------
                            	  5542: *-----------------------------------------------------------
                            	  5543: * OPCODE : SUBX
                            	  5544: *-----------------------------------------------------------
                            	  5545: *-----------------------------------------------------------
                            	  5546: 
                            	  5547: op_SUBX:
                            	  5548: 
                            	  5549: 
                            	  5550: *  * Register to Register
00:000056F8 203CA5A5A5A5    	  5551:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000056FE 223C8167E123    	  5552:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00005704 243CA5A5A5A5    	  5553:                 move.l #$a5a5a5a5,d2
00:0000570A 7600            	  5554:                 moveq  #$00000000,d3
00:0000570C 7800            	  5555:                 moveq  #$00000000,d4       * Cumulative data results
00:0000570E 7A00            	  5556:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005710 7C1E            	  5557:                 move.l #$0000001E,d6       * Inner loop counter
00:00005712 7E1E            	  5558:                 move.l #$0000001E,d7       * Outer loop counter
00:00005714 307C0100        	  5559:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5560: 
                            	  5561: 
                            	  5562: SUBX_OUTER1:
                            	  5563: 
                            	  5564: *     BYTE
00:00005718 2002            	  5565:                 move.l d2,d0
00:0000571A 9101            	  5566:                 subx.b d1,d0
00:0000571C 40C3            	  5567:                 move.w sr,d3
00:0000571E 02830000001F    	  5568:                 andi.l #$1F,d3            * Isolate flags
00:00005724 DA83            	  5569:                 add.l d3,d5               * Copy flag results into accumulator
00:00005726 D880            	  5570:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5571: 
                            	  5572: *     WORD
00:00005728 2002            	  5573:                 move.l d2,d0
00:0000572A 9141            	  5574:                 subx.w d1,d0
00:0000572C 40C3            	  5575:                 move.w sr,d3
00:0000572E 02830000001F    	  5576:                 andi.l #$1F,d3            * Isolate flags
00:00005734 DA83            	  5577:                 add.l d3,d5               * Copy flag results into accumulator
00:00005736 D880            	  5578:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5579: 
                            	  5580: *     LONG
00:00005738 2002            	  5581:                 move.l d2,d0
00:0000573A 9181            	  5582:                 subx.l d1,d0
00:0000573C 40C3            	  5583:                 move.w sr,d3
00:0000573E 02830000001F    	  5584:                 andi.l #$1F,d3            * Isolate flags
00:00005744 DA83            	  5585:                 add.l d3,d5               * Copy flag results into accumulator
00:00005746 D880            	  5586:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5587: 
00:00005748 E299            	  5588:                 ror.l #$1,d1
00:0000574A 51CEFFCC        	  5589:                 dbf d6,SUBX_OUTER1
00:0000574E E29A            	  5590:                 ror.l #$1,d2
00:00005750 223C8167E123    	  5591:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005756 7C1E            	  5592:                 move.l #$0000001E,d6       * Inner loop counter
00:00005758 51CFFFBE        	  5593:                 dbf d7,SUBX_OUTER1
                            	  5594: 
00:0000575C 0C84FCAA913E    	  5595:                 cmpi.l #$FCAA913E,d4      * Check the data results
00:00005762 66FE            	  5596:                 bne.s *
00:00005764 0C8500007E89    	  5597:                 cmpi.l #$00007E89,d5      * Check the Flag results
00:0000576A 66FE            	  5598:                 bne.s *
                            	  5599: 
                            	  5600: 
                            	  5601: 
                            	  5602: *     -(An),-(An)
                            	  5603: 
00:0000576C 7000            	  5604:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
00:0000576E 7200            	  5605:                 moveq  #$00000000,d1
00:00005770 7400            	  5606:                 moveq  #$00000000,d2
00:00005772 307C0100        	  5607:                 move.l #$00000100,a0       * Address for Data-X
00:00005776 327C0200        	  5608:                 move.l #$00000200,a1       * Address for Data-Y
00:0000577A 20FC11FF5580    	  5609:                 move.l #$11FF5580,(a0)+   * Populate test data
00:00005780 20FC1111FFFF    	  5610:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:00005786 20FC80FF337F    	  5611:                 move.l #$80FF337F,(a0)+   * Populate test data
00:0000578C 20FC44444444    	  5612:                 move.l #$44444444,(a0)+   * Populate test data
00:00005792 22FC80FF337F    	  5613:                 move.l #$80FF337F,(a1)+   * Populate test data
00:00005798 22FC1111FFFF    	  5614:                 move.l #$1111FFFF,(a1)+   * Populate test data
00:0000579E 22FC33333333    	  5615:                 move.l #$33333333,(a1)+   * Populate test data
00:000057A4 22FC5580EECC    	  5616:                 move.l #$5580EECC,(a1)+   * Populate test data
                            	  5617: 
                            	  5618: 
00:000057AA 7C0F            	  5619:                 move.l #$0000000F,d6       * Loop counter
                            	  5620: 
00:000057AC 9308            	  5621: SUBX_LOOP3:     subx.b -(a0),-(a1)
00:000057AE 40C3            	  5622:                 move.w sr,d3
00:000057B0 02830000000F    	  5623:                 andi.l #$0F,d3            * Isolate flags
00:000057B6 D083            	  5624:                 add.l d3,d0               * Copy flag results into accumulator
00:000057B8 D211            	  5625:                 add.b (a1),d1
00:000057BA 51CEFFF0        	  5626:                 dbf d6,SUBX_LOOP3
                            	  5627: 
                            	  5628: 
00:000057BE 307C0110        	  5629:                 move.l #$00000110,a0       * Address for Data-X
00:000057C2 327C0210        	  5630:                 move.l #$00000210,a1       * Address for Data-Y
00:000057C6 7C07            	  5631:                 moveq  #$00000007,d6       * Loop counter
                            	  5632: 
00:000057C8 9348            	  5633: SUBX_LOOP4:     subx.w -(a0),-(a1)
00:000057CA 40C3            	  5634:                 move.w sr,d3
00:000057CC 02830000000F    	  5635:                 andi.l #$0F,d3            * Isolate flags
00:000057D2 D083            	  5636:                 add.l d3,d0               * Copy flag results into accumulator
00:000057D4 D251            	  5637:                 add.w (a1),d1
00:000057D6 51CEFFF0        	  5638:                 dbf d6,SUBX_LOOP4
                            	  5639: 
                            	  5640: 
00:000057DA 307C0110        	  5641:                 move.l #$00000110,a0       * Address for Data-X
00:000057DE 327C0210        	  5642:                 move.l #$00000210,a1       * Address for Data-Y
00:000057E2 7C03            	  5643:                 moveq  #$00000003,d6       * Loop counter
                            	  5644: 
00:000057E4 9388            	  5645: SUBX_LOOP5:     subx.l -(a0),-(a1)
00:000057E6 40C3            	  5646:                 move.w sr,d3
00:000057E8 02830000000F    	  5647:                 andi.l #$0F,d3            * Isolate flags
00:000057EE D083            	  5648:                 add.l d3,d0               * Copy flag results into accumulator
00:000057F0 D291            	  5649:                 add.l (a1),d1
00:000057F2 51CEFFF0        	  5650:                 dbf d6,SUBX_LOOP5
                            	  5651: 
                            	  5652: 
00:000057F6 0C80000000B1    	  5653:                 cmpi.l #$000000B1,d0      * Check the flag results
00:000057FC 66FE            	  5654:                 bne.s *
00:000057FE 0C8162C6F417    	  5655:                 cmpi.l #$62C6F417,d1      * Check the data results
00:00005804 66FE            	  5656:                 bne.s *
                            	  5657: 
00:00005806 4E75            	  5658:                 rts
                            	  5659: 
                            	  5660: 
                            	  5661: *-----------------------------------------------------------
                            	  5662: *-----------------------------------------------------------
                            	  5663: * OPCODE : MULU
                            	  5664: *-----------------------------------------------------------
                            	  5665: *-----------------------------------------------------------
                            	  5666: 
                            	  5667: op_MULU:
                            	  5668: 
00:00005808 203CFE805501    	  5669:                 move.l #$FE805501,d0        * Initial
00:0000580E 223C5697EDB6    	  5670:                 move.l #$5697EDB6,d1        * Initial Y
00:00005814 243CFE805501    	  5671:                 move.l #$FE805501,d2
00:0000581A 7600            	  5672:                 moveq  #$00000000,d3
00:0000581C 7800            	  5673:                 moveq  #$00000000,d4        * Cumulative data results
00:0000581E 7A00            	  5674:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005820 7C0E            	  5675:                 move.l #$0000000E,d6       * Inner loop counter
00:00005822 7E0E            	  5676:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5677: 
                            	  5678: 
00:00005824 C0C1            	  5679: MULU_OUTER1:    mulu d1,d0
00:00005826 40C3            	  5680:                 move.w sr,d3
00:00005828 02830000000C    	  5681:                 andi.l #$0C,d3            * Isolate flags
00:0000582E DA83            	  5682:                 add.l d3,d5               * Copy flag results into accumulator
00:00005830 D880            	  5683:                 add.l d0,d4               * Copy data results into data accumulator
00:00005832 E299            	  5684:                 ror.l #$1,d1
                            	  5685: 
00:00005834 51CEFFEE        	  5686:                 dbf d6,MULU_OUTER1
00:00005838 E29A            	  5687:                 ror.l #$1,d2
00:0000583A 2002            	  5688:                 move.l d2,d0
00:0000583C 7C0E            	  5689:                 move.l #$0000000E,d6       * Inner loop counter
00:0000583E 51CFFFE4        	  5690:                 dbf d7,MULU_OUTER1
                            	  5691: 
00:00005842 0C8476FB988C    	  5692:                 cmpi.l #$76FB988C,d4      * Check the data results
00:00005848 66FE            	  5693:                 bne.s *
                            	  5694: 
00:0000584A 0C8500000170    	  5695:                 cmpi.l #$00000170,d5      * Check the Flag results
00:00005850 66FE            	  5696:                 bne.s *
                            	  5697: 
                            	  5698: 
00:00005852 4E75            	  5699:                 rts
                            	  5700: 
                            	  5701: 
                            	  5702: *-----------------------------------------------------------
                            	  5703: *-----------------------------------------------------------
                            	  5704: * OPCODE : MULS
                            	  5705: *-----------------------------------------------------------
                            	  5706: *-----------------------------------------------------------
                            	  5707: 
                            	  5708: op_MULS:
                            	  5709: 
00:00005854 203CFE805501    	  5710:                 move.l #$FE805501,d0        * Initial
00:0000585A 223C5697EDB6    	  5711:                 move.l #$5697EDB6,d1        * Initial Y
00:00005860 243CFE805501    	  5712:                 move.l #$FE805501,d2
00:00005866 7600            	  5713:                 moveq  #$00000000,d3
00:00005868 7800            	  5714:                 moveq  #$00000000,d4        * Cumulative data results
00:0000586A 7A00            	  5715:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000586C 7C0E            	  5716:                 move.l #$0000000E,d6       * Inner loop counter
00:0000586E 7E0E            	  5717:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5718: 
                            	  5719: 
00:00005870 C1C1            	  5720: MULS_OUTER1:    muls d1,d0
00:00005872 40C3            	  5721:                 move.w sr,d3
00:00005874 02830000000C    	  5722:                 andi.l #$0C,d3            * Isolate flags
00:0000587A DA83            	  5723:                 add.l d3,d5               * Copy flag results into accumulator
00:0000587C D880            	  5724:                 add.l d0,d4               * Copy data results into data accumulator
00:0000587E E299            	  5725:                 ror.l #$1,d1
                            	  5726: 
00:00005880 51CEFFEE        	  5727:                 dbf d6,MULS_OUTER1
00:00005884 E29A            	  5728:                 ror.l #$1,d2
00:00005886 2002            	  5729:                 move.l d2,d0
00:00005888 7C0E            	  5730:                 move.l #$0000000E,d6       * Inner loop counter
00:0000588A 51CFFFE4        	  5731:                 dbf d7,MULS_OUTER1
                            	  5732: 
00:0000588E 0C84D4E2988C    	  5733:                 cmpi.l #$D4E2988C,d4      * Check the data results
00:00005894 66FE            	  5734:                 bne.s *
                            	  5735: 
00:00005896 0C85000003E0    	  5736:                 cmpi.l #$000003E0,d5      * Check the Flag results
00:0000589C 66FE            	  5737:                 bne.s *
                            	  5738: 
                            	  5739: 
00:0000589E 4E75            	  5740:                 rts
                            	  5741: 
                            	  5742: 
                            	  5743: 
                            	  5744: *-----------------------------------------------------------
                            	  5745: *-----------------------------------------------------------
                            	  5746: * OPCODE : EXG
                            	  5747: *-----------------------------------------------------------
                            	  5748: *-----------------------------------------------------------
                            	  5749: 
                            	  5750: op_EXG:
00:000058A0 223CD1D1D1D1    	  5751:                 move.l #$d1d1d1d1,d1
00:000058A6 243CD2D2D2D2    	  5752:                 move.l #$d2d2d2d2,d2
00:000058AC 263CD3D3D3D3    	  5753:                 move.l #$d3d3d3d3,d3
00:000058B2 227CA1A1A1A1    	  5754:                 move.l #$a1a1a1a1,a1
00:000058B8 247CA2A2A2A2    	  5755:                 move.l #$a2a2a2a2,a2
00:000058BE 267CA3A3A3A3    	  5756:                 move.l #$a3a3a3a3,a3
                            	  5757: 
00:000058C4 C342            	  5758:                 exg d1,d2
00:000058C6 C34A            	  5759:                 exg a1,a2
00:000058C8 C78B            	  5760:                 exg d3,a3
                            	  5761: 
00:000058CA 0C81D2D2D2D2    	  5762:                 cmpi.l #$d2d2d2d2,d1      * Check the results
00:000058D0 66FE            	  5763:                 bne.s *
00:000058D2 0C82D1D1D1D1    	  5764:                 cmpi.l #$d1d1d1d1,d2
00:000058D8 66FE            	  5765:                 bne.s *
00:000058DA 0C83A3A3A3A3    	  5766:                 cmpi.l #$a3a3a3a3,d3
00:000058E0 66FE            	  5767:                 bne.s *
                            	  5768: 
00:000058E2 2209            	  5769:                 move.l a1,d1
00:000058E4 240A            	  5770:                 move.l a2,d2
00:000058E6 260B            	  5771:                 move.l a3,d3
                            	  5772: 
00:000058E8 0C81A2A2A2A2    	  5773:                 cmpi.l #$a2a2a2a2,d1
00:000058EE 66FE            	  5774:                 bne.s *
00:000058F0 0C82A1A1A1A1    	  5775:                 cmpi.l #$a1a1a1a1,d2
00:000058F6 66FE            	  5776:                 bne.s *
00:000058F8 0C83D3D3D3D3    	  5777:                 cmpi.l #$d3d3d3d3,d3
00:000058FE 66FE            	  5778:                 bne.s *
                            	  5779: 
00:00005900 4E75            	  5780:                 rts
                            	  5781: 
                            	  5782: 
                            	  5783: *-----------------------------------------------------------
                            	  5784: *-----------------------------------------------------------
                            	  5785: * OPCODE : ROx
                            	  5786: *-----------------------------------------------------------
                            	  5787: *-----------------------------------------------------------
                            	  5788: 
                            	  5789: *     Subroutine to check and accumulate the flags
00:00005902 40C3            	  5790: ROx_FLAGS:      move.w sr,d3
00:00005904 02830000000F    	  5791:                 andi.l #$0F,d3            * Isolate flags
00:0000590A DA83            	  5792:                 add.l d3,d5               * Copy flag results into accumulator
00:0000590C 4E75            	  5793:                 rts
                            	  5794: 
                            	  5795: op_ROx:
                            	  5796: 
                            	  5797: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  5798: 
                            	  5799: *        BYTE LEFT
00:0000590E 203C80018FF1    	  5800:                 move.l #$80018FF1,d0
00:00005914 7A00            	  5801:                 moveq  #$00000000,d5
00:00005916 7C11            	  5802:                 moveq  #$00000011,d6
                            	  5803: ROx_LOOP1:
00:00005918 ED38            	  5804:                 rol.b d6,d0
00:0000591A 61E6            	  5805:                 bsr ROx_FLAGS
00:0000591C 51CEFFFA        	  5806:                 dbf d6,ROx_LOOP1
00:00005920 0C8080018FE3    	  5807:                 cmpi.l #$80018FE3,d0
00:00005926 66FE            	  5808:                 bne.s *
00:00005928 0C850000006B    	  5809:                 cmpi.l #$0000006B,d5
00:0000592E 66FE            	  5810:                 bne.s *
                            	  5811: 
                            	  5812: *        BYTE RIGHT
00:00005930 203C80018FF1    	  5813:                 move.l #$80018FF1,d0
00:00005936 7C12            	  5814:                 moveq  #$00000012,d6
                            	  5815: ROx_LOOP2:
00:00005938 EC38            	  5816:                 ror.b d6,d0
00:0000593A 61C6            	  5817:                 bsr ROx_FLAGS
00:0000593C 51CEFFFA        	  5818:                 dbf d6,ROx_LOOP2
00:00005940 0C8080018F3E    	  5819:                 cmpi.l #$80018F3E,d0
00:00005946 66FE            	  5820:                 bne.s *
00:00005948 0C85000000C5    	  5821:                 cmpi.l #$000000C5,d5
00:0000594E 66FE            	  5822:                 bne.s *
                            	  5823: 
                            	  5824: 
                            	  5825: *        WORD LEFT
00:00005950 203C80018FF1    	  5826:                 move.l #$80018FF1,d0
00:00005956 7C13            	  5827:                 moveq  #$00000013,d6
                            	  5828: ROx_LOOP3:
00:00005958 ED78            	  5829:                 rol.w d6,d0
00:0000595A 61A6            	  5830:                 bsr ROx_FLAGS
00:0000595C 51CEFFFA        	  5831:                 dbf d6,ROx_LOOP3
00:00005960 0C80800163FC    	  5832:                 cmpi.l #$800163FC,d0
00:00005966 66FE            	  5833:                 bne.s *
00:00005968 0C8500000131    	  5834:                 cmpi.l #$00000131,d5
00:0000596E 66FE            	  5835:                 bne.s *
                            	  5836: 
                            	  5837: *        WORD RIGHT
00:00005970 203C80018FF1    	  5838:                 move.l #$80018FF1,d0
00:00005976 7C1E            	  5839:                 move.l #$0000001E,d6
                            	  5840: ROx_LOOP4:
00:00005978 EC78            	  5841:                 ror.w d6,d0
00:0000597A 6186            	  5842:                 bsr ROx_FLAGS
00:0000597C 51CEFFFA        	  5843:                 dbf d6,ROx_LOOP4
00:00005980 0C808001C7F8    	  5844:                 cmpi.l #$8001C7F8,d0
00:00005986 66FE            	  5845:                 bne.s *
00:00005988 0C85000001DB    	  5846:                 cmpi.l #$000001DB,d5
00:0000598E 66FE            	  5847:                 bne.s *
                            	  5848: 
                            	  5849: 
                            	  5850: *        LONG LEFT
00:00005990 203C80018FF1    	  5851:                 move.l #$80018FF1,d0
00:00005996 7C15            	  5852:                 moveq  #$00000015,d6
                            	  5853: ROx_LOOP5:
00:00005998 EDB8            	  5854:                 rol.l d6,d0
00:0000599A 6100FF66        	  5855:                 bsr ROx_FLAGS
00:0000599E 51CEFFF8        	  5856:                 dbf d6,ROx_LOOP5
00:000059A2 0C8000C7F8C0    	  5857:                 cmpi.l #$00C7F8C0,d0
00:000059A8 66FE            	  5858:                 bne.s *
00:000059AA 0C850000021A    	  5859:                 cmpi.l #$0000021A,d5
00:000059B0 66FE            	  5860:                 bne.s *
                            	  5861: 
                            	  5862: *        LONG RIGHT
00:000059B2 203C80018FF1    	  5863:                 move.l #$80018FF1,d0
00:000059B8 7C16            	  5864:                 moveq  #$00000016,d6
                            	  5865: ROx_LOOP6:
00:000059BA ECB8            	  5866:                 ror.l d6,d0
00:000059BC 6100FF44        	  5867:                 bsr ROx_FLAGS
00:000059C0 51CEFFF8        	  5868:                 dbf d6,ROx_LOOP6
00:000059C4 0C80000C7F8C    	  5869:                 cmpi.l #$000C7F8C,d0
00:000059CA 66FE            	  5870:                 bne.s *
00:000059CC 0C8500000250    	  5871:                 cmpi.l #$00000250,d5
00:000059D2 66FE            	  5872:                 bne.s *
                            	  5873: 
                            	  5874: 
                            	  5875: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  5876: 
00:000059D4 203C80018FF1    	  5877:                 move.l #$80018FF1,d0
00:000059DA 7A00            	  5878:                 moveq  #$00000000,d5
                            	  5879: 
                            	  5880: *        BYTE LEFT
00:000059DC E318            	  5881:                 rol.b #1,d0
00:000059DE 6100FF22        	  5882:                 bsr ROx_FLAGS
00:000059E2 EB18            	  5883:                 rol.b #5,d0
00:000059E4 6100FF1C        	  5884:                 bsr ROx_FLAGS
00:000059E8 EF18            	  5885:                 rol.b #7,d0
00:000059EA 6100FF16        	  5886:                 bsr ROx_FLAGS
00:000059EE E118            	  5887:                 rol.b #8,d0
00:000059F0 6100FF10        	  5888:                 bsr ROx_FLAGS
00:000059F4 0C8080018F3E    	  5889:                 cmpi.l #$80018F3E,d0
00:000059FA 66FE            	  5890:                 bne.s *
00:000059FC 0C8500000009    	  5891:                 cmpi.l #$00000009,d5
00:00005A02 66FE            	  5892:                 bne.s *
                            	  5893: 
                            	  5894: *        BYTE RIGHT
00:00005A04 E218            	  5895:                 ror.b #1,d0
00:00005A06 6100FEFA        	  5896:                 bsr ROx_FLAGS
00:00005A0A EA18            	  5897:                 ror.b #5,d0
00:00005A0C 6100FEF4        	  5898:                 bsr ROx_FLAGS
00:00005A10 EE18            	  5899:                 ror.b #7,d0
00:00005A12 6100FEEE        	  5900:                 bsr ROx_FLAGS
00:00005A16 E018            	  5901:                 ror.b #8,d0
00:00005A18 6100FEE8        	  5902:                 bsr ROx_FLAGS
00:00005A1C 0C8080018FF1    	  5903:                 cmpi.l #$80018FF1,d0
00:00005A22 66FE            	  5904:                 bne.s *
00:00005A24 0C8500000024    	  5905:                 cmpi.l #$00000024,d5
00:00005A2A 66FE            	  5906:                 bne.s *
                            	  5907: 
                            	  5908: *        WORD LEFT
00:00005A2C E358            	  5909:                 rol.w #1,d0
00:00005A2E 6100FED2        	  5910:                 bsr ROx_FLAGS
00:00005A32 EB58            	  5911:                 rol.w #5,d0
00:00005A34 6100FECC        	  5912:                 bsr ROx_FLAGS
00:00005A38 EF58            	  5913:                 rol.w #7,d0
00:00005A3A 6100FEC6        	  5914:                 bsr ROx_FLAGS
00:00005A3E E158            	  5915:                 rol.w #8,d0
00:00005A40 6100FEC0        	  5916:                 bsr ROx_FLAGS
00:00005A44 0C808001FE31    	  5917:                 cmpi.l #$8001FE31,d0
00:00005A4A 66FE            	  5918:                 bne.s *
00:00005A4C 0C8500000037    	  5919:                 cmpi.l #$00000037,d5
00:00005A52 66FE            	  5920:                 bne.s *
                            	  5921: 
                            	  5922: *        WORD RIGHT
00:00005A54 E258            	  5923:                 ror.w #1,d0
00:00005A56 6100FEAA        	  5924:                 bsr ROx_FLAGS
00:00005A5A EA58            	  5925:                 ror.w #5,d0
00:00005A5C 6100FEA4        	  5926:                 bsr ROx_FLAGS
00:00005A60 EE58            	  5927:                 ror.w #7,d0
00:00005A62 6100FE9E        	  5928:                 bsr ROx_FLAGS
00:00005A66 E058            	  5929:                 ror.w #8,d0
00:00005A68 6100FE98        	  5930:                 bsr ROx_FLAGS
00:00005A6C 0C8080018FF1    	  5931:                 cmpi.l #$80018FF1,d0
00:00005A72 66FE            	  5932:                 bne.s *
00:00005A74 0C850000005B    	  5933:                 cmpi.l #$0000005B,d5
00:00005A7A 66FE            	  5934:                 bne.s *
                            	  5935: 
                            	  5936: *        LONG LEFT
00:00005A7C E398            	  5937:                 rol.l #1,d0
00:00005A7E 6100FE82        	  5938:                 bsr ROx_FLAGS
00:00005A82 EB98            	  5939:                 rol.l #5,d0
00:00005A84 6100FE7C        	  5940:                 bsr ROx_FLAGS
00:00005A88 EF98            	  5941:                 rol.l #7,d0
00:00005A8A 6100FE76        	  5942:                 bsr ROx_FLAGS
00:00005A8E E198            	  5943:                 rol.l #8,d0
00:00005A90 6100FE70        	  5944:                 bsr ROx_FLAGS
00:00005A94 0C80FE300031    	  5945:                 cmpi.l #$FE300031,d0
00:00005A9A 66FE            	  5946:                 bne.s *
00:00005A9C 0C8500000065    	  5947:                 cmpi.l #$00000065,d5
00:00005AA2 66FE            	  5948:                 bne.s *
                            	  5949: 
                            	  5950: *        LONG RIGHT
00:00005AA4 E298            	  5951:                 ror.l #1,d0
00:00005AA6 6100FE5A        	  5952:                 bsr ROx_FLAGS
00:00005AAA EA98            	  5953:                 ror.l #5,d0
00:00005AAC 6100FE54        	  5954:                 bsr ROx_FLAGS
00:00005AB0 EE98            	  5955:                 ror.l #7,d0
00:00005AB2 6100FE4E        	  5956:                 bsr ROx_FLAGS
00:00005AB6 E098            	  5957:                 ror.l #8,d0
00:00005AB8 6100FE48        	  5958:                 bsr ROx_FLAGS
00:00005ABC 0C8080018FF1    	  5959:                 cmpi.l #$80018FF1,d0
00:00005AC2 66FE            	  5960:                 bne.s *
00:00005AC4 0C8500000080    	  5961:                 cmpi.l #$00000080,d5
00:00005ACA 66FE            	  5962:                 bne.s *
                            	  5963: 
                            	  5964: 
                            	  5965: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  5966: 
00:00005ACC 7A00            	  5967:                 moveq  #$00000000,d5
00:00005ACE 307C0100        	  5968:                 move.l #$00000100,a0
00:00005AD2 30BC8FF1        	  5969:                 move.w #$8FF1,(a0)
                            	  5970: 
                            	  5971: *        WORD LEFT
00:00005AD6 E7D0            	  5972:                 rol (a0)
00:00005AD8 6100FE28        	  5973:                 bsr ROx_FLAGS
00:00005ADC E7D0            	  5974:                 rol (a0)
00:00005ADE 6100FE22        	  5975:                 bsr ROx_FLAGS
00:00005AE2 E7D0            	  5976:                 rol (a0)
00:00005AE4 6100FE1C        	  5977:                 bsr ROx_FLAGS
00:00005AE8 E7D0            	  5978:                 rol (a0)
00:00005AEA 6100FE16        	  5979:                 bsr ROx_FLAGS
00:00005AEE 3010            	  5980:                 move.w (a0),d0
00:00005AF0 0C808001FF18    	  5981:                 cmpi.l #$8001FF18,d0
00:00005AF6 66FE            	  5982:                 bne.s *
00:00005AF8 0C8500000009    	  5983:                 cmpi.l #$00000009,d5
00:00005AFE 66FE            	  5984:                 bne.s *
                            	  5985: 
                            	  5986: *        WORD RIGHT
00:00005B00 E6D0            	  5987:                 ror (a0)
00:00005B02 6100FDFE        	  5988:                 bsr ROx_FLAGS
00:00005B06 E6D0            	  5989:                 ror (a0)
00:00005B08 6100FDF8        	  5990:                 bsr ROx_FLAGS
00:00005B0C E6D0            	  5991:                 ror (a0)
00:00005B0E 6100FDF2        	  5992:                 bsr ROx_FLAGS
00:00005B12 E6D0            	  5993:                 ror (a0)
00:00005B14 6100FDEC        	  5994:                 bsr ROx_FLAGS
00:00005B18 E6D0            	  5995:                 ror (a0)
00:00005B1A 6100FDE6        	  5996:                 bsr ROx_FLAGS
00:00005B1E E6D0            	  5997:                 ror (a0)
00:00005B20 6100FDE0        	  5998:                 bsr ROx_FLAGS
00:00005B24 3010            	  5999:                 move.w (a0),d0
00:00005B26 0C80800163FC    	  6000:                 cmpi.l #$800163FC,d0
00:00005B2C 66FE            	  6001:                 bne.s *
00:00005B2E 0C850000001B    	  6002:                 cmpi.l #$0000001B,d5
00:00005B34 66FE            	  6003:                 bne.s *
                            	  6004: 
00:00005B36 4E75            	  6005:                 rts
                            	  6006: 
                            	  6007: 
                            	  6008: 
                            	  6009: *-----------------------------------------------------------
                            	  6010: *-----------------------------------------------------------
                            	  6011: * OPCODE : ROXx
                            	  6012: *-----------------------------------------------------------
                            	  6013: *-----------------------------------------------------------
                            	  6014: 
                            	  6015: *     Subroutine to check and accumulate the flags
00:00005B38 40C3            	  6016: ROXx_FLAGS:     move.w sr,d3
00:00005B3A 02830000000F    	  6017:                 andi.l #$0F,d3            * Isolate flags
00:00005B40 DA83            	  6018:                 add.l d3,d5               * Copy flag results into accumulator
00:00005B42 4E75            	  6019:                 rts
                            	  6020: 
                            	  6021: op_ROXx:
                            	  6022: 
                            	  6023: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6024: 
                            	  6025: *        BYTE LEFT
00:00005B44 203C80018FF1    	  6026:                 move.l #$80018FF1,d0
00:00005B4A 7A00            	  6027:                 moveq  #$00000000,d5
00:00005B4C 7C11            	  6028:                 moveq  #$00000011,d6
                            	  6029: ROXx_LOOP1:
00:00005B4E ED30            	  6030:                 roxl.b d6,d0
00:00005B50 61E6            	  6031:                 bsr ROXx_FLAGS
00:00005B52 51CEFFFA        	  6032:                 dbf d6,ROXx_LOOP1
00:00005B56 0C8080018FD0    	  6033:                 cmpi.l #$80018FD0,d0
00:00005B5C 66FE            	  6034:                 bne.s *
00:00005B5E 0C8500000042    	  6035:                 cmpi.l #$00000042,d5
00:00005B64 66FE            	  6036:                 bne.s *
                            	  6037: 
                            	  6038: *        BYTE RIGHT
00:00005B66 203C80018FF1    	  6039:                 move.l #$80018FF1,d0
00:00005B6C 7C12            	  6040:                 moveq  #$00000012,d6
                            	  6041: ROXx_LOOP2:
00:00005B6E EC30            	  6042:                 roxr.b d6,d0
00:00005B70 61C6            	  6043:                 bsr ROXx_FLAGS
00:00005B72 51CEFFFA        	  6044:                 dbf d6,ROXx_LOOP2
00:00005B76 0C8080018F51    	  6045:                 cmpi.l #$80018F51,d0
00:00005B7C 66FE            	  6046:                 bne.s *
00:00005B7E 0C850000009C    	  6047:                 cmpi.l #$0000009C,d5
00:00005B84 66FE            	  6048:                 bne.s *
                            	  6049: 
                            	  6050: 
                            	  6051: *        WORD LEFT
00:00005B86 203C80018FF1    	  6052:                 move.l #$80018FF1,d0
00:00005B8C 7C13            	  6053:                 moveq  #$00000013,d6
                            	  6054: ROXx_LOOP3:
00:00005B8E ED70            	  6055:                 roxl.w d6,d0
00:00005B90 61A6            	  6056:                 bsr ROXx_FLAGS
00:00005B92 51CEFFFA        	  6057:                 dbf d6,ROXx_LOOP3
00:00005B96 0C8080013980    	  6058:                 cmpi.l #$80013980,d0
00:00005B9C 66FE            	  6059:                 bne.s *
00:00005B9E 0C85000000C9    	  6060:                 cmpi.l #$000000C9,d5
00:00005BA4 66FE            	  6061:                 bne.s *
                            	  6062: 
                            	  6063: *        WORD RIGHT
00:00005BA6 203C80018FF1    	  6064:                 move.l #$80018FF1,d0
00:00005BAC 7C1E            	  6065:                 move.l #$0000001E,d6
                            	  6066: ROXx_LOOP4:
00:00005BAE EC70            	  6067:                 roxr.w d6,d0
00:00005BB0 6186            	  6068:                 bsr ROXx_FLAGS
00:00005BB2 51CEFFFA        	  6069:                 dbf d6,ROXx_LOOP4
00:00005BB6 0C8080010A1D    	  6070:                 cmpi.l #$80010A1D,d0
00:00005BBC 66FE            	  6071:                 bne.s *
00:00005BBE 0C850000014D    	  6072:                 cmpi.l #$0000014D,d5
00:00005BC4 66FE            	  6073:                 bne.s *
                            	  6074: 
                            	  6075: 
                            	  6076: *        LONG LEFT
00:00005BC6 203C80018FF1    	  6077:                 move.l #$80018FF1,d0
00:00005BCC 7C15            	  6078:                 moveq  #$00000015,d6
                            	  6079: ROXx_LOOP5:
00:00005BCE EDB0            	  6080:                 roxl.l d6,d0
00:00005BD0 6100FF66        	  6081:                 bsr ROXx_FLAGS
00:00005BD4 51CEFFF8        	  6082:                 dbf d6,ROXx_LOOP5
00:00005BD8 0C80800185D0    	  6083:                 cmpi.l #$800185D0,d0
00:00005BDE 66FE            	  6084:                 bne.s *
00:00005BE0 0C85000001A1    	  6085:                 cmpi.l #$000001A1,d5
00:00005BE6 66FE            	  6086:                 bne.s *
                            	  6087: 
                            	  6088: *        LONG RIGHT
00:00005BE8 203C80018FF1    	  6089:                 move.l #$80018FF1,d0
00:00005BEE 7C16            	  6090:                 moveq  #$00000016,d6
                            	  6091: ROXx_LOOP6:
00:00005BF0 ECB0            	  6092:                 roxr.l d6,d0
00:00005BF2 6100FF44        	  6093:                 bsr ROXx_FLAGS
00:00005BF6 51CEFFF8        	  6094:                 dbf d6,ROXx_LOOP6
00:00005BFA 0C80082D8200    	  6095:                 cmpi.l #$082D8200,d0
00:00005C00 66FE            	  6096:                 bne.s *
00:00005C02 0C85000001DE    	  6097:                 cmpi.l #$000001DE,d5
00:00005C08 66FE            	  6098:                 bne.s *
                            	  6099: 
                            	  6100: 
                            	  6101: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6102: 
00:00005C0A 203C80018FF1    	  6103:                 move.l #$80018FF1,d0
00:00005C10 7A00            	  6104:                 moveq  #$00000000,d5
                            	  6105: 
                            	  6106: *        BYTE LEFT
00:00005C12 E310            	  6107:                 roxl.b #1,d0
00:00005C14 6100FF22        	  6108:                 bsr ROXx_FLAGS
00:00005C18 EB10            	  6109:                 roxl.b #5,d0
00:00005C1A 6100FF1C        	  6110:                 bsr ROXx_FLAGS
00:00005C1E EF10            	  6111:                 roxl.b #7,d0
00:00005C20 6100FF16        	  6112:                 bsr ROXx_FLAGS
00:00005C24 E110            	  6113:                 roxl.b #8,d0
00:00005C26 6100FF10        	  6114:                 bsr ROXx_FLAGS
00:00005C2A 0C8080018F09    	  6115:                 cmpi.l #$80018F09,d0
00:00005C30 66FE            	  6116:                 bne.s *
00:00005C32 0C850000000B    	  6117:                 cmpi.l #$0000000B,d5
00:00005C38 66FE            	  6118:                 bne.s *
                            	  6119: 
                            	  6120: *        BYTE RIGHT
00:00005C3A E210            	  6121:                 roxr.b #1,d0
00:00005C3C 6100FEFA        	  6122:                 bsr ROXx_FLAGS
00:00005C40 EA10            	  6123:                 roxr.b #5,d0
00:00005C42 6100FEF4        	  6124:                 bsr ROXx_FLAGS
00:00005C46 EE10            	  6125:                 roxr.b #7,d0
00:00005C48 6100FEEE        	  6126:                 bsr ROXx_FLAGS
00:00005C4C E010            	  6127:                 roxr.b #8,d0
00:00005C4E 6100FEE8        	  6128:                 bsr ROXx_FLAGS
00:00005C52 0C8080018F00    	  6129:                 cmpi.l #$80018F00,d0
00:00005C58 66FE            	  6130:                 bne.s *
00:00005C5A 0C8500000015    	  6131:                 cmpi.l #$00000015,d5
00:00005C60 66FE            	  6132:                 bne.s *
                            	  6133: 
                            	  6134: *        WORD LEFT
00:00005C62 E350            	  6135:                 roxl.w #1,d0
00:00005C64 6100FED2        	  6136:                 bsr ROXx_FLAGS
00:00005C68 EB50            	  6137:                 roxl.w #5,d0
00:00005C6A 6100FECC        	  6138:                 bsr ROXx_FLAGS
00:00005C6E EF50            	  6139:                 roxl.w #7,d0
00:00005C70 6100FEC6        	  6140:                 bsr ROXx_FLAGS
00:00005C74 E150            	  6141:                 roxl.w #8,d0
00:00005C76 6100FEC0        	  6142:                 bsr ROXx_FLAGS
00:00005C7A 0C808001B000    	  6143:                 cmpi.l #$8001B000,d0
00:00005C80 66FE            	  6144:                 bne.s *
00:00005C82 0C8500000027    	  6145:                 cmpi.l #$00000027,d5
00:00005C88 66FE            	  6146:                 bne.s *
                            	  6147: 
                            	  6148: *        WORD RIGHT
00:00005C8A E250            	  6149:                 roxr.w #1,d0
00:00005C8C 6100FEAA        	  6150:                 bsr ROXx_FLAGS
00:00005C90 EA50            	  6151:                 roxr.w #5,d0
00:00005C92 6100FEA4        	  6152:                 bsr ROXx_FLAGS
00:00005C96 EE50            	  6153:                 roxr.w #7,d0
00:00005C98 6100FE9E        	  6154:                 bsr ROXx_FLAGS
00:00005C9C E050            	  6155:                 roxr.w #8,d0
00:00005C9E 6100FE98        	  6156:                 bsr ROXx_FLAGS
00:00005CA2 0C8080010A00    	  6157:                 cmpi.l #$80010A00,d0
00:00005CA8 66FE            	  6158:                 bne.s *
00:00005CAA 0C8500000028    	  6159:                 cmpi.l #$00000028,d5
00:00005CB0 66FE            	  6160:                 bne.s *
                            	  6161: 
                            	  6162: *        LONG LEFT
00:00005CB2 E390            	  6163:                 roxl.l #1,d0
00:00005CB4 6100FE82        	  6164:                 bsr ROXx_FLAGS
00:00005CB8 EB90            	  6165:                 roxl.l #5,d0
00:00005CBA 6100FE7C        	  6166:                 bsr ROXx_FLAGS
00:00005CBE EF90            	  6167:                 roxl.l #7,d0
00:00005CC0 6100FE76        	  6168:                 bsr ROXx_FLAGS
00:00005CC4 E190            	  6169:                 roxl.l #8,d0
00:00005CC6 6100FE70        	  6170:                 bsr ROXx_FLAGS
00:00005CCA 0C8040000010    	  6171:                 cmpi.l #$40000010,d0
00:00005CD0 66FE            	  6172:                 bne.s *
00:00005CD2 0C850000002A    	  6173:                 cmpi.l #$0000002A,d5
00:00005CD8 66FE            	  6174:                 bne.s *
                            	  6175: 
                            	  6176: *        LONG RIGHT
00:00005CDA E290            	  6177:                 roxr.l #1,d0
00:00005CDC 6100FE5A        	  6178:                 bsr ROXx_FLAGS
00:00005CE0 EA90            	  6179:                 roxr.l #5,d0
00:00005CE2 6100FE54        	  6180:                 bsr ROXx_FLAGS
00:00005CE6 EE90            	  6181:                 roxr.l #7,d0
00:00005CE8 6100FE4E        	  6182:                 bsr ROXx_FLAGS
00:00005CEC E090            	  6183:                 roxr.l #8,d0
00:00005CEE 6100FE48        	  6184:                 bsr ROXx_FLAGS
00:00005CF2 0C8000010200    	  6185:                 cmpi.l #$00010200,d0
00:00005CF8 66FE            	  6186:                 bne.s *
00:00005CFA 0C8500000032    	  6187:                 cmpi.l #$00000032,d5
00:00005D00 66FE            	  6188:                 bne.s *
                            	  6189: 
                            	  6190: 
                            	  6191: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6192: 
00:00005D02 7A00            	  6193:                 moveq  #$00000000,d5
00:00005D04 307C0100        	  6194:                 move.l #$00000100,a0
00:00005D08 30BC8FF1        	  6195:                 move.w #$8FF1,(a0)
                            	  6196: 
                            	  6197: *        WORD LEFT
00:00005D0C E5D0            	  6198:                 roxl (a0)
00:00005D0E 6100FE28        	  6199:                 bsr ROXx_FLAGS
00:00005D12 E5D0            	  6200:                 roxl (a0)
00:00005D14 6100FE22        	  6201:                 bsr ROXx_FLAGS
00:00005D18 E5D0            	  6202:                 roxl (a0)
00:00005D1A 6100FE1C        	  6203:                 bsr ROXx_FLAGS
00:00005D1E E5D0            	  6204:                 roxl (a0)
00:00005D20 6100FE16        	  6205:                 bsr ROXx_FLAGS
00:00005D24 3010            	  6206:                 move.w (a0),d0
00:00005D26 0C800001FF10    	  6207:                 cmpi.l #$0001FF10,d0
00:00005D2C 66FE            	  6208:                 bne.s *
00:00005D2E 0C8500000009    	  6209:                 cmpi.l #$00000009,d5
00:00005D34 66FE            	  6210:                 bne.s *
                            	  6211: 
                            	  6212: *        WORD RIGHT
00:00005D36 E4D0            	  6213:                 roxr (a0)
00:00005D38 6100FDFE        	  6214:                 bsr ROXx_FLAGS
00:00005D3C E4D0            	  6215:                 roxr (a0)
00:00005D3E 6100FDF8        	  6216:                 bsr ROXx_FLAGS
00:00005D42 E4D0            	  6217:                 roxr (a0)
00:00005D44 6100FDF2        	  6218:                 bsr ROXx_FLAGS
00:00005D48 E4D0            	  6219:                 roxr (a0)
00:00005D4A 6100FDEC        	  6220:                 bsr ROXx_FLAGS
00:00005D4E E4D0            	  6221:                 roxr (a0)
00:00005D50 6100FDE6        	  6222:                 bsr ROXx_FLAGS
00:00005D54 E4D0            	  6223:                 roxr (a0)
00:00005D56 6100FDE0        	  6224:                 bsr ROXx_FLAGS
00:00005D5A 3010            	  6225:                 move.w (a0),d0
00:00005D5C 0C80000103FC    	  6226:                 cmpi.l #$000103FC,d0
00:00005D62 66FE            	  6227:                 bne.s *
00:00005D64 0C850000000A    	  6228:                 cmpi.l #$0000000A,d5
00:00005D6A 66FE            	  6229:                 bne.s *
                            	  6230: 
00:00005D6C 4E75            	  6231:                 rts
                            	  6232: 
                            	  6233: 
                            	  6234: 
                            	  6235: 
                            	  6236: *-----------------------------------------------------------
                            	  6237: *-----------------------------------------------------------
                            	  6238: * OPCODE : SHIFTS
                            	  6239: *-----------------------------------------------------------
                            	  6240: *-----------------------------------------------------------
                            	  6241: 
                            	  6242: *     Subroutine to check and accumulate the flags
00:00005D6E 40C3            	  6243: SHIFTS_FLAGS:   move.w sr,d3
00:00005D70 02830000000F    	  6244:                 andi.l #$0F,d3            * Isolate flags
00:00005D76 DA83            	  6245:                 add.l d3,d5               * Copy flag results into accumulator
00:00005D78 4E75            	  6246:                 rts
                            	  6247: 
                            	  6248: op_SHIFTS:
                            	  6249: 
                            	  6250: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6251: 
                            	  6252: *        BYTE LEFT
00:00005D7A 203C80018F81    	  6253:                 move.l #$80018F81,d0
00:00005D80 7A00            	  6254:                 moveq  #$00000000,d5
00:00005D82 7C02            	  6255:                 moveq  #$00000002,d6
                            	  6256: SHIFTS_LOOP1:
00:00005D84 ED20            	  6257:                 asl.b d6,d0
00:00005D86 61E6            	  6258:                 bsr SHIFTS_FLAGS
00:00005D88 51CEFFFA        	  6259:                 dbf d6,SHIFTS_LOOP1
00:00005D8C 0C8080018F08    	  6260:                 cmpi.l #$80018F08,d0
00:00005D92 66FE            	  6261:                 bne.s *
00:00005D94 0C8500000002    	  6262:                 cmpi.l #$00000002,d5
00:00005D9A 66FE            	  6263:                 bne.s *
                            	  6264: 
                            	  6265: *        BYTE RIGHT
00:00005D9C 203C80018F81    	  6266:                 move.l #$80018F81,d0
00:00005DA2 7C02            	  6267:                 moveq  #$00000002,d6
                            	  6268: SHIFTS_LOOP2:
00:00005DA4 EC20            	  6269:                 asr.b d6,d0
00:00005DA6 61C6            	  6270:                 bsr SHIFTS_FLAGS
00:00005DA8 51CEFFFA        	  6271:                 dbf d6,SHIFTS_LOOP2
00:00005DAC 0C8080018FF0    	  6272:                 cmpi.l #$80018FF0,d0
00:00005DB2 66FE            	  6273:                 bne.s *
00:00005DB4 0C850000001A    	  6274:                 cmpi.l #$0000001A,d5
00:00005DBA 66FE            	  6275:                 bne.s *
                            	  6276: 
                            	  6277: 
                            	  6278: *        WORD LEFT
00:00005DBC 203C80018FF1    	  6279:                 move.l #$80018FF1,d0
00:00005DC2 7C02            	  6280:                 moveq  #$00000002,d6
                            	  6281: SHIFTS_LOOP3:
00:00005DC4 ED60            	  6282:                 asl.w d6,d0
00:00005DC6 61A6            	  6283:                 bsr SHIFTS_FLAGS
00:00005DC8 51CEFFFA        	  6284:                 dbf d6,SHIFTS_LOOP3
00:00005DCC 0C8080017F88    	  6285:                 cmpi.l #$80017F88,d0
00:00005DD2 66FE            	  6286:                 bne.s *
00:00005DD4 0C850000001C    	  6287:                 cmpi.l #$0000001C,d5
00:00005DDA 66FE            	  6288:                 bne.s *
                            	  6289: 
                            	  6290: *        WORD RIGHT
00:00005DDC 203C80018FF1    	  6291:                 move.l #$80018FF1,d0
00:00005DE2 7C02            	  6292:                 moveq  #$00000002,d6
                            	  6293: SHIFTS_LOOP4:
00:00005DE4 EC60            	  6294:                 asr.w d6,d0
00:00005DE6 6186            	  6295:                 bsr SHIFTS_FLAGS
00:00005DE8 51CEFFFA        	  6296:                 dbf d6,SHIFTS_LOOP4
00:00005DEC 0C808001F1FE    	  6297:                 cmpi.l #$8001F1FE,d0
00:00005DF2 66FE            	  6298:                 bne.s *
00:00005DF4 0C8500000034    	  6299:                 cmpi.l #$00000034,d5
00:00005DFA 66FE            	  6300:                 bne.s *
                            	  6301: 
                            	  6302: 
                            	  6303: *        LONG LEFT
00:00005DFC 203C80018FF1    	  6304:                 move.l #$80018FF1,d0
00:00005E02 7C02            	  6305:                 moveq  #$00000002,d6
                            	  6306: SHIFTS_LOOP5:
00:00005E04 EDA0            	  6307:                 asl.l d6,d0
00:00005E06 6100FF66        	  6308:                 bsr SHIFTS_FLAGS
00:00005E0A 51CEFFF8        	  6309:                 dbf d6,SHIFTS_LOOP5
00:00005E0E 0C80000C7F88    	  6310:                 cmpi.l #$000C7F88,d0
00:00005E14 66FE            	  6311:                 bne.s *
00:00005E16 0C8500000036    	  6312:                 cmpi.l #$00000036,d5
00:00005E1C 66FE            	  6313:                 bne.s *
                            	  6314: 
                            	  6315: *        LONG RIGHT
00:00005E1E 203C80018FF1    	  6316:                 move.l #$80018FF1,d0
00:00005E24 7C02            	  6317:                 moveq  #$00000002,d6
                            	  6318: SHIFTS_LOOP6:
00:00005E26 ECA0            	  6319:                 asr.l d6,d0
00:00005E28 6100FF44        	  6320:                 bsr SHIFTS_FLAGS
00:00005E2C 51CEFFF8        	  6321:                 dbf d6,SHIFTS_LOOP6
00:00005E30 0C80F00031FE    	  6322:                 cmpi.l #$F00031FE,d0
00:00005E36 66FE            	  6323:                 bne.s *
00:00005E38 0C850000004E    	  6324:                 cmpi.l #$0000004E,d5
00:00005E3E 66FE            	  6325:                 bne.s *
                            	  6326: 
                            	  6327: 
                            	  6328: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6329: 
00:00005E40 203C80018FF1    	  6330:                 move.l #$80018FF1,d0
00:00005E46 7A00            	  6331:                 moveq  #$00000000,d5
                            	  6332: 
                            	  6333: *        BYTE LEFT
00:00005E48 D000            	  6334:                 asl.b #1,d0
00:00005E4A 6100FF22        	  6335:                 bsr SHIFTS_FLAGS
00:00005E4E E500            	  6336:                 asl.b #2,d0
00:00005E50 6100FF1C        	  6337:                 bsr SHIFTS_FLAGS
00:00005E54 D000            	  6338:                 asl.b #1,d0
00:00005E56 6100FF16        	  6339:                 bsr SHIFTS_FLAGS
00:00005E5A E700            	  6340:                 asl.b #3,d0
00:00005E5C 6100FF10        	  6341:                 bsr SHIFTS_FLAGS
00:00005E60 0C8080018F80    	  6342:                 cmpi.l #$80018F80,d0
00:00005E66 66FE            	  6343:                 bne.s *
00:00005E68 0C850000001F    	  6344:                 cmpi.l #$0000001F,d5
00:00005E6E 66FE            	  6345:                 bne.s *
                            	  6346: 
                            	  6347: *        BYTE RIGHT
00:00005E70 E200            	  6348:                 asr.b #1,d0
00:00005E72 6100FEFA        	  6349:                 bsr SHIFTS_FLAGS
00:00005E76 E400            	  6350:                 asr.b #2,d0
00:00005E78 6100FEF4        	  6351:                 bsr SHIFTS_FLAGS
00:00005E7C E600            	  6352:                 asr.b #3,d0
00:00005E7E 6100FEEE        	  6353:                 bsr SHIFTS_FLAGS
00:00005E82 E200            	  6354:                 asr.b #1,d0
00:00005E84 6100FEE8        	  6355:                 bsr SHIFTS_FLAGS
00:00005E88 0C8080018FFF    	  6356:                 cmpi.l #$80018FFF,d0
00:00005E8E 66FE            	  6357:                 bne.s *
00:00005E90 0C850000003F    	  6358:                 cmpi.l #$0000003F,d5
00:00005E96 66FE            	  6359:                 bne.s *
                            	  6360: 
                            	  6361: *        WORD LEFT
00:00005E98 D040            	  6362:                 asl.w #1,d0
00:00005E9A 6100FED2        	  6363:                 bsr SHIFTS_FLAGS
00:00005E9E E540            	  6364:                 asl.w #2,d0
00:00005EA0 6100FECC        	  6365:                 bsr SHIFTS_FLAGS
00:00005EA4 E740            	  6366:                 asl.w #3,d0
00:00005EA6 6100FEC6        	  6367:                 bsr SHIFTS_FLAGS
00:00005EAA EB40            	  6368:                 asl.w #5,d0
00:00005EAC 6100FEC0        	  6369:                 bsr SHIFTS_FLAGS
00:00005EB0 0C808001F800    	  6370:                 cmpi.l #$8001F800,d0
00:00005EB6 66FE            	  6371:                 bne.s *
00:00005EB8 0C8500000056    	  6372:                 cmpi.l #$00000056,d5
00:00005EBE 66FE            	  6373:                 bne.s *
                            	  6374: 
                            	  6375: *        WORD RIGHT
00:00005EC0 EA40            	  6376:                 asr.w #5,d0
00:00005EC2 6100FEAA        	  6377:                 bsr SHIFTS_FLAGS
00:00005EC6 E240            	  6378:                 asr.w #1,d0
00:00005EC8 6100FEA4        	  6379:                 bsr SHIFTS_FLAGS
00:00005ECC E440            	  6380:                 asr.w #2,d0
00:00005ECE 6100FE9E        	  6381:                 bsr SHIFTS_FLAGS
00:00005ED2 E840            	  6382:                 asr.w #4,d0
00:00005ED4 6100FE98        	  6383:                 bsr SHIFTS_FLAGS
00:00005ED8 0C808001FFFF    	  6384:                 cmpi.l #$8001FFFF,d0
00:00005EDE 66FE            	  6385:                 bne.s *
00:00005EE0 0C8500000077    	  6386:                 cmpi.l #$00000077,d5
00:00005EE6 66FE            	  6387:                 bne.s *
                            	  6388: 
                            	  6389: *        LONG LEFT
00:00005EE8 203C80018FF1    	  6390:                 move.l #$80018FF1,d0
00:00005EEE D080            	  6391:                 asl.l #1,d0
00:00005EF0 6100FE7C        	  6392:                 bsr SHIFTS_FLAGS
00:00005EF4 E580            	  6393:                 asl.l #2,d0
00:00005EF6 6100FE76        	  6394:                 bsr SHIFTS_FLAGS
00:00005EFA EF80            	  6395:                 asl.l #7,d0
00:00005EFC 6100FE70        	  6396:                 bsr SHIFTS_FLAGS
00:00005F00 E980            	  6397:                 asl.l #4,d0
00:00005F02 6100FE6A        	  6398:                 bsr SHIFTS_FLAGS
00:00005F06 0C8063FC4000    	  6399:                 cmpi.l #$63FC4000,d0
00:00005F0C 66FE            	  6400:                 bne.s *
00:00005F0E 0C850000007A    	  6401:                 cmpi.l #$0000007A,d5
00:00005F14 66FE            	  6402:                 bne.s *
                            	  6403: 
                            	  6404: *        LONG RIGHT
00:00005F16 203C80018FF1    	  6405:                 move.l #$80018FF1,d0
00:00005F1C E280            	  6406:                 asr.l #1,d0
00:00005F1E 6100FE4E        	  6407:                 bsr SHIFTS_FLAGS
00:00005F22 EA80            	  6408:                 asr.l #5,d0
00:00005F24 6100FE48        	  6409:                 bsr SHIFTS_FLAGS
00:00005F28 EE80            	  6410:                 asr.l #7,d0
00:00005F2A 6100FE42        	  6411:                 bsr SHIFTS_FLAGS
00:00005F2E E080            	  6412:                 asr.l #8,d0
00:00005F30 6100FE3C        	  6413:                 bsr SHIFTS_FLAGS
00:00005F34 0C80FFFFFC00    	  6414:                 cmpi.l #$FFFFFC00,d0
00:00005F3A 66FE            	  6415:                 bne.s *
00:00005F3C 0C850000009C    	  6416:                 cmpi.l #$0000009C,d5
00:00005F42 66FE            	  6417:                 bne.s *
                            	  6418: 
                            	  6419: 
                            	  6420: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6421: 
00:00005F44 7A00            	  6422:                 moveq  #$00000000,d5
00:00005F46 307C0100        	  6423:                 move.l #$00000100,a0
00:00005F4A 30BC8FF1        	  6424:                 move.w #$8FF1,(a0)
                            	  6425: 
                            	  6426: *        WORD LEFT
00:00005F4E E1D0            	  6427:                 asl  (a0)
00:00005F50 6100FE1C        	  6428:                 bsr SHIFTS_FLAGS
00:00005F54 E1D0            	  6429:                 asl  (a0)
00:00005F56 6100FE16        	  6430:                 bsr SHIFTS_FLAGS
00:00005F5A E1D0            	  6431:                 asl  (a0)
00:00005F5C 6100FE10        	  6432:                 bsr SHIFTS_FLAGS
00:00005F60 E1D0            	  6433:                 asl  (a0)
00:00005F62 6100FE0A        	  6434:                 bsr SHIFTS_FLAGS
00:00005F66 3010            	  6435:                 move.w (a0),d0
00:00005F68 0C80FFFFFF10    	  6436:                 cmpi.l #$FFFFFF10,d0
00:00005F6E 66FE            	  6437:                 bne.s *
00:00005F70 0C850000000D    	  6438:                 cmpi.l #$0000000D,d5
00:00005F76 66FE            	  6439:                 bne.s *
                            	  6440: 
                            	  6441: *        WORD RIGHT
00:00005F78 E0D0            	  6442:                 asr (a0)
00:00005F7A 6100FDF2        	  6443:                 bsr SHIFTS_FLAGS
00:00005F7E E0D0            	  6444:                 asr (a0)
00:00005F80 6100FDEC        	  6445:                 bsr SHIFTS_FLAGS
00:00005F84 E0D0            	  6446:                 asr (a0)
00:00005F86 6100FDE6        	  6447:                 bsr SHIFTS_FLAGS
00:00005F8A E0D0            	  6448:                 asr (a0)
00:00005F8C 6100FDE0        	  6449:                 bsr SHIFTS_FLAGS
00:00005F90 E0D0            	  6450:                 asr (a0)
00:00005F92 6100FDDA        	  6451:                 bsr SHIFTS_FLAGS
00:00005F96 E0D0            	  6452:                 asr (a0)
00:00005F98 6100FDD4        	  6453:                 bsr SHIFTS_FLAGS
00:00005F9C 3010            	  6454:                 move.w (a0),d0
00:00005F9E 0C80FFFFFFFC    	  6455:                 cmpi.l #$FFFFFFFC,d0
00:00005FA4 66FE            	  6456:                 bne.s *
00:00005FA6 0C850000003E    	  6457:                 cmpi.l #$0000003E,d5
00:00005FAC 66FE            	  6458:                 bne.s *
                            	  6459: 
00:00005FAE 4E75            	  6460:                 rts
                            	  6461: 
                            	  6462: 
                            	  6463: 
                            	  6464: *-----------------------------------------------------------
                            	  6465: *-----------------------------------------------------------
                            	  6466: * OPCODE : SHIFTS2
                            	  6467: *-----------------------------------------------------------
                            	  6468: *-----------------------------------------------------------
                            	  6469: 
                            	  6470: *     Subroutine to check and accumulate the flags
00:00005FB0 40C3            	  6471: SHIFTS2_FLAGS:  move.w sr,d3
00:00005FB2 02830000000F    	  6472:                 andi.l #$0F,d3            * Isolate flags
00:00005FB8 DA83            	  6473:                 add.l d3,d5               * Copy flag results into accumulator
00:00005FBA 4E75            	  6474:                 rts
                            	  6475: 
                            	  6476: op_SHIFTS2:
                            	  6477: 
                            	  6478: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6479: 
                            	  6480: *        BYTE LEFT
00:00005FBC 203C80018F81    	  6481:                 move.l #$80018F81,d0
00:00005FC2 7A00            	  6482:                 moveq  #$00000000,d5
00:00005FC4 7C02            	  6483:                 moveq  #$00000002,d6
                            	  6484: SHIFTS2_LOOP1:
00:00005FC6 ED28            	  6485:                 lsl.b d6,d0
00:00005FC8 61E6            	  6486:                 bsr SHIFTS2_FLAGS
00:00005FCA 51CEFFFA        	  6487:                 dbf d6,SHIFTS2_LOOP1
00:00005FCE 0C8080018F08    	  6488:                 cmpi.l #$80018F08,d0
00:00005FD4 66FE            	  6489:                 bne.s *
00:00005FD6 4A85            	  6490:                 cmpi.l #$00000000,d5
00:00005FD8 66FE            	  6491:                 bne.s *
                            	  6492: 
                            	  6493: *        BYTE RIGHT
00:00005FDA 203C80018F81    	  6494:                 move.l #$80018F81,d0
00:00005FE0 7C02            	  6495:                 moveq  #$00000002,d6
                            	  6496: SHIFTS2_LOOP2:
00:00005FE2 EC28            	  6497:                 lsr.b d6,d0
00:00005FE4 61CA            	  6498:                 bsr SHIFTS2_FLAGS
00:00005FE6 51CEFFFA        	  6499:                 dbf d6,SHIFTS2_LOOP2
00:00005FEA 0C8080018F10    	  6500:                 cmpi.l #$80018F10,d0
00:00005FF0 66FE            	  6501:                 bne.s *
00:00005FF2 4A85            	  6502:                 cmpi.l #$00000000,d5
00:00005FF4 66FE            	  6503:                 bne.s *
                            	  6504: 
                            	  6505: 
                            	  6506: *        WORD LEFT
00:00005FF6 203C80018FF1    	  6507:                 move.l #$80018FF1,d0
00:00005FFC 7C02            	  6508:                 moveq  #$00000002,d6
                            	  6509: SHIFTS2_LOOP3:
00:00005FFE ED68            	  6510:                 lsl.w d6,d0
00:00006000 61AE            	  6511:                 bsr SHIFTS2_FLAGS
00:00006002 51CEFFFA        	  6512:                 dbf d6,SHIFTS2_LOOP3
00:00006006 0C8080017F88    	  6513:                 cmpi.l #$80017F88,d0
00:0000600C 66FE            	  6514:                 bne.s *
00:0000600E 4A85            	  6515:                 cmpi.l #$00000000,d5
00:00006010 66FE            	  6516:                 bne.s *
                            	  6517: 
                            	  6518: *        WORD RIGHT
00:00006012 203C80018FF1    	  6519:                 move.l #$80018FF1,d0
00:00006018 7C02            	  6520:                 moveq  #$00000002,d6
                            	  6521: SHIFTS2_LOOP4:
00:0000601A EC68            	  6522:                 lsr.w d6,d0
00:0000601C 6192            	  6523:                 bsr SHIFTS2_FLAGS
00:0000601E 51CEFFFA        	  6524:                 dbf d6,SHIFTS2_LOOP4
00:00006022 0C80800111FE    	  6525:                 cmpi.l #$800111FE,d0
00:00006028 66FE            	  6526:                 bne.s *
00:0000602A 4A85            	  6527:                 cmpi.l #$00000000,d5
00:0000602C 66FE            	  6528:                 bne.s *
                            	  6529: 
                            	  6530: 
                            	  6531: *        LONG LEFT
00:0000602E 203C80018FF1    	  6532:                 move.l #$80018FF1,d0
00:00006034 7C02            	  6533:                 moveq  #$00000002,d6
                            	  6534: SHIFTS2_LOOP5:
00:00006036 EDA8            	  6535:                 lsl.l d6,d0
00:00006038 6100FF76        	  6536:                 bsr SHIFTS2_FLAGS
00:0000603C 51CEFFF8        	  6537:                 dbf d6,SHIFTS2_LOOP5
00:00006040 0C80000C7F88    	  6538:                 cmpi.l #$000C7F88,d0
00:00006046 66FE            	  6539:                 bne.s *
00:00006048 4A85            	  6540:                 cmpi.l #$00000000,d5
00:0000604A 66FE            	  6541:                 bne.s *
                            	  6542: 
                            	  6543: *        LONG RIGHT
00:0000604C 203C80018FF1    	  6544:                 move.l #$80018FF1,d0
00:00006052 7C02            	  6545:                 moveq  #$00000002,d6
                            	  6546: SHIFTS2_LOOP6:
00:00006054 ECA8            	  6547:                 lsr.l d6,d0
00:00006056 6100FF58        	  6548:                 bsr SHIFTS2_FLAGS
00:0000605A 51CEFFF8        	  6549:                 dbf d6,SHIFTS2_LOOP6
00:0000605E 0C80100031FE    	  6550:                 cmpi.l #$100031FE,d0
00:00006064 66FE            	  6551:                 bne.s *
00:00006066 4A85            	  6552:                 cmpi.l #$00000000,d5
00:00006068 66FE            	  6553:                 bne.s *
                            	  6554: 
                            	  6555: 
                            	  6556: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6557: 
00:0000606A 203C80018FF1    	  6558:                 move.l #$80018FF1,d0
00:00006070 7A00            	  6559:                 moveq  #$00000000,d5
                            	  6560: 
                            	  6561: *        BYTE LEFT
00:00006072 E308            	  6562:                 lsl.b #1,d0
00:00006074 6100FF3A        	  6563:                 bsr SHIFTS2_FLAGS
00:00006078 E508            	  6564:                 lsl.b #2,d0
00:0000607A 6100FF34        	  6565:                 bsr SHIFTS2_FLAGS
00:0000607E E308            	  6566:                 lsl.b #1,d0
00:00006080 6100FF2E        	  6567:                 bsr SHIFTS2_FLAGS
00:00006084 E708            	  6568:                 lsl.b #3,d0
00:00006086 6100FF28        	  6569:                 bsr SHIFTS2_FLAGS
00:0000608A 0C8080018F80    	  6570:                 cmpi.l #$80018F80,d0
00:00006090 66FE            	  6571:                 bne.s *
00:00006092 0C850000001B    	  6572:                 cmpi.l #$0000001B,d5
00:00006098 66FE            	  6573:                 bne.s *
                            	  6574: 
                            	  6575: *        BYTE RIGHT
00:0000609A E208            	  6576:                 lsr.b #1,d0
00:0000609C 6100FF12        	  6577:                 bsr SHIFTS2_FLAGS
00:000060A0 E408            	  6578:                 lsr.b #2,d0
00:000060A2 6100FF0C        	  6579:                 bsr SHIFTS2_FLAGS
00:000060A6 E608            	  6580:                 lsr.b #3,d0
00:000060A8 6100FF06        	  6581:                 bsr SHIFTS2_FLAGS
00:000060AC E208            	  6582:                 lsr.b #1,d0
00:000060AE 6100FF00        	  6583:                 bsr SHIFTS2_FLAGS
00:000060B2 0C8080018F01    	  6584:                 cmpi.l #$80018F01,d0
00:000060B8 66FE            	  6585:                 bne.s *
00:000060BA 0C850000001B    	  6586:                 cmpi.l #$0000001B,d5
00:000060C0 66FE            	  6587:                 bne.s *
                            	  6588: 
                            	  6589: *        WORD LEFT
00:000060C2 E348            	  6590:                 lsl.w #1,d0
00:000060C4 6100FEEA        	  6591:                 bsr SHIFTS2_FLAGS
00:000060C8 E548            	  6592:                 lsl.w #2,d0
00:000060CA 6100FEE4        	  6593:                 bsr SHIFTS2_FLAGS
00:000060CE E748            	  6594:                 lsl.w #3,d0
00:000060D0 6100FEDE        	  6595:                 bsr SHIFTS2_FLAGS
00:000060D4 EB48            	  6596:                 lsl.w #5,d0
00:000060D6 6100FED8        	  6597:                 bsr SHIFTS2_FLAGS
00:000060DA 0C8080010800    	  6598:                 cmpi.l #$80010800,d0
00:000060E0 66FE            	  6599:                 bne.s *
00:000060E2 0C8500000025    	  6600:                 cmpi.l #$00000025,d5
00:000060E8 66FE            	  6601:                 bne.s *
                            	  6602: 
                            	  6603: *        WORD RIGHT
00:000060EA EA48            	  6604:                 lsr.w #5,d0
00:000060EC 6100FEC2        	  6605:                 bsr SHIFTS2_FLAGS
00:000060F0 E248            	  6606:                 lsr.w #1,d0
00:000060F2 6100FEBC        	  6607:                 bsr SHIFTS2_FLAGS
00:000060F6 E448            	  6608:                 lsr.w #2,d0
00:000060F8 6100FEB6        	  6609:                 bsr SHIFTS2_FLAGS
00:000060FC E848            	  6610:                 lsr.w #4,d0
00:000060FE 6100FEB0        	  6611:                 bsr SHIFTS2_FLAGS
00:00006102 0C8080010000    	  6612:                 cmpi.l #$80010000,d0
00:00006108 66FE            	  6613:                 bne.s *
00:0000610A 0C850000002A    	  6614:                 cmpi.l #$0000002A,d5
00:00006110 66FE            	  6615:                 bne.s *
                            	  6616: 
                            	  6617: *        LONG LEFT
00:00006112 203C80018FF1    	  6618:                 move.l #$80018FF1,d0
00:00006118 E388            	  6619:                 lsl.l #1,d0
00:0000611A 6100FE94        	  6620:                 bsr SHIFTS2_FLAGS
00:0000611E E588            	  6621:                 lsl.l #2,d0
00:00006120 6100FE8E        	  6622:                 bsr SHIFTS2_FLAGS
00:00006124 EF88            	  6623:                 lsl.l #7,d0
00:00006126 6100FE88        	  6624:                 bsr SHIFTS2_FLAGS
00:0000612A E988            	  6625:                 lsl.l #4,d0
00:0000612C 6100FE82        	  6626:                 bsr SHIFTS2_FLAGS
00:00006130 0C8063FC4000    	  6627:                 cmpi.l #$63FC4000,d0
00:00006136 66FE            	  6628:                 bne.s *
00:00006138 0C850000002B    	  6629:                 cmpi.l #$0000002B,d5
00:0000613E 66FE            	  6630:                 bne.s *
                            	  6631: 
                            	  6632: *        LONG RIGHT
00:00006140 203C80018FF1    	  6633:                 move.l #$80018FF1,d0
00:00006146 E288            	  6634:                 lsr.l #1,d0
00:00006148 6100FE66        	  6635:                 bsr SHIFTS2_FLAGS
00:0000614C EA88            	  6636:                 lsr.l #5,d0
00:0000614E 6100FE60        	  6637:                 bsr SHIFTS2_FLAGS
00:00006152 EE88            	  6638:                 lsr.l #7,d0
00:00006154 6100FE5A        	  6639:                 bsr SHIFTS2_FLAGS
00:00006158 E088            	  6640:                 lsr.l #8,d0
00:0000615A 6100FE54        	  6641:                 bsr SHIFTS2_FLAGS
00:0000615E 0C8000000400    	  6642:                 cmpi.l #$00000400,d0
00:00006164 66FE            	  6643:                 bne.s *
00:00006166 0C850000002D    	  6644:                 cmpi.l #$0000002D,d5
00:0000616C 66FE            	  6645:                 bne.s *
                            	  6646: 
                            	  6647: 
                            	  6648: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6649: 
00:0000616E 7A00            	  6650:                 moveq  #$00000000,d5
00:00006170 307C0100        	  6651:                 move.l #$00000100,a0
00:00006174 30BC8FF1        	  6652:                 move.w #$8FF1,(a0)
                            	  6653: 
                            	  6654: *        WORD LEFT
00:00006178 E3D0            	  6655:                 lsl  (a0)
00:0000617A 6100FE34        	  6656:                 bsr SHIFTS2_FLAGS
00:0000617E E3D0            	  6657:                 lsl  (a0)
00:00006180 6100FE2E        	  6658:                 bsr SHIFTS2_FLAGS
00:00006184 E3D0            	  6659:                 lsl  (a0)
00:00006186 6100FE28        	  6660:                 bsr SHIFTS2_FLAGS
00:0000618A E3D0            	  6661:                 lsl  (a0)
00:0000618C 6100FE22        	  6662:                 bsr SHIFTS2_FLAGS
00:00006190 3010            	  6663:                 move.w (a0),d0
00:00006192 0C800000FF10    	  6664:                 cmpi.l #$0000FF10,d0
00:00006198 66FE            	  6665:                 bne.s *
00:0000619A 0C8500000009    	  6666:                 cmpi.l #$00000009,d5
00:000061A0 66FE            	  6667:                 bne.s *
                            	  6668: 
                            	  6669: *        WORD RIGHT
00:000061A2 E2D0            	  6670:                 lsr (a0)
00:000061A4 6100FE0A        	  6671:                 bsr SHIFTS2_FLAGS
00:000061A8 E2D0            	  6672:                 lsr (a0)
00:000061AA 6100FE04        	  6673:                 bsr SHIFTS2_FLAGS
00:000061AE E2D0            	  6674:                 lsr (a0)
00:000061B0 6100FDFE        	  6675:                 bsr SHIFTS2_FLAGS
00:000061B4 E2D0            	  6676:                 lsr (a0)
00:000061B6 6100FDF8        	  6677:                 bsr SHIFTS2_FLAGS
00:000061BA E2D0            	  6678:                 lsr (a0)
00:000061BC 6100FDF2        	  6679:                 bsr SHIFTS2_FLAGS
00:000061C0 E2D0            	  6680:                 lsr (a0)
00:000061C2 6100FDEC        	  6681:                 bsr SHIFTS2_FLAGS
00:000061C6 3010            	  6682:                 move.w (a0),d0
00:000061C8 0C80000003FC    	  6683:                 cmpi.l #$000003FC,d0
00:000061CE 66FE            	  6684:                 bne.s *
00:000061D0 0C850000000A    	  6685:                 cmpi.l #$0000000A,d5
00:000061D6 66FE            	  6686:                 bne.s *
                            	  6687: 
00:000061D8 4E75            	  6688:                 rts
                            	  6689: 
                            	  6690: ;-----------------------------------------------------------
                            	  6691: ;-----------------------------------------------------------
                            	  6692: ; OPCODE : BSR / RTS
                            	  6693: ;-----------------------------------------------------------
                            	  6694: ;-----------------------------------------------------------
                            	  6695: 
                            	  6696: ;t3_bsr:
                            	  6697: ;	moveq	#3,d3
                            	  6698: ;	rts
                            	  6699: 
                            	  6700: ;t1_bsr:
                            	  6701: ;	moveq	#1,d1
                            	  6702: ;	rts
                            	  6703: 
                            	  6704: ;op_bsr:
                            	  6705: ;	bsr			t1_bsr
                            	  6706: ;	bsr			t2_bsr
                            	  6707: ;	bsr.w		t3_bsr
                            	  6708: ;	bsr.w		t4_bsr
                            	  6709: ;	cmpi.l	#1,d1
                            	  6710: ;	bne			*
                            	  6711: ;	cmpi.l	#2,d2
                            	  6712: ;	bne			*
                            	  6713: ;	cmpi.l	#3,d3
                            	  6714: ;	bne			*
                            	  6715: ;	cmpi.l	#4,d4
                            	  6716: ;	bne			*
                            	  6717: ;	rts
                            	  6718: 
                            	  6719: ;t2_bsr:
                            	  6720: ;	moveq	#2,d2
                            	  6721: ;	rts
                            	  6722: 	
                            	  6723: ;t4_bsr:
                            	  6724: ;	moveq	#4,d4
                            	  6725: ;	rts
                            	  6726: *    END
                            	  6727:     
                            	  6728: 

Source: "boot.x68"
                            	   989: 	include "TinyBasicFlt.x68"

Source: "TinyBasicFlt.x68"
                            	     1: ;*****************************************************************
                            	     2: ;								 *
                            	     3: ;		Tiny Float BASIC for the Motorola MC68000		 *
                            	     4: ;								 *
                            	     5: ; Derived from Palo Alto Tiny BASIC as published in the May 1976 *
                            	     6: ; issue of Dr. Dobb's Journal.  Adapted to the 68000 by:         *
                            	     7: ;	Gordon Brandly						 *
                            	     8: ;								 *
                            	     9: ;*****************************************************************
                            	    10: ;    Copyright (C) 1984 by Gordon Brandly. This program may be	 *
                            	    11: ;    freely distributed for personal use only. All commercial	 *
                            	    12: ;		       rights are reserved.			 *
                            	    13: ;*****************************************************************
                            	    14: ; Modified (c) 2022 for the rf68000. Robert Finch
                            	    15: ; Numerics changed to floating-point
                            	    16: ; added string handling
                            	    17: ; added graphics commands
                            	    18: ;*****************************************************************
                            	    19: 
                            	    20: ; Vers. 1.0  1984/7/17	- Original version by Gordon Brandly
                            	    21: ;	1.1  1984/12/9	- Addition of '$' print term by Marvin Lipford
                            	    22: ;	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                            	    23: ; 
                            	    24: ;	OPT	FRS,BRS 	forward ref.'s & branches default to short
                            	    25: 
                            	    26: ;CR	EQU	$0D		ASCII equates
                            	    27: ;LF	EQU	$0A
                            	    28: ;TAB	EQU	$09
                            	    29: ;CTRLC	EQU	$03
                            	    30: ;CTRLH	EQU	$08
                            	    31: ;CTRLS	EQU	$13
                            	    32: ;CTRLX	EQU	$18
                            	    33: 
                            	    34: DT_NONE equ 0
                            	    35: DT_NUMERIC equ 1
                            	    36: DT_STRING equ 2		; string descriptor
                            	    37: DT_TEXTPTR equ 3	; pointer into program text
                            	    38: DT_INTEGER equ 4
                            	    39: 
                            	    40: BUFLEN	EQU	80		length of keyboard input buffer
                            	    41: STRAREASIZE	EQU	2048	; size of string area
                            	    42: 	CODE
                            	    43: *	ORG	$10000		first free address using Tutor
                            	    44: *
                            	    45: * Standard jump table. You can change these addresses if you are
                            	    46: * customizing this interpreter for a different environment.
                            	    47: *
00:000061DA 6020            	    48: START	BRA	CSTART		Cold Start entry point
00:000061DC 6000008A        	    49: GOWARM	BRA	WSTART		Warm Start entry point
00:000061E0 60001724        	    50: GOOUT	BRA OUTC		Jump to character-out routine
00:000061E4 60001730        	    51: GOIN	BRA INC		Jump to character-in routine
00:000061E8 6000174C        	    52: GOAUXO	BRA	AUXOUT		Jump to auxiliary-out routine
00:000061EC 6000175C        	    53: GOAUXI	BRA	AUXIN		Jump to auxiliary-in routine
00:000061F0 60001778        	    54: GOBYE	BRA	BYEBYE		Jump to monitor, DOS, etc.
                            	    55: *
                            	    56: * Modifiable system constants:
                            	    57: *
00:000061F4 00041000        	    58: TXTBGN	DC.L	$41000		beginning of program memory
00:000061F8 00047FF0        	    59: ENDMEM	DC.L	$47FF0		end of available memory
                            	    60: *
                            	    61: * The main interpreter starts here:
                            	    62: *
                            	    63: CSTART
00:000061FC 2E7AFFFA        	    64: 	MOVE.L ENDMEM,SP	initialize stack pointer
00:00006200 23FC000079220000	    65: 	move.l #INC1,INPPTR
00:00006208 79DC
00:0000620A 13FC0001000400A4	    66: 	move.b #1,InputDevice			; keyboard
00:00006212 13FC0002000400A8	    67: 	move.b #2,OutputDevice		; text video
00:0000621A 23FC000000010004	    68: 	move.l #1,_fpTextIncr
00:00006222 0094
00:00006224 4DFA1752        	    69: 	LEA	INITMSG,A6	tell who we are
00:00006228 610016C4        	    70: 	BSR	PRMESG
00:0000622C 23FAFFC600007A2C	    71: 	MOVE.L TXTBGN,TXTUNF	init. end-of-program pointer
00:00006234 203AFFC2        	    72: 	MOVE.L ENDMEM,D0	get address of end of memory
00:00006238 23FAFFBE000079E8	    73: 	move.l ENDMEM,STKFP
00:00006240 90BC00001000    	    74: 	SUB.L	#4096,D0	reserve 4K for the stack
00:00006246 23C000007A1C    	    75: 	MOVE.L D0,STRSTK
00:0000624C D0BC00000020    	    76: 	ADD.L #32,D0
00:00006252 23C000007A34    	    77: 	MOVE.L D0,STKLMT
00:00006258 90BC00000200    	    78: 	SUB.L	#512,D0 	reserve variable area (32 16 byte floats)
00:0000625E 23C000007A30    	    79: 	MOVE.L D0,VARBGN
00:00006264 610000C2        	    80: 	bsr ClearStringArea
                            	    81: WSTART:
00:00006268 7000            	    82: 	CLR.L	D0		initialize internal variables
00:0000626A 23FC000000010004	    83: 	move.l #1,_fpTextIncr
00:00006272 0094
00:00006274 42B900007A18    	    84: 	clr.l IRQROUT
00:0000627A 23C0000079F4    	    85: 	MOVE.L	D0,LOPVAR
00:00006280 23C0000079EC    	    86: 	MOVE.L	D0,STKGOS
00:00006286 23C0000079E4    	    87: 	MOVE.L	D0,CURRNT	; current line number pointer = 0
00:0000628C 2E7AFF6A        	    88: 	MOVE.L ENDMEM,SP	; init S.P. again, just in case
00:00006290 610000B6        	    89: 	bsr ClearStringStack
00:00006294 4DFA1706        	    90: 	LEA	OKMSG,A6			; display "OK"
00:00006298 61001654        	    91: 	bsr	PRMESG
                            	    92: ST3
00:0000629C 103C003E        	    93: 	MOVE.B	#'>',D0         Prompt with a '>' and
00:000062A0 61001390        	    94: 	bsr	GETLN		read a line.
00:000062A4 610015EC        	    95: 	bsr	TOUPBUF 	convert to upper case
00:000062A8 2848            	    96: 	MOVE.L	A0,A4		save pointer to end of line
00:000062AA 41FA1790        	    97: 	LEA	BUFFER,A0	point to the beginning of line
00:000062AE 6100158C        	    98: 	bsr	TSTNUM		is there a number there?
00:000062B2 610015D4        	    99: 	bsr	IGNBLK		skip trailing blanks
00:000062B6 F2016080        	   100: 	FMOVE.L FP1,D1
00:000062BA 4A82            	   101: 	TST.L D2			; does line no. exist? (or nonzero?)
00:000062BC 670002AE        	   102: 	BEQ	DIRECT		; if not, it's a direct statement
00:000062C0 B2BC0000FFFF    	   103: 	CMP.L	#$FFFF,D1	; see if line no. is <= 16 bits
00:000062C6 6400135C        	   104: 	BCC	QHOW			; if not, we've overflowed
00:000062CA 1101            	   105: 	MOVE.B	D1,-(A0)	store the binary line no.
00:000062CC E059            	   106: 	ROR	#8,D1		(Kludge to store a word on a
00:000062CE 1101            	   107: 	MOVE.B	D1,-(A0)	possible byte boundary)
00:000062D0 E159            	   108: 	ROL	#8,D1
00:000062D2 610013FC        	   109: 	bsr	FNDLN		find this line in save area
00:000062D6 2A49            	   110: 	MOVE.L	A1,A5		save possible line pointer
00:000062D8 6614            	   111: 	BNE	ST4		if not found, insert
00:000062DA 6100141A        	   112: 	bsr	FNDNXT		find the next line (into A1)
00:000062DE 244D            	   113: 	MOVE.L	A5,A2		pointer to line to be deleted
00:000062E0 267A174A        	   114: 	MOVE.L	TXTUNF,A3	points to top of save area
00:000062E4 61001420        	   115: 	bsr	MVUP		move up to delete
00:000062E8 23CA00007A2C    	   116: 	MOVE.L	A2,TXTUNF	update the end pointer
                            	   117: ST4
00:000062EE 200C            	   118: 	MOVE.L	A4,D0		calculate the length of new line
00:000062F0 9088            	   119: 	SUB.L	A0,D0
00:000062F2 B0BC00000003    	   120: 	CMP.L	#3,D0		is it just a line no. & CR?
00:000062F8 6FA2            	   121: 	BLE	ST3		if so, it was just a delete
00:000062FA 267A1730        	   122: 	MOVE.L TXTUNF,A3	compute new end
00:000062FE 2C4B            	   123: 	MOVE.L A3,A6
00:00006300 D7C0            	   124: 	ADD.L	D0,A3
00:00006302 203A1720        	   125: 	MOVE.L StrArea,D0	see if there's enough room
00:00006306 B08B            	   126: 	CMP.L	A3,D0
00:00006308 63001312        	   127: 	BLS	QSORRY		if not, say so
00:0000630C 23CB00007A2C    	   128: 	MOVE.L	A3,TXTUNF	if so, store new end position
00:00006312 224E            	   129: 	MOVE.L	A6,A1		points to old unfilled area
00:00006314 244D            	   130: 	MOVE.L	A5,A2		points to beginning of move area
00:00006316 61001402        	   131: 	bsr	MVDOWN		move things out of the way
00:0000631A 2248            	   132: 	MOVE.L	A0,A1		set up to do the insertion
00:0000631C 244D            	   133: 	MOVE.L	A5,A2
00:0000631E 264C            	   134: 	MOVE.L	A4,A3
00:00006320 610013E4        	   135: 	bsr	MVUP		do it
00:00006324 6000FF76        	   136: 	BRA	ST3		go back and get another line
                            	   137: 
                            	   138: ClearStringArea:
00:00006328 203A1706        	   139: 	move.l VARBGN,d0
00:0000632C 90BC00000800    	   140: 	SUB.L #STRAREASIZE,D0
00:00006332 23C000007A24    	   141: 	MOVE.L D0,StrArea
00:00006338 23C000007A28    	   142: 	MOVE.L D0,LastStr
00:0000633E 207A16E4        	   143: 	move.l StrArea,a0
00:00006342 4298            	   144: 	clr.l (a0)+
00:00006344 4298            	   145: 	clr.l (a0)+
00:00006346 4E75            	   146: 	rts
                            	   147: 
                            	   148: ClearStringStack:
00:00006348 7007            	   149: 	moveq #7,d0
00:0000634A 227A16D0        	   150: 	move.l STRSTK,a1
                            	   151: .0001
00:0000634E 4299            	   152: 	clr.l (a1)+				; clear the string stack
00:00006350 51C8FFFC        	   153: 	dbra d0,.0001
00:00006354 23C900007A20    	   154: 	move.l a1,StrSp		; set string stack stack pointer
00:0000635A 4E75            	   155: 	rts
                            	   156: 
                            	   157: 	even
                            	   158: 
                            	   159: ;******************************************************************
                            	   160: ;
                            	   161: ; *** Tables *** DIRECT *** EXEC ***
                            	   162: ;
                            	   163: ; This section of the code tests a string against a table. When
                            	   164: ; a match is found, control is transferred to the section of
                            	   165: ; code according to the table.
                            	   166: ;
                            	   167: ; At 'EXEC', A0 should point to the string, A1 should point to
                            	   168: ; the character table, and A2 should point to the execution
                            	   169: ; table. At 'DIRECT', A0 should point to the string, A1 and
                            	   170: ; A2 will be set up to point to TAB1 and TAB1_1, which are
                            	   171: ; the tables of all direct and statement commands.
                            	   172: ;
                            	   173: ; A '.' in the string will terminate the test and the partial
                            	   174: ; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                            	   175: ; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                            	   176: ;
                            	   177: ; There are two tables: the character table and the execution
                            	   178: ; table. The character table consists of any number of text items.
                            	   179: ; Each item is a string of characters with the last character's
                            	   180: ; high bit set to one. The execution table holds a 16-bit
                            	   181: ; execution addresses that correspond to each entry in the
                            	   182: ; character table.
                            	   183: ;
                            	   184: ; The end of the character table is a 0 byte which corresponds
                            	   185: ; to the default routine in the execution table, which is
                            	   186: ; executed if none of the other table items are matched.
                            	   187: ;
                            	   188: ; Character-matching tables:
                            	   189: 
                            	   190: TAB1
00:0000635C 3C434F          	   191: 	DC.B	'<CO',('M'+$80)
00:0000635F CD
00:00006360 3C434F          	   192: 	DC.B	'<CO',('N'+$80)
00:00006363 CE
00:00006364 3E434F          	   193: 	DC.B	'>CO',('M'+$80)
00:00006367 CD
00:00006368 3E434F          	   194: 	DC.B	'>CO',('N'+$80)
00:0000636B CE
00:0000636C 3C3E434F        	   195: 	DC.B	'<>CO',('M'+$80)
00:00006370 CD
00:00006371 3C3E434F        	   196: 	DC.B	'<>CO',('N'+$80)
00:00006375 CE
00:00006376 4C4953          	   197: 	DC.B	'LIS',('T'+$80)         Direct commands
00:00006379 D4
00:0000637A 4C4F41          	   198: 	DC.B	'LOA',('D'+$80)
00:0000637D C4
00:0000637E 4E45            	   199: 	DC.B	'NE',('W'+$80)
00:00006380 D7
00:00006381 5255            	   200: 	DC.B	'RU',('N'+$80)
00:00006383 CE
00:00006384 534156          	   201: 	DC.B	'SAV',('E'+$80)
00:00006387 C5
00:00006388 434C            	   202: 	DC.B 	'CL',('S'+$80)
00:0000638A D3
                            	   203: TAB2
00:0000638B 4E4558          	   204: 	DC.B	'NEX',('T'+$80)         Direct / statement
00:0000638E D4
00:0000638F 4C45            	   205: 	DC.B	'LE',('T'+$80)
00:00006391 D4
00:00006392 49              	   206: 	DC.B	'I',('F'+$80)
00:00006393 C6
00:00006394 474F54          	   207: 	DC.B	'GOT',('O'+$80)
00:00006397 CF
00:00006398 474F5355        	   208: 	DC.B	'GOSU',('B'+$80)
00:0000639C C2
00:0000639D 5245545552      	   209: 	DC.B	'RETUR',('N'+$80)
00:000063A2 CE
00:000063A3 5245            	   210: 	DC.B	'RE',('M'+$80)
00:000063A5 CD
00:000063A6 464F            	   211: 	DC.B	'FO',('R'+$80)
00:000063A8 D2
00:000063A9 494E5055        	   212: 	DC.B	'INPU',('T'+$80)
00:000063AD D4
00:000063AE 5052494E        	   213: 	DC.B	'PRIN',('T'+$80)
00:000063B2 D4
00:000063B3 504F4B          	   214: 	DC.B	'POK',('E'+$80)
00:000063B6 C5
00:000063B7 53544F          	   215: 	DC.B	'STO',('P'+$80)
00:000063BA D0
00:000063BB 4259            	   216: 	DC.B	'BY',('E'+$80)
00:000063BD C5
00:000063BE 43414C          	   217: 	DC.B	'CAL',('L'+$80)
00:000063C1 CC
00:000063C2 4F4E4952        	   218: 	DC.B	'ONIR',('Q'+$80)
00:000063C6 D1
                            	   219: ; graphics commands	
00:000063C7 504F494E        	   220: 	DC.B	'POIN',('T'+$80)
00:000063CB D4
00:000063CC 4C494E          	   221: 	DC.B	'LIN',('E'+$80)
00:000063CF C5
00:000063D0 524543          	   222: 	DC.B	'REC',('T'+$80)
00:000063D3 D4
00:000063D4 5452            	   223: 	DC.B	'TR',('I'+$80)
00:000063D6 C9
00:000063D7 43555256        	   224: 	DC.B	'CURV',('E'+$80)
00:000063DB C5
00:000063DC 434F4C4F        	   225: 	DC.B	'COLO',('R'+$80)
00:000063E0 D2
00:000063E1 445241574255    	   226: 	DC.B	'DRAWBU',('F'+$80)
00:000063E7 C6
00:000063E8 444953504255    	   227: 	DC.B	'DISPBU',('F'+$80)
00:000063EE C6
00:000063EF 544558          	   228: 	DC.B	'TEX',('T'+$80)
00:000063F2 D4
00:000063F3 434C4541        	   229: 	dc.b	'CLEA',('R'+$80)
00:000063F7 D2
00:000063F8 00              	   230: 	DC.B	0
                            	   231: TAB4
00:000063F9 504545          	   232: 	DC.B	'PEE',('K'+$80)         Functions
00:000063FC CB
00:000063FD 524E            	   233: 	DC.B	'RN',('D'+$80)
00:000063FF C4
00:00006400 4142            	   234: 	DC.B	'AB',('S'+$80)
00:00006402 D3
00:00006403 53495A          	   235: 	DC.B	'SIZ',('E'+$80)
00:00006406 C5
00:00006407 544943          	   236: 	DC.B	'TIC',('K'+$80)
00:0000640A CB
00:0000640B 434F52454E      	   237: 	DC.B	'COREN',('O'+$80)
00:00006410 CF
00:00006411 4C454654        	   238: 	DC.B	'LEFT',('$'+$80)
00:00006415 A4
00:00006416 5249474854      	   239: 	DC.B	'RIGHT',('$'+$80)
00:0000641B A4
00:0000641C 4D4944          	   240: 	DC.B	'MID',('$'+$80)
00:0000641F A4
00:00006420 4C45            	   241: 	DC.B	'LE',('N'+$80)
00:00006422 CE
00:00006423 494E            	   242: 	DC.B	'IN',('T'+$80)
00:00006425 D4
00:00006426 434852          	   243: 	DC.B	'CHR',('$'+$80)
00:00006429 A4
00:0000642A 00              	   244: 	DC.B	0
                            	   245: TAB5
00:0000642B 54              	   246: 	DC.B	'T',('O'+$80)           "TO" in "FOR"
00:0000642C CF
00:0000642D 00              	   247: 	DC.B	0
                            	   248: TAB6
00:0000642E 535445          	   249: 	DC.B	'STE',('P'+$80)         "STEP" in "FOR"
00:00006431 D0
00:00006432 00              	   250: 	DC.B	0
                            	   251: TAB8
00:00006433 3E              	   252: 	DC.B	'>',('='+$80)           Relational operators
00:00006434 BD
00:00006435 3C              	   253: 	DC.B	'<',('>'+$80)
00:00006436 BE
00:00006437 BE              	   254: 	DC.B	('>'+$80)
00:00006438 BD              	   255: 	DC.B	('='+$80)
00:00006439 3C              	   256: 	DC.B	'<',('='+$80)
00:0000643A BD
00:0000643B BC              	   257: 	DC.B	('<'+$80)
00:0000643C 00              	   258: 	DC.B	0
00:0000643D 00              	   259: 	DC.B	0	<- for aligning on a word boundary
                            	   260: TAB9
00:0000643E 414E            	   261: 	DC.B	'AN',('D'+$80)
00:00006440 C4
00:00006441 00              	   262: 	DC.B	0
                            	   263: TAB10
00:00006442 4F              	   264: 	DC.B	'O',('R'+$80)
00:00006443 D2
00:00006444 00              	   265: 	DC.B	0
                            	   266: TAB11
00:00006445 4D4F            	   267: 	DC.B	'MO',('D'+$80)
00:00006447 C4
00:00006448 00              	   268: 	DC.B	0
00:00006449 00              	   269: 	DC.B	0
                            	   270: TAB12
00:0000644A 44455054        	   271: 	DC.B	'DEPT',('H'+$80)
00:0000644E C8
00:0000644F 00              	   272: 	DC.B	0
00:00006450 00              	   273: 	DC.B	0
                            	   274: 
                            	   275: ; Execution address tables:
                            	   276: 	align 2
                            	   277: TAB1_1	
00:00006454 000065C4        	   278: 	DC.L	INCOM
00:00006458 000065B6        	   279: 	DC.L	INCON
00:0000645C 000065DC        	   280: 	DC.L	OUTCOM
00:00006460 000065F2        	   281: 	DC.L	OUTCON
00:00006464 000065D2        	   282: 	DC.L	IOCOM
00:00006468 000065E8        	   283: 	DC.L	IOCON
00:0000646C 000066DC        	   284: 	DC.L	LIST			Direct commands
00:00006470 000069BA        	   285: 	DC.L	LOAD
00:00006474 000065FE        	   286: 	DC.L	NEW
00:00006478 0000661A        	   287: 	DC.L	RUN
00:0000647C 00006A1A        	   288: 	DC.L	SAVE
00:00006480 000078FA        	   289: 	DC.L	CLS
                            	   290: TAB2_1
00:00006484 00006878        	   291: 	DC.L	NEXT			Direct / statement
00:00006488 000069AA        	   292: 	DC.L	LET
00:0000648C 000068E4        	   293: 	DC.L	IF
00:00006490 00006694        	   294: 	DC.L	GOTO
00:00006494 00006792        	   295: 	DC.L	GOSUB
00:00006498 000067CC        	   296: 	DC.L	RETURN
00:0000649C 000068E2        	   297: 	DC.L	REM
00:000064A0 000067F8        	   298: 	DC.L	FOR
00:000064A4 0000690C        	   299: 	DC.L	INPUT
00:000064A8 00006708        	   300: 	DC.L	PRINT
00:000064AC 00006A98        	   301: 	DC.L	POKE
00:000064B0 00006612        	   302: 	DC.L	STOP
00:000064B4 000061F0        	   303: 	DC.L	GOBYE
00:000064B8 00006B12        	   304: 	DC.L	CALL
00:000064BC 000066A8        	   305: 	DC.L	ONIRQ
00:000064C0 00006BFE        	   306: 	DC.L	POINT
00:000064C4 00006C24        	   307: 	DC.L	LINE
00:000064C8 00006C76        	   308: 	DC.L	RECT
00:000064CC 00006CBC        	   309: 	DC.L	TRIANGLE
00:000064D0 00006D3C        	   310: 	DC.L	CURVE
00:000064D4 00006B8A        	   311: 	DC.L	COLOR
00:000064D8 00006B6A        	   312: 	DC.L	DRAWBUF
00:000064DC 00006B7A        	   313: 	DC.L	DISPBUF
00:000064E0 00006B36        	   314: 	DC.L	TEXT
00:000064E4 00006B28        	   315: 	dc.l	CLEAR
00:000064E8 000069A2        	   316: 	DC.L	DEFLT
                            	   317: TAB4_1
00:000064EC 0000731C        	   318: 	DC.L	PEEK			; Functions
00:000064F0 00007384        	   319: 	DC.L	RND
00:000064F4 000073AE        	   320: 	DC.L	ABS
00:000064F8 000073BA        	   321: 	DC.L	SIZE
00:000064FC 000073CA        	   322: 	DC.L	TICK
00:00006500 000073D6        	   323: 	DC.L	CORENO
00:00006504 000074E8        	   324: 	DC.L	LEFT
00:00006508 000074F4        	   325: 	DC.L	RIGHT
00:0000650C 0000741E        	   326: 	DC.L	MID
00:00006510 0000751C        	   327: 	DC.L	LEN
00:00006514 00007542        	   328: 	DC.L	INT
00:00006518 00007558        	   329: 	DC.L  CHR
00:0000651C 00007026        	   330: 	DC.L	XP40
                            	   331: TAB5_1
00:00006520 00006812        	   332: 	DC.L	FR1			; "TO" in "FOR"
00:00006524 000075DC        	   333: 	DC.L	QWHAT
                            	   334: TAB6_1
00:00006528 0000682A        	   335: 	DC.L	FR2			; "STEP" in "FOR"
00:0000652C 00006830        	   336: 	DC.L	FR3
                            	   337: TAB8_1
00:00006530 00006E5C        	   338: 	DC.L	XP11	>=		Relational operators
00:00006534 00006E68        	   339: 	DC.L	XP12	<>
00:00006538 00006E74        	   340: 	DC.L	XP13	>
00:0000653C 00006E8C        	   341: 	DC.L	XP15	=
00:00006540 00006E80        	   342: 	DC.L	XP14	<=
00:00006544 00006E9A        	   343: 	DC.L	XP16	<
00:00006548 00006EB8        	   344: 	DC.L	XP17
                            	   345: TAB9_1
00:0000654C 00006E1A        	   346: 	DC.L	XP_AND
00:00006550 00006E30        	   347: 	DC.L	XP_ANDX
                            	   348: TAB10_1
00:00006554 00006DF4        	   349: 	DC.L	XP_OR
00:00006558 00006E30        	   350: 	DC.L	XP_ORX
                            	   351: TAB11_1
00:0000655C 00006FF8        	   352: 	DC.L	XP_MOD
00:00006560 00006FC2        	   353: 	DC.L	XP31
                            	   354: 	even
                            	   355: TAB12_1
00:00006564 00006B96        	   356: 	DC.L	COLOR1
00:00006568 00006BEA        	   357: 	DC.L	COLOR2
                            	   358: 	
                            	   359: DIRECT
00:0000656C 33FC000100007A38	   360: 	move.w #1,DIRFLG
00:00006574 43FAFDE6        	   361: 	LEA	TAB1,A1
00:00006578 45FAFEDA        	   362: 	LEA	TAB1_1,A2
                            	   363: EXEC
00:0000657C 6100130A        	   364: 	bsr	IGNBLK				; ignore leading blanks
00:00006580 2648            	   365: 	MOVE.L A0,A3			; save the pointer
00:00006582 4202            	   366: 	CLR.B	D2					; clear match flag
                            	   367: EXLP
00:00006584 1018            	   368: 	MOVE.B (A0)+,D0	 	; get the program character
00:00006586 1211            	   369: 	MOVE.B (A1),D1 		; get the table character
00:00006588 6604            	   370: 	BNE	EXNGO					; If end of table,
00:0000658A 204B            	   371: 	MOVE.L A3,A0			; restore the text pointer and...
00:0000658C 6024            	   372: 	BRA	EXGO					; execute the default.
                            	   373: EXNGO
00:0000658E 1600            	   374: 	MOVE.B D0,D3		 	; Else check for period...
00:00006590 C602            	   375: 	AND.B	D2,D3				; and a match.
00:00006592 B63C002E        	   376: 	CMP.B	#'.',D3
00:00006596 671A            	   377: 	BEQ	EXGO					; if so, execute
00:00006598 C23C007F        	   378: 	AND.B	#$7F,D1 		; ignore the table's high bit
00:0000659C B200            	   379: 	CMP.B	D0,D1				; is there a match?
00:0000659E 670C            	   380: 	BEQ	EXMAT
00:000065A0 588A            	   381: 	ADDQ.L #4,A2			; if not, try the next entry
00:000065A2 204B            	   382: 	MOVE.L A3,A0			; reset the program pointer
00:000065A4 4202            	   383: 	CLR.B	D2					; sorry, no match
                            	   384: EX1
00:000065A6 4A19            	   385: 	TST.B	(A1)+				; get to the end of the entry
00:000065A8 6AFC            	   386: 	BPL	EX1
00:000065AA 60D8            	   387: 	BRA	EXLP					; back for more matching
                            	   388: EXMAT
00:000065AC 74FF            	   389: 	MOVEQ	#-1,D2			; we've got a match so far
00:000065AE 4A19            	   390: 	TST.B	(A1)+				; end of table entry?
00:000065B0 6AD2            	   391: 	BPL	EXLP					; if not, go back for more
                            	   392: EXGO
00:000065B2 2652            	   393: 	MOVE.L (A2),A3		; execute the appropriate routine
00:000065B4 4ED3            	   394: 	JMP	(A3)
                            	   395: 
                            	   396: *******************************************************************
                            	   397: * Console redirection
                            	   398: * <COM will redirect input to the COM port
                            	   399: * >COM will redirect output to the COM port
                            	   400: * <CON will redirect input to the console
                            	   401: * >CON will redirect output to the console
                            	   402: * <>COM will redirect input and output to the COM port
                            	   403: * <>CON will redirect input and output to the console
                            	   404: *******************************************************************
                            	   405: INCON
00:000065B6 23FC000079220000	   406: 	move.l	#INC1,INPPTR
00:000065BE 79DC
00:000065C0 600001C8        	   407: 	bra			FINISH
                            	   408: INCOM
00:000065C4 23FC0000794A0000	   409: 	move.l	#AUXIN,INPPTR
00:000065CC 79DC
00:000065CE 600001BA        	   410: 	bra			FINISH
                            	   411: IOCOM
00:000065D2 23FC0000794A0000	   412: 	move.l	#AUXIN,INPPTR
00:000065DA 79DC
                            	   413: OUTCOM
00:000065DC 13FC0002000400A8	   414: 	move.b #2,OutputDevice
00:000065E4 600001A4        	   415: 	bra	FINISH
                            	   416: IOCON
00:000065E8 23FC000079220000	   417: 	move.l	#INC1,INPPTR
00:000065F0 79DC
                            	   418: OUTCON
00:000065F2 13FC0001000400A8	   419: 	move.b #1,OutputDevice
00:000065FA 6000018E        	   420: 	bra	FINISH
                            	   421: 
                            	   422: *******************************************************************
                            	   423: *
                            	   424: * What follows is the code to execute direct and statement
                            	   425: * commands. Control is transferred to these points via the command
                            	   426: * table lookup code of 'DIRECT' and 'EXEC' in the last section.
                            	   427: * After the command is executed, control is transferred to other
                            	   428: * sections as follows:
                            	   429: *
                            	   430: * For 'LIST', 'NEW', and 'STOP': go back to the warm start point.
                            	   431: * For 'RUN': go execute the first stored line if any; else go
                            	   432: * back to the warm start point.
                            	   433: * For 'GOTO' and 'GOSUB': go execute the target line.
                            	   434: * For 'RETURN' and 'NEXT'; go back to saved return line.
                            	   435: * For all others: if 'CURRNT' is 0, go to warm start; else go
                            	   436: * execute next command. (This is done in 'FINISH'.)
                            	   437: *
                            	   438: *******************************************************************
                            	   439: *
                            	   440: * *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                            	   441: *
                            	   442: * 'NEW<CR>' sets TXTUNF to point to TXTBGN
                            	   443: *
                            	   444: * 'STOP<CR>' goes back to WSTART
                            	   445: *
                            	   446: * 'RUN<CR>' finds the first stored line, stores its address
                            	   447: * in CURRNT, and starts executing it. Note that only those
                            	   448: * commands in TAB2 are legal for a stored program.
                            	   449: *
                            	   450: * There are 3 more entries in 'RUN':
                            	   451: * 'RUNNXL' finds next line, stores it's address and executes it.
                            	   452: * 'RUNTSL' stores the address of this line and executes it.
                            	   453: * 'RUNSML' continues the execution on same line.
                            	   454: *
                            	   455: * 'GOTO expr<CR>' evaluates the expression, finds the target
                            	   456: * line, and jumps to 'RUNTSL' to do it.
                            	   457: *
                            	   458: NEW:
00:000065FE 61000FCA        	   459: 	bsr	ENDCHK
00:00006602 23FAFBF000007A2C	   460: 	MOVE.L TXTBGN,TXTUNF	set the end pointer
00:0000660A 6100FD1C        	   461: 	bsr ClearStringArea
00:0000660E 6100FD38        	   462: 	bsr ClearStringStack
                            	   463: 
                            	   464: STOP:
00:00006612 61000FB6        	   465: 	bsr	ENDCHK
00:00006616 6000FC50        	   466: 	BRA	WSTART
                            	   467: 
                            	   468: RUN:
00:0000661A 427900007A38    	   469: 	clr.w DIRFLG
00:00006620 61000FA8        	   470: 	bsr	ENDCHK
00:00006624 207AFBCE        	   471: 	MOVE.L	TXTBGN,A0	set pointer to beginning
00:00006628 23C8000079E4    	   472: 	MOVE.L	A0,CURRNT
                            	   473: 
                            	   474: RUNNXL:
00:0000662E 4AB9000079E4    	   475: 	TST.L	CURRNT		; executing a program?
00:00006634 6700FC32        	   476: 	beq	WSTART			; if not, we've finished a direct stat.
00:00006638 4AB900007A18    	   477: 	tst.l	IRQROUT		; are we handling IRQ's ?
00:0000663E 672E            	   478: 	beq	RUN1
00:00006640 4A39000400A0    	   479: 	tst.b IRQFlag		; was there an IRQ ?
00:00006646 6726            	   480: 	beq	RUN1
00:00006648 4239000400A0    	   481: 	clr.b IRQFlag
                            	   482: 
                            	   483: 	; same code as GOSUB	
                            	   484: ;	sub.l #128,sp		; allocate storage for local variables
                            	   485: ;	move.l STKFP,-(sp)
                            	   486: ;	move.l sp,STKFP
00:0000664E 6100110E        	   487: 	bsr	PUSHA				; save the current 'FOR' parameters
00:00006652 2F08            	   488: 	MOVE.L A0,-(SP)	; save text pointer
00:00006654 2F3A138E        	   489: 	MOVE.L CURRNT,-(SP)	found it, save old 'CURRNT'...
00:00006658 2F3A1392        	   490: 	MOVE.L STKGOS,-(SP)	and 'STKGOS'
00:0000665C 42B9000079F4    	   491: 	CLR.L	LOPVAR		; load new values
00:00006662 23CF000079EC    	   492: 	MOVE.L SP,STKGOS
                            	   493: 
00:00006668 227A13AE        	   494: 	move.l IRQROUT,a1
00:0000666C 600C            	   495: 	bra	RUNTSL
                            	   496: RUN1
00:0000666E 7200            	   497: 	CLR.L	D1			; else find the next line number
00:00006670 2248            	   498: 	MOVE.L A0,A1
00:00006672 6100106A        	   499: 	bsr	FNDLNP
00:00006676 6500FBF0        	   500: 	BCS	WSTART		; if we've fallen off the end, stop
                            	   501: 
                            	   502: RUNTSL
00:0000667A 23C9000079E4    	   503: 	MOVE.L	A1,CURRNT	set CURRNT to point to the line no.
00:00006680 2049            	   504: 	MOVE.L	A1,A0		set the text pointer to
00:00006682 5488            	   505: 	ADDQ.L	#2,A0		the start of the line text
                            	   506: 
                            	   507: RUNSML
00:00006684 61001256        	   508: 	bsr	CHKIO		see if a control-C was pressed
00:00006688 43FAFD01        	   509: 	LEA	TAB2,A1 	find command in TAB2
00:0000668C 45FAFDF6        	   510: 	LEA	TAB2_1,A2
00:00006690 6000FEEA        	   511: 	BRA	EXEC		and execute it
                            	   512: 
                            	   513: GOTO:	
00:00006694 6100073C        	   514: 	bsr	INT_EXPR	; evaluate the following expression
00:00006698 61000F30        	   515: 	bsr	ENDCHK		; must find end of line
00:0000669C 2200            	   516: 	move.l d0,d1
00:0000669E 61001030        	   517: 	bsr	FNDLN			; find the target line
00:000066A2 66000F80        	   518: 	bne	QHOW			; no such line no.
00:000066A6 60D2            	   519: 	bra	RUNTSL		; go do it
                            	   520: 
                            	   521: ;******************************************************************
                            	   522: ; ONIRQ <line number>
                            	   523: ; ONIRQ sets up an interrupt handler which acts like a specialized
                            	   524: ; subroutine call. ONIRQ is coded like a GOTO that never executes.
                            	   525: ;******************************************************************
                            	   526: 
                            	   527: ONIRQ:
00:000066A8 61000728        	   528: 	bsr	INT_EXPR		; evaluate the following expression
00:000066AC 61000F1C        	   529: 	bsr ENDCHK			; must find end of line
00:000066B0 2200            	   530: 	move.l d0,d1
00:000066B2 6100101C        	   531: 	bsr FNDLN				; find the target line
00:000066B6 660A            	   532: 	bne	ONIRQ1
00:000066B8 42B900007A18    	   533: 	clr.l IRQROUT
00:000066BE 600000CA        	   534: 	bra	FINISH
                            	   535: ONIRQ1:
00:000066C2 23C900007A18    	   536: 	move.l a1,IRQROUT
00:000066C8 600000C0        	   537: 	jmp	FINISH
                            	   538: 
                            	   539: 
                            	   540: WAITIRQ:
00:000066CC 6100120E        	   541: 	jsr	CHKIO				; see if a control-C was pressed
00:000066D0 4A39000400A0    	   542: 	tst.b IRQFlag
00:000066D6 67F4            	   543: 	beq	WAITIRQ
00:000066D8 600000B0        	   544: 	jmp	FINISH
                            	   545: 
                            	   546: *******************************************************************
                            	   547: *
                            	   548: * *** LIST *** PRINT ***
                            	   549: *
                            	   550: * LIST has two forms:
                            	   551: * 'LIST<CR>' lists all saved lines
                            	   552: * 'LIST #<CR>' starts listing at the line #
                            	   553: * Control-S pauses the listing, control-C stops it.
                            	   554: *
                            	   555: * PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                            	   556: * where '....' is a list of expressions, formats, back-arrows,
                            	   557: * and strings.	These items a separated by commas.
                            	   558: *
                            	   559: * A format is a pound sign followed by a number.  It controls
                            	   560: * the number of spaces the value of an expression is going to
                            	   561: * be printed in.  It stays effective for the rest of the print
                            	   562: * command unless changed by another format.  If no format is
                            	   563: * specified, 11 positions will be used.
                            	   564: *
                            	   565: * A string is quoted in a pair of single- or double-quotes.
                            	   566: *
                            	   567: * An underline (back-arrow) means generate a <CR> without a <LF>
                            	   568: *
                            	   569: * A <CR LF> is generated after the entire list has been printed
                            	   570: * or if the list is empty.  If the list ends with a semicolon,
                            	   571: * however, no <CR LF> is generated.
                            	   572: *
                            	   573: 
                            	   574: LIST:	
00:000066DC 6100115E        	   575: 	bsr	TSTNUM		see if there's a line no.
00:000066E0 61000EE8        	   576: 	bsr	ENDCHK		if not, we get a zero
00:000066E4 61000FEA        	   577: 	bsr	FNDLN		find this or next line
                            	   578: LS1
00:000066E8 650000A0        	   579: 	BCS	FINISH		warm start if we passed the end
00:000066EC 61001118        	   580: 	bsr	PRTLN		print the line
00:000066F0 610011EA        	   581: 	bsr	CHKIO		check for listing halt request
00:000066F4 670C            	   582: 	BEQ	LS3
00:000066F6 B03C0013        	   583: 	CMP.B	#CTRLS,D0	pause the listing?
00:000066FA 6606            	   584: 	BNE	LS3
                            	   585: LS2
00:000066FC 610011DE        	   586: 	bsr	CHKIO		if so, wait for another keypress
00:00006700 67FA            	   587: 	BEQ	LS2
                            	   588: LS3
00:00006702 61000FDA        	   589: 	bsr	FNDLNP		find the next line
00:00006706 60E0            	   590: 	BRA	LS1
                            	   591: 
                            	   592: PRINT:	
00:00006708 780B            	   593: 	MOVE.L #11,D4		D4 = number of print spaces
00:0000670A 61001118        	   594: 	bsr	TSTC		if null list and ":"
00:0000670E 3A              	   595: 	DC.B	':',PR2-*
00:0000670F 09
00:00006710 610013E0        	   596: 	bsr	CRLF		give CR-LF and continue
00:00006714 6000FF6E        	   597: 	BRA	RUNSML		execution on the same line
                            	   598: PR2	
00:00006718 6100110A        	   599: 	bsr	TSTC		if null list and <CR>
00:0000671C 0D              	   600: 	DC.B	CR,PR0-*
00:0000671D 09
00:0000671E 610013D2        	   601: 	bsr	CRLF		also give CR-LF and
00:00006722 6000FF0A        	   602: 	BRA	RUNNXL		execute the next line
                            	   603: PR0
00:00006726 610010FC        	   604: 	bsr	TSTC				; else is it a format?
00:0000672A 23              	   605: 	dc.b '#',PR1-*
00:0000672B 09
00:0000672C 610006A4        	   606: 	bsr	INT_EXPR		; yes, evaluate expression
00:00006730 2800            	   607: 	move.l d0,d4		; and save it as print width
00:00006732 600E            	   608: 	bra	PR3					; look for more to print
                            	   609: PR1
00:00006734 610010EE        	   610: 	bsr	TSTC				; is character expression? (MRL)
00:00006738 24              	   611: 	dc.b '$',PR8-*
00:00006739 1B
00:0000673A 61000696        	   612: 	bsr	INT_EXPR		; yep. Evaluate expression (MRL)
00:0000673E 6100FAA0        	   613: 	bsr	GOOUT				; print low byte (MRL)
                            	   614: 	bra	PR3					; look for more. (MRL)
                            	   615: PR3
00:00006742 610010E0        	   616: 	bsr	TSTC						; if ",", go find next
00:00006746 2C              	   617: 	dc.b ',',PR6-*
00:00006747 07
00:00006748 61000E66        	   618: 	bsr	FIN							; in the list.
00:0000674C 60D8            	   619: 	BRA	PR0
                            	   620: PR6
00:0000674E 610013A2        	   621: 	bsr	CRLF						; list ends here
00:00006752 6036            	   622: 	BRA	FINISH
                            	   623: PR8
00:00006754 2F04            	   624: 	move.l d4,-(SP)			; save the width value
00:00006756 6100068C        	   625: 	bsr	EXPR						; evaluate the expression
00:0000675A 281F            	   626: 	move.l (sp)+,d4			; restore the width
00:0000675C 0C8000000002    	   627: 	cmpi.l #DT_STRING,d0	; is it a string?
00:00006762 670C            	   628: 	beq PR9
00:00006764 F2000080        	   629: 	fmove fp0,fp1
00:00006768 7823            	   630: 	move.l #35,d4
00:0000676A 61001050        	   631: 	bsr	PRTNUM					; print its value
00:0000676E 60D2            	   632: 	bra	PR3							; more to print?
                            	   633: 	; Print a string
                            	   634: PR9
00:00006770 F239680000040600	   635: 	fmove.x fp0,_fpWork
00:00006778 323900040600    	   636: 	move.w _fpWork,d1
00:0000677E 227900040604    	   637: 	move.l _fpWork+4,a1
00:00006784 61001030        	   638: 	bsr PRTSTR2
00:00006788 60B8            	   639: 	bra PR3
                            	   640: 
                            	   641: FINISH:
00:0000678A 61000E24        	   642: 	bsr	FIN			; Check end of command
00:0000678E 60000E4C        	   643: 	BRA	QWHAT		; print "What?" if wrong
                            	   644: 
                            	   645: ;******************************************************************
                            	   646: ;
                            	   647: ; *** GOSUB *** & RETURN ***
                            	   648: ;
                            	   649: ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                            	   650: ; except that the current text pointer, stack pointer, etc. are
                            	   651: ; saved so that execution can be continued after the subroutine
                            	   652: ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                            	   653: ; recursive), the save area must be stacked.  The stack pointer
                            	   654: ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                            	   655: ; If we are in the main routine, 'STKGOS' is zero (this was done
                            	   656: ; in the initialization section of the interpreter), but we still
                            	   657: ; save it as a flag for no further 'RETURN's.
                            	   658: ;
                            	   659: ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                            	   660: ; returns the execution to the command after the most recent
                            	   661: ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                            	   662: ; a 'GOSUB' and is thus an error.
                            	   663: 
                            	   664: GOSUB:
00:00006792 4FEFFF80        	   665: 	sub.l #128,sp		; allocate storage for local variables
00:00006796 2F3A1250        	   666: 	move.l STKFP,-(sp)
00:0000679A 23CF000079E8    	   667: 	move.l sp,STKFP
00:000067A0 61000FBC        	   668: 	bsr	PUSHA				; save the current 'FOR' parameters
00:000067A4 6100062C        	   669: 	bsr	INT_EXPR		; get line number
00:000067A8 2F08            	   670: 	MOVE.L	A0,-(SP)	save text pointer
00:000067AA 2200            	   671: 	move.l	d0,d1
00:000067AC 61000F22        	   672: 	bsr	FNDLN		find the target line
00:000067B0 66000E74        	   673: 	BNE	AHOW		if not there, say "How?"
00:000067B4 2F3A122E        	   674: 	MOVE.L	CURRNT,-(SP)	found it, save old 'CURRNT'...
00:000067B8 2F3A1232        	   675: 	MOVE.L	STKGOS,-(SP)	and 'STKGOS'
00:000067BC 42B9000079F4    	   676: 	CLR.L	LOPVAR		load new values
00:000067C2 23CF000079EC    	   677: 	MOVE.L	SP,STKGOS
00:000067C8 6000FEB0        	   678: 	BRA	RUNTSL
                            	   679: 
                            	   680: RETURN:
00:000067CC 61000DFC        	   681: 	bsr	ENDCHK					; there should be just a <CR>
00:000067D0 223A121A        	   682: 	MOVE.L	STKGOS,D1		; get old stack pointer
00:000067D4 67000E06        	   683: 	BEQ	QWHAT						; if zero, it doesn't exist
00:000067D8 2E41            	   684: 	MOVE.L	D1,SP				; else restore it
00:000067DA 23DF000079EC    	   685: 	MOVE.L	(SP)+,STKGOS	; and the old 'STKGOS'
00:000067E0 23DF000079E4    	   686: 	MOVE.L	(SP)+,CURRNT	; and the old 'CURRNT'
00:000067E6 205F            	   687: 	MOVE.L	(SP)+,A0		; and the old text pointer
00:000067E8 61000F38        	   688: 	bsr	POPA						; and the old 'FOR' parameters
                            	   689: ;	move.l STKFP,sp
00:000067EC 23DF000079E8    	   690: 	move.l (sp)+,STKFP
00:000067F2 4FEF0080        	   691: 	add.l #128,sp				; remove local variable storage
00:000067F6 6092            	   692: 	BRA	FINISH					; and we are back home
                            	   693: 
                            	   694: ;******************************************************************
                            	   695: ;
                            	   696: ; *** FOR *** & NEXT ***
                            	   697: ;
                            	   698: ; 'FOR' has two forms:
                            	   699: ; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                            	   700: ; The second form means the same thing as the first form with a
                            	   701: ; STEP of positive 1.  The interpreter will find the variable 'var'
                            	   702: ; and set its value to the current value of 'exp1'.  It also
                            	   703: ; evaluates 'exp2' and 'exp1' and saves all these together with
                            	   704: ; the text pointer, etc. in the 'FOR' save area, which consisits of
                            	   705: ; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                            	   706: ; already something in the save area (indicated by a non-zero
                            	   707: ; 'LOPVAR'), then the old save area is saved on the stack before
                            	   708: ; the new values are stored.  The interpreter will then dig in the
                            	   709: ; stack and find out if this same variable was used in another
                            	   710: ; currently active 'FOR' loop.  If that is the case, then the old
                            	   711: ; 'FOR' loop is deactivated. (i.e. purged from the stack)
                            	   712: ;
                            	   713: ; 'NEXT var' serves as the logical (not necessarily physical) end
                            	   714: ; of the 'FOR' loop.  The control variable 'var' is checked with
                            	   715: ; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                            	   716: ; the stack to find the right one and purges all those that didn't
                            	   717: ; match.  Either way, it then adds the 'STEP' to that variable and
                            	   718: ; checks the result with against the limit value.  If it is within
                            	   719: ; the limit, control loops back to the command following the
                            	   720: ; 'FOR'.  If it's outside the limit, the save area is purged and
                            	   721: ; execution continues.
                            	   722: 
                            	   723: FOR:
00:000067F8 61000F64        	   724: 	bsr	PUSHA			; save the old 'FOR' save area
00:000067FC 61000D92        	   725: 	bsr	SETVAL		; set the control variable
00:00006800 23CE000079F4    	   726: 	move.l a6,LOPVAR		; save its address
00:00006806 43FAFC23        	   727: 	LEA	TAB5,A1 	; use 'EXEC' to test for 'TO'
00:0000680A 45FAFD14        	   728: 	LEA	TAB5_1,A2
00:0000680E 6000FD6C        	   729: 	BRA	EXEC
                            	   730: FR1	
00:00006812 610005B0        	   731: 	bsr	NUM_EXPR		; evaluate the limit
00:00006816 F239680000007A04	   732: 	FMOVE.X	FP0,LOPLMT	; save that
00:0000681E 43FAFC0E        	   733: 	LEA	TAB6,A1 		; use 'EXEC' to look for the
00:00006822 45FAFD04        	   734: 	LEA	TAB6_1,A2		; word 'STEP'
00:00006826 6000FD54        	   735: 	BRA	EXEC
                            	   736: FR2
00:0000682A 61000598        	   737: 	bsr	NUM_EXPR		found it, get the step value
00:0000682E 6006            	   738: 	BRA	FR4
                            	   739: FR3
00:00006830 F23C58000001    	   740: 	FMOVE.B #1,FP0	; not found, step defaults to 1
                            	   741: FR4
00:00006836 F2396800000079F8	   742: 	FMOVE.X	FP0,LOPINC	save that too
                            	   743: FR5	
00:0000683E 23FA11A400007A10	   744: 	MOVE.L	CURRNT,LOPLN	save address of current line number
00:00006846 23C800007A14    	   745: 	MOVE.L	A0,LOPPT	and text pointer
00:0000684C 2C4F            	   746: 	MOVE.L	SP,A6		dig into the stack to find 'LOPVAR'
00:0000684E 600C            	   747: 	BRA	FR7
                            	   748: FR6
00:00006850 4DEE0024        	   749: 	lea 36(a6),a6			; look at next stack frame
00:00006854 BDFAF9A2        	   750: 	cmp.l ENDMEM,a6		; safety check
00:00006858 64000D82        	   751: 	bhs QWHAT
                            	   752: FR7
00:0000685C 2016            	   753: 	MOVE.L	(A6),D0 	; is it zero?
00:0000685E 6714            	   754: 	BEQ	FR8						; if so, we're done
00:00006860 B0BA1192        	   755: 	CMP.L	LOPVAR,D0		; same as current LOPVAR?
00:00006864 66EA            	   756: 	BNE	FR6						; nope, look some more
00:00006866 244F            	   757: 	MOVE.L	SP,A2			; Else remove 9 long words from...
00:00006868 224E            	   758: 	MOVE.L	A6,A1			; inside the stack.
00:0000686A 47E90024        	   759: 	lea	36(a1),a3
00:0000686E 61000EAA        	   760: 	bsr	MVDOWN
00:00006872 2E4B            	   761: 	MOVE.L	A3,SP		set the SP 9 long words up
                            	   762: FR8
00:00006874 6000FF14        	   763: 	BRA	FINISH		and continue execution
                            	   764: 
                            	   765: NEXT	
00:00006878 610009E4        	   766: 	bsr	TSTV						; get address of variable
00:0000687C 65000D5E        	   767: 	bcs	QWHAT						; if no variable, say "What?"
00:00006880 2240            	   768: 	move.l d0,a1				; save variable's address
                            	   769: NX0
00:00006882 203A1170        	   770: 	move.l LOPVAR,D0		; If 'LOPVAR' is zero, we never...
00:00006886 67000D54        	   771: 	beq	QWHAT						; had a FOR loop, so say "What?"
00:0000688A B3C0            	   772: 	cmp.l	d0,a1					; else we check them
00:0000688C 6706            	   773: 	beq	NX3							; OK, they agree
00:0000688E 61000E92        	   774: 	bsr	POPA						; nope, let's see the next frame
00:00006892 60EE            	   775: 	bra	NX0
                            	   776: NX3	
00:00006894 F22948000004    	   777: 	fmove.x	4(a1),fp0		; get control variable's value
00:0000689A F23A4822115A    	   778: 	fadd.x LOPINC,fp0		; add in loop increment
                            	   779: ;	BVS	QHOW		say "How?" for 32-bit overflow
00:000068A0 F22968000004    	   780: 	fmove.x	fp0,4(a1)		; save control variable's new value
00:000068A6 F23A4880115A    	   781: 	fmove.x	LOPLMT,fp1	; get loop's limit value
00:000068AC F23A503A1148    	   782: 	ftst LOPINC
00:000068B2 F293000E        	   783: 	FBGE NX1				; branch if loop increment is positive
00:000068B6 F2276800        	   784: 	FMOVE.X FP0,-(a7)	; exchange FP0,FP1
00:000068BA F2000400        	   785: 	FMOVE.X FP1,FP0
00:000068BE F21F4880        	   786: 	FMOVE.X (a7)+,FP1
                            	   787: NX1	
00:000068C2 F20000B8        	   788: 	FCMP FP0,FP1		;	test against limit
00:000068C6 F2940012        	   789: 	FBLT NX2				; branch if outside limit
00:000068CA 23FA1144000079E4	   790: 	MOVE.L LOPLN,CURRNT	Within limit, go back to the...
00:000068D2 207A1140        	   791: 	MOVE.L LOPPT,A0	saved 'CURRNT' and text pointer.
00:000068D6 6000FEB2        	   792: 	BRA	FINISH
                            	   793: NX2
00:000068DA 61000E46        	   794: 	bsr	POPA		purge this loop
00:000068DE 6000FEAA        	   795: 	BRA	FINISH
                            	   796: 
                            	   797: *******************************************************************
                            	   798: *
                            	   799: * *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                            	   800: *
                            	   801: * 'REM' can be followed by anything and is ignored by the
                            	   802: * interpreter.
                            	   803: *
                            	   804: * 'IF' is followed by an expression, as a condition and one or
                            	   805: * more commands (including other 'IF's) separated by colons.
                            	   806: * Note that the word 'THEN' is not used.  The interpreter evaluates
                            	   807: * the expression.  If it is non-zero, execution continues.  If it
                            	   808: * is zero, the commands that follow are ignored and execution
                            	   809: * continues on the next line.
                            	   810: *
                            	   811: * 'INPUT' is like the 'PRINT' command, and is followed by a list
                            	   812: * of items.  If the item is a string in single or double quotes,
                            	   813: * or is an underline (back arrow), it has the same effect as in
                            	   814: * 'PRINT'.  If an item is a variable, this variable name is
                            	   815: * printed out followed by a colon, then the interpreter waits for
                            	   816: * an expression to be typed in.  The variable is then set to the
                            	   817: * value of this expression.  If the variable is preceeded by a
                            	   818: * string (again in single or double quotes), the string will be
                            	   819: * displayed followed by a colon.  The interpreter the waits for an
                            	   820: * expression to be entered and sets the variable equal to the
                            	   821: * expression's value.  If the input expression is invalid, the
                            	   822: * interpreter will print "What?", "How?", or "Sorry" and reprint
                            	   823: * the prompt and redo the input.  The execution will not terminate
                            	   824: * unless you press control-C.  This is handled in 'INPERR'.
                            	   825: *
                            	   826: * 'LET' is followed by a list of items separated by commas.
                            	   827: * Each item consists of a variable, an equals sign, and an
                            	   828: * expression.  The interpreter evaluates the expression and sets
                            	   829: * the variable to that value.  The interpreter will also handle
                            	   830: * 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                            	   831: 
                            	   832: REM
00:000068E2 600A            	   833: 	BRA	IF2		skip the rest of the line
                            	   834: 
                            	   835: IF
00:000068E4 610004EC        	   836: 	bsr	INT_EXPR		evaluate the expression
                            	   837: IF1
00:000068E8 4A80            	   838: 	TST.L	d0		is it zero?
00:000068EA 6600FD98        	   839: 	BNE	RUNSML		if not, continue
                            	   840: IF2
00:000068EE 2248            	   841: 	MOVE.L	A0,A1
00:000068F0 7200            	   842: 	CLR.L	D1
00:000068F2 61000E04        	   843: 	bsr	FNDSKP		if so, skip the rest of the line
00:000068F6 6400FD82        	   844: 	BCC	RUNTSL		and run the next line
00:000068FA 6000F96C        	   845: 	BRA	WSTART		if no next line, do a warm start
                            	   846: 
00:000068FE 2E7A10F0        	   847: INPERR	MOVE.L	STKINP,SP	restore the old stack pointer
00:00006902 23DF000079E4    	   848: 	MOVE.L	(SP)+,CURRNT	and old 'CURRNT'
00:00006908 588F            	   849: 	ADDQ.L	#4,SP
00:0000690A 205F            	   850: 	MOVE.L	(SP)+,A0	and old text pointer
                            	   851: 
                            	   852: INPUT	
00:0000690C 2F08            	   853: 	MOVE.L	A0,-(SP)	save in case of error
00:0000690E 610004D4        	   854: 	bsr EXPR
00:00006912 0C000002        	   855: 	cmpi.b #DT_STRING,d0
00:00006916 6622            	   856: 	bne IP6
00:00006918 F239680000040600	   857: 	fmove.x fp0,_fpWork
00:00006920 323900040600    	   858: 	move.w _fpWork,d1
00:00006926 227900040604    	   859: 	move.l _fpWork+4,a1
00:0000692C 61000E88        	   860: 	bsr PRTSTR2
                            	   861: ;	bsr	QTSTG		is next item a string?
                            	   862: ;	BRA.S	IP2		nope
                            	   863: IP7
00:00006930 6100092C        	   864: 	bsr	TSTV		yes, but is it followed by a variable?
00:00006934 655C            	   865: 	BCS	IP4		if not, branch
00:00006936 2440            	   866: 	MOVE.L	D0,A2		put away the variable's address
00:00006938 601E            	   867: 	BRA	IP3		if so, input to variable
                            	   868: IP6
00:0000693A 2057            	   869: 	move.l (sp),a0	; restore text pointer
00:0000693C 60F2            	   870: 	bra IP7
                            	   871: IP2
00:0000693E 2F08            	   872: 	MOVE.L	A0,-(SP)	save for 'PRTSTG'
00:00006940 6100091C        	   873: 	bsr	TSTV		must be a variable now
00:00006944 65000C96        	   874: 	BCS	QWHAT		"What?" it isn't?
00:00006948 2440            	   875: 	MOVE.L	D0,A2		put away the variable's address
00:0000694A 1410            	   876: 	MOVE.B	(A0),D2 	get ready for 'PRTSTG'
00:0000694C 4200            	   877: 	CLR.B	D0
00:0000694E 1080            	   878: 	MOVE.B	D0,(A0)
00:00006950 225F            	   879: 	MOVE.L	(SP)+,A1
00:00006952 61000E40        	   880: 	bsr	PRTSTG		print string as prompt
00:00006956 1082            	   881: 	MOVE.B	D2,(A0) 	restore text
                            	   882: IP3
00:00006958 2F08            	   883: 	MOVE.L	A0,-(SP)	save in case of error
00:0000695A 2F3A1088        	   884: 	MOVE.L	CURRNT,-(SP)	also save 'CURRNT'
00:0000695E 23FCFFFFFFFF0000	   885: 	MOVE.L	#-1,CURRNT	flag that we are in INPUT
00:00006966 79E4
00:00006968 23CF000079F0    	   886: 	MOVE.L	SP,STKINP	save the stack pointer too
00:0000696E 2F0A            	   887: 	MOVE.L	A2,-(SP)	save the variable address
00:00006970 103C003A        	   888: 	MOVE.B	#':',D0         print a colon first
00:00006974 61000CBC        	   889: 	bsr	GETLN		then get an input line
00:00006978 41FA10C2        	   890: 	LEA	BUFFER,A0	point to the buffer
00:0000697C 61000466        	   891: 	bsr	EXPR		evaluate the input
00:00006980 245F            	   892: 	MOVE.L	(SP)+,A2	restore the variable address
00:00006982 2480            	   893: 	move.l d0,(a2)			; save data type
00:00006984 F22A68000004    	   894: 	FMOVE.X	FP0,4(A2) 	; save value in variable
00:0000698A 23DF000079E4    	   895: 	MOVE.L	(SP)+,CURRNT	restore old 'CURRNT'
00:00006990 205F            	   896: 	MOVE.L	(SP)+,A0	and the old text pointer
                            	   897: IP4
00:00006992 588F            	   898: 	ADDQ.L	#4,SP		clean up the stack
00:00006994 61000E8E        	   899: 	bsr	TSTC		is the next thing a comma?
00:00006998 2C              	   900: 	DC.B	',',IP5-*
00:00006999 05
00:0000699A 6000FF70        	   901: 	BRA	INPUT		yes, more items
                            	   902: IP5
00:0000699E 6000FDEA        	   903: 	BRA	FINISH
                            	   904: 
                            	   905: DEFLT
00:000069A2 0C10000D        	   906: 	CMP.B	#CR,(A0)	; empty line is OK
00:000069A6 6700FDE2        	   907: 	BEQ	FINISH			; else it is 'LET'
                            	   908: 
                            	   909: LET
00:000069AA 61000BE4        	   910: 	bsr	SETVAL		 	; do the assignment
00:000069AE 61000E74        	   911: 	bsr	TSTC				; check for more 'LET' items
00:000069B2 2C              	   912: 	DC.B	',',LT1-*
00:000069B3 03
00:000069B4 60F4            	   913: 	BRA	LET
                            	   914: LT1
00:000069B6 6000FDD2        	   915: 	BRA	FINISH			; until we are finished.
                            	   916: 
                            	   917: 
                            	   918: *******************************************************************
                            	   919: *
                            	   920: * *** LOAD *** & SAVE ***
                            	   921: *
                            	   922: * These two commands transfer a program to/from an auxiliary
                            	   923: * device such as a cassette, another computer, etc.  The program
                            	   924: * is converted to an easily-stored format: each line starts with
                            	   925: * a colon, the line no. as 4 hex digits, and the rest of the line.
                            	   926: * At the end, a line starting with an '@' sign is sent.  This
                            	   927: * format can be read back with a minimum of processing time by
                            	   928: * the 68000.
                            	   929: *
                            	   930: LOAD	
00:000069BA 207AF838        	   931: 	MOVE.L TXTBGN,A0	set pointer to start of prog. area
00:000069BE 103C000D        	   932: 	MOVE.B #CR,D0		For a CP/M host, tell it we're ready...
00:000069C2 6100F824        	   933: 	BSR	GOAUXO		by sending a CR to finish PIP command.
                            	   934: LOD1	
00:000069C6 6100F824        	   935: 	BSR	GOAUXI		look for start of line
00:000069CA 67FA            	   936: 	BEQ	LOD1
00:000069CC B03C0040        	   937: 	CMP.B	#'@',D0         end of program?
00:000069D0 671E            	   938: 	BEQ	LODEND
00:000069D2 B03C003A        	   939: 	CMP.B	#':',D0         if not, is it start of line?
00:000069D6 66EE            	   940: 	BNE	LOD1		if not, wait for it
00:000069D8 6120            	   941: 	BSR	GBYTE		get first byte of line no.
00:000069DA 10C1            	   942: 	MOVE.B	D1,(A0)+	store it
00:000069DC 611C            	   943: 	BSR	GBYTE		get 2nd bye of line no.
00:000069DE 10C1            	   944: 	MOVE.B	D1,(A0)+	store that, too
                            	   945: LOD2
00:000069E0 6100F80A        	   946: 	BSR	GOAUXI		get another text char.
00:000069E4 67FA            	   947: 	BEQ	LOD2
00:000069E6 10C0            	   948: 	MOVE.B	D0,(A0)+	store it
00:000069E8 B03C000D        	   949: 	CMP.B	#CR,D0		is it the end of the line?
00:000069EC 66F2            	   950: 	BNE	LOD2		if not, go back for more
00:000069EE 60D6            	   951: 	BRA	LOD1		if so, start a new line
                            	   952: LODEND
00:000069F0 23C800007A2C    	   953: 	MOVE.L	A0,TXTUNF	set end-of program pointer
00:000069F6 6000F870        	   954: 	BRA	WSTART		back to direct mode
                            	   955: 
                            	   956: GBYTE
00:000069FA 7401            	   957: 	MOVEQ	#1,D2		get two hex characters from auxiliary
00:000069FC 7200            	   958: 	CLR.L	D1		and store them as a byte in D1
                            	   959: GBYTE1	
00:000069FE 6100F7EC        	   960: 	BSR	GOAUXI		get a char.
00:00006A02 67FA            	   961: 	BEQ	GBYTE1
00:00006A04 B03C0041        	   962: 	CMP.B	#'A',D0
00:00006A08 6502            	   963: 	BCS	GBYTE2
00:00006A0A 5F00            	   964: 	SUBQ.B	#7,D0		if greater than 9, adjust
                            	   965: GBYTE2
00:00006A0C C03C000F        	   966: 	AND.B	#$F,D0		strip ASCII
00:00006A10 E909            	   967: 	LSL.B	#4,D1		put nybble into the result
00:00006A12 8200            	   968: 	OR.B	D0,D1
00:00006A14 51CAFFE8        	   969: 	DBRA	D2,GBYTE1	get another char.
00:00006A18 4E75            	   970: 	RTS
                            	   971: 
                            	   972: SAVE
00:00006A1A 207AF7D8        	   973: 	MOVE.L	TXTBGN,A0	set pointer to start of prog. area
00:00006A1E 227A100C        	   974: 	MOVE.L	TXTUNF,A1	set pointer to end of prog. area
                            	   975: SAVE1	
00:00006A22 103C000D        	   976: 	MOVE.B	#CR,D0		send out a CR & LF (CP/M likes this)
00:00006A26 6100F7C0        	   977: 	BSR	GOAUXO
00:00006A2A 103C000A        	   978: 	MOVE.B	#LF,D0
00:00006A2E 6100F7B8        	   979: 	BSR	GOAUXO
00:00006A32 B3C8            	   980: 	CMP.L	A0,A1		are we finished?
00:00006A34 631E            	   981: 	BLS	SAVEND
00:00006A36 103C003A        	   982: 	MOVE.B	#':',D0         if not, start a line
00:00006A3A 6100F7AC        	   983: 	BSR	GOAUXO
00:00006A3E 1218            	   984: 	MOVE.B	(A0)+,D1	send first half of line no.
00:00006A40 6136            	   985: 	BSR	PBYTE
00:00006A42 1218            	   986: 	MOVE.B	(A0)+,D1	and send 2nd half
00:00006A44 6132            	   987: 	BSR	PBYTE
                            	   988: SAVE2
00:00006A46 1018            	   989: 	MOVE.B	(A0)+,D0	get a text char.
00:00006A48 B03C000D        	   990: 	CMP.B	#CR,D0		is it the end of the line?
00:00006A4C 67D4            	   991: 	BEQ	SAVE1		if so, send CR & LF and start new line
00:00006A4E 6100F798        	   992: 	BSR	GOAUXO		send it out
00:00006A52 60F2            	   993: 	BRA	SAVE2		go back for more text
                            	   994: SAVEND
00:00006A54 103C0040        	   995: 	MOVE.B	#'@',D0         send end-of-program indicator
00:00006A58 6100F78E        	   996: 	BSR	GOAUXO
00:00006A5C 103C000D        	   997: 	MOVE.B	#CR,D0		followed by a CR & LF
00:00006A60 6100F786        	   998: 	BSR	GOAUXO
00:00006A64 103C000A        	   999: 	MOVE.B	#LF,D0
00:00006A68 6100F77E        	  1000: 	BSR	GOAUXO
00:00006A6C 103C001A        	  1001: 	MOVE.B	#$1A,D0 	and a control-Z to end the CP/M file
00:00006A70 6100F776        	  1002: 	BSR	GOAUXO
00:00006A74 6000F7F2        	  1003: 	BRA	WSTART		then go do a warm start
                            	  1004: 
00:00006A78 7401            	  1005: PBYTE	MOVEQ	#1,D2		send two hex characters from D1's low byte
00:00006A7A E919            	  1006: PBYTE1	ROL.B	#4,D1		get the next nybble
00:00006A7C 1001            	  1007: 	MOVE.B	D1,D0
00:00006A7E C03C000F        	  1008: 	AND.B	#$F,D0		strip off garbage
00:00006A82 D03C0030        	  1009: 	ADD.B	#'0',D0         make it into ASCII
00:00006A86 B03C0039        	  1010: 	CMP.B	#'9',D0
00:00006A8A 6302            	  1011: 	BLS	PBYTE2
00:00006A8C 5E00            	  1012: 	ADDQ.B	#7,D0		adjust if greater than 9
00:00006A8E 6100F758        	  1013: PBYTE2	BSR	GOAUXO		send it out
00:00006A92 51CAFFE6        	  1014: 	DBRA	D2,PBYTE1	then send the next nybble
00:00006A96 4E75            	  1015: 	RTS
                            	  1016: 
                            	  1017: *******************************************************************
                            	  1018: *
                            	  1019: * *** POKE *** & CALL ***
                            	  1020: *
                            	  1021: * 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                            	  1022: * address specified by 'expr1'.
                            	  1023: *
                            	  1024: * 'CALL expr' jumps to the machine language subroutine whose
                            	  1025: * starting address is specified by 'expr'.  The subroutine can use
                            	  1026: * all registers but must leave the stack the way it found it.
                            	  1027: * The subroutine returns to the interpreter by executing an RTS.
                            	  1028: *
                            	  1029: POKE
00:00006A98 1E3C0042        	  1030: 	move.b #'B',d7
00:00006A9C 1210            	  1031: 	move.b (a0),d1
00:00006A9E 0C01002E        	  1032: 	cmpi.b #'.',d1
00:00006AA2 6620            	  1033: 	bne .0001
00:00006AA4 5248            	  1034: 	addq #1,a0
00:00006AA6 1210            	  1035: 	move.b (a0),d1
00:00006AA8 0C010042        	  1036: 	cmpi.b #'B',d1
00:00006AAC 6712            	  1037: 	beq .0002
00:00006AAE 0C010057        	  1038: 	cmpi.b #'W',d1
00:00006AB2 670C            	  1039: 	beq .0002
00:00006AB4 0C01004C        	  1040: 	cmpi.b #'L',d1
00:00006AB8 6706            	  1041: 	beq .0002
00:00006ABA 0C010046        	  1042: 	cmpi.b #'F',d1
00:00006ABE 664E            	  1043: 	bne	PKER
                            	  1044: .0002
00:00006AC0 5248            	  1045: 	addq #1,a0
00:00006AC2 1E01            	  1046: 	move.b d1,d7
                            	  1047: .0001
00:00006AC4 6100030C        	  1048: 	BSR	INT_EXPR		get the memory address
00:00006AC8 61000D5A        	  1049: 	bsr	TSTC		it must be followed by a comma
00:00006ACC 2C              	  1050: 	DC.B	',',PKER-*
00:00006ACD 41
00:00006ACE 2F00            	  1051: 	move.l d0,-(sp)		; save the address
00:00006AD0 610002F2        	  1052: 	BSR	NUM_EXPR			; get the value to be POKE'd
00:00006AD4 225F            	  1053: 	move.l	(sp)+,a1	; get the address back
00:00006AD6 0C070042        	  1054: 	CMPI.B #'B',D7
00:00006ADA 6608            	  1055: 	BNE .0003
00:00006ADC F2117800        	  1056: 	FMOVE.B	FP0,(A1) 	store the byte in memory
00:00006AE0 6000FCA8        	  1057: 	BRA	FINISH
                            	  1058: .0003
00:00006AE4 0C070057        	  1059: 	CMPI.B #'W',d7
00:00006AE8 6608            	  1060: 	BNE .0004
00:00006AEA F2117000        	  1061: 	FMOVE.W FP0,(A1)
00:00006AEE 6000FC9A        	  1062: 	BRA FINISH
                            	  1063: .0004
00:00006AF2 0C07004C        	  1064: 	CMPI.B #'L',D7
00:00006AF6 6608            	  1065: 	BNE .0005
00:00006AF8 F2116000        	  1066: 	FMOVE.L FP0,(A1)
00:00006AFC 6000FC8C        	  1067: 	BRA FINISH
                            	  1068: .0005
00:00006B00 0C070046        	  1069: 	CMPI.B #'F',D7
00:00006B04 6608            	  1070: 	BNE .0006
00:00006B06 F2116800        	  1071: 	FMOVE.X FP0,(A1)
00:00006B0A 6000FC7E        	  1072: 	BRA FINISH
                            	  1073: .0006
                            	  1074: PKER
00:00006B0E 60000ACC        	  1075: 	BRA	QWHAT		if no comma, say "What?"
                            	  1076: 
                            	  1077: CALL	
00:00006B12 610002BE        	  1078: 	BSR	INT_EXPR		; get the subroutine's address
00:00006B16 4A80            	  1079: 	TST.l d0				; make sure we got a valid address
00:00006B18 67000B0A        	  1080: 	BEQ QHOW				; if not, say "How?"
00:00006B1C 2F08            	  1081: 	MOVE.L A0,-(SP)	; save the text pointer
00:00006B1E 2240            	  1082: 	MOVE.L D0,A1
00:00006B20 4E91            	  1083: 	JSR	(A1)				; jump to the subroutine
00:00006B22 205F            	  1084: 	MOVE.L (SP)+,A0	; restore the text pointer
00:00006B24 6000FC64        	  1085: 	BRA	FINISH
                            	  1086: 
                            	  1087: ;******************************************************************
                            	  1088: ; Graphics commands:
                            	  1089: ;		DRAWBUF - which buffer to draw to (0 or 1)
                            	  1090: ;		DISPBUF - which buffer to display (0 or 1)
                            	  1091: ;		POINT - plot point
                            	  1092: ;		LINE	- draw line
                            	  1093: ;		RECT	- draw rectangle
                            	  1094: ;		TRI		- draw triangle
                            	  1095: ;		CURVE	- draw curve
                            	  1096: ;
                            	  1097: ;		LINE x1,y1,x2,y2
                            	  1098: ;		TRI x1,y1,x2,y2,x3,y3
                            	  1099: ; RECT specifies a point then width and height
                            	  1100: ;		RECT x1,y1,width,height
                            	  1101: ; Color depth may be specified
                            	  1102: ;		COLOR DEPTH	8		; specifies 24-bits for color
                            	  1103: ;		COLOR 16711680	; color RED in 24-bit color
                            	  1104: ;		COLOR 31744			; color RED in 16-bit color (color depth 5)
                            	  1105: ;
                            	  1106: ; Other:
                            	  1107: ;		CLEAR <device>	- useful for clearing the graphics screen
                            	  1108: ;											device #7
                            	  1109: ;******************************************************************
                            	  1110: 
                            	  1111: CLEAR:
00:00006B28 610002A8        	  1112: 	bsr INT_EXPR
00:00006B2C 2E00            	  1113: 	move.l d0,d7
00:00006B2E 7C0C            	  1114: 	moveq #DEV_CLEAR,d6
00:00006B30 4E40            	  1115: 	trap #0
00:00006B32 6000FC56        	  1116: 	bra FINISH
                            	  1117: 
                            	  1118: TEXT:
00:00006B36 6100029A        	  1119: 	bsr INT_EXPR
00:00006B3A 61000CE8        	  1120: 	bsr	TSTC					; it must be followed by a comma
00:00006B3E 2C              	  1121: 	dc.b	',',TEXTERR-*
00:00006B3F 27
00:00006B40 2F00            	  1122: 	move.l d0,-(sp)
00:00006B42 6100028E        	  1123: 	bsr INT_EXPR
00:00006B46 2400            	  1124: 	move.l d0,d2
00:00006B48 221F            	  1125: 	move.l (sp)+,d1
00:00006B4A 13C20004008C    	  1126: 	move.b d2,TextRows
00:00006B50 13C10004008D    	  1127: 	move.b d1,TextCols
00:00006B56 13C1FD080000    	  1128: 	move.b d1,TEXTREG+0	; set columns
00:00006B5C 13C2FD080001    	  1129: 	move.b d2,TEXTREG+1	; set rows
00:00006B62 60000D96        	  1130: 	bra CLS
                            	  1131: TEXTERR
00:00006B66 60000A74        	  1132: 	bra QWHAT
                            	  1133: 
                            	  1134: DRAWBUF:
00:00006B6A 61000266        	  1135: 	bsr INT_EXPR
00:00006B6E 7E07            	  1136: 	moveq #7,d7
00:00006B70 7C22            	  1137: 	moveq #DEV_SET_DESTBUF,d6
00:00006B72 2200            	  1138: 	move.l d0,d1
00:00006B74 4E40            	  1139: 	trap #0
00:00006B76 6000FC12        	  1140: 	bra FINISH
                            	  1141: 	
                            	  1142: DISPBUF:
00:00006B7A 61000256        	  1143: 	bsr INT_EXPR
00:00006B7E 7E06            	  1144: 	moveq #6,d7
00:00006B80 7C23            	  1145: 	moveq #DEV_SET_DISPBUF,d6
00:00006B82 2200            	  1146: 	move.l d0,d1
00:00006B84 4E40            	  1147: 	trap #0
00:00006B86 6000FC02        	  1148: 	bra FINISH
                            	  1149: 
                            	  1150: ; COLOR DEPTH <bits per color component>	- value between 0 and 10
                            	  1151: ; To enhance draw performance the resulting color is rounded to a byte aligned
                            	  1152: ; value for the following color depths:
                            	  1153: ; 10 results in 32 bpp color	(4 bytes of memory per color)
                            	  1154: ;	 8 results in 24 bpp color	(3 bytes of memory per color)
                            	  1155: ;  5 results in 16 bpp color	(2 bytes of memory per color)
                            	  1156: ;  2 results in  8 bpp color	(1 byte of memory per color)
                            	  1157: ;  0 results in  8 bpp color	(1 byte of memory per color)
                            	  1158: ; for other values the bpp is 3x the color depth (drawing is slower)
                            	  1159: 
                            	  1160: COLOR:
00:00006B8A 43FAF8BE        	  1161: 	lea	TAB12,A1 			; use 'EXEC' to look for the
00:00006B8E 45FAF9D4        	  1162: 	lea	TAB12_1,A2		; word 'DEPTH'
00:00006B92 6000F9E8        	  1163: 	bra	EXEC
                            	  1164: COLOR1
00:00006B96 6100023A        	  1165: 	bsr INT_EXPR
00:00006B9A 0C800000000A    	  1166: 	cmpi.l #10,d0
00:00006BA0 62000A3A        	  1167: 	bhi QWHAT
00:00006BA4 2200            	  1168: 	move.l d0,d1
00:00006BA6 E988            	  1169: 	lsl.l #4,d0
00:00006BA8 8081            	  1170: 	or.l d1,d0
00:00006BAA E988            	  1171: 	lsl.l #4,d0
00:00006BAC 8081            	  1172: 	or.l d1,d0
00:00006BAE 0C01000A        	  1173: 	cmpi.b #10,d1
00:00006BB2 6606            	  1174: 	bne.s .0001
00:00006BB4 807C2000        	  1175: 	or.w #$2000,d0
00:00006BB8 6020            	  1176: 	bra.s .0002
                            	  1177: .0001
00:00006BBA 0C010005        	  1178: 	cmpi.b #5,d1
00:00006BBE 6606            	  1179: 	bne.s .0003
00:00006BC0 807C1000        	  1180: 	or.w #$1000,d0
00:00006BC4 6014            	  1181: 	bra.s .0002
                            	  1182: .0003
00:00006BC6 0C010002        	  1183: 	cmpi.b #2,d1
00:00006BCA 6606            	  1184: 	bne.s .0004
00:00006BCC 807C2000        	  1185: 	or.w #$2000,d0
00:00006BD0 6008            	  1186: 	bra.s .0002
                            	  1187: .0004
00:00006BD2 4A01            	  1188: 	tst.b d1
00:00006BD4 6604            	  1189: 	bne.s .0002
00:00006BD6 303C2222        	  1190: 	move.w #$2222,d0
                            	  1191: .0002
00:00006BDA 7E07            	  1192: 	moveq #7,d7
00:00006BDC 7C21            	  1193: 	moveq #DEV_SET_COLOR_DEPTH,d6
00:00006BDE 2200            	  1194: 	move.l d0,d1
00:00006BE0 4E40            	  1195: 	trap #0
00:00006BE2 7E06            	  1196: 	moveq #6,d7
00:00006BE4 4E40            	  1197: 	trap #0
00:00006BE6 6000FBA2        	  1198: 	bra FINISH
                            	  1199: 
                            	  1200: COLOR2
00:00006BEA 610001E6        	  1201: 	bsr INT_EXPR
00:00006BEE 2200            	  1202: 	move.l d0,d1
00:00006BF0 7E07            	  1203: 	moveq #7,d7						; graphics accelerator
00:00006BF2 7C19            	  1204: 	moveq #DEV_SET_COLOR,d6
00:00006BF4 4E40            	  1205: 	trap #0
00:00006BF6 7E06            	  1206: 	moveq #6,d7						; frame buffer
00:00006BF8 4E40            	  1207: 	trap #0
00:00006BFA 6000FB8E        	  1208: 	bra FINISH
                            	  1209: 
                            	  1210: ; POINT <x, y>	- draws a point in the current color
                            	  1211: 
                            	  1212: POINT:
00:00006BFE 610001D2        	  1213: 	bsr INT_EXPR
00:00006C02 61000C20        	  1214: 	bsr	TSTC		it must be followed by a comma
00:00006C06 2C              	  1215: 	dc.b	',',POINTERR-*
00:00006C07 19
00:00006C08 2F00            	  1216: 	move.l d0,-(sp)
00:00006C0A 610001C6        	  1217: 	bsr INT_EXPR
00:00006C0E 2400            	  1218: 	move.l d0,d2
00:00006C10 221F            	  1219: 	move.l (sp)+,d1
00:00006C12 4841            	  1220: 	swap d1
00:00006C14 4842            	  1221: 	swap d2
00:00006C16 7E07            	  1222: 	moveq #7,d7
00:00006C18 7C1B            	  1223: 	moveq #DEV_PLOT_POINT,d6
00:00006C1A 4E40            	  1224: 	trap #0
00:00006C1C 6000FB6C        	  1225: 	bra FINISH
                            	  1226: POINTERR
00:00006C20 600009BA        	  1227: 	bra QWHAT
                            	  1228: 
                            	  1229: ; LINE <x1,y1,x2,y2>	- draws a line in the current color
                            	  1230: 
                            	  1231: LINE:
00:00006C24 610001AC        	  1232: 	bsr INT_EXPR
00:00006C28 61000BFA        	  1233: 	bsr	TSTC							; it must be followed by a comma
00:00006C2C 2C              	  1234: 	dc.b	',',LINEERR-*
00:00006C2D 39
00:00006C2E 2F00            	  1235: 	move.l d0,-(sp)
00:00006C30 610001A0        	  1236: 	bsr INT_EXPR
00:00006C34 61000BEE        	  1237: 	bsr	TSTC							; it must be followed by a comma
00:00006C38 2C              	  1238: 	dc.b	',',LINEERR1-*
00:00006C39 31
00:00006C3A 2F00            	  1239: 	move.l d0,-(sp)	
00:00006C3C 61000194        	  1240: 	bsr INT_EXPR
00:00006C40 61000BE2        	  1241: 	bsr	TSTC							; it must be followed by a comma
00:00006C44 2C              	  1242: 	dc.b	',',LINEERR2-*
00:00006C45 2B
00:00006C46 2F00            	  1243: 	move.l d0,-(sp)
00:00006C48 61000188        	  1244: 	bsr INT_EXPR
00:00006C4C 2800            	  1245: 	move.l d0,d4
00:00006C4E 4844            	  1246: 	swap d4
00:00006C50 261F            	  1247: 	move.l (sp)+,d3
00:00006C52 4843            	  1248: 	swap d3
00:00006C54 241F            	  1249: 	move.l (sp)+,d2
00:00006C56 4842            	  1250: 	swap d2
00:00006C58 221F            	  1251: 	move.l (sp)+,d1	
00:00006C5A 4841            	  1252: 	swap d1
00:00006C5C 7E07            	  1253: 	moveq #7,d7
00:00006C5E 7C1C            	  1254: 	moveq #DEV_DRAW_LINE,d6
00:00006C60 4E40            	  1255: 	trap #0
00:00006C62 6000FB26        	  1256: 	bra FINISH
                            	  1257: LINEERR
00:00006C66 60000974        	  1258: 	bra QWHAT
                            	  1259: LINEERR1
00:00006C6A 588F            	  1260: 	add.l #4,sp
00:00006C6C 6000096E        	  1261: 	bra QWHAT
                            	  1262: LINEERR2
00:00006C70 508F            	  1263: 	add.l #8,sp
00:00006C72 60000968        	  1264: 	bra QWHAT
                            	  1265: 
                            	  1266: RECT:
00:00006C76 6100015A        	  1267: 	bsr INT_EXPR
00:00006C7A 61000BA8        	  1268: 	bsr	TSTC							; it must be followed by a comma
00:00006C7E 2C              	  1269: 	DC.B	',',LINEERR-*
00:00006C7F E7
00:00006C80 2F00            	  1270: 	move.l d0,-(sp)
00:00006C82 6100014E        	  1271: 	bsr INT_EXPR
00:00006C86 61000B9C        	  1272: 	bsr	TSTC							; it must be followed by a comma
00:00006C8A 2C              	  1273: 	DC.B	',',LINEERR1-*
00:00006C8B DF
00:00006C8C 2F00            	  1274: 	move.l d0,-(sp)	
00:00006C8E 61000142        	  1275: 	bsr INT_EXPR
00:00006C92 61000B90        	  1276: 	bsr	TSTC							; it must be followed by a comma
00:00006C96 2C              	  1277: 	DC.B	',',LINEERR2-*
00:00006C97 D9
00:00006C98 2F00            	  1278: 	move.l d0,-(sp)
00:00006C9A 61000136        	  1279: 	bsr INT_EXPR
00:00006C9E 2800            	  1280: 	move.l d0,d4
00:00006CA0 261F            	  1281: 	move.l (sp)+,d3
00:00006CA2 241F            	  1282: 	move.l (sp)+,d2
00:00006CA4 221F            	  1283: 	move.l (sp)+,d1
00:00006CA6 D681            	  1284: 	add.l d1,d3
00:00006CA8 D882            	  1285: 	add.l d2,d4	
00:00006CAA 4841            	  1286: 	swap d1
00:00006CAC 4842            	  1287: 	swap d2
00:00006CAE 4843            	  1288: 	swap d3
00:00006CB0 4844            	  1289: 	swap d4
00:00006CB2 7E07            	  1290: 	moveq #7,d7
00:00006CB4 7C1E            	  1291: 	moveq #DEV_DRAW_RECTANGLE,d6
00:00006CB6 4E40            	  1292: 	trap #0
00:00006CB8 6000FAD0        	  1293: 	bra FINISH
                            	  1294: 
                            	  1295: TRIANGLE:
00:00006CBC 61000114        	  1296: 	bsr INT_EXPR
00:00006CC0 61000B62        	  1297: 	bsr	TSTC							; it must be followed by a comma
00:00006CC4 2C              	  1298: 	DC.B	',',TRIERR-*
00:00006CC5 57
00:00006CC6 2F00            	  1299: 	move.l d0,-(sp)
00:00006CC8 61000108        	  1300: 	bsr INT_EXPR
00:00006CCC 61000B56        	  1301: 	bsr	TSTC							; it must be followed by a comma
00:00006CD0 2C              	  1302: 	DC.B	',',TRIERR1-*
00:00006CD1 4F
00:00006CD2 2F00            	  1303: 	move.l d0,-(sp)	
00:00006CD4 610000FC        	  1304: 	bsr INT_EXPR
00:00006CD8 61000B4A        	  1305: 	bsr	TSTC							; it must be followed by a comma
00:00006CDC 2C              	  1306: 	DC.B	',',TRIERR2-*
00:00006CDD 49
00:00006CDE 2F00            	  1307: 	move.l d0,-(sp)
00:00006CE0 610000F0        	  1308: 	bsr INT_EXPR
00:00006CE4 61000B3E        	  1309: 	bsr	TSTC							; it must be followed by a comma
00:00006CE8 2C              	  1310: 	DC.B	',',TRIERR3-*
00:00006CE9 43
00:00006CEA 2F00            	  1311: 	move.l d0,-(sp)
00:00006CEC 610000E4        	  1312: 	bsr INT_EXPR
00:00006CF0 61000B32        	  1313: 	bsr	TSTC							; it must be followed by a comma
00:00006CF4 2C              	  1314: 	DC.B	',',TRIERR4-*
00:00006CF5 3F
00:00006CF6 2F00            	  1315: 	move.l d0,-(sp)
00:00006CF8 610000D8        	  1316: 	bsr INT_EXPR
00:00006CFC 2A1F            	  1317: 	move.l (sp)+,d5
00:00006CFE 281F            	  1318: 	move.l (sp)+,d4
00:00006D00 261F            	  1319: 	move.l (sp)+,d3
00:00006D02 241F            	  1320: 	move.l (sp)+,d2
00:00006D04 221F            	  1321: 	move.l (sp)+,d1
00:00006D06 4841            	  1322: 	swap d1
00:00006D08 4842            	  1323: 	swap d2
00:00006D0A 4843            	  1324: 	swap d3
00:00006D0C 4844            	  1325: 	swap d4
00:00006D0E 4845            	  1326: 	swap d5
00:00006D10 4840            	  1327: 	swap d0
00:00006D12 7E07            	  1328: 	moveq #7,d7
00:00006D14 7C1D            	  1329: 	moveq #DEV_DRAW_TRIANGLE,d6
00:00006D16 4E40            	  1330: 	trap #0
00:00006D18 6000FA70        	  1331: 	bra FINISH
                            	  1332: TRIERR
00:00006D1C 600008BE        	  1333: 	bra QWHAT
                            	  1334: TRIERR1
00:00006D20 588F            	  1335: 	add.l #4,sp
00:00006D22 600008B8        	  1336: 	bra QWHAT
                            	  1337: TRIERR2
00:00006D26 508F            	  1338: 	add.l #8,sp
00:00006D28 600008B2        	  1339: 	bra QWHAT
                            	  1340: TRIERR3
00:00006D2C 4FEF000C        	  1341: 	add.l #12,sp
00:00006D30 600008AA        	  1342: 	bra QWHAT
                            	  1343: TRIERR4
00:00006D34 4FEF0010        	  1344: 	add.l #16,sp
00:00006D38 600008A2        	  1345: 	bra QWHAT
                            	  1346: 
                            	  1347: CURVE:
00:00006D3C 61000094        	  1348: 	bsr INT_EXPR
00:00006D40 61000AE2        	  1349: 	bsr	TSTC							; it must be followed by a comma
00:00006D44 2C              	  1350: 	DC.B	',',TRIERR-*
00:00006D45 D7
00:00006D46 2F00            	  1351: 	move.l d0,-(sp)
00:00006D48 61000088        	  1352: 	bsr INT_EXPR
00:00006D4C 61000AD6        	  1353: 	bsr	TSTC							; it must be followed by a comma
00:00006D50 2C              	  1354: 	DC.B	',',TRIERR1-*
00:00006D51 CF
00:00006D52 2F00            	  1355: 	move.l d0,-(sp)	
00:00006D54 617C            	  1356: 	bsr INT_EXPR
00:00006D56 61000ACC        	  1357: 	bsr	TSTC							; it must be followed by a comma
00:00006D5A 2C              	  1358: 	DC.B	',',TRIERR2-*
00:00006D5B CB
00:00006D5C 2F00            	  1359: 	move.l d0,-(sp)
00:00006D5E 6172            	  1360: 	bsr INT_EXPR
00:00006D60 61000AC2        	  1361: 	bsr	TSTC							; it must be followed by a comma
00:00006D64 2C              	  1362: 	DC.B	',',TRIERR3-*
00:00006D65 C7
00:00006D66 2F00            	  1363: 	move.l d0,-(sp)
00:00006D68 6168            	  1364: 	bsr INT_EXPR
00:00006D6A 61000AB8        	  1365: 	bsr	TSTC							; it must be followed by a comma
00:00006D6E 2C              	  1366: 	DC.B	',',TRIERR4-*
00:00006D6F C5
00:00006D70 2F00            	  1367: 	move.l d0,-(sp)
00:00006D72 615E            	  1368: 	bsr INT_EXPR
00:00006D74 2A1F            	  1369: 	move.l (sp)+,d5
00:00006D76 281F            	  1370: 	move.l (sp)+,d4
00:00006D78 261F            	  1371: 	move.l (sp)+,d3
00:00006D7A 241F            	  1372: 	move.l (sp)+,d2
00:00006D7C 221F            	  1373: 	move.l (sp)+,d1
00:00006D7E 4841            	  1374: 	swap d1
00:00006D80 4842            	  1375: 	swap d2
00:00006D82 4843            	  1376: 	swap d3
00:00006D84 4844            	  1377: 	swap d4
00:00006D86 4845            	  1378: 	swap d5
00:00006D88 4840            	  1379: 	swap d0
00:00006D8A 7E07            	  1380: 	moveq #7,d7
00:00006D8C 7C1F            	  1381: 	moveq #DEV_DRAW_CURVE,d6
00:00006D8E 4E40            	  1382: 	trap #0
00:00006D90 6000F9F8        	  1383: 	bra FINISH
                            	  1384: 
                            	  1385: 	
                            	  1386: ;******************************************************************
                            	  1387: ;
                            	  1388: ; *** EXPR ***
                            	  1389: ;
                            	  1390: ; 'EXPR' evaluates arithmetical or logical expressions.
                            	  1391: ; <EXPR>::=<EXPR2>
                            	  1392: ;	   <EXPR2><rel.op.><EXPR2>
                            	  1393: ; where <rel.op.> is one of the operators in TAB8 and the result
                            	  1394: ; of these operations is 1 if true and 0 if false.
                            	  1395: ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                            	  1396: ; where () are optional and (... are optional repeats.
                            	  1397: ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                            	  1398: ; <EXPR4>::=<variable>
                            	  1399: ;	    <function>
                            	  1400: ;	    (<EXPR>)
                            	  1401: ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                            	  1402: ; as an index, functions can have an <EXPR> as arguments, and
                            	  1403: ; <EXPR4> can be an <EXPR> in parenthesis.
                            	  1404: 
                            	  1405: ;-------------------------------------------------------------------------------
                            	  1406: ; Push a value on the stack.
                            	  1407: ;-------------------------------------------------------------------------------
                            	  1408: 
                            	  1409: XP_PUSH:
00:00006D94 225F            	  1410: 	move.l (sp)+,a1				; a1 = return address
                            	  1411: ;	move.l _canary,-(sp)	; push the canary
00:00006D96 4FEFFFF0        	  1412: 	sub.l #16,sp					; allocate for value
00:00006D9A 2E80            	  1413: 	move.l d0,(sp)				; push data type
00:00006D9C F22F68000004    	  1414: 	fmove.x fp0,4(sp)			; and value
00:00006DA2 4ED1            	  1415: 	jmp (a1)
                            	  1416: 
                            	  1417: ;-------------------------------------------------------------------------------
                            	  1418: ; Pop value from stack into first operand.
                            	  1419: ;-------------------------------------------------------------------------------
                            	  1420: 	
                            	  1421: XP_POP:
00:00006DA4 225F            	  1422: 	move.l (sp)+,a1			; get return address
00:00006DA6 2017            	  1423: 	move.l (sp),d0			; pop data type
00:00006DA8 F22F48000004    	  1424: 	fmove.x 4(sp),fp0		; and data element
00:00006DAE 4FEF0010        	  1425: 	add.l #16,sp
                            	  1426: ;	cchk (sp)						; check the canary
                            	  1427: ;	add.l #4,sp					; pop canary	
00:00006DB2 4ED1            	  1428: 	jmp (a1)
                            	  1429: 
                            	  1430: ;-------------------------------------------------------------------------------
                            	  1431: ; Pop value from stack into second operand.
                            	  1432: ;-------------------------------------------------------------------------------
                            	  1433: 
                            	  1434: XP_POP1:
00:00006DB4 225F            	  1435: 	move.l (sp)+,a1			; get return address
00:00006DB6 2217            	  1436: 	move.l (sp),d1			; pop data type
00:00006DB8 F22F48800004    	  1437: 	fmove.x 4(sp),fp1		; and data element
00:00006DBE 4FEF0010        	  1438: 	add.l #16,sp
                            	  1439: ;	cchk (sp)						; check the canary
                            	  1440: ;	add.l #4,sp					; pop canary
00:00006DC2 4ED1            	  1441: 	jmp (a1)
                            	  1442: 
                            	  1443: ;-------------------------------------------------------------------------------
                            	  1444: ; Get and expression and make sure it is numeric.
                            	  1445: ;-------------------------------------------------------------------------------
                            	  1446: 
                            	  1447: NUM_EXPR:
00:00006DC4 611E            	  1448: 	bsr EXPR
00:00006DC6 0C8000000001    	  1449: 	cmpi.l #DT_NUMERIC,d0
00:00006DCC 6600085E        	  1450: 	bne ETYPE
00:00006DD0 4E75            	  1451: 	rts
                            	  1452: 
                            	  1453: ;-------------------------------------------------------------------------------
                            	  1454: ; Get and expression and make sure it is numeric. Convert to integer.
                            	  1455: ;-------------------------------------------------------------------------------
                            	  1456: 
                            	  1457: INT_EXPR:
00:00006DD2 6110            	  1458: 	bsr EXPR
00:00006DD4 0C8000000001    	  1459: 	cmpi.l #DT_NUMERIC,d0
00:00006DDA 66000850        	  1460: 	bne ETYPE
00:00006DDE F2006000        	  1461: 	fmove.l fp0,d0
00:00006DE2 4E75            	  1462: 	rts
                            	  1463: 
                            	  1464: ;-------------------------------------------------------------------------------
                            	  1465: ; The top level of the expression parser.
                            	  1466: ; Get an expression, string or numeric.
                            	  1467: ;
                            	  1468: ; EXEC will smash a lot of regs, so push the current expression value before
                            	  1469: ; doing EXEC
                            	  1470: ;-------------------------------------------------------------------------------
                            	  1471: 
                            	  1472: EXPR:
                            	  1473: EXPR_OR:
00:00006DE4 6124            	  1474: 	BSR EXPR_AND
00:00006DE6 61AC            	  1475: 	BSR XP_PUSH
00:00006DE8 43FAF658        	  1476: 	LEA TAB10,A1
00:00006DEC 45FAF766        	  1477: 	LEA TAB10_1,A2
00:00006DF0 6000F78A        	  1478: 	BRA EXEC
                            	  1479: 	
                            	  1480: ;-------------------------------------------------------------------------------
                            	  1481: ; Boolean 'Or' level
                            	  1482: ;-------------------------------------------------------------------------------
                            	  1483: 
                            	  1484: XP_OR:
00:00006DF4 6114            	  1485: 	bsr EXPR_AND
00:00006DF6 61BC            	  1486: 	bsr XP_POP1
00:00006DF8 613C            	  1487: 	bsr CheckNumeric
00:00006DFA F2036080        	  1488: 	fmove.L FP1,D3
00:00006DFE F2026000        	  1489: 	fmove.L FP0,D2
00:00006E02 8483            	  1490: 	or.L D3,D2
00:00006E04 F2024000        	  1491: 	fmove.L D2,FP0
00:00006E08 4E75            	  1492: 	rts
                            	  1493: 	
                            	  1494: ;-------------------------------------------------------------------------------
                            	  1495: ; Boolean 'And' level
                            	  1496: ;-------------------------------------------------------------------------------
                            	  1497: 
                            	  1498: EXPR_AND:
00:00006E0A 613C            	  1499: 	bsr EXPR_REL
00:00006E0C 6186            	  1500: 	bsr XP_PUSH
00:00006E0E 43FAF62E        	  1501: 	LEA TAB9,A1
00:00006E12 45FAF738        	  1502: 	LEA TAB9_1,A2
00:00006E16 6000F764        	  1503: 	BRA EXEC
                            	  1504: 
                            	  1505: XP_AND:
00:00006E1A 612C            	  1506: 	BSR EXPR_REL
00:00006E1C 6196            	  1507: 	bsr XP_POP1
00:00006E1E 6116            	  1508: 	bsr CheckNumeric
00:00006E20 F2036080        	  1509: 	FMOVE.L FP1,D3
00:00006E24 F2026000        	  1510: 	FMOVE.L FP0,D2
00:00006E28 C483            	  1511: 	AND.L D3,D2
00:00006E2A F2024000        	  1512: 	FMOVE.L D2,FP0
00:00006E2E 4E75            	  1513: 	RTS
                            	  1514: 	
                            	  1515: XP_ANDX:
                            	  1516: XP_ORX
00:00006E30 6100FF72        	  1517: 	bsr XP_POP
00:00006E34 4E75            	  1518: 	rts
                            	  1519: 
                            	  1520: ;-------------------------------------------------------------------------------
                            	  1521: ; Check that two numeric values are being used.
                            	  1522: ;-------------------------------------------------------------------------------
                            	  1523: 
                            	  1524: CheckNumeric:
00:00006E36 0C010001        	  1525: 	CMPI.B #DT_NUMERIC,D1
00:00006E3A 660007F0        	  1526: 	BNE ETYPE
00:00006E3E 0C000001        	  1527: 	CMPI.B #DT_NUMERIC,D0
00:00006E42 660007E8        	  1528: 	BNE ETYPE
00:00006E46 4E75            	  1529: 	RTS
                            	  1530: 
                            	  1531: ;-------------------------------------------------------------------------------
                            	  1532: ; Relational operator level, <,<=,>=,>,=,<>
                            	  1533: ;-------------------------------------------------------------------------------
                            	  1534: 
                            	  1535: EXPR_REL:
00:00006E48 61000088        	  1536: 	bsr	EXPR2
00:00006E4C 6100FF46        	  1537: 	bsr XP_PUSH
00:00006E50 43FAF5E1        	  1538: 	LEA	TAB8,A1 				; look up a relational operator
00:00006E54 45FAF6DA        	  1539: 	LEA	TAB8_1,A2
00:00006E58 6000F722        	  1540: 	bra	EXEC		go do it
                            	  1541: 
                            	  1542: XP11:
00:00006E5C 6100FF46        	  1543: 	bsr XP_POP
00:00006E60 615C            	  1544: 	BSR	XP18		is it ">="?
00:00006E62 F2940044        	  1545: 	FBLT XPRT0		no, return D0=0
00:00006E66 6048            	  1546: 	BRA	XPRT1		else return D0=1
                            	  1547: 
                            	  1548: XP12:
00:00006E68 6100FF3A        	  1549: 	bsr XP_POP
00:00006E6C 6150            	  1550: 	BSR	XP18		is it "<>"?
00:00006E6E F2810038        	  1551: 	FBEQ XPRT0		no, return D0=0
00:00006E72 603C            	  1552: 	BRA	XPRT1		else return D0=1
                            	  1553: 
                            	  1554: XP13:
00:00006E74 6100FF2E        	  1555: 	bsr XP_POP
00:00006E78 6144            	  1556: 	BSR	XP18		is it ">"?
00:00006E7A F295002C        	  1557: 	FBLE XPRT0		no, return D0=0
00:00006E7E 6030            	  1558: 	BRA	XPRT1		else return D0=1
                            	  1559: 
                            	  1560: XP14:
00:00006E80 6100FF22        	  1561: 	bsr XP_POP
00:00006E84 6138            	  1562: 	BSR	XP18		;is it "<="?
00:00006E86 F2920020        	  1563: 	FBGT XPRT0	;	no, return D0=0
00:00006E8A 6024            	  1564: 	BRA	XPRT1		;else return D0=1
                            	  1565: 
                            	  1566: XP15:
00:00006E8C 6100FF16        	  1567: 	bsr XP_POP
00:00006E90 612C            	  1568: 	BSR	XP18		; is it "="?
00:00006E92 F28E0014        	  1569: 	FBNE XPRT0	;	if not, return D0=0
00:00006E96 6018            	  1570: 	BRA	XPRT1		;else return D0=1
                            	  1571: XP15RT
00:00006E98 4E75            	  1572: 	RTS
                            	  1573: 
                            	  1574: XP16:
00:00006E9A 6100FF08        	  1575: 	bsr XP_POP
00:00006E9E 611E            	  1576: 	BSR	XP18		; is it "<"?
00:00006EA0 F2930006        	  1577: 	FBGE XPRT0	;	if not, return D0=0
00:00006EA4 600A            	  1578: 	BRA	XPRT1		; else return D0=1
00:00006EA6 4E75            	  1579: 	RTS
                            	  1580: 
                            	  1581: XPRT0:
00:00006EA8 F23C58000000    	  1582: 	FMOVE.B #0,FP0	; return fp0 = 0 (false)
00:00006EAE 4E75            	  1583: 	RTS
                            	  1584: 
                            	  1585: XPRT1:
00:00006EB0 F23C58000001    	  1586: 	FMOVE.B #1,FP0	; return fp0 = 1 (true)
00:00006EB6 4E75            	  1587: 	RTS
                            	  1588: 
                            	  1589: XP17:								; it's not a rel. operator
00:00006EB8 6100FEEA        	  1590: 	bsr XP_POP				;	return FP0=<EXPR2>
00:00006EBC 4E75            	  1591: 	rts
                            	  1592: 
                            	  1593: XP18:
00:00006EBE 6100FED4        	  1594: 	bsr XP_PUSH
00:00006EC2 610E            	  1595: 	bsr	EXPR2					; do second <EXPR2>
00:00006EC4 6100FEEE        	  1596: 	bsr XP_POP1
00:00006EC8 6100FF6C        	  1597: 	bsr CheckNumeric
00:00006ECC F20000B8        	  1598: 	fcmp fp0,fp1			; compare with the first result
00:00006ED0 4E75            	  1599: 	rts								; return the result
                            	  1600: 
                            	  1601: ;-------------------------------------------------------------------------------
                            	  1602: ; Add/Subtract operator level, +,-
                            	  1603: ;-------------------------------------------------------------------------------
                            	  1604: 
                            	  1605: EXPR2
00:00006ED2 61000950        	  1606: 	bsr	TSTC		; negative sign?
00:00006ED6 2D              	  1607: 	DC.B	'-',XP21-*
00:00006ED7 09
00:00006ED8 F23C58000000    	  1608: 	FMOVE.B #0,FP0
00:00006EDE 604C            	  1609: 	BRA	XP26
                            	  1610: XP21	
00:00006EE0 61000942        	  1611: 	bsr	TSTC		; positive sign? ignore it
00:00006EE4 2B              	  1612: 	DC.B	'+',XP22-*
00:00006EE5 01
                            	  1613: XP22
00:00006EE6 610000C8        	  1614: 	BSR	EXPR3		; first <EXPR3>
                            	  1615: XP23
00:00006EEA 61000938        	  1616: 	bsr	TSTC		; add?
00:00006EEE 2B              	  1617: 	DC.B	'+',XP25-*
00:00006EEF 37
00:00006EF0 6100FEA2        	  1618: 	bsr XP_PUSH
00:00006EF4 610000BA        	  1619: 	BSR	EXPR3					; get the second <EXPR3>
                            	  1620: XP24
00:00006EF8 6100FEBA        	  1621: 	bsr XP_POP1
00:00006EFC B03C0001        	  1622: 	CMP.B #DT_NUMERIC,d0
00:00006F00 660C            	  1623: 	BNE .notNum
00:00006F02 B23C0001        	  1624: 	CMP.B #DT_NUMERIC,d1
00:00006F06 6606            	  1625: 	BNE .notNum
00:00006F08 F2000422        	  1626: 	FADD FP1,FP0			; add it to the first <EXPR3>
                            	  1627: ;	FBVS	QHOW		branch if there's an overflow
00:00006F0C 60DC            	  1628: 	BRA	XP23		else go back for more operations
                            	  1629: .notNum
00:00006F0E B0BC00000002    	  1630: 	cmp.l #DT_STRING,d0
00:00006F14 66000716        	  1631: 	bne ETYPE
00:00006F18 B2BC00000002    	  1632: 	cmp.l #DT_STRING,d1
00:00006F1E 6600070C        	  1633: 	bne ETYPE
00:00006F22 611E            	  1634: 	bsr ConcatString
00:00006F24 4E75            	  1635: 	rts
                            	  1636: 
                            	  1637: XP25
00:00006F26 610008FC        	  1638: 	bsr	TSTC							; subtract?
00:00006F2A 2D              	  1639: 	dc.b	'-',XP27-*
00:00006F2B 15
                            	  1640: XP26
00:00006F2C 6100FE66        	  1641: 	bsr XP_PUSH
00:00006F30 617E            	  1642: 	BSR	EXPR3					; get second <EXPR3>
00:00006F32 0C000001        	  1643: 	cmpi.b #DT_NUMERIC,d0
00:00006F36 660006F4        	  1644: 	bne ETYPE
00:00006F3A F200001A        	  1645: 	FNEG FP0					; change its sign
00:00006F3E 60B8            	  1646: 	JMP	XP24					; and do an addition
                            	  1647: 
                            	  1648: XP27
00:00006F40 4E75            	  1649: 	rts
                            	  1650: 
                            	  1651: ;-------------------------------------------------------------------------------
                            	  1652: ; Concatonate strings, for the '+' operator.
                            	  1653: ;
                            	  1654: ; Parameters:
                            	  1655: ;		fp0 = holds string descriptor for second string
                            	  1656: ;		fp1 = holds string descriptor for first string
                            	  1657: ;	Returns:
                            	  1658: ;		fp0 = string descriptor for combined strings
                            	  1659: ;-------------------------------------------------------------------------------
                            	  1660: 
                            	  1661: ConcatString:
00:00006F42 F239688000040600	  1662: 	fmove.x fp1,_fpWork		; save first string descriptor to memory
00:00006F4A F239680000040610	  1663: 	fmove.x fp0,_fpWork+16; save second string descriptor to memory
00:00006F52 343900040600    	  1664: 	move.w _fpWork,d2			; d2 = length of first string
00:00006F58 D47900040610    	  1665: 	add.w	_fpWork+16,d2		; add length of second string
00:00006F5E 48C2            	  1666: 	ext.l d2							; make d2 a long word
00:00006F60 61000164        	  1667: 	bsr AllocateString		; allocate
00:00006F64 2849            	  1668: 	move.l a1,a4					; a4 = allocated string, saved for later
00:00006F66 2449            	  1669: 	move.l a1,a2					; a2 = allocated string
00:00006F68 3542FFFE        	  1670: 	move.w d2,-2(a2)			; save length of new string (a2)
00:00006F6C 227900040604    	  1671: 	move.l _fpWork+4,a1		; a1 = pointer to string text of first string
00:00006F72 2649            	  1672: 	move.l a1,a3					; compute pointer to end of first string
00:00006F74 363900040600    	  1673: 	move.w _fpWork,d3			; d3 = length of first string
00:00006F7A 48C3            	  1674: 	ext.l d3
00:00006F7C D7C3            	  1675: 	add.l d3,a3						; add length of first string
00:00006F7E 61000786        	  1676: 	bsr MVUP							; move from A1 to A2 until A1=A3
00:00006F82 227900040614    	  1677: 	move.l _fpWork+20,a1	; a1 = pointer to second string text
00:00006F88 2649            	  1678: 	move.l a1,a3
00:00006F8A 363900040610    	  1679: 	move.w _fpWork+16,d3	; d3 = length of second string
00:00006F90 48C3            	  1680: 	ext.l d3
00:00006F92 D7C3            	  1681: 	add.l d3,a3						; a3 points to end of second string
00:00006F94 61000770        	  1682: 	bsr MVUP							; concatonate on second string
00:00006F98 33C200040600    	  1683: 	move.w d2,_fpWork			; save total string length in fp work
00:00006F9E 23CC00040604    	  1684: 	move.l a4,_fpWork+4		; save pointer in fp work area
00:00006FA4 7002            	  1685: 	moveq #DT_STRING,d0		; set return data type = string
00:00006FA6 F239480000040600	  1686: 	fmove.x _fpWork,fp0		; fp0 = string descriptor
00:00006FAE 4E75            	  1687: 	rts
                            	  1688: 
                            	  1689: ;-------------------------------------------------------------------------------
                            	  1690: ; Multiply / Divide operator level, *,/,mod
                            	  1691: ;-------------------------------------------------------------------------------
                            	  1692: 
                            	  1693: EXPR3:
00:00006FB0 6168            	  1694: 	bsr	EXPR4					; get first <EXPR4>
                            	  1695: XP36
00:00006FB2 6100FDE0        	  1696: 	bsr XP_PUSH
                            	  1697: XP30
00:00006FB6 43FAF48D        	  1698: 	lea TAB11,a1
00:00006FBA 45FAF5A0        	  1699: 	lea TAB11_1,a2
00:00006FBE 6000F5BC        	  1700: 	bra EXEC
                            	  1701: XP31
00:00006FC2 61000860        	  1702: 	bsr	TSTC					; multiply?
00:00006FC6 2A              	  1703: 	dc.b	'*',XP34-*
00:00006FC7 11
00:00006FC8 6150            	  1704: 	bsr	EXPR4					; get second <EXPR4>
00:00006FCA 6100FDE8        	  1705: 	bsr XP_POP1
00:00006FCE 6100FE66        	  1706: 	bsr CheckNumeric
00:00006FD2 F2000423        	  1707: 	fmul fp1,fp0			; multiply the two
00:00006FD6 60DA            	  1708: 	bra	XP36					; then look for more terms
                            	  1709: XP34
00:00006FD8 6100084A        	  1710: 	bsr	TSTC					; divide?
00:00006FDC 2F              	  1711: 	dc.b	'/',XP35-*
00:00006FDD 15
00:00006FDE 613A            	  1712: 	bsr	EXPR4					; get second <EXPR4>
00:00006FE0 6100FDD2        	  1713: 	bsr XP_POP1
00:00006FE4 6100FE50        	  1714: 	bsr CheckNumeric
00:00006FE8 F20000A0        	  1715: 	fdiv fp0,fp1			; do the division
00:00006FEC F2000400        	  1716: 	fmove fp1,fp0
00:00006FF0 60C0            	  1717: 	bra	XP36					; go back for any more terms
                            	  1718: XP35
00:00006FF2 6100FDB0        	  1719: 	bsr XP_POP
00:00006FF6 4E75            	  1720: 	rts
                            	  1721: XP_MOD:
00:00006FF8 6120            	  1722: 	bsr EXPR4
00:00006FFA 6100FDB8        	  1723: 	bsr XP_POP1
00:00006FFE F20000A0        	  1724: 	fdiv fp0,fp1			; divide
00:00007002 F2006080        	  1725: 	fmove.l fp1,d0		; convert to integer
00:00007006 F2004180        	  1726: 	fmove.l d0,fp3		; convert back to float
00:0000700A F20001A3        	  1727: 	fmul fp0,fp3			; multiply quotient times divisor
00:0000700E F2000CA8        	  1728: 	fsub fp3,fp1			; subtract from original number
00:00007012 F2000400        	  1729: 	fmove.x fp1,fp0		; return difference in fp0
00:00007016 7001            	  1730: 	moveq #DT_NUMERIC,d0
00:00007018 6098            	  1731: 	bra XP36					; go back and check for more multiply ops
                            	  1732: 	
                            	  1733: ;-------------------------------------------------------------------------------
                            	  1734: ; Lowest Level of expression evaluation.
                            	  1735: ;	Check for
                            	  1736: ;		a function or
                            	  1737: ;		a variable or
                            	  1738: ;		a number or
                            	  1739: ;		a string or
                            	  1740: ;		( expr )
                            	  1741: ;-------------------------------------------------------------------------------
                            	  1742: 
                            	  1743: EXPR4:
00:0000701A 43FAF3DD        	  1744: 	LEA	TAB4,A1 			; find possible function
00:0000701E 45FAF4CC        	  1745: 	LEA	TAB4_1,A2
00:00007022 6000F558        	  1746: 	BRA	EXEC
                            	  1747: XP40
00:00007026 61000236        	  1748: 	bsr	TSTV					; nope, not a function
00:0000702A 650C            	  1749: 	bcs	XP41					; nor a variable
00:0000702C 2240            	  1750: 	move.l d0,a1			; a1 = variable address
00:0000702E 2011            	  1751: 	move.l (a1),d0		; return type in d0
00:00007030 F22948000004    	  1752: 	fmove.x 4(a1),fp0	; if a variable, return its value in fp0
                            	  1753: EXP4RT
00:00007036 4E75            	  1754: 	rts
                            	  1755: XP41
00:00007038 61000802        	  1756: 	bsr	TSTNUM				; or is it a number?
00:0000703C F2000400        	  1757: 	fmove fp1,fp0
00:00007040 0C8000000001    	  1758: 	cmpi.l #DT_NUMERIC,d0
00:00007046 67EE            	  1759: 	beq	EXP4RT				; if so, return it in FP0
                            	  1760: XPSTNG
00:00007048 610007DA        	  1761: 	bsr TSTC					; is it a string constant?
00:0000704C 22              	  1762: 	dc.b '"',XP44-*
00:0000704D 57
00:0000704E 163C0022        	  1763: 	move.b #'"',d3
                            	  1764: XP45
00:00007052 2248            	  1765: 	move.l a0,a1			; record start of string in a1
00:00007054 243C000001FF    	  1766: 	move.l #511,d2		; max 512 characters
                            	  1767: .0003	
00:0000705A 1018            	  1768: 	move.b (a0)+,d0		; get a character
00:0000705C 670E            	  1769: 	beq .0001					; should not be a NULL
00:0000705E 0C00000D        	  1770: 	cmpi.b #CR,d0			; CR means the end of line was hit without a close quote
00:00007062 6708            	  1771: 	beq .0001
00:00007064 B003            	  1772: 	cmp.b d3,d0				; close quote?
00:00007066 6708            	  1773: 	beq .0002
00:00007068 51CAFFF0        	  1774: 	dbra d2,.0003			; no close quote, go back for next char
                            	  1775: .0001
00:0000706C 600005B6        	  1776: 	bra QHOW
                            	  1777: .0002
00:00007070 2008            	  1778: 	move.l a0,d0				; d0 = end of string pointer
00:00007072 9089            	  1779: 	sub.l a1,d0					; compute string length + 1
00:00007074 5340            	  1780: 	subq #1,d0					; subtract out closing quote
00:00007076 2400            	  1781: 	move.l d0,d2				; d2 = string length
00:00007078 2649            	  1782: 	move.l a1,a3				; a3 = pointer to string text
00:0000707A 614A            	  1783: 	bsr AllocateString
00:0000707C 2449            	  1784: 	move.l a1,a2				; a2 points to new text area
00:0000707E 2849            	  1785: 	move.l a1,a4				; save a1 for later
00:00007080 224B            	  1786: 	move.l a3,a1				; a1 = pointer to string in program
00:00007082 3542FFFE        	  1787: 	move.w d2,-2(a2)		; copy length into place
00:00007086 D7C2            	  1788: 	add.l d2,a3					; a3 points to end of string
00:00007088 6100067C        	  1789: 	bsr MVUP						; move from A1 to A2 until A1=A3
00:0000708C 33C200040600    	  1790: 	move.w d2,_fpWork		; copy length into place
00:00007092 23CC00040604    	  1791: 	move.l a4,_fpWork+4	; copy pointer to text into place
00:00007098 F239480000040600	  1792: 	fmove.x _fpWork,fp0	; put string descriptor into fp0
00:000070A0 7002            	  1793: 	moveq #DT_STRING,d0	; return string data type
00:000070A2 4E75            	  1794: 	rts
                            	  1795: XP44
00:000070A4 6100077E        	  1796: 	bsr TSTC					; alternate string constant?
00:000070A8 27              	  1797: 	dc.b '''',PARN-*
00:000070A9 07
00:000070AA 163C0027        	  1798: 	move.b #'''',d3
00:000070AE 60A2            	  1799: 	bra XP45
                            	  1800: PARN
00:000070B0 61000772        	  1801: 	bsr	TSTC					; else look for ( EXPR )
00:000070B4 28              	  1802: 	dc.b '(',XP43-*
00:000070B5 0D
00:000070B6 6100FD2C        	  1803: 	bsr	EXPR
00:000070BA 61000768        	  1804: 	bsr	TSTC
00:000070BE 29              	  1805: 	dc.b ')',XP43-*
00:000070BF 03
                            	  1806: XP42	
00:000070C0 4E75            	  1807: 	rts
                            	  1808: XP43
00:000070C2 60000518        	  1809: 	bra	QWHAT					; else say "What?"
                            	  1810: 
                            	  1811: ;-------------------------------------------------------------------------------	
                            	  1812: ; Allocate storage for a string variable.
                            	  1813: ;
                            	  1814: ; Parameters:
                            	  1815: ;		d2 = number of bytes needed
                            	  1816: ; Returns:
                            	  1817: ;		a1 = pointer to string text area
                            	  1818: ;-------------------------------------------------------------------------------	
                            	  1819: 
                            	  1820: AllocateString:
00:000070C6 48E7383C        	  1821: 	movem.l d2-d4/a2-a5,-(sp)
00:000070CA 283A0964        	  1822: 	move.l VARBGN,d4
00:000070CE 227A0958        	  1823: 	move.l LastStr,a1			; a1 = last string
00:000070D2 3611            	  1824: 	move.w (a1),d3				; d3 = length of last string (0)
00:000070D4 48C3            	  1825: 	ext.l d3
00:000070D6 9883            	  1826: 	sub.l d3,d4						; subtract off length
00:000070D8 5784            	  1827: 	subq.l #3,d4					; size of length field+1 for rounding
00:000070DA 9889            	  1828: 	sub.l a1,d4						; and start position
00:000070DC B484            	  1829: 	cmp.l d4,d2						; is there enough room?
00:000070DE 6224            	  1830: 	bhi .needMoreRoom
                            	  1831: .0001
00:000070E0 227A0946        	  1832: 	move.l LastStr,a1
00:000070E4 2649            	  1833: 	move.l a1,a3
00:000070E6 5489            	  1834: 	addq.l #2,a1					; point a1 to text part of string
00:000070E8 3682            	  1835: 	move.w d2,(a3)				; save the length
00:000070EA D7C2            	  1836: 	add.l d2,a3
00:000070EC 568B            	  1837: 	addq.l #3,a3					; 2 for length field, 1 for rounding
00:000070EE 260B            	  1838: 	move.l a3,d3
00:000070F0 0283FFFFFFFE    	  1839: 	andi.l #$FFFFFFFE,d3	; make pointer even wyde
00:000070F6 23CB00007A28    	  1840: 	move.l a3,LastStr			; set new last str position
00:000070FC 4253            	  1841: 	clr.w (a3)						; set zero length
00:000070FE 4CDF3C1C        	  1842: 	movem.l (sp)+,d2-d4/a2-a5
00:00007102 4E75            	  1843: 	rts
                            	  1844: .needMoreRoom
00:00007104 611E            	  1845: 	bsr GarbageCollectStrings
00:00007106 283A0928        	  1846: 	move.l VARBGN,d4			; d4 = start of variables
00:0000710A 227A091C        	  1847: 	move.l LastStr,a1			; a1 = pointer to last string
00:0000710E 3611            	  1848: 	move.w (a1),d3				; d3 = length of last string (likely 0)
00:00007110 48C3            	  1849: 	ext.l d3
00:00007112 D689            	  1850: 	add.l a1,d3						; d3 = pointer past end of last string
00:00007114 5683            	  1851: 	addq.l #3,d3					; 2 for length, 1 for rounding
00:00007116 9883            	  1852: 	sub.l d3,d4						; free = VARBGN - LastStr+length of (LastStr)
00:00007118 B484            	  1853: 	cmp.l d4,d2						; request < free?
00:0000711A 65C4            	  1854: 	blo .0001
00:0000711C 4DFA089C        	  1855: 	lea NOSTRING,a6
00:00007120 600004C0        	  1856: 	bra ERROR
                            	  1857: 		
                            	  1858: ;-------------------------------------------------------------------------------	
                            	  1859: ; Garbage collect strings. This copies all strings in use to the lower end of
                            	  1860: ; the string area and adjusts the string pointers in variables and on the
                            	  1861: ; stack to point to the new location.
                            	  1862: ;
                            	  1863: ; Modifies:
                            	  1864: ;		none
                            	  1865: ;-------------------------------------------------------------------------------	
                            	  1866: 
                            	  1867: GarbageCollectStrings:
00:00007124 48E70074        	  1868: 	movem.l a1/a2/a3/a5,-(sp)
00:00007128 227A08FA        	  1869: 	move.l StrArea,a1			; source area pointer
00:0000712C 247A08F6        	  1870: 	move.l StrArea,a2			; target area pointer
00:00007130 2A7A08F6        	  1871: 	move.l LastStr,a5
                            	  1872: .0001
00:00007134 6140            	  1873: 	bsr StringInVar				; check if the string is used by a variable
00:00007136 6506            	  1874: 	bcs .moveString
00:00007138 610000A6        	  1875: 	bsr StringOnStack			; check if string is on string expression stack
00:0000713C 641C            	  1876: 	bcc .nextString				; if not on stack or in a var then move to next string
                            	  1877: 	
                            	  1878: 	; The string is in use, copy to active string area
                            	  1879: .moveString:
00:0000713E 610000D0        	  1880: 	bsr UpdateStringPointers	; update pointer to string on stack or in variable
00:00007142 611C            	  1881: 	bsr NextString				; a3 = pointer to next string
00:00007144 610005CA        	  1882: 	bsr MVUPW							; will copy the length and string text
                            	  1883: .0005
00:00007148 B3CD            	  1884: 	cmp.l a5,a1						; is it the last string?
00:0000714A 63E8            	  1885: 	bls .0001
00:0000714C 23CA00007A28    	  1886: 	move.l a2,LastStr			; update last string pointer
00:00007152 4252            	  1887: 	clr.w (a2)						; set zero length
00:00007154 4CDF2E00        	  1888: 	movem.l (sp)+,a1/a2/a3/a5
00:00007158 4E75            	  1889: 	rts
                            	  1890: .nextString:
00:0000715A 6104            	  1891: 	bsr NextString
00:0000715C 224B            	  1892: 	move.l a3,a1
00:0000715E 60E8            	  1893: 	bra .0005
                            	  1894: 
                            	  1895: ;-------------------------------------------------------------------------------	
                            	  1896: ; Parameters:
                            	  1897: ;		a1 - pointer to current string
                            	  1898: ; Returns:
                            	  1899: ;		a3 - pointer to next string
                            	  1900: ;-------------------------------------------------------------------------------	
                            	  1901: 
                            	  1902: NextString:
00:00007160 2F04            	  1903: 	move.l d4,-(sp)
00:00007162 3811            	  1904: 	move.w (a1),d4				; d4 = string length
00:00007164 48C4            	  1905: 	ext.l d4							; make d4 long
00:00007166 5684            	  1906: 	addq.l #3,d4					; plus 2 for length field, 1 for rounding
00:00007168 D889            	  1907: 	add.l a1,d4
00:0000716A 0284FFFFFFFE    	  1908: 	andi.l #$FFFFFFFE,d4	; make even wyde address
00:00007170 2644            	  1909: 	move.l d4,a3
00:00007172 281F            	  1910: 	move.l (sp)+,d4
00:00007174 4E75            	  1911: 	rts
                            	  1912: 
                            	  1913: ;-------------------------------------------------------------------------------	
                            	  1914: ; Check if a variable is using a string
                            	  1915: ;
                            	  1916: ; Modifies:
                            	  1917: ;		d2,d3,a4
                            	  1918: ; Parameters:
                            	  1919: ;		a1 = pointer to string descriptor
                            	  1920: ; Returns:
                            	  1921: ;		cf = 1 if string in use, 0 otherwise
                            	  1922: ;-------------------------------------------------------------------------------	
                            	  1923: 
                            	  1924: StringInVar:
                            	  1925: 	; check global vars
00:00007176 287A08B8        	  1926: 	move.l VARBGN,a4
00:0000717A 761F            	  1927: 	moveq #31,d3			; 32 vars
00:0000717C 6116            	  1928: 	bsr SIV1
                            	  1929: 	; now check local vars
00:0000717E 287A0868        	  1930: 	move.l STKFP,a4
                            	  1931: .0001
00:00007182 588C            	  1932: 	addq.l #4,a4			; point to variable area
00:00007184 7607            	  1933: 	moveq #7,d3
00:00007186 610C            	  1934: 	bsr SIV1					; check variable area
00:00007188 286CFFFC        	  1935: 	move.l -4(a4),a4	; get previous frame pointer
00:0000718C B9FAF06A        	  1936: 	cmp.l ENDMEM,a4
00:00007190 65F0            	  1937: 	blo .0001
00:00007192 4E75            	  1938: 	rts
                            	  1939: 
                            	  1940: ;-------------------------------------------------------------------------------	
                            	  1941: ; SIV1 - string in variable helper. This routine does a two-up return if the
                            	  1942: ; string is found in a variable. No need to keep searching.
                            	  1943: ;
                            	  1944: ; Modifies:
                            	  1945: ;		d2,d3,a4
                            	  1946: ; Parameters:
                            	  1947: ;		d3 = number of variables-1 to check
                            	  1948: ;		a4 = string space
                            	  1949: ;		a1 = pointer to string descriptor
                            	  1950: ; Returns:
                            	  1951: ;		cf = 1 if string in use, 0 otherwise
                            	  1952: ;-------------------------------------------------------------------------------	
                            	  1953: 
                            	  1954: SIV1:
                            	  1955: .0003
00:00007194 0C9400000002    	  1956: 	cmp.l #DT_STRING,(a4)
00:0000719A 6612            	  1957: 	bne .0004
00:0000719C 242C0008        	  1958: 	move.l 8(a4),d2
00:000071A0 5582            	  1959: 	subq.l #2,d2
00:000071A2 B3C2            	  1960: 	cmp.l d2,a1
00:000071A4 6608            	  1961: 	bne .0004
00:000071A6 588F            	  1962: 	addq.l #4,sp			; pop return address
00:000071A8 003C0001        	  1963: 	ori #1,ccr
00:000071AC 4E75            	  1964: 	rts								; do two up return
                            	  1965: .0004
00:000071AE 508C            	  1966: 	addq.l #8,a4			;  increment pointer by 16
00:000071B0 508C            	  1967: 	addq.l #8,a4
00:000071B2 51CBFFE0        	  1968: 	dbra d3,.0003
00:000071B6 023C00FE        	  1969: 	andi #$FE,ccr
00:000071BA 4E75            	  1970: 	rts
                            	  1971: 
                            	  1972: ;-------------------------------------------------------------------------------	
                            	  1973: ; Check if a value could be a pointer into the string area.
                            	  1974: ; Even if the data type indicated a string, it may not be. It could just be a
                            	  1975: ; coincidence. So check that the pointer portion is pointing into string
                            	  1976: ; memory. It is extremely unlikely to have a data type and a valid pointer
                            	  1977: ; match and it not be a string.
                            	  1978: ;
                            	  1979: ; Returns
                            	  1980: ;		d3 = pointer to string
                            	  1981: ;		cf=1 if points into string area, 0 otherwise
                            	  1982: ;-------------------------------------------------------------------------------	
                            	  1983: 
                            	  1984: PointsIntoStringArea:
00:000071BC 0C9400000002    	  1985: 	cmp.l #DT_STRING,(a4)		; is it a string data type?
00:000071C2 6616            	  1986: 	bne .0001
00:000071C4 262C0008        	  1987: 	move.l 8(a4),d3					; likely a string if
00:000071C8 B6BA085A        	  1988: 	cmp.l StrArea,d3				; flagged as a string, and pointer is into string area
00:000071CC 650C            	  1989: 	blo .0001
00:000071CE B6BA0860        	  1990: 	cmp.l VARBGN,d3
00:000071D2 6406            	  1991: 	bhs .0001
00:000071D4 003C0001        	  1992: 	ori #1,ccr
00:000071D8 4E75            	  1993: 	rts
                            	  1994: .0001
00:000071DA 023C00FE        	  1995: 	andi #$FE,ccr
00:000071DE 4E75            	  1996: 	rts
                            	  1997: 
                            	  1998: ;-------------------------------------------------------------------------------	
                            	  1999: ; Check if the string is a temporary on stack
                            	  2000: ;
                            	  2001: ; Parameters:
                            	  2002: ;		a3 = pointer to old string text area
                            	  2003: ; Returns:
                            	  2004: ;		cf = 1 if string in use, 0 otherwise
                            	  2005: ;-------------------------------------------------------------------------------	
                            	  2006: 
                            	  2007: StringOnStack:
00:000071E0 48E72028        	  2008: 	movem.l d2/a2/a4,-(sp)
00:000071E4 7607            	  2009: 	moveq #7,d3
00:000071E6 284F            	  2010: 	move.l sp,a4
                            	  2011: .0002
00:000071E8 61D2            	  2012: 	bsr PointsIntoStringArea
00:000071EA 6408            	  2013: 	bcc .0003
00:000071EC 242C0008        	  2014: 	move.l 8(a4),d2			; d2 = string text pointer
00:000071F0 B7C2            	  2015: 	cmp.l d2,a3					; compare string pointers
00:000071F2 6712            	  2016: 	beq .0001						; same pointer?
                            	  2017: .0003
00:000071F4 588C            	  2018: 	addq.l #4,a4				; bump pointer into stack
00:000071F6 B9FAF000        	  2019: 	cmp.l ENDMEM,a4			; have we hit end of stack yet?
00:000071FA 65EC            	  2020: 	blo .0002
00:000071FC 4CDF1404        	  2021: 	movem.l (sp)+,d2/a2/a4
00:00007200 023C00FE        	  2022: 	andi #$FE,ccr
00:00007204 4E75            	  2023: 	rts
                            	  2024: .0001
00:00007206 4CDF1404        	  2025: 	movem.l (sp)+,d2/a2/a4
00:0000720A 003C0001        	  2026: 	ori #1,ccr
00:0000720E 4E75            	  2027: 	rts
                            	  2028: 	
                            	  2029: ;-------------------------------------------------------------------------------	
                            	  2030: ; Update pointers to string to point to new area. All string areas must be
                            	  2031: ; completely checked because there may be more than one pointer to the string.
                            	  2032: ;
                            	  2033: ; Modifies:
                            	  2034: ;		d2,d3,d4,a4
                            	  2035: ; Parameters:
                            	  2036: ;		a1 = old pointer to string
                            	  2037: ;		a2 = new pointer to string
                            	  2038: ;-------------------------------------------------------------------------------	
                            	  2039: 
                            	  2040: UpdateStringPointers:
00:00007210 2F0B            	  2041: 	move.l a3,-(sp)
00:00007212 47E90002        	  2042: 	lea 2(a1),a3						; a3 points to old string text area
                            	  2043: 	; check global variable space
00:00007216 287A0818        	  2044: 	move.l VARBGN,a4
00:0000721A 761F            	  2045: 	moveq #31,d3						; 32 vars to check
00:0000721C 611E            	  2046: 	bsr USP1
                            	  2047: 	; check stack for strings
00:0000721E 284F            	  2048: 	move.l sp,a4						; start at stack bottom and work towards top
                            	  2049: .0002
00:00007220 619A            	  2050: 	bsr PointsIntoStringArea
00:00007222 640C            	  2051: 	bcc .0001
                            	  2052: 	; Here we probably have a string, one last check
00:00007224 B68A            	  2053: 	cmp.l a2,d3							; should be >= a2 as we are packing the space
00:00007226 6508            	  2054: 	blo .0001
00:00007228 294A0008        	  2055: 	move.l a2,8(a4)					; update pointer on stack with new address
00:0000722C 546C0008        	  2056: 	addi.w #2,8(a4)					; bump up to text part of string
                            	  2057: .0001
00:00007230 588C            	  2058: 	addq.l #4,a4
00:00007232 B9FAEFC4        	  2059: 	cmp.l ENDMEM,a4
00:00007236 65E8            	  2060: 	blo .0002
00:00007238 265F            	  2061: 	move.l (sp)+,a3
00:0000723A 4E75            	  2062: 	rts
                            	  2063: 
                            	  2064: ;-------------------------------------------------------------------------------	
                            	  2065: ; Both global and local variable spaces are updated in the same manner.
                            	  2066: ;
                            	  2067: ; Parameters:
                            	  2068: ;		a1 = old pointer to string
                            	  2069: ;		a2 = new pointer to string
                            	  2070: ;		a4 = start of string space
                            	  2071: ;		d3 = number of string variables
                            	  2072: ;-------------------------------------------------------------------------------	
                            	  2073: 
                            	  2074: USP1:
                            	  2075: .0002
00:0000723C 0C9400000002    	  2076: 	cmp.l #DT_STRING,(a4)		; check the data type
00:00007242 6610            	  2077: 	bne .0001								; not a string, go to next
00:00007244 242C0008        	  2078: 	move.l 8(a4),d2					; d2 = pointer to string text
00:00007248 B7C2            	  2079: 	cmp.l d2,a3							; does pointer match old pointer?
00:0000724A 6608            	  2080: 	bne .0001
00:0000724C 294A0008        	  2081: 	move.l a2,8(a4)					; copy in new pointer
00:00007250 54AC0008        	  2082: 	addi.l #2,8(a4)					; point to string text
                            	  2083: .0001
00:00007254 508C            	  2084: 	addq.l #8,a4						; increment pointer by 16
00:00007256 508C            	  2085: 	addq.l #8,a4
00:00007258 51CBFFE2        	  2086: 	dbra d3,.0002
00:0000725C 4E75            	  2087: 	rts
                            	  2088: 
                            	  2089: ;-------------------------------------------------------------------------------	
                            	  2090: ; ===== Test for a valid variable name.  Returns Carry=1 if not
                            	  2091: ;	found, else returns Carry=0 and the address of the
                            	  2092: ;	variable in D0.
                            	  2093: 
                            	  2094: TSTV:
00:0000725E 61000628        	  2095: 	bsr	IGNBLK
00:00007262 7000            	  2096: 	CLR.L	D0
00:00007264 1010            	  2097: 	MOVE.B (A0),D0 	 	; look at the program text
00:00007266 903C0040        	  2098: 	SUB.B	#'@',D0
00:0000726A 6572            	  2099: 	BCS	TSTVRT				; C=1: not a variable
00:0000726C 6638            	  2100: 	BNE	TV1						; branch if not "@" array
00:0000726E 5248            	  2101: 	ADDQ #1,A0				; If it is, it should be
00:00007270 6100FE3E        	  2102: 	BSR	PARN					; followed by (EXPR) as its index.
00:00007274 D080            	  2103: 	ADD.L	D0,D0
00:00007276 650003AC        	  2104: 	BCS	QHOW					; say "How?" if index is too big
00:0000727A D080            	  2105: 	ADD.L	D0,D0
00:0000727C 650003A6        	  2106: 	BCS	QHOW
00:00007280 D080            	  2107: 	ADD.L	D0,D0
00:00007282 650003A0        	  2108: 	BCS	QHOW
00:00007286 D080            	  2109: 	ADD.L	D0,D0
00:00007288 6500039A        	  2110: 	BCS	QHOW
00:0000728C 2F00            	  2111: 	move.l d0,-(sp)		; save the index
00:0000728E 6100012A        	  2112: 	bsr	SIZE					; get amount of free memory
00:00007292 221F            	  2113: 	move.l (sp)+,d1		; get back the index
00:00007294 F2006000        	  2114: 	fmove.l fp0,d0		; convert to integer
00:00007298 B081            	  2115: 	cmp.l	d1,d0				; see if there's enough memory
00:0000729A 63000380        	  2116: 	bls	QSORRY				; if not, say "Sorry"
00:0000729E 203A0790        	  2117: 	move.l VARBGN,d0	; put address of array element...
00:000072A2 9081            	  2118: 	sub.l	d1,d0				; into D0
00:000072A4 4E75            	  2119: 	rts
                            	  2120: TV1
00:000072A6 B03C001B        	  2121: 	CMP.B	#27,D0			; if not @, is it A through Z?
00:000072AA 0A3C0001        	  2122: 	EOR	#1,CCR
00:000072AE 652E            	  2123: 	BCS	TSTVRT				; if not, set Carry and return
00:000072B0 5248            	  2124: 	ADDQ #1,A0				; else bump the text pointer
00:000072B2 0C00004C        	  2125: 	cmpi.b #'L',d0		; is it a local? L0 to L7
00:000072B6 661E            	  2126: 	bne TV2
00:000072B8 1010            	  2127: 	move.b (a0),d0
00:000072BA 0C000030        	  2128: 	cmpi.b #'0',d0
00:000072BE 6516            	  2129: 	blo TV2
00:000072C0 0C000037        	  2130: 	cmpi.b #'7',d0
00:000072C4 6210            	  2131: 	bhi TV2
00:000072C6 903C0030        	  2132: 	sub.b #'0',d0
00:000072CA 5248            	  2133: 	addq #1,a0			; bump text pointer
00:000072CC E988            	  2134: 	lsl.l #4,d0			; *16 bytes per var
00:000072CE D0BA0718        	  2135: 	add.l STKFP,d0
00:000072D2 5880            	  2136: 	add.l #4,d0
00:000072D4 4E75            	  2137: 	rts
                            	  2138: TV2
00:000072D6 E988            	  2139: 	LSL.L #4,D0			; compute the variable's address
00:000072D8 223A0756        	  2140: 	MOVE.L VARBGN,D1
00:000072DC D081            	  2141: 	ADD.L	D1,D0			; and return it in D0 with Carry=0
                            	  2142: TSTVRT
00:000072DE 4E75            	  2143: 	RTS
                            	  2144: 
                            	  2145: 
                            	  2146: * ===== Divide the 32 bit value in D0 by the 32 bit value in D1.
                            	  2147: *	Returns the 32 bit quotient in D0, remainder in D1.
                            	  2148: *
                            	  2149: DIV32
00:000072E0 4A81            	  2150: 	TST.L	D1		check for divide-by-zero
00:000072E2 67000340        	  2151: 	BEQ	QHOW		if so, say "How?"
00:000072E6 2401            	  2152: 	MOVE.L	D1,D2
00:000072E8 2801            	  2153: 	MOVE.L	D1,D4
00:000072EA B184            	  2154: 	EOR.L	D0,D4		see if the signs are the same
00:000072EC 4A80            	  2155: 	TST.L	D0		take absolute value of D0
00:000072EE 6A02            	  2156: 	BPL	DIV1
00:000072F0 4480            	  2157: 	NEG.L	D0
00:000072F2 4A81            	  2158: DIV1	TST.L	D1		take absolute value of D1
00:000072F4 6A02            	  2159: 	BPL	DIV2
00:000072F6 4481            	  2160: 	NEG.L	D1
00:000072F8 761F            	  2161: DIV2	MOVEQ	#31,D3		iteration count for 32 bits
00:000072FA 2200            	  2162: 	MOVE.L	D0,D1
00:000072FC 7000            	  2163: 	CLR.L	D0
00:000072FE D281            	  2164: DIV3	ADD.L	D1,D1		(This algorithm was translated from
00:00007300 D180            	  2165: 	ADDX.L	D0,D0		; the divide routine in Ron Cain's
00:00007302 6708            	  2166: 	BEQ	DIV4		Small-C run time library.)
00:00007304 B082            	  2167: 	CMP.L	D2,D0
00:00007306 6B04            	  2168: 	BMI	DIV4
00:00007308 5281            	  2169: 	ADDQ.L	#1,D1
00:0000730A 9082            	  2170: 	SUB.L	D2,D0
00:0000730C 51CBFFF0        	  2171: DIV4	DBRA	D3,DIV3
00:00007310 C141            	  2172: 	EXG	D0,D1		put rem. & quot. in proper registers
00:00007312 4A84            	  2173: 	TST.L	D4		were the signs the same?
00:00007314 6A04            	  2174: 	BPL	DIVRT
00:00007316 4480            	  2175: 	NEG.L	D0		if not, results are negative
00:00007318 4481            	  2176: 	NEG.L	D1
00:0000731A 4E75            	  2177: DIVRT	RTS
                            	  2178: 
                            	  2179: 
                            	  2180: ; ===== The PEEK function returns the byte stored at the address
                            	  2181: ;	contained in the following expression.
                            	  2182: 
                            	  2183: PEEK
00:0000731C 1E3C0042        	  2184: 	MOVE.B #'B',d7
00:00007320 1210            	  2185: 	MOVE.B (a0),d1
00:00007322 0C01002E        	  2186: 	CMPI.B #'.',d1
00:00007326 6604            	  2187: 	BNE .0001
00:00007328 5248            	  2188: 	ADDQ #1,a0
00:0000732A 1E18            	  2189: 	move.b (a0)+,d7
                            	  2190: .0001
00:0000732C 6100FD82        	  2191: 	BSR	PARN		get the memory address
00:00007330 0C8000000001    	  2192: 	cmpi.l #DT_NUMERIC,d0
00:00007336 660002F4        	  2193: 	bne ETYPE
00:0000733A F2006000        	  2194: 	FMOVE.L FP0,D0
00:0000733E 2240            	  2195: 	MOVE.L D0,A1
00:00007340 0C070042        	  2196: 	cmpi.b #'B',d7
00:00007344 660C            	  2197: 	bne .0002
                            	  2198: .0005
00:00007346 7000            	  2199: 	CLR.L	D0				; upper 3 bytes will be zero
00:00007348 1011            	  2200: 	MOVE.B (A1),D0
00:0000734A F2005800        	  2201: 	FMOVE.B	D0,FP0 	; get the addressed byte
00:0000734E 7001            	  2202: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00007350 4E75            	  2203: 	rts							; and return it
                            	  2204: .0002
00:00007352 0C070057        	  2205: 	cmpi.b #'W',d7
00:00007356 660C            	  2206: 	bne .0003
00:00007358 7000            	  2207: 	CLR.L d0
00:0000735A 3011            	  2208: 	MOVE.W (A1),D0
00:0000735C F2005000        	  2209: 	FMOVE.W	D0,FP0	;	get the addressed word
00:00007360 7001            	  2210: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00007362 4E75            	  2211: 	rts							; and return it
                            	  2212: .0003
00:00007364 0C07004C        	  2213: 	cmpi.b #'L',d7
00:00007368 660C            	  2214: 	bne .0004
00:0000736A 7000            	  2215: 	CLR.L d0
00:0000736C 2011            	  2216: 	MOVE.L (A1),D0
00:0000736E F2004000        	  2217: 	FMOVE.L	D0,FP0 	; get the lword
00:00007372 7001            	  2218: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00007374 4E75            	  2219: 	rts							; and return it
                            	  2220: .0004
00:00007376 0C070046        	  2221: 	cmpi.b #'F',d7
00:0000737A 66CA            	  2222: 	bne .0005
00:0000737C F2114800        	  2223: 	FMOVE.X	(A1),FP0 		; get the addressed float
00:00007380 7001            	  2224: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00007382 4E75            	  2225: 	rts							; and return it
                            	  2226: 
                            	  2227: ;-------------------------------------------------------------------------------
                            	  2228: ; The RND function returns a random number from 0 to the value of the following
                            	  2229: ; expression in fp0.
                            	  2230: ;-------------------------------------------------------------------------------
                            	  2231: 
                            	  2232: RND:
00:00007384 6100FD2A        	  2233: 	bsr	PARN								; get the upper limit
00:00007388 0C8000000001    	  2234: 	cmpi.l #DT_NUMERIC,d0		; must be numeric
00:0000738E 6600029C        	  2235: 	bne ETYPE
00:00007392 F200003A        	  2236: 	ftst.x fp0							; it must be positive and non-zero
00:00007396 F281028C        	  2237: 	fbeq QHOW
00:0000739A F2940288        	  2238: 	fblt QHOW
00:0000739E F2000100        	  2239: 	fmove fp0,fp2
00:000073A2 7028            	  2240: 	moveq #40,d0						; function #40 get random float
00:000073A4 4E4F            	  2241: 	trap #15
00:000073A6 F2000823        	  2242: 	fmul fp2,fp0
00:000073AA 7001            	  2243: 	moveq #DT_NUMERIC,d0		; data type is a number
00:000073AC 4E75            	  2244: 	rts
                            	  2245: 
                            	  2246: ; ===== The ABS function returns an absolute value in D0.
                            	  2247: 
                            	  2248: ABS:	
00:000073AE 6100FD00        	  2249: 	bsr	PARN			; get the following expr.'s value
00:000073B2 F2000018        	  2250: 	fabs.x fp0
00:000073B6 7001            	  2251: 	moveq #DT_NUMERIC,d0					; data type is a number
00:000073B8 4E75            	  2252: 	rts
                            	  2253: 
                            	  2254: ; ===== The SIZE function returns the size of free memory in D0.
                            	  2255: 
                            	  2256: SIZE:
00:000073BA 203A0668        	  2257: 	move.l StrArea,d0		; get the number of free bytes...
00:000073BE 90BA066C        	  2258: 	sub.l	 TXTUNF,d0		; between 'TXTUNF' and 'StrArea'
00:000073C2 F2004000        	  2259: 	fmove.l d0,fp0
00:000073C6 7001            	  2260: 	moveq #DT_NUMERIC,d0	; data type is a number
00:000073C8 4E75            	  2261: 	rts										; return the number in fp0
                            	  2262: 	
                            	  2263: ; ===== The TICK function returns the processor tick register in D0.
                            	  2264: 
                            	  2265: TICK:
00:000073CA 4E7A0FF0        	  2266: 	movec tick,d0
00:000073CE F2004000        	  2267: 	fmove.l d0,fp0
00:000073D2 7001            	  2268: 	moveq #DT_NUMERIC,d0					; data type is a number
00:000073D4 4E75            	  2269: 	rts
                            	  2270: 
                            	  2271: ; ===== The CORENO function returns the core number in D0.
                            	  2272: 
                            	  2273: CORENO:
00:000073D6 4E7A0FE0        	  2274: 	movec coreno,d0
00:000073DA F2004000        	  2275: 	fmove.l d0,fp0
00:000073DE 7001            	  2276: 	moveq #DT_NUMERIC,d0					; data type is a number
00:000073E0 4E75            	  2277: 	rts
                            	  2278: 
                            	  2279: ;-------------------------------------------------------------------------------
                            	  2280: ; Get a pair of argments for the LEFT$ and RIGHT$ functions.
                            	  2281: ; 	(STRING, NUM)
                            	  2282: ; Returns:
                            	  2283: ;		fp0 = number
                            	  2284: ;		fp1 = string
                            	  2285: ;-------------------------------------------------------------------------------
                            	  2286: 
                            	  2287: LorRArgs:
00:000073E2 61000440        	  2288: 	bsr	TSTC						; else look for ( STRING EXPR, NUM EXPR )
00:000073E6 28              	  2289: 	dc.b	'(',LorR1-*
00:000073E7 33
00:000073E8 6100F9FA        	  2290: 	bsr	EXPR
00:000073EC 0C8000000002    	  2291: 	cmpi.l #DT_STRING,d0
00:000073F2 66000238        	  2292: 	bne ETYPE
00:000073F6 6100F99C        	  2293: 	bsr XP_PUSH
00:000073FA 61000428        	  2294: 	bsr TSTC
00:000073FE 2C              	  2295: 	dc.b ',',LorR1-*
00:000073FF 1B
00:00007400 6100F9E2        	  2296: 	bsr EXPR
00:00007404 0C8000000001    	  2297: 	cmpi.l #DT_NUMERIC,d0
00:0000740A 66000220        	  2298: 	bne ETYPE
00:0000740E 61000414        	  2299: 	bsr	TSTC
00:00007412 29              	  2300: 	dc.b	')',LorR1-*
00:00007413 07
00:00007414 6100F99E        	  2301: 	bsr XP_POP1
00:00007418 4E75            	  2302: 	rts
                            	  2303: LorR1
00:0000741A 60000208        	  2304: 	bra QHOW
                            	  2305: 	
                            	  2306: ;-------------------------------------------------------------------------------
                            	  2307: ; MID$ function gets a substring of characters from start position for
                            	  2308: ; requested length.
                            	  2309: ;-------------------------------------------------------------------------------
                            	  2310: 
                            	  2311: MID:
00:0000741E 61000404        	  2312: 	bsr	TSTC						; look for ( STRING EXPR, NUM EXPR [, NUM_EXPR] )
00:00007422 28              	  2313: 	dc.b	'(',MID1-*
00:00007423 C1
00:00007424 6100F9BE        	  2314: 	bsr	EXPR
00:00007428 0C8000000002    	  2315: 	cmpi.l #DT_STRING,d0
00:0000742E 660001FC        	  2316: 	bne ETYPE
00:00007432 6100F960        	  2317: 	bsr XP_PUSH
00:00007436 610003EC        	  2318: 	bsr TSTC
00:0000743A 2C              	  2319: 	dc.b ',',MID1-*
00:0000743B A9
00:0000743C 6100F9A6        	  2320: 	bsr EXPR
00:00007440 0C8000000001    	  2321: 	cmpi.l #DT_NUMERIC,d0
00:00007446 660001E4        	  2322: 	bne ETYPE
00:0000744A 6100F948        	  2323: 	bsr XP_PUSH
00:0000744E 7A02            	  2324: 	moveq #2,d5
00:00007450 610003D2        	  2325: 	bsr	TSTC
00:00007454 2C              	  2326: 	dc.b ',',MID2-*
00:00007455 11
00:00007456 6100F98C        	  2327: 	bsr EXPR
00:0000745A 0C8000000001    	  2328: 	cmpi.l #DT_NUMERIC,d0
00:00007460 660001CA        	  2329: 	bne ETYPE
00:00007464 7A03            	  2330: 	moveq #3,d5					; d5 indicates 3 params
                            	  2331: MID2
00:00007466 610003BC        	  2332: 	bsr TSTC
00:0000746A 29              	  2333: 	dc.b ')',MID1-*
00:0000746B 79
00:0000746C 6100F946        	  2334: 	bsr XP_POP1
00:00007470 0C050003        	  2335: 	cmpi.b #3,d5				; did we have 3 arguments?
00:00007474 6708            	  2336: 	beq MID5						; branch if did
00:00007476 F23C40000000FFFF	  2337: 	fmove.l #$FFFF,fp0	; set length = max
                            	  2338: MID5
00:0000747E F2000500        	  2339: 	fmove.x fp1,fp2			; fp2 = start pos
00:00007482 6100F930        	  2340: 	bsr XP_POP1					; fp1 = string descriptor
                            	  2341: ;-------------------------------------------------------------------------------
                            	  2342: ; Perform MID$ function
                            	  2343: ; 	fp1 = string descriptor
                            	  2344: ; 	fp2 = starting position
                            	  2345: ; 	fp0 = length
                            	  2346: ;-------------------------------------------------------------------------------
                            	  2347: DOMID
00:00007486 F239688000040600	  2348: 	fmove.x fp1,_fpWork	; _fpWork = string descriptor
00:0000748E F2036100        	  2349: 	fmove.l fp2,d3			; d3 = start pos
00:00007492 B67900040600    	  2350: 	cmp.w _fpWork,d3		; is start pos < length
00:00007498 6400018A        	  2351: 	bhs QHOW
00:0000749C F2026000        	  2352: 	fmove.l fp0,d2			; d2=length
00:000074A0 D682            	  2353: 	add.l d2,d3					; start pos + length < string length?
00:000074A2 B47900040600    	  2354: 	cmp.w _fpWork,d2
00:000074A8 6308            	  2355: 	bls MID4
00:000074AA 343900040600    	  2356: 	move.w _fpWork,d2		; move string length to d2
00:000074B0 48C2            	  2357: 	ext.l d2
                            	  2358: MID4
00:000074B2 6100FC12        	  2359: 	bsr AllocateString	; a1 = pointer to new string
00:000074B6 2449            	  2360: 	move.l a1,a2				; a2 = pointer to new string
00:000074B8 227900040604    	  2361: 	move.l _fpWork+4,a1	; a1 = pointer to string
00:000074BE F2036100        	  2362: 	fmove.l fp2,d3			; d3 = start pos
00:000074C2 D3C3            	  2363: 	add.l d3,a1					; a1 = pointer to start pos
00:000074C4 33C200040600    	  2364: 	move.w d2,_fpWork		; length
00:000074CA 23CA00040604    	  2365: 	move.l a2,_fpWork+4	; prep to return target string
00:000074D0 2649            	  2366: 	move.l a1,a3				; a3 = pointer to start pos
00:000074D2 D7C2            	  2367: 	add.l d2,a3					; a3 = pointer to end pos
00:000074D4 61000230        	  2368: 	bsr MVUP						; move A1 to A2 until A1 = A3
00:000074D8 7002            	  2369: 	moveq #DT_STRING,d0	; data type is a string
00:000074DA F239480000040600	  2370: 	fmove.x _fpWork,fp0	; string descriptor in fp0
00:000074E2 4E75            	  2371: 	rts
                            	  2372: MID1
00:000074E4 6000013E        	  2373: 	bra QHOW
                            	  2374: 	
                            	  2375: ;-------------------------------------------------------------------------------
                            	  2376: ; LEFT$ function truncates the string after fp0 characters.
                            	  2377: ; Just like MID$ but with a zero starting postion.
                            	  2378: ;-------------------------------------------------------------------------------
                            	  2379: 	
                            	  2380: LEFT:
00:000074E8 6100FEF8        	  2381: 	bsr LorRArgs				; get arguments
00:000074EC F23C59000000    	  2382: 	fmove.b #0,fp2			; start pos = 0
00:000074F2 6092            	  2383: 	bra DOMID
                            	  2384: 
                            	  2385: ;-------------------------------------------------------------------------------
                            	  2386: ; RIGHT$ function gets the rightmost characters.
                            	  2387: ; The start position must be calculated based on the number of characters
                            	  2388: ; requested and the string length.
                            	  2389: ;-------------------------------------------------------------------------------
                            	  2390: 
                            	  2391: RIGHT:
00:000074F4 6100FEEC        	  2392: 	bsr LorRArgs				; get arguments
00:000074F8 F2026000        	  2393: 	fmove.l fp0,d2			; d2 = required length
00:000074FC F239688000040600	  2394: 	fmove.x fp1,_fpWork	; _fpWork = string descriptor
00:00007504 363900040600    	  2395: 	move.w _fpWork,d3		; d3 = string length
00:0000750A 48C3            	  2396: 	ext.l d3						; make d3 a long
00:0000750C B682            	  2397: 	cmp.l d2,d3					; is length > right
00:0000750E 6202            	  2398: 	bhi .0001
00:00007510 7400            	  2399: 	moveq #0,d2					; we want all the characters if length <= right
                            	  2400: .0001
00:00007512 9682            	  2401: 	sub.l d2,d3					; d3 = startpos = length - right
00:00007514 F2034100        	  2402: 	fmove.l d3,fp2			; fp2 = start position
00:00007518 6000FF6C        	  2403: 	bra DOMID
                            	  2404: 
                            	  2405: ;-------------------------------------------------------------------------------
                            	  2406: ; LEN( EXPR ) returns the length of a string expression.
                            	  2407: ;-------------------------------------------------------------------------------
                            	  2408: 
                            	  2409: LEN:
00:0000751C 6100FB92        	  2410: 	bsr PARN
00:00007520 0C8000000002    	  2411: 	cmpi.l #DT_STRING,d0
00:00007526 66000104        	  2412: 	bne ETYPE
00:0000752A F239680000040600	  2413: 	fmove.x fp0,_fpWork
00:00007532 303900040600    	  2414: 	move.w _fpWork,d0
00:00007538 48C0            	  2415: 	ext.l d0
00:0000753A F2005000        	  2416: 	fmove.w d0,fp0
00:0000753E 7001            	  2417: 	moveq #DT_NUMERIC,d0
00:00007540 4E75            	  2418: 	rts
                            	  2419: 
                            	  2420: ;-------------------------------------------------------------------------------
                            	  2421: ; INT( EXPR ) returns the integer value of the expression.
                            	  2422: ; the expression must be in the range of a 32-bit integer.
                            	  2423: ;-------------------------------------------------------------------------------
                            	  2424: 
                            	  2425: INT:
00:00007542 6100FB6C        	  2426: 	bsr PARN
00:00007546 0C8000000001    	  2427: 	cmpi.l #DT_NUMERIC,d0
00:0000754C 660000DE        	  2428: 	bne ETYPE
00:00007550 F2000003        	  2429: 	fintrz fp0,fp0
                            	  2430: ;	fmove.l fp0,d0
                            	  2431: ;	fmove.l d0,fp0
00:00007554 7001            	  2432: 	moveq #DT_NUMERIC,d0
00:00007556 4E75            	  2433: 	rts
                            	  2434: 
                            	  2435: 
                            	  2436: ;-------------------------------------------------------------------------------
                            	  2437: ; CHR$( EXPR ) returns a one byte string containing the character.
                            	  2438: ;-------------------------------------------------------------------------------
                            	  2439: 
                            	  2440: CHR:
00:00007558 6100FB56        	  2441: 	bsr PARN
00:0000755C 0C8000000001    	  2442: 	cmpi.l #DT_NUMERIC,d0
00:00007562 660000C8        	  2443: 	bne ETYPE
00:00007566 F2006000        	  2444: 	fmove.l fp0,d0
00:0000756A 7401            	  2445: 	moveq #1,d2
00:0000756C 6100FB58        	  2446: 	bsr AllocateString
00:00007570 1280            	  2447: 	move.b d0,(a1)
00:00007572 42290001        	  2448: 	clr.b 1(a1)
00:00007576 7002            	  2449: 	moveq #DT_STRING,d0
00:00007578 23C900040604    	  2450: 	move.l a1,_fpWork+4
00:0000757E 33FC000100040600	  2451: 	move.w #1,_fpWork
00:00007586 F239480000040600	  2452: 	fmove.x _fpWork,fp0
00:0000758E 4E75            	  2453: 	rts
                            	  2454: 
                            	  2455: ;*******************************************************************
                            	  2456: ;
                            	  2457: ; *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                            	  2458: ;
                            	  2459: ; 'SETVAL' expects a variable, followed by an equal sign and then
                            	  2460: ; an expression.  It evaluates the expression and sets the variable
                            	  2461: ; to that value.
                            	  2462: ;
                            	  2463: ; 'FIN' checks the end of a command.  If it ended with ":",
                            	  2464: ; execution continues.	If it ended with a CR, it finds the
                            	  2465: ; the next line and continues from there.
                            	  2466: ;
                            	  2467: ; 'ENDCHK' checks if a command is ended with a CR. This is
                            	  2468: ; required in certain commands, such as GOTO, RETURN, STOP, etc.
                            	  2469: ;
                            	  2470: ; 'ERROR' prints the string pointed to by A0. It then prints the
                            	  2471: ; line pointed to by CURRNT with a "?" inserted at where the
                            	  2472: ; old text pointer (should be on top of the stack) points to.
                            	  2473: ; Execution of Tiny BASIC is stopped and a warm start is done.
                            	  2474: ; If CURRNT is zero (indicating a direct command), the direct
                            	  2475: ; command is not printed. If CURRNT is -1 (indicating
                            	  2476: ; 'INPUT' command in progress), the input line is not printed
                            	  2477: ; and execution is not terminated but continues at 'INPERR'.
                            	  2478: ;
                            	  2479: ; Related to 'ERROR' are the following:
                            	  2480: ; 'QWHAT' saves text pointer on stack and gets "What?" message.
                            	  2481: ; 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                            	  2482: ; 'QSORRY' and 'ASORRY' do the same kind of thing.
                            	  2483: ; 'QHOW' and 'AHOW' also do this for "How?".
                            	  2484: 
                            	  2485: ; SETVAL
                            	  2486: ; Returns:
                            	  2487: ;		a6 pointer to variable
                            	  2488: 
                            	  2489: SETVAL:	
00:00007590 6100FCCC        	  2490: 	bsr	TSTV					; variable name?
00:00007594 6546            	  2491: 	bcs	QWHAT					; if not, say "What?"
00:00007596 2F00            	  2492: 	move.l d0,-(sp)		; save the variable's address
00:00007598 6100028A        	  2493: 	bsr	TSTC					; get past the "=" sign
00:0000759C 3D              	  2494: 	dc.b	'=',SV1-*
00:0000759D 11
00:0000759E 6100F844        	  2495: 	bsr	EXPR					; evaluate the expression
00:000075A2 2C5F            	  2496: 	move.l (sp)+,a6
00:000075A4 2C80            	  2497: 	move.l d0,(a6)		; save type
00:000075A6 F22E68000004    	  2498: 	fmove.x fp0,4(a6) ; and save its value in the variable
00:000075AC 4E75            	  2499: 	rts
                            	  2500: SV1
00:000075AE 602C            	  2501: 	bra	QWHAT					; if no "=" sign
                            	  2502: 
                            	  2503: FIN
00:000075B0 61000272        	  2504: 	bsr	TSTC					; *** FIN ***
00:000075B4 3A              	  2505: 	DC.B ':',FI1-*
00:000075B5 07
00:000075B6 588F            	  2506: 	ADDQ.L #4,SP			; if ":", discard return address
00:000075B8 6000F0CA        	  2507: 	BRA	RUNSML				; continue on the same line
                            	  2508: FI1
00:000075BC 61000266        	  2509: 	bsr	TSTC					; not ":", is it a CR?
00:000075C0 0D              	  2510: 	DC.B	CR,FI2-*
00:000075C1 07
00:000075C2 588F            	  2511: 	ADDQ.L #4,SP			; yes, purge return address
00:000075C4 6000F068        	  2512: 	BRA	RUNNXL				; execute the next line
                            	  2513: FI2
00:000075C8 4E75            	  2514: 	RTS								; else return to the caller
                            	  2515: 
                            	  2516: ENDCHK
00:000075CA 610002BC        	  2517: 	bsr	IGNBLK
00:000075CE 0C10003A        	  2518: 	CMP.B #':',(a0)
00:000075D2 6706            	  2519: 	BEQ ENDCHK1
00:000075D4 0C10000D        	  2520: 	CMP.B	#CR,(A0)		; does it end with a CR?
00:000075D8 6602            	  2521: 	BNE	QWHAT					; if not, say "WHAT?"
                            	  2522: ENDCHK1:
00:000075DA 4E75            	  2523: 	RTS
                            	  2524: 
                            	  2525: QWHAT
00:000075DC 2F08            	  2526: 	MOVE.L A0,-(SP)
                            	  2527: AWHAT
00:000075DE 4DFA03CA        	  2528: 	LEA	WHTMSG,A6
                            	  2529: ERROR
00:000075E2 6100030A        	  2530: 	bsr	PRMESG		display the error message
00:000075E6 205F            	  2531: 	MOVE.L	(SP)+,A0	restore the text pointer
00:000075E8 203A03FA        	  2532: 	MOVE.L	CURRNT,D0	get the current line number
00:000075EC 6700EC7A        	  2533: 	BEQ	WSTART		if zero, do a warm start
00:000075F0 B0BCFFFFFFFF    	  2534: 	CMP.L	#-1,D0		is the line no. pointer = -1?
00:000075F6 6700F306        	  2535: 	BEQ	INPERR		if so, redo input
00:000075FA 1F10            	  2536: 	MOVE.B	(A0),-(SP)	save the char. pointed to
00:000075FC 4210            	  2537: 	CLR.B	(A0)		put a zero where the error is
00:000075FE 227A03E4        	  2538: 	MOVE.L	CURRNT,A1	point to start of current line
00:00007602 61000202        	  2539: 	bsr	PRTLN		display the line in error up to the 0
00:00007606 109F            	  2540: 	MOVE.B	(SP)+,(A0)	restore the character
00:00007608 103C003F        	  2541: 	MOVE.B	#'?',D0         display a "?"
00:0000760C 6100EBD2        	  2542: 	BSR	GOOUT
00:00007610 4240            	  2543: 	CLR	D0
00:00007612 5389            	  2544: 	SUBQ.L	#1,A1		point back to the error char.
00:00007614 6100017E        	  2545: 	bsr	PRTSTG		display the rest of the line
00:00007618 6000EC4E        	  2546: 	BRA	WSTART		and do a warm start
                            	  2547: QSORRY
00:0000761C 2F08            	  2548: 	MOVE.L	A0,-(SP)
                            	  2549: ASORRY
00:0000761E 4DFA03AC        	  2550: 	LEA	SRYMSG,A6
00:00007622 60BE            	  2551: 	BRA	ERROR
                            	  2552: QHOW:
00:00007624 2F08            	  2553: 	MOVE.L	A0,-(SP)	Error: "How?"
                            	  2554: AHOW
00:00007626 4DFA037B        	  2555: 	LEA	HOWMSG,A6
00:0000762A 60B6            	  2556: 	BRA	ERROR
                            	  2557: ETYPE
00:0000762C 4DFA0384        	  2558: 	lea TYPMSG,a6
00:00007630 60B0            	  2559: 	bra ERROR
                            	  2560: 
                            	  2561: *******************************************************************
                            	  2562: *
                            	  2563: * *** GETLN *** FNDLN (& friends) ***
                            	  2564: *
                            	  2565: * 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                            	  2566: * the character in D0 (given by the caller), then it fills the
                            	  2567: * buffer and echos. It ignores LF's but still echos
                            	  2568: * them back. Control-H is used to delete the last character
                            	  2569: * entered (if there is one), and control-X is used to delete the
                            	  2570: * whole line and start over again. CR signals the end of a line,
                            	  2571: * and causes 'GETLN' to return.
                            	  2572: *
                            	  2573: * 'FNDLN' finds a line with a given line no. (in D1) in the
                            	  2574: * text save area.  A1 is used as the text pointer. If the line
                            	  2575: * is found, A1 will point to the beginning of that line
                            	  2576: * (i.e. the high byte of the line no.), and flags are NC & Z.
                            	  2577: * If that line is not there and a line with a higher line no.
                            	  2578: * is found, A1 points there and flags are NC & NZ. If we reached
                            	  2579: * the end of the text save area and cannot find the line, flags
                            	  2580: * are C & NZ.
                            	  2581: * 'FNDLN' will initialize A1 to the beginning of the text save
                            	  2582: * area to start the search. Some other entries of this routine
                            	  2583: * will not initialize A1 and do the search.
                            	  2584: * 'FNDLNP' will start with A1 and search for the line no.
                            	  2585: * 'FNDNXT' will bump A1 by 2, find a CR and then start search.
                            	  2586: * 'FNDSKP' uses A1 to find a CR, and then starts the search.
                            	  2587: 
                            	  2588: GETLN:
00:00007632 6100EBAC        	  2589: 	BSR	GOOUT		display the prompt
00:00007636 103C0020        	  2590: 	MOVE.B	#' ',D0         and a space
00:0000763A 6100EBA4        	  2591: 	BSR	GOOUT
00:0000763E 41FA03FC        	  2592: 	LEA	BUFFER,A0	; A0 is the buffer pointer
                            	  2593: GL1
00:00007642 61000298        	  2594: 	bsr	CHKIO		check keyboard
00:00007646 67FA            	  2595: 	BEQ	GL1		wait for a char. to come in
00:00007648 B03C0008        	  2596: 	CMP.B	#CTRLH,D0	delete last character?
00:0000764C 6726            	  2597: 	BEQ	GL3		if so
00:0000764E B03C0018        	  2598: 	CMP.B	#CTRLX,D0	delete the whole line?
00:00007652 6744            	  2599: 	BEQ	GL4		if so
00:00007654 B03C000D        	  2600: 	CMP.B	#CR,D0		accept a CR
00:00007658 6706            	  2601: 	BEQ	GL2
00:0000765A B03C0020        	  2602: 	CMP.B	#' ',D0         if other control char., discard it
00:0000765E 65E2            	  2603: 	BCS	GL1
                            	  2604: GL2
00:00007660 10C0            	  2605: 	MOVE.B	D0,(A0)+	save the char.
00:00007662 6100EB7C        	  2606: 	BSR	GOOUT		echo the char back out
00:00007666 B03C000D        	  2607: 	CMP.B	#CR,D0		if it's a CR, end the line
00:0000766A 675C            	  2608: 	BEQ	GL7
00:0000766C B1FC00007A8B    	  2609: 	CMP.L	#(BUFFER+BUFLEN-1),A0	any more room?
00:00007672 65CE            	  2610: 	BCS	GL1		yes: get some more, else delete last char.
                            	  2611: GL3
00:00007674 103C0008        	  2612: 	MOVE.B	#CTRLH,D0	delete a char. if possible
00:00007678 6100EB66        	  2613: 	BSR	GOOUT
00:0000767C 103C0020        	  2614: 	MOVE.B	#' ',D0
00:00007680 6100EB5E        	  2615: 	BSR	GOOUT
00:00007684 B1FC00007A3C    	  2616: 	CMP.L	#BUFFER,A0	any char.'s left?
00:0000768A 63B6            	  2617: 	BLS	GL1		if not
00:0000768C 103C0008        	  2618: 	MOVE.B	#CTRLH,D0	if so, finish the BS-space-BS sequence
00:00007690 6100EB4E        	  2619: 	BSR	GOOUT
00:00007694 5388            	  2620: 	SUBQ.L	#1,A0		decrement the text pointer
00:00007696 60AA            	  2621: 	BRA	GL1		back for more
                            	  2622: GL4
00:00007698 2208            	  2623: 	MOVE.L	A0,D1		delete the whole line
00:0000769A 92BC00007A3C    	  2624: 	SUB.L	#BUFFER,D1	figure out how many backspaces we need
00:000076A0 671E            	  2625: 	BEQ	GL6		if none needed, branch
00:000076A2 5341            	  2626: 	SUBQ	#1,D1		adjust for DBRA
                            	  2627: GL5
00:000076A4 103C0008        	  2628: 	MOVE.B	#CTRLH,D0	and display BS-space-BS sequences
00:000076A8 6100EB36        	  2629: 	BSR	GOOUT
00:000076AC 103C0020        	  2630: 	MOVE.B	#' ',D0
00:000076B0 6100EB2E        	  2631: 	BSR	GOOUT
00:000076B4 103C0008        	  2632: 	MOVE.B	#CTRLH,D0
00:000076B8 6100EB26        	  2633: 	BSR	GOOUT
00:000076BC 51C9FFE6        	  2634: 	DBRA	D1,GL5
                            	  2635: GL6
00:000076C0 41FA037A        	  2636: 	LEA	BUFFER,A0	reinitialize the text pointer
00:000076C4 6000FF7C        	  2637: 	BRA	GL1		and go back for more
                            	  2638: GL7
00:000076C8 103C000A        	  2639: 	MOVE.B	#LF,D0		echo a LF for the CR
00:000076CC 6000EB12        	  2640: 	BRA	GOOUT
                            	  2641: 
                            	  2642: FNDLN:
00:000076D0 B2BC0000FFFF    	  2643: 	CMP.L	#$FFFF,D1	line no. must be < 65535
00:000076D6 6400FF4C        	  2644: 	BCC	QHOW
00:000076DA 227AEB18        	  2645: 	MOVE.L	TXTBGN,A1	init. the text save pointer
                            	  2646: 
                            	  2647: FNDLNP
00:000076DE 247A034C        	  2648: 	MOVE.L	TXTUNF,A2	check if we passed the end
00:000076E2 538A            	  2649: 	SUBQ.L	#1,A2
00:000076E4 B5C9            	  2650: 	CMP.L	A1,A2
00:000076E6 650C            	  2651: 	BCS	FNDRET		if so, return with Z=0 & C=1
00:000076E8 1411            	  2652: 	MOVE.B	(A1),D2	if not, get a line no.
00:000076EA E14A            	  2653: 	LSL	#8,D2
00:000076EC 14290001        	  2654: 	MOVE.B	1(A1),D2
00:000076F0 B441            	  2655: 	CMP.W	D1,D2		is this the line we want?
00:000076F2 6502            	  2656: 	BCS	FNDNXT		no, not there yet
                            	  2657: FNDRET
00:000076F4 4E75            	  2658: 	RTS			return the cond. codes
                            	  2659: 
                            	  2660: FNDNXT
00:000076F6 5489            	  2661: 	ADDQ.L	#2,A1		find the next line
                            	  2662: 
                            	  2663: FNDSKP	
00:000076F8 0C19000D        	  2664: 	CMP.B	#CR,(A1)+	try to find a CR
00:000076FC 67E0            	  2665: 	BEQ		FNDLNP
00:000076FE B3FA032C        	  2666: 	CMP.L	TXTUNF,A1
00:00007702 65F4            	  2667: 	BLO		FNDSKP
00:00007704 60D8            	  2668: 	BRA		FNDLNP		check if end of text
                            	  2669: 
                            	  2670: ;******************************************************************
                            	  2671: ;
                            	  2672: ; *** MVUP *** MVDOWN *** POPA *** PUSHA ***
                            	  2673: ;
                            	  2674: ; 'MVUP' moves a block up from where A1 points to where A2 points
                            	  2675: ; until A1=A3
                            	  2676: ;
                            	  2677: ; 'MVDOWN' moves a block down from where A1 points to where A3
                            	  2678: ; points until A1=A2
                            	  2679: ;
                            	  2680: ; 'POPA' restores the 'FOR' loop variable save area from the stack
                            	  2681: ;
                            	  2682: ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                            	  2683: ;
                            	  2684: 
                            	  2685: MVUP
00:00007706 B7C9            	  2686: 	CMP.L	A1,A3					; see the above description
00:00007708 6304            	  2687: 	BLS	MVRET
00:0000770A 14D9            	  2688: 	MOVE.B	(A1)+,(A2)+
00:0000770C 60F8            	  2689: 	BRA	MVUP
                            	  2690: MVRET
00:0000770E 4E75            	  2691: 	RTS
                            	  2692: 
                            	  2693: ; For string movements only suitable in some circumstances
                            	  2694: 
                            	  2695: MVUPW
00:00007710 B3CB            	  2696: 	cmp.l a3,a1
00:00007712 6404            	  2697: 	bhs .0001
00:00007714 34D9            	  2698: 	move.w (a1)+,(a2)+
00:00007716 60F8            	  2699: 	bra MVUPW
                            	  2700: .0001
00:00007718 4E75            	  2701: 	rts
                            	  2702: 
                            	  2703: MVDOWN
00:0000771A B5C9            	  2704: 	CMP.L	A1,A2		see the above description
00:0000771C 67F0            	  2705: 	BEQ	MVRET
00:0000771E 1721            	  2706: 	MOVE.B	-(A1),-(A3)
00:00007720 60F8            	  2707: 	BRA	MVDOWN
                            	  2708: 
                            	  2709: POPA
00:00007722 2C5F            	  2710: 	MOVE.L	(SP)+,A6			; A6 = return address
00:00007724 23DF000079F4    	  2711: 	MOVE.L	(SP)+,LOPVAR	restore LOPVAR, but zero means no more
00:0000772A 6730            	  2712: 	BEQ	.0001
00:0000772C 23DF00007A00    	  2713: 	MOVE.L	(SP)+,LOPINC+8	if not zero, restore the rest
00:00007732 23DF000079FC    	  2714: 	MOVE.L	(SP)+,LOPINC+4
00:00007738 23DF000079F8    	  2715: 	MOVE.L	(SP)+,LOPINC
00:0000773E 23DF00007A0C    	  2716: 	MOVE.L	(SP)+,LOPLMT+8
00:00007744 23DF00007A08    	  2717: 	MOVE.L	(SP)+,LOPLMT+4
00:0000774A 23DF00007A04    	  2718: 	MOVE.L	(SP)+,LOPLMT
00:00007750 23DF00007A10    	  2719: 	MOVE.L	(SP)+,LOPLN
00:00007756 23DF00007A14    	  2720: 	MOVE.L	(SP)+,LOPPT
                            	  2721: .0001
00:0000775C 4ED6            	  2722: 	JMP	(A6)		return
                            	  2723: 
                            	  2724: PUSHA
00:0000775E 223A02D4        	  2725: 	MOVE.L	STKLMT,D1		; Are we running out of stack room?
00:00007762 928F            	  2726: 	SUB.L	SP,D1
00:00007764 6400FEB6        	  2727: 	BCC	QSORRY					; if so, say we're sorry
00:00007768 2C5F            	  2728: 	MOVE.L	(SP)+,A6		; else get the return address
00:0000776A 223A0288        	  2729: 	MOVE.L	LOPVAR,D1		; save loop variables
00:0000776E 6720            	  2730: 	BEQ	.0001						; if LOPVAR is zero, that's all
00:00007770 2F3A02A2        	  2731: 	MOVE.L	LOPPT,-(SP)	; else save all the others
00:00007774 2F3A029A        	  2732: 	MOVE.L	LOPLN,-(SP)
00:00007778 2F3A028A        	  2733: 	MOVE.L	LOPLMT,-(SP)
00:0000777C 2F3A028A        	  2734: 	MOVE.L	LOPLMT+4,-(SP)
00:00007780 2F3A028A        	  2735: 	MOVE.L	LOPLMT+8,-(SP)
00:00007784 2F3A0272        	  2736: 	MOVE.L	LOPINC,-(SP)
00:00007788 2F3A0272        	  2737: 	MOVE.L	LOPINC+4,-(SP)
00:0000778C 2F3A0272        	  2738: 	MOVE.L	LOPINC+8,-(SP)
                            	  2739: .0001
00:00007790 2F01            	  2740: 	MOVE.L	D1,-(SP)
00:00007792 4ED6            	  2741: 	JMP	(A6)		return
                            	  2742: 
                            	  2743: *******************************************************************
                            	  2744: *
                            	  2745: * *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                            	  2746: *
                            	  2747: * 'PRTSTG' prints a string pointed to by A1. It stops printing
                            	  2748: * and returns to the caller when either a CR is printed or when
                            	  2749: * the next byte is the same as what was passed in D0 by the
                            	  2750: * caller.
                            	  2751: *
                            	  2752: * 'QTSTG' looks for an underline (back-arrow on some systems),
                            	  2753: * single-quote, or double-quote.  If none of these are found, returns
                            	  2754: * to the caller.  If underline, outputs a CR without a LF.  If single
                            	  2755: * or double quote, prints the quoted string and demands a matching
                            	  2756: * end quote.  After the printing, the next 2 bytes of the caller are
                            	  2757: * skipped over (usually a short branch instruction).
                            	  2758: *
                            	  2759: * 'PRTNUM' prints the 32 bit number in D1, leading blanks are added if
                            	  2760: * needed to pad the number of spaces to the number in D4.
                            	  2761: * However, if the number of digits is larger than the no. in
                            	  2762: * D4, all digits are printed anyway. Negative sign is also
                            	  2763: * printed and counted in, positive sign is not.
                            	  2764: *
                            	  2765: * 'PRTLN' prints the saved text line pointed to by A1
                            	  2766: * with line no. and all.
                            	  2767: *
                            	  2768: PRTSTG:
00:00007794 1200            	  2769: 	MOVE.B	D0,D1		save the stop character
                            	  2770: PS1
00:00007796 1019            	  2771: 	MOVE.B	(A1)+,D0	get a text character
00:00007798 B200            	  2772: 	CMP.B	D0,D1		same as stop character?
00:0000779A 6712            	  2773: 	BEQ	PRTRET		if so, return
00:0000779C 6100EA42        	  2774: 	BSR	GOOUT		display the char.
00:000077A0 B03C000D        	  2775: 	CMP.B	#CR,D0		is it a C.R.?
00:000077A4 66F0            	  2776: 	BNE	PS1		no, go back for more
00:000077A6 103C000A        	  2777: 	MOVE.B	#LF,D0		yes, add a L.F.
00:000077AA 6100EA34        	  2778: 	BSR	GOOUT
                            	  2779: PRTRET
00:000077AE 4E75            	  2780: 	RTS			then return
                            	  2781: 
                            	  2782: PRTSTR2a
00:000077B0 1019            	  2783: 	move.b (a1)+,d0
00:000077B2 6100EA2C        	  2784: 	bsr GOOUT
                            	  2785: PRTSTR2:
00:000077B6 51C9FFF8        	  2786: 	dbra d1,PRTSTR2a
00:000077BA 4E75            	  2787: 	rts
                            	  2788: 	
                            	  2789: 	if 0
                            	  2790: QTSTG
                            	  2791: 	bsr	TSTC		*** QTSTG ***
                            	  2792: 	DC.B	'"',QT3-*
                            	  2793: 	MOVE.B	#'"',D0         it is a "
                            	  2794: QT1
                            	  2795: 	MOVE.L	A0,A1
                            	  2796: 	BSR	PRTSTG		print until another
                            	  2797: 	MOVE.L	A1,A0
                            	  2798: 	MOVE.L	(SP)+,A1	pop return address
                            	  2799: 	CMP.B	#LF,D0		was last one a CR?
                            	  2800: 	BEQ	RUNNXL		if so, run next line
                            	  2801: QT2
                            	  2802: 	ADDQ.L	#2,A1		skip 2 bytes on return
                            	  2803: 	JMP	(A1)		return
                            	  2804: QT3
                            	  2805: 	bsr	TSTC		is it a single quote?
                            	  2806: 	DC.B	'''',QT4-*
                            	  2807: 	MOVE.B	#'''',D0        if so, do same as above
                            	  2808: 	BRA	QT1
                            	  2809: QT4
                            	  2810: 	bsr	TSTC		is it an underline?
                            	  2811: 	DC.B	'_',QT5-*
                            	  2812: 	MOVE.B	#CR,D0		if so, output a CR without LF
                            	  2813: 	bsr	GOOUT
                            	  2814: 	MOVE.L	(SP)+,A1	pop return address
                            	  2815: 	BRA	QT2
                            	  2816: QT5
                            	  2817: 	RTS			none of the above
                            	  2818: 	endif
                            	  2819: 
                            	  2820: PRTNUM:
00:000077BC 4E52FFD0        	  2821: 	link a2,#-48
00:000077C0 217900040098002C	  2822: 	move.l _canary,44(a0)
00:000077C8 48D7020F        	  2823: 	movem.l d0/d1/d2/d3/a1,(sp)
00:000077CC F22F68000014    	  2824: 	fmove.x fp0,20(sp)
00:000077D2 F22F68800020    	  2825: 	fmove.x fp1,32(sp)
00:000077D8 F2000400        	  2826: 	fmove.x fp1,fp0					; fp0 = number to print
00:000077DC 43F900040520    	  2827: 	lea _fpBuf,a1						; a1 = pointer to buffer to use
00:000077E2 7027            	  2828: 	moveq #39,d0						; d0 = function #39 print float
00:000077E4 2204            	  2829: 	move.l d4,d1						; d1 = width
00:000077E6 2404            	  2830: 	move.l d4,d2						; d2 = precision max
00:000077E8 7665            	  2831: 	moveq #'e',d3
00:000077EA 4E4F            	  2832: 	trap #15
00:000077EC 4CD7020F        	  2833: 	movem.l (sp),d0/d1/d2/d3/a1
00:000077F0 F22F48000014    	  2834: 	fmove.x 20(sp),fp0
00:000077F6 F22F48800020    	  2835: 	fmove.x 32(sp),fp1
00:000077FC A2A80003002C    	  2836: 	cchk 44(a0)
00:00007802 4E5A            	  2837: 	unlk a2
00:00007804 4E75            	  2838: 	rts
                            	  2839: 
                            	  2840: ; Debugging
                            	  2841: 	if 0
                            	  2842: PRTFP0:
                            	  2843: 	link a2,#-48
                            	  2844: 	move.l _canary,44(a0)
                            	  2845: 	movem.l d0/d1/d2/d3/a1,(sp)
                            	  2846: 	fmove.x fp0,20(sp)
                            	  2847: 	lea _fpBuf,a1						; a1 = pointer to buffer to use
                            	  2848: 	moveq #39,d0						; d0 = function #39 print float
                            	  2849: 	moveq #30,d1						; d1 = width
                            	  2850: 	moveq #25,d2						; d2 = precision max
                            	  2851: 	moveq #'e',d3
                            	  2852: 	trap #15
                            	  2853: 	movem.l (sp),d0/d1/d2/d3/a1
                            	  2854: 	fmove.x 20(sp),fp0
                            	  2855: 	cchk 44(a0)
                            	  2856: 	unlk a2
                            	  2857: 	rts
                            	  2858: 	endif
                            	  2859: 
                            	  2860: PRTLN:
00:00007806 7200            	  2861: 	CLR.L	D1
00:00007808 1219            	  2862: 	MOVE.B (A1)+,D1	get the binary line number
00:0000780A E149            	  2863: 	LSL	#8,D1
00:0000780C 1219            	  2864: 	MOVE.B (A1)+,D1
00:0000780E F2015080        	  2865: 	FMOVE.W D1,FP1
00:00007812 7805            	  2866: 	MOVEQ	#5,D4			; display a 5 digit line no.
00:00007814 61A6            	  2867: 	BSR	PRTNUM
00:00007816 103C0020        	  2868: 	MOVE.B	#' ',D0         followed by a blank
00:0000781A 6100E9C4        	  2869: 	BSR	GOOUT
00:0000781E 4240            	  2870: 	CLR	D0		stop char. is a zero
00:00007820 6000FF72        	  2871: 	BRA	PRTSTG		display the rest of the line
                            	  2872: 
                            	  2873: 
                            	  2874: ; ===== Test text byte following the call to this subroutine. If it
                            	  2875: ; equals the byte pointed to by A0, return to the code following
                            	  2876: ; the call. If they are not equal, branch to the point
                            	  2877: ;	indicated by the offset byte following the text byte.
                            	  2878: 
                            	  2879: TSTC:
00:00007824 6162            	  2880: 	BSR	IGNBLK				; ignore leading blanks
00:00007826 225F            	  2881: 	MOVE.L (SP)+,A1		; get the return address
00:00007828 1219            	  2882: 	MOVE.B (A1)+,D1		; get the byte to compare
00:0000782A B210            	  2883: 	CMP.B	(A0),D1 		;	is it = to what A0 points to?
00:0000782C 6708            	  2884: 	BEQ	TC1						; if so
00:0000782E 7200            	  2885: 	CLR.L	D1					; If not, add the second
00:00007830 1211            	  2886: 	MOVE.B (A1),D1 		; byte following the call to
00:00007832 D3C1            	  2887: 	ADD.L	D1,A1				; the return address.
00:00007834 4ED1            	  2888: 	JMP	(A1)					; jump to the routine
                            	  2889: TC1
00:00007836 5288            	  2890: 	ADDQ.L #1,A0			; if equal, bump text pointer
00:00007838 5289            	  2891: 	ADDQ.L #1,A1			; Skip the 2 bytes following
00:0000783A 4ED1            	  2892: 	JMP	(A1)					; the call and continue.
                            	  2893: 
                            	  2894: 
                            	  2895: ; ===== See if the text pointed to by A0 is a number. If so,
                            	  2896: ;	return the number in FP1 and the number of digits in D2,
                            	  2897: ;	else return zero in FP1 and D2.
                            	  2898: ; If text is not a number, then A0 is not updated, otherwise
                            	  2899: ; A0 is advanced past the number. Note A0 is always updated
                            	  2900: ; past leading spaces.
                            	  2901: 
                            	  2902: TSTNUM:
00:0000783C 4E52FFE0        	  2903: 	link a2,#-32
00:00007840 2F7900040098001C	  2904: 	move.l _canary,28(sp)
00:00007848 48D70202        	  2905: 	movem.l d1/a1,(sp)
00:0000784C F22F68000010    	  2906: 	fmove.x fp0,16(sp)
00:00007852 7029            	  2907: 	moveq #41,d0						; function #41, get float
00:00007854 7201            	  2908: 	moveq #1,d1							; d1 = input stride
00:00007856 2248            	  2909: 	move.l a0,a1						; a1 = pointer to input buffer
00:00007858 4E4F            	  2910: 	trap #15								; call BIOS get float function
00:0000785A 2049            	  2911: 	move.l a1,a0						; set text pointer
00:0000785C 7001            	  2912: 	moveq #DT_NUMERIC,d0		; default data type = number
00:0000785E F2000080        	  2913: 	fmove.x fp0,fp1					; return expected in fp1
00:00007862 4A41            	  2914: 	tst.w d1								; check if a number (digits > 0?)
00:00007864 6706            	  2915: 	beq .0002
00:00007866 7400            	  2916: 	clr.l d2								; d2.l = 0
00:00007868 3401            	  2917: 	move.w d1,d2						; d2 = number of digits
00:0000786A 6008            	  2918: 	bra .0001
                            	  2919: .0002											; not a number, return with orignal text pointer
00:0000786C 7000            	  2920: 	moveq #0,d0							; data type = not a number
00:0000786E 7400            	  2921: 	moveq #0,d2							; d2 = 0
00:00007870 F2024080        	  2922: 	fmove.l d2,fp1					; return a zero
                            	  2923: .0001
00:00007874 4CD70202        	  2924: 	movem.l (sp),d1/a1
00:00007878 F22F48000010    	  2925: 	fmove.x 16(sp),fp0
00:0000787E A2AF0003001C    	  2926: 	cchk 28(sp)
00:00007884 4E5A            	  2927: 	unlk a2
00:00007886 4E75            	  2928: 	rts
                            	  2929: 		
                            	  2930: ; ===== Skip over blanks in the text pointed to by A0.
                            	  2931: 
                            	  2932: IGNBLK:
00:00007888 0C180020        	  2933: 	CMP.B	#' ',(A0)+		; see if it's a space
00:0000788C 67FA            	  2934: 	BEQ	IGNBLK					; if so, swallow it
00:0000788E 5388            	  2935: 	SUBQ.L #1,A0				; decrement the text pointer
00:00007890 4E75            	  2936: 	RTS
                            	  2937: 
                            	  2938: *
                            	  2939: * ===== Convert the line of text in the input buffer to upper
                            	  2940: *	case (except for stuff between quotes).
                            	  2941: *
00:00007892 41FA01A8        	  2942: TOUPBUF LEA	BUFFER,A0	set up text pointer
00:00007896 4201            	  2943: 	CLR.B	D1		clear quote flag
                            	  2944: TOUPB1	
00:00007898 1018            	  2945: 	MOVE.B	(A0)+,D0	get the next text char.
00:0000789A B03C000D        	  2946: 	CMP.B	#CR,D0		is it end of line?
00:0000789E 6718            	  2947: 	BEQ	TOUPBRT 	if so, return
00:000078A0 B03C0022        	  2948: 	CMP.B	#'"',D0         a double quote?
00:000078A4 6714            	  2949: 	BEQ	DOQUO
00:000078A6 B03C0027        	  2950: 	CMP.B	#'''',D0        or a single quote?
00:000078AA 670E            	  2951: 	BEQ	DOQUO
00:000078AC 4A01            	  2952: 	TST.B	D1		inside quotes?
00:000078AE 66E8            	  2953: 	BNE	TOUPB1		if so, do the next one
00:000078B0 6118            	  2954: 	BSR	TOUPPER 	convert to upper case
00:000078B2 1100            	  2955: 	MOVE.B	D0,-(A0)	store it
00:000078B4 5288            	  2956: 	ADDQ.L	#1,A0
00:000078B6 60E0            	  2957: 	BRA	TOUPB1		and go back for more
                            	  2958: TOUPBRT
00:000078B8 4E75            	  2959: 	RTS
                            	  2960: 
00:000078BA 4A01            	  2961: DOQUO	TST.B	D1		are we inside quotes?
00:000078BC 6604            	  2962: 	BNE	DOQUO1
00:000078BE 1200            	  2963: 	MOVE.B	D0,D1		if not, toggle inside-quotes flag
00:000078C0 60D6            	  2964: 	BRA	TOUPB1
00:000078C2 B200            	  2965: DOQUO1	CMP.B	D0,D1		make sure we're ending proper quote
00:000078C4 66D2            	  2966: 	BNE	TOUPB1		if not, ignore it
00:000078C6 4201            	  2967: 	CLR.B	D1		else clear quote flag
00:000078C8 60CE            	  2968: 	BRA	TOUPB1
                            	  2969: 
                            	  2970: *
                            	  2971: * ===== Convert the character in D0 to upper case
                            	  2972: *
00:000078CA B03C0061        	  2973: TOUPPER CMP.B	#'a',D0         is it < 'a'?
00:000078CE 650A            	  2974: 	BCS	TOUPRET
00:000078D0 B03C007A        	  2975: 	CMP.B	#'z',D0         or > 'z'?
00:000078D4 6204            	  2976: 	BHI	TOUPRET
00:000078D6 903C0020        	  2977: 	SUB.B	#32,D0		if not, make it upper case
00:000078DA 4E75            	  2978: TOUPRET RTS
                            	  2979: 
                            	  2980: *
                            	  2981: * 'CHKIO' checks the input. If there's no input, it will return
                            	  2982: * to the caller with the Z flag set. If there is input, the Z
                            	  2983: * flag is cleared and the input byte is in D0. However, if a
                            	  2984: * control-C is read, 'CHKIO' will warm-start BASIC and will not
                            	  2985: * return to the caller.
                            	  2986: *
                            	  2987: CHKIO
00:000078DC 6100E906        	  2988: 	bsr	GOIN		get input if possible
00:000078E0 670A            	  2989: 	BEQ	CHKRET		if Zero, no input
00:000078E2 B03C0003        	  2990: 	CMP.B	#CTRLC,D0	is it control-C?
00:000078E6 6604            	  2991: 	BNE	CHKRET		if not
00:000078E8 6000E97E        	  2992: 	BRA	WSTART		if so, do a warm start
                            	  2993: CHKRET
00:000078EC 4E75            	  2994: 	RTS
                            	  2995: 
                            	  2996: *
                            	  2997: * ===== Display a CR-LF sequence
                            	  2998: *
                            	  2999: ;CRLF	LEA	CLMSG,A6
                            	  3000: 
                            	  3001: 
                            	  3002: ; ===== Display a zero-ended string pointed to by register A6
                            	  3003: 
                            	  3004: PRMESG:
00:000078EE 101E            	  3005: 	MOVE.B (A6)+,D0		; get the char.
00:000078F0 6706            	  3006: 	BEQ	PRMRET				; if it's zero, we're done
00:000078F2 6100E8EC        	  3007: 	BSR	GOOUT					; else display it
00:000078F6 60F6            	  3008: 	BRA	PRMESG
                            	  3009: PRMRET
00:000078F8 4E75            	  3010: 	RTS
                            	  3011: 
                            	  3012: ;*****************************************************
                            	  3013: ; The following routines are the only ones that need *
                            	  3014: ; to be changed for a different I/O environment.     *
                            	  3015: ;*****************************************************
                            	  3016: 
                            	  3017: ; ===== Clear screen and home cursor
                            	  3018: 
                            	  3019: CLS:
00:000078FA 700B            	  3020: 	moveq #11,d0			; set cursor position
00:000078FC 323CFF00        	  3021: 	move.w #$FF00,d1	; home cursor and clear screen
00:00007900 4E4F            	  3022: 	trap #15
00:00007902 6000EE86        	  3023: 	bra FINISH
                            	  3024: 
                            	  3025: ; ===== Output character to the console (Port 1) from register D0
                            	  3026: ;(Preserves all registers.)
                            	  3027: 
                            	  3028: OUTC:
00:00007906 48E7C000        	  3029: 	movem.l d0/d1,-(sp)
00:0000790A 2200            	  3030: 	move.l d0,d1
00:0000790C 7006            	  3031: 	moveq #6,d0
00:0000790E 4E4F            	  3032: 	trap #15
00:00007910 4CDF0003        	  3033: 	movem.l (sp)+,d0/d1
00:00007914 4E75            	  3034: 	rts
                            	  3035: 
                            	  3036: ; ===== Input a character from the console into register D0 (or
                            	  3037: ;	return Zero status if there's no character available).
                            	  3038: ;
                            	  3039: INC
00:00007916 2F0E            	  3040: 	move.l	a6,-(a7)
00:00007918 2C7A00C2        	  3041: 	move.l	INPPTR,a6
00:0000791C 4E96            	  3042: 	jsr			(a6)
00:0000791E 2C5F            	  3043: 	move.l	(a7)+,a6
00:00007920 4E75            	  3044: 	rts
                            	  3045: 
                            	  3046: INC1
00:00007922 2F01            	  3047: 	move.l	d1,-(a7)
00:00007924 7005            	  3048: 	moveq.l	#5,d0			* function 5 GetKey
00:00007926 4E4F            	  3049: 	trap		#15
00:00007928 2001            	  3050: 	move.l	d1,d0
00:0000792A 221F            	  3051: 	move.l	(a7)+,d1
00:0000792C 0C0000FF        	  3052: 	cmpi.b	#-1,d0
00:00007930 6602            	  3053: 	bne			.0001
00:00007932 4200            	  3054: 	clr.b		d0
                            	  3055: .0001:
00:00007934 4E75            	  3056: 	rts
                            	  3057: 
                            	  3058: *INC	BTST	#0,$10040	is character ready?
                            	  3059: *	BEQ	INCRET		if not, return Zero status
                            	  3060: *	MOVE.B	$10042,D0	else get the character
                            	  3061: *	AND.B	#$7F,D0 	zero out the high bit
                            	  3062: *INCRET	RTS
                            	  3063: 
                            	  3064: * ===== Output character to the host (Port 2) from register D0
                            	  3065: *	(Preserves all registers.)
                            	  3066: *
                            	  3067: AUXOUT:
00:00007936 13FC0002000400A8	  3068: 	move.b #2,OutputDevice
00:0000793E 61C6            	  3069: 	bsr OUTC
00:00007940 13FC0001000400A8	  3070: 	move.b #1,OutputDevice
00:00007948 4E75            	  3071: 	rts
                            	  3072: 
                            	  3073: *AUXOUT	BTST	#1,$10041	is port 2 ready for a character?
                            	  3074: *	BEQ	AUXOUT		if not, wait for it
                            	  3075: *	MOVE.B	D0,$10043	out it goes.
                            	  3076: *	RTS
                            	  3077: 
                            	  3078: *
                            	  3079: * ===== Input a character from the host into register D0 (or
                            	  3080: *	return Zero status if there's no character available).
                            	  3081: *
                            	  3082: AUXIN:
00:0000794A 2F01            	  3083: 	move.l	d1,-(a7)
00:0000794C 7024            	  3084: 	moveq		#36,d0				; serial get char from buffer
00:0000794E 4E4F            	  3085: 	trap		#15
00:00007950 2001            	  3086: 	move.l	d1,d0
00:00007952 221F            	  3087: 	move.l	(a7)+,d1
00:00007954 0C40FFFF        	  3088: 	cmpi.w	#-1,d0
00:00007958 670A            	  3089: 	beq			.0001
00:0000795A 0200007F        	  3090: 	andi.b	#$7F,d0				; clear high bit
00:0000795E 4880            	  3091: 	ext.w		d0						; return character in d0
00:00007960 48C0            	  3092: 	ext.l		d0
00:00007962 4E75            	  3093: 	rts
                            	  3094: .0001:
00:00007964 7000            	  3095: 	moveq		#0,d0					; return zf=1 if no character available
00:00007966 4E75            	  3096: 	rts
                            	  3097: 
                            	  3098: ;AUXIN
                            	  3099: *AUXIN	BTST	#0,$10041	is character ready?
                            	  3100: *	BEQ	AXIRET		if not, return Zero status
                            	  3101: *	MOVE.B	$10043,D0	else get the character
                            	  3102: *	AND.B	#$7F,D0 	zero out the high bit
00:00007968 4E75            	  3103: AXIRET	RTS
                            	  3104: 
                            	  3105: ; ===== Return to the resident monitor, operating system, etc.
                            	  3106: ;
                            	  3107: BYEBYE	
00:0000796A 23FC000000080004	  3108: 	move.l #8,_fpTextIncr
00:00007972 0094
00:00007974 600007E6        	  3109: 	bra		Monitor
                            	  3110: ;	MOVE.B	#228,D7 	return to Tutor
                            	  3111: ;	TRAP	#14
                            	  3112: 
00:00007978 0D              	  3113: INITMSG DC.B	CR,LF,'MC68000 Tiny Float BASIC, v1.0',CR,LF,LF,0
00:00007979 0A
00:0000797A 4D43363830303020
00:00007982 54696E7920466C6F
00:0000798A 6174204241534943
00:00007992 2C2076312E30
00:00007998 0D
00:00007999 0A
00:0000799A 0A
00:0000799B 00
00:0000799C 0D              	  3114: OKMSG	DC.B	CR,LF,'OK',CR,LF,0
00:0000799D 0A
00:0000799E 4F4B
00:000079A0 0D
00:000079A1 0A
00:000079A2 00
00:000079A3 486F773F        	  3115: HOWMSG	DC.B	'How?',CR,LF,0
00:000079A7 0D
00:000079A8 0A
00:000079A9 00
00:000079AA 576861743F      	  3116: WHTMSG	DC.B	'What?',CR,LF,0
00:000079AF 0D
00:000079B0 0A
00:000079B1 00
00:000079B2 547970653F      	  3117: TYPMSG	DC.B	'Type?',CR,LF,0
00:000079B7 0D
00:000079B8 0A
00:000079B9 00
00:000079BA 4E6F20737472696E	  3118: NOSTRING	DC.B 'No string space',CR,LF,0
00:000079C2 67207370616365
00:000079C9 0D
00:000079CA 0A
00:000079CB 00
00:000079CC 536F7272792E    	  3119: SRYMSG	DC.B	'Sorry.'
00:000079D2 0D              	  3120: CLMSG	DC.B	CR,LF,0
00:000079D3 0A
00:000079D4 00
00:000079D5 00              	  3121: 	DC.B	0	<- for aligning on a word boundary
                            	  3122: LSTROM	EQU	*		end of possible ROM area
                            	  3123: *
                            	  3124: * Internal variables follow:
                            	  3125: *
                            	  3126: 	align 2
00:000079D8 000061DA        	  3127: RANPNT	DC.L	START		random number pointer
00:000079DC 00000000        	  3128: INPPTR	DS.L	1		input pointer
00:000079E0 00000000        	  3129: OUTPTR	DS.L	1 	output pointer
00:000079E4 00000000        	  3130: CURRNT	DS.L	1		; Current line pointer
00:000079E8 00000000        	  3131: STKFP		DS.L	1		; saves frame pointer
00:000079EC 00000000        	  3132: STKGOS	DS.L	1		Saves stack pointer in 'GOSUB'
00:000079F0 00000000        	  3133: STKINP	DS.L	1		Saves stack pointer during 'INPUT'
00:000079F4 00000000        	  3134: LOPVAR	DS.L	1		'FOR' loop save area
00:000079F8 00000000        	  3135: LOPINC	DS.L	3		increment
00:000079FC *
00:00007A04 00000000        	  3136: LOPLMT	DS.L	3		limit
00:00007A08 *
00:00007A10 00000000        	  3137: LOPLN	DS.L	1		line number
00:00007A14 00000000        	  3138: LOPPT	DS.L	1		text pointer
00:00007A18 00000000        	  3139: IRQROUT	DS.L	1
00:00007A1C 00000000        	  3140: STRSTK	DS.L	1		; string pointer stack area, 8 entries
00:00007A20 00000000        	  3141: StrSp		DS.L	1		; string stack stack pointer
00:00007A24 00000000        	  3142: StrArea	DS.L	1		; pointer to string area
00:00007A28 00000000        	  3143: LastStr	DS.L	1		; pointer to last used string in area
00:00007A2C 00000000        	  3144: TXTUNF	DS.L	1		points to unfilled text area
00:00007A30 00000000        	  3145: VARBGN	DS.L	1		points to variable area
00:00007A34 00000000        	  3146: STKLMT	DS.L	1		holds lower limit for stack growth
00:00007A38 00000000        	  3147: DIRFLG	DS.L	1		; indicates 1=DIRECT mode
00:00007A3C 00              	  3148: BUFFER	DS.B	BUFLEN		Keyboard input buffer
00:00007A3D *
                            	  3149: TXT	EQU	*		Beginning of program area
                            	  3150: ;	END
                            	  3151: 

Source: "boot.x68"
                            	   990: 
                            	   991: ; -----------------------------------------------------------------------------
                            	   992: ; -----------------------------------------------------------------------------
                            	   993: 
                            	   994: set_text_mode:
00:00007A8C 7034            	   995: 	moveq #TEXTCOL,d0
00:00007A8E 13C0FD080000    	   996: 	move.b d0,TEXTREG					; number of columns
00:00007A94 7020            	   997: 	moveq #TEXTROW,d0
00:00007A96 13C0FD080001    	   998: 	move.b d0,TEXTREG+1				; number of rows
00:00007A9C 7000            	   999: 	moveq #0,d0
00:00007A9E 13C0FD080003    	  1000: 	move.b d0,TEXTREG+3				; text mode
00:00007AA4 7011            	  1001: 	moveq #17,d0
00:00007AA6 13C0FD080008    	  1002: 	move.b d0,TEXTREG+8				; max row scan
00:00007AAC 700B            	  1003: 	moveq #11,d0
00:00007AAE 13C0FD08000A    	  1004: 	move.b d0,TEXTREG+10			; max pix
00:00007AB4 4E75            	  1005: 	rts
                            	  1006: 	
                            	  1007: set_graphics_mode:
00:00007AB6 7068            	  1008: 	moveq #TEXTCOL*2,d0
00:00007AB8 13C0FD080000    	  1009: 	move.b d0,TEXTREG					; number of columns
00:00007ABE 7040            	  1010: 	moveq #TEXTROW*2,d0
00:00007AC0 13C0FD080001    	  1011: 	move.b d0,TEXTREG+1				; number of rows
00:00007AC6 7001            	  1012: 	moveq #1,d0
00:00007AC8 13C0FD080003    	  1013: 	move.b d0,TEXTREG+3				; graphics mode
00:00007ACE 7007            	  1014: 	moveq #7,d0
00:00007AD0 13C0FD080008    	  1015: 	move.b d0,TEXTREG+8				; max row scan
00:00007AD6 7007            	  1016: 	moveq #7,d0
00:00007AD8 13C0FD08000A    	  1017: 	move.b d0,TEXTREG+10			; max pix
00:00007ADE 4E75            	  1018: 	rts
                            	  1019: 
                            	  1020: ; -----------------------------------------------------------------------------
                            	  1021: ; -----------------------------------------------------------------------------
                            	  1022: 
                            	  1023: get_screen_address:
00:00007AE0 48E7E300        	  1024: 	movem.l d0/d1/d2/d6/d7,-(a7)
00:00007AE4 7E02            	  1025: 	moveq #2,d7
00:00007AE6 7C10            	  1026: 	moveq #DEV_GETBUF1,d6
00:00007AE8 4E40            	  1027: 	trap #0
00:00007AEA 2041            	  1028: 	move.l d1,a0
00:00007AEC 4CDF00C7        	  1029: 	movem.l (a7)+,d0/d1/d2/d6/d7
00:00007AF0 4E75            	  1030: 	rts
                            	  1031: 	
                            	  1032: 
                            	  1033: CRLF:
00:00007AF2 48E7C000        	  1034: 	movem.l d0/d1,-(a7)
00:00007AF6 123C000D        	  1035: 	move.b #13,d1
00:00007AFA 7006            	  1036: 	moveq #6,d0						; output character function
00:00007AFC 4E4F            	  1037: 	trap #15
00:00007AFE 123C000A        	  1038: 	move.b #10,d1
00:00007B02 7006            	  1039: 	moveq #6,d0						; output character function
00:00007B04 4E4F            	  1040: 	trap #15
00:00007B06 4CDF0003        	  1041: 	movem.l (a7)+,d0/d1
00:00007B0A 4E75            	  1042: 	rts
                            	  1043: 
                            	  1044: ;------------------------------------------------------------------------------
                            	  1045: ; Display a string on standard output.
                            	  1046: ;------------------------------------------------------------------------------
                            	  1047: 
                            	  1048: DisplayString:
00:00007B0C 48E7C040        	  1049: 	movem.l	d0/d1/a1,-(a7)
                            	  1050: dspj1:
00:00007B10 7200            	  1051: 	clr.l d1							; clear upper bits of d1
00:00007B12 1219            	  1052: 	move.b (a1)+,d1				; move string char into d1
00:00007B14 6706            	  1053: 	beq.s dsret						; is it end of string ?
00:00007B16 7006            	  1054: 	moveq #6,d0						; output character function
00:00007B18 4E4F            	  1055: 	trap #15
00:00007B1A 60F4            	  1056: 	bra.s	dspj1						; go back for next character
                            	  1057: dsret:
00:00007B1C 4CDF0203        	  1058: 	movem.l	(a7)+,d0/d1/a1
00:00007B20 4E75            	  1059: 	rts
                            	  1060: 
                            	  1061: ;------------------------------------------------------------------------------
                            	  1062: ; Display a string on the screen followed by carriage return / linefeed.
                            	  1063: ;------------------------------------------------------------------------------
                            	  1064: 
                            	  1065: DisplayStringCRLF:
00:00007B22 61E8            	  1066: 	bsr		DisplayString
00:00007B24 60CC            	  1067: 	bra		CRLF
                            	  1068: 
                            	  1069: ;------------------------------------------------------------------------------
                            	  1070: ; Display a string on the screen limited to 255 chars max.
                            	  1071: ;------------------------------------------------------------------------------
                            	  1072: 
                            	  1073: DisplayStringLimited:
00:00007B26 48E7E040        	  1074: 	movem.l	d0/d1/d2/a1,-(a7)
00:00007B2A 3401            	  1075: 	move.w	d1,d2					; d2 = max count
00:00007B2C 024200FF        	  1076: 	andi.w	#$00FF,d2			; limit to 255 chars
00:00007B30 600A            	  1077: 	bra.s		.0003					; enter loop at bottom
                            	  1078: .0001:
00:00007B32 7200            	  1079: 	clr.l d1							; clear upper bits of d1
00:00007B34 1219            	  1080: 	move.b (a1)+,d1				; move string char into d1
00:00007B36 6708            	  1081: 	beq.s .0002						; is it end of string ?
00:00007B38 7006            	  1082: 	moveq #6,d0						; output character function
00:00007B3A 4E4F            	  1083: 	trap #15
                            	  1084: .0003:
00:00007B3C 51CAFFF4        	  1085: 	dbra		d2,.0001			; go back for next character
                            	  1086: .0002:
00:00007B40 4CDF0207        	  1087: 	movem.l	(a7)+,d0/d1/d2/a1
00:00007B44 4E75            	  1088: 	rts
                            	  1089: 
                            	  1090: DisplayStringLimitedCRLF:
00:00007B46 61DE            	  1091: 	bsr		DisplayStringLimited
00:00007B48 60A8            	  1092: 	bra		CRLF
                            	  1093: 	
                            	  1094: 
                            	  1095: ;==============================================================================
                            	  1096: ; TRAP #15 handler
                            	  1097: ;
                            	  1098: ; Parameters:
                            	  1099: ;		d0.w = function number to perform
                            	  1100: ;==============================================================================
                            	  1101: 
                            	  1102: TRAP15:
00:00007B4A 48E78080        	  1103: 	movem.l	d0/a0,-(a7)
00:00007B4E 41FA0014        	  1104: 	lea T15DispatchTable,a0
00:00007B52 4880            	  1105: 	ext.w d0
00:00007B54 E548            	  1106: 	lsl.w #2,d0
00:00007B56 20700000        	  1107: 	move.l (a0,d0.w),a0
00:00007B5A 4E90            	  1108: 	jsr (a0)
00:00007B5C 4CDF0101        	  1109: 	movem.l (a7)+,d0/a0
00:00007B60 4E73            	  1110: 	rte
                            	  1111: 
                            	  1112: 		align	2
                            	  1113: T15DispatchTable:
00:00007B64 00007B46        	  1114: 	dc.l	DisplayStringLimitedCRLF
00:00007B68 00007B26        	  1115: 	dc.l	DisplayStringLimited
00:00007B6C 00007FFA        	  1116: 	dc.l	StubRout
00:00007B70 00007FFA        	  1117: 	dc.l	StubRout
00:00007B74 00007FFA        	  1118: 	dc.l	StubRout
00:00007B78 00000898        	  1119: 	dc.l	GetKey
00:00007B7C 00009F2A        	  1120: 	dc.l	OutputChar
00:00007B80 0000088C        	  1121: 	dc.l	CheckForKey
00:00007B84 00007D04        	  1122: 	dc.l	GetTick
00:00007B88 00007FFA        	  1123: 	dc.l	StubRout
                            	  1124: 	; 10
00:00007B8C 00007FFA        	  1125: 	dc.l	StubRout
00:00007B90 00007FC2        	  1126: 	dc.l	Cursor1
00:00007B94 00000884        	  1127: 	dc.l	SetKeyboardEcho
00:00007B98 00007B22        	  1128: 	dc.l	DisplayStringCRLF
00:00007B9C 00007B0C        	  1129: 	dc.l	DisplayString
00:00007BA0 00007FFA        	  1130: 	dc.l	StubRout
00:00007BA4 00007FFA        	  1131: 	dc.l	StubRout
00:00007BA8 00007FFA        	  1132: 	dc.l	StubRout
00:00007BAC 00007FFA        	  1133: 	dc.l	StubRout
00:00007BB0 0000088C        	  1134: 	dc.l	CheckForKey
                            	  1135: 	; 20
00:00007BB4 00007FFA        	  1136: 	dc.l	StubRout
00:00007BB8 00007FFA        	  1137: 	dc.l	StubRout
00:00007BBC 00007FFA        	  1138: 	dc.l	StubRout
00:00007BC0 00007D0C        	  1139: 	dc.l	T15Wait100ths
00:00007BC4 00007FFA        	  1140: 	dc.l	StubRout
00:00007BC8 00007FFA        	  1141: 	dc.l	StubRout
00:00007BCC 00007FFA        	  1142: 	dc.l	StubRout
00:00007BD0 00007FFA        	  1143: 	dc.l	StubRout
00:00007BD4 00007FFA        	  1144: 	dc.l	StubRout
00:00007BD8 00007FFA        	  1145: 	dc.l	StubRout
                            	  1146: 	; 30
00:00007BDC 00007FFA        	  1147: 	dc.l	StubRout
00:00007BE0 00007FFA        	  1148: 	dc.l	StubRout
00:00007BE4 00007CF4        	  1149: 	dc.l	SimHardware	;rotate_iofocus
00:00007BE8 00007D88        	  1150: 	dc.l	T15GetWindowSize	;SerialPeekCharDirect
00:00007BEC 00001758        	  1151: 	dc.l	SerialPutChar
00:00007BF0 00001702        	  1152: 	dc.l	SerialPeekChar
00:00007BF4 0000168A        	  1153: 	dc.l	SerialGetChar
00:00007BF8 00002606        	  1154: 	dc.l	T15LockSemaphore
00:00007BFC 0000260C        	  1155: 	dc.l	T15UnlockSemaphore
00:00007C00 00009E8A        	  1156: 	dc.l	prtflt
                            	  1157: 	; 40
00:00007C04 0000254C        	  1158: 	dc.l  _GetRand
00:00007C08 00002612        	  1159: 	dc.l	T15GetFloat
00:00007C0C 00002628        	  1160: 	dc.l	T15Abort
00:00007C10 00009ED0        	  1161: 	dc.l	T15FloatToString
00:00007C14 00007FFA        	  1162: 	dc.l	StubRout
00:00007C18 00007FFA        	  1163: 	dc.l	StubRout
00:00007C1C 00007FFA        	  1164: 	dc.l	StubRout
00:00007C20 00007FFA        	  1165: 	dc.l	StubRout
00:00007C24 00007FFA        	  1166: 	dc.l	StubRout
00:00007C28 00007FFA        	  1167: 	dc.l	StubRout
                            	  1168: 	; 50
00:00007C2C 00007FFA        	  1169: 	dc.l	StubRout
00:00007C30 00007FFA        	  1170: 	dc.l	StubRout
00:00007C34 00007FFA        	  1171: 	dc.l	StubRout
00:00007C38 00007FFA        	  1172: 	dc.l	StubRout
00:00007C3C 00007FFA        	  1173: 	dc.l	StubRout
00:00007C40 00007FFA        	  1174: 	dc.l	StubRout
00:00007C44 00007FFA        	  1175: 	dc.l	StubRout
00:00007C48 00007FFA        	  1176: 	dc.l	StubRout
00:00007C4C 00007FFA        	  1177: 	dc.l	StubRout
00:00007C50 00007FFA        	  1178: 	dc.l	StubRout
                            	  1179: 	; 60
00:00007C54 00007FFA        	  1180: 	dc.l	StubRout
00:00007C58 00007FFA        	  1181: 	dc.l	StubRout
00:00007C5C 00007FFA        	  1182: 	dc.l	StubRout
00:00007C60 00007FFA        	  1183: 	dc.l	StubRout
00:00007C64 00007FFA        	  1184: 	dc.l	StubRout
00:00007C68 00007FFA        	  1185: 	dc.l	StubRout
00:00007C6C 00007FFA        	  1186: 	dc.l	StubRout
00:00007C70 00007FFA        	  1187: 	dc.l	StubRout
00:00007C74 00007FFA        	  1188: 	dc.l	StubRout
00:00007C78 00007FFA        	  1189: 	dc.l	StubRout
                            	  1190: 	; 70
00:00007C7C 00007FFA        	  1191: 	dc.l	StubRout
00:00007C80 00007FFA        	  1192: 	dc.l	StubRout
00:00007C84 00007FFA        	  1193: 	dc.l	StubRout
00:00007C88 00007FFA        	  1194: 	dc.l	StubRout
00:00007C8C 00007FFA        	  1195: 	dc.l	StubRout
00:00007C90 00007FFA        	  1196: 	dc.l	StubRout
00:00007C94 00007FFA        	  1197: 	dc.l	StubRout
00:00007C98 00007FFA        	  1198: 	dc.l	StubRout
00:00007C9C 00007FFA        	  1199: 	dc.l	StubRout
00:00007CA0 00007FFA        	  1200: 	dc.l	StubRout
                            	  1201: 	; 80
00:00007CA4 00007D4A        	  1202: 	dc.l	SetPenColor
00:00007CA8 00007FFA        	  1203: 	dc.l	StubRout
00:00007CAC 00007FFA        	  1204: 	dc.l	StubRout
00:00007CB0 00007FFA        	  1205: 	dc.l	StubRout
00:00007CB4 00007FFA        	  1206: 	dc.l	StubRout
00:00007CB8 00007EE2        	  1207: 	dc.l	DrawToXY
00:00007CBC 00007ED4        	  1208: 	dc.l	MoveToXY
00:00007CC0 00007FFA        	  1209: 	dc.l	StubRout
00:00007CC4 00007FFA        	  1210: 	dc.l	StubRout
00:00007CC8 00007FFA        	  1211: 	dc.l	StubRout
                            	  1212: 	; 90
00:00007CCC 00007D56        	  1213: 	dc.l	T15Rectangle
00:00007CD0 00007FFA        	  1214: 	dc.l	StubRout
00:00007CD4 00007D28        	  1215: 	dc.l	SetDrawMode
00:00007CD8 00007FFA        	  1216: 	dc.l	StubRout
00:00007CDC 00007D9E        	  1217: 	dc.l	GRBufferToScreen
00:00007CE0 00007FFA        	  1218: 	dc.l	StubRout
00:00007CE4 00007FFA        	  1219: 	dc.l	StubRout
00:00007CE8 00007FFA        	  1220: 	dc.l	StubRout
00:00007CEC 00007FFA        	  1221: 	dc.l	StubRout
00:00007CF0 00007FFA        	  1222: 	dc.l	StubRout
                            	  1223: 
                            	  1224: ;------------------------------------------------------------------------------
                            	  1225: 
                            	  1226: SimHardware:
00:00007CF4 0C410003        	  1227: 	cmpi.w #3,d1
00:00007CF8 6608            	  1228: 	bne.s .0001
00:00007CFA 223C000408B8    	  1229: 	move.l #sys_switches,d1
00:00007D00 4E75            	  1230: 	rts
                            	  1231: .0001:
00:00007D02 4E75            	  1232: 	rts
                            	  1233: 
                            	  1234: ;------------------------------------------------------------------------------
                            	  1235: ;
                            	  1236: GetTick:
00:00007D04 22390004009C    	  1237: 	move.l tickcnt,d1
00:00007D0A 4E75            	  1238: 	rts
                            	  1239: 
                            	  1240: T15Wait100ths:
00:00007D0C 2F01            	  1241: 	move.l d1,-(a7)
00:00007D0E B2BC00000002    	  1242: 	cmp.l #2,d1
00:00007D14 630E            	  1243: 	bls.s .0002
00:00007D16 D2B90004009C    	  1244: 	add.l tickcnt,d1
                            	  1245: .0001:
00:00007D1C B2B90004009C    	  1246: 	cmp.l tickcnt,d1
00:00007D22 66F8            	  1247: 	bne.s .0001
                            	  1248: .0002:
00:00007D24 221F            	  1249: 	move.l (a7)+,d1
00:00007D26 4E75            	  1250: 	rts
                            	  1251: 
                            	  1252: ;------------------------------------------------------------------------------
                            	  1253: ;
                            	  1254: SetDrawMode:
00:00007D28 0C01000A        	  1255: 	cmpi.b #10,d1
00:00007D2C 660A            	  1256: 	bne.s .0001
00:00007D2E 13FC000500040D80	  1257: 	move.b #5,framebuf_dcb+DCB_OPCODE			; 'OR' operation
00:00007D36 4E75            	  1258: 	rts
                            	  1259: .0001:
00:00007D38 0C010011        	  1260: 	cmpi.b #17,d1
00:00007D3C 660A            	  1261: 	bne.s .0002
00:00007D3E 33FC0001000408AC	  1262: 	move.w #1,gr_double_buffer
00:00007D46 4E75            	  1263: 	rts
                            	  1264: .0002:
00:00007D48 4E75            	  1265: 	rts
                            	  1266: 	
                            	  1267: SetPenColor:
00:00007D4A 6100A322        	  1268: 	bsr gfxaccel_set_color
00:00007D4E 23C100040D7C    	  1269: 	move.l d1,framebuf_dcb+DCB_FGCOLOR
00:00007D54 4E75            	  1270: 	rts
                            	  1271: 
                            	  1272: ; parameters:
                            	  1273: ;		d0 = color
                            	  1274: ;		d1 = width
                            	  1275: ;		d2 = height
                            	  1276: ;		d3 = x co-ord
                            	  1277: ;		d4 = y co-ord
                            	  1278: 
                            	  1279: T15Rectangle:
00:00007D56 48E76000        	  1280: 	movem.l d1/d2,-(a7)
00:00007D5A D283            	  1281: 	add.l d3,d1
00:00007D5C D484            	  1282: 	add.l d4,d2
00:00007D5E 6100A490        	  1283: 	bsr gfxaccel_draw_rectangle
00:00007D62 4CDF0006        	  1284: 	movem.l (a7)+,d1/d2
00:00007D66 4E75            	  1285: 	rts
                            	  1286: 
                            	  1287: T15GetPixel:
00:00007D68 48E76080        	  1288: 	movem.l d1/d2/a0,-(a7)
00:00007D6C 48C1            	  1289: 	ext.l d1								; clear upper bits
00:00007D6E 48C2            	  1290: 	ext.l d2
00:00007D70 207900040D54    	  1291: 	move.l framebuf_dcb+DCB_OUTBUFPTR,a0
00:00007D76 C4FC0320        	  1292: 	mulu #800,d2						; y * pixels per line
00:00007D7A D481            	  1293: 	add.l d1,d2							; + x
00:00007D7C E58A            	  1294: 	lsl.l #2,d2							; * 4 bytes per pixel
00:00007D7E 20302800        	  1295: 	move.l (a0,d2.l),d0			; get color
00:00007D82 4CDF0106        	  1296: 	movem.l (a7)+,d1/d2/a0
00:00007D86 4E75            	  1297: 	rts
                            	  1298: 
                            	  1299: T15GetWindowSize:
00:00007D88 4A01            	  1300: 	cmpi.b #0,d1
00:00007D8A 660C            	  1301: 	bne.s .0001
00:00007D8C 323C0320        	  1302: 	move.w #800,d1
00:00007D90 4841            	  1303: 	swap d1
00:00007D92 323C0258        	  1304: 	move.w #600,d1
00:00007D96 4E75            	  1305: 	rts
                            	  1306: .0001:
00:00007D98 7200            	  1307: 	move.l #0,d1
00:00007D9A 7200            	  1308: 	move.l #0,d1
00:00007D9C 4E75            	  1309: 	rts
                            	  1310: 
                            	  1311: ;------------------------------------------------------------------------------
                            	  1312: ; Page flip between two buffers.
                            	  1313: ;------------------------------------------------------------------------------
                            	  1314: 
                            	  1315: GRBufferToScreen:
00:00007D9E 7E06            	  1316: 	move.l #6,d7						; framebuffer device
00:00007DA0 7C0D            	  1317: 	move.l #DEV_SWAPBUF,d6	; swap buffers
00:00007DA2 4E40            	  1318: 	trap #0
00:00007DA4 4E75            	  1319: 	rts
                            	  1320: 
                            	  1321: ; The following copies the buffer, why? Not needed if page flipping.
                            	  1322: ;	movem.l d0/a0/a1,-(a7)
                            	  1323: ;	move.l gr_bitmap_buffer,a1
                            	  1324: ;	move.l gr_bitmap_screen,a0
                            	  1325: ;	move.w gr_width,d0
                            	  1326: ;	mulu gr_height,d0
                            	  1327: ;	lsr.l #4,d0							; moving 16 pixels per iteration
                            	  1328: ;	move.l #0,$BFFFFFF8			; set burst length zero
                            	  1329: ;	bra.s .loop
                            	  1330: ;.loop2:
                            	  1331: ;	swap d0
                            	  1332: ;.loop:
                            	  1333: ;	move.l a1,$BFFFFFF0			; set source address
                            	  1334: ;	tst.l $BFFFFFFC					; do a read op, no value needed
                            	  1335: ;	move.l a0,$BFFFFFF4			; set destination address
                            	  1336: ;	move.l d0,$BFFFFFFC			; do a write operation (any value)
                            	  1337: ;	dbra d0,.loop
                            	  1338: ;	swap d0									; might go over 32/64 kB
                            	  1339: ;	dbra d0,.loop2
                            	  1340: ;	movem.l (a7)+,d0/a0/a1
                            	  1341: ;	rts
                            	  1342: 
                            	  1343: 
                            	  1344: TestBitmap:
                            	  1345: ;	move.w #$0700,pen_color		; dark blue
00:00007DA6 33FC070000040D78	  1346: 	move.w #$0700,framebuf_dcb+DCB_BKCOLOR
00:00007DAE 7E06            	  1347: 	move.l #6,d7
00:00007DB0 7C0C            	  1348: 	move.l #DEV_CLEAR,d6
00:00007DB2 4E40            	  1349: 	trap #0
                            	  1350: ;	bsr clear_bitmap_screen4
00:00007DB4 705E            	  1351: 	moveq #94,d0							; page flip (display blank screen)
00:00007DB6 4E4F            	  1352: 	trap #15
00:00007DB8 33FC007C00040890	  1353: 	move.w #$007c,pen_color		; red pen
00:00007DC0 7E06            	  1354: 	moveq #6,d7
00:00007DC2 7C07            	  1355: 	moveq #DEV_SET_OUTPOS,d6
00:00007DC4 7200            	  1356: 	moveq #0,d1
00:00007DC6 7401            	  1357: 	moveq #1,d2
00:00007DC8 4E40            	  1358: 	trap #0
00:00007DCA 7C14            	  1359: 	moveq #DEV_GET_DIMEN,d6
00:00007DCC 4E40            	  1360: 	trap #0
00:00007DCE 5381            	  1361: 	subq.l #1,d1
00:00007DD0 2601            	  1362: 	move.l d1,d3
00:00007DD2 7801            	  1363: 	moveq #1,d4
00:00007DD4 6100018A        	  1364: 	bsr DrawHorizTo
00:00007DD8 42B900040894    	  1365: 	clr.l gr_x
00:00007DDE 42B900040898    	  1366: 	clr.l gr_y
00:00007DE4 7600            	  1367: 	move.l #0,d3
00:00007DE6 2839000408A0    	  1368: 	move.l gr_height,d4
00:00007DEC 5384            	  1369: 	subq.l #1,d4
00:00007DEE 610001A2        	  1370: 	bsr DrawVertTo
00:00007DF2 33FCE00100040890	  1371: 	move.w #$E001,pen_color		; green pen
00:00007DFA 23FC000000020004	  1372: 	move.l #2,gr_x
00:00007E02 0894
00:00007E04 42B900040898    	  1373: 	clr.l gr_y
00:00007E0A 7602            	  1374: 	move.l #2,d3
00:00007E0C 2839000408A0    	  1375: 	move.l gr_height,d4
00:00007E12 5384            	  1376: 	subq.l #1,d4
00:00007E14 6100017C        	  1377: 	bsr DrawVertTo
00:00007E18 42B900040894    	  1378: 	clr.l gr_x
00:00007E1E 42B900040898    	  1379: 	clr.l gr_y
00:00007E24 26390004089C    	  1380: 	move.l gr_width,d3
00:00007E2A 5383            	  1381: 	subq.l #1,d3
00:00007E2C 23C300040894    	  1382: 	move.l d3,gr_x
00:00007E32 2839000408A0    	  1383: 	move.l gr_height,d4
00:00007E38 5384            	  1384: 	subq.l #1,d4
00:00007E3A 610000A6        	  1385: 	bsr DrawToXY
00:00007E3E 705E            	  1386: 	moveq #94,d0							; page flip again
00:00007E40 4E4F            	  1387: 	trap #15
00:00007E42 60000318        	  1388: 	bra Monitor
                            	  1389: 
                            	  1390: Diagonal1:
00:00007E46 42B900040894    	  1391: 	clr.l gr_x
00:00007E4C 42B900040898    	  1392: 	clr.l gr_y
00:00007E52 26390004089C    	  1393: 	move.l gr_width,d3
00:00007E58 5383            	  1394: 	subq.l #1,d3
00:00007E5A 2839000408A0    	  1395: 	move.l gr_height,d4
00:00007E60 5384            	  1396: 	subq.l #1,d4
00:00007E62 617E            	  1397: 	bsr DrawToXY
00:00007E64 4E75            	  1398: 	rts
                            	  1399: 
                            	  1400: Diagonal2:
00:00007E66 26390004089C    	  1401: 	move.l gr_width,d3
00:00007E6C 5383            	  1402: 	subq.l #1,d3
00:00007E6E 23C300040894    	  1403: 	move.l d3,gr_x
00:00007E74 42B900040898    	  1404: 	clr.l gr_y
00:00007E7A 2639000408A0    	  1405: 	move.l gr_height,d3
00:00007E80 5383            	  1406: 	subq.l #1,d3
00:00007E82 7800            	  1407: 	moveq #0,d4
00:00007E84 33FCE00100040890	  1408: 	move.w #$E001,pen_color
00:00007E8C 6154            	  1409: 	bsr DrawToXY
00:00007E8E 4E75            	  1410: 	rts
                            	  1411: 
                            	  1412: Vertical1:
00:00007E90 42B900040894    	  1413: 	clr.l gr_x
00:00007E96 42B900040898    	  1414: 	clr.l gr_y
00:00007E9C 7600            	  1415: 	move.l #0,d3
00:00007E9E 2839000408A0    	  1416: 	move.l gr_height,d4
00:00007EA4 5384            	  1417: 	subq.l #1,d4
00:00007EA6 610000EA        	  1418: 	bsr DrawVertTo
00:00007EAA 4E75            	  1419: 	rts
                            	  1420: 
                            	  1421: Vertical2:
00:00007EAC 33FCE00100040890	  1422: 	move.w #$E001,pen_color		; green pen
00:00007EB4 23FC000000020004	  1423: 	move.l #2,gr_x
00:00007EBC 0894
00:00007EBE 42B900040898    	  1424: 	clr.l gr_y
00:00007EC4 7602            	  1425: 	move.l #2,d3
00:00007EC6 2839000408A0    	  1426: 	move.l gr_height,d4
00:00007ECC 5384            	  1427: 	subq.l #1,d4
00:00007ECE 610000C2        	  1428: 	bsr DrawVertTo
00:00007ED2 4E75            	  1429: 	rts
                            	  1430: 
                            	  1431: ;------------------------------------------------------------------------------
                            	  1432: ; Plot on bitmap screen using current pen color.
                            	  1433: ;
                            	  1434: ;	Parameters:
                            	  1435: ;		d1 = x co-ordinate
                            	  1436: ;		d2 = y co-ordinate
                            	  1437: ;------------------------------------------------------------------------------
                            	  1438: 	
                            	  1439: ;parameter OPBLACK = 4'd0;
                            	  1440: ;parameter OPCOPY = 4'd1;
                            	  1441: ;parameter OPINV = 4'd2;
                            	  1442: ;parameter OPAND = 4'd4;
                            	  1443: ;parameter OPOR = 4'd5;
                            	  1444: ;parameter OPXOR = 4'd6;
                            	  1445: ;parameter OPANDN = 4'd7;
                            	  1446: ;parameter OPNAND = 4'd8;
                            	  1447: ;parameter OPNOR = 4'd9;
                            	  1448: ;parameter OPXNOR = 4'd10;
                            	  1449: ;parameter OPORN = 4'd11;
                            	  1450: ;parameter OPWHITE = 4'd15;
                            	  1451: 
                            	  1452: ;------------------------------------------------------------------------------
                            	  1453: ; Set graphics cursor position.
                            	  1454: ;------------------------------------------------------------------------------
                            	  1455: 
                            	  1456: MoveToXY:
00:00007ED4 23C300040894    	  1457: 	move.l d3,gr_x
00:00007EDA 23C400040898    	  1458: 	move.l d4,gr_y
00:00007EE0 4E75            	  1459: 	rts
                            	  1460: 
                            	  1461: ;------------------------------------------------------------------------------
                            	  1462: ; Draw a line from the current graphics position to x1,y1.
                            	  1463: ;
                            	  1464: ; Register Usage:
                            	  1465: ;		d1 = x0
                            	  1466: ;		d2 = y0
                            	  1467: ;		d3 = x1
                            	  1468: ;		d4 = y1
                            	  1469: ;		d5 = dx
                            	  1470: ;		d6 = dy
                            	  1471: ;		d7 = sx
                            	  1472: ;		d0 = sy
                            	  1473: ;		a0 = err
                            	  1474: ;		a1 = 2*err
                            	  1475: ;------------------------------------------------------------------------------
                            	  1476: 
                            	  1477: DrawToXY:
00:00007EE2 48E7E7C0        	  1478: 	movem.l d0/d1/d2/d5/d6/d7/a0/a1,-(a7)
00:00007EE6 223900040894    	  1479: 	move.l gr_x,d1
00:00007EEC 243900040898    	  1480: 	move.l gr_y,d2
00:00007EF2 2A03            	  1481: 	move.l d3,d5
00:00007EF4 2C04            	  1482: 	move.l d4,d6
00:00007EF6 9A81            	  1483: 	sub.l d1,d5			; d5 = x1-x0
00:00007EF8 6608            	  1484: 	bne.s .notVert
00:00007EFA 4CDF03E7        	  1485: 	movem.l (a7)+,d0/d1/d2/d5/d6/d7/a0/a1
00:00007EFE 60000092        	  1486: 	bra DrawVertTo
                            	  1487: .notVert:
00:00007F02 6A02            	  1488: 	bpl.s .0001
00:00007F04 4485            	  1489: 	neg.l d5				
                            	  1490: .0001:						; d5 = dx = abs(x1-x0)
00:00007F06 9C82            	  1491: 	sub.l d2,d6			; d6 = y1-y0
00:00007F08 6606            	  1492: 	bne.s .notHoriz
00:00007F0A 4CDF03E7        	  1493: 	movem.l (a7)+,d0/d1/d2/d5/d6/d7/a0/a1
00:00007F0E 6050            	  1494: 	bra DrawHorizTo
                            	  1495: .notHoriz:
00:00007F10 6B02            	  1496: 	bmi.s .0002
00:00007F12 4486            	  1497: 	neg.l d6
                            	  1498: .0002:						; d6 = dy = -abs(y1-y0)
00:00007F14 7E01            	  1499: 	move.l #1,d7		; d7 = sx (x0 < x1 ? 1 : -1)
00:00007F16 B681            	  1500: 	cmp.l d1,d3
00:00007F18 6202            	  1501: 	bhi.s .0004
00:00007F1A 4487            	  1502: 	neg.l d7
                            	  1503: .0004:
00:00007F1C 7001            	  1504: 	move.l #1,d0		; d0 = sy (y0 < y1) ? 1 : -1)
00:00007F1E B882            	  1505: 	cmp.l d2,d4
00:00007F20 6202            	  1506: 	bhi.s .0006
00:00007F22 4480            	  1507: 	neg.l d0
                            	  1508: .0006:
00:00007F24 2045            	  1509: 	move.l d5,a0		; a0 = error = dx + dy
00:00007F26 D1C6            	  1510: 	adda.l d6,a0
                            	  1511: .loop:
00:00007F28 610089A8        	  1512: 	bsr CheckForCtrlC
00:00007F2C 61009CC2        	  1513: 	bsr plot				; plot(x0,y0)
00:00007F30 2248            	  1514: 	move.l a0,a1
00:00007F32 D3C9            	  1515: 	adda.l a1,a1		; a1 = error *2
00:00007F34 BC89            	  1516: 	cmp.l a1,d6			; e2 >= dy?
00:00007F36 6E08            	  1517: 	bgt.s .0008
00:00007F38 B681            	  1518: 	cmp.l d1,d3			; x0==x1?
00:00007F3A 6712            	  1519: 	beq.s .brkloop
00:00007F3C D1C6            	  1520: 	adda.l d6,a0		; err = err + dy
00:00007F3E D287            	  1521: 	add.l d7,d1			; x0 = x0 + sx
                            	  1522: .0008:
00:00007F40 BA89            	  1523: 	cmp.l a1,d5			; err2 <= dx?
00:00007F42 6D08            	  1524: 	blt.s .0009
00:00007F44 B882            	  1525: 	cmp.l d2,d4			; y0==y1?
00:00007F46 6706            	  1526: 	beq.s .brkloop
00:00007F48 D1C5            	  1527: 	adda.l d5,a0		; err = err + dx
00:00007F4A D480            	  1528: 	add.l d0,d2			; y0 = y0 + sy
                            	  1529: .0009:
00:00007F4C 60DA            	  1530: 	bra.s .loop
                            	  1531: .brkloop:
00:00007F4E 23C300040894    	  1532: 	move.l d3,gr_x
00:00007F54 23C400040898    	  1533: 	move.l d4,gr_y
00:00007F5A 4CDF03E7        	  1534: 	movem.l (a7)+,d0/d1/d2/d5/d6/d7/a0/a1
00:00007F5E 4E75            	  1535: 	rts
                            	  1536: 
                            	  1537: ; Parameters:
                            	  1538: ;		d3 = x1
                            	  1539: ;		d4 = y1
                            	  1540: 
                            	  1541: DrawHorizTo:
00:00007F60 48E76400        	  1542: 	movem.l d1/d2/d5,-(a7)
00:00007F64 7E06            	  1543: 	moveq #6,d7
00:00007F66 7C17            	  1544: 	moveq #DEV_GET_OUTPOS,d6
00:00007F68 4E40            	  1545: 	trap #0
00:00007F6A 7A01            	  1546: 	move.l #1,d5			; assume increment
00:00007F6C B681            	  1547: 	cmp.l d1,d3
00:00007F6E 6202            	  1548: 	bhi.s .0001
00:00007F70 4485            	  1549: 	neg.l d5					; switch to decrement
                            	  1550: .0001:
00:00007F72 7E06            	  1551: 	moveq #6,d7
00:00007F74 7C12            	  1552: 	moveq #DEV_WRITEAT,d6
00:00007F76 4E40            	  1553: 	trap #0
00:00007F78 B681            	  1554: 	cmp.l d1,d3
00:00007F7A 670A            	  1555: 	beq.s .0002
00:00007F7C D285            	  1556: 	add.l d5,d1
00:00007F7E 7E06            	  1557: 	moveq #6,d7
00:00007F80 7C07            	  1558: 	moveq #DEV_SET_OUTPOS,d6
00:00007F82 4E40            	  1559: 	trap #0
00:00007F84 60EC            	  1560: 	bra.s .0001
                            	  1561: .0002:
00:00007F86 7E06            	  1562: 	moveq #6,d7
00:00007F88 7C07            	  1563: 	moveq #DEV_SET_OUTPOS,d6	; update output position
00:00007F8A 4E40            	  1564: 	trap #0
00:00007F8C 4CDF0026        	  1565: 	movem.l (a7)+,d1/d2/d5
00:00007F90 4E75            	  1566: 	rts
                            	  1567: 	
                            	  1568: 	
                            	  1569: ; Parameters:
                            	  1570: ;		d3 = x1
                            	  1571: ;		d4 = y1
                            	  1572: 
                            	  1573: DrawVertTo:
00:00007F92 48E76400        	  1574: 	movem.l d1/d2/d5,-(a7)
00:00007F96 223900040894    	  1575: 	move.l gr_x,d1
00:00007F9C 243900040898    	  1576: 	move.l gr_y,d2
00:00007FA2 7A01            	  1577: 	move.l #1,d5			; assume increment
00:00007FA4 B882            	  1578: 	cmp.l d2,d4
00:00007FA6 6202            	  1579: 	bhi.s .0001
00:00007FA8 4485            	  1580: 	neg.l d5					; switch to decrement
                            	  1581: .0001:
00:00007FAA 61009C44        	  1582: 	bsr plot
00:00007FAE B882            	  1583: 	cmp.l d2,d4
00:00007FB0 6704            	  1584: 	beq.s .0002
00:00007FB2 D485            	  1585: 	add.l d5,d2
00:00007FB4 60F4            	  1586: 	bra.s .0001
                            	  1587: .0002:
00:00007FB6 23C200040898    	  1588: 	move.l d2,gr_y
00:00007FBC 4CDF0026        	  1589: 	movem.l (a7)+,d1/d2/d5
00:00007FC0 4E75            	  1590: 	rts
                            	  1591: 	
                            	  1592: 	
                            	  1593: ;plotLine(x0, y0, x1, y1)
                            	  1594: ;    dx = abs(x1 - x0)
                            	  1595: ;    sx = x0 < x1 ? 1 : -1
                            	  1596: ;    dy = -abs(y1 - y0)
                            	  1597: ;    sy = y0 < y1 ? 1 : -1
                            	  1598: ;    error = dx + dy
                            	  1599: ;    
                            	  1600: ;    while true
                            	  1601: ;        plot(x0, y0)
                            	  1602: ;        e2 = 2 * error
                            	  1603: ;        if e2 >= dy
                            	  1604: ;            if x0 == x1 break
                            	  1605: ;            error = error + dy
                            	  1606: ;            x0 = x0 + sx
                            	  1607: ;        end if
                            	  1608: ;        if e2 <= dx
                            	  1609: ;            if y0 == y1 break
                            	  1610: ;            error = error + dx
                            	  1611: ;            y0 = y0 + sy
                            	  1612: ;        end if
                            	  1613: ;    end while
                            	  1614:     
                            	  1615: ;------------------------------------------------------------------------------
                            	  1616: ; Cursor positioning / Clear screen
                            	  1617: ; - out of range settings are ignored
                            	  1618: ;
                            	  1619: ; Parameters:
                            	  1620: ;		d1.w cursor position, bits 0 to 7 are row, bits 8 to 15 are column.
                            	  1621: ;	Returns:
                            	  1622: ;		none
                            	  1623: ;------------------------------------------------------------------------------
                            	  1624: 
                            	  1625: Cursor1:
00:00007FC2 48E7F300        	  1626: 	movem.l d0/d1/d2/d3/d6/d7,-(a7)
00:00007FC6 0C41FF00        	  1627: 	cmpi.w #$FF00,d1
00:00007FCA 6616            	  1628: 	bne.s .0002
00:00007FCC 7E02            	  1629: 	moveq #2,d7
00:00007FCE 7C0C            	  1630: 	moveq #DEV_CLEAR,d6	; clear screen
00:00007FD0 4E40            	  1631: 	trap #0
00:00007FD2 7C07            	  1632: 	moveq #DEV_SET_OUTPOS,d6
00:00007FD4 7200            	  1633: 	moveq #0,d1
00:00007FD6 7400            	  1634: 	moveq #0,d2
00:00007FD8 7600            	  1635: 	moveq #0,d3
00:00007FDA 4E40            	  1636: 	trap #0
00:00007FDC 4CDF00CF        	  1637: 	movem.l (a7)+,d0/d1/d2/d3/d6/d7
00:00007FE0 4E75            	  1638: 	rts
                            	  1639: .0002:
00:00007FE2 7E02            	  1640: 	moveq #2,d7
00:00007FE4 7C07            	  1641: 	moveq #DEV_SET_OUTPOS,d6
00:00007FE6 7400            	  1642: 	clr.l d2
00:00007FE8 1401            	  1643: 	move.b d1,d2		; d2 = row (y pos)
00:00007FEA E049            	  1644: 	lsr.w #8,d1			; d1 = col (x pos)
00:00007FEC 4881            	  1645: 	ext.w d1
00:00007FEE 48C1            	  1646: 	ext.l d1
00:00007FF0 7600            	  1647: 	moveq #0,d3
00:00007FF2 4E40            	  1648: 	trap #0
00:00007FF4 4CDF00CF        	  1649: 	movem.l (a7)+,d0/d1/d2/d3/d6/d7
00:00007FF8 4E75            	  1650: 	rts
                            	  1651: 
                            	  1652: ;------------------------------------------------------------------------------
                            	  1653: ; Stub routine for unimplemented functionality.
                            	  1654: ;------------------------------------------------------------------------------
                            	  1655: 
                            	  1656: StubRout:
00:00007FFA 4E75            	  1657: 	rts
                            	  1658: 
                            	  1659: ;------------------------------------------------------------------------------
                            	  1660: ; Select a specific IO focus.
                            	  1661: ;------------------------------------------------------------------------------
                            	  1662: 
                            	  1663: select_iofocus:
00:00007FFC 0C010002        	  1664: 	cmpi.b	#2,d1
00:00008000 650A            	  1665: 	blo.s		.0001
00:00008002 0C010005        	  1666: 	cmpi.b	#NCORES+1,d1
00:00008006 6204            	  1667: 	bhi.s		.0001
00:00008008 2001            	  1668: 	move.l	d1,d0
00:0000800A 6014            	  1669: 	bra.s		select_focus1
                            	  1670: .0001:
00:0000800C 4E75            	  1671: 	rts
                            	  1672: 
                            	  1673: ;------------------------------------------------------------------------------
                            	  1674: ; Rotate the IO focus, done when ALT-Tab is pressed.
                            	  1675: ;
                            	  1676: ; Modifies:
                            	  1677: ;		d0, IOFocus BIOS variable
                            	  1678: ;		updates the text screen pointer
                            	  1679: ;------------------------------------------------------------------------------
                            	  1680: 
                            	  1681: rotate_iofocus:
00:0000800E 103900100000    	  1682: 	move.b IOFocus,d0					; d0 = focus, we can trash d0
00:00008014 5200            	  1683: 	add.b	#1,d0								; increment the focus
00:00008016 B03C0005        	  1684: 	cmp.b	#NCORES+1,d0				; limit to 2 to 9
00:0000801A 6304            	  1685: 	bls.s	.0001
00:0000801C 103C0002        	  1686: 	move.b #2,d0
                            	  1687: .0001:
                            	  1688: select_focus1:
00:00008020 13C000100000    	  1689: 	move.b	d0,IOFocus				; set IO focus
                            	  1690: 	; reset keyboard processor to focus core
                            	  1691: ;	move.l #$3C060500,d0			; core=??,level sensitive,enabled,irq6,inta
                            	  1692: ;	or.b IOFocus,d0
                            	  1693: ;	move.l d0,PLIC+$80+4*30		; set register
                            	  1694: 	; Adjust text screen pointer
00:00008026 5500            	  1695: 	subi.b #2,d0							; screen is 0 to 7, focus is 2 to 9
00:00008028 4880            	  1696: 	ext.w	d0									; make into word value
00:0000802A C0FC0800        	  1697: 	mulu #2048,d0							; * 2048	cells per screen
00:0000802E E158            	  1698: 	rol.w	#8,d0								; swap byte order
00:00008030 4840            	  1699: 	swap d0										; get bits 16-31
00:00008032 E158            	  1700: 	rol.w	#8,d0								; swap byte order
00:00008034 23C0FD080028    	  1701: 	move.l d0,TEXTREG+$28			; update screen address in text controller
00:0000803A 600094B8        	  1702: 	bra	SyncCursor						; set cursor position
                            	  1703: 
                            	  1704: ;==============================================================================
                            	  1705: ; PLIC - platform level interrupt controller
                            	  1706: ;
                            	  1707: ; Register layout:
                            	  1708: ;   bits 0 to 7  = cause code to issue (vector number)
                            	  1709: ;   bits 8 to 11 = irq level to issue
                            	  1710: ;   bit 16 = irq enable
                            	  1711: ;   bit 17 = edge sensitivity
                            	  1712: ;   bit 18 = 0=vpa, 1=inta
                            	  1713: ;		bit 24 to 29 target core
                            	  1714: ;
                            	  1715: ; Note byte order must be reversed for PLIC.
                            	  1716: ;==============================================================================
                            	  1717: 
                            	  1718: init_plic:
00:0000803E 41F9FD260000    	  1719: 	lea	PLIC,a0							; a0 points to PLIC
00:00008044 43E800F4        	  1720: 	lea	$80+4*29(a0),a1			; point to timer registers (29)
00:00008048 22BC0006033F    	  1721: 	move.l #$0006033F,(a1)	; initialize, core=63,edge sensitive,enabled,irq6,vpa
00:0000804E 5889            	  1722: 	lea	4(a1),a1						; point to keyboard registers (30)
00:00008050 22BC3C060502    	  1723: 	move.l #$3C060502,(a1)	; core=2,level sensitive,enabled,irq6,inta
00:00008056 5889            	  1724: 	lea	4(a1),a1						; point to nmi button register (31)
00:00008058 22BC00070302    	  1725: 	move.l #$00070302,(a1)	; initialize, core=2,edge sensitive,enabled,irq7,vpa
00:0000805E 43E800C0        	  1726: 	lea	$80+4*16(a0),a1			; a1 points to ACIA register
00:00008062 22BC3D030502    	  1727: 	move.l #$3D030502,(a1)	; core=2,level sensitive,enabled,irq3,inta	
00:00008068 43E80090        	  1728: 	lea	$80+4*4(a0),a1			; a1 points to io_bitmap irq
00:0000806C 22BC3B060702    	  1729: 	move.l #$3B060702,(a1)	; core=2,edge sensitive,enabled,irq6,inta	
00:00008072 4E75            	  1730: 	rts
                            	  1731: 
                            	  1732: 
                            	  1733: ;==============================================================================
                            	  1734: ;==============================================================================
                            	  1735: ; Monitor
                            	  1736: ;==============================================================================
                            	  1737: ;==============================================================================
                            	  1738: 
                            	  1739: cmdString:
00:00008074 BF              	  1740: 	dc.b	'?'+$80						; ? display help
00:00008075 41              	  1741: 	dc.b	'A','S'+$80				; AS = asteroids
00:00008076 D3
00:00008077 CC              	  1742: 	dc.b	'L'+$80						; L load S19 file
00:00008078 46              	  1743: 	dc.b	'F','B'+$80				; FB fill with byte
00:00008079 C2
00:0000807A 46              	  1744: 	dc.b	'F','W'+$80				; FW fill with wyde
00:0000807B D7
00:0000807C 46              	  1745: 	dc.b	'F','L'+$80				; FL fill with long wyde
00:0000807D CC
00:0000807E 464D54          	  1746: 	dc.b	'FMT','K'+$80			; FMTK run Femtiki OS
00:00008081 CB
00:00008082 42              	  1747: 	dc.b	'B','A'+$80				; BA start Tiny Basic
00:00008083 C1
00:00008084 42              	  1748: 	dc.b	'B','R'+$80				; BR breakpoint
00:00008085 D2
00:00008086 44              	  1749: 	dc.b	'D','I'+$80				; DI disassemble
00:00008087 C9
00:00008088 44              	  1750: 	dc.b	'D','R'+$80				; DR dump registers
00:00008089 D2
00:0000808A C4              	  1751: 	dc.b	'D'+$80						; D dump memory
00:0000808B CA              	  1752: 	dc.b	'J'+$80						; J jump to code
00:0000808C C5              	  1753: 	dc.b	'E'+$80						; : edit memory
00:0000808D 434C            	  1754: 	dc.b	"CL",'S'+$80			; CLS clear screen
00:0000808F D3
00:00008090 434F52          	  1755: 	dc.b	"COR",'E'+$80			; CORE <n> switch to core
00:00008093 C5
00:00008094 5446            	  1756: 	dc.b	"TF",'P'+$80			; TFP test fp
00:00008096 D0
00:00008097 5447            	  1757: 	dc.b  "TG",'F'+$80			; TGF test get float
00:00008099 C6
00:0000809A 545241          	  1758: 	dc.b  "TRA",'M'+$80			; TRAM test RAM
00:0000809D CD
00:0000809E 5345545F54494D  	  1759: 	dc.b	'SET_TIM','E'+$80
00:000080A5 C5
00:000080A6 54494D          	  1760: 	dc.b	'TIM','E'+$80
00:000080A9 C5
00:000080AA 54              	  1761: 	dc.b	'T','R'+$80				; TR test serial receive
00:000080AB D2
00:000080AC 545343          	  1762: 	dc.b	'TSC','D'+$80			; Test SD card
00:000080AF C4
00:000080B0 D4              	  1763: 	dc.b	'T'+$80						; T test CPU
00:000080B1 D3              	  1764: 	dc.b	'S'+$80						; S send serial
00:000080B2 52455345        	  1765: 	dc.b	"RESE",'T'+$80		; RESET <n>
00:000080B6 D4
00:000080B7 434C4F43        	  1766: 	dc.b	"CLOC",'K'+$80		; CLOCK <n>
00:000080BB CB
00:000080BC D2              	  1767: 	dc.b	'R'+$80						; R receive serial
00:000080BD D6              	  1768: 	dc.b	'V'+$80
00:000080BE 47              	  1769: 	dc.b	'G','R'+$80				; graphics demo
00:000080BF D2
00:000080C0 70              	  1770: 	dc.b	'p','l','a','n','t','s'+$80	; plants
00:000080C1 6C
00:000080C2 61
00:000080C3 6E
00:000080C4 74
00:000080C5 F3
00:000080C6 00              	  1771: 	dc.b	0,0
00:000080C7 00
                            	  1772: 
                            	  1773: 	align	2
                            	  1774: cmdTable:
00:000080C8 000084D6        	  1775: 	dc.l	cmdHelp
00:000080CC 00008264        	  1776: 	dc.l	cmdAsteroids
00:000080D0 000096C2        	  1777: 	dc.l	cmdLoadS19
00:000080D4 0000881A        	  1778: 	dc.l	cmdFillB
00:000080D8 0000886E        	  1779: 	dc.l	cmdFillW
00:000080DC 000088C2        	  1780: 	dc.l	cmdFillL
00:000080E0 000083A2        	  1781: 	dc.l	cmdFMTK
00:000080E4 0000835E        	  1782: 	dc.l	cmdTinyBasic
00:000080E8 00008240        	  1783: 	dc.l	cmdBreakpoint
00:000080EC 00008DB4        	  1784: 	dc.l	cmdDisassemble
00:000080F0 00008ED0        	  1785: 	dc.l	cmdDumpRegs
00:000080F4 00008E04        	  1786: 	dc.l	cmdDumpMemory
00:000080F8 000089CE        	  1787: 	dc.l	cmdJump
00:000080FC 00008970        	  1788: 	dc.l	cmdEditMemory
00:00008100 00008372        	  1789: 	dc.l	cmdClearScreen
00:00008104 0000837E        	  1790: 	dc.l	cmdCore
00:00008108 000083AC        	  1791: 	dc.l  cmdTestFP
00:0000810C 00008438        	  1792: 	dc.l	cmdTestGF
00:00008110 000095FA        	  1793: 	dc.l  cmdTestRAM
00:00008114 00008274        	  1794: 	dc.l	cmdSetTime
00:00008118 000082E2        	  1795: 	dc.l	cmdTime
00:0000811C 00008F7A        	  1796: 	dc.l	cmdTestSerialReceive
00:00008120 000084E2        	  1797: 	dc.l	cmdTestSD
00:00008124 00008362        	  1798: 	dc.l	cmdTestCPU
00:00008128 000087B6        	  1799: 	dc.l	cmdSendSerial
00:0000812C 00008484        	  1800: 	dc.l	cmdReset
00:00008130 00008466        	  1801: 	dc.l	cmdClock
00:00008134 000087E6        	  1802: 	dc.l	cmdReceiveSerial	
00:00008138 000081FE        	  1803: 	dc.l	cmdVideoMode
00:0000813C 000089DE        	  1804: 	dc.l	cmdGrDemo
00:00008140 0000826C        	  1805: 	dc.l	cmdPlants
00:00008144 0000815C        	  1806: 	dc.l	cmdMonitor
                            	  1807: 
                            	  1808: ; Get a word from screen memory and swap byte order
                            	  1809: 
                            	  1810: FromScreen:
00:00008148 2210            	  1811: 	move.l (a0),d1
00:0000814A 610016E0        	  1812: 	bsr	rbo
                            	  1813: 	if (SCREEN_FORMAT==1)
00:0000814E 5888            	  1814: 		lea	4(a0),a0	; increment screen pointer
                            	  1815: 	else
                            	  1816: 		lea	8(a0),a0	; increment screen pointer
                            	  1817: 	endif
00:00008150 4E75            	  1818: 	rts
                            	  1819: 
                            	  1820: StartMon:
00:00008152 427900040202    	  1821: 	clr.w	NumSetBreakpoints
00:00008158 61001C9C        	  1822: 	bsr	ClearBreakpointList
                            	  1823: cmdMonitor:
                            	  1824: Monitor:
                            	  1825: 	; Reset the stack pointer on each entry into the monitor
00:0000815C 2E7C00047FFC    	  1826: 	move.l #$47FFC,sp		; reset core's stack
00:00008162 487AFFF8        	  1827: 	pea Monitor					; Cause any RTS to go here
00:00008166 46FC2200        	  1828: 	move.w #$2200,sr		; enable level 2 and higher interrupts
00:0000816A 4E7A0FE0        	  1829: 	movec	coreno,d0
00:0000816E 4840            	  1830: 	swap d0
00:00008170 7201            	  1831: 	moveq	#1,d1
00:00008172 6100A476        	  1832: 	bsr	UnlockSemaphore
00:00008176 42390004000C    	  1833: 	clr.b KeybdEcho			; turn off keyboard echo
                            	  1834: PromptLn:
00:0000817C 6100F974        	  1835: 	bsr	CRLF
00:00008180 123C0024        	  1836: 	move.b #'$',d1
00:00008184 61001DA4        	  1837: 	bsr OutputChar
                            	  1838: 
                            	  1839: ; Get characters until a CR is keyed
                            	  1840: ;
                            	  1841: Prompt3:
00:00008188 6100870E        	  1842: 	bsr	GetKey
00:0000818C 0C0100FF        	  1843: 	cmpi.b #-1,d1
00:00008190 67F6            	  1844: 	beq.s	Prompt3
00:00008192 0C01000D        	  1845: 	cmpi.b #CR,d1
00:00008196 6706            	  1846: 	beq.s	Prompt1
00:00008198 61001D90        	  1847: 	bsr	OutputChar
00:0000819C 60EA            	  1848: 	bra.s	Prompt3
                            	  1849: 
                            	  1850: ; Process the screen line that the CR was keyed on
                            	  1851: 
                            	  1852: Prompt1:
00:0000819E 7E02            	  1853: 	moveq #2,d7
00:000081A0 7C17            	  1854: 	moveq #DEV_GET_OUTPOS,d6
00:000081A2 4E40            	  1855: 	trap #0
                            	  1856: ;	clr.b	CursorCol				; go back to the start of the line
00:000081A4 7C07            	  1857: 	moveq #DEV_SET_OUTPOS,d6
00:000081A6 7200            	  1858: 	moveq #0,d1						; go back to the start of the line
00:000081A8 4E40            	  1859: 	trap #0
00:000081AA 7C18            	  1860: 	moveq #DEV_GET_OUTPTR,d6
00:000081AC 4E40            	  1861: 	trap #0
00:000081AE 2041            	  1862: 	move.l d1,a0					; a0 = pointer to buffer
                            	  1863: ;	bsr	CalcScreenLoc			; a0 = screen memory location
                            	  1864: .0001:
00:000081B0 6196            	  1865: 	bsr	FromScreen				; grab character off screen
00:000081B2 0C010024        	  1866: 	cmpi.b #'$',d1				; skip over '$' prompt character
00:000081B6 67F8            	  1867: 	beq.s	.0001
                            	  1868: 
                            	  1869: ; Dispatch based on command string
                            	  1870: 
                            	  1871: cmdDispatch:
00:000081B8 45FAFEBA        	  1872: 	lea	cmdString,a2
00:000081BC 7800            	  1873: 	clr.l	d4							; command counter
                            	  1874: 	if (SCREEN_FORMAT==1)
00:000081BE 5988            	  1875: 		lea	-4(a0),a0				; backup a character
                            	  1876: 	else
                            	  1877: 		lea	-8(a0),a0				; backup a character
                            	  1878: 	endif
00:000081C0 2648            	  1879: 	move.l	a0,a3					; a3 = start of command on screen
                            	  1880: .checkNextCmd:
00:000081C2 6184            	  1881: 	bsr	FromScreen				; d1 = char from input screen
00:000081C4 1A1A            	  1882: 	move.b (a2)+,d5
00:000081C6 BB01            	  1883: 	eor.b	d5,d1						; does it match with command string?
00:000081C8 67F8            	  1884: 	beq.s	.checkNextCmd		; If it does, keep matching for longest match
00:000081CA 0C010080        	  1885: 	cmpi.b #$80,d1				; didn't match, was it the end of the command?
00:000081CE 6724            	  1886: 	beq.s	.foundCmd
00:000081D0 4A2AFFFF        	  1887: 	tst.b	-1(a2)					; was end of table hit?
00:000081D4 6712            	  1888: 	beq.s	.endOfTable
00:000081D6 5844            	  1889: 	addi.w #4,d4					; increment command counter
00:000081D8 204B            	  1890: 	move.l a3,a0					; reset input pointer
00:000081DA 4A2AFFFF        	  1891: 	tst.b	-1(a2)					; were we at the end of the command?
00:000081DE 6BE2            	  1892: 	bmi.s	.checkNextCmd		; if were at end continue, otherwise scan for end of cmd
                            	  1893: .scanToEndOfCmd
00:000081E0 4A1A            	  1894: 	tst.b	(a2)+						; scan to end of command
00:000081E2 6704            	  1895: 	beq.s	.endOfTable
00:000081E4 6AFA            	  1896: 	bpl.s	.scanToEndOfCmd
00:000081E6 6BDA            	  1897: 	bmi.s	.checkNextCmd
                            	  1898: .endOfTable
00:000081E8 43FA0507        	  1899: 	lea	msgUnknownCmd,a1
00:000081EC 6100F934        	  1900: 	bsr	DisplayStringCRLF
00:000081F0 6000FF6A        	  1901: 	bra	Monitor
                            	  1902: .foundCmd:
00:000081F4 43FAFED2        	  1903: 	lea	cmdTable,a1				; a1 = pointer to command address table
00:000081F8 22714000        	  1904: 	move.l (a1,d4.w),a1		; fetch command routine address from table
00:000081FC 4ED1            	  1905: 	jmp	(a1)							; go execute command
                            	  1906: 
                            	  1907: cmdVideoMode:
00:000081FE 61000710        	  1908: 	bsr ignBlanks
00:00008202 61000D9A        	  1909: 	bsr GetHexNumber
00:00008206 4A01            	  1910: 	cmpi.b #0,d1
00:00008208 660E            	  1911: 	bne.s .0001
00:0000820A 6100F880        	  1912: 	bsr set_text_mode
00:0000820E 7E02            	  1913: 	move.l #2,d7
00:00008210 7C0C            	  1914: 	move.l #DEV_CLEAR,d6
00:00008212 4E40            	  1915: 	trap #0
00:00008214 6000FF46        	  1916: 	bra Monitor
                            	  1917: .0001:
00:00008218 6100F89C        	  1918: 	bsr set_graphics_mode
00:0000821C 6100F8C2        	  1919: 	bsr get_screen_address
00:00008220 42B9FDFF4014    	  1920: 	move.l #0,RAND+4		; select stream 0
00:00008226 343C1D4B        	  1921: 	move.w #7499,d2
                            	  1922: .0002:
00:0000822A 2239FDFF4010    	  1923: 	move.l RAND,d1
00:00008230 42B9FDFF4010    	  1924: 	move.l #0,RAND			; cause new number generation
00:00008236 20C1            	  1925: 	move.l d1,(a0)+			; random display
00:00008238 51CAFFF0        	  1926: 	dbra d2,.0002
00:0000823C 6000FF1E        	  1927: 	bra Monitor
                            	  1928: 
                            	  1929: cmdBreakpoint:
00:00008240 610006CE        	  1930: 	bsr	ignBlanks
00:00008244 6100FF02        	  1931: 	bsr	FromScreen
00:00008248 0C01002B        	  1932: 	cmpi.b	#'+',d1
00:0000824C 67001AB6        	  1933: 	beq	ArmBreakpoint
00:00008250 0C01002D        	  1934: 	cmpi.b	#'-',d1
00:00008254 67001B2C        	  1935: 	beq	DisarmBreakpoint
00:00008258 0C01004C        	  1936: 	cmpi.b	#'L',d1
00:0000825C 67001B78        	  1937: 	beq	ListBreakpoints
00:00008260 6000FEFA        	  1938: 	bra	Monitor
                            	  1939: 
                            	  1940: cmdAsteroids:
00:00008264 487AFEF6        	  1941: 	pea Monitor
00:00008268 60002C60        	  1942: 	jmp asteroids_start
                            	  1943: 
                            	  1944: cmdPlants:
00:0000826C 487AFEEE        	  1945: 	pea Monitor
00:00008270 4EF8027B        	  1946: 	jmp start_plants
                            	  1947: 
                            	  1948: cmdSetTime:
00:00008274 6100069A        	  1949: 	bsr ignBlanks
00:00008278 61000D24        	  1950: 	bsr GetHexNumber
00:0000827C 1601            	  1951: 	move.b d1,d3					; d3 = hours
00:0000827E 863C0040        	  1952: 	or.b #$40,d3					; set 12 hour format
00:00008282 6100068C        	  1953: 	bsr ignBlanks
00:00008286 6100FEC0        	  1954: 	bsr FromScreen
00:0000828A 0C01003A        	  1955: 	cmpi.b #':',d1
00:0000828E 6600FECC        	  1956: 	bne Monitor
00:00008292 6100067C        	  1957: 	bsr ignBlanks
00:00008296 61000D06        	  1958: 	bsr GetHexNumber
00:0000829A 13C100100201    	  1959: 	move.b d1,RTCBuf+$01	; save minutes
00:000082A0 6100066E        	  1960: 	bsr ignBlanks
00:000082A4 6100FEA2        	  1961: 	bsr FromScreen
00:000082A8 0C01003A        	  1962: 	cmpi.b #':',d1
00:000082AC 6600FEAE        	  1963: 	bne Monitor
00:000082B0 6100065E        	  1964: 	bsr ignBlanks
00:000082B4 61000CE8        	  1965: 	bsr GetHexNumber
00:000082B8 00010080        	  1966: 	ori.b #$80,d1					; flag to turn on oscillator
00:000082BC 13C100100200    	  1967: 	move.b d1,RTCBuf+$00	; save seconds
00:000082C2 6100064C        	  1968: 	bsr ignBlanks		
00:000082C6 6100FE80        	  1969: 	bsr FromScreen
00:000082CA 0C010070        	  1970: 	cmpi.b #'p',d1
00:000082CE 6604            	  1971: 	bne .0001
00:000082D0 00030020        	  1972: 	ori.b #$20,d3					; set pm bit
                            	  1973: .0001
00:000082D4 13C300100202    	  1974: 	move.b d3,RTCBuf+$02	; set hours
00:000082DA 610018B6        	  1975: 	bsr rtc_write
00:000082DE 6000FE7C        	  1976: 	bra Monitor
                            	  1977: 
                            	  1978: ; Display the time
                            	  1979: ;		4:17:00 am
                            	  1980: 	
                            	  1981: cmdTime:
00:000082E2 4DF9000408E0    	  1982: 	lea TimeBuf,a6
00:000082E8 610A            	  1983: 	bsr get_time
00:000082EA 224E            	  1984: 	move.l a6,a1
00:000082EC 6100F834        	  1985: 	bsr DisplayStringCRLF
00:000082F0 6000FE6A        	  1986: 	bra Monitor
                            	  1987: 
                            	  1988: ; Get the time into a buffer
                            	  1989: ; Parameters:
                            	  1990: ;		a6 = pointer to buffer to store time as a string
                            	  1991: 
                            	  1992: get_time:
00:000082F4 48E79002        	  1993: 	movem.l d0/d3/a6,-(sp)	; save buffer address
00:000082F8 6100180E        	  1994: 	bsr rtc_read					; read the RTC registers
00:000082FC 103900100202    	  1995: 	move.b RTCBuf+$02,d0
00:00008302 4203            	  1996: 	move.b #0,d3					; flag 24 hour format
00:00008304 08000006        	  1997: 	btst #6,d0						; 0 = 24 hour format
00:00008308 6714            	  1998: 	beq.s .0001
00:0000830A 163C0061        	  1999: 	move.b #'a',d3				; default to am
00:0000830E 08000005        	  2000: 	btst #5,d0
00:00008312 6704            	  2001: 	beq.s .0002
00:00008314 163C0070        	  2002: 	move.b #'p',d3
                            	  2003: .0002
00:00008318 0200001F        	  2004: 	andi.b #$1F,d0
00:0000831C 6004            	  2005: 	bra .0003
                            	  2006: .0001
00:0000831E 0200003F        	  2007: 	andi.b #$3F,d0
                            	  2008: .0003
00:00008322 61001298        	  2009: 	bsr BufByte						; copy hours to buffer
00:00008326 1CFC003A        	  2010: 	move.b #':',(a6)+
00:0000832A 103900100201    	  2011: 	move.b RTCBuf+$01,d0
00:00008330 6100128A        	  2012: 	bsr BufByte						; copy minutes to buffer
00:00008334 1CFC003A        	  2013: 	move.b #':',(a6)+
00:00008338 103900100200    	  2014: 	move.b RTCBuf+$00,d0	
00:0000833E 0200003F        	  2015: 	andi.b #$3F,d0
00:00008342 61001278        	  2016: 	bsr BufByte						; copy seconds to buffer
00:00008346 4A03            	  2017: 	tst.b d3							; 24 hour format?
00:00008348 670C            	  2018: 	beq .0004
00:0000834A 1CFC0020        	  2019: 	move.b #' ',(a6)+
00:0000834E 1003            	  2020: 	move.b d3,d0
00:00008350 1CC3            	  2021: 	move.b d3,(a6)+
00:00008352 1CFC006D        	  2022: 	move.b #'m',(a6)+
                            	  2023: .0004	
00:00008356 421E            	  2024: 	move.b #0,(a6)+				; NULL terminate
00:00008358 4CDF4009        	  2025: 	movem.l (sp)+,d0/d3/a6
00:0000835C 4E75            	  2026: 	rts
                            	  2027: 
                            	  2028: cmdTinyBasic:
00:0000835E 6000DE9C        	  2029: 	bra	CSTART
                            	  2030: 
                            	  2031: cmdTestCPU:
00:00008362 6100A328        	  2032: 	bsr	cpu_test
00:00008366 43FA1DA1        	  2033: 	lea	msg_test_done,a1
00:0000836A 6100F7B6        	  2034: 	bsr	DisplayStringCRLF
00:0000836E 6000FDEC        	  2035: 	bra	Monitor
                            	  2036: 
                            	  2037: cmdClearScreen:
00:00008372 610014B0        	  2038: 	bsr	ClearScreen
00:00008376 6100916A        	  2039: 	bsr	HomeCursor
00:0000837A 6000FDE0        	  2040: 	bra	Monitor
                            	  2041: 
                            	  2042: cmdCore:
00:0000837E 61000590        	  2043: 	bsr			ignBlanks
00:00008382 6100FDC4        	  2044: 	bsr			FromScreen
00:00008386 0C010032        	  2045: 	cmpi.b	#'2',d1					; check range
00:0000838A 6500FDD0        	  2046: 	blo			Monitor
00:0000838E 0C010035        	  2047: 	cmpi.b	#'0'+NCORES+1,d1
00:00008392 6200FDC8        	  2048: 	bhi			Monitor
00:00008396 04010030        	  2049: 	subi.b	#'0',d1					; convert ascii to binary
00:0000839A 6100FC60        	  2050: 	bsr			select_iofocus
00:0000839E 6000FDBC        	  2051: 	bra			Monitor
                            	  2052: 
                            	  2053: cmdFMTK:
00:000083A2 4EB900000220    	  2054: 	bsr FemtikiInit
00:000083A8 6000FDB2        	  2055: 	bra Monitor
                            	  2056: 
                            	  2057: cmdTestFP:
00:000083AC 7029            	  2058: 	moveq #41,d0						; function #41, get float
00:000083AE 7204            	  2059: 	moveq #4,d1							; d1 = input stride
00:000083B0 2248            	  2060: 	move.l a0,a1						; a1 = pointer to input buffer
00:000083B2 4E4F            	  2061: 	trap #15
00:000083B4 2049            	  2062: 	move.l a1,a0
00:000083B6 F2000200        	  2063: 	fmove.x fp0,fp4
00:000083BA 61000554        	  2064: 	bsr ignBlanks
00:000083BE 6100FD88        	  2065: 	bsr FromScreen
00:000083C2 1E01            	  2066: 	move.b d1,d7
00:000083C4 7029            	  2067: 	moveq #41,d0						; function #41, get float
00:000083C6 7208            	  2068: 	move.l #8,d1						; d1 = input stride
00:000083C8 2248            	  2069: 	move.l a0,a1						; a1 = pointer to input buffer
00:000083CA 4E4F            	  2070: 	trap #15
00:000083CC 2049            	  2071: 	move.l a1,a0
00:000083CE F2000100        	  2072: 	fmove.x fp0,fp2
00:000083D2 6100F71E        	  2073: 	bsr CRLF
                            	  2074: ;	moveq #39,d0
                            	  2075: ;	moveq #40,d1
                            	  2076: ;	moveq #30,d2
                            	  2077: ;	moveq #'e',d3
                            	  2078: ;	trap #15
                            	  2079: ;	bsr CRLF
00:000083D6 F2396A00000402C0	  2080: 	fmove.x fp4,fpBuf
00:000083DE F2396900000402D0	  2081: 	fmove.x fp2,fpBuf+16
00:000083E6 0C07002B        	  2082: 	cmpi.b #'+',d7
00:000083EA 6606            	  2083: 	bne .0001
00:000083EC F2000A22        	  2084: 	fadd fp2,fp4
00:000083F0 6022            	  2085: 	bra .0002
                            	  2086: .0001
00:000083F2 0C07002D        	  2087: 	cmpi.b #'-',d7
00:000083F6 6606            	  2088: 	bne .0003
00:000083F8 F2000A28        	  2089: 	fsub fp2,fp4
00:000083FC 6016            	  2090: 	bra .0002
                            	  2091: .0003
00:000083FE 0C07002A        	  2092: 	cmpi.b #'*',d7
00:00008402 6606            	  2093: 	bne .0004
00:00008404 F2000A23        	  2094: 	fmul fp2,fp4
00:00008408 600A            	  2095: 	bra .0002
                            	  2096: .0004
00:0000840A 0C07002F        	  2097: 	cmpi.b #'/',d7
00:0000840E 6620            	  2098: 	bne .0005
00:00008410 F2000A20        	  2099: 	fdiv fp2,fp4
                            	  2100: 	bra .0002
                            	  2101: .0002
00:00008414 F2396A00000402E0	  2102: 	fmove.x fp4,fpBuf+32
00:0000841C F2001000        	  2103: 	fmove.x fp4,fp0
00:00008420 43F900040520    	  2104: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
00:00008426 7027            	  2105: 	moveq #39,d0						; function #39 print float
00:00008428 7228            	  2106: 	moveq #40,d1						; width
00:0000842A 741E            	  2107: 	moveq #30,d2						; precision
00:0000842C 7665            	  2108: 	moveq #'e',d3
00:0000842E 4E4F            	  2109: 	trap #15
                            	  2110: .0005
00:00008430 6100F6C0        	  2111: 	bsr CRLF
00:00008434 6000FD26        	  2112: 	bra Monitor
                            	  2113: 
                            	  2114: cmdTestGF:
00:00008438 6100F6B8        	  2115: 	bsr CRLF
00:0000843C 7029            	  2116: 	moveq #41,d0						; function #41, get float
00:0000843E 7208            	  2117: 	move.l #8,d1						; d1 = input stride
00:00008440 2248            	  2118: 	move.l a0,a1						; a1 = pointer to input buffer
00:00008442 4E4F            	  2119: 	trap #15
00:00008444 F2396800000402E0	  2120: 	fmove.x fp0,fpBuf+32
00:0000844C 43F900040520    	  2121: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
00:00008452 7027            	  2122: 	moveq #39,d0
00:00008454 7228            	  2123: 	moveq #40,d1
00:00008456 741E            	  2124: 	moveq #30,d2
00:00008458 7665            	  2125: 	moveq #'e',d3
00:0000845A 4E4F            	  2126: 	trap #15
00:0000845C 2049            	  2127: 	move.l a1,a0
00:0000845E 6100F692        	  2128: 	bsr CRLF
00:00008462 6000FCF8        	  2129: 	bra Monitor
                            	  2130: 		
                            	  2131: ;-------------------------------------------------------------------------------
                            	  2132: ; CLOCK <n>
                            	  2133: ;    Set the clock register to n which will turn off or on clocks to the CPUs.
                            	  2134: ;-------------------------------------------------------------------------------
                            	  2135: 
                            	  2136: cmdClock:
00:00008466 610004A8        	  2137: 	bsr			ignBlanks
00:0000846A 61000B32        	  2138: 	bsr			GetHexNumber
00:0000846E 4A00            	  2139: 	tst.b		d0							; was there a number?
00:00008470 6700FCEA        	  2140: 	beq			Monitor
00:00008474 00400004        	  2141: 	ori.w		#4,d0						; primary core's clock cannot be turned off
00:00008478 E159            	  2142: 	rol.w		#8,d1						; switch byte order
00:0000847A 33C1FDFF0002    	  2143: 	move.w	d1,RST_REG+2
00:00008480 6000FCDA        	  2144: 	bra			Monitor
                            	  2145: 
                            	  2146: ;-------------------------------------------------------------------------------
                            	  2147: ; RESET <n>
                            	  2148: ;    Reset the specified core. Resetting the core automatically turns on the 
                            	  2149: ; core's clock.
                            	  2150: ;-------------------------------------------------------------------------------
                            	  2151: 
                            	  2152: cmdReset:
00:00008484 6100048A        	  2153: 	bsr			ignBlanks
00:00008488 6100FCBE        	  2154: 	bsr			FromScreen
00:0000848C 0C010032        	  2155: 	cmpi.b	#'2',d1					; check range
00:00008490 6500FCCA        	  2156: 	blo			Monitor
00:00008494 0C010039        	  2157: 	cmpi.b	#'9',d1
00:00008498 6200FCC2        	  2158: 	bhi			Monitor
00:0000849C 04010030        	  2159: 	subi.b	#'0',d1					; convert ascii to binary
00:000084A0 E349            	  2160: 	lsl.w		#1,d1						; make into index
00:000084A2 43FA0012        	  2161: 	lea			tblPow2,a1
00:000084A6 32311000        	  2162: 	move.w	(a1,d1.w),d1
00:000084AA E159            	  2163: 	rol.w		#8,d1						; reverse byte order
00:000084AC 33C1FDFF0000    	  2164: 	move.w	d1,RST_REG
00:000084B2 6000FCA8        	  2165: 	bra			Monitor
                            	  2166: 
                            	  2167: tblPow2:
00:000084B6 0001            	  2168: 	dc.w		1
00:000084B8 0002            	  2169: 	dc.w		2
00:000084BA 0004            	  2170: 	dc.w		4
00:000084BC 0008            	  2171: 	dc.w		8
00:000084BE 0010            	  2172: 	dc.w		16
00:000084C0 0020            	  2173: 	dc.w		32
00:000084C2 0040            	  2174: 	dc.w		64
00:000084C4 0080            	  2175: 	dc.w		128
00:000084C6 0100            	  2176: 	dc.w		256
00:000084C8 0200            	  2177: 	dc.w		512
00:000084CA 0400            	  2178: 	dc.w		1024
00:000084CC 0800            	  2179: 	dc.w		2048
00:000084CE 1000            	  2180: 	dc.w		4096
00:000084D0 2000            	  2181: 	dc.w		8192
00:000084D2 4000            	  2182: 	dc.w		16384
00:000084D4 8000            	  2183: 	dc.w		32768
                            	  2184: 	even
                            	  2185: 	
                            	  2186: cmdHelp:
                            	  2187: DisplayHelp:
00:000084D6 43FA007C        	  2188: 	lea			HelpMsg,a1
00:000084DA 6100F630        	  2189: 	bsr			DisplayString
00:000084DE 6000FC7C        	  2190: 	bra			Monitor
                            	  2191: 
                            	  2192: cmdTestSD:
00:000084E2 6100042C        	  2193: 	bsr ignBlanks
00:000084E6 61000AB6        	  2194: 	bsr GetHexNumber
00:000084EA 263CFD280000    	  2195: 	move.l #SPI_MASTER1,d3
00:000084F0 0C010001        	  2196: 	cmpi.b #1,d1
00:000084F4 6706            	  2197: 	beq.s .0005
00:000084F6 263CFD284000    	  2198: 	move.l #SPI_MASTER2,d3
                            	  2199: .0005
00:000084FC 2203            	  2200: 	move.l d3,d1
                            	  2201: 	macHmash d1
00:000084FE 4841            	     1M 	swap d1
00:00008500 0A8156791123    	     2M 	eori.l #DEV_HMASH,d1
00:00008506 6100132C        	  2202: 	bsr spi_setup
00:0000850A 4A00            	  2203: 	tst.b d0
00:0000850C 6624            	  2204: 	bne.s .0001
00:0000850E 263C00008554    	  2205: 	move.l #HelpMsg,d3
00:00008514 7401            	  2206: 	moveq #1,d2				; write block #1
00:00008516 6100148E        	  2207: 	bsr spi_write_block
00:0000851A 4A00            	  2208: 	tst.b d0
00:0000851C 662A            	  2209: 	bne.s .0003
00:0000851E 7401            	  2210: 	moveq #1,d2
00:00008520 263C00042000    	  2211: 	move.l #spi_buff,d3
00:00008526 6100142C        	  2212: 	bsr spi_read_block
00:0000852A 4A00            	  2213: 	tst.b d0
00:0000852C 6620            	  2214: 	bne.s .0004
00:0000852E 6000FC2C        	  2215: 	bra Monitor
                            	  2216: .0001
00:00008532 123C0053        	  2217: 	move.b #'S',d1
                            	  2218: .0002
00:00008536 610019F2        	  2219: 	bsr OutputChar
00:0000853A 2200            	  2220: 	move.l d0,d1
00:0000853C 61001046        	  2221: 	bsr DisplayTetra
00:00008540 6100F5B0        	  2222: 	bsr CRLF
00:00008544 6000FC16        	  2223: 	bra Monitor
                            	  2224: .0003
00:00008548 103C0057        	  2225: 	move.b #'W',d0
00:0000854C 60E8            	  2226: 	bra .0002
                            	  2227: .0004
00:0000854E 103C0052        	  2228: 	move.b #'R',d0
00:00008552 60E2            	  2229: 	bra .0002	
                            	  2230: 
                            	  2231: HelpMsg:
00:00008554 3F203D2044697370	  2232: 	dc.b	"? = Display help",LF,CR
00:0000855C 6C61792068656C70
00:00008564 0A
00:00008565 0D
00:00008566 434F5245206E203D	  2233: 	dc.b  "CORE n = switch to core n, n = 2 to 9",LF,CR
00:0000856E 2073776974636820
00:00008576 746F20636F726520
00:0000857E 6E2C206E203D2032
00:00008586 20746F2039
00:0000858B 0A
00:0000858C 0D
00:0000858D 5245534554206E20	  2234: 	dc.b  "RESET n = reset core n",LF,CR
00:00008595 3D20726573657420
00:0000859D 636F7265206E
00:000085A3 0A
00:000085A4 0D
00:000085A5 434C53203D20636C	  2235: 	dc.b	"CLS = clear screen",LF,CR
00:000085AD 6561722073637265
00:000085B5 656E
00:000085B7 0A
00:000085B8 0D
00:000085B9 4542203D20456469	  2236: 	dc.b	"EB = Edit memory bytes, EW, EL",LF,CR
00:000085C1 74206D656D6F7279
00:000085C9 2062797465732C20
00:000085D1 45572C20454C
00:000085D7 0A
00:000085D8 0D
00:000085D9 4642203D2046696C	  2237: 	dc.b	"FB = Fill memory bytes, FW, FL",LF,CR
00:000085E1 6C206D656D6F7279
00:000085E9 2062797465732C20
00:000085F1 46572C20464C
00:000085F7 0A
00:000085F8 0D
00:000085F9 464D544B203D2072	  2238: 	dc.b	"FMTK = run Femtiki OS",LF,CR
00:00008601 756E2046656D7469
00:00008609 6B69204F53
00:0000860E 0A
00:0000860F 0D
00:00008610 4752203D20477261	  2239: 	dc.b	"GR = Graphics command",LF,CR
00:00008618 706869637320636F
00:00008620 6D6D616E64
00:00008625 0A
00:00008626 0D
00:00008627 4C203D204C6F6164	  2240: 	dc.b	"L = Load S19 file",LF,CR
00:0000862F 205331392066696C
00:00008637 65
00:00008638 0A
00:00008639 0D
00:0000863A 44203D2044756D70	  2241: 	dc.b	"D = Dump memory, DR = dump registers",LF,CR
00:00008642 206D656D6F72792C
00:0000864A 204452203D206475
00:00008652 6D70207265676973
00:0000865A 74657273
00:0000865E 0A
00:0000865F 0D
00:00008660 4449203D20446973	  2242: 	dc.b	"DI = Disassemble",LF,CR
00:00008668 617373656D626C65
00:00008670 0A
00:00008671 0D
00:00008672 4241203D20737461	  2243: 	dc.b	"BA = start tiny basic",LF,CR
00:0000867A 72742074696E7920
00:00008682 6261736963
00:00008687 0A
00:00008688 0D
00:00008689 4252203D20736574	  2244: 	dc.b  "BR = set breakpoint",LF,CR
00:00008691 20627265616B706F
00:00008699 696E74
00:0000869C 0A
00:0000869D 0D
00:0000869E 4A203D204A756D70	  2245: 	dc.b	"J = Jump to code",LF,CR
00:000086A6 20746F20636F6465
00:000086AE 0A
00:000086AF 0D
00:000086B0 53203D2073656E64	  2246: 	dc.b  "S = send to serial port",LF,CR
00:000086B8 20746F2073657269
00:000086C0 616C20706F7274
00:000086C7 0A
00:000086C8 0D
00:000086C9 54203D2063707520	  2247: 	dc.b	"T = cpu test program",LF,CR
00:000086D1 746573742070726F
00:000086D9 6772616D
00:000086DD 0A
00:000086DE 0D
00:000086DF 5452414D203D2074	  2248: 	dc.b	"TRAM = test RAM",LF,CR,0
00:000086E7 6573742052414D
00:000086EE 0A
00:000086EF 0D
00:000086F0 00
                            	  2249: 
                            	  2250: msgUnknownCmd:
00:000086F1 636F6D6D616E6420	  2251: 	dc.b	"command unknown",0
00:000086F9 756E6B6E6F776E
00:00008700 00
                            	  2252: 
                            	  2253: msgHello:
00:00008701 0A              	  2254: 	dc.b	LF,CR,"Hello World!",LF,CR,0
00:00008702 0D
00:00008703 48656C6C6F20576F
00:0000870B 726C6421
00:0000870F 0A
00:00008710 0D
00:00008711 00
                            	  2255: 	even
                            	  2256: 
                            	  2257: ;------------------------------------------------------------------------------
                            	  2258: ; This routine borrowed from Gordo's Tiny Basic interpreter.
                            	  2259: ; Used to fetch a command line. (Not currently used).
                            	  2260: ;
                            	  2261: ; d0.b	- command prompt
                            	  2262: ;------------------------------------------------------------------------------
                            	  2263: 
                            	  2264: GetCmdLine:
00:00008712 61001816        	  2265: 		bsr		OutputChar		; display prompt
00:00008716 103C0020        	  2266: 		move.b	#' ',d0
00:0000871A 6100180E        	  2267: 		bsr		OutputChar
00:0000871E 41F900040040    	  2268: 		lea		CmdBuf,a0
                            	  2269: .0001:
00:00008724 61008172        	  2270: 		bsr		GetKey
00:00008728 B03C0008        	  2271: 		cmp.b	#CTRLH,d0
00:0000872C 6728            	  2272: 		beq.s	.0003
00:0000872E B03C0018        	  2273: 		cmp.b	#CTRLX,d0
00:00008732 6746            	  2274: 		beq.s	.0004
00:00008734 B03C000D        	  2275: 		cmp.b	#CR,d0
00:00008738 6706            	  2276: 		beq.s	.0002
00:0000873A B03C0020        	  2277: 		cmp.b	#' ',d0
00:0000873E 65E4            	  2278: 		bcs.s	.0001
                            	  2279: .0002:
00:00008740 1080            	  2280: 		move.b	d0,(a0)
00:00008742 5088            	  2281: 		lea			8(a0),a0
00:00008744 610017E4        	  2282: 		bsr		OutputChar
00:00008748 B03C000D        	  2283: 		cmp.b	#CR,d0
00:0000874C 675E            	  2284: 		beq		.0007
00:0000874E B1FC0004007F    	  2285: 		cmp.l	#CmdBufEnd-1,a0
00:00008754 65CE            	  2286: 		bcs.s	.0001
                            	  2287: .0003:
00:00008756 103C0008        	  2288: 		move.b	#CTRLH,d0
00:0000875A 610017CE        	  2289: 		bsr		OutputChar
00:0000875E 103C0020        	  2290: 		move.b	#' ',d0
00:00008762 610017C6        	  2291: 		bsr		OutputChar
00:00008766 B1FC00040040    	  2292: 		cmp.l	#CmdBuf,a0
00:0000876C 63B6            	  2293: 		bls.s	.0001
00:0000876E 103C0008        	  2294: 		move.b	#CTRLH,d0
00:00008772 610017B6        	  2295: 		bsr		OutputChar
00:00008776 5388            	  2296: 		subq.l	#1,a0
00:00008778 60AA            	  2297: 		bra.s	.0001
                            	  2298: .0004:
00:0000877A 2208            	  2299: 		move.l	a0,d1
00:0000877C 92BC00040040    	  2300: 		sub.l	#CmdBuf,d1
00:00008782 671E            	  2301: 		beq.s	.0006
00:00008784 5341            	  2302: 		subq	#1,d1
                            	  2303: .0005:
00:00008786 103C0008        	  2304: 		move.b	#CTRLH,d0
00:0000878A 6100179E        	  2305: 		bsr		OutputChar
00:0000878E 103C0020        	  2306: 		move.b	#' ',d0
00:00008792 61001796        	  2307: 		bsr		OutputChar
00:00008796 103C0008        	  2308: 		move.b	#CTRLH,d0
00:0000879A 6100178E        	  2309: 		bsr		OutputChar
00:0000879E 51C9FFE6        	  2310: 		dbra	d1,.0005
                            	  2311: .0006:
00:000087A2 41F900040040    	  2312: 		lea		CmdBuf,a0
00:000087A8 6000FF7A        	  2313: 		bra		.0001
                            	  2314: .0007:
00:000087AC 103C000A        	  2315: 		move.b	#LF,d0
00:000087B0 61001778        	  2316: 		bsr		OutputChar
00:000087B4 4E75            	  2317: 		rts
                            	  2318: 
                            	  2319: ;------------------------------------------------------------------------------
                            	  2320: ; S <address> <length>
                            	  2321: ; Send data buffer to serial port
                            	  2322: ; S 40000 40
                            	  2323: ;------------------------------------------------------------------------------
                            	  2324: 
                            	  2325: cmdSendSerial:
00:000087B6 61000158        	  2326: 	bsr			ignBlanks
00:000087BA 610007E2        	  2327: 	bsr			GetHexNumber
00:000087BE 6700F99C        	  2328: 	beq			Monitor
00:000087C2 2C01            	  2329: 	move.l	d1,d6					; d6 points to buffer
00:000087C4 6100014A        	  2330: 	bsr			ignBlanks
00:000087C8 610007D4        	  2331: 	bsr			GetHexNumber
00:000087CC 6602            	  2332: 	bne.s		.0003
00:000087CE 7210            	  2333: 	moveq		#16,d1
                            	  2334: .0003:
00:000087D0 2246            	  2335: 	move.l	d6,a1					; a1 points to buffer
00:000087D2 2401            	  2336: 	move.l	d1,d2					; d2 = count of bytes to send
00:000087D4 6008            	  2337: 	bra.s		.0002					; enter loop at bottom
                            	  2338: .0001:
00:000087D6 1219            	  2339: 	move.b	(a1)+,d1
00:000087D8 303C0022        	  2340: 	move.w	#34,d0				; serial putchar
00:000087DC 4E4F            	  2341: 	trap		#15
                            	  2342: .0002:
00:000087DE 51CAFFF6        	  2343: 	dbra		d2,.0001
00:000087E2 6000F978        	  2344: 	bra			Monitor
                            	  2345: 		
                            	  2346: ;------------------------------------------------------------------------------
                            	  2347: ; R <address> <length>
                            	  2348: ; Send data buffer to serial port
                            	  2349: ; R 10000 40
                            	  2350: ;------------------------------------------------------------------------------
                            	  2351: 
                            	  2352: cmdReceiveSerial:
00:000087E6 61000128        	  2353: 	bsr			ignBlanks
00:000087EA 610007B2        	  2354: 	bsr			GetHexNumber
00:000087EE 6700F96C        	  2355: 	beq			Monitor
00:000087F2 2C01            	  2356: 	move.l	d1,d6					; d6 points to buffer
00:000087F4 6100011A        	  2357: 	bsr			ignBlanks
00:000087F8 610007A4        	  2358: 	bsr			GetHexNumber
00:000087FC 6602            	  2359: 	bne.s		.0003
00:000087FE 7210            	  2360: 	moveq		#16,d1
                            	  2361: .0003:
00:00008800 2246            	  2362: 	move.l	d6,a1					; a1 points to buffer
00:00008802 2401            	  2363: 	move.l	d1,d2					; d2 = count of bytes to send
00:00008804 600C            	  2364: 	bra.s		.0002					; enter loop at bottom
                            	  2365: .0001:
00:00008806 303C0024        	  2366: 	move.w	#36,d0				; serial peek char
00:0000880A 4E4F            	  2367: 	trap		#15
00:0000880C 4A81            	  2368: 	tst.l		d1
00:0000880E 6BF6            	  2369: 	bmi.s		.0001
00:00008810 12C1            	  2370: 	move.b	d1,(a1)+
                            	  2371: .0002:
00:00008812 51CAFFF2        	  2372: 	dbra		d2,.0001
00:00008816 6000F944        	  2373: 	bra			Monitor
                            	  2374: 		
                            	  2375: ;------------------------------------------------------------------------------
                            	  2376: ; Fill memory
                            	  2377: ;
                            	  2378: ; FB = fill bytes		FB 00000010 100 FF	; fill starting at 10 for 256 bytes
                            	  2379: ; FB = fill bytes		FB 00000010 100 R		; fill with random bytes
                            	  2380: ; FW = fill words
                            	  2381: ; FL = fill longs
                            	  2382: ; F = fill bytes
                            	  2383: ;------------------------------------------------------------------------------
                            	  2384: 
                            	  2385: cmdFillB:
00:0000881A 610000F4        	  2386: 	bsr			ignBlanks
00:0000881E 6100077E        	  2387: 	bsr			GetHexNumber
00:00008822 2241            	  2388: 	move.l	d1,a1					; a1 = start
00:00008824 610000EA        	  2389: 	bsr			ignBlanks
00:00008828 61000774        	  2390: 	bsr			GetHexNumber
00:0000882C 2601            	  2391: 	move.l	d1,d3					; d3 = count
00:0000882E 6700F92C        	  2392: 	beq			Monitor
00:00008832 610000DC        	  2393: 	bsr			ignBlanks
00:00008836 610000EA        	  2394: 	bsr PeekScreenChar
00:0000883A 0C010052        	  2395: 	cmpi.b #'R',d1
00:0000883E 660A            	  2396: 	bne.s .0002
00:00008840 6100F906        	  2397: 	bsr FromScreen
00:00008844 1A3C0052        	  2398: 	move.b #'R',d5
00:00008848 6006            	  2399: 	bra.s .fmem
                            	  2400: .0002:
00:0000884A 61000752        	  2401: 	bsr	GetHexNumber		; fill value
00:0000884E 1801            	  2402: 	move.b d1,d4
                            	  2403: .fmem:
00:00008850 3409            	  2404: 	move.w a1,d2
00:00008852 4A42            	  2405: 	tst.w d2
00:00008854 6604            	  2406: 	bne.s .0001
00:00008856 6100807A        	  2407: 	bsr	CheckForCtrlC
                            	  2408: .0001:	
00:0000885A 0C050052        	  2409: 	cmpi.b #'R',d5
00:0000885E 6604            	  2410: 	bne.s .0003
00:00008860 61009C60        	  2411: 	bsr RandGetNum
                            	  2412: .0003:
00:00008864 12C4            	  2413: 	move.b d4,(a1)+
00:00008866 5383            	  2414: 	sub.l	#1,d3
00:00008868 66E6            	  2415: 	bne.s	.fmem
00:0000886A 6000F8F0        	  2416: 	bra	Monitor
                            	  2417: 	
                            	  2418: cmdFillW:
00:0000886E 610000A0        	  2419: 	bsr			ignBlanks
00:00008872 6100072A        	  2420: 	bsr			GetHexNumber
00:00008876 2241            	  2421: 	move.l	d1,a1					; a1 = start
00:00008878 61000096        	  2422: 	bsr			ignBlanks
00:0000887C 61000720        	  2423: 	bsr			GetHexNumber
00:00008880 2601            	  2424: 	move.l	d1,d3					; d3 = count
00:00008882 6700F8D8        	  2425: 	beq			Monitor
00:00008886 61000088        	  2426: 	bsr			ignBlanks
00:0000888A 61000096        	  2427: 	bsr PeekScreenChar
00:0000888E 0C010052        	  2428: 	cmpi.b #'R',d1
00:00008892 660A            	  2429: 	bne.s .0002
00:00008894 6100F8B2        	  2430: 	bsr FromScreen
00:00008898 1A3C0052        	  2431: 	move.b #'R',d5
00:0000889C 6006            	  2432: 	bra.s .fmem
                            	  2433: .0002:
00:0000889E 610006FE        	  2434: 	bsr	GetHexNumber			; fill value
00:000088A2 3801            	  2435: 	move.w d1,d4
                            	  2436: .fmem:
00:000088A4 3409            	  2437: 	move.w a1,d2
00:000088A6 4A42            	  2438: 	tst.w d2
00:000088A8 6604            	  2439: 	bne.s .0001
00:000088AA 61008026        	  2440: 	bsr	CheckForCtrlC
                            	  2441: .0001:	
00:000088AE 0C050052        	  2442: 	cmpi.b #'R',d5
00:000088B2 6604            	  2443: 	bne.s .0003
00:000088B4 61009C0C        	  2444: 	bsr RandGetNum
                            	  2445: .0003:
00:000088B8 32C4            	  2446: 	move.w d4,(a1)+
00:000088BA 5383            	  2447: 	sub.l	#1,d3
00:000088BC 66E6            	  2448: 	bne.s	.fmem
00:000088BE 6000F89C        	  2449: 	bra	Monitor
                            	  2450: 	
                            	  2451: cmdFillL:
00:000088C2 614C            	  2452: 	bsr			ignBlanks
00:000088C4 610006D8        	  2453: 	bsr			GetHexNumber
00:000088C8 2241            	  2454: 	move.l	d1,a1					; a1 = start
00:000088CA 6144            	  2455: 	bsr			ignBlanks
00:000088CC 610006D0        	  2456: 	bsr			GetHexNumber
00:000088D0 2601            	  2457: 	move.l	d1,d3					; d3 = count
00:000088D2 6700F888        	  2458: 	beq			Monitor
00:000088D6 6138            	  2459: 	bsr			ignBlanks
00:000088D8 6148            	  2460: 	bsr PeekScreenChar
00:000088DA 0C010052        	  2461: 	cmpi.b #'R',d1
00:000088DE 660A            	  2462: 	bne.s .0002
00:000088E0 6100F866        	  2463: 	bsr FromScreen
00:000088E4 1A3C0052        	  2464: 	move.b #'R',d5
00:000088E8 6006            	  2465: 	bra.s .fmem
                            	  2466: .0002:
00:000088EA 610006B2        	  2467: 	bsr			GetHexNumber	; fill value
00:000088EE 2801            	  2468: 	move.l d1,d4
                            	  2469: .fmem:
00:000088F0 3409            	  2470: 	move.w a1,d2
00:000088F2 4A42            	  2471: 	tst.w d2
00:000088F4 6606            	  2472: 	bne.s .0001
00:000088F6 4EB9000008D2    	  2473: 	bsr	CheckForCtrlC
                            	  2474: .0001:	
00:000088FC 0C050052        	  2475: 	cmpi.b #'R',d5
00:00008900 6604            	  2476: 	bne.s .0003
00:00008902 61009BBE        	  2477: 	bsr RandGetNum
                            	  2478: .0003:
00:00008906 22C4            	  2479: 	move.l d4,(a1)+
00:00008908 5383            	  2480: 	sub.l	#1,d3
00:0000890A 66E4            	  2481: 	bne.s	.fmem
00:0000890C 6000F84E        	  2482: 	bra	Monitor
                            	  2483: 	
                            	  2484: ;------------------------------------------------------------------------------
                            	  2485: ; Modifies:
                            	  2486: ;	a0	- text pointer
                            	  2487: ;------------------------------------------------------------------------------
                            	  2488: 
                            	  2489: ignBlanks:
00:00008910 2F01            	  2490: 	move.l d1,-(a7)
                            	  2491: .0001:
00:00008912 6100F834        	  2492: 	bsr	FromScreen
00:00008916 0C010020        	  2493: 	cmpi.b #' ',d1
00:0000891A 67F6            	  2494: 	beq.s .0001
                            	  2495: 	if (SCREEN_FORMAT==1)
00:0000891C 5988            	  2496: 		lea	-4(a0),a0
                            	  2497: 	else
                            	  2498: 		lea	-8(a0),a0
                            	  2499: 	endif
00:0000891E 221F            	  2500: 	move.l (a7)+,d1
00:00008920 4E75            	  2501: 	rts
                            	  2502: 
                            	  2503: 
                            	  2504: ;------------------------------------------------------------------------------
                            	  2505: ;------------------------------------------------------------------------------
                            	  2506: 
                            	  2507: PeekScreenChar:
00:00008922 2210            	  2508: 	move.l (a0),d1
00:00008924 60000F06        	  2509: 	bra rbo
                            	  2510: 
                            	  2511: ;------------------------------------------------------------------------------
                            	  2512: ; Get the size character
                            	  2513: ; If the size is not recognized, assume a byte size
                            	  2514: ;
                            	  2515: ; Modifies:
                            	  2516: ;		a0	- text pointer
                            	  2517: ;		d1
                            	  2518: ; Returns:
                            	  2519: ;		d4 = size character 'B','W' or 'L'
                            	  2520: ;------------------------------------------------------------------------------
                            	  2521: 
                            	  2522: GetSzChar:
00:00008928 61E6            	  2523: 	bsr	ignBlanks
00:0000892A 7842            	  2524: 	moveq #'B',d4		; assume byte
00:0000892C 2210            	  2525: 	move.l (a0),d1
00:0000892E 61000EFC        	  2526: 	bsr	rbo
00:00008932 0C010042        	  2527: 	cmpi.b #'B',d1
00:00008936 670E            	  2528: 	beq.s .0002
00:00008938 0C010057        	  2529: 	cmpi.b #'W',d1
00:0000893C 6708            	  2530: 	beq.s .0002
00:0000893E 0C01004C        	  2531: 	cmpi.b #'L',d1
00:00008942 6702            	  2532: 	beq.s .0002
00:00008944 4E75            	  2533: 	rts
                            	  2534: .0002:
00:00008946 6100F800        	  2535: 	bsr FromScreen
00:0000894A 1801            	  2536: 	move.b d1,d4
00:0000894C 4E75            	  2537: 	rts
                            	  2538: 
                            	  2539: ;------------------------------------------------------------------------------
                            	  2540: ; Edit memory byte.
                            	  2541: ;    Bytes are built into long words in case the memory is only longword
                            	  2542: ; accessible.
                            	  2543: ;------------------------------------------------------------------------------
                            	  2544: 
                            	  2545: EditMemHelper:
00:0000894E 61C0            	  2546: 	bsr ignBlanks
00:00008950 6100064C        	  2547: 	bsr GetHexNumber
00:00008954 0C04004C        	  2548: 	cmpi.b #'L',d4
00:00008958 6604            	  2549: 	bne.s .0001
00:0000895A 2401            	  2550: 	move.l d1,d2
00:0000895C 4E75            	  2551: 	rts
                            	  2552: .0001:
00:0000895E 0C040057        	  2553: 	cmpi.b #'W',d4
00:00008962 6606            	  2554: 	bne.s .0002
00:00008964 4842            	  2555: 	swap d2
00:00008966 3401            	  2556: 	move.w d1,d2
00:00008968 4E75            	  2557: 	rts
                            	  2558: .0002:
00:0000896A E18A            	  2559: 	lsl.l #8,d2
00:0000896C 1401            	  2560: 	move.b d1,d2
00:0000896E 4E75            	  2561: 	rts
                            	  2562: 	
                            	  2563: cmdEditMemory:
00:00008970 61B6            	  2564: 	bsr GetSzChar
00:00008972 619C            	  2565: 	bsr ignBlanks
00:00008974 61000628        	  2566: 	bsr	GetHexNumber
00:00008978 2241            	  2567: 	move.l d1,a1
                            	  2568: edtmem1:
00:0000897A 0C04004C        	  2569: 	cmpi.b #'L',d4
00:0000897E 6610            	  2570: 	bne.s .0004
00:00008980 7400            	  2571: 	clr.l	d2
00:00008982 61CA            	  2572: 	bsr EditMemHelper
00:00008984 22C2            	  2573: 	move.l d2,(a1)+
00:00008986 7400            	  2574: 	clr.l	d2
00:00008988 61C4            	  2575: 	bsr EditMemHelper
00:0000898A 22C2            	  2576: 	move.l d2,(a1)+
00:0000898C 6000F7CE        	  2577: 	bra Monitor
                            	  2578: .0004:
00:00008990 0C040057        	  2579: 	cmpi.b #'W',d4
00:00008994 6614            	  2580: 	bne.s .0005
00:00008996 7400            	  2581: 	clr.l	d2
00:00008998 61B4            	  2582: 	bsr EditMemHelper
00:0000899A 61B2            	  2583: 	bsr EditMemHelper
                            	  2584: ;	swap d2
00:0000899C 22C2            	  2585: 	move.l d2,(a1)+
00:0000899E 7400            	  2586: 	clr.l	d2
00:000089A0 61AC            	  2587: 	bsr EditMemHelper
00:000089A2 61AA            	  2588: 	bsr EditMemHelper
                            	  2589: ;	swap d2
00:000089A4 22C2            	  2590: 	move.l d2,(a1)+
00:000089A6 6000F7B4        	  2591: 	bra Monitor
                            	  2592: .0005:
00:000089AA 7400            	  2593: 	clr.l	d2
00:000089AC 61A0            	  2594: 	bsr EditMemHelper
00:000089AE 619E            	  2595: 	bsr EditMemHelper
00:000089B0 619C            	  2596: 	bsr EditMemHelper
00:000089B2 619A            	  2597: 	bsr EditMemHelper
00:000089B4 C342            	  2598: 	exg d1,d2
                            	  2599: ;	bsr rbo
00:000089B6 22C1            	  2600: 	move.l d1,(a1)+
                            	  2601: ;	bsr rbo
00:000089B8 C342            	  2602: 	exg d1,d2
00:000089BA 7400            	  2603: 	clr.l	d2
00:000089BC 6190            	  2604: 	bsr EditMemHelper
00:000089BE 618E            	  2605: 	bsr EditMemHelper
00:000089C0 618C            	  2606: 	bsr EditMemHelper
00:000089C2 618A            	  2607: 	bsr EditMemHelper
00:000089C4 C342            	  2608: 	exg d1,d2
                            	  2609: ;	bsr rbo
00:000089C6 22C1            	  2610: 	move.l d1,(a1)+
                            	  2611: ;	bsr rbo
00:000089C8 C342            	  2612: 	exg d1,d2
00:000089CA 6000F790        	  2613: 	bra Monitor
                            	  2614: 
                            	  2615: ;------------------------------------------------------------------------------
                            	  2616: ; Execute code at the specified address.
                            	  2617: ;------------------------------------------------------------------------------
                            	  2618: 
                            	  2619: cmdJump:
                            	  2620: ExecuteCode:
00:000089CE 6100FF40        	  2621: 	bsr	ignBlanks
00:000089D2 610005CA        	  2622: 	bsr	GetHexNumber
00:000089D6 2041            	  2623: 	move.l d1,a0
00:000089D8 4E90            	  2624: 	jsr	(a0)
00:000089DA 6000F780        	  2625: 	bra Monitor
                            	  2626: 
                            	  2627: cmdGrDemo:
00:000089DE 223C00001555    	  2628: 	move.l #$00001555,d1		; 16 bpp
00:000089E4 7E06            	  2629: 	moveq #6,d7							; framebuf device
00:000089E6 7C21            	  2630: 	moveq #DEV_SET_COLOR_DEPTH,d6
00:000089E8 4E40            	  2631: 	trap #0
00:000089EA 7E07            	  2632: 	moveq #7,d7							; same for graphics accelerator device
00:000089EC 4E40            	  2633: 	trap #0
00:000089EE 223C00110001    	  2634: 	move.l #$00110001,d1		; enable, scale 1 clocks/scanlines per pixel, page zero
00:000089F4 61000E36        	  2635: 	bsr rbo
                            	  2636: ;	move.l d1,FRAMEBUF+FRAMEBUF_CTRL
00:000089F8 223C00F00031    	  2637: 	move.l #$0F00031,d1		; burst length of 50, interval of F00h
00:000089FE 61000E2C        	  2638: 	bsr rbo
00:00008A02 23C1FD208004    	  2639: 	move.l d1,FRAMEBUF+FRAMEBUF_CTRL+4		
00:00008A08 7E06            	  2640: 	moveq #6,d7							; framebuf device
00:00008A0A 7C20            	  2641: 	moveq #DEV_SET_DIMEN,d6
00:00008A0C 7000            	  2642: 	moveq #0,d0
00:00008A0E 223C00000558    	  2643: 	move.l #VIDEO_X,d1
00:00008A14 243C00000300    	  2644: 	move.l #VIDEO_Y,d2
00:00008A1A 7600            	  2645: 	move.l #0,d3
00:00008A1C 4E40            	  2646: 	trap #0
00:00008A1E 7E07            	  2647: 	moveq #7,d7							; same for graphics accelerator device
00:00008A20 4E40            	  2648: 	trap #0
00:00008A22 7E06            	  2649: 	moveq #6,d7
00:00008A24 7002            	  2650: 	moveq #2,d0							; set window dimensions
00:00008A26 4E40            	  2651: 	trap #0
                            	  2652: 	; Set destination buffer #0
00:00008A28 7E07            	  2653: 	moveq #7,d7
00:00008A2A 7C22            	  2654: 	moveq #DEV_SET_DESTBUF,d6	; write to buffer 0
00:00008A2C 7200            	  2655: 	moveq #0,d1
00:00008A2E 4E40            	  2656: 	trap #0
                            	  2657: 	; Clear the screen
00:00008A30 7C0C            	  2658: 	moveq #DEV_CLEAR,d6
00:00008A32 4E40            	  2659: 	trap #0
                            	  2660: 	; Now display the clear screen
00:00008A34 7E06            	  2661: 	moveq #6,d7
00:00008A36 7C23            	  2662: 	moveq #DEV_SET_DISPBUF,d6
00:00008A38 7200            	  2663: 	moveq #0,d1							; display buffer 0
00:00008A3A 4E40            	  2664: 	trap #0
                            	  2665: 
                            	  2666: ;	moveq #0,d1
                            	  2667: ;	moveq #0,d2
                            	  2668: ;	move.l #1920,d3
                            	  2669: ;	move.l #1080,d4
                            	  2670: ;	bsr gfxaccel_clip_rect
                            	  2671: 	; Draw two diagonal white lines
00:00008A3C 263C00000300    	  2672: 	move.l #VIDEO_Y,d3
00:00008A42 287C40000000    	  2673: 	move.l #$40000000,a4
                            	  2674: .0002:
00:00008A48 243CFF7FFF7F    	  2675: 	move.l #$FF7FFF7F,d2	; white
00:00008A4E 3882            	  2676: 	move.w d2,(a4)
00:00008A50 49EC1564        	  2677: 	add.l #VIDEO_X*4+4,a4
00:00008A54 51CBFFF2        	  2678: 	dbra d3,.0002
00:00008A58 263C00000300    	  2679: 	move.l #VIDEO_Y,d3
00:00008A5E 287C40000AB0    	  2680: 	move.l #$40000000+VIDEO_X*2,a4
                            	  2681: .0007:
00:00008A64 3882            	  2682: 	move.w d2,(a4)
00:00008A66 49EC155C        	  2683: 	add.l #VIDEO_X*4-4,a4
00:00008A6A 51CBFFF8        	  2684: 	dbra d3,.0007
00:00008A6E 6000F6EC        	  2685: 	bra Monitor
                            	  2686: 
                            	  2687: ;	bra Monitor
                            	  2688: plot_rand_points:
00:00008A72 223C7F127F12    	  2689: 	move.l #$7F127F12,d1
00:00008A78 61000DB2        	  2690: 	bsr rbo
00:00008A7C 610095F0        	  2691: 	bsr gfxaccel_set_color
00:00008A80 2A3C00002710    	  2692: 	move.l #10000,d5
                            	  2693: .0005:
00:00008A86 287C40000000    	  2694: 	move.l #$40000000,a4
00:00008A8C 61009A34        	  2695: 	bsr RandGetNum
00:00008A90 2801            	  2696: 	move.l d1,d4
00:00008A92 61009A2E        	  2697: 	bsr RandGetNum
00:00008A96 2401            	  2698: 	move.l d1,d2
00:00008A98 0282000000FF    	  2699: 	andi.l #$ff,d2
00:00008A9E 61009A22        	  2700: 	bsr RandGetNum
00:00008AA2 0281000001FF    	  2701: 	andi.l #$1ff,d1
00:00008AA8 C4FC03C0        	  2702: 	mulu #960,d2
00:00008AAC D481            	  2703: 	add.l d1,d2
00:00008AAE D481            	  2704: 	add.l d1,d2
00:00008AB0 D9C2            	  2705: 	add.l d2,a4
00:00008AB2 3884            	  2706: 	move.w d4,(a4)				; plot point
00:00008AB4 51CDFFD0        	  2707: 	dbra d5,.0005
00:00008AB8 6000F6A2        	  2708: 	bra Monitor
                            	  2709: 
                            	  2710: ;clear_graphics_screen:
                            	  2711: ;	move.l #0,d1
                            	  2712: ;	moveq #6,d7
                            	  2713: ;	moveq #DEV_SET_COLOR,d6		; set color in frame buffer
                            	  2714: ;	trap #0
                            	  2715: ;	moveq #7,d7								; and in graphics accelerator
                            	  2716: ;	trap #0
                            	  2717: ;	moveq #6,d7								; clear frame buffer
                            	  2718: ;	moveq #DEV_CLEAR,d6
                            	  2719: ;	trap #0
                            	  2720: ;	moveq #DEV_SWAPBUF,d6			; and display it
                            	  2721: ;	trap #0
                            	  2722: ;	rts
                            	  2723: 
                            	  2724: ;	move.l #0,d1
                            	  2725: ;	bsr gfxaccel_set_color
                            	  2726: ;	move.l #0,d1
                            	  2727: ;	move.l #0,d2
                            	  2728: ;	move.l #1920<<16,d3
                            	  2729: ;	move.l #1080<<16,d4
                            	  2730: ;	bsr gfxaccel_draw_rectangle
00:00008ABC 2A3C00100800    	  2731: 	move.l #VIDEO_X*VIDEO_Y,d5		; compute number of strips to write
00:00008AC2 E68D            	  2732: 	lsr.l #3,d5						; 8 pixels per strip
                            	  2733: ;	move.l framebuf_dcb+DCB_OUTBUFPTR,a4
00:00008AC4 287C40000000    	  2734: 	move.l #$40000000,a4
00:00008ACA 42B97FFFFFF8    	  2735: 	move.l #0,$7FFFFFF8		; burst length of zero
00:00008AD0 6002            	  2736: 	bra.s .0001
                            	  2737: .0002:
00:00008AD2 4845            	  2738: 	swap d5
                            	  2739: .0001:
00:00008AD4 220C            	  2740: 	move.l a4,d1
00:00008AD6 61000D54        	  2741: 	bsr rbo
00:00008ADA 23C17FFFFFF4    	  2742: 	move.l d1,$7FFFFFF4		; target address
00:00008AE0 42B97FFFFFFC    	  2743: 	move.l #0,$7FFFFFFC		; value to write
00:00008AE6 49EC0020        	  2744: 	lea.l 32(a4),a4
00:00008AEA 51CDFFE8        	  2745: 	dbra d5,.0001
                            	  2746: ;	swap d5
                            	  2747: ;	dbra d5,.0002
00:00008AEE 4E75            	  2748: 	rts
                            	  2749: 
                            	  2750: clear_graphics_screen2:
                            	  2751: ;	move.l #0,d1
                            	  2752: ;	bsr gfxaccel_set_color
                            	  2753: ;	move.l #0,d1
                            	  2754: ;	move.l #0,d2
                            	  2755: ;	move.l #1920<<16,d3
                            	  2756: ;	move.l #1080<<16,d4
                            	  2757: ;	bsr gfxaccel_draw_rectangle
00:00008AF0 2A3C00100800    	  2758: 	move.l #VIDEO_X*VIDEO_Y,d5		; compute number of strips to write
00:00008AF6 E68D            	  2759: 	lsr.l #3,d5						; 8 pixels per strip
00:00008AF8 E88D            	  2760: 	lsr.l #4,d5						; and burst writing 16 strips at once
00:00008AFA 287900040D54    	  2761: 	move.l framebuf_dcb+DCB_OUTBUFPTR,a4
00:00008B00 23FC0000000F7FFF	  2762: 	move.l #15,$7FFFFFF8		; burst length = 16
00:00008B08 FFF8
00:00008B0A 6002            	  2763: 	bra.s .0001
                            	  2764: .0002:
00:00008B0C 4845            	  2765: 	swap d5
                            	  2766: .0001:
00:00008B0E 220C            	  2767: 	move.l a4,d1
00:00008B10 61000D1A        	  2768: 	bsr rbo
00:00008B14 23C17FFFFFF4    	  2769: 	move.l d1,$7FFFFFF4		; target address
00:00008B1A 720F            	  2770: 	moveq #15,d1
00:00008B1C 61000D0E        	  2771: 	bsr rbo
00:00008B20 23C17FFFFFF8    	  2772: 	move.l d1,$7FFFFFF8	; burst length = 16
00:00008B26 42B97FFFFFFC    	  2773: 	move.l #0,$7FFFFFFC		; value to write
00:00008B2C 49EC0200        	  2774: 	lea.l 32*16(a4),a4
00:00008B30 51CDFFDC        	  2775: 	dbra d5,.0001
                            	  2776: ;	swap d5
                            	  2777: ;	dbra d5,.0002
00:00008B34 6000F626        	  2778: 	bra Monitor
                            	  2779: 
                            	  2780: wait1ms:
00:00008B38 48E7C000        	  2781: 	movem.l d0/d1,-(a7)
00:00008B3C 4E7A0FF0        	  2782: 	movec tick,d0
00:00008B40 D0BC000F4240    	  2783: 	add.l #1000000,d0
00:00008B46 0280FFFFF000    	  2784: 	andi.l #$FFFFF000,d0
                            	  2785: .0001
00:00008B4C 4E7A1FF0        	  2786: 	movec tick,d1
00:00008B50 0281FFFFF000    	  2787: 	andi.l #$FFFFF000,d1
00:00008B56 B280            	  2788: 	cmp.l d0,d1
00:00008B58 66F2            	  2789: 	bne.s .0001
00:00008B5A 4CDF0003        	  2790: 	movem.l (a7)+,d0/d1
00:00008B5E 4E75            	  2791: 	rts
                            	  2792: 
                            	  2793: white_rect:
00:00008B60 72FF            	  2794: 	move.l #$FFFFFFFF,d1
00:00008B62 6100950A        	  2795: 	bsr gfxaccel_set_color
00:00008B66 72644841        	  2796: 	move.l #100<<16,d1
00:00008B6A 243C012C0000    	  2797: 	move.l #300<<16,d2
00:00008B70 263C00FA0000    	  2798: 	move.l #250<<16,d3
00:00008B76 283C02260000    	  2799: 	move.l #550<<16,d4
00:00008B7C 61009672        	  2800: 	bsr gfxaccel_draw_rectangle
00:00008B80 6000F5DA        	  2801: 	bra Monitor
                            	  2802: 
                            	  2803: rand_points:
00:00008B84 2A3C00007530    	  2804: 	move.l #30000,d5
                            	  2805: .0004:
00:00008B8A 61009936        	  2806: 	bsr RandGetNum
00:00008B8E 610094DE        	  2807: 	bsr gfxaccel_set_color
00:00008B92 7600            	  2808: 	move.l #0,d3					; Z
00:00008B94 6100992C        	  2809: 	bsr RandGetNum
00:00008B98 2401            	  2810: 	move.l d1,d2
                            	  2811: ;	divu #VIDEO_Y,d2			; Y
00:00008B9A 0282000001FF    	  2812: 	andi.l #511,d2
00:00008BA0 4842            	  2813: 	swap d2
00:00008BA2 6100991E        	  2814: 	bsr RandGetNum
                            	  2815: ;	divu #VIDEO_X,d1
00:00008BA6 0281000001FF    	  2816: 	andi.l #511,d1
00:00008BAC 4841            	  2817: 	swap d1
00:00008BAE 61009586        	  2818: 	bsr gfxaccel_plot_point
00:00008BB2 51CDFFD6        	  2819: 	dbra d5,.0004
00:00008BB6 6000F5A4        	  2820: 	bra Monitor
                            	  2821: 
                            	  2822: rand_lines:
00:00008BBA 2A3C00007530    	  2823: 	move.l #30000,d5
                            	  2824: .0001:
                            	  2825: .0006:
00:00008BC0 4EB9000008D2    	  2826: 	bsr CheckForCtrlC
00:00008BC6 610098FA        	  2827: 	bsr RandGetNum
00:00008BCA 610094A2        	  2828: 	bsr gfxaccel_set_color
00:00008BCE F23C410000000320	  2829: 	fmove.l #800,fp2
00:00008BD6 F23C418000000258	  2830: 	fmove.l #600,fp3
00:00008BDE 6100996C        	  2831: 	bsr _GetRand
00:00008BE2 F2000CA3        	  2832: 	fmul fp3,fp1
00:00008BE6 F2046080        	  2833: 	fmove.l fp1,d4
00:00008BEA 61009960        	  2834: 	bsr _GetRand
00:00008BEE F20008A3        	  2835: 	fmul fp2,fp1
00:00008BF2 F2036080        	  2836: 	fmove.l fp1,d3
00:00008BF6 61009954        	  2837: 	bsr _GetRand
00:00008BFA F2000CA3        	  2838: 	fmul fp3,fp1
00:00008BFE F2026080        	  2839: 	fmove.l fp1,d2
00:00008C02 61009948        	  2840: 	bsr _GetRand
00:00008C06 F20008A3        	  2841: 	fmul fp2,fp1
00:00008C0A F2016080        	  2842: 	fmove.l fp1,d1
00:00008C0E 61009578        	  2843: 	bsr gfxaccel_draw_line
00:00008C12 51CDFFAC        	  2844: 	dbra d5,.0001
00:00008C16 6000F544        	  2845: 	bra Monitor
                            	  2846: 
                            	  2847: rand_rect:
00:00008C1A 2A3C00007530    	  2848: 	move.l #30000,d5
                            	  2849: .0003:
                            	  2850: .0006:
00:00008C20 4EB9000008D2    	  2851: 	bsr CheckForCtrlC
00:00008C26 6100989A        	  2852: 	bsr RandGetNum
00:00008C2A 61009442        	  2853: 	bsr gfxaccel_set_color
00:00008C2E F23C410000000320	  2854: 	fmove.l #800,fp2
00:00008C36 F23C418000000258	  2855: 	fmove.l #600,fp3
00:00008C3E 6100990C        	  2856: 	bsr _GetRand
00:00008C42 F2000CA3        	  2857: 	fmul fp3,fp1
00:00008C46 F2046080        	  2858: 	fmove.l fp1,d4
00:00008C4A 61009900        	  2859: 	bsr _GetRand
00:00008C4E F20008A3        	  2860: 	fmul fp2,fp1
00:00008C52 F2036080        	  2861: 	fmove.l fp1,d3
00:00008C56 610098F4        	  2862: 	bsr _GetRand
00:00008C5A F2000CA3        	  2863: 	fmul fp3,fp1
00:00008C5E F2026080        	  2864: 	fmove.l fp1,d2
00:00008C62 610098E8        	  2865: 	bsr _GetRand
00:00008C66 F20008A3        	  2866: 	fmul fp2,fp1
00:00008C6A F2016080        	  2867: 	fmove.l fp1,d1
00:00008C6E 61009580        	  2868: 	bsr gfxaccel_draw_rectangle
00:00008C72 51CDFFAC        	  2869: 	dbra d5,.0003
00:00008C76 6000F4E4        	  2870: 	bra Monitor
                            	  2871: 
                            	  2872: rand_rect2:
00:00008C7A 2A3C00002710    	  2873: 	move.l #10000,d5
                            	  2874: .0003:
                            	  2875: .0006:
00:00008C80 4EB9000008D2    	  2876: 	bsr CheckForCtrlC
00:00008C86 6100983A        	  2877: 	bsr RandGetNum
00:00008C8A 610093E2        	  2878: 	bsr gfxaccel_set_color
00:00008C8E 61009832        	  2879: 	bsr RandGetNum
00:00008C92 2801            	  2880: 	move.l d1,d4
00:00008C94 88FC0300        	  2881: 	divu #VIDEO_Y,d4
00:00008C98 61009828        	  2882: 	bsr RandGetNum
00:00008C9C 2601            	  2883: 	move.l d1,d3
00:00008C9E 86FC0558        	  2884: 	divu #VIDEO_X,d3
00:00008CA2 6100981E        	  2885: 	bsr RandGetNum
00:00008CA6 2401            	  2886: 	move.l d1,d2
00:00008CA8 84FC0300        	  2887: 	divu #VIDEO_Y,d2
00:00008CAC 61009814        	  2888: 	bsr RandGetNum
00:00008CB0 82FC0558        	  2889: 	divu #VIDEO_X,d1
00:00008CB4 6100953A        	  2890: 	bsr gfxaccel_draw_rectangle
00:00008CB8 6100FE7E        	  2891: 	bsr wait1ms
00:00008CBC 51CDFFC2        	  2892: 	dbra d5,.0003
00:00008CC0 6000F49A        	  2893: 	bra Monitor
                            	  2894: 
                            	  2895: rand_triangle:
00:00008CC4 2E3C00007530    	  2896: 	move.l #30000,d7
                            	  2897: .0006:
00:00008CCA 4EB9000008D2    	  2898: 	bsr CheckForCtrlC
00:00008CD0 610097F0        	  2899: 	bsr RandGetNum
00:00008CD4 61009398        	  2900: 	bsr gfxaccel_set_color
00:00008CD8 F23C410000000320	  2901: 	fmove.l #800,fp2
00:00008CE0 F23C418000000258	  2902: 	fmove.l #600,fp3
00:00008CE8 61009862        	  2903: 	bsr _GetRand
00:00008CEC F2000CA3        	  2904: 	fmul fp3,fp1
00:00008CF0 F2006080        	  2905: 	fmove.l fp1,d0
00:00008CF4 61009856        	  2906: 	bsr _GetRand
00:00008CF8 F20008A3        	  2907: 	fmul fp2,fp1
00:00008CFC F2056080        	  2908: 	fmove.l fp1,d5
00:00008D00 6100984A        	  2909: 	bsr _GetRand
00:00008D04 F2000CA3        	  2910: 	fmul fp3,fp1
00:00008D08 F2046080        	  2911: 	fmove.l fp1,d4
00:00008D0C 6100983E        	  2912: 	bsr _GetRand
00:00008D10 F20008A3        	  2913: 	fmul fp2,fp1
00:00008D14 F2036080        	  2914: 	fmove.l fp1,d3
00:00008D18 61009832        	  2915: 	bsr _GetRand
00:00008D1C F2000CA3        	  2916: 	fmul fp3,fp1
00:00008D20 F2026080        	  2917: 	fmove.l fp1,d2
00:00008D24 61009826        	  2918: 	bsr _GetRand
00:00008D28 F20008A3        	  2919: 	fmul fp2,fp1
00:00008D2C F2016080        	  2920: 	fmove.l fp1,d1
00:00008D30 61009526        	  2921: 	bsr gfxaccel_draw_triangle
00:00008D34 51CFFF94        	  2922: 	dbra d7,.0006
00:00008D38 6000F422        	  2923: 	bra Monitor
                            	  2924: 
                            	  2925: rand_curve:
00:00008D3C 2E3C00002710    	  2926: 	move.l #10000,d7
                            	  2927: .0006:
00:00008D42 4EB9000008D2    	  2928: 	bsr CheckForCtrlC
00:00008D48 61009778        	  2929: 	bsr RandGetNum
00:00008D4C 61009320        	  2930: 	bsr gfxaccel_set_color
00:00008D50 F23C410000000320	  2931: 	fmove.l #800,fp2
00:00008D58 F23C418000000258	  2932: 	fmove.l #600,fp3
00:00008D60 610097EA        	  2933: 	bsr _GetRand
00:00008D64 F2000CA3        	  2934: 	fmul fp3,fp1
00:00008D68 F2006080        	  2935: 	fmove.l fp1,d0
00:00008D6C 610097DE        	  2936: 	bsr _GetRand
00:00008D70 F20008A3        	  2937: 	fmul fp2,fp1
00:00008D74 F2056080        	  2938: 	fmove.l fp1,d5
00:00008D78 610097D2        	  2939: 	bsr _GetRand
00:00008D7C F2000CA3        	  2940: 	fmul fp3,fp1
00:00008D80 F2046080        	  2941: 	fmove.l fp1,d4
00:00008D84 610097C6        	  2942: 	bsr _GetRand
00:00008D88 F20008A3        	  2943: 	fmul fp2,fp1
00:00008D8C F2036080        	  2944: 	fmove.l fp1,d3
00:00008D90 610097BA        	  2945: 	bsr _GetRand
00:00008D94 F2000CA3        	  2946: 	fmul fp3,fp1
00:00008D98 F2026080        	  2947: 	fmove.l fp1,d2
00:00008D9C 610097AE        	  2948: 	bsr _GetRand
00:00008DA0 F20008A3        	  2949: 	fmul fp2,fp1
00:00008DA4 F2016080        	  2950: 	fmove.l fp1,d1
00:00008DA8 61009536        	  2951: 	bsr gfxaccel_draw_curve
00:00008DAC 51CFFF94        	  2952: 	dbra d7,.0006
00:00008DB0 6000F3AA        	  2953: 	bra Monitor
                            	  2954: 
                            	  2955: ;------------------------------------------------------------------------------
                            	  2956: ; Disassemble code
                            	  2957: ; DI 1000
                            	  2958: ;------------------------------------------------------------------------------
                            	  2959: ;        CALLING SEQUENCE:
                            	  2960: ;   D0,D1,D2 = CODE TO BE DISASSEMBLED
                            	  2961: ;   A4 = VALUE OF PROGRAM COUNTER FOR THE CODE
                            	  2962: ;   A5 = POINTER TO STORE DATA (BUFSIZE = 80 ASSUMED)
                            	  2963: ;        JSR       DCODE68K
                            	  2964: ;
                            	  2965: ;        RETURN:
                            	  2966: ;   A4 = VALUE OF PROGRAM COUNTER FOR NEXT INSTRUCTION
                            	  2967: ;   A5 = POINTER TO LINE AS DISASSEMBLED
                            	  2968: ;   A6 = POINTER TO END OF LINE
                            	  2969: 
                            	  2970: 
                            	  2971: cmdDisassemble:
00:00008DB4 6100FB5A        	  2972: 	bsr ignBlanks
00:00008DB8 610001E4        	  2973: 	bsr GetHexNumber
00:00008DBC 6700F39E        	  2974: 	beq Monitor
00:00008DC0 363C0014        	  2975: 	move.w #20,d3			; number of lines to disassemble
                            	  2976: .0002:
00:00008DC4 2F03            	  2977: 	move.l d3,-(a7)
00:00008DC6 2041            	  2978: 	move.l d1,a0
00:00008DC8 2841            	  2979: 	move.l d1,a4			; a4 = PC of code
00:00008DCA 3018            	  2980: 	move.w (a0)+,d0		; d0 to d2 = bytes of instruction to decode
00:00008DCC 4840            	  2981: 	swap d0
00:00008DCE 3018            	  2982: 	move.w (a0)+,d0
00:00008DD0 3218            	  2983: 	move.w (a0)+,d1		; d0 to d2 = bytes of instruction to decode
00:00008DD2 4841            	  2984: 	swap d1
00:00008DD4 3218            	  2985: 	move.w (a0)+,d1
00:00008DD6 3418            	  2986: 	move.w (a0)+,d2		; d0 to d2 = bytes of instruction to decode
00:00008DD8 4842            	  2987: 	swap d2
00:00008DDA 3418            	  2988: 	move.w (a0)+,d2
00:00008DDC 4BF900040800    	  2989: 	lea _dasmbuf,a5		; a5 = pointer to disassembly buffer
00:00008DE2 61001C40        	  2990: 	bsr DCODE68K	
00:00008DE6 383C003E        	  2991: 	move.w #62,d4
                            	  2992: .0001:
00:00008DEA 121D            	  2993: 	move.b (a5)+,d1
00:00008DEC 6100113C        	  2994: 	bsr OutputChar
00:00008DF0 51CCFFF8        	  2995: 	dbra d4,.0001
00:00008DF4 6100ECFC        	  2996: 	bsr CRLF
00:00008DF8 220C            	  2997: 	move.l a4,d1
00:00008DFA 261F            	  2998: 	move.l (a7)+,d3
00:00008DFC 51CBFFC6        	  2999: 	dbra d3,.0002
00:00008E00 6000F35A        	  3000: 	bra Monitor
                            	  3001: 	
                            	  3002: ;------------------------------------------------------------------------------
                            	  3003: ; Do a memory dump of the requested location.
                            	  3004: ; DB 0800 0850
                            	  3005: ;------------------------------------------------------------------------------
                            	  3006: 
                            	  3007: cmdDumpMemory:
00:00008E04 6100FB22        	  3008: 	bsr GetSzChar
00:00008E08 6100FB06        	  3009: 	bsr ignBlanks
00:00008E0C 61000190        	  3010: 	bsr	GetHexNumber
00:00008E10 6700F34A        	  3011: 	beq	Monitor					; was there a number ? no, other garbage, just ignore
00:00008E14 2601            	  3012: 	move.l d1,d3				; save off start of range
00:00008E16 6100FAF8        	  3013: 	bsr	ignBlanks
00:00008E1A 61000182        	  3014: 	bsr	GetHexNumber
00:00008E1E 6608            	  3015: 	bne.s	DumpMem1
00:00008E20 2203            	  3016: 	move.l d3,d1
00:00008E22 068100000040    	  3017: 	addi.l #64,d1				;	no end specified, just dump 64 bytes
                            	  3018: DumpMem1:
00:00008E28 2043            	  3019: 	move.l d3,a0
00:00008E2A 2241            	  3020: 	move.l d1,a1
00:00008E2C 6100ECC4        	  3021: 	bsr	CRLF
                            	  3022: .0001:
00:00008E30 B3C8            	  3023: 	cmpa.l a0,a1
00:00008E32 6300F328        	  3024: 	bls	Monitor
00:00008E36 6102            	  3025: 	bsr	DisplayMem
00:00008E38 60F6            	  3026: 	bra.s	.0001
                            	  3027: 
                            	  3028: ;------------------------------------------------------------------------------
                            	  3029: ; Display memory dump in a format suitable for edit.
                            	  3030: ;
                            	  3031: ;	EB 12345678 00 11 22 33 44 55 66 77  "........"
                            	  3032: ;
                            	  3033: ; Modifies:
                            	  3034: ;		d1,d2,a0
                            	  3035: ;------------------------------------------------------------------------------
                            	  3036: 	
                            	  3037: DisplayMem:
00:00008E3A 123C0045        	  3038: 	move.b #'E',d1
00:00008E3E 610010EA        	  3039: 	bsr	OutputChar
00:00008E42 1204            	  3040: 	move.b d4,d1
00:00008E44 610010E4        	  3041: 	bsr OutputChar
00:00008E48 61000732        	  3042: 	bsr DisplaySpace
00:00008E4C 2208            	  3043: 	move.l a0,d1
00:00008E4E 61000734        	  3044: 	bsr	DisplayTetra
00:00008E52 7407            	  3045: 	moveq #7,d2						; assume bytes
00:00008E54 0C04004C        	  3046: 	cmpi.b #'L',d4
00:00008E58 6604            	  3047: 	bne.s .0004
00:00008E5A 7401            	  3048: 	moveq	#1,d2
00:00008E5C 6008            	  3049: 	bra.s dspmem1
                            	  3050: .0004:
00:00008E5E 0C040057        	  3051: 	cmpi.b #'W',d4
00:00008E62 6602            	  3052: 	bne.s dspmem1
00:00008E64 7403            	  3053: 	moveq #3,d2
                            	  3054: dspmem1:
00:00008E66 123C0020        	  3055: 	move.b #' ',d1
00:00008E6A 610010BE        	  3056: 	bsr	OutputChar
00:00008E6E 0C04004C        	  3057: 	cmpi.b #'L',d4
00:00008E72 6608            	  3058: 	bne.s .0005
00:00008E74 2218            	  3059: 	move.l (a0)+,d1
00:00008E76 6100070C        	  3060: 	bsr	DisplayTetra
00:00008E7A 6014            	  3061: 	bra.s .0006
                            	  3062: .0005:
00:00008E7C 0C040057        	  3063: 	cmpi.b #'W',d4
00:00008E80 6608            	  3064: 	bne.s .0007
00:00008E82 3218            	  3065: 	move.w (a0)+,d1
00:00008E84 61000704        	  3066: 	bsr	DisplayWyde
00:00008E88 6006            	  3067: 	bra.s .0006
                            	  3068: .0007:
00:00008E8A 1218            	  3069: 	move.b (a0)+,d1
00:00008E8C 61000702        	  3070: 	bsr DisplayByte
                            	  3071: .0006:
00:00008E90 51CAFFD4        	  3072: 	dbra d2,dspmem1
00:00008E94 610006D4        	  3073: 	bsr	DisplayTwoSpaces
00:00008E98 123C0022        	  3074: 	move.b #34,d1
00:00008E9C 6100108C        	  3075: 	bsr	OutputChar
00:00008EA0 5188            	  3076: 	lea	-8(a0),a0
00:00008EA2 7407            	  3077: 	moveq	#7,d2
                            	  3078: .0002:
00:00008EA4 1218            	  3079: 	move.b (a0)+,d1
00:00008EA6 B23C0020        	  3080: 	cmp.b	#' ',d1
00:00008EAA 6506            	  3081: 	blo.s	.0003
00:00008EAC B23C007F        	  3082: 	cmp.b	#127,d1
00:00008EB0 6304            	  3083: 	bls.s	.0001
                            	  3084: .0003:
00:00008EB2 123C002E        	  3085: 	move.b #'.',d1
                            	  3086: .0001:
00:00008EB6 61001072        	  3087: 	bsr	OutputChar
00:00008EBA 51CAFFE8        	  3088: 	dbra d2,.0002
00:00008EBE 123C0022        	  3089: 	move.b #34,d1
00:00008EC2 61001066        	  3090: 	bsr	OutputChar
00:00008EC6 4EB9000008D2    	  3091: 	bsr	CheckForCtrlC
00:00008ECC 6000EC24        	  3092: 	bra	CRLF
                            	  3093: 
                            	  3094: ;------------------------------------------------------------------------------
                            	  3095: ; Dump Registers
                            	  3096: ;    The dump is in a format that allows the register value to be edited.
                            	  3097: ;
                            	  3098: ; RegD0 12345678
                            	  3099: ; RegD1 77777777
                            	  3100: ;	... etc
                            	  3101: ;------------------------------------------------------------------------------
                            	  3102: 
                            	  3103: cmdDumpRegs:
00:00008ED0 6100EC20        	  3104: 	bsr	CRLF
00:00008ED4 363C000F        	  3105: 	move.w #15,d3						; number of registers-1
00:00008ED8 41FA007A        	  3106: 	lea	msg_reglist,a0			;
00:00008EDC 43FA0072        	  3107: 	lea	msg_regs,a1
00:00008EE0 45F900040100    	  3108: 	lea	Regsave,a2					; a2 points to register save area
                            	  3109: .0001:
00:00008EE6 6100EC24        	  3110: 	bsr			DisplayString
00:00008EEA 1218            	  3111: 	move.b	(a0)+,d1
00:00008EEC 6100103C        	  3112: 	bsr			OutputChar
00:00008EF0 1218            	  3113: 	move.b	(a0)+,d1
00:00008EF2 61001036        	  3114: 	bsr			OutputChar
00:00008EF6 61000684        	  3115: 	bsr			DisplaySpace
00:00008EFA 221A            	  3116: 	move.l	(a2)+,d1
00:00008EFC 61000686        	  3117: 	bsr			DisplayTetra
00:00008F00 6100EBF0        	  3118: 	bsr			CRLF
00:00008F04 51CBFFE0        	  3119: 	dbra		d3,.0001
00:00008F08 6100EC02        	  3120: 	bsr			DisplayString
00:00008F0C 1218            	  3121: 	move.b	(a0)+,d1
00:00008F0E 6100101A        	  3122: 	bsr			OutputChar
00:00008F12 1218            	  3123: 	move.b	(a0)+,d1
00:00008F14 61001014        	  3124: 	bsr			OutputChar
00:00008F18 61000662        	  3125: 	bsr			DisplaySpace
00:00008F1C 223900040144    	  3126: 	move.l	Regsave+$44,d1
00:00008F22 61000660        	  3127: 	bsr			DisplayTetra
00:00008F26 6100EBCA        	  3128: 	bsr			CRLF
00:00008F2A 6100EBE0        	  3129: 	bsr			DisplayString
00:00008F2E 1218            	  3130: 	move.b	(a0)+,d1
00:00008F30 61000FF8        	  3131: 	bsr			OutputChar
00:00008F34 1218            	  3132: 	move.b	(a0)+,d1
00:00008F36 61000FF2        	  3133: 	bsr			OutputChar
00:00008F3A 61000640        	  3134: 	bsr			DisplaySpace
00:00008F3E 323900040140    	  3135: 	move.w	Regsave+$40,d1
00:00008F44 61000644        	  3136: 	bsr			DisplayWyde
00:00008F48 6100EBA8        	  3137: 	bsr			CRLF
00:00008F4C 6000F20E        	  3138: 	bra			Monitor
                            	  3139: 
                            	  3140: msg_regs:
00:00008F50 526567          	  3141: 	dc.b	"Reg",0
00:00008F53 00
                            	  3142: msg_reglist:
00:00008F54 4430443144324433	  3143: 	dc.b	"D0D1D2D3D4D5D6D7A0A1A2A3A4A5A6A7PCSR",0
00:00008F5C 4434443544364437
00:00008F64 4130413141324133
00:00008F6C 4134413541364137
00:00008F74 50435352
00:00008F78 00
                            	  3144: 
                            	  3145: 	align	1
                            	  3146: 
                            	  3147: ;------------------------------------------------------------------------------
                            	  3148: ;------------------------------------------------------------------------------
                            	  3149: 
                            	  3150: cmdTestSerialReceive:
                            	  3151: .0002:
00:00008F7A 7024            	  3152: 	moveq		#36,d0				; serial get char from buffer
00:00008F7C 4E4F            	  3153: 	trap		#15
                            	  3154: ;	bsr			SerialPeekCharDirect
00:00008F7E 4A41            	  3155: 	tst.w		d1
00:00008F80 6B0A            	  3156: 	bmi.s		.0001
00:00008F82 0C01001A        	  3157: 	cmpi.b	#CTRLZ,d1
00:00008F86 670C            	  3158: 	beq			.0003
00:00008F88 61000FA0        	  3159: 	bsr			OutputChar
                            	  3160: .0001:	
00:00008F8C 4EB9000008D2    	  3161: 	bsr			CheckForCtrlC
00:00008F92 60E6            	  3162: 	bra			.0002
                            	  3163: .0003:
00:00008F94 4EB9000006D8    	  3164: 	bsr			_KeybdInit
00:00008F9A 6000F1C0        	  3165: 	bra			Monitor
                            	  3166: 
                            	  3167: ;------------------------------------------------------------------------------
                            	  3168: ; Get a hexidecimal number. Maximum of eight digits.
                            	  3169: ;
                            	  3170: ; Returns:
                            	  3171: ;		d0 = number of digits
                            	  3172: ;		d1 = value of number
                            	  3173: ;		zf = number of digits == 0
                            	  3174: ;------------------------------------------------------------------------------
                            	  3175: 
                            	  3176: GetHexNumber:
00:00008F9E 2F02            	  3177: 	move.l d2,-(a7)
00:00008FA0 7400            	  3178: 	clr.l	d2
00:00008FA2 7000            	  3179: 	moveq	#0,d0
                            	  3180: .0002
00:00008FA4 6100F1A2        	  3181: 	bsr	FromScreen
00:00008FA8 61000586        	  3182: 	bsr	AsciiToHexNybble
00:00008FAC 0C0100FF        	  3183: 	cmpi.b #$ff,d1
00:00008FB0 6712            	  3184: 	beq.s	.0001
00:00008FB2 E98A            	  3185: 	lsl.l	#4,d2
00:00008FB4 02810000000F    	  3186: 	andi.l #$0f,d1
00:00008FBA 8481            	  3187: 	or.l d1,d2
00:00008FBC 5240            	  3188: 	addq #1,d0
00:00008FBE 0C000008        	  3189: 	cmpi.b #8,d0
00:00008FC2 65E0            	  3190: 	blo.s	.0002
                            	  3191: .0001
00:00008FC4 2202            	  3192: 	move.l d2,d1
00:00008FC6 241F            	  3193: 	move.l (a7)+,d2
00:00008FC8 4A00            	  3194: 	tst.b	d0
00:00008FCA 4E75            	  3195: 	rts	
                            	  3196: 
                            	  3197: GetDecNumber:
00:00008FCC 48E73000        	  3198: 	movem.l d2/d3,-(a7)
00:00008FD0 7400            	  3199: 	clr.l d2
00:00008FD2 7000            	  3200: 	clr.l d0
                            	  3201: .0002
00:00008FD4 6100F172        	  3202: 	bsr FromScreen					; grab a character off the screen
00:00008FD8 61000556        	  3203: 	bsr	AsciiToHexNybble		; convert to an ascii nybble
00:00008FDC 0C0100FF        	  3204: 	cmpi.b #$ff,d1
00:00008FE0 6718            	  3205: 	beq.s	.0001
00:00008FE2 02810000000F    	  3206: 	andi.l #$0F,d1					; d1 = 0 to 9
00:00008FE8 2602            	  3207: 	move.l d2,d3						; d3 = current number
00:00008FEA D683            	  3208: 	add.l d3,d3							; d3*2
00:00008FEC E78A            	  3209: 	lsl.l #3,d2							; current number * 8
00:00008FEE D483            	  3210: 	add.l d3,d2							; current number * 10
00:00008FF0 D481            	  3211: 	add.l d1,d2							; add in new digit
00:00008FF2 5240            	  3212: 	addq #1,d0							; increment number of digits
00:00008FF4 0C000009        	  3213: 	cmpi.b #9,d0						; make sure 9 or fewer
00:00008FF8 65DA            	  3214: 	blo .0002
                            	  3215: .0001
00:00008FFA 2202            	  3216: 	move.l d2,d1						; return number in d1
00:00008FFC 4CDF000C        	  3217: 	movem.l (a7)+,d2/d3
00:00009000 4A00            	  3218: 	tst.b d0
00:00009002 4E75            	  3219: 	rts
                            	  3220: 	
                            	  3221: 	include "FloatToString.x68"

Source: "FloatToString.x68"
                            	     1: 	code
                            	     2: ;==============================================================================
                            	     3: ; Decimal-Floating point to string conversion routine.
                            	     4: ;
                            	     5: ; Modifies
                            	     6: ;		_fpWork work area
                            	     7: ; Register Usage:
                            	     8: ; 	fp0 = input decimal-float to convert
                            	     9: ;		fp1 = constant holder, 1.0, 10.0
                            	    10: ;		fp2 = 1.0e<fp0 exponent> value for conversion
                            	    11: ;		fp3 = holds digit value during significand conversion
                            	    12: ; 	a0 = pointer to string buffer, updated to point to NULL at end of string
                            	    13: ;		a1 = pointer to "Nan" or "Inf" message string
                            	    14: ;		d0 = temporary
                            	    15: ;		d1 = digit value during exponent, significand conversion
                            	    16: ; 	d6 = exponent
                            	    17: ;==============================================================================
                            	    18: 	align 4
00:00009010 25FF0000        	    19: _dfOne	dc.l $25ff0000,$00000000,$00000000
00:00009014 00000000
00:00009018 00000000
00:0000901C 2600C000        	    20: _dfTen	dc.l $2600C000,$00000000,$00000000
00:00009020 00000000
00:00009024 00000000
00:00009028 2606DDFA        	    21: _dfMil  dc.l $2606DDFA,$1C000000,$00000000
00:0000902C 1C000000
00:00009030 00000000
                            	    22: 
00:00009034 4E614E          	    23: _msgNan	dc.b "NaN",0
00:00009037 00
00:00009038 496E66          	    24: _msgInf dc.b "Inf",0
00:0000903B 00
                            	    25: 	even
                            	    26: 
                            	    27: ;------------------------------------------------------------------------------
                            	    28: ; Check for the special Nan and infinity values. Output the appropriate string.
                            	    29: ;
                            	    30: ; Modifies
                            	    31: ;		_fpWork area
                            	    32: ;		a0
                            	    33: ; Parameters:
                            	    34: ;		fp0 = dbl
                            	    35: ;------------------------------------------------------------------------------
                            	    36: 
                            	    37: _CheckNan:
00:0000903C 4E52FFF4        	    38: 	link a2,#-12
00:00009040 48D70201        	    39: 	movem.l d0/a1,(sp)
00:00009044 2F79000400980008	    40: 	move.l _canary,8(sp)
00:0000904C F239680000040600	    41: 	fmove.x fp0,_fpWork
00:00009054 103900040600    	    42: 	move.b _fpWork,d0				; get sign+combo
00:0000905A 0200007C        	    43: 	andi.b #$7C,d0					; mask for combo bits
00:0000905E 0C00007C        	    44: 	cmpi.b #$7C,d0					; is it the Nan combo?
00:00009062 6606            	    45: 	bne .notNan
00:00009064 43FAFFCE        	    46: 	lea _msgNan,a1					; output "Nan"
00:00009068 600A            	    47: 	bra .outStr
                            	    48: .notNan
00:0000906A 0C000078        	    49: 	cmpi.b #$78,d0					; is it infinity combo?
00:0000906E 661E            	    50: 	bne .notInf
00:00009070 43FAFFC6        	    51: 	lea _msgInf,a1
                            	    52: .outStr
00:00009074 10D9            	    53: 	move.b (a1)+,(a0)+			; output "Inf"
00:00009076 10D9            	    54: 	move.b (a1)+,(a0)+
00:00009078 10D9            	    55: 	move.b (a1)+,(a0)+
00:0000907A 4210            	    56: 	clr.b (a0)
00:0000907C 4CD70201        	    57: 	movem.l (sp),d0/a1
00:00009080 A2AF00030008    	    58: 	cchk 8(sp)
00:00009086 4E5A            	    59: 	unlk a2
00:00009088 003C0001        	    60: 	ori #1,ccr							; set carry and return
00:0000908C 4E75            	    61: 	rts
                            	    62: .notInf
00:0000908E 4CD70201        	    63: 	movem.l (sp),d0/a1
00:00009092 A2AF00030008    	    64: 	cchk 8(sp)
00:00009098 4E5A            	    65: 	unlk a2
00:0000909A 023C00FE        	    66: 	andi #$FE,ccr						; clear carry and return
00:0000909E 4E75            	    67: 	rts
                            	    68: 
                            	    69: ;------------------------------------------------------------------------------
                            	    70: ; Check for a zero value. Output a single "0" if zero,
                            	    71: ;
                            	    72: ; Modifies:
                            	    73: ;		a0
                            	    74: ; Parameters:
                            	    75: ;		fp0 = dbl
                            	    76: ;------------------------------------------------------------------------------
                            	    77: 
                            	    78: _CheckZero:
00:000090A0 F200003A        	    79: 	ftst fp0								; check if number is zero
00:000090A4 F28E000E        	    80: 	fbne .0003
00:000090A8 10FC0030        	    81: 	move.b #'0',(a0)+				; if zero output "0"
00:000090AC 4210            	    82: 	clr.b (a0)
00:000090AE 003C0004        	    83: 	ori #4,ccr							; set zf
00:000090B2 4E75            	    84: 	rts
                            	    85: .0003
00:000090B4 023C00FB        	    86: 	andi #$FB,ccr						; clear zf
00:000090B8 4E75            	    87: 	rts
                            	    88: 
                            	    89: ;------------------------------------------------------------------------------
                            	    90: ; Check for a negative number. This includes Nans and Infinities. Output a "-"
                            	    91: ; if negative.
                            	    92: ;
                            	    93: ;	Modifies
                            	    94: ;		a0
                            	    95: ; Parameters:
                            	    96: ;		fp0 = dbl
                            	    97: ;------------------------------------------------------------------------------
                            	    98: 
                            	    99: _CheckNegative:
00:000090BA F200003A        	   100: 	ftst fp0								; is number negative?
00:000090BE F293000A        	   101: 	fbge .0002
00:000090C2 10FC002D        	   102: 	move.b #'-',(a0)+				; yes, output '-'
00:000090C6 F200001A        	   103: 	fneg fp0								; make fp0 positive
                            	   104: .0002
00:000090CA 4E75            	   105: 	rts
                            	   106: 
                            	   107: ;------------------------------------------------------------------------------
                            	   108: ; Make the input value larger so that digits may appear before the decimal
                            	   109: ; point.
                            	   110: ;
                            	   111: ; Modifies:
                            	   112: ;		fp0,fp1,d6
                            	   113: ; Parameters:
                            	   114: ;		fp0 = dbl
                            	   115: ;------------------------------------------------------------------------------
                            	   116: 
                            	   117: ;	if (dbl < 1.0) {
                            	   118: ;		while (dbl < 1.0) {
                            	   119: ;			dbl *= 1000000.0;
                            	   120: ;			exp -= 6;  
                            	   121: ;		}
                            	   122: ;	}
                            	   123: 
                            	   124: _MakeBig:
00:000090CC F23C50800001    	   125: 	fmove.w #1,fp1
                            	   126: .0002
00:000090D2 F2000438        	   127: 	fcmp fp1,fp0						; is fp0 > 1?
00:000090D6 F293000E        	   128: 	fbge .0001							; yes, return
00:000090DA F23C402600000006	   129: 	fscale.l #6,fp0					; multiply fp0 by a million
00:000090E2 5D46            	   130: 	subi.w #6,d6						; decrement exponent by six
00:000090E4 60EC            	   131: 	bra .0002								; keep trying until number is > 1
                            	   132: .0001
00:000090E6 4E75            	   133: 	rts
                            	   134: 	
                            	   135: ;------------------------------------------------------------------------------
                            	   136: ;	Create a number dbl2 on the same order of magnitude as dbl, but
                            	   137: ;	less than dbl. The number will be 1.0e<dbl's exponent>
                            	   138: ;
                            	   139: ; Modifies:
                            	   140: ;		d6,fp2
                            	   141: ; Parameters:
                            	   142: ;		fp0 = dbl
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: ;	// The following is similar to using log10() and pow() functions.
                            	   146: ;	// Now dbl is >= 1.0
                            	   147: ;	// Create a number dbl2 on the same order of magnitude as dbl, but
                            	   148: ;	// less than dbl.
                            	   149: ;	dbl2 = 1.0;
                            	   150: ;	dbla = dbl2;
                            	   151: ;	if (dbl > dbl2) {	// dbl > 1.0 ?
                            	   152: ;		while (dbl2 <= dbl) {
                            	   153: ;			dbla = dbl2;
                            	   154: ;			dbl2 *= 10.0;	// increase power of 10
                            	   155: ;			exp++;
                            	   156: ;		}
                            	   157: ;		// The above loop goes one too far, we want the last value less
                            	   158: ;		// than dbl.
                            	   159: ;		dbl2 = dbla;
                            	   160: ;		exp--;
                            	   161: ;	}
                            	   162: 
                            	   163: _LessThanDbl:
00:000090E8 F23C51000001    	   164: 	fmove.w #1,fp2			; setup fp2 = 1
00:000090EE F2000838        	   165: 	fcmp fp2,fp0				; if (dbl > dbl2)
00:000090F2 F295001E        	   166: 	fble .0004
                            	   167: .0006
00:000090F6 F2000138        	   168: 	fcmp fp0,fp2				; while (dbl2 <= dbl)
00:000090FA F292000C        	   169: 	fbgt .0005
00:000090FE F23C51260001    	   170: 	fscale.w #1,fp2			; dbl2 *= 10 (increase exponent by one)
00:00009104 5246            	   171: 	addi.w #1,d6				; exp++
00:00009106 60EE            	   172: 	bra .0006
                            	   173: .0005
00:00009108 F23C4126FFFFFFFF	   174: 	fscale.l #-1,fp2		; dbl2 /= 10 (decrease exponent by one)
00:00009110 5346            	   175: 	subi.w #1,d6				; exp--;
                            	   176: .0004	
                            	   177: ;	fmove.x fp0,_fpWork	; debugging
                            	   178: ;	fmove.x fp2,_fpWork+12
00:00009112 4E75            	   179: 	rts
                            	   180: 
                            	   181: ;------------------------------------------------------------------------------
                            	   182: ; Compute the number of digits before the decimal point.
                            	   183: ;
                            	   184: ; Modifies:
                            	   185: ;		d0,d6,_digits_before_decpt
                            	   186: ; Parameters:
                            	   187: ;		d6 = exponent
                            	   188: ;------------------------------------------------------------------------------
                            	   189: 
                            	   190: ; if (exp >= 0 && exp < 6) {
                            	   191: ;   digits_before_decpt = exp+1;
                            	   192: ;		exp = 0;
                            	   193: ;	}
                            	   194: ;	else if (exp >= -7)
                            	   195: ;		digits_before_decpt = 1;
                            	   196: ;	else
                            	   197: ;		digits_before_decpt = -1;
                            	   198: 
                            	   199: _ComputeDigitsBeforeDecpt:
00:00009114 2F00            	   200: 	move.l d0,-(a7)
00:00009116 4A46            	   201: 	tst.w d6
00:00009118 6B16            	   202: 	bmi .0007
00:0000911A 0C460006        	   203: 	cmpi.w #6,d6
00:0000911E 6C10            	   204: 	bge .0007
00:00009120 3006            	   205: 	move.w d6,d0
00:00009122 5240            	   206: 	addi.w #1,d0
00:00009124 33C000040510    	   207: 	move.w d0,_digits_before_decpt	
00:0000912A 4246            	   208: 	clr.w d6
00:0000912C 201F            	   209: 	move.l (a7)+,d0
00:0000912E 4E75            	   210: 	rts
                            	   211: .0007
00:00009130 0C46FFF9        	   212: 	cmpi.w #-7,d6
00:00009134 6D0C            	   213: 	blt .0009
00:00009136 33FC000100040510	   214: 	move.w #1,_digits_before_decpt
00:0000913E 201F            	   215: 	move.l (a7)+,d0
00:00009140 4E75            	   216: 	rts
                            	   217: .0009
00:00009142 33FCFFFF00040510	   218: 	move.w #-1,_digits_before_decpt
00:0000914A 201F            	   219: 	move.l (a7)+,d0
00:0000914C 4E75            	   220: 	rts
                            	   221: 
                            	   222: ;------------------------------------------------------------------------------
                            	   223: ;	Spit out a leading zero before the decimal point for a small number.
                            	   224: ;
                            	   225: ; Modifies:
                            	   226: ;		a0
                            	   227: ; Parameters:
                            	   228: ;		d6 = exponent
                            	   229: ;------------------------------------------------------------------------------
                            	   230: 
                            	   231: ;  if (exp < -7) {
                            	   232: ;		 buf[ndx] = '0';
                            	   233: ;		 ndx++;
                            	   234: ;    buf[ndx] = '.';
                            	   235: ;    ndx++;
                            	   236: ;  }
                            	   237: 
                            	   238: _LeadingZero:
00:0000914E 0C46FFF9        	   239: 	cmpi.w #-7,d6
00:00009152 6C08            	   240: 	bge .0010
00:00009154 10FC0030        	   241: 	move.b #'0',(a0)+
00:00009158 10FC002E        	   242: 	move.b #'.',(a0)+
                            	   243: .0010
00:0000915C 4E75            	   244: 	rts
                            	   245: 
                            	   246: ;------------------------------------------------------------------------------
                            	   247: ; Extract the digits of the significand.
                            	   248: ;
                            	   249: ; Modifies:
                            	   250: ;		_precision variable
                            	   251: ; Register Usage
                            	   252: ;		d0 = counter
                            	   253: ;		d1 = digit
                            	   254: ;		fp0 = dbl
                            	   255: ;		fp2 = dbl2
                            	   256: ;		fp3 = digit as decimal float
                            	   257: ;		fp7 = dbla
                            	   258: ; Parameters:
                            	   259: ;		fp0, fp2
                            	   260: ;------------------------------------------------------------------------------
                            	   261: 
                            	   262: ;	// Now loop processing one digit at a time.
                            	   263: ;  for (nn = 0; nn < 25 && precision > 0; nn++) {
                            	   264: ;    digit = 0;
                            	   265: ;		dbla = dbl;
                            	   266: ;		// dbl is on the same order of magnitude as dbl2 so
                            	   267: ;		// a repeated subtract can be used to find the digit.
                            	   268: ;    while (dbl >= dbl2) {
                            	   269: ;      dbl -= dbl2;
                            	   270: ;      digit++;
                            	   271: ;    }
                            	   272: ;    buf[ndx] = digit + '0';
                            	   273: ;		// Now go back and perform just a single subtract and
                            	   274: ;		// a multiply to find out how much to reduce dbl by.
                            	   275: ;		// This should improve the accuracy
                            	   276: ;		if (digit > 2)
                            	   277: ;			dbl = dbla - dbl2 * digit;
                            	   278: ;    ndx++;
                            	   279: ;    digits_before_decpt--;
                            	   280: ;    if (digits_before_decpt==0) {
                            	   281: ;			buf[ndx] = '.';
                            	   282: ;			ndx++;
                            	   283: ;    }
                            	   284: ;    else if (digits_before_decpt < 0)
                            	   285: ;      precision--;
                            	   286: ;		// Shift the next digit to be tested into position.
                            	   287: ;    dbl *= 10.0;
                            	   288: ;  }
                            	   289: 	
                            	   290: _SpitOutDigits:
00:0000915E 4E52FFE8        	   291: 	link a2,#-24
00:00009162 2F79000400980014	   292: 	move.l _canary,20(sp)
00:0000916A F2176B80        	   293: 	fmove.x fp7,(sp)
00:0000916E 48EF0003000C    	   294: 	movem.l d0/d1,12(sp)
00:00009174 303C0018        	   295: 	move.w #24,d0			; d0 = nn
                            	   296: .0017	
00:00009178 4AB900040514    	   297: 	tst.l _precision
00:0000917E 6F46            	   298: 	ble .0011
00:00009180 7200            	   299: 	moveq #0,d1				; digit = 0
00:00009182 F2000380        	   300: 	fmove fp0,fp7			; dbla = dbl
                            	   301: .0013
00:00009186 F2000838        	   302: 	fcmp fp2,fp0
00:0000918A F294000A        	   303: 	fblt .0012
00:0000918E F2000828        	   304: 	fsub fp2,fp0			; dbl -= dbl2
00:00009192 5201            	   305: 	addi.b #1,d1			; digit++
00:00009194 60F0            	   306: 	bra .0013
                            	   307: .0012
00:00009196 06010030        	   308: 	addi.b #'0',d1		; convert digit to ascii
00:0000919A 10C1            	   309: 	move.b d1,(a0)+		; and store
00:0000919C 04010030        	   310: 	subi.b #'0',d1		; d1 = binary digit again
                            	   311: ;	cmpi.b #2,d1
                            	   312: ;	ble .0014
                            	   313: 
                            	   314: ;	ext.w d1
                            	   315: ;	ext.l d1
                            	   316: ;	fmove.l d1,fp3		; fp3 = digit
                            	   317: ;	fmul fp2,fp3			; fp3 = dbl2 * digit
                            	   318: ;	fmove fp7,fp0
                            	   319: ;	fsub fp3,fp0			; dbl = dbla - dbl2 * digit
                            	   320: .0014
00:000091A0 537900040510    	   321: 	subi.w #1,_digits_before_decpt
00:000091A6 6604            	   322: 	bne .0015
00:000091A8 10FC002E        	   323: 	move.b #'.',(a0)+
                            	   324: .0015
00:000091AC 4A7900040510    	   325: 	tst.w _digits_before_decpt
00:000091B2 6C06            	   326: 	bge .0016
00:000091B4 53B900040514    	   327: 	subi.l #1,_precision
                            	   328: .0016
00:000091BA F23C4126FFFFFFFF	   329: 	fscale.l #-1,fp2		; dbl *= 10.0
00:000091C2 51C8FFB4        	   330: 	dbra d0,.0017
                            	   331: .0011
00:000091C6 4CEF0003000C    	   332: 	movem.l 12(sp),d0/d1
00:000091CC F2174B80        	   333: 	fmove.x (sp),fp7
00:000091D0 A2AF00030014    	   334: 	cchk 20(sp)
00:000091D6 4E5A            	   335: 	unlk a2
00:000091D8 4E75            	   336: 	rts
                            	   337: 
                            	   338: ;------------------------------------------------------------------------------
                            	   339: ; If the number ends in a decimal point, trim off the point.
                            	   340: ;
                            	   341: ; Registers Modified:
                            	   342: ;		none
                            	   343: ; Parameters:
                            	   344: ;		a0 = pointer to end of number
                            	   345: ; Returns:
                            	   346: ;		a0 = updated to point just past last digit.
                            	   347: ;------------------------------------------------------------------------------
                            	   348: 
                            	   349: _TrimTrailingPoint:
00:000091DA 0C28002EFFFF    	   350: 	cmpi.b #'.',-1(a0)
00:000091E0 6604            	   351: 	bne .0001
00:000091E2 4220            	   352: 	clr.b -(a0)
00:000091E4 4E75            	   353: 	rts
                            	   354: .0001
00:000091E6 0C10002E        	   355: 	cmpi.b #'.',(a0)
00:000091EA 660A            	   356: 	bne .0002
00:000091EC 4A280001        	   357: 	cmpi.b #0,1(a0)
00:000091F0 6604            	   358: 	bne .0002
00:000091F2 4210            	   359: 	clr.b (a0)
00:000091F4 5348            	   360: 	subq #1,a0
                            	   361: .0002
00:000091F6 4E75            	   362: 	rts
                            	   363: 	
                            	   364: ;------------------------------------------------------------------------------
                            	   365: ; If the number ends in .0 get rid of the .0
                            	   366: ;
                            	   367: ; Registers Modified:
                            	   368: ;		none
                            	   369: ; Parameters:
                            	   370: ;		a0 = pointer to last digits of number
                            	   371: ; Returns:
                            	   372: ;		a0 = updated to point just past last digit.
                            	   373: ;------------------------------------------------------------------------------
                            	   374: 
                            	   375: _TrimDotZero:
00:000091F8 4A10            	   376: 	tst.b (a0)
00:000091FA 6616            	   377: 	bne .0004
00:000091FC 0C280030FFFF    	   378: 	cmpi.b #'0',-1(a0)
00:00009202 660E            	   379: 	bne .0004
00:00009204 0C28002EFFFE    	   380: 	cmpi.b #'.',-2(a0)
00:0000920A 6606            	   381: 	bne .0004
00:0000920C 4228FFFE        	   382: 	clr.b -2(a0)
00:00009210 5548            	   383: 	subq #2,a0
                            	   384: .0004
00:00009212 4E75            	   385: 	rts
                            	   386: 
                            	   387: ;------------------------------------------------------------------------------
                            	   388: ; Trim trailing zeros from the number. Generally there is no need to display
                            	   389: ; trailing zeros.
                            	   390: ; Turns a number like 652.000000000000000000000 into 650.0
                            	   391: ;
                            	   392: ; Registers Modified:
                            	   393: ;		none
                            	   394: ; Parameters:
                            	   395: ;		a0 = pointer to last digits of number
                            	   396: ; Returns:
                            	   397: ;		a0 = updated to point just past last digit.
                            	   398: ;------------------------------------------------------------------------------
                            	   399: 
                            	   400: ;	// Trim trailing zeros from the number
                            	   401: ;  do {
                            	   402: ;      ndx--;
                            	   403: ;  } while(buf[ndx]=='0');
                            	   404: ;  ndx++;
                            	   405: 
                            	   406: _TrimTrailingZeros:
                            	   407: .0018	
00:00009214 0C200030        	   408: 	cmpi.b #'0',-(a0)		; if the last digit was a zero, backup
00:00009218 67FA            	   409: 	beq .0018
00:0000921A 5248            	   410: 	addq #1,a0					; now advance by one
00:0000921C 4210            	   411: 	move.b #0,(a0)			; NULL terminate string
00:0000921E 4E75            	   412: 	rts
                            	   413: 
                            	   414: ;------------------------------------------------------------------------------
                            	   415: ; Output 'e+' or 'e-'
                            	   416: ;
                            	   417: ; Registers Modified:
                            	   418: ;		d6.w (if negative)
                            	   419: ; Parameters:
                            	   420: ;		a0 = pointer to last digits of number
                            	   421: ; Returns:
                            	   422: ;		a0 = updated to point just past '+' or '-'.
                            	   423: ;------------------------------------------------------------------------------
                            	   424: 
                            	   425: ;	// Spit out +/-E
                            	   426: ;  buf[ndx] = E;
                            	   427: ;  ndx++;
                            	   428: ;  if (exp < 0) {
                            	   429: ;    buf[ndx]='-';
                            	   430: ;    ndx++;
                            	   431: ;    exp = -exp;
                            	   432: ;  }
                            	   433: ;  else {
                            	   434: ;		buf[ndx]='+';
                            	   435: ;		ndx++;
                            	   436: ;  }
                            	   437: 
                            	   438: _SpitOutE:	
00:00009220 10F90004050C    	   439: 	move.b _E,(a0)+
00:00009226 4A46            	   440: 	tst.w d6
00:00009228 6C08            	   441: 	bge .0021
00:0000922A 10FC002D        	   442: 	move.b #'-',(a0)+
00:0000922E 4446            	   443: 	neg.w d6
00:00009230 6004            	   444: 	bra .0022
                            	   445: .0021
00:00009232 10FC002B        	   446: 	move.b #'+',(a0)+
                            	   447: .0022
00:00009236 4E75            	   448: 	rts
                            	   449: 
                            	   450: ;------------------------------------------------------------------------------
                            	   451: ; Extract a single digit of the exponent. Extract works from the leftmost digit
                            	   452: ; to the rightmost.
                            	   453: ;
                            	   454: ; Register Usage
                            	   455: ;		d2 = history of zeros
                            	   456: ;		d3 = digit
                            	   457: ; Modifies
                            	   458: ;		d2,d6,a0
                            	   459: ; Parameter
                            	   460: ; 	d1.w = power of ten
                            	   461: ;		d6.w = exponent
                            	   462: ;------------------------------------------------------------------------------
                            	   463: 
                            	   464: _ExtExpDigit:
00:00009238 2F03            	   465: 	move.l d3,-(a7)
00:0000923A 48C6            	   466: 	ext.l d6				; make d6 a long
00:0000923C 8CC1            	   467: 	divu d1,d6			; divide by power of ten
00:0000923E 1606            	   468: 	move.b d6,d3		; d3 = quotient (0 to 9)
00:00009240 4846            	   469: 	swap d6					; d6 = remainder, setup for next digit
00:00009242 8403            	   470: 	or.b d3,d2
00:00009244 4A03            	   471: 	tst.b d3
00:00009246 6604            	   472: 	bne .0003
00:00009248 4A02            	   473: 	tst.b d2	
00:0000924A 6706            	   474: 	beq .0004
                            	   475: .0003
00:0000924C 06030030        	   476: 	addi.b #'0',d3	; convert to ascii
00:00009250 10C3            	   477: 	move.b d3,(a0)+
                            	   478: .0004
00:00009252 261F            	   479: 	move.l (a7)+,d3
00:00009254 4E75            	   480: 	rts
                            	   481: 
                            	   482: ;------------------------------------------------------------------------------
                            	   483: ; Extract all the digits of the exponent.
                            	   484: ;
                            	   485: ; Register Usage
                            	   486: ;		d1 = power of 10
                            	   487: ;		d2 = history of zeros
                            	   488: ; Parameters
                            	   489: ;		a0 = pointer to string buffer
                            	   490: ;		d6 = exponent
                            	   491: ;------------------------------------------------------------------------------
                            	   492: 
                            	   493: ;	// If the number is times 10^0 don't output the exponent
                            	   494: ;  if (exp==0) {
                            	   495: ;    buf[ndx]='\0';
                            	   496: ;    goto prt;
                            	   497: ;  }
                            	   498: 
                            	   499: _ExtExpDigits:
00:00009256 2F01            	   500: 	move.l d1,-(a7)
00:00009258 4A46            	   501: 	tst.w d6							; is exponent zero?
00:0000925A 671C            	   502: 	beq .0002
00:0000925C 61C2            	   503: 	bsr _SpitOutE					; exponent is non-zero e+
00:0000925E 4202            	   504: 	clr.b d2							; d2 = history of zeros
00:00009260 323C03E8        	   505: 	move.w #1000,d1
00:00009264 61D2            	   506: 	bsr _ExtExpDigit
00:00009266 323C0064        	   507: 	move.w #100,d1
00:0000926A 61CC            	   508: 	bsr _ExtExpDigit
00:0000926C 323C000A        	   509: 	move.w #10,d1
00:00009270 61C6            	   510: 	bsr _ExtExpDigit
00:00009272 323C0001        	   511: 	move.w #1,d1
00:00009276 61C0            	   512: 	bsr _ExtExpDigit
                            	   513: .0002:
00:00009278 221F            	   514: 	move.l (a7)+,d1
00:0000927A 4210            	   515: 	move.b #0,(a0)				; NULL terminate string
00:0000927C 4E75            	   516: 	rts										; and return
                            	   517: 
                            	   518: ;------------------------------------------------------------------------------
                            	   519: ; Pad the left side of the output string.
                            	   520: ;
                            	   521: ; Modifies:
                            	   522: ;		d0,d1,d2,d3
                            	   523: ;------------------------------------------------------------------------------
                            	   524: 
                            	   525: ;  // pad left
                            	   526: ;  if (width > 0) {
                            	   527: ;    if (ndx < width) {
                            	   528: ;      for (nn = 39; nn >= width-ndx; nn--)
                            	   529: ;        buf[nn] = buf[nn-(width-ndx)];
                            	   530: ;      for (; nn >= 0; nn--)
                            	   531: ;        buf[nn] = ' ';
                            	   532: ;    }
                            	   533: ;  }
                            	   534: 	
                            	   535: _PadLeft:
00:0000927E 48E7F000        	   536: 	movem.l d0/d1/d2/d3,-(a7)
00:00009282 4A3900040508    	   537: 	tst.b _width
00:00009288 6F3E            	   538: 	ble .0041
00:0000928A 2008            	   539: 	move.l a0,d0
00:0000928C 90BC00040520    	   540: 	sub.l #_fpBuf,d0	; d0 = ndx
00:00009292 B03900040508    	   541: 	cmp.b _width,d0
00:00009298 6C2E            	   542: 	bge .0041
00:0000929A 323C0031        	   543: 	move.w #49,d1			; d1 = nn
                            	   544: .0040
00:0000929E 143900040508    	   545: 	move.b _width,d2
00:000092A4 4882            	   546: 	ext.w d2
00:000092A6 9440            	   547: 	sub.w d0,d2				; d2 = width-ndx
00:000092A8 B242            	   548: 	cmp.w d2,d1
00:000092AA 6D0E            	   549: 	blt .0039
00:000092AC 3601            	   550: 	move.w d1,d3			; d3 = nn
00:000092AE 9642            	   551: 	sub.w d2,d3				; d3 = nn-(width-ndx)
00:000092B0 11B030001000    	   552: 	move.b (a0,d3.w),(a0,d1.w)
00:000092B6 5341            	   553: 	subi.w #1,d1
00:000092B8 60E4            	   554: 	bra .0040
                            	   555: .0039
00:000092BA 4A41            	   556: 	tst.w d1
00:000092BC 6B0A            	   557: 	bmi .0041
00:000092BE 11BC00201000    	   558: 	move.b #' ',(a0,d1.w)
00:000092C4 5341            	   559: 	subi.w #1,d1
00:000092C6 60F2            	   560: 	bra .0039
                            	   561: .0041
00:000092C8 4CDF000F        	   562: 	movem.l (a7)+,d0/d1/d2/d3
00:000092CC 4E75            	   563: 	rts
                            	   564: 
                            	   565: ;------------------------------------------------------------------------------
                            	   566: ; Pad the right side of the output string.
                            	   567: ;
                            	   568: ; Parameters:
                            	   569: ;		a0 = pointer to end of string
                            	   570: ; Modifies:
                            	   571: ;		none
                            	   572: ; Returns:
                            	   573: ;		none
                            	   574: ;------------------------------------------------------------------------------
                            	   575: 
                            	   576: ;  // pad right
                            	   577: ;  if (width < 0) {
                            	   578: ;    width = -width;
                            	   579: ;    while (ndx < width) {
                            	   580: ;      buf[ndx]=' ';
                            	   581: ;      ndx++;
                            	   582: ;    }
                            	   583: ;    buf[ndx]='\0';
                            	   584: ;  }
                            	   585: ;  return (ndx);
                            	   586: 
                            	   587: _PadRight:
00:000092CE 2F00            	   588: 	move.l d0,-(a7)
00:000092D0 4A3900040508    	   589: 	tst.b _width
00:000092D6 6A24            	   590: 	bpl .0042
00:000092D8 443900040508    	   591: 	neg.b _width
00:000092DE 2008            	   592: 	move.l a0,d0
00:000092E0 90BC00040520    	   593: 	sub.l #_fpBuf,d0	; d0 = ndx
                            	   594: .0044
00:000092E6 B03900040508    	   595: 	cmp.b _width,d0
00:000092EC 6C0A            	   596: 	bge .0043
00:000092EE 11BC00200000    	   597: 	move.b #' ',(a0,d0.w)
00:000092F4 5240            	   598: 	addi.w #1,d0
00:000092F6 60EE            	   599: 	bra .0044
                            	   600: .0043
00:000092F8 42300000        	   601: 	move.b #0,(a0,d0.w)
                            	   602: .0042
00:000092FC 201F            	   603: 	move.l (a7)+,d0
00:000092FE 4E75            	   604: 	rts
                            	   605: 
                            	   606: ;------------------------------------------------------------------------------
                            	   607: ; Output a string representation of a decimal floating point number to a 
                            	   608: ; buffer.
                            	   609: ;
                            	   610: ; Register Usage
                            	   611: ;		a0 = pointer to string buffer
                            	   612: ;		d6 = exponent
                            	   613: ; Modifies:
                            	   614: ;		a0 = points to end of string
                            	   615: ; Parameters:
                            	   616: ;		fp0 = number to convert
                            	   617: ; Returns:
                            	   618: ;		none
                            	   619: ;------------------------------------------------------------------------------
                            	   620: 
                            	   621: _FloatToString:
00:00009300 2F06            	   622: 	move.l d6,-(a7)
00:00009302 6100FDB6        	   623: 	bsr _CheckNegative			; is number negative?
00:00009306 6100FD98        	   624: 	bsr _CheckZero					; check for zero
00:0000930A 6732            	   625: 	beq .0001								; branch since already output "0"
00:0000930C 6100FD2E        	   626: 	bsr _CheckNan						; check for Nan or infinity
00:00009310 652C            	   627: 	bcs .0001								; branch if nan/inf string output
                            	   628: 	; Now the fun begins
00:00009312 7C00            	   629: 	clr.l d6								; exponent = 0
00:00009314 6100FDB6        	   630: 	bsr _MakeBig
00:00009318 6100FDCE        	   631: 	bsr _LessThanDbl
00:0000931C 6100FDF6        	   632: 	bsr _ComputeDigitsBeforeDecpt
00:00009320 6100FE2C        	   633: 	bsr _LeadingZero
00:00009324 6100FE38        	   634: 	bsr _SpitOutDigits
00:00009328 6100FEEA        	   635: 	bsr _TrimTrailingZeros
00:0000932C 6100FEAC        	   636: 	bsr _TrimTrailingPoint
00:00009330 6100FEC6        	   637: 	bsr _TrimDotZero
00:00009334 6100FF20        	   638: 	bsr _ExtExpDigits				; extract exponent digits
00:00009338 6100FF44        	   639: 	bsr _PadLeft						; pad the number to the left or right
00:0000933C 6190            	   640: 	bsr _PadRight
                            	   641: .0001
00:0000933E 2C1F            	   642: 	move.l (a7)+,d6
00:00009340 4E75            	   643: 	rts
                            	   644: 
                            	   645: 

Source: "boot.x68"
                            	  3222: 	include "GetFloat.x68"

Source: "GetFloat.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022-2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;
                            	    37: ; Get a floating point number
                            	    38: ;
                            	    39: _GetFloatGetChar:
00:00009342 1210            	    40: 	move.b (a0),d1
00:00009344 D1C0            	    41: 	add.l d0,a0
00:00009346 4E75            	    42: 	rts
                            	    43: _GetFloatIgnBlanks:
                            	    44: .0001
00:00009348 61F8            	    45: 	bsr _GetFloatGetChar
00:0000934A 0C010020        	    46: 	cmpi.b #' ',d1
00:0000934E 67F8            	    47: 	beq .0001
                            	    48: _GetFloatBackupChar:
00:00009350 91C0            	    49: 	sub.l d0,a0
00:00009352 4E75            	    50: 	rts
                            	    51: 
                            	    52: ;-------------------------------------------------------------------------------
                            	    53: ; Get fractional part of a number, 25 digits max, into a float register.
                            	    54: ;
                            	    55: ; Register Usage:
                            	    56: ;		d1 = digit from input screen
                            	    57: ;		d4 = digit count
                            	    58: ;		d6 = digit scaling factor
                            	    59: ;		fp1 = digit as float number
                            	    60: ; Returns:
                            	    61: ;		fp0 = fraction
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: _GetFraction:
00:00009354 4E52FFE4        	    65: 	link a2,#-28
00:00009358 2F79000400980018	    66: 	move.l _canary,24(sp)
00:00009360 48D70052        	    67: 	movem.l d1/d4/d6,(sp)
00:00009364 F22F6880000C    	    68: 	fmove.x fp1,12(sp)
00:0000936A 7C00            	    69: 	clr.l d6							; d6 = scale factor
00:0000936C F23C50000000    	    70: 	fmove.w #0,fp0				; fract = 0.0
00:00009372 7818            	    71: 	moveq #24,d4
                            	    72: .0002
00:00009374 61CC            	    73: 	bsr _GetFloatGetChar
00:00009376 0C010030        	    74: 	cmpi.b #'0',d1
00:0000937A 6520            	    75: 	blo .0001
00:0000937C 0C010039        	    76: 	cmpi.b #'9',d1				; make sure between 0 and 9
00:00009380 621A            	    77: 	bhi .0001
00:00009382 04010030        	    78: 	subi.b #'0',d1
00:00009386 F23C50260001    	    79: 	fscale.w #1,fp0				; fract * 10.0
00:0000938C 5246            	    80: 	addq #1,d6						; record scaling
00:0000938E F2015880        	    81: 	fmove.b d1,fp1				; fp1 = digit
00:00009392 F2000422        	    82: 	fadd fp1,fp0					; fract += digit
00:00009396 5245            	    83: 	addq.w #1,d5					; increment number of digits in number
00:00009398 51CCFFDA        	    84: 	dbra d4,.0002
                            	    85: .0001
00:0000939C 61B2            	    86: 	bsr _GetFloatBackupChar
00:0000939E 4446            	    87: 	neg d6
00:000093A0 F2064026        	    88: 	fscale.l d6,fp0				; fract /= scale
00:000093A4 4CD70052        	    89: 	movem.l (sp),d1/d4/d6
00:000093A8 F22F4880000C    	    90: 	fmove.x 12(sp),fp1
00:000093AE A2AF00030018    	    91: 	cchk 24(sp)
00:000093B4 4E5A            	    92: 	unlk a2
00:000093B6 4E75            	    93: 	rts
                            	    94: 
                            	    95: ;-------------------------------------------------------------------------------
                            	    96: ; Get exponent part of a number, 4 digits max, into a float register.
                            	    97: ;
                            	    98: ; Register Usage:
                            	    99: ;		d1 = digit from input screen
                            	   100: ;		d2 = exponent
                            	   101: ;		d3 = temp, number times 2
                            	   102: ;		d4 = digit counter
                            	   103: ; Parameters:
                            	   104: ;		fp0 = float number
                            	   105: ; Returns:
                            	   106: ;		fp0 = float number with exponent factored in
                            	   107: ;-------------------------------------------------------------------------------
                            	   108: 
                            	   109: _GetExponent:
00:000093B8 4E52FFE0        	   110: 	link a2,#-32
00:000093BC 2F7900040098001C	   111: 	move.l _canary,28(sp)
00:000093C4 48D7001E        	   112: 	movem.l d1/d2/d3/d4,(sp)
00:000093C8 F22F69000010    	   113: 	fmove.x fp2,16(sp)
00:000093CE 7400            	   114: 	clr.l d2							; d2 = number = 0
00:000093D0 F23C51000000    	   115: 	fmove.w #0,fp2				; fp2 = exp = 0.0
00:000093D6 7601            	   116: 	moveq #1,d3						; d3 = exscale = 1
00:000093D8 6100FF68        	   117: 	bsr _GetFloatGetChar
00:000093DC 0C01002D        	   118: 	cmpi.b #'-',d1
00:000093E0 6608            	   119: 	bne .0001
00:000093E2 4483            	   120: 	neg.l d3							; exscale = -1
                            	   121: .0006
00:000093E4 6100FF62        	   122: 	bsr _GetFloatIgnBlanks
00:000093E8 600A            	   123: 	bra .0002
                            	   124: .0001
00:000093EA 0C01002B        	   125: 	cmpi.b #'+',d1
00:000093EE 67F4            	   126: 	beq .0006
00:000093F0 6100FF5E        	   127: 	bsr _GetFloatBackupChar
                            	   128: .0002	
00:000093F4 7803            	   129: 	moveq #3,d4						; d4 = max 4 digits
                            	   130: .0004
00:000093F6 6100FF4A        	   131: 	bsr _GetFloatGetChar	; d1 = digit char
00:000093FA 0C010030        	   132: 	cmpi.b #'0',d1
00:000093FE 651E            	   133: 	blo .0003
00:00009400 0C010039        	   134: 	cmpi.b #'9',d1				; ensure between 0 and 9
00:00009404 6218            	   135: 	bhi .0003
00:00009406 04010030        	   136: 	subi.b #'0',d1
00:0000940A D482            	   137: 	add.l d2,d2						; number *2
00:0000940C 2602            	   138: 	move.l d2,d3
00:0000940E E58A            	   139: 	lsl.l #2,d2						; number *8
00:00009410 D483            	   140: 	add.l d3,d2						; number *10	
00:00009412 4881            	   141: 	ext.w d1
00:00009414 48C1            	   142: 	ext.l d1
00:00009416 D481            	   143: 	add.l d1,d2						; number + digit
00:00009418 5245            	   144: 	addq.w #1,d5					; increment number of digits in number
00:0000941A 51CCFFDA        	   145: 	dbra d4,.0004
                            	   146: .0003
00:0000941E 6100FF30        	   147: 	bsr _GetFloatBackupChar	; backup a character
00:00009422 C4C3            	   148: 	mulu d3,d2						; *1 or *-1
00:00009424 48C2            	   149: 	ext.l d2
00:00009426 F2024126        	   150: 	fscale.l d2,fp2				; exp * exmul
00:0000942A F2000823        	   151: 	fmul fp2,fp0					; rval *= exp
00:0000942E 4CD7001E        	   152: 	movem.l (sp),d1/d2/d3/d4
00:00009432 F22F49000010    	   153: 	fmove.x 16(sp),fp2
00:00009438 A2AF0003001C    	   154: 	cchk 28(sp)
00:0000943E 4E5A            	   155: 	unlk a2
00:00009440 4E75            	   156: 	rts	
                            	   157: 
                            	   158: ;-------------------------------------------------------------------------------
                            	   159: ; Get an integer number, positive or negative, 25 digits max, into a float
                            	   160: ; register.
                            	   161: ;
                            	   162: ; Register Usage:
                            	   163: ;		d1 = digit from input screen
                            	   164: ;		d2 = digit down counter
                            	   165: ;		d3 = sign of number '+' or '-'
                            	   166: ;		fp1 = digit
                            	   167: ; Modifies:
                            	   168: ;		a0,fp0
                            	   169: ; Returns:
                            	   170: ;		a0 = updated buffer pointer
                            	   171: ;		fp0 = integer number
                            	   172: ;-------------------------------------------------------------------------------
                            	   173: 
                            	   174: _GetInteger:
00:00009442 4E52FFE4        	   175: 	link a2,#-28
00:00009446 2F79000400980018	   176: 	move.l _canary,24(sp)
00:0000944E 48D7000E        	   177: 	movem.l d1/d2/d3,(sp)
00:00009452 F22F6880000C    	   178: 	fmove.x fp1,12(sp)
00:00009458 F23C50000000    	   179: 	fmove.w #0,fp0
00:0000945E 7418            	   180: 	moveq #24,d2					; d2 = digit count (25 max)
00:00009460 6100FEE6        	   181: 	bsr _GetFloatIgnBlanks
00:00009464 6100FEDC        	   182: 	bsr _GetFloatGetChar	; get the sign of the number
00:00009468 0C01002B        	   183: 	cmpi.b #'+',d1
00:0000946C 670A            	   184: 	beq .0002
                            	   185: .0003
00:0000946E 0C01002D        	   186: 	cmpi.b #'-',d1
00:00009472 6608            	   187: 	bne .0004
00:00009474 1E3C002D        	   188: 	move.b #'-',d7
                            	   189: .0002
00:00009478 6100FEC8        	   190: 	bsr _GetFloatGetChar
                            	   191: .0004
00:0000947C 0C010030        	   192: 	cmpi.b #'0',d1				; only characters 0 to 9 valid
00:00009480 651E            	   193: 	blo .0001
00:00009482 0C010039        	   194: 	cmpi.b #'9',d1
00:00009486 6218            	   195: 	bhi .0001
00:00009488 04010030        	   196: 	subi.b #'0',d1
00:0000948C F23C50260001    	   197: 	fscale.w #1,fp0				; number *10
00:00009492 F2015880        	   198: 	fmove.b d1,fp1				; fp1 = digit
00:00009496 F2000422        	   199: 	fadd fp1,fp0
00:0000949A 5245            	   200: 	addq.w #1,d5
00:0000949C 51CAFFDA        	   201: 	dbra d2,.0002
                            	   202: .0001
00:000094A0 6100FEAE        	   203: 	bsr _GetFloatBackupChar
00:000094A4 4CD7000E        	   204: 	movem.l (sp),d1/d2/d3
00:000094A8 F22F4880000C    	   205: 	fmove.x 12(sp),fp1
00:000094AE A2AF00030018    	   206: 	cchk 24(sp)
00:000094B4 4E5A            	   207: 	unlk a2
00:000094B6 4E75            	   208: 	rts
                            	   209: 		
                            	   210: ;-------------------------------------------------------------------------------
                            	   211: ; Get a floating point number off the input screen.
                            	   212: ;
                            	   213: ; Parameters:
                            	   214: ;		a0 = pointer to buffer containing string
                            	   215: ;		d0 = stride of buffer (increment / decrement amount)
                            	   216: ; Register Usage:
                            	   217: ;		d1 = character from input screen
                            	   218: ;		d5.lo = number of digits in number, d5.hi = number of characters fetched
                            	   219: ; Returns:
                            	   220: ;		fp0 = number
                            	   221: ;		a0 = updated buffer pointer
                            	   222: ;		d0 = length of number >0 if a number
                            	   223: ;-------------------------------------------------------------------------------
                            	   224: 
                            	   225: _GetFloat:
00:000094B8 4E52FFE0        	   226: 	link a2,#-32
00:000094BC 2F7900040098001C	   227: 	move.l _canary,28(sp)
00:000094C4 48D702A2        	   228: 	movem.l d1/d5/d7/a1,(sp)
00:000094C8 F22F69000010    	   229: 	fmove.x fp2,16(sp)
00:000094CE 7A00            	   230: 	clr.l d5
00:000094D0 1E3C002B        	   231: 	move.b #'+',d7				; assume a positive number
00:000094D4 2248            	   232: 	move.l a0,a1					; a1 = copy of pointer to buffer
00:000094D6 6100FF6A        	   233: 	bsr _GetInteger				; rval = integer
00:000094DA F2000100        	   234: 	fmove.x fp0,fp2
00:000094DE 6100FE62        	   235: 	bsr _GetFloatGetChar
00:000094E2 0C01002E        	   236: 	cmpi.b #'.',d1
00:000094E6 6706            	   237: 	beq .0004
                            	   238: .0005
00:000094E8 6100FE66        	   239: 	bsr _GetFloatBackupChar
00:000094EC 601C            	   240: 	bra .0002
                            	   241: .0004
00:000094EE 6100FE64        	   242: 	bsr _GetFraction
00:000094F2 F2000822        	   243: 	fadd fp2,fp0					; rval += fraction
00:000094F6 6100FE4A        	   244: 	bsr _GetFloatGetChar
00:000094FA 0C010065        	   245: 	cmpi.b #'e',d1				; accept either 'e' or 'E' indicating exponent
00:000094FE 6706            	   246: 	beq .0001
00:00009500 0C010045        	   247: 	cmpi.b #'E',d1
00:00009504 66E2            	   248: 	bne .0005
                            	   249: .0001
00:00009506 6100FEB0        	   250: 	bsr _GetExponent			; factor exponent into fp0
                            	   251: .0002
00:0000950A 0C07002D        	   252: 	cmpi.b #'-',d7				; adjust number for sign
00:0000950E 6604            	   253: 	bne .0003
00:00009510 F200001A        	   254: 	fneg fp0
                            	   255: .0003
00:00009514 93C8            	   256: 	suba.l a0,a1					; compute number of characters fetched
00:00009516 3009            	   257: 	move.w a1,d0					; move it to d0.hi
00:00009518 4840            	   258: 	swap d0
00:0000951A 3005            	   259: 	move.w d5,d0					; return digit/character count in d0 (non zero for a number)
00:0000951C 4CD702A2        	   260: 	movem.l (sp),d1/d5/d7/a1
00:00009520 F22F49000010    	   261: 	fmove.x 16(sp),fp2
00:00009526 A2AF0003001C    	   262: 	cchk 28(sp)
00:0000952C 4E5A            	   263: 	unlk a2
00:0000952E 4E75            	   264: 	rts	
                            	   265: 
                            	   266: 		

Source: "boot.x68"
                            	  3223: 
                            	  3224: ;------------------------------------------------------------------------------
                            	  3225: ; Convert ASCII character in the range '0' to '9', 'a' tr 'f' or 'A' to 'F'
                            	  3226: ; to a hex nybble.
                            	  3227: ;------------------------------------------------------------------------------
                            	  3228: 
                            	  3229: AsciiToHexNybble:
00:00009530 0C010030        	  3230: 	cmpi.b	#'0',d1
00:00009534 6530            	  3231: 	blo.s		gthx3
00:00009536 0C010039        	  3232: 	cmpi.b	#'9',d1
00:0000953A 6206            	  3233: 	bhi.s		gthx5
00:0000953C 04010030        	  3234: 	subi.b	#'0',d1
00:00009540 4E75            	  3235: 	rts
                            	  3236: gthx5:
00:00009542 0C010041        	  3237: 	cmpi.b	#'A',d1
00:00009546 651E            	  3238: 	blo.s		gthx3
00:00009548 0C010046        	  3239: 	cmpi.b	#'F',d1
00:0000954C 6206            	  3240: 	bhi.s		gthx6
00:0000954E 060100C9        	  3241: 	addi.b	#10-'A',d1
00:00009552 4E75            	  3242: 	rts
                            	  3243: gthx6:
00:00009554 0C010061        	  3244: 	cmpi.b	#'a',d1
00:00009558 650C            	  3245: 	blo.s		gthx3
00:0000955A 0C010066        	  3246: 	cmpi.b	#'f',d1
00:0000955E 6206            	  3247: 	bhi.s		gthx3
00:00009560 060100A9        	  3248: 	addi.b	#10-'a',d1
00:00009564 4E75            	  3249: 	rts
                            	  3250: gthx3:
00:00009566 72FF            	  3251: 	moveq	#-1,d1		; not a hex number
00:00009568 4E75            	  3252: 	rts
                            	  3253: 
                            	  3254: ;------------------------------------------------------------------------------
                            	  3255: ;------------------------------------------------------------------------------
                            	  3256: 
                            	  3257: DisplayTwoSpaces:
00:0000956A 2F01            	  3258: 	move.l	d1,-(a7)
00:0000956C 123C0020        	  3259: 	move.b	#' ',d1
00:00009570 610009B8        	  3260: 	bsr			OutputChar
                            	  3261: dspspc1:
00:00009574 610009B4        	  3262: 	bsr			OutputChar
00:00009578 221F            	  3263: 	move.l	(a7)+,d1
00:0000957A 4E75            	  3264: 	rts
                            	  3265: 
                            	  3266: DisplaySpace:
00:0000957C 2F01            	  3267: 	move.l	d1,-(a7)
00:0000957E 123C0020        	  3268: 	move.b	#' ',d1
00:00009582 60F0            	  3269: 	bra			dspspc1
                            	  3270: 
                            	  3271: ;------------------------------------------------------------------------------
                            	  3272: ; Display the 32 bit word in D1.L
                            	  3273: ;------------------------------------------------------------------------------
                            	  3274: 
                            	  3275: DisplayTetra:
00:00009584 4841            	  3276: 	swap	d1
00:00009586 6102            	  3277: 	bsr		DisplayWyde
00:00009588 4841            	  3278: 	swap	d1
                            	  3279: 
                            	  3280: ;------------------------------------------------------------------------------
                            	  3281: ; Display the byte in D1.W
                            	  3282: ;------------------------------------------------------------------------------
                            	  3283: 
                            	  3284: DisplayWyde:
00:0000958A E059            	  3285: 	ror.w		#8,d1
00:0000958C 6102            	  3286: 	bsr			DisplayByte
00:0000958E E159            	  3287: 	rol.w		#8,d1
                            	  3288: 
                            	  3289: ;------------------------------------------------------------------------------
                            	  3290: ; Display the byte in D1.B
                            	  3291: ;------------------------------------------------------------------------------
                            	  3292: 
                            	  3293: DisplayByte:
00:00009590 E819            	  3294: 	ror.b		#4,d1
00:00009592 6102            	  3295: 	bsr			DisplayNybble
00:00009594 E919            	  3296: 	rol.b		#4,d1
                            	  3297: 
                            	  3298: ;------------------------------------------------------------------------------
                            	  3299: ; Display nybble in D1.B
                            	  3300: ;------------------------------------------------------------------------------
                            	  3301: 
                            	  3302: DisplayNybble:
00:00009596 2F01            	  3303: 	move.l	d1,-(a7)
00:00009598 0201000F        	  3304: 	andi.b	#$F,d1
00:0000959C 06010030        	  3305: 	addi.b	#'0',d1
00:000095A0 0C010039        	  3306: 	cmpi.b	#'9',d1
00:000095A4 6302            	  3307: 	bls.s		.0001
00:000095A6 5E01            	  3308: 	addi.b	#7,d1
                            	  3309: .0001:
00:000095A8 61000980        	  3310: 	bsr			OutputChar
00:000095AC 221F            	  3311: 	move.l	(a7)+,d1
00:000095AE 4E75            	  3312: 	rts
                            	  3313: 
                            	  3314: ;------------------------------------------------------------------------------
                            	  3315: ; Buffer tetra in d0 to buffer pointed to by a6
                            	  3316: ;------------------------------------------------------------------------------
                            	  3317: 
                            	  3318: BufTetra:
00:000095B0 4840            	  3319: 	swap d0
00:000095B2 6102            	  3320: 	bsr BufWyde
00:000095B4 4840            	  3321: 	swap d0
                            	  3322: 
                            	  3323: BufWyde:
00:000095B6 E058            	  3324: 	ror.w #8,d0
00:000095B8 6102            	  3325: 	bsr BufByte
00:000095BA E158            	  3326: 	rol.w #8,d0
                            	  3327: 	
                            	  3328: BufByte:
00:000095BC E818            	  3329: 	ror.b #4,d0
00:000095BE 6102            	  3330: 	bsr BufNybble
00:000095C0 E918            	  3331: 	rol.b #4,d0
                            	  3332: 
                            	  3333: BufNybble:
00:000095C2 2F00            	  3334: 	move.l d0,-(a7)
00:000095C4 0200000F        	  3335: 	andi.b #$F,d0
00:000095C8 06000030        	  3336: 	addi.b #'0',d0
00:000095CC 0C000039        	  3337: 	cmpi.b #'9',d0
00:000095D0 6302            	  3338: 	bls.s .0001
00:000095D2 5E00            	  3339: 	addi.b #7,d0
                            	  3340: .0001:
00:000095D4 1CC0            	  3341: 	move.b d0,(a6)+
00:000095D6 201F            	  3342: 	move.l (a7)+,d0
00:000095D8 4E75            	  3343: 	rts
                            	  3344: 
                            	  3345: ;------------------------------------------------------------------------------
                            	  3346: ;------------------------------------------------------------------------------
                            	  3347: ;
                            	  3348: ;DisplayHexNumber:
                            	  3349: ;	move.w	#$A6A6,leds		; diagnostics
                            	  3350: ;	move.l	#VDGREG,a6
                            	  3351: ;	move.w	#7,d2		; number-1 of digits to display
                            	  3352: ;disphnum1:
                            	  3353: ;	move.b	d1,d0		; get digit into d0.b
                            	  3354: ;	andi.w	#$0f,d0
                            	  3355: ;	cmpi.w	#$09,d0
                            	  3356: ;	bls.s	disphnum2
                            	  3357: ;	addi.w	#7,d0
                            	  3358: ;disphnum2:
                            	  3359: ;	addi.w	#$30,d0	; convert to display char
                            	  3360: ;	move.w	d2,d3		; char count into d3
                            	  3361: ;	asl.w	#3,d3		; scale * 8
                            	  3362: ;disphnum3:
                            	  3363: ;	move.w	$42C(a6),d4			; read character queue index into d4
                            	  3364: ;	cmp.w	#28,d4					; allow up 28 entries to be in progress
                            	  3365: ;	bhs.s	disphnum3				; branch if too many chars queued
                            	  3366: ;	ext.w	d0						; zero out high order bits
                            	  3367: ;	move.w	d0,$420(a6)			; set char code
                            	  3368: ;	move.w	#WHITE,$422(a6)		; set fg color
                            	  3369: ;	move.w	#DARK_BLUE,$424(a6)	; set bk color
                            	  3370: ;	move.w	d3,$426(a6)			; set x pos
                            	  3371: ;	move.w	#8,$428(a6)			; set y pos
                            	  3372: ;	move.w	#$0707,$42A(a6)		; set font x,y extent
                            	  3373: ;	move.w	#0,$42E(a6)			; pulse character queue write signal
                            	  3374: ;	ror.l	#4,d1					; rot to next digit
                            	  3375: ;	dbeq	d2,disphnum1
                            	  3376: ;	jmp		(a5)
                            	  3377: 
                            	  3378: 	include "ramtest.x68"

Source: "ramtest.x68"
                            	     1: ;===============================================================================
                            	     2: ;    Perform ram test. (Uses checkerboard testing).
                            	     3: ; 
                            	     4: ;    Local ram, which does not get tested, is used for the stack.
                            	     5: ;===============================================================================
                            	     6: 	code
                            	     7: 	even
                            	     8: DisplayAddr:
00:000095DA 2208            	     9: 	move.l a0,d1
00:000095DC E089            	    10: 	lsr.l #8,d1
00:000095DE E089            	    11: 	lsr.l #8,d1
00:000095E0 E889            	    12: 	lsr.l #4,d1
00:000095E2 04410400        	    13: 	subi.w #1024,d1
00:000095E6 A2C10000        	    14: 	bin2bcd d1
00:000095EA 619E            	    15: 	bsr	DisplayWyde
00:000095EC 618E            	    16: 	bsr DisplaySpace
00:000095EE 123C000D        	    17: 	move.b #CR,d1
00:000095F2 61000936        	    18: 	bsr OutputChar
00:000095F6 08000083        	    19: 	btst #$83,d0
                            	    20: 	
                            	    21: cmdTestRAM:
                            	    22: ramtest:
00:000095FA 33FCA5A5FDFFC000	    23: 	move.w	#$A5A5,leds		; diagnostics
00:00009602 263CAAAAAAAA    	    24:   move.l #$aaaaaaaa,d3
00:00009608 283C55555555    	    25:   move.l #$55555555,d4
00:0000960E 6134            	    26:   bsr ramtest0
                            	    27:   ; switch checkerboard pattern and repeat test.
00:00009610 C744            	    28:   exg d3,d4
00:00009612 6130            	    29:   bsr ramtest0
                            	    30: 	; Save last ram address in end of memory pointer.
                            	    31: rmtst5:
00:00009614 7025            	    32: 	moveq #37,d0					; lock semaphore
00:00009616 7206            	    33: 	moveq #MEMORY_SEMA,d1
                            	    34: ;	trap #15
00:00009618 207C7FFFFFF8    	    35:   movea.l #$7FFFFFF8,a0
00:0000961E 23C800100004    	    36:   move.l a0,memend
                            	    37: 	; Create very first memory block.
00:00009624 207C3FFFFFF4    	    38:   movea.l #$3FFFFFF4,a0
00:0000962A 23C840000004    	    39:   move.l a0,$40000004		; length of block
00:00009630 23FC465245454000	    40:   move.l #$46524545,$40000000
00:00009638 0000
00:0000963A 7026            	    41: 	moveq #38,d0					; unlock semaphore
00:0000963C 7206            	    42: 	moveq #MEMORY_SEMA,d1
00:0000963E 4E4F            	    43: 	trap #15
00:00009640 6000EB1A        	    44: 	bra Monitor
                            	    45: ;  rts
                            	    46: 
                            	    47: ramtest0:
00:00009644 2003            	    48: 	move.l d3,d0
00:00009646 207C40000000    	    49:   movea.l #$40000000,a0
                            	    50: ;-----------------------------------------------------------
                            	    51: ;   Write checkerboard pattern to ram then read it back to
                            	    52: ; find the highest usable ram address (maybe). This address
                            	    53: ; must be lower than the start of the rom (0xe00000).
                            	    54: ;-----------------------------------------------------------
                            	    55: ramtest1:
00:0000964C 20C3            	    56:   move.l d3,(a0)+
00:0000964E 20C4            	    57:   move.l d4,(a0)+
00:00009650 2208            	    58:   move.l a0,d1
00:00009652 4A41            	    59:   tst.w	d1
00:00009654 6608            	    60:   bne.s rmtst1
00:00009656 6182            	    61:   bsr DisplayAddr
00:00009658 4EB9000008D2    	    62:   bsr CheckForCtrlC
                            	    63: rmtst1:
00:0000965E B1FC7FFFFFF8    	    64:   cmpa.l #$7FFFFFF8,a0
00:00009664 65E6            	    65:   blo.s ramtest1
00:00009666 6100E48A        	    66:   bsr	CRLF
                            	    67: ;------------------------------------------------------
                            	    68: ;   Save maximum useable address for later comparison.
                            	    69: ;------------------------------------------------------
                            	    70: ramtest6:
00:0000966A 33FCA7A7FDFFC000	    71: 	move.w	#$A7A7,leds		; diagnostics
00:00009672 2448            	    72:   movea.l a0,a2
00:00009674 207C40000000    	    73:   movea.l #$40000000,a0
                            	    74: ;--------------------------------------------
                            	    75: ;   Read back checkerboard pattern from ram.
                            	    76: ;--------------------------------------------
                            	    77: ramtest2
00:0000967A 2A18            	    78:   move.l (a0)+,d5
00:0000967C 2C18            	    79:   move.l (a0)+,d6
00:0000967E B1CA            	    80:   cmpa.l a2,a0
00:00009680 643E            	    81:   bhs.s	ramtest3
00:00009682 2208            	    82:   move.l a0,d1
00:00009684 4A41            	    83:   tst.w	d1
00:00009686 660A            	    84:   bne.s	rmtst2
00:00009688 6100FF50        	    85:   bsr	DisplayAddr
00:0000968C 4EB9000008D2    	    86: 	bsr CheckForCtrlC
                            	    87: rmtst2
00:00009692 BA83            	    88:   cmp.l d3,d5
00:00009694 6604            	    89:   bne.s rmtst3
00:00009696 BC84            	    90:   cmp.l d4,d6
00:00009698 67E0            	    91:   beq.s ramtest2
                            	    92: ;----------------------------------
                            	    93: ; Report error in ram.
                            	    94: ;----------------------------------
                            	    95: rmtst3
00:0000969A 6100E456        	    96: 	bsr CRLF
00:0000969E 7245            	    97: 	moveq	#'E',d1
00:000096A0 61000888        	    98: 	bsr OutputChar
00:000096A4 6100FED6        	    99: 	bsr DisplaySpace
00:000096A8 2208            	   100: 	move.l a0,d1
00:000096AA 6100FED8        	   101: 	bsr DisplayTetra
00:000096AE 6100FECC        	   102: 	bsr DisplaySpace
00:000096B2 2205            	   103: 	move.l d5,d1
00:000096B4 6100FECE        	   104: 	bsr DisplayTetra
00:000096B8 4EB9000008D2    	   105: 	bsr CheckForCtrlC
00:000096BE 60BA            	   106: 	bra ramtest2
                            	   107: ramtest3
00:000096C0 4E75            	   108: 	rts
                            	   109: 

Source: "boot.x68"
                            	  3379: 	include "LoadS19.x68"

Source: "LoadS19.x68"
                            	     1: ;==============================================================================
                            	     2: ; Load an S19 format file
                            	     3: ;
                            	     4: ; Register Usage
                            	     5: ;		d1 = temp, character fetched from serial
                            	     6: ;		d3 = byte count for record
                            	     7: ;		d4 = temp, record type
                            	     8: ;		d5 = number of bytes in address
                            	     9: ;		a1 = memory address to update
                            	    10: ;		a2 = dispatch address (Sn routines)
                            	    11: ;		
                            	    12: ;==============================================================================
                            	    13: 
                            	    14: S19TblAddr macro arg1
                            	    15: 	dc.b ((\1-S19ProcTbl)>>2)
                            	    16: endm
                            	    17: 
                            	    18: 	code
                            	    19: 	even
                            	    20: cmdLoadS19:
00:000096C2 6100E42E        	    21: 	bsr CRLF					; move display to next line
00:000096C6 601E            	    22: 	bra	ProcessRec
                            	    23: 
                            	    24: ; The addresses in this table must be within 1kB of the loader
                            	    25: ; The stored displacement is shifted right by two bits.
                            	    26: ; Table must be four bytes aligned.
                            	    27: 	align 2
                            	    28: S19ProcTbl:
                            	    29: 	S19TblAddr NextRec		; manufacturer ID record, ignore
00:000096C8 03              	     1M 	dc.b ((NextRec-S19ProcTbl)>>2)
                            	    30: 	S19TblAddr ProcessS1
00:000096C9 25              	     1M 	dc.b ((ProcessS1-S19ProcTbl)>>2)
                            	    31: 	S19TblAddr ProcessS2
00:000096CA 26              	     1M 	dc.b ((ProcessS2-S19ProcTbl)>>2)
                            	    32: 	S19TblAddr ProcessS3
00:000096CB 27              	     1M 	dc.b ((ProcessS3-S19ProcTbl)>>2)
                            	    33: 	S19TblAddr NextRec
00:000096CC 03              	     1M 	dc.b ((NextRec-S19ProcTbl)>>2)
                            	    34: 	S19TblAddr NextRec		; record count record, ignore
00:000096CD 03              	     1M 	dc.b ((NextRec-S19ProcTbl)>>2)
                            	    35: 	S19TblAddr NextRec
00:000096CE 03              	     1M 	dc.b ((NextRec-S19ProcTbl)>>2)
                            	    36: 	S19TblAddr ProcessS7
00:000096CF 34              	     1M 	dc.b ((ProcessS7-S19ProcTbl)>>2)
                            	    37: 	S19TblAddr ProcessS8
00:000096D0 37              	     1M 	dc.b ((ProcessS8-S19ProcTbl)>>2)
                            	    38: 	S19TblAddr ProcessS9
00:000096D1 3A              	     1M 	dc.b ((ProcessS9-S19ProcTbl)>>2)
                            	    39: 
                            	    40: 	align 2
                            	    41: NextRec:
00:000096D4 6100010C        	    42: 	bsr	sGetChar					; get character from serial port routines
00:000096D8 0C01000A        	    43: 	cmpi.b #LF,d1					; look for a line-feed
00:000096DC 66F6            	    44: 	bne	NextRec
00:000096DE 123C002E        	    45: 	move.b #'.',d1				; progress display
00:000096E2 61000846        	    46: 	bsr	OutputChar
                            	    47: ProcessRec:
00:000096E6 4EB9000008D2    	    48: 	bsr CheckForCtrlC			; check for CTRL-C once per record
00:000096EC 610000F4        	    49: 	bsr	sGetChar
00:000096F0 0C01000D        	    50: 	cmpi.b #CR,d1
00:000096F4 67F0            	    51: 	beq.s	ProcessRec
00:000096F6 1801            	    52: 	move.b d1,d4
00:000096F8 0C04001A        	    53: 	cmpi.b #CTRLZ,d4			; CTRL-Z ?
00:000096FC 6700EA5E        	    54: 	beq	Monitor
00:00009700 0C040053        	    55: 	cmpi.b #'S',d4				; All records must begin with an 'S'
00:00009704 66CE            	    56: 	bne.s	NextRec
00:00009706 610000DA        	    57: 	bsr	sGetChar
00:0000970A 1801            	    58: 	move.b d1,d4
00:0000970C 0C040030        	    59: 	cmpi.b #'0',d4				; Record type must be between '0' and '9'
00:00009710 65C2            	    60: 	blo.s	NextRec
00:00009712 0C040039        	    61: 	cmpi.b #'9',d4				; d4 = record type
00:00009716 62BC            	    62: 	bhi.s	NextRec
00:00009718 423900100150    	    63: 	clr.b S19Checksum
00:0000971E 611E            	    64: 	bsr S19GetByte				; get byte count for record
00:00009720 1601            	    65: 	move.b d1,d3					; d3 = byte count
00:00009722 983C0030        	    66: 	sub.b #'0',d4
00:00009726 4884            	    67: 	ext.w d4
00:00009728 45FAFF9E        	    68: 	lea S19ProcTbl(pc),a2
00:0000972C 18324000        	    69: 	move.b (a2,d4.w),d4
00:00009730 4884            	    70: 	ext.w d4
00:00009732 48C4            	    71: 	ext.l d4
00:00009734 E58C            	    72: 	lsl.l #2,d4
00:00009736 D5C4            	    73: 	add.l d4,a2
00:00009738 7400            	    74: 	clr.l d2							; will hold address
00:0000973A 7A00            	    75: 	clr.l d5							; d5 = number of bytes in address
00:0000973C 4ED2            	    76: 	jmp (a2)
                            	    77: 
                            	    78: 	even
                            	    79: 
                            	    80: ; Get a byte and add to checksum.
                            	    81: ;		
                            	    82: ; Returns:
                            	    83: ;		d1 = byte
                            	    84: 
                            	    85: S19GetByte:
00:0000973E 610000A2        	    86: 	bsr	sGetChar
00:00009742 6100FDEC        	    87: 	bsr	AsciiToHexNybble
00:00009746 1401            	    88: 	move.b d1,d2
00:00009748 61000098        	    89: 	bsr	sGetChar
00:0000974C 6100FDE2        	    90: 	bsr	AsciiToHexNybble
00:00009750 E90A            	    91: 	lsl.b	#4,d2
00:00009752 8202            	    92: 	or.b d2,d1
00:00009754 D33900100150    	    93: 	add.b d1,S19Checksum
00:0000975A 4E75            	    94: 	rts
                            	    95: 
                            	    96: ;------------------------------------------------------------------------------
                            	    97: ; Process S record. Three entry points depending on address size.
                            	    98: ;------------------------------------------------------------------------------
                            	    99: 
                            	   100: 	align 2
                            	   101: ProcessS1:
00:0000975C 6170            	   102: 	bsr	S19Get16BitAddress
00:0000975E 6006            	   103: 	bra	pcssxa
                            	   104: 	align 2
                            	   105: ProcessS2:
00:00009760 6162            	   106: 	bsr	S19Get24BitAddress
00:00009762 6002            	   107: 	bra	pcssxa
                            	   108: 	align 2
                            	   109: ProcessS3:
00:00009764 6156            	   110: 	bsr	S19Get32BitAddress
                            	   111: 	; fall through
                            	   112: 
                            	   113: ;------------------------------------------------------------------------------
                            	   114: ; Parameters:
                            	   115: ; 	a1 = address pointer
                            	   116: ; 	d3 = byte count
                            	   117: ; Modifies:
                            	   118: ;		d1 = temp
                            	   119: ;		d2 = checksum
                            	   120: ;		d3 decremented to -1
                            	   121: ;		a1 incremented by count
                            	   122: ;		S19Checksum variable
                            	   123: ;------------------------------------------------------------------------------
                            	   124: 
                            	   125: pcssxa:
00:00009766 024300FF        	   126: 	andi.w #$ff,d3		
00:0000976A 5543            	   127: 	subi.w #2,d3			; one less for dbra, one less for checksum
00:0000976C 9645            	   128: 	sub.w d5,d3				; subtract out size of address (2 to 4 bytes)
00:0000976E 6B00FF64        	   129: 	bmi NextRec
                            	   130: .0001
00:00009772 61CA            	   131: 	bsr S19GetByte
00:00009774 12C1            	   132: 	move.b d1,(a1)+		; move byte to memory
00:00009776 51CBFFFA        	   133: 	dbf d3,.0001
00:0000977A 61C2            	   134: 	bsr S19GetByte		; Get the checksum byte (does not go to memory)
00:0000977C 0C3900FF00100150	   135: 	cmp.b	#$FF,S19Checksum
00:00009784 6700FF4E        	   136: 	beq	NextRec
00:00009788 6100FE06        	   137: 	bsr DisplayByte
00:0000978C 123C0045        	   138: 	move.b #'E',d1
00:00009790 61000798        	   139: 	bsr	OutputChar
00:00009794 6000FF3E        	   140: 	bra	NextRec
                            	   141: 
                            	   142: 	align 2
                            	   143: ProcessS7:
00:00009798 6122            	   144: 	bsr	S19Get32BitAddress
00:0000979A 23C900040008    	   145: 	move.l a1,S19StartAddress
00:000097A0 6000E9BA        	   146: 	bra	Monitor
                            	   147: 	align 2
                            	   148: ProcessS8:
00:000097A4 611E            	   149: 	bsr	S19Get24BitAddress
00:000097A6 23C900040008    	   150: 	move.l a1,S19StartAddress
00:000097AC 6000E9AE        	   151: 	bra	Monitor
                            	   152: 	align 2
                            	   153: ProcessS9:
00:000097B0 611C            	   154: 	bsr	S19Get16BitAddress
00:000097B2 23C900040008    	   155: 	move.l a1,S19StartAddress
00:000097B8 6000E9A2        	   156: 	bra	Monitor
                            	   157: 
                            	   158: ;------------------------------------------------------------------------------
                            	   159: ; Get an address. Three entry points to get a 32,24, or 16 bit address.
                            	   160: ;
                            	   161: ; Modifies:
                            	   162: ;		d1,d2
                            	   163: ; Returns:
                            	   164: ;		a1 = address
                            	   165: ;		d5 = number of bytes in address
                            	   166: ;------------------------------------------------------------------------------
                            	   167: 
                            	   168: S19Get32BitAddress:
00:000097BC 6180            	   169: 	bsr S19GetByte
00:000097BE 1401            	   170: 	move.b d1,d2
00:000097C0 E18A            	   171: 	lsl.l #8,d2
00:000097C2 5245            	   172: 	add.w #1,d5
                            	   173: 	;fall through
                            	   174: S19Get24BitAddress:
00:000097C4 6100FF78        	   175: 	bsr S19GetByte
00:000097C8 1401            	   176: 	move.b d1,d2
00:000097CA E18A            	   177: 	lsl.l #8,d2
00:000097CC 5245            	   178: 	add.w #1,d5
                            	   179: 	; fall through
                            	   180: S19Get16BitAddress:
00:000097CE 6100FF6E        	   181: 	bsr S19GetByte
00:000097D2 1401            	   182: 	move.b d1,d2
00:000097D4 E18A            	   183: 	lsl.l #8,d2
00:000097D6 6100FF66        	   184: 	bsr S19GetByte
00:000097DA 1401            	   185: 	move.b d1,d2
00:000097DC 2242            	   186: 	move.l d2,a1
00:000097DE 5445            	   187: 	add.w #2,d5
00:000097E0 4E75            	   188: 	rts
                            	   189: 
                            	   190: ;------------------------------------------------------------------------------
                            	   191: ; Get a character from auxillary input. Waiting for a character is limited to
                            	   192: ; 320000 tries. If a character is not available within the limit, then a return
                            	   193: ; to the monitor is done.
                            	   194: ;
                            	   195: ;	Parameters:
                            	   196: ;		none
                            	   197: ; Returns:
                            	   198: ;		d1.w = character from receive buffer or -1 if no char available
                            	   199: ;------------------------------------------------------------------------------
                            	   200: 
                            	   201: sGetChar:
00:000097E2 48E7A000        	   202: 	movem.l	d0/d2,-(a7)
00:000097E6 243C0004E200    	   203: 	move.l	#320000,d2
00:000097EC 6002            	   204: 	bra .0001
                            	   205: .0004
00:000097EE 4842            	   206: 	swap d2
                            	   207: .0001
00:000097F0 7024            	   208: 	moveq	#36,d0				; serial get char from buffer
00:000097F2 4E4F            	   209: 	trap #15
00:000097F4 0C41FFFF        	   210: 	cmpi.w #-1,d1				; was there a char available?
00:000097F8 6618            	   211: 	bne.s	.0002
00:000097FA 51CAFFF4        	   212: 	dbra d2,.0001				; no - try again
00:000097FE 4EB9000008D2    	   213: 	bsr CheckForCtrlC
00:00009804 4842            	   214: 	swap d2
00:00009806 51CAFFE6        	   215: 	dbra d2,.0004
00:0000980A 4CDF0005        	   216: 	movem.l	(a7)+,d0/d2
                            	   217: .0003
                            	   218: ;	bsr			_KeybdInit
00:0000980E 6000E94C        	   219: 	bra	Monitor						; ran out of tries
                            	   220: .0002
00:00009812 4CDF0005        	   221: 	movem.l (a7)+,d0/d2
00:00009816 0C01001A        	   222: 	cmpi.b #CTRLZ,d1			; receive end of file?
00:0000981A 67F2            	   223: 	beq .0003
00:0000981C 4E75            	   224: 	rts
                            	   225: 

Source: "boot.x68"
                            	  3380: 	
                            	  3381: AudioInputTest:
00:0000981E 4E75            	  3382: 	rts
                            	  3383: BouncingBalls:
00:00009820 4E75            	  3384: 	rts
                            	  3385: GraphicsDemo:
00:00009822 4E75            	  3386: 	rts
                            	  3387: ClearScreen:
00:00009824 7E02            	  3388: 	move.l #2,d7
00:00009826 7C0C            	  3389: 	move.l #DEV_CLEAR,d6
00:00009828 4E40            	  3390: 	trap #0
00:0000982A 4E75            	  3391: 	rts
                            	  3392: 
                            	  3393: ;------------------------------------------------------------------------------
                            	  3394: ; Reverse the order of bytes in d1.
                            	  3395: ;------------------------------------------------------------------------------
                            	  3396: 
                            	  3397: rbo:
00:0000982C E159            	  3398: 	rol.w	#8,d1
00:0000982E 4841            	  3399: 	swap d1
00:00009830 E159            	  3400: 	rol.w	#8,d1
00:00009832 4E75            	  3401: 	rts
                            	  3402: 
                            	  3403: ;===============================================================================
                            	  3404: ;===============================================================================
                            	  3405: 
                            	  3406: SPI_MASTER_VERSION_REG equ 0
                            	  3407: SPI_MASTER_CTRL_REG	equ 1
                            	  3408: SPI_TRANS_TYPE_REG equ 2
                            	  3409: SPI_TRANS_CTRL_REG equ 3
                            	  3410: SPI_TRANS_STS_REG equ 4
                            	  3411: SPI_TRANS_ERR_REG equ 5
                            	  3412: SPI_DIRECT_ACCESS_DATA_REG equ 6
                            	  3413: SPI_ADDR_70 equ 7
                            	  3414: SPI_ADDR_158 equ 8
                            	  3415: SPI_ADDR_2316 equ 9
                            	  3416: SPI_ADDR_3124 equ 10
                            	  3417: SPI_CLK_DEL_REG equ 11
                            	  3418: SPI_RX_FIFO_DATA_REG equ 16
                            	  3419: SPI_RX_FIFO_DATA_COUNT_MSB equ 18
                            	  3420: SPI_RX_FIFO_DATA_COUNT_LSB equ 19
                            	  3421: SPI_RX_FIFO_CTRL_REG equ 20
                            	  3422: SPI_TX_FIFO_DATA_REG equ 32
                            	  3423: SPI_TX_FIFO_CTRL_REG equ 36
                            	  3424: 
                            	  3425: SPI_DIRECT_ACCESS equ	0
                            	  3426: SPI_INIT_SD equ 1
                            	  3427: SPI_RW_READ_SD_BLOCK	equ 2
                            	  3428: SPI_RW_WRITE_SD_BLOCK	equ 3
                            	  3429: 
                            	  3430: ; Setup the SPI device.
                            	  3431: ;
                            	  3432: ; Parameters:
                            	  3433: ;		d1 = pointer to SPI master device (handle)
                            	  3434: ; Returns:
                            	  3435: ;		d0 = E_Ok if successful
                            	  3436: ;				 E_NoDev is card not present
                            	  3437: 
                            	  3438: spi_setup:
                            	  3439: spi_init:
                            	  3440: init_spi:
00:00009834 48E74040        	  3441: 	movem.l d1/a1,-(sp)
                            	  3442: 	macUnhmash d1
00:00009838 0A8156791123    	     1M 	eori.l #DEV_HMASH,d1
00:0000983E 4841            	     2M 	swap d1
00:00009840 2241            	  3443: 	move.l d1,a1
                            	  3444: 	; Turn on the power (negate reset) to the card and reset the logic
00:00009842 137C00010001    	  3445: 	move.b #$01,SPI_MASTER_CTRL_REG(a1)
00:00009848 082900020001    	  3446: 	btst #2,SPI_MASTER_CTRL_REG(a1)		; ensure there is a card present
00:0000984E 6740            	  3447: 	beq.s .0005
                            	  3448: 	; reset fifos
00:00009850 137C00010024    	  3449: 	move.b #1,SPI_TX_FIFO_CTRL_REG(a1)
00:00009856 137C00010014    	  3450: 	move.b #1,SPI_RX_FIFO_CTRL_REG(a1)
00:0000985C 137C00010002    	  3451: 	move.b #SPI_INIT_SD,SPI_TRANS_TYPE_REG(a1)
00:00009862 137C00010003    	  3452: 	move.b #1,SPI_TRANS_CTRL_REG(a1)
                            	  3453: .0001
00:00009868 4EB9000008D2    	  3454: 	bsr CheckForCtrlC
00:0000986E 082900000004    	  3455: 	btst #0,SPI_TRANS_STS_REG(a1)	
00:00009874 66F2            	  3456: 	bne.s .0001
                            	  3457: .0004
00:00009876 10290005        	  3458: 	move.b SPI_TRANS_ERR_REG(a1),d0
00:0000987A 02000003        	  3459: 	andi.b #3,d0
00:0000987E 6608            	  3460: 	bne.s .err
00:00009880 4CDF0202        	  3461: 	movem.l (sp)+,d1/a1
00:00009884 7000            	  3462: 	moveq #E_Ok,d0
00:00009886 4E75            	  3463: 	rts
                            	  3464: .err
00:00009888 4CDF0202        	  3465: 	movem.l (sp)+,d1/a1
00:0000988C 7027            	  3466: 	moveq #E_InitErr,d0
00:0000988E 4E75            	  3467: 	rts
                            	  3468: .0005
00:00009890 4CDF0202        	  3469: 	movem.l (sp)+,d1/a1
00:00009894 7021            	  3470: 	moveq #E_NoDev,d0
00:00009896 4E75            	  3471: 	rts
                            	  3472: 
                            	  3473: ;		d1 = pointer to SPI master device (handle)
                            	  3474: ;		d2 = byte to write
                            	  3475: ;
                            	  3476: spi_send_byte:
00:00009898 48E74040        	  3477: 	movem.l d1/a1,-(sp)
00:0000989C 2241            	  3478: 	move.l d1,a1
                            	  3479: 	macUnhmash d1
00:0000989E 0A8156791123    	     1M 	eori.l #DEV_HMASH,d1
00:000098A4 4841            	     2M 	swap d1
                            	  3480: .0001
00:000098A6 4EB9000008D2    	  3481: 	bsr CheckForCtrlC
00:000098AC 083800000004    	  3482: 	btst #0,SPI_TRANS_STS_REG
00:000098B2 66F2            	  3483: 	bne.s .0001
00:000098B4 13420006        	  3484: 	move.b d2,SPI_DIRECT_ACCESS_DATA_REG(a1)
00:000098B8 42290002        	  3485: 	move.b #0,SPI_TRANS_TYPE_REG(a1)
00:000098BC 137C00010003    	  3486: 	move.b #1,SPI_TRANS_CTRL_REG(a1)
00:000098C2 4CDF0202        	  3487: 	movem.l (sp)+,d1/a1
00:000098C6 4E75            	  3488: 	rts
                            	  3489: 
                            	  3490: ; Parameters:
                            	  3491: ;		d1 = pointer to SPI master device (handle)
                            	  3492: ;		d2 = command
                            	  3493: ;		d3 = command arg
                            	  3494: ;		d4 = checksum
                            	  3495: 
                            	  3496: spi_send_cmd:
00:000098C8 48E72840        	  3497: 	movem.l d2/d4/a1,-(sp)
00:000098CC 00020040        	  3498: 	ori.b #$40,d2
00:000098D0 61C6            	  3499: 	bsr spi_send_byte
00:000098D2 2403            	  3500: 	move.l d3,d2
00:000098D4 E19A            	  3501: 	rol.l #8,d2
00:000098D6 61C0            	  3502: 	bsr spi_send_byte
00:000098D8 E19A            	  3503: 	rol.l #8,d2
00:000098DA 61BC            	  3504: 	bsr spi_send_byte
00:000098DC E19A            	  3505: 	rol.l #8,d2
00:000098DE 61B8            	  3506: 	bsr spi_send_byte
00:000098E0 E19A            	  3507: 	rol.l #8,d2
00:000098E2 61B4            	  3508: 	bsr spi_send_byte
00:000098E4 1404            	  3509: 	move.b d4,d2
00:000098E6 61B0            	  3510: 	bsr spi_send_byte
00:000098E8 383C001F        	  3511: 	move.w #31,d4
                            	  3512: .0002
00:000098EC 143C00FF        	  3513: 	move.b #$FF,d2
00:000098F0 61A6            	  3514: 	bsr spi_send_byte
                            	  3515: 	macUnhmash d1
00:000098F2 0A8156791123    	     1M 	eori.l #DEV_HMASH,d1
00:000098F8 4841            	     2M 	swap d1
00:000098FA 2241            	  3516: 	move.l d1,a1
00:000098FC 14290006        	  3517: 	move.b SPI_DIRECT_ACCESS_DATA_REG(a1),d2
                            	  3518: 	macHmash d1
00:00009900 4841            	     1M 	swap d1
00:00009902 0A8156791123    	     2M 	eori.l #DEV_HMASH,d1
00:00009908 08020007        	  3519: 	btst.l #7,d2
00:0000990C 6704            	  3520: 	beq.s .0001
00:0000990E 51CCFFDC        	  3521: 	dbra d4,.0002
                            	  3522: .0001	
00:00009912 1202            	  3523: 	move.b d2,d1
00:00009914 4CDF0214        	  3524: 	movem.l (sp)+,d2/d4/a1
00:00009918 4200            	  3525: 	move.b #E_Ok,d0
00:0000991A 4E75            	  3526: 	rts
                            	  3527: 
                            	  3528: ;
                            	  3529: ;		d1 = pointer to SPI master device (handle)
                            	  3530: ;		d2 = block number to write
                            	  3531: ;
                            	  3532: spi_setpos:
                            	  3533: spi_set_block_address:
00:0000991C 48E74040        	  3534: 	movem.l d1/a1,-(sp)
                            	  3535: 	macUnhmash d1
00:00009920 0A8156791123    	     1M 	eori.l #DEV_HMASH,d1
00:00009926 4841            	     2M 	swap d1
00:00009928 2241            	  3536: 	move.l d1,a1
                            	  3537: 	; set the block read address
00:0000992A 082900010001    	  3538: 	btst #1,SPI_MASTER_CTRL_REG(a1)		; check for high-density card
00:00009930 6604            	  3539: 	bne.s .0001
00:00009932 E18A            	  3540: 	lsl.l #8,d2										; for a low density card the address is 
00:00009934 E38A            	  3541: 	lsl.l #1,d2										; specified directly, is not a block address
                            	  3542: .0001:
00:00009936 13420007        	  3543: 	move.b d2,SPI_ADDR_70(a1)
00:0000993A E09A            	  3544: 	ror.l #8,d2
00:0000993C 13420008        	  3545: 	move.b d2,SPI_ADDR_158(a1)
00:00009940 E09A            	  3546: 	ror.l #8,d2
00:00009942 13420009        	  3547: 	move.b d2,SPI_ADDR_2316(a1)
00:00009946 E09A            	  3548: 	ror.l #8,d2
00:00009948 1342000A        	  3549: 	move.b d2,SPI_ADDR_3124(a1)
00:0000994C E09A            	  3550: 	ror.l #8,d2
00:0000994E 4CDF0202        	  3551: 	movem.l (sp)+,d1/a1
00:00009952 4E75            	  3552: 	rts
                            	  3553: 
                            	  3554: ; Parameters:
                            	  3555: ;		d1 = pointer to SPI master device (handle)
                            	  3556: ;		d2 = block number to read
                            	  3557: ;		d3 = buffer to put read data in
                            	  3558: ;
                            	  3559: ; Returns:
                            	  3560: ;		d0 = E_ReadError if there was a read error
                            	  3561: ;		     E_Ok if successful
                            	  3562: ;
                            	  3563: spi_read_block:
00:00009954 48E740C0        	  3564: 	movem.l d1/a0/a1,-(sp)
                            	  3565: 	macUnhmash d1
00:00009958 0A8156791123    	     1M 	eori.l #DEV_HMASH,d1
00:0000995E 4841            	     2M 	swap d1
00:00009960 2241            	  3566: 	move.l d1,a1
00:00009962 2043            	  3567: 	move.l d3,a0
                            	  3568: 	; set the block read address
00:00009964 61B6            	  3569: 	bsr spi_set_block_address
00:00009966 137C00020002    	  3570: 	move.b #SPI_RW_READ_SD_BLOCK,SPI_TRANS_TYPE_REG(a1)	; set read transaction
00:0000996C 137C00010003    	  3571: 	move.b #1,SPI_TRANS_CTRL_REG(a1)	; start transaction
                            	  3572: .0002
00:00009972 4EB9000008D2    	  3573: 	bsr CheckForCtrlC
00:00009978 082900000004    	  3574: 	btst.b #0,SPI_TRANS_STS_REG(a1)		; wait for transaction not busy
00:0000997E 66F2            	  3575: 	bne.s .0002
00:00009980 10290005        	  3576: 	move.b SPI_TRANS_ERR_REG(a1),d0
00:00009984 0200000C        	  3577: 	andi.b #$0c,d0
00:00009988 6614            	  3578: 	bne.s .readerr
                            	  3579: 	; now read the data from the fifo
00:0000998A 303C0200        	  3580: 	move.w #512,d0	
                            	  3581: .0003
00:0000998E 10E90010        	  3582: 	move.b SPI_RX_FIFO_DATA_REG(a1),(a0)+
00:00009992 51C8FFFA        	  3583: 	dbra d0,.0003
00:00009996 4CDF0302        	  3584: 	movem.l (sp)+,d1/a0/a1
00:0000999A 7000            	  3585: 	moveq #E_Ok,d0
00:0000999C 4E75            	  3586: 	rts
                            	  3587: .readerr:
00:0000999E 4CDF0302        	  3588: 	movem.l (sp)+,d1/a0/a1
00:000099A2 7023            	  3589: 	moveq #E_ReadError,d0
00:000099A4 4E75            	  3590: 	rts
                            	  3591: 
                            	  3592: ; Parameters:
                            	  3593: ;		d1 = pointer to SPI master device (handle)
                            	  3594: ;		d2 = block number to write
                            	  3595: ;		d3 = buffer to output write data from
                            	  3596: ;
                            	  3597: ; Returns:
                            	  3598: ;		d0 = E_WriteError if there was a write error
                            	  3599: ;		     E_Ok if successful
                            	  3600: ;
                            	  3601: spi_write_block:
00:000099A6 48E740C0        	  3602: 	movem.l d1/a0/a1,-(sp)
                            	  3603: 	macUnhmash d1
00:000099AA 0A8156791123    	     1M 	eori.l #DEV_HMASH,d1
00:000099B0 4841            	     2M 	swap d1
00:000099B2 2241            	  3604: 	move.l d1,a1
00:000099B4 2043            	  3605: 	move.l d3,a0
                            	  3606: 	; First load up the write fifo with data
00:000099B6 303C0200        	  3607: 	move.w #512,d0
                            	  3608: .0001
00:000099BA 13580020        	  3609: 	move.b (a0)+,SPI_TX_FIFO_DATA_REG(a1)
00:000099BE 51C8FFFA        	  3610: 	dbra d0,.0001	
00:000099C2 6100FF58        	  3611: 	bsr spi_set_block_address
00:000099C6 137C00030002    	  3612: 	move.b #SPI_RW_WRITE_SD_BLOCK,SPI_TRANS_TYPE_REG(a1)	; set write transaction
00:000099CC 137C00010003    	  3613: 	move.b #1,SPI_TRANS_CTRL_REG(a1)	; start transaction
                            	  3614: .0002
00:000099D2 4EB9000008D2    	  3615: 	bsr CheckForCtrlC
00:000099D8 082900000004    	  3616: 	btst.b #0,SPI_TRANS_STS_REG(a1)		; wait for transaction not busy
00:000099DE 66F2            	  3617: 	bne.s .0002
00:000099E0 10290005        	  3618: 	move.b SPI_TRANS_ERR_REG(a1),d0
00:000099E4 02000030        	  3619: 	andi.b #$30,d0
00:000099E8 6608            	  3620: 	bne.s .writeerr
00:000099EA 4CDF0302        	  3621: 	movem.l (sp)+,d1/a0/a1
00:000099EE 7000            	  3622: 	moveq #E_Ok,d0
00:000099F0 4E75            	  3623: 	rts
                            	  3624: .writeerr
00:000099F2 4CDF0302        	  3625: 	movem.l (sp)+,d1/a0/a1
00:000099F6 7024            	  3626: 	moveq #E_WriteError,d0
00:000099F8 4E75            	  3627: 	rts
                            	  3628: 
                            	  3629: ; Parameters:
                            	  3630: ;		d1 = pointer to SPI master device (handle)
                            	  3631: ;		d2 = first block number to read
                            	  3632: ;		d3 = address of buffer
                            	  3633: ;		d4 = length of buffer
                            	  3634: ;
                            	  3635: ; Returns:
                            	  3636: ;		d0 = E_WriteError if there was a write error
                            	  3637: ;		     E_Ok if successful
                            	  3638: ;
                            	  3639: spi_getbuf:
00:000099FA 48E778C0        	  3640: 	movem.l d1/d2/d3/d4/a0/a1,-(sp)
                            	  3641: 	macUnhmash d1
00:000099FE 0A8156791123    	     1M 	eori.l #DEV_HMASH,d1
00:00009A04 4841            	     2M 	swap d1
00:00009A06 2241            	  3642: 	move.l d1,a1					; a1 = pointer to SPI device
00:00009A08 2043            	  3643: 	move.l d3,a0					; a0 = address of buffer
00:00009A0A 2202            	  3644: 	move.l d2,d1					; d1 = block number to write
00:00009A0C D8BC000001FF    	  3645: 	add.l #511,d4					; round length up to even block number
00:00009A12 0284FFFFFE00    	  3646: 	andi.l #$FFFFFE00,d4
00:00009A18 5384            	  3647: 	subq.l #1,d4					; loop the correct number of times
                            	  3648: .0001
00:00009A1A 6100FF38        	  3649: 	bsr spi_read_block
00:00009A1E 4A00            	  3650: 	tst.b d0
00:00009A20 6612            	  3651: 	bne.s .err
00:00009A22 41E80200        	  3652: 	lea 512(a0),a0				; advance pointer to next block
00:00009A26 5281            	  3653: 	addq.l #1,d1					; advance block number
00:00009A28 51CCFFF0        	  3654: 	dbra d4,.0001
00:00009A2C 4CDF031E        	  3655: 	movem.l (sp)+,d1/d2/d3/d4/a0/a1
00:00009A30 7000            	  3656: 	moveq #E_Ok,d0
00:00009A32 4E75            	  3657: 	rts
                            	  3658: .err
00:00009A34 4CDF031E        	  3659: 	movem.l (sp)+,d1/d2/d3/d4/a0/a1
00:00009A38 4E75            	  3660: 	rts
                            	  3661: 
                            	  3662: ; Parameters:
                            	  3663: ;		d1 = pointer to SPI master device (handle)
                            	  3664: ;		d2 = first block number to write
                            	  3665: ;		d3 = address of buffer
                            	  3666: ;		d4 = length of buffer
                            	  3667: ;
                            	  3668: ; Returns:
                            	  3669: ;		d0 = E_WriteError if there was a write error
                            	  3670: ;		     E_Ok if successful
                            	  3671: ;
                            	  3672: spi_putbuf:
00:00009A3A 48E778C0        	  3673: 	movem.l d1/d2/d3/d4/a0/a1,-(sp)
                            	  3674: 	macUnhmash d1
00:00009A3E 0A8156791123    	     1M 	eori.l #DEV_HMASH,d1
00:00009A44 4841            	     2M 	swap d1
00:00009A46 2241            	  3675: 	move.l d1,a1					; a1 = pointer to SPI device
00:00009A48 2043            	  3676: 	move.l d3,a0					; a0 = address of buffer
00:00009A4A 2202            	  3677: 	move.l d2,d1					; d1 = block number to write
00:00009A4C D8BC000001FF    	  3678: 	add.l #511,d4					; round length up to even block number
00:00009A52 0284FFFFFE00    	  3679: 	andi.l #$FFFFFE00,d4
00:00009A58 5384            	  3680: 	subq.l #1,d4					; loop the correct number of times
                            	  3681: .0001
00:00009A5A 6100FF4A        	  3682: 	bsr spi_write_block
00:00009A5E 4A00            	  3683: 	tst.b d0
00:00009A60 6612            	  3684: 	bne.s .err
00:00009A62 41E80200        	  3685: 	lea 512(a0),a0				; advance pointer to next block
00:00009A66 5281            	  3686: 	addq.l #1,d1					; advance block number
00:00009A68 51CCFFF0        	  3687: 	dbra d4,.0001
00:00009A6C 4CDF031E        	  3688: 	movem.l (sp)+,d1/d2/d3/d4/a0/a1
00:00009A70 7000            	  3689: 	moveq #E_Ok,d0
00:00009A72 4E75            	  3690: 	rts
                            	  3691: .err
00:00009A74 4CDF031E        	  3692: 	movem.l (sp)+,d1/d2/d3/d4/a0/a1
00:00009A78 4E75            	  3693: 	rts
                            	  3694: 
                            	  3695: ;===============================================================================
                            	  3696: ; Generic I2C routines
                            	  3697: ;
                            	  3698: ; a6 points to I2C device
                            	  3699: ;===============================================================================
                            	  3700: 
                            	  3701: 	even
                            	  3702: ; i2c
                            	  3703: i2c_setup:
                            	  3704: ;		lea		I2C,a6				
                            	  3705: ;		move.w	#19,I2C_PREL(a6)	; setup prescale for 400kHz clock
                            	  3706: ;		move.w	#0,I2C_PREH(a6)
                            	  3707: init_i2c:
                            	  3708: ;	lea	I2C2,a6				
00:00009A7A 422E0002        	  3709: 	move.b #0,I2C_CTRL(a6)		; make sure I2C disabled
00:00009A7E 1CBC0031        	  3710: 	move.b #49,I2C_PREL(a6)		; setup prescale for 400kHz clock, 100MHz master
00:00009A82 422E0001        	  3711: 	move.b #0,I2C_PREH(a6)
00:00009A86 4E75            	  3712: 	rts
                            	  3713: 
                            	  3714: i2c_enable:
00:00009A88 1D7C00800002    	  3715: 	move.b #$80,I2C_CTRL(a6)	; enable I2C
00:00009A8E 4E75            	  3716: 	rts
                            	  3717: 
                            	  3718: i2c_disable:
00:00009A90 422E0002        	  3719: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
00:00009A94 4E75            	  3720: 	rts
                            	  3721: 
                            	  3722: ; Wait for I2C transfer to complete
                            	  3723: ;
                            	  3724: ; Parameters
                            	  3725: ; 	a6 - I2C controller base address
                            	  3726: 
                            	  3727: i2c_wait_tip:
                            	  3728: .0001
00:00009A96 4EB9000008D2    	  3729: 	bsr CheckForCtrlC				
00:00009A9C 082E00010004    	  3730: 	btst #1,I2C_STAT(a6)			; wait for tip to clear
00:00009AA2 66F2            	  3731: 	bne.s	.0001
00:00009AA4 4E75            	  3732: 	rts
                            	  3733: 
                            	  3734: ; Reads the i2c then outputs a STOP
                            	  3735: ;
                            	  3736: ; Parameters
                            	  3737: ;		a6	 - I2C controller base address
                            	  3738: ; Returns:
                            	  3739: ;		d0.b - I2C status
                            	  3740: 
                            	  3741: i2c_read_stop:
00:00009AA6 1D7C00680004    	  3742: 	move.b #$68,I2C_CMD(a6)		; rd bit, STO + nack
00:00009AAC 61E8            	  3743: 	bsr	i2c_wait_tip
00:00009AAE 6148            	  3744: 	bsr	i2c_wait_rx_nack
                            	  3745: i2c_get_status:	
00:00009AB0 102E0004        	  3746: 	move.b I2C_STAT(a6),d0
00:00009AB4 4E75            	  3747: 	rts
                            	  3748: 
                            	  3749: i2c_read_ack:
00:00009AB6 1D7C00200004    	  3750: 	move.b #$20,I2C_CMD(a6)		; rd bit+ACK
00:00009ABC 61D8            	  3751: 	bsr	i2c_wait_tip
00:00009ABE 102E0004        	  3752: 	move.b I2C_STAT(a6),d0
00:00009AC2 4E75            	  3753: 	rts
                            	  3754: 
                            	  3755: i2c_read:
00:00009AC4 102E0003        	  3756: 	move.b I2C_RXR(a6),d0
00:00009AC8 4E75            	  3757: 	rts
                            	  3758: 
                            	  3759: ; Parameters
                            	  3760: ;		a6	 - I2C controller base address
                            	  3761: ;		d0.b - data to transmit
                            	  3762: ;		d1.b - command value
                            	  3763: ; Returns:
                            	  3764: ;		d0.b - I2C status
                            	  3765: 
                            	  3766: i2c_wr_cmd:
00:00009ACA 1D400003        	  3767: 	move.b d0,I2C_TXR(a6)
00:00009ACE 1D410004        	  3768: 	move.b d1,I2C_CMD(a6)
00:00009AD2 61C2            	  3769: 	bsr	i2c_wait_tip
00:00009AD4 102E0004        	  3770: 	move.b I2C_STAT(a6),d0
00:00009AD8 4E75            	  3771: 	rts
                            	  3772: 
                            	  3773: i2c_xmit1:
00:00009ADA 2F00            	  3774: 	move.l d0,-(a7)
00:00009ADC 1D7C00010002    	  3775: 	move.b #1,I2C_CTRL(a6)		; enable the core
00:00009AE2 7076            	  3776: 	moveq	#$76,d0				; set slave address = %0111011
00:00009AE4 323C0090        	  3777: 	move.w #$90,d1				; set STA, WR
00:00009AE8 61E0            	  3778: 	bsr i2c_wr_cmd
00:00009AEA 610C            	  3779: 	bsr	i2c_wait_rx_nack
00:00009AEC 201F            	  3780: 	move.l (a7)+,d0
00:00009AEE 323C0050        	  3781: 	move.w #$50,d1				; set STO, WR
00:00009AF2 61D6            	  3782: 	bsr i2c_wr_cmd
00:00009AF4 61000002        	  3783: 	bsr	i2c_wait_rx_nack
                            	  3784: 
                            	  3785: i2c_wait_rx_nack:
                            	  3786: .0001						
00:00009AF8 4EB9000008D2    	  3787: 	bsr CheckForCtrlC
00:00009AFE 082E00070004    	  3788: 	btst #7,I2C_STAT(a6)		; wait for RXack = 0
00:00009B04 66F2            	  3789: 	bne.s	.0001
00:00009B06 4E75            	  3790: 	rts
                            	  3791: 
                            	  3792: ;===============================================================================
                            	  3793: ; Realtime clock routines
                            	  3794: ;===============================================================================
                            	  3795: 
                            	  3796: rtc_read:
00:00009B08 48E77006        	  3797: 	movem.l d1/d2/d3/a5/a6,-(sp)
00:00009B0C 4DF9FDFE4000    	  3798: 	lea	I2C2,a6
00:00009B12 4BF900100200    	  3799: 	lea	RTCBuf,a5
00:00009B18 363C0014        	  3800: 	move.w #20,d3
00:00009B1C 7400            	  3801: 	moveq #0,d2
00:00009B1E 6100FF68        	  3802: 	bsr i2c_enable
                            	  3803: .0002	
00:00009B22 103C00DE        	  3804: 	move.b #$DE,d0				; read address, write op
00:00009B26 123C0090        	  3805: 	move.b #$90,d1				; STA + wr bit
00:00009B2A 619E            	  3806: 	bsr	i2c_wr_cmd
00:00009B2C 4A00            	  3807: 	tst.b	d0							; look for ACK(bit7=0)
00:00009B2E 5ACBFFF2        	  3808: 	dbpl d3,.0002
00:00009B32 6B54            	  3809: 	bmi	.rxerr
00:00009B34 1002            	  3810: 	move.b d2,d0					; d0=address
00:00009B36 123C0050        	  3811: 	move.b #$50,d1				; wr bit + STO
00:00009B3A 618E            	  3812: 	bsr	i2c_wr_cmd
00:00009B3C 4A00            	  3813: 	tst.b	d0
00:00009B3E 5ACBFFE2        	  3814: 	dbpl d3,.0002
00:00009B42 6B44            	  3815: 	bmi	.rxerr
00:00009B44 363C0014        	  3816: 	move.w #20,d3
                            	  3817: .0001
00:00009B48 103C00DF        	  3818: 	move.b #$DF,d0				; read address, read op
00:00009B4C 123C0090        	  3819: 	move.b #$90,d1				; STA + wr bit
00:00009B50 6100FF78        	  3820: 	bsr	i2c_wr_cmd
00:00009B54 4A00            	  3821: 	tst.b	d0							; look for ACK(bit7=0)
00:00009B56 5ACBFFF0        	  3822: 	dbpl d3,.0001
00:00009B5A 6B2C            	  3823: 	bmi	.rxerr
                            	  3824: .0003
00:00009B5C 6100FF58        	  3825: 	bsr i2c_read_ack
00:00009B60 6100FF62        	  3826: 	bsr i2c_read
00:00009B64 1B802000        	  3827: 	move.b d0,(a5,d2.w)
00:00009B68 5242            	  3828: 	addi.w #1,d2
00:00009B6A 0C42005F        	  3829: 	cmpi.w #$5f,d2
00:00009B6E 66EC            	  3830: 	bne	.0003
00:00009B70 6100FF34        	  3831: 	bsr i2c_read_stop
00:00009B74 6100FF4E        	  3832: 	bsr i2c_read
00:00009B78 1B802000        	  3833: 	move.b d0,(a5,d2.w)
00:00009B7C 6100FF12        	  3834: 	bsr i2c_disable
00:00009B80 4CDF600E        	  3835: 	movem.l (sp)+,d1/d2/d3/a5/a6
00:00009B84 7000            	  3836: 	moveq	#0,d0
00:00009B86 4E75            	  3837: 	rts
                            	  3838: .rxerr
00:00009B88 6100FF06        	  3839: 	bsr i2c_disable
00:00009B8C 4CDF600E        	  3840: 	movem.l (sp)+,d1/d2/d3/a5/a6
00:00009B90 4E75            	  3841: 	rts
                            	  3842: 
                            	  3843: rtc_write:
00:00009B92 48E77006        	  3844: 	movem.l d1/d2/d3/a5/a6,-(sp)
00:00009B96 2C7CFDFE4000    	  3845: 	movea.l	#I2C2,a6
00:00009B9C 4BF900100200    	  3846: 	lea	RTCBuf,a5
00:00009BA2 6100FEE4        	  3847: 	bsr i2c_enable
00:00009BA6 4242            	  3848: 	move.w #$00,d2
00:00009BA8 363C0014        	  3849: 	move.w #20,d3
                            	  3850: .0002
00:00009BAC 103C00DE        	  3851: 	move.b #$DE,d0				; read address, write op
00:00009BB0 123C0090        	  3852: 	move.b #$90,d1				; STA + wr bit
00:00009BB4 6100FF14        	  3853: 	bsr	i2c_wr_cmd
00:00009BB8 4A00            	  3854: 	tst.b	d0
00:00009BBA 5ACBFFF0        	  3855: 	dbpl d3,.0002
00:00009BBE 6B56            	  3856: 	bmi .rxerr
00:00009BC0 1002            	  3857: 	move.b d2,d0					; address zero
00:00009BC2 123C0010        	  3858: 	move.b #$10,d1				; wr bit
00:00009BC6 6100FF02        	  3859: 	bsr	i2c_wr_cmd
00:00009BCA 4A00            	  3860: 	tst.b	d0
00:00009BCC 5ACBFFDE        	  3861: 	dbpl d3,.0002						; received a NACK, try again
00:00009BD0 6B44            	  3862: 	bmi.s .rxerr
                            	  3863: .0004
00:00009BD2 363C0014        	  3864: 	move.w #20,d3
                            	  3865: .0001
00:00009BD6 10352000        	  3866: 	move.b (a5,d2.w),d0
00:00009BDA 123C0010        	  3867: 	move.b #$10,d1				; wr bit
00:00009BDE 6100FEEA        	  3868: 	bsr	i2c_wr_cmd
00:00009BE2 4A00            	  3869: 	tst.b d0
00:00009BE4 5ACBFFF0        	  3870: 	dbpl d3,.0001
00:00009BE8 6B2C            	  3871: 	bmi.s .rxerr
00:00009BEA 5242            	  3872: 	addi.w #1,d2
00:00009BEC 0C42005F        	  3873: 	cmpi.w #$5f,d2
00:00009BF0 66E0            	  3874: 	bne.s	.0004
00:00009BF2 363C0014        	  3875: 	move.w #20,d3
                            	  3876: .0003
00:00009BF6 10352000        	  3877: 	move.b (a5,d2.w),d0
00:00009BFA 123C0050        	  3878: 	move.b #$50,d1				; wr bit + STO
00:00009BFE 6100FECA        	  3879: 	bsr	i2c_wr_cmd
00:00009C02 4A00            	  3880: 	tst.b d0
00:00009C04 5ACBFFF0        	  3881: 	dbpl d3,.0003
00:00009C08 6B0C            	  3882: 	bmi.s .rxerr
00:00009C0A 6100FE84        	  3883: 	bsr i2c_disable
00:00009C0E 4CDF600E        	  3884: 	movem.l (sp)+,d1/d2/d3/a5/a6
00:00009C12 7000            	  3885: 	moveq	#0,d0
00:00009C14 4E75            	  3886: 	rts
                            	  3887: .rxerr:
00:00009C16 6100FE78        	  3888: 	bsr i2c_disable
00:00009C1A 4CDF600E        	  3889: 	movem.l (sp)+,d1/d2/d3/a5/a6
00:00009C1E 4E75            	  3890: 	rts
                            	  3891: 
                            	  3892: msgRtcReadFail:
00:00009C20 5254432072656164	  3893: 	dc.b	"RTC read/write failed.",$0A,$0D,$00
00:00009C28 2F77726974652066
00:00009C30 61696C65642E
00:00009C36 0A
00:00009C37 0D
00:00009C38 00
                            	  3894: 
                            	  3895: msgBusErr:
00:00009C39 0A              	  3896: 	dc.b	$0A,$0D,"Bus error at: ",$00
00:00009C3A 0D
00:00009C3B 427573206572726F
00:00009C43 722061743A20
00:00009C49 00
                            	  3897: 	even
                            	  3898: 
                            	  3899: ;------------------------------------------------------------------------------
                            	  3900: ;------------------------------------------------------------------------------
                            	  3901: 	even
                            	  3902: 
                            	  3903: bus_err:
00:00009C4A 4E71            	  3904: 	nop
00:00009C4C 43FAFFEB        	  3905: 	lea.l msgBusErr,a1
00:00009C50 6100DEBA        	  3906: 	bsr DisplayString
00:00009C54 222F0002        	  3907: 	move.l 2(a7),d1
00:00009C58 6100F92A        	  3908: 	bsr DisplayTetra
00:00009C5C 6100DE94        	  3909: 	bsr CRLF
00:00009C60 6000E4FA        	  3910: 	bra	Monitor
                            	  3911: 
                            	  3912: trap3:
                            	  3913: 	; First save all registers
00:00009C64 48F9FFFF00040100	  3914: 	movem.l		d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
00:00009C6C 33DF00040140    	  3915: 	move.w		(a7)+,Regsave+$40
00:00009C72 23DF00040144    	  3916: 	move.l		(a7)+,Regsave+$44
00:00009C78 2E7C00040FFC    	  3917: 	move.l		#$40FFC,a7			; reset stack pointer
00:00009C7E 46FC2500        	  3918: 	move.w		#$2500,sr				; enable interrupts
00:00009C82 303900040202    	  3919: 	move.w		NumSetBreakpoints,d0
00:00009C88 5340            	  3920: 	subi.w		#1,d0
00:00009C8A 41F900040220    	  3921: 	lea				Breakpoints,a0
00:00009C90 223900040144    	  3922: 	move.l		Regsave+$44,d1
                            	  3923: .0001:
00:00009C96 B298            	  3924: 	cmp.l			(a0)+,d1
00:00009C98 6708            	  3925: 	beq.s			ProcessBreakpoint
00:00009C9A 51C8FFFA        	  3926: 	dbra			d0,.0001
00:00009C9E 6000E4BC        	  3927: 	bra				Monitor					; not a breakpoint
                            	  3928: ProcessBreakpoint:
00:00009CA2 6104            	  3929: 	bsr				DisarmAllBreakpoints
00:00009CA4 6000F22A        	  3930: 	bra				cmdDumpRegs
                            	  3931: 
                            	  3932: ;------------------------------------------------------------------------------
                            	  3933: ; DisarmAllBreakpoints, used when entering the monitor.
                            	  3934: ;------------------------------------------------------------------------------
                            	  3935: 
                            	  3936: DisarmAllBreakpoints:
00:00009CA8 48E780E0        	  3937: 	movem.l	d0/a0/a1/a2,-(a7)			; stack some regs
00:00009CAC 303900040202    	  3938: 	move.w	NumSetBreakpoints,d0	; d0 = number of breakpoints that are set
00:00009CB2 0C400008        	  3939: 	cmpi.w	#numBreakpoints,d0		; check for valid number
00:00009CB6 641A            	  3940: 	bhs.s		.0001
00:00009CB8 45F900040220    	  3941: 	lea			Breakpoints,a2				; a2 = pointer to breakpoint address table
00:00009CBE 41F900040280    	  3942: 	lea			BreakpointWords,a0		; a0 = pointer to breakpoint instruction word table
00:00009CC4 6004            	  3943: 	bra.s		.0003									; enter loop at bottom
                            	  3944: .0002:
00:00009CC6 225A            	  3945: 	move.l	(a2)+,a1							; a1 = address of breakpoint
00:00009CC8 3298            	  3946: 	move.w	(a0)+,(a1)						; copy instruction word back to code
                            	  3947: .0003:
00:00009CCA 51C8FFFA        	  3948: 	dbra		d0,.0002
00:00009CCE 4CDF0701        	  3949: 	movem.l	(a7)+,d0/a0/a1/a2			; restore regs
                            	  3950: .0001:
00:00009CD2 4E75            	  3951: 	rts	
                            	  3952: 
                            	  3953: ;------------------------------------------------------------------------------
                            	  3954: ; ArmAllBreakpoints, used when entering the monitor.
                            	  3955: ;------------------------------------------------------------------------------
                            	  3956: 
                            	  3957: ArmAllBreakpoints:
00:00009CD4 48E780E0        	  3958: 	movem.l		d0/a0/a1/a2,-(a7)			; stack some regs
00:00009CD8 303900040202    	  3959: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:00009CDE 0C400008        	  3960: 	cmpi.w		#numBreakpoints,d0		; is the number valid?
00:00009CE2 641E            	  3961: 	bhs.s			.0001
00:00009CE4 45F900040220    	  3962: 	lea				Breakpoints,a2				; a2 = pointer to breakpoint address table
00:00009CEA 41F900040280    	  3963: 	lea				BreakpointWords,a0		; a0 = pointer to instruction word table
00:00009CF0 6008            	  3964: 	bra.s			.0003									; enter loop at bottom
                            	  3965: .0002:
00:00009CF2 225A            	  3966: 	move.l		(a2)+,a1							; a1 = address of breakpoint
00:00009CF4 3091            	  3967: 	move.w		(a1),(a0)							; copy instruction word to table
00:00009CF6 30FC4E43        	  3968: 	move.w		#$4E43,(a0)+					; set instruction = TRAP3
                            	  3969: .0003:
00:00009CFA 51C8FFF6        	  3970: 	dbra			d0,.0002
00:00009CFE 4CDF0701        	  3971: 	movem.l		(a7)+,d0/a0/a1/a2			; restore regs
                            	  3972: .0001:
00:00009D02 4E75            	  3973: 	rts	
                            	  3974: 
                            	  3975: ;------------------------------------------------------------------------------
                            	  3976: ;------------------------------------------------------------------------------
                            	  3977: 
                            	  3978: ArmBreakpoint:
00:00009D04 48E7E0E0        	  3979: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
00:00009D08 303900040202    	  3980: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:00009D0E 0C400008        	  3981: 	cmpi.w		#numBreakpoints,d0		; check if too many
00:00009D12 645A            	  3982: 	bhs.s			.0001
00:00009D14 527900040202    	  3983: 	addi.w		#1,NumSetBreakpoints	; increment number of breakpoints
00:00009D1A 2400            	  3984: 	move.l		d0,d2
00:00009D1C 6100EBF2        	  3985: 	bsr				ignBlanks
00:00009D20 6100F27C        	  3986: 	bsr				GetHexNumber
00:00009D24 6748            	  3987: 	beq.s			.0001									; was there an address?
00:00009D26 08010000        	  3988: 	btst			#0,d1									; address value must be even
00:00009D2A 6642            	  3989: 	bne.s			.0001
                            	  3990: 	; See if the breakpoint is in the table already
00:00009D2C 43F900040220    	  3991: 	lea				Breakpoints,a1				; a1 points to breakpoint table
00:00009D32 343C0007        	  3992: 	move.w		#numBreakpoints-1,d2
                            	  3993: .0002:
00:00009D36 B299            	  3994: 	cmp.l			(a1)+,d1
00:00009D38 673A            	  3995: 	beq.s			.0003									; breakpoint is in table already
00:00009D3A 51CAFFFA        	  3996: 	dbra			d2,.0002
                            	  3997: 	; Add breakpoint to table
                            	  3998: 	; Search for empty entry
00:00009D3E 43F900040220    	  3999: 	lea				Breakpoints,a1				; a1 = pointer to breakpoint address table
00:00009D44 4242            	  4000: 	clr.w			d2										; d2 = count
                            	  4001: .0006:
00:00009D46 4A91            	  4002: 	tst.l			(a1)									; is the entry empty?
00:00009D48 670C            	  4003: 	beq.s			.0005									; branch if found empty entry
00:00009D4A 5889            	  4004: 	lea				4(a1),a1							; point to next entry
00:00009D4C 5242            	  4005: 	addi.w		#1,d2									; increment count
00:00009D4E 0C420008        	  4006: 	cmpi.w		#numBreakpoints,d2		; safety: check against max number
00:00009D52 65F2            	  4007: 	blo.s			.0006
00:00009D54 6018            	  4008: 	bra.s			.0001									; what? no empty entries found, table corrupt?
                            	  4009: .0005:
00:00009D56 E542            	  4010: 	asl.w			#2,d2									; d2 = long word index
00:00009D58 23812000        	  4011: 	move.l		d1,(a1,d2.w)					; move breakpoint address to table
00:00009D5C 2441            	  4012: 	move.l		d1,a2
00:00009D5E E24A            	  4013: 	lsr.w			#1,d2									; d2 = word index
                            	  4014: .0004:
00:00009D60 43F900040280    	  4015: 	lea				BreakpointWords,a1
00:00009D66 33922000        	  4016: 	move.w		(a2),(a1,d2.w)				; copy instruction word to table
00:00009D6A 34BC4E43        	  4017: 	move.w		#$4E43,(a2)						; replace word with TRAP3
                            	  4018: .0001:
00:00009D6E 4CDF0707        	  4019: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
00:00009D72 4E75            	  4020: 	rts
                            	  4021: .0003:
00:00009D74 2469FFFC        	  4022: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
00:00009D78 0C524E43        	  4023: 	cmpi.w		#$4E43,(a2)						; see if breakpoint already armed
00:00009D7C 67F0            	  4024: 	beq.s			.0001
00:00009D7E D482            	  4025: 	asl.l			#1,d2									; d2 = word index
00:00009D80 60DE            	  4026: 	bra.s			.0004
                            	  4027: 
                            	  4028: 
                            	  4029: ;------------------------------------------------------------------------------
                            	  4030: ;------------------------------------------------------------------------------
                            	  4031: 
                            	  4032: DisarmBreakpoint:
00:00009D82 48E7E0E0        	  4033: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
00:00009D86 303900040202    	  4034: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:00009D8C 0C400008        	  4035: 	cmpi.w		#numBreakpoints,d0		; check if too many
00:00009D90 623E            	  4036: 	bhi.s			.0001
00:00009D92 2400            	  4037: 	move.l		d0,d2
00:00009D94 6100EB7A        	  4038: 	bsr				ignBlanks
00:00009D98 6100F204        	  4039: 	bsr				GetHexNumber
00:00009D9C 6732            	  4040: 	beq.s			.0001									; was there an address?
00:00009D9E 08010000        	  4041: 	btst			#0,d1									; address value must be even
00:00009DA2 662C            	  4042: 	bne.s			.0001
                            	  4043: 	; See if the breakpoint is in the table already
00:00009DA4 43F900040220    	  4044: 	lea				Breakpoints,a1				; a1 points to breakpoint table
00:00009DAA 5342            	  4045: 	subi.w		#1,d2
                            	  4046: .0002:
00:00009DAC B299            	  4047: 	cmp.l			(a1)+,d1
00:00009DAE 6706            	  4048: 	beq.s			.0003									; breakpoint is in table already
00:00009DB0 51CAFFFA        	  4049: 	dbra			d2,.0002
00:00009DB4 601A            	  4050: 	bra				.0001									; breakpoint was not in table
                            	  4051: .0003:
                            	  4052: 	; Remove breakpoint from table
00:00009DB6 537900040202    	  4053: 	subi.w		#1,NumSetBreakpoints	; decrement number of breakpoints
00:00009DBC 2469FFFC        	  4054: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
00:00009DC0 42A9FFFC        	  4055: 	clr.l			-4(a1)								; empty out breakpoint
00:00009DC4 43F900040280    	  4056: 	lea				BreakpointWords,a1
00:00009DCA D482            	  4057: 	asl.l			#1,d2									; d2 = word index
00:00009DCC 34B12000        	  4058: 	move.w		(a1,d2.w),(a2)				; copy instruction from table back to code
                            	  4059: .0001:
00:00009DD0 4CDF0707        	  4060: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
00:00009DD4 4E75            	  4061: 	rts
                            	  4062: 
                            	  4063: ;------------------------------------------------------------------------------
                            	  4064: ;------------------------------------------------------------------------------
                            	  4065: 
                            	  4066: ListBreakpoints:
00:00009DD6 6100DD1A        	  4067: 	bsr			CRLF
00:00009DDA 343C0008        	  4068: 	move.w	#numBreakpoints,d2
00:00009DDE 43F900040220    	  4069: 	lea			Breakpoints,a1
                            	  4070: .0001:
00:00009DE4 2219            	  4071: 	move.l	(a1)+,d1
00:00009DE6 6100F79C        	  4072: 	bsr			DisplayTetra
00:00009DEA 6100DD06        	  4073: 	bsr			CRLF
00:00009DEE 51CAFFF4        	  4074: 	dbra		d2,.0001
00:00009DF2 6000E368        	  4075: 	bra			Monitor
                            	  4076: 
                            	  4077: ;------------------------------------------------------------------------------
                            	  4078: ;------------------------------------------------------------------------------
                            	  4079: 
                            	  4080: ClearBreakpointList:
00:00009DF6 343C0008        	  4081: 	move.w	#numBreakpoints,d2
00:00009DFA 43F900040220    	  4082: 	lea			Breakpoints,a1
                            	  4083: .0001:
00:00009E00 4299            	  4084: 	clr.l		(a1)+
00:00009E02 51CAFFFC        	  4085: 	dbra		d2,.0001
00:00009E06 4E75            	  4086: 	rts
                            	  4087: 
                            	  4088: ;------------------------------------------------------------------------------
                            	  4089: ; SendMsg
                            	  4090: ; 00100xy0
                            	  4091: ;
                            	  4092: ; Parameters:
                            	  4093: ;		d1 = target core number
                            	  4094: ;		d2 = argument 1
                            	  4095: ;		d3 = argument 2
                            	  4096: ;		d4 = argument 3
                            	  4097: ;
                            	  4098: ;------------------------------------------------------------------------------
                            	  4099: 
                            	  4100: SendMsg:
00:00009E08 48E70440        	  4101: 	movem.l	d5/a1,-(a7)
00:00009E0C E149            	  4102: 	lsl.w		#8,d1
00:00009E0E 4E7A5FE0        	  4103: 	movec		coreno,d5
00:00009E12 E94D            	  4104: 	lsl.w		#4,d5
00:00009E14 8245            	  4105: 	or.w		d5,d1
00:00009E16 43F900100000    	  4106: 	lea			$00100000,a1
00:00009E1C 4AB11000        	  4107: 	tst.l		0(a1,d1.w)
00:00009E20 661C            	  4108: 	bne			.msgFull
00:00009E22 4E7A5FE0        	  4109: 	movec		coreno,d5
00:00009E26 23851000        	  4110: 	move.l	d5,0(a1,d1.w)
00:00009E2A 23821004        	  4111: 	move.l	d2,4(a1,d1.w)
00:00009E2E 23831008        	  4112: 	move.l	d3,8(a1,d1.w)
00:00009E32 2384100C        	  4113: 	move.l	d4,12(a1,d1.w)
00:00009E36 4CDF0220        	  4114: 	movem.l	(a7)+,d5/a1
00:00009E3A 7200            	  4115: 	moveq		#0,d1
00:00009E3C 4E75            	  4116: 	rts
                            	  4117: .msgFull:
00:00009E3E 4CDF0220        	  4118: 	movem.l	(a7)+,d5/a1
00:00009E42 72FF            	  4119: 	moveq		#-1,d1
00:00009E44 4E75            	  4120: 	rts
                            	  4121: 
                            	  4122: ;------------------------------------------------------------------------------
                            	  4123: ; ReceiveMsg
                            	  4124: ;		Scan the message table for messages and dispatch them.
                            	  4125: ; 00100xy0
                            	  4126: ;
                            	  4127: ; Parameters:
                            	  4128: ;------------------------------------------------------------------------------
                            	  4129: 
                            	  4130: ReceiveMsg:
00:00009E46 48E77F40        	  4131: 	movem.l		d1/d2/d3/d4/d5/d6/d7/a1,-(a7)
00:00009E4A 43F900100000    	  4132: 	lea				$00100000,a1
00:00009E50 4E7A5FE0        	  4133: 	movec			coreno,d5
00:00009E54 E14D            	  4134: 	lsl.w			#8,d5
00:00009E56 7C02            	  4135: 	moveq			#2,d6
                            	  4136: .nextCore:
00:00009E58 3E06            	  4137: 	move.w		d6,d7
00:00009E5A E94F            	  4138: 	lsl.w			#4,d7
00:00009E5C DE45            	  4139: 	add.w			d5,d7
00:00009E5E 4AB17000        	  4140: 	tst.l			0(a1,d7.w)			; Is there a message from core d6?
00:00009E62 6716            	  4141: 	beq.s			.noMsg
00:00009E64 22317000        	  4142: 	move.l		0(a1,d7.w),d1
00:00009E68 24317004        	  4143: 	move.l		4(a1,d7.w),d2
00:00009E6C 26317008        	  4144: 	move.l		8(a1,d7.w),d3
00:00009E70 2831700C        	  4145: 	move.l		12(a1,d7.w),d4
00:00009E74 42B17000        	  4146: 	clr.l			0(a1,d7.w)			; indicate message was received
00:00009E78 610E            	  4147: 	bsr				DispatchMsg
                            	  4148: .noMsg:
00:00009E7A 5246            	  4149: 	addq			#1,d6
00:00009E7C BC7C0009        	  4150: 	cmp.w			#9,d6
00:00009E80 63D6            	  4151: 	bls				.nextCore
00:00009E82 4CDF02FE        	  4152: 	movem.l		(a7)+,d1/d2/d3/d4/d5/d6/d7/a1
00:00009E86 4E75            	  4153: 	rts
                            	  4154: 
                            	  4155: ;------------------------------------------------------------------------------
                            	  4156: ;------------------------------------------------------------------------------
                            	  4157: 
                            	  4158: DispatchMsg:
00:00009E88 4E75            	  4159: 	rts
                            	  4160: 
                            	  4161: ;------------------------------------------------------------------------------
                            	  4162: ; Trap #15, function 39 - convert floating-point to string and display
                            	  4163: ;
                            	  4164: ; Parameters
                            	  4165: ;		a1 = pointer to buffer
                            	  4166: ;		fp0 = number to print
                            	  4167: ;		d1 = width of print field
                            	  4168: ;		d2 = precision
                            	  4169: ;		d3 = 'E' or 'e'
                            	  4170: ;------------------------------------------------------------------------------
                            	  4171: 
                            	  4172: prtflt:
00:00009E8A 4E52FFD0        	  4173: 	link a2,#-48
00:00009E8E 2F7900040098002C	  4174: 	move.l _canary,44(sp)
00:00009E96 48D7074F        	  4175: 	movem.l d0/d1/d2/d3/d6/a0/a1/a2,(sp)
00:00009E9A F22F68000020    	  4176: 	fmove.x fp0,32(sp)
00:00009EA0 2049            	  4177: 	move.l a1,a0						; a0 = pointer to buffer to use
00:00009EA2 13C100040508    	  4178: 	move.b d1,_width
00:00009EA8 23C200040514    	  4179: 	move.l d2,_precision
00:00009EAE 13C30004050C    	  4180: 	move.b d3,_E
00:00009EB4 6100F44A        	  4181: 	bsr _FloatToString
00:00009EB8 6100DC52        	  4182: 	bsr DisplayString
00:00009EBC F22F48000020    	  4183: 	fmove.x 32(sp),fp0
00:00009EC2 4CD7074F        	  4184: 	movem.l (sp),d0/d1/d2/d3/d6/a0/a1/a2
00:00009EC6 A2AF0003002C    	  4185: 	cchk 44(sp)
00:00009ECC 4E5A            	  4186: 	unlk a2
00:00009ECE 4E75            	  4187: 	rts
                            	  4188: 
                            	  4189: T15FloatToString:
00:00009ED0 4E52FFD4        	  4190: 	link a2,#-44
00:00009ED4 48D7034F        	  4191: 	movem.l d0/d1/d2/d3/d6/a0/a1,(sp)
00:00009ED8 F22F6800001C    	  4192: 	fmove.x fp0,28(sp)
00:00009EDE 2049            	  4193: 	move.l a1,a0						; a0 = pointer to buffer to use
00:00009EE0 13C100040508    	  4194: 	move.b d1,_width
00:00009EE6 23C200040514    	  4195: 	move.l d2,_precision
00:00009EEC 13C30004050C    	  4196: 	move.b d3,_E
00:00009EF2 6100F40C        	  4197: 	bsr _FloatToString
00:00009EF6 F22F4800001C    	  4198: 	fmove.x 28(sp),fp0
00:00009EFC 4CD7034F        	  4199: 	movem.l (sp),d0/d1/d2/d3/d6/a0/a1
00:00009F00 4E5A            	  4200: 	unlk a2
00:00009F02 4E75            	  4201: 	rts
                            	  4202: 
                            	  4203: ;==============================================================================
                            	  4204: ; Parameters:
                            	  4205: ;		d7 = device number
                            	  4206: ;		d6 = function number
                            	  4207: ;		d0 to d5 = arguments
                            	  4208: ;==============================================================================
                            	  4209: 
                            	  4210: io_trap:
00:00009F04 0C070007        	  4211: 	cmpi.b #7,d7							; make sure legal device
00:00009F08 621C            	  4212: 	bhi.s .0002
00:00009F0A 48E70180        	  4213: 	movem.l d7/a0,-(a7)
00:00009F0E 4887            	  4214: 	ext.w d7
00:00009F10 CEFC0084        	  4215: 	mulu #DCB_SIZE,d7					; index to DCB
00:00009F14 207C00040A00    	  4216: 	move.l #null_dcb,a0
00:00009F1A 20707018        	  4217: 	move.l DCB_CMDPROC(a0,d7.w),a0
00:00009F1E 4E90            	  4218: 	jsr (a0)
00:00009F20 4CDF0180        	  4219: 	movem.l (a7)+,d7/a0
00:00009F24 4E73            	  4220: 	rte
                            	  4221: .0002:
00:00009F26 7020            	  4222: 	moveq #E_BadDevNum,d0
00:00009F28 4E73            	  4223: 	rte
                            	  4224: 
                            	  4225: ;==============================================================================
                            	  4226: ; Output a character to the current output device.
                            	  4227: ;
                            	  4228: ; Parameters:
                            	  4229: ;		d1.b	 character to output
                            	  4230: ; Returns:
                            	  4231: ;		none
                            	  4232: ;==============================================================================
                            	  4233: 
                            	  4234: OutputChar:
00:00009F2A 48E78300        	  4235: 	movem.l d0/d6/d7,-(a7)
00:00009F2E 7E00            	  4236: 	clr.l d7
00:00009F30 7C00            	  4237: 	clr.l d6
00:00009F32 1E39000400A8    	  4238: 	move.b OutputDevice,d7		; d7 = output device
00:00009F38 3C3C0002        	  4239: 	move.w #DEV_PUTCHAR,d6		; d6 = function
00:00009F3C 4E40            	  4240: 	trap #0
00:00009F3E 4CDF00C1        	  4241: 	movem.l (a7)+,d0/d6/d7
00:00009F42 4E75            	  4242: 	rts
                            	  4243: 
                            	  4244: ;------------------------------------------------------------------------------
                            	  4245: ;------------------------------------------------------------------------------
                            	  4246: 
                            	  4247: InitIRQ:
00:00009F44 7006            	  4248: 	moveq		#6,d0
00:00009F46 41F900000B9E    	  4249: 	lea			KeybdIRQ,a0
00:00009F4C 610E            	  4250: 	bsr			InstallIRQ
00:00009F4E 41FA0050        	  4251: 	lea			TickIRQ,a0
00:00009F52 6108            	  4252: 	bsr			InstallIRQ
00:00009F54 7003            	  4253: 	moveq		#3,d0
00:00009F56 41F9000017F8    	  4254: 	lea			SerialIRQ,a0
                            	  4255: 	; fall through
                            	  4256: 
                            	  4257: ;------------------------------------------------------------------------------
                            	  4258: ; Install an IRQ handler.
                            	  4259: ;
                            	  4260: ; Parameters:
                            	  4261: ;		a0 = pointer to bucket containing vector
                            	  4262: ;		d0 = vector (64 to 255)
                            	  4263: ; Returns:
                            	  4264: ;		d0 = 0 if successfully added, otherwise E_NotAlloc
                            	  4265: ;		nf = 0, zf = 1 if successfully added, otherwise nf = 1, zf = 0
                            	  4266: ;------------------------------------------------------------------------------
                            	  4267: 
                            	  4268: InstallIRQ:
00:00009F5C 48E70060        	  4269: 	movem.l a1/a2,-(a7)				; save working register
00:00009F60 4A90            	  4270: 	tst.l (a0)								; link field must be NULL
00:00009F62 6634            	  4271: 	bne.s .0003
00:00009F64 0C400040        	  4272: 	cmpi.w #64,d0							; is vector in range (64 to 255)?
00:00009F68 652E            	  4273: 	blo.s .0003
00:00009F6A 0C4000FF        	  4274: 	cmpi.w #255,d0
00:00009F6E 6228            	  4275: 	bhi.s .0003
00:00009F70 45F80400        	  4276: 	lea	irq_list_tbl,a2				; a2 points to installed IRQ list
00:00009F74 E748            	  4277: 	lsl.w	#3,d0								; multiply by 2 long words
00:00009F76 22720000        	  4278: 	move.l (a2,d0.w),a1				; get first link
00:00009F7A 45F20000        	  4279: 	lea (a2,d0.w),a2					; 
                            	  4280: .0002:
00:00009F7E B1C9            	  4281: 	cmpa.l a1,a0							; installed already?
00:00009F80 6716            	  4282: 	beq.s .0003
00:00009F82 B2FC0000        	  4283: 	cmpa.l #0,a1							; is link NULL?
00:00009F86 6706            	  4284: 	beq.s .0001
00:00009F88 2449            	  4285: 	move.l a1,a2							; save previous link
00:00009F8A 2251            	  4286: 	move.l (a1),a1						; get next link
00:00009F8C 60F0            	  4287: 	bra .0002
                            	  4288: .0001:
00:00009F8E 2488            	  4289: 	move.l a0,(a2)						; set link
00:00009F90 225F245F        	  4290: 	movem.l (a7)+,a1/a2
00:00009F94 7000            	  4291: 	moveq #E_Ok,d0
00:00009F96 4E75            	  4292: 	rts
                            	  4293: .0003:
00:00009F98 225F245F        	  4294: 	movem.l (a7)+,a1/a2
00:00009F9C 7009            	  4295: 	moveq #E_NotAlloc,d0			; return failed to add
00:00009F9E 4E75            	  4296: 	rts
                            	  4297: 
                            	  4298: ;------------------------------------------------------------------------------
                            	  4299: ; TickIRQ
                            	  4300: ; - this IRQ is processed by all cores.
                            	  4301: ; - reset the edge circuit.
                            	  4302: ; - an IRQ live indicator is updated on the text screen for the core
                            	  4303: ;------------------------------------------------------------------------------
                            	  4304: 
                            	  4305: TickIRQ:
00:00009FA0 46FC2600        	  4306: 	move.w #$2600,sr					; disable lower level IRQs
00:00009FA4 48E77080        	  4307: 	movem.l	d1/d2/d3/a0,-(a7)
00:00009FA8 52B90004009C    	  4308: 	addi.l #1,tickcnt
00:00009FAE 13FC0001000400A0	  4309: 	move.b #1,IRQFlag					; tick interrupt indicator in local memory
00:00009FB6 4E7A1FE0        	  4310: 	movec	coreno,d1						; d1 = core number
00:00009FBA 2601            	  4311: 	move.l d1,d3
                            	  4312: 	if (SCREEN_FORMAT==1)
00:00009FBC E583            	  4313: 		asl.l #2,d3								; 4 bytes per text cell
                            	  4314: 	else
                            	  4315: 		asl.l #3,d3								; 8 bytes per text cell
                            	  4316: 	endif
00:00009FBE 23FC1D000000FD26	  4317: 	move.l #$1D000000,PLIC+$14	; reset edge sense circuit
00:00009FC6 0014
00:00009FC8 41F9FD0000A8    	  4318: 	lea $FD000000+(TEXTCOL-10)*4,a0			; display field address
00:00009FCE 24303004        	  4319: 	move.l 4(a0,d3.w),d2			; get char from screen
                            	  4320: ;	rol.l #8,d2								; extract char field
                            	  4321: ;	clr.b d2									; clear char field
                            	  4322: ;	addi.b #'0',d1						; binary to ascii core number
                            	  4323: ;	or.b	d1,d2								; insert core number
                            	  4324: ;	ror.l #8,d2								; reposition to proper place
                            	  4325: ;	addi.w #1,d2							; flashy colors
00:00009FD2 5282            	  4326: 	addi.l #$0001,d2
00:00009FD4 21823004        	  4327: 	move.l d2,4(a0,d3.w)			; update onscreen IRQ flag
00:00009FD8 6100FE6C        	  4328: 	bsr	ReceiveMsg
00:00009FDC 4CDF010E        	  4329: 	movem.l	(a7)+,d1/d2/d3/a0
00:00009FE0 4E73            	  4330: 	rte
                            	  4331: 
                            	  4332: ;------------------------------------------------------------------------------
                            	  4333: ;------------------------------------------------------------------------------
                            	  4334: 
                            	  4335: irq3_rout:
                            	  4336: ;	movem.l	d0/d1/a0/a1,-(a7)
                            	  4337: ;	lea			InstalledIRQ+8*4*3,a0
                            	  4338: ;	bra			irq_rout
                            	  4339: 
                            	  4340: irq6_rout:
                            	  4341: ;	movem.l	d0/d1/a0/a1,-(a7)
                            	  4342: ;	lea			InstalledIRQ+8*4*6,a0
                            	  4343: irq_rout:
00:00009FE2 7007            	  4344: 	moveq		#7,d0
                            	  4345: .nextHandler:
00:00009FE4 2258            	  4346: 	move.l	(a0)+,a1
00:00009FE6 6706            	  4347: 	beq.s		.0003
00:00009FE8 4E91            	  4348: 	jsr			(a1)
00:00009FEA 4A81            	  4349: 	tst.l		d1								; was IRQ handled?
00:00009FEC 6B04            	  4350: 	bmi.s		.0002							; first one to return handled quits loop
                            	  4351: .0003:
00:00009FEE 51C8FFF4        	  4352: 	dbra		d0,.nextHandler
                            	  4353: .0002:
00:00009FF2 4CDF0303        	  4354: 	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  4355: 
                            	  4356: ; Load head of list into an address register, then branch to a generic routine.
                            	  4357: 
                            	  4358: ;	rept 192
                            	  4359: ;	macIRQ_proc_label REPTN
                            	  4360: ;	movem.l a0/a1,-(a7)
                            	  4361: ;	move.l irq_list_tbl+REPTN*4,a1	; get the head of the list
                            	  4362: ;	jmp irq_proc_generic
                            	  4363: ;	endr
                            	  4364: 
                            	  4365: irq_proc_generic:
                            	  4366: .0003:
00:00009FF6 20690004        	  4367: 	move.l 4(a1),a0									; a0 = vector
00:00009FFA B0FC0000        	  4368: 	cmpa.l #0,a0										; ugh. move to address does not set flags
00:00009FFE 6706            	  4369: 	beq.s .0001											; valid vector?
00:0000A000 4E90            	  4370: 	jsr (a0)												; call the interrupt routine
00:0000A002 4A81            	  4371: 	tst.l d1												; IRQ handled?
00:0000A004 6B08            	  4372: 	bmi.s .0002											
                            	  4373: .0001:
00:0000A006 2251            	  4374: 	move.l (a1),a1
00:0000A008 B0FC0000        	  4375: 	cmpa.l #0,a0										; end of list?
00:0000A00C 66E8            	  4376: 	bne.s .0003
                            	  4377: .0002:
00:0000A00E 205F225F        	  4378: 	movem.l (a7)+,a0/a1
00:0000A012 4E73            	  4379: 	rte 
                            	  4380: 
                            	  4381: SpuriousIRQ:
00:0000A014 4E73            	  4382: 	rte
                            	  4383: 
                            	  4384: ;	bsr			KeybdIRQ
                            	  4385: ;	tst.l		d1								; handled by KeybdIRQ?
                            	  4386: ;	bmi.s		.0002							; if yes, go return
                            	  4387: ;.0001:
                            	  4388: ;	move.l	#$1D000000,PLIC+$14	; reset edge sense circuit
                            	  4389: ;	move.l	TextScr,a0				; a0 = screen address
                            	  4390: ;	addi.l	#1,40(a0)					; update onscreen IRQ flag
                            	  4391: ;.0002:	
                            	  4392: ;	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  4393: ;	rte
                            	  4394: 
                            	  4395: nmi_rout:
00:0000A016 48E7C080        	  4396: 	movem.l	d0/d1/a0,-(a7)
00:0000A01A 123C004E        	  4397: 	move.b	#'N',d1
00:0000A01E 6100FF0A        	  4398: 	bsr			OutputChar
00:0000A022 4CDF0103        	  4399: 	movem.l	(a7)+,d0/d1/a0		; return
00:0000A026 4E73            	  4400: 	rte
                            	  4401: 
                            	  4402: addr_err:
00:0000A028 544F            	  4403: 	addq		#2,sp						; get rid of sr
00:0000A02A 221F            	  4404: 	move.l	(sp)+,d1				; pop exception address
00:0000A02C 6100F556        	  4405: 	bsr			DisplayTetra		; and display it
00:0000A030 43FA00A6        	  4406: 	lea			msgAddrErr,a1	; followed by message
00:0000A034 6100DAEC        	  4407: 	bsr			DisplayStringCRLF
                            	  4408: .0001:
00:0000A038 60FE            	  4409: 	bra			.0001
00:0000A03A 6000E120        	  4410: 	bra			Monitor
                            	  4411: 	
                            	  4412: brdisp_trap:
00:0000A03E 48F9FFFF00040100	  4413: 	movem.l	d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
00:0000A046 33DF00040140    	  4414: 	move.w	(a7)+,Regsave+$40
00:0000A04C 23DF00040144    	  4415: 	move.l	(a7)+,Regsave+$44
00:0000A052 2E7C00047FFC    	  4416: 	move.l	#$47FFC,a7			; reset stack pointer
00:0000A058 46FC2500        	  4417: 	move.w	#$2500,sr				; enable interrupts
00:0000A05C 43FA0099        	  4418: 	lea			msg_bad_branch_disp,a1
00:0000A060 6100DAAA        	  4419: 	bsr			DisplayString
00:0000A064 6100F516        	  4420: 	bsr			DisplaySpace
00:0000A068 223900040144    	  4421: 	move.l	Regsave+$44,d1	; exception address
00:0000A06E 6100F514        	  4422: 	bsr			DisplayTetra		; and display it
                            	  4423: ;	move.l	(sp)+,d1				; pop format word 68010 mode only
00:0000A072 6000EE5C        	  4424: 	bra			cmdDumpRegs
                            	  4425: 
                            	  4426: illegal_trap:
00:0000A076 544F            	  4427: 	addq		#2,sp						; get rid of sr
00:0000A078 221F            	  4428: 	move.l	(sp)+,d1				; pop exception address
00:0000A07A 6100F508        	  4429: 	bsr			DisplayTetra		; and display it
00:0000A07E 43FA0065        	  4430: 	lea			msg_illegal,a1	; followed by message
00:0000A082 6100DA88        	  4431: 	bsr			DisplayString
                            	  4432: .0001:
00:0000A086 60FE            	  4433: 	bra			.0001
00:0000A088 6000E0D2        	  4434: 	bra			Monitor
                            	  4435: 	
                            	  4436: io_irq:
00:0000A08C 544F            	  4437: 	addq #2,sp
00:0000A08E 221F            	  4438: 	move.l (sp)+,d1
00:0000A090 6100F4F2        	  4439: 	bsr DisplayTetra
00:0000A094 43FA0083        	  4440: 	lea msg_io_access,a1
00:0000A098 6100DA72        	  4441: 	bsr DisplayString
00:0000A09C 6000EE32        	  4442: 	bra cmdDumpRegs
                            	  4443: 
                            	  4444: ; -----------------------------------------------------------------------------
                            	  4445: ; -----------------------------------------------------------------------------
                            	  4446: 
                            	  4447: msg_start:
00:0000A0A0 46656D74696B6920	  4448: 	dc.b	"Femtiki rf68k Multi-core OS Starting",LF,CR,0
00:0000A0A8 726636386B204D75
00:0000A0B0 6C74692D636F7265
00:0000A0B8 204F532053746172
00:0000A0C0 74696E67
00:0000A0C4 0A
00:0000A0C5 0D
00:0000A0C6 00
                            	  4449: ;	dc.b	"rf68k System Starting",CR,LF,0
                            	  4450: msg_core_start:
00:0000A0C7 20636F7265207374	  4451: 	dc.b	" core starting",CR,LF,0
00:0000A0CF 617274696E67
00:0000A0D5 0D
00:0000A0D6 0A
00:0000A0D7 00
                            	  4452: msgAddrErr
00:0000A0D8 2061646472657373	  4453: 	dc.b	" address err",0
00:0000A0E0 20657272
00:0000A0E4 00
                            	  4454: msg_illegal:
00:0000A0E5 20696C6C6567616C	  4455: 	dc.b	" illegal opcode",CR,LF,0
00:0000A0ED 206F70636F6465
00:0000A0F4 0D
00:0000A0F5 0A
00:0000A0F6 00
                            	  4456: msg_bad_branch_disp:
00:0000A0F7 206272616E636820	  4457: 	dc.b	" branch selfref: ",0
00:0000A0FF 73656C667265663A
00:0000A107 20
00:0000A108 00
                            	  4458: msg_test_done:
00:0000A109 2043505520746573	  4459: 	dc.b	" CPU test done.",0
00:0000A111 7420646F6E652E
00:0000A118 00
                            	  4460: msg_io_access
00:0000A119 20756E7065726D69	  4461: 	dc.b " unpermitted access to I/O",0
00:0000A121 7474656420616363
00:0000A129 65737320746F2049
00:0000A131 2F4F
00:0000A133 00
                            	  4462: msgChk
00:0000A134 20636865636B2066	  4463: 	dc.b " check failed",0
00:0000A13C 61696C6564
00:0000A141 00
                            	  4464: msgStackCanary
00:0000A142 20737461636B2063	  4465: 	dc.b " stack canary overwritten",0
00:0000A14A 616E617279206F76
00:0000A152 6572777269747465
00:0000A15A 6E
00:0000A15B 00
                            	  4466: 
                            	  4467: 	even
                            	  4468: 
                            	  4469: ;-------------------------------------------------------------------------
                            	  4470: ; File HEX2DEC   HEX2DEC convert hex to decimal                   11/02/81
                            	  4471: ;
                            	  4472: ;    CONVERT BINARY TO DECIMAL  REG  D0 PUT IN ( A6) BUFFER AS ASCII
                            	  4473: 
                            	  4474: ; Shift buffer one character to left
                            	  4475: ShiftBuf:
00:0000A15C 48E78028        	  4476: 	movem.l d0/a2/a4,-(a7)
00:0000A160 200B            	  4477: 	move.l a3,d0
00:0000A162 06800000003F    	  4478: 	addi.l #BUFSIZE,d0
                            	  4479: .0001:
00:0000A168 18EC0001        	  4480: 	move.b 1(a4),(a4)+
00:0000A16C B08C            	  4481: 	cmp.l a4,d0
00:0000A16E 65F8            	  4482: 	blo.s .0001
00:0000A170 4CDF1401        	  4483: 	movem.l (a7)+,d0/a2/a4
00:0000A174 4E75            	  4484: 	rts
                            	  4485: 
                            	  4486: HEX2DEC2:
00:0000A176 48E7C01C        	  4487: 	movem.l d0/d1/a3/a4/a5,-(a7)
00:0000A17A 264E            	  4488: 	move.l a6,a3
00:0000A17C 284E            	  4489: 	move.l a6,a4
00:0000A17E 2200            	  4490: 	move.l d0,d1
00:0000A180 6A0A            	  4491: 	bpl.s .0001
00:0000A182 4480            	  4492: 	neg.l d0										;
00:0000A184 6B32            	  4493: 	bmi.s .0002									; neg and still minus, must be -tve zero
00:0000A186 1CFC002D        	  4494: 	move.b #'-',(a6)+
00:0000A18A 284E            	  4495: 	move.l a6,a4
                            	  4496: .0001:
00:0000A18C 82FC0064        	  4497: 	divu #100,d1								; scale d1 - chop last 2 decimal digits
00:0000A190 A2C10000        	  4498: 	bin2bcd d1									; convert to BCD
00:0000A194 6100F41A        	  4499: 	bsr BufTetra								; capture in buffer (8 digits)
00:0000A198 2200            	  4500: 	move.l d0,d1
00:0000A19A A2C10000        	  4501: 	bin2bcd d1									; convert to BCD
00:0000A19E 6100F41C        	  4502: 	bsr BufByte									; capture last 2 digits in buffer
                            	  4503: .0004:
00:0000A1A2 0C140030        	  4504: 	cmpi.b #'0',(a4)						; Is there a leading zero?
00:0000A1A6 6606            	  4505: 	bne.s .0003									; No, we're done shifting
00:0000A1A8 61B2            	  4506: 	bsr ShiftBuf								; Shift the buffer over a character
00:0000A1AA 538E            	  4507: 	subq.l #1,a6								; adjust buffer pos.
00:0000A1AC 60F4            	  4508: 	bra.s .0004									; go check next character
                            	  4509: .0003:
00:0000A1AE 4A14            	  4510: 	tst.b (a4)
00:0000A1B0 6706            	  4511: 	beq.s .0002
00:0000A1B2 0C140020        	  4512: 	cmpi.b #' ',(a4)						; is the buffer empty?
00:0000A1B6 6606            	  4513: 	bne.s .0005
                            	  4514: .0002:
00:0000A1B8 18FC0030        	  4515: 	move.b #'0',(a4)+						; ensure at least a '0'
00:0000A1BC 2C4C            	  4516: 	move.l a4,a6
                            	  4517: .0005:
00:0000A1BE 4CDF3803        	  4518: 	movem.l (a7)+,d0/d1/a3/a4/a5
00:0000A1C2 4E75            	  4519: 	rts
                            	  4520: 
                            	  4521: HEX2DEC: 
00:0000A1C4 48E77B00        	  4522: 	movem.l D1-D4/D6-D7,-(A7)   ; SAVE REGISTERS
00:0000A1C8 2E00            	  4523: 	move.l D0,D7          			; SAVE IT HERE
00:0000A1CA 6A08            	  4524: 	bpl.s HX2DC
00:0000A1CC 4487            	  4525: 	neg.l D7              			; CHANGE TO POSITIVE
00:0000A1CE 6B4E            	  4526: 	bmi.s HX2DC57          			; SPECIAL CASE (-0)
00:0000A1D0 1CFC002D        	  4527: 	move.b #'-',(A6)+      			; PUT IN NEG SIGN
                            	  4528: HX2DC:  
00:0000A1D4 4244            	  4529: 	clr.w D4              			; FOR ZERO SURPRESS
00:0000A1D6 7C0A            	  4530: 	moveq #10,D6          			; COUNTER
                            	  4531: HX2DC0:
00:0000A1D8 7401            	  4532:   moveq #1,D2           			; VALUE TO SUB
00:0000A1DA 2206            	  4533: 	move.l D6,D1          			; COUNTER
00:0000A1DC 5381            	  4534: 	subq.l #1,D1           			; ADJUST - FORM POWER OF TEN
00:0000A1DE 671A            	  4535: 	beq.s HX2DC2           			; IF POWER IS ZERO
                            	  4536: HX2DC1:
00:0000A1E0 3602            	  4537:   move.w D2,D3          			; D3=LOWER WORD
00:0000A1E2 C6FC000A        	  4538: 	mulu #10,D3
00:0000A1E6 4842            	  4539: 	swap D2              				; D2=UPPER WORD
00:0000A1E8 C4FC000A        	  4540: 	mulu #10,D2
00:0000A1EC 4843            	  4541: 	swap D3              				; ADD UPPER TO UPPER
00:0000A1EE D443            	  4542: 	add.w D3,D2
00:0000A1F0 4842            	  4543: 	swap D2              				; PUT UPPER IN UPPER
00:0000A1F2 4843            	  4544: 	swap D3              				; PUT LOWER IN LOWER
00:0000A1F4 3403            	  4545: 	move.w D3,D2          			; D2=UPPER & LOWER
00:0000A1F6 5381            	  4546: 	subq.l #1,D1
00:0000A1F8 66E6            	  4547: 	bne.s HX2DC1
                            	  4548: HX2DC2:
00:0000A1FA 7000            	  4549:   clr.l D0              			; HOLDS SUB AMT
                            	  4550: HX2DC22:
00:0000A1FC BE82            	  4551: 	cmp.l D2,D7
00:0000A1FE 6D06            	  4552:   blt.s HX2DC3           			; IF NO MORE SUB POSSIBLE
00:0000A200 5280            	  4553: 	addq.l #1,D0           			; BUMP SUBS
00:0000A202 9E82            	  4554: 	sub.l D2,D7          				; COUNT DOWN BY POWERS OF TEN
00:0000A204 60F6            	  4555: 	bra.s HX2DC22          			; DO MORE
                            	  4556: HX2DC3:
00:0000A206 4A00            	  4557:   tst.b D0              			; ANY VALUE?
00:0000A208 6604            	  4558: 	bne.s HX2DC4
00:0000A20A 4A44            	  4559: 	tst.w D4              			; ZERO SURPRESS
00:0000A20C 6708            	  4560: 	beq.s HX2DC5
                            	  4561: HX2DC4:
00:0000A20E 06000030        	  4562:   addi.b #$30,D0         		; BINARY TO ASCII
00:0000A212 1CC0            	  4563: 	move.b D0,(A6)+       			; PUT IN BUFFER
00:0000A214 1800            	  4564: 	move.b D0,D4          			; MARK AS NON ZERO SURPRESS
                            	  4565: HX2DC5:
00:0000A216 5386            	  4566:   subq.l #1,D6           			; NEXT POWER
00:0000A218 66BE            	  4567: 	bne.s HX2DC0
00:0000A21A 4A44            	  4568: 	tst.w D4              			; SEE IF ANYTHING PRINTED
00:0000A21C 6604            	  4569: 	bne.s HX2DC6
                            	  4570: HX2DC57:
00:0000A21E 1CFC0030        	  4571:  move.b #'0',(A6)+      			; PRINT AT LEST A ZERO
                            	  4572: HX2DC6:
00:0000A222 4CDF00DE        	  4573: 	movem.l (A7)+,D1-D4/D6-D7 ; RESTORE REGISTERS
00:0000A226 4E75            	  4574:   rts                      	; END OF ROUTINE
                            	  4575: 
                            	  4576: 
                            	  4577: PNT4HX:
                            	  4578: PNT4HEX:
00:0000A228 6000F38C        	  4579: 	bra BufWyde
                            	  4580: PNT6HX:
00:0000A22C 4840            	  4581: 	swap d0
00:0000A22E 6100F38C        	  4582: 	bsr BufByte
00:0000A232 4840            	  4583: 	swap d0
00:0000A234 6000F380        	  4584: 	bra BufWyde
                            	  4585: PNT8HX:
00:0000A238 6000F376        	  4586: 	bra BufTetra
                            	  4587: 	
                            	  4588: ; FORMAT RELATIVE ADDRESS  AAAAAA+Rn
                            	  4589: ;        ENTER     D0 = VALUE
                            	  4590: ;                  A6 = STORE POINTER
                            	  4591: ;
                            	  4592: FRELADDR:
00:0000A23C 48E74780        	  4593: 	movem.l D1/D5-D7/A0,-(A7)
00:0000A240 41F900040880    	  4594: 	lea OFFSET,A0
00:0000A246 7EFF            	  4595: 	moveq #-1,D7        	; D7 = DIFF. BEST FIT
00:0000A248 7C00            	  4596: 	clr.l D6            	; D6 = OFFSET POSITION
                            	  4597: FREL10:
00:0000A24A 2200            	  4598:   move.l D0,D1
00:0000A24C 4A90            	  4599: 	tst.l (a0)
00:0000A24E 670C            	  4600: 	beq.s FREL15         	; ZERO OFFSET
00:0000A250 9290            	  4601: 	sub.l (a0),d1      		; D1 = DIFF.
00:0000A252 6B08            	  4602: 	bmi.s FREL15         	; NO FIT
00:0000A254 B287            	  4603: 	cmp.l D7,D1
00:0000A256 6404            	  4604: 	bcc.s FREL15         	; OLD FIT BETTER
00:0000A258 2E01            	  4605: 	move.l D1,D7        	; D7 = NEW BEST FIT
00:0000A25A 2A06            	  4606: 	move.l D6,D5        	; D5 = POSITION
                            	  4607: FREL15:
00:0000A25C 5888            	  4608:   addq.l #4,A0
00:0000A25E 5286            	  4609: 	addq.l #1,D6
00:0000A260 0C460008        	  4610: 	cmpi.w #8,D6
00:0000A264 66E4            	  4611: 	bne.s FREL10         	; MORE OFFSETS TO CHECK
00:0000A266 4A87            	  4612: 	tst.l D7
00:0000A268 6B1E            	  4613: 	bmi.s FREL25         	; NO FIT
00:0000A26A 4A46            	  4614: 	tst D6
00:0000A26C 6608            	  4615: 	bne.s FREL20
00:0000A26E 4AB900040880    	  4616: 	tst.l OFFSET
00:0000A274 6712            	  4617: 	beq.s FREL25         	; R0 = 000000; NO FIT
                            	  4618: FREL20:
00:0000A276 2007            	  4619:   move.l D7,D0
00:0000A278 61B2            	  4620: 	bsr	PNT6HX         		; FORMAT OFFSET
00:0000A27A 1CFC002B        	  4621: 	move.b #'+',(A6)+    	; +
00:0000A27E 1CFC0052        	  4622: 	move.b #'R',(A6)+    	; R
00:0000A282 06050030        	  4623: 	addi.b #'0',D5       	; MAKE ASCII
00:0000A286 600A            	  4624: 	bra.s FREL30
                            	  4625: FREL25:
00:0000A288 61A2            	  4626:   bsr	PNT6HX         	; FORMAT ADDRESS AS IS
00:0000A28A 1A3C0020        	  4627: 	move.b #BLANK,D5
00:0000A28E 1CC5            	  4628: 	move.b D5,(A6)+     	; THREE SPACES FOR ALIGNMENT
00:0000A290 1CC5            	  4629: 	move.b D5,(A6)+
                            	  4630: FREL30:
00:0000A292 1CC5            	  4631:   move.b D5,(A6)+
00:0000A294 4CDF01E2        	  4632: 	movem.l (A7)+,D1/D5-D7/A0
00:0000A298 4E75            	  4633: 	rts
                            	  4634: 
                            	  4635: 	include "dcode68k.x68"

Source: "dcode68k.x68"
                            	     1: ;-------------------------------------------------------------------------
                            	     2: ; File DCODE68K  68K ONE LINE DISASSEMBLER                        07/28/82
                            	     3: ;
                            	     4: ;        CALLING SEQUENCE:
                            	     5: ;   D0,D1,D2 = CODE TO BE DISASSEMBLED
                            	     6: ;   A4 = VALUE OF PROGRAM COUNTER FOR THE CODE
                            	     7: ;   A5 = POINTER TO STORE DATA (BUFSIZE = 80 ASSUMED)
                            	     8: ;        JSR       DCODE68K
                            	     9: ;
                            	    10: ;        RETURN:
                            	    11: ;   A4 = VALUE OF PROGRAM COUNTER FOR NEXT INSTRUCTION
                            	    12: ;   A5 = POINTER TO LINE AS DISASSEMBLED
                            	    13: ;   A6 = POINTER TO END OF LINE
                            	    14: ;
                            	    15: ; 01234567890123456789012345678901234567890123456789
                            	    16: ; AAAAAA FDATA.DDDDDDDDDDDDDD FOC.... FOP.....
                            	    17: ;
                            	    18: ;FDATA   =       10             DATA FIELD
                            	    19: ;FOC     =       31             OP-CODE FIELD
                            	    20: ;FOP     =       39             OPERAND FIELD
                            	    21: ;
                            	    22: ; CAUSES ORGIN MODULO 4
                            	    23: ; LONG:    macro
                            	    24: ;         .align  2
                            	    25: ;         DS.B    (;-X)&2
                            	    26: ;         endm
                            	    27: LOCVARSZ = 16
                            	    28: BUFSIZE  = 63
                            	    29: FDATA    =       10        ; OFFSET TO DATA
                            	    30: FOL      =       31        ; OFFSET TO LABEL
                            	    31: FOC      =       31        ; OFFSET TO OP-CODE (NO LABEL FIELD)
                            	    32: FOP      =       39        ; OFFSET TO OPERAND (NO LABEL FIELD)
                            	    33: 
                            	    34: 					code
                            	    35: 					even
                            	    36: X:       ;              ; BASE ADDRESS THIS MODULE
                            	    37:                                 ; LONG
                            	    38: 
                            	    39: ;  MOVEM REGISTERS TO EA
                            	    40: ;
                            	    41: ;        01001D001S......
                            	    42: ;        ..........XXXXXX       EFFECTIVE ADDRESS
                            	    43: ;        .........0......       WORD
                            	    44: ;        .........1......       LONG
                            	    45: ;        .....0..........       REGISTER TO MEMORY
                            	    46: ;        .....1..........       MEMORY TO REGISTER
                            	    47: ;
                            	    48: ;
                            	    49: IMOVEMFR:
00:0000A29A 610006F8        	    50:          BSR     MOVEMS         ; SIZE
                            	    51: 
00:0000A29E 7C38            	    52:          MOVEQ   #$0038,D6
00:0000A2A0 CC54            	    53:          AND.W   (A4),D6
00:0000A2A2 0C460020        	    54:          CMPI.W  #$0020,D6
00:0000A2A6 6706            	    55:          BEQ.S   IM7788         ; PREDECREMENT MODE
                            	    56: 
00:0000A2A8 7C01            	    57:          MOVEQ   #1,D6         ; D6 = INCREMENTER (BIT POSITION)
00:0000A2AA 7200            	    58:          MOVEQ   #0,D1         ; D1 = BIT POSITION
00:0000A2AC 6004            	    59:          BRA.S   IM7799
                            	    60: 
00:0000A2AE 7CFF            	    61: IM7788:  MOVEQ   #-1,D6        ; D6 = DECREMENTER (BIT POSITION)
00:0000A2B0 720F            	    62:          MOVEQ   #15,D1        ; D1 = BIT POSITION
00:0000A2B2 610006F4        	    63: IM7799:  BSR     MOVEMR         ; BUILD MASK WORD
                            	    64: 
00:0000A2B6 1CFC002C        	    65:          MOVE.B  #',',(A6)+    ; STORE COMMA
                            	    66: 
00:0000A2BA 5483            	    67:          ADDQ.L  #2,D3
00:0000A2BC 3814            	    68:          MOVE.W  (A4),D4
00:0000A2BE 3E3C01F4        	    69:          MOVE.W  #$1F4,D7     ; CONTROL + PREDECREMENT
00:0000A2C2 6100050E        	    70:          BSR     EEA
00:0000A2C6 601A            	    71:          BRA.S   CS16           ; COMMON
                            	    72: 
                            	    73:          
                            	    74: 
                            	    75: ; MOVEM  EA  TO REGISTERS
                            	    76: ;
00:0000A2C8 610006CA        	    77: IMOVEMTR:BSR     MOVEMS         ; SIZE
00:0000A2CC 5483            	    78:          ADDQ.L  #2,D3
00:0000A2CE 3E3C07EC        	    79:          MOVE.W  #$7EC,D7     ; CONTROL + POSTINCREMENT
00:0000A2D2 610004FE        	    80:          BSR     EEA
                            	    81: 
00:0000A2D6 1CFC002C        	    82:          MOVE.B  #',',(A6)+    ; STORE COMMA
                            	    83: 
00:0000A2DA 7C01            	    84:          MOVEQ   #1,D6         ; D6 = BIT POSITION INCREMENTER
00:0000A2DC 7200            	    85:          MOVEQ   #0,D1         ; D1 = BIT POSITION
00:0000A2DE 610006C8        	    86:          BSR     MOVEMR
                            	    87: 
00:0000A2E2 606C            	    88: CS16:    BRA.S   CS15           ; COMMON
                            	    89: 
                            	    90:          
                            	    91: ISTOP:
00:0000A2E4 302C0002        	    92: 	move.w 2(A4),D0
00:0000A2E8 1CFC0023        	    93: 	move.b #'#',(A6)+    	; IMMEDIATE
00:0000A2EC 1CFC0024        	    94: 	move.b #'$',(A6)+    	; HEX
00:0000A2F0 6100FF36        	    95: 	bsr PNT4HX         		; VALUE
00:0000A2F4 600007C6        	    96: 	bra COMMON4
                            	    97: 
                            	    98: IMMED:   ;.align  2              ; ADD  AND  CMP #  EOR  OR  SUB
00:0000A2F8 6100044E        	    99: 	bsr FORMSIZE
00:0000A2FC 5483            	   100: 	addq.l #2,D3         	; SIZE = 4
00:0000A2FE 1CFC0023        	   101: 	move.b #'#',(A6)+    	; IMMEDIATE
00:0000A302 7000            	   102: 	clr.l D0
00:0000A304 302C0002        	   103: 	move.w 2(A4),D0     	; D0 = EXTENSION WORD
00:0000A308 3214            	   104: 	move.w (A4),D1
00:0000A30A EC49            	   105: 	lsr.w #6,D1
00:0000A30C 02410003        	   106: 	andi.w #3,D1
00:0000A310 6746            	   107: 	beq.s IMMED65        	; .BYTE
00:0000A312 0C010001        	   108: 	cmpi.b #1,D1
00:0000A316 6750            	   109: 	beq.s IMMED75        	; .WORD
00:0000A318 5483            	   110: 	addq.l #2,D3         	; .LONG    SIZE = 6
00:0000A31A 202C0002        	   111: 	move.l 2(A4),D0     	; D0 = LONG EXTENSION WORD
                            	   112: 
                            	   113: IMMED45:
00:0000A31E 6100FEA4        	   114: 	bsr HEX2DEC        		; DECIMAL
00:0000A322 1CC5            	   115: 	move.b D5,(A6)+     	; COMMA SEPARATOR
00:0000A324 3014            	   116: 	move (A4),D0
00:0000A326 0240003F        	   117: 	andi.w #$003F,D0
00:0000A32A 0C40003C        	   118: 	cmpi.w #$003C,D0    	; DESTINATION ADDRESS MODE 111100  "SR"
00:0000A32E 6622            	   119: 	bne.s IMMED55        	; NOT FOUND
00:0000A330 3014            	   120: 	move.w (A4),D0      	; "SR"  ILLEGAL FOR
00:0000A332 02404000        	   121: 	andi.w #$4000,D0    	; ADDI   SUBI  CMPI
00:0000A336 660007AE        	   122: 	bne FERROR         		; 0600   0400  0C00
00:0000A33A 3214            	   123: 	move.w (A4),D1
00:0000A33C 024100C0        	   124: 	andi.w #$00C0,D1
00:0000A340 0C410080        	   125: 	cmpi.w #$0080,D1
00:0000A344 670007A0        	   126: 	beq FERROR         		; .LONG NOT ALLOWED
00:0000A348 1CFC0053        	   127: 	move.b #'S',(A6)+    	; #,SR FOR ANDI, EORI, ORI
00:0000A34C 1CFC0052        	   128: 	move.b #'R',(A6)+
                            	   129: CS15:
00:0000A350 603C            	   130: 	bra.s CS14           	; COMMON
                            	   131: IMMED55:
00:0000A352 6100047E        	   132: 	bsr EEA
00:0000A356 6036            	   133: 	bra.s CS14           	; COMMON
                            	   134: IMMED65:
00:0000A358 2200            	   135: 	move.l D0,D1        	; D1 = XXXXXXXX........
00:0000A35A E049            	   136: 	lsr.w #8,D1         	; D1 = 00000000XXXXXXXX
00:0000A35C 670A            	   137: 	beq.s IMMED75
00:0000A35E 2200            	   138: 	move.l D0,D1
00:0000A360 EE41            	   139: 	asr.w #7,D1
00:0000A362 5241            	   140: 	addq.w #1,D1         ; CHECK FOR NEGATIVE
00:0000A364 66000780        	   141: 	bne FERROR
                            	   142: IMMED75:
00:0000A368 48C0            	   143: 	ext.l D0
00:0000A36A 60B2            	   144: 	bra.s IMMED45
                            	   145: 
                            	   146: ;  BIT   5432109876543210
                            	   147: ;        ....RRRMMM......       ; DESTINATION REGISTER MODE
                            	   148: ;        ..........MMMRRR       ; SOURCE MODE REGISTER
                            	   149: ;        0001............       ; .BYTE
                            	   150: ;        0011............       ; .WORD
                            	   151: ;        0010............       ; .LONG
                            	   152: ;
                            	   153: ; IF BYTE SIZE; DESTINATION ADDRESS DIRECT NOT ALLOWED
                            	   154:    
                            	   155: IMOVE:
00:0000A36C 6000037E        	   156: 	bra IMOVEA1
                            	   157: 
                            	   158: ILINK:
00:0000A370 6158            	   159: 	bsr.s FORMREGA
00:0000A372 1CC5            	   160: 	move.b D5,(A6)+     ; COMMA SERARATOR
00:0000A374 1CFC0023        	   161: 	move.b #'#',(A6)+
00:0000A378 302C0002        	   162: 	move.w 2(A4),D0
00:0000A37C 48C0            	   163: 	ext.l D0
00:0000A37E 6100FE44        	   164: 	bsr HEX2DEC        	; DECIMAL DISPLACEMENT
00:0000A382 60000738        	   165: 	bra COMMON4
                            	   166:          
                            	   167:          ; CLR  NEG  NEGX  NOT TST
                            	   168: FORM1:
00:0000A386 610003C0        	   169: 	bsr FORMSIZE
                            	   170: ;                               ; NBCD TAS
                            	   171: FORM1A:
00:0000A38A 61000446        	   172: 	bsr EEA            	; DATA ALTERABLE ONLY
                            	   173: CS14:
00:0000A38E 6068            	   174: 	bra.s CS13          ; COMMON
                            	   175:      
                            	   176: 
                            	   177: 				;.align  2              ; EXT  SWAP
                            	   178: FORM3:   
00:0000A390 6148            	   179: 	bsr.s FORMREGD
00:0000A392 6064            	   180: 	bra.s CS13           	; COMMON
                            	   181:          
                            	   182: 
                            	   183: FORM4:	;   .align  2              ; TRAP
00:0000A394 1CFC0023        	   184:          MOVE.B  #'#',(A6)+
00:0000A398 3014            	   185:          MOVE.W  (A4),D0
00:0000A39A 02800000000F    	   186:          ANDI.L  #$0F,D0
00:0000A3A0 6100FE22        	   187:          BSR     HEX2DEC        ; DECIMAL
00:0000A3A4 6052            	   188:          BRA.S   CS13           ; COMMON
                            	   189: 
                            	   190:          
                            	   191: 
                            	   192: FORM5:	;   .align  2              ; UNLNK
00:0000A3A6 6122            	   193:          BSR.S   FORMREGA
00:0000A3A8 604E            	   194:          BRA.S   CS13           ; COMMON
                            	   195: 
                            	   196: ;  BIT   5432109876543210
                            	   197: ;        ....RRR.........       ; ADDRESS REGISTER
                            	   198: ;        ..........XXXXXX       ; EFFECTIVE ADDRESS
                            	   199: ;
                            	   200:          
                            	   201: 
                            	   202: FORM6A:	;  .align  2              ; LEA
00:0000A3AA 3E3C07E4        	   203:          MOVE.W  #$7E4,D7     ; CONTROL ADDRESSING
00:0000A3AE 6150            	   204:          BSR.S   EEA10
                            	   205: 
00:0000A3B0 1CC5            	   206:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   207: 
00:0000A3B2 3814            	   208:          MOVE.W  (A4),D4
00:0000A3B4 EF5C            	   209:          ROL.W   #7,D4
00:0000A3B6 6112            	   210:          BSR.S   FORMREGA
00:0000A3B8 603E            	   211:          BRA.S   CS13           ; COMMON
                            	   212: 
                            	   213: ;  BIT   5432109876543210
                            	   214: ;        ....DDD.........       ; DATA REGISTER
                            	   215: ;        ..........XXXXXX       ; EFFECTIVE ADDRESS
                            	   216: ;
                            	   217:          
                            	   218: 
                            	   219: FORM6D:  ;.align  2              ; CHK  DIVS  DIVU  MULS  MULU
00:0000A3BA 3E3C0FFD        	   220:          MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:0000A3BE 6140            	   221:          BSR.S   EEA10
                            	   222: 
00:0000A3C0 1CC5            	   223:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   224: 
00:0000A3C2 3814            	   225:          MOVE.W  (A4),D4
00:0000A3C4 EF5C            	   226:          ROL.W   #7,D4
00:0000A3C6 6112            	   227:          BSR.S   FORMREGD
00:0000A3C8 602E            	   228:          BRA.S   CS13           ; COMMON
                            	   229: 
00:0000A3CA 1CFC0041        	   230: FORMREGA:MOVE.B  #'A',(A6)+    ; FORMAT A@
00:0000A3CE 02040007        	   231: FORMREG5:ANDI.B  #$07,D4
00:0000A3D2 00040030        	   232:          ORI.B   #'0',D4
00:0000A3D6 1CC4            	   233:          MOVE.B  D4,(A6)+
00:0000A3D8 4E75            	   234:          RTS
                            	   235: 
00:0000A3DA 1CFC0044        	   236: FORMREGD:MOVE.B  #'D',(A6)+    ; FORMAT D@
00:0000A3DE 60EE            	   237:          BRA.S   FORMREG5
                            	   238: 
                            	   239: ;  BIT   5432109876543210
                            	   240: ;        ....DDD......DDD       ; DATA REGISTERS
                            	   241: ;
                            	   242:         
                            	   243: FORM7: ;  .align  2              ; EXG
00:0000A3E0 EF5C            	   244: 	rol.w #7,D4
00:0000A3E2 61F6            	   245: 	bsr.s FORMREGD
00:0000A3E4 1CC5            	   246: 	move.b D5,(A6)+     	; COMMA SEPARATOR
00:0000A3E6 3814            	   247: 	move.w (A4),D4
00:0000A3E8 61F0            	   248: 	bsr.s FORMREGD
00:0000A3EA 600C            	   249: 	bra.s CS13           	; COMMON
                            	   250: 
                            	   251: ;  BIT   5432109876543210
                            	   252: ;        ....AAA......AAA       ; ADDRESS REGISTERS
                            	   253: ;
                            	   254:          
                            	   255: FORM8:   ;.align  2              ; EXG
00:0000A3EC EF5C            	   256:          ROL.W   #7,D4
00:0000A3EE 61DA            	   257:          BSR.S   FORMREGA
                            	   258: 
                            	   259: FORM815:
00:0000A3F0 1CFC002C        	   260: 	MOVE.B  #',',(A6)+    ; COMMA SEPARATOR
00:0000A3F4 3814            	   261: 	MOVE.W  (A4),D4
00:0000A3F6 61D2            	   262: 	BSR.S   FORMREGA
                            	   263: CS13:
00:0000A3F8 6078            	   264: 	BRA     CS12           ; COMMON
                            	   265: 
                            	   266: ;  BIT   5432109876543210
                            	   267: ;        ....DDD.........       ; DATA REGISTER
                            	   268: ;        .............AAA       ; ADDRESS REGISTER
                            	   269: ;
                            	   270:          
                            	   271: 
                            	   272: FORM9:   ;.align  2              ; EXG
00:0000A3FA EF5C            	   273:          ROL.W   #7,D4
00:0000A3FC 61DC            	   274:          BSR.S   FORMREGD       ; DATA REGISTER
00:0000A3FE 60F0            	   275:          BRA.S   FORM815
                            	   276: 
00:0000A400 600003D0        	   277: EEA10:   BRA     EEA
                            	   278: 
                            	   279: ;  BIT   5432109876543210
                            	   280: ;        ..........AAAAAA         EFFECTIVE ADDRESS
                            	   281: ;        .......MMM......         OP-MODE
                            	   282: ;        ....RRR.........         D-REGISTER
                            	   283: ;        .......011......         WORD  EA,A@
                            	   284: ;        .......111......         LONG  EA,A@
                            	   285: ;        .......000......         EA,D@ BYTE (ADDRESS REGISTER DIRECT NOT ALLOWED)
                            	   286: ;        .......0........         EA,D@
                            	   287: ;        .......1........         D@,EA
                            	   288: ;        ........00......         BYTE
                            	   289: ;        ........01......         WORD
                            	   290: ;        ........10......         LONG
                            	   291: ;
                            	   292:          
                            	   293: 
                            	   294: ;                               ADD <EA>,A@   CMP <EA>,A@   SUB <EA>,A@
                            	   295: FORM10EX:	;.align  2              ; ADD  CMP  SUB
00:0000A404 3E3C0FFF        	   296:          MOVE.W  #$FFF,D7     ; ALL MODES ALLOWED
00:0000A408 2004            	   297:          MOVE.L  D4,D0
00:0000A40A 024001C0        	   298:          ANDI.W  #$01C0,D0
00:0000A40E 6738            	   299:          BEQ.S   FORM103        ; .......000......
00:0000A410 0C4001C0        	   300:          CMPI.W  #$01C0,D0
00:0000A414 6710            	   301:          BEQ.S   FORM10E3       ; .......111......
00:0000A416 0C4000C0        	   302:          CMPI.W  #$00C0,D0
00:0000A41A 661E            	   303:          BNE.S   FORM10E6
                            	   304: 
00:0000A41C 1AFC002E        	   305:          MOVE.B  #'.',(A5)+    ; .......011......       STORE PERIOD
00:0000A420 1AFC0057        	   306:          MOVE.B  #'W',(A5)+
00:0000A424 6008            	   307:          BRA.S   FORM10E4
                            	   308: 
00:0000A426 1AFC002E        	   309: FORM10E3:MOVE.B  #'.',(A5)+
00:0000A42A 1AFC004C        	   310:          MOVE.B  #'L',(A5)+
                            	   311: 
00:0000A42E 61D0            	   312: FORM10E4:BSR.S   EEA10
                            	   313: 
00:0000A430 1CC5            	   314:          MOVE.B  D5,(A6)+     ; STORE COMMA SEPARATOR
                            	   315: 
00:0000A432 3814            	   316:          MOVE.W  (A4),D4
00:0000A434 EF5C            	   317:          ROL.W   #7,D4
00:0000A436 6192            	   318:          BSR.S   FORMREGA       ; <EA>,A@
00:0000A438 6038            	   319:          BRA.S   CS12           ; COMMON
                            	   320: 
00:0000A43A 08140000        	   321: FORM10E6:BTST.B  #0,(A4)
00:0000A43E 661C            	   322:          BNE.S   FORM105        ; .......1........    D@,<EA>
00:0000A440 600A            	   323:          BRA.S   FORM104        ; .......0........    <EA>,D@
                            	   324: 
                            	   325: ;  BIT   5432109876543210
                            	   326: ;        ..........AAAAAA       EFFECTIVE ADDRESS
                            	   327: ;        .......MMM......       OP-MODE
                            	   328: ;        ....RRR.........       D-REGISTER
                            	   329: ;        .......0........       EA,D@
                            	   330: ;        .......1........       D@,EA
                            	   331: ;        ........00......       BYTE
                            	   332: ;        ........01......       WORD
                            	   333: ;        ........10......       LONG
                            	   334: 
                            	   335:          
                            	   336: 
                            	   337: FORM10:  ;.align  2              ; AND  EOR  OR
00:0000A442 08140000        	   338:          BTST.B  #0,(A4)
00:0000A446 6614            	   339:          BNE.S   FORM105
                            	   340: 
00:0000A448 3E3C0FFD        	   341: FORM103: MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:0000A44C 610002FA        	   342: FORM104: BSR     FORMSIZE
00:0000A450 61AE            	   343:          BSR.S   EEA10          ; <EA>,D@
                            	   344: 
00:0000A452 1CC5            	   345:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   346: 
00:0000A454 1814            	   347:          MOVE.B  (A4),D4
00:0000A456 E20C            	   348:          LSR.B   #1,D4
00:0000A458 6180            	   349:          BSR     FORMREGD
00:0000A45A 6016            	   350:          BRA.S   CS12           ; COMMON
                            	   351: 
00:0000A45C 610002EA        	   352: FORM105: BSR     FORMSIZE       ; D@,<EA>
00:0000A460 1814            	   353:          MOVE.B  (A4),D4
00:0000A462 E20C            	   354:          LSR.B   #1,D4
00:0000A464 6100FF74        	   355:          BSR     FORMREGD
                            	   356: 
00:0000A468 1CC5            	   357:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   358: 
00:0000A46A 3814            	   359:          MOVE.W  (A4),D4
00:0000A46C 3E3C01FD        	   360:          MOVE.W  #$1FD,D7     ; ALTERABLE MEMORY ADDRESSING
00:0000A470 618E            	   361:          BSR.S   EEA10
00:0000A472 6000064A        	   362: CS12:    BRA     COMMON
                            	   363: 
                            	   364:          
                            	   365: 
                            	   366: ;                               PEA     (JMP  JSR)
00:0000A476 3E3C07E4        	   367: FORM11:  MOVE.W  #$7E4,D7     ; CONTROL ADDERSSING
00:0000A47A 6184            	   368:          BSR     EEA10
00:0000A47C 60F4            	   369:          BRA.S   CS12           ; COMMON
                            	   370: 
                            	   371:          
                            	   372: 
                            	   373: ;                               ; JMP  JSR
00:0000A47E 2004            	   374: FORM11SL:MOVE.L  D4,D0        ; LOOK FOR .S  OR  .L
00:0000A480 0240003F        	   375:          ANDI.W  #$3F,D0
00:0000A484 0C400038        	   376:          CMPI.W  #$38,D0
00:0000A488 6608            	   377:          BNE.S   FORM112        ; NOT .S
00:0000A48A 1AFC002E        	   378:          MOVE.B  #'.',(A5)+    ; PERIOD
00:0000A48E 1AFC0053        	   379:          MOVE.B  #'S',(A5)+    ; S
00:0000A492 0C400039        	   380: FORM112: CMPI.W  #$39,D0
00:0000A496 6608            	   381:          BNE.S   FORM114
00:0000A498 1AFC002E        	   382:          MOVE.B  #'.',(A5)+    ; PERIOD
00:0000A49C 1AFC004C        	   383:          MOVE.B  #'L',(A5)+    ; L
00:0000A4A0 60D4            	   384: FORM114: BRA.S   FORM11
                            	   385: 
                            	   386: ;  BIT   5432109876543210
                            	   387: ;        ....XXX.....0...       DATA DESTINATION REGISTER
                            	   388: ;        ....XXX.....1...       ADDRESS REGISTER
                            	   389: ;        ....XXX.00......       BYTE
                            	   390: ;        ........01......       WORD
                            	   391: ;        ........10......       LONG
                            	   392: ;        ............0...       DATA REGISTER TO DATA REGISTER
                            	   393: ;        ............1...       MEMORY TO MEMORY
                            	   394: ;        ............0xXX       DATA SOURCE REGISTER
                            	   395: ;        ............1XXX       ADDRESS SOURCE REGISTER
                            	   396: ;
                            	   397:          
                            	   398: 
                            	   399: FORM12:  ;.align  2              ; ABCD  ADDX  SBCD  SUBX
00:0000A4A2 610002A4        	   400:          BSR     FORMSIZE
                            	   401: 
00:0000A4A6 08040003        	   402:          BTST    #3,D4
00:0000A4AA 6610            	   403:          BNE.S   FORM125
                            	   404: 
00:0000A4AC 6100FF2C        	   405:          BSR     FORMREGD       ; D@,D@;   FORMAT SOURCE
                            	   406: 
00:0000A4B0 1CC5            	   407:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   408: 
00:0000A4B2 1814            	   409:          MOVE.B  (A4),D4
00:0000A4B4 E20C            	   410:          LSR.B   #1,D4
00:0000A4B6 6100FF22        	   411:          BSR     FORMREGD       ; FORMAT DESTINATION
00:0000A4BA 6046            	   412:          BRA.S   CS11           ; COMMON
                            	   413: 
00:0000A4BC 1CFC002D        	   414: FORM125: MOVE.B  #'-',(A6)+    ; -
00:0000A4C0 1CFC0028        	   415:          MOVE.B  #'(',(A6)+    ; (
00:0000A4C4 6100FF04        	   416:          BSR     FORMREGA       ; A@    SOURCE
                            	   417: 
00:0000A4C8 203C282D2C29    	   418:          MOVE.L  #$282d2c29,D0 ; ),-(
00:0000A4CE 6152            	   419:          BSR.S   SCHR           ; STORE CHARS
                            	   420: 
00:0000A4D0 1814            	   421:          MOVE.B  (A4),D4
00:0000A4D2 E20C            	   422:          LSR.B   #1,D4
00:0000A4D4 6100FEF4        	   423:          BSR     FORMREGA       ; A@   DESTINATION
00:0000A4D8 1CFC0029        	   424:          MOVE.B  #')',(A6)+
00:0000A4DC 6024            	   425:          BRA.S   CS11           ; COMMON
                            	   426: 
                            	   427: ;  BIT   5432109876543210
                            	   428: ;        ....XXX.....1...       ADDRESS REGISTER    DESTINATION
                            	   429: ;        ....XXX.00......       BYTE
                            	   430: ;        ........01......       WORD
                            	   431: ;        ........10......       LONG
                            	   432: ;        ............1...       MEMORY TO MEMORY
                            	   433: ;        ............1XXX       ADDRESS SOURCE REGISTER
                            	   434: ;
                            	   435:          
                            	   436: 
                            	   437: FORM12A: ;.align  2              ; CMPM
00:0000A4DE 61000268        	   438:          BSR     FORMSIZE
                            	   439: 
00:0000A4E2 1CFC0028        	   440:          MOVE.B  #'(',(A6)+    ; (
00:0000A4E6 6100FEE2        	   441:          BSR     FORMREGA       ; A@
                            	   442: 
00:0000A4EA 203C282C2B29    	   443:          MOVE.L  #$282c2b29,D0  ; )+,(
00:0000A4F0 6130            	   444:          BSR.S   SCHR           ; STORE CHARS
                            	   445: 
00:0000A4F2 1814            	   446:          MOVE.B  (A4),D4
00:0000A4F4 E20C            	   447:          LSR.B   #1,D4
00:0000A4F6 6100FED2        	   448:          BSR     FORMREGA       ; A@
00:0000A4FA 1CFC0029        	   449:          MOVE.B  #')',(A6)+
00:0000A4FE 1CFC002B        	   450:          MOVE.B  #'+',(A6)+
00:0000A502 600005BA        	   451: CS11:    BRA     COMMON
                            	   452: 
                            	   453:          
                            	   454: 
00:0000A506 60000210        	   455: IQUICK:  BRA     IQUICKA        ; ADDQ  SUBQ
                            	   456: 
                            	   457: ;  BIT   5432109876543210
                            	   458: ;        0111...0........       FIXED
                            	   459: ;        ....RRR.........       DATA REGISTER
                            	   460: ;        ........DDDDDDDD       SIGN EXTENDED DATA
                            	   461: ;
                            	   462:          
                            	   463: 
                            	   464: IMOVEQ:  ;.align  2
00:0000A50A 1CFC0023        	   465:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	   466: 
00:0000A50E 3014            	   467:          MOVE.W  (A4),D0
00:0000A510 4880            	   468:          EXT.W   D0
00:0000A512 48C0            	   469:          EXT.L   D0
00:0000A514 6100FCAE        	   470:          BSR     HEX2DEC        ; DECIMAL
                            	   471: 
00:0000A518 1CC5            	   472:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   473: 
00:0000A51A EF5C            	   474:          ROL.W   #7,D4
00:0000A51C 6100FEBC        	   475:          BSR     FORMREGD
00:0000A520 60E0            	   476:          BRA.S   CS11           ; COMMON
                            	   477: 
00:0000A522 1CC0            	   478: SCHR:    MOVE.B  D0,(A6)+     ; OUTPUT STRING
00:0000A524 E088            	   479:          LSR.L   #8,D0
00:0000A526 66FA            	   480:          BNE.S   SCHR           ; MORE TO OUTPUT
00:0000A528 4E75            	   481:          RTS
                            	   482: 
                            	   483: ; MOVE FROM SR  (STATUS REGISTER)
                            	   484: ;
                            	   485:          
                            	   486: 
00:0000A52A 203C002C5253    	   487: IMVFSR:  MOVE.L  #$002c5253,D0 ; SR,
                            	   488: 
00:0000A530 61F0            	   489:          BSR.S   SCHR
00:0000A532 6100029E        	   490:          BSR     EEA            ; DATA ALTERABLE
00:0000A536 60CA            	   491:          BRA.S   CS11           ; COMMON
                            	   492: 
                            	   493: ; MOVE FROM USP (USER STACK POINTER)
                            	   494: ;
                            	   495:          
                            	   496: 
00:0000A538 203C2C505355    	   497: IMVFUSP: MOVE.L  #$2c505355,D0 ; USP,
00:0000A53E 61E2            	   498:          BSR.S   SCHR
00:0000A540 6100FE88        	   499:          BSR     FORMREGA
00:0000A544 60BC            	   500:          BRA.S   CS11           ; COMMON
                            	   501: 
                            	   502: ; MOVE TO SR (STATUS REGISTER)
                            	   503: ;
                            	   504:          
                            	   505: 
00:0000A546 3E3C0FFD        	   506: IMVTSR:  MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:0000A54A 61000286        	   507:          BSR     EEA
00:0000A54E 203C0052532C    	   508:          MOVE.L  #$0052532c,D0 ; ,SR
00:0000A554 61CC            	   509: IMVT44:  BSR.S   SCHR
00:0000A556 60AA            	   510:          BRA.S   CS11           ; COMMON
                            	   511: 
                            	   512: ; MOVE TO USP (USER STACK POINTER)
                            	   513: ;
                            	   514:          
                            	   515: 
00:0000A558 6100FE70        	   516: IMVTUSP: BSR     FORMREGA
00:0000A55C 203C5053552C    	   517:          MOVE.L  #$5053552c,D0 ; ,USP
00:0000A562 60F0            	   518:          BRA.S   IMVT44
                            	   519: 
                            	   520: ;  MOVE TO CCR (CONDITION CODE REGISTER)
                            	   521: ;
                            	   522:          
                            	   523: 
00:0000A564 3E3C0FFD        	   524: IMVTCCR: MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:0000A568 61000268        	   525:          BSR     EEA
00:0000A56C 203C5243432C    	   526:          MOVE.L  #$5243432c,D0 ; ,CCR
00:0000A572 60E0            	   527:          BRA.S   IMVT44
                            	   528: 
                            	   529: ;  BIT   5432109876543210
                            	   530: ;        0000...1..001...       FIXED
                            	   531: ;        ....XXX.........       DATA REGISTER
                            	   532: ;        ........0.......       MEMORY TO REGISTER
                            	   533: ;        ........1.......       REGISTER TO MEMORY
                            	   534: ;        .........0......       WORD
                            	   535: ;        .........1......       LONG
                            	   536: ;        .............XXX       ADDRESS REGISTER
                            	   537: ;
                            	   538:          
                            	   539: 
                            	   540: IMOVEP:  ;.align  2
00:0000A574 1AFC002E        	   541:          MOVE.B  #'.',(A5)+    ; D@,#(A@)
00:0000A578 303C4C57        	   542:          MOVE.W  #$4c57,D0    ; "LW"
00:0000A57C 08040006        	   543:          BTST    #6,D4
00:0000A580 6702            	   544:          BEQ.S   IMOVEP11       ; USE "W"
00:0000A582 E048            	   545:          LSR.W   #8,D0         ; USE "L"
00:0000A584 1AC0            	   546: IMOVEP11:MOVE.B  D0,(A5)+     ; LENGTH
                            	   547: 
00:0000A586 1814            	   548:          MOVE.B  (A4),D4
00:0000A588 E20C            	   549:          LSR.B   #1,D4
                            	   550: 
00:0000A58A 082C00070001    	   551:          BTST.B  #7,1(A4)
00:0000A590 670E            	   552:          BEQ.S   IMOVEP35
                            	   553: 
00:0000A592 6100FE46        	   554:          BSR     FORMREGD       ; D@,$HHHH(A@)
                            	   555: 
00:0000A596 1CC5            	   556:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   557: 
00:0000A598 3814            	   558:          MOVE.W  (A4),D4
00:0000A59A 6112            	   559:          BSR.S   IMOVEP66
00:0000A59C 6000051E        	   560: CS20:    BRA     COMMON4
                            	   561: 
00:0000A5A0 610C            	   562: IMOVEP35:BSR.S   IMOVEP66       ; $HHHH(A@),D@
                            	   563: 
00:0000A5A2 1CC5            	   564:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   565: 
00:0000A5A4 1814            	   566:          MOVE.B  (A4),D4
00:0000A5A6 E20C            	   567:          LSR.B   #1,D4
00:0000A5A8 6100FE30        	   568:          BSR     FORMREGD
00:0000A5AC 60EE            	   569:          BRA.S   CS20           ; COMMON4
                            	   570: 
00:0000A5AE 1CFC0024        	   571: IMOVEP66:MOVE.B  #'$',(A6)+    ; FORMAT DISPLACEMENT
00:0000A5B2 302C0002        	   572:          MOVE.W  2(A4),D0
00:0000A5B6 6100FC70        	   573:          BSR     PNT4HX
                            	   574: 
00:0000A5BA 1CFC0028        	   575:          MOVE.B  #'(',(A6)+
                            	   576: 
00:0000A5BE 3814            	   577:          MOVE.W  (A4),D4
00:0000A5C0 6100FE08        	   578:          BSR     FORMREGA
00:0000A5C4 1CFC0029        	   579:          MOVE.B  #')',(A6)+
00:0000A5C8 4E75            	   580:          RTS
                            	   581: 
                            	   582: SCOMMON:
00:0000A5CA 600004F2        	   583: 	bra COMMON         ; NOP RESET RTE RTR RTS TRAPV
                            	   584:         
                            	   585: 
00:0000A5CE 610000E4        	   586: ISCC:    BSR     ICCCC          ; GET REST OF OP-CODE
00:0000A5D2 610001FE        	   587:          BSR     EEA            ; DATA ALTERABLE
00:0000A5D6 60F2            	   588:          BRA.S   SCOMMON
                            	   589: 
                            	   590:          
                            	   591: 
                            	   592: IDBCC:   ;.align  2              ; DB--
00:0000A5D8 3814            	   593:          MOVE.W  (A4),D4
00:0000A5DA 6100FDFE        	   594:          BSR     FORMREGD
                            	   595: 
00:0000A5DE 1CC5            	   596:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
00:0000A5E0 1CFC0024        	   597:          MOVE.B  #'$',(A6)+    ; HEX FIELD TO FOLLOW
                            	   598: 
00:0000A5E4 610000CE        	   599:          BSR     ICCCC
00:0000A5E8 602C            	   600:          BRA.S   ICC55
                            	   601: 
                            	   602: ;  BIT   5432109876543210
                            	   603: ;        0110............       FIXED
                            	   604: ;        ....CCCC........       CONDITION
                            	   605: ;        ........DDDDDDD0       DISPLACEMENT
                            	   606: ;        ...............1       ERROR (ODD BOUNDRY DISPLACEMENT)
                            	   607: ;
                            	   608:          
                            	   609: 
                            	   610: ICC:     ;.align  2              ; B--
00:0000A5EA 610000C8        	   611:          BSR     ICCCC
                            	   612: 
00:0000A5EE 1CFC0024        	   613: IBSR:    MOVE.B  #'$',(A6)+    ; BSR.S BRA
                            	   614: 
00:0000A5F2 4A04            	   615:          TST.B   D4
00:0000A5F4 6720            	   616:          BEQ.S   ICC55          ; 16 BIT DISPLACEMENT
                            	   617: 
00:0000A5F6 1AFC002E        	   618:          MOVE.B  #'.',(A5)+
00:0000A5FA 1AFC0053        	   619:          MOVE.B  #'S',(A5)+
00:0000A5FE 4884            	   620:          EXT.W   D4            ; 8 BIT DISPLACEMENT
                            	   621: 
00:0000A600 48C4            	   622: ICC35:   EXT.L   D4            ; SIGN-EXTENDED DISPLACEMENT
00:0000A602 D8A9FFFC        	   623:          ADD.L   HISPC(A1),D4  ; + PROGRAM COUNTER
00:0000A606 5484            	   624:          ADDQ.L  #2,D4         ; + TWO
00:0000A608 2004            	   625:          MOVE.L  D4,D0
                            	   626: 
00:0000A60A E284            	   627:          ASR.L   #1,D4
00:0000A60C 650004D8        	   628:          BCS     FERROR         ; ODD BOUNDRY DISPLACEMENT
                            	   629: 
00:0000A610 6100FC1A        	   630:          BSR     PNT6HX
00:0000A614 60B4            	   631:          BRA.S   SCOMMON
                            	   632: 
00:0000A616 5483            	   633: ICC55:   ADDQ.L  #2,D3         ; SIZE
00:0000A618 382C0002        	   634:          MOVE.W  2(A4),D4
00:0000A61C 1AFC002E        	   635:          MOVE.B  #'.',(A5)+
00:0000A620 1AFC004C        	   636:          MOVE.B  #'L',(A5)+    ; .L FOR 16 BIT DISPLACEMENT
00:0000A624 60DA            	   637:          BRA.S   ICC35
                            	   638: 
                            	   639:          
                            	   640: ;                               ; BCHG  BCLR  BSET  BTST
                            	   641: ISETD:   ;.align  2              ; DYNAMIC BIT
00:0000A626 EF5C            	   642:          ROL.W   #7,D4
00:0000A628 6100FDB0        	   643:          BSR     FORMREGD       ; DATA REGISTER
                            	   644: 
00:0000A62C 1CC5            	   645: ISETD12: MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   646: 
00:0000A62E 3814            	   647:          MOVE.W  (A4),D4
00:0000A630 610001A0        	   648:          BSR     EEA            ; DATA ALTERABLE
00:0000A634 6094            	   649: CS18:    BRA.S   SCOMMON
                            	   650: 
                            	   651:          ;.align   4
                            	   652: 
                            	   653: ;                            BCHG  BCLR  BSET  BTST
                            	   654: ;  1ST WORD     .... .... ..XX XXXX    EA   DATA ALTERABLE ONLY
                            	   655: ;  2ND WORD     0000 0000 000Y YYYY    BIT NUMBER
                            	   656: ;
                            	   657: ISETS:   ;.align  2              ; STATIC BIT
00:0000A636 5483            	   658:          ADDQ.L  #2,D3         ; SIZE
00:0000A638 1CFC0023        	   659:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	   660: 
00:0000A63C 7000            	   661:          CLR.L   D0
00:0000A63E 302C0002        	   662:          MOVE.W  2(A4),D0     ; GET BIT POSITION FROM 2ND WORD
00:0000A642 2200            	   663:          MOVE.L  D0,D1
00:0000A644 EA89            	   664:          LSR.L   #5,D1
00:0000A646 6600049E        	   665:          BNE     FERROR
00:0000A64A 6100FB78        	   666:          BSR     HEX2DEC        ; DECIMAL
                            	   667: 
00:0000A64E 60DC            	   668:          BRA.S   ISETD12
                            	   669: 
                            	   670: ;   BIT  5432109876543210
                            	   671: ;        ....XXX.........       IMMEDIATE COUNT/REGISTER
                            	   672: ;        .......0........       RIGHT SHIFT
                            	   673: ;        .......1........       LEFT SHIFT
                            	   674: ;        ........00......       BYTE
                            	   675: ;        ........01......       WORD
                            	   676: ;        ........10......       LONG
                            	   677: ;        ....0...11......       WORD (MEMORY)
                            	   678: ;        ....0...11AAAAAA       EFFECTIVE ADDRESS
                            	   679: ;        ..........0.....       SHIFT IMMEDIATE COUNT
                            	   680: ;        ..........1.....       SHIFT COUNT (MODULO 64) IN DATA REGISTER
                            	   681: ;
                            	   682:          ;.align   4
                            	   683: 
                            	   684: ISHIFT:  ;.align   2             ; AS-  LS-  RO-  ROX-
00:0000A650 303C4C52        	   685:          MOVE.W  #$4c52,D0    ; "LR"
00:0000A654 08040008        	   686:          BTST    #8,D4         ; DIRECTION BIT
00:0000A658 6702            	   687:          BEQ.S   ISHIFT13       ; RIGHT
00:0000A65A E048            	   688:          LSR.W   #8,D0         ; LEFT
00:0000A65C 1AC0            	   689: ISHIFT13:MOVE.B  D0,(A5)+     ; DIRECTION; "L" OR "R"
                            	   690: 
00:0000A65E 3014            	   691:          MOVE.W  (A4),D0
00:0000A660 024000C0        	   692:          ANDI.W  #$00C0,D0
00:0000A664 0C4000C0        	   693:          CMPI.W  #$00C0,D0
00:0000A668 6730            	   694:          BEQ.S   ISHIFTM1       ; MEMORY SHIFT
                            	   695: 
00:0000A66A 610000DC        	   696:          BSR     FORMSIZE
                            	   697: 
00:0000A66E EF5C            	   698:          ROL.W   #7,D4
00:0000A670 0804000C        	   699:          BTST    #12,D4        ; I/R BIT
00:0000A674 6616            	   700:          BNE.S   ISHIFT33       ; COUNT IN REGISTER
                            	   701: 
00:0000A676 02040007        	   702:          ANDI.B  #$07,D4      ; IMMEDIATE COUNT
00:0000A67A 6604            	   703:          BNE.S   ISHIFT23
00:0000A67C 00040008        	   704:          ORI.B   #$08,D4      ; CHANGE ZERO TO EIGHT
00:0000A680 00040030        	   705: ISHIFT23:ORI.B   #'0',D4
00:0000A684 1CFC0023        	   706:          MOVE.B  #'#',(A6)+
00:0000A688 1CC4            	   707:          MOVE.B  D4,(A6)+
00:0000A68A 6004            	   708:          BRA.S   ISHIFT44
                            	   709: 
00:0000A68C 6100FD4C        	   710: ISHIFT33:BSR     FORMREGD
                            	   711: 
00:0000A690 1CC5            	   712: ISHIFT44:MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   713: 
00:0000A692 3814            	   714:          MOVE.W  (A4),D4
00:0000A694 6100FD44        	   715:          BSR     FORMREGD
00:0000A698 609A            	   716: CS17:    BRA.S   CS18           ; COMMON
                            	   717: 
00:0000A69A 1AFC002E        	   718: ISHIFTM1:MOVE.B  #'.',(A5)+    ; PERIOD
00:0000A69E 1AFC0057        	   719:          MOVE.B  #'W',(A5)+    ; .WORD
                            	   720: 
00:0000A6A2 0804000B        	   721:          BTST    #11,D4
00:0000A6A6 6600043E        	   722:          BNE     FERROR         ; BIT 11 MUST BE ZERO
                            	   723: 
00:0000A6AA 3E3C01FC        	   724:          MOVE.W  #$1FC,D7     ; MEMORY ALTERABLE ADDRESSING
00:0000A6AE 61000122        	   725:          BSR     EEA
00:0000A6B2 60E4            	   726:          BRA.S   CS17           ; COMMON
                            	   727: 
00:0000A6B4 700F            	   728: ICCCC:   MOVEQ   #$0F,D0      ; APPEND CONDITION CODE
00:0000A6B6 C014            	   729:          AND.B   (A4),D0      ; D0 = CCC
00:0000A6B8 E388            	   730:          LSL.L   #1,D0         ; D0 = CCC;2
                            	   731: 
00:0000A6BA 323B0010        	   732:          MOVE.W  BRTBL(PC,D0.W),D1 ; GET BRANCH MNEMONIC
00:0000A6BE 1AC1            	   733:          MOVE.B  D1,(A5)+     ; (REVERSED) FROM THE TABLE
00:0000A6C0 E049            	   734:          LSR.W   #8,D1         ; AND ADD THE NONBLANK PORTION
00:0000A6C2 0C010020        	   735:          CMPI.B  #BLANK,D1     ; TO THE BUFFER.
00:0000A6C6 6702            	   736:          BEQ.S   ICCCC9
00:0000A6C8 1AC1            	   737:          MOVE.B  D1,(A5)+
00:0000A6CA 4E75            	   738: ICCCC9:  RTS
                            	   739: 
00:0000A6CC 2054            	   740: BRTBL:   dc.b  " T"           ; "T " BRA ACCEPTED
00:0000A6CE 2046            	   741:          dc.b  " F"           ; "F "
00:0000A6D0 4948            	   742:          dc.b  "IH"           ; "HI"
00:0000A6D2 534C            	   743:          dc.b  "SL"           ; "LS"
00:0000A6D4 4343            	   744:          dc.b  "CC"           ; "CC"
00:0000A6D6 5343            	   745:          dc.b  "SC"           ; "CS"
00:0000A6D8 454E            	   746:          dc.b  "EN"           ; "NE"
00:0000A6DA 5145            	   747:          dc.b  "QE"           ; "EQ"
00:0000A6DC 4356            	   748:          dc.b  "CV"           ; "VC"
00:0000A6DE 5356            	   749:          dc.b  "SV"           ; "VS"
00:0000A6E0 4C50            	   750:          dc.b  "LP"           ; "PL"
00:0000A6E2 494D            	   751:          dc.b  "IM"           ; "MI"
00:0000A6E4 4547            	   752:          dc.b  "EG"           ; "GE"
00:0000A6E6 544C            	   753:          dc.b  "TL"           ; "LT"
00:0000A6E8 5447            	   754:          dc.b  "TG"           ; "GT"
00:0000A6EA 454C            	   755:          dc.b  "EL"           ; "LE"
                            	   756: 
                            	   757: ;   BIT  5432109876543210
                            	   758: ;        ....RRRMMM......    DESTINATION REGISTER MODE
                            	   759: ;        ..........MMMRRR    SOURCE MODE REGISTER
                            	   760: ;
                            	   761: ; IF BYTE SIZE; ADDRESS DIRECT NOT ALLOWED AS SOURCE
                            	   762: ;
                            	   763: 					even
                            	   764: IMOVEA1: ;.align  2
00:0000A6EC 3E3C0FFF        	   765:          MOVE.W  #$FFF,D7     ; ALL MODES
00:0000A6F0 610000E0        	   766:          BSR     EEA
                            	   767: 
00:0000A6F4 1CC5            	   768:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   769: 
00:0000A6F6 3814            	   770:          MOVE.W  (A4),D4      ; ....RRRMMM......
00:0000A6F8 E24C            	   771:          LSR.W   #1,D4         ; .....RRRMMM.....
00:0000A6FA EA0C            	   772:          LSR.B   #5,D4         ; .....RRR.....MMM
00:0000A6FC E05C            	   773:          ROR.W   #8,D4         ; .....MMM.....RRR
00:0000A6FE EB0C            	   774:          LSL.B   #5,D4         ; .....MMMRRR.....
00:0000A700 EA4C            	   775:          LSR.W   #5,D4         ; ..........MMMRRR
                            	   776: 
                            	   777: ; IF .BYTE DESTINATION A@ NOT ALLOWED
00:0000A702 3E3C01FF        	   778:          MOVE.W  #$1FF,D7     ; DATA ALTERABLE + A@
00:0000A706 1014            	   779:          MOVE.B  (A4),D0
00:0000A708 0C000001        	   780:          CMPI.B  #$01,D0
00:0000A70C 6604            	   781:          BNE.S   IMOVE19        ; NOT BYTE SIZE
                            	   782: 
00:0000A70E 3E3C01FD        	   783:          MOVE.W  #$1FD,D7     ; DATA ALTERABLE
                            	   784: IMOVE19:
                            	   785: 
00:0000A712 610000BE        	   786:          BSR     EEA
00:0000A716 602C            	   787:          BRA.S   CS19           ; COMMON
                            	   788: 
                            	   789: ;  IF BYTE; ADDRESS REGISTER DIRECT NOT ALLOWED
                            	   790: IQUICKA: ;.align  2              ; ADDQ  SUBQ
00:0000A718 612E            	   791:          BSR.S   FORMSIZE
                            	   792: 
00:0000A71A 1CFC0023        	   793:          MOVE.B  #'#',(A6)+
00:0000A71E EF5C            	   794:          ROL.W   #7,D4
00:0000A720 02040007        	   795:          ANDI.B  #7,D4
00:0000A724 6604            	   796:          BNE.S   IQUICK21
00:0000A726 00040008        	   797:          ORI.B   #8,D4         ; MAKE ZERO INTO EIGHT
00:0000A72A 00040030        	   798: IQUICK21:ORI.B   #'0',D4       ; MAKE ASCII
00:0000A72E 1CC4            	   799:          MOVE.B  D4,(A6)+
                            	   800: 
00:0000A730 1CC5            	   801:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   802: 
00:0000A732 3814            	   803:          MOVE.W  (A4),D4
                            	   804: 
00:0000A734 3014            	   805:          MOVE.W  (A4),D0
00:0000A736 024000C0        	   806:          ANDI.W  #$00C0,D0
00:0000A73A 6704            	   807:          BEQ.S   IQUICK31       ; DATA ALTERABLE
00:0000A73C 3E3C01FF        	   808:          MOVE.W  #$1FF,D7     ; ALTERABLE ADDRESSING
00:0000A740 61000090        	   809: IQUICK31:BSR     EEA
00:0000A744 60000378        	   810: CS19:    BRA     COMMON
                            	   811: 
                            	   812: ;  BIT   5432109876543210
                            	   813: ;        ........00......       BYTE
                            	   814: ;        ........01......       WORD
                            	   815: ;        ........10......       LONG
                            	   816: ;        ........11......       ERROR
                            	   817: ;
                            	   818: FORMSIZE: ;.align  2
00:0000A748 3414            	   819:          MOVE.W  (A4),D2
00:0000A74A 1AFC002E        	   820:          MOVE.B  #'.',(A5)+    ; STORE PERIOD
00:0000A74E EC4A            	   821:          LSR.W   #6,D2
00:0000A750 02420003        	   822:          ANDI.W  #$03,D2
00:0000A754 6606            	   823:          BNE.S   FORM91
00:0000A756 1AFC0042        	   824:          MOVE.B  #'B',(A5)+    ; STORE "B"
00:0000A75A 6016            	   825:          BRA.S   FORM95
                            	   826: 
00:0000A75C 103C0057        	   827: FORM91:  MOVE.B  #'W',D0
00:0000A760 0C020001        	   828:          CMPI.B  #1,D2
00:0000A764 670A            	   829:          BEQ.S   FORM93
00:0000A766 103C004C        	   830:          MOVE.B  #'L',D0
00:0000A76A 0C020002        	   831:          CMPI.B  #2,D2
00:0000A76E 665E            	   832:          BNE.S   FE10           ; FERROR
00:0000A770 1AC0            	   833: FORM93:  MOVE.B  D0,(A5)+     ; STORE "W" OR "L"
00:0000A772 4E75            	   834: FORM95:  RTS
                            	   835: 
00:0000A774 6100FC64        	   836: EA000:   BSR     FORMREGD
00:0000A778 08070000        	   837:          BTST    #0,D7
00:0000A77C 6750            	   838:          BEQ.S   FE10           ; FERROR
00:0000A77E 4E75            	   839:          RTS
                            	   840: 
00:0000A780 6100FC48        	   841: EA001:   BSR     FORMREGA
00:0000A784 08070001        	   842:          BTST    #1,D7
00:0000A788 6744            	   843:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:0000A78A 4E75            	   844:          RTS
                            	   845: 
00:0000A78C 1CFC0028        	   846: EA010:   MOVE.B  #'(',(A6)+
00:0000A790 6100FC38        	   847:          BSR     FORMREGA
00:0000A794 1CFC0029        	   848:          MOVE.B  #')',(A6)+
00:0000A798 08070002        	   849:          BTST    #2,D7
00:0000A79C 6730            	   850:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:0000A79E 4E75            	   851:          RTS
                            	   852: 
00:0000A7A0 1CFC0028        	   853: EA011:   MOVE.B  #'(',(A6)+
00:0000A7A4 6100FC24        	   854:          BSR     FORMREGA
00:0000A7A8 1CFC0029        	   855:          MOVE.B  #')',(A6)+
00:0000A7AC 1CFC002B        	   856:          MOVE.B  #'+',(A6)+
00:0000A7B0 08070003        	   857:          BTST    #3,D7
00:0000A7B4 6718            	   858:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:0000A7B6 4E75            	   859: EA011RTS:RTS
                            	   860: 
00:0000A7B8 1CFC002D        	   861: EA100:   MOVE.B  #'-',(A6)+
00:0000A7BC 1CFC0028        	   862:          MOVE.B  #'(',(A6)+
00:0000A7C0 6100FC08        	   863:          BSR     FORMREGA
00:0000A7C4 1CFC0029        	   864:          MOVE.B  #')',(A6)+
00:0000A7C8 08070004        	   865:          BTST    #4,D7
00:0000A7CC 66E8            	   866:          BNE.S   EA011RTS
00:0000A7CE 60000316        	   867: FE10:    BRA     FERROR         ; THIS MODE NOT ALLOWED
                            	   868: 
                            	   869: ;  ENTER       A4 = POINTER TO FIRST WORD
                            	   870: ;              D3 = OFFSET TO EXTENSION
                            	   871: ;              D4 = VALUE TO PROCESS
                            	   872: ;              D7 = MODES ALLOWED MASK
                            	   873: ;
                            	   874: EEA:     ;.align  2
00:0000A7D2 2004            	   875: 	move.l D4,D0
00:0000A7D4 E648            	   876: 	lsr.w #3,D0
00:0000A7D6 02400007        	   877: 	andi.w #$7,D0
00:0000A7DA 6798            	   878: 	beq.s EA000
00:0000A7DC 0C000001        	   879: 	cmpi.b #1,D0
00:0000A7E0 679E            	   880: 	beq.s EA001
00:0000A7E2 0C000002        	   881: 	cmpi.b #2,D0
00:0000A7E6 67A4            	   882: 	beq.s EA010
00:0000A7E8 0C000003        	   883: 	cmpi.b #3,D0
00:0000A7EC 67B2            	   884: 	beq.s EA011
00:0000A7EE 0C000004        	   885: 	cmpi.b #4,D0
00:0000A7F2 67C4            	   886: 	beq.s EA100
00:0000A7F4 0C000005        	   887: 	cmpi.b #5,D0
00:0000A7F8 6760            	   888: 	beq.s EA101
00:0000A7FA 0C000007        	   889: 	cmpi.b #7,D0
00:0000A7FE 6770            	   890: 	beq.s EA111
                            	   891: 
                            	   892: ;    EXTENSION WORD
                            	   893: ;   BIT  5432109876543210
                            	   894: ;        0...............    DATA REGISTER
                            	   895: ;        1...............    ADDRESS REGISTER
                            	   896: ;        .RRR............    REGISTER
                            	   897: ;        ....0...........    SIGN EXTENDED, LOW ORDER INTEGER IN INDEX REG
                            	   898: ;        ....1...........    LONG VALUE IN INDEX REGISTER
                            	   899: ;        .....000........
                            	   900: ;        ........DDDDDDDD    DISPLACEMENT INTEGER
                            	   901: ;
                            	   902: ; EA110            ADDRESS REGISTER INDIRECT WITH INDEX
                            	   903: 
00:0000A800 08070006        	   904:          BTST    #6,D7
00:0000A804 67C8            	   905:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
                            	   906: 
00:0000A806 32343000        	   907:          MOVE.W  (A4,D3.W),D1
00:0000A80A 02410700        	   908:          ANDI.W  #$0700,D1
00:0000A80E 66BE            	   909:          BNE.S   FE10           ; FERROR  BITS 10-8 MUST BE ZERO
                            	   910: 
00:0000A810 30343000        	   911:          MOVE.W  (A4,D3.W),D0  ; D0 = DISPLACEMENT
00:0000A814 4880            	   912:          EXT.W   D0
00:0000A816 48C0            	   913:          EXT.L   D0
00:0000A818 6100F9AA        	   914:          BSR     HEX2DEC        ; DECIMAL
00:0000A81C 1CFC0028        	   915:          MOVE.B  #'(',(A6)+    ; (
                            	   916: 
00:0000A820 6100FBA8        	   917:          BSR     FORMREGA       ; XX(A@
                            	   918: 
00:0000A824 1CFC002C        	   919:          MOVE.B  #',',(A6)+    ; XX(A@,
                            	   920: 
00:0000A828 18343000        	   921:          MOVE.B  (A4,D3.W),D4
00:0000A82C E804            	   922:          ASR.B   #4,D4
00:0000A82E 6A06            	   923:          BPL.S   EA1105
00:0000A830 6100FB98        	   924:          BSR     FORMREGA
00:0000A834 6004            	   925:          BRA.S   EA1107
                            	   926: 
00:0000A836 6100FBA2        	   927: EA1105:  BSR     FORMREGD
00:0000A83A 1CFC002E        	   928: EA1107:  MOVE.B  #'.',(A6)+    ; XX(A@,X@.
                            	   929: 
00:0000A83E 38343000        	   930:          MOVE.W  (A4,D3.W),D4 ; D4 = R@
00:0000A842 103C0057        	   931:          MOVE.B  #'W',D0       ; ..........W
00:0000A846 0804000B        	   932:          BTST    #11,D4
00:0000A84A 6704            	   933:          BEQ.S   EA1109
00:0000A84C 103C004C        	   934:          MOVE.B  #'L',D0       ; ..........L
00:0000A850 1CC0            	   935: EA1109:  MOVE.B  D0,(A6)+
00:0000A852 1CFC0029        	   936:          MOVE.B  #')',(A6)+    ; ...........)
00:0000A856 5483            	   937:          ADDQ.L  #2,D3
00:0000A858 4E75            	   938:          RTS
                            	   939: 
                            	   940: ; ADDRESS REGISTER INDIRECT WITH DISPLACEMENT
                            	   941: ;
                            	   942: EA101:
00:0000A85A 08070005        	   943: 	btst #5,D7         	; 101000;   DIS(A@)
00:0000A85E 6756            	   944: 	beq.s FE11          ; FERROR;  THIS MODE NOT ALLOWED
00:0000A860 30343000        	   945: 	move.w (A4,D3.W),D0
00:0000A864 48C0            	   946: 	ext.l D0
00:0000A866 6100F95C        	   947: 	bsr HEX2DEC        	; DECIMAL
00:0000A86A 5483            	   948: 	addq.l #2,D3        ; SIZE
00:0000A86C 6000FF1E        	   949: 	bra EA010
                            	   950: 
                            	   951: ;  111000        ABSOLUTE SHORT
                            	   952: ;  111001        ABSOLUTE LONG
                            	   953: ;  111010        PROGRAM COUNTER WITH DISPLACEMENT
                            	   954: ;  111011        PROGRAM COUNTER WITH INDEX
                            	   955: ;  111100        IMMEDIATE OR STATUS REG
                            	   956: ;
                            	   957: EA111:
00:0000A870 02440007        	   958: 	andi.w #7,D4
00:0000A874 6618            	   959: 	bne.s EA1112
00:0000A876 08070007        	   960: 	btst #7,D7
00:0000A87A 673A            	   961: 	beq.s FE11           	; FERROR;  THIS MODE NOT ALLOWED
00:0000A87C 30343000        	   962: 	move.w (A4,D3.W),D0 	; 111000;   ABSOLUTE SHORT
00:0000A880 48C0            	   963: 	ext.l D0
00:0000A882 1CFC0024        	   964: 	move.b #'$',(A6)+
00:0000A886 6100F9B0        	   965: 	bsr PNT8HX         		; SIGN EXTENDED VALUE
00:0000A88A 5483            	   966: 	addq.l #2,D3         	; SIZE + 2
00:0000A88C 4E75            	   967: 	rts
                            	   968: 
                            	   969: EA1112:
00:0000A88E 0C040001        	   970: 	cmpi.b #1,D4
00:0000A892 6616            	   971: 	bne.s EA1113
00:0000A894 08070008        	   972: 	btst #8,D7
00:0000A898 671C            	   973: 	beq.s FE11          	; FERROR;  THIS MODE NOT ALLOWED
00:0000A89A 1CFC0024        	   974: 	move.b #'$',(A6)+    	; HEX
00:0000A89E 20343000        	   975: 	move.l (A4,D3.W),D0  	; 111001;     ABSOLUTE LONG
00:0000A8A2 6100F994        	   976: 	bsr PNT8HX
                            	   977: 	;-       MOVE.B  #'.',(A6)+    ; FORCE LONG FORMAT
                            	   978: 	;-       MOVE.B  #'L',(A6)+    ; IE   .L
00:0000A8A6 5883            	   979: 	addq.l #4,D3
00:0000A8A8 4E75            	   980: 	rts
                            	   981: 
                            	   982: EA1113:
00:0000A8AA 0C040002        	   983: 	cmpi.b #2,D4
00:0000A8AE 662C            	   984: 	bne.s EA1114
00:0000A8B0 08070009        	   985: 	btst #9,D7
00:0000A8B4 6604            	   986: 	bne.s EA1113A
                            	   987: FE11:
00:0000A8B6 6000022E        	   988: 	bra FERROR         	; THIS MODE NOT ALLOWED
                            	   989: 
                            	   990: EA1113A:
00:0000A8BA 30343000        	   991: 	move.w (A4,D3.W),D0  ; 111010;  PC + DISPLACEMENT  DESTINATION(PC)
00:0000A8BE 48C0            	   992: 	ext.l D0
00:0000A8C0 D0A9FFFC        	   993: 	add.l HISPC(A1),D0
00:0000A8C4 5480            	   994: 	addq.l #2,D0
00:0000A8C6 1CFC0024        	   995: 	move.b #'$',(A6)+    ; HEX "$"
00:0000A8CA 6100F96C        	   996: 	bsr PNT8HX         ; DESTINATION
00:0000A8CE 203C29435028    	   997: 	move.l #$29435028,D0  ; (PC)
00:0000A8D4 6100FC4C        	   998: 	bsr SCHR           ; STORE WORD
00:0000A8D8 5483            	   999: 	addq.l #2,D3         ; SIZE
00:0000A8DA 4E75            	  1000: 	rts
                            	  1001: 
                            	  1002: EA1114:
00:0000A8DC 0C040003        	  1003: 	cmpi.b #3,D4
00:0000A8E0 6664            	  1004: 	bne.s EA1115
                            	  1005: 
                            	  1006: ; PROGRAM COUNTER WITH INDEX    DESTINATION(PC,R@.X)
                            	  1007: ;
                            	  1008: ;        5432109876543210       SECOND WORD
                            	  1009: ;        0...............       DATA REGISTER
                            	  1010: ;        1...............       ADDRESS REGISTER
                            	  1011: ;        .XXX............       REGISTER
                            	  1012: ;        ....0...........       SIGN-EXTENDED, LOW ORDER WORD INTEGER
                            	  1013: ;                               ..IN INDEX REGISTER
                            	  1014: ;        ....1...........       LONG VALUE IN INDEX REGISTER
                            	  1015: ;        .....000........
                            	  1016: ;        ........XXXXXXXX       DISPLACEMENT INTEGER
                            	  1017: ;
00:0000A8E2 0807000A        	  1018:          BTST    #10,D7
00:0000A8E6 67CE            	  1019:          BEQ.S   FE11           ; FERROR  THIS MODE NOT ASLLOWED
                            	  1020: 
00:0000A8E8 32343000        	  1021:          MOVE.W  (A4,D3.W),D1
00:0000A8EC 02410700        	  1022:          ANDI.W  #$0700,D1
00:0000A8F0 66C4            	  1023:          BNE.S   FE11           ; FERROR;  BITS 10-8 MUST BE ZERO
                            	  1024: 
00:0000A8F2 10343001        	  1025:          MOVE.B  1(A4,D3.W),D0 ; 111100;   DESTINATION(PC,R@.X)
00:0000A8F6 4880            	  1026:          EXT.W   D0
00:0000A8F8 48C0            	  1027:          EXT.L   D0
00:0000A8FA D0A9FFFC        	  1028:          ADD.L   HISPC(A1),D0
00:0000A8FE 5480            	  1029:          ADDQ.L  #2,D0
00:0000A900 1CFC0024        	  1030:          MOVE.B  #'$',(A6)+    ; HEX "$"
00:0000A904 6100F932        	  1031:          BSR     PNT8HX         ; DESTINATION
                            	  1032: 
00:0000A908 203C2C435028    	  1033:          MOVE.L  #$2c435028,D0
00:0000A90E 6100FC12        	  1034:          BSR     SCHR           ; DES(PC,
                            	  1035: 
00:0000A912 38343000        	  1036:          MOVE.W  (A4,D3.W),D4
00:0000A916 E95C            	  1037:          ROL.W   #4,D4
00:0000A918 08040003        	  1038:          BTST    #3,D4
00:0000A91C 6706            	  1039:          BEQ.S   EAF25
00:0000A91E 6100FAAA        	  1040:          BSR     FORMREGA
00:0000A922 6004            	  1041:          BRA.S   EAF27
00:0000A924 6100FAB4        	  1042: EAF25:   BSR     FORMREGD       ; DES(PC,R@
                            	  1043: EAF27:
                            	  1044: 
00:0000A928 1CFC002E        	  1045:          MOVE.B  #'.',(A6)+    ; DES(PC,R@.
                            	  1046: 
00:0000A92C 38343000        	  1047:          MOVE.W  (A4,D3.W),D4
00:0000A930 303C4C57        	  1048:          MOVE.W  #$4c57,D0    ; "LW"
00:0000A934 0804000B        	  1049:          BTST    #11,D4
00:0000A938 6702            	  1050:          BEQ.S   EAF35
00:0000A93A E048            	  1051:          LSR.W   #8,D0
00:0000A93C 1CC0            	  1052: EAF35:   MOVE.B  D0,(A6)+     ; DES(PC,R@.X
                            	  1053: 
00:0000A93E 1CFC0029        	  1054:          MOVE.B  #')',(A6)+    ; DES(PC,R@.X)
00:0000A942 5483            	  1055:          ADDQ.L  #2,D3
00:0000A944 4E75            	  1056:          RTS
                            	  1057: 
                            	  1058: ;   BIT  5432109876543210
                            	  1059: ;        ..........111100       ; FIRST WORD;  #<IMMEDIATE>
                            	  1060: ;
00:0000A946 0C040004        	  1061: EA1115:  CMPI.B  #4,D4
00:0000A94A 6600FF6A        	  1062:          BNE     FE11           ; FERROR
                            	  1063: 
00:0000A94E 0807000B        	  1064:          BTST    #11,D7
00:0000A952 6700FF62        	  1065:          BEQ     FE11           ; FERROR;  THIS MODE NOT ALLOWED
                            	  1066: 
00:0000A956 1CFC0023        	  1067:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	  1068: 
00:0000A95A 122DFFFF        	  1069:          MOVE.B  -1(A5),D1
00:0000A95E 0C01004C        	  1070:          CMPI.B  #'L',D1
00:0000A962 6724            	  1071:          BEQ.S   EA11155        ; LONG
                            	  1072: 
00:0000A964 30343000        	  1073:          MOVE.W  (A4,D3.W),D0
                            	  1074: 
00:0000A968 0C010042        	  1075:          CMPI.B  #'B',D1
00:0000A96C 6610            	  1076:          BNE.S   EA11153        ; .WORD
                            	  1077: 
                            	  1078: ; BYTE SIZE; DATA ALLOWED
                            	  1079: ;  0000 0000 XXXX XXXX
                            	  1080: ;  1111 1111 1XXX XXXX
00:0000A96E 2200            	  1081:          MOVE.L  D0,D1
00:0000A970 E049            	  1082:          LSR.W   #8,D1
00:0000A972 670A            	  1083:          BEQ.S   EA11153
00:0000A974 2200            	  1084:          MOVE.L  D0,D1
00:0000A976 EE41            	  1085:          ASR.W   #7,D1
00:0000A978 5241            	  1086:          ADDQ.W  #1,D1
00:0000A97A 6600FF3A        	  1087:          BNE     FE11           ; FERROR
                            	  1088: 
00:0000A97E 48C0            	  1089: EA11153: EXT.L   D0
00:0000A980 6100F842        	  1090:          BSR     HEX2DEC
00:0000A984 5483            	  1091:          ADDQ.L  #2,D3
00:0000A986 4E75            	  1092:          RTS
                            	  1093: 
00:0000A988 20343000        	  1094: EA11155: MOVE.L  (A4,D3.W),D0
00:0000A98C 6100F836        	  1095:          BSR     HEX2DEC
00:0000A990 5883            	  1096:          ADDQ.L  #4,D3         ; SIZE
00:0000A992 4E75            	  1097:          RTS
                            	  1098: 
00:0000A994 1AFC002E        	  1099: MOVEMS:  MOVE.B  #'.',(A5)+    ; PERIOD
00:0000A998 303C4C57        	  1100:          MOVE.W  #$4c57,D0    ; "LW"
00:0000A99C 08040006        	  1101:          BTST    #6,D4
00:0000A9A0 6702            	  1102:          BEQ.S   MOVEMS2
00:0000A9A2 E048            	  1103:          LSR.W   #8,D0
00:0000A9A4 1AC0            	  1104: MOVEMS2: MOVE.B  D0,(A5)+     ; SIZE
00:0000A9A6 4E75            	  1105:          RTS
                            	  1106: 
                            	  1107: ; MOVEM - REGISTER EXPANSION
                            	  1108: ;
                            	  1109: MOVEMR:  ;.align  2
00:0000A9A8 342C0002        	  1110:          MOVE.W  2(A4),D2     ; D2 = SECOND WORD
00:0000A9AC 7020            	  1111:          MOVEQ   #$20,D0      ; D0 = SPACE
00:0000A9AE 7E2F            	  1112:          MOVEQ   #$2F,D7      ; D7 = /
00:0000A9B0 538E            	  1113:          SUBQ.L  #1,A6         ; ADJUST STORE POINTER
00:0000A9B2 7A30            	  1114:          MOVEQ   #$30,D5      ; D5 = REGISTER #
00:0000A9B4 383C4144        	  1115:          MOVE.W  #$4144,D4    ; "AD" D4 = REG CLASS
                            	  1116: 
00:0000A9B8 0302            	  1117: MOVEMR11:BTST    D1,D2
00:0000A9BA 6730            	  1118:          BEQ.S   MOVEMR77       ; BIT RESET
                            	  1119: 
00:0000A9BC B016            	  1120:          CMP.B   (A6),D0      ; BIT SET
00:0000A9BE 6612            	  1121:          BNE.S   MOVEMR44       ; NOT SPACE
                            	  1122: 
00:0000A9C0 1D440001        	  1123: MOVEMR33:MOVE.B  D4,1(A6)     ; REG TYPE
00:0000A9C4 1D450002        	  1124:          MOVE.B  D5,2(A6)     ; REG #
00:0000A9C8 1D7C002D0003    	  1125:          MOVE.B  #'-',3(A6)    ; -
00:0000A9CE 568E            	  1126:          ADDQ.L  #3,A6
00:0000A9D0 602E            	  1127:          BRA.S   MOVEMR88
                            	  1128: 
                            	  1129: MOVEMR44:
00:0000A9D2 0C16002C        	  1130: 	cmpi.b #',',(A6)
00:0000A9D6 67E8            	  1131: 	beq.s MOVEMR33      ; COMMA SEPARATOR
00:0000A9D8 BE16            	  1132: 	cmp.b (A6),D7      	; / SEPARATOR
00:0000A9DA 67E4            	  1133: 	beq.s MOVEMR33
00:0000A9DC 1D440001        	  1134: 	move.b D4,1(A6)     ; REG TYPE
00:0000A9E0 1D450002        	  1135: 	move.b D5,2(A6)     ; REG #
00:0000A9E4 1D7C002D0003    	  1136: 	move.b #'-',3(A6)   ; - SEPARATOR
00:0000A9EA 6014            	  1137: 	bra.s MOVEMR88
                            	  1138: 
                            	  1139: MOVEMR77:
00:0000A9EC 0C16002C        	  1140: 	cmpi.b #',',(A6)
00:0000A9F0 670E            	  1141: 	beq.s MOVEMR88       ; COMMA
00:0000A9F2 B016            	  1142: 	cmp.b (A6),D0
00:0000A9F4 670A            	  1143: 	beq.s MOVEMR88       ; SPACE
00:0000A9F6 B02E0001        	  1144: 	cmp.b 1(A6),D0
00:0000A9FA 6702            	  1145: 	beq.s MOVEMR79       ; SPACE
00:0000A9FC 568E            	  1146: 	addq.l #3,A6
                            	  1147: MOVEMR79:
00:0000A9FE 1C87            	  1148: 	move.b D7,(A6)      ; / SEPARATOR
                            	  1149: 
                            	  1150: MOVEMR88:
00:0000AA00 5285            	  1151: 	addq.l #1,D5
00:0000AA02 D286            	  1152: 	add.l D6,D1        ; D1 = BIT POSITION
00:0000AA04 0C050038        	  1153: 	cmpi.b #'8',D5
00:0000AA08 66AE            	  1154: 	bne.s MOVEMR11
00:0000AA0A B016            	  1155: 	cmp.b (A6),D0      ; SPACE
00:0000AA0C 670A            	  1156: 	beq.s MOVEMR94
00:0000AA0E B02E0001        	  1157: 	cmp.b 1(A6),D0     ; SPACE
00:0000AA12 6704            	  1158: 	beq.s MOVEMR94
00:0000AA14 568E            	  1159: 	addq.l #3,A6
00:0000AA16 1C87            	  1160: 	move.b D7,(A6)      ; /   SEPARATOR
                            	  1161: 
                            	  1162: MOVEMR94:
00:0000AA18 1A3C0030        	  1163: 	move.b #'0',D5       	; RESET REG TO ZERO
00:0000AA1C E04C            	  1164: 	lsr.w #8,D4         	; CHANGE REG TYPE
00:0000AA1E 6698            	  1165: 	bne.s MOVEMR11       	; MORE
00:0000AA20 1C80            	  1166: 	move.b D0,(A6)      	; SPACE
00:0000AA22 4E75            	  1167: 	rts
                            	  1168: 
                            	  1169: DCODE68K:
00:0000AA24 4E51FFF0        	  1170: 	link A1,#-LOCVARSZ 	; CREATE A FRAME FOR THE
00:0000AA28 48E91007FFF0    	  1171: 	movem.l D0-D2/A4,DDATA(A1)  ; CODE AND ITS PC.  A4
00:0000AA2E 49E9FFF0        	  1172: 	lea DDATA(A1),A4 		; POINTS TO THE CODE.
00:0000AA32 264D            	  1173: 	move.l A5,A3        ; A3 = START OF OUTPUT BUFFER
00:0000AA34 2C4D            	  1174: 	move.l A5,A6
00:0000AA36 703F            	  1175: 	moveq #BUFSIZE,D0
                            	  1176: DEC311:
00:0000AA38 1CFC0020        	  1177:   move.b #BLANK,(a6)+  ; SPACE FILL BUFFER
00:0000AA3C 5380            	  1178: 	subq.l #1,D0
00:0000AA3E 66F8            	  1179: 	bne.s DEC311
00:0000AA40 421E            	  1180: 	clr.b (a6)+					; NULL temrinate
00:0000AA42 2C4B            	  1181: 	move.l A3,A6        ; FORMAT ADDRESS
00:0000AA44 2029FFFC        	  1182: 	move.l HISPC(A1),D0
00:0000AA48 6100F7F2        	  1183: 	bsr FRELADDR
                            	  1184: 
                            	  1185: ; CHECK FOR KNOWN ILLEGAL CODES
00:0000AA4C 3014            	  1186: 	move.w (a4),d0
00:0000AA4E 4BFA00C0        	  1187: 	lea KI(PC),a5
00:0000AA52 2C4D            	  1188: 	move.l a5,a6
00:0000AA54 548E            	  1189: 	add.l #KIEND-KI,a6
                            	  1190: DEC404:
00:0000AA56 B05D            	  1191:   cmp.w (a5)+,d0
00:0000AA58 671A            	  1192: 	beq.s FE12           ; FERROR;  ILLEGAL CODE
00:0000AA5A BBCE            	  1193: 	cmp.l a6,a5
00:0000AA5C 66F8            	  1194: 	bne.s DEC404
                            	  1195: 
                            	  1196: ; LOOK FOR MATCH OF OP-CODE
                            	  1197: ;
00:0000AA5E 4BFA00B2        	  1198: 	lea TBL(PC),A5   		; A5 = POINTER TO DECODE TABLE
00:0000AA62 4DFA0366        	  1199: 	lea TBLE(PC),A6  		; A6 = POINTER TO END OF TABLE
                            	  1200: DEC411:
00:0000AA66 3014            	  1201: 	move.w (A4),D0      ;  FIRST WORD
00:0000AA68 C05D            	  1202: 	and.w (A5)+,D0     	;  MASK
00:0000AA6A B05D            	  1203: 	cmp.w (A5)+,D0
00:0000AA6C 6708            	  1204: 	beq.s DEC425        ; FOUND MATCH
00:0000AA6E 588D            	  1205: 	addq.l #4,A5        ; UPDATE POINTER
00:0000AA70 BBCE            	  1206: 	cmp.l A6,A5
00:0000AA72 65F2            	  1207: 	blo.s DEC411        ; MORE TABLE
                            	  1208: FE12:
00:0000AA74 6070            	  1209: 	bra.s FERROR        ; ILLEGAL INSTRUCTION
                            	  1210: DEC425:
00:0000AA76 7C00            	  1211:   clr.l D6
00:0000AA78 3C1D            	  1212: 	move.w (A5)+,D6     ; D6 = (GOTO OFFSET)/4
                            	  1213: ;         LSL.L   #2,D6
00:0000AA7A 7E00            	  1214: 	clr.l D7
00:0000AA7C 3E1D            	  1215: 	move.w (A5)+,D7     ; D7 = INDEX TO OP-CODE
                            	  1216: 
                            	  1217: ; MOVE OP-CODE TO BUFFER
                            	  1218: ;
00:0000AA7E 41FA034A        	  1219: 	lea OPCTBL(PC),A0
                            	  1220: DEC510:
00:0000AA82 4A47            	  1221:   tst D7
00:0000AA84 6708            	  1222: 	beq.s DEC530         	; AT INDEX
                            	  1223: DEC515:
00:0000AA86 4A18            	  1224:   tst.b (A0)+
00:0000AA88 6AFC            	  1225: 	bpl.s DEC515         	; MOVE THROUGH FIELD
00:0000AA8A 5387            	  1226: 	subq.l #1,D7
00:0000AA8C 60F4            	  1227: 	bra.s DEC510
                            	  1228: DEC530:
00:0000AA8E 701F            	  1229: 	moveq #FOC,D0
00:0000AA90 4BF30000        	  1230: 	lea.l (A3,D0.W),A5 		; A5 = STORE POINTER  OP-CODE
                            	  1231: DEC535:
00:0000AA94 1018            	  1232:   move.b (A0)+,D0
00:0000AA96 08800007        	  1233: 	bclr #7,D0
00:0000AA9A 6604            	  1234: 	bne.s DEC537         	; END OF MOVE
00:0000AA9C 1AC0            	  1235: 	move.b D0,(A5)+
00:0000AA9E 60F4            	  1236: 	bra.s DEC535
                            	  1237: DEC537:
00:0000AAA0 1AC0            	  1238:   move.b D0,(A5)+
                            	  1239: 
                            	  1240: ; CALCULATE GOTO AND GO
                            	  1241: ;
00:0000AAA2 7602            	  1242: 	moveq #2,D3         ; D3= SIZE
00:0000AAA4 41FAF7F4        	  1243: 	lea X(PC),A0
00:0000AAA8 D1C6            	  1244: 	add.l D6,A0
00:0000AAAA 7027            	  1245: 	moveq #FOP,D0
00:0000AAAC 4DF30000        	  1246: 	lea.l (A3,D0.W),A6 	; A6 = POINTER FOR OPERAND
00:0000AAB0 3814            	  1247: 	move.w (A4),D4      ; D4 = FIRST WORD
00:0000AAB2 1A3C002C        	  1248: 	move.b #',',D5      ; D5 = CONTAINS ASCII COMMA
00:0000AAB6 3E3C01FD        	  1249: 	move.w #$1FD,D7     ; D7 = DATA ALTERABLE MODES ALLOWED
00:0000AABA 4ED0            	  1250: 	jmp (A0)
                            	  1251: 
                            	  1252: ;	 A3 = pointer to beginning of buffer
                            	  1253: ;  A4 = POINTER TO DATA IN FRAME CREATED BY "LINK A1,..."
                            	  1254: ;  A5 = POINTER STORE OP-CODE
                            	  1255: ;  A6 = POINTER STORE OPERAND
                            	  1256: ;  D3 = SIZE = 2 BYTES
                            	  1257: ;  D4 = FIRST WORD
                            	  1258: ;  D7 = ADDRESS MODES ALLOWED ($1FD) DATA ALTERABLE
                            	  1259: 
                            	  1260: COMMON4:
00:0000AABC 5483            	  1261: 	addq.l #2,D3         	; SIZE = 4
                            	  1262: COMMON:
00:0000AABE 2C03            	  1263: 	move.l D3,D6        	; D6 = SIZE
00:0000AAC0 1CFC0020        	  1264: 	move.b #BLANK,(A6)+ 	; SPACE AS LAST CHAR
00:0000AAC4 2A4E            	  1265: 	move.l A6,A5        	; SAVE END OF BUFFER POINTER
00:0000AAC6 700A            	  1266: 	moveq #FDATA,D0
00:0000AAC8 4DF30000        	  1267: 	lea.l (A3,D0.W),A6
                            	  1268: COMMON35:
00:0000AACC 301C            	  1269: 	move.w (A4)+,D0     	; GET NEXT WORD OF DATA.
00:0000AACE 54A9FFFC        	  1270: 	addq.l #2,HISPC(A1)  	; ADJUST PROG COUNTER.
00:0000AAD2 6100F754        	  1271: 	bsr PNT4HX         		; FORMAT DATA. (A6)+
00:0000AAD6 5503            	  1272: 	subq.b #2,D3
00:0000AAD8 66F2            	  1273: 	bne.s COMMON35
00:0000AADA 2C4D            	  1274: 	move.l A5,A6        	; A6 = RESTORE END POINTER
00:0000AADC 2A4B            	  1275: 	move.l A3,A5        	; A5 =  BEGINNING OF BUFFER
00:0000AADE 2869FFFC        	  1276: 	move.l HISPC(A1),A4 	; MOVE THE UPDATED PC
00:0000AAE2 4E59            	  1277: 	unlk A1            		; TO A4 AND UNDO FRAME.
00:0000AAE4 4E75            	  1278: 	rts
                            	  1279: 
                            	  1280: FERROR:  ;.align  2
                            	  1281: ; ILLEGAL INSTRUCTION
                            	  1282: ;
00:0000AAE6 701F            	  1283: 	moveq #FOC,D0
00:0000AAE8 4DF30000        	  1284: 	lea.l (A3,D0.W),A6
00:0000AAEC 4BFA0018        	  1285: 	lea MSG111(PC),A5
                            	  1286: FERROR35:
00:0000AAF0 101D            	  1287: 	move.b (A5)+,D0
00:0000AAF2 0C000004        	  1288: 	cmpi.b #EOT,D0
00:0000AAF6 6704            	  1289: 	beq.s FERROR39
00:0000AAF8 1CC0            	  1290: 	move.b D0,(A6)+
00:0000AAFA 60F4            	  1291: 	bra.s FERROR35
                            	  1292: FERROR39:
00:0000AAFC 3014            	  1293: 	move.w (A4),D0
00:0000AAFE 6100F728        	  1294: 	bsr PNT4HX
00:0000AB02 7602            	  1295: 	moveq #2,D3         ; SIZE
00:0000AB04 60B8            	  1296: 	bra.s COMMON
                            	  1297: MSG111:  
00:0000AB06 44432E5720202020	  1298: 	dc.b "DC.W    $"
00:0000AB0E 24
00:0000AB0F 04              	  1299: 	dc.b EOT
                            	  1300: 
                            	  1301: KI:
00:0000AB10 4AFB            	  1302: 	dc.w $4AFB         ; KNOWN ILLEGAL CODES
                            	  1303: KIEND:   
                            	  1304: 	even
                            	  1305: 
                            	  1306: ;  \1   MASK
                            	  1307: ;  \2   OP-CODE PATTERN
                            	  1308: ;  \3   GOTO OFFSET
                            	  1309: ;  \4   INDEX TO OP-CODE
                            	  1310: C68:     macro arg1,arg2,arg3,arg4
                            	  1311:          DC.W    $\1
                            	  1312:          DC.W    $\2
                            	  1313:          DC.W    (\3-X)
                            	  1314:          DC.w    \4
                            	  1315:          endm
                            	  1316: 
                            	  1317: 				 even
                            	  1318: TBL:     ;.align  2
                            	  1319:          C68     FEC0,E6C0,ISHIFT,56           ; RO
00:0000AB12 FEC0            	     1M          DC.W    $FEC0
00:0000AB14 E6C0            	     2M          DC.W    $E6C0
00:0000AB16 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000AB18 0038            	     4M          DC.w    56
                            	  1320:          C68     FEC0,E4C0,ISHIFT,57           ; ROX
00:0000AB1A FEC0            	     1M          DC.W    $FEC0
00:0000AB1C E4C0            	     2M          DC.W    $E4C0
00:0000AB1E 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000AB20 0039            	     4M          DC.w    57
                            	  1321:          C68     FEC0,E2C0,ISHIFT,55           ; LS
00:0000AB22 FEC0            	     1M          DC.W    $FEC0
00:0000AB24 E2C0            	     2M          DC.W    $E2C0
00:0000AB26 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000AB28 0037            	     4M          DC.w    55
                            	  1322:          C68     FEC0,E0C0,ISHIFT,54           ; AS
00:0000AB2A FEC0            	     1M          DC.W    $FEC0
00:0000AB2C E0C0            	     2M          DC.W    $E0C0
00:0000AB2E 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000AB30 0036            	     4M          DC.w    54
                            	  1323:          C68     F018,E018,ISHIFT,56           ; RO
00:0000AB32 F018            	     1M          DC.W    $F018
00:0000AB34 E018            	     2M          DC.W    $E018
00:0000AB36 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000AB38 0038            	     4M          DC.w    56
                            	  1324:          C68     F018,E010,ISHIFT,57           ; ROX
00:0000AB3A F018            	     1M          DC.W    $F018
00:0000AB3C E010            	     2M          DC.W    $E010
00:0000AB3E 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000AB40 0039            	     4M          DC.w    57
                            	  1325:          C68     F018,E008,ISHIFT,55           ; LS
00:0000AB42 F018            	     1M          DC.W    $F018
00:0000AB44 E008            	     2M          DC.W    $E008
00:0000AB46 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000AB48 0037            	     4M          DC.w    55
                            	  1326:          C68     F018,E000,ISHIFT,54           ; AS
00:0000AB4A F018            	     1M          DC.W    $F018
00:0000AB4C E000            	     2M          DC.W    $E000
00:0000AB4E 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000AB50 0036            	     4M          DC.w    54
                            	  1327:          C68     F0C0,D0C0,FORM10EX,4          ; ADD       <EA>,A@
00:0000AB52 F0C0            	     1M          DC.W    $F0C0
00:0000AB54 D0C0            	     2M          DC.W    $D0C0
00:0000AB56 016A            	     3M          DC.W    (FORM10EX-X)
00:0000AB58 0004            	     4M          DC.w    4
                            	  1328:          C68     F130,D100,FORM12,53           ; ADDX
00:0000AB5A F130            	     1M          DC.W    $F130
00:0000AB5C D100            	     2M          DC.W    $D100
00:0000AB5E 0208            	     3M          DC.W    (FORM12-X)
00:0000AB60 0035            	     4M          DC.w    53
                            	  1329:          C68     F000,D000,FORM10EX,4          ; ADD
00:0000AB62 F000            	     1M          DC.W    $F000
00:0000AB64 D000            	     2M          DC.W    $D000
00:0000AB66 016A            	     3M          DC.W    (FORM10EX-X)
00:0000AB68 0004            	     4M          DC.w    4
                            	  1330:          C68     F1F8,C188,FORM9,50            ; EXG
00:0000AB6A F1F8            	     1M          DC.W    $F1F8
00:0000AB6C C188            	     2M          DC.W    $C188
00:0000AB6E 0160            	     3M          DC.W    (FORM9-X)
00:0000AB70 0032            	     4M          DC.w    50
                            	  1331:          C68     F1F8,C148,FORM8,50            ; EXG
00:0000AB72 F1F8            	     1M          DC.W    $F1F8
00:0000AB74 C148            	     2M          DC.W    $C148
00:0000AB76 0152            	     3M          DC.W    (FORM8-X)
00:0000AB78 0032            	     4M          DC.w    50
                            	  1332:          C68     F1F8,C140,FORM7,50            ; EXG
00:0000AB7A F1F8            	     1M          DC.W    $F1F8
00:0000AB7C C140            	     2M          DC.W    $C140
00:0000AB7E 0146            	     3M          DC.W    (FORM7-X)
00:0000AB80 0032            	     4M          DC.w    50
                            	  1333:          C68     F1F0,C100,FORM12,49           ; ABCD
00:0000AB82 F1F0            	     1M          DC.W    $F1F0
00:0000AB84 C100            	     2M          DC.W    $C100
00:0000AB86 0208            	     3M          DC.W    (FORM12-X)
00:0000AB88 0031            	     4M          DC.w    49
                            	  1334:          C68     F1C0,C1C0,FORM6D,48           ; MULS
00:0000AB8A F1C0            	     1M          DC.W    $F1C0
00:0000AB8C C1C0            	     2M          DC.W    $C1C0
00:0000AB8E 0120            	     3M          DC.W    (FORM6D-X)
00:0000AB90 0030            	     4M          DC.w    48
                            	  1335:          C68     F1C0,C0C0,FORM6D,47           ; MULU
00:0000AB92 F1C0            	     1M          DC.W    $F1C0
00:0000AB94 C0C0            	     2M          DC.W    $C0C0
00:0000AB96 0120            	     3M          DC.W    (FORM6D-X)
00:0000AB98 002F            	     4M          DC.w    47
                            	  1336:          C68     F000,C000,FORM10,2            ; AND
00:0000AB9A F000            	     1M          DC.W    $F000
00:0000AB9C C000            	     2M          DC.W    $C000
00:0000AB9E 01A8            	     3M          DC.W    (FORM10-X)
00:0000ABA0 0002            	     4M          DC.w    2
                            	  1337:          C68     F0C0,B0C0,FORM10EX,6          ; CMP     <EA>,A@
00:0000ABA2 F0C0            	     1M          DC.W    $F0C0
00:0000ABA4 B0C0            	     2M          DC.W    $B0C0
00:0000ABA6 016A            	     3M          DC.W    (FORM10EX-X)
00:0000ABA8 0006            	     4M          DC.w    6
                            	  1338:          C68     F138,B108,FORM12A,46          ; CMPM
00:0000ABAA F138            	     1M          DC.W    $F138
00:0000ABAC B108            	     2M          DC.W    $B108
00:0000ABAE 0244            	     3M          DC.W    (FORM12A-X)
00:0000ABB0 002E            	     4M          DC.w    46
                            	  1339:          C68     F100,B100,FORM10,5            ; EOR
00:0000ABB2 F100            	     1M          DC.W    $F100
00:0000ABB4 B100            	     2M          DC.W    $B100
00:0000ABB6 01A8            	     3M          DC.W    (FORM10-X)
00:0000ABB8 0005            	     4M          DC.w    5
                            	  1340:          C68     F000,B000,FORM10EX,6          ; CMP
00:0000ABBA F000            	     1M          DC.W    $F000
00:0000ABBC B000            	     2M          DC.W    $B000
00:0000ABBE 016A            	     3M          DC.W    (FORM10EX-X)
00:0000ABC0 0006            	     4M          DC.w    6
                            	  1341:          C68     F0C0,90C0,FORM10EX,44         ; SUB       <EA>,A@
00:0000ABC2 F0C0            	     1M          DC.W    $F0C0
00:0000ABC4 90C0            	     2M          DC.W    $90C0
00:0000ABC6 016A            	     3M          DC.W    (FORM10EX-X)
00:0000ABC8 002C            	     4M          DC.w    44
                            	  1342:          C68     F130,9100,FORM12,45           ; SUBX
00:0000ABCA F130            	     1M          DC.W    $F130
00:0000ABCC 9100            	     2M          DC.W    $9100
00:0000ABCE 0208            	     3M          DC.W    (FORM12-X)
00:0000ABD0 002D            	     4M          DC.w    45
                            	  1343:          C68     F000,9000,FORM10EX,44         ; SUB
00:0000ABD2 F000            	     1M          DC.W    $F000
00:0000ABD4 9000            	     2M          DC.W    $9000
00:0000ABD6 016A            	     3M          DC.W    (FORM10EX-X)
00:0000ABD8 002C            	     4M          DC.w    44
                            	  1344:          C68     F1F0,8100,FORM12,43           ; SBCD
00:0000ABDA F1F0            	     1M          DC.W    $F1F0
00:0000ABDC 8100            	     2M          DC.W    $8100
00:0000ABDE 0208            	     3M          DC.W    (FORM12-X)
00:0000ABE0 002B            	     4M          DC.w    43
                            	  1345:          C68     F1C0,81C0,FORM6D,42           ; DIVS
00:0000ABE2 F1C0            	     1M          DC.W    $F1C0
00:0000ABE4 81C0            	     2M          DC.W    $81C0
00:0000ABE6 0120            	     3M          DC.W    (FORM6D-X)
00:0000ABE8 002A            	     4M          DC.w    42
                            	  1346:          C68     F1C0,80C0,FORM6D,41           ; DIVU
00:0000ABEA F1C0            	     1M          DC.W    $F1C0
00:0000ABEC 80C0            	     2M          DC.W    $80C0
00:0000ABEE 0120            	     3M          DC.W    (FORM6D-X)
00:0000ABF0 0029            	     4M          DC.w    41
                            	  1347:          C68     F000,8000,FORM10,40           ; OR
00:0000ABF2 F000            	     1M          DC.W    $F000
00:0000ABF4 8000            	     2M          DC.W    $8000
00:0000ABF6 01A8            	     3M          DC.W    (FORM10-X)
00:0000ABF8 0028            	     4M          DC.w    40
                            	  1348:          C68     F100,7000,IMOVEQ,39           ; MOVEQ
00:0000ABFA F100            	     1M          DC.W    $F100
00:0000ABFC 7000            	     2M          DC.W    $7000
00:0000ABFE 0270            	     3M          DC.W    (IMOVEQ-X)
00:0000AC00 0027            	     4M          DC.w    39
                            	  1349:          C68     FF00,6100,IBSR,51             ; BSR
00:0000AC02 FF00            	     1M          DC.W    $FF00
00:0000AC04 6100            	     2M          DC.W    $6100
00:0000AC06 0354            	     3M          DC.W    (IBSR-X)
00:0000AC08 0033            	     4M          DC.w    51
                            	  1350:          C68     FF00,6000,IBSR,65             ; BRA
00:0000AC0A FF00            	     1M          DC.W    $FF00
00:0000AC0C 6000            	     2M          DC.W    $6000
00:0000AC0E 0354            	     3M          DC.W    (IBSR-X)
00:0000AC10 0041            	     4M          DC.w    65
                            	  1351:          C68     F000,6000,ICC,38              ; B
00:0000AC12 F000            	     1M          DC.W    $F000
00:0000AC14 6000            	     2M          DC.W    $6000
00:0000AC16 0350            	     3M          DC.W    (ICC-X)
00:0000AC18 0026            	     4M          DC.w    38
                            	  1352:          C68     F0F8,50C8,IDBCC,37            ; DB
00:0000AC1A F0F8            	     1M          DC.W    $F0F8
00:0000AC1C 50C8            	     2M          DC.W    $50C8
00:0000AC1E 033E            	     3M          DC.W    (IDBCC-X)
00:0000AC20 0025            	     4M          DC.w    37
                            	  1353:          C68     F0C0,50C0,ISCC,36             ; S
00:0000AC22 F0C0            	     1M          DC.W    $F0C0
00:0000AC24 50C0            	     2M          DC.W    $50C0
00:0000AC26 0334            	     3M          DC.W    (ISCC-X)
00:0000AC28 0024            	     4M          DC.w    36
                            	  1354:          C68     F100,5100,IQUICK,35           ; SUBQ
00:0000AC2A F100            	     1M          DC.W    $F100
00:0000AC2C 5100            	     2M          DC.W    $5100
00:0000AC2E 026C            	     3M          DC.W    (IQUICK-X)
00:0000AC30 0023            	     4M          DC.w    35
                            	  1355:          C68     F100,5000,IQUICK,34           ; ADDQ
00:0000AC32 F100            	     1M          DC.W    $F100
00:0000AC34 5000            	     2M          DC.W    $5000
00:0000AC36 026C            	     3M          DC.W    (IQUICK-X)
00:0000AC38 0022            	     4M          DC.w    34
                            	  1356:          C68     F1C0,41C0,FORM6A,33           ; LEA
00:0000AC3A F1C0            	     1M          DC.W    $F1C0
00:0000AC3C 41C0            	     2M          DC.W    $41C0
00:0000AC3E 0110            	     3M          DC.W    (FORM6A-X)
00:0000AC40 0021            	     4M          DC.w    33
                            	  1357:          C68     F1C0,4180,FORM6D,32           ; CHK
00:0000AC42 F1C0            	     1M          DC.W    $F1C0
00:0000AC44 4180            	     2M          DC.W    $4180
00:0000AC46 0120            	     3M          DC.W    (FORM6D-X)
00:0000AC48 0020            	     4M          DC.w    32
                            	  1358:          C68     FFC0,4EC0,FORM11SL,31         ; JMP
00:0000AC4A FFC0            	     1M          DC.W    $FFC0
00:0000AC4C 4EC0            	     2M          DC.W    $4EC0
00:0000AC4E 01E4            	     3M          DC.W    (FORM11SL-X)
00:0000AC50 001F            	     4M          DC.w    31
                            	  1359:          C68     FFC0,4E80,FORM11SL,30         ; JSR
00:0000AC52 FFC0            	     1M          DC.W    $FFC0
00:0000AC54 4E80            	     2M          DC.W    $4E80
00:0000AC56 01E4            	     3M          DC.W    (FORM11SL-X)
00:0000AC58 001E            	     4M          DC.w    30
                            	  1360:          C68     FFFF,4E77,SCOMMON,29          ; RTR
00:0000AC5A FFFF            	     1M          DC.W    $FFFF
00:0000AC5C 4E77            	     2M          DC.W    $4E77
00:0000AC5E 0330            	     3M          DC.W    (SCOMMON-X)
00:0000AC60 001D            	     4M          DC.w    29
                            	  1361:          C68     FFFF,4E76,SCOMMON,28          ; TRAPV
00:0000AC62 FFFF            	     1M          DC.W    $FFFF
00:0000AC64 4E76            	     2M          DC.W    $4E76
00:0000AC66 0330            	     3M          DC.W    (SCOMMON-X)
00:0000AC68 001C            	     4M          DC.w    28
                            	  1362:          C68     FFFF,4E75,SCOMMON,27          ; RTS
00:0000AC6A FFFF            	     1M          DC.W    $FFFF
00:0000AC6C 4E75            	     2M          DC.W    $4E75
00:0000AC6E 0330            	     3M          DC.W    (SCOMMON-X)
00:0000AC70 001B            	     4M          DC.w    27
                            	  1363:          C68     FFFF,4E73,SCOMMON,26          ; RTE
00:0000AC72 FFFF            	     1M          DC.W    $FFFF
00:0000AC74 4E73            	     2M          DC.W    $4E73
00:0000AC76 0330            	     3M          DC.W    (SCOMMON-X)
00:0000AC78 001A            	     4M          DC.w    26
                            	  1364:          C68     FFFF,4E72,ISTOP,25            ; STOP
00:0000AC7A FFFF            	     1M          DC.W    $FFFF
00:0000AC7C 4E72            	     2M          DC.W    $4E72
00:0000AC7E 004A            	     3M          DC.W    (ISTOP-X)
00:0000AC80 0019            	     4M          DC.w    25
                            	  1365:          C68     FFFF,4E71,SCOMMON,24          ; NOP
00:0000AC82 FFFF            	     1M          DC.W    $FFFF
00:0000AC84 4E71            	     2M          DC.W    $4E71
00:0000AC86 0330            	     3M          DC.W    (SCOMMON-X)
00:0000AC88 0018            	     4M          DC.w    24
                            	  1366:          C68     FFFF,4E70,SCOMMON,23          ; RESET
00:0000AC8A FFFF            	     1M          DC.W    $FFFF
00:0000AC8C 4E70            	     2M          DC.W    $4E70
00:0000AC8E 0330            	     3M          DC.W    (SCOMMON-X)
00:0000AC90 0017            	     4M          DC.w    23
                            	  1367:          C68     FFF8,4E68,IMVFUSP,60          ; MOVE FROM USP
00:0000AC92 FFF8            	     1M          DC.W    $FFF8
00:0000AC94 4E68            	     2M          DC.W    $4E68
00:0000AC96 029E            	     3M          DC.W    (IMVFUSP-X)
00:0000AC98 003C            	     4M          DC.w    60
                            	  1368:          C68     FFF8,4E60,IMVTUSP,60          ; MOVE TO USP
00:0000AC9A FFF8            	     1M          DC.W    $FFF8
00:0000AC9C 4E60            	     2M          DC.W    $4E60
00:0000AC9E 02BE            	     3M          DC.W    (IMVTUSP-X)
00:0000ACA0 003C            	     4M          DC.w    60
                            	  1369:          C68     FFF8,4E58,FORM5,22            ; UNLINK
00:0000ACA2 FFF8            	     1M          DC.W    $FFF8
00:0000ACA4 4E58            	     2M          DC.W    $4E58
00:0000ACA6 010C            	     3M          DC.W    (FORM5-X)
00:0000ACA8 0016            	     4M          DC.w    22
                            	  1370:          C68     FFF8,4E50,ILINK,21            ; LINK
00:0000ACAA FFF8            	     1M          DC.W    $FFF8
00:0000ACAC 4E50            	     2M          DC.W    $4E50
00:0000ACAE 00D6            	     3M          DC.W    (ILINK-X)
00:0000ACB0 0015            	     4M          DC.w    21
                            	  1371:          C68     FFF0,4E40,FORM4,20            ; TRAP
00:0000ACB2 FFF0            	     1M          DC.W    $FFF0
00:0000ACB4 4E40            	     2M          DC.W    $4E40
00:0000ACB6 00FA            	     3M          DC.W    (FORM4-X)
00:0000ACB8 0014            	     4M          DC.w    20
                            	  1372:          C68     FF80,4C80,IMOVEMTR,15         ; MOVEM FROM REGISTERS
00:0000ACBA FF80            	     1M          DC.W    $FF80
00:0000ACBC 4C80            	     2M          DC.W    $4C80
00:0000ACBE 002E            	     3M          DC.W    (IMOVEMTR-X)
00:0000ACC0 000F            	     4M          DC.w    15
                            	  1373:          C68     FFC0,4AC0,FORM1A,19           ; TAS
00:0000ACC2 FFC0            	     1M          DC.W    $FFC0
00:0000ACC4 4AC0            	     2M          DC.W    $4AC0
00:0000ACC6 00F0            	     3M          DC.W    (FORM1A-X)
00:0000ACC8 0013            	     4M          DC.w    19
                            	  1374:          C68     FF00,4A00,FORM1,18            ; TST
00:0000ACCA FF00            	     1M          DC.W    $FF00
00:0000ACCC 4A00            	     2M          DC.W    $4A00
00:0000ACCE 00EC            	     3M          DC.W    (FORM1-X)
00:0000ACD0 0012            	     4M          DC.w    18
                            	  1375:          C68     FFF8,48C0,FORM3,17            ; EXT.L
00:0000ACD2 FFF8            	     1M          DC.W    $FFF8
00:0000ACD4 48C0            	     2M          DC.W    $48C0
00:0000ACD6 00F6            	     3M          DC.W    (FORM3-X)
00:0000ACD8 0011            	     4M          DC.w    17
                            	  1376:          C68     FFF8,4880,FORM3,16            ; EXT.W
00:0000ACDA FFF8            	     1M          DC.W    $FFF8
00:0000ACDC 4880            	     2M          DC.W    $4880
00:0000ACDE 00F6            	     3M          DC.W    (FORM3-X)
00:0000ACE0 0010            	     4M          DC.w    16
                            	  1377:          C68     FF80,4880,IMOVEMFR,15         ; MOVEA TO REGISTERS
00:0000ACE2 FF80            	     1M          DC.W    $FF80
00:0000ACE4 4880            	     2M          DC.W    $4880
00:0000ACE6 0000            	     3M          DC.W    (IMOVEMFR-X)
00:0000ACE8 000F            	     4M          DC.w    15
                            	  1378:          C68     FFF8,4840,FORM3,14            ; SWAP
00:0000ACEA FFF8            	     1M          DC.W    $FFF8
00:0000ACEC 4840            	     2M          DC.W    $4840
00:0000ACEE 00F6            	     3M          DC.W    (FORM3-X)
00:0000ACF0 000E            	     4M          DC.w    14
                            	  1379:          C68     FFC0,4840,FORM11,13           ; PEA
00:0000ACF2 FFC0            	     1M          DC.W    $FFC0
00:0000ACF4 4840            	     2M          DC.W    $4840
00:0000ACF6 01DC            	     3M          DC.W    (FORM11-X)
00:0000ACF8 000D            	     4M          DC.w    13
                            	  1380:          C68     FFC0,4800,FORM1A,12           ; NBCD
00:0000ACFA FFC0            	     1M          DC.W    $FFC0
00:0000ACFC 4800            	     2M          DC.W    $4800
00:0000ACFE 00F0            	     3M          DC.W    (FORM1A-X)
00:0000AD00 000C            	     4M          DC.w    12
                            	  1381:          C68     FFC0,46C0,IMVTSR,59           ; MOVE TO SR
00:0000AD02 FFC0            	     1M          DC.W    $FFC0
00:0000AD04 46C0            	     2M          DC.W    $46C0
00:0000AD06 02AC            	     3M          DC.W    (IMVTSR-X)
00:0000AD08 003B            	     4M          DC.w    59
                            	  1382:          C68     FF00,4600,FORM1,11            ; NOT
00:0000AD0A FF00            	     1M          DC.W    $FF00
00:0000AD0C 4600            	     2M          DC.W    $4600
00:0000AD0E 00EC            	     3M          DC.W    (FORM1-X)
00:0000AD10 000B            	     4M          DC.w    11
                            	  1383:          C68     FFC0,44C0,IMVTCCR,59          ; MOVE TO CCR
00:0000AD12 FFC0            	     1M          DC.W    $FFC0
00:0000AD14 44C0            	     2M          DC.W    $44C0
00:0000AD16 02CA            	     3M          DC.W    (IMVTCCR-X)
00:0000AD18 003B            	     4M          DC.w    59
                            	  1384:          C68     FF00,4400,FORM1,10            ; NEG
00:0000AD1A FF00            	     1M          DC.W    $FF00
00:0000AD1C 4400            	     2M          DC.W    $4400
00:0000AD1E 00EC            	     3M          DC.W    (FORM1-X)
00:0000AD20 000A            	     4M          DC.w    10
                            	  1385:          C68     FF00,4200,FORM1,9             ; CLR
00:0000AD22 FF00            	     1M          DC.W    $FF00
00:0000AD24 4200            	     2M          DC.W    $4200
00:0000AD26 00EC            	     3M          DC.W    (FORM1-X)
00:0000AD28 0009            	     4M          DC.w    9
                            	  1386:          C68     FFC0,40C0,IMVFSR,59           ; MOVE.W  FROM  SR
00:0000AD2A FFC0            	     1M          DC.W    $FFC0
00:0000AD2C 40C0            	     2M          DC.W    $40C0
00:0000AD2E 0290            	     3M          DC.W    (IMVFSR-X)
00:0000AD30 003B            	     4M          DC.w    59
                            	  1387:          C68     FF00,4000,FORM1,8             ; NEGX
00:0000AD32 FF00            	     1M          DC.W    $FF00
00:0000AD34 4000            	     2M          DC.W    $4000
00:0000AD36 00EC            	     3M          DC.W    (FORM1-X)
00:0000AD38 0008            	     4M          DC.w    8
                            	  1388:          C68     F000,3000,IMOVE,59            ; MOVE.W
00:0000AD3A F000            	     1M          DC.W    $F000
00:0000AD3C 3000            	     2M          DC.W    $3000
00:0000AD3E 00D2            	     3M          DC.W    (IMOVE-X)
00:0000AD40 003B            	     4M          DC.w    59
                            	  1389:          C68     F000,2000,IMOVE,60            ; MOVE.L
00:0000AD42 F000            	     1M          DC.W    $F000
00:0000AD44 2000            	     2M          DC.W    $2000
00:0000AD46 00D2            	     3M          DC.W    (IMOVE-X)
00:0000AD48 003C            	     4M          DC.w    60
                            	  1390:          C68     F000,1000,IMOVE,58            ; MOVE.B
00:0000AD4A F000            	     1M          DC.W    $F000
00:0000AD4C 1000            	     2M          DC.W    $1000
00:0000AD4E 00D2            	     3M          DC.W    (IMOVE-X)
00:0000AD50 003A            	     4M          DC.w    58
                            	  1391:          C68     FF00,0C00,IMMED,6             ; CMP       #
00:0000AD52 FF00            	     1M          DC.W    $FF00
00:0000AD54 0C00            	     2M          DC.W    $0C00
00:0000AD56 005E            	     3M          DC.W    (IMMED-X)
00:0000AD58 0006            	     4M          DC.w    6
                            	  1392:          C68     FF00,0A00,IMMED,5             ; EOR       #
00:0000AD5A FF00            	     1M          DC.W    $FF00
00:0000AD5C 0A00            	     2M          DC.W    $0A00
00:0000AD5E 005E            	     3M          DC.W    (IMMED-X)
00:0000AD60 0005            	     4M          DC.w    5
                            	  1393:          C68     FF00,0600,IMMED,4             ; ADD       #
00:0000AD62 FF00            	     1M          DC.W    $FF00
00:0000AD64 0600            	     2M          DC.W    $0600
00:0000AD66 005E            	     3M          DC.W    (IMMED-X)
00:0000AD68 0004            	     4M          DC.w    4
                            	  1394:          C68     FF00,0400,IMMED,3             ; SUB       #
00:0000AD6A FF00            	     1M          DC.W    $FF00
00:0000AD6C 0400            	     2M          DC.W    $0400
00:0000AD6E 005E            	     3M          DC.W    (IMMED-X)
00:0000AD70 0003            	     4M          DC.w    3
                            	  1395:          C68     FF00,0200,IMMED,2             ; AND       #
00:0000AD72 FF00            	     1M          DC.W    $FF00
00:0000AD74 0200            	     2M          DC.W    $0200
00:0000AD76 005E            	     3M          DC.W    (IMMED-X)
00:0000AD78 0002            	     4M          DC.w    2
                            	  1396:          C68     FF00,0000,IMMED,1             ; OR        #
00:0000AD7A FF00            	     1M          DC.W    $FF00
00:0000AD7C 0000            	     2M          DC.W    $0000
00:0000AD7E 005E            	     3M          DC.W    (IMMED-X)
00:0000AD80 0001            	     4M          DC.w    1
                            	  1397:          C68     F138,0108,IMOVEP,0            ; MOVEP
00:0000AD82 F138            	     1M          DC.W    $F138
00:0000AD84 0108            	     2M          DC.W    $0108
00:0000AD86 02DA            	     3M          DC.W    (IMOVEP-X)
00:0000AD88 0000            	     4M          DC.w    0
                            	  1398:          C68     FFC0,08C0,ISETS,64            ; BSET
00:0000AD8A FFC0            	     1M          DC.W    $FFC0
00:0000AD8C 08C0            	     2M          DC.W    $08C0
00:0000AD8E 039C            	     3M          DC.W    (ISETS-X)
00:0000AD90 0040            	     4M          DC.w    64
                            	  1399:          C68     FFC0,0880,ISETS,63            ; BCLR
00:0000AD92 FFC0            	     1M          DC.W    $FFC0
00:0000AD94 0880            	     2M          DC.W    $0880
00:0000AD96 039C            	     3M          DC.W    (ISETS-X)
00:0000AD98 003F            	     4M          DC.w    63
                            	  1400:          C68     FFC0,0840,ISETS,62            ; BCHG
00:0000AD9A FFC0            	     1M          DC.W    $FFC0
00:0000AD9C 0840            	     2M          DC.W    $0840
00:0000AD9E 039C            	     3M          DC.W    (ISETS-X)
00:0000ADA0 003E            	     4M          DC.w    62
                            	  1401:          C68     FFC0,0800,ISETS,61            ; BTST
00:0000ADA2 FFC0            	     1M          DC.W    $FFC0
00:0000ADA4 0800            	     2M          DC.W    $0800
00:0000ADA6 039C            	     3M          DC.W    (ISETS-X)
00:0000ADA8 003D            	     4M          DC.w    61
                            	  1402:          C68     F1C0,01C0,ISETD,64            ; BSET
00:0000ADAA F1C0            	     1M          DC.W    $F1C0
00:0000ADAC 01C0            	     2M          DC.W    $01C0
00:0000ADAE 038C            	     3M          DC.W    (ISETD-X)
00:0000ADB0 0040            	     4M          DC.w    64
                            	  1403:          C68     F1C0,0180,ISETD,63            ; BCLR
00:0000ADB2 F1C0            	     1M          DC.W    $F1C0
00:0000ADB4 0180            	     2M          DC.W    $0180
00:0000ADB6 038C            	     3M          DC.W    (ISETD-X)
00:0000ADB8 003F            	     4M          DC.w    63
                            	  1404:          C68     F1C0,0140,ISETD,62            ; BCHG
00:0000ADBA F1C0            	     1M          DC.W    $F1C0
00:0000ADBC 0140            	     2M          DC.W    $0140
00:0000ADBE 038C            	     3M          DC.W    (ISETD-X)
00:0000ADC0 003E            	     4M          DC.w    62
                            	  1405:          C68     F1C0,0100,ISETD,61            ; BTST
00:0000ADC2 F1C0            	     1M          DC.W    $F1C0
00:0000ADC4 0100            	     2M          DC.W    $0100
00:0000ADC6 038C            	     3M          DC.W    (ISETD-X)
00:0000ADC8 003D            	     4M          DC.w    61
                            	  1406: TBLE:
                            	  1407:           even
                            	  1408: 
                            	  1409: N68:     macro arg1,arg2
                            	  1410:          dc.b  "\1",\2
                            	  1411:          endm
                            	  1412: 
                            	  1413: 				even
                            	  1414: OPCTBL:  ;.align  2
                            	  1415:          N68     MOVE,$d0    ; 0
00:0000ADCA 4D4F5645        	     1M          dc.b  "MOVE",$d0
00:0000ADCE D0
                            	  1416:          N68     O,$d2       ; 1
00:0000ADCF 4F              	     1M          dc.b  "O",$d2
00:0000ADD0 D2
                            	  1417:          N68     AN,$c4      ; 2
00:0000ADD1 414E            	     1M          dc.b  "AN",$c4
00:0000ADD3 C4
                            	  1418:          N68     SU,$c2      ; 3
00:0000ADD4 5355            	     1M          dc.b  "SU",$c2
00:0000ADD6 C2
                            	  1419:          N68     AD,$c4      ; 4
00:0000ADD7 4144            	     1M          dc.b  "AD",$c4
00:0000ADD9 C4
                            	  1420:          N68     EO,$d2      ; 5
00:0000ADDA 454F            	     1M          dc.b  "EO",$d2
00:0000ADDC D2
                            	  1421:          N68     CM,$d0      ; 6
00:0000ADDD 434D            	     1M          dc.b  "CM",$d0
00:0000ADDF D0
                            	  1422:          N68     MOV,$c5     ; 7
00:0000ADE0 4D4F56          	     1M          dc.b  "MOV",$c5
00:0000ADE3 C5
                            	  1423:          N68     NEG,$d8     ; 8
00:0000ADE4 4E4547          	     1M          dc.b  "NEG",$d8
00:0000ADE7 D8
                            	  1424:          N68     CL,$d2      ; 9
00:0000ADE8 434C            	     1M          dc.b  "CL",$d2
00:0000ADEA D2
                            	  1425:          N68     NE,$c7      ; 10
00:0000ADEB 4E45            	     1M          dc.b  "NE",$c7
00:0000ADED C7
                            	  1426:          N68     NO,$d4      ; 11
00:0000ADEE 4E4F            	     1M          dc.b  "NO",$d4
00:0000ADF0 D4
                            	  1427:          N68     NBC,$c4     ; 12
00:0000ADF1 4E4243          	     1M          dc.b  "NBC",$c4
00:0000ADF4 C4
                            	  1428:          N68     PEA.,$cc    ; 13
00:0000ADF5 5045412E        	     1M          dc.b  "PEA.",$cc
00:0000ADF9 CC
                            	  1429:          N68     SWAP.,$d7   ; 14
00:0000ADFA 535741502E      	     1M          dc.b  "SWAP.",$d7
00:0000ADFF D7
                            	  1430:          N68     MOVE,$cd    ; 15
00:0000AE00 4D4F5645        	     1M          dc.b  "MOVE",$cd
00:0000AE04 CD
                            	  1431:          N68     EXT.,$d7    ; 16
00:0000AE05 4558542E        	     1M          dc.b  "EXT.",$d7
00:0000AE09 D7
                            	  1432:          N68     EXT.,$cc    ; 17
00:0000AE0A 4558542E        	     1M          dc.b  "EXT.",$cc
00:0000AE0E CC
                            	  1433:          N68     TS,$d4      ; 18
00:0000AE0F 5453            	     1M          dc.b  "TS",$d4
00:0000AE11 D4
                            	  1434:          N68     TAS.,$c2    ; 19
00:0000AE12 5441532E        	     1M          dc.b  "TAS.",$c2
00:0000AE16 C2
                            	  1435:          N68     TRA,$d0     ; 20
00:0000AE17 545241          	     1M          dc.b  "TRA",$d0
00:0000AE1A D0
                            	  1436:          N68     LIN,$cb     ; 21
00:0000AE1B 4C494E          	     1M          dc.b  "LIN",$cb
00:0000AE1E CB
                            	  1437:          N68     UNL,$cb     ; 22
00:0000AE1F 554E4C          	     1M          dc.b  "UNL",$cb
00:0000AE22 CB
                            	  1438:          N68     RESE,$d4    ; 23
00:0000AE23 52455345        	     1M          dc.b  "RESE",$d4
00:0000AE27 D4
                            	  1439:          N68     NO,$d0      ; 24
00:0000AE28 4E4F            	     1M          dc.b  "NO",$d0
00:0000AE2A D0
                            	  1440:          N68     STO,$d0     ; 25
00:0000AE2B 53544F          	     1M          dc.b  "STO",$d0
00:0000AE2E D0
                            	  1441:          N68     RT,$c5      ; 26
00:0000AE2F 5254            	     1M          dc.b  "RT",$c5
00:0000AE31 C5
                            	  1442:          N68     RT,$d3      ; 27
00:0000AE32 5254            	     1M          dc.b  "RT",$d3
00:0000AE34 D3
                            	  1443:          N68     TRAP,$d6    ; 28
00:0000AE35 54524150        	     1M          dc.b  "TRAP",$d6
00:0000AE39 D6
                            	  1444:          N68     RT,$d2      ; 29
00:0000AE3A 5254            	     1M          dc.b  "RT",$d2
00:0000AE3C D2
                            	  1445:          N68     JS,$d2      ; 30
00:0000AE3D 4A53            	     1M          dc.b  "JS",$d2
00:0000AE3F D2
                            	  1446:          N68     JM,$d0      ; 31
00:0000AE40 4A4D            	     1M          dc.b  "JM",$d0
00:0000AE42 D0
                            	  1447:          N68     CHK.,$d7    ; 32
00:0000AE43 43484B2E        	     1M          dc.b  "CHK.",$d7
00:0000AE47 D7
                            	  1448:          N68     LEA.,$cc    ; 33
00:0000AE48 4C45412E        	     1M          dc.b  "LEA.",$cc
00:0000AE4C CC
                            	  1449:          N68     ADD,$d1     ; 34
00:0000AE4D 414444          	     1M          dc.b  "ADD",$d1
00:0000AE50 D1
                            	  1450:          N68     SUB,$d1     ; 35
00:0000AE51 535542          	     1M          dc.b  "SUB",$d1
00:0000AE54 D1
00:0000AE55 D3              	  1451:          DC.B    $d3         ; 36
                            	  1452:          N68     D,$c2       ; 37
00:0000AE56 44              	     1M          dc.b  "D",$c2
00:0000AE57 C2
00:0000AE58 C2              	  1453:          DC.B    $c2         ; 38
                            	  1454:          N68     MOVEQ.,$cc  ; .....39
00:0000AE59 4D4F5645512E    	     1M          dc.b  "MOVEQ.",$cc
00:0000AE5F CC
                            	  1455:          N68     O,$d2       ; 40
00:0000AE60 4F              	     1M          dc.b  "O",$d2
00:0000AE61 D2
                            	  1456:          N68     DIVU.,$d7   ; 41
00:0000AE62 444956552E      	     1M          dc.b  "DIVU.",$d7
00:0000AE67 D7
                            	  1457:          N68     DIVS.,$d7   ; 42
00:0000AE68 444956532E      	     1M          dc.b  "DIVS.",$d7
00:0000AE6D D7
                            	  1458:          N68     SBC,$c4     ; 43
00:0000AE6E 534243          	     1M          dc.b  "SBC",$c4
00:0000AE71 C4
                            	  1459:          N68     SU,$c2      ; 44
00:0000AE72 5355            	     1M          dc.b  "SU",$c2
00:0000AE74 C2
                            	  1460:          N68     SUB,$d8     ; 45
00:0000AE75 535542          	     1M          dc.b  "SUB",$d8
00:0000AE78 D8
                            	  1461:          N68     CMP,$cd     ; 46
00:0000AE79 434D50          	     1M          dc.b  "CMP",$cd
00:0000AE7C CD
                            	  1462:          N68     MULU.,$d7   ; 47
00:0000AE7D 4D554C552E      	     1M          dc.b  "MULU.",$d7
00:0000AE82 D7
                            	  1463:          N68     MULS.,$d7   ; 48
00:0000AE83 4D554C532E      	     1M          dc.b  "MULS.",$d7
00:0000AE88 D7
                            	  1464:          N68     ABC,$c4     ; 49
00:0000AE89 414243          	     1M          dc.b  "ABC",$c4
00:0000AE8C C4
                            	  1465:          N68     EX,$c7      ; 50
00:0000AE8D 4558            	     1M          dc.b  "EX",$c7
00:0000AE8F C7
                            	  1466:          N68     BS,$d2      ; .....51
00:0000AE90 4253            	     1M          dc.b  "BS",$d2
00:0000AE92 D2
                            	  1467:          N68     NUL,$cc     ; .....52
00:0000AE93 4E554C          	     1M          dc.b  "NUL",$cc
00:0000AE96 CC
                            	  1468:          N68     ADD,$d8     ; 53
00:0000AE97 414444          	     1M          dc.b  "ADD",$d8
00:0000AE9A D8
                            	  1469:          N68     A,$d3       ; 54
00:0000AE9B 41              	     1M          dc.b  "A",$d3
00:0000AE9C D3
                            	  1470:          N68     L,$d3       ; 55
00:0000AE9D 4C              	     1M          dc.b  "L",$d3
00:0000AE9E D3
                            	  1471:          N68     R,$cf       ; 56
00:0000AE9F 52              	     1M          dc.b  "R",$cf
00:0000AEA0 CF
                            	  1472:          N68     RO,$d8      ; 57
00:0000AEA1 524F            	     1M          dc.b  "RO",$d8
00:0000AEA3 D8
                            	  1473:          N68     MOVE.,$c2   ; 58
00:0000AEA4 4D4F56452E      	     1M          dc.b  "MOVE.",$c2
00:0000AEA9 C2
                            	  1474:          N68     MOVE.,$d7   ; 59
00:0000AEAA 4D4F56452E      	     1M          dc.b  "MOVE.",$d7
00:0000AEAF D7
                            	  1475:          N68     MOVE.,$cc   ; 60
00:0000AEB0 4D4F56452E      	     1M          dc.b  "MOVE.",$cc
00:0000AEB5 CC
                            	  1476:          N68     BTS,$d4     ; 61
00:0000AEB6 425453          	     1M          dc.b  "BTS",$d4
00:0000AEB9 D4
                            	  1477:          N68     BCH,$c7     ; 62
00:0000AEBA 424348          	     1M          dc.b  "BCH",$c7
00:0000AEBD C7
                            	  1478:          N68     BCL,$d2     ; 63
00:0000AEBE 42434C          	     1M          dc.b  "BCL",$d2
00:0000AEC1 D2
                            	  1479:          N68     BSE,$d4     ; 64
00:0000AEC2 425345          	     1M          dc.b  "BSE",$d4
00:0000AEC5 D4
                            	  1480:          N68     BR,$c1      ; 65
00:0000AEC6 4252            	     1M          dc.b  "BR",$c1
00:0000AEC8 C1
                            	  1481: 
00:0000AEC9 00              	  1482:          DC.B    0         ; PAD BYTE
                            	  1483: 
                            	  1484: 

Source: "boot.x68"
                            	  4636:  	include "games/asteroids/asteroids 1_0.x68"

Source: "games\asteroids\asteroids 1_0.x68"
                            	     1: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	     2: ;														;
                            	     3: ;	ASTEROIDS type game for the EASy68k simulator	2009/05/17	V1.00			;
                            	     4: ;														;
                            	     5: ;	The objective of of the game is to score as many points as possible by		;
                            	     6: ;	destroying asteroids and flying saucers. You control a triangular ship		;
                            	     7: ;	that can rotate, fire shots forward and thrust forward. As the ship moves,	;
                            	     8: ;	momentum is not conserved, the ship eventually comes to a stop when not		;
                            	     9: ;	thrusting. In moments of extreme danger you can send the ship into		;
                            	    10: ;	hyperspace, causing it to disappear and reappear in a random location.		;
                            	    11: ;														;
                            	    12: ;	Each wave starts with the asteroids drifting in random directions onto the	;
                            	    13: ;	screen. Objects wrap around screen edges, an asteroid that drifts off the	;
                            	    14: ;	left edge of the screen reappears at the right and continues moving in the	;
                            	    15: ;	same direction. As you shoot asteroids they break into smaller asteroids	;
                            	    16: ;	that often move faster and are more difficult to hit. The smaller the		;
                            	    17: ;	asteroid the higher the points scored.							;
                            	    18: ;														;
                            	    19: ;	Every so often a flying saucer will appear on one side of the screen and	;
                            	    20: ;	move to the other before disappearing again. Large saucers fire in random	;
                            	    21: ;	directions, while small saucers aim their fire towards the player's ship.	;
                            	    22: ;														;
                            	    23: ;	Once all of the asteroids and flying saucers have been cleared a new set of	;
                            	    24: ;	large asteroids appears. The number of asteroids increases by two each round	;
                            	    25: ;	up to a maximum of eleven. The game continues until all the player lives	;
                            	    26: ;	are lost, a bonus life being awarded for each 10,000 points scored up to a	;
                            	    27: ;	maximum of 255 lives. A maximum of only 18 lives are shown on screen.		;
                            	    28: ;														;
                            	    29: ;	Like the original game the maximum possible score in this game is 99,990	;
                            	    30: ;	points after which it rolls over back to zero.						;
                            	    31: ;														;
                            	    32: ;	Also like the original game some game parameters can be set using the		;
                            	    33: ;	switches in the hardware window. These can be changed at any time during	;
                            	    34: ;	the game.												;
                            	    35: ;														;
                            	    36: ;	Switch	Function										;
                            	    37: ;	------	--------										;
                            	    38: ;	7 - 3		Unused										;
                            	    39: ;	  2		Starting ship count. On = 4, off = 3					;
                            	    40: ;	1 - 0		Language	1	0								;
                            	    41: ;					off	off	English						;
                            	    42: ;					off	on	German						;
                            	    43: ;					on	off	French						;
                            	    44: ;					on	on	Spanish						;
                            	    45: ;														;
                            	    46: ;	Game controls...											;
                            	    47: ;														;
                            	    48: ;	 [1] or [2] for a one or two player game start						;
                            	    49: ;	 [s] to toggle the sound off and on								;
                            	    50: ;														;
                            	    51: ;	 [q] to rotate the ship widdershins								;
                            	    52: ;	 [w] to rotate the ship deocil								;
                            	    53: ;	 [l] to fire the ship thruster								;
                            	    54: ;	 [p] to fire the ship weapon									;
                            	    55: ;	 [SPACE] to jump to hyperspace								;
                            	    56: ;														;
                            	    57: ;	Other keys are:											;
                            	    58: ;														;
                            	    59: ;	 The F2, F3 and F4 keys can be used to select a screen size of 640 x 480,	;
                            	    60: ;	 800 x 600 and 1024 x 768 respectively.							;
                            	    61: ;														;
                            	    62: ;	The game saves the high scores in the file asteroids.hi If this file is		;
                            	    63: ;	not present it will be created after the first high score is entered. If	;
                            	    64: ;	this file is read only new high scores will not be saved. No check is made	;
                            	    65: ;	on the validity of this file, editing the file may cause the game to crash.	;
                            	    66: ;														;
                            	    67: ;	This version for Sim68K 4.6.0 or later							;
                            	    68: ;														;
                            	    69: ;	More 68000 and other projects can be found on my website at ..			;
                            	    70: ;														;
                            	    71: ;	 http://mycorner.no-ip.org/index.html							;
                            	    72: ;														;
                            	    73: ;	mail : leeedavison@googlemail.com								;
                            	    74: ;														;
                            	    75: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    76: 
                            	    77: ; a0 = system calls and volatile
                            	    78: ; a1 = system calls and volatile
                            	    79: ; a2 = volatile
                            	    80: ; a3 = variables base address
                            	    81: ; a4 = vector list pointer
                            	    82: ; a5 = player 1 / current player
                            	    83: ; a6 = player 2 / other player
                            	    84: ; a7 = stack pointer
                            	    85: 
                            	    86: 
                            	    87: 	ORG	$10000
                            	    88: 	code
                            	    89: 	even
                            	    90: 
                            	    91: asteroids_start:
00:0000AECA 61001222        	    92: 	bsr	Initialise				; go setup everything
00:0000AECE 610006DA        	    93: 	bsr reset_game				; clear the scores and set the ship start count
                            	    94: 
                            	    95: ; main loop. this is executed at most once every 16ms, as it waits for the 16ms counter
                            	    96: ; to be incremented from zero since the last loop
                            	    97: 
                            	    98: main_loop:
00:0000AED2 705E            	    99: 	moveq	#94,d0					; copy screen buffer to main (page flip)
00:0000AED4 4E4F            	   100: 	trap #15
                            	   101: 
00:0000AED6 7E06            	   102: 	moveq #6,d7						; video frame buffer
00:0000AED8 7C0C            	   103: 	moveq #DEV_CLEAR,d6
00:0000AEDA 4E40            	   104: 	trap #0
                            	   105: 
                            	   106: ;	move.w #$FF00,d1			; clear screen
                            	   107: ;	moveq #11,d0					; position cursor
                            	   108: ;	trap #15
                            	   109: 
                            	   110: ;	bsr sound_key					; handle the sound key
00:0000AEDC 61001204        	   111: 	bsr s_controls				; go check the screen controls
                            	   112: 
00:0000AEE0 20390004009C    	   113: 	move.l tickcnt,d0
                            	   114: .0001:
00:0000AEE6 B0B90004009C    	   115: 	cmp.l tickcnt,d0
00:0000AEEC 67F8            	   116: 	beq.s .0001
00:0000AEEE 7001            	   117: 	moveq #1,d0
                            	   118: ;wait_16ms
                            	   119: ;	MOVE.b	sixteen_ms(a3),d0		; get the 16ms counter
                            	   120: ;	BEQ.s		wait_16ms			; if not there yet just loop
                            	   121: 
                            	   122: ;	clr.b	sixteen_ms(a3)			; clear the 16ms counter
00:0000AEF0 D16B0059        	   123: 	add.w d0,game_count(a3)		; increment the game counter
00:0000AEF4 D12B0025        	   124: 	add.b d0,time_count(a3)		; increment the timeout counter
                            	   125: 
00:0000AEF8 49FA13D4        	   126: 	lea vector(pc),a4			; reset the vector RAM pointer
                            	   127: 
00:0000AEFC 6168            	   128: 	bsr game_message			; do "PLAYER x", "GAME OVER" or credit messages
                            	   129: 
00:0000AEFE 61000F1C        	   130: 	bsr check_hiscores		; do the high score checks
00:0000AF02 610004C0        	   131: 	bsr enter_hiscores		; get the player high score entries
00:0000AF06 6A30            	   132: 	bpl.s no_play					; if the high scores are being entered skip the
                            	   133: 												; active play routines
                            	   134: 
00:0000AF08 61000C70        	   135: 	bsr high_scores				; display the high score table if the game is
                            	   136: 												; over
00:0000AF0C 652A            	   137: 	bcs.s	no_play					; if the high score table was displayed skip
                            	   138: 												; active play
                            	   139: 
00:0000AF0E 4A2B001C        	   140: 	tst.b px_time(a3)			; test the "PLAYER x" timer
00:0000AF12 661C            	   141: 	bne.s px_hide					; skip the control checks if the "PLAYER x"
                            	   142: 												; timer is not timed out
                            	   143: 
00:0000AF14 4A2B001A        	   144: 	tst.b num_players(a3)	; test the number of players in the game
00:0000AF18 6712            	   145: 	beq.s skip_player_cont		; if no players skip the player controls
                            	   146: 
00:0000AF1A 4A2D0027        	   147: 	tst.b p_flag_off(a5)			; test the player flag
00:0000AF1E 6B08            	   148: 	bmi.s skip_player_move		; if the player is exploding skip the player
                            	   149: 														; move controls
                            	   150: 
00:0000AF20 610003FA        	   151: 	bsr	ship_fire					; handle the fire button			##
00:0000AF24 610005F4        	   152: 	bsr	hyperspace				; handle the hyperspace button		##
                            	   153: skip_player_move
00:0000AF28 610007F0        	   154: 	bsr ship_move					; handle ship rotation and thrust		##
                            	   155: skip_player_cont
00:0000AF2C 61000280        	   156: 	bsr do_saucer					; handle the saucer
                            	   157: px_hide
00:0000AF30 610006F6        	   158: 	bsr move_items				; move all the objects and add them to the
                            	   159: 												; vector list
00:0000AF34 61000146        	   160: 	bsr check_hits				; check for player/saucer/shot hits
                            	   161: no_play
00:0000AF38 61000AB0        	   162: 	bsr static_messages		; add (c), scores and players ships to the
                            	   163: 												; vector list
                            	   164: 
00:0000AF3C 61000E26        	   165: 	bsr fx_sounds					; do the saucer and thump sounds
                            	   166: 
00:0000AF40 38FCB000        	   167: 	move.w #HALT,(a4)+		; add HALT to the vector list
                            	   168: 
00:0000AF44 49FA1388        	   169: 	lea vector(pc),a4			; reset the vector RAM pointer
00:0000AF48 6100123A        	   170: 	bsr do_vector					; go do the vector list, draw them
                            	   171: 
00:0000AF4C 102D007B        	   172: 	move.b new_rocks(a5),d0			; test the generate new rocks flag
00:0000AF50 6704            	   173: 	beq.s no_dec_new_rocks			; if counted out skip the decrement
                            	   174: 
00:0000AF52 532D007B        	   175: 	subq.b #1,new_rocks(a5)			; else decrement the generate new rocks flag
                            	   176: no_dec_new_rocks
00:0000AF56 802D0076        	   177: 	or.b rock_count(a5),d0			; OR the new rocks flag with the rock count
00:0000AF5A 6600FF76        	   178: 	bne main_loop					; if not counted out or still rocks go do the
                            	   179: 												; main loop
                            	   180: 
00:0000AF5E 487AFF72        	   181: 	pea main_loop					; return to the main loop
00:0000AF62 6000090C        	   182: 	bra make_rocks				; go generate new rocks
                            	   183: 
                            	   184: 
                            	   185: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   186: ;
                            	   187: ; do "PLAYER x", "GAME OVER" or credit messages
                            	   188: 
                            	   189: game_message:
00:0000AF66 4A2B001A        	   190: 	tst.b num_players(a3)		; test the number of players in the game
00:0000AF6A 670E            	   191: 	beq.s do_start_mess			; if no players go do the start message
                            	   192: 
00:0000AF6C 4A2B001C        	   193: 	tst.b px_time(a3)				; test the "PLAYER x" timer
00:0000AF70 6778            	   194: 	beq.s game_over					; if timed out go do "GAME OVER" or thump
                            	   195: 													; sound count
                            	   196: 
00:0000AF72 532B001C        	   197: 	subq.b #1,px_time(a3)		; decrement the "PLAYER x" timer
00:0000AF76 60001100        	   198: 	bra player_x						; add "PLAYER x" to the vector list and return
                            	   199: 
                            	   200: ; do the push start message
                            	   201: 
                            	   202: do_start_mess:
00:0000AF7A 7005            	   203: 	moveq #5,d0					; GetKey
00:0000AF7C 4E4F            	   204: 	trap #15
00:0000AF7E 7001            	   205: 	moveq #1,d0
00:0000AF80 0C010031        	   206: 	cmpi.b #'1',d1
00:0000AF84 6718            	   207: 	beq.s start_game
00:0000AF86 0C010032        	   208: 	cmpi.b #'2',d1
00:0000AF8A 6646            	   209: 	bne.s push_start_mess
                            	   210: 
                            	   211: ;	MOVE.l	#'2121',d1			; [2][1][2][1] key
                            	   212: ;	MOVEQ		#19,d0			; check for keypress
                            	   213: ;	TRAP		#15
                            	   214: 
                            	   215: ;	MOVEQ		#1,d0				; default to one player
                            	   216: ;	TST.b		d1				; test the [1] key result
                            	   217: ;	BMI.s		start_game			; if pressed go start a one player game
                            	   218: 
                            	   219: ;	TST.w		d1				; test the [2] key result
                            	   220: 	;BPL.s		push_start_mess		; if not pressed go do the "PUSH START" message
                            	   221: 
                            	   222: 							; else the two player start was pressed
00:0000AF8C 4BEB01F7        	   223: 	lea player_2(a3),a5		; set the pointer to player two's variables
00:0000AF90 61000618        	   224: 	bsr reset_game				; clear the score and set the ship start count
00:0000AF94 61000982        	   225: 	bsr player_init				; initialise the player variables
00:0000AF98 610008D6        	   226: 	bsr make_rocks				; generate new rocks
00:0000AF9C 7002            	   227: 	moveq #2,d0						; set two players in this game
                            	   228: 
                            	   229: ; one or two player game start
                            	   230: 
                            	   231: start_game:
00:0000AF9E 1740001A        	   232: 	move.b d0,num_players(a3)	; save the number of players in the game
                            	   233: 
00:0000AFA2 422B0018        	   234: 	clr.b player_idx(a3)			; clear the player index
00:0000AFA6 4BEB00F3        	   235: 	lea	player_1(a3),a5				; set the pointer to player one's variables
00:0000AFAA 4DEB01F7        	   236: 	lea player_2(a3),a6				; set the pointer to player two's variables
                            	   237: 
00:0000AFAE 610005FA        	   238: 	bsr reset_game				; clear the scores and set the ship start count
00:0000AFB2 61000964        	   239: 	bsr player_init				; initialise the player variables
00:0000AFB6 610008B8        	   240: 	bsr make_rocks				; generate new rocks
                            	   241: 
00:0000AFBA 7000            	   242: 	moveq #0,d0						; clear the longword
00:0000AFBC 3B400080        	   243: 	move.w d0,score_off(a5)		; clear player 1's score
00:0000AFC0 3D400080        	   244: 	move.w d0,score_off(a6)		; clear player 2's score
                            	   245: 
00:0000AFC4 177C0080001C    	   246: 	move.b #$80,px_time(a3)		; set the "PLAYER x" timer
00:0000AFCA 177C00040024    	   247: 	move.b #$04,thump_time(a3)	; set the thump sound change timer
00:0000AFD0 4E75            	   248: 	rts
                            	   249: 
                            	   250: ; else do the "PUSH START" message
                            	   251: 
                            	   252: push_start_mess:
00:0000AFD2 102B0176        	   253: 	move.b p1_high(a3),d0			; get the player 1 highscore flag
00:0000AFD6 C02B027A        	   254: 	and.b p2_high(a3),d0			; and with the player 2 highscore flag
00:0000AFDA 6A0C            	   255: 	bpl.s exit_push_start			; if either player is entering their high score
                            	   256: 														; skip the "PUSH START" message
                            	   257: 
00:0000AFDC 7206            	   258: 	moveq #$06,d1								; message 6 - "PUSH START"
00:0000AFDE 082B0005005A    	   259: 	btst.b #5,game_count+1(a3)	; test a bit in the game counter low byte
00:0000AFE4 67001024        	   260: 	beq add_message							; if set add message d1 to the display list
                            	   261: 															; and return
                            	   262: exit_push_start
00:0000AFE8 4E75            	   263: 	rts
                            	   264: 
                            	   265: ; do "GAME OVER" or thump sound count
                            	   266: 
                            	   267: game_over:
00:0000AFEA 703F            	   268: 	moveq #$3F,d0							; set the game counter mask
00:0000AFEC C06B0059        	   269: 	and.w game_count(a3),d0		; mask the game counter
00:0000AFF0 660C            	   270: 	bne.s nodec_thmpi					; branch if not zero
                            	   271: 
                            	   272: 							; gets here 1/64th of the time
00:0000AFF2 0C2D0006007C    	   273: 	cmpi.b #6,thmp_sndi(a5)		; compare the thump sound change timer initial
                            	   274: 							; value with the minimum value
00:0000AFF8 6704            	   275: 	beq.s nodec_thmpi					; if there already don't decrement it
                            	   276: 
00:0000AFFA 532D007C        	   277: 	subq.b #1,thmp_sndi(a5)		; else decrement the thump sound change timer
                            	   278: 							; initial value
                            	   279: nodec_thmpi
00:0000AFFE 4A2D0082        	   280: 	tst.b ships_off(a5)			; test the player ship count
00:0000B002 6624            	   281: 	bne.s no_game_over			; if ships left skip game over
                            	   282: 
                            	   283: 							; else this player has no ships left
00:0000B004 102D002B        	   284: 	move.b p_fire_off(a5),d0		; get player fire 1
00:0000B008 802D002C        	   285: 	or.b p_fire_off+1(a5),d0		; OR with player fire 2
00:0000B00C 802D002D        	   286: 	or.b p_fire_off+2(a5),d0		; OR with player fire 3
00:0000B010 802D002E        	   287: 	or.b p_fire_off+3(a5),d0		; OR with player fire 4
00:0000B014 6612            	   288: 	bne.s no_game_over			; if shots still flying skip the game over
                            	   289: 
00:0000B016 7207            	   290: 	moveq #7,d1							; else message 7 - "GAME OVER"
00:0000B018 61000FF0        	   291: 	bsr add_message					; add message d1 to the display list
                            	   292: 
00:0000B01C 0C2B0002001A    	   293: 	cmpi.b #$02,num_players(a3)	; compare the number of players with two
00:0000B022 6604            	   294: 	bne.s no_game_over			; if not two player skip which game's over
                            	   295: 
00:0000B024 61001052        	   296: 	bsr player_x						; add "PLAYER x" to the vector list
                            	   297: no_game_over
00:0000B028 4A2D0027        	   298: 	tst.b p_flag_off(a5)		; test the player flag
00:0000B02C 6638            	   299: 	bne.s	exit_game_message		; if alive or exploding just exit
                            	   300: 
00:0000B02E 0C2D0080007A    	   301: 	cmpi.b #$80,hide_p_cnt(a5)	; compare with about to die - 1 with the hide
                            	   302: 							; the player count
00:0000B034 6630            	   303: 	bne.s exit_game_message			; if not about to die just exit
                            	   304: 
00:0000B036 1B7C0010007A    	   305: 	move.b #$10,hide_p_cnt(a5)	; set the hide the player count
                            	   306: 
00:0000B03C 122B001A        	   307: 	move.b num_players(a3),d1	; get the number of players in the game
                            	   308: 
00:0000B040 102B0175        	   309: 	move.b p1_ships(a3),d0		; get player 1's ship count
00:0000B044 802B0279        	   310: 	or.b p2_ships(a3),d0			; OR with player 2's ship count
00:0000B048 671E            	   311: 	beq.s end_game					; if no ships left go end the game
                            	   312: 
00:0000B04A 610006BA        	   313: 	bsr clear_saucer				; clear the saucer and restart the saucer timer
00:0000B04E 5301            	   314: 	subq.b #1,d1						; decrement the number of players in the game
00:0000B050 6714            	   315: 	beq.s exit_game_message	; if that was the last player go flag no game
                            	   316: 							; and exit
                            	   317: 
00:0000B052 177C0080001C    	   318: 	move.b #$80,px_time(a3)		; set the "PLAYER x" timer
                            	   319: 
00:0000B058 4A2E0082        	   320: 	tst.b ships_off(a6)			; test the other player's ship count
00:0000B05C 6708            	   321: 	beq.s exit_game_message		; if no ships left go flag no game and exit
                            	   322: 
                            	   323: 														; else change to the other player
00:0000B05E 0A2B00010018    	   324: 	eori.b #1,player_idx(a3)		; toggle the player index
00:0000B064 CB4E            	   325: 	exg a5,a6									; swap the player pointers
                            	   326: exit_game_message
00:0000B066 4E75            	   327: 	rts
                            	   328: 
                            	   329: ; neither player has any ships left so end the game
                            	   330: 
                            	   331: end_game:
00:0000B068 17410019        	   332: 	move.b d1,past_play(a3)		; save the number of players that were in the
                            	   333: 							; game
00:0000B06C 177C00FF001A    	   334: 	move.b #$FF,num_players(a3)	; clear the number of players in the game
00:0000B072 4BEB00F3        	   335: 	lea player_1(a3),a5		; set the pointer to player one's variables
00:0000B076 4DEB01F7        	   336: 	lea player_2(a3),a6		; set the pointer to player two's variables
00:0000B07A 4E75            	   337: 	rts
                            	   338: 
                            	   339: 
                            	   340: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   341: ;
                            	   342: ; check for player/saucer/shot hits
                            	   343: 
                            	   344: check_hits:
00:0000B07C 7C07            	   345: 	moveq #flag_end-p_flag_off-1,d6
                            	   346: 							; set the count/index for player/saucer/shots
                            	   347: pss_check_loop
00:0000B07E 4A356027        	   348: 	tst.b p_flag_off(a5,d6.w)	; test if the player/saucer/shot exists
00:0000B082 6E06            	   349: 	bgt.s check_pss			; if the item exists and is not exploding go
                            	   350: 							; test it
                            	   351: 
                            	   352: next_pss
00:0000B084 51CEFFF8        	   353: 	dbf d6,pss_check_loop	; decrement count/index and loop if more to do
                            	   354: 
00:0000B088 4E75            	   355: 	rts
                            	   356: 
                            	   357: ; the player/saucer/shot exists and is not exploding
                            	   358: 
                            	   359: check_pss
00:0000B08A 7E1C            	   360: 	moveq #s_flag_off-flags_off,d7
                            	   361: 							; set the item index to the saucer
00:0000B08C 0C460004        	   362: 	cmpi.w #p_fire_off-p_flag_off,d6
                            	   363: 							; compare the player/saucer/shot index with the
                            	   364: 							; first player shot
00:0000B090 640A            	   365: 	bcc.s check_all			; if it is a player shot go test it against all
                            	   366: 							; the items
                            	   367: 
00:0000B092 5347            	   368: 	subq.w #1,d7				; else skip the saucer
00:0000B094 4A46            	   369: 	tst.w d6						; test the player/saucer/shot index
00:0000B096 6604            	   370: 	bne.s check_all			; if not the player go test against everything
                            	   371: 
                            	   372: 							; else skip the player
                            	   373: check_next_object
00:0000B098 5347            	   374: 	subq.w #1,d7				; decrement the item index
00:0000B09A 6BE8            	   375: 	bmi.s next_pss			; if all done go do next player/saucer/shot
                            	   376: 
                            	   377: check_all
00:0000B09C 1435700C        	   378: 	move.b flags_off(a5,d7.w),d2	; get the item flag indexed by d7
00:0000B0A0 6FF6            	   379: 	ble.s	check_next_object		; if the item doesn't exist or the item is
                            	   380: 							; exploding go try the next item
                            	   381: 
00:0000B0A2 3A07            	   382: 	move.w d7,d5				; copy the item index
00:0000B0A4 DA45            	   383: 	add.w d5,d5					; *2 for the item position index
                            	   384: 
00:0000B0A6 3806            	   385: 	move.w d6,d4				; copy the fire item index
00:0000B0A8 D844            	   386: 	add.w	d4,d4					; * 2 for the fire item position index
                            	   387: 
00:0000B0AA 30355080        	   388: 	move.w x_pos_off(a5,d5.w),d0	; get item x position
00:0000B0AE 907540B6        	   389: 	sub.w p_xpos_off(a5,d4.w),d0	; subtract the player/saucer/shot x position
00:0000B0B2 6A02            	   390: 	bpl.s delta_x_pos			; if the delta is positive skip the negate
                            	   391: 
00:0000B0B4 4440            	   392: 	neg.w	d0						; else negate the delta
                            	   393: delta_x_pos
00:0000B0B6 0C400151        	   394: 	CMPI.w	#$0151,d0			; compare the range with $0151
00:0000B0BA 64DC            	   395: 	BCC.s		check_next_object		; if it's out of range go try the next item
                            	   396: 
00:0000B0BC 323550C6        	   397: 	MOVE.w	y_pos_off(a5,d5.w),d1	; get item y position
00:0000B0C0 927540FC        	   398: 	SUB.w		p_ypos_off(a5,d4.w),d1	; subtract the player/saucer/shot y position
00:0000B0C4 6A02            	   399: 	BPL.s		delta_y_pos			; if the delta is positive skip the negate
                            	   400: 
00:0000B0C6 4441            	   401: 	NEG.w		d1				; else negate the delta
                            	   402: delta_y_pos
00:0000B0C8 0C410151        	   403: 	CMPI.w	#$0151,d1			; compare the range with $0151
00:0000B0CC 64CA            	   404: 	BCC.s		check_next_object		; if it's out of range go try the next item
                            	   405: 
00:0000B0CE C0C0            	   406: 	MULU.w	d0,d0				; calculate delta x^2
00:0000B0D0 C2C1            	   407: 	MULU.w	d1,d1				; calculate delta y^2
00:0000B0D2 D081            	   408: 	ADD.l		d1,d0				; calculate delta x^2 + delta y^2
00:0000B0D4 E480            	   409: 	ASR.l		#2,d0				; / 4 makes it a word value again
                            	   410: 
00:0000B0D6 02420007        	   411: 	ANDI.w	#$07,d2			; mask the size bits
00:0000B0DA 5302            	   412: 	SUBQ.b	#1,d2				; make $01 to $04 into $00 to $03
00:0000B0DC D402            	   413: 	ADD.b		d2,d2				; ; 2 bytes per size^2
                            	   414: 
00:0000B0DE 0C460001        	   415: 	CMPI.w	#s_flag_off-p_flag_off,d6
                            	   416: 							; compare the player/saucer/shot index with the
                            	   417: 							; saucer
00:0000B0E2 6E10            	   418: 	BGT.s		no_add_size			; if shot index just go get the collision size
                            	   419: 
00:0000B0E4 6B0C            	   420: 	BMI.s		add_p_size			; if player index only add the player offset
                            	   421: 
00:0000B0E6 083500016027    	   422: 	BTST.b	#1,p_flag_off(a5,d6.w)	; else test the saucer size flag
00:0000B0EC 6702            	   423: 	BEQ.s		small_s_size		; if not size $02 only add the small saucer size
                            	   424: 
00:0000B0EE 5042            	   425: 	ADDQ.w	#col_table_l-col_table_s,d2
                            	   426: 							; add the offset to the item + large saucer size
                            	   427: 							; table
                            	   428: small_s_size
00:0000B0F0 5042            	   429: 	ADDQ.w	#col_table_s-col_table_p,d2
                            	   430: 							; add the offset to the item + small saucer size
                            	   431: 							; table
                            	   432: add_p_size
00:0000B0F2 5042            	   433: 	ADDQ.w	#col_table_p-col_table,d2
                            	   434: 							; add the offset to the item + player size table
                            	   435: no_add_size
00:0000B0F4 343B200C        	   436: 	MOVE.w	col_table(pc,d2.w),d2	; get the collision size from the table
                            	   437: 
00:0000B0F8 B440            	   438: 	CMP.w		d0,d2				; compare the distance^2 with the collision size
00:0000B0FA 659C            	   439: 	BCS.s		check_next_object		; if it's out of range go try the next item
                            	   440: 
00:0000B0FC 487AFF86        	   441: 	PEA		next_pss(pc)		; now go try the next fire item, this one died
00:0000B100 6020            	   442: 	BRA.s		handle_collision		; else go handle a collision between items
                            	   443: 
                            	   444: ; table of collision distance squares
                            	   445: 
                            	   446: col_table
00:0000B102 06E4            	   447: 	dc.w	$06E4			; $24^2		small rock, small saucer, player
00:0000B104 1440            	   448: 	dc.w	$1440			; $48^2		medium rock, large saucer
00:0000B106 0000            	   449: 	dc.w	$0000			; no size 3 rock
00:0000B108 4410            	   450: 	dc.w	$4410			; $84^2		large rock
                            	   451: col_table_p
00:0000B10A 1000            	   452: 	dc.w	$1000			; ($24 + $1C)^2	small rock  + player
00:0000B10C 2710            	   453: 	dc.w	$2710			; ($48 + $1C)^2	medium rock + player
00:0000B10E 0000            	   454: 	dc.w	$0000			; no size 3 rock
00:0000B110 6400            	   455: 	dc.w	$6400			; ($84 + $1C)^2	large rock  + player
                            	   456: col_table_s
00:0000B112 0B64            	   457: 	dc.w	$0B64			; ($24 + $12)^2	small rock  + small saucer
00:0000B114 1FA4            	   458: 	dc.w	$1FA4			; ($48 + $12)^2	medium rock + small saucer
00:0000B116 0000            	   459: 	dc.w	$0000			; no size 3 rock
00:0000B118 57E4            	   460: 	dc.w	$57E4			; ($84 + $12)^2	large rock  + small saucer
                            	   461: col_table_l
00:0000B11A 1440            	   462: 	dc.w	$1440			; ($24 + $24)^2	small rock  + large saucer
00:0000B11C 2D90            	   463: 	dc.w	$2D90			; ($48 + $24)^2	medium rock + large saucer
00:0000B11E 0000            	   464: 	dc.w	$0000			; no size 3 rock
00:0000B120 6E40            	   465: 	dc.w	$6E40			; ($84 + $24)^2	large rock  + large saucer
                            	   466: 
                            	   467: 
                            	   468: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   469: ;
                            	   470: ; handle collision between items
                            	   471: ;
                            	   472: ; d6 = X = player/saucer/shot index
                            	   473: ; d7 = Y = object index
                            	   474: 
                            	   475: handle_collision:
00:0000B122 0C460001        	   476: 	CMPI.w	#s_flag_off-p_flag_off,d6
                            	   477: 							; compare the player/saucer/shot index with the
                            	   478: 							; saucer
00:0000B126 660A            	   479: 	BNE.s		not_saucer			; if not the saucer go find out what it was
                            	   480: 
                            	   481: 							; else the saucer hit something
00:0000B128 0C47001B        	   482: 	CMPI.w	#p_flag_off-flags_off,d7
                            	   483: 							; compare the object with the player index
00:0000B12C 6612            	   484: 	BNE.s		not_player			; if not the player go find out what it was
                            	   485: 
                            	   486: 							; else the saucer hit the player so make it that
                            	   487: 							; the player hit the saucer
00:0000B12E 7E1C            	   488: 	MOVEQ		#s_flag_off-flags_off,d7
                            	   489: 							; make the object the saucer
00:0000B130 7C00            	   490: 	MOVEQ		#p_flag_off-p_flag_off,d6
                            	   491: 							; make the player/saucer/shot index the player
                            	   492: not_saucer
00:0000B132 4A46            	   493: 	TST.w		d6				; test the player/saucer/shot index
00:0000B134 6622            	   494: 	BNE.s		not_pss_player		; if it's not the player go find out what it was
                            	   495: 
                            	   496: ; the player hit something
                            	   497: 
00:0000B136 1B7C0081007A    	   498: 	MOVE.b	#$81,hide_p_cnt(a5)	; set the hide the player count
00:0000B13C 532D0082        	   499: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
                            	   500: 
                            	   501: ; either the player hit the saucer or the player or saucer hit either a rock or a shot
                            	   502: 
                            	   503: not_player
00:0000B140 1BBC00A06027    	   504: 	MOVE.b	#$A0,p_flag_off(a5,d6.w)
                            	   505: 							; set the item is exploding flag
00:0000B146 7000            	   506: 	MOVEQ		#0,d0				; clear the longword
00:0000B148 1B80604A        	   507: 	MOVE.b	d0,p_xvel_off(a5,d6.w)	; clear the player/saucer/shot x velocity
00:0000B14C 1B80606D        	   508: 	MOVE.b	d0,p_yvel_off(a5,d6.w)	; clear the player/saucer/shot y velocity
00:0000B150 0C47001B        	   509: 	CMPI.w	#p_flag_off-flags_off,d7
                            	   510: 							; compare the object with the player index
00:0000B154 650E            	   511: 	BCS.s		what_hit_rock		; if less go handle something hitting a rock
                            	   512: 
00:0000B156 6038            	   513: 	BRA.s		what_hit_saucer		; else go handle something hitting the saucer
                            	   514: 
                            	   515: ; else a shot hit something
                            	   516: 
                            	   517: not_pss_player
00:0000B158 42356027        	   518: 	CLR.b		p_flag_off(a5,d6.w)	; clear the shot object
00:0000B15C 0C07001B        	   519: 	CMPI.b	#p_flag_off-flags_off,d7
                            	   520: 							; compare the item with the player's index
00:0000B160 6722            	   521: 	BEQ.s		player_shot			; if it's the player go handle a shot hitting
                            	   522: 							; the player
                            	   523: 
00:0000B162 642C            	   524: 	BCC.s		what_hit_saucer		; if it's the saucer go handle a shot hitting
                            	   525: 							; the saucer
                            	   526: 
                            	   527: what_hit_rock
00:0000B164 61000C40        	   528: 	BSR		hit_a_rock			; handle something hitting a rock
                            	   529: 
                            	   530: ; explode the object
                            	   531: 
                            	   532: explode_object
00:0000B168 7203            	   533: 	MOVEQ		#$03,d1			; set the mask for the two size bits
00:0000B16A C235700C        	   534: 	AND.b		flags_off(a5,d7.w),d1	; and it with the item flag
00:0000B16E 5A01            	   535: 	ADDQ.b	#sexpl_snd,d1		; add the small explosion sound to the size
00:0000B170 61002B8C        	   536: 	BSR		play_sample			; go play the sample
                            	   537: 
00:0000B174 1BBC00A0700C    	   538: 	MOVE.b	#$A0,flags_off(a5,d7.w)	; set the item to exploding
00:0000B17A 4235702F        	   539: 	CLR.b		x_vel_off(a5,d7.w)	; clear the item x velocity byte
00:0000B17E 42357052        	   540: 	CLR.b		y_vel_off(a5,d7.w)	; clear the item y velocity byte
00:0000B182 4E75            	   541: 	RTS
                            	   542: 
                            	   543: ; handle a shot hitting the player
                            	   544: 
                            	   545: player_shot
00:0000B184 532D0082        	   546: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
00:0000B188 1B7C0081007A    	   547: 	MOVE.b	#$81,hide_p_cnt(a5)	; set the hide the player count
00:0000B18E 60D8            	   548: 	BRA.s		explode_object		; go explode the player
                            	   549: 
                            	   550: ; handle something hitting the saucer
                            	   551: 
                            	   552: what_hit_saucer
00:0000B190 1B6D00780077    	   553: 	MOVE.b	i_sauc_tim(a5),sauc_cntdn(a5)
                            	   554: 							; save the small saucer boundary/initial saucer
                            	   555: 							; value to the saucer countdown timer
00:0000B196 4A2B001A        	   556: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000B19A 67CC            	   557: 	BEQ.s		explode_object		; if no players skip adding the score
                            	   558: 
00:0000B19C 7299            	   559: 	MOVEQ		#$99,d1			; default to 990 points for a small saucer
00:0000B19E 082D00000028    	   560: 	BTST.b	#0,s_flag_off(a5)		; test the saucer size bit
00:0000B1A4 6602            	   561: 	BNE.s		keep_small			; if it was a small saucer keep the score value
                            	   562: 
00:0000B1A6 7220            	   563: 	MOVEQ		#$20,d1			; else set 200 points for the large saucer
                            	   564: keep_small
00:0000B1A8 6100099C        	   565: 	BSR		add_score			; add d1 to the current player's score
00:0000B1AC 60BA            	   566: 	BRA.s		explode_object		; go explode the saucer
                            	   567: 
                            	   568: 
                            	   569: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   570: ;
                            	   571: ; handle the saucer
                            	   572: 
                            	   573: do_saucer
00:0000B1AE 70FC            	   574: 	MOVEQ		#-4,d0			; set the timeout counter mask
00:0000B1B0 C02B0025        	   575: 	AND.b		time_count(a3),d0		; mask the timeout counter
00:0000B1B4 670000B0        	   576: 	BEQ		exit_do_saucer		; 3/4 of the time just exit
                            	   577: 
00:0000B1B8 B12B0025        	   578: 	EOR.b		d0,time_count(a3)		; reset the timeout counter
                            	   579: 
00:0000B1BC 4A2D0028        	   580: 	TST.b		s_flag_off(a5)		; test the saucer flag
00:0000B1C0 6B0000A4        	   581: 	BMI		exit_do_saucer		; if the saucer is exploding just exit
                            	   582: 
00:0000B1C4 660000A2        	   583: 	BNE		existing_saucer		; if a saucer exists go handle it
                            	   584: 
                            	   585: ; no saucer exists so possibly generate a new one
                            	   586: 
00:0000B1C8 4A2B001A        	   587: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000B1CC 670C            	   588: 	BEQ.s		attract_saucer		; if no players go do the attract mode saucer
                            	   589: 
00:0000B1CE 4A2D0027        	   590: 	TST.b		p_flag_off(a5)		; test the player flag
00:0000B1D2 67000092        	   591: 	BEQ		exit_do_saucer		; if this player doesn't exist just exit
                            	   592: 
00:0000B1D6 6B00008E        	   593: 	BMI		exit_do_saucer		; if this player is exploding just exit
                            	   594: 
                            	   595: attract_saucer
00:0000B1DA 4A2D0079        	   596: 	TST.b		r_hit_tim(a5)		; test the rock hit timer
00:0000B1DE 6704            	   597: 	BEQ.s		rock_hit_out		; if counted out skip the decrement
                            	   598: 
00:0000B1E0 532D0079        	   599: 	SUBQ.b	#1,r_hit_tim(a5)		; else decrement the rock hit timer
                            	   600: rock_hit_out
00:0000B1E4 532D0077        	   601: 	SUBQ.b	#1,sauc_cntdn(a5)		; decrement the saucer countdown timer
00:0000B1E8 667C            	   602: 	BNE		exit_do_saucer		; if not there yet just exit
                            	   603: 
00:0000B1EA 1B7C00120077    	   604: 	MOVE.b	#$12,sauc_cntdn(a5)	; set the first saucer fire count
                            	   605: 
00:0000B1F0 4A2D0079        	   606: 	TST.b		r_hit_tim(a5)		; test the rock hit timer
00:0000B1F4 670C            	   607: 	BEQ.s		dec_isaucer_time		; if timed out go decrement the initial saucer
                            	   608: 							; timer
                            	   609: 
00:0000B1F6 102D0076        	   610: 	MOVE.b	rock_count(a5),d0		; get the rock count
00:0000B1FA 676A            	   611: 	BEQ.s		exit_do_saucer		; if no rocks just exit
                            	   612: 
00:0000B1FC B02D007D        	   613: 	CMP.b		min_rocks(a5),d0		; compare the rock count with the minimum rock
                            	   614: 							; count before the saucer initial timer starts
                            	   615: 							; to decrement
00:0000B200 6364            	   616: 	BLS.s		exit_do_saucer		; if the minimum rock count is >= the rock count
                            	   617: 							; just exit
                            	   618: 
                            	   619: dec_isaucer_time
00:0000B202 70FA            	   620: 	MOVEQ		#-6,d0			; set to subtract 6
00:0000B204 D02D0078        	   621: 	ADD.b		i_sauc_tim(a5),d0		; subtract it from the small saucer
                            	   622: 							; boundary/initial saucer timer
00:0000B208 0C000020        	   623: 	CMPI.b	#$20,d0			; compare it with the minimum value
00:0000B20C 6504            	   624: 	BCS.s		no_save_ist			; if less skip the save
                            	   625: 
00:0000B20E 1B400078        	   626: 	MOVE.b	d0,i_sauc_tim(a5)		; save the small saucer boundary/initial saucer
                            	   627: 							; timer
                            	   628: no_save_ist
00:0000B212 61000F5E        	   629: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B216 302B000A        	   630: 	MOVE.w	PRNlword(a3),d0		; get a pseudo random word
00:0000B21A 0C401800        	   631: 	CMPI.w	#$1800,d0			; compare with $1800
00:0000B21E 6504            	   632: 	BCS.s		saucer_yok			; if less than $1800 just use it
                            	   633: 
00:0000B220 024017FF        	   634: 	ANDI.w	#$17FF,d0			; else mask to $17xx
                            	   635: saucer_yok
00:0000B224 3B40FFFE        	   636: 	MOVE.w	d0,s_ypos_off(a5)		; save the saucer y position
                            	   637: 
00:0000B228 7000            	   638: 	MOVEQ		#0,d0				; clear the saucer x position
00:0000B22A 7210            	   639: 	MOVEQ		#$10,d1			; set the saucer x velocity to + $10
00:0000B22C 4A6B000C        	   640: 	TST.w		PRNlword+2(a3)		; test a pseudo random word
00:0000B230 6B06            	   641: 	BMI.s		start_left			; if bit set start on the left
                            	   642: 
                            	   643: 							; else start at the right side and move left
00:0000B232 303C1FFF        	   644: 	MOVE.w	#$1FFF,d0			; set the saucer x position
00:0000B236 72F0            	   645: 	MOVEQ		#$F0,d1			; set the saucer x velocity to - $10
                            	   646: start_left
00:0000B238 1B41004B        	   647: 	MOVE.b	d1,s_xvel_off(a5)		; save the saucer x velocity byte
00:0000B23C 3B40FFB8        	   648: 	MOVE.w	d0,s_xpos_off(a5)		; save the saucer x position
                            	   649: 
00:0000B240 7202            	   650: 	MOVEQ		#$02,d1			; default to a large saucer
00:0000B242 4A2D0078        	   651: 	TST.b		i_sauc_tim(a5)		; test the small saucer boundary/initial saucer
                            	   652: 							; timer
00:0000B246 6B1A            	   653: 	BMI.s		save_saucer			; if > $80 always make a big saucer
                            	   654: 
00:0000B248 0C2D00300080    	   655: 	CMPI.b	#$30,score_off(a5)	; compare the player's score with 30000 points
00:0000B24E 6410            	   656: 	BCC.s		small_saucer		; if >= 30000 points go make a small saucer
                            	   657: 
00:0000B250 61000F20        	   658: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B254 142D0078        	   659: 	MOVE.b	i_sauc_tim(a5),d2		; get the small saucer boundary/initial saucer
                            	   660: 							; timer
00:0000B258 E20A            	   661: 	LSR.b		#1,d2				; / 2
00:0000B25A B42B000C        	   662: 	CMP.b		PRNlword+2(a3),d2		; compare it with the random byte
00:0000B25E 6402            	   663: 	BCC.s		save_saucer			; if the small saucer boundary is > the random
                            	   664: 							; byte go save the large saucer
                            	   665: 
                            	   666: small_saucer
00:0000B260 7201            	   667: 	MOVEQ		#$01,d1			; else make it a small saucer
                            	   668: save_saucer
00:0000B262 1B410028        	   669: 	MOVE.b	d1,s_flag_off(a5)		; save the saucer flag
                            	   670: exit_do_saucer
00:0000B266 4E75            	   671: 	RTS
                            	   672: 
                            	   673: ; there is an existing saucer
                            	   674: 
                            	   675: existing_saucer
00:0000B268 707E            	   676: 	MOVEQ		#$7E,d0			; set saucer change mask
00:0000B26A C06B0059        	   677: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000B26E 6610            	   678: 	BNE.s		keep_saucer_dir		; if it was not x000 000x skip the saucer
                            	   679: 							; direction change
                            	   680: 
00:0000B270 61000F00        	   681: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B274 7003            	   682: 	MOVEQ		#3,d0				; set the direction mask
00:0000B276 C02B000A        	   683: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000B27A 1B7B0018006E    	   684: 	MOVE.b	saucer_yvel(pc,d0.w),s_yvel_off(a5)
                            	   685: 							; save the saucer y velocity byte
                            	   686: keep_saucer_dir
00:0000B280 4A2B001A        	   687: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000B284 6706            	   688: 	BEQ.s		attract_fire		; if no players just go do the fire countdown
                            	   689: 
00:0000B286 4A2D007A        	   690: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:0000B28A 6606            	   691: 	BNE.s		exit_existing_saucer	; if the player is hidden just exit
                            	   692: 
                            	   693: attract_fire
00:0000B28C 532D0077        	   694: 	SUBQ.b	#1,sauc_cntdn(a5)		; decrement the saucer countdown timer
00:0000B290 6706            	   695: 	BEQ.s		fire_saucer			; if counted out go fire
                            	   696: 
                            	   697: exit_existing_saucer
00:0000B292 4E75            	   698: 	RTS
                            	   699: 
                            	   700: ; saucer y velocity byte
                            	   701: 
                            	   702: saucer_yvel
00:0000B294 F0              	   703: 	dc.b	$F0			; down
00:0000B295 00              	   704: 	dc.b	$00			; horizontal
00:0000B296 00              	   705: 	dc.b	$00			; horizontal
00:0000B297 10              	   706: 	dc.b	$10			; up
                            	   707: 
                            	   708: 
                            	   709: ; handle the saucer fire
                            	   710: 
                            	   711: fire_saucer
00:0000B298 1B7C000A0077    	   712: 	MOVE.b	#$0A,sauc_cntdn(a5)	; set the time between saucer shots, save the
                            	   713: 							; countdown timer
00:0000B29E 7001            	   714: 	MOVEQ		#1,d0				; set the mask for a small saucer
00:0000B2A0 C02D0028        	   715: 	AND.b		s_flag_off(a5),d0		; mask the saucer flag
00:0000B2A4 660A            	   716: 	BNE.s		aim_shot			; if it's a small saucer go aim at the player
                            	   717: 
00:0000B2A6 61000ECA        	   718: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B2AA 102B000A        	   719: 	MOVE.b	PRNlword(a3),d0		; get a pseudo random byte
00:0000B2AE 6056            	   720: 	BRA.s		no_aim_shot			; and go fire wildly in any direction
                            	   721: 
                            	   722: ; aim the shot at the player
                            	   723: 
                            	   724: aim_shot
00:0000B2B0 1F2D004B        	   725: 	MOVE.b	s_xvel_off(a5),-(sp)	; copy the saucer x velocity byte
00:0000B2B4 301F            	   726: 	MOVE.w	(sp)+,d0			; get the byte as a word
00:0000B2B6 4200            	   727: 	CLR.b		d0				; clear the low byte
00:0000B2B8 E240            	   728: 	ASR.w		#1,d0				; / 2
                            	   729: 
00:0000B2BA 322DFFB6        	   730: 	MOVE.w	p_xpos_off(a5),d1		; get the player x position
00:0000B2BE 926DFFB8        	   731: 	SUB.w		s_xpos_off(a5),d1		; subtract the saucer x position
00:0000B2C2 E541            	   732: 	ASL.w		#2,d1				; ; 4 delta x
                            	   733: 
00:0000B2C4 9240            	   734: 	SUB.w		d0,d1				; subtract the half saucer x velocity word
                            	   735: 
00:0000B2C6 1F2D006E        	   736: 	MOVE.b	s_yvel_off(a5),-(sp)	; copy the saucer y velocity byte
00:0000B2CA 301F            	   737: 	MOVE.w	(sp)+,d0			; get the byte as a word
00:0000B2CC 4200            	   738: 	CLR.b		d0				; clear the low byte
00:0000B2CE E240            	   739: 	ASR.w		#1,d0				; / 2
                            	   740: 
00:0000B2D0 342DFFFC        	   741: 	MOVE.w	p_ypos_off(a5),d2		; get the player y position
00:0000B2D4 946DFFFE        	   742: 	SUB.w		s_ypos_off(a5),d2		; subtract the saucer y position
00:0000B2D8 E542            	   743: 	ASL.w		#2,d2				; ; 4 delta x low byte
                            	   744: 
00:0000B2DA 9440            	   745: 	SUB.w		d0,d2				; subtract the half saucer y velocity word
                            	   746: 
00:0000B2DC 61000BE4        	   747: 	BSR		get_atn			; calculate the angle given the delta x,y in
                            	   748: 							; d1.w,d2.w
00:0000B2E0 1740001F        	   749: 	MOVE.b	d0,s_orient(a3)		; save the saucer shot direction
                            	   750: 
00:0000B2E4 61000E8C        	   751: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B2E8 7200            	   752: 	MOVEQ		#0,d1				; set index to +/- $0F degree units perturbation
00:0000B2EA 102B000A        	   753: 	MOVE.b	PRNlword(a3),d0		; get a pseudo random byte
00:0000B2EE 0C2D00350080    	   754: 	CMPI.b	#$35,score_off(a5)	; compare the player's score with 35000
00:0000B2F4 6502            	   755: 	BCS.s		wide_shot			; if less than 35000 skip the index change
                            	   756: 
00:0000B2F6 7201            	   757: 	MOVEQ		#1,d1				; set index to +/- $07 degree units perturbation
                            	   758: wide_shot
00:0000B2F8 C03B101E        	   759: 	AND.b		shot_mask(pc,d1.w),d0	; mask with the shot AND mask
00:0000B2FC 6A04            	   760: 	BPL.s		no_shot_or			; if the result is positive skip the bit set
                            	   761: 
00:0000B2FE 803B101A        	   762: 	OR.b		shot_or(pc,d1.w),d0	; else set the correct bits for a negative
                            	   763: 							; perturbation
                            	   764: no_shot_or
00:0000B302 D02B001F        	   765: 	ADD.b		s_orient(a3),d0		; add the saucer shot direction to the
                            	   766: 							; perturbation
                            	   767: no_aim_shot
00:0000B306 1740001F        	   768: 	MOVE.b	d0,s_orient(a3)		; save the saucer shot direction
                            	   769: 
00:0000B30A 7801            	   770: 	MOVEQ		#1,d4				; set the index to the saucer velocity
00:0000B30C 7A02            	   771: 	MOVEQ		#2,d5				; set the index to the saucer position
00:0000B30E 7CFF            	   772: 	MOVEQ		#-1,d6			; set the minimum shot index - 1
00:0000B310 7E01            	   773: 	MOVEQ		#1,d7				; set the shot start index
                            	   774: 
00:0000B312 122B0021        	   775: 	MOVE.b	last_fire(a3),d1		; get the fire last state
00:0000B316 6022            	   776: 	BRA.s		test_fire_loop		; go fire the shot
                            	   777: 
                            	   778: 
                            	   779: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   780: ;
                            	   781: ; these two byte pairs together effect the accuracy of the small saucer's shooting
                            	   782: ; by limiting the range of the random perturbation to the saucer's aim
                            	   783: 
                            	   784: ; shot AND mask, masks the perturbation to either +/- $0F or +/- $07 degree units
                            	   785: 
                            	   786: shot_mask
00:0000B318 8F              	   787: 	dc.b	$8F			; AND mask to +/- $0F degree units
00:0000B319 87              	   788: 	dc.b	$87			; AND mask to +/- $07 degree units
                            	   789: 
                            	   790: ; shot OR byte, sets the needed bits for a negative perturbation result
                            	   791: 
                            	   792: shot_or
00:0000B31A 70              	   793: 	dc.b	$70			; OR to set bits after - $0F mask result
00:0000B31B 78              	   794: 	dc.b	$78			; OR to set bits after - $07 mask result
                            	   795: 
                            	   796: 
                            	   797: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   798: ;
                            	   799: ; handle the fire button
                            	   800: 
                            	   801: ship_fire:
                            	   802: ;##	TST.b		num_players(a3)		; test the number of players in the game
                            	   803: ;##	BEQ.s		exit_ship_fire		; if no players just exit
                            	   804: 
                            	   805: ;##	TST.b		hide_p_cnt(a5)		; test the hide the player count
                            	   806: ;##	BNE.s		exit_ship_fire		; if the player is hidden just exit
                            	   807: 
                            	   808: ;	MOVEQ		#'P',d1			; [P] key
                            	   809: ;	MOVEQ		#19,d0			; check for keypress
                            	   810: ;	TRAP		#15
                            	   811: 
00:0000B31C 7005            	   812: 	moveq #5,d0					; getkey
00:0000B31E 4E4F            	   813: 	trap #15
00:0000B320 0C010050        	   814: 	cmpi.b #'P',d1
00:0000B324 6620            	   815: 	bne.s save_ship_fire
                            	   816: 
                            	   817: ;	TST.b		d1				; test the result
                            	   818: ;	BEQ.s		save_ship_fire		; if fire not pressed go clear the fire state
                            	   819: 							; and exit
                            	   820: 
00:0000B326 4A2B0021        	   821: 	tst.b last_fire(a3)		; test the fire last state
00:0000B32A 661E            	   822: 	bne.s exit_ship_fire	; if the fire button is held just exit
                            	   823: 
00:0000B32C 7800            	   824: 	moveq #0,d4					; set the index to the player velocity
00:0000B32E 7A00            	   825: 	moveq #0,d5					; set the index to the player position
00:0000B330 7C01            	   826: 	moveq #1,d6					; set the minimum shot index - 1
00:0000B332 7E05            	   827: 	moveq #5,d7					; set the shot start index
                            	   828: 
00:0000B334 176B001E001F    	   829: 	move.b p_orient(a3),s_orient(a3)
                            	   830: 							; copy the player orientation
                            	   831: 
                            	   832: ; fire the shot, player or saucer
                            	   833: 
                            	   834: test_fire_loop
00:0000B33A 4A357029        	   835: 	tst.b s_fire_off(a5,d7.w)	; test this fire object
00:0000B33E 670C            	   836: 	beq.s fire_shot			; if this shot is free go use it
                            	   837: 
00:0000B340 5347            	   838: 	subq.w #1,d7				; decrement the shot index
00:0000B342 BC47            	   839: 	cmp.w d7,d6					; compare with minimum - 1 index
00:0000B344 66F4            	   840: 	bne.s test_fire_loop		; loop if more to do
                            	   841: 
                            	   842: save_ship_fire
00:0000B346 17410021        	   843: 	move.b d1,last_fire(a3)		; save the fire last state
                            	   844: exit_ship_fire
00:0000B34A 4E75            	   845: 	rts
                            	   846: 
                            	   847: ; player/saucer fired and a shot, indexed by d7, is free
                            	   848: 
                            	   849: fire_shot:
00:0000B34C 3C07            	   850: 	move.w d7,d6				; copy the item index
00:0000B34E DC46            	   851: 	add.w d6,d6					; 2 for position index
                            	   852: 
00:0000B350 1BBC00127029    	   853: 	MOVE.b	#$12,s_fire_off(a5,d7.w)
                            	   854: 							; set the fire item flag
                            	   855: 
00:0000B356 102B001F        	   856: 	MOVE.b	s_orient(a3),d0		; get the player/saucer orientation
00:0000B35A 61000C0E        	   857: 	BSR		cos_d0			; do COS(d0)
                            	   858: 
00:0000B35E 1635404A        	   859: 	MOVE.b	p_xvel_off(a5,d4.w),d3	; get the player/saucer x velocity byte
00:0000B362 613A            	   860: 	BSR.s		calc_fire_byte		; test the fire velocity and make 3/4 sin/cos
00:0000B364 1B83704C        	   861: 	MOVE.b	d3,f_xvel_off(a5,d7.w)	; save the shot x velocity byte
                            	   862: 
00:0000B368 D07550B6        	   863: 	ADD.w		p_xpos_off(a5,d5.w),d0	; add the player/saucer x position
00:0000B36C 3B8060BA        	   864: 	MOVE.w	d0,f_xpos_off(a5,d6.w)	; save the shot x position
                            	   865: 
00:0000B370 102B001F        	   866: 	MOVE.b	s_orient(a3),d0		; get the player/saucer orientation
00:0000B374 61000BF8        	   867: 	BSR		sin_d0			; do SIN(d0)
                            	   868: 
00:0000B378 1635406D        	   869: 	MOVE.b	p_yvel_off(a5,d4.w),d3	; get the player/saucer y velocity byte
00:0000B37C 6120            	   870: 	BSR		calc_fire_byte		; test the fire velocity and make 3/4 sin/cos
00:0000B37E 1B83706F        	   871: 	MOVE.b	d3,f_yvel_off(a5,d7.w)	; save the shot y velocity byte
                            	   872: 
00:0000B382 D07550FC        	   873: 	ADD.w		p_ypos_off(a5,d5.w),d0	; add the player/saucer y position
00:0000B386 3B806000        	   874: 	MOVE.w	d0,f_ypos_off(a5,d6.w)	; save the shot y position
                            	   875: 
00:0000B38A 17410021        	   876: 	MOVE.b	d1,last_fire(a3)		; save the fire last state
                            	   877: 
00:0000B38E 7201            	   878: 	MOVEQ		#pfire_snd,d1		; default to the player fire sound
00:0000B390 0C470002        	   879: 	CMPI.w	#2,d7				; compare the index with the lowest player fire
00:0000B394 64002968        	   880: 	BCC		play_sample			; if it was the player go play the sample and
                            	   881: 							; return
                            	   882: 
                            	   883: 							; else it must be the saucer that fired so
00:0000B398 7200            	   884: 	MOVEQ		#sfire_snd,d1		; set the saucer fire sound
00:0000B39A 60002962        	   885: 	BRA		play_sample			; play the sample and return
                            	   886: 
                            	   887: 
                            	   888: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   889: ;
                            	   890: ; test the fire velocity and make 3/4 sin/cos
                            	   891: 
                            	   892: calc_fire_byte
00:0000B39E E240            	   893: 	ASR.w		#1,d0				; / 2
                            	   894: 
00:0000B3A0 3F00            	   895: 	MOVE.w	d0,-(sp)			; push the word value
00:0000B3A2 101F            	   896: 	MOVE.b	(sp)+,d0			; pop it as a byte value
                            	   897: 
00:0000B3A4 D600            	   898: 	ADD.b		d0,d3				; add it to the COS / 2 value
00:0000B3A6 6B0A            	   899: 	BMI.s		test_neg_fire		; if negative go test the negative limit
                            	   900: 
00:0000B3A8 0C030070        	   901: 	CMPI.b	#$70,d3			; else compare it with the positive limit
00:0000B3AC 650C            	   902: 	BCS.s		fire_ok			; if < the positive limit skip the adjust
                            	   903: 
00:0000B3AE 766F            	   904: 	MOVEQ		#$6F,d3			; else set the value to the positive limit
00:0000B3B0 6008            	   905: 	BRA.s		fire_ok			; go save the shot x velocity
                            	   906: 
                            	   907: test_neg_fire
00:0000B3B2 0C030091        	   908: 	CMPI.b	#$91,d3			; compare it with the negative limit
00:0000B3B6 6402            	   909: 	BCC.s		fire_ok			; if < the negative limit skip the adjust
                            	   910: 
00:0000B3B8 7691            	   911: 	MOVEQ		#$91,d3			; else set the value to the negative limit
                            	   912: fire_ok
00:0000B3BA 4880            	   913: 	EXT.w		d0				; make the byte value into a word
                            	   914: 
00:0000B3BC 3400            	   915: 	MOVE.w	d0,d2				; get the COS / 2 back
00:0000B3BE E242            	   916: 	ASR.w		#1,d2				; / 4
00:0000B3C0 D142            	   917: 	ADDX.w	d2,d0				; make 3 / 4 COS and round up
                            	   918: 
00:0000B3C2 4E75            	   919: 	RTS
                            	   920: 
                            	   921: 
                            	   922: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   923: ;
                            	   924: ; get the player high score entries
                            	   925: 
                            	   926: enter_hiscores
00:0000B3C4 102D0083        	   927: 	MOVE.b	high_off(a5),d0		; get the player 1 highscore flag
00:0000B3C8 C02E0083        	   928: 	AND.b		high_off(a6),d0		; and with the player 2 highscore flag
00:0000B3CC 6B00014A        	   929: 	BMI		exit_enter_hiscores	; if neither player is entering their high
                            	   930: 							; score just exit
                            	   931: 
00:0000B3D0 102D0083        	   932: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:0000B3D4 6B000088        	   933: 	BMI		next_p_high			; if this player isn't entering their high
                            	   934: 							; score go try the other player
                            	   935: 
                            	   936: 							; get a player high score entry
00:0000B3D8 0C2B00010019    	   937: 	CMPI.b	#1,past_play(a3)		; compare 1 with the number of players that
                            	   938: 							; were in the game
00:0000B3DE 6712            	   939: 	BEQ.s		no_playerx			; if it was only 1 player skip the "PLAYER x"
                            	   940: 							; message
                            	   941: 
00:0000B3E0 7201            	   942: 	MOVEQ		#1,d1				; message 1 - "PLAYER "
00:0000B3E2 61000C26        	   943: 	BSR		add_message			; add message d1 to the display list
                            	   944: 
00:0000B3E6 7010            	   945: 	MOVEQ		#$10,d0			; set game counter mask
00:0000B3E8 C06B0059        	   946: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000B3EC 6604            	   947: 	BNE.s		no_playerx			; if bit set skip the player number write
                            	   948: 
00:0000B3EE 61000C8C        	   949: 	BSR		player_n			; add the player number to the vector list
                            	   950: no_playerx
00:0000B3F2 7202            	   951: 	MOVEQ		#2,d1				; message 2 - "YOUR SCORE IS ONE OF THE TE..."
00:0000B3F4 61000C14        	   952: 	BSR		add_message			; add message d1 to the display list
00:0000B3F8 7203            	   953: 	MOVEQ		#3,d1				; message 3 - "PLEASE ENTER YOUR INITIALS"
00:0000B3FA 61000C0E        	   954: 	BSR		add_message			; add message d1 to the display list
00:0000B3FE 7204            	   955: 	MOVEQ		#4,d1				; message 4 - "PUSH ROTATE TO SELECT LETTER"
00:0000B400 61000C08        	   956: 	BSR		add_message			; add message d1 to the display list
00:0000B404 7205            	   957: 	MOVEQ		#5,d1				; message 5 - "PUSH HYPERSPACE WHEN LETTER..."
00:0000B406 61000C02        	   958: 	BSR		add_message			; add message d1 to the display list
                            	   959: 
00:0000B40A 36BC2000        	   960: 	MOVE.w	#$2000,glob_scale(a3)	; set the global scale
                            	   961: 
00:0000B40E 7264            	   962: 	MOVEQ		#$64,d1			; set the x co-ordinate
00:0000B410 7439            	   963: 	MOVEQ		#$39,d2			; set the y co-ordinate
00:0000B412 61000CAC        	   964: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	   965: 							; a draw command
                            	   966: 
00:0000B416 323C7000        	   967: 	MOVE.w	#REL7,d1			; make a $7000,$0000 command
00:0000B41A 61000CBE        	   968: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	   969: 
00:0000B41E 7000            	   970: 	MOVEQ		#0,d0				; clear the longword
00:0000B420 102D0083        	   971: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:0000B424 41F3003B        	   972: 	LEA		hinames(a3,d0.w),a0	; point to the high score names
                            	   973: 
00:0000B428 610001AA        	   974: 	BSR		write_initial		; write a high score initial to the vector list
00:0000B42C 610001A6        	   975: 	BSR		write_initial		; write a high score initial to the vector list
00:0000B430 610001A2        	   976: 	BSR		write_initial		; write a high score initial to the vector list
                            	   977: 
                            	   978: ;	MOVEQ		#' ',d1			; [SPACE] key
                            	   979: ;	MOVEQ		#19,d0			; check for keypress
                            	   980: ;	TRAP		#15
00:0000B434 7005            	   981: 	moveq #5,d0
00:0000B436 4E4F            	   982: 	trap #15
00:0000B438 4A81            	   983: 	tst.l d1
00:0000B43A 6B6E            	   984: 	bmi.s save_hbutton
00:0000B43C 0C010020        	   985: 	cmpi.b #' ',d1
00:0000B440 6668            	   986: 	bne.s save_hbutton
                            	   987: 
                            	   988: ;	TST.b		d1				; test the result
                            	   989: ;	BEQ.s		save_hbutton		; if hyperspace not pressed go save the state
                            	   990: 
00:0000B442 4A2B0022        	   991: 	TST.b		last_hype(a3)		; test the hyperspace last state
00:0000B446 6662            	   992: 	BNE.s		save_hbutton		; if hyperspace is held go save the state
                            	   993: 
                            	   994: ; the hyperspace button has just been pressed
                            	   995: 
00:0000B448 522B0020        	   996: 	ADDQ.b	#1,hi_char(a3)		; increment the input character index
00:0000B44C 0C2B00030020    	   997: 	CMPI.b	#3,hi_char(a3)		; compare with end + 1
00:0000B452 653E            	   998: 	BCS.s		next_hi_char		; if not there yet go and increment to the next
                            	   999: 							; character
                            	  1000: 
                            	  1001: 							; else that was the last character
00:0000B454 17410022        	  1002: 	MOVE.b	d1,last_hype(a3)		; save the hyperspace last state
00:0000B458 1B7C00FF0083    	  1003: 	MOVE.b	#$FF,high_off(a5)		; clear the player highscore flag
                            	  1004: next_p_high
00:0000B45E 7000            	  1005: 	MOVEQ		#0,d0				; clear the longword
00:0000B460 17400020        	  1006: 	MOVE.b	d0,hi_char(a3)		; clear the input character index
                            	  1007: 
00:0000B464 43FA29AA        	  1008: 	LEA		filename(pc),a1		; point to the highscore filename
00:0000B468 7034            	  1009: 	MOVEQ		#52,d0			; open new file
00:0000B46A 4E4F            	  1010: 	TRAP		#15
                            	  1011: 
00:0000B46C 4A40            	  1012: 	TST.w		d0				; check for errors
00:0000B46E 660A            	  1013: 	BNE.s		close_all			; if error go close all files
                            	  1014: 
00:0000B470 43EB0027        	  1015: 	LEA		hiscores(a3),a1		; point to the highscore tables
00:0000B474 7432            	  1016: 	MOVEQ		#50,d2			; set the table length
00:0000B476 7036            	  1017: 	MOVEQ		#54,d0			; write file
00:0000B478 4E4F            	  1018: 	TRAP		#15
                            	  1019: 
                            	  1020: close_all
00:0000B47A 7032            	  1021: 	MOVEQ		#50,d0			; close all files
00:0000B47C 4E4F            	  1022: 	TRAP		#15
                            	  1023: 
00:0000B47E 17400018        	  1024: 	MOVE.b	d0,player_idx(a3)		; clear the player index
00:0000B482 4BEB00F3        	  1025: 	LEA		player_1(a3),a5		; get the pointer to player one's variables
00:0000B486 4DEB01F7        	  1026: 	LEA		player_2(a3),a6		; get the pointer to player two's variables
                            	  1027: 
00:0000B48A 177C00F00059    	  1028: 	MOVE.b	#$F0,game_count(a3)	; set the game counter high byte, high score
                            	  1029: 							; entry timeout
00:0000B490 4E75            	  1030: 	RTS
                            	  1031: 
                            	  1032: ; hyperspace button press accepted and not at initials end
                            	  1033: 
                            	  1034: next_hi_char
00:0000B492 177C00F40059    	  1035: 	MOVE.b	#$F4,game_count(a3)	; set the game counter high byte, high score
                            	  1036: 							; entry timeout
                            	  1037: 
00:0000B498 7000            	  1038: 	MOVEQ		#0,d0				; clear the longword
00:0000B49A 102D0083        	  1039: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:0000B49E D02B0020        	  1040: 	ADD.b		hi_char(a3),d0		; add the input character index
00:0000B4A2 41F3003B        	  1041: 	LEA		hinames(a3,d0.w),a0	; point to the high score names
00:0000B4A6 10BC000B        	  1042: 	MOVE.b	#$0B,(a0)			; set the next character to "A"
                            	  1043: save_hbutton
00:0000B4AA 17410022        	  1044: 	MOVE.b	d1,last_hype(a3)		; save the hyperspace button last state
                            	  1045: 
00:0000B4AE 4A2B0059        	  1046: 	TST.b		game_count(a3)		; test the game counter high byte
00:0000B4B2 660C            	  1047: 	BNE.s		not_timed_out		; if not timed out just continue
                            	  1048: 
00:0000B4B4 70FF            	  1049: 	MOVEQ		#-1,d0			; flag high score done
00:0000B4B6 1B400083        	  1050: 	MOVE.b	d0,high_off(a5)		; clear the player 1 highscore flag
00:0000B4BA 1D400083        	  1051: 	MOVE.b	d0,high_off(a6)		; clear the player 2 highscore flag
00:0000B4BE 609E            	  1052: 	BRA.s		next_p_high			; go save the entry end exit, branch always
                            	  1053: 
                            	  1054: not_timed_out
00:0000B4C0 70F8            	  1055: 	MOVEQ		#-8,d0			; set the timeout counter mask
00:0000B4C2 C02B0025        	  1056: 	AND.b		time_count(a3),d0		; mask the timeout counter
00:0000B4C6 674E            	  1057: 	BEQ.s		exit_not_done		; just exit 7/8ths of the time
                            	  1058: 
00:0000B4C8 B12B0025        	  1059: 	EOR.b		d0,time_count(a3)		; reset the timeout counter
                            	  1060: 
00:0000B4CC 7400            	  1061: 	MOVEQ		#0,d2				; assume no rotate
                            	  1062: ;	MOVE.w	#'WQ',d1			; [WQ] keys
                            	  1063: ;	MOVEQ		#19,d0			; check for keypress
                            	  1064: ;	TRAP		#15
00:0000B4CE 7005            	  1065: 	moveq #5,d0
00:0000B4D0 4E4F            	  1066: 	trap #15
00:0000B4D2 0C010051        	  1067: 	cmpi.b #'Q',d1
00:0000B4D6 6604            	  1068: 	bne.s not_rot_left
00:0000B4D8 7401            	  1069: 	moveq #1,d2
00:0000B4DA 6008            	  1070: 	bra.s was_rot_left
                            	  1071: not_rot_left:
00:0000B4DC 0C010057        	  1072: 	cmpi.b #'W',d1
00:0000B4E0 6602            	  1073: 	bne.s not_rot_right2
00:0000B4E2 5302            	  1074: 	subq.b #1,d2	
                            	  1075: 
                            	  1076: ;	TST.b		d1				; test the result
                            	  1077: ;	BPL.s		rot_not_left		; if not pressed go test rotate right
                            	  1078: ;
                            	  1079: ;	MOVEQ		#1,d2				; if pressed set the offset to + 1
                            	  1080: rot_not_left
                            	  1081: ;	TST.w		d1				; test the result
                            	  1082: ;	BPL.s		rot_not_right		; if not pressed go add the rotation
                            	  1083: 
                            	  1084: ;	SUBQ.b	#1,d2				; if pressed set the offset to - 1
                            	  1085: not_rot_right2
                            	  1086: was_rot_left:
00:0000B4E4 7000            	  1087: 	MOVEQ		#0,d0				; clear the longword
00:0000B4E6 102D0083        	  1088: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:0000B4EA D02B0020        	  1089: 	ADD.b		hi_char(a3),d0		; add the input character index
00:0000B4EE D433003B        	  1090: 	ADD.b		hinames(a3,d0.w),d2	; add the character to the offset
00:0000B4F2 6B14            	  1091: 	BMI.s		wrap_to_z			; if negative go set "Z"
                            	  1092: 
00:0000B4F4 0C02000B        	  1093: 	CMPI.b	#$0B,d2			; compare with "A"
00:0000B4F8 6410            	  1094: 	BCC.s		check_alpha			; if >= "A" go test for <= "Z"
                            	  1095: 
00:0000B4FA 0C020001        	  1096: 	CMPI.b	#$01,d2			; compare with "0"
00:0000B4FE 6704            	  1097: 	BEQ.s		wrap_to_a			; if "0" go set to "A"
                            	  1098: 
                            	  1099: 							; gets here if it was "2" to "9"
00:0000B500 7400            	  1100: 	MOVEQ		#0,d2				; else set to " "
00:0000B502 600E            	  1101: 	BRA.s		save_char			; go save the new character
                            	  1102: 
                            	  1103: wrap_to_a
00:0000B504 740B            	  1104: 	MOVEQ		#$0B,d2			; set to "A"
00:0000B506 600A            	  1105: 	BRA.s		save_char			; go save the new character
                            	  1106: 
                            	  1107: wrap_to_z
00:0000B508 7424            	  1108: 	MOVEQ		#$24,d2			; set to "Z"
                            	  1109: check_alpha
00:0000B50A 0C020025        	  1110: 	CMPI.b	#$25,d2			; compare with "Z" + 1
00:0000B50E 6502            	  1111: 	BCS.s		save_char			; if less skip the reset
                            	  1112: 
00:0000B510 7400            	  1113: 	MOVEQ		#0,d2				; else reset it to " "
                            	  1114: save_char
00:0000B512 1782003B        	  1115: 	MOVE.b	d2,hinames(a3,d0.w)	; save the new character
                            	  1116: exit_not_done
00:0000B516 7000            	  1117: 	MOVEQ		#0,d0				; flag high score not complete
                            	  1118: exit_enter_hiscores
00:0000B518 4E75            	  1119: 	RTS
                            	  1120: 
                            	  1121: 
                            	  1122: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1123: ;
                            	  1124: ; handle the hyperspace button
                            	  1125: 
                            	  1126: hyperspace
                            	  1127: ;##	TST.b		num_players(a3)		; test the number of players in the game
                            	  1128: ;##	BEQ		exit_hyperspace		; if no players just exit
                            	  1129: 
                            	  1130: ;##	TST.b		hide_p_cnt(a5)		; test the hide the player count
                            	  1131: ;##	BNE		exit_hyperspace		; if the player is hidden just exit
                            	  1132: 
00:0000B51A 4A2D0027        	  1133: 	tst.b p_flag_off(a5)		; test the player flag
00:0000B51E 6F000088        	  1134: 	ble exit_hyperspace			; if no player or player exploding just exit
                            	  1135: 
                            	  1136: ;	MOVEQ		#' ',d1			; [SPACE] key, read the hyperspace button
                            	  1137: ;	MOVEQ		#19,d0			; check for keypress
                            	  1138: ;	TRAP		#15
00:0000B522 7005            	  1139: 	moveq #5,d0
00:0000B524 4E4F            	  1140: 	trap #15
00:0000B526 0C010020        	  1141: 	cmpi.b #' ',d1
00:0000B52A 667C            	  1142: 	bne.s exit_hyperspace
                            	  1143: 
                            	  1144: ;	TST.b		d1				; test the result
                            	  1145: ;	BEQ.s		exit_hyperspace		; if the key is not pressed just exit
                            	  1146: 
00:0000B52C 7000            	  1147: 	MOVEQ		#0,d0				; clear the longword
00:0000B52E 1B400027        	  1148: 	MOVE.b	d0,p_flag_off(a5)		; clear the player flag
00:0000B532 1B40004A        	  1149: 	MOVE.b	d0,p_xvel_off(a5)		; clear the player x velocity
00:0000B536 1B40006D        	  1150: 	MOVE.b	d0,p_yvel_off(a5)		; clear the player y velocity
                            	  1151: 
00:0000B53A 1B7C0030007A    	  1152: 	MOVE.b	#$30,hide_p_cnt(a5)	; set the hide the player count
                            	  1153: 
00:0000B540 61000C30        	  1154: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B544 302B000A        	  1155: 	MOVE.w	PRNlword(a3),d0		; get a pseudo random word
00:0000B548 02401FFF        	  1156: 	ANDI.w	#$1FFF,d0			; mask to $1Fxx
00:0000B54C 0C401E00        	  1157: 	CMPI.w	#$1E00,d0			; compare with $1E00
00:0000B550 6504            	  1158: 	BCS.s		hype_xok1			; if less than $1E00 just use it
                            	  1159: 
00:0000B552 02401CFF        	  1160: 	ANDI.w	#$1CFF,d0			; else restrict it to $1Cxx
                            	  1161: hype_xok1
00:0000B556 0C400400        	  1162: 	CMPI.w	#$0400,d0			; compare it with $0400
00:0000B55A 6404            	  1163: 	BCC.s		hype_xok2			; if >= $0400 go use it
                            	  1164: 
00:0000B55C 00400300        	  1165: 	ORI.w		#$0300,d0			; else make it $03xx
                            	  1166: hype_xok2
00:0000B560 3B40FFB6        	  1167: 	MOVE.w	d0,p_xpos_off(a5)		; save the player x position
                            	  1168: 
00:0000B564 61000C0C        	  1169: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B568 302B000A        	  1170: 	MOVE.w	PRNlword(a3),d0		; get a pseudo random word
00:0000B56C 02401FFF        	  1171: 	ANDI.w	#$1FFF,d0			; mask to $1Fxx
                            	  1172: 
00:0000B570 3F00            	  1173: 	MOVE.w	d0,-(sp)			; push the word
00:0000B572 141F            	  1174: 	MOVE.b	(sp)+,d2			; pull the byte for later success/fail check
                            	  1175: 
00:0000B574 0C401600        	  1176: 	CMPI.w	#$1600,d0			; compare with $1600
00:0000B578 6504            	  1177: 	BCS.s		hype_yok1			; if less than $1600 just use it
                            	  1178: 
00:0000B57A 024014FF        	  1179: 	ANDI.w	#$14FF,d0			; else restrict it to $14xx
                            	  1180: hype_yok1
00:0000B57E 0C400400        	  1181: 	CMPI.w	#$0400,d0			; compare it with $0400
00:0000B582 6404            	  1182: 	BCC.s		hype_yok2			; if >= $0400 go use it
                            	  1183: 
00:0000B584 00400300        	  1184: 	ORI.w		#$0300,d0			; else make it $03xx
                            	  1185: hype_yok2
00:0000B588 3B40FFFC        	  1186: 	MOVE.w	d0,p_ypos_off(a5)		; save the player y position
                            	  1187: 
00:0000B58C 7201            	  1188: 	MOVEQ		#1,d1				; default to a successful hyperspace jump
                            	  1189: 
00:0000B58E 0C020018        	  1190: 	CMPI.b	#$18,d2			; compare with $18xx
00:0000B592 6510            	  1191: 	BCS.s		save_hyperspace		; if less than $18xx go save the hyperspace flag
                            	  1192: 
00:0000B594 02020007        	  1193: 	ANDI.b	#$07,d2			; else mask it
00:0000B598 D402            	  1194: 	ADD.b		d2,d2				; ; 2
00:0000B59A 5802            	  1195: 	ADDI.b	#$04,d2			; + 4
00:0000B59C B42D0076        	  1196: 	CMP.b		rock_count(a5),d2		; compare this with the rock count
00:0000B5A0 6502            	  1197: 	BCS.s		save_hyperspace		; if < the rock count allow the jump
                            	  1198: 
00:0000B5A2 7280            	  1199: 	MOVEQ		#$80,d1			; else flag an unsuccessful hyperspace jump
                            	  1200: save_hyperspace
00:0000B5A4 17410026        	  1201: 	MOVE.b	d1,hyper(a3)		; save the hyperspace flag
                            	  1202: exit_hyperspace
00:0000B5A8 4E75            	  1203: 	RTS
                            	  1204: 
                            	  1205: 
                            	  1206: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1207: ;
                            	  1208: ; clear the items and set the ship start count
                            	  1209: 
                            	  1210: reset_game:
00:0000B5AA 7003            	  1211: 	MOVEQ		#3,d0				; default to a 3 ship game
00:0000B5AC 206B000E        	  1212: 	MOVEA.l	switch_addr(a3),a0	; point to the switch
00:0000B5B0 08100002        	  1213: 	BTST		#2,(a0)			; test the ship start switch
00:0000B5B4 6702            	  1214: 	BEQ.s		three_ship_start		; if 0 go start with three ships
                            	  1215: 
00:0000B5B6 7004            	  1216: 	MOVEQ		#4,d0				; else make it a 4 ship game
                            	  1217: three_ship_start
00:0000B5B8 1740001B        	  1218: 	MOVE.b	d0,ss_count(a3)		; save the starting ship count
                            	  1219: 
00:0000B5BC 1B7C00020075    	  1220: 	MOVE.b	#2,i_rk_count(a5)		; set the previous initial rock count
                            	  1221: 
00:0000B5C2 7000            	  1222: 	MOVEQ		#0,d0				; clear the longword
00:0000B5C4 7E22            	  1223: 	MOVEQ		#flag_end-flags_off-1,d7
                            	  1224: 							; set the count for the number of items
                            	  1225: clear_items_loop
00:0000B5C6 1B80700C        	  1226: 	MOVE.b	d0,flags_off(a5,d7.w)	; clear an item
00:0000B5CA 51CFFFFA        	  1227: 	DBF		d7,clear_items_loop	; loop if more to do
                            	  1228: 
00:0000B5CE 1B400076        	  1229: 	MOVE.b	d0,rock_count(a5)		; clear the rock count
                            	  1230: 
00:0000B5D2 4E75            	  1231: 	RTS
                            	  1232: 
                            	  1233: 
                            	  1234: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1235: ;
                            	  1236: ; write a high score initial to the vector list
                            	  1237: 
                            	  1238: write_initial:
00:0000B5D4 7200            	  1239: 	MOVEQ		#0,d1				; clear the longword
00:0000B5D6 1218            	  1240: 	MOVE.b	(a0)+,d1			; get a high score initial
00:0000B5D8 6614            	  1241: 	BNE.s		add_character		; if not [SPACE] just go add it
                            	  1242: 
00:0000B5DA 102B0176        	  1243: 	MOVE.b	p1_high(a3),d0		; get the player 1 highscore flag
00:0000B5DE C02B027A        	  1244: 	AND.b		p2_high(a3),d0		; and with the player 2 highscore flag
00:0000B5E2 6B0A            	  1245: 	BMI.s		add_character		; if neither is entering their initials just
                            	  1246: 							; go add the character
                            	  1247: 
                            	  1248: 							; else add a "_" instead of a [SPACE]
00:0000B5E4 38FCF872        	  1249: 	MOVE.w	#$F872,(a4)+		; add the underline vector word to the vector
                            	  1250: 							; list
00:0000B5E8 38FCF801        	  1251: 	MOVE.w	#$F801,(a4)+		; add the step to next character vector word
                            	  1252: 							; to the vector list
00:0000B5EC 4E75            	  1253: 	RTS
                            	  1254: 
                            	  1255: 
                            	  1256: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1257: ;
                            	  1258: ; add character (d1) to the vector list
                            	  1259: 
                            	  1260: add_character:
00:0000B5EE 2F08            	  1261: 	MOVE.l	a0,-(sp)			; save a0
00:0000B5F0 D241            	  1262: 	ADD.w		d1,d1				; ; 2 bytes per character (d1) JSRL
00:0000B5F2 41FA22F6        	  1263: 	LEA		char_set(pc),a0		; point to the character JSRL table
00:0000B5F6 38F01000        	  1264: 	MOVE.w	(a0,d1.w),(a4)+		; add the JSRL word to the vector list
00:0000B5FA 205F            	  1265: 	MOVE.l	(sp)+,a0			; restore a0
00:0000B5FC 4E75            	  1266: 	RTS
                            	  1267: 
                            	  1268: 
                            	  1269: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1270: ;
                            	  1271: ; add d7 ships to the vector list. this is limited to a maximum of eighteen ships for
                            	  1272: ; speed and clarity
                            	  1273: 
                            	  1274: add_ships:
00:0000B5FE 6726            	  1275: 	BEQ.s		exit_add_ships		; if no ships left just exit
                            	  1276: 
00:0000B600 7012            	  1277: 	MOVEQ		#18,d0			; set the maximum ship count
00:0000B602 B047            	  1278: 	CMP.w		d7,d0				; compare the ship count with the max count
00:0000B604 6402            	  1279: 	BCC.s		show_ships			; if <= to max go show the ships
                            	  1280: 
00:0000B606 3E00            	  1281: 	MOVE.w	d0,d7				; else set the ship count to the maximum
                            	  1282: show_ships
00:0000B608 9247            	  1283: 	SUB.w		d7,d1				; subtract the ship count twice to move the ..
00:0000B60A 9247            	  1284: 	SUB.w		d7,d1				; .. ships further right the more there are
                            	  1285: 
00:0000B60C 36BCE000        	  1286: 	MOVE.w	#$E000,glob_scale(a3)	; set the global scale
00:0000B610 343C00D1        	  1287: 	MOVE.w	#$D1,d2			; set the ships y co-ordinate
00:0000B614 61000AAA        	  1288: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1289: 							; a draw command
00:0000B618 5347            	  1290: 	SUBQ.w	#1,d7				; adjust for loop type
                            	  1291: add_ships_loop
00:0000B61A 43FA20D4        	  1292: 	LEA		play_liv(pc),a1		; set the pointer to ships left
00:0000B61E 61000A8A        	  1293: 	BSR		add_address			; convert the a1 address and add it to the
                            	  1294: 							; vector list as a vector subroutine call
00:0000B622 51CFFFF6        	  1295: 	DBF		d7,add_ships_loop		; decrement the ship count and loop if more
                            	  1296: 							; to do
                            	  1297: exit_add_ships
00:0000B626 4E75            	  1298: 	RTS
                            	  1299: 
                            	  1300: 
                            	  1301: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1302: ;
                            	  1303: ; move all the items and add them to the vector list
                            	  1304: 
                            	  1305: ; d6 = object index
                            	  1306: ; d7 = position index
                            	  1307: 
                            	  1308: move_items:
00:0000B628 7E44            	  1309: 	MOVEQ		#x_pos_end-x_pos_off-2,d7
                            	  1310: 							; set the index to the last object position
00:0000B62A 7C22            	  1311: 	MOVEQ		#flag_end-flags_off-1,d6
                            	  1312: 							; set the count to the last object
                            	  1313: move_next_item
00:0000B62C 1035600C        	  1314: 	MOVE.b	flags_off(a5,d6.w),d0	; get an object flag
00:0000B630 670000CC        	  1315: 	BEQ		move_next_object		; if no item go do the next one
                            	  1316: 
                            	  1317: ; have an active item
                            	  1318: 
00:0000B634 6A5C            	  1319: 	BPL.s		move_item			; if the item is not exploding go move the item
                            	  1320: 
                            	  1321: 							; else the item is exploding
00:0000B636 4400            	  1322: 	NEG.b		d0				; do twos complement [$A0 becones $60]
00:0000B638 E808            	  1323: 	LSR.b		#4,d0				; shift the high nibble to the low nibble
                            	  1324: 							; [$60 becomes $06]
00:0000B63A 5200            	  1325: 	ADDQ.b	#1,d0				; + 1
00:0000B63C 0C06001B        	  1326: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  1327: 							; compare the index with the player index
00:0000B640 6606            	  1328: 	BNE.s		skip_play_inc		; if not the player skip setting the player
                            	  1329: 							; increment
                            	  1330: 
                            	  1331: ; set the player explosion increment to 1/2 by only setting it to 1 on alternate loops
                            	  1332: 
00:0000B642 7001            	  1333: 	MOVEQ		#1,d0				; set game counter mask
00:0000B644 C06B0059        	  1334: 	AND.w		game_count(a3),d0		; mask the game counter
                            	  1335: skip_play_inc
00:0000B648 D035600C        	  1336: 	ADD.b		flags_off(a5,d6.w),d0	; add the item flag
00:0000B64C 6B2A            	  1337: 	BMI.s		item_exploding		; go handle the item still exploding
                            	  1338: 
00:0000B64E 0C46001B        	  1339: 	CMPI.w	#p_flag_off-flags_off,d6
                            	  1340: 							; compare the index with the player index
00:0000B652 6716            	  1341: 	BEQ.s		go_reset_play		; if the player go reset the player and do next
                            	  1342: 
00:0000B654 641A            	  1343: 	BCC.s		go_reset_sauc		; if the saucer go reset the saucer and do next
                            	  1344: 
                            	  1345: 							; else it was a rock so clear it
00:0000B656 532D0076        	  1346: 	SUBQ.b	#1,rock_count(a5)		; decrement the rock count
00:0000B65A 6606            	  1347: 	BNE.s		no_new_rocks		; skip flag set if rocks still left
                            	  1348: 
00:0000B65C 1B7C007F007B    	  1349: 	MOVE.b	#$7F,new_rocks(a5)	; else set the generate new rocks flag
                            	  1350: no_new_rocks
00:0000B662 4235600C        	  1351: 	CLR.b		flags_off(a5,d6.w)	; clear the item flag
00:0000B666 60000096        	  1352: 	BRA		move_next_object		; go check next item
                            	  1353: 
                            	  1354: go_reset_play
00:0000B66A 610002E2        	  1355: 	BSR		player_reset		; reset the player velocity and position
00:0000B66E 60F2            	  1356: 	BRA		no_new_rocks		; go clear the player and do the next item
                            	  1357: 
                            	  1358: ; reset the saucer timer
                            	  1359: 
                            	  1360: go_reset_sauc
00:0000B670 1B6D00780077    	  1361: 	MOVE.b	i_sauc_tim(a5),sauc_cntdn(a5)
                            	  1362: 							; get the small saucer boundary/initial saucer
                            	  1363: 							; timer and reset the saucer countdown timer
00:0000B676 60EA            	  1364: 	BRA.s		no_new_rocks		; go clear the saucer and do the next item
                            	  1365: 
                            	  1366: ; the item is still exploding
                            	  1367: 
                            	  1368: item_exploding
00:0000B678 1B80600C        	  1369: 	MOVE.b	d0,flags_off(a5,d6.w)	; save the incremented item flag
00:0000B67C 1F00            	  1370: 	MOVE.b	d0,-(sp)			; save the byte
00:0000B67E 321F            	  1371: 	MOVE.w	(sp)+,d1			; pull the word
00:0000B680 C27CF000        	  1372: 	AND.w		#$F000,d1			; mask the top nibble as the scale
00:0000B684 D27C1000        	  1373: 	ADD.w		#$1000,d1			; + $10
00:0000B688 0C06001B        	  1374: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  1375: 							; compare the index with the player index
00:0000B68C 6602            	  1376: 	BNE.s		no_reset_scale		; if not the player ship skip the scale reset
                            	  1377: 
00:0000B68E 7200            	  1378: 	MOVEQ		#$0000,d1			; else it was the player so reset the scale
                            	  1379: no_reset_scale
00:0000B690 6066            	  1380: 	BRA.s		keep_scale			; go add the object to the vector list and do
                            	  1381: 							; the next item
                            	  1382: 
                            	  1383: ; the item is not exploding so move the item
                            	  1384: 
                            	  1385: move_item:
00:0000B692 1035602F        	  1386: 	MOVE.b	x_vel_off(a5,d6.w),d0	; get the x velocity byte
00:0000B696 4880            	  1387: 	EXT.w		d0				; extend it to a word value
00:0000B698 D0757080        	  1388: 	ADD.w		x_pos_off(a5,d7.w),d0	; add the x position
00:0000B69C 6B06            	  1389: 	BMI.s		x_pos_neg			; if negative go mask to $2000
                            	  1390: 
00:0000B69E B07C2000        	  1391: 	CMP.w		#$2000,d0			; compare the object x position with $2000
00:0000B6A2 6510            	  1392: 	BCS.s		not_x_max			; if less go do y position
                            	  1393: 
                            	  1394: x_pos_neg
00:0000B6A4 02401FFF        	  1395: 	ANDI.w	#$1FFF,d0			; else wrap round the x position
                            	  1396: 
00:0000B6A8 0C06001C        	  1397: 	CMPI.b	#s_flag_off-flags_off,d6
                            	  1398: 							; compare the index with the saucer index
00:0000B6AC 6606            	  1399: 	BNE.s		not_x_max			; if not saucer continue
                            	  1400: 
                            	  1401: 							; else the saucer has passed the screen end
00:0000B6AE 487A004E        	  1402: 	PEA		move_next_object(pc)	; on RTS go check the next item
00:0000B6B2 6052            	  1403: 	BRA.s		clear_saucer		; clear the saucer and restart the saucer timer
                            	  1404: 
                            	  1405: not_x_max
00:0000B6B4 3B807080        	  1406: 	MOVE.w	d0,x_pos_off(a5,d7.w)	; save the new x position
                            	  1407: 
00:0000B6B8 10356052        	  1408: 	MOVE.b	y_vel_off(a5,d6.w),d0	; get the y velocity byte
00:0000B6BC 4880            	  1409: 	EXT.w		d0				; extend it to a word value
00:0000B6BE D07570C6        	  1410: 	ADD.w		y_pos_off(a5,d7.w),d0	; add the y position
00:0000B6C2 6A06            	  1411: 	BPL.s		y_not_neg			; skip add if not < 0
                            	  1412: 
00:0000B6C4 D07C1800        	  1413: 	ADD.w		#$1800,d0			; else wrap round the y position
00:0000B6C8 600A            	  1414: 	BRA.s		not_y_max			; and skip the max check
                            	  1415: 
                            	  1416: y_not_neg
00:0000B6CA B07C1800        	  1417: 	CMP.w		#$1800,d0			; compare the object y position with $1800
00:0000B6CE 6504            	  1418: 	BCS.s		not_y_max			; if less just continue
                            	  1419: 
00:0000B6D0 907C1800        	  1420: 	SUB.w		#$1800,d0			; else wrap round the y position
                            	  1421: not_y_max
00:0000B6D4 3B8070C6        	  1422: 	MOVE.w	d0,y_pos_off(a5,d7.w)	; save the new y position
                            	  1423: 
00:0000B6D8 323CE000        	  1424: 	MOVE.w	#$E000,d1			; set the scale to $E000
00:0000B6DC 0C46001D        	  1425: 	CMPI.w	#s_fire_off-flags_off,d6
                            	  1426: 							; compare the index with the fire objects
00:0000B6E0 6416            	  1427: 	BCC.s		keep_scale			; if fire object keep this scale and go add the
                            	  1428: 							; item and do next
                            	  1429: 
00:0000B6E2 1035600C        	  1430: 	MOVE.b	flags_off(a5,d6.w),d0	; get the object flag
00:0000B6E6 08000000        	  1431: 	BTST.l	#0,d0				; test bit 0
00:0000B6EA 660C            	  1432: 	BNE.s		keep_scale			; if %xx1 keep this scale and go add the item
                            	  1433: 							; and do next
                            	  1434: 
00:0000B6EC 323CF000        	  1435: 	MOVE.w	#$F000,d1			; set the scale to $F000
00:0000B6F0 08000001        	  1436: 	BTST.l	#1,d0				; test bit 0
00:0000B6F4 6602            	  1437: 	BNE.s		keep_scale			; if %x10 keep this scale and go add the item
                            	  1438: 							; and do next
                            	  1439: 
00:0000B6F6 7200            	  1440: 	MOVEQ		#0,d1				; set the scale to $0000
                            	  1441: 
                            	  1442: ; add the item to the vector list and go do the next item
                            	  1443: 
                            	  1444: keep_scale
00:0000B6F8 3681            	  1445: 	MOVE.w	d1,glob_scale(a3)		; save the global scale
00:0000B6FA 610003DE        	  1446: 	BSR		add_to_list			; add an object to the vector list
                            	  1447: move_next_object
00:0000B6FE 5547            	  1448: 	SUBQ.w	#2,d7				; decrement the position index
00:0000B700 51CEFF2A        	  1449: 	DBF		d6,move_next_item		; decrement the count and loop if more to do
                            	  1450: 
00:0000B704 4E75            	  1451: 	RTS
                            	  1452: 
                            	  1453: 
                            	  1454: 
                            	  1455: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1456: ;
                            	  1457: ; clear the saucer and restart the saucer timer
                            	  1458: 
                            	  1459: clear_saucer:
00:0000B706 1B6D00780077    	  1460: 	move.b i_sauc_tim(a5),sauc_cntdn(a5)	
                            	  1461: 							; copy the small saucer boundary/initial saucer
                            	  1462: 							; timer to the saucer countdown timer
00:0000B70C 422D0028        	  1463: 	clr.b s_flag_off(a5)		; clear the saucer flag
00:0000B710 422D004B        	  1464: 	clr.b s_xvel_off(a5)		; clear the saucer x velocity byte
00:0000B714 422D006E        	  1465: 	clr.b s_yvel_off(a5)		; clear the saucer y velocity byte
00:0000B718 4E75            	  1466: 	rts
                            	  1467: 
                            	  1468: 
                            	  1469: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1470: ;
                            	  1471: ; handle ship rotation and thrust
                            	  1472: 
                            	  1473: ship_move:
                            	  1474: ;##	TST.b		num_players(a3)		; test the number of players in the game
                            	  1475: ;##	BEQ.s		exit_ship_move		; if no players just exit
                            	  1476: 
00:0000B71A 4A2D0027        	  1477: 	TST.b		p_flag_off(a5)		; test the player flag
00:0000B71E 6B4A            	  1478: 	BMI.s		exit_ship_move		; if the player is exploding just exit
                            	  1479: 
00:0000B720 4A2D007A        	  1480: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:0000B724 6746            	  1481: 	BEQ.s		rot_and_thrust		; if the player is visible go handle the ship
                            	  1482: 							; rotate and thrust
                            	  1483: 
00:0000B726 532D007A        	  1484: 	SUBQ.b	#1,hide_p_cnt(a5)		; else decrement the hide the player count
00:0000B72A 663E            	  1485: 	BNE.s		exit_ship_move		; if not timed out just exit
                            	  1486: 
00:0000B72C 4A2B0026        	  1487: 	TST.b		hyper(a3)			; test the hyperspace flag
00:0000B730 6B1E            	  1488: 	BMI.s		kill_the_player		; if negative go handle an unsuccessful
                            	  1489: 							; hyperspace jump
                            	  1490: 
00:0000B732 6614            	  1491: 	BNE.s		reveal_player		; else if non zero go handle a successful
                            	  1492: 							; hyperspace jump
                            	  1493: 
                            	  1494: 							; else the player has just become visible
00:0000B734 610000F8        	  1495: 	BSR		check_clear			; check items within $0400 range of the player
00:0000B738 662C            	  1496: 	BNE.s		clear_hyper			; if there are items within range go clear the
                            	  1497: 							; hyperspace flag and exit
                            	  1498: 
00:0000B73A 4A2D0028        	  1499: 	TST.b		s_flag_off(a5)		; test the saucer flag
00:0000B73E 6708            	  1500: 	BEQ.s		reveal_player		; if there's no saucer go reveal the player
                            	  1501: 
00:0000B740 1B7C0002007A    	  1502: 	MOVE.b	#$02,hide_p_cnt(a5)	; else set the hide the player count
00:0000B746 4E75            	  1503: 	RTS
                            	  1504: 
                            	  1505: ; handle a successful hyperspace jump
                            	  1506: 
                            	  1507: reveal_player
00:0000B748 1B7C00010027    	  1508: 	MOVE.b	#$01,p_flag_off(a5)	; set the player flag
00:0000B74E 6016            	  1509: 	BRA.s		clear_hyper			; go clear the hyperspace flag and return
                            	  1510: 
                            	  1511: ; handle an unsuccessful hyperspace jump
                            	  1512: 
                            	  1513: kill_the_player:
00:0000B750 1B7C00A00027    	  1514: 	MOVE.b	#$A0,p_flag_off(a5)	; flag that the player's ship is exploding
00:0000B756 532D0082        	  1515: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
00:0000B75A 1B7C0081007A    	  1516: 	MOVE.b	#$81,hide_p_cnt(a5)	; set the hide the player count
                            	  1517: 
00:0000B760 7206            	  1518: 	MOVEQ		#mexpl_snd,d1		; set the medium explosion sound
00:0000B762 6100259A        	  1519: 	BSR		play_sample			; go play the sample
                            	  1520: clear_hyper
00:0000B766 422B0026        	  1521: 	CLR.b		hyper(a3)			; clear the hyperspace flag
                            	  1522: exit_ship_move
00:0000B76A 4E75            	  1523: 	RTS
                            	  1524: 
                            	  1525: ; handle the ship rotate and thrust
                            	  1526: 
                            	  1527: rot_and_thrust
                            	  1528: ;	MOVEQ		#0,d2				; assume no rotate
                            	  1529: ;	MOVE.l	#'L WQ',d1			; [L WQ] keys
                            	  1530: ;	MOVEQ		#19,d0			; check for keypress
                            	  1531: ;	TRAP		#15
00:0000B76C 7005            	  1532: 	moveq #5,d0
00:0000B76E 4E4F            	  1533: 	trap #15
00:0000B770 0C010051        	  1534: 	cmpi.b #'Q',d1
00:0000B774 6602            	  1535: 	bne.s not_rot_left1
00:0000B776 7403            	  1536: 	moveq #3,d2
                            	  1537: not_rot_left1:
00:0000B778 0C010057        	  1538: 	cmpi.b #'W',d1
00:0000B77C 6602            	  1539: 	bne.s not_rot_right1
00:0000B77E 5702            	  1540: 	subq.b #3,d2
                            	  1541: not_rot_right1:
                            	  1542: 
                            	  1543: ;	TST.b		d1				; test the [Q] result
                            	  1544: ;	BPL.s		not_rot_left		; if not pressed go test rotate right
                            	  1545: 
                            	  1546: ;	MOVEQ		#3,d2				; if pressed set the rotation angle to + 3
                            	  1547: ;not_rot_left
                            	  1548: ;	TST.w		d1				; test the [W] result
                            	  1549: ;	BPL.s		not_rot_right		; if not pressed go add the rotation
                            	  1550: 
                            	  1551: ;	SUBQ.b	#3,d2				; if pressed set the rotation angle to - 3
                            	  1552: ;not_rot_right
00:0000B780 D52B001E        	  1553: 	add.b d2,p_orient(a3)		; add the roataion to the player orientation
                            	  1554: 
00:0000B784 7001            	  1555: 	moveq #1,d0				; set game counter mask
00:0000B786 C06B0059        	  1556: 	and.w game_count(a3),d0		; mask the game counter
00:0000B78A 66DE            	  1557: 	bne.s exit_ship_move		; just exit half the time
                            	  1558: 
00:0000B78C 0C01004C        	  1559: 	cmpi.b #'L',d1
00:0000B790 664C            	  1560: 	bne.s not_thrust
                            	  1561: ;	TST.l		d1				; test the [L] result
                            	  1562: ;	BPL.s		not_thrust			; if not pressed then go slow the ship
                            	  1563: 
                            	  1564: ; thrust button is pressed so increase the ship velocity
                            	  1565: 
00:0000B792 7202            	  1566: 	MOVEQ		#thrst_snd,d1		; set the thrust sound
00:0000B794 61002568        	  1567: 	BSR		play_sample			; play the sample and return
                            	  1568: 
00:0000B798 102B001E        	  1569: 	MOVE.b	p_orient(a3),d0		; get the player orientation
00:0000B79C 610007CC        	  1570: 	BSR		cos_d0			; do COS(d0)
00:0000B7A0 EE40            	  1571: 	ASR.w		#7,d0				; scale to 1/128th
                            	  1572: 
00:0000B7A2 1F2D004A        	  1573: 	MOVE.b	p_xvel_off(a5),-(sp)	; get the x velocity high byte
00:0000B7A6 321F            	  1574: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000B7A8 122D007E        	  1575: 	MOVE.b	p_xvlo_off(a5),d1		; get the x velocity low byte
00:0000B7AC D240            	  1576: 	ADD.w		d0,d1				; add the thrust x component
00:0000B7AE 6164            	  1577: 	BSR.s		check_velocity		; limit check the velocity in d1
00:0000B7B0 1B41007E        	  1578: 	MOVE.b	d1,p_xvlo_off(a5)		; save the x velocity low byte
00:0000B7B4 3F01            	  1579: 	MOVE.w	d1,-(sp)			; save the word
00:0000B7B6 1B5F004A        	  1580: 	MOVE.b	(sp)+,p_xvel_off(a5)	; save the x velocity high byte
                            	  1581: 
00:0000B7BA 102B001E        	  1582: 	MOVE.b	p_orient(a3),d0		; get the player orientation
00:0000B7BE 610007AE        	  1583: 	BSR		sin_d0			; do SIN(d0)
00:0000B7C2 EE40            	  1584: 	ASR.w		#7,d0				; scale to 1/128th
                            	  1585: 
00:0000B7C4 1F2D006D        	  1586: 	MOVE.b	p_yvel_off(a5),-(sp)	; get the y velocity high byte
00:0000B7C8 321F            	  1587: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000B7CA 122D007F        	  1588: 	MOVE.b	p_yvlo_off(a5),d1		; get the y velocity low byte
00:0000B7CE D240            	  1589: 	ADD.w		d0,d1				; add the thrust y component
00:0000B7D0 6142            	  1590: 	BSR.s		check_velocity		; limit check the velocity in d1
00:0000B7D2 1B41007F        	  1591: 	MOVE.b	d1,p_yvlo_off(a5)		; save the y velocity low byte
00:0000B7D6 3F01            	  1592: 	MOVE.w	d1,-(sp)			; save the word
00:0000B7D8 1B5F006D        	  1593: 	MOVE.b	(sp)+,p_yvel_off(a5)	; save the y velocity high byte
                            	  1594: 
00:0000B7DC 4E75            	  1595: 	RTS
                            	  1596: 
                            	  1597: ; thrust button is not pressed so slow the ship by adding - 128 ; velocity
                            	  1598: 
                            	  1599: not_thrust
00:0000B7DE 1F2D004A        	  1600: 	MOVE.b	p_xvel_off(a5),-(sp)	; get the x velocity high byte
00:0000B7E2 321F            	  1601: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000B7E4 122D007E        	  1602: 	MOVE.b	p_xvlo_off(a5),d1		; get the x velocity low byte
00:0000B7E8 3001            	  1603: 	MOVE.w	d1,d0				; copy the x velocity
00:0000B7EA EE40            	  1604: 	ASR.w		#7,d0				; scale to 1/128th
00:0000B7EC 9240            	  1605: 	SUB.w		d0,d1				; subtract the x drag component
00:0000B7EE 1B41007E        	  1606: 	MOVE.b	d1,p_xvlo_off(a5)		; save the x velocity low byte
00:0000B7F2 3F01            	  1607: 	MOVE.w	d1,-(sp)			; save the word
00:0000B7F4 1B5F004A        	  1608: 	MOVE.b	(sp)+,p_xvel_off(a5)	; save the x velocity high byte
                            	  1609: 
                            	  1610: ; done the x velocity now do the y
                            	  1611: 
00:0000B7F8 1F2D006D        	  1612: 	MOVE.b	p_yvel_off(a5),-(sp)	; get the y velocity high byte
00:0000B7FC 321F            	  1613: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000B7FE 122D007F        	  1614: 	MOVE.b	p_yvlo_off(a5),d1		; get the y velocity low byte
00:0000B802 3001            	  1615: 	MOVE.w	d1,d0				; copy the y velocity
00:0000B804 EE40            	  1616: 	ASR.w		#7,d0				; scale to 1/128th
00:0000B806 9240            	  1617: 	SUB.w		d0,d1				; subtract the y drag component
00:0000B808 1B41007F        	  1618: 	MOVE.b	d1,p_yvlo_off(a5)		; save the y velocity low byte
00:0000B80C 3F01            	  1619: 	MOVE.w	d1,-(sp)			; save the word
00:0000B80E 1B5F006D        	  1620: 	MOVE.b	(sp)+,p_yvel_off(a5)	; save the y velocity high byte
                            	  1621: 
00:0000B812 4E75            	  1622: 	RTS
                            	  1623: 
                            	  1624: 
                            	  1625: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1626: ;
                            	  1627: ; limit check the velocity in XA
                            	  1628: 
                            	  1629: check_velocity:
00:0000B814 6B0C            	  1630: 	BMI.s		check_neg_velocity	; if negative go check negative limit
                            	  1631: 
00:0000B816 0C414000        	  1632: 	CMPI.w	#$4000,d1			; compare velocity with positive limit
00:0000B81A 6510            	  1633: 	BCS.s		exit_check_velocity	; if less just exit
                            	  1634: 
00:0000B81C 323C3FFF        	  1635: 	MOVE.w	#$3FFF,d1			; else set the velocity
00:0000B820 4E75            	  1636: 	rts
                            	  1637: 
                            	  1638: ; velocity is negative so check against the negative limit
                            	  1639: 
                            	  1640: check_neg_velocity
00:0000B822 0C41C002        	  1641: 	CMPI.w	#$C002,d1			; compare velocity with negative limit
00:0000B826 6404            	  1642: 	BCC.s		exit_check_velocity	; if greater or equal just exit
                            	  1643: 
00:0000B828 323CC001        	  1644: 	MOVE.w	#$C001,d1			; else set the velocity
                            	  1645: exit_check_velocity
00:0000B82C 4E75            	  1646: 	rts
                            	  1647: 
                            	  1648: 
                            	  1649: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1650: ;
                            	  1651: ; check items within $0400 range of the player
                            	  1652: 
                            	  1653: check_clear:
00:0000B82E 7C1C            	  1654: 	moveq #s_flag_off-flags_off,d6
                            	  1655: 							; set the count/index to the saucer
00:0000B830 7E38            	  1656: 	moveq #s_xpos_off-x_pos_off,d7
                            	  1657: 							; set the index to the saucer position
                            	  1658: check_clear_loop
00:0000B832 4A35600C        	  1659: 	tst.b flags_off(a5,d6.w)	; test the item flag
00:0000B836 6F28            	  1660: 	BLE.s		not_closer			; if no item or exploding go do the next item
                            	  1661: 
00:0000B838 30357080        	  1662: 	MOVE.w	x_pos_off(a5,d7.w),d0	; get the item x position
00:0000B83C 906DFFB6        	  1663: 	SUB.w		p_xpos_off(a5),d0		; subtract the player x position
00:0000B840 0C400400        	  1664: 	CMPI.w	#$0400,d0			; compare the result with $0400
00:0000B844 6506            	  1665: 	BCS.s		check_clear_y		; if closer go check the y distance
                            	  1666: 
00:0000B846 0C40FC00        	  1667: 	CMPI.w	#$FC00,d0			; compare the result with -$0400
00:0000B84A 6514            	  1668: 	BCS.s		not_closer			; if not closer go do the next item
                            	  1669: 
                            	  1670: check_clear_y
00:0000B84C 303570C6        	  1671: 	MOVE.w	y_pos_off(a5,d7.w),d0	; get the item y position
00:0000B850 906DFFFC        	  1672: 	SUB.w		p_ypos_off(a5),d0		; subtract the player y position
00:0000B854 0C400400        	  1673: 	CMPI.w	#$0400,d0			; compare the result with $0400
00:0000B858 6510            	  1674: 	BCS.s		is_closer			; if closer go flag within distance and
                            	  1675: 							; increment the hide the player count
                            	  1676: 
00:0000B85A 0C40FC00        	  1677: 	CMPI.w	#$FC00,d0			; compare the result with -$0400
00:0000B85E 640A            	  1678: 	BCC.s		is_closer			; if closer go flag within distance and
                            	  1679: 							; increment the hide the player count
                            	  1680: 
                            	  1681: not_closer
00:0000B860 5547            	  1682: 	SUBQ.w	#2,d7				; decrement the position index
00:0000B862 51CEFFCE        	  1683: 	DBF		d6,check_clear_loop	; decrement the count and loop if more to do
                            	  1684: 
00:0000B866 7000            	  1685: 	MOVEQ		#0,d0				; return Zb = 1
00:0000B868 4E75            	  1686: 	rts
                            	  1687: 
                            	  1688: is_closer
00:0000B86A 522D007A        	  1689: 	ADDQ.b	#1,hide_p_cnt(a5)		; increment the hide the player count
                            	  1690: 							; return Zb = 0
00:0000B86E 4E75            	  1691: 	rts
                            	  1692: 
                            	  1693: 
                            	  1694: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1695: ;
                            	  1696: ; generate new rocks
                            	  1697: 
                            	  1698: make_rocks:
00:0000B870 4A2D0028        	  1699: 	TST.b		s_flag_off(a5)		; test the saucer flag
00:0000B874 660000A0        	  1700: 	BNE		exit_make_rocks		; if existing saucer just exit
                            	  1701: 
00:0000B878 7C34            	  1702: 	MOVEQ		#p_xpos_off-x_pos_off-2,d6
                            	  1703: 							; set the index to the last rock position
00:0000B87A 7A1A            	  1704: 	MOVEQ		#p_flag_off-flags_off-1,d5
                            	  1705: 							; set the count/index to the last rock flag
00:0000B87C 4A2D007B        	  1706: 	TST.b		new_rocks(a5)		; test the generate new rocks flag
00:0000B880 6600008A        	  1707: 	BNE		clear_rocks			; if not counted out go clear all the rocks
                            	  1708: 
                            	  1709: ; these are used as the new rock initial velocity
                            	  1710: 
00:0000B884 7000            	  1711: 	MOVEQ		#0,d0				; clear the longword
00:0000B886 1B40004B        	  1712: 	MOVE.b	d0,s_xvel_off(a5)		; clear the saucer x velocity byte
00:0000B88A 1B40006E        	  1713: 	MOVE.b	d0,s_yvel_off(a5)		; clear the saucer y velocity byte
                            	  1714: 
00:0000B88E 700A            	  1715: 	MOVEQ		#$0A,d0			; set the max value
00:0000B890 B02D007D        	  1716: 	CMP.b		min_rocks(a5),d0		; compare minimum rock count with $0A
00:0000B894 6504            	  1717: 	BCS.s		no_inc_min			; if > skip the increment
                            	  1718: 
00:0000B896 522D007D        	  1719: 	ADDQ.b	#1,min_rocks(a5)		; else decrement the minimum rock count before
                            	  1720: 							; the saucer initial timer starts to decrement
                            	  1721: no_inc_min
00:0000B89A 7800            	  1722: 	MOVEQ		#0,d4				; clear the longword
00:0000B89C 182D0075        	  1723: 	MOVE.b	i_rk_count(a5),d4		; get the initial rock count
00:0000B8A0 5404            	  1724: 	ADDQ.b	#2,d4				; + 2
00:0000B8A2 0C04000B        	  1725: 	CMPI.b	#11,d4			; compare the new rock count with 11 rocks
00:0000B8A6 6302            	  1726: 	BLS.s		no_set_max			; if less or equal just use it
                            	  1727: 
00:0000B8A8 780B            	  1728: 	MOVEQ		#11,d4			; else set the new rock count to 11
                            	  1729: no_set_max
00:0000B8AA 1B440076        	  1730: 	MOVE.b	d4,rock_count(a5)		; save the rock count
00:0000B8AE 1B440075        	  1731: 	MOVE.b	d4,i_rk_count(a5)		; save the initial rock count
                            	  1732: 
00:0000B8B2 7E1C            	  1733: 	MOVEQ		#s_xvel_off-x_vel_off,d7
                            	  1734: 							; set the index to the saucer for a zero initial
                            	  1735: 							; velocity
                            	  1736: 
00:0000B8B4 5344            	  1737: 	SUBQ.w	#1,d4				; adjust for the loop type
                            	  1738: gen_rock_loop
00:0000B8B6 610008BA        	  1739: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B8BA 7018            	  1740: 	MOVEQ		#$18,d0			; set the rock type mask
00:0000B8BC C02B000A        	  1741: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000B8C0 00000004        	  1742: 	ORI.b		#$04,d0			; set the rock size to the largest
00:0000B8C4 1B80500C        	  1743: 	MOVE.b	d0,flags_off(a5,d5.w)	; save the rock flag
00:0000B8C8 610000C4        	  1744: 	BSR		copy_velocity		; copy the saucer velocity, (d7), plus a random
                            	  1745: 							; delta x,y velocity to the new rock, (d5),
                            	  1746: 							; velocity
                            	  1747: 
00:0000B8CC 610008A4        	  1748: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B8D0 7200            	  1749: 	MOVEQ		#0,d1				; clear the other axis position
00:0000B8D2 303C3FFF        	  1750: 	MOVE.w	#$3FFF,d0			; set the starting position mask
00:0000B8D6 C06B000A        	  1751: 	AND.w		PRNlword(a3),d0		; mask a pseudo random word
00:0000B8DA E248            	  1752: 	LSR.w		#1,d0				; shift a random bit into Cb
00:0000B8DC 640C            	  1753: 	BCC.s		rock_on_x			; if Cb = 0 go set the rock at a point along
                            	  1754: 							; the x axis
                            	  1755: 
                            	  1756: ; set the rock at a point along the y axis
                            	  1757: 
00:0000B8DE 0C401800        	  1758: 	CMPI.w	#$1800,d0			; compare the position with the y axis maximum
00:0000B8E2 6504            	  1759: 	BCS.s		rock_y_ok			; if less just use it
                            	  1760: 
00:0000B8E4 024017FF        	  1761: 	ANDI.w	#$17FF,d0			; mask the position to the y axis maximum
                            	  1762: rock_y_ok
00:0000B8E8 C340            	  1763: 	EXG		d1,d0				; swap y value to d1, zero to d0
                            	  1764: 
                            	  1765: ; set the rock at a point along the x axis
                            	  1766: 
                            	  1767: rock_on_x
00:0000B8EA 3B806080        	  1768: 	MOVE.w	d0,x_pos_off(a5,d6.w)	; save the rock x position
00:0000B8EE 3B8160C6        	  1769: 	MOVE.w	d1,y_pos_off(a5,d6.w)	; save the rock y position
00:0000B8F2 5546            	  1770: 	SUBQ.w	#2,d6				; decrement the rock position index
00:0000B8F4 5345            	  1771: 	SUBQ.w	#1,d5				; decrement the rock count/index
00:0000B8F6 51CCFFBE        	  1772: 	DBF		d4,gen_rock_loop		; decrement the new rock count and loop if more
                            	  1773: 							; to do
                            	  1774: 
00:0000B8FA 1B7C007F0077    	  1775: 	MOVE.b	#$7F,sauc_cntdn(a5)	; set the saucer countdown timer
00:0000B900 1B7C0034007C    	  1776: 	MOVE.b	#$34,thmp_sndi(a5)	; reset the thump sound change timer initial
                            	  1777: 							; value
00:0000B906 177C00080023    	  1778: 	MOVE.b	#beat1_snd,thump_snd(a3)
                            	  1779: 							; reset the thump sound value
                            	  1780: 
                            	  1781: ; now clear all the other rocks
                            	  1782: 
                            	  1783: clear_rocks
00:0000B90C 7000            	  1784: 	MOVEQ		#0,d0				; clear the longword
                            	  1785: clear_rocks_loop
00:0000B90E 1B80500C        	  1786: 	MOVE.b	d0,flags_off(a5,d5.w)	; clear the rock flag
00:0000B912 51CDFFFA        	  1787: 	DBF		d5,clear_rocks_loop	; decrement the count and loop if more to do
                            	  1788: 
                            	  1789: exit_make_rocks
00:0000B916 4E75            	  1790: 	rts
                            	  1791: 
                            	  1792: 
                            	  1793: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1794: ;
                            	  1795: ; initialise the player variables
                            	  1796: 
                            	  1797: player_init:
00:0000B918 1B6B001B0082    	  1798: 	move.b ss_count(a3),ships_off(a5)
                            	  1799: 							; set the player's starting ship count
00:0000B91E 1B7C00920078    	  1800: 	move.b #$92,i_sauc_tim(a5)	; set the small saucer boundary/initial saucer
                            	  1801: 							; timer
00:0000B924 1B7C00920077    	  1802: 	move.b #$92,sauc_cntdn(a5)	; set the saucer countdown timer
00:0000B92A 1B7C007F007B    	  1803: 	move.b #$7F,new_rocks(a5)	; set the generate new rocks flag
                            	  1804: 
00:0000B930 1B7C0005007D    	  1805: 	move.b #$05,min_rocks(a5)	; set the minimum rock count before the saucer
                            	  1806: 							; initial timer starts to decrement
00:0000B936 1B7C0034007C    	  1807: 	move.b #$34,thmp_sndi(a5)	; reset the thump sound change timer initial
                            	  1808: 							; value
00:0000B93C 177C00080023    	  1809: 	move.b #beat1_snd,thump_snd(a3)	; reset the thump sound value
00:0000B942 1B7C00FF0083    	  1810: 	move.b #$FF,high_off(a5)		; clear the player highscore flag
00:0000B948 1B7C0001007A    	  1811: 	move.b #$01,hide_p_cnt(a5)	; set the hide the player count
                            	  1812: 
                            	  1813: 
                            	  1814: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1815: ;
                            	  1816: ; reset the player velocity and position
                            	  1817: 
                            	  1818: player_reset:
00:0000B94E 3B7C1000FFB6    	  1819: 	move.w #$1000,p_xpos_off(a5)	; set the player x position
00:0000B954 3B7C0C00FFFC    	  1820: 	move.w #$0C00,p_ypos_off(a5)	; set the player y position
00:0000B95A 422D004A        	  1821: 	clr.b p_xvel_off(a5)					; clear the player x velocity
00:0000B95E 422D006D        	  1822: 	clr.b p_yvel_off(a5)					; clear the player y velocity
00:0000B962 4E75            	  1823: 	rts
                            	  1824: 
                            	  1825: 
                            	  1826: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1827: ;
                            	  1828: ; copy the item parameters from the old rock, (d7), to the new rock, (d5)
                            	  1829: 
                            	  1830: copy_rock:
00:0000B964 3807            	  1831: 	MOVE.w	d7,d4				; copy the old rock index
00:0000B966 D844            	  1832: 	ADD.w		d4,d4				; ; 2 for the old rock position index
                            	  1833: 
                            	  1834: copy_rock_2
00:0000B968 3605            	  1835: 	MOVE.w	d5,d3				; copy the new rock index
00:0000B96A D643            	  1836: 	ADD.w		d3,d3				; ; 2 for the new rock position index
                            	  1837: 
00:0000B96C 7207            	  1838: 	MOVEQ		#$07,d1			; set the size mask
00:0000B96E C235700C        	  1839: 	AND.b		flags_off(a5,d7.w),d1	; mask the old rock size
00:0000B972 610007FE        	  1840: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B976 7018            	  1841: 	MOVEQ		#$18,d0			; set the rock type mask
00:0000B978 C02B000A        	  1842: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000B97C 8001            	  1843: 	OR.b		d1,d0				; OR in the old rock size
00:0000B97E 1B80500C        	  1844: 	MOVE.b	d0,flags_off(a5,d5.w)	; save the new rock flag
                            	  1845: 
00:0000B982 3BB540803080    	  1846: 	MOVE.w	x_pos_off(a5,d4.w),x_pos_off(a5,d3.w)
                            	  1847: 							; copy the old rock x position to the new rock
                            	  1848: 							; x position
00:0000B988 3BB540C630C6    	  1849: 	MOVE.w	y_pos_off(a5,d4.w),y_pos_off(a5,d3.w)
                            	  1850: 							; copy the old rock y position to the new rock
                            	  1851: 							; y position
                            	  1852: 
                            	  1853: 
                            	  1854: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1855: ;
                            	  1856: ; copy the old rock, (d7), velocity plus random delta x,y velocity to the new rock,
                            	  1857: ; (d5), velocity
                            	  1858: 
                            	  1859: copy_velocity:
00:0000B98E 610007E2        	  1860: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B992 708F            	  1861: 	MOVEQ		#$8F,d0			; mask +/- $00 to $0F
00:0000B994 C02B000A        	  1862: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000B998 6A04            	  1863: 	BPL.s		x_off_pos			; skip bits set if positive
                            	  1864: 
00:0000B99A 00000070        	  1865: 	ORI.b		#$70,d0			; else make $Fx
                            	  1866: x_off_pos
00:0000B99E D035702F        	  1867: 	ADD.b		x_vel_off(a5,d7.w),d0	; add the item (d7) to the delta x velocity
00:0000B9A2 6120            	  1868: 	BSR.s		limit_velocity		; ensure velocity is within limits
00:0000B9A4 1B80502F        	  1869: 	MOVE.b	d0,x_vel_off(a5,d5.w)	; save the rock x velocity
                            	  1870: 
                            	  1871: 
00:0000B9A8 610007C8        	  1872: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B9AC 708F            	  1873: 	MOVEQ		#$8F,d0			; mask +/- $00 to $0F
00:0000B9AE C02B000A        	  1874: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000B9B2 6A04            	  1875: 	BPL.s		y_off_pos			; skip bits set if positive
                            	  1876: 
00:0000B9B4 00000070        	  1877: 	ORI.b		#$70,d0			; else make $Fx
                            	  1878: y_off_pos
00:0000B9B8 D0357052        	  1879: 	ADD.b		y_vel_off(a5,d7.w),d0	; add the item (d5) to the delta y velocity
00:0000B9BC 6106            	  1880: 	BSR.s		limit_velocity		; ensure velocity is within limits
00:0000B9BE 1B805052        	  1881: 	MOVE.b	d0,y_vel_off(a5,d5.w)	; save the rock y velocity
                            	  1882: 
00:0000B9C2 4E75            	  1883: 	RTS
                            	  1884: 
                            	  1885: 
                            	  1886: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1887: ;
                            	  1888: ; ensure velocity is within limits
                            	  1889: 
                            	  1890: limit_velocity:
00:0000B9C4 6A12            	  1891: 	BPL.s		limit_p_vel			; if positive go test positive limit
                            	  1892: 
00:0000B9C6 0C0000E1        	  1893: 	CMPI.b	#$E1,d0			; compare velocity with upper limit
00:0000B9CA 6402            	  1894: 	BCC.s		neg_upper_ok		; if less skip set
                            	  1895: 
00:0000B9CC 70E1            	  1896: 	MOVEQ		#$E1,d0			; else set velocity to -$1F
                            	  1897: neg_upper_ok
00:0000B9CE 0C0000FB        	  1898: 	CMPI.b	#$FB,d0			; compare velocity with lower limit
00:0000B9D2 6514            	  1899: 	BCS.s		exit_limit_velocity	; if greater just exit
                            	  1900: 
00:0000B9D4 70FA            	  1901: 	MOVEQ		#$FA,d0			; else set velocity to -$06
00:0000B9D6 4E75            	  1902: 	RTS
                            	  1903: 
                            	  1904: ; test velocity positive limit
                            	  1905: 
                            	  1906: limit_p_vel
00:0000B9D8 0C000006        	  1907: 	CMPI.b	#$06,d0			; compare velocity with lower limit
00:0000B9DC 6402            	  1908: 	BCC.s		pos_lower_ok		; skip set if greater
                            	  1909: 
00:0000B9DE 7006            	  1910: 	MOVEQ		#$06,d0			; else set velocity to $06
                            	  1911: pos_lower_ok
00:0000B9E0 0C000020        	  1912: 	CMPI.b	#$20,d0			; compare velocity with upper limit
00:0000B9E4 6502            	  1913: 	BCS.s		exit_limit_velocity	; if less just exit
                            	  1914: 
00:0000B9E6 701F            	  1915: 	MOVEQ		#$1F,d0			; else set velocity to $1F
                            	  1916: exit_limit_velocity
00:0000B9E8 4E75            	  1917: 	RTS
                            	  1918: 
                            	  1919: 
                            	  1920: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1921: ;
                            	  1922: ; add (c), scores and players ships to the vector list
                            	  1923: 
                            	  1924: static_messages:
00:0000B9EA 43FA18E2        	  1925: 	LEA		copy_msg(pc),a1		; set the pointer to the copyright message
00:0000B9EE 610006BA        	  1926: 	BSR		add_address			; convert the a1 address and add it to the
                            	  1927: 							; vector list as a vector subroutine call
                            	  1928: 
00:0000B9F2 36BC1000        	  1929: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
00:0000B9F6 7219            	  1930: 	MOVEQ		#$19,d1			; set the score x co-ordinate
00:0000B9F8 343C00D7        	  1931: 	MOVE.w	#$D7,d2			; set the score y co-ordinate
00:0000B9FC 610006C2        	  1932: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1933: 							; a draw command
                            	  1934: 
00:0000BA00 323C7000        	  1935: 	MOVE.w	#REL7,d1			; make a $7000,$0000 command
00:0000BA04 610006D4        	  1936: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  1937: 
00:0000BA08 0C2B0002001A    	  1938: 	CMPI.b	#$02,num_players(a3)	; compare the number of players in the game
00:0000BA0E 661E            	  1939: 	BNE.s		skip_play_flash		; if not two players skip flashing the active
                            	  1940: 							; player
                            	  1941: 
00:0000BA10 4A2B0018        	  1942: 	TST.b		player_idx(a3)		; test the player index
00:0000BA14 6618            	  1943: 	BNE.s		skip_play_flash		; if player 2 go add the player to the vector
                            	  1944: 							; list
                            	  1945: 
00:0000BA16 102D0027        	  1946: 	MOVE.b	p_flag_off(a5),d0		; get the player flag
00:0000BA1A 802B0026        	  1947: 	OR.b		hyper(a3),d0		; OR with the hyperspace flag
00:0000BA1E 660E            	  1948: 	BNE.s		skip_play_flash		; if playing go add player 1's score to the
                            	  1949: 							; vector list
                            	  1950: 
00:0000BA20 4A2D007A        	  1951: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:0000BA24 6B08            	  1952: 	BMI.s		skip_play_flash		; if the player is dieing go display the score
                            	  1953: 
00:0000BA26 082B0004005A    	  1954: 	BTST.b	#4,game_count+1(a3)	; test a bit in the game counter low byte
00:0000BA2C 6714            	  1955: 	BEQ.s		do_p1_ships			; skip the score display if the flash is off
                            	  1956: 
                            	  1957: ; add the active player to the vector list
                            	  1958: 
                            	  1959: skip_play_flash
00:0000BA2E 43EB0173        	  1960: 	LEA		p1_score(a3),a1		; point to player 1's score
00:0000BA32 7E02            	  1961: 	MOVEQ		#$02,d7			; set the number byte count
00:0000BA34 17470016        	  1962: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000BA38 61000512        	  1963: 	BSR		output_number		; output the number (a1) as a leading zero
                            	  1964: 							; suppressed character string
00:0000BA3C 7200            	  1965: 	MOVEQ		#0,d1				; add player 1's score's trailing "0"
00:0000BA3E 61000650        	  1966: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  1967: 
                            	  1968: do_p1_ships
00:0000BA42 7229            	  1969: 	MOVEQ		#$29,d1			; set the x co-ordinate for player 1's ships
00:0000BA44 7E00            	  1970: 	MOVEQ		#0,d7				; clear the longword
00:0000BA46 1E2B0175        	  1971: 	MOVE.b	p1_ships(a3),d7		; get player 1's ship count
00:0000BA4A 6100FBB2        	  1972: 	BSR		add_ships			; add d7 ships to the vector list
                            	  1973: 
00:0000BA4E 4253            	  1974: 	MOVE.w	#$0000,glob_scale(a3)	; set the global scale
                            	  1975: 
00:0000BA50 7278            	  1976: 	MOVEQ		#$78,d1			; set the high score x co-ordinate
00:0000BA52 343C00D7        	  1977: 	MOVE.w	#$D7,d2			; set the high score y co-ordinate
00:0000BA56 61000668        	  1978: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1979: 							; a draw command
00:0000BA5A 323C5000        	  1980: 	MOVE.w	#REL5,d1			; make a $5000,$0000 command
00:0000BA5E 6100067A        	  1981: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  1982: 
00:0000BA62 43EB0027        	  1983: 	LEA		hiscores(a3),a1		; point to the highest high score
00:0000BA66 7E02            	  1984: 	MOVEQ		#$02,d7			; set the number byte count
00:0000BA68 17470016        	  1985: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000BA6C 610004DE        	  1986: 	BSR		output_number		; output the number (a1) as a leading zero
                            	  1987: 							; suppressed character string
                            	  1988: 
00:0000BA70 7200            	  1989: 	MOVEQ		#0,d1				; add the high score trailing "0"
00:0000BA72 6100061C        	  1990: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  1991: 
00:0000BA76 36BC1000        	  1992: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
                            	  1993: 
00:0000BA7A 323C00C0        	  1994: 	MOVE.w	#$C0,d1			; set the score x co-ordinate
00:0000BA7E 343C00D7        	  1995: 	MOVE.w	#$D7,d2			; set the score y co-ordinate
00:0000BA82 6100063C        	  1996: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1997: 							; a draw command
00:0000BA86 323C5000        	  1998: 	MOVE.w	#REL5,d1			; make a $5000,$0000 command
00:0000BA8A 6100064E        	  1999: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  2000: 
00:0000BA8E 0C2B0001001A    	  2001: 	CMPI.b	#$01,num_players(a3)	; compare the number of players in the game
                            	  2002: 							; with one
00:0000BA94 6742            	  2003: 	BEQ.s		exit_static			; if just one player skip displaying p2 score
                            	  2004: 
00:0000BA96 651E            	  2005: 	BCS.s		do_p2_score			; if no players go add player 2's score to
                            	  2006: 							; the vector list
                            	  2007: 
00:0000BA98 4A2B0018        	  2008: 	TST.b		player_idx(a3)		; test the player index
00:0000BA9C 6718            	  2009: 	BEQ.s		do_p2_score			; if player 1 go add the player to the vector
                            	  2010: 							; list
                            	  2011: 
00:0000BA9E 102D0027        	  2012: 	MOVE.b	p_flag_off(a5),d0		; get the player flag
00:0000BAA2 802B0026        	  2013: 	OR.b		hyper(a3),d0		; OR with the hyperspace flag
00:0000BAA6 660E            	  2014: 	BNE.s		do_p2_score			; if playing go add player 2's score to the
                            	  2015: 							; vector list
                            	  2016: 
00:0000BAA8 4A2D007A        	  2017: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:0000BAAC 6B08            	  2018: 	BMI.s		do_p2_score			; if the player is dieing go display the score
                            	  2019: 
00:0000BAAE 082B0004005A    	  2020: 	BTST.b	#4,game_count+1(a3)	; test a bit in the game counter low byte
00:0000BAB4 6714            	  2021: 	BEQ.s		skip_p2_score		; skip the score display if the flash is off
                            	  2022: 
                            	  2023: do_p2_score
00:0000BAB6 43EB0277        	  2024: 	LEA		p2_score(a3),a1		; point to player 2's score
00:0000BABA 7E02            	  2025: 	MOVEQ		#$02,d7			; set the number byte count
00:0000BABC 17470016        	  2026: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000BAC0 6100048A        	  2027: 	BSR		output_number		; output the number (a1) as a leading zero
                            	  2028: 							; suppressed character string
00:0000BAC4 7200            	  2029: 	MOVEQ		#0,d1				; add player 2's score's trailing "0"
00:0000BAC6 610005C8        	  2030: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  2031: 
                            	  2032: skip_p2_score
00:0000BACA 323C00D0        	  2033: 	MOVE.w	#$D0,d1			; set the x co-ordinate for player 2's ships
00:0000BACE 7E00            	  2034: 	MOVEQ		#0,d7				; clear the longword
00:0000BAD0 1E2B0279        	  2035: 	MOVE.b	p2_ships(a3),d7		; get player 2's ship count
00:0000BAD4 6000FB28        	  2036: 	BRA		add_ships			; add d7 ships to the vector list and return
                            	  2037: 
                            	  2038: exit_static
00:0000BAD8 4E75            	  2039: 	RTS
                            	  2040: 
                            	  2041: 
                            	  2042: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2043: ;
                            	  2044: ; add an item to the vector list
                            	  2045: ;
                            	  2046: ; d6 = object flag offset
                            	  2047: ; d7 = position offset
                            	  2048: 
                            	  2049: 							; first add the DRAW to the item's origin
                            	  2050: add_to_list:
00:0000BADA 303570C6        	  2051: 	MOVE.w	y_pos_off(a5,d7.w),d0	; get the y position
00:0000BADE D07C0400        	  2052: 	ADD.w		#$0400,d0			; add offset so y is centred around 512
00:0000BAE2 E648            	  2053: 	LSR.w		#3,d0				; / 8
00:0000BAE4 0040A000        	  2054: 	ORI.w		#DRAW,d0			; OR in the draw command
00:0000BAE8 38C0            	  2055: 	MOVE.w	d0,(a4)+			; add it to the vector list
                            	  2056: 
00:0000BAEA 30357080        	  2057: 	MOVE.w	x_pos_off(a5,d7.w),d0	; get the x position
00:0000BAEE E648            	  2058: 	LSR.w		#3,d0				; / 8
00:0000BAF0 8041            	  2059: 	OR.w		d1,d0				; OR in the global scale
00:0000BAF2 38C0            	  2060: 	MOVE.w	d0,(a4)+			; add it to the vector list
                            	  2061: 
00:0000BAF4 7200            	  2062: 	MOVEQ		#0,d1				; clear the longword
00:0000BAF6 1235600C        	  2063: 	MOVE.b	flags_off(a5,d6.w),d1	; get the object flag
00:0000BAFA 6A12            	  2064: 	BPL.s		add_item			; if not exploding go add the item to the
                            	  2065: 							; vector list
                            	  2066: 
                            	  2067: 							; else add an exploding item
00:0000BAFC 0C06001B        	  2068: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  2069: 							; compare the index with the player index
00:0000BB00 6700014A        	  2070: 	BEQ		add_play_explode		; if it is the player go add ship pieces to the
                            	  2071: 							; vector list
                            	  2072: 
00:0000BB04 0201000C        	  2073: 	ANDI.b	#$0C,d1			; else mask the rock type
00:0000BB08 43FA1804        	  2074: 	LEA		expl_tab(pc),a1		; point to the explosion JSRL table
00:0000BB0C 601A            	  2075: 	BRA.s		add_explode			; go add the JSRL word to the vector list and
                            	  2076: 							; return
                            	  2077: 
                            	  2078: ; add item d6 to the vector list
                            	  2079: 
                            	  2080: add_item:
00:0000BB0E 0C06001B        	  2081: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  2082: 							; compare the index with the player index
00:0000BB12 670001DE        	  2083: 	BEQ		add_player			; if = go add the player to the vector list
                            	  2084: 
00:0000BB16 0C06001C        	  2085: 	CMPI.b	#s_flag_off-flags_off,d6
                            	  2086: 							; compare the index with the saucer index
00:0000BB1A 6712            	  2087: 	BEQ.s		add_saucer			; if = go add the saucer to the vector list
                            	  2088: 
00:0000BB1C 6416            	  2089: 	BCC.s		add_fire			; if > saucer go add fire to the vector list
                            	  2090: 
                            	  2091: 							; else add a rock to the vector list
00:0000BB1E 02410018        	  2092: 	ANDI.w	#$0018,d1			; mask the rock type
00:0000BB22 E449            	  2093: 	LSR.w		#2,d1				; >> 3 << 1
00:0000BB24 43FA18CE        	  2094: 	LEA		rock_tab(pc),a1		; point to the rock JSRL table
                            	  2095: add_explode
00:0000BB28 38F11000        	  2096: 	MOVE.w	(a1,d1.w),(a4)+		; add the JSRL word to the vector list
00:0000BB2C 4E75            	  2097: 	RTS
                            	  2098: 
                            	  2099: ; add the saucer to the vector list
                            	  2100: 
                            	  2101: add_saucer:
00:0000BB2E 38FA1936        	  2102: 	MOVE.w	sauc_jsr(pc),(a4)+	; add the saucer JSRL to the vector list
00:0000BB32 4E75            	  2103: 	RTS
                            	  2104: 
                            	  2105: ; add fire to the vector list
                            	  2106: 
                            	  2107: add_fire:
00:0000BB34 38FA1DFE        	  2108: 	MOVE.w	shot_jsr(pc),(a4)+	; add the shot JSRL to the vector list
                            	  2109: 
00:0000BB38 7003            	  2110: 	MOVEQ		#3,d0				; set the game counter mask
00:0000BB3A C06B0059        	  2111: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000BB3E 6604            	  2112: 	BNE.s		no_shot_dec			; skip the shot decrement 3/4 of the time
                            	  2113: 
00:0000BB40 5335600C        	  2114: 	SUBQ.b	#1,flags_off(a5,d6.w)	; decrement fire item (d7) flag
                            	  2115: no_shot_dec
00:0000BB44 4E75            	  2116: 	RTS
                            	  2117: 
                            	  2118: 
                            	  2119: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2120: ;
                            	  2121: ; add d1.b to the current player's score
                            	  2122: 
                            	  2123: add_score:
00:0000BB46 44FC0004        	  2124: 	MOVE.w	#4,CCR			; set Zb, clear everything else
00:0000BB4A 142D0081        	  2125: 	MOVE.b	score_off+1(a5),d2	; get the player's score, tens
00:0000BB4E C501            	  2126: 	ABCD.b	d1,d2				; add the value to the score
00:0000BB50 6422            	  2127: 	BCC.s		exit_add_score		; if no carry just exit
                            	  2128: 
00:0000BB52 7200            	  2129: 	MOVEQ		#0,d1				; clear the add high byte
00:0000BB54 102D0080        	  2130: 	MOVE.b	score_off(a5),d0		; get the player's score, thousands
00:0000BB58 C101            	  2131: 	ABCD.b	d1,d0				; add the value to the score
00:0000BB5A 1B400080        	  2132: 	MOVE.b	d0,score_off(a5)		; save the player's score, thousands
                            	  2133: 
00:0000BB5E 0200000F        	  2134: 	ANDI.b	#$0F,d0			; mask the units of thousands
00:0000BB62 6610            	  2135: 	BNE.s		exit_add_score		; if the score is not x0000 just exit
                            	  2136: 
00:0000BB64 720A            	  2137: 	MOVEQ		#extra_snd,d1		; set the bonus ship sound
00:0000BB66 61002196        	  2138: 	BSR		play_sample			; go play the sample
                            	  2139: 
00:0000BB6A 522D0082        	  2140: 	ADDQ.b	#1,ships_off(a5)		; increment the player's ship count
00:0000BB6E 6604            	  2141: 	BNE.s		exit_add_score		; exit if not wrappwd
                            	  2142: 
00:0000BB70 532D0082        	  2143: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
                            	  2144: exit_add_score
00:0000BB74 1B420081        	  2145: 	MOVE.b	d2,score_off+1(a5)	; save the player's score, tens
00:0000BB78 4E75            	  2146: 	RTS
                            	  2147: 
                            	  2148: 
                            	  2149: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2150: ;
                            	  2151: ; display the high score table if the game is over
                            	  2152: 
                            	  2153: high_scores:
00:0000BB7A 4A2B001A        	  2154: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000BB7E 660000A0        	  2155: 	BNE		exit_no_scores		; if playing skip the high scores
                            	  2156: 
00:0000BB82 082B00020059    	  2157: 	BTST.b	#2,game_count(a3)		; test a bit in the game counter high byte
00:0000BB88 66000096        	  2158: 	BNE		exit_no_scores		; if not high score time just exit
                            	  2159: 
00:0000BB8C 45EB0027        	  2160: 	LEA		hiscores(a3),a2		; point to the high score table
                            	  2161: 
00:0000BB90 4A52            	  2162: 	TST.w		(a2)				; test the highest high score
00:0000BB92 6700008C        	  2163: 	BEQ		exit_no_scores		; if the high score table is empty just exit
                            	  2164: 
00:0000BB96 7200            	  2165: 	MOVEQ		#0,d1				; message 0 - "HIGH SCORES"
00:0000BB98 61000470        	  2166: 	BSR		add_message			; add message d1 to the display list
                            	  2167: 
00:0000BB9C 36BC1000        	  2168: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
                            	  2169: 
00:0000BBA0 41EB003B        	  2170: 	LEA		hinames(a3),a0		; point to the high score names
00:0000BBA4 7C00            	  2171: 	MOVEQ		#0,d6				; clear the high score index
00:0000BBA6 377C00A70012    	  2172: 	MOVE.w	#$00A7,hiscore_y(a3)	; set the score's y co-ordinate
                            	  2173: high_scores_loop
00:0000BBAC 4A52            	  2174: 	TST.w		(a2)				; test the high score entry
00:0000BBAE 676A            	  2175: 	BEQ.s		exit_high_scores		; if this score is zero just exit
                            	  2176: 
00:0000BBB0 725F            	  2177: 	MOVEQ		#$5F,d1			; set the score's x co-ordinate
00:0000BBB2 342B0012        	  2178: 	MOVE.w	hiscore_y(a3),d2		; get the score's y co-ordinate
00:0000BBB6 61000508        	  2179: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  2180: 							; a draw command
                            	  2181: 
00:0000BBBA 323C4000        	  2182: 	MOVE.w	#REL4,d1			; make a $4000,$0000 command
00:0000BBBE 6100051A        	  2183: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  2184: 
00:0000BBC2 43EB0017        	  2185: 	LEA		high_idx(a3),a1		; point to the high score index
00:0000BBC6 7E01            	  2186: 	MOVEQ		#$01,d7			; set the number byte count and the increment
00:0000BBC8 44FC0004        	  2187: 	MOVE.w	#4,CCR			; set Zb, clear everything else
00:0000BBCC CD07            	  2188: 	ABCD.b	d7,d6				; add to the high score index
00:0000BBCE 1286            	  2189: 	MOVE.b	d6,(a1)			; save the high score decimal index
00:0000BBD0 17470016        	  2190: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000BBD4 61000376        	  2191: 	BSR		output_number		; output a number as a leading zero suppressed
                            	  2192: 							; string
                            	  2193: 
                            	  2194: 							; set the point after the high score number
00:0000BBD8 323C4000        	  2195: 	MOVE.w	#REL4,d1			; make a $4000,$xx00 command
00:0000BBDC 3401            	  2196: 	MOVE.w	d1,d2				; make a $4000,$4000 command, point after entry
                            	  2197: 							; number
00:0000BBDE 610004FC        	  2198: 	BSR		add_pair			; add (d1)00,(d2)00 to the vector list
                            	  2199: 
00:0000BBE2 7200            	  2200: 	MOVEQ		#0,d1				; set [SPACE] character
00:0000BBE4 6100FA08        	  2201: 	BSR		add_character		; add character (d1) to the vector list
                            	  2202: 
00:0000BBE8 224A            	  2203: 	MOVEA.l	a2,a1				; point to the high score entry
00:0000BBEA 7E02            	  2204: 	MOVEQ		#$02,d7			; set the number byte count
00:0000BBEC 177C00FF0016    	  2205: 	MOVE.b	#-1,suppress_0(a3)	; set the flag to suppress leading zeros
00:0000BBF2 61000358        	  2206: 	BSR		output_number		; output a number as a leading zero suppressed
                            	  2207: 							; string
                            	  2208: 
00:0000BBF6 7200            	  2209: 	MOVEQ		#0,d1				; add the final "0"
00:0000BBF8 61000496        	  2210: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  2211: 
00:0000BBFC 7200            	  2212: 	MOVEQ		#0,d1				; set [SPACE] character
00:0000BBFE 6100F9EE        	  2213: 	BSR		add_character		; add character (d1) to the vector list
                            	  2214: 
00:0000BC02 6100F9D0        	  2215: 	BSR		write_initial		; write a high score initial to the vector list
00:0000BC06 6100F9CC        	  2216: 	BSR		write_initial		; write a high score initial to the vector list
00:0000BC0A 6100F9C8        	  2217: 	BSR		write_initial		; write a high score initial to the vector list
                            	  2218: 
00:0000BC0E 516B0012        	  2219: 	SUBQ.w	#8,hiscore_y(a3)		; subtract 8 from the score's y co-ordinate
00:0000BC12 544A            	  2220: 	ADDQ.w	#2,a2				; increment the high score pointer
                            	  2221: 
00:0000BC14 0C060010        	  2222: 	CMPI.b	#$10,d6			; compare the high score index with 10
00:0000BC18 6592            	  2223: 	BCS.s		high_scores_loop		; loop if more to do
                            	  2224: 
                            	  2225: exit_high_scores
00:0000BC1A 003C0001        	  2226: 	ORI.b		#$01,CCR			; set the carry, flag scores displayed
00:0000BC1E 4E75            	  2227: 	RTS
                            	  2228: 
                            	  2229: exit_no_scores
00:0000BC20 023C00FE        	  2230: 	ANDI.b	#$FE,CCR			; clear the carry, flag scores not displayed
00:0000BC24 4E75            	  2231: 	RTS
                            	  2232: 
                            	  2233: 
                            	  2234: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2235: ;
                            	  2236: ; find a free rock item, the index is returned in d5
                            	  2237: 
                            	  2238: find_rock:
00:0000BC26 7A1A            	  2239: 	MOVEQ		#p_flag_off-flags_off-1,d5
                            	  2240: 							; set the count/index to the last rock flag
                            	  2241: 
                            	  2242: ; find a free rock item from d5
                            	  2243: 
                            	  2244: find_next_rock
00:0000BC28 4A35500C        	  2245: 	TST.b		flags_off(a5,d5.w)	; test the rock flag
00:0000BC2C 6704            	  2246: 	BEQ.s		exit_find_rock		; if free return this index
                            	  2247: 
00:0000BC2E 51CDFFF8        	  2248: 	DBF		d5,find_next_rock		; else loop if more to do
                            	  2249: 
                            	  2250: exit_find_rock
00:0000BC32 4E75            	  2251: 	RTS
                            	  2252: 
                            	  2253: 
                            	  2254: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2255: ;
                            	  2256: ; wrecked ship piece x,y velocities
                            	  2257: 
                            	  2258: ship_wrk_x
00:0000BC34 FFD8            	  2259: 	dc.w	$FFD8					; x
00:0000BC36 0032            	  2260: 	dc.w	$0032					; x
00:0000BC38 0000            	  2261: 	dc.w	$0000					; x
00:0000BC3A 003C            	  2262: 	dc.w	$003C					; x
00:0000BC3C 000A            	  2263: 	dc.w	$000A					; x
00:0000BC3E FFD8            	  2264: 	dc.w	$FFD8					; x
                            	  2265: 
                            	  2266: ship_wrk_y
00:0000BC40 001E            	  2267: 	dc.w	$001E					; y
00:0000BC42 FFEC            	  2268: 	dc.w	$FFEC					; y
00:0000BC44 FFC4            	  2269: 	dc.w	$FFC4					; y
00:0000BC46 0014            	  2270: 	dc.w	$0014					; y
00:0000BC48 0046            	  2271: 	dc.w	$0046					; y
00:0000BC4A FFD8            	  2272: 	dc.w	$FFD8					; y
                            	  2273: 
                            	  2274: 
                            	  2275: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2276: ;
                            	  2277: ; add the player explosion to the vector list
                            	  2278: 
                            	  2279: add_play_explode:
00:0000BC4C 48E70300        	  2280: 	MOVEM.l	d6-d7,-(sp)			; save the registers
00:0000BC50 7200            	  2281: 	MOVEQ		#0,d1				; clear the longword
00:0000BC52 122D0027        	  2282: 	MOVE.b	p_flag_off(a5),d1		; get the player flag
00:0000BC56 0C0100A2        	  2283: 	CMPI.b	#$A2,d1			; compare the player flag with $A2
00:0000BC5A 641A            	  2284: 	BCC.s		no_reset_xy			; if >= $A2 skip resetting the explosion
                            	  2285: 							; start point
                            	  2286: 
                            	  2287: 							; else reset the explosion start point
00:0000BC5C 7E0A            	  2288: 	MOVEQ		#$0A,d7			; set the index to the last piece x,y pair
                            	  2289: reset_xy_loop
00:0000BC5E 303B70D4        	  2290: 	MOVE.w	ship_wrk_x(pc,d7.w),d0	; get the x velocity word
00:0000BC62 E948            	  2291: 	LSL.w		#4,d0				; ; 16
00:0000BC64 3780705B        	  2292: 	MOVE.w	d0,expl_x_pos(a3,d7.w)	; save the x position word
                            	  2293: 
00:0000BC68 303B70D6        	  2294: 	MOVE.w	ship_wrk_y(pc,d7.w),d0	; get the y velocity word
00:0000BC6C E948            	  2295: 	LSL.w		#4,d0				; ; 16
00:0000BC6E 37807067        	  2296: 	MOVE.w	d0,expl_y_pos(a3,d7.w)	; save the y position word
                            	  2297: 
00:0000BC72 5547            	  2298: 	SUBQ.w	#2,d7				; decrement the index
00:0000BC74 6AE8            	  2299: 	BPL.s		reset_xy_loop		; loop if more to do
                            	  2300: 
                            	  2301: ; now use the player flag as the start index to the ship pieces. this means there will
                            	  2302: ; be less pieces as the explosion progresses
                            	  2303: 
                            	  2304: no_reset_xy
00:0000BC76 7070            	  2305: 	MOVEQ		#$70,d0			; set the mask
00:0000BC78 B101            	  2306: 	EOR.b		d0,d1				; toggle the player flag
00:0000BC7A C200            	  2307: 	AND.b		d0,d1				; mask the player flag
00:0000BC7C E609            	  2308: 	LSR.b		#3,d1				; / 16 ; 2 gives the piece start index
00:0000BC7E 3E01            	  2309: 	MOVE.w	d1,d7				; copy the index
                            	  2310: 
                            	  2311: 							; the piece draw loop	
                            	  2312: piece_draw_loop
00:0000BC80 303B70B2        	  2313: 	MOVE.w	ship_wrk_x(pc,d7.w),d0	; get the x velocity word
00:0000BC84 D073705B        	  2314: 	ADD.w		expl_x_pos(a3,d7.w),d0	; add the x position word
00:0000BC88 3780705B        	  2315: 	MOVE.w	d0,expl_x_pos(a3,d7.w)	; save the x position word
                            	  2316: 
00:0000BC8C 323B70B2        	  2317: 	MOVE.w	ship_wrk_y(pc,d7.w),d1	; get the y velocity word
00:0000BC90 D2737067        	  2318: 	ADD.w		expl_y_pos(a3,d7.w),d1	; add the y position word
00:0000BC94 37817067        	  2319: 	MOVE.w	d1,expl_y_pos(a3,d7.w)	; save the y position word
                            	  2320: 
00:0000BC98 244C            	  2321: 	MOVEA.l	a4,a2				; copy the vector pointer
                            	  2322: 
00:0000BC9A 7400            	  2323: 	MOVEQ		#0,d2				; clear the x sign bit
00:0000BC9C 4A40            	  2324: 	TST.w		d0				; test the x position word
00:0000BC9E 6A06            	  2325: 	BPL.s		vec_x_pos			; if positive skip the negate
                            	  2326: 
00:0000BCA0 4440            	  2327: 	NEG.w		d0				; else negate the x position, make it positive
00:0000BCA2 343C0400        	  2328: 	MOVE.w	#$0400,d2			; and set the x sign bit
                            	  2329: vec_x_pos
                            	  2330: 
00:0000BCA6 7600            	  2331: 	MOVEQ		#0,d3				; clear the y sign bit
00:0000BCA8 4A41            	  2332: 	TST.w		d1				; test the y position word
00:0000BCAA 6A06            	  2333: 	BPL.s		vec_y_pos			; if positive skip the negate
                            	  2334: 
00:0000BCAC 4441            	  2335: 	NEG.w		d1				; else negate the y position, make it positive
00:0000BCAE 363C0400        	  2336: 	MOVE.w	#$0400,d3			; and set the y sign bit
                            	  2337: vec_y_pos
00:0000BCB2 E848            	  2338: 	LSR.w		#4,d0				; shift the x position
00:0000BCB4 E849            	  2339: 	LSR.w		#4,d1				; shift the y position
                            	  2340: 
00:0000BCB6 8042            	  2341: 	OR.w		d2,d0				; OR in the x sign bit
00:0000BCB8 00416000        	  2342: 	ORI.w		#$6000,d1			; fix the scale
00:0000BCBC 8243            	  2343: 	OR.w		d3,d1				; OR in the y sign bit
                            	  2344: 
00:0000BCBE 38C1            	  2345: 	MOVE.w	d1,(a4)+			; add y position to the vector list
00:0000BCC0 38C0            	  2346: 	MOVE.w	d0,(a4)+			; add x position to the vector list
                            	  2347: 
                            	  2348: 							; add the piece vector to the list
                            	  2349: 
00:0000BCC2 303B7022        	  2350: 	MOVE.w	ship_parts(pc,d7.w),d0	; get wrecked ship piece vector word
00:0000BCC6 38C0            	  2351: 	MOVE.w	d0,(a4)+			; add the wrecked ship piece vector word to the
                            	  2352: 							; vector list
                            	  2353: 
00:0000BCC8 0A400404        	  2354: 	EORI.w	#$0404,d0			; toggle the sign bits
00:0000BCCC 0240FF0F        	  2355: 	ANDI.w	#$FF0F,d0			; clear the intensity bits
00:0000BCD0 38C0            	  2356: 	MOVE.w	d0,(a4)+			; add the inverse wrecked ship piece vector word
                            	  2357: 							; to the vector list
                            	  2358: 
                            	  2359: 							; now copy an inverse relative long vector to
                            	  2360: 							; the list
00:0000BCD2 2012            	  2361: 	MOVE.l	(a2),d0			; get the vector to the piece
00:0000BCD4 0A8004000400    	  2362: 	EORI.l	#$04000400,d0		; toggle the sign bits
00:0000BCDA 28C0            	  2363: 	MOVE.l	d0,(a4)+			; save the inverse vector to the list
                            	  2364: 
00:0000BCDC 5547            	  2365: 	SUBQ.w	#2,d7				; decrement the index
00:0000BCDE 6AA0            	  2366: 	BPL		piece_draw_loop		; loop if more to do
                            	  2367: 
00:0000BCE0 4CDF00C0        	  2368: 	MOVEM.l	(sp)+,d6-d7			; restore the registers
00:0000BCE4 4E75            	  2369: 	rts
                            	  2370: 
                            	  2371: 
                            	  2372: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2373: ;
                            	  2374: ; pieces of wrecked ship
                            	  2375: 
                            	  2376: ship_parts
00:0000BCE6 FFC6            	  2377: 	dc.w	$FFC6				; x = -2, Y = -3
00:0000BCE8 FEC1            	  2378: 	dc.w	$FEC1				; x =  1, Y = -2
00:0000BCEA F1C3            	  2379: 	dc.w	$F1C3				; x =  3, Y =  1
00:0000BCEC F1CD            	  2380: 	dc.w	$F1CD				; x = -1, Y =  1
00:0000BCEE F1C7            	  2381: 	dc.w	$F1C7				; x = -3, Y =  1
00:0000BCF0 FDC1            	  2382: 	dc.w	$FDC1				; x =  1, Y = -1
                            	  2383: 
                            	  2384: 
                            	  2385: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2386: ;
                            	  2387: ; add the player ship to the vector list
                            	  2388: 
                            	  2389: add_player:
00:0000BCF2 7600            	  2390: 	MOVEQ		#0,d3				; clear the x_sign
00:0000BCF4 7400            	  2391: 	MOVEQ		#0,d2				; clear the y_sign
00:0000BCF6 7800            	  2392: 	MOVEQ		#0,d4				; yx_sign
                            	  2393: 
00:0000BCF8 122B001E        	  2394: 	MOVE.b	p_orient(a3),d1		; get the player orientation
00:0000BCFC 6A0A            	  2395: 	BPL.s		no_pos_reflect		; if positive skip reflection
                            	  2396: 
00:0000BCFE 343C0400        	  2397: 	MOVE.w	#$0400,d2			; set the y_sign
00:0000BD02 3802            	  2398: 	MOVE.w	d2,d4				; set the yx_sign
00:0000BD04 4401            	  2399: 	NEG.b		d1				; make ABS orientation
00:0000BD06 6B06            	  2400: 	BMI.s		third_quad			; if still negative go do the third quad
                            	  2401: 
                            	  2402: no_pos_reflect
00:0000BD08 08010006        	  2403: 	BTST.l	#6,d1				; test the quadrant
00:0000BD0C 670E            	  2404: 	BEQ.s		first_quad			; skip reflect if in first quadrant
                            	  2405: 
                            	  2406: third_quad
00:0000BD0E 363C0400        	  2407: 	MOVE.w	#$0400,d3			; set the x_sign
00:0000BD12 183C0004        	  2408: 	MOVE.b	#$04,d4			; set the yx_sign
                            	  2409: 
00:0000BD16 4401            	  2410: 	NEG.b		d1				; negate the byte
00:0000BD18 D23C0080        	  2411: 	ADD.b		#$80,d1			; reflect the quadrant
                            	  2412: first_quad
00:0000BD1C E209            	  2413: 	LSR.b		#1,d1				; do quadrant value / 2
00:0000BD1E C23C003E        	  2414: 	AND.b		#$3E,d1			; mask to word boundary, value is $00 to $20
                            	  2415: 
00:0000BD22 43FA1760        	  2416: 	LEA		play_tab(pc),a1		; point to the player ship table
00:0000BD26 32311000        	  2417: 	MOVE.w	(a1,d1.w),d1		; get the offset to the player ship
00:0000BD2A 43F11000        	  2418: 	LEA		(a1,d1.w),a1		; get the pointer to the player ship
00:0000BD2E 6118            	  2419: 	BSR.s		copy_vectors		; copy the vectors from (a1) to the vector list
                            	  2420: 
                            	  2421: ;	MOVEQ		#'L',d1			; set for the thrust button
                            	  2422: ;	MOVEQ		#19,d0			; check for keypress
                            	  2423: ;	TRAP		#15
00:0000BD30 7005            	  2424: 	moveq #5,d0
00:0000BD32 4E4F            	  2425: 	trap #15
00:0000BD34 0C01004C        	  2426: 	cmpi.b #'L',d1
00:0000BD38 6608            	  2427: 	bne.s no_thrust
                            	  2428: 
                            	  2429: ;	TST.b		d1				; test the result
                            	  2430: ;	BEQ.s		no_thrust			; if not pressed then skip the thrust copy
                            	  2431: 
00:0000BD3A 7003            	  2432: 	MOVEQ		#3,d0				; set the game counter mask
00:0000BD3C C06B0059        	  2433: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000BD40 6606            	  2434: 	BNE.s		copy_vectors		; 3/4 of the time go copy the vectors from (a1)
                            	  2435: 							; to the vector list and return
                            	  2436: no_thrust
00:0000BD42 4E75            	  2437: 	RTS
                            	  2438: 
                            	  2439: 
                            	  2440: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2441: ;
                            	  2442: ; copy the vectors from (a1) to the vector list
                            	  2443: 
                            	  2444: copy_short:
00:0000BD44 B940            	  2445: 	EOR.w		d4,d0				; possibly toggle the x and y signs
00:0000BD46 38C0            	  2446: 	MOVE.w	d0,(a4)+			; copy the word to the vector list
                            	  2447: 
                            	  2448: copy_vectors
00:0000BD48 3019            	  2449: 	MOVE.w	(a1)+,d0			; get a vector word
00:0000BD4A B07CF000        	  2450: 	CMP.w		#SHRT,d0			; compare with short form vector
00:0000BD4E 64F4            	  2451: 	BCC.s		copy_short			; if short vector go copy it
                            	  2452: 
00:0000BD50 B07CA000        	  2453: 	CMP.w		#DRAW,d0			; compare with the DRAW command
00:0000BD54 640C            	  2454: 	BCC.s		exit_copy_vectors		; if DRAW or greater exit the vector copy
                            	  2455: 
                            	  2456: ; else it is a long vector
                            	  2457: 
00:0000BD56 B540            	  2458: 	EOR.w		d2,d0				; possibly toggle the y sign
00:0000BD58 38C0            	  2459: 	MOVE.w	d0,(a4)+			; copy the word to the vector list
00:0000BD5A 3019            	  2460: 	MOVE.w	(a1)+,d0			; get the second vector word
00:0000BD5C B740            	  2461: 	EOR.w		d3,d0				; possibly toggle the x sign
00:0000BD5E 38C0            	  2462: 	MOVE.w	d0,(a4)+			; copy the word to the vector list
00:0000BD60 60E6            	  2463: 	BRA.s		copy_vectors		; go do the next word
                            	  2464: 
                            	  2465: ; it's a short form vector
                            	  2466: 
                            	  2467: exit_copy_vectors
00:0000BD62 4E75            	  2468: 	RTS
                            	  2469: 
                            	  2470: 
                            	  2471: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2472: ;
                            	  2473: ; do the game sounds
                            	  2474: 
                            	  2475: fx_sounds:
00:0000BD64 7200            	  2476: 	MOVEQ		#0,d1				; clear the longword
00:0000BD66 122D0028        	  2477: 	MOVE.b	s_flag_off(a5),d1		; get the saucer flag
00:0000BD6A 6F06            	  2478: 	BLE.s		no_saucer_sound		; if no saucer or the saucer is exploding skip
                            	  2479: 							; the saucer sound
                            	  2480: 
00:0000BD6C 5401            	  2481: 	ADDQ.b	#smsau_snd-1,d1		; add the small saucer sound to the size
00:0000BD6E 61001F8E        	  2482: 	BSR		play_sample			; go play the sample
                            	  2483: no_saucer_sound
00:0000BD72 4A2D0076        	  2484: 	TST.b		rock_count(a5)		; test the rock count
00:0000BD76 672C            	  2485: 	BEQ.s		no_thump_sound		; if no rocks skip the thump sound
                            	  2486: 
00:0000BD78 4A2D0027        	  2487: 	TST.b		p_flag_off(a5)		; test the player flag
00:0000BD7C 6F26            	  2488: 	BLE.s		no_thump_sound		; if no player or the player is exploding skip
                            	  2489: 							; the thump sound
                            	  2490: 
00:0000BD7E 4A2B0026        	  2491: 	TST.b		hyper(a3)			; test the hyperspace flag
00:0000BD82 6620            	  2492: 	BNE.s		no_thump_sound		; if in hyperspace skip the thump sound
                            	  2493: 
00:0000BD84 532B0024        	  2494: 	SUBQ.b	#1,thump_time(a3)		; decrement the thump sound change timer
00:0000BD88 661A            	  2495: 	BNE.s		no_thump_sound		; skip changing the sound if not timed out
                            	  2496: 
00:0000BD8A 7004            	  2497: 	MOVEQ		#4,d0				; add the sound on time
00:0000BD8C D02D007C        	  2498: 	ADD.b		thmp_sndi(a5),d0		; add the thump sound change timer initial
00:0000BD90 17400024        	  2499: 	MOVE.b	d0,thump_time(a3)		; save the thump sound change timer
                            	  2500: 
00:0000BD94 7001            	  2501: 	MOVEQ		#1,d0				; set the bitmap change mask
00:0000BD96 122B0023        	  2502: 	MOVE.b	thump_snd(a3),d1		; get the thump sound value
00:0000BD9A B101            	  2503: 	EOR.b		d0,d1				; change the thump sound value
00:0000BD9C 17410023        	  2504: 	MOVE.b	d1,thump_snd(a3)		; save the thump sound value
00:0000BDA0 60001F5C        	  2505: 	BRA		play_sample			; go play the sample and return
                            	  2506: 
                            	  2507: no_thump_sound
00:0000BDA4 4E75            	  2508: 	RTS
                            	  2509: 
                            	  2510: 
                            	  2511: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2512: ;
                            	  2513: ; handle something hitting a rock
                            	  2514: 
                            	  2515: ; d6 = player/saucer/shot object index
                            	  2516: ; d7 = object index
                            	  2517: 
                            	  2518: hit_a_rock:
00:0000BDA6 1B7C00500079    	  2519: 	MOVE.b	#$50,r_hit_tim(a5)	; set the rock hit timer
00:0000BDAC 1035700C        	  2520: 	MOVE.b	flags_off(a5,d7.w),d0	; get the rock flag
00:0000BDB0 7278            	  2521: 	MOVEQ		#$78,d1			; set the mask for the rock type
00:0000BDB2 C200            	  2522: 	AND.b		d0,d1				; mask the rock type
                            	  2523: 
00:0000BDB4 02400007        	  2524: 	ANDI.w	#$07,d0			; mask the rock size
00:0000BDB8 E248            	  2525: 	LSR.w		#1,d0				; / 2
00:0000BDBA 3400            	  2526: 	MOVE.w	d0,d2				; copy the size
00:0000BDBC 6702            	  2527: 	BEQ.s		clear_rock			; if the size is zero then the rock is destroyed
                            	  2528: 							; so go clear the rock flag
                            	  2529: 
00:0000BDBE 8001            	  2530: 	OR.b		d1,d0				; else OR back the rock type
                            	  2531: clear_rock
00:0000BDC0 1B80700C        	  2532: 	MOVE.b	d0,flags_off(a5,d7.w)	; save the rock flag
                            	  2533: 
00:0000BDC4 4A2B001A        	  2534: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000BDC8 6712            	  2535: 	BEQ.s		skip_add			; if no players skip the score add
                            	  2536: 
00:0000BDCA 4A46            	  2537: 	TST.w		d6				; test the player/saucer/shot index
00:0000BDCC 6706            	  2538: 	BEQ.s		add_to_score		; if the player hit the rock go add it to the
                            	  2539: 							; player's score
                            	  2540: 
00:0000BDCE 0C460004        	  2541: 	CMPI.w	#p_fire_off-p_flag_off,d6
                            	  2542: 							; compare the player/saucer/shot index with the
                            	  2543: 							; first of the player's fire
00:0000BDD2 6508            	  2544: 	BCS.s		skip_add			; if < the player's fire skip adding to the
                            	  2545: 							; player's score
                            	  2546: 
                            	  2547: add_to_score
00:0000BDD4 123B2042        	  2548: 	MOVE.b	rock_score(pc,d2.w),d1	; get the score per rock size
00:0000BDD8 6100FD6C        	  2549: 	BSR		add_score			; add d1.b to the current player's score
                            	  2550: skip_add
00:0000BDDC 4A35700C        	  2551: 	TST.b		flags_off(a5,d7.w)	; test the rock flag
00:0000BDE0 6734            	  2552: 	BEQ.s		exit_hit_a_rock		; if the rock was destroyed just exit
                            	  2553: 
                            	  2554: ; else break the rock into none, one, or two smaller rocks
                            	  2555: 
00:0000BDE2 6100FE42        	  2556: 	BSR		find_rock			; find a free rock, the index is returned in d5
00:0000BDE6 662E            	  2557: 	BNE.s		exit_hit_a_rock		; if there are no free rocks just exit
                            	  2558: 
00:0000BDE8 522D0076        	  2559: 	ADDQ.b	#1,rock_count(a5)		; else increment the rock count
                            	  2560: 
00:0000BDEC 6100FB76        	  2561: 	BSR		copy_rock			; copy the item parameters from the old rock,
                            	  2562: 							; (d7), to the new rock, (d5)
                            	  2563: 
00:0000BDF0 701F            	  2564: 	MOVEQ		#$1F,d0			; set the mask for the low 5 bits
00:0000BDF2 C035502F        	  2565: 	AND.b		x_vel_off(a5,d5.w),d0	; get the new rock x velocity byte
00:0000BDF6 D000            	  2566: 	ADD.b		d0,d0				; ; 2
00:0000BDF8 B1353081        	  2567: 	EOR.b		d0,x_pos_off+1(a5,d3.w)	; purturb the new rock x position low byte
                            	  2568: 
00:0000BDFC 6100FE2A        	  2569: 	BSR		find_next_rock		; find a free rock from d5, the index is
                            	  2570: 							; returned in d5
00:0000BE00 6614            	  2571: 	BNE.s		exit_hit_a_rock		; if there are no free rocks just exit
                            	  2572: 
00:0000BE02 522D0076        	  2573: 	ADDQ.b	#1,rock_count(a5)		; else increment the rock count
                            	  2574: 
00:0000BE06 6100FB60        	  2575: 	BSR		copy_rock_2			; copy the item parameters from the old rock,
                            	  2576: 							; (d7), to the new rock, (d5)
                            	  2577: 
00:0000BE0A 701F            	  2578: 	MOVEQ		#$1F,d0			; set the mask for the low 5 bits
00:0000BE0C C0355052        	  2579: 	AND.b		y_vel_off(a5,d5.w),d0	; get the new rock y velocity byte
00:0000BE10 D000            	  2580: 	ADD.b		d0,d0				; ; 2
00:0000BE12 B13530C7        	  2581: 	EOR.b		d0,y_pos_off+1(a5,d3.w)	; purturb the new rock y position low byte
                            	  2582: exit_hit_a_rock
00:0000BE16 4E75            	  2583: 	RTS
                            	  2584: 
                            	  2585: 
                            	  2586: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2587: ;
                            	  2588: ; score per rock size
                            	  2589: 
                            	  2590: rock_score
00:0000BE18 10              	  2591: 	dc.b	$10					; 100 points, small rock
00:0000BE19 05              	  2592: 	dc.b	$05					;  50 points, medium rock
00:0000BE1A 02              	  2593: 	dc.b	$02					;  20 points, large rock
00:0000BE1B 00              	  2594: 	dc.b	$00					;   0 points, null pad byte
                            	  2595: 
                            	  2596: 
                            	  2597: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2598: ;
                            	  2599: ; do the high score checks
                            	  2600: 
                            	  2601: check_hiscores:
00:0000BE1C 102B001A        	  2602: 	MOVE.b	num_players(a3),d0	; get the number of players in the game
00:0000BE20 6A5A            	  2603: 	BPL.s		exit_check_hiscores	; if still players just exit
                            	  2604: 
00:0000BE22 1B400083        	  2605: 	MOVE.b	d0,high_off(a5)		; clear the player 2 highscore flag
00:0000BE26 1D400083        	  2606: 	MOVE.b	d0,high_off(a6)		; clear the player 1 highscore flag
                            	  2607: 
00:0000BE2A 177C00010018    	  2608: 	MOVE.b	#$01,player_idx(a3)	; set the player index for player two
00:0000BE30 4BEB01F7        	  2609: 	LEA		player_2(a3),a5		; set the pointer to player two's variables
00:0000BE34 4DEB00F3        	  2610: 	LEA		player_1(a3),a6		; set the pointer to player one's variables
                            	  2611: check_hi_player
00:0000BE38 7400            	  2612: 	MOVEQ		#0,d2				; clear the high score index
00:0000BE3A 302D0080        	  2613: 	MOVE.w	score_off(a5),d0		; get the player score
00:0000BE3E 670E            	  2614: 	BEQ.s		check_hi_next		; if zero go try the other player
                            	  2615: 
                            	  2616: check_hi_loop
00:0000BE40 B0732027        	  2617: 	CMP.w		hiscores(a3,d2.w),d0	; compare the high score with the player score
00:0000BE44 6238            	  2618: 	BHI.s		insert_hiscore		; if the player score was more go insert the
                            	  2619: 							; score
                            	  2620: 
00:0000BE46 5442            	  2621: 	ADDQ.w	#2,d2				; increment the high score index
00:0000BE48 0C420014        	  2622: 	CMPI.w	#20,d2			; compare with max + 2
00:0000BE4C 65F2            	  2623: 	BCS.s		check_hi_loop		; loop if more high scores to do
                            	  2624: 
                            	  2625: 							; else change to the other player
                            	  2626: check_hi_next
00:0000BE4E CB4E            	  2627: 	EXG		a5,a6				; swap the players
00:0000BE50 0A2B00010018    	  2628: 	EORI.b	#1,player_idx(a3)		; toggle the player index
00:0000BE56 67E0            	  2629: 	BEQ.s		check_hi_player		; loop if more players to do
                            	  2630: 
00:0000BE58 102D0083        	  2631: 	MOVE.b	high_off(a5),d0		; get player 2's highscore flag
00:0000BE5C 6B14            	  2632: 	BMI.s		exit_hi_chk			; if not entering a high score go clear the
                            	  2633: 							; player count and exit
                            	  2634: 
00:0000BE5E B02E0083        	  2635: 	CMP.b		high_off(a6),d0		; compare with the player 1 highscore flag
00:0000BE62 650E            	  2636: 	BCS.s		exit_hi_chk			; if player 2's position < player 1's position
                            	  2637: 							; just exit
                            	  2638: 
00:0000BE64 5600            	  2639: 	ADDQ.b	#3,d0				; else increment player 2's position to the
                            	  2640: 							; next entry
00:0000BE66 0C00001E        	  2641: 	CMPI.b	#$1E,d0			; compare the result with max + 1
00:0000BE6A 6502            	  2642: 	BCS.s		save_hi_index		; if less go save the new player 1 index
                            	  2643: 
00:0000BE6C 70FF            	  2644: 	MOVEQ		#-1,d0			; else reset player 2's highscore flag
                            	  2645: save_hi_index
00:0000BE6E 1B400083        	  2646: 	MOVE.b	d0,high_off(a5)		; save player 2's highscore flag
                            	  2647: exit_hi_chk
00:0000BE72 7000            	  2648: 	MOVEQ		#0,d0				; clear the longword
00:0000BE74 1740001A        	  2649: 	MOVE.b	d0,num_players(a3)	; clear the number of players in the game
00:0000BE78 17400020        	  2650: 	MOVE.b	d0,hi_char(a3)		; clear the input character index
                            	  2651: exit_check_hiscores
00:0000BE7C 4E75            	  2652: 	RTS
                            	  2653: 
                            	  2654: ; insert a new high score into the high score table. the index is in d2.w
                            	  2655: 
                            	  2656: insert_hiscore:
00:0000BE7E 7612            	  2657: 	MOVEQ		#18,d3			; index to the last high score
00:0000BE80 781B            	  2658: 	MOVEQ		#27,d4			; index to the last high score initials
                            	  2659: insert_loop
00:0000BE82 B443            	  2660: 	CMP.w		d3,d2				; compare the current high score with the insert
                            	  2661: 							; point
00:0000BE84 671E            	  2662: 	BEQ.s		exit_insert_loop		; if there exit the loop
                            	  2663: 
00:0000BE86 37B330253027    	  2664: 	MOVE.w	hiscores-2(a3,d3.w),hiscores(a3,d3.w)
                            	  2665: 							; copy the (n-1)th high score to this one
00:0000BE8C 17B34038403B    	  2666: 	MOVE.b	hinames-3(a3,d4.w),hinames(a3,d4.w)
                            	  2667: 							; copy the (n-1)th high score name first byte
00:0000BE92 17B34039403C    	  2668: 	MOVE.b	hinames-2(a3,d4.w),hinames+1(a3,d4.w)
                            	  2669: 							; copy the (n-1)th high score name second byte
00:0000BE98 17B3403A403D    	  2670: 	MOVE.b	hinames-1(a3,d4.w),hinames+2(a3,d4.w)
                            	  2671: 							; copy the (n-1)th high score name third byte
                            	  2672: 
00:0000BE9E 5543            	  2673: 	SUBQ.w	#2,d3				; decrement the index to the previous score
00:0000BEA0 5744            	  2674: 	SUBQ.w	#3,d4				; decrement the index to the previous initials
00:0000BEA2 66DE            	  2675: 	BNE.s		insert_loop			; loop for the next high score
                            	  2676: 
                            	  2677: exit_insert_loop
00:0000BEA4 1B440083        	  2678: 	MOVE.b	d4,high_off(a5)		; save the player highscore flag
00:0000BEA8 37803027        	  2679: 	MOVE.w	d0,hiscores(a3,d3.w)	; copy the player score to this one
00:0000BEAC 17BC000B403B    	  2680: 	MOVE.b	#$0B,hinames(a3,d4.w)	; make the high score name first byte "A"
00:0000BEB2 4233403C        	  2681: 	CLR.b		hinames+1(a3,d4.w)	; make the high score name second byte " "
00:0000BEB6 4233403D        	  2682: 	CLR.b		hinames+2(a3,d4.w)	; make the high score name third byte " "
                            	  2683: 
00:0000BEBA 177C00F00059    	  2684: 	MOVE.b	#$F0,game_count(a3)	; set the game counter high byte, high score
                            	  2685: 							; entry timeout
                            	  2686: 
00:0000BEC0 608C            	  2687: 	BRA.s		check_hi_next		; loop for the other player
                            	  2688: 
                            	  2689: 
                            	  2690: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2691: ;
                            	  2692: ; calculate the angle given the delta x,y. the delta is calculated by subtracting the
                            	  2693: ; source x,y co-ordinates from the target x,y co-ordinates. the angle is returned in
                            	  2694: ; d0.b with $00 being 3 o'clock
                            	  2695: ;
                            	  2696: ; d1.w = delta x = target x - source x
                            	  2697: ; d2.w = delta y = target y - source y
                            	  2698: 
                            	  2699: get_atn:
00:0000BEC2 4A42            	  2700: 	TST.w		d2				; test the delta y
00:0000BEC4 6A08            	  2701: 	BPL.s		atn_semi			; if +ve skip the delta y negate
                            	  2702: 
00:0000BEC6 4442            	  2703: 	NEG.w		d2				; else make delta y positive
00:0000BEC8 6104            	  2704: 	BSR.s		atn_semi			; get arctan(y/x) for the semicircle
00:0000BECA 4400            	  2705: 	NEG.b		d0				; negate the result
00:0000BECC 4E75            	  2706: 	RTS
                            	  2707: 
                            	  2708: ; get arctan(y/x) for the semicircle
                            	  2709: 
                            	  2710: atn_semi:
00:0000BECE 4A41            	  2711: 	TST.w		d1				; test the delta x
00:0000BED0 6A0C            	  2712: 	BPL.s		atn_quad			; if +ve skip the delta x negate
                            	  2713: 
00:0000BED2 4441            	  2714: 	NEG.w		d1				; else make delta x positive
00:0000BED4 6108            	  2715: 	BSR.s		atn_quad			; get arctan(y/x) or arctan(x/y)
00:0000BED6 0A000080        	  2716: 	EORI.b	#$80,d0			; reflect 180 degrees
00:0000BEDA 4400            	  2717: 	NEG.b		d0				; negate the result
00:0000BEDC 4E75            	  2718: 	RTS
                            	  2719: 
                            	  2720: 
                            	  2721: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2722: ;
                            	  2723: ; get arctan(y/x) or arctan(x/y) for one quadrant.
                            	  2724: 
                            	  2725: atn_quad:
00:0000BEDE B441            	  2726: 	CMP.w		d1,d2				; compare y with x
00:0000BEE0 650C            	  2727: 	BCS.s		atn_eight			; if x > y get arctan(y/x) from the table
                            	  2728: 							; and return
                            	  2729: 
00:0000BEE2 C342            	  2730: 	EXG		d1,d2				; else swap x,y
00:0000BEE4 6108            	  2731: 	BSR.s		atn_eight			; get arctan(x/y) from the table
00:0000BEE6 04000040        	  2732: 	SUBI.b	#$40,d0			; reflect the quadrant
00:0000BEEA 4400            	  2733: 	NEG.b		d0				; and negate the result
00:0000BEEC 4E75            	  2734: 	RTS
                            	  2735: 
                            	  2736: 
                            	  2737: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2738: ;
                            	  2739: ; divide d2.w by d1.w, the six bit result in d0.w is then used to index the ATN()
                            	  2740: ; table to get the result for this octant. (is that the right word for one eighth
                            	  2741: ; of a circle?)
                            	  2742: 
                            	  2743: atn_eight:
00:0000BEEE 7000            	  2744: 	MOVEQ		#0,d0				; clear the result
00:0000BEF0 7E05            	  2745: 	MOVEQ		#6-1,d7			; set the bit count
                            	  2746: loop_atn
00:0000BEF2 D442            	  2747: 	ADD.w		d2,d2				; shift the dividend
00:0000BEF4 3602            	  2748: 	MOVE.w	d2,d3				; copy the dividend
00:0000BEF6 9641            	  2749: 	SUB.w		d1,d3				; compare it with the divisor
00:0000BEF8 6502            	  2750: 	BCS.s		skip_sub			; if the dividend < the divisor skip the
                            	  2751: 							; subtract
                            	  2752: 
00:0000BEFA 9441            	  2753: 	SUB.w		d1,d2				; else subtract the divisor
                            	  2754: skip_sub
00:0000BEFC D100            	  2755: 	ADDX.b	d0,d0				; shift a bit into the result
00:0000BEFE 51CFFFF2        	  2756: 	DBF		d7,loop_atn			; loop if more to do
                            	  2757: 
00:0000BF02 0200003F        	  2758: 	ANDI.b	#$3F,d0			; mask the result to $0000 to $003F
00:0000BF06 103B0004        	  2759: 	MOVE.b	atn_tab(pc,d0.w),d0	; get the arctan from the table
00:0000BF0A 4E75            	  2760: 	RTS
                            	  2761: 
                            	  2762: 
                            	  2763: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2764: ;
                            	  2765: ; arctangent table. returns the effective angle of the dx/dy ratio for scaled values
                            	  2766: ; of dx/dy of up to 0.984375 or 63/64ths. this is only 1/8th of a full circle but it
                            	  2767: ; is easy to rotate and reflect these values to cover the other 7/8ths.
                            	  2768: 
                            	  2769: atn_tab
00:0000BF0C 20              	  2770: 	dc.b	$20,$20,$1F,$1F,$1F,$1E,$1E,$1E,$1D,$1D,$1C,$1C,$1C,$1B,$1B,$1A
00:0000BF0D 20
00:0000BF0E 1F
00:0000BF0F 1F
00:0000BF10 1F
00:0000BF11 1E
00:0000BF12 1E
00:0000BF13 1E
00:0000BF14 1D
00:0000BF15 1D
00:0000BF16 1C
00:0000BF17 1C
00:0000BF18 1C
00:0000BF19 1B
00:0000BF1A 1B
00:0000BF1B 1A
00:0000BF1C 1A              	  2771: 	dc.b	$1A,$1A,$19,$19,$18,$18,$17,$17,$17,$16,$16,$15,$15,$14,$14,$13
00:0000BF1D 1A
00:0000BF1E 19
00:0000BF1F 19
00:0000BF20 18
00:0000BF21 18
00:0000BF22 17
00:0000BF23 17
00:0000BF24 17
00:0000BF25 16
00:0000BF26 16
00:0000BF27 15
00:0000BF28 15
00:0000BF29 14
00:0000BF2A 14
00:0000BF2B 13
00:0000BF2C 13              	  2772: 	dc.b	$13,$12,$12,$11,$11,$10,$0F,$0F,$0E,$0E,$0D,$0D,$0C,$0B,$0B,$0A
00:0000BF2D 12
00:0000BF2E 12
00:0000BF2F 11
00:0000BF30 11
00:0000BF31 10
00:0000BF32 0F
00:0000BF33 0F
00:0000BF34 0E
00:0000BF35 0E
00:0000BF36 0D
00:0000BF37 0D
00:0000BF38 0C
00:0000BF39 0B
00:0000BF3A 0B
00:0000BF3B 0A
00:0000BF3C 0A              	  2773: 	dc.b	$0A,$09,$08,$08,$07,$07,$06,$05,$05,$04,$03,$03,$02,$02,$01,$00
00:0000BF3D 09
00:0000BF3E 08
00:0000BF3F 08
00:0000BF40 07
00:0000BF41 07
00:0000BF42 06
00:0000BF43 05
00:0000BF44 05
00:0000BF45 04
00:0000BF46 03
00:0000BF47 03
00:0000BF48 02
00:0000BF49 02
00:0000BF4A 01
00:0000BF4B 00
                            	  2774: 
                            	  2775: 
                            	  2776: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2777: ;
                            	  2778: ; output a number as a leading zero suppressed character string
                            	  2779: ;
                            	  2780: ; a1 = number address
                            	  2781: ; d7 = number byte count
                            	  2782: 
                            	  2783: output_number:
00:0000BF4C 5347            	  2784: 	SUBQ.w	#1,d7				; adjust for the loop type
                            	  2785: output_number_loop
00:0000BF4E 1211            	  2786: 	MOVE.b	(a1),d1			; get a byte
00:0000BF50 E809            	  2787: 	LSR.b		#4,d1				; shift the high nibble to the low nibble
00:0000BF52 61000130        	  2788: 	BSR		add_sup_hex_chr		; add a leading zero suppressed character
00:0000BF56 4A47            	  2789: 	TST.w		d7				; test the byte count
00:0000BF58 6604            	  2790: 	BNE.s		zero_suppress		; if this isn't the last byte skip the zero
                            	  2791: 							; suppress clear
                            	  2792: 
00:0000BF5A 422B0016        	  2793: 	CLR.b		suppress_0(a3)		; clear the zero suppress for the last digit
                            	  2794: zero_suppress
00:0000BF5E 1219            	  2795: 	MOVE.b	(a1)+,d1			; get a byte and increment the pointer
00:0000BF60 61000122        	  2796: 	BSR		add_sup_hex_chr		; add a leading zero suppressed character
00:0000BF64 51CFFFE8        	  2797: 	DBF		d7,output_number_loop	; decrement count and loop if more to do
                            	  2798: 
00:0000BF68 4E75            	  2799: 	RTS
                            	  2800: 
                            	  2801: 
                            	  2802: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2803: ;
                            	  2804: ; get COS(d0) in d0. d0 is an eight bit value representing a full circle with the
                            	  2805: ; value increasing as you turn widdershins
                            	  2806: 
                            	  2807: cos_d0
00:0000BF6A 06000040        	  2808: 	ADDI.b	#$40,d0			; add 1/4 rotation
                            	  2809: 
                            	  2810: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2811: ;
                            	  2812: ; get SIN(d0) in d0. d0 is an eight bit value representing a full circle with the
                            	  2813: ; value increasing as you turn widdershins
                            	  2814: 
                            	  2815: sin_d0
00:0000BF6E 024000FF        	  2816: 	ANDI.w	#$00FF,d0			; mask one full circle
00:0000BF72 4A00            	  2817: 	TST.b		d0				; test angle sign
00:0000BF74 6A06            	  2818: 	BPL.s		cossin_d0			; if +ve just get SIN/COS and return
                            	  2819: 
00:0000BF76 6104            	  2820: 	BSR.s		cossin_d0			; else get SIN/COS
00:0000BF78 4440            	  2821: 	NEG.w		d0				; now do twos complement
00:0000BF7A 4E75            	  2822: 	RTS
                            	  2823: 
                            	  2824: ; get d0 from SIN/COS table
                            	  2825: 
                            	  2826: cossin_d0
00:0000BF7C D000            	  2827: 	ADD.b		d0,d0				; ; 2 bytes per word value
00:0000BF7E 6A02            	  2828: 	BPL.s		a_was_less			; branch if the angle < 1/4 circle
                            	  2829: 
00:0000BF80 4400            	  2830: 	NEG.b		d0				; wrap $82 to $FE to $7E to $02
                            	  2831: a_was_less
00:0000BF82 303B0004        	  2832: 	MOVE.w	sin_cos(pc,d0.w),d0	; get the SIN/COS value
00:0000BF86 4E75            	  2833: 	RTS
                            	  2834: 
                            	  2835: 
                            	  2836: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2837: ;
                            	  2838: ; SIN/COS table, returns values between $0000 and $7FFF. the last value should be
                            	  2839: ; $8000 but that can cause an overflow in the word length calculations and it's
                            	  2840: ; easier to fudge the table a bit. no one will ever notice.
                            	  2841: 
                            	  2842: sin_cos
00:0000BF88 0000            	  2843: 	dc.w	$0000,$0324,$0648,$096B,$0C8C,$0FAB,$12C8,$15E2
00:0000BF8A 0324
00:0000BF8C 0648
00:0000BF8E 096B
00:0000BF90 0C8C
00:0000BF92 0FAB
00:0000BF94 12C8
00:0000BF96 15E2
00:0000BF98 18F9            	  2844: 	dc.w	$18F9,$1C0C,$1F1A,$2224,$2528,$2827,$2B1F,$2E11
00:0000BF9A 1C0C
00:0000BF9C 1F1A
00:0000BF9E 2224
00:0000BFA0 2528
00:0000BFA2 2827
00:0000BFA4 2B1F
00:0000BFA6 2E11
00:0000BFA8 30FC            	  2845: 	dc.w	$30FC,$33DF,$36BA,$398D,$3C57,$3F17,$41CE,$447B
00:0000BFAA 33DF
00:0000BFAC 36BA
00:0000BFAE 398D
00:0000BFB0 3C57
00:0000BFB2 3F17
00:0000BFB4 41CE
00:0000BFB6 447B
00:0000BFB8 471D            	  2846: 	dc.w	$471D,$49B4,$4C40,$4EC0,$5134,$539B,$55F6,$5843
00:0000BFBA 49B4
00:0000BFBC 4C40
00:0000BFBE 4EC0
00:0000BFC0 5134
00:0000BFC2 539B
00:0000BFC4 55F6
00:0000BFC6 5843
00:0000BFC8 5A82            	  2847: 	dc.w	$5A82,$5CB4,$5ED7,$60EC,$62F2,$64E9,$66CF,$68A7
00:0000BFCA 5CB4
00:0000BFCC 5ED7
00:0000BFCE 60EC
00:0000BFD0 62F2
00:0000BFD2 64E9
00:0000BFD4 66CF
00:0000BFD6 68A7
00:0000BFD8 6A6E            	  2848: 	dc.w	$6A6E,$6C24,$6DCA,$6F5F,$70E3,$7255,$73B6,$7505
00:0000BFDA 6C24
00:0000BFDC 6DCA
00:0000BFDE 6F5F
00:0000BFE0 70E3
00:0000BFE2 7255
00:0000BFE4 73B6
00:0000BFE6 7505
00:0000BFE8 7642            	  2849: 	dc.w	$7642,$776C,$7885,$798A,$7A7D,$7B5D,$7C2A,$7CE4
00:0000BFEA 776C
00:0000BFEC 7885
00:0000BFEE 798A
00:0000BFF0 7A7D
00:0000BFF2 7B5D
00:0000BFF4 7C2A
00:0000BFF6 7CE4
00:0000BFF8 7D8A            	  2850: 	dc.w	$7D8A,$7E1E,$7E9D,$7F0A,$7F62,$7FA7,$7FD9,$7FF6
00:0000BFFA 7E1E
00:0000BFFC 7E9D
00:0000BFFE 7F0A
00:0000C000 7F62
00:0000C002 7FA7
00:0000C004 7FD9
00:0000C006 7FF6
00:0000C008 7FFF            	  2851: 	dc.w	$7FFF
                            	  2852: 
                            	  2853: 
                            	  2854: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2855: ;
                            	  2856: ; add message d1 to the display list
                            	  2857: 
                            	  2858: add_message:
00:0000C00A 36BC1000        	  2859: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
                            	  2860: 
00:0000C00E D241            	  2861: 	ADD.w		d1,d1				; make into a word index
00:0000C010 3F01            	  2862: 	MOVE.w	d1,-(sp)			; save the index
                            	  2863: 
00:0000C012 D241            	  2864: 	ADD.w		d1,d1				; make into a word pair index
00:0000C014 41FA1932        	  2865: 	LEA		mess_origin(pc),a0	; point to the mesage co-ordinate table
00:0000C018 34301002        	  2866: 	MOVE.w	2(a0,d1.w),d2		; get the message y co-ordinate
00:0000C01C 32301000        	  2867: 	MOVE.w	(a0,d1.w),d1		; get the message x co-ordinate
00:0000C020 6100009E        	  2868: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  2869: 							; a draw command
                            	  2870: 
00:0000C024 323C7000        	  2871: 	MOVE.w	#REL7,d1			; make a $7000,$0000 command
00:0000C028 610000B0        	  2872: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  2873: 
00:0000C02C 7003            	  2874: 	MOVEQ		#$03,d0			; set the mask for the language bits
00:0000C02E 206B000E        	  2875: 	MOVEA.l	switch_addr(a3),a0	; point to the switch
00:0000C032 C010            	  2876: 	AND.b		(a0),d0			; get and mask the switch bits
00:0000C034 D040            	  2877: 	ADD.w		d0,d0				; make into a word pointer
                            	  2878: 
00:0000C036 41FA1930        	  2879: 	LEA		mess_table(pc),a0		; point to the mesage language table
00:0000C03A 30300000        	  2880: 	MOVE.w	(a0,d0.w),d0		; get the offset to the messages
00:0000C03E 41F00000        	  2881: 	LEA		(a0,d0.w),a0		; get the pointer to the messages
                            	  2882: 
00:0000C042 321F            	  2883: 	MOVE.w	(sp)+,d1			; restore the message index
                            	  2884: 
00:0000C044 32301000        	  2885: 	MOVE.w	(a0,d1.w),d1		; get the offset to the message
00:0000C048 41F01000        	  2886: 	LEA		(a0,d1.w),a0		; get the pointer to the message
00:0000C04C 43FA189C        	  2887: 	LEA		char_set(pc),a1		; get the pointer to the character JSRL table
00:0000C050 7000            	  2888: 	MOVEQ		#0,d0				; clear the longword
                            	  2889: add_char_loop
00:0000C052 1018            	  2890: 	MOVE.b	(a0)+,d0			; get the next character
00:0000C054 671A            	  2891: 	BEQ.s		exit_add_message		; if null just exit
                            	  2892: 
                            	  2893: ; convert the character and add it to the vector list
                            	  2894: 
00:0000C056 903C0020        	  2895: 	SUB.b		#' ',d0			; subtract [SPACE]
00:0000C05A 670C            	  2896: 	BEQ.s		add_the_char		; if it was [SPACE] go add it
                            	  2897: 
00:0000C05C 903C000F        	  2898: 	SUB.b		#15,d0			; convert a number
00:0000C060 0C00000B        	  2899: 	CMPI.b	#11,d0			; compare with converted "9"+1
00:0000C064 6502            	  2900: 	BCS.s		add_the_char		; if it was <="9" go add it
                            	  2901: 
00:0000C066 5F00            	  2902: 	SUBQ.b	#7,d0				; else convert "A" to "Z"
                            	  2903: add_the_char
00:0000C068 D000            	  2904: 	ADD.b		d0,d0				; ; 2
00:0000C06A 38F10000        	  2905: 	MOVE.w	(a1,d0.w),(a4)+		; copy the JSRL to the vector list
00:0000C06E 60E2            	  2906: 	BRA.s		add_char_loop		; loop for next
                            	  2907: 
                            	  2908: exit_add_message
00:0000C070 4E75            	  2909: 	RTS
                            	  2910: 
                            	  2911: 
                            	  2912: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2913: ;
                            	  2914: ; timer interrupt. the timer interrupt should be triggered every 16ms
                            	  2915: 
                            	  2916: timer_interrupt
00:0000C072 522B001D        	  2917: 	ADDQ.b	#1,sixteen_ms(a3)		; increment the 16ms counter
00:0000C076 4E73            	  2918: 	RTE
                            	  2919: 
                            	  2920: 
                            	  2921: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2922: ;
                            	  2923: ; add "PLAYER x" to the vector list
                            	  2924: 
                            	  2925: player_x:
00:0000C078 7201            	  2926: 	MOVEQ		#1,d1				; message 1 - "PLAYER "
00:0000C07A 618E            	  2927: 	BSR		add_message			; add message d1 to the display list
                            	  2928: player_n
00:0000C07C 7201            	  2929: 	MOVEQ		#1,d1				; make 0,1 into 1,2
00:0000C07E D22B0018        	  2930: 	ADD.b		player_idx(a3),d1		; add the player index
00:0000C082 600C            	  2931: 	BRA.s		add_hex_chr			; write a hex character to the vector list
                            	  2932: 							; and return
                            	  2933: 
                            	  2934: 
                            	  2935: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2936: ;
                            	  2937: ; if suppress_0 <> 0 write a leading zero suppressed hex character to the vector list
                            	  2938: 
                            	  2939: add_sup_hex_chr
00:0000C084 4A2B0016        	  2940: 	TST.b		suppress_0(a3)		; test the leading zero suppressed flag
00:0000C088 6706            	  2941: 	BEQ.s		add_hex_chr			; if not suppressed go write a hex character
                            	  2942: 							; to the vector list
                            	  2943: 
                            	  2944: ; if supressed write a [SPACE] instead of a "0"
                            	  2945: 
00:0000C08A 700F            	  2946: 	MOVEQ		#$0F,d0			; set the nibble mask
00:0000C08C C240            	  2947: 	AND.w		d0,d1				; mask the low nibble
00:0000C08E 670A            	  2948: 	BEQ.s		add_sup_zero		; if it is zero go write a space
                            	  2949: 
                            	  2950: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2951: ;
                            	  2952: ; write a hex character d1 to the vector list
                            	  2953: 
                            	  2954: add_hex_chr
00:0000C090 C27C000F        	  2955: 	AND.w		#$0F,d1			; mask the low nibble
00:0000C094 5241            	  2956: 	ADDQ.w	#1,d1				; add 1 to pass the [SPACE] character
00:0000C096 422B0016        	  2957: 	CLR.b		suppress_0(a3)		; clear the leading zero suppressed flag
                            	  2958: add_sup_zero
00:0000C09A D241            	  2959: 	ADD.w		d1,d1				; ; 2, bytes per character
00:0000C09C 2F08            	  2960: 	MOVE.l	a0,-(sp)			; save a0
00:0000C09E 41FA184A        	  2961: 	LEA		char_set(pc),a0		; point to the character JSRL table
00:0000C0A2 38F01000        	  2962: 	MOVE.w	(a0,d1.w),(a4)+		; copy the character JSRL to the vector list
00:0000C0A6 205F            	  2963: 	MOVE.l	(sp)+,a0			; restore a0
                            	  2964: 
00:0000C0A8 4E75            	  2965: 	RTS
                            	  2966: 
                            	  2967: 
                            	  2968: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2969: ;
                            	  2970: ; convert the a1 address and add it to the vector list as a vector subroutine call
                            	  2971: 
                            	  2972: add_address:
00:0000C0AA 41FA0222        	  2973: 	LEA		vector(pc),a0		; point to the vector memory
00:0000C0AE 93C8            	  2974: 	SUBA.l	a0,a1				; convert the pointer to an offset
00:0000C0B0 2209            	  2975: 	MOVE.l	a1,d1				; copy the result
00:0000C0B2 E249            	  2976: 	LSR.w		#1,d1				; / 2
00:0000C0B4 C27C0FFF        	  2977: 	AND.w		#$0FFF,d1			; mask the address bits
00:0000C0B8 0041C000        	  2978: 	ORI.w		#JSRL,d1			; OR with vector subroutine call
00:0000C0BC 38C1            	  2979: 	MOVE.w	d1,(a4)+			; copy to the vector list
00:0000C0BE 4E75            	  2980: 	RTS
                            	  2981: 
                            	  2982: 
                            	  2983: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2984: ;
                            	  2985: ; add 4 ; the co-ordinate pair in d1,d2 to the list as a draw command
                            	  2986: 
                            	  2987: add_coords:
00:0000C0C0 7002            	  2988: 	MOVEQ		#2,d0				; set shift count
00:0000C0C2 E161            	  2989: 	ASL.w		d0,d1				; x co-ordinate ; 4
00:0000C0C4 E162            	  2990: 	ASL.w		d0,d2				; y co-ordinate ; 4
                            	  2991: 
00:0000C0C6 303C0FFC        	  2992: 	MOVE.w	#$0FFC,d0			; set the co-ordinate mask
00:0000C0CA C240            	  2993: 	AND.w		d0,d1				; mask the x co-ordinate
00:0000C0CC C440            	  2994: 	AND.w		d0,d2				; mask the y co-ordinate
                            	  2995: 
00:0000C0CE 0042A000        	  2996: 	ORI.w		#DRAW,d2			; OR in the draw command
00:0000C0D2 8253            	  2997: 	OR.w		glob_scale(a3),d1		; OR in the global scale
                            	  2998: 
00:0000C0D4 38C2            	  2999: 	MOVE.w	d2,(a4)+			; save the command/y co-ordinate to the list
00:0000C0D6 38C1            	  3000: 	MOVE.w	d1,(a4)+			; save the scale/x co-ordinate to the list
00:0000C0D8 4E75            	  3001: 	RTS
                            	  3002: 
                            	  3003: 
                            	  3004: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3005: ;
                            	  3006: ; add (d1)00,0000 to the vector list
                            	  3007: 
                            	  3008: add_single
00:0000C0DA 7400            	  3009: 	MOVEQ		#0,d2				; clear the second word
                            	  3010: 
                            	  3011: 
                            	  3012: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3013: ;
                            	  3014: ; add (A)00,(X)00 to the vector list
                            	  3015: 
                            	  3016: add_pair
00:0000C0DC 38C1            	  3017: 	MOVE.w	d1,(a4)+			; save the first word to the vector list
00:0000C0DE 38C2            	  3018: 	MOVE.w	d2,(a4)+			; save the second word to the vector list
00:0000C0E0 4E75            	  3019: 	RTS
                            	  3020: 
                            	  3021: 
                            	  3022: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3023: ;
                            	  3024: ; check the [F2], [F3] and [F4] keys. set the screen size to 640 x 480, 800 x 600 or
                            	  3025: ; 1024 x 768 if the corresponding key has been pressed
                            	  3026: 
                            	  3027: s_controls
                            	  3028: ;	MOVE.l	#$71007273,d1		; [F2], [], [F3] and [F4] keys
                            	  3029: ;	MOVEQ		#19,d0			; check for keypress
                            	  3030: ;	TRAP		#15
                            	  3031: 
                            	  3032: ;	MOVEQ		#33,d0			; set/get output window size
                            	  3033: 
                            	  3034: ;	MOVE.l	d1,d2				; copy result
                            	  3035: ;	BEQ.s		notscreen			; skip screen size if no F key
                            	  3036: 
                            	  3037: ;	MOVE.l	#$028001E0,d1		; set 640 x 480
                            	  3038: ;	TST.l		d2				; test result
                            	  3039: ;	BMI.s		setscreen			; if F2 go set window size
                            	  3040: 
                            	  3041: ;	MOVE.l	#$03200258,d1		; set 800 x 600
                            	  3042: ;	TST.w		d2				; test result
                            	  3043: ;	BMI.s		setscreen			; if F3 go set window size
                            	  3044: 
                            	  3045: 							; else was F4 so ..
                            	  3046: ;	MOVE.l	#$04000300,d1		; set 1024 x 768
                            	  3047: setscreen
                            	  3048: ;	CMP.l		scr_x(a3),d1		; compare with current screen size
                            	  3049: ;	BEQ.s		notscreen			; if already set skip setting it now
                            	  3050: 
                            	  3051: ;	TRAP		#15
                            	  3052: 
                            	  3053: notscreen
                            	  3054: ;	MOVEQ		#0,d1				; get the current window size
                            	  3055: ;	TRAP		#15
                            	  3056: 
00:0000C0E2 223C03200258    	  3057: 	move.l #$03200258,d1		; always 800x600
00:0000C0E8 27410006        	  3058: 	move.l d1,scr_x(a3)			; save the screen x and y size
00:0000C0EC 4E75            	  3059: 	rts
                            	  3060: 
                            	  3061: 
                            	  3062: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3063: ;
                            	  3064: ; setup stuff.
                            	  3065: 
                            	  3066: Initialise:
00:0000C0EE 7200            	  3067: 	moveq	#0,d1					; turn off echo
00:0000C0F0 700C            	  3068: 	moveq	#12,d0				; keyboard echo
00:0000C0F2 4E4F            	  3069: 	trap #15
                            	  3070: 
                            	  3071: ;	move.w #$FF00,d1		; clear screen
                            	  3072: ;	moveq #11,d0				; position cursor
                            	  3073: ;	trap #15
                            	  3074: 
00:0000C0F4 7211            	  3075: 	moveq #17,d1				; enable double buffering
00:0000C0F6 705C            	  3076: 	moveq	#92,d0				; set draw mode
00:0000C0F8 4E4F            	  3077: 	trap #15
                            	  3078: 
00:0000C0FA 720A            	  3079: 	moveq #10,d1				; OR mode drawing, this helps on two ways.
                            	  3080: 							; first it emulates a vector display where
                            	  3081: 							; the vectors that cross can bright up the
                            	  3082: 							; intersection and second it means we can
                            	  3083: 							; forget depth sorting of objects
00:0000C0FC 705C            	  3084: 	moveq #92,d0				; set draw mode
00:0000C0FE 4E4F            	  3085: 	trap #15
                            	  3086: 
00:0000C100 47FA1D1B        	  3087: 	lea	variables(pc),a3	; get the pointer to the variables base
00:0000C104 4BEB00F3        	  3088: 	lea player_1(a3),a5		; get the pointer to player one's variables
00:0000C108 4DEB01F7        	  3089: 	lea player_2(a3),a6		; get the pointer to player two's variables
                            	  3090: 
                            	  3091: 										; clear all the variable space
00:0000C10C 7000            	  3092: 	moveq #0,d0				; clear the longword
00:0000C10E 41EB0012        	  3093: 	lea hiscore_y(a3),a0		; get the start address
00:0000C112 43EB027B        	  3094: 	lea p_2_end(a3),a1			; get the end address
                            	  3095: clear_loop
00:0000C116 30C0            	  3096: 	move.w d0,(a0)+			; clear the word
00:0000C118 B1C9            	  3097: 	cmpa.l a1,a0				; compare the addresses
00:0000C11A 66FA            	  3098: 	bne.s clear_loop		; if not at end loop
                            	  3099: 
00:0000C11C 7008            	  3100: 	moveq #8,d0					; get the time in 1/100 ths seconds
00:0000C11E 4E4F            	  3101: 	trap #15
                            	  3102: 
00:0000C120 0A81DEADBEEF    	  3103: 	eori.l	#$DEADBEEF,d1		; EOR with the initial PRNG seed, this must
                            	  3104: 													; result in any value but zero
00:0000C126 4EB900002458    	  3105: 	jsr InitRand
00:0000C12C 2741000A        	  3106: 	move.l	d1,PRNlword(a3)		; save the initial PRNG seed
                            	  3107: 
00:0000C130 7203            	  3108: 	moveq #3,d1					; get the switches address
00:0000C132 7020            	  3109: 	moveq #32,d0				; simulator hardware
00:0000C134 4E4F            	  3110: 	trap #15
                            	  3111: 
00:0000C136 2741000E        	  3112: 	move.l d1,switch_addr(a3)	; save the switches address
                            	  3113: 
                            	  3114: 	;LEA		timer_interrupt(pc),a0	; get the timer interrupt routine address
                            	  3115: 	;MOVE.l	a0,$64.w			; save the timer interrupt as interrupt 1
                            	  3116: 
                            	  3117: 	;MOVEQ		#6,d1				; set auto IRQ
                            	  3118: 	;MOVEQ		#$81,d2			; enable IRQ 1
                            	  3119: 	;MOVEQ		#16,d3			; set the time in ms
                            	  3120: 	;MOVEQ		#32,d0			; set simulator hardware
                            	  3121: 	;TRAP		#15
                            	  3122: 
                            	  3123: 	;MOVEQ		#5,d1				; enable exceptions
                            	  3124: 	;MOVEQ		#32,d0			; set simulator hardware
                            	  3125: 	;TRAP		#15
                            	  3126: 
00:0000C13A 49FA0192        	  3127: 	lea vector(pc),a4			; get the pointer to the vector list RAM
00:0000C13E 38BCB000        	  3128: 	move.w #HALT,(a4)			; add HALT to the vector list
                            	  3129: 
00:0000C142 61001B4D        	  3130: 	bsr sound_init				; initialise the sounds
                            	  3131: 
00:0000C146 70FF            	  3132: 	moveq #-1,d0					; flag high score done
00:0000C148 17400176        	  3133: 	move.b d0,p1_high(a3)	; save the player 1 highscore flag
00:0000C14C 1740027A        	  3134: 	move.b d0,p2_high(a3)	; save the player 2 highscore flag
                            	  3135: 
00:0000C150 43FA1CBE        	  3136: 	lea filename(pc),a1		; point to the highscore filename
00:0000C154 7033            	  3137: 	moveq	#51,d0					; open existing file
00:0000C156 4E4F            	  3138: 	trap #15
                            	  3139: 
00:0000C158 4A40            	  3140: 	tst.w d0							; check for errors
00:0000C15A 6706            	  3141: 	beq.s read_hi					; if no error go read the file
                            	  3142: 
00:0000C15C 0C400003        	  3143: 	cmpi.w #3,d0					; compare with read only
00:0000C160 660A            	  3144: 	bne.s	close_all_2			; if not read only go close all files
                            	  3145: 
                            	  3146: read_hi
00:0000C162 43EB0027        	  3147: 	lea hiscores(a3),a1		; point to the highscore tables
00:0000C166 7432            	  3148: 	moveq	#50,d2					; set the table length
00:0000C168 7035            	  3149: 	moveq	#53,d0					; read file
00:0000C16A 4E4F            	  3150: 	trap #15
                            	  3151: 
                            	  3152: close_all_2
00:0000C16C 7032            	  3153: 	moveq #50,d0					; close all files
00:0000C16E 4E4F            	  3154: 	trap #15
                            	  3155: 
00:0000C170 4E75            	  3156: 	rts
                            	  3157: 
                            	  3158: 
                            	  3159: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3160: ;
                            	  3161: ; This is the code that generates the pseudo random sequence. A seed word located in
                            	  3162: ; PRNlword(a3) is loaded into a register before being operated on to generate the
                            	  3163: ; next number in the sequence. This number is then saved as the seed for the next
                            	  3164: ; time it's called.
                            	  3165: ;
                            	  3166: ; This code is adapted from the 32 bit version of RND(n) used in EhBASIC68. Taking
                            	  3167: ; the 19th next number is slower but helps to hide the shift and add nature of this
                            	  3168: ; generator as can be seen from analysing the output.
                            	  3169: 
                            	  3170: gen_prng:
00:0000C172 2F01            	  3171: 	move.l d1,-(a7)
00:0000C174 4EB9000024C2    	  3172: 	jsr RandGetNum
00:0000C17A 2741000A        	  3173: 	move.l d1,PRNlword(a3)
00:0000C17E 221F            	  3174: 	move.l (a7)+,d1
00:0000C180 4E75            	  3175: 	rts
                            	  3176: 
                            	  3177: ;	MOVEM.l	d0-d2,-(sp)			; save d0, d1 and d2
                            	  3178: ;	MOVE.l	PRNlword(a3),d0		; get current seed longword
                            	  3179: ;	MOVEQ		#$AF-$100,d1		; set the EOR value
                            	  3180: ;	MOVEQ		#18,d2			; do this 19 times
                            	  3181: Ninc0
                            	  3182: ;	ADD.l		d0,d0				; shift left 1 bit
                            	  3183: ;	BCC.s		Ninc1				; if bit not set skip feedback
                            	  3184: 
                            	  3185: ;	EOR.b		d1,d0				; do Galois LFSR feedback
                            	  3186: Ninc1
                            	  3187: ;	DBF		d2,Ninc0			; loop
                            	  3188: 
                            	  3189: ;	MOVE.l	d0,PRNlword(a3)		; save back to seed longword
                            	  3190: ;	MOVEM.l	(sp)+,d0-d2			; restore d0, d1 and d2
                            	  3191: 
                            	  3192: ;	RTS
                            	  3193: 
                            	  3194: 
                            	  3195: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3196: ;
                            	  3197: ; vector generator subroutines. this code emulates the atari digital vector generator
                            	  3198: ; and truns the vector draw list into lines on the screen
                            	  3199: 
                            	  3200: ; vector subroutine return code. if a vector subroutine is called the address for this
                            	  3201: ; code is pushed on the stack
                            	  3202: 
                            	  3203: op_rtsvec:
00:0000C182 285F            	  3204: 	MOVE.l	(sp)+,a4			; restore the vector pointer
                            	  3205: 
                            	  3206: ; evaluate the next vector command. the command is pointed to by (a4) and execution
                            	  3207: ; will continue until an RTSL or HALT command is encountered. this is a subset of the
                            	  3208: ; battlezone DVG command set
                            	  3209: 
                            	  3210: do_vector:
00:0000C184 381C            	  3211: 	MOVE.w	(a4)+,d4			; get the vector opcode
00:0000C186 3004            	  3212: 	MOVE.w	d4,d0				; copy it
00:0000C188 ED58            	  3213: 	ROL.w		#6,d0				; shift opcode bits to b5-b2
00:0000C18A 0240003C        	  3214: 	ANDI.w	#$003C,d0			; mask the opcode bits
00:0000C18E 4EFB0076        	  3215: 	JMP		vector_base(pc,d0.w)	; go do the vector opcode
                            	  3216: 
                            	  3217: ; call vector subroutine, push the vector pointer and then the vector subroutine
                            	  3218: ; address as the return address then do jump to vector address
                            	  3219: 
                            	  3220: op_call
00:0000C192 2F0C            	  3221: 	MOVE.l	a4,-(sp)			; save the vector pointer
00:0000C194 487AFFEC        	  3222: 	PEA		op_rtsvec(pc)		; push vector return code as return address
                            	  3223: 
                            	  3224: ; jump to vector, the address is a thirteen bit address
                            	  3225: 
                            	  3226: op_jump
00:0000C198 C87C0FFF        	  3227: 	AND.w		#$0FFF,d4			; mask the address
00:0000C19C D844            	  3228: 	ADD.w		d4,d4				; make it a word address
00:0000C19E 49FA012E        	  3229: 	LEA		vector(pc),a4		; reset the vector RAM pointer
00:0000C1A2 49F44000        	  3230: 	LEA		(a4,d4.w),a4		; calculate the new address
00:0000C1A6 60DC            	  3231: 	BRA.s		do_vector			; go do the next vector
                            	  3232: 
                            	  3233: ; relative vector routine. co-ordinates are ten bit with sign numbers
                            	  3234: 
                            	  3235: op_vctr
00:0000C1A8 3E3C07FF        	  3236: 	MOVE.w	#$07FF,d7			; set the co-ordinate and sign bits mask
00:0000C1AC 720A            	  3237: 	MOVEQ		#10,d1			; set the sign bit number
                            	  3238: 
00:0000C1AE C847            	  3239: 	AND.w		d7,d4				; mask the y co-ordinate and sign
00:0000C1B0 0384            	  3240: 	BCLR.l	d1,d4				; test and clear the sign bit
00:0000C1B2 6702            	  3241: 	BEQ.s		no_neg_y11			; if positive skip the negate
                            	  3242: 
00:0000C1B4 4444            	  3243: 	NEG.w		d4				; else negate the y co-ordinate
                            	  3244: no_neg_y11
                            	  3245: 
00:0000C1B6 361C            	  3246: 	MOVE.w	(a4)+,d3			; get the second word
00:0000C1B8 3403            	  3247: 	MOVE.w	d3,d2				; copy the intensity
                            	  3248: 
00:0000C1BA C647            	  3249: 	AND.w		d7,d3				; mask the x co-ordinate and sign
00:0000C1BC 0383            	  3250: 	BCLR.l	d1,d3				; test and clear the sign bit
00:0000C1BE 6702            	  3251: 	BEQ.s		no_neg_x11			; if positive skip the negate
                            	  3252: 
00:0000C1C0 4443            	  3253: 	NEG.w		d3				; else negate the x co-ordinate
                            	  3254: no_neg_x11
                            	  3255: 
00:0000C1C2 E440            	  3256: 	ASR.w		#2,d0				; make the scale count from the masked JMP
00:0000C1C4 4440            	  3257: 	NEG.w		d0				; make negative
00:0000C1C6 D07C0009        	  3258: 	ADD.w		#9,d0				; make 9 - scale
                            	  3259: 
00:0000C1CA E063            	  3260: 	ASR.w		d0,d3				; scale the x co-ordinate
00:0000C1CC E064            	  3261: 	ASR.w		d0,d4				; scale the y co-ordinate
                            	  3262: 
00:0000C1CE 600000A2        	  3263: 	BRA		end_vector			; go do the end of the vector draw
                            	  3264: 
                            	  3265: ; set scale and position the beam
                            	  3266: 
                            	  3267: op_abs
00:0000C1D2 3E3C07FF        	  3268: 	MOVE.w	#$07FF,d7			; set the co-ordinate and sign bits mask
00:0000C1D6 720A            	  3269: 	MOVEQ		#10,d1			; set the sign bit number
                            	  3270: 
00:0000C1D8 C847            	  3271: 	AND.w		d7,d4				; mask the y co-ordinate and sign
00:0000C1DA 0384            	  3272: 	BCLR.l	d1,d4				; test and clear the sign bit
00:0000C1DC 6702            	  3273: 	BEQ.s		no_neg_y10			; if positive skip the negate
                            	  3274: 
00:0000C1DE 4444            	  3275: 	NEG.w		d4				; else negate the y co-ordinate
                            	  3276: no_neg_y10
                            	  3277: 
00:0000C1E0 361C            	  3278: 	MOVE.w	(a4)+,d3			; get the second word
00:0000C1E2 3403            	  3279: 	MOVE.w	d3,d2				; copy the scale
                            	  3280: 
00:0000C1E4 C647            	  3281: 	AND.w		d7,d3				; mask the x co-ordinate and sign
00:0000C1E6 0383            	  3282: 	BCLR.l	d1,d3				; test and clear the sign bit
00:0000C1E8 6702            	  3283: 	BEQ.s		no_neg_x10			; if positive skip the negate
                            	  3284: 
00:0000C1EA 4443            	  3285: 	NEG.w		d3				; else negate the x co-ordinate
                            	  3286: no_neg_x10
                            	  3287: 
                            	  3288: ; now convert the scale so it is b15 = direction flag and the rest is the shift count
                            	  3289: 
00:0000C1EC E95A            	  3290: 	ROL.w		#4,d2				; move the scale bits to bits 3 to 0
00:0000C1EE 0242000F        	  3291: 	ANDI.w	#$000F,d2			; mask the scale bits
00:0000C1F2 08820003        	  3292: 	BCLR.l	#3,d2				; clear the top bit
00:0000C1F6 6706            	  3293: 	BEQ.s		not_right			; ship right shift adjust
                            	  3294: 
00:0000C1F8 4442            	  3295: 	NEG.w		d2				; make negative
00:0000C1FA D47C8008        	  3296: 	ADD.w		#$8008,d2			; add offset and flag right shift
                            	  3297: not_right
00:0000C1FE 3682            	  3298: 	MOVE.w	d2,(a3)			; save the global scal, offset is zero	##
                            	  3299: ;##	MOVE.w	d2,vector_s(a3)		; save the global scale
                            	  3300: 
00:0000C200 7056            	  3301: 	MOVEQ		#86,d0			; set move to x,y
00:0000C202 6000009E        	  3302: 	BRA		vector_move			; go do the move
                            	  3303: 
                            	  3304: vector_base
00:0000C206 4E75            	  3305: 	RTS						; treat $0xxx as HALT, quit processing vectors
00:0000C208 4E71            	  3306: 	NOP						; filler
00:0000C20A 6000FF9C        	  3307: 	BRA.w		op_vctr			; scale 1 relative long vector
00:0000C20E 6000FF98        	  3308: 	BRA.w		op_vctr			; scale 2 relative long vector
00:0000C212 6000FF94        	  3309: 	BRA.w		op_vctr			; scale 3 relative long vector
00:0000C216 6000FF90        	  3310: 	BRA.w		op_vctr			; scale 4 relative long vector
00:0000C21A 6000FF8C        	  3311: 	BRA.w		op_vctr			; scale 5 relative long vector
00:0000C21E 6000FF88        	  3312: 	BRA.w		op_vctr			; scale 6 relative long vector
00:0000C222 6000FF84        	  3313: 	BRA.w		op_vctr			; scale 7 relative long vector
00:0000C226 6000FF80        	  3314: 	BRA.w		op_vctr			; scale 8 relative long vector
00:0000C22A 6000FF7C        	  3315: 	BRA.w		op_vctr			; scale 9 relative long vector
00:0000C22E 6000FFA2        	  3316: 	BRA.w		op_abs			; set scale and position beam
00:0000C232 4E75            	  3317: 	RTS						; do HALT, quit processing vectors
00:0000C234 4E71            	  3318: 	NOP						; filler
00:0000C236 6000FF5A        	  3319: 	BRA.w		op_call			; call vector subroutine
00:0000C23A 4E75            	  3320: 	RTS						; return from vector subroutine
00:0000C23C 4E71            	  3321: 	NOP						; filler
00:0000C23E 6000FF58        	  3322: 	BRA.w		op_jump			; do vector jump
                            	  3323: ;##	BRA.w		op_short			; draw relative short vector
                            	  3324: 
                            	  3325: ; do relative short vector
                            	  3326: 
                            	  3327: op_short
00:0000C242 3E04            	  3328: 	MOVE.w	d4,d7				; copy the opcode
00:0000C244 02470808        	  3329: 	ANDI.w	#$0808,d7			; mask the scale bits	0000 x000 0000 y000
00:0000C248 E94F            	  3330: 	LSL.w		#4,d7				; shift bits to b8,b0	x000 0000 y000 0000
00:0000C24A E31F            	  3331: 	ROL.b		#1,d7				; shift bits together	x000 0000 0000 000y
00:0000C24C E35F            	  3332: 	ROL.w		#1,d7				; shift bits to b1,b0	0000 0000 0000 00yx
00:0000C24E 5247            	  3333: 	ADDQ.w	#1,d7				; make 1 to 4
                            	  3334: 
00:0000C250 1F04            	  3335: 	MOVE.b	d4,-(sp)			; push the intensity byte
00:0000C252 341F            	  3336: 	MOVE.w	(sp)+,d2			; pull the word, intensity now in high byte
                            	  3337: 
00:0000C254 7007            	  3338: 	MOVEQ		#7,d0				; set the co-ordinate and sign bits mask
00:0000C256 7202            	  3339: 	MOVEQ		#2,d1				; set the sign bit number
                            	  3340: 
00:0000C258 3604            	  3341: 	MOVE.w	d4,d3				; copy the opcode for the x co-ordinate
                            	  3342: 
00:0000C25A 3F04            	  3343: 	MOVE.w	d4,-(sp)			; push the opcode
00:0000C25C 181F            	  3344: 	MOVE.b	(sp)+,d4			; pull the y co-ordinate byte
                            	  3345: 
00:0000C25E C840            	  3346: 	AND.w		d0,d4				; mask the y co-ordinate and sign bits
00:0000C260 0384            	  3347: 	BCLR.l	d1,d4				; test and clear the sign bit
00:0000C262 6702            	  3348: 	BEQ.s		no_neg_y2			; if positive just exit
                            	  3349: 
00:0000C264 4444            	  3350: 	NEG.w		d4				; else negate the y co-ordinate
                            	  3351: no_neg_y2
                            	  3352: 
00:0000C266 C640            	  3353: 	AND.w		d0,d3				; mask the x co-ordinate and sign bits
00:0000C268 0383            	  3354: 	BCLR.l	d1,d3				; test and clear the sign bit
00:0000C26A 6702            	  3355: 	BEQ.s		no_neg_x2			; if positive just exit
                            	  3356: 
00:0000C26C 4443            	  3357: 	NEG.w		d3				; else negate the x co-ordinate
                            	  3358: no_neg_x2
                            	  3359: 
00:0000C26E EF63            	  3360: 	ASL.w		d7,d3				; scale the x magnitude
00:0000C270 EF64            	  3361: 	ASL.w		d7,d4				; scale the y magnitude
                            	  3362: 
                            	  3363: end_vector
00:0000C272 3E13            	  3364: 	MOVE.w	(a3),d7			; get the global scale, offset is zero	##
                            	  3365: ;##	MOVE.w	vector_s(a3),d7		; get the global scale
00:0000C274 6A06            	  3366: 	BPL.s		shift_left			; if positive go shift left
                            	  3367: 
                            	  3368: 							; else shift right
00:0000C276 EE63            	  3369: 	ASR.w		d7,d3				; scale the x co-ordinate
00:0000C278 EE64            	  3370: 	ASR.w		d7,d4				; scale the y co-ordinate
00:0000C27A 6004            	  3371: 	BRA.s		last_vector			; continue
                            	  3372: 
                            	  3373: shift_left
00:0000C27C EF63            	  3374: 	ASL.w		d7,d3				; scale the x co-ordinate
00:0000C27E EF64            	  3375: 	ASL.w		d7,d4				; scale the y co-ordinate
                            	  3376: last_vector
00:0000C280 D66B0002        	  3377: 	ADD.w		local_x(a3),d3		; add x the co-ordinate to vector x
00:0000C284 D86B0004        	  3378: 	ADD.w		local_y(a3),d4		; add y the co-ordinate to vector y
                            	  3379: 
00:0000C288 7056            	  3380: 	MOVEQ		#86,d0			; set move to x,y
                            	  3381: 
00:0000C28A C47CF000        	  3382: 	AND.w		#$F000,d2			; d2 is intensity
00:0000C28E 6712            	  3383: 	BEQ.s		vector_move			; if zero intensity just do move
                            	  3384: 
00:0000C290 7200            	  3385: 	MOVEQ		#0,d1				; clear the longword
00:0000C292 3F02            	  3386: 	MOVE.w	d2,-(sp)			; copy the intensity
00:0000C294 141F            	  3387: 	MOVE.b	(sp)+,d2			; to the low byte byte
00:0000C296 1202            	  3388: 	MOVE.b	d2,d1				; copy the intensity byte
00:0000C298 4841            	  3389: 	SWAP		d1				; move to the high word
00:0000C29A 3202            	  3390: 	MOVE.w	d2,d1				; get the other word
                            	  3391: 
00:0000C29C 7050            	  3392: 	MOVEQ		#80,d0			; set pen colour
00:0000C29E 4E4F            	  3393: 	TRAP		#15
                            	  3394: 
00:0000C2A0 7055            	  3395: 	MOVEQ		#85,d0			; set draw to x,y
                            	  3396: vector_move
00:0000C2A2 3404            	  3397: 	MOVE.w	d4,d2				; copy the y co-ordinate
00:0000C2A4 3203            	  3398: 	MOVE.w	d3,d1				; copy the x co-ordinate
                            	  3399: ;##	BRA.s		display_vector		; display the vector
                            	  3400: 
                            	  3401: 
                            	  3402: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3403: ;
                            	  3404: ; display vector and do next. takes the vector, scales the x and y to the current
                            	  3405: ; screen size - does axis inversion if needed - and then displays it. set up the
                            	  3406: ; graphics function in d0, x co-ordinate in d1.w and y co-ordinate in d2.w
                            	  3407: 
                            	  3408: ;##display_vector
00:0000C2A6 37410002        	  3409: 	MOVE.w	d1,local_x(a3)		; save as new local x co-ordinate
00:0000C2AA 37420004        	  3410: 	MOVE.w	d2,local_y(a3)		; save as new local y co-ordinate
                            	  3411: 
00:0000C2AE 760A            	  3412: 	MOVEQ		#10,d3			; set the shift count for / 1024
                            	  3413: 
00:0000C2B0 C3EB0006        	  3414: 	MULS.w	scr_x(a3),d1		; x ; screen x
00:0000C2B4 E6A1            	  3415: 	ASR.l		d3,d1				; / 1024
                            	  3416: 
00:0000C2B6 947C0080        	  3417: 	SUB.w		#128,d2			; subtract offset to centre vertically
00:0000C2BA C5EB0006        	  3418: 	MULS.w	scr_x(a3),d2		; y ; screen x
00:0000C2BE E6A2            	  3419: 	ASR.l		d3,d2				; / 1024
00:0000C2C0 4442            	  3420: 	NEG.w		d2				; y = 0 is top of screen remember
00:0000C2C2 D46B0008        	  3421: 	ADD.w		scr_y(a3),d2		; + screen y
00:0000C2C6 5342            	  3422: 	SUBQ.w	#1,d2				; - 1
                            	  3423: 
00:0000C2C8 4E4F            	  3424: 	TRAP		#15				; do move or draw
                            	  3425: 
00:0000C2CA 6000FEB8        	  3426: 	BRA		do_vector			; go do the next vector opcode
                            	  3427: 
                            	  3428: 
                            	  3429: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3430: ;
                            	  3431: ; vector commands
                            	  3432: 
                            	  3433: REL1		EQU $1000				; draw relative
                            	  3434: REL2		EQU $2000				; draw relative
                            	  3435: REL3		EQU $3000				; draw relative
                            	  3436: REL4		EQU $4000				; draw relative
                            	  3437: REL5		EQU $5000				; draw relative
                            	  3438: REL6		EQU $6000				; draw relative
                            	  3439: REL7		EQU $7000				; draw relative
                            	  3440: REL8		EQU $8000				; draw relative
                            	  3441: REL9		EQU $9000				; draw relative
                            	  3442: DRAW		EQU $A000				; draw absolute
                            	  3443: HALT		EQU $B000				; halt
                            	  3444: JSRL		EQU $C000				; vector subroutine call
                            	  3445: RTSL		EQU $D000				; return from vector subroutine
                            	  3446: JMPL		EQU $E000				; vector jump
                            	  3447: SHRT		EQU $F000				; relative short vector
                            	  3448: 
                            	  3449: 
                            	  3450: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3451: ;
                            	  3452: ; vector list RAM
                            	  3453: 
                            	  3454: vector
00:0000C2CE 00              	  3455: 	ds.b	$1000					; 4k of space
00:0000C2CF *
                            	  3456: 
                            	  3457: 
                            	  3458: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3459: ;
                            	  3460: ; vector ROM
                            	  3461: 
                            	  3462: ; copyright symbol followed by JSR's to write "2009 LEE DAVISO", followed by a JMP to
                            	  3463: ; char_n, which is the routine for "N"
                            	  3464: 
                            	  3465: copy_msg
00:0000D2CE A088            	  3466: 	dc.w	$A088,$019A,$7000,$0000,$F573,$F173,$F178,$F177
00:0000D2D0 019A
00:0000D2D2 7000
00:0000D2D4 0000
00:0000D2D6 F573
00:0000D2D8 F173
00:0000D2DA F178
00:0000D2DC F177
00:0000D2DE F577            	  3467: 	dc.w	$F577,$F578,$3180,$0200,$F875,$FD70,$F871,$FD02
00:0000D2E0 F578
00:0000D2E2 3180
00:0000D2E4 0200
00:0000D2E6 F875
00:0000D2E8 FD70
00:0000D2EA F871
00:0000D2EC FD02
00:0000D2EE CAD6            	  3468: 	dc.w	JSRL+(char_2-vector)>>1		; 2
00:0000D2F0 CA81            	  3469: 	dc.w	JSRL+(char_o0-vector)>>1	; 0
00:0000D2F2 CA81            	  3470: 	dc.w	JSRL+(char_o0-vector)>>1	; 0
00:0000D2F4 CB07            	  3471: 	dc.w	JSRL+(char_9-vector)>>1		; 9
00:0000D2F6 CAD0            	  3472: 	dc.w	JSRL+(char_spc-vector)>>1	; [SPACE]
00:0000D2F8 CA71            	  3473: 	dc.w	JSRL+(char_l-vector)>>1		; L
00:0000D2FA CA3F            	  3474: 	dc.w	JSRL+(char_e-vector)>>1		; E
00:0000D2FC CA3F            	  3475: 	dc.w	JSRL+(char_e-vector)>>1		; E
00:0000D2FE CAD0            	  3476: 	dc.w	JSRL+(char_spc-vector)>>1	; [SPACE]
00:0000D300 CA37            	  3477: 	dc.w	JSRL+(char_d-vector)>>1		; D
00:0000D302 CA1C            	  3478: 	dc.w	JSRL+(char_a-vector)>>1		; A
00:0000D304 CAB2            	  3479: 	dc.w	JSRL+(char_v-vector)>>1		; V
00:0000D306 CA5E            	  3480: 	dc.w	JSRL+(char_i-vector)>>1		; I
00:0000D308 CA9F            	  3481: 	dc.w	JSRL+(char_s-vector)>>1		; S
00:0000D30A CA81            	  3482: 	dc.w	JSRL+(char_o0-vector)>>1	; O
00:0000D30C EA7C            	  3483: 	dc.w	JMPL+(char_n-vector)>>1		; N
                            	  3484: 
                            	  3485: ; table for the various saucer and rock explosions
                            	  3486: 
                            	  3487: expl_tab
00:0000D30E C874            	  3488: 	dc.w	JSRL+(expl_0-vector)>>1		; explosion 0
00:0000D310 C859            	  3489: 	dc.w	JSRL+(expl_1-vector)>>1		; explosion 1
00:0000D312 C83A            	  3490: 	dc.w	JSRL+(expl_2-vector)>>1		; explosion 2
00:0000D314 C824            	  3491: 	dc.w	JSRL+(expl_3-vector)>>1		; explosion 3
                            	  3492: 
                            	  3493: ; explosion 3
                            	  3494: 
                            	  3495: expl_3
00:0000D316 F80D            	  3496: 	dc.w	$F80D,$F8F8,$FD0D,$F8F8,$FD09,$F8F8,$F10B,$F8F8
00:0000D318 F8F8
00:0000D31A FD0D
00:0000D31C F8F8
00:0000D31E FD09
00:0000D320 F8F8
00:0000D322 F10B
00:0000D324 F8F8
00:0000D326 F50A            	  3497: 	dc.w	$F50A,$F8F8,$F908,$F8F8,$F309,$F8F8,$F30D,$F8F8
00:0000D328 F8F8
00:0000D32A F908
00:0000D32C F8F8
00:0000D32E F309
00:0000D330 F8F8
00:0000D332 F30D
00:0000D334 F8F8
00:0000D336 5480            	  3498: 	dc.w	$5480,$0600,$F8F8,$F10F,$F8F8,RTSL
00:0000D338 0600
00:0000D33A F8F8
00:0000D33C F10F
00:0000D33E F8F8
00:0000D340 D000
                            	  3499: 
                            	  3500: ; explosion 2
                            	  3501: 
                            	  3502: expl_2
00:0000D342 3000            	  3503: 	dc.w	$3000,$0780,$F8F8,$3780,$0780,$F8F8,$3780,$0380
00:0000D344 0780
00:0000D346 F8F8
00:0000D348 3780
00:0000D34A 0780
00:0000D34C F8F8
00:0000D34E 3780
00:0000D350 0380
00:0000D352 F8F8            	  3504: 	dc.w	$F8F8,$40E0,$02A0,$F8F8,$35C0,$0380,$F8F8,$3380
00:0000D354 40E0
00:0000D356 02A0
00:0000D358 F8F8
00:0000D35A 35C0
00:0000D35C 0380
00:0000D35E F8F8
00:0000D360 3380
00:0000D362 0000            	  3505: 	dc.w	$0000,$F8F8,$42A0,$00E0,$F8F8,$42A0,$04E0,$F8F8
00:0000D364 F8F8
00:0000D366 42A0
00:0000D368 00E0
00:0000D36A F8F8
00:0000D36C 42A0
00:0000D36E 04E0
00:0000D370 F8F8
00:0000D372 44E0            	  3506: 	dc.w	$44E0,$0780,$F8F8,$40E0,$06A0,$F8F8,RTSL
00:0000D374 0780
00:0000D376 F8F8
00:0000D378 40E0
00:0000D37A 06A0
00:0000D37C F8F8
00:0000D37E D000
                            	  3507: 
                            	  3508: ; explosion 1
                            	  3509: 
                            	  3510: expl_1
00:0000D380 F807            	  3511: 	dc.w	$F807,$F8F8,$FF07,$F8F8,$FF03,$F8F8,$40C0,$0240
00:0000D382 F8F8
00:0000D384 FF07
00:0000D386 F8F8
00:0000D388 FF03
00:0000D38A F8F8
00:0000D38C 40C0
00:0000D38E 0240
00:0000D390 F8F8            	  3512: 	dc.w	$F8F8,$3580,$0300,$F8F8,$FB00,$F8F8,$4240,$00C0
00:0000D392 3580
00:0000D394 0300
00:0000D396 F8F8
00:0000D398 FB00
00:0000D39A F8F8
00:0000D39C 4240
00:0000D39E 00C0
00:0000D3A0 F8F8            	  3513: 	dc.w	$F8F8,$4240,$04C0,$F8F8,$44C0,$0700,$F8F8,$40C0
00:0000D3A2 4240
00:0000D3A4 04C0
00:0000D3A6 F8F8
00:0000D3A8 44C0
00:0000D3AA 0700
00:0000D3AC F8F8
00:0000D3AE 40C0
00:0000D3B0 0640            	  3514: 	dc.w	$0640,$F8F8,RTSL
00:0000D3B2 F8F8
00:0000D3B4 D000
                            	  3515: 
                            	  3516: ; explosion 0
                            	  3517: 
                            	  3518: expl_0
00:0000D3B6 3000            	  3519: 	dc.w	$3000,$0680,$F8F8,$3680,$0680,$F8F8,$3680,$0280
00:0000D3B8 0680
00:0000D3BA F8F8
00:0000D3BC 3680
00:0000D3BE 0680
00:0000D3C0 F8F8
00:0000D3C2 3680
00:0000D3C4 0280
00:0000D3C6 F8F8            	  3520: 	dc.w	$F8F8,$3140,$03C0,$F8F8,$3540,$0280,$F8F8,$3280
00:0000D3C8 3140
00:0000D3CA 03C0
00:0000D3CC F8F8
00:0000D3CE 3540
00:0000D3D0 0280
00:0000D3D2 F8F8
00:0000D3D4 3280
00:0000D3D6 0000            	  3521: 	dc.w	$0000,$F8F8,$33C0,$0140,$F8F8,$33C0,$0540,$F8F8
00:0000D3D8 F8F8
00:0000D3DA 33C0
00:0000D3DC 0140
00:0000D3DE F8F8
00:0000D3E0 33C0
00:0000D3E2 0540
00:0000D3E4 F8F8
00:0000D3E6 44A0            	  3522: 	dc.w	$44A0,$0680,$F8F8,$3140,$07C0,$F8F8,RTSL
00:0000D3E8 0680
00:0000D3EA F8F8
00:0000D3EC 3140
00:0000D3EE 07C0
00:0000D3F0 F8F8
00:0000D3F2 D000
                            	  3523: 
                            	  3524: ; table for rocks
                            	  3525: 
                            	  3526: rock_tab
00:0000D3F4 C897            	  3527: 	dc.w	JSRL+(rock_0-vector)>>1		; top notch rock
00:0000D3F6 C8A3            	  3528: 	dc.w	JSRL+(rock_1-vector)>>1		; "X" rock
00:0000D3F8 C8B1            	  3529: 	dc.w	JSRL+(rock_2-vector)>>1		; bottom and left notch rock
00:0000D3FA C8BE            	  3530: 	dc.w	JSRL+(rock_3-vector)>>1		; left and right notch rock
                            	  3531: 
                            	  3532: ; top notch rock
                            	  3533: 
                            	  3534: rock_0
00:0000D3FC F908            	  3535: 	dc.w	$F908,$F979,$FD79,$F67D,$F679,$F68F,$F08F,$F97D
00:0000D3FE F979
00:0000D400 FD79
00:0000D402 F67D
00:0000D404 F679
00:0000D406 F68F
00:0000D408 F08F
00:0000D40A F97D
00:0000D40C FA78            	  3536: 	dc.w	$FA78,$F979,$FD79,RTSL
00:0000D40E F979
00:0000D410 FD79
00:0000D412 D000
                            	  3537: 
                            	  3538: ; "X" rock
                            	  3539: 
                            	  3540: rock_1
00:0000D414 F10A            	  3541: 	dc.w	$F10A,$F17A,$F97D,$F57E,$F17E,$FD7D,$F679,$F67D
00:0000D416 F17A
00:0000D418 F97D
00:0000D41A F57E
00:0000D41C F17E
00:0000D41E FD7D
00:0000D420 F679
00:0000D422 F67D
00:0000D424 FD79            	  3542: 	dc.w	$FD79,$F179,$F58B,$F38A,$F97D,RTSL
00:0000D426 F179
00:0000D428 F58B
00:0000D42A F38A
00:0000D42C F97D
00:0000D42E D000
                            	  3543: 
                            	  3544: ; bottom and left notch rock
                            	  3545: 
                            	  3546: rock_2
00:0000D430 F80D            	  3547: 	dc.w	$F80D,$F57E,$F77A,$F37A,$F778,$F879,$F37A,$F978
00:0000D432 F57E
00:0000D434 F77A
00:0000D436 F37A
00:0000D438 F778
00:0000D43A F879
00:0000D43C F37A
00:0000D43E F978
00:0000D440 F37E            	  3548: 	dc.w	$F37E,$F07F,$F77F,$F57A,RTSL
00:0000D442 F07F
00:0000D444 F77F
00:0000D446 F57A
00:0000D448 D000
                            	  3549: 
                            	  3550: ; left and right notch rock
                            	  3551: 
                            	  3552: rock_3
00:0000D44A F009            	  3553: 	dc.w	$F009,$F17B,$F168,$F27F,$F07F,$F669,$F07F,$F778
00:0000D44C F17B
00:0000D44E F168
00:0000D450 F27F
00:0000D452 F07F
00:0000D454 F669
00:0000D456 F07F
00:0000D458 F778
00:0000D45A F77A            	  3554: 	dc.w	$F77A,$F17B,$F569,$F969,$F27F,RTSL
00:0000D45C F17B
00:0000D45E F569
00:0000D460 F969
00:0000D462 F27F
00:0000D464 D000
                            	  3555: 
                            	  3556: ; indirect saucer table
                            	  3557: 
                            	  3558: sauc_jsr
00:0000D466 C8CD            	  3559: 	dc.w	JSRL+(sauc_vec-vector)>>1	; saucer
                            	  3560: 
                            	  3561: ; saucer
                            	  3562: 
                            	  3563: sauc_vec
00:0000D468 F10E            	  3564: 	dc.w	$F10E,$F8CA,$F60B,$6000,$D680,$F6DB,$F8CA,$F2DB
00:0000D46A F8CA
00:0000D46C F60B
00:0000D46E 6000
00:0000D470 D680
00:0000D472 F6DB
00:0000D474 F8CA
00:0000D476 F2DB
00:0000D478 F2DF            	  3565: 	dc.w	$F2DF,$F2CD,$F8CD,$F6CD,$F6DF,RTSL
00:0000D47A F2CD
00:0000D47C F8CD
00:0000D47E F6CD
00:0000D480 F6DF
00:0000D482 D000
                            	  3566: 
                            	  3567: ; player ship address table
                            	  3568: 
                            	  3569: play_tab
00:0000D484 0022            	  3570: 	dc.w	play_00-play_tab
00:0000D486 003A            	  3571: 	dc.w	play_01-play_tab
00:0000D488 005E            	  3572: 	dc.w	play_02-play_tab
00:0000D48A 0082            	  3573: 	dc.w	play_03-play_tab
00:0000D48C 00A6            	  3574: 	dc.w	play_04-play_tab
00:0000D48E 00C8            	  3575: 	dc.w	play_05-play_tab
00:0000D490 00EC            	  3576: 	dc.w	play_06-play_tab
00:0000D492 0110            	  3577: 	dc.w	play_07-play_tab
00:0000D494 0134            	  3578: 	dc.w	play_08-play_tab
00:0000D496 0158            	  3579: 	dc.w	play_09-play_tab
00:0000D498 017C            	  3580: 	dc.w	play_0A-play_tab
00:0000D49A 01A0            	  3581: 	dc.w	play_0B-play_tab
00:0000D49C 01C4            	  3582: 	dc.w	play_0C-play_tab
00:0000D49E 01E8            	  3583: 	dc.w	play_0D-play_tab
00:0000D4A0 020C            	  3584: 	dc.w	play_0E-play_tab
00:0000D4A2 0230            	  3585: 	dc.w	play_0F-play_tab
00:0000D4A4 0254            	  3586: 	dc.w	play_10-play_tab
                            	  3587: 
                            	  3588: ; ship and thrust outlines. each ship outline is followed by its thrust outline which
                            	  3589: ; is only copied if the thrust button is pressed
                            	  3590: 
                            	  3591: play_00
00:0000D4A6 F60F            	  3592: 	dc.w	$F60F,$FAC8,$F9BD,$6500,$C300,$6500,$C700,$F9B9
00:0000D4A8 FAC8
00:0000D4AA F9BD
00:0000D4AC 6500
00:0000D4AE C300
00:0000D4B0 6500
00:0000D4B2 C700
00:0000D4B4 F9B9
00:0000D4B6 D000            	  3593: 	dc.w	RTSL
00:0000D4B8 F9CE            	  3594: 	dc.w	$F9CE,$F9CA,RTSL
00:0000D4BA F9CA
00:0000D4BC D000
                            	  3595: play_01
00:0000D4BE 4640            	  3596: 	dc.w	$4640,$06C0,$5200,$C430,$41C0,$C620,$64B0,$C318
00:0000D4C0 06C0
00:0000D4C2 5200
00:0000D4C4 C430
00:0000D4C6 41C0
00:0000D4C8 C620
00:0000D4CA 64B0
00:0000D4CC C318
00:0000D4CE 6548            	  3597: 	dc.w	$6548,$C6E0,$4220,$C1C0,RTSL
00:0000D4D0 C6E0
00:0000D4D2 4220
00:0000D4D4 C1C0
00:0000D4D6 D000
00:0000D4D8 50D0            	  3598: 	dc.w	$50D0,$C610,$4260,$C3C0,RTSL
00:0000D4DA C610
00:0000D4DC 4260
00:0000D4DE C3C0
00:0000D4E0 D000
                            	  3599: play_02
00:0000D4E2 4680            	  3600: 	dc.w	$4680,$0680,$43E0,$C4C0,$41A0,$C660,$6468,$C320
00:0000D4E4 0680
00:0000D4E6 43E0
00:0000D4E8 C4C0
00:0000D4EA 41A0
00:0000D4EC C660
00:0000D4EE 6468
00:0000D4F0 C320
00:0000D4F2 6590            	  3601: 	dc.w	$6590,$C6C0,$4260,$C1A0,RTSL
00:0000D4F4 C6C0
00:0000D4F6 4260
00:0000D4F8 C1A0
00:0000D4FA D000
00:0000D4FC 5090            	  3602: 	dc.w	$5090,$C630,$42C0,$C380,RTSL
00:0000D4FE C630
00:0000D500 42C0
00:0000D502 C380
00:0000D504 D000
                            	  3603: play_03
00:0000D506 46C0            	  3604: 	dc.w	$46C0,$0640,$43E0,$C520,$4160,$C680,$6418,$C328
00:0000D508 0640
00:0000D50A 43E0
00:0000D50C C520
00:0000D50E 4160
00:0000D510 C680
00:0000D512 6418
00:0000D514 C328
00:0000D516 65D0            	  3605: 	dc.w	$65D0,$C698,$4280,$C160,RTSL
00:0000D518 C698
00:0000D51A 4280
00:0000D51C C160
00:0000D51E D000
00:0000D520 5060            	  3606: 	dc.w	$5060,$C630,$4320,$C340,RTSL
00:0000D522 C630
00:0000D524 4320
00:0000D526 C340
00:0000D528 D000
                            	  3607: play_04
00:0000D52A F70E            	  3608: 	dc.w	$F70E,$43C0,$C580,$4120,$C6A0,$6038,$C328,$6610
00:0000D52C 43C0
00:0000D52E C580
00:0000D530 4120
00:0000D532 C6A0
00:0000D534 6038
00:0000D536 C328
00:0000D538 6610
00:0000D53A C660            	  3609: 	dc.w	$C660,$42A0,$C120,RTSL
00:0000D53C 42A0
00:0000D53E C120
00:0000D540 D000
00:0000D542 5030            	  3610: 	dc.w	$5030,$C640,$4360,$C2E0,RTSL
00:0000D544 C640
00:0000D546 4360
00:0000D548 C2E0
00:0000D54A D000
                            	  3611: play_05
00:0000D54C 4720            	  3612: 	dc.w	$4720,$05C0,$4380,$C5E0,$40E0,$C6C0,$6088,$C320
00:0000D54E 05C0
00:0000D550 4380
00:0000D552 C5E0
00:0000D554 40E0
00:0000D556 C6C0
00:0000D558 6088
00:0000D55A C320
00:0000D55C 6648            	  3613: 	dc.w	$6648,$C630,$42C0,$C0E0,RTSL
00:0000D55E C630
00:0000D560 42C0
00:0000D562 C0E0
00:0000D564 D000
00:0000D566 5410            	  3614: 	dc.w	$5410,$C640,$43A0,$C2A0,RTSL
00:0000D568 C640
00:0000D56A 43A0
00:0000D56C C2A0
00:0000D56E D000
                            	  3615: play_06
00:0000D570 4760            	  3616: 	dc.w	$4760,$0560,$4360,$C640,$4080,$C6C0,$60D8,$C310
00:0000D572 0560
00:0000D574 4360
00:0000D576 C640
00:0000D578 4080
00:0000D57A C6C0
00:0000D57C 60D8
00:0000D57E C310
00:0000D580 6680            	  3617: 	dc.w	$6680,$C5F0,$42C0,$C080,RTSL
00:0000D582 C5F0
00:0000D584 42C0
00:0000D586 C080
00:0000D588 D000
00:0000D58A 5440            	  3618: 	dc.w	$5440,$C630,$43E0,$C240,RTSL
00:0000D58C C630
00:0000D58E 43E0
00:0000D590 C240
00:0000D592 D000
                            	  3619: play_07
00:0000D594 4780            	  3620: 	dc.w	$4780,$0500,$4320,$C680,$4040,$C6E0,$6120,$C2F8
00:0000D596 0500
00:0000D598 4320
00:0000D59A C680
00:0000D59C 4040
00:0000D59E C6E0
00:0000D5A0 6120
00:0000D5A2 C2F8
00:0000D5A4 66B0            	  3621: 	dc.w	$66B0,$C5B0,$42E0,$C040,RTSL
00:0000D5A6 C5B0
00:0000D5A8 42E0
00:0000D5AA C040
00:0000D5AC D000
00:0000D5AE 5480            	  3622: 	dc.w	$5480,$C630,$5210,$C0F0,RTSL
00:0000D5B0 C630
00:0000D5B2 5210
00:0000D5B4 C0F0
00:0000D5B6 D000
                            	  3623: play_08
00:0000D5B8 4780            	  3624: 	dc.w	$4780,$04C0,$42E0,$C6E0,$4000,$C6E0,$6168,$C2D8
00:0000D5BA 04C0
00:0000D5BC 42E0
00:0000D5BE C6E0
00:0000D5C0 4000
00:0000D5C2 C6E0
00:0000D5C4 6168
00:0000D5C6 C2D8
00:0000D5C8 66D8            	  3625: 	dc.w	$66D8,$C568,$42E0,$C000,RTSL
00:0000D5CA C568
00:0000D5CC 42E0
00:0000D5CE C000
00:0000D5D0 D000
00:0000D5D2 54B0            	  3626: 	dc.w	$54B0,$C620,$5220,$C0B0,RTSL
00:0000D5D4 C620
00:0000D5D6 5220
00:0000D5D8 C0B0
00:0000D5DA D000
                            	  3627: play_09
00:0000D5DC 47A0            	  3628: 	dc.w	$47A0,$0460,$4280,$C720,$4440,$C6E0,$61B0,$C2B0
00:0000D5DE 0460
00:0000D5E0 4280
00:0000D5E2 C720
00:0000D5E4 4440
00:0000D5E6 C6E0
00:0000D5E8 61B0
00:0000D5EA C2B0
00:0000D5EC 66F8            	  3629: 	dc.w	$66F8,$C520,$42E0,$C440,RTSL
00:0000D5EE C520
00:0000D5F0 42E0
00:0000D5F2 C440
00:0000D5F4 D000
00:0000D5F6 54F0            	  3630: 	dc.w	$54F0,$C610,$5230,$C080,RTSL
00:0000D5F8 C610
00:0000D5FA 5230
00:0000D5FC C080
00:0000D5FE D000
                            	  3631: play_0A
00:0000D600 47A0            	  3632: 	dc.w	$47A0,$0000,$4240,$C760,$4480,$C6C0,$61F0,$C280
00:0000D602 0000
00:0000D604 4240
00:0000D606 C760
00:0000D608 4480
00:0000D60A C6C0
00:0000D60C 61F0
00:0000D60E C280
00:0000D610 6710            	  3633: 	dc.w	$6710,$C4D8,$42C0,$C480,RTSL
00:0000D612 C4D8
00:0000D614 42C0
00:0000D616 C480
00:0000D618 D000
00:0000D61A 4640            	  3634: 	dc.w	$4640,$C7E0,$5230,$C040,RTSL
00:0000D61C C7E0
00:0000D61E 5230
00:0000D620 C040
00:0000D622 D000
                            	  3635: play_0B
00:0000D624 47A0            	  3636: 	dc.w	$47A0,$0060,$41E0,$C780,$44E0,$C6C0,$6230,$C248
00:0000D626 0060
00:0000D628 41E0
00:0000D62A C780
00:0000D62C 44E0
00:0000D62E C6C0
00:0000D630 6230
00:0000D632 C248
00:0000D634 6720            	  3637: 	dc.w	$6720,$C488,$42C0,$C4E0,RTSL
00:0000D636 C488
00:0000D638 42C0
00:0000D63A C4E0
00:0000D63C D000
00:0000D63E 46A0            	  3638: 	dc.w	$46A0,$C7A0,$5240,$C010,RTSL
00:0000D640 C7A0
00:0000D642 5240
00:0000D644 C010
00:0000D646 D000
                            	  3639: play_0C
00:0000D648 4780            	  3640: 	dc.w	$4780,$00C0,$4180,$C7C0,$4520,$C6A0,$6260,$C210
00:0000D64A 00C0
00:0000D64C 4180
00:0000D64E C7C0
00:0000D650 4520
00:0000D652 C6A0
00:0000D654 6260
00:0000D656 C210
00:0000D658 6728            	  3641: 	dc.w	$6728,$C438,$42A0,$C520,RTSL
00:0000D65A C438
00:0000D65C 42A0
00:0000D65E C520
00:0000D660 D000
00:0000D662 46E0            	  3642: 	dc.w	$46E0,$C760,$5240,$C430,RTSL
00:0000D664 C760
00:0000D666 5240
00:0000D668 C430
00:0000D66A D000
                            	  3643: play_0D
00:0000D66C 4780            	  3644: 	dc.w	$4780,$0100,$4120,$C7E0,$4560,$C680,$6298,$C1D0
00:0000D66E 0100
00:0000D670 4120
00:0000D672 C7E0
00:0000D674 4560
00:0000D676 C680
00:0000D678 6298
00:0000D67A C1D0
00:0000D67C 6728            	  3645: 	dc.w	$6728,$C018,$4280,$C560,RTSL
00:0000D67E C018
00:0000D680 4280
00:0000D682 C560
00:0000D684 D000
00:0000D686 4740            	  3646: 	dc.w	$4740,$C720,$5230,$C460,RTSL
00:0000D688 C720
00:0000D68A 5230
00:0000D68C C460
00:0000D68E D000
                            	  3647: play_0E
00:0000D690 4760            	  3648: 	dc.w	$4760,$0160,$40C0,$C7E0,$45A0,$C660,$62C0,$C190
00:0000D692 0160
00:0000D694 40C0
00:0000D696 C7E0
00:0000D698 45A0
00:0000D69A C660
00:0000D69C 62C0
00:0000D69E C190
00:0000D6A0 6720            	  3649: 	dc.w	$6720,$C068,$4260,$C5A0,RTSL
00:0000D6A2 C068
00:0000D6A4 4260
00:0000D6A6 C5A0
00:0000D6A8 D000
00:0000D6AA 4780            	  3650: 	dc.w	$4780,$C6C0,$5230,$C490,RTSL
00:0000D6AC C6C0
00:0000D6AE 5230
00:0000D6B0 C490
00:0000D6B2 D000
                            	  3651: play_0F
00:0000D6B4 4720            	  3652: 	dc.w	$4720,$01C0,$5030,$C600,$45C0,$C620,$62E0,$C148
00:0000D6B6 01C0
00:0000D6B8 5030
00:0000D6BA C600
00:0000D6BC 45C0
00:0000D6BE C620
00:0000D6C0 62E0
00:0000D6C2 C148
00:0000D6C4 6718            	  3653: 	dc.w	$6718,$C0B0,$4220,$C5C0,RTSL
00:0000D6C6 C0B0
00:0000D6C8 4220
00:0000D6CA C5C0
00:0000D6CC D000
00:0000D6CE 47C0            	  3654: 	dc.w	$47C0,$C660,$5210,$C4D0,RTSL
00:0000D6D0 C660
00:0000D6D2 5210
00:0000D6D4 C4D0
00:0000D6D6 D000
                            	  3655: play_10
00:0000D6D8 F70A            	  3656: 	dc.w	$F70A,$F8CE,$FDCD,$6300,$C100,$6700,$C100,$F9CD
00:0000D6DA F8CE
00:0000D6DC FDCD
00:0000D6DE 6300
00:0000D6E0 C100
00:0000D6E2 6700
00:0000D6E4 C100
00:0000D6E6 F9CD
00:0000D6E8 D000            	  3657: 	dc.w	RTSL
00:0000D6EA FECD            	  3658: 	dc.w	$FECD,$FACD,RTSL
00:0000D6EC FACD
00:0000D6EE D000
                            	  3659: 
                            	  3660: ; ship outline for player lives
                            	  3661: 
                            	  3662: play_liv
00:0000D6F0 F70E            	  3663: 	dc.w	$F70E,$F87A,$FD79,$6300,$7500,$6700,$7500,$F979
00:0000D6F2 F87A
00:0000D6F4 FD79
00:0000D6F6 6300
00:0000D6F8 7500
00:0000D6FA 6700
00:0000D6FC 7500
00:0000D6FE F979
00:0000D700 60C0            	  3664: 	dc.w	$60C0,$0280,$D09F
00:0000D702 0280
00:0000D704 D09F
                            	  3665: 
                            	  3666: ; character set
                            	  3667: 
                            	  3668: char_a						; A
00:0000D706 FA70            	  3669: 	dc.w	$FA70,$F272,$F672,$FE70
00:0000D708 F272
00:0000D70A F672
00:0000D70C FE70
00:0000D70E F906            	  3670: 	dc.w	$F906,$F872,$F602,RTSL
00:0000D710 F872
00:0000D712 F602
00:0000D714 D000
                            	  3671: char_b						; B
00:0000D716 FB70            	  3672: 	dc.w	$FB70,$F073,$F571,$F570
00:0000D718 F073
00:0000D71A F571
00:0000D71C F570
00:0000D71E F575            	  3673: 	dc.w	$F575,$F077,$F003,$F571
00:0000D720 F077
00:0000D722 F003
00:0000D724 F571
00:0000D726 F570            	  3674: 	dc.w	$F570,$F575,$F077,$F803,RTSL
00:0000D728 F575
00:0000D72A F077
00:0000D72C F803
00:0000D72E D000
                            	  3675: char_c						; C
00:0000D730 FB70            	  3676: 	dc.w	$FB70,$F872,$FF06,$F872
00:0000D732 F872
00:0000D734 FF06
00:0000D736 F872
00:0000D738 F002            	  3677: 	dc.w	$F002,RTSL
00:0000D73A D000
                            	  3678: char_d						; D
00:0000D73C FB70            	  3679: 	dc.w	$FB70,$F072,$F672,$F670
00:0000D73E F072
00:0000D740 F672
00:0000D742 F670
00:0000D744 F676            	  3680: 	dc.w	$F676,$F076,$F803,RTSL
00:0000D746 F076
00:0000D748 F803
00:0000D74A D000
                            	  3681: char_e						; E
00:0000D74C FB70            	  3682: 	dc.w	$FB70,$F872,$F705,$F077
00:0000D74E F872
00:0000D750 F705
00:0000D752 F077
00:0000D754 F700            	  3683: 	dc.w	$F700,$F872,$F002,RTSL
00:0000D756 F872
00:0000D758 F002
00:0000D75A D000
                            	  3684: char_f						; F
00:0000D75C FB70            	  3685: 	dc.w	$FB70,$F872,$F705,$F077
00:0000D75E F872
00:0000D760 F705
00:0000D762 F077
00:0000D764 F700            	  3686: 	dc.w	$F700,$F803,RTSL
00:0000D766 F803
00:0000D768 D000
                            	  3687: char_g						; G
00:0000D76A FB70            	  3688: 	dc.w	$FB70,$F872,$F670,$F606
00:0000D76C F872
00:0000D76E F670
00:0000D770 F606
00:0000D772 F072            	  3689: 	dc.w	$F072,$F670,$F876,$F803
00:0000D774 F670
00:0000D776 F876
00:0000D778 F803
00:0000D77A D000            	  3690: 	dc.w	RTSL
                            	  3691: char_h						; H
00:0000D77C FB70            	  3692: 	dc.w	$FB70,$F700,$F872,$F300
00:0000D77E F700
00:0000D780 F872
00:0000D782 F300
00:0000D784 FF70            	  3693: 	dc.w	$FF70,$F002,RTSL
00:0000D786 F002
00:0000D788 D000
                            	  3694: char_i						; I
00:0000D78A F872            	  3695: 	dc.w	$F872,$F006,$FB70,$F002
00:0000D78C F006
00:0000D78E FB70
00:0000D790 F002
00:0000D792 F876            	  3696: 	dc.w	$F876,$FF03,RTSL
00:0000D794 FF03
00:0000D796 D000
                            	  3697: char_j						; J
00:0000D798 F200            	  3698: 	dc.w	$F200,$F672,$F072,$FB70
00:0000D79A F672
00:0000D79C F072
00:0000D79E FB70
00:0000D7A0 FF01            	  3699: 	dc.w	$FF01,RTSL
00:0000D7A2 D000
                            	  3700: char_k						; K
00:0000D7A4 FB70            	  3701: 	dc.w	$FB70,$F003,$F777,$F773
00:0000D7A6 F003
00:0000D7A8 F777
00:0000D7AA F773
00:0000D7AC F003            	  3702: 	dc.w	$F003,RTSL
00:0000D7AE D000
                            	  3703: char_l						; L
00:0000D7B0 FB00            	  3704: 	dc.w	$FB00,$FF70,$F872,$F002,RTSL
00:0000D7B2 FF70
00:0000D7B4 F872
00:0000D7B6 F002
00:0000D7B8 D000
                            	  3705: char_m						; M
00:0000D7BA FB70            	  3706: 	dc.w	$FB70,$F672,$F272,$FF70
00:0000D7BC F672
00:0000D7BE F272
00:0000D7C0 FF70
00:0000D7C2 F002            	  3707: 	dc.w	$F002,RTSL
00:0000D7C4 D000
                            	  3708: char_n						; N
00:0000D7C6 FB70            	  3709: 	dc.w	$FB70,$FF72,$FB70,$FF01,RTSL
00:0000D7C8 FF72
00:0000D7CA FB70
00:0000D7CC FF01
00:0000D7CE D000
                            	  3710: char_o0						; O,0
00:0000D7D0 FB70            	  3711: 	dc.w	$FB70,$F872,$FF70,$F876
00:0000D7D2 F872
00:0000D7D4 FF70
00:0000D7D6 F876
00:0000D7D8 F803            	  3712: 	dc.w	$F803,RTSL
00:0000D7DA D000
                            	  3713: char_p						; P
00:0000D7DC FB70            	  3714: 	dc.w	$FB70,$F872,$F770,$F876
00:0000D7DE F872
00:0000D7E0 F770
00:0000D7E2 F876
00:0000D7E4 F703            	  3715: 	dc.w	$F703,$F003,RTSL
00:0000D7E6 F003
00:0000D7E8 D000
                            	  3716: char_q						; Q
00:0000D7EA FB70            	  3717: 	dc.w	$FB70,$F872,$FE70,$F676
00:0000D7EC F872
00:0000D7EE FE70
00:0000D7F0 F676
00:0000D7F2 F076            	  3718: 	dc.w	$F076,$F202,$F672,$F002
00:0000D7F4 F202
00:0000D7F6 F672
00:0000D7F8 F002
00:0000D7FA D000            	  3719: 	dc.w	RTSL
                            	  3720: char_r						; R
00:0000D7FC FB70            	  3721: 	dc.w	$FB70,$F872,$F770,$F876
00:0000D7FE F872
00:0000D800 F770
00:0000D802 F876
00:0000D804 F001            	  3722: 	dc.w	$F001,$F773,$F002,RTSL
00:0000D806 F773
00:0000D808 F002
00:0000D80A D000
                            	  3723: char_s						; S
00:0000D80C F872            	  3724: 	dc.w	$F872,$F370,$F876,$F370
00:0000D80E F370
00:0000D810 F876
00:0000D812 F370
00:0000D814 F872            	  3725: 	dc.w	$F872,$FF01,RTSL
00:0000D816 FF01
00:0000D818 D000
                            	  3726: char_t						; T
00:0000D81A F002            	  3727: 	dc.w	$F002,$FB70,$F006,$F872
00:0000D81C FB70
00:0000D81E F006
00:0000D820 F872
00:0000D822 FF01            	  3728: 	dc.w	$FF01,RTSL
00:0000D824 D000
                            	  3729: char_u						; U
00:0000D826 FB00            	  3730: 	dc.w	$FB00,$FF70,$F872,$FB70
00:0000D828 FF70
00:0000D82A F872
00:0000D82C FB70
00:0000D82E FF01            	  3731: 	dc.w	$FF01,RTSL
00:0000D830 D000
                            	  3732: char_v						; V
00:0000D832 FB00            	  3733: 	dc.w	$FB00,$FF71,$FB71,$FF01,RTSL
00:0000D834 FF71
00:0000D836 FB71
00:0000D838 FF01
00:0000D83A D000
                            	  3734: char_w						; W
00:0000D83C FB00            	  3735: 	dc.w	$FB00,$FF70,$F272,$F672
00:0000D83E FF70
00:0000D840 F272
00:0000D842 F672
00:0000D844 FB70            	  3736: 	dc.w	$FB70,$FF01,RTSL
00:0000D846 FF01
00:0000D848 D000
                            	  3737: char_x						; X
00:0000D84A FB72            	  3738: 	dc.w	$FB72,$F806,$FF72,$F002,RTSL
00:0000D84C F806
00:0000D84E FF72
00:0000D850 F002
00:0000D852 D000
                            	  3739: char_y						; Y
00:0000D854 F002            	  3740: 	dc.w	$F002,$FA70,$F276,$F802
00:0000D856 FA70
00:0000D858 F276
00:0000D85A F802
00:0000D85C F676            	  3741: 	dc.w	$F676,$FE02,RTSL
00:0000D85E FE02
00:0000D860 D000
                            	  3742: char_z						; Z
00:0000D862 FB00            	  3743: 	dc.w	$FB00,$F872,$FF76,$F872
00:0000D864 F872
00:0000D866 FF76
00:0000D868 F872
00:0000D86A F002            	  3744: 	dc.w	$F002,RTSL
00:0000D86C D000
                            	  3745: char_spc						; [SPACE]
00:0000D86E F803            	  3746: 	dc.w	$F803,RTSL
00:0000D870 D000
                            	  3747: char_1						; 1
00:0000D872 F002            	  3748: 	dc.w	$F002,$FB70,$FF02,RTSL
00:0000D874 FB70
00:0000D876 FF02
00:0000D878 D000
                            	  3749: char_2						; 2
00:0000D87A FB00            	  3750: 	dc.w	$FB00,$F872,$F770,$F876
00:0000D87C F872
00:0000D87E F770
00:0000D880 F876
00:0000D882 F770            	  3751: 	dc.w	$F770,$F872,$F002,RTSL
00:0000D884 F872
00:0000D886 F002
00:0000D888 D000
                            	  3752: char_3						; 3
00:0000D88A F872            	  3753: 	dc.w	$F872,$FB70,$F876,$F700
00:0000D88C FB70
00:0000D88E F876
00:0000D890 F700
00:0000D892 F872            	  3754: 	dc.w	$F872,$F702,RTSL
00:0000D894 F702
00:0000D896 D000
                            	  3755: char_4						; 4
00:0000D898 FB00            	  3756: 	dc.w	$FB00,$F770,$F872,$F300
00:0000D89A F770
00:0000D89C F872
00:0000D89E F300
00:0000D8A0 FF70            	  3757: 	dc.w	$FF70,$F002,RTSL
00:0000D8A2 F002
00:0000D8A4 D000
                            	  3758: char_5						; 6
00:0000D8A6 F872            	  3759: 	dc.w	$F872,$F370,$F876,$F370
00:0000D8A8 F370
00:0000D8AA F876
00:0000D8AC F370
00:0000D8AE F872            	  3760: 	dc.w	$F872,$FF01,RTSL
00:0000D8B0 FF01
00:0000D8B2 D000
                            	  3761: char_6						; 6
00:0000D8B4 F300            	  3762: 	dc.w	$F300,$F872,$F770,$F876
00:0000D8B6 F872
00:0000D8B8 F770
00:0000D8BA F876
00:0000D8BC FB70            	  3763: 	dc.w	$FB70,$FF03,RTSL
00:0000D8BE FF03
00:0000D8C0 D000
                            	  3764: char_7						; 7
00:0000D8C2 FB00            	  3765: 	dc.w	$FB00,$F872,$FF70,$F002,RTSL
00:0000D8C4 F872
00:0000D8C6 FF70
00:0000D8C8 F002
00:0000D8CA D000
                            	  3766: char_8						; 8
00:0000D8CC F872            	  3767: 	dc.w	$F872,$FB70,$F876,$FF70
00:0000D8CE FB70
00:0000D8D0 F876
00:0000D8D2 FF70
00:0000D8D4 F300            	  3768: 	dc.w	$F300,$F872,$F702,RTSL
00:0000D8D6 F872
00:0000D8D8 F702
00:0000D8DA D000
                            	  3769: char_9						; 9
00:0000D8DC F802            	  3770: 	dc.w	$F802,$FB70,$F876,$F770
00:0000D8DE FB70
00:0000D8E0 F876
00:0000D8E2 F770
00:0000D8E4 F872            	  3771: 	dc.w	$F872,$F702,RTSL
00:0000D8E6 F702
00:0000D8E8 D000
                            	  3772: 
                            	  3773: ; indirect table for character set
                            	  3774: 
                            	  3775: char_set
00:0000D8EA CAD0            	  3776: 	dc.w	JSRL+(char_spc-vector)>>1	; [SPACE]
00:0000D8EC CA81            	  3777: 	dc.w	JSRL+(char_o0-vector)>>1	; 0 also O
00:0000D8EE CAD2            	  3778: 	dc.w	JSRL+(char_1-vector)>>1		; 1
00:0000D8F0 CAD6            	  3779: 	dc.w	JSRL+(char_2-vector)>>1		; 2
00:0000D8F2 CADE            	  3780: 	dc.w	JSRL+(char_3-vector)>>1		; 3
00:0000D8F4 CAE5            	  3781: 	dc.w	JSRL+(char_4-vector)>>1		; 4
00:0000D8F6 CAEC            	  3782: 	dc.w	JSRL+(char_5-vector)>>1		; 5
00:0000D8F8 CAF3            	  3783: 	dc.w	JSRL+(char_6-vector)>>1		; 6
00:0000D8FA CAFA            	  3784: 	dc.w	JSRL+(char_7-vector)>>1		; 7
00:0000D8FC CAFF            	  3785: 	dc.w	JSRL+(char_8-vector)>>1		; 8
00:0000D8FE CB07            	  3786: 	dc.w	JSRL+(char_9-vector)>>1		; 9
00:0000D900 CA1C            	  3787: 	dc.w	JSRL+(char_a-vector)>>1		; A
00:0000D902 CA24            	  3788: 	dc.w	JSRL+(char_b-vector)>>1		; B
00:0000D904 CA31            	  3789: 	dc.w	JSRL+(char_c-vector)>>1		; C
00:0000D906 CA37            	  3790: 	dc.w	JSRL+(char_d-vector)>>1		; D
00:0000D908 CA3F            	  3791: 	dc.w	JSRL+(char_e-vector)>>1		; E
00:0000D90A CA47            	  3792: 	dc.w	JSRL+(char_f-vector)>>1		; F
00:0000D90C CA4E            	  3793: 	dc.w	JSRL+(char_g-vector)>>1		; G
00:0000D90E CA57            	  3794: 	dc.w	JSRL+(char_h-vector)>>1		; H
00:0000D910 CA5E            	  3795: 	dc.w	JSRL+(char_i-vector)>>1		; I
00:0000D912 CA65            	  3796: 	dc.w	JSRL+(char_j-vector)>>1		; J
00:0000D914 CA6B            	  3797: 	dc.w	JSRL+(char_k-vector)>>1		; K
00:0000D916 CA71            	  3798: 	dc.w	JSRL+(char_l-vector)>>1		; L
00:0000D918 CA76            	  3799: 	dc.w	JSRL+(char_m-vector)>>1		; M
00:0000D91A CA7C            	  3800: 	dc.w	JSRL+(char_n-vector)>>1		; N
00:0000D91C CA81            	  3801: 	dc.w	JSRL+(char_o0-vector)>>1	; O also 0
00:0000D91E CA87            	  3802: 	dc.w	JSRL+(char_p-vector)>>1		; P
00:0000D920 CA8E            	  3803: 	dc.w	JSRL+(char_q-vector)>>1		; Q
00:0000D922 CA97            	  3804: 	dc.w	JSRL+(char_r-vector)>>1		; R
00:0000D924 CA9F            	  3805: 	dc.w	JSRL+(char_s-vector)>>1		; S
00:0000D926 CAA6            	  3806: 	dc.w	JSRL+(char_t-vector)>>1		; T
00:0000D928 CAAC            	  3807: 	dc.w	JSRL+(char_u-vector)>>1		; U
00:0000D92A CAB2            	  3808: 	dc.w	JSRL+(char_v-vector)>>1		; V
00:0000D92C CAB7            	  3809: 	dc.w	JSRL+(char_w-vector)>>1		; W
00:0000D92E CABE            	  3810: 	dc.w	JSRL+(char_x-vector)>>1		; X
00:0000D930 CAC3            	  3811: 	dc.w	JSRL+(char_y-vector)>>1		; Y
00:0000D932 CACA            	  3812: 	dc.w	JSRL+(char_z-vector)>>1		; Z
                            	  3813: 
                            	  3814: ; indirect shot table
                            	  3815: 
                            	  3816: shot_jsr
00:0000D934 CB34            	  3817: 	dc.w	JSRL+(shot_vec-vector)>>1	; shot
                            	  3818: 
                            	  3819: ; shot vector object, a small cross of intensity $F
                            	  3820: 
                            	  3821: shot_vec
00:0000D936 7420            	  3822: 	dc.w	$7420,$0000
00:0000D938 0000
00:0000D93A 7040            	  3823: 	dc.w	$7040,$F000
00:0000D93C F000
00:0000D93E 7420            	  3824: 	dc.w	$7420,$0420
00:0000D940 0420
00:0000D942 7000            	  3825: 	dc.w	$7000,$F040
00:0000D944 F040
00:0000D946 D000            	  3826: 	dc.w	RTSL
                            	  3827: 
                            	  3828: 
                            	  3829: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3830: ;
                            	  3831: ; canned messages
                            	  3832: 
                            	  3833: ; x,y co-ordinates for the message origins
                            	  3834: 
                            	  3835: mess_origin
00:0000D948 0064            	  3836: 	dc.w	$0064,$00B6				; message 0 x,y
00:0000D94A 00B6
00:0000D94C 0064            	  3837: 	dc.w	$0064,$00B6				; message 1 x,y
00:0000D94E 00B6
00:0000D950 000C            	  3838: 	dc.w	$000C,$00AA				; message 2 x,y
00:0000D952 00AA
00:0000D954 000C            	  3839: 	dc.w	$000C,$00A2				; message 3 x,y
00:0000D956 00A2
00:0000D958 000C            	  3840: 	dc.w	$000C,$009A				; message 4 x,y
00:0000D95A 009A
00:0000D95C 000C            	  3841: 	dc.w	$000C,$0092				; message 5 x,y
00:0000D95E 0092
00:0000D960 0064            	  3842: 	dc.w	$0064,$00C6				; message 6 x,y
00:0000D962 00C6
00:0000D964 0064            	  3843: 	dc.w	$0064,$009D				; message 7 x,y
00:0000D966 009D
                            	  3844: 
                            	  3845: ; message tables
                            	  3846: 
                            	  3847: mess_table
00:0000D968 0008            	  3848: 	dc.w	e_messages-mess_table		; english
00:0000D96A 00C2            	  3849: 	dc.w	d_messages-mess_table		; german
00:0000D96C 019E            	  3850: 	dc.w	f_messages-mess_table		; french
00:0000D96E 026C            	  3851: 	dc.w	s_messages-mess_table		; spanish
                            	  3852: 
                            	  3853: ; message offset table
                            	  3854: 
                            	  3855: e_messages
00:0000D970 0010            	  3856: 	dc.w	e_mess_0-e_messages		; message 0
00:0000D972 001C            	  3857: 	dc.w	e_mess_1-e_messages		; message 1
00:0000D974 0024            	  3858: 	dc.w	e_mess_2-e_messages		; message 2
00:0000D976 0046            	  3859: 	dc.w	e_mess_3-e_messages		; message 3
00:0000D978 0061            	  3860: 	dc.w	e_mess_4-e_messages		; message 4
00:0000D97A 007E            	  3861: 	dc.w	e_mess_5-e_messages		; message 5
00:0000D97C 00A5            	  3862: 	dc.w	e_mess_6-e_messages		; message 6
00:0000D97E 00B0            	  3863: 	dc.w	e_mess_7-e_messages		; message 7
                            	  3864: 
                            	  3865: e_mess_0
00:0000D980 484947482053434F	  3866: 	dc.b	'HIGH SCORES',$00
00:0000D988 524553
00:0000D98B 00
                            	  3867: e_mess_1
00:0000D98C 504C4159455220  	  3868: 	dc.b	'PLAYER ',$00
00:0000D993 00
                            	  3869: e_mess_2
00:0000D994 594F55522053434F	  3870: 	dc.b	'YOUR SCORE IS ONE OF THE TEN BEST',$00
00:0000D99C 5245204953204F4E
00:0000D9A4 45204F4620544845
00:0000D9AC 2054454E20424553
00:0000D9B4 54
00:0000D9B5 00
                            	  3871: e_mess_3
00:0000D9B6 504C454153452045	  3872: 	dc.b	'PLEASE ENTER YOUR INITIALS',$00
00:0000D9BE 4E54455220594F55
00:0000D9C6 5220494E49544941
00:0000D9CE 4C53
00:0000D9D0 00
                            	  3873: e_mess_4
00:0000D9D1 5055534820524F54	  3874: 	dc.b	'PUSH ROTATE TO SELECT LETTER',$00
00:0000D9D9 41544520544F2053
00:0000D9E1 454C454354204C45
00:0000D9E9 54544552
00:0000D9ED 00
                            	  3875: e_mess_5
00:0000D9EE 5055534820485950	  3876: 	dc.b	'PUSH HYPERSPACE WHEN LETTER IS CORRECT',$00
00:0000D9F6 4552535041434520
00:0000D9FE 5748454E204C4554
00:0000DA06 5445522049532043
00:0000DA0E 4F5252454354
00:0000DA14 00
                            	  3877: e_mess_6
00:0000DA15 5055534820535441	  3878: 	dc.b	'PUSH START',$00
00:0000DA1D 5254
00:0000DA1F 00
                            	  3879: e_mess_7
00:0000DA20 47414D45204F5645	  3880: 	dc.b	'GAME OVER',$00
00:0000DA28 52
00:0000DA29 00
                            	  3881: 
                            	  3882: 	ds.w	0					; ensure even
                            	  3883: 
                            	  3884: ; german message offset table
                            	  3885: 
                            	  3886: d_messages
00:0000DA2A 0010            	  3887: 	dc.w	d_mess_0-d_messages		; message 0
00:0000DA2C 0020            	  3888: 	dc.w	d_mess_1-d_messages		; message 1
00:0000DA2E 0029            	  3889: 	dc.w	d_mess_2-d_messages		; message 2
00:0000DA30 0050            	  3890: 	dc.w	d_mess_3-d_messages		; message 3
00:0000DA32 0073            	  3891: 	dc.w	d_mess_4-d_messages		; message 4
00:0000DA34 0096            	  3892: 	dc.w	d_mess_5-d_messages		; message 5
00:0000DA36 00BC            	  3893: 	dc.w	d_mess_6-d_messages		; message 6
00:0000DA38 00D2            	  3894: 	dc.w	d_mess_7-d_messages		; message 7
                            	  3895: 
                            	  3896: d_mess_0
00:0000DA3A 484F454348535445	  3897: 	dc.b	'HOECHSTERGEBNIS',$00
00:0000DA42 524745424E4953
00:0000DA49 00
                            	  3898: d_mess_1
00:0000DA4A 535049454C455220	  3899: 	dc.b	'SPIELER ',$00
00:0000DA52 00
                            	  3900: d_mess_2
00:0000DA53 4948522045524745	  3901: 	dc.b	'IHR ERGEBNIS IST EINES DER ZEHN BESTEN',$00
00:0000DA5B 424E495320495354
00:0000DA63 2045494E45532044
00:0000DA6B 4552205A45484E20
00:0000DA73 42455354454E
00:0000DA79 00
                            	  3902: d_mess_3
00:0000DA7A 4249545445204745	  3903: 	dc.b	'BITTE GEBEN SIE IHRE INITIALEN EIN',$00
00:0000DA82 42454E2053494520
00:0000DA8A 4948524520494E49
00:0000DA92 5449414C454E2045
00:0000DA9A 494E
00:0000DA9C 00
                            	  3904: d_mess_4
00:0000DA9D 5A55522042554348	  3905: 	dc.b	'ZUR BUCHSTABENWAHL ROTATE DRUECKEN',$00
00:0000DAA5 53544142454E5741
00:0000DAAD 484C20524F544154
00:0000DAB5 452044525545434B
00:0000DABD 454E
00:0000DABF 00
                            	  3906: d_mess_5
00:0000DAC0 57454E4E20425543	  3907: 	dc.b	'WENN BUCHSTABE OK HYPERSPACE DRUECKEN',$00
00:0000DAC8 485354414245204F
00:0000DAD0 4B20485950455253
00:0000DAD8 5041434520445255
00:0000DAE0 45434B454E
00:0000DAE5 00
                            	  3908: d_mess_6
00:0000DAE6 53544152544B4E4F	  3909: 	dc.b	'STARTKNOEPFE DRUECKEN',$00
00:0000DAEE 4550464520445255
00:0000DAF6 45434B454E
00:0000DAFB 00
                            	  3910: d_mess_7
00:0000DAFC 535049454C454E44	  3911: 	dc.b	'SPIELENDE',$00
00:0000DB04 45
00:0000DB05 00
                            	  3912: 
                            	  3913: 	ds.w	0					; ensure even
                            	  3914: 
                            	  3915: ; french message offset table
                            	  3916: 
                            	  3917: f_messages
00:0000DB06 0010            	  3918: 	dc.w	f_mess_0-f_messages		; message 0
00:0000DB08 001F            	  3919: 	dc.w	f_mess_1-f_messages		; message 1
00:0000DB0A 0026            	  3920: 	dc.w	f_mess_2-f_messages		; message 2
00:0000DB0C 004A            	  3921: 	dc.w	f_mess_3-f_messages		; message 3
00:0000DB0E 0063            	  3922: 	dc.w	f_mess_4-f_messages		; message 4
00:0000DB10 0085            	  3923: 	dc.w	f_mess_5-f_messages		; message 5
00:0000DB12 00AE            	  3924: 	dc.w	f_mess_6-f_messages		; message 6
00:0000DB14 00C0            	  3925: 	dc.w	f_mess_7-f_messages		; message 7
                            	  3926: 
                            	  3927: f_mess_0
00:0000DB16 4D45494C4C455552	  3928: 	dc.b	'MEILLEUR SCORE',$00
00:0000DB1E 2053434F5245
00:0000DB24 00
                            	  3929: f_mess_1
00:0000DB25 4A4F55455220    	  3930: 	dc.b	'JOUER ',$00
00:0000DB2B 00
                            	  3931: f_mess_2
00:0000DB2C 564F545245205343	  3932: 	dc.b	'VOTRE SCORE EST UN DES 10 MEILLEURS',$00
00:0000DB34 4F52452045535420
00:0000DB3C 554E204445532031
00:0000DB44 30204D45494C4C45
00:0000DB4C 555253
00:0000DB4F 00
                            	  3933: f_mess_3
00:0000DB50 53565020454E5452	  3934: 	dc.b	'SVP ENTREZ VOS INITIALES',$00
00:0000DB58 455A20564F532049
00:0000DB60 4E495449414C4553
00:0000DB68 00
                            	  3935: f_mess_4
00:0000DB69 504F555353455A20	  3936: 	dc.b	'POUSSEZ ROTATE POUR VOS INITIALES',$00
00:0000DB71 524F544154452050
00:0000DB79 4F555220564F5320
00:0000DB81 494E495449414C45
00:0000DB89 53
00:0000DB8A 00
                            	  3937: f_mess_5
00:0000DB8B 504F555353455A20	  3938: 	dc.b	'POUSSEZ HYPERSPACE QUAND LETTRE CORRECTE',$00
00:0000DB93 4859504552535041
00:0000DB9B 4345205155414E44
00:0000DBA3 204C455454524520
00:0000DBAB 434F525245435445
00:0000DBB3 00
                            	  3939: f_mess_6
00:0000DBB4 4150505559455220	  3940: 	dc.b	'APPUYER SUR START',$00
00:0000DBBC 5355522053544152
00:0000DBC4 54
00:0000DBC5 00
                            	  3941: f_mess_7
00:0000DBC6 46494E2044452050	  3942: 	dc.b	'FIN DE PARTIE',$00
00:0000DBCE 4152544945
00:0000DBD3 00
                            	  3943: 
                            	  3944: 	ds.w	0					; ensure even
                            	  3945: 
                            	  3946: ; spanish message offset table
                            	  3947: 
                            	  3948: s_messages
00:0000DBD4 0010            	  3949: 	dc.w	s_mess_0-s_messages		; message 0
00:0000DBD6 0018            	  3950: 	dc.w	s_mess_1-s_messages		; message 1
00:0000DBD8 0021            	  3951: 	dc.w	s_mess_2-s_messages		; message 2
00:0000DBDA 0048            	  3952: 	dc.w	s_mess_3-s_messages		; message 3
00:0000DBDC 0066            	  3953: 	dc.w	s_mess_4-s_messages		; message 4
00:0000DBDE 008E            	  3954: 	dc.w	s_mess_5-s_messages		; message 5
00:0000DBE0 00A0            	  3955: 	dc.w	s_mess_6-s_messages		; message 6
00:0000DBE2 00AD            	  3956: 	dc.w	s_mess_7-s_messages		; message 7
                            	  3957: 
                            	  3958: s_mess_0
00:0000DBE4 5245434F524453  	  3959: 	dc.b	'RECORDS',$00
00:0000DBEB 00
                            	  3960: s_mess_1
00:0000DBEC 4A554741444F5220	  3961: 	dc.b	'JUGADOR ',$00
00:0000DBF4 00
                            	  3962: s_mess_2
00:0000DBF5 53552050554E5441	  3963: 	dc.b	'SU PUNTAJE ESTA ENTRE LOS DIEZ MEJORES',$00
00:0000DBFD 4A45204553544120
00:0000DC05 454E545245204C4F
00:0000DC0D 53204449455A204D
00:0000DC15 454A4F524553
00:0000DC1B 00
                            	  3964: s_mess_3
00:0000DC1C 504F52204641564F	  3965: 	dc.b	'POR FAVOR ENTRE SUS INICIALES',$00
00:0000DC24 5220454E54524520
00:0000DC2C 53555320494E4943
00:0000DC34 49414C4553
00:0000DC39 00
                            	  3966: s_mess_4
00:0000DC3A 4F5052494D412052	  3967: 	dc.b	'OPRIMA ROTATE PARA SELECCIONAR LA LETRA',$00
00:0000DC42 4F54415445205041
00:0000DC4A 52412053454C4543
00:0000DC52 43494F4E4152204C
00:0000DC5A 41204C45545241
00:0000DC61 00
                            	  3968: s_mess_5
00:0000DC62 4F5052494D412048	  3969: 	dc.b	'OPRIMA HYPERSPACE',$00
00:0000DC6A 5950455253504143
00:0000DC72 45
00:0000DC73 00
                            	  3970: s_mess_6
00:0000DC74 50554C5341522053	  3971: 	dc.b	'PULSAR START',$00
00:0000DC7C 54415254
00:0000DC80 00
                            	  3972: s_mess_7
00:0000DC81 4A5545474F205445	  3973: 	dc.b	'JUEGO TERMINADO',$00
00:0000DC89 524D494E41444F
00:0000DC90 00
                            	  3974: 
                            	  3975: 	ds.w	0					; ensure even
                            	  3976: 
                            	  3977: 
                            	  3978: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3979: ;
                            	  3980: ; include files
                            	  3981: 
                            	  3982: 	INCLUDE	"games/asteroids/sounds.x68"

Source: "games\asteroids\sounds.x68"
                            	     1: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	     2: ;														;
                            	     3: ;	Sound routines V1.00. This is an include file for asteroids 1_0.x68		;
                            	     4: ;														;
                            	     5: ;	load the sounds, play an indexed sample. Uses the DirextX sound play and	;
                            	     6: ;	requires EASy68K 3.7.10 beta or later.							;
                            	     7: ;														;
                            	     8: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	     9: 
                            	    10: sfire_snd	EQU  0
                            	    11: pfire_snd	EQU  1
                            	    12: thrst_snd	EQU  2
                            	    13: smsau_snd	EQU  3
                            	    14: lgsau_snd	EQU  4
                            	    15: sexpl_snd	EQU  5
                            	    16: mexpl_snd	EQU  sexpl_snd+1
                            	    17: lexpl_snd	EQU  sexpl_snd+2
                            	    18: beat1_snd	EQU  8				; beat_2 must be beat_1 XOR 1
                            	    19: beat2_snd	EQU  9				; see above
                            	    20: extra_snd	EQU 10
                            	    21: 
                            	    22: 
                            	    23: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    24: ;
                            	    25: ; initialise the sounds routine
                            	    26: 
                            	    27: sound_init
00:0000DC92 422B0014        	    28: 	MOVE.b	#0,s_key(a3)		; clear the last [S] key status
00:0000DC96 177C00FF0015    	    29: 	MOVE.b	#-1,play_sound(a3)	; set the sound flag
                            	    30: 
00:0000DC9C 43FA0098        	    31: 	LEA		beat1_sound(pc),a1	; point to the background beat sound file name
00:0000DCA0 7208            	    32: 	MOVEQ		#beat1_snd,d1		; index 10
00:0000DCA2 614E            	    33: 	BSR.s		load_sound			; load the sound into directx memory
                            	    34: 
00:0000DCA4 43FA00A2        	    35: 	LEA		beat2_sound(pc),a1	; point to the background beat sound file name
00:0000DCA8 7209            	    36: 	MOVEQ		#beat2_snd,d1		; index 9
00:0000DCAA 6146            	    37: 	BSR.s		load_sound			; load the sound into directx memory
                            	    38: 
00:0000DCAC 43FA00AC        	    39: 	LEA		lexpl_sound(pc),a1	; point to the large explosion sound file name
00:0000DCB0 7207            	    40: 	MOVEQ		#lexpl_snd,d1		; index 8
00:0000DCB2 613E            	    41: 	BSR.s		load_sound			; load the sound into directx memory
                            	    42: 
00:0000DCB4 43FA00B9        	    43: 	LEA		mexpl_sound(pc),a1	; point to the medium explosion sound file name
00:0000DCB8 7206            	    44: 	MOVEQ		#mexpl_snd,d1		; index 7
00:0000DCBA 6136            	    45: 	BSR.s		load_sound			; load the sound into directx memory
                            	    46: 
00:0000DCBC 43FA00C6        	    47: 	LEA		sexpl_sound(pc),a1	; point to the small explosion sound file name
00:0000DCC0 7205            	    48: 	MOVEQ		#sexpl_snd,d1		; index 6
00:0000DCC2 612E            	    49: 	BSR.s		load_sound			; load the sound into directx memory
                            	    50: 
00:0000DCC4 43FA00D3        	    51: 	LEA		extra_sound(pc),a1	; point to the extra life sound file name
00:0000DCC8 720A            	    52: 	MOVEQ		#extra_snd,d1		; index 5
00:0000DCCA 6126            	    53: 	BSR.s		load_sound			; load the sound into directx memory
                            	    54: 
00:0000DCCC 43FA00E1        	    55: 	LEA		lgsau_sound(pc),a1	; point to the large saucer sound file name
00:0000DCD0 7204            	    56: 	MOVEQ		#lgsau_snd,d1		; index 4
00:0000DCD2 6124            	    57: 	BSR.s		load_old_sound		; load the sound into sound memory
                            	    58: 
00:0000DCD4 43FA00EE        	    59: 	LEA		smsau_sound(pc),a1	; point to the small saucer sound file name
00:0000DCD8 7203            	    60: 	MOVEQ		#smsau_snd,d1		; index 3
00:0000DCDA 611C            	    61: 	BSR.s		load_old_sound		; load the sound into directx memory
                            	    62: 
00:0000DCDC 43FA00FB        	    63: 	LEA		thrst_sound(pc),a1	; point to the ship thrust sound file name
00:0000DCE0 7202            	    64: 	MOVEQ		#thrst_snd,d1		; index 2
00:0000DCE2 610E            	    65: 	BSR.s		load_sound			; load the sound into directx memory
                            	    66: 
00:0000DCE4 43FA0106        	    67: 	LEA		pfire_sound(pc),a1	; point to the player fire sound file name
00:0000DCE8 7201            	    68: 	MOVEQ		#pfire_snd,d1		; index 1
00:0000DCEA 6106            	    69: 	BSR.s		load_sound			; load the sound into directx memory
                            	    70: 
00:0000DCEC 43FA0110        	    71: 	LEA		sfire_sound(pc),a1	; point to the saucer fire sound file name
00:0000DCF0 7200            	    72: 	MOVEQ		#sfire_snd,d1		; index 0
                            	    73: 
                            	    74: 
                            	    75: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    76: ;
                            	    77: ; load the sound into directx memory
                            	    78: 
                            	    79: load_sound
00:0000DCF2 704A            	    80: 	MOVEQ		#74,d0			; load the sound into directx memory
00:0000DCF4 4E4F            	    81: 	TRAP		#15
                            	    82: 
00:0000DCF6 4E75            	    83: 	RTS
                            	    84: 
                            	    85: 
                            	    86: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    87: ;
                            	    88: ; load the sound into sound memory
                            	    89: 
                            	    90: load_old_sound
00:0000DCF8 7047            	    91: 	MOVEQ		#71,d0			; load the sound into sound memory
00:0000DCFA 4E4F            	    92: 	TRAP		#15
                            	    93: 
00:0000DCFC 4E75            	    94: 	RTS
                            	    95: 
                            	    96: 
                            	    97: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    98: ;
                            	    99: ; play a sound sample
                            	   100: 
                            	   101: play_sample
00:0000DCFE 4A2B001A        	   102: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000DD02 6718            	   103: 	BEQ.s		exit_play_sample		; if no players left just exit
                            	   104: 
00:0000DD04 4A2B0015        	   105: 	TST.b		play_sound(a3)		; test the sound flag
00:0000DD08 6712            	   106: 	BEQ.s		exit_play_sample		; if the sound is off just exit
                            	   107: 
00:0000DD0A 7048            	   108: 	MOVEQ		#72,d0			; play a sound from sound memory
00:0000DD0C 0C410003        	   109: 	CMPI.w	#smsau_snd,d1		; is it the small saucer sound
00:0000DD10 6708            	   110: 	BEQ.s		old_sound_play		; if so go play it with the old player
                            	   111: 
00:0000DD12 0C410004        	   112: 	CMPI.w	#lgsau_snd,d1		; is it the large saucer sound
00:0000DD16 6702            	   113: 	BEQ.s		old_sound_play		; if so go play it with the old player
                            	   114: 
00:0000DD18 704B            	   115: 	MOVEQ		#75,d0			; play a sound from directx memory
                            	   116: old_sound_play
00:0000DD1A 4E4F            	   117: 	TRAP		#15
                            	   118: 
                            	   119: exit_play_sample
00:0000DD1C 4E75            	   120: 	RTS
                            	   121: 
                            	   122: 
                            	   123: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   124: ;
                            	   125: ; test the sound key
                            	   126: 
                            	   127: sound_key
00:0000DD1E 7253            	   128: 	MOVEQ		#$53,d1			; [][][][S] key
00:0000DD20 7013            	   129: 	MOVEQ		#19,d0			; check for keypress
00:0000DD22 4E4F            	   130: 	TRAP		#15
                            	   131: 
00:0000DD24 102B0014        	   132: 	MOVE.b	s_key(a3),d0		; get the last key(s) state
00:0000DD28 B300            	   133: 	EOR.b		d1,d0				; compare the result with the last key(s) state,
                            	   134: 							; each byte is now $FF if a key has changed or
                            	   135: 							; $00 if a key has not changed
00:0000DD2A C001            	   136: 	AND.b		d1,d0				; make each byte $FF if key just pressed or
                            	   137: 							; $00 if key not just pressed
00:0000DD2C B12B0015        	   138: 	EOR.b		d0,play_sound(a3)		; if key just pressed toggle the sound flag
00:0000DD30 17410014        	   139: 	MOVE.b	d1,s_key(a3)		; save the last [S] key status
00:0000DD34 4E75            	   140: 	RTS
                            	   141: 
                            	   142: 
                            	   143: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   144: ;
                            	   145: ; sound file names
                            	   146: 
                            	   147: beat1_sound
00:0000DD36 73616D706C65735C	   148: 	dc.b	'samples\beat1.wav',$00		; background beat sound
00:0000DD3E 62656174312E7761
00:0000DD46 76
00:0000DD47 00
                            	   149: 
                            	   150: beat2_sound
00:0000DD48 73616D706C65735C	   151: 	dc.b	'samples\beat2.wav',$00		; background beat sound
00:0000DD50 62656174322E7761
00:0000DD58 76
00:0000DD59 00
                            	   152: 
                            	   153: lexpl_sound
00:0000DD5A 73616D706C65735C	   154: 	dc.b	'samples\lexplode.wav',$00	; large explosion sound
00:0000DD62 6C6578706C6F6465
00:0000DD6A 2E776176
00:0000DD6E 00
                            	   155: 
                            	   156: mexpl_sound
00:0000DD6F 73616D706C65735C	   157: 	dc.b	'samples\mexplode.wav',$00	; medium explosion sound
00:0000DD77 6D6578706C6F6465
00:0000DD7F 2E776176
00:0000DD83 00
                            	   158: 
                            	   159: sexpl_sound
00:0000DD84 73616D706C65735C	   160: 	dc.b	'samples\sexplode.wav',$00	; small explosion sound
00:0000DD8C 736578706C6F6465
00:0000DD94 2E776176
00:0000DD98 00
                            	   161: 
                            	   162: extra_sound
00:0000DD99 73616D706C65735C	   163: 	dc.b	'samples\extraship.wav',$00	; extra life sound
00:0000DDA1 6578747261736869
00:0000DDA9 702E776176
00:0000DDAE 00
                            	   164: 
                            	   165: lgsau_sound
00:0000DDAF 73616D706C65735C	   166: 	dc.b	'samples\lgsaucer.wav',$00	; large saucer sound
00:0000DDB7 6C67736175636572
00:0000DDBF 2E776176
00:0000DDC3 00
                            	   167: 
                            	   168: smsau_sound
00:0000DDC4 73616D706C65735C	   169: 	dc.b	'samples\smsaucer.wav',$00	; small saucer sound
00:0000DDCC 736D736175636572
00:0000DDD4 2E776176
00:0000DDD8 00
                            	   170: 
                            	   171: thrst_sound
00:0000DDD9 73616D706C65735C	   172: 	dc.b	'samples\thrust.wav',$00	; ship thrust sound
00:0000DDE1 7468727573742E77
00:0000DDE9 6176
00:0000DDEB 00
                            	   173: 
                            	   174: pfire_sound
00:0000DDEC 73616D706C65735C	   175: 	dc.b	'samples\pfire.wav',$00		; player fire sound
00:0000DDF4 70666972652E7761
00:0000DDFC 76
00:0000DDFD 00
                            	   176: 
                            	   177: sfire_sound
00:0000DDFE 73616D706C65735C	   178: 	dc.b	'samples\sfire.wav',$00		; saucer fire sound
00:0000DE06 73666972652E7761
00:0000DE0E 76
00:0000DE0F 00
                            	   179: 
                            	   180: 	ds.w	0					; ensure even
                            	   181: 
                            	   182: 
                            	   183: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   184: 
                            	   185: 

Source: "games\asteroids\asteroids 1_0.x68"
                            	  3983: 							; sound routines
                            	  3984: 
                            	  3985: 
                            	  3986: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3987: ;
                            	  3988: ; high score table filename
                            	  3989: 
                            	  3990: filename
00:0000DE10 61737465726F6964	  3991: 	dc.b		'asteroids.hi',0		; highscore filename
00:0000DE18 732E6869
00:0000DE1C 00
                            	  3992: 	ds.w		0				; ensure even
                            	  3993: 
                            	  3994: 
                            	  3995: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3996: ;
                            	  3997: ; variables
                            	  3998: 
                            	  3999: variables
                            	  4000: 
                            	  4001: 	OFFSET	0				; going to use relative addressing
                            	  4002: 
                            	  4003: vector_s
                            	  4004: ;##	ds.w	1				; vector scale
02:00000000 0000            	  4005: glob_scale	ds.w	1				; global scale
                            	  4006: 
                            	  4007: 
02:00000002 0000            	  4008: local_x	ds.w	1				; local screen x co-ordinate offset
02:00000004 0000            	  4009: local_y	ds.w	1				; local screen y co-ordinate offset
                            	  4010: 
02:00000006 0000            	  4011: scr_x		ds.w	1				; screen x size
02:00000008 0000            	  4012: scr_y		ds.w	1				; screen y size
                            	  4013: 
02:0000000A 00000000        	  4014: PRNlword	ds.l	1				; PRNG seed long word
                            	  4015: 
02:0000000E 00000000        	  4016: switch_addr	ds.l	1				; hardware switch address
                            	  4017: 
02:00000012 0000            	  4018: hiscore_y	ds.w	1				; high score y co-ordinate
                            	  4019: 
                            	  4020: 
02:00000014 00              	  4021: s_key		ds.b	1				; last [s] key status
02:00000015 00              	  4022: play_sound	ds.b	1				; sound flag
                            	  4023: 
02:00000016 00              	  4024: suppress_0	ds.b	1				; leading zero suppress flag
                            	  4025: 							; 0 = don't suppress
                            	  4026: 
02:00000017 00              	  4027: high_idx	ds.b	1				; high score index, single byte, 1 to 10 in BCD
                            	  4028: 
02:00000018 00              	  4029: player_idx	ds.b	1				; player index
                            	  4030: 							; 0 = player 1
                            	  4031: 							; 1 = player 2
                            	  4032: 
02:00000019 00              	  4033: past_play	ds.b	1				; number of players that were in the game
                            	  4034: 
02:0000001A 00              	  4035: num_players	ds.b	1				; number of players in the game
                            	  4036: 							; $00 - game over
                            	  4037: 							; $01 - 1 player game
                            	  4038: 							; $02 - 2 player game
                            	  4039: 							; $FF - game over, high score not checked
                            	  4040: 
02:0000001B 00              	  4041: ss_count	ds.b	1				; starting ship count
                            	  4042: 
02:0000001C 00              	  4043: px_time	ds.b	1				; "PLAYER x" timer. while this is non zero
                            	  4044: 							; "PLAYER x" will be displayed. this is used at
                            	  4045: 							; the beginning of any game and at the beginning
                            	  4046: 							; of each turn in a two player game
                            	  4047: 
02:0000001D 00              	  4048: sixteen_ms	ds.b	1				; 16ms counter, incremented every 16ms by the
                            	  4049: 							; timer interrupt and cleared by the main
                            	  4050: 							; program loop
                            	  4051: 
02:0000001E 00              	  4052: p_orient	ds.b	1				; player orientation, this is shared by both
                            	  4053: 							; players as it is in the arcade machine
                            	  4054: 							;
                            	  4055: 							; $00 = right
                            	  4056: 							; $40 = up
                            	  4057: 							; $80 = left
                            	  4058: 							; $C0 = down
                            	  4059: 							;
                            	  4060: 							; this is $00 = right then anticlockwise each
                            	  4061: 							; positive step being 1.40625 degrees so that
                            	  4062: 							; by the time you get back to $00 one full
                            	  4063: 							; rotation has been done
                            	  4064: 
02:0000001F 00              	  4065: s_orient	ds.b	1				; shot direction, see above
                            	  4066: 
02:00000020 00              	  4067: hi_char	ds.b	1				; high score input character index
                            	  4068: 
02:00000021 00              	  4069: last_fire	ds.b	1				; fire key last state register
02:00000022 00              	  4070: last_hype	ds.b	1				; hyperspace key last state register
                            	  4071: 
02:00000023 00              	  4072: thump_snd	ds.b	1				; thump sound value
02:00000024 00              	  4073: thump_time	ds.b	1				; thump sound change timer
02:00000025 00              	  4074: time_count	ds.b	1				; game counter byte
                            	  4075: 
02:00000026 00              	  4076: hyper		ds.b	1				; hyperspace flag
                            	  4077: 							; $00 = no jump
                            	  4078: 							; $01 = jump successful
                            	  4079: 							; $80 = jump unsuccessful
                            	  4080: 							; $xx = 
                            	  4081: 
                            	  4082: 		ds.w	0
                            	  4083: 
02:00000027 0000            	  4084: hiscores	ds.w	10				; high score table, each score is a BCD word
02:00000029 *
02:0000003B 00              	  4085: hinames	ds.b	3*10				; high score initials table
02:0000003C *
                            	  4086: 
02:00000059 0000            	  4087: game_count	ds.w	1				; game counter word
                            	  4088: 
02:0000005B 0000            	  4089: expl_x_pos	ds.w	6				; player ship explosion pieces x positions
02:0000005D *
                            	  4090: 
02:00000067 0000            	  4091: expl_y_pos	ds.w	6				; player ship explosion pieces y positions
02:00000069 *
                            	  4092: 
                            	  4093: 
                            	  4094: ; player 1 variables
                            	  4095: 
                            	  4096: player_1	EQU	*+$80				; player one variables base
                            	  4097: 
                            	  4098: x_pos_off	EQU	*-player_1			; offset to the x position base
02:00000073 0000            	  4099: 		ds.w	$1B				; item x position base address
02:00000075 *
                            	  4100: 
                            	  4101: p_xpos_off	EQU	*-player_1			; offset to the player x position
02:000000A9 0000            	  4102: 		ds.w	1				; player x position
                            	  4103: 
                            	  4104: s_xpos_off	EQU	*-player_1			; offset to the saucer x position
02:000000AB 0000            	  4105: 		ds.w	1				; saucer x position
                            	  4106: 
                            	  4107: f_xpos_off	EQU	*-player_1			; offset to the player x position
02:000000AD 0000            	  4108: 		ds.w	6				; fire objects x position
02:000000AF *
                            	  4109: x_pos_end	EQU	*-player_1			; offset to the flags end
                            	  4110: 
                            	  4111: y_pos_off	EQU	*-player_1			; offset to the y position base
02:000000B9 0000            	  4112: 		ds.w	$1B				; item y position base address
02:000000BB *
                            	  4113: 
                            	  4114: p_ypos_off	EQU	*-player_1			; offset to the player y position
02:000000EF 0000            	  4115: 		ds.w	1				; player y position
                            	  4116: s_ypos_off	EQU	*-player_1			; offset to the saucer y position
02:000000F1 0000            	  4117: 		ds.w	1				; saucer y position
                            	  4118: 
                            	  4119: f_ypos_off	EQU	*-player_1			; offset to the player y position
02:000000F3 0000            	  4120: 		ds.w	6				; fire objects y position
02:000000F5 *
                            	  4121: 
                            	  4122: 							; items $xx00 to $xx1A are rocks
                            	  4123: 							; $00 = no item
                            	  4124: 							; $0x = item exists
                            	  4125: 							; $Ax = item exploding
                            	  4126: 
                            	  4127: flags_off	EQU	*-player_1			; offset to the flags base
02:000000FF 00              	  4128: 		ds.b	$1B				; space for the rock flags
02:00000100 *
                            	  4129: 
                            	  4130: p_flag_off	EQU	*-player_1			; offset to the player flag
02:0000011A 00              	  4131: 		ds.b	1				; player flag
                            	  4132: 
                            	  4133: s_flag_off	EQU	*-player_1			; offset to the saucer flag
02:0000011B 00              	  4134: 		ds.b	1				; saucer flag
                            	  4135: 							; $00 = no saucer
                            	  4136: 							; $01 = small saucer
                            	  4137: 							; $02 = large saucer
                            	  4138: 							; $8x = saucer exploding
                            	  4139: 
                            	  4140: s_fire_off	EQU	*-player_1			; offset to the saucer fire flags
02:0000011C 00              	  4141: 		ds.b	2				; saucer fire objects
02:0000011D *
                            	  4142: 
                            	  4143: p_fire_off	EQU	*-player_1			; offset to the player fire flags
02:0000011E 00              	  4144: 		ds.b	4				; player fire objects
02:0000011F *
                            	  4145: flag_end	EQU	*-player_1			; offset to the flags end
                            	  4146: 
                            	  4147: x_vel_off	EQU	*-player_1			; offset to the x velocity base
02:00000122 00              	  4148: 		ds.b	$1B				; item x velocity base address
02:00000123 *
                            	  4149: 
                            	  4150: p_xvel_off	EQU	*-player_1			; offset to the player x velocity
02:0000013D 00              	  4151: 		ds.b	1				; player x velocity
                            	  4152: 
                            	  4153: s_xvel_off	EQU	*-player_1			; offset to the saucer x velocity
02:0000013E 00              	  4154: 		ds.b	1				; saucer x velocity
                            	  4155: 
                            	  4156: f_xvel_off	EQU	*-player_1			; offset to the fire objects x velocity
02:0000013F 00              	  4157: 		ds.b	6				; fire objects x velocity
02:00000140 *
                            	  4158: 
                            	  4159: y_vel_off	EQU	*-player_1			; offset to the x velocity base
02:00000145 00              	  4160: 		ds.b	$1B				; item y velocity base address
02:00000146 *
                            	  4161: 
                            	  4162: p_yvel_off	EQU	*-player_1			; offset to the player y velocity
02:00000160 00              	  4163: 		ds.b	1				; player y velocity
                            	  4164: 
                            	  4165: s_yvel_off	EQU	*-player_1			; offset to the saucer y velocity
02:00000161 00              	  4166: 		ds.b	1				; saucer y velocity
                            	  4167: 
                            	  4168: f_yvel_off	EQU	*-player_1			; offset to the fire objects y velocity
02:00000162 00              	  4169: 		ds.b	6				; fire objects y velocity
02:00000163 *
                            	  4170: 
                            	  4171: 
                            	  4172: i_rk_count	EQU	*-player_1			; offset to the initial rock count
02:00000168 00              	  4173: 		ds.b	1				; initial rock count
                            	  4174: rock_count	EQU	*-player_1			; offset to the rock count
02:00000169 00              	  4175: 		ds.b	1				; rock count
                            	  4176: 
                            	  4177: sauc_cntdn	EQU	*-player_1			; offset to the saucer countdown timer
02:0000016A 00              	  4178: 		ds.b	1				; saucer countdown timer
                            	  4179: 
                            	  4180: i_sauc_tim	EQU	*-player_1			; offset to the initial saucer timer
02:0000016B 00              	  4181: 		ds.b	1				; small saucer boundary/initial saucer timer
                            	  4182: 
                            	  4183: r_hit_tim	EQU	*-player_1			; offset to the rock hit timer
02:0000016C 00              	  4184: 		ds.b	1				; rock hit timer. if this times out because the
                            	  4185: 							; player hasn't shot a rock for a while then
                            	  4186: 							; the saucer timer initial value is decremented
                            	  4187: 							; so that the saucers come faster if the player
                            	  4188: 							; is just ignoring the last rock
                            	  4189: 
                            	  4190: hide_p_cnt	EQU	*-player_1			; offset to the hide the player count
02:0000016D 00              	  4191: 		ds.b	1				; hide the player count. when this count is non
                            	  4192: 							; zero the player is not displayed and the
                            	  4193: 							; thump sound does not sound. this count is set
                            	  4194: 							; to various lengths after certain events have
                            	  4195: 							; occured
                            	  4196: 							;
                            	  4197: 							; $0x player hidden, will appear
                            	  4198: 							; $8x player hidden, gonna die
                            	  4199: 
                            	  4200: new_rocks	EQU	*-player_1			; offset to the new rocks flag
02:0000016E 00              	  4201: 		ds.b	1				; generate new rocks flag
                            	  4202: 							; 0 = generate new rocks
                            	  4203: thmp_sndi	EQU	*-player_1			; offset to the thump sound change initial value
02:0000016F 00              	  4204: 		ds.b	1				; thump sound change timer initial value
                            	  4205: 
                            	  4206: min_rocks	EQU	*-player_1			; offset to the minimum rock count
02:00000170 00              	  4207: 		ds.b	1				; minimum rock count before the saucer initial
                            	  4208: 							; timer starts to decrement
                            	  4209: 
                            	  4210: p_xvlo_off	EQU	*-player_1			; offset to the player y velocity low byte
02:00000171 00              	  4211: 		ds.b	1				; player x velocity low byte
                            	  4212: p_yvlo_off	EQU	*-player_1			; offset to the player y velocity low byte
02:00000172 00              	  4213: 		ds.b	1				; player y velocity low byte
                            	  4214: 
                            	  4215: 		ds.w	0				; ensure even
                            	  4216: 
                            	  4217: score_off	EQU	*-player_1			; offset to the score word
02:00000173 0000            	  4218: p1_score	ds.w	1				; player score
                            	  4219: 
                            	  4220: ships_off	EQU	*-player_1			; offset to the ship count
02:00000175 00              	  4221: p1_ships	ds.b	1				; player 1 ship count
                            	  4222: 
                            	  4223: high_off	EQU	*-player_1			; offset to the player entering hiscore flag
02:00000176 00              	  4224: p1_high	ds.b	1				; player 1 highscore flag
                            	  4225: 							; $0x - entering high score, also index
                            	  4226: 							; $8x - done
                            	  4227: 
                            	  4228: 
                            	  4229: 		ds.w	0				; ensure even
                            	  4230: 
                            	  4231: ; player 2 variables
                            	  4232: 
                            	  4233: 
                            	  4234: player_2	EQU	*+$80				; player two variables base
02:00000177 00              	  4235: 		ds.b	score_off+$80		; space for the player two variables
02:00000178 *
                            	  4236: 
02:00000277 0000            	  4237: p2_score	ds.w	1				; player 2 score
                            	  4238: 
02:00000279 00              	  4239: p2_ships	ds.b	1				; player 2 ship count
                            	  4240: 
02:0000027A 00              	  4241: p2_high	ds.b	1				; player 2 highscore flag
                            	  4242: 							; $0x - entering high score, also index
                            	  4243: 							; $8x - done
                            	  4244: 
                            	  4245: 		ds.w	0				; ensure even
                            	  4246: 
                            	  4247: p_2_end
                            	  4248: 
                            	  4249: 
                            	  4250: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  4251: 
                            	  4252: 
                            	  4253: ;	END	asteroids_start
                            	  4254: 
                            	  4255: 
                            	  4256: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  4257: 

Source: "boot.x68"
                            	  4637: 	include "games/plants/plants.x68"

Source: "games\plants\plants.x68"
                            	     1: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	     2: ;														;
                            	     3: ;	Plants and animals demo EASy68K V1.20			2011/05/30			;
                            	     4: ;														;
                            	     5: ;	This world is inhabited by two types of life. Plants, which are photosyn-	;
                            	     6: ;	thetic and will grow until they fill all space, and animals which eat the	;
                            	     7: ;	foliage of the plants and will multiply while food is available.			;
                            	     8: ;														;
                            	     9: ;	The growing tip of the plant is a redish bud, this tip not only grows but	;
                            	    10: ;	sprouts new buds as it goes up to a preset maximum number of buds. As a		;
                            	    11: ;	bud grows and moves on it leaves behind green foliage. If a bud has no		;
                            	    12: ;	space to grow into that bud stops growing and another bud can be spawned	;
                            	    13: ;	elsewhere on the plant.										;
                            	    14: ;														;
                            	    15: ;	The animals eat the plant's green foliage and once they have eaten enough	;
                            	    16: ;	they will spawn a new animal which will go its own way eating another share	;
                            	    17: ;	of green foliage. If there is no green foliage to eat an animal will starve.	;
                            	    18: ;														;
                            	    19: ;	Also a bud trying to grow into the space where there is an animal will get	;
                            	    20: ;	stepped on and die, and animal trying to eat the bud of a plant will get	;
                            	    21: ;	sick and die. Watching over all this is a benevolent deity who, on seeing	;
                            	    22: ;	the extinction of growing plants or eating animals will spawn a new proge-	;
                            	    23: ;	nitor for the extinct species.								;
                            	    24: ;														;
                            	    25: ;														;
                            	    26: ;	The main loop time is throttled by measuring the time the loop took and		;
                            	    27: ;	then waiting the remains of the required time using task #23, delay. This,	;
                            	    28: ;	on my laptop, reduces the CPU loading from 100% to 65%.				;
                            	    29: ;														;
                            	    30: ;	Changes to the way new plants and animals are spawned, the plant or animal	;
                            	    31: ;	array is not searched if it is already full, has further reduced the CPU	;
                            	    32: ;	loading to 50% on my laptop.									;
                            	    33: ;														;
                            	    34: ;														;
                            	    35: ;	The [F2], [F3] and [F4]	keys can be used to select a screen size of 640 x	;
                            	    36: ;	480, 800 x 600 and 1024 x 768 respectively.						;
                            	    37: ;														;
                            	    38: ;	[ESC] can be used to quit the program.							;
                            	    39: ;														;
                            	    40: ;	More 68000 and other projects can be found on my website at ..			;
                            	    41: ;														;
                            	    42: ;	 http://mycorner.no-ip.org/index.html							;
                            	    43: ;														;
                            	    44: ;	mail : leeedavison@googlemail.com								;
                            	    45: ;														;
                            	    46: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    47: ;
                            	    48: ; some equates
                            	    49: 
                            	    50: ESC		EQU	$1B				; [ESC] character
                            	    51: ;CR		EQU	$0D				; [CR] character
                            	    52: ;LF		EQU	$0A				; [LF] character
                            	    53: 
                            	    54: def_back	EQU	$000000			; the default background colour
                            	    55: def_animal	EQU	$FFFFFF		; the default animal colour
                            	    56: def_plant	EQU	$8080FF			; the default plant colour
                            	    57: def_leaf	EQU	$008000			; the default leaf colour
                            	    58: 
                            	    59: def_plants	EQU	50				; the default plant count
                            	    60: def_p_spawn	EQU	1				; the default plant spawn level
                            	    61: def_animals	EQU	50				; the default animal count
                            	    62: def_a_spawn	EQU	5				; the default animal spawn level
                            	    63: 
                            	    64: 
                            	    65: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    66: ;
                            	    67: 
                            	    68: ;	ORG		$20000
                            	    69: 
                            	    70: start_plants:
02:0000027C 13FC000EFDFFC000	    71: 	move.b #14,leds
02:00000284 61000362        	    72: 	bsr InitialisePlants	; go setup everything but the world
                            	    73: restart
02:00000288 13FC000FFDFFC000	    74: 	move.b #15,leds
02:00000290 6100008E        	    75: 	bsr	init_world				; go setup the world
                            	    76: 
                            	    77: ; main loop
                            	    78: 
                            	    79: plants_main_loop
02:00000294 7008            	    80: 	MOVEQ		#8,d0				; get the time in 1/100 ths seconds
02:00000296 4E4F            	    81: 	TRAP		#15
                            	    82: 
02:00000298 2F01            	    83: 	MOVE.l	d1,-(sp)			; save the time on the stack
                            	    84: 
02:0000029A 705E            	    85: 	MOVEQ		#94,d0			; copy buffer screen to main
02:0000029C 4E4F            	    86: 	TRAP		#15
02:0000029E 13FC0003FDFFC000	    87: 	move.b #$03,leds
                            	    88: 
                            	    89: ; animate the scene
                            	    90: 
02:000002A6 61000118        	    91: 	BSR		do_plants			; do the plants
02:000002AA 6100014A        	    92: 	BSR		do_animals			; do the animals
                            	    93: 
                            	    94: ; test the keys used
                            	    95: 
02:000002AE 610003BE        	    96: 	BSR		screen_size			; test and handle widow size change keys
02:000002B2 61000053        	    97: 	BSR		test_escape			; test if the user wants to quit
                            	    98: 
                            	    99: ; now see if we need to wait for some time
                            	   100: 
02:000002B6 2E1F            	   101: 	MOVE.l	(sp)+,d7			; get the main loop start time
02:000002B8 7008            	   102: 	MOVEQ		#8,d0				; get time in 1/100 ths seconds
02:000002BA 4E4F            	   103: 	TRAP		#15
                            	   104: 
02:000002BC 13FC0004FDFFC000	   105: 	move.b #$04,leds
                            	   106: 
                            	   107: ; doing the BGT means that if the clock passed midnight while the code was in the main
                            	   108: ; loop then the delay is skipped this go. this means things may run a bit fast for one
                            	   109: ; loop which is waaaaay better than waiting for a few 100ths of a second shy of twenty
                            	   110: ; four hours by mistake
                            	   111: 
02:000002C4 9E81            	   112: 	SUB.l		d1,d7				; subtract the current time from the start time
02:000002C6 6E1A            	   113: 	BGT.s		end_main_loop		; if the time crossed midnight just contimue
                            	   114: 
                            	   115: ; moving the wait time into d1 like this menas we can have any wait up to 1.27 seconds
                            	   116: ; and still use the MOVEQ form to load it
                            	   117: 
02:000002C8 7205            	   118: 	MOVEQ		#5,d1				; set the wait time in 100ths of a second
02:000002CA D287            	   119: 	ADD.l		d7,d1				; add the loop negative time delta
02:000002CC 6F14            	   120: 	BLE.s		end_main_loop		; if the time is up just contimue
                            	   121: 
02:000002CE 13FC0005FDFFC000	   122: 	move.b #$05,leds
02:000002D6 7017            	   123: 	moveq	#23,d0				; else wait d1 100ths of a second
02:000002D8 4E4F            	   124: 	trap #15
02:000002DA 13FC0006FDFFC000	   125: 	move.b #$06,leds
                            	   126: 
                            	   127: end_main_loop
02:000002E2 4A6B0002        	   128: 	TST.w		redraw(a3)			; test the redraw flag
02:000002E6 66A0            	   129: 	BNE.s		restart			; if redraw go initialise the world
                            	   130: 
02:000002E8 4A53            	   131: 	TST.w		quit(a3)			; test the quit flag
02:000002EA 67A8            	   132: 	BEQ.s		plants_main_loop			; if not quit go get another key
                            	   133: 
                            	   134: ; all done so tidy up and stop
                            	   135: 
                            	   136: ;	MOVE.b	#16,d1			; disable double buffering
                            	   137: ;	MOVE.b	#92,d0			; set draw mode
                            	   138: ;	TRAP		#15
                            	   139: 
02:000002EC 43FA02FA        	   140: 	LEA		goodbye_message(pc),a1	; set the goodbye message pointer
02:000002F0 700D            	   141: 	MOVEQ		#13,d0			; display a string with [CR][LF]
02:000002F2 4E4F            	   142: 	TRAP		#15
                            	   143: 
02:000002F4 4EF90000815C    	   144: 	jmp Monitor
                            	   145: ;	MOVEQ		#9,d0				; halt the simulator
                            	   146: ;	TRAP		#15
                            	   147: 
                            	   148: goodbye_message
02:000002FA 0C              	   149: 	dc.b	$0C,CR,LF
02:000002FB 0D
02:000002FC 0A
02:000002FD 2020476F6F646279	   150: 	dc.b	'  Goodbye',0
02:00000305 65
02:00000306 00
                            	   151: 
                            	   152: 	ds.w	0					; ensure even
                            	   153: 
                            	   154: 
                            	   155: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   156: ;
                            	   157: ; test if the user wants to quit
                            	   158: 
                            	   159: test_escape
02:00000308 7007            	   160: 	MOVEQ		#7,d0				; read the key status
02:0000030A 4E4F            	   161: 	TRAP		#15
                            	   162: 
02:0000030C 4A01            	   163: 	TST.b		d1				; test the result
02:0000030E 670E            	   164: 	BEQ.s		exit_test_escape		; if no key just exit
                            	   165: 
02:00000310 7005            	   166: 	MOVEQ		#5,d0				; read a key
02:00000312 4E4F            	   167: 	TRAP		#15
                            	   168: 
02:00000314 0C01001B        	   169: 	CMPI.b	#ESC,d1			; compare with [ESC]
02:00000318 6604            	   170: 	BNE.s		exit_test_escape		; if not [ESC] just exit
                            	   171: 
02:0000031A 72FF            	   172: 	MOVEQ		#-1,d1			; set the longword
02:0000031C 3681            	   173: 	MOVE.w	d1,quit(a3)			; set the quit flag
                            	   174: exit_test_escape
02:0000031E 4E75            	   175: 	RTS
                            	   176: 
                            	   177: 
                            	   178: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   179: ;
                            	   180: ; setup the world
                            	   181: 
                            	   182: init_world:
                            	   183: ;	MOVE.w	#$FF00,d1			; clear screen
                            	   184: ;	MOVEQ		#11,d0			; position cursor
                            	   185: ;	TRAP		#15
02:00000320 7E07            	   186: 	moveq #7,d7
02:00000322 7C0C            	   187: 	moveq #DEV_CLEAR,d6
02:00000324 4E40            	   188: 	trap #0
02:00000326 123C0045        	   189: 	move.b #'E',d1
02:0000032A 4EB900000000    	   190: 	jsr DisplayChar
                            	   191: 
02:00000330 203C00FFFFFF    	   192: 	MOVE.l	#def_animal,d0		; set the default animal colour
02:00000336 27400014        	   193: 	MOVE.l	d0,animal_colour(a3)	; save the animal colour
02:0000033A 7000            	   194: 	MOVE.l	#def_back,d0		; set the default background colour
02:0000033C 27400018        	   195: 	MOVE.l	d0,animal_fill(a3)	; save the animal fill colour
                            	   196: 
                            	   197: 
02:00000340 203C008080FF    	   198: 	MOVE.l	#def_plant,d0		; set the default plant colour
02:00000346 27400010        	   199: 	MOVE.l	d0,plant_colour(a3)	; save the plant colour
02:0000034A 203C00008000    	   200: 	MOVE.l	#def_leaf,d0		; set the default leaf colour
02:00000350 27400012        	   201: 	MOVE.l	d0,plant_fill(a3)		; save the plant fill colour
                            	   202: 
02:00000354 7032            	   203: 	MOVEQ		#def_plants,d0		; set the default plant count
02:00000356 3740000A        	   204: 	MOVE.w	d0,max_plants(a3)		; save the maximum plants count
02:0000035A 7001            	   205: 	MOVEQ		#def_p_spawn,d0		; set the default plant spawn value
02:0000035C 17400220        	   206: 	MOVE.b	d0,plant_spawn(a3)	; save the plant spawn value
                            	   207: 
02:00000360 7032            	   208: 	MOVEQ		#def_animals,d0		; set the default animal count
02:00000362 3740000E        	   209: 	MOVE.w	d0,max_animals(a3)	; save the maximum animals count
02:00000366 7005            	   210: 	MOVEQ		#def_a_spawn,d0		; set the default animal spawn value
02:00000368 17400221        	   211: 	MOVE.b	d0,animal_spawn(a3)	; save the animal spawn value
                            	   212: 
02:0000036C 7000            	   213: 	MOVEQ		#0,d0				; clear the longword
02:0000036E 37400002        	   214: 	MOVE.w	d0,redraw(a3)		; clear the redraw flag
                            	   215: 
                            	   216: ; clear all the plants
                            	   217: 
02:00000372 41EB00F4        	   218: 	LEA		plant_flag(a3),a0		; set the pointer to the plant flags
02:00000376 3E2B000A        	   219: 	MOVE.w	max_plants(a3),d7		; get the maximum plants count
02:0000037A 5347            	   220: 	SUBQ.w	#1,d7				; adjust for the loop type
02:0000037C 13FC0001FDFFC000	   221: 	move.b #$01,leds
                            	   222: clr_plant_loop
02:00000384 10C0            	   223: 	MOVE.b	d0,(a0)+			; clear the plant flag
02:00000386 51CFFFFC        	   224: 	DBF		d7,clr_plant_loop		; loop if more to do
                            	   225: 
02:0000038A 37400008        	   226: 	MOVE.w	d0,num_plants(a3)		; clear the plants count
                            	   227: 
                            	   228: ; clear all the animals
                            	   229: 
02:0000038E 41EB01EE        	   230: 	LEA		animal_flag(a3),a0	; set the pointer to the animal flags
02:00000392 3E2B000E        	   231: 	MOVE.w	max_animals(a3),d7	; get the maximum animals count
02:00000396 5347            	   232: 	SUBQ.w	#1,d7				; adjust for the loop type
                            	   233: clr_animals_loop
02:00000398 10C0            	   234: 	MOVE.b	d0,(a0)+			; clear the animal flag
02:0000039A 51CFFFFC        	   235: 	DBF		d7,clr_animals_loop	; loop if more to do
                            	   236: 
02:0000039E 3740000C        	   237: 	MOVE.w	d0,num_animals(a3)	; clear the animals count
                            	   238: 
                            	   239: ; get the screen size
02:000003A2 13FC0002FDFFC000	   240: 	move.b #$02,leds
                            	   241: 
02:000003AA 7200            	   242: 	moveq #0,d1				; get current window size
02:000003AC 7021            	   243: 	moveq #33,d0			; set/get output window size
02:000003AE 4E4F            	   244: 	trap #15
02:000003B0 13FC0003FDFFC000	   245: 	move.b #$03,leds
                            	   246: 
02:000003B8 E289            	   247: 	lsr.l	#1,d1				; / 2 for 2x2 pixels
02:000003BA 27410004        	   248: 	move.l d1,width(a3)		; save the screen x,y size
                            	   249: 
02:000003BE 4E75            	   250: 	rts
                            	   251: 
                            	   252: 
                            	   253: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   254: ;
                            	   255: ; do the plants
                            	   256: 
                            	   257: do_plants
02:000003C0 13FC0007FDFFC000	   258: 	move.b #$07,leds
02:000003C8 41EB0008        	   259: 	LEA		num_plants(a3),a0		; point to the plants count
02:000003CC 326B000A        	   260: 	MOVE.w	max_plants(a3),a1		; get the plants maximum
02:000003D0 45EB0220        	   261: 	LEA		plant_spawn(a3),a2	; point to the plant spawn level
02:000003D4 49EB002C        	   262: 	LEA		plant_xy(a3),a4		; point to the plant position array
02:000003D8 4BEB00F4        	   263: 	LEA		plant_flag(a3),a5		; point to the plant flags
02:000003DC 276B0010001C    	   264: 	MOVE.l	plant_colour(a3),thing_colour(a3)
                            	   265: 							; copy the plant colour
02:000003E2 276B00120020    	   266: 	MOVE.l	plant_fill(a3),fill_colour(a3)
                            	   267: 							; copy the plant fill colour
02:000003E8 276B00180024    	   268: 	MOVE.l	animal_fill(a3),food_colour(a3)
                            	   269: 							; copy the animal fill colour
02:000003EE 276B00140028    	   270: 	MOVE.l	animal_colour(a3),poison_colour(a3)
                            	   271: 							; copy the animal colour
02:000003F4 6034            	   272: 	BRA.s		do_things			; go do the plants
                            	   273: 
                            	   274: 
                            	   275: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   276: ;
                            	   277: ; do the animals
                            	   278: 
                            	   279: do_animals
02:000003F6 13FC0008FDFFC000	   280: 	move.b #$08,leds
02:000003FE 41EB000C        	   281: 	LEA		num_animals(a3),a0	; point to the animals count
02:00000402 326B000E        	   282: 	MOVE.w	max_animals(a3),a1	; get the animals maximum
02:00000406 45EB0221        	   283: 	LEA		animal_spawn(a3),a2	; point to the animal spawn level
02:0000040A 49EB0126        	   284: 	LEA		animal_xy(a3),a4		; point to the animal position array
02:0000040E 4BEB01EE        	   285: 	LEA		animal_flag(a3),a5	; point to the animal flags
02:00000412 276B0014001C    	   286: 	MOVE.l	animal_colour(a3),thing_colour(a3)
                            	   287: 							; copy the animal colour
02:00000418 276B00180020    	   288: 	MOVE.l	animal_fill(a3),fill_colour(a3)
                            	   289: 							; copy the animal fill colour
02:0000041E 276B00120024    	   290: 	MOVE.l	plant_fill(a3),food_colour(a3)
                            	   291: 							; copy the plant fill colour
02:00000424 276B00100028    	   292: 	MOVE.l	plant_colour(a3),poison_colour(a3)
                            	   293: 							; copy the plant colour
                            	   294: 
                            	   295: 
                            	   296: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   297: ;
                            	   298: ; do things
                            	   299: 
                            	   300: do_things
02:0000042A 13FC0009FDFFC000	   301: 	move.b #$09,leds
02:00000432 3E10            	   302: 	MOVE.w	(a0),d7			; get the things count
02:00000434 6636            	   303: 	BNE.s		things_exist		; if things exist go make them eat
                            	   304: 
                            	   305: ; else get a random position for thing zero
                            	   306: 
02:00000436 302B0004        	   307: 	MOVE.w	width(a3),d0		; get the screen width
02:0000043A 61000222        	   308: 	BSR		get_prng			; get a random number between 0 and d0.w - 1
02:0000043E 3600            	   309: 	MOVE.w	d0,d3				; copy the x co-ordinate
02:00000440 3800            	   310: 	MOVE.w	d0,d4				; copy the x co-ordinate again
02:00000442 4844            	   311: 	SWAP		d4				; swap it to the high word
02:00000444 302B0006        	   312: 	MOVE.w	height(a3),d0		; get the screen height
02:00000448 61000214        	   313: 	BSR		get_prng			; get a random number between 0 and d0.w - 1
02:0000044C 3800            	   314: 	MOVE.w	d0,d4				; copy the x co-ordinate
02:0000044E 2884            	   315: 	MOVE.l	d4,(a4)			; set the x,y for thing zero
                            	   316: 
02:00000450 7008            	   317: 	MOVEQ		#8,d0				; direction is this position
02:00000452 610000DE        	   318: 	BSR		neighbour			; get the neighbouring pixel colour in
                            	   319: 							; direction d0
02:00000456 BAAB0024        	   320: 	CMP.l		food_colour(a3),d5	; compare the colour with the food colour
02:0000045A 660000D4        	   321: 	BNE		exit_do_things		; if it is not food just exit
                            	   322: 
                            	   323: ; else make thing zero active
                            	   324: 
02:0000045E 5250            	   325: 	ADDQ.w	#1,(a0)			; increment the thing count
02:00000460 1ABC0001        	   326: 	MOVE.b	#1,(a5)			; flag thing zero active
                            	   327: 
02:00000464 2F2B001C        	   328: 	MOVE.l	thing_colour(a3),-(sp)	; fill the old position with the thing colour
02:00000468 600000BC        	   329: 	BRA		fill_old_thing		; go draw thing zero, d7.w = 0 here
                            	   330: 
                            	   331: ; set the direction delta, randomly setting -1 and +1 should remove any bias toward
                            	   332: ; sweeping round the screen clockwise or anticlockwise
                            	   333: 
                            	   334: things_exist
02:0000046C 13FC000AFDFFC000	   335: 	move.b #10,leds
02:00000474 7002            	   336: 	MOVEQ		#2,d0				; set for 0 or 1
02:00000476 610001E6        	   337: 	BSR		get_prng			; get a random number between 0 and d0.w - 1
02:0000047A D040            	   338: 	ADD.w		d0,d0				; now 0 or 2
02:0000047C 5340            	   339: 	SUBQ.w	#1,d0				; -1 or + 1
02:0000047E 3C40            	   340: 	MOVE.w	d0,a6				; copy the direction delta
                            	   341: 
                            	   342: ; scan through all the possible things
02:00000480 5349            	   343: 	SUBQ.w	#1,a1				; - 1 for loop type
02:00000482 3E09            	   344: 	MOVE.w	a1,d7				; get the maximum things count
                            	   345: do_things_loop
02:00000484 4A357000        	   346: 	TST.b		(a5,d7.w)			; test the thing status
02:00000488 670000A2        	   347: 	BEQ		next_thing			; if not active skip this thing
                            	   348: 
                            	   349: ; get this thing's x,y position
                            	   350: 
                            	   351: thing_zero_only
02:0000048C 13FC000BFDFFC000	   352: 	move.b #11,leds
02:00000494 3807            	   353: 	MOVE.w	d7,d4				; copy the index
02:00000496 E544            	   354: 	ASL.w		#2,d4				; ; 4 bytes per word
02:00000498 28344000        	   355: 	MOVE.l	(a4,d4.w),d4		; get the thing's x,y position
02:0000049C 2604            	   356: 	MOVE.l	d4,d3				; copy the thing's x position
02:0000049E 4843            	   357: 	SWAP		d3				; move the thing's x position to the low word
                            	   358: 
                            	   359: ; fill the thing's current position
                            	   360: 
02:000004A0 2F2B0020        	   361: 	MOVE.l	fill_colour(a3),-(sp)	; set the fill behind colour
                            	   362: 
                            	   363: ; get a random direction
                            	   364: 
02:000004A4 610001B6        	   365: 	BSR		get_direction		; get a random direction
                            	   366: 
                            	   367: ; remember the direction we start from
                            	   368: 
02:000004A8 3C00            	   369: 	MOVE.w	d0,d6				; copy the start direction
                            	   370: check_for_food
02:000004AA 13FC000CFDFFC000	   371: 	move.b #12,leds
02:000004B2 617E            	   372: 	BSR.s		neighbour			; get the neighbouring pixel colour in
                            	   373: 							; direction d0
02:000004B4 BAAB0024        	   374: 	CMP.l		food_colour(a3),d5	; compare the colour with the food colour
02:000004B8 6720            	   375: 	BEQ.s		is_food			; if it is food go move the thing
                            	   376: 
02:000004BA BAAB0028        	   377: 	CMP.l		poison_colour(a3),d5	; compare the colour with the poison colour
02:000004BE 670A            	   378: 	BEQ.s		kill_thing			; if it is poison go kill the thing
                            	   379: 
                            	   380: ; no food in the direction looked so try the next direction
                            	   381: 
02:000004C0 D04E            	   382: 	ADD.w		a6,d0				; add the direction delta
02:000004C2 02400007        	   383: 	ANDI.w	#7,d0				; mask 0 to 7
02:000004C6 BC40            	   384: 	CMP.w		d0,d6				; compare it with the start direction
02:000004C8 66E0            	   385: 	BNE.s		check_for_food		; if not back at the start go check for food
                            	   386: 
                            	   387: ; else this thing has starved so kill it
                            	   388: 
                            	   389: kill_thing
02:000004CA 13FC000DFDFFC000	   390: 	move.b #13,leds
02:000004D2 5350            	   391: 	SUBQ.w	#1,(a0)			; decrement the thing count
02:000004D4 42357000        	   392: 	MOVE.b	#0,(a5,d7.w)		; clear the thing flag
02:000004D8 604C            	   393: 	BRA.s		fill_old_thing		; go fill this thing with the fill behind colour
                            	   394: 
                            	   395: ; found food beside the thing so move it there
                            	   396: 
                            	   397: is_food
02:000004DA 13FC000EFDFFC000	   398: 	move.b #14,leds
02:000004E2 3007            	   399: 	MOVE.w	d7,d0				; copy the index
02:000004E4 E540            	   400: 	ASL.w		#2,d0				; ; 4 bytes per word
02:000004E6 39810000        	   401: 	MOVE.w	d1,(a4,d0.w)		; save the thing's new x position
02:000004EA 39820002        	   402: 	MOVE.w	d2,2(a4,d0.w)		; save the thing's new y position
                            	   403: 
02:000004EE 52357000        	   404: 	ADDQ.b	#1,(a5,d7.w)		; increment the thing flag
                            	   405: 
                            	   406: ; check for spawning a new thing
                            	   407: 
02:000004F2 10357000        	   408: 	MOVE.b	(a5,d7.w),d0		; get the thing flag
02:000004F6 9012            	   409: 	SUB.b		(a2),d0			; compare it with the spawn level
02:000004F8 6F2A            	   410: 	BLE.s		draw_old_thing		; if not there yet skip the spawn
                            	   411: 
                            	   412: ; else the thing is going to try to spawn
                            	   413: 
02:000004FA 1B807000        	   414: 	MOVE.b	d0,(a5,d7.w)		; reset the flag for this thing, d0 = 1
                            	   415: 
                            	   416: ; search for a free thing slot
                            	   417: 
02:000004FE 3C09            	   418: 	MOVE.w	a1,d6				; get the maximum things count
02:00000500 BC50            	   419: 	CMP.w		(a0),d6			; compare it with the things count
02:00000502 6B20            	   420: 	BMI.s		draw_old_thing		; if no space just draw the old thing
                            	   421: 
                            	   422: new_thing_loop
02:00000504 13FC000FFDFFC000	   423: 	move.b #15,leds
02:0000050C 4A356000        	   424: 	TST.b		(a5,d6.w)			; test this thing flag
02:00000510 57CEFFF2        	   425: 	DBEQ		d6,new_thing_loop		; loop if active
                            	   426: 
                            	   427: ; found one of the free thing slots so flag that the new thing is active
                            	   428: 
02:00000514 5250            	   429: 	ADDQ.w	#1,(a0)			; increment the thing count
02:00000516 1B806000        	   430: 	MOVE.b	d0,(a5,d6.w)		; set the new thing's active flag, d0 = 1
                            	   431: 
                            	   432: ; save the new thing position
                            	   433: 
02:0000051A E546            	   434: 	ASL.w		#2,d6				; ; 4 bytes per word
02:0000051C 29846000        	   435: 	MOVE.l	d4,(a4,d6.w)		; save the new thing's x,y position
                            	   436: 
                            	   437: ; set the new thing's colour to fill the thing's old position
                            	   438: 
02:00000520 2EAB001C        	   439: 	MOVE.l	thing_colour(a3),(sp)	; fill the old position with the thing colour
                            	   440: 
                            	   441: ; now draw the current thing in the new position and fill the old position
                            	   442: 
                            	   443: draw_old_thing
02:00000524 617C            	   444: 	BSR.s		set_thing_pixel		; set the pixel at d1,d2 to the thing's colour
                            	   445: fill_old_thing
02:00000526 201F            	   446: 	MOVE.l	(sp)+,d0			; get the d3,d4 pixel's colout
02:00000528 6100008E        	   447: 	BSR		set_a_pixel			; set the pixel at d3,d4 to the d0's colour
                            	   448: next_thing
02:0000052C 51CFFF56        	   449: 	DBF		d7,do_things_loop		; decrement and loop if more things to do
                            	   450: 
                            	   451: exit_do_things
02:00000530 4E75            	   452: 	RTS
                            	   453: 
                            	   454: 
                            	   455: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   456: ;
                            	   457: ; get the neighbouring 2x2 pixel colour in direction d0.w
                            	   458: ;
                            	   459: ; x is in d3.w, y is in d4.w
                            	   460: ;
                            	   461: ; returns the pixel colour or -1 of out of range in d5.l
                            	   462: ; returns the new x,y in d1,d2
                            	   463: 
                            	   464: neighbour
02:00000532 13FC0010FDFFC000	   465: 	move.b #16,leds
02:0000053A 48E78080        	   466: 	MOVEM.l	d0/a0,-(sp)		; save the direction
                            	   467: 
02:0000053E 7AFF            	   468: 	MOVEQ		#-1,d5			; flag out of range
                            	   469: 
02:00000540 3203            	   470: 	MOVE.w	d3,d1				; copy x
02:00000542 3404            	   471: 	MOVE.w	d4,d2				; copy y
                            	   472: 
02:00000544 D040            	   473: 	add.w	d0,d0					; * 2 bytes per word
02:00000546 41FA057E        	   474: 	lea delta_x(pc),a0
02:0000054A D2700000        	   475: 	add.w	(a0,d0.w),d1			; add the direction delta x to x
02:0000054E 6B28            	   476: 	BMI.s		exit_neighbour		; if x < screen x minimum just exit
                            	   477: 
02:00000550 B26B0004        	   478: 	CMP.w		width(a3),d1		; compare it with the screen width
02:00000554 6C22            	   479: 	BGE.s		exit_neighbour		; if x > screen x maximum just exit
                            	   480: 
02:00000556 41FA0590        	   481: 	lea delta_y(pc),a0
02:0000055A D4700000        	   482: 	add.w	(a0,d0.w),d2	; add the direction delta y to y
02:0000055E 6B18            	   483: 	BMI.s		exit_neighbour		; if y < screen y minimum just exit
                            	   484: 
02:00000560 B46B0006        	   485: 	CMP.w		height(a3),d2		; compare it with the screen height
02:00000564 6C12            	   486: 	BGE.s		exit_neighbour		; if y > screen y maximum just exit
                            	   487: 
02:00000566 48E76000        	   488: 	MOVEM.l	d1-d2,-(sp)			; save the new x,y
                            	   489: 
02:0000056A D241            	   490: 	ADD.w		d1,d1				; * 2
02:0000056C D442            	   491: 	ADD.w		d2,d2				; * 2
02:0000056E 7053            	   492: 	MOVEQ		#83,d0			; read a pixel
02:00000570 4E4F            	   493: 	trap #15
                            	   494: 
02:00000572 4CDF0006        	   495: 	MOVEM.l	(sp)+,d1-d2			; restore the new x,y
                            	   496: 
02:00000576 2A00            	   497: 	MOVE.l	d0,d5				; copy the pixel colour
                            	   498: exit_neighbour
02:00000578 4CDF0101        	   499: 	MOVEM.l	(sp)+,d0/a0			; restore the direction
                            	   500: 
02:0000057C 4E75            	   501: 	rts
                            	   502: 
                            	   503: ; direction deltas				; the directions are
                            	   504: 							;
                            	   505: 							; +---+---+---+
                            	   506: 							; | 5 | 4 | 3 |
                            	   507: 							; +---+---+---+
                            	   508: 							; | 6 | 8 | 2 |
                            	   509: 							; +---+---+---+
                            	   510: 							; | 7 | 0 | 1 |
                            	   511: 							; +---+---+---+
                            	   512: delta_x
02:0000057E 0000            	   513: 	dc.w	0					; direction 0 dx,dy =  0, 1
02:00000580 0001            	   514: 	dc.w	1					; direction 1 dx,dy =  1, 1
02:00000582 0001            	   515: 	dc.w	1					; direction 2 dx,dy =  1, 0
02:00000584 0001            	   516: 	dc.w	1					; direction 3 dx,dy =  1,-1
02:00000586 0000            	   517: 	dc.w	0					; direction 4 dx,dy =  0,-1
02:00000588 FFFF            	   518: 	dc.w	-1					; direction 5 dx,dy = -1,-1
02:0000058A FFFF            	   519: 	dc.w	-1					; direction 6 dx,dy = -1, 0
02:0000058C FFFF            	   520: 	dc.w	-1					; direction 7 dx,dy = -1, 1
02:0000058E 0000            	   521: 	dc.w	0					; direction 8 dx,dy =  0, 0
                            	   522: 
                            	   523: delta_y
02:00000590 0001            	   524: 	dc.w	1					; direction 0 dx,dy =  0, 1
02:00000592 0001            	   525: 	dc.w	1					; direction 1 dx,dy =  1, 1
02:00000594 0000            	   526: 	dc.w	0					; direction 2 dx,dy =  1, 0
02:00000596 FFFF            	   527: 	dc.w	-1					; direction 3 dx,dy =  1,-1
02:00000598 FFFF            	   528: 	dc.w	-1					; direction 4 dx,dy =  0,-1
02:0000059A FFFF            	   529: 	dc.w	-1					; direction 5 dx,dy = -1,-1
02:0000059C 0000            	   530: 	dc.w	0					; direction 6 dx,dy = -1, 0
02:0000059E 0001            	   531: 	dc.w	1					; direction 7 dx,dy = -1, 1
02:000005A0 0000            	   532: 	dc.w	0					; direction 8 dx,dy =  0, 0
                            	   533: 
                            	   534: 
                            	   535: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   536: ;
                            	   537: ; set the 2x2 pixel at d1,d2 to the thing's
                            	   538: 
                            	   539: set_thing_pixel
02:000005A2 13FC0012FDFFC000	   540: 	move.b #18,leds
02:000005AA 48E77800        	   541: 	MOVEM.l	d1-d4,-(sp)			; save the registers
02:000005AE 3601            	   542: 	MOVE.w	d1,d3				; copy the thing's new x position
02:000005B0 3802            	   543: 	MOVE.w	d2,d4				; copy the thing's new y position
02:000005B2 202B001C        	   544: 	MOVE.l	thing_colour(a3),d0	; get the thing colour
02:000005B6 600C            	   545: 	BRA.s		set_this_pixel		; go set this pixel
                            	   546: 
                            	   547: 
                            	   548: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   549: ;
                            	   550: ; set the 2x2 pixel at d3,d4 to colour d0
                            	   551: 
                            	   552: set_a_pixel
02:000005B8 13FC0013FDFFC000	   553: 	move.b #19,leds
02:000005C0 48E77800        	   554: 	MOVEM.l	d1-d4,-(sp)			; save the registers
                            	   555: 
                            	   556: set_this_pixel
02:000005C4 13FC0014FDFFC000	   557: 	move.b #20,leds
02:000005CC 2200            	   558: 	MOVE.l	d0,d1				; copy the colour
02:000005CE 7050            	   559: 	MOVEQ		#80,d0			; set the pen colour
02:000005D0 4E4F            	   560: 	TRAP		#15
                            	   561: 
02:000005D2 7201            	   562: 	MOVEQ		#1,d1				; + 1
02:000005D4 7401            	   563: 	MOVEQ		#1,d2				; + 1
02:000005D6 D643            	   564: 	ADD.w		d3,d3				; x*2
02:000005D8 D844            	   565: 	ADD.w		d4,d4				; y*2
02:000005DA D243            	   566: 	ADD.w		d3,d1				; x*2 + 1
02:000005DC D444            	   567: 	ADD.w		d4,d2				; y*2 + 1
02:000005DE 705A            	   568: 	MOVEQ		#90,d0			; draw a rectangle in the pen colour
02:000005E0 4E4F            	   569: 	TRAP		#15
                            	   570: 
02:000005E2 4CDF001E        	   571: 	MOVEM.l	(sp)+,d1-d4			; restore the registers
02:000005E6 4E75            	   572: 	RTS
                            	   573: 
                            	   574: 
                            	   575: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   576: ;
                            	   577: ; setup stuff
                            	   578: 
                            	   579: InitialisePlants:
02:000005E8 123C0040        	   580: 	move.b #'@',d1
02:000005EC 4EB900000000    	   581: 	jsr DisplayChar
                            	   582: 	
                            	   583: ;	MOVE.b	#17,d1			; enable double buffering
                            	   584: ;	MOVE.b	#92,d0			; set draw mode
                            	   585: ;	TRAP		#15
                            	   586: 
02:000005F2 123C0041        	   587: 	move.b #'A',d1
02:000005F6 4EB900000000    	   588: 	jsr DisplayChar
                            	   589: 	
02:000005FC 7200            	   590: 	moveq #0,d1					; echo off
02:000005FE 700C            	   591: 	moveq #12,d0				; set keyboard echo
02:00000600 4E4F            	   592: 	trap #15
02:00000602 123C0042        	   593: 	move.b #'B',d1
02:00000606 4EB900000000    	   594: 	jsr DisplayChar
                            	   595: 
02:0000060C 223C00000888    	   596: 	move.l #$00000888,d1		; 24 bpp
02:00000612 7E06            	   597: 	moveq #6,d7							; framebuf device
02:00000614 7C21            	   598: 	moveq #DEV_SET_COLOR_DEPTH,d6
02:00000616 4E40            	   599: 	trap #0
02:00000618 7E07            	   600: 	moveq #7,d7							; graphics accelerator device
02:0000061A 4E40            	   601: 	trap #0
02:0000061C 223C0F003F4F    	   602: 	move.l #$0F003F4F,d1		; set burst length, max burst number and interval
02:00000622 4EB90000982C    	   603: 	jsr rbo
02:00000628 23C1FD208004    	   604: 	move.l d1,FRAMEBUF+4
02:0000062E 123C0043        	   605: 	move.b #'C',d1
02:00000632 4EB900000000    	   606: 	jsr DisplayChar
                            	   607: 
02:00000638 47FA06AC        	   608: 	lea	pvariables(pc),a3		; get the variables base address
                            	   609: 
02:0000063C 3681            	   610: 	move.w d1,quit(a3)			; clear the quit flag
                            	   611: 
02:0000063E 7008            	   612: 	moveq #8,d0					; get time in 1/100 ths seconds
02:00000640 4E4F            	   613: 	trap #15
02:00000642 2001            	   614: 	move.l d1,d0
02:00000644 123C0044        	   615: 	move.b #'D',d1
02:00000648 4EB900000000    	   616: 	jsr DisplayChar
02:0000064E 2200            	   617: 	move.l d0,d1
                            	   618: 
02:00000650 0A81DEADBEEF    	   619: 	eori.l #$DEADBEEF,d1		; EOR with the initial PRNG seed, this must
                            	   620: 													; result in any value but zero
02:00000656 2741000A        	   621: 	move.l d1,PRNlword(a3)	; save the initial PRNG seed
02:0000065A 4E75            	   622: 	rts
                            	   623: 
                            	   624: 
                            	   625: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   626: ;
                            	   627: ; get a random direction
                            	   628: 
                            	   629: get_direction
02:0000065C 7008            	   630: 	moveq #8,d0				; set for direction 0 to 7
                            	   631: 
                            	   632: 
                            	   633: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   634: ;
                            	   635: ; get a random number between 0 and d0.w - 1
                            	   636: 
                            	   637: get_prng
02:0000065E 4EB90000C172    	   638: 	jsr gen_prng			; call the PRNG code
02:00000664 C0EB000A        	   639: 	mulu.w PRNlword(a3),d0		; random word times scale
02:00000668 4240            	   640: 	clr.w	d0					; clear the low word
02:0000066A 4840            	   641: 	swap d0						; return the high word as the result
02:0000066C 4E75            	   642: 	rts
                            	   643: 
                            	   644: 
                            	   645: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   646: ;
                            	   647: ; This is the code that generates the pseudo random sequence. A seed word located in
                            	   648: ; PRNlword(a3) is loaded into a register before being operated on to generate the
                            	   649: ; next number in the sequence. This number is then saved as the seed for the next
                            	   650: ; time it's called.
                            	   651: ;
                            	   652: ; This code is adapted from the 32 bit version of RND(n) used in EhBASIC68. Taking
                            	   653: ; the 19th next number is slower but helps to hide the shift and add nature of this
                            	   654: ; generator as can be seen from analysing the output.
                            	   655: 
                            	   656: ;gen_prng
                            	   657: ;	MOVEM.l	d0-d2,-(sp)			; save d0, d1 and d2
                            	   658: ;	MOVE.l	PRNlword(a3),d0		; get current seed longword
                            	   659: ;	MOVEQ		#$AF-$100,d1		; set EOR value
                            	   660: ;	MOVEQ		#18,d2			; do this 19 times
                            	   661: ;Ninc0
                            	   662: ;	ADD.l		d0,d0				; shift left 1 bit
                            	   663: ;	BCC.s		Ninc1				; if bit not set skip feedback
                            	   664: 
                            	   665: ;	EOR.b		d1,d0				; do Galois LFSR feedback
                            	   666: ;Ninc1
                            	   667: ;	DBF		d2,Ninc0			; loop;
                            	   668: 
                            	   669: ;	MOVE.l	d0,PRNlword(a3)		; save back to seed longword
                            	   670: ;	MOVEM.l	(sp)+,d0-d2			; restore d0, d1 and d2
                            	   671: 
                            	   672: ;	RTS
                            	   673: 
                            	   674: 
                            	   675: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   676: ;
                            	   677: ; check the [F2], [F3] and [F4] keys. set the screen size to 640 x 480, 800 x 600 or
                            	   678: ; 1024 x 768 if the corresponding key has been pressed
                            	   679: 
                            	   680: screen_size
02:0000066E 4E75            	   681: 	rts
02:00000670 223C71007273    	   682: 	MOVE.l	#$71007273,d1		; [F2], [], [F3] and [F4] keys
02:00000676 7013            	   683: 	MOVEQ		#19,d0			; check for keypress
02:00000678 4E4F            	   684: 	TRAP		#15
                            	   685: 
02:0000067A 2401            	   686: 	MOVE.l	d1,d2				; copy result
02:0000067C 672C            	   687: 	BEQ.s		pnotscreen			; skip screen size if no F key
                            	   688: 
02:0000067E 223C014000F0    	   689: 	MOVE.l	#$028001E0/2,d1		; set 640 x 480
02:00000684 4A82            	   690: 	TST.l		d2				; test result
02:00000686 6B10            	   691: 	BMI.s		psetscreen			; if F2 go set window size
                            	   692: 
02:00000688 223C0190012C    	   693: 	MOVE.l	#$03200258/2,d1		; set 800 x 600
02:0000068E 4A42            	   694: 	TST.w		d2				; test result
02:00000690 6B06            	   695: 	BMI.s		psetscreen			; if F3 go set window size
                            	   696: 
                            	   697: 							; else was F4 so ..
02:00000692 223C02000180    	   698: 	MOVE.l	#$04000300/2,d1		; set 1024 x 768
                            	   699: psetscreen
02:00000698 B2AB0004        	   700: 	CMP.l		width(a3),d1		; compare with current screen size
02:0000069C 670C            	   701: 	BEQ.s		.0001			; if already set skip setting it now
                            	   702: 
02:0000069E D281            	   703: 	ADD.l		d1,d1				; make it the full size
02:000006A0 7021            	   704: 	MOVEQ 	#33,d0			; get/set window size
02:000006A2 4E4F            	   705: 	TRAP		#15
                            	   706: 
02:000006A4 70FF            	   707: 	MOVEQ		#-1,d0			; set the longword
02:000006A6 37400002        	   708: 	MOVE.w	d0,redraw(a3)		; set the redraw flag
                            	   709: .0001
                            	   710: pnotscreen:
02:000006AA 4E75            	   711: 	rts
                            	   712: 
                            	   713: 
                            	   714: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   715: ;
                            	   716: ; variables
                            	   717: 
                            	   718: pvariables
                            	   719: 
                            	   720: 	OFFSET	0				; going to use relative addressing
                            	   721: 
                            	   722: ;PRNlword
                            	   723: ;	ds.l	1					; PRNG seed long word
                            	   724: quit
03:00000000 0000            	   725: 	ds.w	1					; quit flag
                            	   726: redraw
03:00000002 0000            	   727: 	ds.w	1					; redraw the world flag
                            	   728: 
                            	   729: width
03:00000004 0000            	   730: 	ds.w	1					; screen width
                            	   731: height
03:00000006 0000            	   732: 	ds.w	1					; screen height
                            	   733: 
                            	   734: num_plants
03:00000008 0000            	   735: 	ds.w	1					; the number of plants
                            	   736: max_plants
03:0000000A 0000            	   737: 	ds.w	1					; the maximum number of plants
                            	   738: 
                            	   739: num_animals
03:0000000C 0000            	   740: 	ds.w	1					; the number of animals
                            	   741: max_animals
03:0000000E 0000            	   742: 	ds.w	1					; the maximum number of animals
                            	   743: 
                            	   744: plant_colour
03:00000010 0000            	   745: 	ds.w	1					; plant colour
                            	   746: plant_fill
03:00000012 0000            	   747: 	ds.w	1					; plant overfill
                            	   748: 
                            	   749: animal_colour
03:00000014 00000000        	   750: 	ds.l	1					; animal colour
                            	   751: animal_fill
03:00000018 00000000        	   752: 	ds.l	1					; animal overfill
                            	   753: 
                            	   754: thing_colour
03:0000001C 00000000        	   755: 	ds.l	1					; the colour of things
                            	   756: fill_colour
03:00000020 00000000        	   757: 	ds.l	1					; the colour that things leave
                            	   758: food_colour
03:00000024 00000000        	   759: 	ds.l	1					; the colour that things eat
                            	   760: poison_colour
03:00000028 00000000        	   761: 	ds.l	1					; the colour that kills things
                            	   762: 
                            	   763: plant_xy
03:0000002C 0000            	   764: 	ds.w	def_plants*2			; plant x,y positions
03:0000002E *
                            	   765: plant_flag
03:000000F4 00              	   766: 	ds.b	def_plants				; plant active flags
03:000000F5 *
                            	   767: 
                            	   768: animal_xy
03:00000126 0000            	   769: 	ds.w	def_animals*2			; animal x,y positions
03:00000128 *
                            	   770: animal_flag
03:000001EE 00              	   771: 	ds.b	def_animals				; animal active and state
03:000001EF *
                            	   772: 
                            	   773: plant_spawn
03:00000220 00              	   774: 	ds.b	1					; the space count at which a plant reproduces
                            	   775: animal_spawn
03:00000221 00              	   776: 	ds.b	1					; the leaf count at which a animal reproduces
                            	   777: 
                            	   778: 	ds.w	0					; ensure even
                            	   779: 
                            	   780: 
                            	   781: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   782: 
                            	   783: 	END		start_plants
                            	   784: 
                            	   785: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   786: 

Source: "boot.x68"
                            	  4638: 


Symbols by name:
ABCD_INNER1                     00:00004A08
ABCD_INNER2                     00:00004A76
ABCD_NO_C1                      00:00004A24
ABCD_NO_C2                      00:00004A2C
ABCD_NO_C3                      00:00004A92
ABCD_NO_C4                      00:00004A9A
ABCD_OUTER1                     00:00004A06
ABCD_OUTER2                     00:00004A74
ABS                             00:000073AE
ACIA                             E:FDFE0010
ACIA_CMD                         E:00000008
ACIA_CTRL                        E:0000000C
ACIA_RX                          E:00000000
ACIA_STAT                        E:00000004
ACIA_TX                          E:00000000
ADAU1761                         E:FD254000
ADDA_OUTER1                     00:00005576
ADDQ_LOOP1                      00:00004D90
ADDQ_LOOP2                      00:00004DCE
ADDQ_LOOP3                      00:00004E04
ADDX_LOOP3                      00:0000569C
ADDX_LOOP4                      00:000056B8
ADDX_LOOP5                      00:000056D4
ADDX_OUTER1                     00:00005608
ADD_OUTER1                      00:0000539C
ADD_OUTER2                      00:00005410
AHOW                            00:00007626
ALL_DONE                        00:0000276A
AND_OUTER1                      00:000050BA
AND_OUTER2                      00:0000512E
ASORRY                          00:0000761E
AUXIN                           00:0000794A
AUXOUT                          00:00007936
AWHAT                           00:000075DE
AXIRET                          00:00007968
AllocateString                  00:000070C6
ArmAllBreakpoints               00:00009CD4
ArmBreakpoint                   00:00009D04
AsciiToHexNybble                00:00009530
AudioInputTest                  00:0000981E
AudioTestOff                    00:000023DC
AudioTestOn                     00:00002394
BCC1                            00:00004CAE
BCC10                           00:00004D00
BCC11                           00:00004D08
BCC12                           00:00004D12
BCC13                           00:00004D1A
BCC14                           00:00004D24
BCC2                            00:00004CB8
BCC3                            00:00004CC0
BCC4                            00:00004CCA
BCC5                            00:00004CD2
BCC6                            00:00004CDC
BCC7                            00:00004CE4
BCC8                            00:00004CEE
BCC9                            00:00004CF6
BLANK                            E:00000020
BRTBL                           00:0000A6CC
BSR_CLOSE1                      00:0000383E
BSR_CLOSE2                      00:00003874
BSR_FAR1                        00:0000276C
BSR_FAR2                        00:00004C9E
BUFFER                          00:00007A3C
BUFLEN                           E:00000050
BUFSIZE                          E:0000003F
BYEBYE                          00:0000796A
BlankLastLine                   00:00001488
BouncingBalls                   00:00009820
BreakpointWords                  E:00040280
Breakpoints                      E:00040220
BufByte                         00:000095BC
BufNybble                       00:000095C2
BufTetra                        00:000095B0
BufWyde                         00:000095B6
CALL                            00:00006B12
CHKIO                           00:000078DC
CHKRET                          00:000078EC
CHR                             00:00007558
CLEAR                           00:00006B28
CLMSG                           00:000079D2
CLS                             00:000078FA
CMPA_OUTER1                     00:00005290
CMPM_LOOP1                      00:0000531E
CMPM_LOOP2                      00:00005338
CMPM_LOOP3                      00:00005352
CMP_OUTER1                      00:0000521A
COLOR                           00:00006B8A
COLOR1                          00:00006B96
COLOR2                          00:00006BEA
COMMON                          00:0000AABE
COMMON35                        00:0000AACC
COMMON4                         00:0000AABC
COM_CMDTBL                      00:00001568
CORENO                          00:000073D6
CR                               E:0000000D
CRLF                            00:00007AF2
CS11                            00:0000A502
CS12                            00:0000A472
CS13                            00:0000A3F8
CS14                            00:0000A38E
CS15                            00:0000A350
CS16                            00:0000A2E2
CS17                            00:0000A698
CS18                            00:0000A634
CS19                            00:0000A744
CS20                            00:0000A59C
CSTART                          00:000061FC
CTRLC                            E:00000003
CTRLH                            E:00000008
CTRLS                            E:00000013
CTRLX                            E:00000018
CTRLZ                            E:0000001A
CURRNT                          00:000079E4
CURVE                           00:00006D3C
CalcScreenLoc                   00:0000125C
CallOS                          00:00000240
CheckForCtrlC                   00:000008D2
CheckForKey                     00:0000088C
CheckNumeric                    00:00006E36
ClearBreakpointList             00:00009DF6
ClearScreen                     00:00009824
ClearStringArea                 00:00006328
ClearStringStack                00:00006348
CmdBuf                           E:00040040
CmdBufEnd                        E:00040080
ConcatString                    00:00006F42
Cursor1                         00:00007FC2
DBCC_LOOP1                      00:00004D2E
DBCC_LOOP2                      00:00004D3C
DCB_BKCOLOR                      E:00000060
DCB_CMDPROC                      E:00000018
DCB_FGCOLOR                      E:00000064
DCB_INBUFPTR                     E:00000038
DCB_INBUFPTR2                    E:00000070
DCB_INBUFSIZE                    E:00000040
DCB_INDIMX                       E:00000048
DCB_INDIMY                       E:0000004C
DCB_INDIMZ                       E:00000050
DCB_INPOSX                       E:0000002C
DCB_INPOSY                       E:00000030
DCB_INPOSZ                       E:00000034
DCB_MAGIC                        E:00000000
DCB_NAME                         E:00000004
DCB_OPCODE                       E:00000068
DCB_OUTBUFPTR                    E:0000003C
DCB_OUTBUFPTR2                   E:00000074
DCB_OUTBUFSIZE                   E:00000044
DCB_OUTBUFSIZE2                  E:0000007C
DCB_OUTDIMX                      E:00000054
DCB_OUTDIMY                      E:00000058
DCB_OUTDIMZ                      E:0000005C
DCB_OUTPOSX                      E:00000020
DCB_OUTPOSY                      E:00000024
DCB_OUTPOSZ                      E:00000028
DCB_SIZE                         E:00000084
DCB_UNIT                         E:00000080
DCODE68K                        00:0000AA24
DDATA                            E:FFFFFFF0
DEC311                          00:0000AA38
DEC404                          00:0000AA56
DEC411                          00:0000AA66
DEC425                          00:0000AA76
DEC510                          00:0000AA82
DEC515                          00:0000AA86
DEC530                          00:0000AA8E
DEC535                          00:0000AA94
DEC537                          00:0000AAA0
DEFLT                           00:000069A2
DEV_CLEAR                        E:0000000C
DEV_DRAW_CURVE                   E:0000001F
DEV_DRAW_LINE                    E:0000001C
DEV_DRAW_RECTANGLE               E:0000001E
DEV_DRAW_TRIANGLE                E:0000001D
DEV_GETBUF1                      E:00000010
DEV_GET_DIMEN                    E:00000014
DEV_GET_OUTPOS                   E:00000017
DEV_GET_OUTPTR                   E:00000018
DEV_HMASH                        E:56791123
DEV_PLOT_POINT                   E:0000001B
DEV_PUTCHAR                      E:00000002
DEV_SET_COLOR                    E:00000019
DEV_SET_COLOR_DEPTH              E:00000021
DEV_SET_DESTBUF                  E:00000022
DEV_SET_DIMEN                    E:00000020
DEV_SET_DISPBUF                  E:00000023
DEV_SET_OUTPOS                   E:00000007
DEV_SWAPBUF                      E:0000000D
DEV_WRITEAT                      E:00000012
DIRECT                          00:0000656C
DIRFLG                          00:00007A38
DISPBUF                         00:00006B7A
DIV1                            00:000072F2
DIV2                            00:000072F8
DIV3                            00:000072FE
DIV32                           00:000072E0
DIV4                            00:0000730C
DIVRT                           00:0000731A
DIVS_OUTER1                     00:00004F7A
DIVU_OUTER1                     00:00004F28
DOMID                           00:00007486
DOQUO                           00:000078BA
DOQUO1                          00:000078C2
DRAW                             E:0000A000
DRAWBUF                         00:00006B6A
DT_NUMERIC                       E:00000001
DT_STRING                        E:00000002
Delay3s                         00:0000264C
Delay3s2                        00:00002670
Diagonal1                       00:00007E46
Diagonal2                       00:00007E66
DisarmAllBreakpoints            00:00009CA8
DisarmBreakpoint                00:00009D82
DispatchMsg                     00:00009E88
DisplayAddr                     00:000095DA
DisplayByte                     00:00009590
DisplayChar                     external
DisplayHelp                     00:000084D6
DisplayMem                      00:00008E3A
DisplayNybble                   00:00009596
DisplaySpace                    00:0000957C
DisplayString                   00:00007B0C
DisplayStringCRLF               00:00007B22
DisplayStringLimited            00:00007B26
DisplayStringLimitedCRLF        00:00007B46
DisplayTetra                    00:00009584
DisplayTwoSpaces                00:0000956A
DisplayWyde                     00:0000958A
DrawHorizTo                     00:00007F60
DrawToXY                        00:00007EE2
DrawVertTo                      00:00007F92
DumpMem1                        00:00008E28
EA000                           00:0000A774
EA001                           00:0000A780
EA010                           00:0000A78C
EA011                           00:0000A7A0
EA011RTS                        00:0000A7B6
EA100                           00:0000A7B8
EA101                           00:0000A85A
EA1105                          00:0000A836
EA1107                          00:0000A83A
EA1109                          00:0000A850
EA111                           00:0000A870
EA1112                          00:0000A88E
EA1113                          00:0000A8AA
EA1113A                         00:0000A8BA
EA1114                          00:0000A8DC
EA1115                          00:0000A946
EA11153                         00:0000A97E
EA11155                         00:0000A988
EAF25                           00:0000A924
EAF27                           00:0000A928
EAF35                           00:0000A93C
EEA                             00:0000A7D2
EEA10                           00:0000A400
ENDCHK                          00:000075CA
ENDCHK1                         00:000075DA
ENDMEM                          00:000061F8
EOR_OUTER2                      00:000051A4
EOT                              E:00000004
ERROR                           00:000075E2
ESC                              E:0000001B
ETYPE                           00:0000762C
EX1                             00:000065A6
EXCEPTION_6                     00:00002774
EXCEPTION_7                     00:0000277C
EXEC                            00:0000657C
EXGO                            00:000065B2
EXLP                            00:00006584
EXMAT                           00:000065AC
EXNGO                           00:0000658E
EXP4RT                          00:00007036
EXPR                            00:00006DE4
EXPR2                           00:00006ED2
EXPR3                           00:00006FB0
EXPR4                           00:0000701A
EXPR_AND                        00:00006E0A
EXPR_OR                         00:00006DE4
EXPR_REL                        00:00006E48
E_BadDevNum                      E:00000020
E_Func                           E:00000002
E_InitErr                        E:00000027
E_NoDev                          E:00000021
E_NotAlloc                       E:00000009
E_NotSupported                   E:0000000A
E_Ok                             E:00000000
E_ReadError                      E:00000023
E_WriteError                     E:00000024
EditMemHelper                   00:0000894E
ExecuteCode                     00:000089CE
FDATA                            E:0000000A
FE10                            00:0000A7CE
FE11                            00:0000A8B6
FE12                            00:0000AA74
FERROR                          00:0000AAE6
FERROR35                        00:0000AAF0
FERROR39                        00:0000AAFC
FI1                             00:000075BC
FI2                             00:000075C8
FIN                             00:000075B0
FINISH                          00:0000678A
FMTK_SEMA                        E:00000008
FNDLN                           00:000076D0
FNDLNP                          00:000076DE
FNDNXT                          00:000076F6
FNDRET                          00:000076F4
FNDSKP                          00:000076F8
FOC                              E:0000001F
FOP                              E:00000027
FOR                             00:000067F8
FORM1                           00:0000A386
FORM10                          00:0000A442
FORM103                         00:0000A448
FORM104                         00:0000A44C
FORM105                         00:0000A45C
FORM10E3                        00:0000A426
FORM10E4                        00:0000A42E
FORM10E6                        00:0000A43A
FORM10EX                        00:0000A404
FORM11                          00:0000A476
FORM112                         00:0000A492
FORM114                         00:0000A4A0
FORM11SL                        00:0000A47E
FORM12                          00:0000A4A2
FORM125                         00:0000A4BC
FORM12A                         00:0000A4DE
FORM1A                          00:0000A38A
FORM3                           00:0000A390
FORM4                           00:0000A394
FORM5                           00:0000A3A6
FORM6A                          00:0000A3AA
FORM6D                          00:0000A3BA
FORM7                           00:0000A3E0
FORM8                           00:0000A3EC
FORM815                         00:0000A3F0
FORM9                           00:0000A3FA
FORM91                          00:0000A75C
FORM93                          00:0000A770
FORM95                          00:0000A772
FORMREG5                        00:0000A3CE
FORMREGA                        00:0000A3CA
FORMREGD                        00:0000A3DA
FORMSIZE                        00:0000A748
FR1                             00:00006812
FR2                             00:0000682A
FR3                             00:00006830
FR4                             00:00006836
FR5                             00:0000683E
FR6                             00:00006850
FR7                             00:0000685C
FR8                             00:00006874
FRAMEBUF                         E:FD208000
FRAMEBUF_BMPSIZE_X               E:00000068
FRAMEBUF_BMPSIZE_Y               E:0000006C
FRAMEBUF_CMDTBL                 00:000018E8
FRAMEBUF_COLOR_COMP              E:00000098
FRAMEBUF_CTRL                    E:00000000
FRAMEBUF_PAGE1_ADDR              E:00000010
FRAMEBUF_PAGE2_ADDR              E:00000018
FRAMEBUF_PPS                     E:000000B0
FRAMEBUF_WINDOW_DIMEN            E:00000078
FREL10                          00:0000A24A
FREL15                          00:0000A25C
FREL20                          00:0000A276
FREL25                          00:0000A288
FREL30                          00:0000A292
FRELADDR                        00:0000A23C
FemtikiInit                     00:00000220
FemtikiInitIRQ                  00:00000230
FemtikiTimerIRQ                 00:0000030E
ForceUnlockSemaphore            00:000025D0
FreeTCB                          E:0010030C
FromScreen                      00:00008148
GBYTE                           00:000069FA
GBYTE1                          00:000069FE
GBYTE2                          00:00006A0C
GETLN                           00:00007632
GFXACCEL                         E:FD210000
GFXACCEL_CMDTBL                 00:00001DA8
GFX_CLIP_PIXEL0_X                E:00000074
GFX_CLIP_PIXEL0_Y                E:00000078
GFX_CLIP_PIXEL1_X                E:0000007C
GFX_CLIP_PIXEL1_Y                E:00000080
GFX_COLOR0                       E:00000084
GFX_COLOR1                       E:00000088
GFX_COLOR2                       E:0000008C
GFX_COLOR_COMP                   E:000000D0
GFX_CTRL                         E:00000000
GFX_DEST_PIXEL_X                 E:00000038
GFX_DEST_PIXEL_Y                 E:0000003C
GFX_DEST_PIXEL_Z                 E:00000040
GFX_PPS                          E:000000D4
GFX_STATUS                       E:00000004
GFX_TARGET_BASE                  E:00000010
GFX_TARGET_SIZE_X                E:00000014
GFX_TARGET_SIZE_Y                E:00000018
GFX_TARGET_X0                    E:000000B0
GFX_TARGET_X1                    E:000000B8
GFX_TARGET_Y0                    E:000000B4
GFX_TARGET_Y1                    E:000000BC
GL1                             00:00007642
GL2                             00:00007660
GL3                             00:00007674
GL4                             00:00007698
GL5                             00:000076A4
GL6                             00:000076C0
GL7                             00:000076C8
GOAUXI                          00:000061EC
GOAUXO                          00:000061E8
GOBYE                           00:000061F0
GOIN                            00:000061E4
GOOUT                           00:000061E0
GOSUB                           00:00006792
GOTO                            00:00006694
GOWARM                          00:000061DC
GRBufferToScreen                00:00007D9E
GarbageCollectStrings           00:00007124
GetCmdLine                      00:00008712
GetDecNumber                    00:00008FCC
GetHexNumber                    00:00008F9E
GetKey                          00:00000898
GetRunningTCBPointer            00:000002AA
GetSzChar                       00:00008928
GetTick                         00:00007D04
GlobalReadLong                  00:000023FE
GlobalWriteLong                 00:00002404
GraphicsDemo                    00:00009822
HALT                             E:0000B000
HAS_MMU                          E:00000000
HEX2DEC                         00:0000A1C4
HEX2DEC2                        00:0000A176
HISPC                            E:FFFFFFFC
HOWMSG                          00:000079A3
HX2DC                           00:0000A1D4
HX2DC0                          00:0000A1D8
HX2DC1                          00:0000A1E0
HX2DC2                          00:0000A1FA
HX2DC22                         00:0000A1FC
HX2DC3                          00:0000A206
HX2DC4                          00:0000A20E
HX2DC5                          00:0000A216
HX2DC57                         00:0000A21E
HX2DC6                          00:0000A222
HelpMsg                         00:00008554
HomeCursor                      00:000014E2
I2C1                             E:FD250000
I2C2                             E:FDFE4000
I2C_CMD                          E:00000004
I2C_CTRL                         E:00000002
I2C_PREH                         E:00000001
I2C_PREL                         E:00000000
I2C_RXR                          E:00000003
I2C_STAT                         E:00000004
I2C_TXR                          E:00000003
IBSR                            00:0000A5EE
ICC                             00:0000A5EA
ICC35                           00:0000A600
ICC55                           00:0000A616
ICCCC                           00:0000A6B4
ICCCC9                          00:0000A6CA
IDBCC                           00:0000A5D8
IF                              00:000068E4
IF1                             00:000068E8
IF2                             00:000068EE
IGNBLK                          00:00007888
ILINK                           00:0000A370
IM7788                          00:0000A2AE
IM7799                          00:0000A2B2
IMMED                           00:0000A2F8
IMMED45                         00:0000A31E
IMMED55                         00:0000A352
IMMED65                         00:0000A358
IMMED75                         00:0000A368
IMOVE                           00:0000A36C
IMOVE19                         00:0000A712
IMOVEA1                         00:0000A6EC
IMOVEMFR                        00:0000A29A
IMOVEMTR                        00:0000A2C8
IMOVEP                          00:0000A574
IMOVEP11                        00:0000A584
IMOVEP35                        00:0000A5A0
IMOVEP66                        00:0000A5AE
IMOVEQ                          00:0000A50A
IMVFSR                          00:0000A52A
IMVFUSP                         00:0000A538
IMVT44                          00:0000A554
IMVTCCR                         00:0000A564
IMVTSR                          00:0000A546
IMVTUSP                         00:0000A558
INC                             00:00007916
INC1                            00:00007922
INCOM                           00:000065C4
INCON                           00:000065B6
INITMSG                         00:00007978
INPERR                          00:000068FE
INPPTR                          00:000079DC
INPUT                           00:0000690C
INT                             00:00007542
INT_EXPR                        00:00006DD2
IOCOM                           00:000065D2
IOCON                           00:000065E8
IOFocus                          E:00100000
IP2                             00:0000693E
IP3                             00:00006958
IP4                             00:00006992
IP5                             00:0000699E
IP6                             00:0000693A
IP7                             00:00006930
IQUICK                          00:0000A506
IQUICK21                        00:0000A72A
IQUICK31                        00:0000A740
IQUICKA                         00:0000A718
IRQFlag                          E:000400A0
IRQROUT                         00:00007A18
IRQ_trampolines                 01:00000100
ISCC                            00:0000A5CE
ISETD                           00:0000A626
ISETD12                         00:0000A62C
ISETS                           00:0000A636
ISHIFT                          00:0000A650
ISHIFT13                        00:0000A65C
ISHIFT23                        00:0000A680
ISHIFT33                        00:0000A68C
ISHIFT44                        00:0000A690
ISHIFTM1                        00:0000A69A
ISTOP                           00:0000A2E4
IncCursorPos                    00:000013FE
IncCursorRow                    00:00001418
InitIOPBitmap                   00:0000240C
InitIRQ                         00:00009F44
InitRand                        00:00002458
InitSemaphores                  00:00002588
Initialise                      00:0000C0EE
InitialisePlants                 S:000005E8
InputDevice                      E:000400A4
InstallIRQ                      00:00009F5C
JMPL                             E:0000E000
JSRL                             E:0000C000
KBD_CMDTBL                      00:00000610
KEYBD                            E:FDFF8000
KEYBD_SEMA                       E:00000003
KI                              00:0000AB10
KIEND                           00:0000AB12
KeybdEcho                        E:0004000C
KeybdGetChar                    00:000008F2
KeybdGetCharNoWait              00:000008E2
KeybdGetCharWait                00:000008EA
KeybdGetID                      00:0000066E
KeybdID                          E:00100018
KeybdIRQ                        00:00000B9E
KeybdInit                       00:000006D8
KeybdLEDs                        E:0010000E
KeybdRecvByte                   00:0000083C
KeybdSendByte                   00:00000B5E
KeybdSetLED                     00:000006AC
KeybdSetLEDStatus               00:00000B0E
KeybdWaitFlag                    E:0004000D
KeybdWaitTx                     00:0000085E
LEA1                            00:0000424A
LEFT                            00:000074E8
LEN                             00:0000751C
LET                             00:000069AA
LF                               E:0000000A
LINE                            00:00006C24
LINEERR                         00:00006C66
LINEERR1                        00:00006C6A
LINEERR2                        00:00006C70
LIST                            00:000066DC
LOAD                            00:000069BA
LOCVARSZ                         E:00000010
LOD1                            00:000069C6
LOD2                            00:000069E0
LODEND                          00:000069F0
LOPINC                          00:000079F8
LOPLMT                          00:00007A04
LOPLN                           00:00007A10
LOPPT                           00:00007A14
LOPVAR                          00:000079F4
LS1                             00:000066E8
LS2                             00:000066FC
LS3                             00:00006702
LSTROM                          00:000079D6
LT1                             00:000069B6
LastStr                         00:00007A28
ListBreakpoints                 00:00009DD6
LockSemaphore                   00:000025AE
LockSysSemaphore                00:00000396
LorR1                           00:0000741A
LorRArgs                        00:000073E2
MAX_TID                          E:00000FFF
MEMORY_SEMA                      E:00000006
MID                             00:0000741E
MID1                            00:000074E4
MID2                            00:00007466
MID4                            00:000074B2
MID5                            00:0000747E
MMU                              E:FDC00000
MOVE1                           00:00003EB8
MOVE2                           00:00003E3C
MOVE3                           00:00003F38
MOVE4                           00:00004092
MOVEMR                          00:0000A9A8
MOVEMR11                        00:0000A9B8
MOVEMR33                        00:0000A9C0
MOVEMR44                        00:0000A9D2
MOVEMR77                        00:0000A9EC
MOVEMR79                        00:0000A9FE
MOVEMR88                        00:0000AA00
MOVEMR94                        00:0000AA18
MOVEMS                          00:0000A994
MOVEMS2                         00:0000A9A4
MSG111                          00:0000AB06
MULS_OUTER1                     00:00005870
MULU_OUTER1                     00:00005824
MVDOWN                          00:0000771A
MVRET                           00:0000770E
MVUP                            00:00007706
MVUPW                           00:00007710
Monitor                         00:0000815C
MoveToXY                        00:00007ED4
NBCD_LOOP                       00:00004BEE
NBCD_LOOP1                      00:00004C34
NBCD_NO_C                       00:00004BFA
NBCD_NO_C1                      00:00004C48
NBCD_NO_Z                       00:00004BFE
NBCD_NO_Z1                      00:00004C4C
NCORES                           E:00000004
NEW                             00:000065FE
NEXT                            00:00006878
NOSTRING                        00:000079BA
NR_TCB                           E:00001000
NUM_EXPR                        00:00006DC4
NX0                             00:00006882
NX1                             00:000068C2
NX2                             00:000068DA
NX3                             00:00006894
NextRec                         00:000096D4
NextString                      00:00007160
Ninc0                           00:0000C182
Ninc1                           00:0000C182
NumSetBreakpoints                E:00040202
OFFSET                           E:00040880
OKMSG                           00:0000799C
ONIRQ                           00:000066A8
ONIRQ1                          00:000066C2
OPCTBL                          00:0000ADCA
OR_OUTER1                       00:00004FD0
OR_OUTER2                       00:00005044
OSCallTable                     00:0000023E
OUTC                            00:00007906
OUTCOM                          00:000065DC
OUTCON                          00:000065F2
OUTPTR                          00:000079E0
OutputChar                      00:00009F2A
OutputDevice                     E:000400A8
PARN                            00:000070B0
PBYTE                           00:00006A78
PBYTE1                          00:00006A7A
PBYTE2                          00:00006A8E
PEEK                            00:0000731C
PKER                            00:00006B0E
PLIC                             E:FD260000
PNT4HEX                         00:0000A228
PNT4HX                          00:0000A228
PNT6HX                          00:0000A22C
PNT8HX                          00:0000A238
POINT                           00:00006BFE
POINTERR                        00:00006C20
POKE                            00:00006A98
POPA                            00:00007722
PR0                             00:00006726
PR1                             00:00006734
PR2                             00:00006718
PR3                             00:00006742
PR6                             00:0000674E
PR8                             00:00006754
PR9                             00:00006770
PRINT                           00:00006708
PRMESG                          00:000078EE
PRMRET                          00:000078F8
PRNlword                         S:0000000A
PRTLN                           00:00007806
PRTNUM                          00:000077BC
PRTRET                          00:000077AE
PRTSTG                          00:00007794
PRTSTR2                         00:000077B6
PRTSTR2a                        00:000077B0
PS1                             00:00007796
PSG                              E:FD240000
PSG_CTRL                         E:00000005
PSG_FREQ                         E:00000000
PSG_MASTER_VOLUME                E:00000120
PSG_OUTPUT_SEL                   E:00000006
PSG_SUSTAIN                      E:00000014
PSG_VOICE_TYPE                   E:00000004
PUSHA                           00:0000775E
PeekScreenChar                  00:00008922
PointsIntoStringArea            00:000071BC
ProcessBreakpoint               00:00009CA2
ProcessRec                      00:000096E6
ProcessS1                       00:0000975C
ProcessS2                       00:00009760
ProcessS3                       00:00009764
ProcessS7                       00:00009798
ProcessS8                       00:000097A4
ProcessS9                       00:000097B0
Prompt1                         00:0000819E
Prompt3                         00:00008188
PromptLn                        00:0000817C
QHOW                            00:00007624
QSORRY                          00:0000761C
QWHAT                           00:000075DC
QueueCycle                       E:0010031C
RAND                             E:FDFF4010
RAND_MW                          E:FDFF401C
RAND_MZ                          E:FDFF4018
RAND_NUM                         E:FDFF4010
RAND_SEMA                        E:00000004
RAND_STRM                        E:FDFF4014
RANPNT                          00:000079D8
RECT                            00:00006C76
REL4                             E:00004000
REL5                             E:00005000
REL7                             E:00007000
REM                             00:000068E2
RETURN                          00:000067CC
RIGHT                           00:000074F4
RND                             00:00007384
ROXx_FLAGS                      00:00005B38
ROXx_LOOP1                      00:00005B4E
ROXx_LOOP2                      00:00005B6E
ROXx_LOOP3                      00:00005B8E
ROXx_LOOP4                      00:00005BAE
ROXx_LOOP5                      00:00005BCE
ROXx_LOOP6                      00:00005BF0
ROx_FLAGS                       00:00005902
ROx_LOOP1                       00:00005918
ROx_LOOP2                       00:00005938
ROx_LOOP3                       00:00005958
ROx_LOOP4                       00:00005978
ROx_LOOP5                       00:00005998
ROx_LOOP6                       00:000059BA
RST_REG                          E:FDFF0000
RTCBuf                           E:00100200
RTR_DONE                        00:00004C90
RTSL                             E:0000D000
RUN                             00:0000661A
RUN1                            00:0000666E
RUNNXL                          00:0000662E
RUNSML                          00:00006684
RUNTSL                          00:0000667A
RandGetNum                      00:000024C2
RandInit                        00:00002458
RandWait                        00:00002570
ReceiveMsg                      00:00009E46
Regsave                          E:00040100
RunningTCB                       E:00100224
S19Checksum                      E:00100150
S19Get16BitAddress              00:000097CE
S19Get24BitAddress              00:000097C4
S19Get32BitAddress              00:000097BC
S19GetByte                      00:0000973E
S19ProcTbl                      00:000096C8
S19StartAddress                  E:00040008
SAVE                            00:00006A1A
SAVE1                           00:00006A22
SAVE2                           00:00006A46
SAVEND                          00:00006A54
SBCD_INNER1                     00:00004B00
SBCD_INNER2                     00:00004B6E
SBCD_NO_C1                      00:00004B1C
SBCD_NO_C2                      00:00004B24
SBCD_NO_C3                      00:00004B8A
SBCD_NO_C4                      00:00004B92
SBCD_OUTER1                     00:00004AFE
SBCD_OUTER2                     00:00004B6C
SCHR                            00:0000A522
SCOMMON                         00:0000A5CA
SCREEN_FORMAT                    E:00000001
SCREEN_SEMA                      E:00000005
SC_ALT                           E:00000011
SC_CAPSLOCK                      E:00000058
SC_CTRL                          E:00000014
SC_EXTEND                        E:000000E0
SC_KEYUP                         E:000000F0
SC_LSHIFT                        E:00000012
SC_NUMLOCK                       E:00000077
SC_RSHIFT                        E:00000059
SC_SCROLLLOCK                    E:0000007E
SC_TAB                           E:0000000D
SERIAL_SEMA                      E:00000002
SETVAL                          00:00007590
SHIFTS2_FLAGS                   00:00005FB0
SHIFTS2_LOOP1                   00:00005FC6
SHIFTS2_LOOP2                   00:00005FE2
SHIFTS2_LOOP3                   00:00005FFE
SHIFTS2_LOOP4                   00:0000601A
SHIFTS2_LOOP5                   00:00006036
SHIFTS2_LOOP6                   00:00006054
SHIFTS_FLAGS                    00:00005D6E
SHIFTS_LOOP1                    00:00005D84
SHIFTS_LOOP2                    00:00005DA4
SHIFTS_LOOP3                    00:00005DC4
SHIFTS_LOOP4                    00:00005DE4
SHIFTS_LOOP5                    00:00005E04
SHIFTS_LOOP6                    00:00005E26
SHRT                             E:0000F000
SIV1                            00:00007194
SIZE                            00:000073BA
SPI_ADDR_158                     E:00000008
SPI_ADDR_2316                    E:00000009
SPI_ADDR_3124                    E:0000000A
SPI_ADDR_70                      E:00000007
SPI_DIRECT_ACCESS_DATA_REG       E:00000006
SPI_INIT_SD                      E:00000001
SPI_MASTER1                      E:FD280000
SPI_MASTER2                      E:FD284000
SPI_MASTER_CTRL_REG              E:00000001
SPI_RW_READ_SD_BLOCK             E:00000002
SPI_RW_WRITE_SD_BLOCK            E:00000003
SPI_RX_FIFO_CTRL_REG             E:00000014
SPI_RX_FIFO_DATA_REG             E:00000010
SPI_TRANS_CTRL_REG               E:00000003
SPI_TRANS_ERR_REG                E:00000005
SPI_TRANS_STS_REG                E:00000004
SPI_TRANS_TYPE_REG               E:00000002
SPI_TX_FIFO_CTRL_REG             E:00000024
SPI_TX_FIFO_DATA_REG             E:00000020
SRYMSG                          00:000079CC
ST3                             00:0000629C
ST4                             00:000062EE
START                           00:000061DA
STKFP                           00:000079E8
STKGOS                          00:000079EC
STKINP                          00:000079F0
STKLMT                          00:00007A34
STOP                            00:00006612
STRAREASIZE                      E:00000800
STRSTK                          00:00007A1C
SUBA_OUTER1                     00:000055C2
SUBQ_LOOP1                      00:00004E4E
SUBQ_LOOP2                      00:00004E88
SUBQ_LOOP3                      00:00004EBE
SUBX_LOOP3                      00:000057AC
SUBX_LOOP4                      00:000057C8
SUBX_LOOP5                      00:000057E4
SUBX_OUTER1                     00:00005718
SUB_OUTER1                      00:00005486
SUB_OUTER2                      00:000054FA
SV1                             00:000075AE
ScrollUp                        00:00001442
SelectThreadToRun               00:000002C2
SendMsg                         00:00009E08
SerHeadRcv                       E:00100162
SerHeadXmit                      E:00100168
SerRcvBuf                        E:00101000
SerRcvXoff                       E:00100165
SerRcvXon                        E:00100164
SerTailRcv                       E:00100160
SerTailXmit                      E:00100166
SerXmitBuf                       E:00102000
SerXmitXoff                      E:0010016A
SerialGetChar                   00:0000168A
SerialIRQ                       00:000017F8
SerialInit                      00:00001654
SerialPeekChar                  00:00001702
SerialPeekCharDirect            00:0000173E
SerialPutChar                   00:00001758
SerialPutCharDirect             00:000017BC
SerialRcvCount                  00:000017D8
SetDrawMode                     00:00007D28
SetKeyboardEcho                 00:00000884
SetPenColor                     00:00007D4A
ShiftBuf                        00:0000A15C
SimHardware                     00:00007CF4
SpuriousIRQ                     00:0000A014
StartMon                        00:00008152
StartQ                          00:00000172
StrArea                         00:00007A24
StrSp                           00:00007A20
StringInVar                     00:00007176
StringOnStack                   00:000071E0
StubRout                        00:00007FFA
SyncCursor                      00:000014F4
T15Abort                        00:00002628
T15DispatchTable                00:00007B64
T15FloatToString                00:00009ED0
T15GetFloat                     00:00002612
T15GetPixel                     00:00007D68
T15GetWindowSize                00:00007D88
T15LockSemaphore                00:00002606
T15Rectangle                    00:00007D56
T15UnlockSemaphore              00:0000260C
T15Wait100ths                   00:00007D0C
TAB1                            00:0000635C
TAB10                           00:00006442
TAB10_1                         00:00006554
TAB11                           00:00006445
TAB11_1                         00:0000655C
TAB12                           00:0000644A
TAB12_1                         00:00006564
TAB1_1                          00:00006454
TAB2                            00:0000638B
TAB2_1                          00:00006484
TAB4                            00:000063F9
TAB4_1                          00:000064EC
TAB5                            00:0000642B
TAB5_1                          00:00006520
TAB6                            00:0000642E
TAB6_1                          00:00006528
TAB8                            00:00006433
TAB8_1                          00:00006530
TAB9                            00:0000643E
TAB9_1                          00:0000654C
TBL                             00:0000AB12
TBLE                            00:0000ADCA
TC1                             00:00007836
TCBAffineChose                  00:000000A0
TCBAffinity                      E:00000084
TCBAffinityBase                  E:00000082
TCBAlloc                        00:0000006E
TCBEndTick                       E:00000070
TCBFree                         00:00000092
TCBHandleToPointer              00:00000028
TCBIAlloc                       00:00000050
TCBIFree                        00:0000007C
TCBInit                         00:00000000
TCBInsertIntoReadyQueue         00:000000D8
TCBNext                          E:0000007C
TCBPC                            E:00000050
TCBPointerToHandle              00:00000040
TCBPopReadyQueue                00:0000017A
TCBPrev                          E:00000080
TCBPriority                      E:00000055
TCBRegs                          E:00000004
TCBRemoveFromReadyQueue         00:00000150
TCBSR                            E:0000004C
TCBSSP                           E:00000048
TCBStartTick                     E:0000006C
TCBStatus                        E:00000054
TCBTicks                         E:00000074
TCBUSP                           E:00000044
TCB_SIZE                         E:00000100
TEXT                            00:00006B36
TEXTCOL                          E:00000034
TEXTERR                         00:00006B66
TEXTREG                          E:FD080000
TEXTROW                          E:00000020
TEXTVID_CMDTBL                  00:00000F54
TICK                            00:000073CA
TOUPB1                          00:00007898
TOUPBRT                         00:000078B8
TOUPBUF                         00:00007892
TOUPPER                         00:000078CA
TOUPRET                         00:000078DA
TRAP15                          00:00007B4A
TRIANGLE                        00:00006CBC
TRIERR                          00:00006D1C
TRIERR1                         00:00006D20
TRIERR2                         00:00006D26
TRIERR3                         00:00006D2C
TRIERR4                         00:00006D34
TSTC                            00:00007824
TSTNUM                          00:0000783C
TSTV                            00:0000725E
TSTVRT                          00:000072DE
TS_PREEMPT                       E:00000020
TS_RUNNING                       E:00000080
TV1                             00:000072A6
TV2                             00:000072D6
TXT                             00:00007A8C
TXTBGN                          00:000061F4
TXTUNF                          00:00007A2C
TYPMSG                          00:000079B2
TestBitmap                      00:00007DA6
TextCols                         E:0004008D
TextRows                         E:0004008C
TextScr                          E:00040004
TickIRQ                         00:00009FA0
TimeBuf                          E:000408E0
TimerStack                       E:00041BFC
USP1                            00:0000723C
UnlockSemaphore                 00:000025EA
UnlockSysSemaphore              00:000003A6
UpdateIRQLive                   00:000002EC
UpdateStringPointers            00:00007210
VARBGN                          00:00007A30
VIDEO_X                          E:00000558
VIDEO_Y                          E:00000300
Vertical1                       00:00007E90
Vertical2                       00:00007EAC
WAITIRQ                         00:000066CC
WHTMSG                          00:000079AA
WSTART                          00:00006268
Wait10ms                        00:00000B66
Wait300ms                       00:00000B82
X                               00:0000A29A
XOFF                             E:00000013
XON                              E:00000011
XP11                            00:00006E5C
XP12                            00:00006E68
XP13                            00:00006E74
XP14                            00:00006E80
XP15                            00:00006E8C
XP15RT                          00:00006E98
XP16                            00:00006E9A
XP17                            00:00006EB8
XP18                            00:00006EBE
XP21                            00:00006EE0
XP22                            00:00006EE6
XP23                            00:00006EEA
XP24                            00:00006EF8
XP25                            00:00006F26
XP26                            00:00006F2C
XP27                            00:00006F40
XP30                            00:00006FB6
XP31                            00:00006FC2
XP34                            00:00006FD8
XP35                            00:00006FF2
XP36                            00:00006FB2
XP40                            00:00007026
XP41                            00:00007038
XP42                            00:000070C0
XP43                            00:000070C2
XP44                            00:000070A4
XP45                            00:00007052
XPRT0                           00:00006EA8
XPRT1                           00:00006EB0
XPSTNG                          00:00007048
XP_AND                          00:00006E1A
XP_ANDX                         00:00006E30
XP_MOD                          00:00006FF8
XP_OR                           00:00006DF4
XP_ORX                          00:00006E30
XP_POP                          00:00006DA4
XP_POP1                         00:00006DB4
XP_PUSH                         00:00006D94
_CheckForCtrlC                  00:000008D2
_CheckNan                       00:0000903C
_CheckNegative                  00:000090BA
_CheckZero                      00:000090A0
_ComputeDigitsBeforeDecpt       00:00009114
_E                               E:0004050C
_ExtExpDigit                    00:00009238
_ExtExpDigits                   00:00009256
_FloatToString                  00:00009300
_GetExponent                    00:000093B8
_GetFloat                       00:000094B8
_GetFloatBackupChar             00:00009350
_GetFloatGetChar                00:00009342
_GetFloatIgnBlanks              00:00009348
_GetFraction                    00:00009354
_GetInteger                     00:00009442
_GetRand                        00:0000254C
_KeyState1                       E:0010000F
_KeyState2                       E:00100010
_KeybdBuf                        E:00100020
_KeybdClearIRQ                  00:00000826
_KeybdCnt                        E:00100013
_KeybdGetScancode               00:00000808
_KeybdGetStatus                 00:000007EA
_KeybdHead                       E:00100011
_KeybdInit                      00:000006D8
_KeybdOBuf                       E:00100080
_KeybdTail                       E:00100012
_Keybd_tick                      E:0001001C
_LeadingZero                    00:0000914E
_LessThanDbl                    00:000090E8
_MakeBig                        00:000090CC
_PadLeft                        00:0000927E
_PadRight                       00:000092CE
_SpitOutDigits                  00:0000915E
_SpitOutE                       00:00009220
_TrimDotZero                    00:000091F8
_TrimTrailingPoint              00:000091DA
_TrimTrailingZeros              00:00009214
_canary                          E:00040098
_dasmbuf                         E:00040800
_dfMil                          00:00009028
_dfOne                          00:00009010
_dfTen                          00:0000901C
_digits_before_decpt             E:00040510
_fpBuf                           E:00040520
_fpTextIncr                      E:00040094
_fpWork                          E:00040600
_keybdControlCodes              00:00000E54
_keybdExtendedCodes             00:00000ED4
_msgInf                         00:00009038
_msgNan                         00:00009034
_precision                       E:00040514
_shiftedScanCodes               00:00000D54
_unshiftedScanCodes             00:00000C54
_width                           E:00040508
a_was_less                      00:0000BF82
add_address                     00:0000C0AA
add_char_loop                   00:0000C052
add_character                   00:0000B5EE
add_coords                      00:0000C0C0
add_explode                     00:0000BB28
add_fire                        00:0000BB34
add_hex_chr                     00:0000C090
add_item                        00:0000BB0E
add_message                     00:0000C00A
add_p_size                      00:0000B0F2
add_pair                        00:0000C0DC
add_play_explode                00:0000BC4C
add_player                      00:0000BCF2
add_saucer                      00:0000BB2E
add_score                       00:0000BB46
add_ships                       00:0000B5FE
add_ships_loop                  00:0000B61A
add_single                      00:0000C0DA
add_sup_hex_chr                 00:0000C084
add_sup_zero                    00:0000C09A
add_the_char                    00:0000C068
add_to_list                     00:0000BADA
add_to_score                    00:0000BDD4
addr_err                        00:0000A028
aim_shot                        00:0000B2B0
animal_colour                    S:00000014
animal_fill                      S:00000018
animal_flag                      S:000001EE
animal_spawn                     S:00000221
animal_xy                        S:00000126
asteroids_start                 00:0000AECA
atn_eight                       00:0000BEEE
atn_quad                        00:0000BEDE
atn_semi                        00:0000BECE
atn_tab                         00:0000BF0C
attract_fire                    00:0000B28C
attract_saucer                  00:0000B1DA
beat1_snd                        E:00000008
beat1_sound                     00:0000DD36
beat2_snd                        E:00000009
beat2_sound                     00:0000DD48
bkColor                          E:00040088
brdisp_trap                     00:0000A03E
bus_err                         00:00009C4A
calc_fire_byte                  00:0000B39E
char_1                          00:0000D872
char_2                          00:0000D87A
char_3                          00:0000D88A
char_4                          00:0000D898
char_5                          00:0000D8A6
char_6                          00:0000D8B4
char_7                          00:0000D8C2
char_8                          00:0000D8CC
char_9                          00:0000D8DC
char_a                          00:0000D706
char_b                          00:0000D716
char_c                          00:0000D730
char_d                          00:0000D73C
char_e                          00:0000D74C
char_f                          00:0000D75C
char_g                          00:0000D76A
char_h                          00:0000D77C
char_i                          00:0000D78A
char_j                          00:0000D798
char_k                          00:0000D7A4
char_l                          00:0000D7B0
char_m                          00:0000D7BA
char_n                          00:0000D7C6
char_o0                         00:0000D7D0
char_p                          00:0000D7DC
char_q                          00:0000D7EA
char_r                          00:0000D7FC
char_s                          00:0000D80C
char_set                        00:0000D8EA
char_spc                        00:0000D86E
char_t                          00:0000D81A
char_u                          00:0000D826
char_v                          00:0000D832
char_w                          00:0000D83C
char_x                          00:0000D84A
char_y                          00:0000D854
char_z                          00:0000D862
check_all                       00:0000B09C
check_alpha                     00:0000B50A
check_clear                     00:0000B82E
check_clear_loop                00:0000B832
check_clear_y                   00:0000B84C
check_for_food                   S:000004AA
check_hi_loop                   00:0000BE40
check_hi_next                   00:0000BE4E
check_hi_player                 00:0000BE38
check_hiscores                  00:0000BE1C
check_hits                      00:0000B07C
check_neg_velocity              00:0000B822
check_next_object               00:0000B098
check_pss                       00:0000B08A
check_velocity                  00:0000B814
chk_exception                   00:00002638
clear_graphics_screen           00:00001CE4
clear_graphics_screen2          00:00008AF0
clear_hyper                     00:0000B766
clear_items_loop                00:0000B5C6
clear_loop                      00:0000C116
clear_rock                      00:0000BDC0
clear_rocks                     00:0000B90C
clear_rocks_loop                00:0000B90E
clear_saucer                    00:0000B706
close_all                       00:0000B47A
close_all_2                     00:0000C16C
clr_animals_loop                 S:00000398
clr_plant_loop                   S:00000384
cmdAsteroids                    00:00008264
cmdBreakpoint                   00:00008240
cmdClearScreen                  00:00008372
cmdClock                        00:00008466
cmdCore                         00:0000837E
cmdDisassemble                  00:00008DB4
cmdDispatch                     00:000081B8
cmdDumpMemory                   00:00008E04
cmdDumpRegs                     00:00008ED0
cmdEditMemory                   00:00008970
cmdFMTK                         00:000083A2
cmdFillB                        00:0000881A
cmdFillL                        00:000088C2
cmdFillW                        00:0000886E
cmdGrDemo                       00:000089DE
cmdHelp                         00:000084D6
cmdJump                         00:000089CE
cmdLoadS19                      00:000096C2
cmdMonitor                      00:0000815C
cmdPlants                       00:0000826C
cmdReceiveSerial                00:000087E6
cmdReset                        00:00008484
cmdSendSerial                   00:000087B6
cmdSetTime                      00:00008274
cmdString                       00:00008074
cmdTable                        00:000080C8
cmdTestCPU                      00:00008362
cmdTestFP                       00:000083AC
cmdTestGF                       00:00008438
cmdTestRAM                      00:000095FA
cmdTestSD                       00:000084E2
cmdTestSerialReceive            00:00008F7A
cmdTime                         00:000082E2
cmdTinyBasic                    00:0000835E
cmdVideoMode                    00:000081FE
col_table                       00:0000B102
col_table_l                     00:0000B11A
col_table_p                     00:0000B10A
col_table_s                     00:0000B112
copy_msg                        00:0000D2CE
copy_rock                       00:0000B964
copy_rock_2                     00:0000B968
copy_short                      00:0000BD44
copy_vectors                    00:0000BD48
copy_velocity                   00:0000B98E
cos_d0                          00:0000BF6A
cossin_d0                       00:0000BF7C
cpu_test                        00:0000268C
d_mess_0                        00:0000DA3A
d_mess_1                        00:0000DA4A
d_mess_2                        00:0000DA53
d_mess_3                        00:0000DA7A
d_mess_4                        00:0000DA9D
d_mess_5                        00:0000DAC0
d_mess_6                        00:0000DAE6
d_mess_7                        00:0000DAFC
d_messages                      00:0000DA2A
dccr                            00:000012B0
dclf                            00:00001384
dcx10                           00:00001318
dcx11                           00:0000133A
dcx12                           00:00001330
dcx14                           00:000012A4
dcx16                           00:00001388
dcx4                            00:0000138C
dcx6                            00:000012CE
dcx7                            00:000012A8
dcx8                            00:000012E4
dcx9                            00:000012FA
dec_isaucer_time                00:0000B202
def_a_spawn                      E:00000005
def_animal                       E:00FFFFFF
def_animals                      E:00000032
def_back                         E:00000000
def_leaf                         E:00008000
def_p_spawn                      E:00000001
def_plant                        E:008080FF
def_plants                       E:00000032
delta_x                          S:0000057E
delta_x_pos                     00:0000B0B6
delta_y                          S:00000590
delta_y_pos                     00:0000B0C8
dly3s1                          00:0000265C
dly3s2                          00:0000265A
doBackspace                     00:00001396
doCtrlX                         00:000013DA
doDelete                        00:000013A4
do_animals                       S:000003F6
do_nothing                      00:0000053E
do_p1_ships                     00:0000BA42
do_p2_score                     00:0000BAB6
do_plants                        S:000003C0
do_saucer                       00:0000B1AE
do_start_mess                   00:0000AF7A
do_things                        S:0000042A
do_things_loop                   S:00000484
do_vector                       00:0000C184
draw_old_thing                   S:00000524
dspj1                           00:00007B10
dspmem1                         00:00008E66
dspspc1                         00:00009574
dsret                           00:00007B1C
e_mess_0                        00:0000D980
e_mess_1                        00:0000D98C
e_mess_2                        00:0000D994
e_mess_3                        00:0000D9B6
e_mess_4                        00:0000D9D1
e_mess_5                        00:0000D9EE
e_mess_6                        00:0000DA15
e_mess_7                        00:0000DA20
e_messages                      00:0000D970
edtmem1                         00:0000897A
end_game                        00:0000B068
end_main_loop                    S:000002E2
end_vector                      00:0000C272
enter_hiscores                  00:0000B3C4
err_cmdproc                     00:00001564
err_dcb                          E:00040B8C
err_init                        00:00001536
err_ret                         00:00001562
existing_saucer                 00:0000B268
exit_add_message                00:0000C070
exit_add_score                  00:0000BB74
exit_add_ships                  00:0000B626
exit_check_hiscores             00:0000BE7C
exit_check_velocity             00:0000B82C
exit_copy_vectors               00:0000BD62
exit_do_saucer                  00:0000B266
exit_do_things                   S:00000530
exit_enter_hiscores             00:0000B518
exit_existing_saucer            00:0000B292
exit_find_rock                  00:0000BC32
exit_game_message               00:0000B066
exit_hi_chk                     00:0000BE72
exit_high_scores                00:0000BC1A
exit_hit_a_rock                 00:0000BE16
exit_hyperspace                 00:0000B5A8
exit_insert_loop                00:0000BEA4
exit_limit_velocity             00:0000B9E8
exit_make_rocks                 00:0000B916
exit_neighbour                   S:00000578
exit_no_scores                  00:0000BC20
exit_not_done                   00:0000B516
exit_play_sample                00:0000DD1C
exit_push_start                 00:0000AFE8
exit_ship_fire                  00:0000B34A
exit_ship_move                  00:0000B76A
exit_static                     00:0000BAD8
exit_test_escape                 S:0000031E
expl_0                          00:0000D3B6
expl_1                          00:0000D380
expl_2                          00:0000D342
expl_3                          00:0000D316
expl_tab                        00:0000D30E
expl_x_pos                       S:0000005B
expl_y_pos                       S:00000067
explode_object                  00:0000B168
extra_snd                        E:0000000A
extra_sound                     00:0000DD99
f_mess_0                        00:0000DB16
f_mess_1                        00:0000DB25
f_mess_2                        00:0000DB2C
f_mess_3                        00:0000DB50
f_mess_4                        00:0000DB69
f_mess_5                        00:0000DB8B
f_mess_6                        00:0000DBB4
f_mess_7                        00:0000DBC6
f_messages                      00:0000DB06
f_xpos_off                       E:FFFFFFBA
f_xvel_off                       E:0000004C
f_ypos_off                       E:00000000
f_yvel_off                       E:0000006F
fgColor                          E:00040084
filename                        00:0000DE10
fill_colour                      S:00000020
fill_old_thing                   S:00000526
find_next_rock                  00:0000BC28
find_rock                       00:0000BC26
fire_ok                         00:0000B3BA
fire_saucer                     00:0000B298
fire_shot                       00:0000B34C
first_quad                      00:0000BD1C
flag_end                         E:0000002F
flags_off                        E:0000000C
food_colour                      S:00000024
fpBuf                            E:000402C0
framebuf_clear                  00:00001D14
framebuf_cmdproc                00:00001930
framebuf_dcb                     E:00040D18
framebuf_get_color              00:00001B4C
framebuf_get_dimen              00:00001B5C
framebuf_getbuf                 00:00001B3C
framebuf_getbuf1                00:00001AA0
framebuf_getbuf2                00:00001AA8
framebuf_getchar                00:00001A7C
framebuf_init                   00:000019D0
framebuf_putbuf                 00:00001B3C
framebuf_putchar                00:00001A7C
framebuf_set_color_depth        00:00001B40
framebuf_set_destbuf            00:00001A7C
framebuf_set_dimen              00:00001B8C
framebuf_set_dispbuf            00:00001B24
framebuf_set_inpos              00:00001A80
framebuf_set_outpos             00:00001A90
framebuf_set_unit               00:00001B30
framebuf_setbuf1                00:00001AB0
framebuf_setbuf2                00:00001AC0
framebuf_stat                   00:00001A7C
framebuf_stub                   00:00001B3C
framebuf_swapbuf                00:00001AD0
framebuf_writeat                00:00001BF0
fx_sounds                       00:0000BD64
game_count                       S:00000059
game_message                    00:0000AF66
game_over                       00:0000AFEA
gen_prng                        00:0000C172
gen_rock_loop                   00:0000B8B6
get_atn                         00:0000BEC2
get_direction                    S:0000065C
get_prng                         S:0000065E
get_screen_address              00:00007AE0
get_screen_color                00:0000123C
get_time                        00:000082F4
gfxaccel_clear                  00:00001FBA
gfxaccel_clip_rect              00:000020C6
gfxaccel_cmdproc                00:00001E38
gfxaccel_ctrl                    E:000408C0
gfxaccel_dcb                     E:00040D9C
gfxaccel_draw_curve             00:000022E0
gfxaccel_draw_line              00:00002188
gfxaccel_draw_rectangle         00:000021F0
gfxaccel_draw_triangle          00:00002258
gfxaccel_get_color              00:00002060
gfxaccel_get_dimen              00:00001F56
gfxaccel_get_inpos              00:00001F56
gfxaccel_get_outpos             00:00001F56
gfxaccel_get_outptr             00:00001F56
gfxaccel_getbuf                 00:00001F56
gfxaccel_getbuf1                00:00001F56
gfxaccel_getbuf2                00:00001F56
gfxaccel_getchar                00:00001F56
gfxaccel_init                   00:00001EE6
gfxaccel_plot_point             00:00002136
gfxaccel_putbuf                 00:00001F56
gfxaccel_putchar                00:00001F56
gfxaccel_set_active_point       00:0000210A
gfxaccel_set_color              00:0000206E
gfxaccel_set_color123           00:0000208E
gfxaccel_set_color_depth        00:0000204E
gfxaccel_set_destbuf            00:00001F8E
gfxaccel_set_dimen              00:00001F5A
gfxaccel_set_dispbuf            00:00001F56
gfxaccel_set_inpos              00:00001F56
gfxaccel_set_outpos             00:00001F56
gfxaccel_set_unit               00:00001F56
gfxaccel_setbuf1                00:00001F56
gfxaccel_setbuf2                00:00001F56
gfxaccel_stat                   00:00001F48
gfxaccel_stub                   00:00001F56
gfxaccel_swapbuf                00:00001F56
gfxaccel_wait                   00:00002366
gfxaccel_writeat                00:00001F56
glob_scale                       S:00000000
go_reset_play                   00:0000B66A
go_reset_sauc                   00:0000B670
goodbye_message                  S:000002FA
gr_double_buffer                 E:000408AC
gr_height                        E:000408A0
gr_width                         E:0004089C
gr_x                             E:00040894
gr_y                             E:00040898
gthx3                           00:00009566
gthx5                           00:00009542
gthx6                           00:00009554
handle_collision                00:0000B122
height                           S:00000006
hi_char                          S:00000020
hide_p_cnt                       E:0000007A
high_idx                         S:00000017
high_off                         E:00000083
high_scores                     00:0000BB7A
high_scores_loop                00:0000BBAC
hinames                          S:0000003B
hiscore_y                        S:00000012
hiscores                         S:00000027
hit_a_rock                      00:0000BDA6
hype_xok1                       00:0000B556
hype_xok2                       00:0000B560
hype_yok1                       00:0000B57E
hype_yok2                       00:0000B588
hyper                            S:00000026
hyperspace                      00:0000B51A
i2c_disable                     00:00009A90
i2c_enable                      00:00009A88
i2c_get_status                  00:00009AB0
i2c_read                        00:00009AC4
i2c_read_ack                    00:00009AB6
i2c_read_stop                   00:00009AA6
i2c_setup                       00:00009A7A
i2c_wait_rx_nack                00:00009AF8
i2c_wait_tip                    00:00009A96
i2c_wr_cmd                      00:00009ACA
i2c_xmit1                       00:00009ADA
i_rk_count                       E:00000075
i_sauc_tim                       E:00000078
icc1                            00:00001440
ignBlanks                       00:00008910
illegal_trap                    00:0000A076
init_i2c                        00:00009A7A
init_plic                       00:0000803E
init_spi                        00:00009834
init_world                       S:00000320
insert_hiscore                  00:0000BE7E
insert_loop                     00:0000BE82
io_irq                          00:0000A08C
io_trap                         00:00009F04
irq3_rout                       00:00009FE2
irq6_rout                       00:00009FE2
irq_list_tbl                     A:00000400
irq_proc_generic                00:00009FF6
irq_rout                        00:00009FE2
is_closer                       00:0000B86A
is_food                          S:000004DA
item_exploding                  00:0000B678
kbdi0002                        00:00000704
kbdi0004                        00:0000077C
kbdi0005                        00:00000798
kbdiTryAgain                    00:0000076E
kbdiXmitBusy                    00:000007B2
keep_saucer_dir                 00:0000B280
keep_scale                      00:0000B6F8
keep_small                      00:0000B1A8
keybd_cmdproc                   00:00000630
keybd_dcb                        E:00040A84
keybd_getbuf                    00:0000066A
keybd_getchar                   00:00000662
keybd_init                      00:0000058C
keybd_putbuf                    00:0000066A
keybd_putchar                   00:0000065A
keybd_set_inpos                 00:0000066A
keybd_set_outpos                00:0000066A
keybd_stat                      00:00000652
kgid1                           00:000006A0
kgnotKbd                        00:000006A8
kill_the_player                 00:0000B750
kill_thing                       S:000004CA
last_fire                        S:00000021
last_hype                        S:00000022
last_vector                     00:0000C280
leds                             E:FDFFC000
ledxit                          00:0000079C
lexpl_snd                        E:00000007
lexpl_sound                     00:0000DD5A
lgsau_snd                        E:00000004
lgsau_sound                     00:0000DDAF
limit_p_vel                     00:0000B9D8
limit_velocity                  00:0000B9C4
load_old_sound                  00:0000DCF8
load_sound                      00:0000DCF2
local_x                          S:00000002
local_y                          S:00000004
loop1                           00:00000506
loop2                           00:00000504
loop3                           00:0000121E
loop_atn                        00:0000BEF2
m_w                              E:000408D4
m_z                              E:000408D0
main_loop                       00:0000AED2
make_rocks                      00:0000B870
max_animals                      S:0000000E
max_plants                       S:0000000A
memend                           E:00100004
mess_origin                     00:0000D948
mess_table                      00:0000D968
mexpl_snd                        E:00000006
mexpl_sound                     00:0000DD6F
min_rocks                        E:0000007D
move_item                       00:0000B692
move_items                      00:0000B628
move_next_item                  00:0000B62C
move_next_object                00:0000B6FE
msgAddrErr                      00:0000A0D8
msgBadKeybd                     00:000007C0
msgBusErr                       00:00009C39
msgChk                          00:0000A134
msgHello                        00:00008701
msgRtcReadFail                  00:00009C20
msgStackCanary                  00:0000A142
msgUnknownCmd                   00:000086F1
msgXmitBusy                     00:000007CF
msg_bad_branch_disp             00:0000A0F7
msg_core_start                  00:0000A0C7
msg_illegal                     00:0000A0E5
msg_io_access                   00:0000A119
msg_reglist                     00:00008F54
msg_regs                        00:00008F50
msg_start                       00:0000A0A0
msg_test_done                   00:0000A109
nd1                             00:00002408
nd2                             00:00002408
nd3                             00:00002408
nd4                             00:00002408
neg_upper_ok                    00:0000B9CE
neighbour                        S:00000532
net_delay                       00:00002408
new_rocks                        E:0000007B
new_thing_loop                   S:00000504
next_hi_char                    00:0000B492
next_m_w                         E:000408DC
next_m_z                         E:000408D8
next_p_high                     00:0000B45E
next_pss                        00:0000B084
next_thing                       S:0000052C
nmeSerial                       00:000018E0
nmi_rout                        00:0000A016
no_add_size                     00:0000B0F4
no_aim_shot                     00:0000B306
no_dec_new_rocks                00:0000AF56
no_game_over                    00:0000B028
no_inc_min                      00:0000B89A
no_neg_x10                      00:0000C1EC
no_neg_x11                      00:0000C1C2
no_neg_x2                       00:0000C26E
no_neg_y10                      00:0000C1E0
no_neg_y11                      00:0000C1B6
no_neg_y2                       00:0000C266
no_new_rocks                    00:0000B662
no_play                         00:0000AF38
no_playerx                      00:0000B3F2
no_pos_reflect                  00:0000BD08
no_reset_scale                  00:0000B690
no_reset_xy                     00:0000BC76
no_saucer_sound                 00:0000BD72
no_save_ist                     00:0000B212
no_set_max                      00:0000B8AA
no_shot_dec                     00:0000BB44
no_shot_or                      00:0000B302
no_thrust                       00:0000BD42
no_thump_sound                  00:0000BDA4
nodec_thmpi                     00:0000AFFE
notRxInt                        00:00001880
notTxInt                        00:000018CE
not_closer                      00:0000B860
not_player                      00:0000B140
not_pss_player                  00:0000B158
not_right                       00:0000C1FE
not_rot_left                    00:0000B4DC
not_rot_left1                   00:0000B778
not_rot_right1                  00:0000B780
not_rot_right2                  00:0000B4E4
not_saucer                      00:0000B132
not_thrust                      00:0000B7DE
not_timed_out                   00:0000B4C0
not_x_max                       00:0000B6B4
not_y_max                       00:0000B6D4
notscreen                       00:0000C0E2
null_cmdproc                    00:00000588
null_dcb                         E:00040A00
null_init                       00:00000544
null_ret                        00:00000586
numBreakpoints                   E:00000008
num_animals                      S:0000000C
num_plants                       S:00000008
num_players                      S:0000001A
old_sound_play                  00:0000DD1A
op_ABCD                         00:000049E6
op_ADD                          00:0000537C
op_ADDA                         00:00005550
op_ADDQ                         00:00004D7C
op_ADDX                         00:000055E8
op_ADD_I                        00:00003A64
op_AND                          00:0000509A
op_ANDI_TO_CCR                  00:00002814
op_ANDI_TO_SR                   00:0000283A
op_BCC                          00:00004CA6
op_BCHG                         00:00002C0A
op_BCLR                         00:00002F72
op_BOOL_I                       00:00003694
op_BSET                         00:000032C0
op_BSR                          00:00003846
op_BTST                         00:00002860
op_BTST0                        00:000029EA
op_BTST1                        00:000029F6
op_BTST10                       00:00002A3E
op_BTST11                       00:00002A46
op_BTST12                       00:00002A4C
op_BTST2                        00:000029FE
op_BTST20                       00:00002BA4
op_BTST21                       00:00002BAE
op_BTST22                       00:00002BB4
op_BTST23                       00:00002BBA
op_BTST24                       00:00002BC0
op_BTST25                       00:00002BC6
op_BTST26                       00:00002BCC
op_BTST27                       00:00002BD2
op_BTST28                       00:00002BD8
op_BTST29                       00:00002BDE
op_BTST3                        00:00002A06
op_BTST30                       00:00002BE4
op_BTST31                       00:00002BEA
op_BTST32                       00:00002BEE
op_BTST4                        00:00002A0E
op_BTST5                        00:00002A16
op_BTST6                        00:00002A1E
op_BTST7                        00:00002A26
op_BTST8                        00:00002A2E
op_BTST9                        00:00002A36
op_CHK                          00:000042F0
op_CMP                          00:000051FA
op_CMPA                         00:00005270
op_CMPM                         00:000052D6
op_CMP_I                        00:0000387C
op_DBCC                         00:00004D26
op_DIVS                         00:00004F5E
op_DIVU                         00:00004F0C
op_EOR                          00:00005184
op_EORI_TO_CCR                  00:000027C8
op_EORI_TO_SR                   00:000027EE
op_EXG                          00:000058A0
op_EXT                          00:00004170
op_LEAPEA                       00:000041B2
op_LINKS                        00:000042C2
op_MOVE                         00:00003D70
op_MOVEM                        00:000046C8
op_MOVEP                        00:00003608
op_MOVEQ                        00:00004EF0
op_MOVE_USP                     00:000042E0
op_MOVE_xxx_FLAGS               00:00003F7C
op_MULS                         00:00005854
op_MULU                         00:00005808
op_NBCD                         00:00004BD6
op_NEGS                         00:0000433A
op_OR                           00:00004FB0
op_ORI_TO_CCR                   00:00002784
op_ORI_TO_SR                    00:000027A6
op_ROXx                         00:00005B44
op_ROx                          00:0000590E
op_RTR                          00:00004C84
op_SBCD                         00:00004ADE
op_SCC                          00:00004D4C
op_SHIFTS                       00:00005D7A
op_SHIFTS2                      00:00005FBC
op_SUB                          00:00005466
op_SUBA                         00:0000559C
op_SUBQ                         00:00004E36
op_SUBX                         00:000056F8
op_SUB_I                        00:00003BEA
op_SWAP                         00:0000419C
op_TAS                          00:0000425E
op_TRAPV                        00:00004C68
op_TST                          00:00004284
op_abs                          00:0000C1D2
op_call                         00:0000C192
op_jump                         00:0000C198
op_rtsvec                       00:0000C182
op_short                        00:0000C242
op_vctr                         00:0000C1A8
output_number                   00:0000BF4C
output_number_loop              00:0000BF4E
p1_high                          S:00000176
p1_score                         S:00000173
p1_ships                         S:00000175
p2_high                          S:0000027A
p2_score                         S:00000277
p2_ships                         S:00000279
p_2_end                          S:0000027B
p_fire_off                       E:0000002B
p_flag_off                       E:00000027
p_orient                         S:0000001E
p_xpos_off                       E:FFFFFFB6
p_xvel_off                       E:0000004A
p_xvlo_off                       E:0000007E
p_ypos_off                       E:FFFFFFFC
p_yvel_off                       E:0000006D
p_yvlo_off                       E:0000007F
past_play                        S:00000019
pcssxa                          00:00009766
pen_color                        E:00040890
pfire_snd                        E:00000001
pfire_sound                     00:0000DDEC
piece_draw_loop                 00:0000BC80
plant_colour                     S:00000010
plant_fill                       S:00000012
plant_flag                       S:000000F4
plant_spawn                      S:00000220
plant_xy                         S:0000002C
plants_main_loop                 S:00000294
play_00                         00:0000D4A6
play_01                         00:0000D4BE
play_02                         00:0000D4E2
play_03                         00:0000D506
play_04                         00:0000D52A
play_05                         00:0000D54C
play_06                         00:0000D570
play_07                         00:0000D594
play_08                         00:0000D5B8
play_09                         00:0000D5DC
play_0A                         00:0000D600
play_0B                         00:0000D624
play_0C                         00:0000D648
play_0D                         00:0000D66C
play_0E                         00:0000D690
play_0F                         00:0000D6B4
play_10                         00:0000D6D8
play_liv                        00:0000D6F0
play_sample                     00:0000DCFE
play_sound                       S:00000015
play_tab                        00:0000D484
player_1                         E:000000F3
player_2                         E:000001F7
player_idx                       S:00000018
player_init                     00:0000B918
player_n                        00:0000C07C
player_reset                    00:0000B94E
player_shot                     00:0000B184
player_x                        00:0000C078
plot                            00:00001BF0
plot_and                        00:00001CAC
plot_black                      00:00001CCE
plot_copy                       00:00001CC0
plot_or                         00:00001C82
plot_rand_points                00:00008A72
plot_sw                         00:00001C5C
plot_white                      00:00001CD8
plot_xor                        00:00001C96
plottbl                         00:00001C20
pnotscreen                       S:000006AA
poison_colour                    S:00000028
pos_lower_ok                    00:0000B9E0
prng                            00:000024F2
prtflt                          00:00009E8A
psetscreen                       S:00000698
pss_check_loop                  00:0000B07E
push_start_mess                 00:0000AFD2
pvariables                       S:000006AC
px_hide                         00:0000AF30
px_time                          S:0000001C
quit                             S:00000000
r_hit_tim                        E:00000079
ramtest                         00:000095FA
ramtest0                        00:00009644
ramtest1                        00:0000964C
ramtest2                        00:0000967A
ramtest3                        00:000096C0
ramtest6                        00:0000966A
rand_curve                      00:00008D3C
rand_lines                      00:00008BBA
rand_points                     00:00008B84
rand_rect                       00:00008C1A
rand_rect2                      00:00008C7A
rand_triangle                   00:00008CC4
rbo                             00:0000982C
read_hi                         00:0000C162
readyQ                           E:00100320
redraw                           S:00000002
reset_game                      00:0000B5AA
reset_xy_loop                   00:0000BC5E
restart                          S:00000288
reveal_player                   00:0000B748
rmtst1                          00:0000965E
rmtst2                          00:00009692
rmtst3                          00:0000969A
rmtst5                          00:00009614
rock_0                          00:0000D3FC
rock_1                          00:0000D414
rock_2                          00:0000D430
rock_3                          00:0000D44A
rock_count                       E:00000076
rock_hit_out                    00:0000B1E4
rock_on_x                       00:0000B8EA
rock_score                      00:0000BE18
rock_tab                        00:0000D3F4
rock_y_ok                       00:0000B8E8
rot_and_thrust                  00:0000B76C
rot_not_left                    00:0000B4E4
rotate_iofocus                  00:0000800E
rtc_read                        00:00009B08
rtc_write                       00:00009B92
sGetChar                        00:000097E2
s_controls                      00:0000C0E2
s_fire_off                       E:00000029
s_flag_off                       E:00000028
s_key                            S:00000014
s_mess_0                        00:0000DBE4
s_mess_1                        00:0000DBEC
s_mess_2                        00:0000DBF5
s_mess_3                        00:0000DC1C
s_mess_4                        00:0000DC3A
s_mess_5                        00:0000DC62
s_mess_6                        00:0000DC74
s_mess_7                        00:0000DC81
s_messages                      00:0000DBD4
s_orient                         S:0000001F
s_xpos_off                       E:FFFFFFB8
s_xvel_off                       E:0000004B
s_ypos_off                       E:FFFFFFFE
s_yvel_off                       E:0000006E
sauc_cntdn                       E:00000077
sauc_jsr                        00:0000D466
sauc_vec                        00:0000D468
saucer_yok                      00:0000B224
saucer_yvel                     00:0000B294
save_char                       00:0000B512
save_hbutton                    00:0000B4AA
save_hi_index                   00:0000BE6E
save_hyperspace                 00:0000B5A4
save_saucer                     00:0000B262
save_ship_fire                  00:0000B346
score_off                        E:00000080
scr_x                            S:00000006
scr_y                            S:00000008
screen_size                      S:0000066E
select_focus1                   00:00008020
select_iofocus                  00:00007FFC
semamem                          E:FD300000
serial_cmdproc                  00:000015FC
serial_dcb                       E:00040C94
serial_getbuf                   00:00001650
serial_getchar                  00:0000162A
serial_getchar_direct           00:00001630
serial_init                     00:00001598
serial_peek_char                00:00001638
serial_peek_char_direct         00:00001640
serial_putbuf                   00:00001650
serial_putchar                  00:00001622
serial_putchar_direct           00:00001648
serial_set_inpos                00:00001650
serial_set_outpos               00:00001650
serial_stat                     00:0000161E
set_a_pixel                      S:000005B8
set_graphics_mode               00:00007AB6
set_text_mode                   00:00007A8C
set_thing_pixel                  S:000005A2
set_this_pixel                   S:000005C4
setscreen                       00:0000C0E2
setup_err                       00:00001536
setup_framebuf                  00:0000195C
setup_gfxaccel                  00:00001E5C
setup_keybd                     00:0000058C
setup_null                      00:00000544
setup_serial                    00:00001598
setup_textvid                   00:00000FDC
sexpl_snd                        E:00000005
sexpl_sound                     00:0000DD84
sfire_snd                        E:00000000
sfire_sound                     00:0000DDFE
shift_left                      00:0000C27C
ship_fire                       00:0000B31C
ship_move                       00:0000B71A
ship_parts                      00:0000BCE6
ship_wrk_x                      00:0000BC34
ship_wrk_y                      00:0000BC40
ships_off                        E:00000082
shot_jsr                        00:0000D934
shot_mask                       00:0000B318
shot_or                         00:0000B31A
shot_vec                        00:0000D936
show_ships                      00:0000B608
sin_cos                         00:0000BF88
sin_d0                          00:0000BF6E
sirq0001                        00:0000182E
sirq0002                        00:000018CE
sirqNxtByte                     00:0000181C
sirqRxFull                      00:00001880
sirqTxEmpty                     00:000018CE
sirqXmitOff                     00:000018CE
sixteen_ms                       S:0000001D
skip_add                        00:0000BDDC
skip_p2_score                   00:0000BACA
skip_play_flash                 00:0000BA2E
skip_play_inc                   00:0000B648
skip_player_cont                00:0000AF2C
skip_player_move                00:0000AF28
skip_sub                        00:0000BEFC
small_s_size                    00:0000B0F0
small_saucer                    00:0000B260
smsau_snd                        E:00000003
smsau_sound                     00:0000DDC4
sound_init                      00:0000DC91
sound_key                       00:0000DD1E
spi_buff                         E:00042000
spi_getbuf                      00:000099FA
spi_init                        00:00009834
spi_putbuf                      00:00009A3A
spi_read_block                  00:00009954
spi_send_byte                   00:00009898
spi_send_cmd                    00:000098C8
spi_set_block_address           00:0000991C
spi_setpos                      00:0000991C
spi_setup                       00:00009834
spi_write_block                 00:000099A6
ss_count                         S:0000001B
start                           00:000003B8
start_game                      00:0000AF9E
start_left                      00:0000B238
start_other                     00:00000518
start_plants                     S:0000027B
static_messages                 00:0000B9EA
suppress_0                       S:00000016
switch_addr                      S:0000000E
sys_switches                     E:000408B8
tblPow2                         00:000084B6
tcbs                             E:20010000
test_escape                      S:00000307
test_fire_loop                  00:0000B33A
test_neg_fire                   00:0000B3B2
textvid_clear                   00:000011C4
textvid_cmdproc                 00:00000FB8
textvid_dcb                      E:00040B08
textvid_get_color               00:0000116A
textvid_get_dimen               00:00001194
textvid_get_inpos               00:000010EC
textvid_get_outpos              00:0000112E
textvid_get_outptr              00:00001144
textvid_getbuf                  00:000010E8
textvid_getbuf1                 00:0000117A
textvid_getchar                 00:000010E0
textvid_init                    00:00001034
textvid_putbuf                  00:000010E8
textvid_putchar                 00:00001286
textvid_set_inpos               00:00001102
textvid_set_outpos              00:00001118
textvid_set_unit                00:0000118A
textvid_stat                    00:000010DC
textvid_stub                    00:000010E8
thing_colour                     S:0000001C
things_exist                     S:0000046C
third_quad                      00:0000BD0E
thmp_sndi                        E:0000007C
three_ship_start                00:0000B5B8
thrst_snd                        E:00000002
thrst_sound                     00:0000DDD9
thump_snd                        S:00000023
thump_time                       S:00000024
tickcnt                          E:0004009C
time_count                       S:00000025
timer_interrupt                 00:0000C072
trap3                           00:00009C64
variables                       00:0000DE1D
vec_x_pos                       00:0000BCA6
vec_y_pos                       00:0000BCB2
vector                          00:0000C2CE
vector_base                     00:0000C206
vector_move                     00:0000C2A2
wait1ms                         00:00008B38
was_rot_left                    00:0000B4E4
what_hit_rock                   00:0000B164
what_hit_saucer                 00:0000B190
white_rect                      00:00008B60
wide_shot                       00:0000B2F8
width                            S:00000004
wrap_to_a                       00:0000B504
wrap_to_z                       00:0000B508
write_initial                   00:0000B5D4
x_off_pos                       00:0000B99E
x_pos_end                        E:FFFFFFC6
x_pos_neg                       00:0000B6A4
x_pos_off                        E:FFFFFF80
x_vel_off                        E:0000002F
y_not_neg                       00:0000B6CA
y_off_pos                       00:0000B9B8
y_pos_off                        E:FFFFFFC6
y_vel_off                        E:00000052
zero_suppress                   00:0000BF5E

Symbols by value:
FD080000 TEXTREG
FD208000 FRAMEBUF
FD210000 GFXACCEL
FD240000 PSG
FD250000 I2C1
FD254000 ADAU1761
FD260000 PLIC
FD280000 SPI_MASTER1
FD284000 SPI_MASTER2
FD300000 semamem
FDC00000 MMU
FDFE0010 ACIA
FDFE4000 I2C2
FDFF0000 RST_REG
FDFF4010 RAND_NUM
FDFF4010 RAND
FDFF4014 RAND_STRM
FDFF4018 RAND_MZ
FDFF401C RAND_MW
FDFF8000 KEYBD
FDFFC000 leds
FFFFFF80 x_pos_off
FFFFFFB6 p_xpos_off
FFFFFFB8 s_xpos_off
FFFFFFBA f_xpos_off
FFFFFFC6 y_pos_off
FFFFFFC6 x_pos_end
FFFFFFF0 DDATA
FFFFFFFC p_ypos_off
FFFFFFFC HISPC
FFFFFFFE s_ypos_off
00000000 f_ypos_off
00000000 quit
00000000 HAS_MMU
00000000 ACIA_TX
00000000 PSG_FREQ
00000000 E_Ok
00000000 sfire_snd
00000000 DCB_MAGIC
00000000 def_back
00000000 glob_scale
00000000 ACIA_RX
00000000 TCBInit
00000000 FRAMEBUF_CTRL
00000000 GFX_CTRL
00000000 I2C_PREL
00000001 SCREEN_FORMAT
00000001 SPI_INIT_SD
00000001 DT_NUMERIC
00000001 pfire_snd
00000001 def_p_spawn
00000001 SPI_MASTER_CTRL_REG
00000001 I2C_PREH
00000002 DEV_PUTCHAR
00000002 DT_STRING
00000002 redraw
00000002 SERIAL_SEMA
00000002 local_x
00000002 thrst_snd
00000002 I2C_CTRL
00000002 E_Func
00000002 SPI_TRANS_TYPE_REG
00000002 SPI_RW_READ_SD_BLOCK
00000003 I2C_TXR
00000003 CTRLC
00000003 SPI_RW_WRITE_SD_BLOCK
00000003 I2C_RXR
00000003 SPI_TRANS_CTRL_REG
00000003 KEYBD_SEMA
00000003 smsau_snd
00000004 I2C_STAT
00000004 GFX_STATUS
00000004 ACIA_STAT
00000004 DCB_NAME
00000004 TCBRegs
00000004 NCORES
00000004 PSG_VOICE_TYPE
00000004 width
00000004 EOT
00000004 local_y
00000004 I2C_CMD
00000004 lgsau_snd
00000004 RAND_SEMA
00000004 SPI_TRANS_STS_REG
00000005 def_a_spawn
00000005 SPI_TRANS_ERR_REG
00000005 SCREEN_SEMA
00000005 PSG_CTRL
00000005 sexpl_snd
00000006 SPI_DIRECT_ACCESS_DATA_REG
00000006 mexpl_snd
00000006 scr_x
00000006 PSG_OUTPUT_SEL
00000006 height
00000006 MEMORY_SEMA
00000007 lexpl_snd
00000007 DEV_SET_OUTPOS
00000007 SPI_ADDR_70
00000008 SPI_ADDR_158
00000008 numBreakpoints
00000008 CTRLH
00000008 FMTK_SEMA
00000008 ACIA_CMD
00000008 num_plants
00000008 beat1_snd
00000008 scr_y
00000009 SPI_ADDR_2316
00000009 E_NotAlloc
00000009 beat2_snd
0000000A E_NotSupported
0000000A max_plants
0000000A FDATA
0000000A PRNlword
0000000A SPI_ADDR_3124
0000000A extra_snd
0000000A LF
0000000C DEV_CLEAR
0000000C ACIA_CTRL
0000000C flags_off
0000000C num_animals
0000000D CR
0000000D DEV_SWAPBUF
0000000D SC_TAB
0000000E max_animals
0000000E switch_addr
00000010 DEV_GETBUF1
00000010 FRAMEBUF_PAGE1_ADDR
00000010 plant_colour
00000010 GFX_TARGET_BASE
00000010 LOCVARSZ
00000010 SPI_RX_FIFO_DATA_REG
00000011 SC_ALT
00000011 XON
00000012 DEV_WRITEAT
00000012 hiscore_y
00000012 plant_fill
00000012 SC_LSHIFT
00000013 CTRLS
00000013 XOFF
00000014 s_key
00000014 GFX_TARGET_SIZE_X
00000014 SC_CTRL
00000014 PSG_SUSTAIN
00000014 animal_colour
00000014 SPI_RX_FIFO_CTRL_REG
00000014 DEV_GET_DIMEN
00000015 play_sound
00000016 suppress_0
00000017 DEV_GET_OUTPOS
00000017 high_idx
00000018 player_idx
00000018 CTRLX
00000018 animal_fill
00000018 FRAMEBUF_PAGE2_ADDR
00000018 DEV_GET_OUTPTR
00000018 DCB_CMDPROC
00000018 GFX_TARGET_SIZE_Y
00000019 DEV_SET_COLOR
00000019 past_play
0000001A CTRLZ
0000001A num_players
0000001B ESC
0000001B ss_count
0000001B DEV_PLOT_POINT
0000001C thing_colour
0000001C px_time
0000001C DEV_DRAW_LINE
0000001D DEV_DRAW_TRIANGLE
0000001D sixteen_ms
0000001E p_orient
0000001E DEV_DRAW_RECTANGLE
0000001F FOC
0000001F s_orient
0000001F DEV_DRAW_CURVE
00000020 SPI_TX_FIFO_DATA_REG
00000020 TS_PREEMPT
00000020 fill_colour
00000020 DCB_OUTPOSX
00000020 TEXTROW
00000020 BLANK
00000020 E_BadDevNum
00000020 hi_char
00000020 DEV_SET_DIMEN
00000021 DEV_SET_COLOR_DEPTH
00000021 last_fire
00000021 E_NoDev
00000022 last_hype
00000022 DEV_SET_DESTBUF
00000023 thump_snd
00000023 DEV_SET_DISPBUF
00000023 E_ReadError
00000024 thump_time
00000024 DCB_OUTPOSY
00000024 food_colour
00000024 E_WriteError
00000024 SPI_TX_FIFO_CTRL_REG
00000025 time_count
00000026 hyper
00000027 hiscores
00000027 FOP
00000027 E_InitErr
00000027 p_flag_off
00000028 s_flag_off
00000028 TCBHandleToPointer
00000028 poison_colour
00000028 DCB_OUTPOSZ
00000029 s_fire_off
0000002B p_fire_off
0000002C plant_xy
0000002C DCB_INPOSX
0000002F flag_end
0000002F x_vel_off
00000030 DCB_INPOSY
00000032 def_plants
00000032 def_animals
00000034 DCB_INPOSZ
00000034 TEXTCOL
00000038 GFX_DEST_PIXEL_X
00000038 DCB_INBUFPTR
0000003B hinames
0000003C GFX_DEST_PIXEL_Y
0000003C DCB_OUTBUFPTR
0000003F BUFSIZE
00000040 TCBPointerToHandle
00000040 DCB_INBUFSIZE
00000040 GFX_DEST_PIXEL_Z
00000044 TCBUSP
00000044 DCB_OUTBUFSIZE
00000048 TCBSSP
00000048 DCB_INDIMX
0000004A p_xvel_off
0000004B s_xvel_off
0000004C f_xvel_off
0000004C DCB_INDIMY
0000004C TCBSR
00000050 TCBPC
00000050 DCB_INDIMZ
00000050 BUFLEN
00000050 TCBIAlloc
00000052 y_vel_off
00000054 TCBStatus
00000054 DCB_OUTDIMX
00000055 TCBPriority
00000058 DCB_OUTDIMY
00000058 SC_CAPSLOCK
00000059 game_count
00000059 SC_RSHIFT
0000005B expl_x_pos
0000005C DCB_OUTDIMZ
00000060 DCB_BKCOLOR
00000064 DCB_FGCOLOR
00000067 expl_y_pos
00000068 DCB_OPCODE
00000068 FRAMEBUF_BMPSIZE_X
0000006C FRAMEBUF_BMPSIZE_Y
0000006C TCBStartTick
0000006D p_yvel_off
0000006E TCBAlloc
0000006E s_yvel_off
0000006F f_yvel_off
00000070 DCB_INBUFPTR2
00000070 TCBEndTick
00000074 DCB_OUTBUFPTR2
00000074 GFX_CLIP_PIXEL0_X
00000074 TCBTicks
00000075 i_rk_count
00000076 rock_count
00000077 sauc_cntdn
00000077 SC_NUMLOCK
00000078 FRAMEBUF_WINDOW_DIMEN
00000078 i_sauc_tim
00000078 GFX_CLIP_PIXEL0_Y
00000079 r_hit_tim
0000007A hide_p_cnt
0000007B new_rocks
0000007C GFX_CLIP_PIXEL1_X
0000007C DCB_OUTBUFSIZE2
0000007C thmp_sndi
0000007C TCBIFree
0000007C TCBNext
0000007D min_rocks
0000007E p_xvlo_off
0000007E SC_SCROLLLOCK
0000007F p_yvlo_off
00000080 TCBPrev
00000080 DCB_UNIT
00000080 score_off
00000080 TS_RUNNING
00000080 GFX_CLIP_PIXEL1_Y
00000082 TCBAffinityBase
00000082 ships_off
00000083 high_off
00000084 DCB_SIZE
00000084 GFX_COLOR0
00000084 TCBAffinity
00000088 GFX_COLOR1
0000008C GFX_COLOR2
00000092 TCBFree
00000098 FRAMEBUF_COLOR_COMP
000000A0 TCBAffineChose
000000B0 GFX_TARGET_X0
000000B0 FRAMEBUF_PPS
000000B4 GFX_TARGET_Y0
000000B8 GFX_TARGET_X1
000000BC GFX_TARGET_Y1
000000D0 GFX_COLOR_COMP
000000D4 GFX_PPS
000000D8 TCBInsertIntoReadyQueue
000000E0 SC_EXTEND
000000F0 SC_KEYUP
000000F3 player_1
000000F4 plant_flag
00000100 IRQ_trampolines
00000100 TCB_SIZE
00000120 PSG_MASTER_VOLUME
00000126 animal_xy
00000150 TCBRemoveFromReadyQueue
00000172 StartQ
00000173 p1_score
00000175 p1_ships
00000176 p1_high
0000017A TCBPopReadyQueue
000001EE animal_flag
000001F7 player_2
00000220 plant_spawn
00000220 FemtikiInit
00000221 animal_spawn
00000230 FemtikiInitIRQ
0000023E OSCallTable
00000240 CallOS
00000277 p2_score
00000279 p2_ships
0000027A p2_high
0000027B start_plants
0000027B p_2_end
00000288 restart
00000294 plants_main_loop
000002AA GetRunningTCBPointer
000002C2 SelectThreadToRun
000002E2 end_main_loop
000002EC UpdateIRQLive
000002FA goodbye_message
00000300 VIDEO_Y
00000307 test_escape
0000030E FemtikiTimerIRQ
0000031E exit_test_escape
00000320 init_world
00000384 clr_plant_loop
00000396 LockSysSemaphore
00000398 clr_animals_loop
000003A6 UnlockSysSemaphore
000003B8 start
000003C0 do_plants
000003F6 do_animals
00000400 irq_list_tbl
0000042A do_things
0000046C things_exist
00000484 do_things_loop
000004AA check_for_food
000004CA kill_thing
000004DA is_food
00000504 new_thing_loop
00000504 loop2
00000506 loop1
00000518 start_other
00000524 draw_old_thing
00000526 fill_old_thing
0000052C next_thing
00000530 exit_do_things
00000532 neighbour
0000053E do_nothing
00000544 setup_null
00000544 null_init
00000558 VIDEO_X
00000578 exit_neighbour
0000057E delta_x
00000586 null_ret
00000588 null_cmdproc
0000058C setup_keybd
0000058C keybd_init
00000590 delta_y
000005A2 set_thing_pixel
000005B8 set_a_pixel
000005C4 set_this_pixel
000005E8 InitialisePlants
00000610 KBD_CMDTBL
00000630 keybd_cmdproc
00000652 keybd_stat
0000065A keybd_putchar
0000065C get_direction
0000065E get_prng
00000662 keybd_getchar
0000066A keybd_getbuf
0000066A keybd_set_inpos
0000066A keybd_set_outpos
0000066A keybd_putbuf
0000066E KeybdGetID
0000066E screen_size
00000698 psetscreen
000006A0 kgid1
000006A8 kgnotKbd
000006AA pnotscreen
000006AC pvariables
000006AC KeybdSetLED
000006D8 _KeybdInit
000006D8 KeybdInit
00000704 kbdi0002
0000076E kbdiTryAgain
0000077C kbdi0004
00000798 kbdi0005
0000079C ledxit
000007B2 kbdiXmitBusy
000007C0 msgBadKeybd
000007CF msgXmitBusy
000007EA _KeybdGetStatus
00000800 STRAREASIZE
00000808 _KeybdGetScancode
00000826 _KeybdClearIRQ
0000083C KeybdRecvByte
0000085E KeybdWaitTx
00000884 SetKeyboardEcho
0000088C CheckForKey
00000898 GetKey
000008D2 _CheckForCtrlC
000008D2 CheckForCtrlC
000008E2 KeybdGetCharNoWait
000008EA KeybdGetCharWait
000008F2 KeybdGetChar
00000B0E KeybdSetLEDStatus
00000B5E KeybdSendByte
00000B66 Wait10ms
00000B82 Wait300ms
00000B9E KeybdIRQ
00000C54 _unshiftedScanCodes
00000D54 _shiftedScanCodes
00000E54 _keybdControlCodes
00000ED4 _keybdExtendedCodes
00000F54 TEXTVID_CMDTBL
00000FB8 textvid_cmdproc
00000FDC setup_textvid
00000FFF MAX_TID
00001000 NR_TCB
00001034 textvid_init
000010DC textvid_stat
000010E0 textvid_getchar
000010E8 textvid_getbuf
000010E8 textvid_stub
000010E8 textvid_putbuf
000010EC textvid_get_inpos
00001102 textvid_set_inpos
00001118 textvid_set_outpos
0000112E textvid_get_outpos
00001144 textvid_get_outptr
0000116A textvid_get_color
0000117A textvid_getbuf1
0000118A textvid_set_unit
00001194 textvid_get_dimen
000011C4 textvid_clear
0000121E loop3
0000123C get_screen_color
0000125C CalcScreenLoc
00001286 textvid_putchar
000012A4 dcx14
000012A8 dcx7
000012B0 dccr
000012CE dcx6
000012E4 dcx8
000012FA dcx9
00001318 dcx10
00001330 dcx12
0000133A dcx11
00001384 dclf
00001388 dcx16
0000138C dcx4
00001396 doBackspace
000013A4 doDelete
000013DA doCtrlX
000013FE IncCursorPos
00001418 IncCursorRow
00001440 icc1
00001442 ScrollUp
00001488 BlankLastLine
000014E2 HomeCursor
000014F4 SyncCursor
00001536 err_init
00001536 setup_err
00001562 err_ret
00001564 err_cmdproc
00001568 COM_CMDTBL
00001598 serial_init
00001598 setup_serial
000015FC serial_cmdproc
0000161E serial_stat
00001622 serial_putchar
0000162A serial_getchar
00001630 serial_getchar_direct
00001638 serial_peek_char
00001640 serial_peek_char_direct
00001648 serial_putchar_direct
00001650 serial_getbuf
00001650 serial_set_inpos
00001650 serial_putbuf
00001650 serial_set_outpos
00001654 SerialInit
0000168A SerialGetChar
00001702 SerialPeekChar
0000173E SerialPeekCharDirect
00001758 SerialPutChar
000017BC SerialPutCharDirect
000017D8 SerialRcvCount
000017F8 SerialIRQ
0000181C sirqNxtByte
0000182E sirq0001
00001880 sirqRxFull
00001880 notRxInt
000018CE sirq0002
000018CE sirqXmitOff
000018CE notTxInt
000018CE sirqTxEmpty
000018E0 nmeSerial
000018E8 FRAMEBUF_CMDTBL
00001930 framebuf_cmdproc
0000195C setup_framebuf
000019D0 framebuf_init
00001A7C framebuf_getchar
00001A7C framebuf_set_destbuf
00001A7C framebuf_stat
00001A7C framebuf_putchar
00001A80 framebuf_set_inpos
00001A90 framebuf_set_outpos
00001AA0 framebuf_getbuf1
00001AA8 framebuf_getbuf2
00001AB0 framebuf_setbuf1
00001AC0 framebuf_setbuf2
00001AD0 framebuf_swapbuf
00001B24 framebuf_set_dispbuf
00001B30 framebuf_set_unit
00001B3C framebuf_stub
00001B3C framebuf_getbuf
00001B3C framebuf_putbuf
00001B40 framebuf_set_color_depth
00001B4C framebuf_get_color
00001B5C framebuf_get_dimen
00001B8C framebuf_set_dimen
00001BF0 plot
00001BF0 framebuf_writeat
00001C20 plottbl
00001C5C plot_sw
00001C82 plot_or
00001C96 plot_xor
00001CAC plot_and
00001CC0 plot_copy
00001CCE plot_black
00001CD8 plot_white
00001CE4 clear_graphics_screen
00001D14 framebuf_clear
00001DA8 GFXACCEL_CMDTBL
00001E38 gfxaccel_cmdproc
00001E5C setup_gfxaccel
00001EE6 gfxaccel_init
00001F48 gfxaccel_stat
00001F56 gfxaccel_putchar
00001F56 gfxaccel_getbuf
00001F56 gfxaccel_putbuf
00001F56 gfxaccel_set_dispbuf
00001F56 gfxaccel_getbuf1
00001F56 gfxaccel_get_outpos
00001F56 gfxaccel_get_inpos
00001F56 gfxaccel_get_dimen
00001F56 gfxaccel_set_outpos
00001F56 gfxaccel_getbuf2
00001F56 gfxaccel_getchar
00001F56 gfxaccel_set_unit
00001F56 gfxaccel_setbuf1
00001F56 gfxaccel_writeat
00001F56 gfxaccel_setbuf2
00001F56 gfxaccel_set_inpos
00001F56 gfxaccel_get_outptr
00001F56 gfxaccel_stub
00001F56 gfxaccel_swapbuf
00001F5A gfxaccel_set_dimen
00001F8E gfxaccel_set_destbuf
00001FBA gfxaccel_clear
0000204E gfxaccel_set_color_depth
00002060 gfxaccel_get_color
0000206E gfxaccel_set_color
0000208E gfxaccel_set_color123
000020C6 gfxaccel_clip_rect
0000210A gfxaccel_set_active_point
00002136 gfxaccel_plot_point
00002188 gfxaccel_draw_line
000021F0 gfxaccel_draw_rectangle
00002258 gfxaccel_draw_triangle
000022E0 gfxaccel_draw_curve
00002366 gfxaccel_wait
00002394 AudioTestOn
000023DC AudioTestOff
000023FE GlobalReadLong
00002404 GlobalWriteLong
00002408 net_delay
00002408 nd2
00002408 nd4
00002408 nd3
00002408 nd1
0000240C InitIOPBitmap
00002458 InitRand
00002458 RandInit
000024C2 RandGetNum
000024F2 prng
0000254C _GetRand
00002570 RandWait
00002588 InitSemaphores
000025AE LockSemaphore
000025D0 ForceUnlockSemaphore
000025EA UnlockSemaphore
00002606 T15LockSemaphore
0000260C T15UnlockSemaphore
00002612 T15GetFloat
00002628 T15Abort
00002638 chk_exception
0000264C Delay3s
0000265A dly3s2
0000265C dly3s1
00002670 Delay3s2
0000268C cpu_test
0000276A ALL_DONE
0000276C BSR_FAR1
00002774 EXCEPTION_6
0000277C EXCEPTION_7
00002784 op_ORI_TO_CCR
000027A6 op_ORI_TO_SR
000027C8 op_EORI_TO_CCR
000027EE op_EORI_TO_SR
00002814 op_ANDI_TO_CCR
0000283A op_ANDI_TO_SR
00002860 op_BTST
000029EA op_BTST0
000029F6 op_BTST1
000029FE op_BTST2
00002A06 op_BTST3
00002A0E op_BTST4
00002A16 op_BTST5
00002A1E op_BTST6
00002A26 op_BTST7
00002A2E op_BTST8
00002A36 op_BTST9
00002A3E op_BTST10
00002A46 op_BTST11
00002A4C op_BTST12
00002BA4 op_BTST20
00002BAE op_BTST21
00002BB4 op_BTST22
00002BBA op_BTST23
00002BC0 op_BTST24
00002BC6 op_BTST25
00002BCC op_BTST26
00002BD2 op_BTST27
00002BD8 op_BTST28
00002BDE op_BTST29
00002BE4 op_BTST30
00002BEA op_BTST31
00002BEE op_BTST32
00002C0A op_BCHG
00002F72 op_BCLR
000032C0 op_BSET
00003608 op_MOVEP
00003694 op_BOOL_I
0000383E BSR_CLOSE1
00003846 op_BSR
00003874 BSR_CLOSE2
0000387C op_CMP_I
00003A64 op_ADD_I
00003BEA op_SUB_I
00003D70 op_MOVE
00003E3C MOVE2
00003EB8 MOVE1
00003F38 MOVE3
00003F7C op_MOVE_xxx_FLAGS
00004000 REL4
00004092 MOVE4
00004170 op_EXT
0000419C op_SWAP
000041B2 op_LEAPEA
0000424A LEA1
0000425E op_TAS
00004284 op_TST
000042C2 op_LINKS
000042E0 op_MOVE_USP
000042F0 op_CHK
0000433A op_NEGS
000046C8 op_MOVEM
000049E6 op_ABCD
00004A06 ABCD_OUTER1
00004A08 ABCD_INNER1
00004A24 ABCD_NO_C1
00004A2C ABCD_NO_C2
00004A74 ABCD_OUTER2
00004A76 ABCD_INNER2
00004A92 ABCD_NO_C3
00004A9A ABCD_NO_C4
00004ADE op_SBCD
00004AFE SBCD_OUTER1
00004B00 SBCD_INNER1
00004B1C SBCD_NO_C1
00004B24 SBCD_NO_C2
00004B6C SBCD_OUTER2
00004B6E SBCD_INNER2
00004B8A SBCD_NO_C3
00004B92 SBCD_NO_C4
00004BD6 op_NBCD
00004BEE NBCD_LOOP
00004BFA NBCD_NO_C
00004BFE NBCD_NO_Z
00004C34 NBCD_LOOP1
00004C48 NBCD_NO_C1
00004C4C NBCD_NO_Z1
00004C68 op_TRAPV
00004C84 op_RTR
00004C90 RTR_DONE
00004C9E BSR_FAR2
00004CA6 op_BCC
00004CAE BCC1
00004CB8 BCC2
00004CC0 BCC3
00004CCA BCC4
00004CD2 BCC5
00004CDC BCC6
00004CE4 BCC7
00004CEE BCC8
00004CF6 BCC9
00004D00 BCC10
00004D08 BCC11
00004D12 BCC12
00004D1A BCC13
00004D24 BCC14
00004D26 op_DBCC
00004D2E DBCC_LOOP1
00004D3C DBCC_LOOP2
00004D4C op_SCC
00004D7C op_ADDQ
00004D90 ADDQ_LOOP1
00004DCE ADDQ_LOOP2
00004E04 ADDQ_LOOP3
00004E36 op_SUBQ
00004E4E SUBQ_LOOP1
00004E88 SUBQ_LOOP2
00004EBE SUBQ_LOOP3
00004EF0 op_MOVEQ
00004F0C op_DIVU
00004F28 DIVU_OUTER1
00004F5E op_DIVS
00004F7A DIVS_OUTER1
00004FB0 op_OR
00004FD0 OR_OUTER1
00005000 REL5
00005044 OR_OUTER2
0000509A op_AND
000050BA AND_OUTER1
0000512E AND_OUTER2
00005184 op_EOR
000051A4 EOR_OUTER2
000051FA op_CMP
0000521A CMP_OUTER1
00005270 op_CMPA
00005290 CMPA_OUTER1
000052D6 op_CMPM
0000531E CMPM_LOOP1
00005338 CMPM_LOOP2
00005352 CMPM_LOOP3
0000537C op_ADD
0000539C ADD_OUTER1
00005410 ADD_OUTER2
00005466 op_SUB
00005486 SUB_OUTER1
000054FA SUB_OUTER2
00005550 op_ADDA
00005576 ADDA_OUTER1
0000559C op_SUBA
000055C2 SUBA_OUTER1
000055E8 op_ADDX
00005608 ADDX_OUTER1
0000569C ADDX_LOOP3
000056B8 ADDX_LOOP4
000056D4 ADDX_LOOP5
000056F8 op_SUBX
00005718 SUBX_OUTER1
000057AC SUBX_LOOP3
000057C8 SUBX_LOOP4
000057E4 SUBX_LOOP5
00005808 op_MULU
00005824 MULU_OUTER1
00005854 op_MULS
00005870 MULS_OUTER1
000058A0 op_EXG
00005902 ROx_FLAGS
0000590E op_ROx
00005918 ROx_LOOP1
00005938 ROx_LOOP2
00005958 ROx_LOOP3
00005978 ROx_LOOP4
00005998 ROx_LOOP5
000059BA ROx_LOOP6
00005B38 ROXx_FLAGS
00005B44 op_ROXx
00005B4E ROXx_LOOP1
00005B6E ROXx_LOOP2
00005B8E ROXx_LOOP3
00005BAE ROXx_LOOP4
00005BCE ROXx_LOOP5
00005BF0 ROXx_LOOP6
00005D6E SHIFTS_FLAGS
00005D7A op_SHIFTS
00005D84 SHIFTS_LOOP1
00005DA4 SHIFTS_LOOP2
00005DC4 SHIFTS_LOOP3
00005DE4 SHIFTS_LOOP4
00005E04 SHIFTS_LOOP5
00005E26 SHIFTS_LOOP6
00005FB0 SHIFTS2_FLAGS
00005FBC op_SHIFTS2
00005FC6 SHIFTS2_LOOP1
00005FE2 SHIFTS2_LOOP2
00005FFE SHIFTS2_LOOP3
0000601A SHIFTS2_LOOP4
00006036 SHIFTS2_LOOP5
00006054 SHIFTS2_LOOP6
000061DA START
000061DC GOWARM
000061E0 GOOUT
000061E4 GOIN
000061E8 GOAUXO
000061EC GOAUXI
000061F0 GOBYE
000061F4 TXTBGN
000061F8 ENDMEM
000061FC CSTART
00006268 WSTART
0000629C ST3
000062EE ST4
00006328 ClearStringArea
00006348 ClearStringStack
0000635C TAB1
0000638B TAB2
000063F9 TAB4
0000642B TAB5
0000642E TAB6
00006433 TAB8
0000643E TAB9
00006442 TAB10
00006445 TAB11
0000644A TAB12
00006454 TAB1_1
00006484 TAB2_1
000064EC TAB4_1
00006520 TAB5_1
00006528 TAB6_1
00006530 TAB8_1
0000654C TAB9_1
00006554 TAB10_1
0000655C TAB11_1
00006564 TAB12_1
0000656C DIRECT
0000657C EXEC
00006584 EXLP
0000658E EXNGO
000065A6 EX1
000065AC EXMAT
000065B2 EXGO
000065B6 INCON
000065C4 INCOM
000065D2 IOCOM
000065DC OUTCOM
000065E8 IOCON
000065F2 OUTCON
000065FE NEW
00006612 STOP
0000661A RUN
0000662E RUNNXL
0000666E RUN1
0000667A RUNTSL
00006684 RUNSML
00006694 GOTO
000066A8 ONIRQ
000066C2 ONIRQ1
000066CC WAITIRQ
000066DC LIST
000066E8 LS1
000066FC LS2
00006702 LS3
00006708 PRINT
00006718 PR2
00006726 PR0
00006734 PR1
00006742 PR3
0000674E PR6
00006754 PR8
00006770 PR9
0000678A FINISH
00006792 GOSUB
000067CC RETURN
000067F8 FOR
00006812 FR1
0000682A FR2
00006830 FR3
00006836 FR4
0000683E FR5
00006850 FR6
0000685C FR7
00006874 FR8
00006878 NEXT
00006882 NX0
00006894 NX3
000068C2 NX1
000068DA NX2
000068E2 REM
000068E4 IF
000068E8 IF1
000068EE IF2
000068FE INPERR
0000690C INPUT
00006930 IP7
0000693A IP6
0000693E IP2
00006958 IP3
00006992 IP4
0000699E IP5
000069A2 DEFLT
000069AA LET
000069B6 LT1
000069BA LOAD
000069C6 LOD1
000069E0 LOD2
000069F0 LODEND
000069FA GBYTE
000069FE GBYTE1
00006A0C GBYTE2
00006A1A SAVE
00006A22 SAVE1
00006A46 SAVE2
00006A54 SAVEND
00006A78 PBYTE
00006A7A PBYTE1
00006A8E PBYTE2
00006A98 POKE
00006B0E PKER
00006B12 CALL
00006B28 CLEAR
00006B36 TEXT
00006B66 TEXTERR
00006B6A DRAWBUF
00006B7A DISPBUF
00006B8A COLOR
00006B96 COLOR1
00006BEA COLOR2
00006BFE POINT
00006C20 POINTERR
00006C24 LINE
00006C66 LINEERR
00006C6A LINEERR1
00006C70 LINEERR2
00006C76 RECT
00006CBC TRIANGLE
00006D1C TRIERR
00006D20 TRIERR1
00006D26 TRIERR2
00006D2C TRIERR3
00006D34 TRIERR4
00006D3C CURVE
00006D94 XP_PUSH
00006DA4 XP_POP
00006DB4 XP_POP1
00006DC4 NUM_EXPR
00006DD2 INT_EXPR
00006DE4 EXPR
00006DE4 EXPR_OR
00006DF4 XP_OR
00006E0A EXPR_AND
00006E1A XP_AND
00006E30 XP_ANDX
00006E30 XP_ORX
00006E36 CheckNumeric
00006E48 EXPR_REL
00006E5C XP11
00006E68 XP12
00006E74 XP13
00006E80 XP14
00006E8C XP15
00006E98 XP15RT
00006E9A XP16
00006EA8 XPRT0
00006EB0 XPRT1
00006EB8 XP17
00006EBE XP18
00006ED2 EXPR2
00006EE0 XP21
00006EE6 XP22
00006EEA XP23
00006EF8 XP24
00006F26 XP25
00006F2C XP26
00006F40 XP27
00006F42 ConcatString
00006FB0 EXPR3
00006FB2 XP36
00006FB6 XP30
00006FC2 XP31
00006FD8 XP34
00006FF2 XP35
00006FF8 XP_MOD
00007000 REL7
0000701A EXPR4
00007026 XP40
00007036 EXP4RT
00007038 XP41
00007048 XPSTNG
00007052 XP45
000070A4 XP44
000070B0 PARN
000070C0 XP42
000070C2 XP43
000070C6 AllocateString
00007124 GarbageCollectStrings
00007160 NextString
00007176 StringInVar
00007194 SIV1
000071BC PointsIntoStringArea
000071E0 StringOnStack
00007210 UpdateStringPointers
0000723C USP1
0000725E TSTV
000072A6 TV1
000072D6 TV2
000072DE TSTVRT
000072E0 DIV32
000072F2 DIV1
000072F8 DIV2
000072FE DIV3
0000730C DIV4
0000731A DIVRT
0000731C PEEK
00007384 RND
000073AE ABS
000073BA SIZE
000073CA TICK
000073D6 CORENO
000073E2 LorRArgs
0000741A LorR1
0000741E MID
00007466 MID2
0000747E MID5
00007486 DOMID
000074B2 MID4
000074E4 MID1
000074E8 LEFT
000074F4 RIGHT
0000751C LEN
00007542 INT
00007558 CHR
00007590 SETVAL
000075AE SV1
000075B0 FIN
000075BC FI1
000075C8 FI2
000075CA ENDCHK
000075DA ENDCHK1
000075DC QWHAT
000075DE AWHAT
000075E2 ERROR
0000761C QSORRY
0000761E ASORRY
00007624 QHOW
00007626 AHOW
0000762C ETYPE
00007632 GETLN
00007642 GL1
00007660 GL2
00007674 GL3
00007698 GL4
000076A4 GL5
000076C0 GL6
000076C8 GL7
000076D0 FNDLN
000076DE FNDLNP
000076F4 FNDRET
000076F6 FNDNXT
000076F8 FNDSKP
00007706 MVUP
0000770E MVRET
00007710 MVUPW
0000771A MVDOWN
00007722 POPA
0000775E PUSHA
00007794 PRTSTG
00007796 PS1
000077AE PRTRET
000077B0 PRTSTR2a
000077B6 PRTSTR2
000077BC PRTNUM
00007806 PRTLN
00007824 TSTC
00007836 TC1
0000783C TSTNUM
00007888 IGNBLK
00007892 TOUPBUF
00007898 TOUPB1
000078B8 TOUPBRT
000078BA DOQUO
000078C2 DOQUO1
000078CA TOUPPER
000078DA TOUPRET
000078DC CHKIO
000078EC CHKRET
000078EE PRMESG
000078F8 PRMRET
000078FA CLS
00007906 OUTC
00007916 INC
00007922 INC1
00007936 AUXOUT
0000794A AUXIN
00007968 AXIRET
0000796A BYEBYE
00007978 INITMSG
0000799C OKMSG
000079A3 HOWMSG
000079AA WHTMSG
000079B2 TYPMSG
000079BA NOSTRING
000079CC SRYMSG
000079D2 CLMSG
000079D6 LSTROM
000079D8 RANPNT
000079DC INPPTR
000079E0 OUTPTR
000079E4 CURRNT
000079E8 STKFP
000079EC STKGOS
000079F0 STKINP
000079F4 LOPVAR
000079F8 LOPINC
00007A04 LOPLMT
00007A10 LOPLN
00007A14 LOPPT
00007A18 IRQROUT
00007A1C STRSTK
00007A20 StrSp
00007A24 StrArea
00007A28 LastStr
00007A2C TXTUNF
00007A30 VARBGN
00007A34 STKLMT
00007A38 DIRFLG
00007A3C BUFFER
00007A8C set_text_mode
00007A8C TXT
00007AB6 set_graphics_mode
00007AE0 get_screen_address
00007AF2 CRLF
00007B0C DisplayString
00007B10 dspj1
00007B1C dsret
00007B22 DisplayStringCRLF
00007B26 DisplayStringLimited
00007B46 DisplayStringLimitedCRLF
00007B4A TRAP15
00007B64 T15DispatchTable
00007CF4 SimHardware
00007D04 GetTick
00007D0C T15Wait100ths
00007D28 SetDrawMode
00007D4A SetPenColor
00007D56 T15Rectangle
00007D68 T15GetPixel
00007D88 T15GetWindowSize
00007D9E GRBufferToScreen
00007DA6 TestBitmap
00007E46 Diagonal1
00007E66 Diagonal2
00007E90 Vertical1
00007EAC Vertical2
00007ED4 MoveToXY
00007EE2 DrawToXY
00007F60 DrawHorizTo
00007F92 DrawVertTo
00007FC2 Cursor1
00007FFA StubRout
00007FFC select_iofocus
00008000 def_leaf
0000800E rotate_iofocus
00008020 select_focus1
0000803E init_plic
00008074 cmdString
000080C8 cmdTable
00008148 FromScreen
00008152 StartMon
0000815C cmdMonitor
0000815C Monitor
0000817C PromptLn
00008188 Prompt3
0000819E Prompt1
000081B8 cmdDispatch
000081FE cmdVideoMode
00008240 cmdBreakpoint
00008264 cmdAsteroids
0000826C cmdPlants
00008274 cmdSetTime
000082E2 cmdTime
000082F4 get_time
0000835E cmdTinyBasic
00008362 cmdTestCPU
00008372 cmdClearScreen
0000837E cmdCore
000083A2 cmdFMTK
000083AC cmdTestFP
00008438 cmdTestGF
00008466 cmdClock
00008484 cmdReset
000084B6 tblPow2
000084D6 DisplayHelp
000084D6 cmdHelp
000084E2 cmdTestSD
00008554 HelpMsg
000086F1 msgUnknownCmd
00008701 msgHello
00008712 GetCmdLine
000087B6 cmdSendSerial
000087E6 cmdReceiveSerial
0000881A cmdFillB
0000886E cmdFillW
000088C2 cmdFillL
00008910 ignBlanks
00008922 PeekScreenChar
00008928 GetSzChar
0000894E EditMemHelper
00008970 cmdEditMemory
0000897A edtmem1
000089CE ExecuteCode
000089CE cmdJump
000089DE cmdGrDemo
00008A72 plot_rand_points
00008AF0 clear_graphics_screen2
00008B38 wait1ms
00008B60 white_rect
00008B84 rand_points
00008BBA rand_lines
00008C1A rand_rect
00008C7A rand_rect2
00008CC4 rand_triangle
00008D3C rand_curve
00008DB4 cmdDisassemble
00008E04 cmdDumpMemory
00008E28 DumpMem1
00008E3A DisplayMem
00008E66 dspmem1
00008ED0 cmdDumpRegs
00008F50 msg_regs
00008F54 msg_reglist
00008F7A cmdTestSerialReceive
00008F9E GetHexNumber
00008FCC GetDecNumber
00009010 _dfOne
0000901C _dfTen
00009028 _dfMil
00009034 _msgNan
00009038 _msgInf
0000903C _CheckNan
000090A0 _CheckZero
000090BA _CheckNegative
000090CC _MakeBig
000090E8 _LessThanDbl
00009114 _ComputeDigitsBeforeDecpt
0000914E _LeadingZero
0000915E _SpitOutDigits
000091DA _TrimTrailingPoint
000091F8 _TrimDotZero
00009214 _TrimTrailingZeros
00009220 _SpitOutE
00009238 _ExtExpDigit
00009256 _ExtExpDigits
0000927E _PadLeft
000092CE _PadRight
00009300 _FloatToString
00009342 _GetFloatGetChar
00009348 _GetFloatIgnBlanks
00009350 _GetFloatBackupChar
00009354 _GetFraction
000093B8 _GetExponent
00009442 _GetInteger
000094B8 _GetFloat
00009530 AsciiToHexNybble
00009542 gthx5
00009554 gthx6
00009566 gthx3
0000956A DisplayTwoSpaces
00009574 dspspc1
0000957C DisplaySpace
00009584 DisplayTetra
0000958A DisplayWyde
00009590 DisplayByte
00009596 DisplayNybble
000095B0 BufTetra
000095B6 BufWyde
000095BC BufByte
000095C2 BufNybble
000095DA DisplayAddr
000095FA cmdTestRAM
000095FA ramtest
00009614 rmtst5
00009644 ramtest0
0000964C ramtest1
0000965E rmtst1
0000966A ramtest6
0000967A ramtest2
00009692 rmtst2
0000969A rmtst3
000096C0 ramtest3
000096C2 cmdLoadS19
000096C8 S19ProcTbl
000096D4 NextRec
000096E6 ProcessRec
0000973E S19GetByte
0000975C ProcessS1
00009760 ProcessS2
00009764 ProcessS3
00009766 pcssxa
00009798 ProcessS7
000097A4 ProcessS8
000097B0 ProcessS9
000097BC S19Get32BitAddress
000097C4 S19Get24BitAddress
000097CE S19Get16BitAddress
000097E2 sGetChar
0000981E AudioInputTest
00009820 BouncingBalls
00009822 GraphicsDemo
00009824 ClearScreen
0000982C rbo
00009834 spi_init
00009834 spi_setup
00009834 init_spi
00009898 spi_send_byte
000098C8 spi_send_cmd
0000991C spi_set_block_address
0000991C spi_setpos
00009954 spi_read_block
000099A6 spi_write_block
000099FA spi_getbuf
00009A3A spi_putbuf
00009A7A init_i2c
00009A7A i2c_setup
00009A88 i2c_enable
00009A90 i2c_disable
00009A96 i2c_wait_tip
00009AA6 i2c_read_stop
00009AB0 i2c_get_status
00009AB6 i2c_read_ack
00009AC4 i2c_read
00009ACA i2c_wr_cmd
00009ADA i2c_xmit1
00009AF8 i2c_wait_rx_nack
00009B08 rtc_read
00009B92 rtc_write
00009C20 msgRtcReadFail
00009C39 msgBusErr
00009C4A bus_err
00009C64 trap3
00009CA2 ProcessBreakpoint
00009CA8 DisarmAllBreakpoints
00009CD4 ArmAllBreakpoints
00009D04 ArmBreakpoint
00009D82 DisarmBreakpoint
00009DD6 ListBreakpoints
00009DF6 ClearBreakpointList
00009E08 SendMsg
00009E46 ReceiveMsg
00009E88 DispatchMsg
00009E8A prtflt
00009ED0 T15FloatToString
00009F04 io_trap
00009F2A OutputChar
00009F44 InitIRQ
00009F5C InstallIRQ
00009FA0 TickIRQ
00009FE2 irq3_rout
00009FE2 irq_rout
00009FE2 irq6_rout
00009FF6 irq_proc_generic
0000A000 DRAW
0000A014 SpuriousIRQ
0000A016 nmi_rout
0000A028 addr_err
0000A03E brdisp_trap
0000A076 illegal_trap
0000A08C io_irq
0000A0A0 msg_start
0000A0C7 msg_core_start
0000A0D8 msgAddrErr
0000A0E5 msg_illegal
0000A0F7 msg_bad_branch_disp
0000A109 msg_test_done
0000A119 msg_io_access
0000A134 msgChk
0000A142 msgStackCanary
0000A15C ShiftBuf
0000A176 HEX2DEC2
0000A1C4 HEX2DEC
0000A1D4 HX2DC
0000A1D8 HX2DC0
0000A1E0 HX2DC1
0000A1FA HX2DC2
0000A1FC HX2DC22
0000A206 HX2DC3
0000A20E HX2DC4
0000A216 HX2DC5
0000A21E HX2DC57
0000A222 HX2DC6
0000A228 PNT4HX
0000A228 PNT4HEX
0000A22C PNT6HX
0000A238 PNT8HX
0000A23C FRELADDR
0000A24A FREL10
0000A25C FREL15
0000A276 FREL20
0000A288 FREL25
0000A292 FREL30
0000A29A IMOVEMFR
0000A29A X
0000A2AE IM7788
0000A2B2 IM7799
0000A2C8 IMOVEMTR
0000A2E2 CS16
0000A2E4 ISTOP
0000A2F8 IMMED
0000A31E IMMED45
0000A350 CS15
0000A352 IMMED55
0000A358 IMMED65
0000A368 IMMED75
0000A36C IMOVE
0000A370 ILINK
0000A386 FORM1
0000A38A FORM1A
0000A38E CS14
0000A390 FORM3
0000A394 FORM4
0000A3A6 FORM5
0000A3AA FORM6A
0000A3BA FORM6D
0000A3CA FORMREGA
0000A3CE FORMREG5
0000A3DA FORMREGD
0000A3E0 FORM7
0000A3EC FORM8
0000A3F0 FORM815
0000A3F8 CS13
0000A3FA FORM9
0000A400 EEA10
0000A404 FORM10EX
0000A426 FORM10E3
0000A42E FORM10E4
0000A43A FORM10E6
0000A442 FORM10
0000A448 FORM103
0000A44C FORM104
0000A45C FORM105
0000A472 CS12
0000A476 FORM11
0000A47E FORM11SL
0000A492 FORM112
0000A4A0 FORM114
0000A4A2 FORM12
0000A4BC FORM125
0000A4DE FORM12A
0000A502 CS11
0000A506 IQUICK
0000A50A IMOVEQ
0000A522 SCHR
0000A52A IMVFSR
0000A538 IMVFUSP
0000A546 IMVTSR
0000A554 IMVT44
0000A558 IMVTUSP
0000A564 IMVTCCR
0000A574 IMOVEP
0000A584 IMOVEP11
0000A59C CS20
0000A5A0 IMOVEP35
0000A5AE IMOVEP66
0000A5CA SCOMMON
0000A5CE ISCC
0000A5D8 IDBCC
0000A5EA ICC
0000A5EE IBSR
0000A600 ICC35
0000A616 ICC55
0000A626 ISETD
0000A62C ISETD12
0000A634 CS18
0000A636 ISETS
0000A650 ISHIFT
0000A65C ISHIFT13
0000A680 ISHIFT23
0000A68C ISHIFT33
0000A690 ISHIFT44
0000A698 CS17
0000A69A ISHIFTM1
0000A6B4 ICCCC
0000A6CA ICCCC9
0000A6CC BRTBL
0000A6EC IMOVEA1
0000A712 IMOVE19
0000A718 IQUICKA
0000A72A IQUICK21
0000A740 IQUICK31
0000A744 CS19
0000A748 FORMSIZE
0000A75C FORM91
0000A770 FORM93
0000A772 FORM95
0000A774 EA000
0000A780 EA001
0000A78C EA010
0000A7A0 EA011
0000A7B6 EA011RTS
0000A7B8 EA100
0000A7CE FE10
0000A7D2 EEA
0000A836 EA1105
0000A83A EA1107
0000A850 EA1109
0000A85A EA101
0000A870 EA111
0000A88E EA1112
0000A8AA EA1113
0000A8B6 FE11
0000A8BA EA1113A
0000A8DC EA1114
0000A924 EAF25
0000A928 EAF27
0000A93C EAF35
0000A946 EA1115
0000A97E EA11153
0000A988 EA11155
0000A994 MOVEMS
0000A9A4 MOVEMS2
0000A9A8 MOVEMR
0000A9B8 MOVEMR11
0000A9C0 MOVEMR33
0000A9D2 MOVEMR44
0000A9EC MOVEMR77
0000A9FE MOVEMR79
0000AA00 MOVEMR88
0000AA18 MOVEMR94
0000AA24 DCODE68K
0000AA38 DEC311
0000AA56 DEC404
0000AA66 DEC411
0000AA74 FE12
0000AA76 DEC425
0000AA82 DEC510
0000AA86 DEC515
0000AA8E DEC530
0000AA94 DEC535
0000AAA0 DEC537
0000AABC COMMON4
0000AABE COMMON
0000AACC COMMON35
0000AAE6 FERROR
0000AAF0 FERROR35
0000AAFC FERROR39
0000AB06 MSG111
0000AB10 KI
0000AB12 TBL
0000AB12 KIEND
0000ADCA OPCTBL
0000ADCA TBLE
0000AECA asteroids_start
0000AED2 main_loop
0000AF28 skip_player_move
0000AF2C skip_player_cont
0000AF30 px_hide
0000AF38 no_play
0000AF56 no_dec_new_rocks
0000AF66 game_message
0000AF7A do_start_mess
0000AF9E start_game
0000AFD2 push_start_mess
0000AFE8 exit_push_start
0000AFEA game_over
0000AFFE nodec_thmpi
0000B000 HALT
0000B028 no_game_over
0000B066 exit_game_message
0000B068 end_game
0000B07C check_hits
0000B07E pss_check_loop
0000B084 next_pss
0000B08A check_pss
0000B098 check_next_object
0000B09C check_all
0000B0B6 delta_x_pos
0000B0C8 delta_y_pos
0000B0F0 small_s_size
0000B0F2 add_p_size
0000B0F4 no_add_size
0000B102 col_table
0000B10A col_table_p
0000B112 col_table_s
0000B11A col_table_l
0000B122 handle_collision
0000B132 not_saucer
0000B140 not_player
0000B158 not_pss_player
0000B164 what_hit_rock
0000B168 explode_object
0000B184 player_shot
0000B190 what_hit_saucer
0000B1A8 keep_small
0000B1AE do_saucer
0000B1DA attract_saucer
0000B1E4 rock_hit_out
0000B202 dec_isaucer_time
0000B212 no_save_ist
0000B224 saucer_yok
0000B238 start_left
0000B260 small_saucer
0000B262 save_saucer
0000B266 exit_do_saucer
0000B268 existing_saucer
0000B280 keep_saucer_dir
0000B28C attract_fire
0000B292 exit_existing_saucer
0000B294 saucer_yvel
0000B298 fire_saucer
0000B2B0 aim_shot
0000B2F8 wide_shot
0000B302 no_shot_or
0000B306 no_aim_shot
0000B318 shot_mask
0000B31A shot_or
0000B31C ship_fire
0000B33A test_fire_loop
0000B346 save_ship_fire
0000B34A exit_ship_fire
0000B34C fire_shot
0000B39E calc_fire_byte
0000B3B2 test_neg_fire
0000B3BA fire_ok
0000B3C4 enter_hiscores
0000B3F2 no_playerx
0000B45E next_p_high
0000B47A close_all
0000B492 next_hi_char
0000B4AA save_hbutton
0000B4C0 not_timed_out
0000B4DC not_rot_left
0000B4E4 not_rot_right2
0000B4E4 rot_not_left
0000B4E4 was_rot_left
0000B504 wrap_to_a
0000B508 wrap_to_z
0000B50A check_alpha
0000B512 save_char
0000B516 exit_not_done
0000B518 exit_enter_hiscores
0000B51A hyperspace
0000B556 hype_xok1
0000B560 hype_xok2
0000B57E hype_yok1
0000B588 hype_yok2
0000B5A4 save_hyperspace
0000B5A8 exit_hyperspace
0000B5AA reset_game
0000B5B8 three_ship_start
0000B5C6 clear_items_loop
0000B5D4 write_initial
0000B5EE add_character
0000B5FE add_ships
0000B608 show_ships
0000B61A add_ships_loop
0000B626 exit_add_ships
0000B628 move_items
0000B62C move_next_item
0000B648 skip_play_inc
0000B662 no_new_rocks
0000B66A go_reset_play
0000B670 go_reset_sauc
0000B678 item_exploding
0000B690 no_reset_scale
0000B692 move_item
0000B6A4 x_pos_neg
0000B6B4 not_x_max
0000B6CA y_not_neg
0000B6D4 not_y_max
0000B6F8 keep_scale
0000B6FE move_next_object
0000B706 clear_saucer
0000B71A ship_move
0000B748 reveal_player
0000B750 kill_the_player
0000B766 clear_hyper
0000B76A exit_ship_move
0000B76C rot_and_thrust
0000B778 not_rot_left1
0000B780 not_rot_right1
0000B7DE not_thrust
0000B814 check_velocity
0000B822 check_neg_velocity
0000B82C exit_check_velocity
0000B82E check_clear
0000B832 check_clear_loop
0000B84C check_clear_y
0000B860 not_closer
0000B86A is_closer
0000B870 make_rocks
0000B89A no_inc_min
0000B8AA no_set_max
0000B8B6 gen_rock_loop
0000B8E8 rock_y_ok
0000B8EA rock_on_x
0000B90C clear_rocks
0000B90E clear_rocks_loop
0000B916 exit_make_rocks
0000B918 player_init
0000B94E player_reset
0000B964 copy_rock
0000B968 copy_rock_2
0000B98E copy_velocity
0000B99E x_off_pos
0000B9B8 y_off_pos
0000B9C4 limit_velocity
0000B9CE neg_upper_ok
0000B9D8 limit_p_vel
0000B9E0 pos_lower_ok
0000B9E8 exit_limit_velocity
0000B9EA static_messages
0000BA2E skip_play_flash
0000BA42 do_p1_ships
0000BAB6 do_p2_score
0000BACA skip_p2_score
0000BAD8 exit_static
0000BADA add_to_list
0000BB0E add_item
0000BB28 add_explode
0000BB2E add_saucer
0000BB34 add_fire
0000BB44 no_shot_dec
0000BB46 add_score
0000BB74 exit_add_score
0000BB7A high_scores
0000BBAC high_scores_loop
0000BC1A exit_high_scores
0000BC20 exit_no_scores
0000BC26 find_rock
0000BC28 find_next_rock
0000BC32 exit_find_rock
0000BC34 ship_wrk_x
0000BC40 ship_wrk_y
0000BC4C add_play_explode
0000BC5E reset_xy_loop
0000BC76 no_reset_xy
0000BC80 piece_draw_loop
0000BCA6 vec_x_pos
0000BCB2 vec_y_pos
0000BCE6 ship_parts
0000BCF2 add_player
0000BD08 no_pos_reflect
0000BD0E third_quad
0000BD1C first_quad
0000BD42 no_thrust
0000BD44 copy_short
0000BD48 copy_vectors
0000BD62 exit_copy_vectors
0000BD64 fx_sounds
0000BD72 no_saucer_sound
0000BDA4 no_thump_sound
0000BDA6 hit_a_rock
0000BDC0 clear_rock
0000BDD4 add_to_score
0000BDDC skip_add
0000BE16 exit_hit_a_rock
0000BE18 rock_score
0000BE1C check_hiscores
0000BE38 check_hi_player
0000BE40 check_hi_loop
0000BE4E check_hi_next
0000BE6E save_hi_index
0000BE72 exit_hi_chk
0000BE7C exit_check_hiscores
0000BE7E insert_hiscore
0000BE82 insert_loop
0000BEA4 exit_insert_loop
0000BEC2 get_atn
0000BECE atn_semi
0000BEDE atn_quad
0000BEEE atn_eight
0000BEF2 loop_atn
0000BEFC skip_sub
0000BF0C atn_tab
0000BF4C output_number
0000BF4E output_number_loop
0000BF5E zero_suppress
0000BF6A cos_d0
0000BF6E sin_d0
0000BF7C cossin_d0
0000BF82 a_was_less
0000BF88 sin_cos
0000C000 JSRL
0000C00A add_message
0000C052 add_char_loop
0000C068 add_the_char
0000C070 exit_add_message
0000C072 timer_interrupt
0000C078 player_x
0000C07C player_n
0000C084 add_sup_hex_chr
0000C090 add_hex_chr
0000C09A add_sup_zero
0000C0AA add_address
0000C0C0 add_coords
0000C0DA add_single
0000C0DC add_pair
0000C0E2 setscreen
0000C0E2 notscreen
0000C0E2 s_controls
0000C0EE Initialise
0000C116 clear_loop
0000C162 read_hi
0000C16C close_all_2
0000C172 gen_prng
0000C182 op_rtsvec
0000C182 Ninc0
0000C182 Ninc1
0000C184 do_vector
0000C192 op_call
0000C198 op_jump
0000C1A8 op_vctr
0000C1B6 no_neg_y11
0000C1C2 no_neg_x11
0000C1D2 op_abs
0000C1E0 no_neg_y10
0000C1EC no_neg_x10
0000C1FE not_right
0000C206 vector_base
0000C242 op_short
0000C266 no_neg_y2
0000C26E no_neg_x2
0000C272 end_vector
0000C27C shift_left
0000C280 last_vector
0000C2A2 vector_move
0000C2CE vector
0000D000 RTSL
0000D2CE copy_msg
0000D30E expl_tab
0000D316 expl_3
0000D342 expl_2
0000D380 expl_1
0000D3B6 expl_0
0000D3F4 rock_tab
0000D3FC rock_0
0000D414 rock_1
0000D430 rock_2
0000D44A rock_3
0000D466 sauc_jsr
0000D468 sauc_vec
0000D484 play_tab
0000D4A6 play_00
0000D4BE play_01
0000D4E2 play_02
0000D506 play_03
0000D52A play_04
0000D54C play_05
0000D570 play_06
0000D594 play_07
0000D5B8 play_08
0000D5DC play_09
0000D600 play_0A
0000D624 play_0B
0000D648 play_0C
0000D66C play_0D
0000D690 play_0E
0000D6B4 play_0F
0000D6D8 play_10
0000D6F0 play_liv
0000D706 char_a
0000D716 char_b
0000D730 char_c
0000D73C char_d
0000D74C char_e
0000D75C char_f
0000D76A char_g
0000D77C char_h
0000D78A char_i
0000D798 char_j
0000D7A4 char_k
0000D7B0 char_l
0000D7BA char_m
0000D7C6 char_n
0000D7D0 char_o0
0000D7DC char_p
0000D7EA char_q
0000D7FC char_r
0000D80C char_s
0000D81A char_t
0000D826 char_u
0000D832 char_v
0000D83C char_w
0000D84A char_x
0000D854 char_y
0000D862 char_z
0000D86E char_spc
0000D872 char_1
0000D87A char_2
0000D88A char_3
0000D898 char_4
0000D8A6 char_5
0000D8B4 char_6
0000D8C2 char_7
0000D8CC char_8
0000D8DC char_9
0000D8EA char_set
0000D934 shot_jsr
0000D936 shot_vec
0000D948 mess_origin
0000D968 mess_table
0000D970 e_messages
0000D980 e_mess_0
0000D98C e_mess_1
0000D994 e_mess_2
0000D9B6 e_mess_3
0000D9D1 e_mess_4
0000D9EE e_mess_5
0000DA15 e_mess_6
0000DA20 e_mess_7
0000DA2A d_messages
0000DA3A d_mess_0
0000DA4A d_mess_1
0000DA53 d_mess_2
0000DA7A d_mess_3
0000DA9D d_mess_4
0000DAC0 d_mess_5
0000DAE6 d_mess_6
0000DAFC d_mess_7
0000DB06 f_messages
0000DB16 f_mess_0
0000DB25 f_mess_1
0000DB2C f_mess_2
0000DB50 f_mess_3
0000DB69 f_mess_4
0000DB8B f_mess_5
0000DBB4 f_mess_6
0000DBC6 f_mess_7
0000DBD4 s_messages
0000DBE4 s_mess_0
0000DBEC s_mess_1
0000DBF5 s_mess_2
0000DC1C s_mess_3
0000DC3A s_mess_4
0000DC62 s_mess_5
0000DC74 s_mess_6
0000DC81 s_mess_7
0000DC91 sound_init
0000DCF2 load_sound
0000DCF8 load_old_sound
0000DCFE play_sample
0000DD1A old_sound_play
0000DD1C exit_play_sample
0000DD1E sound_key
0000DD36 beat1_sound
0000DD48 beat2_sound
0000DD5A lexpl_sound
0000DD6F mexpl_sound
0000DD84 sexpl_sound
0000DD99 extra_sound
0000DDAF lgsau_sound
0000DDC4 smsau_sound
0000DDD9 thrst_sound
0000DDEC pfire_sound
0000DDFE sfire_sound
0000DE10 filename
0000DE1D variables
0000E000 JMPL
0000F000 SHRT
0001001C _Keybd_tick
00040004 TextScr
00040008 S19StartAddress
0004000C KeybdEcho
0004000D KeybdWaitFlag
00040040 CmdBuf
00040080 CmdBufEnd
00040084 fgColor
00040088 bkColor
0004008C TextRows
0004008D TextCols
00040094 _fpTextIncr
00040098 _canary
0004009C tickcnt
000400A0 IRQFlag
000400A4 InputDevice
000400A8 OutputDevice
00040100 Regsave
00040202 NumSetBreakpoints
00040220 Breakpoints
00040280 BreakpointWords
000402C0 fpBuf
00040508 _width
0004050C _E
00040510 _digits_before_decpt
00040514 _precision
00040520 _fpBuf
00040600 _fpWork
00040800 _dasmbuf
00040880 OFFSET
00040890 pen_color
00040894 gr_x
00040898 gr_y
0004089C gr_width
000408A0 gr_height
000408AC gr_double_buffer
000408B8 sys_switches
000408C0 gfxaccel_ctrl
000408D0 m_z
000408D4 m_w
000408D8 next_m_z
000408DC next_m_w
000408E0 TimeBuf
00040A00 null_dcb
00040A84 keybd_dcb
00040B08 textvid_dcb
00040B8C err_dcb
00040C94 serial_dcb
00040D18 framebuf_dcb
00040D9C gfxaccel_dcb
00041BFC TimerStack
00042000 spi_buff
00100000 IOFocus
00100004 memend
0010000E KeybdLEDs
0010000F _KeyState1
00100010 _KeyState2
00100011 _KeybdHead
00100012 _KeybdTail
00100013 _KeybdCnt
00100018 KeybdID
00100020 _KeybdBuf
00100080 _KeybdOBuf
00100150 S19Checksum
00100160 SerTailRcv
00100162 SerHeadRcv
00100164 SerRcvXon
00100165 SerRcvXoff
00100166 SerTailXmit
00100168 SerHeadXmit
0010016A SerXmitXoff
00100200 RTCBuf
00100224 RunningTCB
0010030C FreeTCB
0010031C QueueCycle
00100320 readyQ
00101000 SerRcvBuf
00102000 SerXmitBuf
008080FF def_plant
00FFFFFF def_animal
20010000 tcbs
56791123 DEV_HMASH

Sections:
00: "DATA" (0-218)
01: "seg500" (500-500)
02: "CODE" (0-70F1)


Source: "boot.asm"
                            	     1: ;-------------------------------------------------------------------------------
                            	     2: ;
                            	     3: ; system memory map
                            	     4: ;
                            	     5: ;
                            	     6: ; 00000000 +----------------+      <+
                            	     7: ;          | startup sp,pc  | 8 B   |
                            	     8: ; 00000008 +----------------+       |
                            	     9: ;					 |    vectors     | pair shared+
                            	    10: ; 00000400 +----------------+       |
                            	    11: ;					 |   bios mem     |       |
                            	    12: ; 00001000 +----------------+       |
                            	    13: ;					 |   bios code    |       |
                            	    14: ; 00008000 +----------------+      <+
                            	    15: ;					 |    unused      |
                            	    16: ; 00040000 +----------------+
                            	    17: ;					 |   local ram    |
                            	    18: ; 00042000 +----------------+
                            	    19: ;					 |    unused      |
                            	    20: ; 00100000 +----------------+
                            	    21: ;					 |   global ram   |
                            	    22: ; 00101000 +----------------+
                            	    23: ;					 | serial rcvbuf  |
                            	    24: ; 00102000 +----------------+
                            	    25: ;					 |    unused      |
                            	    26: ; 20000000 +----------------+
                            	    27: ;          |                |
                            	    28: ;          |                |
                            	    29: ;          |                |
                            	    30: ;          :  dram memory   : 512 MB
                            	    31: ;          |                |
                            	    32: ;          |                |
                            	    33: ;          |                |
                            	    34: ; 40000000 +----------------+
                            	    35: ;          |                |
                            	    36: ;          :     unused     :
                            	    37: ;          |                |
                            	    38: ; FD000000 +----------------+
                            	    39: ;          |                |
                            	    40: ;          :    I/O area    : 1.0 M
                            	    41: ;          |                |
                            	    42: ; FFE00000 +----------------+
                            	    43: ;          |                |
                            	    44: ;          :     unused     :
                            	    45: ;          |                |
                            	    46: ; FFFFFFFF +----------------+
                            	    47: ;
                            	    48: ;-------------------------------------------------------------------------------
                            	    49: ;
                            	    50: HAS_MMU equ 0
                            	    51: 
                            	    52: CTRLC	EQU		$03
                            	    53: CTRLH	EQU		$08
                            	    54: CTRLS	EQU		$13
                            	    55: CTRLX	EQU		$18
                            	    56: CTRLZ	EQU		$1A
                            	    57: LF		EQU		$0A
                            	    58: CR		EQU		$0D
                            	    59: XON		EQU		$11
                            	    60: XOFF	EQU		$13
                            	    61: 
                            	    62: SC_F12  EQU    $07
                            	    63: SC_C    EQU    $21
                            	    64: SC_T    EQU    $2C
                            	    65: SC_Z    EQU    $1A
                            	    66: SC_KEYUP	EQU		$F0
                            	    67: SC_EXTEND   EQU		$E0
                            	    68: SC_CTRL		EQU		$14
                            	    69: SC_RSHIFT	EQU		$59
                            	    70: SC_NUMLOCK	EQU		$77
                            	    71: SC_SCROLLLOCK	EQU	$7E
                            	    72: SC_CAPSLOCK		EQU	$58
                            	    73: SC_ALT		EQU		$11
                            	    74: SC_LSHIFT	EQU		$12
                            	    75: SC_DEL		EQU		$71		; extend
                            	    76: SC_LCTRL	EQU		$58
                            	    77: SC_TAB      EQU		$0D
                            	    78: 
                            	    79: 	if HAS_MMU
                            	    80: TEXTREG		EQU	$1E3FF00	; virtual addresses
                            	    81: txtscreen	EQU	$1E00000
                            	    82: semamem		EQU	$1E50000
                            	    83: ACIA			EQU	$1E60000
                            	    84: ACIA_RX		EQU	0
                            	    85: ACIA_TX		EQU	0
                            	    86: ACIA_STAT	EQU	4
                            	    87: ACIA_CMD	EQU	8
                            	    88: ACIA_CTRL	EQU	12
                            	    89: I2C2 			equ $01E69000
                            	    90: I2C_PREL 	equ 0
                            	    91: I2C_PREH 	equ 1
                            	    92: I2C_CTRL 	equ 2
                            	    93: I2C_RXR 	equ 3
                            	    94: I2C_TXR 	equ 3
                            	    95: I2C_CMD 	equ 4
                            	    96: I2C_STAT 	equ 4
                            	    97: PLIC			EQU	$1E90000
                            	    98: MMU				EQU $FDC00000	; physical address
                            	    99: leds			EQU	$1EFFF00	; virtual addresses
                            	   100: keybd			EQU	$1EFFE00
                            	   101: KEYBD			EQU	$1EFFE00
                            	   102: RAND			EQU	$1EFFD00
                            	   103: RAND_NUM	EQU	$1EFFD00
                            	   104: RAND_STRM	EQU	$1EFFD04
                            	   105: RAND_MZ		EQU $1EFFD08
                            	   106: RAND_MW		EQU	$1EFFD0C
                            	   107: RST_REG		EQU	$1EFFC00
                            	   108: IO_BITMAP	EQU $1F00000
                            	   109: 	else
                            	   110: TEXTREG		EQU	$FD03FF00	; virtual addresses
                            	   111: txtscreen	EQU	$FD000000
                            	   112: semamem		EQU	$FD050000
                            	   113: ACIA			EQU	$FD060000
                            	   114: ACIA_RX		EQU	0
                            	   115: ACIA_TX		EQU	0
                            	   116: ACIA_STAT	EQU	4
                            	   117: ACIA_CMD	EQU	8
                            	   118: ACIA_CTRL	EQU	12
                            	   119: I2C2 			equ $FD069000
                            	   120: I2C_PREL 	equ 0
                            	   121: I2C_PREH 	equ 1
                            	   122: I2C_CTRL 	equ 2
                            	   123: I2C_RXR 	equ 3
                            	   124: I2C_TXR 	equ 3
                            	   125: I2C_CMD 	equ 4
                            	   126: I2C_STAT 	equ 4
                            	   127: PLIC			EQU	$FD090000
                            	   128: MMU				EQU $FDC00000	; physical address
                            	   129: leds			EQU	$FD0FFF00	; virtual addresses
                            	   130: keybd			EQU	$FD0FFE00
                            	   131: KEYBD			EQU	$FD0FFE00
                            	   132: RAND			EQU	$FD0FFD00
                            	   133: RAND_NUM	EQU	$FD0FFD00
                            	   134: RAND_STRM	EQU	$FD0FFD04
                            	   135: RAND_MZ		EQU $FD0FFD08
                            	   136: RAND_MW		EQU	$FD0FFD0C
                            	   137: RST_REG		EQU	$FD0FFC00
                            	   138: IO_BITMAP	EQU $FD100000
                            	   139: 	endif
                            	   140: 
                            	   141: SERIAL_SEMA	EQU	2
                            	   142: KEYBD_SEMA	EQU	3
                            	   143: RAND_SEMA		EQU	4
                            	   144: SCREEN_SEMA	EQU	5
                            	   145: MEMORY_SEMA EQU 6
                            	   146: TCB_SEMA 		EQU	7
                            	   147: 
                            	   148: 	data
00:00000000 00040FFC        	   149: 	dc.l		$00040FFC
00:00000004 00000000        	   150: 	dc.l		start
00:00000008 00006950        	   151: 	dc.l		bus_err
00:0000000C 00000000        	   152: 	dc.l		0
00:00000010 00007040        	   153: 	dc.l		illegal_trap		* ILLEGAL instruction
00:00000014 00000000        	   154: 	dc.l		0
00:00000018 0000039E        	   155: 	dc.l		EXCEPTION_6			* CHK
00:0000001C 000003A6        	   156: 	dc.l		EXCEPTION_7			* TRAPV
00:00000020 00000000        	   157: 	dc.l		0
00:00000024 00000000        	   158: 	dc.l		0
                            	   159: 	
                            	   160: 	; 10
00:00000028 00000000        	   161: 	dc.l		0
00:0000002C 00000000        	   162: 	dc.l		0
00:00000030 00000000        	   163: 	dc.l		0
00:00000034 00000000        	   164: 	dc.l		0
00:00000038 00000000        	   165: 	dc.l		0
00:0000003C 00000000        	   166: 	dc.l		0
00:00000040 00000000        	   167: 	dc.l		0
00:00000044 00000000        	   168: 	dc.l		0
00:00000048 00000000        	   169: 	dc.l		0
00:0000004C 00000000        	   170: 	dc.l		0
                            	   171: 	
                            	   172: 	; 20
00:00000050 00000000        	   173: 	dc.l		0
00:00000054 00000000        	   174: 	dc.l		0
00:00000058 00000000        	   175: 	dc.l		0
00:0000005C 00000000        	   176: 	dc.l		0
00:00000060 00006FF4        	   177: 	dc.l		SpuriousIRQ
00:00000064 00000000        	   178: 	dc.l		0
00:00000068 00000000        	   179: 	dc.l		0
00:0000006C 00006FCE        	   180: 	dc.l		irq3_rout
00:00000070 00000000        	   181: 	dc.l		0
00:00000074 00000000        	   182: 	dc.l		0
                            	   183: 	
                            	   184: 	; 30
00:00000078 00006F88        	   185: 	dc.l		TickIRQ						; IRQ 30 - timer / keyboard
00:0000007C 00006FF6        	   186: 	dc.l		nmi_rout
00:00000080 00000000        	   187: 	dc.l		0
00:00000084 00000000        	   188: 	dc.l		0
00:00000088 00000000        	   189: 	dc.l		0
00:0000008C 00006954        	   190: 	dc.l		trap3							; breakpoint
00:00000090 00000000        	   191: 	dc.l		0
00:00000094 00000000        	   192: 	dc.l		0
00:00000098 00000000        	   193: 	dc.l		0
00:0000009C 00000000        	   194: 	dc.l		0
                            	   195: 
                            	   196: 	; 40
00:000000A0 00000000        	   197: 	dc.l		0
00:000000A4 00000000        	   198: 	dc.l		0
00:000000A8 00000000        	   199: 	dc.l		0
00:000000AC 00000000        	   200: 	dc.l		0
00:000000B0 00000000        	   201: 	dc.l		0
00:000000B4 00000000        	   202: 	dc.l		0
00:000000B8 00000000        	   203: 	dc.l		0
00:000000BC 000051A2        	   204: 	dc.l		TRAP15
00:000000C0 00000000        	   205: 	dc.l		0
00:000000C4 00000000        	   206: 	dc.l		0
                            	   207: 
                            	   208: 	; 50	
00:000000C8 00000000        	   209: 	dc.l		0
00:000000CC 00000000        	   210: 	dc.l		0
00:000000D0 00000000        	   211: 	dc.l		0
00:000000D4 00000000        	   212: 	dc.l		0
00:000000D8 00000000        	   213: 	dc.l		0
00:000000DC 00000000        	   214: 	dc.l		0
00:000000E0 00000000        	   215: 	dc.l		0
00:000000E4 00000000        	   216: 	dc.l		0
00:000000E8 00000000        	   217: 	dc.l		0
00:000000EC 00007056        	   218: 	dc.l		io_irq
                            	   219: 
                            	   220: 	; 60
00:000000F0 000057DE        	   221: 	dc.l		KeybdIRQ
00:000000F4 00006752        	   222: 	dc.l		SerialIRQ
00:000000F8 00000000        	   223: 	dc.l		0
00:000000FC 00007008        	   224: 	dc.l		brdisp_trap
00:00000100 00000000        	   225: 	dc.l		0
00:00000104 00000000        	   226: 	dc.l		0
00:00000108 00000000        	   227: 	dc.l		0
00:0000010C 00000000        	   228: 	dc.l		0
00:00000110 00000000        	   229: 	dc.l		0
00:00000114 00000000        	   230: 	dc.l		0
                            	   231: 
                            	   232: 	org			$400
                            	   233: 
                            	   234: InstalledIRQ:
00:00000400 00000000        	   235: 	dc.l		0
00:00000404 00000000        	   236: 	dc.l		0
00:00000408 00000000        	   237: 	dc.l		0
00:0000040C 00000000        	   238: 	dc.l		0
00:00000410 00000000        	   239: 	dc.l		0
00:00000414 00000000        	   240: 	dc.l		0
00:00000418 00000000        	   241: 	dc.l		0
00:0000041C 00000000        	   242: 	dc.l		0
                            	   243: 
00:00000420 00000000        	   244: 	dc.l		0
00:00000424 00000000        	   245: 	dc.l		0
00:00000428 00000000        	   246: 	dc.l		0
00:0000042C 00000000        	   247: 	dc.l		0
00:00000430 00000000        	   248: 	dc.l		0
00:00000434 00000000        	   249: 	dc.l		0
00:00000438 00000000        	   250: 	dc.l		0
00:0000043C 00000000        	   251: 	dc.l		0
                            	   252: 
00:00000440 00000000        	   253: 	dc.l		0
00:00000444 00000000        	   254: 	dc.l		0
00:00000448 00000000        	   255: 	dc.l		0
00:0000044C 00000000        	   256: 	dc.l		0
00:00000450 00000000        	   257: 	dc.l		0
00:00000454 00000000        	   258: 	dc.l		0
00:00000458 00000000        	   259: 	dc.l		0
00:0000045C 00000000        	   260: 	dc.l		0
                            	   261: 
00:00000460 00000000        	   262: 	dc.l		0
00:00000464 00000000        	   263: 	dc.l		0
00:00000468 00000000        	   264: 	dc.l		0
00:0000046C 00000000        	   265: 	dc.l		0
00:00000470 00000000        	   266: 	dc.l		0
00:00000474 00000000        	   267: 	dc.l		0
00:00000478 00000000        	   268: 	dc.l		0
00:0000047C 00000000        	   269: 	dc.l		0
                            	   270: 
00:00000480 00000000        	   271: 	dc.l		0
00:00000484 00000000        	   272: 	dc.l		0
00:00000488 00000000        	   273: 	dc.l		0
00:0000048C 00000000        	   274: 	dc.l		0
00:00000490 00000000        	   275: 	dc.l		0
00:00000494 00000000        	   276: 	dc.l		0
00:00000498 00000000        	   277: 	dc.l		0
00:0000049C 00000000        	   278: 	dc.l		0
                            	   279: 
00:000004A0 00000000        	   280: 	dc.l		0
00:000004A4 00000000        	   281: 	dc.l		0
00:000004A8 00000000        	   282: 	dc.l		0
00:000004AC 00000000        	   283: 	dc.l		0
00:000004B0 00000000        	   284: 	dc.l		0
00:000004B4 00000000        	   285: 	dc.l		0
00:000004B8 00000000        	   286: 	dc.l		0
00:000004BC 00000000        	   287: 	dc.l		0
                            	   288: 
00:000004C0 00000000        	   289: 	dc.l		0
00:000004C4 00000000        	   290: 	dc.l		0
00:000004C8 00000000        	   291: 	dc.l		0
00:000004CC 00000000        	   292: 	dc.l		0
00:000004D0 00000000        	   293: 	dc.l		0
00:000004D4 00000000        	   294: 	dc.l		0
00:000004D8 00000000        	   295: 	dc.l		0
00:000004DC 00000000        	   296: 	dc.l		0
                            	   297: 
00:000004E0 00000000        	   298: 	dc.l		0
00:000004E4 00000000        	   299: 	dc.l		0
00:000004E8 00000000        	   300: 	dc.l		0
00:000004EC 00000000        	   301: 	dc.l		0
00:000004F0 00000000        	   302: 	dc.l		0
00:000004F4 00000000        	   303: 	dc.l		0
00:000004F8 00000000        	   304: 	dc.l		0
00:000004FC 00000000        	   305: 	dc.l		0
                            	   306: 
                            	   307: 	org			$500
                            	   308: 
                            	   309: ;-------------------------------------------------------------------------------
                            	   310: ;-------------------------------------------------------------------------------
                            	   311: 
                            	   312: ; BIOS variables which must be local (not shared) to each core
                            	   313: 
                            	   314: CursorRow	equ		$40000
                            	   315: CursorCol	equ		$40001
                            	   316: TextPos		equ		$40002
                            	   317: TextCurpos	equ	$40002
                            	   318: TextScr			equ	$40004
                            	   319: S19StartAddress	equ	$40008
                            	   320: KeybdEcho		equ	$4000C
                            	   321: KeybdWaitFlag	equ	$4000D
                            	   322: CmdBuf			equ $40040
                            	   323: CmdBufEnd		equ	$40080
                            	   324: fgColor			equ	$40084
                            	   325: bkColor			equ	$40088
                            	   326: TextRows		equ	$4008C
                            	   327: TextCols		equ	$4008D
                            	   328: Regsave			equ	$40100
                            	   329: numBreakpoints	equ		8
                            	   330: BreakpointFlag	equ		$40200
                            	   331: NumSetBreakpoints	equ	$40202	; to $40203
                            	   332: Breakpoints			equ		$40220	; to $40240
                            	   333: BreakpointWords	equ		$40280	; to $402A0
                            	   334: fpBuf       equ $402C0
                            	   335: ;RunningTCB  equ $40300
                            	   336: _exp equ $40500
                            	   337: _digit equ $40504
                            	   338: _width equ $40508
                            	   339: _E equ $4050C
                            	   340: _digits_before_decpt equ $40510
                            	   341: _precision equ $40514
                            	   342: _fpBuf equ $40520	; to $40560
                            	   343: _fpWork equ $40600
                            	   344: TimerStack	equ	$40BFC
                            	   345: 
                            	   346: ; Keyboard buffer is in shared memory
                            	   347: IOFocus			EQU	$00100000
                            	   348: memend			equ $00100004
                            	   349: KeybdLEDs		equ	$0010000E
                            	   350: _KeyState1	equ	$0010000F
                            	   351: _KeyState2	equ	$00100010
                            	   352: _KeybdHead	equ	$00100011
                            	   353: _KeybdTail	equ	$00100012
                            	   354: _KeybdCnt		equ	$00100013
                            	   355: KeybdID			equ	$00100016
                            	   356: _KeybdBuf		equ	$00100020
                            	   357: S19Checksum	equ	$00100150
                            	   358: SerTailRcv	equ	$00100160
                            	   359: SerHeadRcv	equ	$00100162
                            	   360: SerRcvXon		equ	$00100164
                            	   361: SerRcvXoff	equ	$00100165
                            	   362: SerRcvBuf		equ	$00101000
                            	   363: RTCBuf			equ $00100200	; to $0010023F
                            	   364: 
                            	   365: 	include "..\Femtiki\source\kernel\Femtiki_vars.x68"

Source: "..\Femtiki\source\kernel\Femtiki_vars.x68"
                            	     1: 
                            	     2: PAMShareCounts	EQU	$20000000	; one byte for each physical page of memory
                            	     3: tcbs						EQU	$20010000	; 4095*256 = 1MB
                            	     4: tcbs_end				EQU	$20020000
                            	     5: messages				EQU	$20020000	; 32*8192 (680*16=21760 messages)
                            	     6: messages_end		EQU	$20060000
                            	     7: mailboxes				EQU	$20060000
                            	     8: mailboxes_end		EQU	$20078000	;	12*8192 (816*12=9792 mailboxes)
                            	     9: acbs						EQU	$20080000	; 32*2*8192 =512kB
                            	    10: acbs_end				EQU	$20100000
                            	    11: 
                            	    12: 
                            	    13: sys_stacks			EQU	$DF0000
                            	    14: 
                            	    15: FemtikiVars			EQU	$00100200
                            	    16: PAMLastAllocate2	EQU		$00100218
                            	    17: RunningAID		EQU		$00100220
                            	    18: RunningTCB			EQU		$00100224
                            	    19: ACBPtrs				EQU		$00100228
                            	    20: MidStackBottoms	EQU		$00100264
                            	    21: FemtikiInited	EQU		$00100284
                            	    22: missed_ticks	EQU		$00100288
                            	    23: IOFocusList		EQU		$0010028C
                            	    24: IOFocusID			EQU		$001002AC
                            	    25: iof_switch		EQU		$001002AD
                            	    26: nMessage			EQU		$001002AE
                            	    27: nMailbox			EQU		$001002B0
                            	    28: hKeybdMbx			EQU		$001002BA
                            	    29: hFocusSwitchMbx		EQU		$001002BC
                            	    30: BIOS_RespMbx	EQU		$001002BE
                            	    31: hasUltraHighPriorityTasks	EQU		$001002C0
                            	    32: im_save				EQU		$001002C2
                            	    33: sp_tmp				EQU		$001002C4
                            	    34: startQNdx			EQU		$001002C6
                            	    35: NPAGES				EQU		$001002D8
                            	    36: syspages			EQU		$001002DA
                            	    37: mmu_FreeMaps	EQU		$001002E0
                            	    38: mmu_entries		EQU		$00100300
                            	    39: freelist			EQU		$00100302
                            	    40: hSearchMap		EQU		$00100304
                            	    41: OSActive			EQU		$00100305
                            	    42: FreeACB				EQU		$00100308
                            	    43: FreeTCB				EQU		$0010030C
                            	    44: FreeMSG				EQU		$00100310
                            	    45: FreeMBX				EQU		$00100314
                            	    46: TimeoutList		EQU		$00100318
                            	    47: QueueCycle    EQU   $0010031C
                            	    48: readyQ				EQU		$00100320
                            	    49: readyQTail		EQU		$00100340
                            	    50: FemtikiVars_end	EQU	$00100400
                            	    51: 
                            	    52: ;gc_stack		rmb		512
                            	    53: ;gc_pc				fcdw		0
                            	    54: ;gc_omapno		fcw			0
                            	    55: ;gc_mapno		fcw			0
                            	    56: ;gc_dl				fcw			0
                            	    57: 

Source: "boot.asm"
                            	   366: 
                            	   367: 	code
                            	   368: 	align		2
                            	   369: start:
                            	   370: ;	fadd (a0)+,fp2
02:00000000 46FC2700        	   371: 	move.w #$2700,sr					; enable level 6 and higher interrupts
02:00000004 7000            	   372: 	moveq #0,d0								; set address space zero
02:00000006 4E7B0003        	   373: 	movec d0,asid
                            	   374: 	; Setup circuit select signals
02:0000000A 203CFDC00000    	   375: 	move.l #MMU,d0
02:00000010 4E7B0014        	   376: 	movec d0,mmus
                            	   377: 	if HAS_MMU
                            	   378: 		move.l #$01F00000,d0			; set virtual address for iop bitmap
                            	   379: 		movec d0,iops
                            	   380: 		move.l #$01E00000,d0			; set virtual address for io block
                            	   381: 		movec d0,ios
                            	   382: 	else
02:00000014 203CFD100000    	   383: 		move.l #$FD100000,d0			; set virtual address for iop bitmap
02:0000001A 4E7B0016        	   384: 		movec d0,iops
02:0000001E 203CFD000000    	   385: 		move.l #$FD000000,d0			; set virtual address for io block
02:00000024 4E7B0015        	   386: 		movec d0,ios
                            	   387: 	endif
02:00000028 4E7A0FE0        	   388: 	movec coreno,d0							; set initial value of thread register
02:0000002C 4840            	   389: 	swap d0											; coreno in high eight bits
02:0000002E E188            	   390: 	lsl.l #8,d0
02:00000030 4E7B0012        	   391: 	movec d0,tr
                            	   392: 	; Prepare local variable storage
02:00000034 303C03FF        	   393: 	move.w #1023,d0						; 1024 longs to clear
02:00000038 41F900040000    	   394: 	lea	$40000,a0							; non shared local memory address
                            	   395: .0111:
02:0000003E 4298            	   396: 	clr.l	(a0)+								; clear the memory area
02:00000040 51C8FFFC        	   397: 	dbra d0,.0111
02:00000044 23FC001FFFFF0004	   398: 	move.l #$1fffff,fgColor		; set foreground / background color
02:0000004C 0084
02:0000004E 23FC0000003F0004	   399: 	move.l #$00003f,bkColor
02:00000056 0088
02:00000058 4E7A0FE0        	   400: 	movec.l	coreno,d0					; get core number (2 to 9)
02:0000005C 5500            	   401: 	subi.b #2,d0							; adjust (0 to 7)
02:0000005E C0FC4000        	   402: 	mulu #16384,d0						; compute screen location
                            	   403: 	if HAS_MMU
                            	   404: 		addi.l #$01E00000,d0
                            	   405: 	else
02:00000062 0680FD000000    	   406: 		addi.l #$FD000000,d0
                            	   407: 	endif
02:00000068 23C000040004    	   408: 	move.l d0,TextScr
02:0000006E 13FC00400004008D	   409: 	move.b #64,TextCols				; set rows and columns
02:00000076 13FC00200004008C	   410: 	move.b #32,TextRows
02:0000007E 4E7A0FE0        	   411: 	movec.l	coreno,d0					; get core number
02:00000082 0C000002        	   412: 	cmpi.b #2,d0
02:00000086 6668            	   413: 	bne	start_other
02:00000088 13C000100000    	   414: 	move.b d0,IOFocus					; Set the IO focus in global memory
                            	   415: 	if HAS_MMU
                            	   416: 		bsr InitMMU							; Can't access anything till this is done
                            	   417: 	endif
02:0000008E 61000082        	   418: 	bsr	InitIOPBitmap					; not going to get far without this
02:00000092 61000154        	   419: 	bsr	InitSemaphores
02:00000096 610000CA        	   420: 	bsr	InitRand
02:0000009A 610001D6        	   421: 	bsr	Delay3s						; give devices time to reset
02:0000009E 61004D70        	   422: 	bsr	clear_screen
                            	   423: 
02:000000A2 610052CA        	   424: 	bsr	_KeybdInit
                            	   425: ;	bsr	InitIRQ
02:000000A6 6100656A        	   426: 	bsr	SerialInit
02:000000AA 61006736        	   427: 	bsr init_i2c
                            	   428: ;	bsr rtc_read
                            	   429: 
                            	   430: 	; Write startup message to screen
                            	   431: 
02:000000AE 43FA6FBA        	   432: 	lea	msg_start,a1
02:000000B2 61005070        	   433: 	bsr	DisplayString
                            	   434: ;	bsr	FemtikiInit
02:000000B6 4E7A0FE0        	   435: 	movec	coreno,d0
02:000000BA 4840            	   436: 	swap d0
02:000000BC 7201            	   437: 	moveq	#1,d1
02:000000BE 6100018A        	   438: 	bsr	UnlockSemaphore	; allow another cpu access
02:000000C2 7200            	   439: 	moveq	#0,d1
02:000000C4 61000184        	   440: 	bsr	UnlockSemaphore	; allow other cpus to proceed
02:000000C8 33FCA4A4FD0FFF00	   441: 	move.w #$A4A4,leds			; diagnostics
02:000000D0 610051FC        	   442: 	bsr	init_plic				; initialize platform level interrupt controller
02:000000D4 60005B00        	   443: 	bra	StartMon
02:000000D8 610001D8        	   444: 	bsr	cpu_test
                            	   445: ;	lea	brdisp_trap,a0	; set brdisp trap vector
                            	   446: ;	move.l	a0,64*4
                            	   447: 
                            	   448: loop2:
02:000000DC 70FF            	   449: 	move.l	#-1,d0
                            	   450: loop1:
02:000000DE 2200            	   451: 	move.l	d0,d1
02:000000E0 E089            	   452: 	lsr.l		#8,d1
02:000000E2 E089            	   453: 	lsr.l		#8,d1
02:000000E4 13C1FD0FFF00    	   454: 	move.b	d1,leds
02:000000EA 51C8FFF2        	   455: 	dbra		d0,loop1
02:000000EE 60EC            	   456: 	bra			loop2
                            	   457: 
                            	   458: start_other:
02:000000F0 610001A4        	   459: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
02:000000F4 610001A0        	   460: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
02:000000F8 61004D16        	   461: 	bsr			clear_screen
02:000000FC 4E7A1FE0        	   462: 	movec		coreno,d1
02:00000100 610061F4        	   463: 	bsr			DisplayByte
02:00000104 43FA6F8B        	   464: 	lea			msg_core_start,a1
02:00000108 6100501A        	   465: 	bsr			DisplayString
                            	   466: ;	bsr			FemtikiInitIRQ
                            	   467: do_nothing:	
02:0000010C 60005AC8        	   468: 	bra			StartMon
02:00000110 60FA            	   469: 	bra			do_nothing
                            	   470: 
                            	   471: ;------------------------------------------------------------------------------
                            	   472: ; Initialize the MMU to allow thread #0 access to IO
                            	   473: ;------------------------------------------------------------------------------
                            	   474: 	if HAS_MMU
                            	   475: 	align 2
                            	   476: mmu_adrtbl:	; virtual address[24:16], physical address[31:16] bytes reversed!
                            	   477: 	dc.l	$0010,$10000300	; global scratch pad
                            	   478: 	dc.l	$01E0,$00FD0300	
                            	   479: 	dc.l	$01E1,$01FD0300
                            	   480: 	dc.l	$01E2,$02FD0300
                            	   481: 	dc.l  $01E3,$03FD0300
                            	   482: 	dc.l	$01E5,$05FD0300
                            	   483: 	dc.l	$01E6,$06FD0300
                            	   484: 	dc.l	$01E9,$09FD0300
                            	   485: 	dc.l	$01EF,$0FFD0300
                            	   486: 	dc.l	$01F0,$10FD0300
                            	   487: 	dc.l  $01FF,$FFFF0300	; all ones output for IRQ ack needed
                            	   488: 
                            	   489: 	even
                            	   490: InitMMU:
                            	   491: 	lea MMU+8,a0				; first 128kB is local RAM
                            	   492: 	move.l #$32000,d2		; map all pages to DRAM
                            	   493: 	move.l #510,d0			; then override for IO later
                            	   494: .0002
                            	   495: 	move.l d2,d1
                            	   496: 	bsr rbo
                            	   497: 	move.l d1,(a0)+
                            	   498: 	addi.w #1,d2				; increment DRAM page number
                            	   499: 	dbra d0,.0002
                            	   500: 	lea MMU,a0					; now program IO access
                            	   501: 	lea mmu_adrtbl,a1
                            	   502: 	moveq #10,d0
                            	   503: .0001
                            	   504: 	move.l (a1)+,d2
                            	   505: 	lsl.l #2,d2
                            	   506: 	move.l (a1)+,(a0,d2.w)
                            	   507: 	dbra d0,.0001
                            	   508: 	rts	
                            	   509: 	endif
                            	   510: 
                            	   511: ;------------------------------------------------------------------------------
                            	   512: ; The IO bitmap needs to be initialized to allow access to IO.
                            	   513: ;------------------------------------------------------------------------------
                            	   514: 
                            	   515: InitIOPBitmap:
02:00000112 7600            	   516: 	moveq #0,d3				; d3 = asid value
02:00000114 303C003F        	   517: 	move.w #63,d0			; 64 bitmaps to setup
02:00000118 4E7A8016        	   518: 	movec iops,a0			; a0 = IOP bitmap address
02:0000011C 2248            	   519: 	movea.l a0,a1			; a1 = table address
                            	   520: .0004
02:0000011E 4A03            	   521: 	tst.b d3
02:00000120 57C1            	   522: 	seq d1						; set entire bitmap for asid 0, otherwise clear entire bitmap
02:00000122 4881            	   523: 	ext.w	d1					; make into a long value
02:00000124 48C1            	   524: 	ext.l d1
02:00000126 383C007F        	   525: 	move.w #127,d4
                            	   526: .0001
02:0000012A 22C1            	   527: 	move.l d1,(a1)+		; set or clear entire table
02:0000012C 51CCFFFC        	   528: 	dbra d4,.0001
02:00000130 72FF            	   529: 	moveq #-1,d1
02:00000132 214100A0        	   530: 	move.l d1,160(a0)	; all cores have access to semaphores
02:00000136 214100A4        	   531: 	move.l d1,164(a0)
02:0000013A 214100A8        	   532: 	move.l d1,168(a0)
02:0000013E 214100AC        	   533: 	move.l d1,172(a0)
02:00000142 217C0000000201FC	   534: 	move.l #2,508(a0)	; all cores access random # generator
02:0000014A 4840            	   535: 	swap d0
02:0000014C 303C001F        	   536: 	move.w #31,d0			; 32 long words for the screen area per bitmap
                            	   537: .0003
02:00000150 20C1            	   538: 	move.l d1,(a0)+		; all cores have access to a screen
02:00000152 51C8FFFC        	   539: 	dbra d0,.0003
02:00000156 4840            	   540: 	swap d0
02:00000158 5203            	   541: 	addi.b #1,d3			; do next address space
02:0000015A 2049            	   542: 	movea.l a1,a0			; a0 points to area for next address space
02:0000015C 51C8FFC0        	   543: 	dbra d0,.0004
02:00000160 4E75            	   544: 	rts	
                            	   545: 	
                            	   546: ;------------------------------------------------------------------------------
                            	   547: ; RandInit
                            	   548: ; 	Initialize random number generator.
                            	   549: ;
                            	   550: ; Modifies:
                            	   551: ;		none
                            	   552: ; Parameters:
                            	   553: ;		none
                            	   554: ;	Returns:
                            	   555: ;		none
                            	   556: ;------------------------------------------------------------------------------
                            	   557: 
                            	   558: InitRand:
                            	   559: RandInit:
02:00000162 48E7C000        	   560: 	movem.l	d0/d1,-(a7)
02:00000166 7025            	   561: 	moveq #37,d0								; lock semaphore
02:00000168 7204            	   562: 	moveq	#RAND_SEMA,d1
02:0000016A 4E4F            	   563: 	trap #15
02:0000016C 4E7A0FE0        	   564: 	movec coreno,d0							; d0 = core number
02:00000170 ED88            	   565: 	lsl.l	#6,d0									; allow 64 streams per core
02:00000172 23C0FD0FFD04    	   566: 	move.l d0,RAND_STRM					; select the stream
02:00000178 23FC12345678FD0F	   567: 	move.l #$12345678,RAND_MZ		; initialize to some value
02:00000180 FD08
02:00000182 23FC98765432FD0F	   568: 	move.l #$98765432,RAND_MW
02:0000018A FD0C
02:0000018C 23FC2E5BF271FD0F	   569: 	move.l #777777777,RAND_NUM	; generate first number
02:00000194 FD00
02:00000196 7026            	   570: 	moveq #38,d0								; unlock semaphore
02:00000198 7204            	   571: 	moveq	#RAND_SEMA,d1
02:0000019A 4E4F            	   572: 	trap #15
02:0000019C 4CDF0003        	   573: 	movem.l	(a7)+,d0/d1
02:000001A0 4E75            	   574: 	rts
                            	   575: 
                            	   576: ;------------------------------------------------------------------------------
                            	   577: ;------------------------------------------------------------------------------
                            	   578: 
                            	   579: RandGetNum:
02:000001A2 48E7A000        	   580: 	movem.l	d0/d2,-(a7)
02:000001A6 7025            	   581: 	moveq #37,d0								; lock semaphore
02:000001A8 7204            	   582: 	moveq	#RAND_SEMA,d1
02:000001AA 4E4F            	   583: 	trap #15
02:000001AC 4E7A0FE0        	   584: 	movec	coreno,d0
02:000001B0 ED88            	   585: 	lsl.l	#6,d0
02:000001B2 23C0FD0FFD04    	   586: 	move.l d0,RAND_STRM					; select the stream
02:000001B8 2439FD0FFD00    	   587: 	move.l RAND_NUM,d2					; d2 = random number
02:000001BE 42B9FD0FFD00    	   588: 	clr.l	RAND_NUM							; generate next number
02:000001C4 7026            	   589: 	moveq #38,d0								; unlock semaphore
02:000001C6 7204            	   590: 	moveq	#RAND_SEMA,d1
02:000001C8 4E4F            	   591: 	trap #15
02:000001CA 2202            	   592: 	move.l d2,d1
02:000001CC 4CDF0005        	   593: 	movem.l	(a7)+,d0/d2
02:000001D0 4E75            	   594: 	rts
                            	   595: 
                            	   596: ;------------------------------------------------------------------------------
                            	   597: ; RandWait
                            	   598: ;    Wait some random number of clock cycles before returning.
                            	   599: ;------------------------------------------------------------------------------
                            	   600: 
                            	   601: RandWait:
02:000001D2 48E7C000        	   602: 	movem.l	d0/d1,-(a7)
02:000001D6 61CA            	   603: 	bsr			RandGetNum
02:000001D8 0241000F        	   604: 	andi.w	#15,d1
                            	   605: .0001:
02:000001DC 4E71            	   606: 	nop
02:000001DE 51C9FFFC        	   607: 	dbra		d1,.0001
02:000001E2 4CDF0003        	   608: 	movem.l	(a7)+,d0/d1
02:000001E6 4E75            	   609: 	rts
                            	   610: 
                            	   611: ;------------------------------------------------------------------------------
                            	   612: ; Initialize semaphores
                            	   613: ; - all semaphores are set to unlocked except the first one, which is locked
                            	   614: ; for core #2.
                            	   615: ;
                            	   616: ; Parameters:
                            	   617: ;		<none>
                            	   618: ; Modifies:
                            	   619: ;		<none>
                            	   620: ; Returns:
                            	   621: ;		<none>
                            	   622: ;------------------------------------------------------------------------------
                            	   623: 
                            	   624: InitSemaphores:
02:000001E8 48E74080        	   625: 	movem.l	d1/a0,-(a7)
02:000001EC 41F9FD050000    	   626: 	lea			semamem,a0
02:000001F2 217C000200002000	   627: 	move.l	#$20000,$2000(a0)	; lock the first semaphore for core #2, thread #0
02:000001FA 323C00FE        	   628: 	move.w	#254,d1
                            	   629: .0001:
02:000001FE 5888            	   630: 	lea			4(a0),a0
02:00000200 42A82000        	   631: 	clr.l		$2000(a0)					; write zeros to unlock
02:00000204 51C9FFF8        	   632: 	dbra		d1,.0001
02:00000208 4CDF0102        	   633: 	movem.l	(a7)+,d1/a0
02:0000020C 4E75            	   634: 	rts
                            	   635: 
                            	   636: ; -----------------------------------------------------------------------------
                            	   637: ; Parameters:
                            	   638: ;		d1 semaphore number
                            	   639: ;
                            	   640: ; Side Effects:
                            	   641: ;		increments semaphore, saturates at 255
                            	   642: ;
                            	   643: ; Returns:	
                            	   644: ; 	z flag set if semaphore was zero
                            	   645: ; -----------------------------------------------------------------------------
                            	   646: 
                            	   647: ;IncrementSemaphore:
                            	   648: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   649: ;	lea			semamem,a0			; point to semaphore memory
                            	   650: ;	ext.w		d1							; make d1 word value
                            	   651: ;	asl.w		#4,d1						; align to memory
                            	   652: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   653: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   654: ;	rts
                            	   655: 	
                            	   656: ; -----------------------------------------------------------------------------
                            	   657: ; Parameters:
                            	   658: ;		d1 semaphore number
                            	   659: ;
                            	   660: ; Side Effects:
                            	   661: ;		decrements semaphore, saturates at zero
                            	   662: ;
                            	   663: ; Returns:	
                            	   664: ; 	z flag set if semaphore was zero
                            	   665: ; -----------------------------------------------------------------------------
                            	   666: 
                            	   667: ;DecrementSemaphore:
                            	   668: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   669: ;	lea			semamem,a0			; point to semaphore memory
                            	   670: ;	andi.w	#255,d1					; make d1 word value
                            	   671: ;	asl.w		#4,d1						; align to memory
                            	   672: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   673: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   674: ;	rts
                            	   675: 
                            	   676: ; -----------------------------------------------------------------------------
                            	   677: ; Lock a semaphore
                            	   678: ;
                            	   679: ; Parameters:
                            	   680: ;		d0 = key
                            	   681: ;		d1 = semaphore number
                            	   682: ; -----------------------------------------------------------------------------
                            	   683: 
                            	   684: LockSemaphore:
02:0000020E 4E75            	   685: 	rts
02:00000210 48E74080        	   686: 	movem.l	d1/a0,-(a7)			; save registers
02:00000214 41F9FD050000    	   687: 	lea			semamem,a0			; point to semaphore memory lock area
02:0000021A 024100FF        	   688: 	andi.w	#255,d1					; make d1 word value
02:0000021E E549            	   689: 	lsl.w		#2,d1						; align to memory
                            	   690: .0001
02:00000220 21801000        	   691: 	move.l	d0,(a0,d1.w)		; try and write the semaphore
02:00000224 B0B01000        	   692: 	cmp.l		(a0,d1.w),d0		; did it lock?
02:00000228 66F6            	   693: 	bne.s		.0001						; no, try again
02:0000022A 4CDF0102        	   694: 	movem.l	(a7)+,a0/d1			; restore regs
02:0000022E 4E75            	   695: 	rts
                            	   696: 	
                            	   697: ; -----------------------------------------------------------------------------
                            	   698: ; Unlocks a semaphore even if not the owner.
                            	   699: ;
                            	   700: ; Parameters:
                            	   701: ;		d1 semaphore number
                            	   702: ; -----------------------------------------------------------------------------
                            	   703: 
                            	   704: ForceUnlockSemaphore:
02:00000230 48E74080        	   705: 	movem.l	d1/a0,-(a7)				; save registers
02:00000234 41F9FD053000    	   706: 	lea			semamem+$3000,a0	; point to semaphore memory read/write area
02:0000023A 024100FF        	   707: 	andi.w	#255,d1						; make d1 word value
02:0000023E E549            	   708: 	lsl.w		#2,d1							; align to memory
02:00000240 42B01000        	   709: 	clr.l		(a0,d1.w)					; write zero to unlock
02:00000244 4CDF0102        	   710: 	movem.l	(a7)+,a0/d1				; restore regs
02:00000248 4E75            	   711: 	rts
                            	   712: 
                            	   713: ; -----------------------------------------------------------------------------
                            	   714: ; Unlocks a semaphore. Must be the owner to have effect.
                            	   715: ; Three cases:
                            	   716: ;	1) the owner, the semaphore will be reset to zero
                            	   717: ;	2) not the owner, the write will be ignored
                            	   718: ; 3) already unlocked, the write will be ignored
                            	   719: ;
                            	   720: ; Parameters:
                            	   721: ;		d0 = key
                            	   722: ;		d1 = semaphore number
                            	   723: ; -----------------------------------------------------------------------------
                            	   724: 
                            	   725: UnlockSemaphore:
02:0000024A 60E4            	   726: 	bra ForceUnlockSemaphore
02:0000024C 48E74080        	   727: 	movem.l	d1/a0,-(a7)				; save registers
02:00000250 41F9FD051000    	   728: 	lea			semamem+$1000,a0	; point to semaphore memory unlock area
02:00000256 024100FF        	   729: 	andi.w	#255,d1						; make d1 word value
02:0000025A E549            	   730: 	lsl.w		#2,d1							; align to memory
02:0000025C 21801000        	   731: 	move.l	d0,(a0,d1.w)			; write matching value to unlock
02:00000260 4CDF0102        	   732: 	movem.l	(a7)+,a0/d1				; restore regs
02:00000264 4E75            	   733: 	rts
                            	   734: 
                            	   735: ; -----------------------------------------------------------------------------
                            	   736: ; Parameters:
                            	   737: ;		d1 = semaphore to lock / unlock
                            	   738: ; -----------------------------------------------------------------------------
                            	   739: 
                            	   740: T15LockSemaphore:	
02:00000266 4E7A0012        	   741: 	movec tr,d0
02:0000026A 60A2            	   742: 	bra LockSemaphore
                            	   743: 
                            	   744: T15UnlockSemaphore:
02:0000026C 4E7A0012        	   745: 	movec tr,d0
02:00000270 60D8            	   746: 	bra UnlockSemaphore
                            	   747: 
                            	   748: ; -----------------------------------------------------------------------------
                            	   749: ; Delay for a few seconds to allow some I/O reset operations to take place.
                            	   750: ; -----------------------------------------------------------------------------
                            	   751: 
                            	   752: Delay3s:
02:00000272 203C002DC6C0    	   753: 	move.l	#3000000,d0		; this should take a few seconds to loop
02:00000278 41F9FD0FFF00    	   754: 	lea			leds,a0				; a0 = address of LED output register
02:0000027E 6002            	   755: 	bra			dly3s1				; branch to the loop
                            	   756: dly3s2:	
02:00000280 4840            	   757: 	swap		d0						; loop is larger than 16-bits
                            	   758: dly3s1:
02:00000282 2200            	   759: 	move.l	d0,d1					; the counter cycles fast, so use upper bits for display
02:00000284 E199            	   760: 	rol.l		#8,d1					; could use swap here, but lets test rol
02:00000286 E199            	   761: 	rol.l		#8,d1
02:00000288 1081            	   762: 	move.b	d1,(a0)				; set the LEDs
02:0000028A 51C8FFF6        	   763: 	dbra		d0,dly3s1			; decrement and branch back
02:0000028E 4840            	   764: 	swap		d0
02:00000290 51C8FFEE        	   765: 	dbra		d0,dly3s2
02:00000294 4E75            	   766: 	rts
                            	   767: 
                            	   768: Delay3s2:
02:00000296 4E7A0FE0        	   769: 	movec		coreno,d0			; vary delay by core to stagger startup
02:0000029A E188            	   770: 	lsl.l		#8,d0
02:0000029C 0680002DC6C0    	   771: 	addi.l	#3000000,d0		; this should take a few seconds to loop
02:000002A2 6002            	   772: 	bra			.0001					; branch to the loop
                            	   773: .0002	
02:000002A4 4840            	   774: 	swap		d0						; loop is larger than 16-bits
                            	   775: .0001
02:000002A6 51C8FFFE        	   776: 	dbra		d0,.0001			; decrement and branch back
02:000002AA 4840            	   777: 	swap		d0
02:000002AC 51C8FFF6        	   778: 	dbra		d0,.0002
02:000002B0 4E75            	   779: 	rts
                            	   780: 
                            	   781: 	include "cputest.asm"

Source: "cputest.asm"
                            	     1: ** @name cputest.s Tests 68000 cpu
                            	     2: *
                            	     3: * Based on https://github.com/MicroCoreLabs/Projects/blob/master/MCL68/MC68000_Test_Code/MC68000_test_all_opcodes.X68
                            	     4: *
                            	     5: * Converted into a CD-i system ROM image by CD-i Fan:
                            	     6: * - comment lines must start in first column
                            	     7: * - replaced org instructions by suitable rept
                            	     8: * - copy vectors to low memory at startup
                            	     9: * - replaced jsr/jmp by bsr/bra for position independence
                            	    10: * - replaced move.l by moveq whenever possible
                            	    11: * - converted branches to short form whenever possible (e.g. beq => beq.s)
                            	    12: * - added immediate suffix to opcodes where required (e.g. and => andi)
                            	    13: * The last three modifications are required to make the test work;
                            	    14: * apparently the original assembler was somewhat smarter then
                            	    15: * the Microware OS-9 assembler and did this automatically.
                            	    16: *
                            	    17: * In some cases the opcodes of the test are used as test data!
                            	    18: *
                            	    19: * Original file header follows.
                            	    20: *
                            	    21: *  File Name   :  MCL68 Opcode Tests
                            	    22: *  Used on     :
                            	    23: *  Author      :  Ted Fried, MicroCore Labs
                            	    24: *  Creation    :  7/14/2020
                            	    25: *
                            	    26: *   Description:
                            	    27: *   ============
                            	    28: *
                            	    29: *  Program to test all of the Motorola 68000's opcodes.
                            	    30: *
                            	    31: *  If failures are detected, the code will immediately loop on itself.
                            	    32: *  All addressing modes, data sizes, and opcode combinations are tested.
                            	    33: *
                            	    34: *  This code was developed using the Easy68K simulator where all tests passed!
                            	    35: *
                            	    36: *------------------------------------------------------------------------
                            	    37: *
                            	    38: * Modification History:
                            	    39: * =====================
                            	    40: *
                            	    41: * Revision 1 7/14/2020
                            	    42: * Initial revision
                            	    43: *
                            	    44: *
                            	    45: *------------------------------------------------------------------------
                            	    46: *
                            	    47: * Copyright (c) 2020 Ted Fried
                            	    48: *
                            	    49: * Permission is hereby granted, free of charge, to any person obtaining a copy
                            	    50: * of this software and associated documentation files (the "Software"), to deal
                            	    51: * in the Software without restriction, including without limitation the rights
                            	    52: * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                            	    53: * copies of the Software, and to permit persons to whom the Software is
                            	    54: * furnished to do so, subject to the following conditions:
                            	    55: *
                            	    56: * The above copyright notice and this permission notice shall be included in all
                            	    57: * copies or substantial portions of the Software.
                            	    58: *
                            	    59: * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            	    60: * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            	    61: * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            	    62: * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            	    63: * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                            	    64: * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                            	    65: * SOFTWARE.
                            	    66: 
                            	    67: * Modified for rf68000 project (c) 2022 Robert Finch
                            	    68: 
                            	    69: *	data
                            	    70: *	dc.l		$0001FFFC						; top of local ram area
                            	    71: *	dc.l		start
                            	    72: 
                            	    73: *    org $1000												; code starts at $400 in local ram
                            	    74: *start:
                            	    75: *	move.l	$FFFFFFE0,d0		; get core number
                            	    76: *	cmpi.b	#2,d0
                            	    77: *	bne			do_nothing
                            	    78: 
                            	    79: *	lea			EXCEPTION_6,a0	* check exception vector
                            	    80: *	move.l	a0,6*4
                            	    81: *	lea			EXCEPTION_7,a0	* TRAPV exception vector
                            	    82: *	move.l	a0,7*4
                            	    83: 
                            	    84: cpu_test:
02:000002B2 610000FA        	    85: 	bsr	op_ORI_TO_CCR
02:000002B6 61000118        	    86: 	bsr	op_ORI_TO_SR
02:000002BA 61000136        	    87: 	bsr	op_EORI_TO_CCR
02:000002BE 61000158        	    88: 	bsr	op_EORI_TO_SR
02:000002C2 6100017A        	    89: 	bsr	op_ANDI_TO_CCR
02:000002C6 6100019C        	    90: 	bsr	op_ANDI_TO_SR
02:000002CA 610001BE        	    91: 	bsr	op_BTST
02:000002CE 61000564        	    92: 	bsr	op_BCHG
02:000002D2 610008C8        	    93: 	bsr	op_BCLR
02:000002D6 61000C12        	    94: 	bsr	op_BSET
02:000002DA 61000F56        	    95: 	bsr op_MOVEP
02:000002DE 61000FDE        	    96: 	bsr op_BOOL_I
02:000002E2 610011C2        	    97: 	bsr op_CMP_I
02:000002E6 610013A6        	    98: 	bsr op_ADD_I
02:000002EA 61001528        	    99: 	bsr op_SUB_I
02:000002EE 610016AA        	   100: 	bsr op_MOVE
02:000002F2 610018B2        	   101: 	bsr op_MOVE_xxx_FLAGS
02:000002F6 61001AA2        	   102: 	bsr op_EXT
02:000002FA 61001ACA        	   103: 	bsr op_SWAP
02:000002FE 61001ADC        	   104: 	bsr op_LEAPEA
02:00000302 61001B84        	   105: 	bsr op_TAS
02:00000306 61001BA6        	   106: 	bsr op_TST
02:0000030A 61001BE0        	   107: 	bsr op_LINKS
02:0000030E 61001BFA        	   108: 	bsr op_MOVE_USP
02:00000312 61001C06        	   109: 	bsr op_CHK
02:00000316 61001C3C        	   110: 	bsr op_NEGS
02:0000031A 61001FC6        	   111: 	bsr op_MOVEM
                            	   112: *	bsr op_ABCD
                            	   113: *	bsr op_SBCD
                            	   114: *	bsr op_NBCD
02:0000031E 61002562        	   115: 	bsr op_TRAPV
02:00000322 6100257A        	   116: 	bsr op_RTR
02:00000326 61001148        	   117: 	bsr op_BSR
02:0000032A 61002594        	   118: 	bsr op_BCC
02:0000032E 61002610        	   119: 	bsr op_DBCC
02:00000332 61002632        	   120: 	bsr op_SCC
02:00000336 6100265E        	   121: 	bsr op_ADDQ
02:0000033A 61002714        	   122: 	bsr op_SUBQ
02:0000033E 610027CA        	   123: 	bsr op_MOVEQ
02:00000342 610027E2        	   124: 	bsr op_DIVU
                            	   125: *	bsr op_DIVS
02:00000346 61002882        	   126: 	bsr op_OR
02:0000034A 61002968        	   127: 	bsr op_AND
02:0000034E 61002A4E        	   128: 	bsr op_EOR
02:00000352 61002AC0        	   129: 	bsr op_CMP
02:00000356 61002B32        	   130: 	bsr op_CMPA
02:0000035A 61002B94        	   131: 	bsr op_CMPM
02:0000035E 61002C36        	   132: 	bsr op_ADD
02:00000362 61002D1C        	   133: 	bsr op_SUB
02:00000366 61002E02        	   134: 	bsr op_ADDA
02:0000036A 61002E4A        	   135: 	bsr op_SUBA
02:0000036E 61002E92        	   136: 	bsr op_ADDX	
02:00000372 61002F9E        	   137: 	bsr op_SUBX
02:00000376 610030AA        	   138: 	bsr op_MULU
02:0000037A 610030F2        	   139: 	bsr op_MULS
02:0000037E 6100313A        	   140: 	bsr op_EXG
02:00000382 610031A4        	   141: 	bsr op_ROx
02:00000386 610033D6        	   142: 	bsr op_ROXx
02:0000038A 61003608        	   143: 	bsr op_SHIFTS
02:0000038E 61003846        	   144: 	bsr op_SHIFTS2
                            	   145: 
02:00000392 4E75            	   146: 	rts
                            	   147: 	bra ALL_DONE
                            	   148: 
                            	   149: * Loop here when all tests pass
                            	   150: *
                            	   151: 
02:00000394 60FE            	   152: ALL_DONE: bra.s ALL_DONE
                            	   153: 
02:00000396 263C33333333    	   154: BSR_FAR1:       move.l #$33333333,d3
02:0000039C 4E75            	   155:                 rts
                            	   156: 
                            	   157: ;	moveq		#-1,d0
                            	   158: ;	move.l	d0,$FD0FFF00
                            	   159: ;do_nothing:
                            	   160: ;	bra			*		
                            	   161: 
                            	   162: 
                            	   163: * Exception Vector = 6   CHK Instruction
                            	   164: *
                            	   165: *	align	4
                            	   166: EXCEPTION_6:
02:0000039E 2C3CEEEE0006    	   167: 	move.l #$EEEE0006,d6      * Set d6 to the exception vector
02:000003A4 4E73            	   168: 	rte
                            	   169: 
                            	   170: * Exception Vector = 7   TRAPV Instruction
                            	   171: *
                            	   172: *	align	4
                            	   173: EXCEPTION_7:
02:000003A6 203C12345678    	   174: 	move.l #$12345678,d0      * Set d6 to the exception vector
02:000003AC 4E73            	   175: 	rte
                            	   176: 
                            	   177: ;-----------------------------------------------------------
                            	   178: ;-----------------------------------------------------------
                            	   179: ; OPCODE : ORI_TO_CCR
                            	   180: ;-----------------------------------------------------------
                            	   181: ;-----------------------------------------------------------
                            	   182: op_ORI_TO_CCR:
                            	   183: 
02:000003AE 003C00FF        	   184:     ori.b #$FF,CCR
02:000003B2 6AFE            	   185:     bpl.s *                   ; branch if Z clear
02:000003B4 66FE            	   186:     bne.s *                   ; branch if N clear
02:000003B6 68FE            	   187:     bvc.s *                   ; branch if V clear
02:000003B8 64FE            	   188:     bcc.s *                   ; branch if C clear
                            	   189: 
02:000003BA 44FC0000        	   190:     move #$00,CCR
02:000003BE 003C0000        	   191:     ori.b #$00,CCR
02:000003C2 67FE            	   192:     beq.s *                   ; branch if Z set
02:000003C4 6BFE            	   193:     bmi.s *                   ; branch if N set
02:000003C6 69FE            	   194:     bvs.s *                   ; branch if V set
02:000003C8 65FE            	   195:     bcs.s *                   ; branch if C set
                            	   196: 
02:000003CA 46FC2700        	   197:     move.w #$2700,SR          ; Put flags back to initial value
                            	   198: 
02:000003CE 4E75            	   199:     rts
                            	   200: 
                            	   201: ;-----------------------------------------------------------
                            	   202: ;-----------------------------------------------------------
                            	   203: ; OPCODE : ORI_TO_SR
                            	   204: ;-----------------------------------------------------------
                            	   205: ;-----------------------------------------------------------
                            	   206: 
                            	   207: op_ORI_TO_SR:
                            	   208: 
02:000003D0 007C2FFF        	   209:     ori.w #$2FFF,SR
02:000003D4 6AFE            	   210:     bpl.s *                   * branch if Z clear
02:000003D6 66FE            	   211:     bne.s *                   * branch if N clear
02:000003D8 68FE            	   212:     bvc.s *                   * branch if V clear
02:000003DA 64FE            	   213:     bcc.s *                   * branch if C clear
                            	   214: 
02:000003DC 46FC2000        	   215:     move.w #$2000,SR
02:000003E0 007C0000        	   216:     ori.w #$0000,SR
02:000003E4 67FE            	   217:     beq.s *                   * branch if Z set
02:000003E6 6BFE            	   218:     bmi.s *                   * branch if N set
02:000003E8 69FE            	   219:     bvs.s *                   * branch if V set
02:000003EA 65FE            	   220:     bcs.s *                   * branch if C set
                            	   221: 
02:000003EC 46FC2700        	   222:     move.w #$2700,sr         * Put flags back to initial value
                            	   223: 
02:000003F0 4E75            	   224:     rts
                            	   225: ; 
                            	   226: ;-----------------------------------------------------------
                            	   227: ;-----------------------------------------------------------
                            	   228: ; OPCODE : EORI_TO_CCR
                            	   229: ;-----------------------------------------------------------
                            	   230: ;-----------------------------------------------------------
                            	   231: op_EORI_TO_CCR:
                            	   232: 
02:000003F2 44FC0000        	   233:     move #$00,CCR
02:000003F6 0A3C00FF        	   234:     eori.b #$FF,CCR
02:000003FA 6AFE            	   235:     bpl.s *                   ; branch if Z clear
02:000003FC 66FE            	   236:     bne.s *                   ; branch if N clear
02:000003FE 68FE            	   237:     bvc.s *                   ; branch if V clear
02:00000400 64FE            	   238:     bcc.s *                   ; branch if C clear
                            	   239: 
02:00000402 44FC0000        	   240:     move #$00,CCR
02:00000406 0A3C0000        	   241:     eori.b #$00,CCR
02:0000040A 67FE            	   242:     beq.s *                   ; branch if Z set
02:0000040C 6BFE            	   243:     bmi.s *                   ; branch if N set
02:0000040E 69FE            	   244:     bvs.s *                   ; branch if V set
02:00000410 65FE            	   245:     bcs.s *                   ; branch if C set
                            	   246: 
02:00000412 46FC2700        	   247:     move.w #$2700,sr           ; Put flags back to initial value
                            	   248: 
02:00000416 4E75            	   249:     rts
                            	   250: 
                            	   251: 
                            	   252: 
                            	   253: *-----------------------------------------------------------
                            	   254: *-----------------------------------------------------------
                            	   255: * OPCODE : EORI_TO_SR
                            	   256: *-----------------------------------------------------------
                            	   257: *-----------------------------------------------------------
                            	   258: op_EORI_TO_SR:
                            	   259: 
02:00000418 46FC2000        	   260:     move.w #$2000,SR
02:0000041C 0A7C0FFF        	   261:     eori.w #$0FFF,SR
02:00000420 6AFE            	   262:     bpl.s *                   * branch if Z clear
02:00000422 66FE            	   263:     bne.s *                   * branch if N clear
02:00000424 68FE            	   264:     bvc.s *                   * branch if V clear
02:00000426 64FE            	   265:     bcc.s *                   * branch if C clear
                            	   266: 
02:00000428 46FC2000        	   267:     move.w #$2000,SR
02:0000042C 0A7C0000        	   268:     eori.w #$0000,SR
02:00000430 67FE            	   269:     beq.s *                   * branch if Z set
02:00000432 6BFE            	   270:     bmi.s *                   * branch if N set
02:00000434 69FE            	   271:     bvs.s *                   * branch if V set
02:00000436 65FE            	   272:     bcs.s *                   * branch if C set
                            	   273: 
02:00000438 46FC2700        	   274:     move.w #$2700,sr          * Put flags back to initial value
                            	   275: 
02:0000043C 4E75            	   276:     rts
                            	   277: 
                            	   278: 
                            	   279: 
                            	   280: *-----------------------------------------------------------
                            	   281: *-----------------------------------------------------------
                            	   282: * OPCODE : ANDI_TO_CCR
                            	   283: *-----------------------------------------------------------
                            	   284: *-----------------------------------------------------------
                            	   285: op_ANDI_TO_CCR:
                            	   286: 
02:0000043E 44FC00FF        	   287:     move #$FF,CCR
02:00000442 023C00FF        	   288:     andi.b #$FF,CCR
02:00000446 6AFE            	   289:     bpl.s *                   * branch if Z clear
02:00000448 66FE            	   290:     bne.s *                   * branch if N clear
02:0000044A 68FE            	   291:     bvc.s *                   * branch if V clear
02:0000044C 64FE            	   292:     bcc.s *                   * branch if C clear
                            	   293: 
02:0000044E 44FC00FF        	   294:     move #$FF,CCR
02:00000452 023C0000        	   295:     andi.b #$00,CCR
02:00000456 67FE            	   296:     beq.s *                   * branch if Z set
02:00000458 6BFE            	   297:     bmi.s *                   * branch if N set
02:0000045A 69FE            	   298:     bvs.s *                   * branch if V set
02:0000045C 65FE            	   299:     bcs.s *                   * branch if C set
                            	   300: 
02:0000045E 46FC2700        	   301:     move #$2700,SR           * Put flags back to initial value
                            	   302: 
02:00000462 4E75            	   303:     rts
                            	   304: 
                            	   305: 
                            	   306: 
                            	   307: *-----------------------------------------------------------
                            	   308: *-----------------------------------------------------------
                            	   309: * OPCODE : ANDI_TO_SR
                            	   310: *-----------------------------------------------------------
                            	   311: *-----------------------------------------------------------
                            	   312: op_ANDI_TO_SR:
02:00000464 46FC20FF        	   313:     move.w #$20FF,SR
02:00000468 027CFFFF        	   314:     andi.w #$FFFF,SR
02:0000046C 6AFE            	   315:     bpl.s *                   * branch if Z clear
02:0000046E 66FE            	   316:     bne.s *                   * branch if N clear
02:00000470 68FE            	   317:     bvc.s *                   * branch if V clear
02:00000472 64FE            	   318:     bcc.s *                   * branch if C clear
                            	   319: 
02:00000474 46FC20FF        	   320:     move.w #$20FF,SR
02:00000478 027CFF00        	   321:     andi.w #$FF00,SR
02:0000047C 67FE            	   322:     beq.s *                   * branch if Z set
02:0000047E 6BFE            	   323:     bmi.s *                   * branch if N set
02:00000480 69FE            	   324:     bvs.s *                   * branch if V set
02:00000482 65FE            	   325:     bcs.s *                   * branch if C set
                            	   326: 
02:00000484 46FC2700        	   327:     move.w #$2700,sr           * Put flags back to initial value
                            	   328: 
02:00000488 4E75            	   329:     rts
                            	   330: 
                            	   331: 
                            	   332: *-----------------------------------------------------------
                            	   333: *-----------------------------------------------------------
                            	   334: * OPCODE : BTST
                            	   335: *-----------------------------------------------------------
                            	   336: *-----------------------------------------------------------
                            	   337: op_BTST:
                            	   338: 
                            	   339: *  Bit Number.s Static
                            	   340: 
                            	   341: *             EA = Dn  - LONG only
02:0000048A 203C80000001    	   342:             move.l #$80000001,d0      * populate test data
02:00000490 08000000        	   343:             btst.l #0,d0
02:00000494 67FE            	   344:             beq.s *               * branch if Z set
02:00000496 08000001        	   345:             btst.l #1,d0              *
02:0000049A 66FE            	   346:             bne.s *               * branch if Z clear
02:0000049C 0800001F        	   347:             btst.l #31,d0             *
02:000004A0 67FE            	   348:             beq.s *               * branch if Z set
                            	   349: 
                            	   350: 
                            	   351: *             EA = (An)  - BYTE only
02:000004A2 307C0100        	   352:             move.l #$00000100,a0      * point to memory to address 0x100
02:000004A6 10BC0081        	   353:             move.b #$81,(a0)          * populate test data
02:000004AA 1210            	   354:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:000004AC 08100000        	   355:             btst.b #0,(a0)
02:000004B0 67FE            	   356:             beq.s *               * branch if Z set
02:000004B2 08100001        	   357:             btst.b #1,(a0)            *
02:000004B6 66FE            	   358:             bne.s *               * branch if Z clear
02:000004B8 08100007        	   359:             btst.b #7,(a0)            *
02:000004BC 67FE            	   360:             beq.s *               * branch if Z set
                            	   361: 
                            	   362: 
                            	   363: *             EA = (An)+  - BYTE only
02:000004BE 307C0100        	   364:             move.l #$00000100,a0      * point to memory to address 0x100
02:000004C2 10FC0001        	   365:             move.b #$01,(a0)+         * populate test data
02:000004C6 10FC00FC        	   366:             move.b #$FC,(a0)+         * populate test data
02:000004CA 10FC0080        	   367:             move.b #$80,(a0)+         * populate test data
02:000004CE 307C0100        	   368:             move.l #$00000100,a0      * point to memory to address 0x100
02:000004D2 08180000        	   369:             btst.b #0,(a0)+
02:000004D6 67FE            	   370:             beq.s *               * branch if Z set
02:000004D8 08180001        	   371:             btst.b #1,(a0)+           *
02:000004DC 66FE            	   372:             bne.s *               * branch if Z clear
02:000004DE 08180007        	   373:             btst.b #7,(a0)+           *
02:000004E2 67FE            	   374:             beq.s *               * branch if Z set
                            	   375: 
                            	   376: 
                            	   377: *             EA = -(An)  - BYTE only
02:000004E4 307C0100        	   378:             move.l #$00000100,a0      * point to memory to address
02:000004E8 10FC0080        	   379:             move.b #$80,(a0)+         * populate test data
02:000004EC 10FC00FC        	   380:             move.b #$FC,(a0)+         * populate test data
02:000004F0 10FC0001        	   381:             move.b #$01,(a0)+         * populate test data
02:000004F4 307C0103        	   382:             move.l #$00000103,a0      * point to memory to address
02:000004F8 08200000        	   383:             btst.b #0,-(a0)
02:000004FC 67FE            	   384:             beq.s *               * branch if Z set
02:000004FE 08200001        	   385:             btst.b #1,-(a0)           *
02:00000502 66FE            	   386:             bne.s *               * branch if Z clear
02:00000504 08200007        	   387:             btst.b #7,-(a0)           *
02:00000508 67FE            	   388:             beq.s *               * branch if Z set
                            	   389: 
                            	   390: 
                            	   391: *             EA = n(An)  - BYTE only
02:0000050A 307C0100        	   392:             move.l #$00000100,a0      * point to memory to address
02:0000050E 10FC0001        	   393:             move.b #$01,(a0)+         * populate test data
02:00000512 10FC00FC        	   394:             move.b #$FC,(a0)+         * populate test data
02:00000516 10FC0080        	   395:             move.b #$80,(a0)+         * populate test data
02:0000051A 307C0100        	   396:             move.l #$00000100,a0      * point to memory to address
02:0000051E 08100000        	   397:             btst.b #0,0(a0)
02:00000522 67FE            	   398:             beq.s *               * branch if Z set
02:00000524 082800010001    	   399:             btst.b #1,1(a0)           *
02:0000052A 66FE            	   400:             bne.s *               * branch if Z clear
02:0000052C 082800070002    	   401:             btst.b #7,2(a0)           *
02:00000532 67FE            	   402:             beq.s *               * branch if Z set
                            	   403: 
                            	   404: 
                            	   405: *             EA = n(An,R.W)  - BYTE only
02:00000534 307C0100        	   406:             move.l #$00000100,a0      * point to memory to address
02:00000538 93C9            	   407:             move.l #$00000000,a1      * point to memory to address
02:0000053A 347C0001        	   408:             move.l #$00000001,a2      * point to memory to address
02:0000053E 7000            	   409:             moveq  #$00000000,d0      * point to memory to address
02:00000540 7201            	   410:             moveq  #$00000001,d1      * point to memory to address
02:00000542 083000000000    	   411:             btst.b #0,0(a0,d0.w)
02:00000548 67FE            	   412:             beq.s *               * branch if Z set
02:0000054A 083000011000    	   413:             btst.b #1,0(a0,d1.w)      *
02:00000550 66FE            	   414:             bne.s *               * branch if Z clear
02:00000552 083000071001    	   415:             btst.b #7,1(a0,d1.w)      *
02:00000558 67FE            	   416:             beq.s *               * branch if Z set
                            	   417: *             EA = n(An,R.L)  - BYTE only
02:0000055A 083000000800    	   418:             btst.b #0,0(a0,d0.l)
02:00000560 67FE            	   419:             beq.s *               * branch if Z set
02:00000562 083000011800    	   420:             btst.b #1,0(a0,d1.l)      *
02:00000568 66FE            	   421:             bne.s *               * branch if Z clear
02:0000056A 083000071801    	   422:             btst.b #7,1(a0,d1.l)      *
02:00000570 67FE            	   423:             beq.s *               * branch if Z set
                            	   424: *             EA = n(An,A.W)  - BYTE only
02:00000572 083000009000    	   425:             btst.b #0,0(a0,a1.w)
02:00000578 67FE            	   426:             beq.s *               * branch if Z set
02:0000057A 08300001A000    	   427:             btst.b #1,0(a0,a2.w)      *
02:00000580 66FE            	   428:             bne.s *               * branch if Z clear
02:00000582 08300007A001    	   429:             btst.b #7,1(a0,a2.w)      *
02:00000588 67FE            	   430:             beq.s *               * branch if Z set
                            	   431: *             EA = n(An,A.L)  - BYTE only
02:0000058A 083000009800    	   432:             btst.b #0,0(a0,a1.l)
02:00000590 67FE            	   433:             beq.s *               * branch if Z set
02:00000592 08300001A800    	   434:             btst.b #1,0(a0,a2.l)      *
02:00000598 66FE            	   435:             bne.s *               * branch if Z clear
02:0000059A 08300007A801    	   436:             btst.b #7,1(a0,a2.l)      *
02:000005A0 67FE            	   437:             beq.s *               * branch if Z set
                            	   438: 
                            	   439: 
                            	   440: *             EA = x.W  - BYTE only
02:000005A2 083800000100    	   441:             btst.b #0,$0100
02:000005A8 67FE            	   442:             beq.s *               * branch if Z set
02:000005AA 083800010101    	   443:             btst.b #1,$0101           *
02:000005B0 66FE            	   444:             bne.s *               * branch if Z clear
02:000005B2 083800070102    	   445:             btst.b #7,$0102           *
02:000005B8 67FE            	   446:             beq.s *               * branch if Z set
                            	   447: 
                            	   448: 
                            	   449: *             EA = x.L  - BYTE only
02:000005BA 207C0000F100    	   450:             move.l #$F100,a0      * point to memory to address 0x100
02:000005C0 10FC0001        	   451:             move.b #$01,(a0)+         * populate test data
02:000005C4 10FC00FC        	   452:             move.b #$FC,(a0)+         * populate test data
02:000005C8 10FC0080        	   453:             move.b #$80,(a0)+         * populate test data
02:000005CC 083900000000F100	   454:             btst.b #0,$F100
02:000005D4 67FE            	   455:             beq.s *               * branch if Z set
02:000005D6 083900010000F101	   456:             btst.b #1,$F101       *
02:000005DE 66FE            	   457:             bne.s *               * branch if Z clear
02:000005E0 083900070000F102	   458:             btst.b #7,$F102       *
02:000005E8 67FE            	   459:             beq.s *               * branch if Z set
                            	   460: 
                            	   461: 
                            	   462: *             EA = x(PC)  - BYTE only
02:000005EA 4BFAFE9E        	   463:             lea op_BTST(pc),a5
02:000005EE 083A0000FE98    	   464:             btst.b #0,op_BTST(pc)
02:000005F4 66FE            	   465:             bne.s *               * branch if Z clear
02:000005F6 083A0003001A    	   466:             btst.b #3,op_BTST0(pc)     *
02:000005FC 67FE            	   467:             beq.s *               * branch if Z set
02:000005FE 083A00060074    	   468:             btst.b #6,op_BTST12(pc)    *
02:00000604 67FE            	   469:             beq.s *               * branch if Z set
                            	   470: 
                            	   471: 
                            	   472: *             EA = n(PC,R.W)  - BYTE only
02:00000606 307C0100        	   473:             move.l #$00000100,a0      * point to memory to address
02:0000060A 93C9            	   474:             move.l #$00000000,a1      * point to memory to address
02:0000060C 347C0001        	   475:             move.l #$00000001,a2      * point to memory to address
02:00000610 7000            	   476:             moveq  #$00000000,d0      * point to memory to address
02:00000612 7201            	   477:             moveq  #$00000001,d1      * point to memory to address
                            	   478: 
02:00000614 083B000000FC    	   479: op_BTST0:   btst.b #0,op_BTST0(pc,d0.w)
02:0000061A 66FE            	   480:             bne.s *               * branch if Z clear
                            	   481: 
02:0000061C 4BFB1002        	   482:             lea op_BTST1(pc,d1.w),a5
02:00000620 083B000110FC    	   483: op_BTST1:   btst.b #1,op_BTST1(pc,d1.w)      *
02:00000626 67FE            	   484:             beq.s *               * branch if Z set
02:00000628 083B000710FC    	   485: op_BTST2:   btst.b #7,op_BTST2(pc,d1.w)      *
02:0000062E 66FE            	   486:             bne.s *               * branch if Z clear
                            	   487: *             EA = n(PC,R.L)  - BYTE only
02:00000630 083B000008FC    	   488: op_BTST3:   btst.b #0,op_BTST3(pc,d0.l)
02:00000636 66FE            	   489:             bne.s *               * branch if Z clear
02:00000638 083B000118FC    	   490: op_BTST4:   btst.b #1,op_BTST4(pc,d1.l)      *
02:0000063E 67FE            	   491:             beq.s *               * branch if Z set
02:00000640 083B000718FC    	   492: op_BTST5:   btst.b #7,op_BTST5(pc,d1.l)      *
02:00000646 66FE            	   493:             bne.s *               * branch if Z clear
                            	   494: *             EA = n(PC,A.W)  - BYTE only
02:00000648 083B000090FC    	   495: op_BTST6    btst.b #0,op_BTST6(pc,a1.w)
02:0000064E 66FE            	   496:             bne.s *               * branch if Z clear
02:00000650 083B0001A0FC    	   497: op_BTST7:   btst.b #1,op_BTST7(pc,a2.w)      *
02:00000656 67FE            	   498:             beq.s *               * branch if Z set
02:00000658 083B0007A0FC    	   499: op_BTST8:   btst.b #7,op_BTST8(pc,a2.w)      *
02:0000065E 66FE            	   500:             bne.s *               * branch if Z clear
                            	   501: *             EA = n(PC,A.L)  - BYTE only
02:00000660 083B000098FC    	   502: op_BTST9:   btst.b #0,op_BTST9(pc,a1.l)
02:00000666 66FE            	   503:             bne.s *               * branch if Z clear
02:00000668 083B0001A8FC    	   504: op_BTST10:  btst.b #1,op_BTST10(pc,a2.l)      *
02:0000066E 67FE            	   505:             beq.s *               * branch if Z set
02:00000670 083B0007A8FC    	   506: op_BTST11:  btst.b #7,op_BTST11(pc,a2.l)      *
02:00000676 66FE            	   507: op_BTST12:  bne.s *               * branch if Z clear
                            	   508: 
                            	   509: 
                            	   510: 
                            	   511: * Bit Number.s Dynamic
                            	   512: 
                            	   513: *             EA = Dn  - LONG only
02:00000678 203C80000001    	   514:             move.l #$80000001,d0      * populate test data
02:0000067E 7A00            	   515:             move.l #0,d5              * populate bit.s number to test
02:00000680 7C01            	   516:             move.l #1,d6              * populate bit.s number to test
02:00000682 7E1F            	   517:             move.l #31,d7              * populate bit.s number to test
                            	   518: 
02:00000684 0B00            	   519:             btst.l d5,d0
02:00000686 67FE            	   520:             beq.s *               * branch if Z set
02:00000688 0D00            	   521:             btst.l d6,d0              *
02:0000068A 66FE            	   522:             bne.s *               * branch if Z clear
02:0000068C 0F00            	   523:             btst.l d7,d0             *
02:0000068E 67FE            	   524:             beq.s *               * branch if Z set
                            	   525: 
                            	   526: 
                            	   527: *             EA = (An)  - BYTE only
02:00000690 7A00            	   528:             move.l #0,d5              * populate bit.s number to test
02:00000692 7C01            	   529:             move.l #1,d6              * populate bit.s number to test
02:00000694 7E07            	   530:             move.l #7,d7              * populate bit.s number to test
02:00000696 307C0100        	   531:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000069A 10BC0081        	   532:             move.b #$81,(a0)          * populate test data
02:0000069E 1210            	   533:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:000006A0 0B10            	   534:             btst.b d5,(a0)
02:000006A2 67FE            	   535:             beq.s *               * branch if Z set
02:000006A4 0D10            	   536:             btst.b d6,(a0)            *
02:000006A6 66FE            	   537:             bne.s *               * branch if Z clear
02:000006A8 0F10            	   538:             btst.b d7,(a0)            *
02:000006AA 67FE            	   539:             beq.s *               * branch if Z set
                            	   540: 
                            	   541: * ---
                            	   542: 
                            	   543: 
                            	   544: *             EA = (An)+  - BYTE only
02:000006AC 307C0100        	   545:             move.l #$00000100,a0      * point to memory to address 0x100
02:000006B0 10FC0001        	   546:             move.b #$01,(a0)+         * populate test data
02:000006B4 10FC00FC        	   547:             move.b #$FC,(a0)+         * populate test data
02:000006B8 10FC0080        	   548:             move.b #$80,(a0)+         * populate test data
02:000006BC 307C0100        	   549:             move.l #$00000100,a0      * point to memory to address 0x100
02:000006C0 0B18            	   550:             btst.b d5,(a0)+
02:000006C2 67FE            	   551:             beq.s *               * branch if Z set
02:000006C4 0D18            	   552:             btst.b d6,(a0)+           *
02:000006C6 66FE            	   553:             bne.s *               * branch if Z clear
02:000006C8 0F18            	   554:             btst.b d7,(a0)+           *
02:000006CA 67FE            	   555:             beq.s *               * branch if Z set
                            	   556: 
                            	   557: 
                            	   558: *             EA = -(An)  - BYTE only
02:000006CC 307C0100        	   559:             move.l #$00000100,a0      * point to memory to address
02:000006D0 10FC0080        	   560:             move.b #$80,(a0)+         * populate test data
02:000006D4 10FC00FC        	   561:             move.b #$FC,(a0)+         * populate test data
02:000006D8 10FC0001        	   562:             move.b #$01,(a0)+         * populate test data
02:000006DC 307C0103        	   563:             move.l #$00000103,a0      * point to memory to address
02:000006E0 0B20            	   564:             btst.b d5,-(a0)
02:000006E2 67FE            	   565:             beq.s *               * branch if Z set
02:000006E4 0D20            	   566:             btst.b d6,-(a0)           *
02:000006E6 66FE            	   567:             bne.s *               * branch if Z clear
02:000006E8 0F20            	   568:             btst.b d7,-(a0)           *
02:000006EA 67FE            	   569:             beq.s *               * branch if Z set
                            	   570: 
                            	   571: 
                            	   572: *             EA = n(An)  - BYTE only
02:000006EC 307C0100        	   573:             move.l #$00000100,a0      * point to memory to address
02:000006F0 10FC0001        	   574:             move.b #$01,(a0)+         * populate test data
02:000006F4 10FC00FC        	   575:             move.b #$FC,(a0)+         * populate test data
02:000006F8 10FC0080        	   576:             move.b #$80,(a0)+         * populate test data
02:000006FC 307C0100        	   577:             move.l #$00000100,a0      * point to memory to address
02:00000700 0B10            	   578:             btst.b d5,0(a0)
02:00000702 67FE            	   579:             beq.s *               * branch if Z set
02:00000704 0D280001        	   580:             btst.b d6,1(a0)           *
02:00000708 66FE            	   581:             bne.s *               * branch if Z clear
02:0000070A 0F280002        	   582:             btst.b d7,2(a0)           *
02:0000070E 67FE            	   583:             beq.s *               * branch if Z set
                            	   584: 
                            	   585: 
                            	   586: *             EA = n(An,R.W)  - BYTE only
02:00000710 307C0100        	   587:             move.l #$00000100,a0      * point to memory to address
02:00000714 93C9            	   588:             move.l #$00000000,a1      * point to memory to address
02:00000716 347C0001        	   589:             move.l #$00000001,a2      * point to memory to address
02:0000071A 7000            	   590:             moveq  #$00000000,d0      * point to memory to address
02:0000071C 7201            	   591:             moveq  #$00000001,d1      * point to memory to address
02:0000071E 0B300000        	   592:             btst.b d5,0(a0,d0.w)
02:00000722 67FE            	   593:             beq.s *               * branch if Z set
02:00000724 0D301000        	   594:             btst.b d6,0(a0,d1.w)      *
02:00000728 66FE            	   595:             bne.s *               * branch if Z clear
02:0000072A 0F301001        	   596:             btst.b d7,1(a0,d1.w)      *
02:0000072E 67FE            	   597:             beq.s *               * branch if Z set
                            	   598: *             EA = n(An,R.L)  - BYTE only
02:00000730 0B300800        	   599:             btst.b d5,0(a0,d0.l)
02:00000734 67FE            	   600:             beq.s *               * branch if Z set
02:00000736 0D301800        	   601:             btst.b d6,0(a0,d1.l)      *
02:0000073A 66FE            	   602:             bne.s *               * branch if Z clear
02:0000073C 0F301801        	   603:             btst.b d7,1(a0,d1.l)      *
02:00000740 67FE            	   604:             beq.s *               * branch if Z set
                            	   605: *             EA = n(An,A.W)  - BYTE only
02:00000742 0B309000        	   606:             btst.b d5,0(a0,a1.w)
02:00000746 67FE            	   607:             beq.s *               * branch if Z set
02:00000748 0D30A000        	   608:             btst.b d6,0(a0,a2.w)      *
02:0000074C 66FE            	   609:             bne.s *               * branch if Z clear
02:0000074E 0F30A001        	   610:             btst.b d7,1(a0,a2.w)      *
02:00000752 67FE            	   611:             beq.s *               * branch if Z set
                            	   612: *             EA = n(An,A.L)  - BYTE only
02:00000754 0B309800        	   613:             btst.b d5,0(a0,a1.l)
02:00000758 67FE            	   614:             beq.s *               * branch if Z set
02:0000075A 0D30A800        	   615:             btst.b d6,0(a0,a2.l)      *
02:0000075E 66FE            	   616:             bne.s *               * branch if Z clear
02:00000760 0F30A801        	   617:             btst.b d7,1(a0,a2.l)      *
02:00000764 67FE            	   618:             beq.s *               * branch if Z set
                            	   619: 
                            	   620: 
                            	   621: *             EA = x.W  - BYTE only
02:00000766 0B380100        	   622:             btst.b d5,$0100
02:0000076A 67FE            	   623:             beq.s *               * branch if Z set
02:0000076C 0D380101        	   624:             btst.b d6,$0101           *
02:00000770 66FE            	   625:             bne.s *               * branch if Z clear
02:00000772 0F380102        	   626:             btst.b d7,$0102           *
02:00000776 67FE            	   627:             beq.s *               * branch if Z set
                            	   628: 
                            	   629: 
                            	   630: *             EA = x.L  - BYTE only
02:00000778 207C0000F100    	   631:             move.l #$F100,a0      * point to memory to address 0x100
02:0000077E 10FC0001        	   632:             move.b #$01,(a0)+         * populate test data
02:00000782 10FC00FC        	   633:             move.b #$FC,(a0)+         * populate test data
02:00000786 10FC0080        	   634:             move.b #$80,(a0)+         * populate test data
02:0000078A 0B390000F100    	   635:             btst.b d5,$F100
02:00000790 67FE            	   636:             beq.s *               * branch if Z set
02:00000792 0D390000F101    	   637:             btst.b d6,$F101       *
02:00000798 66FE            	   638:             bne.s *               * branch if Z clear
02:0000079A 0F390000F102    	   639:             btst.b d7,$F102       *
02:000007A0 67FE            	   640:             beq.s *               * branch if Z set
                            	   641: 
                            	   642: 
                            	   643: *             EA = x(PC)  - BYTE only
02:000007A2 7C03            	   644:             move.l #3,d6              * populate bit.s number to test
02:000007A4 7E06            	   645:             move.l #6,d7              * populate bit.s number to test
02:000007A6 4BFAFCE2        	   646:             lea op_BTST(pc),a5
02:000007AA 0B3AFCDE        	   647:             btst.b d5,op_BTST(pc)
02:000007AE 66FE            	   648:             bne.s *               * branch if Z clear
02:000007B0 0D3AFE62        	   649:             btst.b d6,op_BTST0(pc)     *
02:000007B4 67FE            	   650:             beq.s *               * branch if Z set
02:000007B6 0F3AFEBE        	   651:             btst.b d7,op_BTST12(pc)    *
02:000007BA 67FE            	   652:             beq.s *               * branch if Z set
                            	   653: 
                            	   654: 
                            	   655: *             EA = n(PC,R.W)  - BYTE only
02:000007BC 307C0100        	   656:             move.l #$00000100,a0      * point to memory to address
02:000007C0 93C9            	   657:             move.l #$00000000,a1      * point to memory to address
02:000007C2 347C0001        	   658:             move.l #$00000001,a2      * point to memory to address
02:000007C6 7000            	   659:             moveq  #$00000000,d0      * point to memory to address
02:000007C8 7201            	   660:             moveq  #$00000001,d1      * point to memory to address
02:000007CA 7C01            	   661:             move.l #1,d6              * populate bit.s number to test
02:000007CC 7E07            	   662:             move.l #7,d7              * populate bit.s number to test
                            	   663: 
02:000007CE 0B3B00FE        	   664: op_BTST20:  btst.b d5,op_BTST20(pc,d0.w)
02:000007D2 67FE            	   665:             beq.s *               * branch if Z set
02:000007D4 4BFB1002        	   666:             lea op_BTST21(pc,d1.w),a5
02:000007D8 0D3B10FE        	   667: op_BTST21:  btst.b d6,op_BTST21(pc,d1.w)      *
02:000007DC 67FE            	   668:             beq.s *               * branch if Z set
02:000007DE 0F3B10FE        	   669: op_BTST22:  btst.b d7,op_BTST22(pc,d1.w)      *
02:000007E2 66FE            	   670:             bne.s *               * branch if Z clear
                            	   671: *             EA = n(PC,R.L)  - BYTE only
02:000007E4 0B3B08FE        	   672: op_BTST23:  btst.b d5,op_BTST23(pc,d0.l)
02:000007E8 67FE            	   673:             beq.s *               * branch if Z set
02:000007EA 0D3B18FE        	   674: op_BTST24: btst.b d6,op_BTST24(pc,d1.l)      *
02:000007EE 67FE            	   675:             beq.s *               * branch if Z set
02:000007F0 0F3B18FE        	   676: op_BTST25  btst.b d7,op_BTST25(pc,d1.l)      *
02:000007F4 66FE            	   677:             bne.s *               * branch if Z clear
                            	   678: *             EA = n(PC,A.W)  - BYTE only
02:000007F6 0B3B90FE        	   679: op_BTST26   btst.b d5,op_BTST26(pc,a1.w)
02:000007FA 67FE            	   680:             beq.s *               * branch if Z set
02:000007FC 0D3BA0FE        	   681: op_BTST27:  btst.b d6,op_BTST27(pc,a2.w)      *
02:00000800 67FE            	   682:             beq.s *               * branch if Z set
02:00000802 0F3BA0FE        	   683: op_BTST28:  btst.b d7,op_BTST28(pc,a2.w)      *
02:00000806 66FE            	   684:             bne.s *               * branch if Z clear
                            	   685: *             EA = n(PC,A.L)  - BYTE only
02:00000808 0B3B98FE        	   686: op_BTST29:  btst.b d5,op_BTST29(pc,a1.l)
02:0000080C 67FE            	   687:             beq.s *               * branch if Z set
02:0000080E 0D3BA8FE        	   688: op_BTST30:  btst.b d6,op_BTST30(pc,a2.l)      *
02:00000812 67FE            	   689:             beq.s *               * branch if Z set
02:00000814 0F3BA8FE        	   690: op_BTST31:  btst.b d7,op_BTST31(pc,a2.l)      *
02:00000818 66FE            	   691: op_BTST32:  bne.s *               * branch if Z clear
                            	   692: 
                            	   693: *             EA = #x  - BYTE only
                            	   694: 
02:0000081A 7A00            	   695:             move.l #0,d5              * populate bit.s number to test
02:0000081C 7C03            	   696:             move.l #3,d6              * populate bit.s number to test
02:0000081E 7E07            	   697:             move.l #7,d7              * populate bit.s number to test
                            	   698: 
02:00000820 0B3C0088        	   699:             btst.b d5,#$88
02:00000824 66FE            	   700:             bne.s *               * branch if Z clear
02:00000826 0D3C0088        	   701:             btst.b d6,#$88
02:0000082A 67FE            	   702:             beq.s *               * branch if Z set
02:0000082C 0F3C0088        	   703:             btst.b d7,#$88
02:00000830 67FE            	   704:             beq.s *               * branch if Z set
                            	   705: 
                            	   706: 
02:00000832 4E75            	   707:     rts
                            	   708: 
                            	   709: *-----------------------------------------------------------
                            	   710: *-----------------------------------------------------------
                            	   711: * OPCODE : BCHG
                            	   712: *-----------------------------------------------------------
                            	   713: *-----------------------------------------------------------
                            	   714: op_BCHG:
                            	   715: 
                            	   716: 
                            	   717: *  Bit Number.s Static
                            	   718: 
                            	   719: *             EA = Dn  - LONG only
02:00000834 203C80000001    	   720:             move.l #$80000001,d0      * populate test data
02:0000083A 08400000        	   721:             bchg.l #0,d0
02:0000083E 67FE            	   722:             beq.s *               * branch if Z set
02:00000840 08400001        	   723:             bchg.l #1,d0              *
02:00000844 66FE            	   724:             bne.s *               * branch if Z clear
02:00000846 0840001F        	   725:             bchg.l #31,d0             *
02:0000084A 67FE            	   726:             beq.s *               * branch if Z set
02:0000084C 0C8000000002    	   727:             cmpi.l #$00000002,d0
02:00000852 66FE            	   728:             bne.s *               * branch if Z clear
                            	   729: 
                            	   730: 
                            	   731: *             EA = (An)  - BYTE only
02:00000854 307C0100        	   732:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000858 10BC0081        	   733:             move.b #$81,(a0)          * populate test data
02:0000085C 1210            	   734:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:0000085E 08500000        	   735:             bchg.b #0,(a0)
02:00000862 67FE            	   736:             beq.s *               * branch if Z set
02:00000864 08500001        	   737:             bchg.b #1,(a0)            *
02:00000868 66FE            	   738:             bne.s *               * branch if Z clear
02:0000086A 08500007        	   739:             bchg.b #7,(a0)            *
02:0000086E 67FE            	   740:             beq.s *               * branch if Z set
02:00000870 0C100002        	   741:             cmpi.b #$02,(a0)
02:00000874 66FE            	   742:             bne.s *               * branch if Z clear
                            	   743: 
                            	   744: *             EA = (An)+  - BYTE only
02:00000876 307C0100        	   745:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000087A 10FC0001        	   746:             move.b #$01,(a0)+         * populate test data
02:0000087E 10FC00FC        	   747:             move.b #$FC,(a0)+         * populate test data
02:00000882 10FC0080        	   748:             move.b #$80,(a0)+         * populate test data
02:00000886 307C0100        	   749:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000088A 08580000        	   750:             bchg.b #0,(a0)+
02:0000088E 67FE            	   751:             beq.s *               * branch if Z set
02:00000890 08580001        	   752:             bchg.b #1,(a0)+           *
02:00000894 66FE            	   753:             bne.s *               * branch if Z clear
02:00000896 08580007        	   754:             bchg.b #7,(a0)+           *
02:0000089A 67FE            	   755:             beq.s *               * branch if Z set
02:0000089C 307C0100        	   756:             move.l #$00000100,a0      * point to memory to address 0x100
02:000008A0 4A18            	   757:             cmpi.b #$00,(a0)+
02:000008A2 66FE            	   758:             bne.s *               * branch if Z clear
02:000008A4 0C1800FE        	   759:             cmpi.b #$FE,(a0)+
02:000008A8 66FE            	   760:             bne.s *               * branch if Z clear
02:000008AA 4A18            	   761:             cmpi.b #$00,(a0)+
02:000008AC 66FE            	   762:             bne.s *               * branch if Z clear
                            	   763: 
                            	   764: *             EA = -(An)  - BYTE only
02:000008AE 307C0100        	   765:             move.l #$00000100,a0      * point to memory to address
02:000008B2 10FC0080        	   766:             move.b #$80,(a0)+         * populate test data
02:000008B6 10FC00FC        	   767:             move.b #$FC,(a0)+         * populate test data
02:000008BA 10FC0001        	   768:             move.b #$01,(a0)+         * populate test data
02:000008BE 307C0103        	   769:             move.l #$00000103,a0      * point to memory to address
02:000008C2 08600000        	   770:             bchg.b #0,-(a0)
02:000008C6 67FE            	   771:             beq.s *               * branch if Z set
02:000008C8 08600001        	   772:             bchg.b #1,-(a0)           *
02:000008CC 66FE            	   773:             bne.s *               * branch if Z clear
02:000008CE 08600007        	   774:             bchg.b #7,-(a0)           *
02:000008D2 67FE            	   775:             beq.s *               * branch if Z set
02:000008D4 307C0103        	   776:             move.l #$00000103,a0      * point to memory to address 0x100
02:000008D8 4A20            	   777:             cmpi.b #$00,-(a0)
02:000008DA 66FE            	   778:             bne.s *               * branch if Z clear
02:000008DC 0C2000FE        	   779:             cmpi.b #$FE,-(a0)
02:000008E0 66FE            	   780:             bne.s *               * branch if Z clear
02:000008E2 4A20            	   781:             cmpi.b #$00,-(a0)
02:000008E4 66FE            	   782:             bne.s *               * branch if Z clear
                            	   783: 
                            	   784: 
                            	   785: *             EA = n(An)  - BYTE only
02:000008E6 307C0100        	   786:             move.l #$00000100,a0      * point to memory to address
02:000008EA 10FC0001        	   787:             move.b #$01,(a0)+         * populate test data
02:000008EE 10FC00FC        	   788:             move.b #$FC,(a0)+         * populate test data
02:000008F2 10FC0080        	   789:             move.b #$80,(a0)+         * populate test data
02:000008F6 307C0100        	   790:             move.l #$00000100,a0      * point to memory to address
02:000008FA 08500000        	   791:             bchg.b #0,0(a0)
02:000008FE 67FE            	   792:             beq.s *               * branch if Z set
02:00000900 086800010001    	   793:             bchg.b #1,1(a0)           *
02:00000906 66FE            	   794:             bne.s *               * branch if Z clear
02:00000908 086800070002    	   795:             bchg.b #7,2(a0)           *
02:0000090E 67FE            	   796:             beq.s *               * branch if Z set
02:00000910 307C0100        	   797:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000914 4A18            	   798:             cmpi.b #$00,(a0)+
02:00000916 66FE            	   799:             bne.s *               * branch if Z clear
02:00000918 0C1800FE        	   800:             cmpi.b #$FE,(a0)+
02:0000091C 66FE            	   801:             bne.s *               * branch if Z clear
02:0000091E 4A18            	   802:             cmpi.b #$00,(a0)+
02:00000920 66FE            	   803:             bne.s *               * branch if Z clear
                            	   804: 
                            	   805: 
                            	   806: *             EA = n(An,D.W)  - BYTE only
02:00000922 307C0100        	   807:             move.l #$00000100,a0      * point to memory to address
02:00000926 93C9            	   808:             move.l #$00000000,a1      * point to memory to address
02:00000928 347C0001        	   809:             move.l #$00000001,a2      * point to memory to address
02:0000092C 7000            	   810:             moveq  #$00000000,d0      * point to memory to address
02:0000092E 7201            	   811:             moveq  #$00000001,d1      * point to memory to address
02:00000930 087000000000    	   812:             bchg.b #0,0(a0,d0.w)
02:00000936 66FE            	   813:             bne.s *               * branch if Z clear
02:00000938 087000011000    	   814:             bchg.b #1,0(a0,d1.w)      *
02:0000093E 67FE            	   815:             beq.s *               * branch if Z set
02:00000940 087000071001    	   816:             bchg.b #7,1(a0,d1.w)      *
02:00000946 66FE            	   817:             bne.s *               * branch if Z clear
                            	   818: *             EA = n(An,D.L)  - BYTE only
02:00000948 087000000800    	   819:             bchg.b #0,0(a0,d0.l)
02:0000094E 67FE            	   820:             beq.s *               * branch if Z set
02:00000950 087000011800    	   821:             bchg.b #1,0(a0,d1.l)      *
02:00000956 66FE            	   822:             bne.s *               * branch if Z clear
02:00000958 087000071801    	   823:             bchg.b #7,1(a0,d1.l)      *
02:0000095E 67FE            	   824:             beq.s *               * branch if Z set
                            	   825: *             EA = n(An,A.W)  - BYTE only
02:00000960 087000009000    	   826:             bchg.b #0,0(a0,a1.w)
02:00000966 66FE            	   827:             bne.s *               * branch if Z clear
02:00000968 08700001A000    	   828:             bchg.b #1,0(a0,a2.w)      *
02:0000096E 67FE            	   829:             beq.s *               * branch if Z set
02:00000970 08700007A001    	   830:             bchg.b #7,1(a0,a2.w)      *
02:00000976 66FE            	   831:             bne.s *               * branch if Z clear
                            	   832: *             EA = n(An,A.L)  - BYTE only
02:00000978 087000009800    	   833:             bchg.b #0,0(a0,a1.l)
02:0000097E 67FE            	   834:             beq.s *               * branch if Z set
02:00000980 08700001A800    	   835:             bchg.b #1,0(a0,a2.l)      *
02:00000986 66FE            	   836:             bne.s *               * branch if Z clear
02:00000988 08700007A801    	   837:             bchg.b #7,1(a0,a2.l)      *
02:0000098E 67FE            	   838:             beq.s *               * branch if Z set
02:00000990 307C0100        	   839:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000994 4A18            	   840:             cmpi.b #$00,(a0)+
02:00000996 66FE            	   841:             bne.s *               * branch if Z clear
02:00000998 0C1800FE        	   842:             cmpi.b #$FE,(a0)+
02:0000099C 66FE            	   843:             bne.s *               * branch if Z clear
02:0000099E 4A18            	   844:             cmpi.b #$00,(a0)+
02:000009A0 66FE            	   845:             bne.s *               * branch if Z clear
                            	   846: 
                            	   847: 
                            	   848: *             EA = x.W  - BYTE only
02:000009A2 087800000100    	   849:             bchg.b #0,$0100
02:000009A8 66FE            	   850:             bne.s *               * branch if Z clear
02:000009AA 087800010101    	   851:             bchg.b #1,$0101           *
02:000009B0 67FE            	   852:             beq.s *               * branch if Z set
02:000009B2 087800070102    	   853:             bchg.b #7,$0102           *
02:000009B8 66FE            	   854:             bne.s *               * branch if Z clear
02:000009BA 307C0100        	   855:             move.l #$00000100,a0      * point to memory to address 0x100
02:000009BE 0C180001        	   856:             cmpi.b #$01,(a0)+
02:000009C2 66FE            	   857:             bne.s *               * branch if Z clear
02:000009C4 0C1800FC        	   858:             cmpi.b #$FC,(a0)+
02:000009C8 66FE            	   859:             bne.s *               * branch if Z clear
02:000009CA 0C180080        	   860:             cmpi.b #$80,(a0)+
02:000009CE 66FE            	   861:             bne.s *               * branch if Z clear
                            	   862: 
                            	   863: *             EA = x.L  - BYTE only
02:000009D0 207C0000F100    	   864:             move.l #$F100,a0      * point to memory to address 0x100
02:000009D6 10FC0001        	   865:             move.b #$01,(a0)+         * populate test data
02:000009DA 10FC00FC        	   866:             move.b #$FC,(a0)+         * populate test data
02:000009DE 10FC0080        	   867:             move.b #$80,(a0)+         * populate test data
02:000009E2 087900000000F100	   868:             bchg.b #0,$F100
02:000009EA 67FE            	   869:             beq.s *               * branch if Z set
02:000009EC 087900010000F101	   870:             bchg.b #1,$F101       *
02:000009F4 66FE            	   871:             bne.s *               * branch if Z clear
02:000009F6 087900070000F102	   872:             bchg.b #7,$F102       *
02:000009FE 67FE            	   873:             beq.s *               * branch if Z set
02:00000A00 307C0100        	   874:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A04 0C180001        	   875:             cmpi.b #$01,(a0)+
02:00000A08 66FE            	   876:             bne.s *               * branch if Z clear
02:00000A0A 0C1800FC        	   877:             cmpi.b #$FC,(a0)+
02:00000A0E 66FE            	   878:             bne.s *               * branch if Z clear
02:00000A10 0C180080        	   879:             cmpi.b #$80,(a0)+
02:00000A14 66FE            	   880:             bne.s *               * branch if Z clear
                            	   881: 
                            	   882: 
                            	   883: * Bit Number.s Dynamic
                            	   884: 
                            	   885: *             EA = Dn  - LONG only
02:00000A16 203C80000001    	   886:             move.l #$80000001,d0      * populate test data
02:00000A1C 7A00            	   887:             move.l #0,d5              * populate bit.s number to test
02:00000A1E 7C01            	   888:             move.l #1,d6              * populate bit.s number to test
02:00000A20 7E1F            	   889:             move.l #31,d7              * populate bit.s number to test
                            	   890: 
02:00000A22 0B40            	   891:             bchg.l d5,d0
02:00000A24 67FE            	   892:             beq.s *               * branch if Z set
02:00000A26 0D40            	   893:             bchg.l d6,d0              *
02:00000A28 66FE            	   894:             bne.s *               * branch if Z clear
02:00000A2A 0F40            	   895:             bchg.l d7,d0             *
02:00000A2C 67FE            	   896:             beq.s *               * branch if Z set
02:00000A2E 0C8000000002    	   897:             cmpi.l #$00000002,d0
02:00000A34 66FE            	   898:             bne.s *               * branch if Z clear
                            	   899: 
                            	   900: 
                            	   901: *             EA = (An)  - BYTE only
02:00000A36 7A00            	   902:             move.l #0,d5              * populate bit.s number to test
02:00000A38 7C01            	   903:             move.l #1,d6              * populate bit.s number to test
02:00000A3A 7E07            	   904:             move.l #7,d7              * populate bit.s number to test
02:00000A3C 307C0100        	   905:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A40 10BC0081        	   906:             move.b #$81,(a0)          * populate test data
02:00000A44 1210            	   907:             move.b (a0),d1            * Check to see if data in memory is 0x81
02:00000A46 0B50            	   908:             bchg.b d5,(a0)
02:00000A48 67FE            	   909:             beq.s *               * branch if Z set
02:00000A4A 0D50            	   910:             bchg.b d6,(a0)            *
02:00000A4C 66FE            	   911:             bne.s *               * branch if Z clear
02:00000A4E 0F50            	   912:             bchg.b d7,(a0)            *
02:00000A50 67FE            	   913:             beq.s *               * branch if Z set
02:00000A52 0C100002        	   914:             cmpi.b #$02,(a0)
02:00000A56 66FE            	   915:             bne.s *               * branch if Z clear
                            	   916: 
                            	   917: 
                            	   918: *             EA = (An)+  - BYTE only
02:00000A58 307C0100        	   919:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A5C 10FC0001        	   920:             move.b #$01,(a0)+         * populate test data
02:00000A60 10FC00FC        	   921:             move.b #$FC,(a0)+         * populate test data
02:00000A64 10FC0080        	   922:             move.b #$80,(a0)+         * populate test data
02:00000A68 307C0100        	   923:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A6C 0B58            	   924:             bchg.b d5,(a0)+
02:00000A6E 67FE            	   925:             beq.s *               * branch if Z set
02:00000A70 0D58            	   926:             bchg.b d6,(a0)+           *
02:00000A72 66FE            	   927:             bne.s *               * branch if Z clear
02:00000A74 0F58            	   928:             bchg.b d7,(a0)+           *
02:00000A76 67FE            	   929:             beq.s *               * branch if Z set
02:00000A78 307C0100        	   930:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000A7C 4A18            	   931:             cmpi.b #$00,(a0)+
02:00000A7E 66FE            	   932:             bne.s *               * branch if Z clear
02:00000A80 0C1800FE        	   933:             cmpi.b #$FE,(a0)+
02:00000A84 66FE            	   934:             bne.s *               * branch if Z clear
02:00000A86 4A18            	   935:             cmpi.b #$00,(a0)+
02:00000A88 66FE            	   936:             bne.s *               * branch if Z clear
                            	   937: 
                            	   938: *             EA = -(An)  - BYTE only
02:00000A8A 307C0100        	   939:             move.l #$00000100,a0      * point to memory to address
02:00000A8E 10FC0080        	   940:             move.b #$80,(a0)+         * populate test data
02:00000A92 10FC00FC        	   941:             move.b #$FC,(a0)+         * populate test data
02:00000A96 10FC0001        	   942:             move.b #$01,(a0)+         * populate test data
02:00000A9A 307C0103        	   943:             move.l #$00000103,a0      * point to memory to address
02:00000A9E 0B60            	   944:             bchg.b d5,-(a0)
02:00000AA0 67FE            	   945:             beq.s *               * branch if Z set
02:00000AA2 0D60            	   946:             bchg.b d6,-(a0)           *
02:00000AA4 66FE            	   947:             bne.s *               * branch if Z clear
02:00000AA6 0F60            	   948:             bchg.b d7,-(a0)           *
02:00000AA8 67FE            	   949:             beq.s *               * branch if Z set
02:00000AAA 307C0103        	   950:             move.l #$00000103,a0      * point to memory to address 0x100
02:00000AAE 4A20            	   951:             cmpi.b #$00,-(a0)
02:00000AB0 66FE            	   952:             bne.s *               * branch if Z clear
02:00000AB2 0C2000FE        	   953:             cmpi.b #$FE,-(a0)
02:00000AB6 66FE            	   954:             bne.s *               * branch if Z clear
02:00000AB8 4A20            	   955:             cmpi.b #$00,-(a0)
02:00000ABA 66FE            	   956:             bne.s *               * branch if Z clear
                            	   957: 
                            	   958: *             EA = n(An)  - BYTE only
02:00000ABC 307C0100        	   959:             move.l #$00000100,a0      * point to memory to address
02:00000AC0 10FC0001        	   960:             move.b #$01,(a0)+         * populate test data
02:00000AC4 10FC00FC        	   961:             move.b #$FC,(a0)+         * populate test data
02:00000AC8 10FC0080        	   962:             move.b #$80,(a0)+         * populate test data
02:00000ACC 307C0100        	   963:             move.l #$00000100,a0      * point to memory to address
02:00000AD0 0B50            	   964:             bchg.b d5,0(a0)
02:00000AD2 67FE            	   965:             beq.s *               * branch if Z set
02:00000AD4 0D680001        	   966:             bchg.b d6,1(a0)           *
02:00000AD8 66FE            	   967:             bne.s *               * branch if Z clear
02:00000ADA 0F680002        	   968:             bchg.b d7,2(a0)           *
02:00000ADE 67FE            	   969:             beq.s *               * branch if Z set
02:00000AE0 307C0100        	   970:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000AE4 4A18            	   971:             cmpi.b #$00,(a0)+
02:00000AE6 66FE            	   972:             bne.s *               * branch if Z clear
02:00000AE8 0C1800FE        	   973:             cmpi.b #$FE,(a0)+
02:00000AEC 66FE            	   974:             bne.s *               * branch if Z clear
02:00000AEE 4A18            	   975:             cmpi.b #$00,(a0)+
02:00000AF0 66FE            	   976:             bne.s *               * branch if Z clear
                            	   977: 
                            	   978: *             EA = n(An,R.W)  - BYTE only
02:00000AF2 307C0100        	   979:             move.l #$00000100,a0      * point to memory to address
02:00000AF6 93C9            	   980:             move.l #$00000000,a1      * point to memory to address
02:00000AF8 347C0001        	   981:             move.l #$00000001,a2      * point to memory to address
02:00000AFC 7000            	   982:             moveq  #$00000000,d0      * point to memory to address
02:00000AFE 7201            	   983:             moveq  #$00000001,d1      * point to memory to address
02:00000B00 0B700000        	   984:             bchg.b d5,0(a0,d0.w)
02:00000B04 66FE            	   985:             bne.s *               * branch if Z clear
02:00000B06 0D701000        	   986:             bchg.b d6,0(a0,d1.w)      *
02:00000B0A 67FE            	   987:             beq.s *               * branch if Z set
02:00000B0C 0F701001        	   988:             bchg.b d7,1(a0,d1.w)      *
02:00000B10 66FE            	   989:             bne.s *               * branch if Z clear
                            	   990: *             EA = n(An,R.L)  - BYTE only
02:00000B12 0B700800        	   991:             bchg.b d5,0(a0,d0.l)
02:00000B16 67FE            	   992:             beq.s *               * branch if Z set
02:00000B18 0D701800        	   993:             bchg.b d6,0(a0,d1.l)      *
02:00000B1C 66FE            	   994:             bne.s *               * branch if Z clear
02:00000B1E 0F701801        	   995:             bchg.b d7,1(a0,d1.l)      *
02:00000B22 67FE            	   996:             beq.s *               * branch if Z set
                            	   997: *             EA = n(An,A.W)  - BYTE only
02:00000B24 0B709000        	   998:             bchg.b d5,0(a0,a1.w)
02:00000B28 66FE            	   999:             bne.s *               * branch if Z clear
02:00000B2A 0D70A000        	  1000:             bchg.b d6,0(a0,a2.w)      *
02:00000B2E 67FE            	  1001:             beq.s *               * branch if Z set
02:00000B30 0F70A001        	  1002:             bchg.b d7,1(a0,a2.w)      *
02:00000B34 66FE            	  1003:             bne.s *               * branch if Z clear
                            	  1004: *             EA = n(An,A.L)  - BYTE only
02:00000B36 0B709800        	  1005:             bchg.b d5,0(a0,a1.l)
02:00000B3A 67FE            	  1006:             beq.s *               * branch if Z set
02:00000B3C 0D70A800        	  1007:             bchg.b d6,0(a0,a2.l)      *
02:00000B40 66FE            	  1008:             bne.s *               * branch if Z clear
02:00000B42 0F70A801        	  1009:             bchg.b d7,1(a0,a2.l)      *
02:00000B46 67FE            	  1010:             beq.s *               * branch if Z set
02:00000B48 4A18            	  1011:             cmpi.b #$00,(a0)+
02:00000B4A 66FE            	  1012:             bne.s *               * branch if Z clear
                            	  1013: 
                            	  1014: *             EA = x.W  - BYTE only
02:00000B4C 0B780100        	  1015:             bchg.b d5,$0100
02:00000B50 66FE            	  1016:             bne.s *               * branch if Z clear
02:00000B52 0D780101        	  1017:             bchg.b d6,$0101           *
02:00000B56 67FE            	  1018:             beq.s *               * branch if Z set
02:00000B58 0F780102        	  1019:             bchg.b d7,$0102           *
02:00000B5C 66FE            	  1020:             bne.s *               * branch if Z clear
02:00000B5E 0C1800FC        	  1021:             cmpi.b #$FC,(a0)+
02:00000B62 66FE            	  1022:             bne.s *               * branch if Z clear
                            	  1023: 
                            	  1024: *             EA = x.L  - BYTE only
02:00000B64 207C0000F100    	  1025:             move.l #$F100,a0      * point to memory to address 0x100
02:00000B6A 10FC0001        	  1026:             move.b #$01,(a0)+         * populate test data
02:00000B6E 10FC00FC        	  1027:             move.b #$FC,(a0)+         * populate test data
02:00000B72 10FC0080        	  1028:             move.b #$80,(a0)+         * populate test data
02:00000B76 0B790000F100    	  1029:             bchg.b d5,$F100
02:00000B7C 67FE            	  1030:             beq.s *               * branch if Z set
02:00000B7E 0D790000F101    	  1031:             bchg.b d6,$F101       *
02:00000B84 66FE            	  1032:             bne.s *               * branch if Z clear
02:00000B86 0F790000F102    	  1033:             bchg.b d7,$F102       *
02:00000B8C 67FE            	  1034:             beq.s *               * branch if Z set
02:00000B8E 207C0000F101    	  1035:             move.l #$F101,a0      * point to memory to address 0x100
02:00000B94 0C1000FE        	  1036:             cmpi.b #$FE,(a0)
02:00000B98 66FE            	  1037:             bne.s *               * branch if Z clear
                            	  1038: 
                            	  1039: 
02:00000B9A 4E75            	  1040:     rts
                            	  1041: 
                            	  1042: *-----------------------------------------------------------
                            	  1043: *-----------------------------------------------------------
                            	  1044: * OPCODE : BCLR
                            	  1045: *-----------------------------------------------------------
                            	  1046: *-----------------------------------------------------------
                            	  1047: op_BCLR:
                            	  1048: 
                            	  1049: 
                            	  1050: *  Bit Number.s Static
                            	  1051: 
                            	  1052: *             EA = Dn  - LONG only
02:00000B9C 203CFF0000FF    	  1053:             move.l #$FF0000FF,d0      * populate test data
02:00000BA2 08800000        	  1054:             bclr.l #0,d0
02:00000BA6 67FE            	  1055:             beq.s *               * branch if Z set
02:00000BA8 08800001        	  1056:             bclr.l #1,d0              *
02:00000BAC 67FE            	  1057:             beq.s *               * branch if Z set
02:00000BAE 0880000F        	  1058:             bclr.l #15,d0             *
02:00000BB2 66FE            	  1059:             bne.s *               * branch if Z clear
02:00000BB4 0880001F        	  1060:             bclr.l #31,d0             *
02:00000BB8 67FE            	  1061:             beq.s *               * branch if Z set
02:00000BBA 0C807F0000FC    	  1062:             cmpi.l #$7F0000FC,d0
02:00000BC0 66FE            	  1063:             bne.s *               * branch if Z clear
                            	  1064: 
                            	  1065: 
                            	  1066: *             EA = (An)  - BYTE only
02:00000BC2 307C0100        	  1067:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000BC6 10BC000F        	  1068:             move.b #$0F,(a0)          * populate test data
02:00000BCA 08900000        	  1069:             bclr.b #0,(a0)
02:00000BCE 67FE            	  1070:             beq.s *               * branch if Z set
02:00000BD0 08900007        	  1071:             bclr.b #7,(a0)            *
02:00000BD4 66FE            	  1072:             bne.s *               * branch if Z clear
02:00000BD6 0C10000E        	  1073:             cmpi.b #$0E,(a0)
02:00000BDA 66FE            	  1074:             bne.s *               * branch if Z clear
                            	  1075: 
                            	  1076: *             EA = (An)+  - BYTE only
02:00000BDC 307C0100        	  1077:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000BE0 10FC0001        	  1078:             move.b #$01,(a0)+         * populate test data
02:00000BE4 4218            	  1079:             move.b #$00,(a0)+         * populate test data
02:00000BE6 307C0100        	  1080:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000BEA 08980000        	  1081:             bclr.b #0,(a0)+
02:00000BEE 67FE            	  1082:             beq.s *               * branch if Z set
02:00000BF0 08980001        	  1083:             bclr.b #1,(a0)+           *
02:00000BF4 66FE            	  1084:             bne.s *               * branch if Z clear
02:00000BF6 307C0100        	  1085:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000BFA 4A18            	  1086:             cmpi.b #$00,(a0)+
02:00000BFC 66FE            	  1087:             bne.s *               * branch if Z clear
02:00000BFE 4A18            	  1088:             cmpi.b #$00,(a0)+
02:00000C00 66FE            	  1089:             bne.s *               * branch if Z clear
                            	  1090: 
                            	  1091: 
                            	  1092: *             EA = -(An)  - BYTE only
02:00000C02 307C0100        	  1093:             move.l #$00000100,a0      * point to memory to address
02:00000C06 10FC0001        	  1094:             move.b #$01,(a0)+         * populate test data
02:00000C0A 10FC0080        	  1095:             move.b #$80,(a0)+         * populate test data
02:00000C0E 08A00007        	  1096:             bclr.b #7,-(a0)
02:00000C12 67FE            	  1097:             beq.s *               * branch if Z set
02:00000C14 08A00000        	  1098:             bclr.b #0,-(a0)           *
02:00000C18 67FE            	  1099:             beq.s *               * branch if Z set
02:00000C1A 307C0102        	  1100:             move.l #$00000102,a0      * point to memory to address 0x100
02:00000C1E 4A20            	  1101:             cmpi.b #$00,-(a0)
02:00000C20 66FE            	  1102:             bne.s *               * branch if Z clear
02:00000C22 4A20            	  1103:             cmpi.b #$00,-(a0)
02:00000C24 66FE            	  1104:             bne.s *               * branch if Z clear
                            	  1105: 
                            	  1106: 
                            	  1107: *             EA = n(An)  - BYTE only
02:00000C26 307C0100        	  1108:             move.l #$00000100,a0      * point to memory to address
02:00000C2A 10FC00FF        	  1109:             move.b #$FF,(a0)+         * populate test data
02:00000C2E 10FC00FF        	  1110:             move.b #$FF,(a0)+         * populate test data
02:00000C32 307C0100        	  1111:             move.l #$00000100,a0      * point to memory to address
02:00000C36 08900000        	  1112:             bclr.b #0,0(a0)
02:00000C3A 67FE            	  1113:             beq.s *               * branch if Z set
02:00000C3C 08A800040001    	  1114:             bclr.b #4,1(a0)           *
02:00000C42 67FE            	  1115:             beq.s *               * branch if Z set
02:00000C44 307C0100        	  1116:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000C48 0C1800FE        	  1117:             cmpi.b #$FE,(a0)+
02:00000C4C 66FE            	  1118:             bne.s *               * branch if Z clear
02:00000C4E 0C1800EF        	  1119:             cmpi.b #$EF,(a0)+
02:00000C52 66FE            	  1120:             bne.s *               * branch if Z clear
                            	  1121: 
                            	  1122: 
                            	  1123: *             EA = n(An,D.W)  - BYTE only
02:00000C54 307C0100        	  1124:             move.l #$00000100,a0      * point to memory to address
02:00000C58 93C9            	  1125:             move.l #$00000000,a1      * point to memory to address
02:00000C5A 347C0001        	  1126:             move.l #$00000001,a2      * point to memory to address
02:00000C5E 7000            	  1127:             moveq  #$00000000,d0      * point to memory to address
02:00000C60 7201            	  1128:             moveq  #$00000001,d1      * point to memory to address
02:00000C62 10FC00FF        	  1129:             move.b #$FF,(a0)+         * populate test data
02:00000C66 10FC00FF        	  1130:             move.b #$FF,(a0)+         * populate test data
02:00000C6A 307C0100        	  1131:             move.l #$00000100,a0      * point to memory to address
02:00000C6E 08B000000000    	  1132:             bclr.b #0,0(a0,d0.w)
02:00000C74 67FE            	  1133:             beq.s *               * branch if Z set
02:00000C76 08B000011000    	  1134:             bclr.b #1,0(a0,d1.w)      *
02:00000C7C 67FE            	  1135:             beq.s *               * branch if Z set
02:00000C7E 08B000021001    	  1136:             bclr.b #2,1(a0,d1.w)      *
02:00000C84 66FE            	  1137:             bne.s *               * branch if Z clear
                            	  1138: *             EA = n(An,D.L)  - BYTE only
02:00000C86 08B000030800    	  1139:             bclr.b #3,0(a0,d0.l)
02:00000C8C 67FE            	  1140:             beq.s *               * branch if Z set
02:00000C8E 08B000041800    	  1141:             bclr.b #4,0(a0,d1.l)      *
02:00000C94 67FE            	  1142:             beq.s *               * branch if Z set
02:00000C96 08B000051801    	  1143:             bclr.b #5,1(a0,d1.l)      *
02:00000C9C 66FE            	  1144:             bne.s *               * branch if Z clear
                            	  1145: *             EA = n(An,A.W)  - BYTE only
02:00000C9E 08B000069000    	  1146:             bclr.b #6,0(a0,a1.w)
02:00000CA4 67FE            	  1147:             beq.s *               * branch if Z set
02:00000CA6 08B00001A000    	  1148:             bclr.b #1,0(a0,a2.w)      *
02:00000CAC 66FE            	  1149:             bne.s *               * branch if Z clear
02:00000CAE 08B00007A001    	  1150:             bclr.b #7,1(a0,a2.w)      *
02:00000CB4 67FE            	  1151:             beq.s *               * branch if Z set
                            	  1152: *             EA = n(An,A.L)  - BYTE only
02:00000CB6 08B000009800    	  1153:             bclr.b #0,0(a0,a1.l)
02:00000CBC 66FE            	  1154:             bne.s *               * branch if Z clear
02:00000CBE 08B00000A800    	  1155:             bclr.b #0,0(a0,a2.l)      *
02:00000CC4 67FE            	  1156:             beq.s *               * branch if Z set
02:00000CC6 08B00001A801    	  1157:             bclr.b #1,1(a0,a2.l)      *
02:00000CCC 66FE            	  1158:             bne.s *               * branch if Z clear
02:00000CCE 307C0100        	  1159:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000CD2 0C1800B6        	  1160:             cmpi.b #$B6,(a0)+
02:00000CD6 66FE            	  1161:             bne.s *               * branch if Z clear
02:00000CD8 0C1800EC        	  1162:             cmpi.b #$EC,(a0)+
02:00000CDC 66FE            	  1163:             bne.s *               * branch if Z clear
02:00000CDE 0C180059        	  1164:             cmpi.b #$59,(a0)+
02:00000CE2 67FE            	  1165:             beq.s *               * branch if Z set
                            	  1166: 
                            	  1167: 
                            	  1168: *             EA = x.W  - BYTE only
02:00000CE4 307C0100        	  1169:             move.l #$00000100,a0      * point to memory to address
02:00000CE8 10FC00FF        	  1170:             move.b #$FF,(a0)+         * populate test data
02:00000CEC 08B800000100    	  1171:             bclr.b #0,$0100
02:00000CF2 67FE            	  1172:             beq.s *               * branch if Z set
02:00000CF4 08B800010100    	  1173:             bclr.b #1,$0100           *
02:00000CFA 67FE            	  1174:             beq.s *               * branch if Z set
02:00000CFC 307C0100        	  1175:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000D00 0C1800FC        	  1176:             cmpi.b #$FC,(a0)+
02:00000D04 66FE            	  1177:             bne.s *               * branch if Z clear
                            	  1178: 
                            	  1179: 
                            	  1180: *             EA = x.L  - BYTE only
02:00000D06 207C0000F100    	  1181:             move.l #$F100,a0      * point to memory to address 0x100
02:00000D0C 10BC00FF        	  1182:             move.b #$FF,(a0)          * populate test data
02:00000D10 08B900000000F100	  1183:             bclr.b #0,$F100
02:00000D18 67FE            	  1184:             beq.s *               * branch if Z set
02:00000D1A 08B900010000F100	  1185:             bclr.b #1,$F100       *
02:00000D22 67FE            	  1186:             beq.s *               * branch if Z set
02:00000D24 08B900020000F100	  1187:             bclr.b #2,$F100       *
02:00000D2C 67FE            	  1188:             beq.s *               * branch if Z set
02:00000D2E 207C0000F100    	  1189:             move.l #$F100,a0      * point to memory to address 0x100
02:00000D34 0C1800F8        	  1190:             cmpi.b #$F8,(a0)+
02:00000D38 66FE            	  1191:             bne.s *               * branch if Z clear
                            	  1192: 
                            	  1193: 
                            	  1194: * Bit Number.s Dynamic
                            	  1195: 
                            	  1196: *             EA = Dn  - LONG only
02:00000D3A 203CFF00FF00    	  1197:             move.l #$FF00FF00,d0      * populate test data
02:00000D40 7A00            	  1198:             move.l #0,d5              * populate bit.s number to test
02:00000D42 7C01            	  1199:             move.l #1,d6              * populate bit.s number to test
02:00000D44 7E1F            	  1200:             move.l #31,d7              * populate bit.s number to test
                            	  1201: 
02:00000D46 0B80            	  1202:             bclr.l d5,d0
02:00000D48 66FE            	  1203:             bne.s *               * branch if Z clear
02:00000D4A 0D80            	  1204:             bclr.l d6,d0              *
02:00000D4C 66FE            	  1205:             bne.s *               * branch if Z clear
02:00000D4E 0F80            	  1206:             bclr.l d7,d0             *
02:00000D50 67FE            	  1207:             beq.s *               * branch if Z set
02:00000D52 0C807F00FF00    	  1208:             cmpi.l #$7F00FF00,d0
02:00000D58 66FE            	  1209:             bne.s *               * branch if Z clear
                            	  1210: 
                            	  1211: 
                            	  1212: *             EA = (An)  - BYTE only
02:00000D5A 7A00            	  1213:             move.l #0,d5              * populate bit.s number to test
02:00000D5C 7C01            	  1214:             move.l #1,d6              * populate bit.s number to test
02:00000D5E 7E07            	  1215:             move.l #7,d7              * populate bit.s number to test
02:00000D60 307C0100        	  1216:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000D64 10BC0081        	  1217:             move.b #$81,(a0)          * populate test data
02:00000D68 0B90            	  1218:             bclr.b d5,(a0)
02:00000D6A 67FE            	  1219:             beq.s *               * branch if Z set
02:00000D6C 0D90            	  1220:             bclr.b d6,(a0)            *
02:00000D6E 66FE            	  1221:             bne.s *               * branch if Z clear
02:00000D70 0F90            	  1222:             bclr.b d7,(a0)            *
02:00000D72 67FE            	  1223:             beq.s *               * branch if Z set
02:00000D74 4A10            	  1224:             cmpi.b #$00,(a0)
02:00000D76 66FE            	  1225:             bne.s *               * branch if Z clear
                            	  1226: 
                            	  1227: 
                            	  1228: *             EA = (An)+  - BYTE only
02:00000D78 307C0100        	  1229:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000D7C 10FC0001        	  1230:             move.b #$01,(a0)+         * populate test data
02:00000D80 10FC00FC        	  1231:             move.b #$FC,(a0)+         * populate test data
02:00000D84 10FC0080        	  1232:             move.b #$80,(a0)+         * populate test data
02:00000D88 307C0100        	  1233:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000D8C 0B98            	  1234:             bclr.b d5,(a0)+
02:00000D8E 67FE            	  1235:             beq.s *               * branch if Z set
02:00000D90 0D98            	  1236:             bclr.b d6,(a0)+           *
02:00000D92 66FE            	  1237:             bne.s *               * branch if Z clear
02:00000D94 0F98            	  1238:             bclr.b d7,(a0)+           *
02:00000D96 67FE            	  1239:             beq.s *               * branch if Z set
02:00000D98 307C0100        	  1240:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000D9C 4A18            	  1241:             cmpi.b #$00,(a0)+
02:00000D9E 66FE            	  1242:             bne.s *               * branch if Z clear
02:00000DA0 0C1800FC        	  1243:             cmpi.b #$FC,(a0)+
02:00000DA4 66FE            	  1244:             bne.s *               * branch if Z clear
02:00000DA6 4A18            	  1245:             cmpi.b #$00,(a0)+
02:00000DA8 66FE            	  1246:             bne.s *               * branch if Z clear
                            	  1247: 
                            	  1248: *             EA = -(An)  - BYTE only
02:00000DAA 307C0100        	  1249:             move.l #$00000100,a0      * point to memory to address
02:00000DAE 10FC0080        	  1250:             move.b #$80,(a0)+         * populate test data
02:00000DB2 10FC00FC        	  1251:             move.b #$FC,(a0)+         * populate test data
02:00000DB6 10FC0001        	  1252:             move.b #$01,(a0)+         * populate test data
02:00000DBA 307C0103        	  1253:             move.l #$00000103,a0      * point to memory to address
02:00000DBE 0BA0            	  1254:             bclr.b d5,-(a0)
02:00000DC0 67FE            	  1255:             beq.s *               * branch if Z set
02:00000DC2 0DA0            	  1256:             bclr.b d6,-(a0)           *
02:00000DC4 66FE            	  1257:             bne.s *               * branch if Z clear
02:00000DC6 0FA0            	  1258:             bclr.b d7,-(a0)           *
02:00000DC8 67FE            	  1259:             beq.s *               * branch if Z set
02:00000DCA 307C0103        	  1260:             move.l #$00000103,a0      * point to memory to address 0x100
02:00000DCE 4A20            	  1261:             cmpi.b #$00,-(a0)
02:00000DD0 66FE            	  1262:             bne.s *               * branch if Z clear
02:00000DD2 0C2000FC        	  1263:             cmpi.b #$FC,-(a0)
02:00000DD6 66FE            	  1264:             bne.s *               * branch if Z clear
02:00000DD8 4A20            	  1265:             cmpi.b #$00,-(a0)
02:00000DDA 66FE            	  1266:             bne.s *               * branch if Z clear
                            	  1267: 
                            	  1268: *             EA = n(An)  - BYTE only
02:00000DDC 307C0100        	  1269:             move.l #$00000100,a0      * point to memory to address
02:00000DE0 10FC0001        	  1270:             move.b #$01,(a0)+         * populate test data
02:00000DE4 10FC00FC        	  1271:             move.b #$FC,(a0)+         * populate test data
02:00000DE8 10FC0080        	  1272:             move.b #$80,(a0)+         * populate test data
02:00000DEC 307C0100        	  1273:             move.l #$00000100,a0      * point to memory to address
02:00000DF0 0B90            	  1274:             bclr.b d5,0(a0)
02:00000DF2 67FE            	  1275:             beq.s *               * branch if Z set
02:00000DF4 0DA80001        	  1276:             bclr.b d6,1(a0)           *
02:00000DF8 66FE            	  1277:             bne.s *               * branch if Z clear
02:00000DFA 0FA80002        	  1278:             bclr.b d7,2(a0)           *
02:00000DFE 67FE            	  1279:             beq.s *               * branch if Z set
02:00000E00 307C0100        	  1280:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000E04 4A18            	  1281:             cmpi.b #$00,(a0)+
02:00000E06 66FE            	  1282:             bne.s *               * branch if Z clear
02:00000E08 0C1800FC        	  1283:             cmpi.b #$FC,(a0)+
02:00000E0C 66FE            	  1284:             bne.s *               * branch if Z clear
02:00000E0E 4A18            	  1285:             cmpi.b #$00,(a0)+
02:00000E10 66FE            	  1286:             bne.s *               * branch if Z clear
                            	  1287: 
                            	  1288: *             EA = n(An,R.W)  - BYTE only
02:00000E12 307C0100        	  1289:             move.l #$00000100,a0      * point to memory to address
02:00000E16 10FC00FF        	  1290:             move.b #$FF,(a0)+         * populate test data
02:00000E1A 10FC00FF        	  1291:             move.b #$FF,(a0)+         * populate test data
02:00000E1E 10FC00FF        	  1292:             move.b #$FF,(a0)+         * populate test data
02:00000E22 307C0103        	  1293:             move.l #$00000103,a0      * point to memory to address
02:00000E26 307C0100        	  1294:             move.l #$00000100,a0      * point to memory to address
02:00000E2A 93C9            	  1295:             move.l #$00000000,a1      * point to memory to address
02:00000E2C 347C0001        	  1296:             move.l #$00000001,a2      * point to memory to address
02:00000E30 7000            	  1297:             moveq  #$00000000,d0      * point to memory to address
02:00000E32 7201            	  1298:             moveq  #$00000001,d1      * point to memory to address
02:00000E34 0BB00000        	  1299:             bclr.b d5,0(a0,d0.w)
02:00000E38 67FE            	  1300:             beq.s *               * branch if Z set
02:00000E3A 0DB01000        	  1301:             bclr.b d6,0(a0,d1.w)      *
02:00000E3E 67FE            	  1302:             beq.s *               * branch if Z set
02:00000E40 0FB01001        	  1303:             bclr.b d7,1(a0,d1.w)      *
02:00000E44 67FE            	  1304:             beq.s *               * branch if Z set
                            	  1305: *             EA = n(An,R.L)  - BYTE only
02:00000E46 0BB00800        	  1306:             bclr.b d5,0(a0,d0.l)
02:00000E4A 66FE            	  1307:             bne.s *               * branch if Z clear
02:00000E4C 0DB01800        	  1308:             bclr.b d6,0(a0,d1.l)      *
02:00000E50 66FE            	  1309:             bne.s *               * branch if Z clear
02:00000E52 0FB01801        	  1310:             bclr.b d7,1(a0,d1.l)      *
02:00000E56 66FE            	  1311:             bne.s *               * branch if Z clear
                            	  1312: *             EA = n(An,A.W)  - BYTE only
02:00000E58 0BB09000        	  1313:             bclr.b d5,0(a0,a1.w)
02:00000E5C 66FE            	  1314:             bne.s *               * branch if Z clear
02:00000E5E 0DB0A000        	  1315:             bclr.b d6,0(a0,a2.w)      *
02:00000E62 66FE            	  1316:             bne.s *               * branch if Z clear
02:00000E64 0FB0A001        	  1317:             bclr.b d7,1(a0,a2.w)      *
02:00000E68 66FE            	  1318:             bne.s *               * branch if Z clear
                            	  1319: *             EA = n(An,A.L)  - BYTE only
02:00000E6A 0BB09800        	  1320:             bclr.b d5,0(a0,a1.l)
02:00000E6E 66FE            	  1321:             bne.s *               * branch if Z clear
02:00000E70 0DB0A800        	  1322:             bclr.b d6,0(a0,a2.l)      *
02:00000E74 66FE            	  1323:             bne.s *               * branch if Z clear
02:00000E76 0FB0A801        	  1324:             bclr.b d7,1(a0,a2.l)      *
02:00000E7A 66FE            	  1325:             bne.s *               * branch if Z clear
02:00000E7C 307C0100        	  1326:             move.l #$00000100,a0      * point to memory to address
02:00000E80 0C1000FE        	  1327:             cmpi.b #$FE,(a0)
02:00000E84 66FE            	  1328:             bne.s *               * branch if Z clear
                            	  1329: 
                            	  1330: *             EA = x.W  - BYTE only
02:00000E86 307C0100        	  1331:             move.l #$00000100,a0      * point to memory to address
02:00000E8A 10FC00FF        	  1332:             move.b #$FF,(a0)+         * populate test data
02:00000E8E 10FC00FF        	  1333:             move.b #$FF,(a0)+         * populate test data
02:00000E92 10FC00FF        	  1334:             move.b #$FF,(a0)+         * populate test data
02:00000E96 0BB80100        	  1335:             bclr.b d5,$0100
02:00000E9A 67FE            	  1336:             beq.s *               * branch if Z set
02:00000E9C 0DB80101        	  1337:             bclr.b d6,$0101           *
02:00000EA0 67FE            	  1338:             beq.s *               * branch if Z set
02:00000EA2 0FB80102        	  1339:             bclr.b d7,$0102           *
02:00000EA6 67FE            	  1340:             beq.s *               * branch if Z set
02:00000EA8 307C0100        	  1341:             move.l #$00000100,a0      * point to memory to address
02:00000EAC 0C1800FE        	  1342:             cmpi.b #$FE,(a0)+
02:00000EB0 66FE            	  1343:             bne.s *               * branch if Z clear
                            	  1344: 
                            	  1345: *             EA = x.L  - BYTE only
02:00000EB2 207C0000F100    	  1346:             move.l #$F100,a0      * point to memory to address 0x100
02:00000EB8 10FC0001        	  1347:             move.b #$01,(a0)+         * populate test data
02:00000EBC 10FC00FC        	  1348:             move.b #$FC,(a0)+         * populate test data
02:00000EC0 10FC0080        	  1349:             move.b #$80,(a0)+         * populate test data
02:00000EC4 0BB90000F100    	  1350:             bclr.b d5,$F100
02:00000ECA 67FE            	  1351:             beq.s *               * branch if Z set
02:00000ECC 0DB90000F101    	  1352:             bclr.b d6,$F101       *
02:00000ED2 66FE            	  1353:             bne.s *               * branch if Z clear
02:00000ED4 0FB90000F102    	  1354:             bclr.b d7,$F102       *
02:00000EDA 67FE            	  1355:             beq.s *               * branch if Z set
02:00000EDC 207C0000F101    	  1356:             move.l #$F101,a0      * point to memory to address 0x100
02:00000EE2 0C1000FC        	  1357:             cmpi.b #$FC,(a0)
02:00000EE6 66FE            	  1358:             bne.s *               * branch if Z clear
                            	  1359: 
                            	  1360: 
                            	  1361: 
02:00000EE8 4E75            	  1362:     rts
                            	  1363: 
                            	  1364: *-----------------------------------------------------------
                            	  1365: *-----------------------------------------------------------
                            	  1366: * OPCODE : BSET
                            	  1367: *-----------------------------------------------------------
                            	  1368: *-----------------------------------------------------------
                            	  1369: op_BSET:
                            	  1370: 
                            	  1371: 
                            	  1372: *  Bit Number.s Static
                            	  1373: 
                            	  1374: *             EA = Dn  - LONG only
02:00000EEA 7000            	  1375:             moveq  #$00000000,d0      * populate test data
02:00000EEC 08C00000        	  1376:             bset.l #0,d0
02:00000EF0 66FE            	  1377:             bne.s *               * branch if Z clear
02:00000EF2 08C00001        	  1378:             bset.l #1,d0              *
02:00000EF6 66FE            	  1379:             bne.s *               * branch if Z clear
02:00000EF8 08C0000F        	  1380:             bset.l #15,d0             *
02:00000EFC 66FE            	  1381:             bne.s *               * branch if Z clear
02:00000EFE 08C0001F        	  1382:             bset.l #31,d0             *
02:00000F02 66FE            	  1383:             bne.s *               * branch if Z clear
02:00000F04 0C8080008003    	  1384:             cmpi.l #$80008003,d0
02:00000F0A 66FE            	  1385:             bne.s *               * branch if Z clear
                            	  1386: 
                            	  1387: 
                            	  1388: *             EA = (An)  - BYTE only
02:00000F0C 307C0100        	  1389:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000F10 4210            	  1390:             move.b #$00,(a0)          * populate test data
02:00000F12 08D00000        	  1391:             bset.b #0,(a0)
02:00000F16 66FE            	  1392:             bne.s *               * branch if Z clear
02:00000F18 08D00007        	  1393:             bset.b #7,(a0)            *
02:00000F1C 66FE            	  1394:             bne.s *               * branch if Z clear
02:00000F1E 0C100081        	  1395:             cmpi.b #$81,(a0)
02:00000F22 66FE            	  1396:             bne.s *               * branch if Z clear
                            	  1397: 
                            	  1398: *             EA = (An)+  - BYTE only
02:00000F24 307C0100        	  1399:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000F28 4218            	  1400:             move.b #$00,(a0)+         * populate test data
02:00000F2A 4218            	  1401:             move.b #$00,(a0)+         * populate test data
02:00000F2C 307C0100        	  1402:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000F30 08D80000        	  1403:             bset.b #0,(a0)+
02:00000F34 66FE            	  1404:             bne.s *               * branch if Z clear
02:00000F36 08D80001        	  1405:             bset.b #1,(a0)+           *
02:00000F3A 66FE            	  1406:             bne.s *               * branch if Z clear
02:00000F3C 307C0100        	  1407:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000F40 0C180001        	  1408:             cmpi.b #$01,(a0)+
02:00000F44 66FE            	  1409:             bne.s *               * branch if Z clear
02:00000F46 0C180002        	  1410:             cmpi.b #$02,(a0)+
02:00000F4A 66FE            	  1411:             bne.s *               * branch if Z clear
                            	  1412: 
                            	  1413: 
                            	  1414: *             EA = -(An)  - BYTE only
02:00000F4C 307C0100        	  1415:             move.l #$00000100,a0      * point to memory to address
02:00000F50 4218            	  1416:             move.b #$00,(a0)+         * populate test data
02:00000F52 4218            	  1417:             move.b #$00,(a0)+         * populate test data
02:00000F54 08E00007        	  1418:             bset.b #7,-(a0)
02:00000F58 66FE            	  1419:             bne.s *               * branch if Z clear
02:00000F5A 08E00000        	  1420:             bset.b #0,-(a0)           *
02:00000F5E 66FE            	  1421:             bne.s *               * branch if Z clear
02:00000F60 307C0102        	  1422:             move.l #$00000102,a0      * point to memory to address 0x100
02:00000F64 0C200080        	  1423:             cmpi.b #$80,-(a0)
02:00000F68 66FE            	  1424:             bne.s *               * branch if Z clear
02:00000F6A 0C200001        	  1425:             cmpi.b #$01,-(a0)
02:00000F6E 66FE            	  1426:             bne.s *               * branch if Z clear
                            	  1427: 
                            	  1428: 
                            	  1429: *             EA = n(An)  - BYTE only
02:00000F70 307C0100        	  1430:             move.l #$00000100,a0      * point to memory to address
02:00000F74 4218            	  1431:             move.b #$00,(a0)+         * populate test data
02:00000F76 4218            	  1432:             move.b #$00,(a0)+         * populate test data
02:00000F78 307C0100        	  1433:             move.l #$00000100,a0      * point to memory to address
02:00000F7C 08D00000        	  1434:             bset.b #0,0(a0)
02:00000F80 66FE            	  1435:             bne.s *               * branch if Z clear
02:00000F82 08E800040001    	  1436:             bset.b #4,1(a0)           *
02:00000F88 66FE            	  1437:             bne.s *               * branch if Z clear
02:00000F8A 307C0100        	  1438:             move.l #$00000100,a0      * point to memory to address 0x100
02:00000F8E 0C180001        	  1439:             cmpi.b #$01,(a0)+
02:00000F92 66FE            	  1440:             bne.s *               * branch if Z clear
02:00000F94 0C180010        	  1441:             cmpi.b #$10,(a0)+
02:00000F98 66FE            	  1442:             bne.s *               * branch if Z clear
                            	  1443: 
                            	  1444: 
                            	  1445: *             EA = n(An,D.W)  - BYTE only
02:00000F9A 307C0100        	  1446:             move.l #$00000100,a0      * point to memory to address
02:00000F9E 93C9            	  1447:             move.l #$00000000,a1      * point to memory to address
02:00000FA0 347C0004        	  1448:             move.l #$00000004,a2      * point to memory to address
02:00000FA4 7000            	  1449:             moveq  #$00000000,d0      * point to memory to address
02:00000FA6 7201            	  1450:             moveq  #$00000001,d1      * point to memory to address
02:00000FA8 4218            	  1451:             move.b #$00,(a0)+         * populate test data
02:00000FAA 4218            	  1452:             move.b #$00,(a0)+         * populate test data
02:00000FAC 4218            	  1453:             move.b #$00,(a0)+         * populate test data
02:00000FAE 4218            	  1454:             move.b #$00,(a0)+         * populate test data
02:00000FB0 4218            	  1455:             move.b #$00,(a0)+         * populate test data
02:00000FB2 4218            	  1456:             move.b #$00,(a0)+         * populate test data
02:00000FB4 4218            	  1457:             move.b #$00,(a0)+         * populate test data
02:00000FB6 4218            	  1458:             move.b #$00,(a0)+         * populate test data
02:00000FB8 4218            	  1459:             move.b #$00,(a0)+         * populate test data
02:00000FBA 4218            	  1460:             move.b #$00,(a0)+         * populate test data
02:00000FBC 307C0100        	  1461:             move.l #$00000100,a0      * point to memory to address
02:00000FC0 08F000000000    	  1462:             bset.b #0,0(a0,d0.w)
02:00000FC6 66FE            	  1463:             bne.s *               * branch if Z clear
02:00000FC8 08F000011000    	  1464:             bset.b #1,0(a0,d1.w)      *
02:00000FCE 66FE            	  1465:             bne.s *               * branch if Z clear
02:00000FD0 08F000021001    	  1466:             bset.b #2,1(a0,d1.w)      *
02:00000FD6 66FE            	  1467:             bne.s *               * branch if Z clear
                            	  1468: *             EA = n(An,D.L)  - BYTE only
02:00000FD8 08F000030802    	  1469:             bset.b #3,2(a0,d0.l)
02:00000FDE 66FE            	  1470:             bne.s *               * branch if Z clear
02:00000FE0 08F000041800    	  1471:             bset.b #4,0(a0,d1.l)      *
02:00000FE6 66FE            	  1472:             bne.s *               * branch if Z clear
02:00000FE8 08F000051801    	  1473:             bset.b #5,1(a0,d1.l)      *
02:00000FEE 66FE            	  1474:             bne.s *               * branch if Z clear
                            	  1475: *             EA = n(An,A.W)  - BYTE only
02:00000FF0 08F000069000    	  1476:             bset.b #6,0(a0,a1.w)
02:00000FF6 66FE            	  1477:             bne.s *               * branch if Z clear
02:00000FF8 08F00001A000    	  1478:             bset.b #1,0(a0,a2.w)      *
02:00000FFE 66FE            	  1479:             bne.s *               * branch if Z clear
02:00001000 08F00007A001    	  1480:             bset.b #7,1(a0,a2.w)      *
02:00001006 66FE            	  1481:             bne.s *               * branch if Z clear
                            	  1482: *             EA = n(An,A.L)  - BYTE only
02:00001008 08F00000A802    	  1483:             bset.b #0,2(a0,a2.l)
02:0000100E 66FE            	  1484:             bne.s *               * branch if Z clear
02:00001010 08F00000A803    	  1485:             bset.b #0,3(a0,a2.l)      *
02:00001016 66FE            	  1486:             bne.s *               * branch if Z clear
02:00001018 08F00001A804    	  1487:             bset.b #1,4(a0,a2.l)      *
02:0000101E 66FE            	  1488:             bne.s *               * branch if Z clear
02:00001020 307C0100        	  1489:             move.l #$00000100,a0      * point to memory to address 0x100
02:00001024 0C9841122C00    	  1490:             cmpi.l #$41122C00,(a0)+
02:0000102A 66FE            	  1491:             bne.s *               * branch if Z clear
02:0000102C 0C9802800101    	  1492:             cmpi.l #$02800101,(a0)+
02:00001032 66FE            	  1493:             bne.s *
                            	  1494: 
                            	  1495: 
                            	  1496: 
                            	  1497: *             EA = x.W  - BYTE only
02:00001034 307C0100        	  1498:             move.l #$00000100,a0      * point to memory to address
02:00001038 4218            	  1499:             move.b #$00,(a0)+         * populate test data
02:0000103A 08F800000100    	  1500:             bset.b #0,$0100
02:00001040 66FE            	  1501:             bne.s *               * branch if Z clear
02:00001042 08F800010100    	  1502:             bset.b #1,$0100           *
02:00001048 66FE            	  1503:             bne.s *               * branch if Z clear
02:0000104A 307C0100        	  1504:             move.l #$00000100,a0      * point to memory to address 0x100
02:0000104E 0C180003        	  1505:             cmpi.b #$03,(a0)+
02:00001052 66FE            	  1506:             bne.s *
                            	  1507: 
                            	  1508: 
                            	  1509: *             EA = x.L  - BYTE only
02:00001054 207C0000F100    	  1510:             move.l #$F100,a0      * point to memory to address 0x100
02:0000105A 4210            	  1511:             move.b #$00,(a0)          * populate test data
02:0000105C 08F900000000F100	  1512:             bset.b #0,$F100
02:00001064 66FE            	  1513:             bne.s *               * branch if Z clear
02:00001066 08F900010000F100	  1514:             bset.b #1,$F100       *
02:0000106E 66FE            	  1515:             bne.s *               * branch if Z clear
02:00001070 08F900020000F100	  1516:             bset.b #2,$F100       *
02:00001078 66FE            	  1517:             bne.s *               * branch if Z clear
02:0000107A 207C0000F100    	  1518:             move.l #$F100,a0      * point to memory to address 0x100
02:00001080 0C180007        	  1519:             cmpi.b #$07,(a0)+
02:00001084 66FE            	  1520:             bne.s *
                            	  1521: 
                            	  1522: 
                            	  1523: * Bit Number.s Dynamic
                            	  1524: 
                            	  1525: *             EA = Dn  - LONG only
02:00001086 7000            	  1526:             moveq  #$00000000,d0      * populate test data
02:00001088 7A00            	  1527:             move.l #0,d5              * populate bit.s number to test
02:0000108A 7C01            	  1528:             move.l #1,d6              * populate bit.s number to test
02:0000108C 7E1F            	  1529:             move.l #31,d7              * populate bit.s number to test
                            	  1530: 
02:0000108E 0BC0            	  1531:             bset.l d5,d0
02:00001090 66FE            	  1532:             bne.s *               * branch if Z clear
02:00001092 0DC0            	  1533:             bset.l d6,d0              *
02:00001094 66FE            	  1534:             bne.s *               * branch if Z clear
02:00001096 0FC0            	  1535:             bset.l d7,d0             *
02:00001098 66FE            	  1536:             bne.s *               * branch if Z clear
02:0000109A 0C8080000003    	  1537:             cmpi.l #$80000003,d0
02:000010A0 66FE            	  1538:             bne.s *               * branch if Z clear
                            	  1539: 
                            	  1540: 
                            	  1541: *             EA = (An)  - BYTE only
02:000010A2 7A00            	  1542:             move.l #0,d5              * populate bit.s number to test
02:000010A4 7C01            	  1543:             move.l #1,d6              * populate bit.s number to test
02:000010A6 7E07            	  1544:             move.l #7,d7              * populate bit.s number to test
02:000010A8 307C0100        	  1545:             move.l #$00000100,a0      * point to memory to address 0x100
02:000010AC 4210            	  1546:             move.b #$00,(a0)          * populate test data
02:000010AE 0BD0            	  1547:             bset.b d5,(a0)
02:000010B0 66FE            	  1548:             bne.s *               * branch if Z clear
02:000010B2 0DD0            	  1549:             bset.b d6,(a0)            *
02:000010B4 66FE            	  1550:             bne.s *               * branch if Z clear
02:000010B6 0FD0            	  1551:             bset.b d7,(a0)            *
02:000010B8 66FE            	  1552:             bne.s *               * branch if Z clear
02:000010BA 0C100083        	  1553:             cmpi.b #$83,(a0)
02:000010BE 66FE            	  1554:             bne.s *               * branch if Z clear
                            	  1555: 
                            	  1556: 
                            	  1557: *             EA = (An)+  - BYTE only
02:000010C0 307C0100        	  1558:             move.l #$00000100,a0      * point to memory to address 0x100
02:000010C4 4218            	  1559:             move.b #$00,(a0)+         * populate test data
02:000010C6 4218            	  1560:             move.b #$00,(a0)+         * populate test data
02:000010C8 4218            	  1561:             move.b #$00,(a0)+         * populate test data
02:000010CA 307C0100        	  1562:             move.l #$00000100,a0      * point to memory to address 0x100
02:000010CE 0BD8            	  1563:             bset.b d5,(a0)+
02:000010D0 66FE            	  1564:             bne.s *               * branch if Z clear
02:000010D2 0DD8            	  1565:             bset.b d6,(a0)+           *
02:000010D4 66FE            	  1566:             bne.s *               * branch if Z clear
02:000010D6 0FD8            	  1567:             bset.b d7,(a0)+           *
02:000010D8 66FE            	  1568:             bne.s *               * branch if Z clear
02:000010DA 307C0100        	  1569:             move.l #$00000100,a0      * point to memory to address 0x100
02:000010DE 0C180001        	  1570:             cmpi.b #$01,(a0)+
02:000010E2 66FE            	  1571:             bne.s *               * branch if Z clear
02:000010E4 0C180002        	  1572:             cmpi.b #$02,(a0)+
02:000010E8 66FE            	  1573:             bne.s *               * branch if Z clear
02:000010EA 0C180080        	  1574:             cmpi.b #$80,(a0)+
02:000010EE 66FE            	  1575:             bne.s *               * branch if Z clear
                            	  1576: 
                            	  1577: *             EA = -(An)  - BYTE only
02:000010F0 307C0100        	  1578:             move.l #$00000100,a0      * point to memory to address
02:000010F4 4218            	  1579:             move.b #$00,(a0)+         * populate test data
02:000010F6 4218            	  1580:             move.b #$00,(a0)+         * populate test data
02:000010F8 4218            	  1581:             move.b #$00,(a0)+         * populate test data
02:000010FA 307C0103        	  1582:             move.l #$00000103,a0      * point to memory to address
02:000010FE 0BE0            	  1583:             bset.b d5,-(a0)
02:00001100 66FE            	  1584:             bne.s *               * branch if Z clear
02:00001102 0DE0            	  1585:             bset.b d6,-(a0)           *
02:00001104 66FE            	  1586:             bne.s *               * branch if Z clear
02:00001106 0FE0            	  1587:             bset.b d7,-(a0)           *
02:00001108 66FE            	  1588:             bne.s *               * branch if Z clear
02:0000110A 307C0103        	  1589:             move.l #$00000103,a0      * point to memory to address 0x100
02:0000110E 0C200001        	  1590:             cmpi.b #$01,-(a0)
02:00001112 66FE            	  1591:             bne.s *               * branch if Z clear
02:00001114 0C200002        	  1592:             cmpi.b #$02,-(a0)
02:00001118 66FE            	  1593:             bne.s *               * branch if Z clear
02:0000111A 0C200080        	  1594:             cmpi.b #$80,-(a0)
02:0000111E 66FE            	  1595:             bne.s *               * branch if Z clear
                            	  1596: 
                            	  1597: *             EA = n(An)  - BYTE only
02:00001120 307C0100        	  1598:             move.l #$00000100,a0      * point to memory to address
02:00001124 4218            	  1599:             move.b #$00,(a0)+         * populate test data
02:00001126 4218            	  1600:             move.b #$00,(a0)+         * populate test data
02:00001128 4218            	  1601:             move.b #$00,(a0)+         * populate test data
02:0000112A 307C0100        	  1602:             move.l #$00000100,a0      * point to memory to address
02:0000112E 0BD0            	  1603:             bset.b d5,0(a0)
02:00001130 66FE            	  1604:             bne.s *               * branch if Z clear
02:00001132 0DE80001        	  1605:             bset.b d6,1(a0)           *
02:00001136 66FE            	  1606:             bne.s *               * branch if Z clear
02:00001138 0FE80002        	  1607:             bset.b d7,2(a0)           *
02:0000113C 66FE            	  1608:             bne.s *               * branch if Z clear
02:0000113E 307C0100        	  1609:             move.l #$00000100,a0      * point to memory to address 0x100
02:00001142 0C180001        	  1610:             cmpi.b #$01,(a0)+
02:00001146 66FE            	  1611:             bne.s *               * branch if Z clear
02:00001148 0C180002        	  1612:             cmpi.b #$02,(a0)+
02:0000114C 66FE            	  1613:             bne.s *               * branch if Z clear
02:0000114E 0C180080        	  1614:             cmpi.b #$80,(a0)+
02:00001152 66FE            	  1615:             bne.s *               * branch if Z clear
                            	  1616: 
                            	  1617: *             EA = n(An,R.W)  - BYTE only
02:00001154 307C0100        	  1618:             move.l #$00000100,a0      * point to memory to address
02:00001158 4218            	  1619:             move.b #$00,(a0)+         * populate test data
02:0000115A 4218            	  1620:             move.b #$00,(a0)+         * populate test data
02:0000115C 4218            	  1621:             move.b #$00,(a0)+         * populate test data
02:0000115E 4218            	  1622:             move.b #$00,(a0)+         * populate test data
02:00001160 4218            	  1623:             move.b #$00,(a0)+         * populate test data
02:00001162 4218            	  1624:             move.b #$00,(a0)+         * populate test data
02:00001164 4218            	  1625:             move.b #$00,(a0)+         * populate test data
02:00001166 4218            	  1626:             move.b #$00,(a0)+         * populate test data
02:00001168 4218            	  1627:             move.b #$00,(a0)+         * populate test data
02:0000116A 4218            	  1628:             move.b #$00,(a0)+         * populate test data
02:0000116C 4218            	  1629:             move.b #$00,(a0)+         * populate test data
02:0000116E 4218            	  1630:             move.b #$00,(a0)+         * populate test data
02:00001170 307C0100        	  1631:             move.l #$00000100,a0      * point to memory to address
02:00001174 93C9            	  1632:             move.l #$00000000,a1      * point to memory to address
02:00001176 347C0001        	  1633:             move.l #$00000001,a2      * point to memory to address
02:0000117A 7000            	  1634:             moveq  #$00000000,d0      * point to memory to address
02:0000117C 7201            	  1635:             moveq  #$00000001,d1      * point to memory to address
02:0000117E 0BF00000        	  1636:             bset.b d5,0(a0,d0.w)
02:00001182 66FE            	  1637:             bne.s *               * branch if Z clear
02:00001184 0DF01000        	  1638:             bset.b d6,0(a0,d1.w)      *
02:00001188 66FE            	  1639:             bne.s *               * branch if Z clear
02:0000118A 0FF01001        	  1640:             bset.b d7,1(a0,d1.w)      *
02:0000118E 66FE            	  1641:             bne.s *               * branch if Z clear
                            	  1642: *             EA = n(An,R.L)  - BYTE only
02:00001190 0BF00802        	  1643:             bset.b d5,2(a0,d0.l)
02:00001194 66FE            	  1644:             bne.s *               * branch if Z clear
02:00001196 0DF01803        	  1645:             bset.b d6,3(a0,d1.l)      *
02:0000119A 66FE            	  1646:             bne.s *               * branch if Z clear
02:0000119C 0FF01804        	  1647:             bset.b d7,4(a0,d1.l)      *
02:000011A0 66FE            	  1648:             bne.s *               * branch if Z clear
                            	  1649: *             EA = n(An,A.W)  - BYTE only
02:000011A2 0BF09005        	  1650:             bset.b d5,5(a0,a1.w)
02:000011A6 66FE            	  1651:             bne.s *               * branch if Z clear
02:000011A8 0DF0A006        	  1652:             bset.b d6,6(a0,a2.w)      *
02:000011AC 66FE            	  1653:             bne.s *               * branch if Z clear
02:000011AE 0FF0A007        	  1654:             bset.b d7,7(a0,a2.w)      *
02:000011B2 66FE            	  1655:             bne.s *               * branch if Z clear
                            	  1656: *             EA = n(An,A.L)  - BYTE only
02:000011B4 0BF09808        	  1657:             bset.b d5,8(a0,a1.l)
02:000011B8 66FE            	  1658:             bne.s *               * branch if Z clear
02:000011BA 0DF0A809        	  1659:             bset.b d6,9(a0,a2.l)      *
02:000011BE 66FE            	  1660:             bne.s *               * branch if Z clear
02:000011C0 0FF0A80A        	  1661:             bset.b d7,10(a0,a2.l)      *
02:000011C4 66FE            	  1662:             bne.s *               * branch if Z clear
02:000011C6 307C0100        	  1663:             move.l #$00000100,a0      * point to memory to address 0x100
02:000011CA 0C9801028100    	  1664:             cmpi.l #$01028100,(a0)+
02:000011D0 66FE            	  1665:             bne.s *               * branch if Z clear
02:000011D2 0C9802810002    	  1666:             cmpi.l #$02810002,(a0)+
02:000011D8 66FE            	  1667:             bne.s *
                            	  1668: 
                            	  1669: 
                            	  1670: *             EA = x.W  - BYTE only
02:000011DA 307C0100        	  1671:             move.l #$00000100,a0      * point to memory to address
02:000011DE 4218            	  1672:             move.b #$00,(a0)+         * populate test data
02:000011E0 4218            	  1673:             move.b #$00,(a0)+         * populate test data
02:000011E2 4218            	  1674:             move.b #$00,(a0)+         * populate test data
02:000011E4 0BF80100        	  1675:             bset.b d5,$0100
02:000011E8 66FE            	  1676:             bne.s *               * branch if Z clear
02:000011EA 0DF80100        	  1677:             bset.b d6,$0100           *
02:000011EE 66FE            	  1678:             bne.s *               * branch if Z clear
02:000011F0 0FF80100        	  1679:             bset.b d7,$0100           *
02:000011F4 66FE            	  1680:             bne.s *               * branch if Z clear
02:000011F6 307C0100        	  1681:             move.l #$00000100,a0      * point to memory to address
02:000011FA 0C180083        	  1682:             cmpi.b #$83,(a0)+
02:000011FE 66FE            	  1683:             bne.s *               * branch if Z clear
                            	  1684: 
                            	  1685: *             EA = x.L  - BYTE only
02:00001200 207C0000F100    	  1686:             move.l #$F100,a0      * point to memory to address 0x100
02:00001206 4218            	  1687:             move.b #$00,(a0)+         * populate test data
02:00001208 4218            	  1688:             move.b #$00,(a0)+         * populate test data
02:0000120A 4218            	  1689:             move.b #$00,(a0)+         * populate test data
02:0000120C 0BF90000F100    	  1690:             bset.b d5,$F100
02:00001212 66FE            	  1691:             bne.s *               * branch if Z clear
02:00001214 0DF90000F100    	  1692:             bset.b d6,$F100       *
02:0000121A 66FE            	  1693:             bne.s *               * branch if Z clear
02:0000121C 0FF90000F100    	  1694:             bset.b d7,$F100       *
02:00001222 66FE            	  1695:             bne.s *               * branch if Z clear
02:00001224 207C0000F100    	  1696:             move.l #$F100,a0      * point to memory to address 0x100
02:0000122A 0C100083        	  1697:             cmpi.b #$83,(a0)
02:0000122E 66FE            	  1698:             bne.s *               * branch if Z clear
                            	  1699: 
                            	  1700: 
02:00001230 4E75            	  1701:     rts
                            	  1702: 
                            	  1703: *-----------------------------------------------------------
                            	  1704: *-----------------------------------------------------------
                            	  1705: * OPCODE : MOVEP
                            	  1706: *-----------------------------------------------------------
                            	  1707: *-----------------------------------------------------------
                            	  1708: op_MOVEP:
                            	  1709: 
                            	  1710: * Dn --> x(An)
02:00001232 307C0100        	  1711:             move.l #$00000100,a0
02:00001236 203C12345678    	  1712:             move.l #$12345678,d0
02:0000123C 223CAABBCCDD    	  1713:             move.l #$AABBCCDD,d1
02:00001242 4290            	  1714:             move.l #0,(a0)
02:00001244 42A80004        	  1715:             move.l #0,4(a0)
                            	  1716: 
02:00001248 01880000        	  1717:             movep.w d0,0(a0)      * even offset
02:0000124C 03880001        	  1718:             movep.w d1,1(a0)      * odd offset
                            	  1719: 
02:00001250 01C80004        	  1720:             movep.l d0,4(a0)      * even offset
02:00001254 03C80005        	  1721:             movep.l d1,5(a0)      * odd offset
                            	  1722: 
02:00001258 0C9056CC78DD    	  1723:             cmpi.l #$56CC78DD,(a0)
02:0000125E 66FE            	  1724:             bne.s *
02:00001260 0CA812AA34BB0004	  1725:             cmpi.l #$12AA34BB,4(a0)
02:00001268 66FE            	  1726:             bne.s *
02:0000126A 0CA856CC78DD0008	  1727:             cmpi.l #$56CC78DD,8(a0)
02:00001272 66FE            	  1728:             bne.s *
                            	  1729: 
                            	  1730: 
                            	  1731: * x(An)--> Dn
02:00001274 203C5A5A5A5A    	  1732:             move.l #$5a5a5a5a,d0
02:0000127A 223C5A5A5A5A    	  1733:             move.l #$5a5a5a5a,d1
02:00001280 243C5A5A5A5A    	  1734:             move.l #$5a5a5a5a,d2
02:00001286 263C5A5A5A5A    	  1735:             move.l #$5a5a5a5a,d3
                            	  1736: 
02:0000128C 01080000        	  1737:             movep.w 0(a0),d0      * even offset
02:00001290 03080001        	  1738:             movep.w 1(a0),d1      * odd offset
                            	  1739: 
02:00001294 05480004        	  1740:             movep.l 4(a0),d2      * even offset
02:00001298 07480005        	  1741:             movep.l 5(a0),d3      * odd offset
                            	  1742: 
02:0000129C 0C805A5A5678    	  1743:             cmpi.l #$5a5a5678,d0
02:000012A2 66FE            	  1744:             bne.s *
02:000012A4 0C815A5ACCDD    	  1745:             cmpi.l #$5a5aCCDD,d1
02:000012AA 66FE            	  1746:             bne.s *
02:000012AC 0C8212345678    	  1747:             cmpi.l #$12345678,d2
02:000012B2 66FE            	  1748:             bne.s *
02:000012B4 0C83AABBCCDD    	  1749:             cmpi.l #$AABBCCDD,d3
02:000012BA 66FE            	  1750:             bne.s *
                            	  1751: 
02:000012BC 4E75            	  1752:             rts
                            	  1753: 
                            	  1754: 
                            	  1755: 
                            	  1756: *-----------------------------------------------------------
                            	  1757: *-----------------------------------------------------------
                            	  1758: * OPCODE : BOOL_I
                            	  1759: *-----------------------------------------------------------
                            	  1760: *-----------------------------------------------------------
                            	  1761: op_BOOL_I:
                            	  1762: 
                            	  1763: *     Dn -- BYTE
02:000012BE 203C12345678    	  1764:             move.l #$12345678,d0
02:000012C4 44FC000F        	  1765:             move.w #$000F,CCR          * pre-set Flags
02:000012C8 000000FF        	  1766:             ori.b  #$FF,d0
02:000012CC 0A00005A        	  1767:             eori.b #$5A,d0
02:000012D0 020000F0        	  1768:             andi.b #$F0,d0
02:000012D4 69FE            	  1769:             bvs.s *                       * Check V,C are cleared
02:000012D6 65FE            	  1770:             bcs.s *
02:000012D8 6AFE            	  1771:             bpl.s *                       * Verify if N flag is set
02:000012DA 4200            	  1772:             andi.b #$00,d0
02:000012DC 6BFE            	  1773:             bmi.s *                       * Verify if N flag is cleared
02:000012DE 66FE            	  1774:             bne.s *                       * Verify if Z flag is set
                            	  1775: 
                            	  1776: *     Dn -- WORD
02:000012E0 223C12345678    	  1777:             move.l #$12345678,d1
02:000012E6 44FC000F        	  1778:             move.w #$000F,CCR          * pre-set Flags
02:000012EA 0041FFFF        	  1779:             ori.w  #$FFFF,d1
02:000012EE 0A415A5A        	  1780:             eori.w #$5A5A,d1
02:000012F2 0241F0F0        	  1781:             andi.w #$F0F0,d1
02:000012F6 69FE            	  1782:             bvs.s *                       * Check V,C are cleared
02:000012F8 65FE            	  1783:             bcs.s *
02:000012FA 6AFE            	  1784:             bpl.s *                       * Verify if N flag is set
02:000012FC 4241            	  1785:             andi.w #$0000,d1
02:000012FE 6BFE            	  1786:             bmi.s *                       * Verify if N flag is cleared
02:00001300 66FE            	  1787:             bne.s *                       * Verify if Z flag is set
                            	  1788: 
                            	  1789: *     Dn -- LONG
02:00001302 243C12345678    	  1790:             move.l #$12345678,d2
02:00001308 44FC000F        	  1791:             move.w #$000F,CCR          * pre-set Flags
02:0000130C 0082FFFFFFFF    	  1792:             ori.l  #$FFFFFFFF,d2
02:00001312 0A825A5A5A5A    	  1793:             eori.l #$5A5A5A5A,d2
02:00001318 0282F0F0F0F0    	  1794:             andi.l #$F0F0F0F0,d2
02:0000131E 69FE            	  1795:             bvs.s *                       * Check V,C are cleared
02:00001320 65FE            	  1796:             bcs.s *
02:00001322 6AFE            	  1797:             bpl.s *                       * Verify if N flag is set
02:00001324 4282            	  1798:             andi.l #$00000000,d2
02:00001326 6BFE            	  1799:             bmi.s *                       * Verify if N flag is cleared
02:00001328 66FE            	  1800:             bne.s *                       * Verify if Z flag is set
                            	  1801: 
                            	  1802: 
                            	  1803: *     (An) -- BYTE
02:0000132A 307C0100        	  1804:             move.l #$00000100,a0
02:0000132E 20BC12345678    	  1805:             move.l #$12345678,(a0)
02:00001334 44FC000F        	  1806:             move.w #$000F,CCR          * pre-set Flags
02:00001338 001000FF        	  1807:             ori.b  #$FF,(a0)
02:0000133C 0A10005A        	  1808:             eori.b #$5A,(a0)
02:00001340 021000F0        	  1809:             andi.b #$F0,(a0)
02:00001344 69FE            	  1810:             bvs.s *                       * Check V,C are cleared
02:00001346 65FE            	  1811:             bcs.s *
02:00001348 6AFE            	  1812:             bpl.s *                       * Verify if N flag is set
02:0000134A 4210            	  1813:             andi.b #$00,(a0)
02:0000134C 6BFE            	  1814:             bmi.s *                       * Verify if N flag is cleared
02:0000134E 66FE            	  1815:             bne.s *                       * Verify if Z flag is set
02:00001350 4A10            	  1816:             cmpi.b #$00,(a0)
02:00001352 66FE            	  1817:             bne.s *                       * Verify if Z flag is set
                            	  1818: 
                            	  1819: *     (An) -- WORD
02:00001354 20BC12345678    	  1820:             move.l #$12345678,(a0)
02:0000135A 44FC000F        	  1821:             move.w #$000F,CCR          * pre-set Flags
02:0000135E 0050FFFF        	  1822:             ori.w  #$FFFF,(a0)
02:00001362 0A505A5A        	  1823:             eori.w #$5A5A,(a0)
02:00001366 0250F0F0        	  1824:             andi.w #$F0F0,(a0)
02:0000136A 69FE            	  1825:             bvs.s *                       * Check V,C are cleared
02:0000136C 65FE            	  1826:             bcs.s *
02:0000136E 6AFE            	  1827:             bpl.s *                       * Verify if N flag is set
02:00001370 4250            	  1828:             andi.w #$0000,(a0)
02:00001372 6BFE            	  1829:             bmi.s *                       * Verify if N flag is cleared
02:00001374 66FE            	  1830:             bne.s *                       * Verify if Z flag is set
02:00001376 4A50            	  1831:             cmpi.w #$00,(a0)
02:00001378 66FE            	  1832:             bne.s *                       * Verify if Z flag is set
                            	  1833: 
                            	  1834: *     (An) -- LONG
02:0000137A 20BC12345678    	  1835:             move.l #$12345678,(a0)
02:00001380 44FC000F        	  1836:             move.w #$000F,CCR          * pre-set Flags
02:00001384 0090FFFFFFFF    	  1837:             ori.l  #$FFFFFFFF,(a0)
02:0000138A 0A905A5A5A5A    	  1838:             eori.l #$5A5A5A5A,(a0)
02:00001390 0290F0F0F0F0    	  1839:             andi.l #$F0F0F0F0,(a0)
02:00001396 69FE            	  1840:             bvs.s *                       * Check V,C are cleared
02:00001398 65FE            	  1841:             bcs.s *
02:0000139A 6AFE            	  1842:             bpl.s *                       * Verify if N flag is set
02:0000139C 4290            	  1843:             andi.l #$00000000,(a0)
02:0000139E 6BFE            	  1844:             bmi.s *                       * Verify if N flag is cleared
02:000013A0 66FE            	  1845:             bne.s *                       * Verify if Z flag is set
02:000013A2 4A90            	  1846:             cmpi.l #$00,(a0)
02:000013A4 66FE            	  1847:             bne.s *                       * Verify if Z flag is set
                            	  1848: 
                            	  1849: 
                            	  1850: 
                            	  1851: *     (An)+ -- BYTE
02:000013A6 307C0100        	  1852:             move.l #$00000100,a0
02:000013AA 20BC00A5FF88    	  1853:             move.l #$00A5FF88,(a0)
02:000013B0 44FC000F        	  1854:             move.w #$000F,CCR          * pre-set Flags
                            	  1855: 
02:000013B4 001800F5        	  1856:             ori.b  #$F5,(a0)+
02:000013B8 6AFE            	  1857:             bpl.s *                       * Verify if N flag is set
02:000013BA 67FE            	  1858:             beq.s *                       * Verify if Z flag is cleared
                            	  1859: 
02:000013BC 4618            	  1860:             eori.b #$FF,(a0)+
02:000013BE 6BFE            	  1861:             bmi.s *                       * Verify if N flag is cleared
02:000013C0 67FE            	  1862:             beq.s *                       * Verify if Z flag is cleared
                            	  1863: 
02:000013C2 021800AA        	  1864:             andi.b #$AA,(a0)+
02:000013C6 6AFE            	  1865:             bpl.s *                       * Verify if N flag is set
02:000013C8 67FE            	  1866:             beq.s *                       * Verify if Z flag is cleared
                            	  1867: 
02:000013CA 307C0100        	  1868:             move.l #$00000100,a0
02:000013CE 0C90F55AAA88    	  1869:             cmpi.l #$F55AAA88,(a0)
02:000013D4 66FE            	  1870:             bne.s *                       * Verify if Z flag is set
                            	  1871: 
                            	  1872: 
                            	  1873: *     (An)+ -- WORD
02:000013D6 307C0100        	  1874:             move.l #$00000100,a0
02:000013DA 327C0104        	  1875:             move.l #$00000104,a1
02:000013DE 20BC00005A5A    	  1876:             move.l #$00005a5a,(a0)
02:000013E4 22BC12345678    	  1877:             move.l #$12345678,(a1)
02:000013EA 44FC000F        	  1878:             move.w #$000F,CCR          * pre-set Flags
                            	  1879: 
02:000013EE 00585678        	  1880:             ori.w  #$5678,(a0)+
02:000013F2 6BFE            	  1881:             bmi.s *                       * Verify if N flag is cleared
02:000013F4 67FE            	  1882:             beq.s *                       * Verify if Z flag is cleared
                            	  1883: 
02:000013F6 4658            	  1884:             eori.w #$FFFF,(a0)+
02:000013F8 6AFE            	  1885:             bpl.s *                       * Verify if N flag is set
02:000013FA 67FE            	  1886:             beq.s *                       * Verify if Z flag is cleared
                            	  1887: 
02:000013FC 0258A55A        	  1888:             andi.w #$A55A,(a0)+
02:00001400 6BFE            	  1889:             bmi.s *                       * Verify if N flag is cleared
02:00001402 67FE            	  1890:             beq.s *                       * Verify if Z flag is cleared
                            	  1891: 
02:00001404 307C0100        	  1892:             move.l #$00000100,a0
02:00001408 0C905678A5A5    	  1893:             cmpi.l #$5678a5a5,(a0)
02:0000140E 307C0104        	  1894:             move.l #$00000104,a0
02:00001412 0C9000105678    	  1895:             cmpi.l #$00105678,(a0)
02:00001418 66FE            	  1896:             bne.s *                       * Verify if Z flag is set
                            	  1897: 
                            	  1898: *     (An)+ -- LONG
02:0000141A 307C0100        	  1899:             move.l #$00000100,a0
02:0000141E 4298            	  1900:             move.l #$00000000,(a0)+
02:00001420 20FC5A5A5A5A    	  1901:             move.l #$5a5a5a5a,(a0)+
02:00001426 20FCFFFFFFFF    	  1902:             move.l #$FFFFFFFF,(a0)+
02:0000142C 307C0100        	  1903:             move.l #$00000100,a0
02:00001430 44FC000F        	  1904:             move.w #$000F,CCR          * pre-set Flags
                            	  1905: 
02:00001434 009812345678    	  1906:             ori.l  #$12345678,(a0)+
02:0000143A 6BFE            	  1907:             bmi.s *                       * Verify if N flag is cleared
02:0000143C 67FE            	  1908:             beq.s *                       * Verify if Z flag is cleared
                            	  1909: 
02:0000143E 4698            	  1910:             eori.l #$FFFFFFFF,(a0)+
02:00001440 6AFE            	  1911:             bpl.s *                       * Verify if N flag is set
02:00001442 67FE            	  1912:             beq.s *                       * Verify if Z flag is cleared
                            	  1913: 
02:00001444 0298A5A5A55A    	  1914:             andi.l #$A5A5A55A,(a0)+
02:0000144A 6AFE            	  1915:             bpl.s *                       * Verify if N flag is set
02:0000144C 67FE            	  1916:             beq.s *                       * Verify if Z flag is cleared
                            	  1917: 
02:0000144E 307C0100        	  1918:             move.l #$00000100,a0
02:00001452 0C9812345678    	  1919:             cmpi.l #$12345678,(a0)+
02:00001458 0C98A5A5A5A5    	  1920:             cmpi.l #$a5a5a5a5,(a0)+
02:0000145E 0C98A5A5A55A    	  1921:             cmpi.l #$a5a5a55a,(a0)+
02:00001464 66FE            	  1922:             bne.s *                       * Verify if Z flag is set
                            	  1923: 
02:00001466 4E75            	  1924:             rts
                            	  1925: 
                            	  1926: 
                            	  1927: *-----------------------------------------------------------
                            	  1928: *-----------------------------------------------------------
                            	  1929: * OPCODE : BSR
                            	  1930: *-----------------------------------------------------------
                            	  1931: *-----------------------------------------------------------
                            	  1932: 
                            	  1933: 
02:00001468 223C11111111    	  1934: BSR_CLOSE1:     move.l #$11111111,d1
02:0000146E 4E75            	  1935:                 rts
                            	  1936: 
                            	  1937: 
                            	  1938: 
02:00001470 61F6            	  1939: op_BSR:         bsr BSR_CLOSE1        * Negative 8-bit.s displacement
02:00001472 612A            	  1940:                 bsr BSR_CLOSE2        * Positive 8-bit.s displacement
02:00001474 6100EF20        	  1941:                 bsr.w BSR_FAR1          * Negative 16-bit.s displacement
02:00001478 6100143E        	  1942:                 bsr.w BSR_FAR2          * Positive 16-bit.s displacement
                            	  1943: 
02:0000147C 0C8111111111    	  1944:                 cmpi.l #$11111111,d1
02:00001482 66FE            	  1945:                 bne.s *
02:00001484 0C8222222222    	  1946:                 cmpi.l #$22222222,d2
02:0000148A 66FE            	  1947:                 bne.s *
02:0000148C 0C8333333333    	  1948:                 cmpi.l #$33333333,d3
02:00001492 66FE            	  1949:                 bne.s *
02:00001494 0C8444444444    	  1950:                 cmpi.l #$44444444,d4
02:0000149A 66FE            	  1951:                 bne.s *
                            	  1952: 
02:0000149C 4E75            	  1953:                 rts
                            	  1954: 
                            	  1955: 
02:0000149E 243C22222222    	  1956: BSR_CLOSE2:     move.l #$22222222,d2
02:000014A4 4E75            	  1957:                 rts
                            	  1958: 
                            	  1959: *-----------------------------------------------------------
                            	  1960: *-----------------------------------------------------------
                            	  1961: * OPCODE : op_CMP_I
                            	  1962: *-----------------------------------------------------------
                            	  1963: *-----------------------------------------------------------
                            	  1964: op_CMP_I:
                            	  1965: 
02:000014A6 307C0100        	  1966:             move.l #$00000100,a0
02:000014AA 20BC00000100    	  1967:             move.l #$00000100,(a0)
                            	  1968: 
                            	  1969: *     REGISTER - BYTE
02:000014B0 7080            	  1970:             move.l #$FFFFFF80,d0
02:000014B2 0C000080        	  1971:             cmpi.b #$80,d0
02:000014B6 66FE            	  1972:             bne.s *                       * Check Z Flag  beq/bne
02:000014B8 6BFE            	  1973:             bmi.s *                       * Check N Flag  bmi/bpl
02:000014BA 65FE            	  1974:             bcs.s *                       * Check C Flag  bcc/bcs
02:000014BC 69FE            	  1975:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1976: 
02:000014BE 223CFFFFF000    	  1977:             move.l #$FFFFF000,d1
02:000014C4 4A01            	  1978:             cmpi.b #$00,d1
02:000014C6 66FE            	  1979:             bne.s *                       * Check Z Flag  beq/bne
02:000014C8 6BFE            	  1980:             bmi.s *                       * Check N Flag  bmi/bpl
02:000014CA 65FE            	  1981:             bcs.s *                       * Check C Flag  bcc/bcs
02:000014CC 69FE            	  1982:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1983: 
02:000014CE 7481D442        	  1984:             move.l #$FFFFFF02,d2
02:000014D2 0C0200FF        	  1985:             cmpi.b #$FF,d2
02:000014D6 67FE            	  1986:             beq.s *                       * Check Z Flag  beq/bne
02:000014D8 6BFE            	  1987:             bmi.s *                       * Check N Flag  bmi/bpl
02:000014DA 64FE            	  1988:             bcc.s *                       * Check C Flag  bcc/bcs
02:000014DC 69FE            	  1989:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1990: 
02:000014DE 263CFFFFFF7F    	  1991:             move.l #$FFFFFF7F,d3
02:000014E4 0C0300FF        	  1992:             cmpi.b #$FF,d3
02:000014E8 67FE            	  1993:             beq.s *                       * Check Z Flag  beq/bne
02:000014EA 6AFE            	  1994:             bpl.s *                       * Check N Flag  bmi/bpl
02:000014EC 64FE            	  1995:             bcc.s *                       * Check C Flag  bcc/bcs
02:000014EE 68FE            	  1996:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  1997: 
                            	  1998: 
                            	  1999: *     REGISTER - WORD
02:000014F0 203CFFFF8000    	  2000:             move.l #$FFFF8000,d0
02:000014F6 0C408000        	  2001:             cmpi.w #$8000,d0
02:000014FA 66FE            	  2002:             bne.s *                       * Check Z Flag  beq/bne
02:000014FC 6BFE            	  2003:             bmi.s *                       * Check N Flag  bmi/bpl
02:000014FE 65FE            	  2004:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001500 69FE            	  2005:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2006: 
02:00001502 223CFFF00000    	  2007:             move.l #$FFF00000,d1
02:00001508 4A41            	  2008:             cmpi.w #$0000,d1
02:0000150A 66FE            	  2009:             bne.s *                       * Check Z Flag  beq/bne
02:0000150C 6BFE            	  2010:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000150E 65FE            	  2011:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001510 69FE            	  2012:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2013: 
02:00001512 243CFFFF0002    	  2014:             move.l #$FFFF0002,d2
02:00001518 0C42FFFF        	  2015:             cmpi.w #$FFFF,d2
02:0000151C 67FE            	  2016:             beq.s *                       * Check Z Flag  beq/bne
02:0000151E 6BFE            	  2017:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001520 64FE            	  2018:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001522 69FE            	  2019:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2020: 
02:00001524 263CFFFF7FFF    	  2021:             move.l #$FFFF7FFF,d3
02:0000152A 0C43FFFF        	  2022:             cmpi.w #$FFFF,d3
02:0000152E 67FE            	  2023:             beq.s *                       * Check Z Flag  beq/bne
02:00001530 6AFE            	  2024:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001532 64FE            	  2025:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001534 68FE            	  2026:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2027: 
                            	  2028: *     REGISTER - LONG
02:00001536 203C80000000    	  2029:             move.l #$80000000,d0
02:0000153C 0C8080000000    	  2030:             cmpi.l #$80000000,d0
02:00001542 66FE            	  2031:             bne.s *                       * Check Z Flag  beq/bne
02:00001544 6BFE            	  2032:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001546 65FE            	  2033:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001548 69FE            	  2034:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2035: 
02:0000154A 7200            	  2036:             moveq  #$00000000,d1
02:0000154C 4A81            	  2037:             cmpi.l #$00000000,d1
02:0000154E 66FE            	  2038:             bne.s *                       * Check Z Flag  beq/bne
02:00001550 6BFE            	  2039:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001552 65FE            	  2040:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001554 69FE            	  2041:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2042: 
02:00001556 7402            	  2043:             moveq  #$00000002,d2
02:00001558 0C82FFFFFFFF    	  2044:             cmpi.l #$FFFFFFFF,d2
02:0000155E 67FE            	  2045:             beq.s *                       * Check Z Flag  beq/bne
02:00001560 6BFE            	  2046:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001562 64FE            	  2047:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001564 69FE            	  2048:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2049: 
02:00001566 263C7FFFFFFF    	  2050:             move.l #$7FFFFFFF,d3
02:0000156C 0C83FFFFFFFF    	  2051:             cmpi.l #$FFFFFFFF,d3
02:00001572 67FE            	  2052:             beq.s *                       * Check Z Flag  beq/bne
02:00001574 6AFE            	  2053:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001576 64FE            	  2054:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001578 68FE            	  2055:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2056: 
                            	  2057: 
                            	  2058: 
                            	  2059: 
                            	  2060: *     EA=x(An,Dn) - BYTE
02:0000157A 307C0100        	  2061:             move.l #$00000100,a0
02:0000157E 7E04            	  2062:             moveq  #$00000004,d7
                            	  2063: 
02:00001580 21BCFFFFFF80700C	  2064:             move.l #$FFFFFF80,12(a0,d7)
02:00001588 21BCFFFFFF80700C	  2065:             move.l #$FFFFFF80,12(a0,d7)
02:00001590 0C300080700F    	  2066:             cmpi.b #$80,15(a0,d7)
02:00001596 66FE            	  2067:             bne.s *                       * Check Z Flag  beq/bne
02:00001598 6BFE            	  2068:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000159A 65FE            	  2069:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000159C 69FE            	  2070:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2071: 
02:0000159E 21BCFFFFF000700C	  2072:             move.l #$FFFFF000,12(a0,d7)
02:000015A6 4A30700F        	  2073:             cmpi.b #$00,15(a0,d7)
02:000015AA 66FE            	  2074:             bne.s *                       * Check Z Flag  beq/bne
02:000015AC 6BFE            	  2075:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015AE 65FE            	  2076:             bcs.s *                       * Check C Flag  bcc/bcs
02:000015B0 69FE            	  2077:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2078: 
02:000015B2 21BCFFFFFF02700C	  2079:             move.l #$FFFFFF02,12(a0,d7)
02:000015BA 0C3000FF700F    	  2080:             cmpi.b #$FF,15(a0,d7)
02:000015C0 67FE            	  2081:             beq.s *                       * Check Z Flag  beq/bne
02:000015C2 6BFE            	  2082:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015C4 64FE            	  2083:             bcc.s *                       * Check C Flag  bcc/bcs
02:000015C6 69FE            	  2084:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2085: 
02:000015C8 21BCFFFFFF7F700C	  2086:             move.l #$FFFFFF7F,12(a0,d7)
02:000015D0 0C3000FF700F    	  2087:             cmpi.b #$FF,15(a0,d7)
02:000015D6 67FE            	  2088:             beq.s *                       * Check Z Flag  beq/bne
02:000015D8 6AFE            	  2089:             bpl.s *                       * Check N Flag  bmi/bpl
02:000015DA 64FE            	  2090:             bcc.s *                       * Check C Flag  bcc/bcs
02:000015DC 68FE            	  2091:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2092: 
                            	  2093: 
                            	  2094: *     EA=x(An,Dn) - WORD
02:000015DE 21BCFFFF8000700C	  2095:             move.l #$FFFF8000,12(a0,d7)
02:000015E6 0C708000700E    	  2096:             cmpi.w #$8000,14(a0,d7)
02:000015EC 66FE            	  2097:             bne.s *                       * Check Z Flag  beq/bne
02:000015EE 6BFE            	  2098:             bmi.s *                       * Check N Flag  bmi/bpl
02:000015F0 65FE            	  2099:             bcs.s *                       * Check C Flag  bcc/bcs
02:000015F2 69FE            	  2100:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2101: 
02:000015F4 21BCFFF00000700C	  2102:             move.l #$FFF00000,12(a0,d7)
02:000015FC 4A70700E        	  2103:             cmpi.w #$0000,14(a0,d7)
02:00001600 66FE            	  2104:             bne.s *                       * Check Z Flag  beq/bne
02:00001602 6BFE            	  2105:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001604 65FE            	  2106:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001606 69FE            	  2107:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2108: 
02:00001608 21BCFFFF0002700C	  2109:             move.l #$FFFF0002,12(a0,d7)
02:00001610 0C70FFFF700E    	  2110:             cmpi.w #$FFFF,14(a0,d7)
02:00001616 67FE            	  2111:             beq.s *                       * Check Z Flag  beq/bne
02:00001618 6BFE            	  2112:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000161A 64FE            	  2113:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000161C 69FE            	  2114:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2115: 
02:0000161E 21BCFFFF7FFF700C	  2116:             move.l #$FFFF7FFF,12(a0,d7)
02:00001626 0C70FFFF700E    	  2117:             cmpi.w #$FFFF,14(a0,d7)
02:0000162C 67FE            	  2118:             beq.s *                       * Check Z Flag  beq/bne
02:0000162E 6AFE            	  2119:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001630 64FE            	  2120:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001632 68FE            	  2121:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2122: 
                            	  2123: *     EA=x(An,Dn) - LONG
02:00001634 21BC80000000700C	  2124:             move.l #$80000000,12(a0,d7)
02:0000163C 0CB080000000700C	  2125:             cmpi.l #$80000000,12(a0,d7)
02:00001644 66FE            	  2126:             bne.s *                       * Check Z Flag  beq/bne
02:00001646 6BFE            	  2127:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001648 65FE            	  2128:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000164A 69FE            	  2129:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2130: 
02:0000164C 42B0700C        	  2131:             move.l #$00000000,12(a0,d7)
02:00001650 4AB0700C        	  2132:             cmpi.l #$00000000,12(a0,d7)
02:00001654 66FE            	  2133:             bne.s *                       * Check Z Flag  beq/bne
02:00001656 6BFE            	  2134:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001658 65FE            	  2135:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000165A 69FE            	  2136:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2137: 
02:0000165C 21BC00000002700C	  2138:             move.l #$00000002,12(a0,d7)
02:00001664 0CB0FFFFFFFF700C	  2139:             cmpi.l #$FFFFFFFF,12(a0,d7)
02:0000166C 67FE            	  2140:             beq.s *                       * Check Z Flag  beq/bne
02:0000166E 6BFE            	  2141:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001670 64FE            	  2142:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001672 69FE            	  2143:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2144: 
02:00001674 21BC7FFFFFFF700C	  2145:             move.l #$7FFFFFFF,12(a0,d7)
02:0000167C 0CB0FFFFFFFF700C	  2146:             cmpi.l #$FFFFFFFF,12(a0,d7)
02:00001684 67FE            	  2147:             beq.s *                       * Check Z Flag  beq/bne
02:00001686 6AFE            	  2148:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001688 64FE            	  2149:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000168A 68FE            	  2150:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2151: 
                            	  2152: 
                            	  2153: 
                            	  2154: 
02:0000168C 4E75            	  2155:             rts
                            	  2156: 
                            	  2157: 
                            	  2158: 
                            	  2159: *-----------------------------------------------------------
                            	  2160: *-----------------------------------------------------------
                            	  2161: * OPCODE : ADD_I
                            	  2162: *-----------------------------------------------------------
                            	  2163: *-----------------------------------------------------------
                            	  2164: op_ADD_I:
                            	  2165: 
                            	  2166: *     EA = Dn  - Byte
02:0000168E 203C12345678    	  2167:             move.l #$12345678,d0      * populate test data
02:00001694 06000000        	  2168:             addi.b #0,d0
02:00001698 67FE            	  2169:             beq.s *                       * Check Z Flag  beq/bne
02:0000169A 6BFE            	  2170:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000169C 65FE            	  2171:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000169E 69FE            	  2172:             bvs.s *                       * Check V Flag  bvc/bvs
02:000016A0 06000010        	  2173:             addi.b #$10,d0
02:000016A4 67FE            	  2174:             beq.s *                       * Check Z Flag  beq/bne
02:000016A6 6AFE            	  2175:             bpl.s *                       * Check N Flag  bmi/bpl
02:000016A8 65FE            	  2176:             bcs.s *                       * Check C Flag  bcc/bcs
02:000016AA 68FE            	  2177:             bvc.s *                       * Check V Flag  bvc/bvs
02:000016AC 060000A5        	  2178:             addi.b #$A5,d0
02:000016B0 67FE            	  2179:             beq.s *                       * Check Z Flag  beq/bne
02:000016B2 6BFE            	  2180:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016B4 64FE            	  2181:             bcc.s *                       * Check C Flag  bcc/bcs
02:000016B6 68FE            	  2182:             bvc.s *                       * Check V Flag  bvc/bvs
02:000016B8 0C00002D        	  2183:             cmpi.b #$2D,d0
02:000016BC 66FE            	  2184:             bne.s *                       * Check Z Flag  beq/bne
                            	  2185: 
                            	  2186: *     EA = Dn  - WORD
02:000016BE 203C12345678    	  2187:             move.l #$12345678,d0      * populate test data
02:000016C4 06400000        	  2188:             addi.w #0,d0
02:000016C8 67FE            	  2189:             beq.s *                       * Check Z Flag  beq/bne
02:000016CA 6BFE            	  2190:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016CC 65FE            	  2191:             bcs.s *                       * Check C Flag  bcc/bcs
02:000016CE 69FE            	  2192:             bvs.s *                       * Check V Flag  bvc/bvs
02:000016D0 06407000        	  2193:             addi.w #$7000,d0
02:000016D4 67FE            	  2194:             beq.s *                       * Check Z Flag  beq/bne
02:000016D6 6AFE            	  2195:             bpl.s *                       * Check N Flag  bmi/bpl
02:000016D8 65FE            	  2196:             bcs.s *                       * Check C Flag  bcc/bcs
02:000016DA 68FE            	  2197:             bvc.s *                       * Check V Flag  bvc/bvs
02:000016DC 0640A55A        	  2198:             addi.w #$A55A,d0
02:000016E0 67FE            	  2199:             beq.s *                       * Check Z Flag  beq/bne
02:000016E2 6BFE            	  2200:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016E4 64FE            	  2201:             bcc.s *                       * Check C Flag  bcc/bcs
02:000016E6 68FE            	  2202:             bvc.s *                       * Check V Flag  bvc/bvs
02:000016E8 0C406BD2        	  2203:             cmpi.w #$6BD2,d0
02:000016EC 66FE            	  2204:             bne.s *                       * Check Z Flag  beq/bne
                            	  2205: 
                            	  2206: *     EA = Dn  - LONG
02:000016EE 203C12345678    	  2207:             move.l #$12345678,d0      * populate test data
02:000016F4 068000000000    	  2208:             addi.l #0,d0
02:000016FA 67FE            	  2209:             beq.s *                       * Check Z Flag  beq/bne
02:000016FC 6BFE            	  2210:             bmi.s *                       * Check N Flag  bmi/bpl
02:000016FE 65FE            	  2211:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001700 69FE            	  2212:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001702 0680F0000000    	  2213:             addi.l #$F0000000,d0
02:00001708 67FE            	  2214:             beq.s *                       * Check Z Flag  beq/bne
02:0000170A 6BFE            	  2215:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000170C 64FE            	  2216:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000170E 69FE            	  2217:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001710 0680855AA55A    	  2218:             addi.l #$855AA55A,d0
02:00001716 67FE            	  2219:             beq.s *                       * Check Z Flag  beq/bne
02:00001718 6AFE            	  2220:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000171A 65FE            	  2221:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000171C 69FE            	  2222:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000171E 0680A0000000    	  2223:             addi.l #$A0000000,d0
02:00001724 68FE            	  2224:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001726 0C80278EFBD2    	  2225:             cmpi.l #$278EFBD2,d0
02:0000172C 66FE            	  2226:             bne.s *                       * Check Z Flag  beq/bne
                            	  2227: 
                            	  2228: 
                            	  2229: 
                            	  2230: *     EA = x.L  - Byte
02:0000172E 207C0000F100    	  2231:             move.l #$F100,a0      * populate test data
02:00001734 20BC12345678    	  2232:             move.l #$12345678,(a0)     * populate test data
02:0000173A 063900000000F103	  2233:             addi.b #0,$F103
02:00001742 67FE            	  2234:             beq.s *                       * Check Z Flag  beq/bne
02:00001744 6BFE            	  2235:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001746 65FE            	  2236:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001748 69FE            	  2237:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000174A 063900100000F103	  2238:             addi.b #$10,$F103
02:00001752 67FE            	  2239:             beq.s *                       * Check Z Flag  beq/bne
02:00001754 6AFE            	  2240:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001756 65FE            	  2241:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001758 68FE            	  2242:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000175A 063900A50000F103	  2243:             addi.b #$A5,$F103
02:00001762 67FE            	  2244:             beq.s *                       * Check Z Flag  beq/bne
02:00001764 6BFE            	  2245:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001766 64FE            	  2246:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001768 68FE            	  2247:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000176A 0C39002D0000F103	  2248:             cmpi.b #$2D,$F103
02:00001772 66FE            	  2249:             bne.s *                       * Check Z Flag  beq/bne
                            	  2250: 
                            	  2251: *     EA = x.L- WORD
02:00001774 207C0000F100    	  2252:             move.l #$F100,a0      * populate test data
02:0000177A 20BC12345678    	  2253:             move.l #$12345678,(a0)     * populate test data
02:00001780 067900000000F100	  2254:             addi.w #0,$F100
02:00001788 67FE            	  2255:             beq.s *                       * Check Z Flag  beq/bne
02:0000178A 6BFE            	  2256:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000178C 65FE            	  2257:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000178E 69FE            	  2258:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001790 067970000000F100	  2259:             addi.w #$7000,$F100
02:00001798 67FE            	  2260:             beq.s *                       * Check Z Flag  beq/bne
02:0000179A 6AFE            	  2261:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000179C 65FE            	  2262:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000179E 68FE            	  2263:             bvc.s *                       * Check V Flag  bvc/bvs
02:000017A0 0679A55A0000F100	  2264:             addi.w #$A55A,$F100
02:000017A8 67FE            	  2265:             beq.s *                       * Check Z Flag  beq/bne
02:000017AA 6BFE            	  2266:             bmi.s *                       * Check N Flag  bmi/bpl
02:000017AC 64FE            	  2267:             bcc.s *                       * Check C Flag  bcc/bcs
02:000017AE 68FE            	  2268:             bvc.s *                       * Check V Flag  bvc/bvs
02:000017B0 0C79278E0000F100	  2269:             cmpi.w #$278E,$F100
02:000017B8 66FE            	  2270:             bne.s *                       * Check Z Flag  beq/bne
                            	  2271: 
                            	  2272: *     EA = x.L- LONG
02:000017BA 23FC123456780000	  2273:             move.l #$12345678,$F100  * populate test data
02:000017C2 F100
02:000017C4 06B9000000000000	  2274:             addi.l #0,$F100
02:000017CC F100
02:000017CE 67FE            	  2275:             beq.s *                       * Check Z Flag  beq/bne
02:000017D0 6BFE            	  2276:             bmi.s *                       * Check N Flag  bmi/bpl
02:000017D2 65FE            	  2277:             bcs.s *                       * Check C Flag  bcc/bcs
02:000017D4 69FE            	  2278:             bvs.s *                       * Check V Flag  bvc/bvs
02:000017D6 06B9F00000000000	  2279:             addi.l #$F0000000,$F100
02:000017DE F100
02:000017E0 67FE            	  2280:             beq.s *                       * Check Z Flag  beq/bne
02:000017E2 6BFE            	  2281:             bmi.s *                       * Check N Flag  bmi/bpl
02:000017E4 64FE            	  2282:             bcc.s *                       * Check C Flag  bcc/bcs
02:000017E6 69FE            	  2283:             bvs.s *                       * Check V Flag  bvc/bvs
02:000017E8 06B9855AA55A0000	  2284:             addi.l #$855AA55A,$F100
02:000017F0 F100
02:000017F2 67FE            	  2285:             beq.s *                       * Check Z Flag  beq/bne
02:000017F4 6AFE            	  2286:             bpl.s *                       * Check N Flag  bmi/bpl
02:000017F6 65FE            	  2287:             bcs.s *                       * Check C Flag  bcc/bcs
02:000017F8 69FE            	  2288:             bvs.s *                       * Check V Flag  bvc/bvs
02:000017FA 06B9A00000000000	  2289:             addi.l #$A0000000,$F100
02:00001802 F100
02:00001804 68FE            	  2290:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001806 0CB9278EFBD20000	  2291:             cmpi.l #$278EFBD2,$F100
02:0000180E F100
02:00001810 66FE            	  2292:             bne.s *                       * Check Z Flag  beq/bne
                            	  2293: 
02:00001812 4E75            	  2294:             rts
                            	  2295: 
                            	  2296: 
                            	  2297: *-----------------------------------------------------------
                            	  2298: *-----------------------------------------------------------
                            	  2299: * OPCODE : SUB_I
                            	  2300: *-----------------------------------------------------------
                            	  2301: *-----------------------------------------------------------
                            	  2302: op_SUB_I:
                            	  2303: 
                            	  2304: *     EA = Dn  - Byte
02:00001814 203C12345678    	  2305:             move.l #$12345678,d0      * populate test data
02:0000181A 04000000        	  2306:             subi.b #0,d0
02:0000181E 67FE            	  2307:             beq.s *                       * Check Z Flag  beq/bne
02:00001820 6BFE            	  2308:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001822 65FE            	  2309:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001824 69FE            	  2310:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001826 04000010        	  2311:             subi.b #$10,d0
02:0000182A 67FE            	  2312:             beq.s *                       * Check Z Flag  beq/bne
02:0000182C 6BFE            	  2313:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000182E 65FE            	  2314:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001830 69FE            	  2315:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001832 040000A5        	  2316:             subi.b #$A5,d0
02:00001836 67FE            	  2317:             beq.s *                       * Check Z Flag  beq/bne
02:00001838 6AFE            	  2318:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000183A 64FE            	  2319:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000183C 68FE            	  2320:             bvc.s *                       * Check V Flag  bvc/bvs
02:0000183E 0C0000C3        	  2321:             cmpi.b #$C3,d0
02:00001842 66FE            	  2322:             bne.s *                       * Check Z Flag  beq/bne
                            	  2323: 
                            	  2324: *     EA = Dn  - WORD
02:00001844 203C12345678    	  2325:             move.l #$12345678,d0      * populate test data
02:0000184A 04400000        	  2326:             subi.w #0,d0
02:0000184E 67FE            	  2327:             beq.s *                       * Check Z Flag  beq/bne
02:00001850 6BFE            	  2328:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001852 65FE            	  2329:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001854 69FE            	  2330:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001856 04407000        	  2331:             subi.w #$7000,d0
02:0000185A 67FE            	  2332:             beq.s *                       * Check Z Flag  beq/bne
02:0000185C 6AFE            	  2333:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000185E 64FE            	  2334:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001860 69FE            	  2335:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001862 0440A55A        	  2336:             subi.w #$A55A,d0
02:00001866 67FE            	  2337:             beq.s *                       * Check Z Flag  beq/bne
02:00001868 6BFE            	  2338:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000186A 65FE            	  2339:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000186C 69FE            	  2340:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000186E 0C40411E        	  2341:             cmpi.w #$411E,d0
02:00001872 66FE            	  2342:             bne.s *                       * Check Z Flag  beq/bne
                            	  2343: 
                            	  2344: *     EA = Dn  - LONG
02:00001874 203C12345678    	  2345:             move.l #$12345678,d0      * populate test data
02:0000187A 048000000000    	  2346:             subi.l #0,d0
02:00001880 67FE            	  2347:             beq.s *                       * Check Z Flag  beq/bne
02:00001882 6BFE            	  2348:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001884 65FE            	  2349:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001886 69FE            	  2350:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001888 0480F0000000    	  2351:             subi.l #$F0000000,d0
02:0000188E 67FE            	  2352:             beq.s *                       * Check Z Flag  beq/bne
02:00001890 6BFE            	  2353:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001892 64FE            	  2354:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001894 69FE            	  2355:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001896 0480855AA55A    	  2356:             subi.l #$855AA55A,d0
02:0000189C 67FE            	  2357:             beq.s *                       * Check Z Flag  beq/bne
02:0000189E 6AFE            	  2358:             bpl.s *                       * Check N Flag  bmi/bpl
02:000018A0 64FE            	  2359:             bcc.s *                       * Check C Flag  bcc/bcs
02:000018A2 68FE            	  2360:             bvc.s *                       * Check V Flag  bvc/bvs
02:000018A4 0480A0000000    	  2361:             subi.l #$A0000000,d0
02:000018AA 69FE            	  2362:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018AC 0C80FCD9B11E    	  2363:             cmpi.l #$FCD9B11E,d0
02:000018B2 66FE            	  2364:             bne.s *                       * Check Z Flag  beq/bne
                            	  2365: 
                            	  2366: 
                            	  2367: 
                            	  2368: *     EA = x.L  - Byte
02:000018B4 207C0000F100    	  2369:             move.l #$F100,a0      * populate test data
02:000018BA 20BC12345678    	  2370:             move.l #$12345678,(a0)     * populate test data
02:000018C0 043900000000F103	  2371:             subi.b #0,$F103
02:000018C8 67FE            	  2372:             beq.s *                       * Check Z Flag  beq/bne
02:000018CA 6BFE            	  2373:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018CC 65FE            	  2374:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018CE 69FE            	  2375:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018D0 043900100000F103	  2376:             subi.b #$10,$F103
02:000018D8 67FE            	  2377:             beq.s *                       * Check Z Flag  beq/bne
02:000018DA 6BFE            	  2378:             bmi.s *                       * Check N Flag  bmi/bpl
02:000018DC 65FE            	  2379:             bcs.s *                       * Check C Flag  bcc/bcs
02:000018DE 69FE            	  2380:             bvs.s *                       * Check V Flag  bvc/bvs
02:000018E0 043900A50000F103	  2381:             subi.b #$A5,$F103
02:000018E8 67FE            	  2382:             beq.s *                       * Check Z Flag  beq/bne
02:000018EA 6AFE            	  2383:             bpl.s *                       * Check N Flag  bmi/bpl
02:000018EC 64FE            	  2384:             bcc.s *                       * Check C Flag  bcc/bcs
02:000018EE 68FE            	  2385:             bvc.s *                       * Check V Flag  bvc/bvs
02:000018F0 0C3900C30000F103	  2386:             cmpi.b #$C3,$F103
02:000018F8 66FE            	  2387:             bne.s *                       * Check Z Flag  beq/bne
                            	  2388: 
                            	  2389: *     EA = x.L- WORD
02:000018FA 207C0000F100    	  2390:             move.l #$F100,a0      * populate test data
02:00001900 20BC12345678    	  2391:             move.l #$12345678,(a0)     * populate test data
02:00001906 047900000000F100	  2392:             subi.w #0,$F100
02:0000190E 67FE            	  2393:             beq.s *                       * Check Z Flag  beq/bne
02:00001910 6BFE            	  2394:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001912 65FE            	  2395:             bcs.s *                       * Check C Flag  bcc/bcs
02:00001914 69FE            	  2396:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001916 047970000000F100	  2397:             subi.w #$7000,$F100
02:0000191E 67FE            	  2398:             beq.s *                       * Check Z Flag  beq/bne
02:00001920 6AFE            	  2399:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001922 64FE            	  2400:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001924 69FE            	  2401:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001926 0479A55A0000F100	  2402:             subi.w #$A55A,$F100
02:0000192E 67FE            	  2403:             beq.s *                       * Check Z Flag  beq/bne
02:00001930 6AFE            	  2404:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001932 64FE            	  2405:             bcc.s *                       * Check C Flag  bcc/bcs
02:00001934 69FE            	  2406:             bvs.s *                       * Check V Flag  bvc/bvs
02:00001936 0C79FCDA0000F100	  2407:             cmpi.w #$FCDA,$F100
02:0000193E 66FE            	  2408:             bne.s *                       * Check Z Flag  beq/bne
                            	  2409: 
                            	  2410: *     EA = x.L- LONG
02:00001940 23FC123456780000	  2411:             move.l #$12345678,$F100  * populate test data
02:00001948 F100
02:0000194A 04B9000000000000	  2412:             subi.l #0,$F100
02:00001952 F100
02:00001954 67FE            	  2413:             beq.s *                       * Check Z Flag  beq/bne
02:00001956 6BFE            	  2414:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001958 65FE            	  2415:             bcs.s *                       * Check C Flag  bcc/bcs
02:0000195A 69FE            	  2416:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000195C 04B9F00000000000	  2417:             subi.l #$F0000000,$F100
02:00001964 F100
02:00001966 67FE            	  2418:             beq.s *                       * Check Z Flag  beq/bne
02:00001968 6BFE            	  2419:             bmi.s *                       * Check N Flag  bmi/bpl
02:0000196A 64FE            	  2420:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000196C 69FE            	  2421:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000196E 04B9855AA55A0000	  2422:             subi.l #$855AA55A,$F100
02:00001976 F100
02:00001978 67FE            	  2423:             beq.s *                       * Check Z Flag  beq/bne
02:0000197A 6AFE            	  2424:             bpl.s *                       * Check N Flag  bmi/bpl
02:0000197C 64FE            	  2425:             bcc.s *                       * Check C Flag  bcc/bcs
02:0000197E 68FE            	  2426:             bvc.s *                       * Check V Flag  bvc/bvs
02:00001980 04B9A00000000000	  2427:             subi.l #$A0000000,$F100
02:00001988 F100
02:0000198A 69FE            	  2428:             bvs.s *                       * Check V Flag  bvc/bvs
02:0000198C 0CB9FCD9B11E0000	  2429:             cmpi.l #$FCD9B11E,$F100
02:00001994 F100
02:00001996 66FE            	  2430:             bne.s *                       * Check Z Flag  beq/bne
                            	  2431: 
02:00001998 4E75            	  2432:             rts
                            	  2433: 
                            	  2434: 
                            	  2435: 
                            	  2436: *-----------------------------------------------------------
                            	  2437: *-----------------------------------------------------------
                            	  2438: * OPCODE : MOVE
                            	  2439: *-----------------------------------------------------------
                            	  2440: *-----------------------------------------------------------
                            	  2441: op_MOVE:
02:0000199A 203C11223344    	  2442:             move.l #$11223344,d0
02:000019A0 223C55667788    	  2443:             move.l #$55667788,d1
02:000019A6 243C8899AABB    	  2444:             move.l #$8899aabb,d2
02:000019AC 263CCCDDEEFF    	  2445:             move.l #$ccddeeff,d3
02:000019B2 7800            	  2446:             moveq  #$00000000,d4
02:000019B4 7A00            	  2447:             moveq  #$00000000,d5
02:000019B6 7C00            	  2448:             moveq  #$00000000,d6
02:000019B8 7E00            	  2449:             moveq  #$00000000,d7
02:000019BA 207C44332211    	  2450:             move.l #$44332211,a0
02:000019C0 227C88776655    	  2451:             move.l #$88776655,a1
02:000019C6 247CBBAA9988    	  2452:             move.l #$bbaa9988,a2
02:000019CC 267CFFEEDDCC    	  2453:             move.l #$ffeeddcc,a3
                            	  2454: 
02:000019D2 1800            	  2455:             move.b d0,d4              * BYTE - DATA REGISTER
02:000019D4 67FE            	  2456:             beq.s *                       * Check Z Flag  beq/bne
02:000019D6 6BFE            	  2457:             bmi.s *                       * Check N Flag  bmi/bpl
02:000019D8 0C8400000044    	  2458:             cmpi.l #$00000044,d4
02:000019DE 66FE            	  2459:             bne.s *                       * Check Z Flag  beq/bne
                            	  2460: 
02:000019E0 3A01            	  2461:             move.w d1,d5              * WORD - DATA REGISTER
02:000019E2 67FE            	  2462:             beq.s *                       * Check Z Flag  beq/bne
02:000019E4 6BFE            	  2463:             bmi.s *                       * Check N Flag  bmi/bpl
02:000019E6 0C8500007788    	  2464:             cmpi.l #$00007788,d5
02:000019EC 66FE            	  2465:             bne.s *                       * Check Z Flag  beq/bne
                            	  2466: 
02:000019EE 2C02            	  2467:             move.l d2,d6              * LONG - DATA REGISTER
02:000019F0 67FE            	  2468:             beq.s *                       * Check Z Flag  beq/bne
02:000019F2 6AFE            	  2469:             bpl.s *                       * Check N Flag  bmi/bpl
02:000019F4 0C868899AABB    	  2470:             cmpi.l #$8899aabb,d6
02:000019FA 66FE            	  2471:             bne.s *                       * Check Z Flag  beq/bne
                            	  2472: 
02:000019FC 3A09            	  2473:             move.w a1,d5              * WORD - ADDRESS REGISTER
02:000019FE 67FE            	  2474:             beq.s *                       * Check Z Flag  beq/bne
02:00001A00 6BFE            	  2475:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A02 0C8500006655    	  2476:             cmpi.l #$00006655,d5
02:00001A08 66FE            	  2477:             bne.s *                       * Check Z Flag  beq/bne
                            	  2478: 
02:00001A0A 2C0A            	  2479:             move.l a2,d6              * LONG - ADDRESS REGISTER
02:00001A0C 67FE            	  2480:             beq.s *                       * Check Z Flag  beq/bne
02:00001A0E 6AFE            	  2481:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001A10 0C86BBAA9988    	  2482:             cmpi.l #$bbaa9988,d6
02:00001A16 66FE            	  2483:             bne.s *                       * Check Z Flag  beq/bne
                            	  2484: 
                            	  2485: 
02:00001A18 3842            	  2486:             movea.w d2,a4             * WORD - ADDRESS REGISTER as SOURCE ## MOVEA
02:00001A1A B9C2            	  2487:             cmpa.l d2,a4
02:00001A1C 67FE            	  2488:             beq.s *                       * Check Z Flag  beq/bne ## comopare fails because A4 was sign extended
                            	  2489: 
02:00001A1E 2A41            	  2490:             movea.l d1,a5             * LONG - ADDRESS REGISTER as SOURCE ## MOVEA
02:00001A20 BBC1            	  2491:             cmpa.l d1,a5
02:00001A22 66FE            	  2492:             bne.s *                       * Check Z Flag  beq/bne
                            	  2493: 
                            	  2494: 
                            	  2495: 
                            	  2496: *   Too mamy EA combinations to test,so we focus on a few of the more complicted EA's
                            	  2497: 
02:00001A24 203C11223344    	  2498:             move.l #$11223344,d0
02:00001A2A 223C00010100    	  2499:             move.l #$00010100,d1
02:00001A30 243C8899AABB    	  2500:             move.l #$8899aabb,d2
02:00001A36 7601            	  2501:             moveq  #$00000001,d3
02:00001A38 7800            	  2502:             moveq  #$00000000,d4
02:00001A3A 7A00            	  2503:             moveq  #$00000000,d5
02:00001A3C 7C00            	  2504:             moveq  #$00000000,d6
02:00001A3E 7E00            	  2505:             moveq  #$00000000,d7
02:00001A40 91C8            	  2506:             move.l #$00000000,a0
02:00001A42 227C00010100    	  2507:             move.l #$00010100,a1
                            	  2508: 
                            	  2509: *     x(An,AL) --> x.L
02:00001A48 11BC005A9804    	  2510:             move.b #$5A,4(a0,a1.l)    * BYTE
02:00001A4E 47F09804        	  2511:             lea 4(a0,a1.l),a3
02:00001A52 13F0980400010105	  2512:             move.b 4(a0,a1.l),$00010105
02:00001A5A 67FE            	  2513:             beq.s *                       * Check Z Flag  beq/bne
02:00001A5C 6BFE            	  2514:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A5E 0C30005A9805    	  2515:             cmpi.b #$5A,5(a0,a1.l)
02:00001A64 66FE            	  2516:             bne.s *                       * Check Z Flag  beq/bne
                            	  2517: 
                            	  2518: *     x.L --> n(An,Dw)
02:00001A66 11B9000101051007	  2519: MOVE2:      move.b  $00010105,7(a0,d1.w)    * BYTE
02:00001A6E 67FE            	  2520:             beq.s *                       * Check Z Flag  beq/bne
02:00001A70 6BFE            	  2521:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A72 0C30005A1007    	  2522:             cmpi.b #$5A,7(a0,d1.w)
02:00001A78 66FE            	  2523:             bne.s *                       * Check Z Flag  beq/bne
                            	  2524: 
                            	  2525: *     x(PC,Ds) --> x.w
02:00001A7A 11FB30660100    	  2526:             move.b  MOVE1(pc,d3.w),$0100 * BYTE
02:00001A80 67FE            	  2527:             beq.s *                       * Check Z Flag  beq/bne
02:00001A82 6AFE            	  2528:             bpl.s *                       * Check N Flag  bmi/bpl
02:00001A84 0C3900B900001A67	  2529:             cmpi.b #$B9,1+MOVE2
02:00001A8C 66FE            	  2530:             bne.s *                       * Check Z Flag  beq/bne
                            	  2531: 
                            	  2532: *     #x -->    n(An,AL)
02:00001A8E 11BC00781007    	  2533:             move.b  #$78,7(a0,d1.w)    * BYTE
02:00001A94 67FE            	  2534:             beq.s *                       * Check Z Flag  beq/bne
02:00001A96 6BFE            	  2535:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001A98 0C3000781007    	  2536:             cmpi.b #$78,7(a0,d1.w)
02:00001A9E 66FE            	  2537:             bne.s *                       * Check Z Flag  beq/bne
                            	  2538: 
02:00001AA0 203C11223344    	  2539:             move.l #$11223344,d0
02:00001AA6 223C00010100    	  2540:             move.l #$00010100,d1
02:00001AAC 243C8899AABB    	  2541:             move.l #$8899aabb,d2
02:00001AB2 7602            	  2542:             moveq  #$00000002,d3
02:00001AB4 7800            	  2543:             moveq  #$00000000,d4
02:00001AB6 7A00            	  2544:             moveq  #$00000000,d5
02:00001AB8 7C00            	  2545:             moveq  #$00000000,d6
02:00001ABA 7E00            	  2546:             moveq  #$00000000,d7
02:00001ABC 91C8            	  2547:             move.l #$00000000,a0
02:00001ABE 227C00010100    	  2548:             move.l #$00010100,a1
                            	  2549: 
                            	  2550: *     x(An,AL) --> x.L
02:00001AC4 31BC5A5A9804    	  2551:             move.w #$5A5A,4(a0,a1.l)    * WORD
02:00001ACA 49F09804        	  2552:             lea 4(a0,a1.l),a4
02:00001ACE 33F0980400010104	  2553:             move.w 4(a0,a1.l),$00010104
02:00001AD6 67FE            	  2554:             beq.s *                       * Check Z Flag  beq/bne
02:00001AD8 6BFE            	  2555:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001ADA 0C705A5A9804    	  2556:             cmpi.w #$5A5A,4(a0,a1.l)
02:00001AE0 66FE            	  2557:             bne.s *                       * Check Z Flag  beq/bne
                            	  2558: 
                            	  2559: *     x.L --> n(An,Dw)
02:00001AE2 31B9000101041006	  2560: MOVE1:      move.w  $00010104,6(a0,d1.w)    * WORD
02:00001AEA 67FE            	  2561:             beq.s *                       * Check Z Flag  beq/bne
02:00001AEC 6BFE            	  2562:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001AEE 0C705A5A1006    	  2563:             cmpi.w #$5A5A,6(a0,d1.w)
02:00001AF4 66FE            	  2564:             bne.s *                       * Check Z Flag  beq/bne
                            	  2565: 
                            	  2566: *     x(PC,Ds) --> x.w
02:00001AF6 31FB30EA0100    	  2567:             move.w  MOVE1(pc,d3),$0100 * WORD
02:00001AFC 67FE            	  2568:             beq.s *                       * Check Z Flag  beq/bne
02:00001AFE 6BFE            	  2569:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B00 0C7967FE00001AEA	  2570:             cmpi.w #$67FE,8+MOVE1
02:00001B08 66FE            	  2571:             bne.s *                       * Check Z Flag  beq/bne
                            	  2572: 
                            	  2573: *     #x -->    n(An,AL)
02:00001B0A 31BC78781006    	  2574:             move.w  #$7878,6(a0,d1.w)    * WORD
02:00001B10 67FE            	  2575:             beq.s *                       * Check Z Flag  beq/bne
02:00001B12 6BFE            	  2576:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B14 0C7078781006    	  2577:             cmpi.w #$7878,6(a0,d1.w)
02:00001B1A 66FE            	  2578:             bne.s *                       * Check Z Flag  beq/bne
                            	  2579: 
                            	  2580: * ---
                            	  2581: 
02:00001B1C 203C11223344    	  2582:             move.l #$11223344,d0
02:00001B22 223C00010100    	  2583:             move.l #$00010100,d1
02:00001B28 243C8899AABB    	  2584:             move.l #$8899aabb,d2
02:00001B2E 7602            	  2585:             moveq  #$00000002,d3
02:00001B30 7800            	  2586:             moveq  #$00000000,d4
02:00001B32 7A00            	  2587:             moveq  #$00000000,d5
02:00001B34 7C00            	  2588:             moveq  #$00000000,d6
02:00001B36 7E00            	  2589:             moveq  #$00000000,d7
02:00001B38 91C8            	  2590:             move.l #$00000000,a0
02:00001B3A 227C00010100    	  2591:             move.l #$00010100,a1
                            	  2592: 
                            	  2593: *     x(An,AL) --> x.L
02:00001B40 21BC5A5A12349804	  2594:             move.l #$5A5A1234,4(a0,a1.l)    * LONG
02:00001B48 49F09804        	  2595:             lea 4(a0,a1.l),a4
02:00001B4C 23F0980400010104	  2596:             move.l 4(a0,a1.l),$00010104
02:00001B54 67FE            	  2597:             beq.s *                       * Check Z Flag  beq/bne
02:00001B56 6BFE            	  2598:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B58 0CB05A5A12349804	  2599:             cmpi.l #$5A5A1234,4(a0,a1.l)
02:00001B60 66FE            	  2600:             bne.s *                       * Check Z Flag  beq/bne
                            	  2601: 
                            	  2602: *     x.L --> n(An,Dw)
02:00001B62 21B9000101041006	  2603: MOVE3:      move.l  $00010104,6(a0,d1.w)    * LONG
02:00001B6A 67FE            	  2604:             beq.s *                       * Check Z Flag  beq/bne
02:00001B6C 6BFE            	  2605:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B6E 0CB05A5A12341006	  2606:             cmpi.l #$5A5A1234,6(a0,d1.w)
02:00001B76 66FE            	  2607:             bne.s *                       * Check Z Flag  beq/bne
                            	  2608: 
                            	  2609: *     x(PC,Ds) --> x.w
02:00001B78 21FB30E80100    	  2610:             move.l  MOVE3(pc,d3),$0100 * LONG
02:00001B7E 67FE            	  2611:             beq.s *                       * Check Z Flag  beq/bne
02:00001B80 6BFE            	  2612:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B82 0CB967FE6BFE0000	  2613:             cmpi.l #$67FE6BFE,8+MOVE3
02:00001B8A 1B6A
02:00001B8C 66FE            	  2614:             bne.s *                       * Check Z Flag  beq/bne
                            	  2615: 
                            	  2616: *     #x -->    n(An,AL)
02:00001B8E 21BC787823231006	  2617:             move.l  #$78782323,6(a0,d1.w)    * LONG
02:00001B96 67FE            	  2618:             beq.s *                       * Check Z Flag  beq/bne
02:00001B98 6BFE            	  2619:             bmi.s *                       * Check N Flag  bmi/bpl
02:00001B9A 0CB0787823231006	  2620:             cmpi.l #$78782323,6(a0,d1.w)
02:00001BA2 66FE            	  2621:             bne.s *                       * Check Z Flag  beq/bne
                            	  2622: 
                            	  2623: 
02:00001BA4 4E75            	  2624:          rts
                            	  2625: 
                            	  2626: 
                            	  2627: *-----------------------------------------------------------
                            	  2628: *-----------------------------------------------------------
                            	  2629: * OPCODE : MOVE_xxx_FLAGS
                            	  2630: *-----------------------------------------------------------
                            	  2631: *-----------------------------------------------------------
                            	  2632: op_MOVE_xxx_FLAGS:
                            	  2633: 
                            	  2634: *     Move_To_SR
                            	  2635: 
                            	  2636: *     Dn
                            	  2637: 
02:00001BA6 303C2FFF        	  2638:             move.w #$2FFF,d0
02:00001BAA 46C0            	  2639:             move.w d0,SR
02:00001BAC 6AFE            	  2640:             bpl.s *           * branch if Z clear
02:00001BAE 66FE            	  2641:             bne.s *           * branch if N clear
02:00001BB0 68FE            	  2642:             bvc.s *           * branch if V clear
02:00001BB2 64FE            	  2643:             bcc.s *           * branch if C clear
02:00001BB4 303C2F00        	  2644:             move.w #$2F00,d0
02:00001BB8 44C0            	  2645:             move d0,CCR
02:00001BBA 67FE            	  2646:             beq.s *           * branch if Z set
02:00001BBC 6BFE            	  2647:             bmi.s *           * branch if N set
02:00001BBE 69FE            	  2648:             bvs.s *           * branch if V set
02:00001BC0 65FE            	  2649:             bcs.s *           * branch if C set
                            	  2650: 
02:00001BC2 303C2000        	  2651:             move.w #$2000,d0
02:00001BC6 46C0            	  2652:             move.w d0,SR
02:00001BC8 67FE            	  2653:             beq.s *           * branch if Z set
02:00001BCA 6BFE            	  2654:             bmi.s *           * branch if N set
02:00001BCC 69FE            	  2655:             bvs.s *           * branch if V set
02:00001BCE 65FE            	  2656:             bcs.s *           * branch if C set
                            	  2657: 
                            	  2658: *     (An)
02:00001BD0 307C0100        	  2659:             move.l #$00000100,a0
02:00001BD4 30BC2FFF        	  2660:             move.w #$2FFF,(a0)
02:00001BD8 46D0            	  2661:             move.w (a0),SR
02:00001BDA 6AFE            	  2662:             bpl.s *           * branch if Z clear
02:00001BDC 66FE            	  2663:             bne.s *           * branch if N clear
02:00001BDE 68FE            	  2664:             bvc.s *           * branch if V clear
02:00001BE0 64FE            	  2665:             bcc.s *           * branch if C clear
                            	  2666: 
02:00001BE2 30BC2000        	  2667:             move.w #$2000,(a0)
02:00001BE6 46D0            	  2668:             move.w (a0),SR
02:00001BE8 67FE            	  2669:             beq.s *           * branch if Z set
02:00001BEA 6BFE            	  2670:             bmi.s *           * branch if N set
02:00001BEC 69FE            	  2671:             bvs.s *           * branch if V set
02:00001BEE 65FE            	  2672:             bcs.s *           * branch if C set
                            	  2673: 
                            	  2674: *     (An)+
02:00001BF0 307C0100        	  2675:             move.l #$00000100,a0
02:00001BF4 30BC2FFF        	  2676:             move.w #$2FFF,(a0)
02:00001BF8 46D8            	  2677:             move.w (a0)+,SR
02:00001BFA 6AFE            	  2678:             bpl.s *           * branch if Z clear
02:00001BFC 66FE            	  2679:             bne.s *           * branch if N clear
02:00001BFE 68FE            	  2680:             bvc.s *           * branch if V clear
02:00001C00 64FE            	  2681:             bcc.s *           * branch if C clear
                            	  2682: 
02:00001C02 30BC2000        	  2683:             move.w #$2000,(a0)
02:00001C06 46D8            	  2684:             move.w (a0)+,SR
02:00001C08 67FE            	  2685:             beq.s *           * branch if Z set
02:00001C0A 6BFE            	  2686:             bmi.s *           * branch if N set
02:00001C0C 69FE            	  2687:             bvs.s *           * branch if V set
02:00001C0E 65FE            	  2688:             bcs.s *           * branch if C set
                            	  2689: 
                            	  2690: *     -(An)
02:00001C10 307C0102        	  2691:             move.l #$00000102,a0
02:00001C14 30BC2FFF        	  2692:             move.w #$2FFF,(a0)
02:00001C18 46D8            	  2693:             move.w (a0)+,SR
02:00001C1A 6AFE            	  2694:             bpl.s *           * branch if Z clear
02:00001C1C 66FE            	  2695:             bne.s *           * branch if N clear
02:00001C1E 68FE            	  2696:             bvc.s *           * branch if V clear
02:00001C20 64FE            	  2697:             bcc.s *           * branch if C clear
                            	  2698: 
02:00001C22 30BC2000        	  2699:             move.w #$2000,(a0)
02:00001C26 46D8            	  2700:             move.w (a0)+,SR
02:00001C28 67FE            	  2701:             beq.s *           * branch if Z set
02:00001C2A 6BFE            	  2702:             bmi.s *           * branch if N set
02:00001C2C 69FE            	  2703:             bvs.s *           * branch if V set
02:00001C2E 65FE            	  2704:             bcs.s *           * branch if C set
                            	  2705: 
                            	  2706: *     n(An)
02:00001C30 307C0102        	  2707:             move.l #$00000102,a0
02:00001C34 317C2FFF0002    	  2708:             move.w #$2FFF,2(a0)
02:00001C3A 46E80002        	  2709:             move.w 2(a0),SR
02:00001C3E 6AFE            	  2710:             bpl.s *           * branch if Z clear
02:00001C40 66FE            	  2711:             bne.s *           * branch if N clear
02:00001C42 68FE            	  2712:             bvc.s *           * branch if V clear
02:00001C44 64FE            	  2713:             bcc.s *           * branch if C clear
                            	  2714: 
02:00001C46 317C20000002    	  2715:             move.w #$2000,2(a0)
02:00001C4C 46E80002        	  2716:             move.w 2(a0),SR
02:00001C50 67FE            	  2717:             beq.s *           * branch if Z set
02:00001C52 6BFE            	  2718:             bmi.s *           * branch if N set
02:00001C54 69FE            	  2719:             bvs.s *           * branch if V set
02:00001C56 65FE            	  2720:             bcs.s *           * branch if C set
                            	  2721: 
                            	  2722: *     n(An,Rn.l)
02:00001C58 307C0100        	  2723:             move.l #$00000100,a0
02:00001C5C 7002            	  2724:             moveq  #$00000002,d0
02:00001C5E 31BC2FFF0802    	  2725:             move.w #$2FFF,2(a0,d0.l)
02:00001C64 46F00802        	  2726:             move.w 2(a0,d0.l),SR
02:00001C68 6AFE            	  2727:             bpl.s *           * branch if Z clear
02:00001C6A 66FE            	  2728:             bne.s *           * branch if N clear
02:00001C6C 68FE            	  2729:             bvc.s *           * branch if V clear
02:00001C6E 64FE            	  2730:             bcc.s *           * branch if C clear
                            	  2731: 
02:00001C70 31BC20000802    	  2732:             move.w #$2000,2(a0,d0.l)
02:00001C76 46F00802        	  2733:             move.w 2(a0,d0.l),SR
02:00001C7A 67FE            	  2734:             beq.s *           * branch if Z set
02:00001C7C 6BFE            	  2735:             bmi.s *           * branch if N set
02:00001C7E 69FE            	  2736:             bvs.s *           * branch if V set
02:00001C80 65FE            	  2737:             bcs.s *           * branch if C set
                            	  2738: 
                            	  2739: *     x.W
02:00001C82 31FC2FFF0100    	  2740:             move.w #$2FFF,$0100
02:00001C88 46F80100        	  2741:             move.w $0100,SR
02:00001C8C 6AFE            	  2742:             bpl.s *           * branch if Z clear
02:00001C8E 66FE            	  2743:             bne.s *           * branch if N clear
02:00001C90 68FE            	  2744:             bvc.s *           * branch if V clear
02:00001C92 64FE            	  2745:             bcc.s *           * branch if C clear
                            	  2746: 
02:00001C94 31FC20000100    	  2747:             move.w #$2000,$0100
02:00001C9A 46F80100        	  2748:             move.w $0100,SR
02:00001C9E 67FE            	  2749:             beq.s *           * branch if Z set
02:00001CA0 6BFE            	  2750:             bmi.s *           * branch if N set
02:00001CA2 69FE            	  2751:             bvs.s *           * branch if V set
02:00001CA4 65FE            	  2752:             bcs.s *           * branch if C set
                            	  2753: 
                            	  2754: *     x.L
02:00001CA6 33FC2FFF00010100	  2755:             move.w #$2FFF,$00010100
02:00001CAE 46F900010100    	  2756:             move.w $00010100,SR
02:00001CB4 6AFE            	  2757:             bpl.s *           * branch if Z clear
02:00001CB6 66FE            	  2758:             bne.s *           * branch if N clear
02:00001CB8 68FE            	  2759:             bvc.s *           * branch if V clear
02:00001CBA 64FE            	  2760:             bcc.s *           * branch if C clear
                            	  2761: 
02:00001CBC 33FC200000010100	  2762: MOVE4:      move.w #$2000,$00010100
02:00001CC4 46F900010100    	  2763:             move.w $00010100,SR
02:00001CCA 67FE            	  2764:             beq.s *           * branch if Z set
02:00001CCC 6BFE            	  2765:             bmi.s *           * branch if N set
02:00001CCE 69FE            	  2766:             bvs.s *           * branch if V set
02:00001CD0 65FE            	  2767:             bcs.s *           * branch if C set
                            	  2768: 
                            	  2769: *     x(PC)
02:00001CD2 46FAFFEA        	  2770:             move.w MOVE4+2(pc),SR
02:00001CD6 67FE            	  2771:             beq.s *           * branch if Z set
02:00001CD8 6BFE            	  2772:             bmi.s *           * branch if N set
02:00001CDA 69FE            	  2773:             bvs.s *           * branch if V set
02:00001CDC 65FE            	  2774:             bcs.s *           * branch if C set
                            	  2775: 
                            	  2776: *     x(PC,d0.l)
02:00001CDE 7000            	  2777:             moveq  #$00000000,d0
02:00001CE0 46FB08DC        	  2778:             move.w MOVE4+2(pc,d0.l),SR
02:00001CE4 67FE            	  2779:             beq.s *           * branch if Z set
02:00001CE6 6BFE            	  2780:             bmi.s *           * branch if N set
02:00001CE8 69FE            	  2781:             bvs.s *           * branch if V set
02:00001CEA 65FE            	  2782:             bcs.s *           * branch if C set
02:00001CEC 44FB08D0        	  2783:             move MOVE4+2(pc,d0.l),CCR
02:00001CF0 67FE            	  2784:             beq.s *           * branch if Z set
02:00001CF2 6BFE            	  2785:             bmi.s *           * branch if N set
02:00001CF4 69FE            	  2786:             bvs.s *           * branch if V set
02:00001CF6 65FE            	  2787:             bcs.s *           * branch if C set
                            	  2788: 
                            	  2789: *     #x
02:00001CF8 46FC2FFF        	  2790:             move.w #$2FFF,SR
02:00001CFC 66FE            	  2791:             bne.s *           * branch if Z clear
02:00001CFE 6AFE            	  2792:             bpl.s *           * branch if N clear
02:00001D00 68FE            	  2793:             bvc.s *           * branch if V clear
02:00001D02 64FE            	  2794:             bcc.s *           * branch if C clear
                            	  2795: 
                            	  2796: 
                            	  2797: 
                            	  2798: *  MOVE_From_SR
                            	  2799: 
                            	  2800: 
                            	  2801: 
                            	  2802: *     Dn
02:00001D04 46FC275A        	  2803:             move.w #$275A,SR          * Initial value
02:00001D08 40C0            	  2804:             move.w SR,d0
02:00001D0A 0C40271A        	  2805:             cmpi.w #$271A,d0
                            	  2806: * The following fails because sr bits are implemented and non-zero so later code works.           
                            	  2807: *            bne.s *                   * branch if Z set
                            	  2808: 
                            	  2809: *     (An)
02:00001D0E 307C0100        	  2810:             move.l #$00000100,a0
02:00001D12 46FC275A        	  2811:             move.w #$275A,SR          * Initial value
02:00001D16 40D0            	  2812:             move.w SR,(a0)
02:00001D18 0C50275A        	  2813:             cmpi.w #$275A,(a0)
02:00001D1C 66FE            	  2814:             bne.s *                   * branch if Z set
                            	  2815: 
                            	  2816: *     (An)+
02:00001D1E 307C0100        	  2817:             move.l #$00000100,a0
02:00001D22 46FC257A        	  2818:             move.w #$257A,SR          * Initial value
02:00001D26 40D8            	  2819:             move.w SR,(a0)+
02:00001D28 307C0100        	  2820:             move.l #$00000100,a0
02:00001D2C 0C58257A        	  2821:             cmpi.w #$257A,(a0)+
02:00001D30 66FE            	  2822:             bne.s *                   * branch if Z set
                            	  2823: 
                            	  2824: *     -(An)
02:00001D32 307C0102        	  2825:             move.l #$00000102,a0
02:00001D36 46FC2766        	  2826:             move.w #$2766,SR          * Initial value
02:00001D3A 40E0            	  2827:             move.w SR,-(a0)
02:00001D3C 307C0100        	  2828:             move.l #$00000100,a0
02:00001D40 0C502766        	  2829:             cmpi.w #$2766,(a0)
02:00001D44 66FE            	  2830:             bne.s *                   * branch if Z set
                            	  2831: 
                            	  2832: *     x(An)
02:00001D46 307C0102        	  2833:             move.l #$00000102,a0
02:00001D4A 46FC2733        	  2834:             move.w #$2733,SR          * Initial value
02:00001D4E 40E80004        	  2835:             move.w SR,4(a0)
02:00001D52 0C6827330004    	  2836:             cmpi.w #$2733,4(a0)
02:00001D58 66FE            	  2837:             bne.s *                   * branch if Z set
                            	  2838: 
                            	  2839: *     x(An,rn)
02:00001D5A 307C0102        	  2840:             move.l #$00000102,a0
02:00001D5E 7004            	  2841:             moveq  #$00000004,d0
02:00001D60 46FC275A        	  2842:             move.w #$275a,SR          * Initial value
02:00001D64 40F00804        	  2843:             move.w SR,4(a0,d0.l)
02:00001D68 0C70275A0804    	  2844:             cmpi.w #$275a,4(a0,d0.l)
02:00001D6E 66FE            	  2845:             bne.s *                   * branch if Z set
                            	  2846: 
                            	  2847: *     x.W
02:00001D70 46FC2777        	  2848:             move.w #$2777,SR          * Initial value
02:00001D74 40F80102        	  2849:             move.w SR,$0102
02:00001D78 0C7827770102    	  2850:             cmpi.w #$2777,$0102
02:00001D7E 66FE            	  2851:             bne.s *                   * branch if Z set
                            	  2852: 
                            	  2853: *     x.L
02:00001D80 46FC2777        	  2854:             move.w #$2777,SR          * Initial value
02:00001D84 40F900010102    	  2855:             move.w SR,$10102
02:00001D8A 0C79277700010102	  2856:             cmpi.w #$2777,$10102
02:00001D92 66FE            	  2857:             bne.s *                   * branch if Z set
                            	  2858: 
                            	  2859: 
                            	  2860: 
02:00001D94 46FC2700        	  2861:             move.w #$2700,SR          * Put flags back to initial value
                            	  2862: 
02:00001D98 4E75            	  2863:             rts
                            	  2864: 
                            	  2865: 
                            	  2866: *-----------------------------------------------------------
                            	  2867: *-----------------------------------------------------------
                            	  2868: * OPCODE : EXT
                            	  2869: *-----------------------------------------------------------
                            	  2870: *-----------------------------------------------------------
                            	  2871: op_EXT:
                            	  2872: 
02:00001D9A 707F            	  2873:             move.l #$0000007F,d0
02:00001D9C 223C00008FFF    	  2874:             move.l #$00008FFF,d1
02:00001DA2 7400            	  2875:             moveq  #$00000000,d2
                            	  2876: 
02:00001DA4 4880            	  2877:             ext.w d0
02:00001DA6 6BFE            	  2878:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001DA8 67FE            	  2879:             beq.s *                   * Check Z Flag  beq/bne
02:00001DAA 0C800000007F    	  2880:             cmpi.l #$0000007F,d0
02:00001DB0 66FE            	  2881:             bne.s *                   * branch if Z set
                            	  2882: 
02:00001DB2 48C1            	  2883:             ext.l d1
02:00001DB4 6AFE            	  2884:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001DB6 67FE            	  2885:             beq.s *                   * Check Z Flag  beq/bne
02:00001DB8 0C81FFFF8FFF    	  2886:             cmpi.l #$FFFF8FFF,d1
02:00001DBE 66FE            	  2887:             bne.s *                   * branch if Z set
                            	  2888: 
02:00001DC0 48C2            	  2889:             ext.l d2
02:00001DC2 66FE            	  2890:             bne.s *                   * Check Z Flag  beq/bne
                            	  2891: 
                            	  2892: 
                            	  2893: 
02:00001DC4 4E75            	  2894:             rts
                            	  2895: 
                            	  2896: 
                            	  2897: *-----------------------------------------------------------
                            	  2898: *-----------------------------------------------------------
                            	  2899: * OPCODE : SWAP
                            	  2900: *-----------------------------------------------------------
                            	  2901: *-----------------------------------------------------------
                            	  2902: op_SWAP:
                            	  2903: 
02:00001DC6 203C12345678    	  2904:             move.l #$12345678,d0
                            	  2905: 
02:00001DCC 4840            	  2906:             swap d0
02:00001DCE 6BFE            	  2907:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001DD0 67FE            	  2908:             beq.s *                   * Check Z Flag  beq/bne
02:00001DD2 0C8056781234    	  2909:             cmpi.l #$56781234,d0
02:00001DD8 66FE            	  2910:             bne.s *                   * branch if Z set
                            	  2911: 
                            	  2912: 
                            	  2913: 
02:00001DDA 4E75            	  2914:             rts
                            	  2915: 
                            	  2916: 
                            	  2917: *-----------------------------------------------------------
                            	  2918: *-----------------------------------------------------------
                            	  2919: * OPCODE : LEA_PEA
                            	  2920: *-----------------------------------------------------------
                            	  2921: *-----------------------------------------------------------
                            	  2922: op_LEAPEA:
                            	  2923: 
02:00001DDC 207C00345678    	  2924:             move.l #$00345678,a0
02:00001DE2 7800            	  2925:             moveq  #$00000000,d4
                            	  2926: 
                            	  2927: *     (An)
02:00001DE4 4DD0            	  2928:             lea (a0),a6
02:00001DE6 200E            	  2929:             move.l a6,d0
02:00001DE8 0C8000345678    	  2930:             cmpi.l #$00345678,d0
02:00001DEE 66FE            	  2931:             bne.s *                   * branch if Z set
02:00001DF0 4850            	  2932:             pea (a0)
02:00001DF2 0C9700345678    	  2933:             cmpi.l #$00345678,(a7)
02:00001DF8 66FE            	  2934:             bne.s *                   * branch if Z set
                            	  2935:             * This was without a specifier which the assembler defaulted to .w
02:00001DFA 588F            	  2936:             addq.l #4,a7            * Restore Stack Pointer
                            	  2937: 
                            	  2938: *     x(An)
02:00001DFC 4DE80004        	  2939:             lea 4(a0),a6
02:00001E00 200E            	  2940:             move.l a6,d0
02:00001E02 0C800034567C    	  2941:             cmpi.l #$0034567C,d0
02:00001E08 66FE            	  2942:             bne.s *                   * branch if Z set
02:00001E0A 48680004        	  2943:             pea 4(a0)
02:00001E0E 0C970034567C    	  2944:             cmpi.l #$0034567C,(a7)
02:00001E14 66FE            	  2945:             bne.s *                   * branch if Z set
                            	  2946:             * This was without a specifier which the assembler defaulted to .w
02:00001E16 588F            	  2947:             addq.l #4,a7            * Restore Stack Pointer
                            	  2948: 
                            	  2949: *     x(An,Dn.l)
02:00001E18 4DF04004        	  2950:             lea 4(a0,d4),a6
02:00001E1C 200E            	  2951:             move.l a6,d0
02:00001E1E 0C800034567C    	  2952:             cmpi.l #$0034567C,d0
02:00001E24 66FE            	  2953:             bne.s *                   * branch if Z set
02:00001E26 48704804        	  2954:             pea 4(a0,d4.l)
02:00001E2A 0C970034567C    	  2955:             cmpi.l #$0034567C,(a7)
02:00001E30 66FE            	  2956:             bne.s *                   * branch if Z set
                            	  2957:             * This was without a specifier which the assembler defaulted to .w
02:00001E32 588F            	  2958:             addq.l #4,a7            * Restore Stack Pointer
                            	  2959: 
                            	  2960: *     x.W
02:00001E34 4DF81234        	  2961:             lea $1234,a6
02:00001E38 200E            	  2962:             move.l a6,d0
02:00001E3A 0C401234        	  2963:             cmpi.w #$1234,d0
02:00001E3E 66FE            	  2964:             bne.s *                   * branch if Z set
02:00001E40 48781234        	  2965:             pea $1234
02:00001E44 0C9700001234    	  2966:             cmpi.l #$00001234,(a7)
02:00001E4A 66FE            	  2967:             bne.s *                   * branch if Z set
                            	  2968:             * This was without a specifier which the assembler defaulted to .w
02:00001E4C 588F            	  2969:             addq.l #4,a7            * Restore Stack Pointer
                            	  2970: 
                            	  2971: *     x.L
02:00001E4E 4DF900345678    	  2972:             lea $00345678,a6
02:00001E54 200E            	  2973:             move.l a6,d0
02:00001E56 B08E            	  2974:             cmp.l a6,d0
02:00001E58 66FE            	  2975:             bne.s *                   * branch if Z set
02:00001E5A 487900345678    	  2976:             pea $00345678
02:00001E60 0C9700345678    	  2977:             cmpi.l #$00345678,(a7)
02:00001E66 66FE            	  2978:             bne.s *                   * branch if Z set
                            	  2979:             * This was without a specifier which the assembler defaulted to .w
02:00001E68 588F            	  2980:             addq.l #4,a7            * Restore Stack Pointer
                            	  2981: 
                            	  2982: *     x(PC)
02:00001E6A 4DFA0008        	  2983:             lea LEA1(pc),a6
02:00001E6E 200E            	  2984:             move.l a6,d0
02:00001E70 B08E            	  2985:             cmp.l a6,d0
02:00001E72 66FE            	  2986:             bne.s *                   * branch if Z set
02:00001E74 487AFFFE        	  2987: LEA1:       pea LEA1(pc)
02:00001E78 0C970000241E    	  2988:             cmpi.l #$0000241E,(a7)
02:00001E7E 67FE            	  2989:             beq.s *                   * branch if Z clear
                            	  2990:             * This was without a specifier which the assembler defaulted to .w
02:00001E80 588F            	  2991:             addq.l #4,a7              * Restore Stack Pointer
                            	  2992: 
                            	  2993: 
                            	  2994: 
                            	  2995: 
02:00001E82 46FC2700        	  2996:             move.w #$2700,sr          * Put flags back to initial value
                            	  2997: 
02:00001E86 4E75            	  2998:             rts
                            	  2999:  	
                            	  3000: 
                            	  3001: 
                            	  3002: *-----------------------------------------------------------
                            	  3003: *-----------------------------------------------------------
                            	  3004: * OPCODE : LEA_TAS
                            	  3005: *-----------------------------------------------------------
                            	  3006: *-----------------------------------------------------------
                            	  3007: op_TAS:
                            	  3008: 
                            	  3009: *     Test just one addressing mode
                            	  3010: 
02:00001E88 307C0100        	  3011:             move.l #$00000100,a0
                            	  3012: 
                            	  3013: *     (An)
02:00001E8C 4210            	  3014:             move.b #$00,(a0)
02:00001E8E 6BFE            	  3015:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001E90 66FE            	  3016:             bne.s *                   * Check Z Flag  beq/bne
02:00001E92 4AD0            	  3017:             tas (a0)
02:00001E94 0C100080        	  3018:             cmpi.b #$80,(a0)
02:00001E98 66FE            	  3019:             bne.s *                   * branch if Z set
02:00001E9A 10BC00F5        	  3020:             move.b #$F5,(a0)
02:00001E9E 4AD0            	  3021:             tas (a0)
02:00001EA0 6AFE            	  3022:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001EA2 67FE            	  3023:             beq.s *                   * Check Z Flag  beq/bne
02:00001EA4 4AD0            	  3024:             tas (a0)
02:00001EA6 0C1000F5        	  3025:             cmpi.b #$F5,(a0)
02:00001EAA 66FE            	  3026:             bne.s *                   * branch if Z set
                            	  3027: 
02:00001EAC 4E75            	  3028:             rts
                            	  3029: 
                            	  3030: 
                            	  3031: *-----------------------------------------------------------
                            	  3032: *-----------------------------------------------------------
                            	  3033: * OPCODE : LEA_TST
                            	  3034: *-----------------------------------------------------------
                            	  3035: *-----------------------------------------------------------
                            	  3036: op_TST:
                            	  3037: 
                            	  3038: *     Test just one addressing mode
                            	  3039: 
02:00001EAE 307C0100        	  3040:             move.l #$00000100,a0
                            	  3041: 
                            	  3042: *     (An) - BYTE
02:00001EB2 4210            	  3043:             move.b #$00,(a0)
02:00001EB4 4A10            	  3044:             tst.b (a0)
02:00001EB6 6BFE            	  3045:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001EB8 66FE            	  3046:             bne.s *                   * Check Z Flag  beq/bne
02:00001EBA 10BC00F5        	  3047:             move.b #$F5,(a0)
02:00001EBE 4A10            	  3048:             tst.b (a0)
02:00001EC0 6AFE            	  3049:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001EC2 67FE            	  3050:             beq.s *                   * Check Z Flag  beq/bne
                            	  3051: 
                            	  3052: *     (An) - WORD
02:00001EC4 4250            	  3053:             move.w #$0000,(a0)
02:00001EC6 4A50            	  3054:             tst.w (a0)
02:00001EC8 6BFE            	  3055:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001ECA 66FE            	  3056:             bne.s *                   * Check Z Flag  beq/bne
02:00001ECC 30BCF567        	  3057:             move.w #$F567,(a0)
02:00001ED0 4A50            	  3058:             tst.w (a0)
02:00001ED2 6AFE            	  3059:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001ED4 67FE            	  3060:             beq.s *                   * Check Z Flag  beq/bne
                            	  3061: 
                            	  3062: *     (An) - LONG
02:00001ED6 4290            	  3063:             move.l #$00000000,(a0)
02:00001ED8 4A90            	  3064:             tst.l (a0)
02:00001EDA 6BFE            	  3065:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001EDC 66FE            	  3066:             bne.s *                   * Check Z Flag  beq/bne
02:00001EDE 20BCF56789AB    	  3067:             move.l #$F56789ab,(a0)
02:00001EE4 4A90            	  3068:             tst.l (a0)
02:00001EE6 6AFE            	  3069:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001EE8 67FE            	  3070:             beq.s *                   * Check Z Flag  beq/bne
                            	  3071: 
                            	  3072: 
02:00001EEA 4E75            	  3073:             rts
                            	  3074: 
                            	  3075: 
                            	  3076: *-----------------------------------------------------------
                            	  3077: *-----------------------------------------------------------
                            	  3078: * OPCODE : LINKS
                            	  3079: *-----------------------------------------------------------
                            	  3080: *-----------------------------------------------------------
                            	  3081: op_LINKS:
                            	  3082: 
02:00001EEC 207C11223344    	  3083:             move.l #$11223344,a0
02:00001EF2 203C11223344    	  3084:             move.l #$11223344,d0
02:00001EF8 4E500000        	  3085:             link a0,#$0
02:00001EFC 0C9711223344    	  3086:             cmpi.l #$11223344,(a7)
                            	  3087: 
02:00001F02 4E58            	  3088:             unlk a0
02:00001F04 B1C0            	  3089:             cmp.l d0,a0
02:00001F06 66FE            	  3090:             bne.s *                   * branch if Z set
                            	  3091: 
02:00001F08 4E75            	  3092:             rts
                            	  3093: 
                            	  3094: *-----------------------------------------------------------
                            	  3095: *-----------------------------------------------------------
                            	  3096: * OPCODE : MOVE_USP
                            	  3097: *-----------------------------------------------------------
                            	  3098: *-----------------------------------------------------------
                            	  3099: op_MOVE_USP:
                            	  3100: 
02:00001F0A 207C11223344    	  3101:             move.l #$11223344,a0
02:00001F10 4E60            	  3102:             move a0,USP
02:00001F12 4E69            	  3103:             move USP,a1
02:00001F14 B3C8            	  3104:             cmp.l a0,a1
02:00001F16 66FE            	  3105:             bne.s *                   * branch if Z set
                            	  3106: 
02:00001F18 4E75            	  3107:             rts
                            	  3108: 
                            	  3109: 
                            	  3110: *-----------------------------------------------------------
                            	  3111: *-----------------------------------------------------------
                            	  3112: * OPCODE : CHK
                            	  3113: *-----------------------------------------------------------
                            	  3114: *-----------------------------------------------------------
                            	  3115: op_CHK:
02:00001F1A 303C1122        	  3116:             move.w #$1122,d0
02:00001F1E 323C1122        	  3117:             move.w #$1122,d1
02:00001F22 4380            	  3118:             chk d0,d1
                            	  3119: 
02:00001F24 4E71            	  3120:             nop
02:00001F26 4E71            	  3121:             nop
                            	  3122: 
02:00001F28 323C1122        	  3123:             move.w #$1122,d1
02:00001F2C 43BC1122        	  3124:             chk #$1122,d1
                            	  3125: 
02:00001F30 323C1122        	  3126:             move.w #$1122,d1
02:00001F34 43BC007A        	  3127:             chk #00122,d1
02:00001F38 BCBCEEEE0006    	  3128:             cmp.l #$EEEE0006,d6
02:00001F3E 66FE            	  3129:             bne.s *                   * branch if Z set
                            	  3130: 
02:00001F40 303C1122        	  3131:             move.w #$1122,d0
02:00001F44 323C8000        	  3132:             move.w #$8000,d1
02:00001F48 4380            	  3133:             chk d0,d1
02:00001F4A BCBCEEEE0006    	  3134:             cmp.l #$EEEE0006,d6
02:00001F50 66FE            	  3135:             bne.s *                   * branch if Z set
                            	  3136: 
02:00001F52 4E75            	  3137:             rts
                            	  3138: 
                            	  3139: 
                            	  3140: *-----------------------------------------------------------
                            	  3141: *-----------------------------------------------------------
                            	  3142: * OPCODE : NEGS
                            	  3143: *-----------------------------------------------------------
                            	  3144: *-----------------------------------------------------------
                            	  3145: op_NEGS:
                            	  3146: 
                            	  3147: *     NOT - BYTE
02:00001F54 307C0100        	  3148:             move.l #$00000100,a0
02:00001F58 7000            	  3149:             moveq  #$00000000,d0
02:00001F5A 4600            	  3150:             not.b d0
02:00001F5C 6AFE            	  3151:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F5E 67FE            	  3152:             beq.s *                   * Check Z Flag  beq/bne
02:00001F60 4600            	  3153:             not.b d0
02:00001F62 6BFE            	  3154:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F64 66FE            	  3155:             bne.s *                   * Check Z Flag  beq/bne
02:00001F66 4A00            	  3156:             cmpi.b #$00,d0
02:00001F68 66FE            	  3157:             bne.s *                   * Check Z Flag  beq/bne
02:00001F6A 10BC0080        	  3158:             move.b #$80,(a0)
02:00001F6E 4610            	  3159:             not.b (a0)
02:00001F70 6BFE            	  3160:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F72 67FE            	  3161:             beq.s *                   * Check Z Flag  beq/bne
02:00001F74 4610            	  3162:             not.b (a0)
02:00001F76 6AFE            	  3163:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F78 67FE            	  3164:             beq.s *                   * Check Z Flag  beq/bne
02:00001F7A 0C100080        	  3165:             cmpi.b #$80,(a0)
02:00001F7E 66FE            	  3166:             bne.s *                   * Check Z Flag  beq/bne
                            	  3167: 
                            	  3168: *     NOT - WORD
02:00001F80 307C0100        	  3169:             move.l #$00000100,a0
02:00001F84 7000            	  3170:             moveq  #$00000000,d0
02:00001F86 4640            	  3171:             not.w d0
02:00001F88 6AFE            	  3172:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F8A 67FE            	  3173:             beq.s *                   * Check Z Flag  beq/bne
02:00001F8C 4640            	  3174:             not.w d0
02:00001F8E 6BFE            	  3175:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001F90 66FE            	  3176:             bne.s *                   * Check Z Flag  beq/bne
02:00001F92 4A40            	  3177:             cmpi.w #$0000,d0
02:00001F94 66FE            	  3178:             bne.s *                   * Check Z Flag  beq/bne
02:00001F96 30BC5A5A        	  3179:             move.w #$5a5a,(a0)
02:00001F9A 4650            	  3180:             not.w (a0)
02:00001F9C 6AFE            	  3181:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001F9E 67FE            	  3182:             beq.s *                   * Check Z Flag  beq/bne
02:00001FA0 4650            	  3183:             not.w (a0)
02:00001FA2 6BFE            	  3184:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001FA4 67FE            	  3185:             beq.s *                   * Check Z Flag  beq/bne
02:00001FA6 0C505A5A        	  3186:             cmpi.w #$5a5a,(a0)
02:00001FAA 66FE            	  3187:             bne.s *                   * Check Z Flag  beq/bne
                            	  3188: 
                            	  3189: *     NOT - LONG
02:00001FAC 307C0100        	  3190:             move.l #$00000100,a0
02:00001FB0 7000            	  3191:             moveq  #$00000000,d0
02:00001FB2 4680            	  3192:             not.l d0
02:00001FB4 6AFE            	  3193:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001FB6 67FE            	  3194:             beq.s *                   * Check Z Flag  beq/bne
02:00001FB8 4680            	  3195:             not.l d0
02:00001FBA 6BFE            	  3196:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001FBC 66FE            	  3197:             bne.s *                   * Check Z Flag  beq/bne
02:00001FBE 4A80            	  3198:             cmpi.l #$00000000,d0
02:00001FC0 66FE            	  3199:             bne.s *                   * Check Z Flag  beq/bne
02:00001FC2 20BC5A5A1234    	  3200:             move.l #$5a5a1234,(a0)
02:00001FC8 4690            	  3201:             not.l (a0)
02:00001FCA 6AFE            	  3202:             bpl.s *                   * Check N Flag  bmi/bpl
02:00001FCC 67FE            	  3203:             beq.s *                   * Check Z Flag  beq/bne
02:00001FCE 4690            	  3204:             not.l (a0)
02:00001FD0 6BFE            	  3205:             bmi.s *                   * Check N Flag  bmi/bpl
02:00001FD2 67FE            	  3206:             beq.s *                   * Check Z Flag  beq/bne
02:00001FD4 0C905A5A1234    	  3207:             cmpi.l #$5a5a1234,(a0)
02:00001FDA 66FE            	  3208:             bne.s *                   * Check Z Flag  beq/bne
                            	  3209: 
                            	  3210: * -----
                            	  3211: 
                            	  3212: *     NEG - BYTE
02:00001FDC 307C0100        	  3213:             move.l #$00000100,a0
02:00001FE0 7000            	  3214:             moveq  #$00000000,d0
02:00001FE2 7240D241        	  3215:             move.l #$00000080,d1
02:00001FE6 4400            	  3216:             neg.b d0
02:00001FE8 6BFE            	  3217:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00001FEA 66FE            	  3218:             bne.s *                   * Check Z Flag  beq/bne 1
02:00001FEC 65FE            	  3219:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:00001FEE 69FE            	  3220:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00001FF0 4401            	  3221:             neg.b d1
02:00001FF2 6AFE            	  3222:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00001FF4 67FE            	  3223:             beq.s *                   * Check Z Flag  beq/bne 0
02:00001FF6 64FE            	  3224:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00001FF8 68FE            	  3225:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:00001FFA 0C010080        	  3226:             cmpi.b #$80,d1
02:00001FFE 66FE            	  3227:             bne.s *                   * Check Z Flag  beq/bne
02:00002000 10BC007F        	  3228:             move.b #$7F,(a0)
02:00002004 4410            	  3229:             neg.b (a0)
02:00002006 6AFE            	  3230:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002008 67FE            	  3231:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000200A 64FE            	  3232:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000200C 69FE            	  3233:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000200E 10BC00F5        	  3234:             move.b #$F5,(a0)
02:00002012 4410            	  3235:             neg.b (a0)
02:00002014 6BFE            	  3236:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002016 67FE            	  3237:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002018 64FE            	  3238:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000201A 69FE            	  3239:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000201C 0C10000B        	  3240:             cmpi.b #$0B,(a0)
02:00002020 66FE            	  3241:             bne.s *                   * Check Z Flag  beq/bne
                            	  3242: 
                            	  3243: * -----
                            	  3244: 
                            	  3245: *     NEG - WORD
02:00002022 307C0100        	  3246:             move.l #$00000100,a0
02:00002026 7000            	  3247:             moveq  #$00000000,d0
02:00002028 223C00008000    	  3248:             move.l #$00008000,d1
02:0000202E 4440            	  3249:             neg.w d0
02:00002030 6BFE            	  3250:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002032 66FE            	  3251:             bne.s *                   * Check Z Flag  beq/bne 1
02:00002034 65FE            	  3252:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:00002036 69FE            	  3253:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002038 4441            	  3254:             neg.w d1
02:0000203A 6AFE            	  3255:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:0000203C 67FE            	  3256:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000203E 64FE            	  3257:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002040 68FE            	  3258:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:00002042 0C418000        	  3259:             cmpi.w #$8000,d1
02:00002046 66FE            	  3260:             bne.s *                   * Check Z Flag  beq/bne
02:00002048 30BC7FFF        	  3261:             move.w #$7FFF,(a0)
02:0000204C 4450            	  3262:             neg.w (a0)
02:0000204E 6AFE            	  3263:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002050 67FE            	  3264:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002052 64FE            	  3265:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002054 69FE            	  3266:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002056 30BCF578        	  3267:             move.w #$F578,(a0)
02:0000205A 4450            	  3268:             neg.w (a0)
02:0000205C 6BFE            	  3269:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000205E 67FE            	  3270:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002060 64FE            	  3271:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002062 69FE            	  3272:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002064 0C500A88        	  3273:             cmpi.w #$0A88,(a0)
02:00002068 66FE            	  3274:             bne.s *                   * Check Z Flag  beq/bne
                            	  3275: 
                            	  3276: * -----
                            	  3277: 
                            	  3278: *     NEG - LONG
02:0000206A 307C0100        	  3279:             move.l #$00000100,a0
02:0000206E 7000            	  3280:             moveq  #$00000000,d0
02:00002070 223C80000000    	  3281:             move.l #$80000000,d1
02:00002076 4480            	  3282:             neg.l d0
02:00002078 6BFE            	  3283:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000207A 66FE            	  3284:             bne.s *                   * Check Z Flag  beq/bne 1
02:0000207C 65FE            	  3285:             bcs.s *                   * Check C Flag  bcc/bcs 1
02:0000207E 69FE            	  3286:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002080 4481            	  3287:             neg.l d1
02:00002082 6AFE            	  3288:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002084 67FE            	  3289:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002086 64FE            	  3290:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002088 68FE            	  3291:             bvc.s *                   * Check V Flag  bvc/bvs 0
02:0000208A 0C8180000000    	  3292:             cmpi.l #$80000000,d1
02:00002090 66FE            	  3293:             bne.s *                   * Check Z Flag  beq/bne
02:00002092 20BC7FFFFFFF    	  3294:             move.l #$7FFFFFFF,(a0)
02:00002098 4490            	  3295:             neg.l (a0)
02:0000209A 6AFE            	  3296:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:0000209C 67FE            	  3297:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000209E 64FE            	  3298:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020A0 69FE            	  3299:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020A2 20BCF5781234    	  3300:             move.l #$F5781234,(a0)
02:000020A8 4490            	  3301:             neg.l (a0)
02:000020AA 6BFE            	  3302:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000020AC 67FE            	  3303:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020AE 64FE            	  3304:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020B0 69FE            	  3305:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020B2 0C900A87EDCC    	  3306:             cmpi.l #$0A87EDCC,(a0)
02:000020B8 66FE            	  3307:             bne.s *                   * Check Z Flag  beq/bne
                            	  3308: 
                            	  3309: 
                            	  3310: * -----
                            	  3311: 
                            	  3312: *     NEGX - BYTE
02:000020BA 307C0100        	  3313:             move.l #$00000100,a0
02:000020BE 7000            	  3314:             moveq  #$00000000,d0
02:000020C0 7240D241        	  3315:             move.l #$00000080,d1
02:000020C4 003C0010        	  3316:             ori.b #$10,CCR        * Set X Flag
02:000020C8 4000            	  3317:             negx.b d0
02:000020CA 6AFE            	  3318:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:000020CC 67FE            	  3319:             beq.s *                   * Check Z Flag  beq/bne 1
02:000020CE 64FE            	  3320:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:000020D0 69FE            	  3321:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020D2 023C00EF        	  3322:             andi.b #$EF,CCR       * Clear X Flag
02:000020D6 4000            	  3323:             negx.b d0
02:000020D8 6BFE            	  3324:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000020DA 67FE            	  3325:             beq.s *                   * Check Z Flag  beq/bne 1
02:000020DC 64FE            	  3326:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:000020DE 69FE            	  3327:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000020E0 003C0010        	  3328:             ori.b #$10,CCR        * Set X Flag
02:000020E4 4001            	  3329:             negx.b d1
02:000020E6 6BFE            	  3330:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:000020E8 67FE            	  3331:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020EA 64FE            	  3332:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000020EC 69FE            	  3333:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:000020EE 0C01007F        	  3334:             cmpi.b #$7F,d1
02:000020F2 66FE            	  3335:             bne.s *                   * Check Z Flag  beq/bne
02:000020F4 023C00EF        	  3336:             andi.b #$EF,CCR       * Clear X Flag
02:000020F8 4001            	  3337:             negx.b d1
02:000020FA 6AFE            	  3338:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000020FC 67FE            	  3339:             beq.s *                   * Check Z Flag  beq/bne 0
02:000020FE 64FE            	  3340:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002100 69FE            	  3341:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:00002102 0C010081        	  3342:             cmpi.b #$81,d1
02:00002106 66FE            	  3343:             bne.s *                   * Check Z Flag  beq/bne
02:00002108 10BC007F        	  3344:             move.b #$7F,(a0)
02:0000210C 003C0010        	  3345:             ori.b #$10,CCR        * Set X Flag
02:00002110 4010            	  3346:             negx.b (a0)
02:00002112 6AFE            	  3347:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002114 67FE            	  3348:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002116 64FE            	  3349:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3350:             * I think overflow should happen here.
                            	  3351: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002118 10BC007F        	  3352:             move.b #$7F,(a0)
02:0000211C 023C00EF        	  3353:             andi.b #$EF,CCR       * Clear X Flag
02:00002120 4010            	  3354:             negx.b (a0)
02:00002122 6AFE            	  3355:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002124 67FE            	  3356:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002126 64FE            	  3357:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002128 69FE            	  3358:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000212A 10BC00F5        	  3359:             move.b #$F5,(a0)
02:0000212E 003C0010        	  3360:             ori.b #$10,CCR        * Set X Flag
02:00002132 4010            	  3361:             negx.b (a0)
02:00002134 6BFE            	  3362:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002136 67FE            	  3363:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002138 64FE            	  3364:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000213A 69FE            	  3365:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000213C 0C10000A        	  3366:             cmpi.b #$0A,(a0)
02:00002140 66FE            	  3367:             bne.s *                   * Check Z Flag  beq/bne
02:00002142 023C00EF        	  3368:             andi.b #$EF,CCR       * Clear X Flag
02:00002146 4010            	  3369:             negx.b (a0)
02:00002148 6AFE            	  3370:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:0000214A 67FE            	  3371:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000214C 64FE            	  3372:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000214E 69FE            	  3373:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002150 0C1000F6        	  3374:             cmpi.b #$F6,(a0)
02:00002154 66FE            	  3375:             bne.s *                   * Check Z Flag  beq/bne
                            	  3376: 
                            	  3377: 
                            	  3378: 
                            	  3379: * -----
                            	  3380: 
                            	  3381: *     NEGX - WORD
02:00002156 307C0100        	  3382:             move.l #$00000100,a0
02:0000215A 7000            	  3383:             moveq  #$00000000,d0
02:0000215C 223C00008000    	  3384:             move.l #$00008000,d1
02:00002162 003C0010        	  3385:             ori.b #$10,CCR        * Set X Flag
02:00002166 4040            	  3386:             negx.w d0
02:00002168 6AFE            	  3387:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:0000216A 67FE            	  3388:             beq.s *                   * Check Z Flag  beq/bne 1
02:0000216C 64FE            	  3389:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:0000216E 69FE            	  3390:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002170 023C00EF        	  3391:             andi.b #$EF,CCR       * Clear X Flag
02:00002174 4040            	  3392:             negx.w d0
02:00002176 6BFE            	  3393:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002178 67FE            	  3394:             beq.s *                   * Check Z Flag  beq/bne 1
02:0000217A 64FE            	  3395:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:0000217C 69FE            	  3396:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000217E 003C0010        	  3397:             ori.b #$10,CCR        * Set X Flag
02:00002182 4041            	  3398:             negx.w d1
02:00002184 6BFE            	  3399:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:00002186 67FE            	  3400:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002188 64FE            	  3401:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000218A 69FE            	  3402:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:0000218C 0C417FFF        	  3403:             cmpi.w #$7FFF,d1
02:00002190 66FE            	  3404:             bne.s *                   * Check Z Flag  beq/bne
02:00002192 023C00EF        	  3405:             andi.b #$EF,CCR       * Clear X Flag
02:00002196 4041            	  3406:             negx.w d1
02:00002198 6AFE            	  3407:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:0000219A 67FE            	  3408:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000219C 64FE            	  3409:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000219E 69FE            	  3410:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:000021A0 0C418001        	  3411:             cmpi.w #$8001,d1
02:000021A4 66FE            	  3412:             bne.s *                   * Check Z Flag  beq/bne
02:000021A6 30BC7FFF        	  3413:             move.w #$7FFF,(a0)
02:000021AA 003C0010        	  3414:             ori.b #$10,CCR        * Set X Flag
02:000021AE 4050            	  3415:             negx.w (a0)
02:000021B0 6AFE            	  3416:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:000021B2 67FE            	  3417:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021B4 64FE            	  3418:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3419: ***            
                            	  3420: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021B6 30BCF567        	  3421:             move.w #$F567,(a0)
02:000021BA 023C00EF        	  3422:             andi.b #$EF,CCR       * Clear X Flag
02:000021BE 4050            	  3423:             negx.w (a0)
02:000021C0 6BFE            	  3424:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:000021C2 67FE            	  3425:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021C4 64FE            	  3426:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000021C6 69FE            	  3427:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021C8 30BCF567        	  3428:             move.w #$F567,(a0)
02:000021CC 003C0010        	  3429:             ori.b #$10,CCR        * Set X Flag
02:000021D0 4050            	  3430:             negx.w (a0)
02:000021D2 6BFE            	  3431:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000021D4 67FE            	  3432:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021D6 64FE            	  3433:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000021D8 69FE            	  3434:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021DA 0C500A98        	  3435:             cmpi.w #$0A98,(a0)
02:000021DE 66FE            	  3436:             bne.s *                   * Check Z Flag  beq/bne
02:000021E0 023C00EF        	  3437:             andi.b #$EF,CCR       * Clear X Flag
02:000021E4 4050            	  3438:             negx.w (a0)
02:000021E6 6AFE            	  3439:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:000021E8 67FE            	  3440:             beq.s *                   * Check Z Flag  beq/bne 0
02:000021EA 64FE            	  3441:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:000021EC 69FE            	  3442:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:000021EE 0C50F568        	  3443:             cmpi.w #$F568,(a0)
02:000021F2 66FE            	  3444:             bne.s *                   * Check Z Flag  beq/bne
                            	  3445: 
                            	  3446: 
                            	  3447: * -----
                            	  3448: 
                            	  3449: *     NEGX - LONG
02:000021F4 307C0100        	  3450:             move.l #$00000100,a0
02:000021F8 7000            	  3451:             moveq  #$00000000,d0
02:000021FA 223C80000000    	  3452:             move.l #$80000000,d1
02:00002200 003C0010        	  3453:             ori.b #$10,CCR        * Set X Flag
02:00002204 4080            	  3454:             negx.l d0
02:00002206 6AFE            	  3455:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:00002208 67FE            	  3456:             beq.s *                   * Check Z Flag  beq/bne 1
02:0000220A 64FE            	  3457:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:0000220C 69FE            	  3458:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000220E 023C00EF        	  3459:             andi.b #$EF,CCR       * Clear X Flag
02:00002212 4080            	  3460:             negx.l d0
02:00002214 6BFE            	  3461:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:00002216 67FE            	  3462:             beq.s *                   * Check Z Flag  beq/bne 1
02:00002218 64FE            	  3463:             bcc.s *                   * Check C Flag  bcc/bcs 1
02:0000221A 69FE            	  3464:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000221C 003C0010        	  3465:             ori.b #$10,CCR        * Set X Flag
02:00002220 4081            	  3466:             negx.l d1
02:00002222 6BFE            	  3467:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:00002224 67FE            	  3468:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002226 64FE            	  3469:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002228 69FE            	  3470:             bvs.s *                   * Check V Flag  bvc/bvs 0
02:0000222A 0C817FFFFFFF    	  3471:             cmpi.l #$7FFFFFFF,d1
02:00002230 66FE            	  3472:             bne.s *                   * Check Z Flag  beq/bne
02:00002232 023C00EF        	  3473:             andi.b #$EF,CCR       * Clear X Flag
02:00002236 4081            	  3474:             negx.l d1
02:00002238 6AFE            	  3475:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:0000223A 67FE            	  3476:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000223C 64FE            	  3477:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3478: ****            
                            	  3479: *            bvs.s *                   * Check V Flag  bvc/bvs 0
02:0000223E 0C8180000001    	  3480:             cmpi.l #$80000001,d1
02:00002244 66FE            	  3481:             bne.s *                   * Check Z Flag  beq/bne
02:00002246 20BC00007FFF    	  3482:             move.l #$7FFF,(a0)
02:0000224C 003C0010        	  3483:             ori.b #$10,CCR        * Set X Flag
02:00002250 4090            	  3484:             negx.l (a0)
02:00002252 6AFE            	  3485:             bpl.s *                   * Check N Flag  bmi/bpl 1
02:00002254 67FE            	  3486:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002256 64FE            	  3487:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3488: ****            
                            	  3489: *            bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002258 20BCF5671234    	  3490:             move.l #$F5671234,(a0)
02:0000225E 023C00EF        	  3491:             andi.b #$EF,CCR       * Clear X Flag
02:00002262 4090            	  3492:             negx.l (a0)
02:00002264 6BFE            	  3493:             bmi.s *                   * Check N Flag  bmi/bpl 1
02:00002266 67FE            	  3494:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002268 64FE            	  3495:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000226A 69FE            	  3496:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:0000226C 20BCF5675678    	  3497:             move.l #$F5675678,(a0)
02:00002272 003C0010        	  3498:             ori.b #$10,CCR        * Set X Flag
02:00002276 4090            	  3499:             negx.l (a0)
02:00002278 6BFE            	  3500:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:0000227A 67FE            	  3501:             beq.s *                   * Check Z Flag  beq/bne 0
02:0000227C 64FE            	  3502:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:0000227E 69FE            	  3503:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002280 0C900A98A987    	  3504:             cmpi.l #$0A98A987,(a0)
02:00002286 66FE            	  3505:             bne.s *                   * Check Z Flag  beq/bne
02:00002288 023C00EF        	  3506:             andi.b #$EF,CCR       * Clear X Flag
02:0000228C 4090            	  3507:             negx.l (a0)
02:0000228E 6AFE            	  3508:             bpl.s *                   * Check N Flag  bmi/bpl 0
02:00002290 67FE            	  3509:             beq.s *                   * Check Z Flag  beq/bne 0
02:00002292 64FE            	  3510:             bcc.s *                   * Check C Flag  bcc/bcs 0
02:00002294 69FE            	  3511:             bvs.s *                   * Check V Flag  bvc/bvs 1
02:00002296 0C90F5675679    	  3512:             cmpi.l #$F5675679,(a0)
02:0000229C 66FE            	  3513:             bne.s *                   * Check Z Flag  beq/bne
                            	  3514: 
                            	  3515: 
                            	  3516: * -----
                            	  3517: 
                            	  3518: *     CLR - BYTE
02:0000229E 307C0100        	  3519:             move.l #$00000100,a0
02:000022A2 203C12345678    	  3520:             move.l #$12345678,d0
02:000022A8 223C12345678    	  3521:             move.l #$12345678,d1
02:000022AE 243C12345678    	  3522:             move.l #$12345678,d2
02:000022B4 283C12345600    	  3523:             move.l #$12345600,d4
02:000022BA 2A3C12340000    	  3524:             move.l #$12340000,d5
02:000022C0 7C00            	  3525:             moveq  #$00000000,d6
                            	  3526: 
02:000022C2 4200            	  3527:             clr.b d0
02:000022C4 66FE            	  3528:             bne.s *                   * Check Z Flag  beq/bne 0
02:000022C6 6BFE            	  3529:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000022C8 B880            	  3530:             cmp.l d0,d4
02:000022CA 66FE            	  3531:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3532: 
02:000022CC 4241            	  3533:             clr.w d1
02:000022CE 66FE            	  3534:             bne.s *                   * Check Z Flag  beq/bne 0
02:000022D0 6BFE            	  3535:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000022D2 BA81            	  3536:             cmp.l d1,d5
02:000022D4 66FE            	  3537:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3538: 
02:000022D6 7400            	  3539:             clr.l d2
02:000022D8 66FE            	  3540:             bne.s *                   * Check Z Flag  beq/bne 0
02:000022DA 6BFE            	  3541:             bmi.s *                   * Check N Flag  bmi/bpl 0
02:000022DC BC82            	  3542:             cmp.l d2,d6
02:000022DE 66FE            	  3543:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3544: 
02:000022E0 4E75            	  3545:             rts
                            	  3546: 
                            	  3547: 
                            	  3548: 
                            	  3549: *-----------------------------------------------------------
                            	  3550: *-----------------------------------------------------------
                            	  3551: * OPCODE : MOVEM
                            	  3552: *-----------------------------------------------------------
                            	  3553: *-----------------------------------------------------------
                            	  3554: op_MOVEM:
                            	  3555: 
                            	  3556: *     WORD  Registers --> Memory
02:000022E2 203C0000D0D0    	  3557:             move.l #$0000d0d0,d0
02:000022E8 223C0000D1D1    	  3558:             move.l #$0000d1d1,d1
02:000022EE 243C0000D2D2    	  3559:             move.l #$0000d2d2,d2
02:000022F4 263C0000D3D3    	  3560:             move.l #$0000d3d3,d3
02:000022FA 283C0000D4D4    	  3561:             move.l #$0000d4d4,d4
02:00002300 2A3C0000D5D5    	  3562:             move.l #$0000d5d5,d5
02:00002306 2C3C0000D6D6    	  3563:             move.l #$0000d6d6,d6
02:0000230C 2E3C0000D7D7    	  3564:             move.l #$0000d7d7,d7
02:00002312 307C0A0A        	  3565:             move.l #$00000a0a,a0
02:00002316 327C1A1A        	  3566:             move.l #$00001a1a,a1
02:0000231A 347C2A2A        	  3567:             move.l #$00002a2a,a2
02:0000231E 367C3A3A        	  3568:             move.l #$00003a3a,a3
02:00002322 387C4A4A        	  3569:             move.l #$00004a4a,a4
02:00002326 3A7C5A5A        	  3570:             move.l #$00005a5a,a5
02:0000232A 3C7C6A6A        	  3571:             move.l #$00006a6a,a6
                            	  3572: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3573: 
02:0000232E 48B8FFFF0100    	  3574:             movem.w D0-D7/A0-A7,$00000100
                            	  3575: 
02:00002334 307C0100        	  3576:             move.l #$00000100,a0
                            	  3577: 
02:00002338 B058            	  3578:             cmp.w (a0)+,d0
02:0000233A 66FE            	  3579:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000233C B258            	  3580:             cmp.w (a0)+,d1
02:0000233E 66FE            	  3581:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002340 B458            	  3582:             cmp.w (a0)+,d2
02:00002342 66FE            	  3583:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002344 B658            	  3584:             cmp.w (a0)+,d3
02:00002346 66FE            	  3585:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002348 B858            	  3586:             cmp.w (a0)+,d4
02:0000234A 66FE            	  3587:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000234C BA58            	  3588:             cmp.w (a0)+,d5
02:0000234E 66FE            	  3589:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002350 BC58            	  3590:             cmp.w (a0)+,d6
02:00002352 66FE            	  3591:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002354 BE58            	  3592:             cmp.w (a0)+,d7
02:00002356 66FE            	  3593:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3594: 
02:00002358 0C580A0A        	  3595:             cmpi.w #$0A0A,(a0)+    * Because we are using a0 as a pointer
02:0000235C 66FE            	  3596:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3597: 
02:0000235E B2D8            	  3598:             cmp.w (a0)+,a1
02:00002360 66FE            	  3599:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002362 B4D8            	  3600:             cmp.w (a0)+,a2
02:00002364 66FE            	  3601:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002366 B6D8            	  3602:             cmp.w (a0)+,a3
02:00002368 66FE            	  3603:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000236A B8D8            	  3604:             cmp.w (a0)+,a4
02:0000236C 66FE            	  3605:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000236E BAD8            	  3606:             cmp.w (a0)+,a5
02:00002370 66FE            	  3607:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002372 BCD8            	  3608:             cmp.w (a0)+,a6
02:00002374 66FE            	  3609:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3610: 
                            	  3611: 
                            	  3612: 
                            	  3613: 
                            	  3614: *     LONG  Registers --> Memory
02:00002376 203CD0D0D0D0    	  3615:             move.l #$d0d0d0d0,d0
02:0000237C 223CD1D1D1D1    	  3616:             move.l #$d1d1d1d1,d1
02:00002382 243CD2D2D2D2    	  3617:             move.l #$d2d2d2d2,d2
02:00002388 263CD3D3D3D3    	  3618:             move.l #$d3d3d3d3,d3
02:0000238E 283CD4D4D4D4    	  3619:             move.l #$d4d4d4d4,d4
02:00002394 2A3CD5D5D5D5    	  3620:             move.l #$d5d5d5d5,d5
02:0000239A 2C3CD6D6D6D6    	  3621:             move.l #$d6d6d6d6,d6
02:000023A0 2E3CD7D7D7D7    	  3622:             move.l #$d7d7d7d7,d7
02:000023A6 207C0A0A0A0A    	  3623:             move.l #$0a0a0a0a,a0
02:000023AC 227C1A1A1A1A    	  3624:             move.l #$1a1a1a1a,a1
02:000023B2 247C2A2A2A2A    	  3625:             move.l #$2a2a2a2a,a2
02:000023B8 267C3A3A3A3A    	  3626:             move.l #$3a3a3a3a,a3
02:000023BE 287C4A4A4A4A    	  3627:             move.l #$4a4a4a4a,a4
02:000023C4 2A7C5A5A5A5A    	  3628:             move.l #$5a5a5a5a,a5
02:000023CA 2C7C6A6A6A6A    	  3629:             move.l #$6a6a6a6a,a6
                            	  3630: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3631: 
                            	  3632: 
02:000023D0 48F8FFFF0120    	  3633:             movem.l D0-D7/A0-A7,$00000120
                            	  3634: 
02:000023D6 307C0120        	  3635:             move.l #$00000120,a0
                            	  3636: 
02:000023DA B098            	  3637:             cmp.l (a0)+,d0
02:000023DC 66FE            	  3638:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023DE B298            	  3639:             cmp.l (a0)+,d1
02:000023E0 66FE            	  3640:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023E2 B498            	  3641:             cmp.l (a0)+,d2
02:000023E4 66FE            	  3642:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023E6 B698            	  3643:             cmp.l (a0)+,d3
02:000023E8 66FE            	  3644:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023EA B898            	  3645:             cmp.l (a0)+,d4
02:000023EC 66FE            	  3646:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023EE BA98            	  3647:             cmp.l (a0)+,d5
02:000023F0 66FE            	  3648:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023F2 BC98            	  3649:             cmp.l (a0)+,d6
02:000023F4 66FE            	  3650:             bne.s *                   * Check Z Flag  beq/bne 0
02:000023F6 BE98            	  3651:             cmp.l (a0)+,d7
02:000023F8 66FE            	  3652:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3653: 
02:000023FA 0C980A0A0A0A    	  3654:             cmpi.l #$0A0A0A0A,(a0)+    * Because we are using a0 as a pointer
02:00002400 66FE            	  3655:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3656: 
02:00002402 B3D8            	  3657:             cmp.l (a0)+,a1
02:00002404 66FE            	  3658:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002406 B5D8            	  3659:             cmp.l (a0)+,a2
02:00002408 66FE            	  3660:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000240A B7D8            	  3661:             cmp.l (a0)+,a3
02:0000240C 66FE            	  3662:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000240E B9D8            	  3663:             cmp.l (a0)+,a4
02:00002410 66FE            	  3664:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002412 BBD8            	  3665:             cmp.l (a0)+,a5
02:00002414 66FE            	  3666:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002416 BDD8            	  3667:             cmp.l (a0)+,a6
02:00002418 66FE            	  3668:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3669: *      ----
                            	  3670: 
                            	  3671: 
                            	  3672: *     WORD  Registers --> Memory  -(An) EA Mode
02:0000241A 203C0000D0D0    	  3673:             move.l #$0000d0d0,d0
02:00002420 223C0000D1D1    	  3674:             move.l #$0000d1d1,d1
02:00002426 243C0000D2D2    	  3675:             move.l #$0000d2d2,d2
02:0000242C 263C0000D3D3    	  3676:             move.l #$0000d3d3,d3
02:00002432 283C0000D4D4    	  3677:             move.l #$0000d4d4,d4
02:00002438 2A3C0000D5D5    	  3678:             move.l #$0000d5d5,d5
02:0000243E 2C3C0000D6D6    	  3679:             move.l #$0000d6d6,d6
02:00002444 2E3C0000D7D7    	  3680:             move.l #$0000d7d7,d7
02:0000244A 307C0A0A        	  3681:             move.l #$00000a0a,a0
02:0000244E 327C1A1A        	  3682:             move.l #$00001a1a,a1
02:00002452 347C2A2A        	  3683:             move.l #$00002a2a,a2
02:00002456 367C3A3A        	  3684:             move.l #$00003a3a,a3
02:0000245A 387C4A4A        	  3685:             move.l #$00004a4a,a4
02:0000245E 3A7C5A5A        	  3686:             move.l #$00005a5a,a5
02:00002462 3C7C6A6A        	  3687:             move.l #$00006a6a,a6
                            	  3688: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3689: 
02:00002466 307C01A0        	  3690:             move.l #$000001A0,a0
02:0000246A 48A0FFFF        	  3691:             movem.w D0-D7/A0-A7,-(a0)
                            	  3692: 
02:0000246E 307C019E        	  3693:             move.l #$0000019E,a0
                            	  3694: 
02:00002472 BCE0            	  3695:             cmp.w -(a0),a6
02:00002474 66FE            	  3696:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002476 BAE0            	  3697:             cmp.w -(a0),a5
02:00002478 66FE            	  3698:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000247A B8E0            	  3699:             cmp.w -(a0),a4
02:0000247C 66FE            	  3700:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000247E B6E0            	  3701:             cmp.w -(a0),a3
02:00002480 66FE            	  3702:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002482 B4E0            	  3703:             cmp.w -(a0),a2
02:00002484 66FE            	  3704:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002486 B2E0            	  3705:             cmp.w -(a0),a1
02:00002488 66FE            	  3706:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000248A B0E0            	  3707:             cmp.w -(a0),a0
                            	  3708: *            bne.s *                   * Check Z Flag  beq/bne 0
02:0000248C BE60            	  3709:             cmp.w -(a0),d7
02:0000248E 66FE            	  3710:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002490 BC60            	  3711:             cmp.w -(a0),d6
02:00002492 66FE            	  3712:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002494 BA60            	  3713:             cmp.w -(a0),d5
02:00002496 66FE            	  3714:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002498 B860            	  3715:             cmp.w -(a0),d4
02:0000249A 66FE            	  3716:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000249C B660            	  3717:             cmp.w -(a0),d3
02:0000249E 66FE            	  3718:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024A0 B460            	  3719:             cmp.w -(a0),d2
02:000024A2 66FE            	  3720:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024A4 B260            	  3721:             cmp.w -(a0),d1
02:000024A6 66FE            	  3722:             bne.s *                   * Check Z Flag  beq/bne 0
02:000024A8 B060            	  3723:             cmp.w -(a0),d0
02:000024AA 66FE            	  3724:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3725: 
                            	  3726: 
                            	  3727: 
                            	  3728: 
                            	  3729: *     LONG  Registers --> Memory   -(An) EA Mode
02:000024AC 203CD0D0D0D0    	  3730:             move.l #$d0d0d0d0,d0
02:000024B2 223CD1D1D1D1    	  3731:             move.l #$d1d1d1d1,d1
02:000024B8 243CD2D2D2D2    	  3732:             move.l #$d2d2d2d2,d2
02:000024BE 263CD3D3D3D3    	  3733:             move.l #$d3d3d3d3,d3
02:000024C4 283CD4D4D4D4    	  3734:             move.l #$d4d4d4d4,d4
02:000024CA 2A3CD5D5D5D5    	  3735:             move.l #$d5d5d5d5,d5
02:000024D0 2C3CD6D6D6D6    	  3736:             move.l #$d6d6d6d6,d6
02:000024D6 2E3CD7D7D7D7    	  3737:             move.l #$d7d7d7d7,d7
02:000024DC 207C0A0A0A0A    	  3738:             move.l #$0a0a0a0a,a0
02:000024E2 227C1A1A1A1A    	  3739:             move.l #$1a1a1a1a,a1
02:000024E8 247C2A2A2A2A    	  3740:             move.l #$2a2a2a2a,a2
02:000024EE 267C3A3A3A3A    	  3741:             move.l #$3a3a3a3a,a3
02:000024F4 287C4A4A4A4A    	  3742:             move.l #$4a4a4a4a,a4
02:000024FA 2A7C5A5A5A5A    	  3743:             move.l #$5a5a5a5a,a5
02:00002500 2C7C6A6A6A6A    	  3744:             move.l #$6a6a6a6a,a6
                            	  3745: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3746: 
                            	  3747: 
02:00002506 307C01A0        	  3748:             move.l #$000001A0,a0
02:0000250A 48E0FFFF        	  3749:             movem.l D0-D7/A0-A7,-(a0)
                            	  3750: 
02:0000250E 307C019C        	  3751:             move.l #$0000019C,a0
                            	  3752: 
02:00002512 BDE0            	  3753:             cmp.l -(a0),a6
02:00002514 66FE            	  3754:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002516 BBE0            	  3755:             cmp.l -(a0),a5
02:00002518 66FE            	  3756:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000251A B9E0            	  3757:             cmp.l -(a0),a4
02:0000251C 66FE            	  3758:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000251E B7E0            	  3759:             cmp.l -(a0),a3
02:00002520 66FE            	  3760:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002522 B5E0            	  3761:             cmp.l -(a0),a2
02:00002524 66FE            	  3762:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002526 B3E0            	  3763:             cmp.l -(a0),a1
02:00002528 66FE            	  3764:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000252A B1E0            	  3765:             cmp.l -(a0),a0
                            	  3766: *            bne.s *                   * Check Z Flag  beq/bne 0
02:0000252C BEA0            	  3767:             cmp.l -(a0),d7
02:0000252E 66FE            	  3768:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002530 BCA0            	  3769:             cmp.l -(a0),d6
02:00002532 66FE            	  3770:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002534 BAA0            	  3771:             cmp.l -(a0),d5
02:00002536 66FE            	  3772:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002538 B8A0            	  3773:             cmp.l -(a0),d4
02:0000253A 66FE            	  3774:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000253C B6A0            	  3775:             cmp.l -(a0),d3
02:0000253E 66FE            	  3776:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002540 B4A0            	  3777:             cmp.l -(a0),d2
02:00002542 66FE            	  3778:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002544 B2A0            	  3779:             cmp.l -(a0),d1
02:00002546 66FE            	  3780:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002548 B0A0            	  3781:             cmp.l -(a0),d0
02:0000254A 66FE            	  3782:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3783: 
                            	  3784: 
                            	  3785: 
                            	  3786: *     ----
                            	  3787: 
                            	  3788: *     WORD - Memory --> Registers
02:0000254C 7000            	  3789:             moveq  #$00000000,d0
02:0000254E 7200            	  3790:             moveq  #$00000000,d1
02:00002550 7400            	  3791:             moveq  #$00000000,d2
02:00002552 7600            	  3792:             moveq  #$00000000,d3
02:00002554 7800            	  3793:             moveq  #$00000000,d4
02:00002556 7A00            	  3794:             moveq  #$00000000,d5
02:00002558 7C00            	  3795:             moveq  #$00000000,d6
02:0000255A 7E00            	  3796:             moveq  #$00000000,d7
02:0000255C 91C8            	  3797:             move.l #$00000000,a0
02:0000255E 93C9            	  3798:             move.l #$00000000,a1
02:00002560 95CA            	  3799:             move.l #$00000000,a2
02:00002562 97CB            	  3800:             move.l #$00000000,a3
02:00002564 99CC            	  3801:             move.l #$00000000,a4
02:00002566 9BCD            	  3802:             move.l #$00000000,a5
02:00002568 9DCE            	  3803:             move.l #$00000000,a6
                            	  3804: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3805: 
02:0000256A 4CB82A550100    	  3806:             movem.w $00000100,D0/D2/D4/D6/A1/A3/A5
                            	  3807: 
02:00002570 B0BCFFFFD0D0    	  3808:             cmp.l #$FFFFD0D0,d0
02:00002576 66FE            	  3809:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002578 B4BCFFFFD1D1    	  3810:             cmp.l #$FFFFD1D1,d2
02:0000257E 66FE            	  3811:             bne.s *                  * Check Z Flag  beq/bne 0
02:00002580 B8BCFFFFD2D2    	  3812:             cmp.l #$FFFFD2D2,d4
02:00002586 66FE            	  3813:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002588 BCBCFFFFD3D3    	  3814:             cmp.l #$FFFFD3D3,d6
02:0000258E 66FE            	  3815:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002590 B2FCD4D4        	  3816:             cmp.l #$FFFFD4D4,a1
02:00002594 66FE            	  3817:             bne.s *                   * Check Z Flag  beq/bne 0
02:00002596 B6FCD5D5        	  3818:             cmp.l #$FFFFD5D5,a3
02:0000259A 66FE            	  3819:             bne.s *                   * Check Z Flag  beq/bne 0
02:0000259C BAFCD6D6        	  3820:             cmp.l #$FFFFD6D6,a5
02:000025A0 66FE            	  3821:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3822: 
                            	  3823: 
                            	  3824: *     LONG - Memory --> Registers
02:000025A2 7000            	  3825:             moveq  #$00000000,d0
02:000025A4 7200            	  3826:             moveq  #$00000000,d1
02:000025A6 7400            	  3827:             moveq  #$00000000,d2
02:000025A8 7600            	  3828:             moveq  #$00000000,d3
02:000025AA 7800            	  3829:             moveq  #$00000000,d4
02:000025AC 7A00            	  3830:             moveq  #$00000000,d5
02:000025AE 7C00            	  3831:             moveq  #$00000000,d6
02:000025B0 7E00            	  3832:             moveq  #$00000000,d7
02:000025B2 91C8            	  3833:             move.l #$00000000,a0
02:000025B4 93C9            	  3834:             move.l #$00000000,a1
02:000025B6 95CA            	  3835:             move.l #$00000000,a2
02:000025B8 97CB            	  3836:             move.l #$00000000,a3
02:000025BA 99CC            	  3837:             move.l #$00000000,a4
02:000025BC 9BCD            	  3838:             move.l #$00000000,a5
02:000025BE 9DCE            	  3839:             move.l #$00000000,a6
                            	  3840: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3841: 
02:000025C0 4CF82A550120    	  3842:             movem.l $00000120,D0/D2/D4/D6/A1/A3/A5
                            	  3843: 
02:000025C6 B0BCD0D0D0D0    	  3844:             cmp.l #$D0D0D0D0,d0
02:000025CC 66FE            	  3845:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025CE B4BCD1D1D1D1    	  3846:             cmp.l #$D1D1D1D1,d2
02:000025D4 66FE            	  3847:             bne.s *                  * Check Z Flag  beq/bne 0
02:000025D6 B8BCD2D2D2D2    	  3848:             cmp.l #$D2D2D2D2,d4
02:000025DC 66FE            	  3849:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025DE BCBCD3D3D3D3    	  3850:             cmp.l #$D3D3D3D3,d6
02:000025E4 66FE            	  3851:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025E6 B3FCD4D4D4D4    	  3852:             cmp.l #$D4D4D4D4,a1
02:000025EC 66FE            	  3853:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025EE B7FCD5D5D5D5    	  3854:             cmp.l #$D5D5D5D5,a3
02:000025F4 66FE            	  3855:             bne.s *                   * Check Z Flag  beq/bne 0
02:000025F6 BBFCD6D6D6D6    	  3856:             cmp.l #$D6D6D6D6,a5
02:000025FC 66FE            	  3857:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3858: 
02:000025FE 4E75            	  3859:             rts
                            	  3860: 
                            	  3861: 
                            	  3862: *-----------------------------------------------------------
                            	  3863: *-----------------------------------------------------------
                            	  3864: * OPCODE : ABCD
                            	  3865: *-----------------------------------------------------------
                            	  3866: *-----------------------------------------------------------
                            	  3867: op_ABCD:
                            	  3868: 
                            	  3869: *     Test with X Flag CLEARED
02:00002600 307C0110        	  3870:                 move.l #$00000110,a0 * Address pointer-X
02:00002604 327C0120        	  3871:                 move.l #$00000120,a1 * Address pointer-Y
02:00002608 7000            	  3872:                 moveq  #$00000000,d0 * BCD byte-X
02:0000260A 7200            	  3873:                 moveq  #$00000000,d1 * BCD byte-Y
02:0000260C 7400            	  3874:                 moveq  #$00000000,d2
02:0000260E 7600            	  3875:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:00002610 7800            	  3876:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:00002612 7A00            	  3877:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:00002614 2C3C00000099    	  3878:                 move.l #$00000099,d6 * Inner loop counter
02:0000261A 2E3C00000099    	  3879:                 move.l #$00000099,d7 * Outer loop counter
                            	  3880: 
02:00002620 2007            	  3881: ABCD_OUTER1:    move.l d7,d0
02:00002622 2206            	  3882: ABCD_INNER1:    move.l d6,d1
02:00002624 023C00EF        	  3883:                 andi.b #$EF,CCR     * Clear X Flag
02:00002628 307C0110        	  3884:                 move.l #$00000110,a0 * Address pointer-X
02:0000262C 327C0120        	  3885:                 move.l #$00000120,a1 * Address pointer-Y
02:00002630 1140FFFF        	  3886:                 move.b d0,-1(a0)
02:00002634 1341FFFF        	  3887:                 move.b d1,-1(a1)
                            	  3888: 
02:00002638 C300            	  3889:                 abcd d0,d1
02:0000263A 6402            	  3890:                 bcc.s ABCD_NO_C1          * Check C Flag  bcc/bcs 0
02:0000263C 5284            	  3891:                 add.l #1,d4
02:0000263E DA81            	  3892: ABCD_NO_C1:     add.l d1,d5
                            	  3893: 
02:00002640 C308            	  3894:                 abcd -(a0),-(a1)
02:00002642 6402            	  3895:                 bcc.s ABCD_NO_C2          * Check C Flag  bcc/bcs 0
02:00002644 5284            	  3896:                 add.l #1,d4
02:00002646 D611            	  3897: ABCD_NO_C2:     add.b (a1),d3
                            	  3898: 
                            	  3899: 
02:00002648 51CEFFD8        	  3900:                 dbf d6,ABCD_INNER1
02:0000264C 2C3C00000099    	  3901:                 move.l #$00000099,d6
02:00002652 51CFFFCC        	  3902:                 dbf d7,ABCD_OUTER1
02:00002656 0C8400005AFC    	  3903:                 cmpi.l #$00005AFC,d4  * Check the cumulative results
02:0000265C 66FE            	  3904:                 bne.s *
02:0000265E 0C85001C9A34    	  3905:                 cmpi.l #$001C9A34,d5
02:00002664 66FE            	  3906:                 bne.s *
02:00002666 0C8300000034    	  3907:                 cmpi.l #$00000034,d3
02:0000266C 66FE            	  3908:                 bne.s *
                            	  3909: 
                            	  3910: *     Test with X Flag SET
02:0000266E 307C0110        	  3911:                 move.l #$00000110,a0 * Address pointer-X
02:00002672 327C0120        	  3912:                 move.l #$00000120,a1 * Address pointer-Y
02:00002676 7000            	  3913:                 moveq  #$00000000,d0 * BCD byte-X
02:00002678 7200            	  3914:                 moveq  #$00000000,d1 * BCD byte-Y
02:0000267A 7400            	  3915:                 moveq  #$00000000,d2
02:0000267C 7600            	  3916:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:0000267E 7800            	  3917:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:00002680 7A00            	  3918:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:00002682 2C3C00000099    	  3919:                 move.l #$00000099,d6 * Inner loop counter
02:00002688 2E3C00000099    	  3920:                 move.l #$00000099,d7 * Outer loop counter
                            	  3921: 
02:0000268E 2007            	  3922: ABCD_OUTER2:    move.l d7,d0
02:00002690 2206            	  3923: ABCD_INNER2:    move.l d6,d1
02:00002692 003C0010        	  3924:                 ori.b #$10,CCR      * Set X Flag
02:00002696 307C0110        	  3925:                 move.l #$00000110,a0 * Address pointer-X
02:0000269A 327C0120        	  3926:                 move.l #$00000120,a1 * Address pointer-Y
02:0000269E 1140FFFF        	  3927:                 move.b d0,-1(a0)
02:000026A2 1341FFFF        	  3928:                 move.b d1,-1(a1)
                            	  3929: 
02:000026A6 C300            	  3930:                 abcd d0,d1
02:000026A8 6402            	  3931:                 bcc.s ABCD_NO_C3          * Check C Flag  bcc/bcs 0
02:000026AA 5284            	  3932:                 add.l #1,d4
02:000026AC DA81            	  3933: ABCD_NO_C3:     add.l d1,d5
                            	  3934: 
02:000026AE C308            	  3935:                 abcd -(a0),-(a1)
02:000026B0 6402            	  3936:                 bcc.s ABCD_NO_C4          * Check C Flag  bcc/bcs 0
02:000026B2 5284            	  3937:                 add.l #1,d4
02:000026B4 D611            	  3938: ABCD_NO_C4:     add.b (a1),d3
                            	  3939: 
                            	  3940: 
02:000026B6 51CEFFD8        	  3941:                 dbf d6,ABCD_INNER2
02:000026BA 2C3C00000099    	  3942:                 move.l #$00000099,d6
02:000026C0 51CFFFCC        	  3943:                 dbf d7,ABCD_OUTER2
02:000026C4 0C8400005B60    	  3944:                 cmpi.l #$00005B60,d4  * Check the cumulative results
02:000026CA 66FE            	  3945:                 bne.s *
02:000026CC 0C85001CCFC8    	  3946:                 cmpi.l #$001CCFC8,d5
02:000026D2 66FE            	  3947:                 bne.s *
02:000026D4 0C8300000034    	  3948:                 cmpi.l #$00000034,d3
02:000026DA 66FE            	  3949:                 bne.s *
                            	  3950: 
                            	  3951: *             Quick check of Z Flag
02:000026DC 4200            	  3952:                 move.b #$00,d0
02:000026DE 4201            	  3953:                 move.b #$00,d1
02:000026E0 44FC0000        	  3954:                 move #$00,CCR              * Set Z flag to 0
02:000026E4 C101            	  3955:                 abcd d1,d0                  * Should NOT set Z Flag to 1
02:000026E6 67FE            	  3956:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3957: 
02:000026E8 103C0001        	  3958:                 move.b #$01,d0
02:000026EC 4201            	  3959:                 move.b #$00,d1
02:000026EE 44FC0004        	  3960:                 move #$04,CCR              * Set Z flag to 0
02:000026F2 C101            	  3961:                 abcd d1,d0                  * Should NOT set Z Flag to 1
02:000026F4 67FE            	  3962:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3963: 
02:000026F6 4E75            	  3964:                 rts
                            	  3965: 
                            	  3966: *-----------------------------------------------------------
                            	  3967: *-----------------------------------------------------------
                            	  3968: * OPCODE : SBCD
                            	  3969: *-----------------------------------------------------------
                            	  3970: *-----------------------------------------------------------
                            	  3971: op_SBCD:
                            	  3972: 
                            	  3973: *     Test with X Flag CLEARED
02:000026F8 307C0110        	  3974:                 move.l #$00000110,a0 * Address pointer-X
02:000026FC 327C0120        	  3975:                 move.l #$00000120,a1 * Address pointer-Y
02:00002700 7000            	  3976:                 moveq  #$00000000,d0 * BCD byte-X
02:00002702 7200            	  3977:                 moveq  #$00000000,d1 * BCD byte-Y
02:00002704 7400            	  3978:                 moveq  #$00000000,d2
02:00002706 7600            	  3979:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:00002708 7800            	  3980:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:0000270A 7A00            	  3981:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:0000270C 2C3C00000099    	  3982:                 move.l #$00000099,d6 * Inner loop counter
02:00002712 2E3C00000099    	  3983:                 move.l #$00000099,d7 * Outer loop counter
                            	  3984: 
02:00002718 2007            	  3985: SBCD_OUTER1:    move.l d7,d0
02:0000271A 2206            	  3986: SBCD_INNER1:    move.l d6,d1
02:0000271C 023C00EF        	  3987:                 andi.b #$EF,CCR     * Clear X Flag
02:00002720 307C0110        	  3988:                 move.l #$00000110,a0 * Address pointer-X
02:00002724 327C0120        	  3989:                 move.l #$00000120,a1 * Address pointer-Y
02:00002728 1140FFFF        	  3990:                 move.b d0,-1(a0)
02:0000272C 1341FFFF        	  3991:                 move.b d1,-1(a1)
                            	  3992: 
02:00002730 8300            	  3993:                 sbcd d0,d1
02:00002732 6402            	  3994:                 bcc.s SBCD_NO_C1          * Check C Flag  bcc/bcs 0
02:00002734 5284            	  3995:                 add.l #1,d4
02:00002736 DA81            	  3996: SBCD_NO_C1:     add.l d1,d5
                            	  3997: 
02:00002738 8308            	  3998:                 sbcd -(a0),-(a1)
02:0000273A 6402            	  3999:                 bcc.s SBCD_NO_C2          * Check C Flag  bcc/bcs 0
02:0000273C 5284            	  4000:                 add.l #1,d4
02:0000273E D611            	  4001: SBCD_NO_C2:     add.b (a1),d3
                            	  4002: 
                            	  4003: 
02:00002740 51CEFFD8        	  4004:                 dbf d6,SBCD_INNER1
02:00002744 2C3C00000099    	  4005:                 move.l #$00000099,d6
02:0000274A 51CFFFCC        	  4006:                 dbf d7,SBCD_OUTER1
02:0000274E 0C8400005C0A    	  4007:                 cmpi.l #$00005C0A,d4  * Check the cumulative results
02:00002754 66FE            	  4008:                 bne.s *
02:00002756 0C85001C459E    	  4009:                 cmpi.l #$001C459E,d5
02:0000275C 66FE            	  4010:                 bne.s *
02:0000275E 0C830000009E    	  4011:                 cmpi.l #$0000009E,d3
02:00002764 66FE            	  4012:                 bne.s *
                            	  4013: 
                            	  4014: *     Test with X Flag SET
02:00002766 307C0110        	  4015:                 move.l #$00000110,a0 * Address pointer-X
02:0000276A 327C0120        	  4016:                 move.l #$00000120,a1 * Address pointer-Y
02:0000276E 7000            	  4017:                 moveq  #$00000000,d0 * BCD byte-X
02:00002770 7200            	  4018:                 moveq  #$00000000,d1 * BCD byte-Y
02:00002772 7400            	  4019:                 moveq  #$00000000,d2
02:00002774 7600            	  4020:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
02:00002776 7800            	  4021:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:00002778 7A00            	  4022:                 moveq  #$00000000,d5 * Cumulative Register BCD results
02:0000277A 2C3C00000099    	  4023:                 move.l #$00000099,d6 * Inner loop counter
02:00002780 2E3C00000099    	  4024:                 move.l #$00000099,d7 * Outer loop counter
                            	  4025: 
02:00002786 2007            	  4026: SBCD_OUTER2:    move.l d7,d0
02:00002788 2206            	  4027: SBCD_INNER2:    move.l d6,d1
02:0000278A 003C0010        	  4028:                 ori.b #$10,CCR      * Set X Flag
02:0000278E 307C0110        	  4029:                 move.l #$00000110,a0 * Address pointer-X
02:00002792 327C0120        	  4030:                 move.l #$00000120,a1 * Address pointer-Y
02:00002796 1140FFFF        	  4031:                 move.b d0,-1(a0)
02:0000279A 1341FFFF        	  4032:                 move.b d1,-1(a1)
                            	  4033: 
02:0000279E 8300            	  4034:                 sbcd d0,d1
02:000027A0 6402            	  4035:                 bcc.s SBCD_NO_C3          * Check C Flag  bcc/bcs 0
02:000027A2 5284            	  4036:                 add.l #1,d4
02:000027A4 DA81            	  4037: SBCD_NO_C3:     add.l d1,d5
                            	  4038: 
02:000027A6 8308            	  4039:                 sbcd -(a0),-(a1)
02:000027A8 6402            	  4040:                 bcc.s SBCD_NO_C4          * Check C Flag  bcc/bcs 0
02:000027AA 5284            	  4041:                 add.l #1,d4
02:000027AC D611            	  4042: SBCD_NO_C4:     add.b (a1),d3
                            	  4043: 
02:000027AE 51CEFFD8        	  4044:                 dbf d6,SBCD_INNER2
02:000027B2 2C3C00000099    	  4045:                 move.l #$00000099,d6
02:000027B8 51CFFFCC        	  4046:                 dbf d7,SBCD_OUTER2
02:000027BC 0C8400005CA4    	  4047:                 cmpi.l #$00005CA4,d4  * Check the cumulative results
02:000027C2 66FE            	  4048:                 bne.s *
02:000027C4 0C85001C5C66    	  4049:                 cmpi.l #$001C5C66,d5
02:000027CA 66FE            	  4050:                 bne.s *
02:000027CC 0C830000009E    	  4051:                 cmpi.l #$0000009E,d3
02:000027D2 66FE            	  4052:                 bne.s *
                            	  4053: 
                            	  4054: 
                            	  4055: *             Quick check of Z Flag
02:000027D4 4200            	  4056:                 move.b #$00,d0
02:000027D6 4201            	  4057:                 move.b #$00,d1
02:000027D8 44FC0000        	  4058:                 move #$00,CCR              * Set Z flag to 0
02:000027DC 8101            	  4059:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
02:000027DE 67FE            	  4060:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4061: 
02:000027E0 103C0001        	  4062:                 move.b #$01,d0
02:000027E4 4201            	  4063:                 move.b #$00,d1
02:000027E6 44FC0004        	  4064:                 move #$04,CCR              * Set Z flag to 0
02:000027EA 8101            	  4065:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
02:000027EC 67FE            	  4066:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4067: 
02:000027EE 4E75            	  4068:                 rts
                            	  4069: 
                            	  4070: *-----------------------------------------------------------
                            	  4071: *-----------------------------------------------------------
                            	  4072: * OPCODE : NBCD
                            	  4073: *-----------------------------------------------------------
                            	  4074: *-----------------------------------------------------------
                            	  4075: op_NBCD:
                            	  4076: 
                            	  4077: *        NBCD to a  Register
                            	  4078: 
02:000027F0 7000            	  4079:                 moveq  #$00000000,d0 * BCD byte
02:000027F2 7200            	  4080:                 moveq  #$00000000,d1
02:000027F4 7400            	  4081:                 moveq  #$00000000,d2
02:000027F6 7600            	  4082:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
02:000027F8 7800            	  4083:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:000027FA 7A00            	  4084:                 moveq  #$00000000,d5 * Cumulative BCD results
02:000027FC 2C3C00000099    	  4085:                 move.l #$00000099,d6
02:00002802 2E3C00000099    	  4086:                 move.l #$00000099,d7 * Loop counter
                            	  4087: 
02:00002808 2007            	  4088: NBCD_LOOP:      move.l d7,d0
02:0000280A 44FC0004        	  4089:                 move #$04,CCR        * Set Z flag to 0
                            	  4090: 
02:0000280E 4800            	  4091:                 nbcd d0
                            	  4092: 
02:00002810 6402            	  4093:                 bcc.s NBCD_NO_C         * Check C Flag
02:00002812 5284            	  4094:                 add.l #1,d4
02:00002814 6602            	  4095: NBCD_NO_C:      bne.s NBCD_NO_Z         * Check Z Flag
02:00002816 5283            	  4096:                 add.l #1,d3
02:00002818 DA80            	  4097: NBCD_NO_Z:      add.l d0,d5         * Add results into d5
                            	  4098: 
02:0000281A 51CFFFEC        	  4099:                 dbf d7,NBCD_LOOP
                            	  4100: 
02:0000281E 0C8300000001    	  4101:                 cmpi.l #$00000001,d3  * Check the cumulative results
02:00002824 66FE            	  4102:                 bne.s *
02:00002826 0C8400000099    	  4103:                 cmpi.l #$00000099,d4
02:0000282C 66FE            	  4104:                 bne.s *
02:0000282E 0C8500002E3B    	  4105:                 cmpi.l #$00002E3B,d5
02:00002834 66FE            	  4106:                 bne.s *
                            	  4107: 
                            	  4108: 
                            	  4109: *        NBCD to a memory location
                            	  4110: 
02:00002836 7000            	  4111:                 moveq  #$00000000,d0 * BCD byte
02:00002838 7200            	  4112:                 moveq  #$00000000,d1
02:0000283A 7400            	  4113:                 moveq  #$00000000,d2
02:0000283C 7600            	  4114:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
02:0000283E 7800            	  4115:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
02:00002840 7A00            	  4116:                 moveq  #$00000000,d5 * Cumulative BCD results
02:00002842 2C3C00000099    	  4117:                 move.l #$00000099,d6
02:00002848 2E3C00000099    	  4118:                 move.l #$00000099,d7 * Loop counter
                            	  4119: 
02:0000284E 11C70100        	  4120: NBCD_LOOP1:     move.b d7,$00000100
02:00002852 44FC0004        	  4121:                 move #$04,CCR        * Set Z flag to 0
                            	  4122: 
02:00002856 48380100        	  4123:                 nbcd $00000100
02:0000285A 10380100        	  4124:                 move.b $00000100,d0
                            	  4125: 
02:0000285E 6402            	  4126:                 bcc.s NBCD_NO_C1        * Check C Flag
02:00002860 5284            	  4127:                 add.l #1,d4
02:00002862 6602            	  4128: NBCD_NO_C1:     bne.s NBCD_NO_Z1        * Check Z Flag
02:00002864 5283            	  4129:                 add.l #1,d3
02:00002866 DA80            	  4130: NBCD_NO_Z1:     add.l d0,d5         * Add results into d5
                            	  4131: 
02:00002868 51CFFFE4        	  4132:                 dbf d7,NBCD_LOOP1
                            	  4133: 
02:0000286C 0C8300000001    	  4134:                 cmpi.l #$00000001,d3  * Check the cumulative results
02:00002872 66FE            	  4135:                 bne.s *
02:00002874 4A84            	  4136:                 cmpi.l #$00000000,d4
02:00002876 66FE            	  4137:                 bne.s *
02:00002878 0C8500002E3B    	  4138:                 cmpi.l #$00002E3B,d5
02:0000287E 66FE            	  4139:                 bne.s *
                            	  4140: 
                            	  4141: 
02:00002880 4E75            	  4142:                 rts
                            	  4143: 
                            	  4144: 
                            	  4145: 
                            	  4146: *-----------------------------------------------------------
                            	  4147: *-----------------------------------------------------------
                            	  4148: * OPCODE : TRAPV
                            	  4149: *-----------------------------------------------------------
                            	  4150: *-----------------------------------------------------------
                            	  4151: op_TRAPV:
                            	  4152: 
                            	  4153: *     TRAPV will set d0 to 12345678 if V flag is set
                            	  4154: 
02:00002882 7000            	  4155:                 moveq  #$00000000,d0 * Clear d0
                            	  4156: 
02:00002884 44FC0000        	  4157:                 move #$00,CCR        * Clear V flag
02:00002888 4E76            	  4158:                 trapv
02:0000288A 4A80            	  4159:                 cmpi.l #$00000000,d0  * Check of d0 was updated (should not be_)
02:0000288C 66FE            	  4160:                 bne.s *
                            	  4161: 
02:0000288E 44FC0002        	  4162:                 move #$02,CCR        * Set V flag
02:00002892 4E76            	  4163:                 trapv
02:00002894 0C8012345678    	  4164:                 cmpi.l #$12345678,d0  * Check of d0 was updated (should not be_)
02:0000289A 66FE            	  4165:                 bne.s *
                            	  4166: 
                            	  4167: 
02:0000289C 4E75            	  4168:                 rts
                            	  4169: 
                            	  4170: 
                            	  4171: 
                            	  4172: *-----------------------------------------------------------
                            	  4173: *-----------------------------------------------------------
                            	  4174: * OPCODE : RTR
                            	  4175: *-----------------------------------------------------------
                            	  4176: *-----------------------------------------------------------
                            	  4177: 
                            	  4178: op_RTR:
                            	  4179: 
                            	  4180: *     Leventhal claims only 5 LSB's are popped from the stack to the CCR
                            	  4181: 
02:0000289E 41FA000A        	  4182:                 lea 		RTR_DONE,a0
02:000028A2 2F08            	  4183:                 move.l 	a0,-(a7)     * push destination PC to the stack
02:000028A4 3F3CFF15        	  4184:                 move.w 	#$FF15,-(a7)       * push flags=0xFFFF to the stack
02:000028A8 4E77            	  4185:                 rtr
                            	  4186: 
02:000028AA 40C0            	  4187: RTR_DONE:       move.w SR,d0
02:000028AC 0240001F        	  4188:                 andi.w #$1F,d0
02:000028B0 0C400015        	  4189:                 cmpi.w #$15,d0
02:000028B4 66FE            	  4190:                 bne.s *
                            	  4191: 
02:000028B6 4E75            	  4192:                 rts
                            	  4193: 
                            	  4194: 
02:000028B8 283C44444444    	  4195: BSR_FAR2:       move.l #$44444444,d4
02:000028BE 4E75            	  4196:                 rts
                            	  4197: 
                            	  4198: 
                            	  4199: *-----------------------------------------------------------
                            	  4200: *-----------------------------------------------------------
                            	  4201: * OPCODE : BCC
                            	  4202: *-----------------------------------------------------------
                            	  4203: *-----------------------------------------------------------
                            	  4204: 
02:000028C0 44FC0000        	  4205: op_BCC:         move #$00,CCR
02:000028C4 6202            	  4206:                 bhi.s BCC1            * Higher Than         C=0 AND Z=0
02:000028C6 60FE            	  4207:                 bra.s *
                            	  4208: 
02:000028C8 44FC0001        	  4209: BCC1:           move #$01,CCR
02:000028CC 63000004        	  4210:                 bls.w BCC2            * Lower or Same       C=1 OR Z=1
02:000028D0 60FE            	  4211:                 bra.s *
                            	  4212: 
02:000028D2 44FC0000        	  4213: BCC2:           move #$00,CCR
02:000028D6 6402            	  4214:                 bcc.s BCC3            * Carry Clear         C=0
02:000028D8 60FE            	  4215:                 bra.s *
                            	  4216: 
02:000028DA 44FC0001        	  4217: BCC3:           move #$01,CCR
02:000028DE 65000004        	  4218:                 bcs.w BCC4            * Carry Set           C=1
02:000028E2 60FE            	  4219:                 bra.s *
                            	  4220: 
02:000028E4 44FC0000        	  4221: BCC4:           move #$00,CCR
02:000028E8 6602            	  4222:                 bne.s BCC5            * Not Equal           Z=0
02:000028EA 60FE            	  4223:                 bra.s *
                            	  4224: 
02:000028EC 44FC0004        	  4225: BCC5:           move #$04,CCR
02:000028F0 67000004        	  4226:                 beq.w BCC6            * Equal               Z=1
02:000028F4 60FE            	  4227:                 bra.s *
                            	  4228: 
02:000028F6 44FC0000        	  4229: BCC6:           move #$00,CCR
02:000028FA 6802            	  4230:                 bvc.s BCC7            * V Clear             V=0
02:000028FC 60FE            	  4231:                 bra.s *
                            	  4232: 
02:000028FE 44FC0002        	  4233: BCC7:           move #$02,CCR
02:00002902 69000004        	  4234:                 bvs.w BCC8            * V Set               V=1
02:00002906 60FE            	  4235:                 bra.s *
                            	  4236: 
02:00002908 44FC0000        	  4237: BCC8:           move #$00,CCR
02:0000290C 6A02            	  4238:                 bpl.s BCC9            * Plus                N=0
02:0000290E 60FE            	  4239:                 bra.s *
                            	  4240: 
02:00002910 44FC0008        	  4241: BCC9:           move #$08,CCR
02:00002914 6B000004        	  4242:                 bmi.w BCC10           * Minus               N=1
02:00002918 60FE            	  4243:                 bra.s *
                            	  4244: 
02:0000291A 44FC0000        	  4245: BCC10:          move #$00,CCR
02:0000291E 6C02            	  4246:                 bge.s BCC11           * Greater or Equal    N=V
02:00002920 60FE            	  4247:                 bra.s *
                            	  4248: 
02:00002922 44FC0002        	  4249: BCC11:          move #$02,CCR
02:00002926 6D000004        	  4250:                 blt.w BCC12           * Less Than           N!=V
02:0000292A 60FE            	  4251:                 bra.s *
                            	  4252: 
02:0000292C 44FC000A        	  4253: BCC12:          move #$0A,CCR
02:00002930 6E02            	  4254:                 bgt.s BCC13           * Greater Than        N=V  AND Z=0
02:00002932 60FE            	  4255:                 bra.s *
                            	  4256: 
02:00002934 44FC0006        	  4257: BCC13:          move #$06,CCR
02:00002938 6F000004        	  4258:                 ble.w BCC14           * Less Than or Equal  N!=V AND Z=1
02:0000293C 60FE            	  4259:                 bra.s *
                            	  4260: 
                            	  4261: 
02:0000293E 4E75            	  4262: BCC14:          rts
                            	  4263: 
                            	  4264: 
                            	  4265: *-----------------------------------------------------------
                            	  4266: *-----------------------------------------------------------
                            	  4267: * OPCODE : DBCC
                            	  4268: *-----------------------------------------------------------
                            	  4269: *-----------------------------------------------------------
                            	  4270: 
02:00002940 7003            	  4271: op_DBCC:        moveq  #$00000003,d0    * Loop counter
02:00002942 7200            	  4272:                 moveq  #$00000000,d1    * Accumulator
02:00002944 44FC0000        	  4273:                 move #$00,CCR
                            	  4274: 
02:00002948 5201            	  4275: DBCC_LOOP1:     addi.b #$1,d1
02:0000294A 51C8FFFC        	  4276:                 dbf d0,DBCC_LOOP1
                            	  4277: 
02:0000294E 0C8100000004    	  4278:                 cmpi.l #$00000004,d1  * Check Accumulator results
02:00002954 66FE            	  4279:                 bne.s *
                            	  4280: 
02:00002956 5201            	  4281: DBCC_LOOP2:     addi.b #$1,d1
02:00002958 54C8FFFC        	  4282:                 dbcc d0,DBCC_LOOP2    * Dont loop
                            	  4283: 
02:0000295C 0C8100000005    	  4284:                 cmpi.l #$00000005,d1  * Check Accumulator results
02:00002962 66FE            	  4285:                 bne.s *
                            	  4286: 
02:00002964 4E75            	  4287:                 rts
                            	  4288: 
                            	  4289: 
                            	  4290: *-----------------------------------------------------------
                            	  4291: *-----------------------------------------------------------
                            	  4292: * OPCODE : SCC
                            	  4293: *-----------------------------------------------------------
                            	  4294: *-----------------------------------------------------------
                            	  4295: 
02:00002966 44FC0001        	  4296: op_SCC:         move #$01,CCR
02:0000296A 54F900010000    	  4297:                 scc $00010000                   * Clear the EA byte
02:00002970 4A3900010000    	  4298:                 cmpi.b #$00,$00010000
02:00002976 66FE            	  4299:                 bne.s *
                            	  4300: 
02:00002978 44FC0000        	  4301:                 move #$00,CCR
02:0000297C 54F900010000    	  4302:                 scc $00010000                   * Set the EA byte to 0xFF
02:00002982 0C3900FF00010000	  4303:                 cmpi.b #$FF,$00010000
02:0000298A 66FE            	  4304:                 bne.s *
                            	  4305: 
02:0000298C 54C0            	  4306: 								scc d0													* Test setting a data register
02:0000298E 0C0000FF        	  4307: 								cmpi.b #$FF,d0
02:00002992 66FE            	  4308: 								bne.s *
02:00002994 4E75            	  4309:                 rts
                            	  4310: 
                            	  4311: 
                            	  4312: 
                            	  4313: *-----------------------------------------------------------
                            	  4314: *-----------------------------------------------------------
                            	  4315: * OPCODE : ADDQ
                            	  4316: *-----------------------------------------------------------
                            	  4317: *-----------------------------------------------------------
                            	  4318: 
                            	  4319: op_ADDQ:
                            	  4320: 
                            	  4321: *     BYTE
02:00002996 203C000000FF    	  4322:                 move.l #$000000FF,d0    * Loop counter
02:0000299C 7200            	  4323:                 moveq  #$00000000,d1    * Flag results accumulator
02:0000299E 7400            	  4324:                 moveq  #$00000000,d2    * Data results accumulator
02:000029A0 7600            	  4325:                 moveq  #$00000000,d3
02:000029A2 7800            	  4326:                 moveq  #$00000000,d4
02:000029A4 7A00            	  4327:                 moveq  #$00000000,d5
02:000029A6 7C00            	  4328:                 moveq  #$00000000,d6
02:000029A8 7E00            	  4329:                 moveq  #$00000000,d7
                            	  4330: 
02:000029AA 5605            	  4331: ADDQ_LOOP1:     addq.b #3,d5
02:000029AC 40C6            	  4332:                 move.w SR,d6
02:000029AE 02860000001F    	  4333:                 andi.l #$1F,d6        * Isolate flags
02:000029B4 D286            	  4334:                 add.l d6,d1           * Copy flag results into accumulator
02:000029B6 D485            	  4335:                 add.l d5,d2           * Copy data results into data accumulator
02:000029B8 51C8FFF0        	  4336:                 dbf d0,ADDQ_LOOP1
                            	  4337: 
02:000029BC 0C810000043D    	  4338:                 cmpi.l #$0000043D,d1
02:000029C2 66FE            	  4339:                 bne.s *
02:000029C4 0C8200007F80    	  4340:                 cmpi.l #$00007F80,d2
02:000029CA 66FE            	  4341:                 bne.s *
                            	  4342: 
                            	  4343: 
                            	  4344: *     WORD
02:000029CC 203C000000FF    	  4345:                 move.l #$000000FF,d0    * Loop counter
02:000029D2 7200            	  4346:                 moveq  #$00000000,d1    * Flag results accumulator
02:000029D4 7400            	  4347:                 moveq  #$00000000,d2    * Data results accumulator
02:000029D6 7600            	  4348:                 moveq  #$00000000,d3
02:000029D8 7800            	  4349:                 moveq  #$00000000,d4
02:000029DA 2A3C0000FFF0    	  4350:                 move.l #$0000FFF0,d5
02:000029E0 7C00            	  4351:                 moveq  #$00000000,d6
02:000029E2 7E00            	  4352:                 moveq  #$00000000,d7
02:000029E4 307C0100        	  4353:                 move.l #$00000100,a0
                            	  4354: 
02:000029E8 5A45            	  4355: ADDQ_LOOP2:     addq.w #5,d5
02:000029EA 40C6            	  4356:                 move.w SR,d6
02:000029EC 02860000001F    	  4357:                 andi.l #$1F,d6        * Isolate flags
02:000029F2 D286            	  4358:                 add.l d6,d1           * Copy flag results into accumulator
02:000029F4 D485            	  4359:                 add.l d5,d2           * Copy data results into data accumulator
02:000029F6 51C8FFF0        	  4360:                 dbf d0,ADDQ_LOOP2
                            	  4361: 
02:000029FA 0C8100000029    	  4362:                 cmpi.l #$00000029,d1
02:00002A00 66FE            	  4363:                 bne.s *
02:00002A02 0C8200057280    	  4364:                 cmpi.l #$00057280,d2
02:00002A08 66FE            	  4365:                 bne.s *
                            	  4366: 
                            	  4367: 
                            	  4368: *     LONG
02:00002A0A 203C000000FF    	  4369:                 move.l #$000000FF,d0    * Loop counter
02:00002A10 7200            	  4370:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A12 7400            	  4371:                 moveq  #$00000000,d2    * Data results accumulator
02:00002A14 7600            	  4372:                 moveq  #$00000000,d3
02:00002A16 7800            	  4373:                 moveq  #$00000000,d4
02:00002A18 7AF0            	  4374:                 move.l #$FFFFFFF0,d5
02:00002A1A 7C00            	  4375:                 moveq  #$00000000,d6
02:00002A1C 7E00            	  4376:                 moveq  #$00000000,d7
                            	  4377: 
02:00002A1E 5285            	  4378: ADDQ_LOOP3:     addq.l #1,d5
02:00002A20 40C6            	  4379:                 move.w SR,d6
02:00002A22 02860000001F    	  4380:                 andi.l #$1F,d6        * Isolate flags
02:00002A28 D286            	  4381:                 add.l d6,d1           * Copy flag results into accumulator
02:00002A2A D485            	  4382:                 add.l d5,d2           * Copy data results into data accumulator
02:00002A2C 51C8FFF0        	  4383:                 dbf d0,ADDQ_LOOP3
                            	  4384: 
02:00002A30 0C810000008D    	  4385:                 cmpi.l #$0000008D,d1
02:00002A36 66FE            	  4386:                 bne.s *
02:00002A38 0C8200007080    	  4387:                 cmpi.l #$00007080,d2
02:00002A3E 66FE            	  4388:                 bne.s *
                            	  4389: 
                            	  4390: *     Check that Flags are not updated for Address registers
02:00002A40 207C0000FFFF    	  4391:                 move.l #$0000FFFF,a0
02:00002A46 44FC0000        	  4392:                 move #$00,CCR         * Clear flags
02:00002A4A 5E48            	  4393:                 addq.w #$7,a0
02:00002A4C 65FE            	  4394:                 bcs.s *
                            	  4395: 
02:00002A4E 4E75            	  4396:                 rts
                            	  4397: 
                            	  4398: 
                            	  4399: 
                            	  4400: *-----------------------------------------------------------
                            	  4401: *-----------------------------------------------------------
                            	  4402: * OPCODE : SUBQ
                            	  4403: *-----------------------------------------------------------
                            	  4404: *-----------------------------------------------------------
                            	  4405: 
                            	  4406: op_SUBQ:
                            	  4407: 
                            	  4408: *     BYTE
02:00002A50 203C000000FF    	  4409:                 move.l #$000000FF,d0    * Loop counter
02:00002A56 7200            	  4410:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A58 243C00001234    	  4411:                 move.l #$00001234,d2    * Data results accumulator
02:00002A5E 7600            	  4412:                 moveq  #$00000000,d3
02:00002A60 7800            	  4413:                 moveq  #$00000000,d4
02:00002A62 7A12            	  4414:                 moveq  #$00000012,d5
02:00002A64 7C00            	  4415:                 moveq  #$00000000,d6
02:00002A66 7E00            	  4416:                 moveq  #$00000000,d7
                            	  4417: 
02:00002A68 5305            	  4418: SUBQ_LOOP1:     subq.b #1,d5
02:00002A6A 40C6            	  4419:                 move.w SR,d6
02:00002A6C 02860000001F    	  4420:                 andi.l #$1F,d6        * Isolate flags
02:00002A72 D286            	  4421:                 add.l d6,d1           * Copy flag results into accumulator
02:00002A74 D485            	  4422:                 add.l d5,d2           * Copy data results into data accumulator
02:00002A76 51C8FFF0        	  4423:                 dbf d0,SUBQ_LOOP1
                            	  4424: 
02:00002A7A 0C8100000417    	  4425:                 cmpi.l #$00000417,d1
02:00002A80 66FE            	  4426:                 bne.s *
02:00002A82 0C82000091B4    	  4427:                 cmpi.l #$000091B4,d2
02:00002A88 66FE            	  4428:                 bne.s *
                            	  4429: 
                            	  4430: 
                            	  4431: *     WORD
02:00002A8A 203C000000FF    	  4432:                 move.l #$000000FF,d0    * Loop counter
02:00002A90 7200            	  4433:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002A92 7400            	  4434:                 moveq  #$00000000,d2    * Data results accumulator
02:00002A94 7600            	  4435:                 moveq  #$00000000,d3
02:00002A96 7800            	  4436:                 moveq  #$00000000,d4
02:00002A98 7A02            	  4437:                 moveq  #$00000002,d5
02:00002A9A 7C00            	  4438:                 moveq  #$00000000,d6
02:00002A9C 7E00            	  4439:                 moveq  #$00000000,d7
02:00002A9E 307C0100        	  4440:                 move.l #$00000100,a0
                            	  4441: 
02:00002AA2 5B45            	  4442: SUBQ_LOOP2:     subq.w #5,d5
02:00002AA4 40C6            	  4443:                 move.w SR,d6
02:00002AA6 02860000001F    	  4444:                 andi.l #$1F,d6        * Isolate flags
02:00002AAC D286            	  4445:                 add.l d6,d1           * Copy flag results into accumulator
02:00002AAE D485            	  4446:                 add.l d5,d2           * Copy data results into data accumulator
02:00002AB0 51C8FFF0        	  4447:                 dbf d0,SUBQ_LOOP2
                            	  4448: 
02:00002AB4 0C8100000811    	  4449:                 cmpi.l #$00000811,d1
02:00002ABA 66FE            	  4450:                 bne.s *
02:00002ABC 0C8200FD7F80    	  4451:                 cmpi.l #$00FD7F80,d2
02:00002AC2 66FE            	  4452:                 bne.s *
                            	  4453: 
                            	  4454: 
                            	  4455: *     LONG
02:00002AC4 203C000000FF    	  4456:                 move.l #$000000FF,d0    * Loop counter
02:00002ACA 7200            	  4457:                 moveq  #$00000000,d1    * Flag results accumulator
02:00002ACC 7400            	  4458:                 moveq  #$00000000,d2    * Data results accumulator
02:00002ACE 7600            	  4459:                 moveq  #$00000000,d3
02:00002AD0 7800            	  4460:                 moveq  #$00000000,d4
02:00002AD2 7A07            	  4461:                 moveq  #$00000007,d5
02:00002AD4 7C00            	  4462:                 moveq  #$00000000,d6
02:00002AD6 7E00            	  4463:                 moveq  #$00000000,d7
                            	  4464: 
02:00002AD8 5385            	  4465: SUBQ_LOOP3:     subq.l #1,d5
02:00002ADA 40C6            	  4466:                 move.w SR,d6
02:00002ADC 02860000001F    	  4467:                 andi.l #$1F,d6        * Isolate flags
02:00002AE2 D286            	  4468:                 add.l d6,d1           * Copy flag results into accumulator
02:00002AE4 D485            	  4469:                 add.l d5,d2           * Copy data results into data accumulator
02:00002AE6 51C8FFF0        	  4470:                 dbf d0,SUBQ_LOOP3
                            	  4471: 
02:00002AEA 0C81000007DD    	  4472:                 cmpi.l #$000007DD,d1
02:00002AF0 66FE            	  4473:                 bne.s *
02:00002AF2 0C82FFFF8680    	  4474:                 cmpi.l #$FFFF8680,d2
02:00002AF8 66FE            	  4475:                 bne.s *
                            	  4476: 
                            	  4477: *     Check that Flags are not updated for Address registers
02:00002AFA 207C0001FFFF    	  4478:                 move.l #$0001FFFF,a0
02:00002B00 44FC0000        	  4479:                 move #$00,CCR         * Clear flags
02:00002B04 5F48            	  4480:                 subq.w #$7,a0
02:00002B06 65FE            	  4481:                 bcs.s *
                            	  4482: 
02:00002B08 4E75            	  4483:                 rts
                            	  4484: 
                            	  4485: 
                            	  4486: 
                            	  4487: 
                            	  4488: *-----------------------------------------------------------
                            	  4489: *-----------------------------------------------------------
                            	  4490: * OPCODE : MOVEQ
                            	  4491: *-----------------------------------------------------------
                            	  4492: *-----------------------------------------------------------
                            	  4493: 
                            	  4494: op_MOVEQ:
02:00002B0A 7000            	  4495:                 moveq  #$00000000,d0
02:00002B0C 7000            	  4496:                 moveq #$0,d0
02:00002B0E 66FE            	  4497:                 bne.s *
02:00002B10 4A80            	  4498:                 cmpi.l #$00000000,d0
02:00002B12 66FE            	  4499:                 bne.s *
                            	  4500: 
02:00002B14 7000            	  4501:                 moveq  #$00000000,d0
02:00002B16 7080            	  4502:                 moveq #-128,d0
02:00002B18 67FE            	  4503:                 beq.s *
02:00002B1A 6AFE            	  4504:                 bpl.s *
02:00002B1C 0C80FFFFFF80    	  4505:                 cmpi.l #$FFFFFF80,d0
02:00002B22 66FE            	  4506:                 bne.s *
                            	  4507: 
                            	  4508: 
02:00002B24 4E75            	  4509:                 rts
                            	  4510: 
                            	  4511: 
                            	  4512: *-----------------------------------------------------------
                            	  4513: *-----------------------------------------------------------
                            	  4514: * OPCODE : DIVU
                            	  4515: *-----------------------------------------------------------
                            	  4516: *-----------------------------------------------------------
                            	  4517: 
                            	  4518: op_DIVU:
                            	  4519: 
02:00002B26 203CA5A5A5A5    	  4520:                 move.l #$a5a5a5a5,d0        * Initial Numerator
02:00002B2C 223C00005A5A    	  4521:                 move.l #$00005a5a,d1        * Initial Divisor
02:00002B32 243CA5A5A5A5    	  4522:                 move.l #$a5a5a5a5,d2
02:00002B38 7600            	  4523:                 moveq  #$00000000,d3
02:00002B3A 7800            	  4524:                 moveq  #$00000000,d4        * Cumulative data results
02:00002B3C 7A00            	  4525:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002B3E 7C0E            	  4526:                 move.l #$0000000E,d6       * Inner loop counter
02:00002B40 7E1E            	  4527:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4528: 
                            	  4529: 
02:00002B42 80C1            	  4530: DIVU_OUTER1:    divu d1,d0               * !! Easy68K C not always cleared
02:00002B44 40C3            	  4531:                 move.w SR,d3
02:00002B46 02830000000C    	  4532:                 andi.l #$0C,d3            * Isolate flags
02:00002B4C DA83            	  4533:                 add.l d3,d5               * Copy flag results into accumulator
02:00002B4E D880            	  4534:                 add.l d0,d4               * Copy data results into data accumulator
02:00002B50 E289            	  4535:                 lsr.l #$1,d1
                            	  4536: 
02:00002B52 51CEFFEE        	  4537:                 dbf d6,DIVU_OUTER1
02:00002B56 E28A            	  4538:                 lsr.l #$1,d2
02:00002B58 2002            	  4539:                 move.l d2,d0
02:00002B5A 223C00005A5A    	  4540:                 move.l #$00005a5a,d1       * Initial Divisor
02:00002B60 7C0E            	  4541:                 move.l #$0000000E,d6       * Inner loop counter
02:00002B62 51CFFFDE        	  4542:                 dbf d7,DIVU_OUTER1
                            	  4543: 
02:00002B66 0C8492FEDB89    	  4544:                 cmpi.l #$92FEDB89,d4      * Check the data results
02:00002B6C 66FE            	  4545:                 bne.s *
                            	  4546: 
02:00002B6E 0C8500000110    	  4547:                 cmpi.l #$00000110,d5      * Check the Flag results
02:00002B74 66FE            	  4548:                 bne.s *
                            	  4549: 
                            	  4550: 
02:00002B76 4E75            	  4551:                 rts
                            	  4552: 
                            	  4553: 
                            	  4554: 
                            	  4555: *-----------------------------------------------------------
                            	  4556: *-----------------------------------------------------------
                            	  4557: * OPCODE : DIVS
                            	  4558: *-----------------------------------------------------------
                            	  4559: *-----------------------------------------------------------
                            	  4560: 
                            	  4561: op_DIVS:
                            	  4562: 
02:00002B78 203CA5A5A5A5    	  4563:                 move.l #$a5a5a5a5,d0        * Initial Numerator
02:00002B7E 223C00005A5A    	  4564:                 move.l #$00005a5a,d1        * Initial Divisor
02:00002B84 243CA5A5A5A5    	  4565:                 move.l #$a5a5a5a5,d2
02:00002B8A 7600            	  4566:                 moveq  #$00000000,d3
02:00002B8C 7800            	  4567:                 moveq  #$00000000,d4        * Cumulative data results
02:00002B8E 7A00            	  4568:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002B90 7C0E            	  4569:                 move.l #$0000000E,d6       * Inner loop counter
02:00002B92 7E1E            	  4570:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4571: 
                            	  4572: 
02:00002B94 81C1            	  4573: DIVS_OUTER1:    divs d1,d0               * !! Easy68K C not always cleared
02:00002B96 40C3            	  4574:                 move.w SR,d3
02:00002B98 02830000000C    	  4575:                 andi.l #$0C,d3            * Isolate flags
02:00002B9E DA83            	  4576:                 add.l d3,d5               * Copy flag results into accumulator
02:00002BA0 D880            	  4577:                 add.l d0,d4               * Copy data results into data accumulator
02:00002BA2 E289            	  4578:                 lsr.l #$1,d1
                            	  4579: 
02:00002BA4 51CEFFEE        	  4580:                 dbf d6,DIVS_OUTER1
02:00002BA8 E28A            	  4581:                 lsr.l #$1,d2
02:00002BAA 2002            	  4582:                 move.l d2,d0
02:00002BAC 223C00005A5A    	  4583:                 move.l #$00005a5a,d1       * Initial Divisor
02:00002BB2 7C0E            	  4584:                 move.l #$0000000E,d6       * Inner loop counter
02:00002BB4 51CFFFDE        	  4585:                 dbf d7,DIVS_OUTER1
                            	  4586: 
02:00002BB8 0C844EC5D057    	  4587:                 cmpi.l #$4EC5D057,d4      * Check the data results
02:00002BBE 66FE            	  4588:                 bne.s *
                            	  4589: 
02:00002BC0 0C8500000038    	  4590:                 cmpi.l #$00000038,d5      * Check the Flag results
02:00002BC6 66FE            	  4591:                 bne.s *
                            	  4592: 
                            	  4593: 
02:00002BC8 4E75            	  4594:                 rts
                            	  4595: 
                            	  4596: 
                            	  4597: 
                            	  4598: *-----------------------------------------------------------
                            	  4599: *-----------------------------------------------------------
                            	  4600: * OPCODE : OR
                            	  4601: *-----------------------------------------------------------
                            	  4602: *-----------------------------------------------------------
                            	  4603: 
                            	  4604: op_OR:
                            	  4605: 
                            	  4606: *  * <EA> to Register
                            	  4607: 
02:00002BCA 203CA5A5A5A5    	  4608:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002BD0 223C8167E123    	  4609:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002BD6 243CA5A5A5A5    	  4610:                 move.l #$a5a5a5a5,d2
02:00002BDC 7600            	  4611:                 moveq  #$00000000,d3
02:00002BDE 7800            	  4612:                 moveq  #$00000000,d4       * Cumulative data results
02:00002BE0 7A00            	  4613:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002BE2 7C1E            	  4614:                 move.l #$0000001E,d6       * Inner loop counter
02:00002BE4 7E1E            	  4615:                 move.l #$0000001E,d7       * Outer loop counter
02:00002BE6 307C0100        	  4616:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4617: 
                            	  4618: 
                            	  4619: OR_OUTER1:
                            	  4620: 
                            	  4621: *     BYTE
02:00002BEA 2081            	  4622:                 move.l d1,(a0)
02:00002BEC 8010            	  4623:                 or.b (a0),d0
02:00002BEE 40C3            	  4624:                 move.w SR,d3
02:00002BF0 02830000000C    	  4625:                 andi.l #$0C,d3            * Isolate flags
02:00002BF6 DA83            	  4626:                 add.l d3,d5               * Copy flag results into accumulator
02:00002BF8 D880            	  4627:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4628: 
                            	  4629: *     WORD
02:00002BFA 2081            	  4630:                 move.l d1,(a0)
02:00002BFC 8050            	  4631:                 or.w (a0),d0
02:00002BFE 40C3            	  4632:                 move.w SR,d3
02:00002C00 02830000000C    	  4633:                 andi.l #$0C,d3            * Isolate flags
02:00002C06 DA83            	  4634:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C08 D880            	  4635:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4636: 
                            	  4637: *     LONG
02:00002C0A 2081            	  4638:                 move.l d1,(a0)
02:00002C0C 8090            	  4639:                 or.l (a0),d0
02:00002C0E 40C3            	  4640:                 move.w SR,d3
02:00002C10 02830000000F    	  4641:                 andi.l #$0F,d3            * Isolate flags
02:00002C16 DA83            	  4642:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C18 D880            	  4643:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4644: 
                            	  4645: 
02:00002C1A E289            	  4646:                 lsr.l #$1,d1
02:00002C1C 51CEFFCC        	  4647:                 dbf d6,OR_OUTER1
02:00002C20 E28A            	  4648:                 lsr.l #$1,d2
02:00002C22 223C8167E123    	  4649:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002C28 7C1E            	  4650:                 move.l #$0000001E,d6       * Inner loop counter
02:00002C2A 51CFFFBE        	  4651:                 dbf d7,OR_OUTER1
                            	  4652: 
02:00002C2E 0C8476EAC803    	  4653:                 cmpi.l #$76EAC803,d4      * Check the data results
02:00002C34 66FE            	  4654:                 bne.s *
02:00002C36 0C8500005A18    	  4655:                 cmpi.l #$00005A18,d5      * Check the Flag results
02:00002C3C 66FE            	  4656:                 bne.s *
                            	  4657: 
                            	  4658: 
                            	  4659: *  * Register to <EA>
                            	  4660: 
02:00002C3E 203C86738374    	  4661:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002C44 223CFC55F2FE    	  4662:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002C4A 243C86738374    	  4663:                 move.l #$86738374,d2
02:00002C50 7600            	  4664:                 moveq  #$00000000,d3
02:00002C52 7800            	  4665:                 moveq  #$00000000,d4       * Cumulative data results
02:00002C54 7A00            	  4666:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002C56 7C1E            	  4667:                 move.l #$0000001E,d6       * Inner loop counter
02:00002C58 7E1D            	  4668:                 move.l #$0000001D,d7       * Outer loop counter
02:00002C5A 307C0100        	  4669:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4670: 
                            	  4671: 
                            	  4672: OR_OUTER2:
                            	  4673: 
                            	  4674: *     BYTE
02:00002C5E 2080            	  4675:                 move.l d0,(a0)
02:00002C60 8310            	  4676:                 or.b d1,(a0)
02:00002C62 40C3            	  4677:                 move.w SR,d3
02:00002C64 02830000000C    	  4678:                 andi.l #$0C,d3            * Isolate flags
02:00002C6A DA83            	  4679:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C6C D890            	  4680:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4681: 
                            	  4682: *     WORD
02:00002C6E 2080            	  4683:                 move.l d0,(a0)
02:00002C70 8350            	  4684:                 or.w d1,(a0)
02:00002C72 40C3            	  4685:                 move.w SR,d3
02:00002C74 02830000000C    	  4686:                 andi.l #$0C,d3            * Isolate flags
02:00002C7A DA83            	  4687:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C7C D890            	  4688:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4689: 
                            	  4690: *     LONG
02:00002C7E 2080            	  4691:                 move.l d0,(a0)
02:00002C80 8390            	  4692:                 or.l d1,(a0)
02:00002C82 40C3            	  4693:                 move.w SR,d3
02:00002C84 02830000000F    	  4694:                 andi.l #$0F,d3            * Isolate flags
02:00002C8A DA83            	  4695:                 add.l d3,d5               * Copy flag results into accumulator
02:00002C8C D890            	  4696:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4697: 
                            	  4698: 
02:00002C8E E289            	  4699:                 lsr.l #$1,d1
02:00002C90 51CEFFCC        	  4700:                 dbf d6,OR_OUTER2
02:00002C94 E28A            	  4701:                 lsr.l #$1,d2
02:00002C96 223C8167E123    	  4702:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002C9C 7C1E            	  4703:                 move.l #$0000001E,d6       * Inner loop counter
02:00002C9E 51CFFFBE        	  4704:                 dbf d7,OR_OUTER2
                            	  4705: 
02:00002CA2 0C84FA82B9E4    	  4706:                 cmpi.l #$FA82B9E4,d4      * Check the data results
02:00002CA8 66FE            	  4707:                 bne.s *
02:00002CAA 0C8500005730    	  4708:                 cmpi.l #$00005730,d5      * Check the Flag results
02:00002CB0 66FE            	  4709:                 bne.s *
                            	  4710: 
                            	  4711: 
02:00002CB2 4E75            	  4712:                 rts
                            	  4713: 
                            	  4714: 
                            	  4715: 
                            	  4716: *-----------------------------------------------------------
                            	  4717: *-----------------------------------------------------------
                            	  4718: * OPCODE : AND
                            	  4719: *-----------------------------------------------------------
                            	  4720: *-----------------------------------------------------------
                            	  4721: 
                            	  4722: op_AND:
                            	  4723: 
                            	  4724: *  * <EA> to Register
                            	  4725: 
02:00002CB4 203CA5A5A5A5    	  4726:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002CBA 223C8167E123    	  4727:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002CC0 243CA5A5A5A5    	  4728:                 move.l #$a5a5a5a5,d2
02:00002CC6 7600            	  4729:                 moveq  #$00000000,d3
02:00002CC8 7800            	  4730:                 moveq  #$00000000,d4       * Cumulative data results
02:00002CCA 7A00            	  4731:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002CCC 7C1E            	  4732:                 move.l #$0000001E,d6       * Inner loop counter
02:00002CCE 7E1E            	  4733:                 move.l #$0000001E,d7       * Outer loop counter
02:00002CD0 307C0100        	  4734:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4735: 
                            	  4736: 
                            	  4737: AND_OUTER1:
                            	  4738: 
                            	  4739: *     BYTE
02:00002CD4 2081            	  4740:                 move.l d1,(a0)
02:00002CD6 C010            	  4741:                 and.b (a0),d0
02:00002CD8 40C3            	  4742:                 move.w sr,d3
02:00002CDA 02830000000C    	  4743:                 andi.l #$0C,d3            * Isolate flags
02:00002CE0 DA83            	  4744:                 add.l d3,d5               * Copy flag results into accumulator
02:00002CE2 D880            	  4745:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4746: 
                            	  4747: *     WORD
02:00002CE4 2081            	  4748:                 move.l d1,(a0)
02:00002CE6 C050            	  4749:                 and.w (a0),d0
02:00002CE8 40C3            	  4750:                 move.w sr,d3
02:00002CEA 02830000000C    	  4751:                 andi.l #$0C,d3            * Isolate flags
02:00002CF0 DA83            	  4752:                 add.l d3,d5               * Copy flag results into accumulator
02:00002CF2 D880            	  4753:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4754: 
                            	  4755: *     LONG
02:00002CF4 2081            	  4756:                 move.l d1,(a0)
02:00002CF6 C090            	  4757:                 and.l (a0),d0
02:00002CF8 40C3            	  4758:                 move.w sr,d3
02:00002CFA 02830000000F    	  4759:                 andi.l #$0F,d3            * Isolate flags
02:00002D00 DA83            	  4760:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D02 D880            	  4761:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4762: 
                            	  4763: 
02:00002D04 E289            	  4764:                 lsr.l #$1,d1
02:00002D06 51CEFFCC        	  4765:                 dbf d6,AND_OUTER1
02:00002D0A E28A            	  4766:                 lsr.l #$1,d2
02:00002D0C 223C8167E123    	  4767:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002D12 7C1E            	  4768:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D14 51CFFFBE        	  4769:                 dbf d7,AND_OUTER1
                            	  4770: 
02:00002D18 0C84CF212883    	  4771:                 cmpi.l #$CF212883,d4      * Check the data results
02:00002D1E 66FE            	  4772:                 bne.s *
02:00002D20 0C8500002D10    	  4773:                 cmpi.l #$00002D10,d5      * Check the Flag results
02:00002D26 66FE            	  4774:                 bne.s *
                            	  4775: 
                            	  4776: 
                            	  4777: *  * Register to <EA>
                            	  4778: 
02:00002D28 203C86738374    	  4779:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002D2E 223CFC55F2FE    	  4780:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002D34 243C86738374    	  4781:                 move.l #$86738374,d2
02:00002D3A 7600            	  4782:                 moveq  #$00000000,d3
02:00002D3C 7800            	  4783:                 moveq  #$00000000,d4       * Cumulative data results
02:00002D3E 7A00            	  4784:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002D40 7C1E            	  4785:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D42 7E1D            	  4786:                 move.l #$0000001D,d7       * Outer loop counter
02:00002D44 307C0100        	  4787:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4788: 
                            	  4789: 
                            	  4790: AND_OUTER2:
                            	  4791: 
                            	  4792: *     BYTE
02:00002D48 2080            	  4793:                 move.l d0,(a0)
02:00002D4A C310            	  4794:                 and.b d1,(a0)
02:00002D4C 40C3            	  4795:                 move.w sr,d3
02:00002D4E 02830000000C    	  4796:                 andi.l #$0C,d3            * Isolate flags
02:00002D54 DA83            	  4797:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D56 D890            	  4798:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4799: 
                            	  4800: *     WORD
02:00002D58 2080            	  4801:                 move.l d0,(a0)
02:00002D5A C350            	  4802:                 and.w d1,(a0)
02:00002D5C 40C3            	  4803:                 move.w sr,d3
02:00002D5E 02830000000C    	  4804:                 andi.l #$0C,d3            * Isolate flags
02:00002D64 DA83            	  4805:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D66 D890            	  4806:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4807: 
                            	  4808: *     LONG
02:00002D68 2080            	  4809:                 move.l d0,(a0)
02:00002D6A C390            	  4810:                 and.l d1,(a0)
02:00002D6C 40C3            	  4811:                 move.w sr,d3
02:00002D6E 02830000000F    	  4812:                 andi.l #$0F,d3            * Isolate flags
02:00002D74 DA83            	  4813:                 add.l d3,d5               * Copy flag results into accumulator
02:00002D76 D890            	  4814:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4815: 
                            	  4816: 
02:00002D78 E289            	  4817:                 lsr.l #$1,d1
02:00002D7A 51CEFFCC        	  4818:                 dbf d6,AND_OUTER2
02:00002D7E E28A            	  4819:                 lsr.l #$1,d2
02:00002D80 223C8167E123    	  4820:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002D86 7C1E            	  4821:                 move.l #$0000001E,d6       * Inner loop counter
02:00002D88 51CFFFBE        	  4822:                 dbf d7,AND_OUTER2
                            	  4823: 
02:00002D8C 0C844A3DE544    	  4824:                 cmpi.l #$4A3DE544,d4      * Check the data results
02:00002D92 66FE            	  4825:                 bne.s *
02:00002D94 0C85000018E8    	  4826:                 cmpi.l #$000018E8,d5      * Check the Flag results
02:00002D9A 66FE            	  4827:                 bne.s *
                            	  4828: 
                            	  4829: 
02:00002D9C 4E75            	  4830:                 rts
                            	  4831: 
                            	  4832: 
                            	  4833: 
                            	  4834: *-----------------------------------------------------------
                            	  4835: *-----------------------------------------------------------
                            	  4836: * OPCODE : EOR
                            	  4837: *-----------------------------------------------------------
                            	  4838: *-----------------------------------------------------------
                            	  4839: 
                            	  4840: op_EOR:
                            	  4841: 
                            	  4842: *  * Register to <EA>
                            	  4843: 
02:00002D9E 203C86738374    	  4844:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00002DA4 223CFC55F2FE    	  4845:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00002DAA 243C86738374    	  4846:                 move.l #$86738374,d2
02:00002DB0 7600            	  4847:                 moveq  #$00000000,d3
02:00002DB2 7800            	  4848:                 moveq  #$00000000,d4       * Cumulative data results
02:00002DB4 7A00            	  4849:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002DB6 7C1E            	  4850:                 move.l #$0000001E,d6       * Inner loop counter
02:00002DB8 7E1D            	  4851:                 move.l #$0000001D,d7       * Outer loop counter
02:00002DBA 307C0100        	  4852:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4853: 
                            	  4854: 
                            	  4855: EOR_OUTER2:
                            	  4856: 
                            	  4857: *     BYTE
02:00002DBE 2080            	  4858:                 move.l d0,(a0)
02:00002DC0 B310            	  4859:                 eor.b d1,(a0)
02:00002DC2 40C3            	  4860:                 move.w sr,d3
02:00002DC4 02830000000C    	  4861:                 andi.l #$0C,d3            * Isolate flags
02:00002DCA DA83            	  4862:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DCC D890            	  4863:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4864: 
                            	  4865: *     WORD
02:00002DCE 2080            	  4866:                 move.l d0,(a0)
02:00002DD0 B350            	  4867:                 eor.w d1,(a0)
02:00002DD2 40C3            	  4868:                 move.w sr,d3
02:00002DD4 02830000000C    	  4869:                 andi.l #$0C,d3            * Isolate flags
02:00002DDA DA83            	  4870:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DDC D890            	  4871:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4872: 
                            	  4873: *     LONG
02:00002DDE 2080            	  4874:                 move.l d0,(a0)
02:00002DE0 B390            	  4875:                 eor.l d1,(a0)
02:00002DE2 40C3            	  4876:                 move.w sr,d3
02:00002DE4 02830000000F    	  4877:                 andi.l #$0F,d3            * Isolate flags
02:00002DEA DA83            	  4878:                 add.l d3,d5               * Copy flag results into accumulator
02:00002DEC D890            	  4879:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4880: 
                            	  4881: 
02:00002DEE E289            	  4882:                 lsr.l #$1,d1
02:00002DF0 51CEFFCC        	  4883:                 dbf d6,EOR_OUTER2
02:00002DF4 E28A            	  4884:                 lsr.l #$1,d2
02:00002DF6 223C8167E123    	  4885:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002DFC 7C1E            	  4886:                 move.l #$0000001E,d6       * Inner loop counter
02:00002DFE 51CFFFBE        	  4887:                 dbf d7,EOR_OUTER2
                            	  4888: 
02:00002E02 0C8455C5EB70    	  4889:                 cmpi.l #$55C5EB70,d4      * Check the data results
02:00002E08 66FE            	  4890:                 bne.s *
02:00002E0A 0C8500004430    	  4891:                 cmpi.l #$00004430,d5      * Check the Flag results
02:00002E10 66FE            	  4892:                 bne.s *
                            	  4893: 
                            	  4894: 
02:00002E12 4E75            	  4895:                 rts
                            	  4896: 
                            	  4897: 
                            	  4898: *-----------------------------------------------------------
                            	  4899: *-----------------------------------------------------------
                            	  4900: * OPCODE : CMP
                            	  4901: *-----------------------------------------------------------
                            	  4902: *-----------------------------------------------------------
                            	  4903: 
                            	  4904: op_CMP:
                            	  4905: 
                            	  4906: 
                            	  4907: *  * <EA> to Register
                            	  4908: 
02:00002E14 203CA5A5A5A5    	  4909:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002E1A 223C8167E123    	  4910:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002E20 243CA5A5A5A5    	  4911:                 move.l #$a5a5a5a5,d2
02:00002E26 7600            	  4912:                 moveq  #$00000000,d3
02:00002E28 7800            	  4913:                 moveq  #$00000000,d4       * Cumulative data results
02:00002E2A 7A00            	  4914:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002E2C 7C1E            	  4915:                 move.l #$0000001E,d6       * Inner loop counter
02:00002E2E 7E1E            	  4916:                 move.l #$0000001E,d7       * Outer loop counter
02:00002E30 307C0100        	  4917:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4918: 
                            	  4919: 
                            	  4920: CMP_OUTER1:
                            	  4921: 
                            	  4922: *     BYTE
02:00002E34 2081            	  4923:                 move.l d1,(a0)
02:00002E36 B010            	  4924:                 cmp.b (a0),d0
02:00002E38 40C3            	  4925:                 move.w sr,d3
02:00002E3A 02830000000F    	  4926:                 andi.l #$0F,d3            * Isolate flags
02:00002E40 DA83            	  4927:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E42 D880            	  4928:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4929: 
                            	  4930: *     WORD
02:00002E44 2081            	  4931:                 move.l d1,(a0)
02:00002E46 B050            	  4932:                 cmp.w (a0),d0
02:00002E48 40C3            	  4933:                 move.w sr,d3
02:00002E4A 02830000000F    	  4934:                 andi.l #$0F,d3            * Isolate flags
02:00002E50 DA83            	  4935:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E52 D880            	  4936:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4937: 
                            	  4938: *     LONG
02:00002E54 2081            	  4939:                 move.l d1,(a0)
02:00002E56 B090            	  4940:                 cmp.l (a0),d0
02:00002E58 40C3            	  4941:                 move.w sr,d3
02:00002E5A 02830000000F    	  4942:                 andi.l #$0F,d3            * Isolate flags
02:00002E60 DA83            	  4943:                 add.l d3,d5               * Copy flag results into accumulator
02:00002E62 D880            	  4944:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4945: 
                            	  4946: 
02:00002E64 E289            	  4947:                 lsr.l #$1,d1
02:00002E66 51CEFFCC        	  4948:                 dbf d6,CMP_OUTER1
02:00002E6A E28A            	  4949:                 lsr.l #$1,d2
02:00002E6C 223C8167E123    	  4950:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002E72 7C1E            	  4951:                 move.l #$0000001E,d6       * Inner loop counter
02:00002E74 51CFFFBE        	  4952:                 dbf d7,CMP_OUTER1
                            	  4953: 
02:00002E78 0C847878712F    	  4954:                 cmpi.l #$7878712F,d4      * Check the data results
02:00002E7E 66FE            	  4955:                 bne.s *
02:00002E80 0C8500005502    	  4956:                 cmpi.l #$00005502,d5      * Check the Flag results
02:00002E86 66FE            	  4957:                 bne.s *
                            	  4958: 
                            	  4959: 
                            	  4960: 
02:00002E88 4E75            	  4961:                 rts
                            	  4962: 
                            	  4963: 
                            	  4964: *-----------------------------------------------------------
                            	  4965: *-----------------------------------------------------------
                            	  4966: * OPCODE : CMPA
                            	  4967: *-----------------------------------------------------------
                            	  4968: *-----------------------------------------------------------
                            	  4969: 
                            	  4970: op_CMPA:
                            	  4971: 
                            	  4972: 
                            	  4973: *  * <EA> to Register
                            	  4974: 
02:00002E8A 207CA5A5A5A5    	  4975:                 move.l #$a5a5a5a5,a0       * Initial Data-X  Inner loop
02:00002E90 223C8167E123    	  4976:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002E96 243CA5A5A5A5    	  4977:                 move.l #$a5a5a5a5,d2
02:00002E9C 7600            	  4978:                 moveq  #$00000000,d3
02:00002E9E 7800            	  4979:                 moveq  #$00000000,d4       * Cumulative data results
02:00002EA0 7A00            	  4980:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002EA2 7C1E            	  4981:                 move.l #$0000001E,d6       * Inner loop counter
02:00002EA4 7E1E            	  4982:                 move.l #$0000001E,d7       * Outer loop counter
02:00002EA6 327C0100        	  4983:                 move.l #$00000100,a1       * Address for memory EA operations
                            	  4984: 
                            	  4985: 
                            	  4986: CMPA_OUTER1:
                            	  4987: 
                            	  4988: 
                            	  4989: *     WORD
02:00002EAA 2281            	  4990:                 move.l d1,(a1)
02:00002EAC B0D1            	  4991:                 cmpa.w (a1),a0
02:00002EAE 40C3            	  4992:                 move.w sr,d3
02:00002EB0 02830000000F    	  4993:                 andi.l #$0F,d3            * Isolate flags
02:00002EB6 DA83            	  4994:                 add.l d3,d5               * Copy flag results into accumulator
02:00002EB8 D888            	  4995:                 add.l a0,d4               * Copy data results into data accumulator
                            	  4996: 
                            	  4997: *     LONG
02:00002EBA 2281            	  4998:                 move.l d1,(a1)
02:00002EBC B1D1            	  4999:                 cmpa.l (a1),a0
02:00002EBE 40C3            	  5000:                 move.w sr,d3
02:00002EC0 02830000000F    	  5001:                 andi.l #$0F,d3            * Isolate flags
02:00002EC6 DA83            	  5002:                 add.l d3,d5               * Copy flag results into accumulator
02:00002EC8 D888            	  5003:                 add.l a0,d4               * Copy data results into data accumulator
                            	  5004: 
                            	  5005: 
02:00002ECA E289            	  5006:                 lsr.l #$1,d1
02:00002ECC 51CEFFDC        	  5007:                 dbf d6,CMPA_OUTER1
02:00002ED0 E28A            	  5008:                 lsr.l #$1,d2
02:00002ED2 223C8167E123    	  5009:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002ED8 7C1E            	  5010:                 move.l #$0000001E,d6       * Inner loop counter
02:00002EDA 51CFFFCE        	  5011:                 dbf d7,CMPA_OUTER1
                            	  5012: 
02:00002EDE 0C84A5A5A0CA    	  5013:                 cmpi.l #$a5a5a0ca,d4      * Check the data results
02:00002EE4 66FE            	  5014:                 bne.s *
02:00002EE6 0C8500003A7D    	  5015:                 cmpi.l #$00003A7D,d5      * Check the Flag results
02:00002EEC 66FE            	  5016:                 bne.s *
                            	  5017: 
                            	  5018: 
02:00002EEE 4E75            	  5019:                 rts
                            	  5020: 
                            	  5021: 
                            	  5022: 
                            	  5023: *-----------------------------------------------------------
                            	  5024: *-----------------------------------------------------------
                            	  5025: * OPCODE : CMPM
                            	  5026: *-----------------------------------------------------------
                            	  5027: *-----------------------------------------------------------
                            	  5028: 
                            	  5029: op_CMPM:
                            	  5030: 
02:00002EF0 307C0100        	  5031:                 move.l #$00000100,a0       * Address for Data-X
02:00002EF4 327C0200        	  5032:                 move.l #$00000200,a1       * Address for Data-Y
02:00002EF8 7000            	  5033:                 moveq  #$00000000,d0
02:00002EFA 7200            	  5034:                 moveq  #$00000000,d1
02:00002EFC 7400            	  5035:                 moveq  #$00000000,d2
                            	  5036: 
02:00002EFE 20FC11FF5580    	  5037:                 move.l #$11FF5580,(a0)+   * Populate test data
02:00002F04 20FC1111FFFF    	  5038:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:00002F0A 20FC33333333    	  5039:                 move.l #$33333333,(a0)+   * Populate test data
02:00002F10 20FC44444444    	  5040:                 move.l #$44444444,(a0)+   * Populate test data
                            	  5041: 
02:00002F16 22FC80FF337F    	  5042:                 move.l #$80FF337F,(a1)+   * Populate test data
02:00002F1C 22FCFFFF1111    	  5043:                 move.l #$FFFF1111,(a1)+   * Populate test data
02:00002F22 22FC33333333    	  5044:                 move.l #$33333333,(a1)+   * Populate test data
02:00002F28 22FC44444444    	  5045:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5046: 
02:00002F2E 307C0100        	  5047:                 move.l #$00000100,a0       * Address for Data-X
02:00002F32 327C0200        	  5048:                 move.l #$00000200,a1       * Address for Data-Y
02:00002F36 7C0F            	  5049:                 move.l #$0000000F,d6       * Loop counter
                            	  5050: 
02:00002F38 B308            	  5051: CMPM_LOOP1:     cmpm.b (a0)+,(a1)+
02:00002F3A 40C3            	  5052:                 move.w sr,d3
02:00002F3C 02830000000F    	  5053:                 andi.l #$0F,d3            * Isolate flags
02:00002F42 D083            	  5054:                 add.l d3,d0               * Copy flag results into accumulator
02:00002F44 51CEFFF2        	  5055:                 dbf d6,CMPM_LOOP1
                            	  5056: 
                            	  5057: 
02:00002F48 307C0100        	  5058:                 move.l #$00000100,a0       * Address for Data-X
02:00002F4C 327C0200        	  5059:                 move.l #$00000200,a1       * Address for Data-Y
02:00002F50 7C07            	  5060:                 moveq  #$00000007,d6       * Loop counter
                            	  5061: 
02:00002F52 B348            	  5062: CMPM_LOOP2:     cmpm.w (a0)+,(a1)+
02:00002F54 40C3            	  5063:                 move.w sr,d3
02:00002F56 02830000000F    	  5064:                 andi.l #$0F,d3            * Isolate flags
02:00002F5C D283            	  5065:                 add.l d3,d1               * Copy flag results into accumulator
02:00002F5E 51CEFFF2        	  5066:                 dbf d6,CMPM_LOOP2
                            	  5067: 
                            	  5068: 
02:00002F62 307C0100        	  5069:                 move.l #$00000100,a0       * Address for Data-X
02:00002F66 327C0200        	  5070:                 move.l #$00000200,a1       * Address for Data-Y
02:00002F6A 7C03            	  5071:                 moveq  #$00000003,d6       * Loop counter
                            	  5072: 
02:00002F6C B388            	  5073: CMPM_LOOP3:     cmpm.l (a0)+,(a1)+
02:00002F6E 40C3            	  5074:                 move.w sr,d3
02:00002F70 02830000000F    	  5075:                 andi.l #$0F,d3            * Isolate flags
02:00002F76 D483            	  5076:                 add.l d3,d2               * Copy flag results into accumulator
02:00002F78 51CEFFF2        	  5077:                 dbf d6,CMPM_LOOP3
                            	  5078: 
                            	  5079: 
02:00002F7C 0C800000004C    	  5080:                 cmpi.l #$0000004C,d0      * Check the data results
02:00002F82 66FE            	  5081:                 bne.s *
02:00002F84 0C8100000024    	  5082:                 cmpi.l #$00000024,d1
02:00002F8A 66FE            	  5083:                 bne.s *
02:00002F8C 0C8200000012    	  5084:                 cmpi.l #$00000012,d2
02:00002F92 66FE            	  5085:                 bne.s *
                            	  5086: 
02:00002F94 4E75            	  5087:                 rts
                            	  5088: 
                            	  5089: 
                            	  5090: *-----------------------------------------------------------
                            	  5091: *-----------------------------------------------------------
                            	  5092: * OPCODE : ADD
                            	  5093: *-----------------------------------------------------------
                            	  5094: *-----------------------------------------------------------
                            	  5095: 
                            	  5096: op_ADD:
                            	  5097: 
                            	  5098: 
                            	  5099: *  * <EA> to Register
02:00002F96 203CA5A5A5A5    	  5100:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00002F9C 223C8167E123    	  5101:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:00002FA2 243CA5A5A5A5    	  5102:                 move.l #$a5a5a5a5,d2
02:00002FA8 7600            	  5103:                 moveq  #$00000000,d3
02:00002FAA 7800            	  5104:                 moveq  #$00000000,d4       * Cumulative data results
02:00002FAC 7A00            	  5105:                 moveq  #$00000000,d5       * Cumulative flag results
02:00002FAE 7C1E            	  5106:                 move.l #$0000001E,d6       * Inner loop counter
02:00002FB0 7E1E            	  5107:                 move.l #$0000001E,d7       * Outer loop counter
02:00002FB2 307C0100        	  5108:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5109: 
                            	  5110: 
                            	  5111: ADD_OUTER1:
                            	  5112: 
                            	  5113: *     BYTE
02:00002FB6 2081            	  5114:                 move.l d1,(a0)
02:00002FB8 D010            	  5115:                 add.b (a0),d0
02:00002FBA 40C3            	  5116:                 move.w sr,d3
02:00002FBC 02830000001F    	  5117:                 andi.l #$1F,d3            * Isolate flags
02:00002FC2 DA83            	  5118:                 add.l d3,d5               * Copy flag results into accumulator
02:00002FC4 D880            	  5119:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5120: 
                            	  5121: *     WORD
02:00002FC6 2081            	  5122:                 move.l d1,(a0)
02:00002FC8 D050            	  5123:                 add.w (a0),d0
02:00002FCA 40C3            	  5124:                 move.w sr,d3
02:00002FCC 02830000000C    	  5125:                 andi.l #$0C,d3            * Isolate flags
02:00002FD2 DA83            	  5126:                 add.l d3,d5               * Copy flag results into accumulator
02:00002FD4 D880            	  5127:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5128: 
                            	  5129: *     LONG
02:00002FD6 2081            	  5130:                 move.l d1,(a0)
02:00002FD8 D090            	  5131:                 add.l (a0),d0
02:00002FDA 40C3            	  5132:                 move.w sr,d3
02:00002FDC 02830000000F    	  5133:                 andi.l #$0F,d3            * Isolate flags
02:00002FE2 DA83            	  5134:                 add.l d3,d5               * Copy flag results into accumulator
02:00002FE4 D880            	  5135:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5136: 
                            	  5137: 
02:00002FE6 E299            	  5138:                 ror.l #$1,d1
02:00002FE8 51CEFFCC        	  5139:                 dbf d6,ADD_OUTER1
02:00002FEC E29A            	  5140:                 ror.l #$1,d2
02:00002FEE 223C8167E123    	  5141:                 move.l #$8167E123,d1       * Initial Data-Y
02:00002FF4 7C1E            	  5142:                 move.l #$0000001E,d6       * Inner loop counter
02:00002FF6 51CFFFBE        	  5143:                 dbf d7,ADD_OUTER1
                            	  5144: 
02:00002FFA 0C8423ED428F    	  5145:                 cmpi.l #$23ED428F,d4      * Check the data results
02:00003000 66FE            	  5146:                 bne.s *
02:00003002 0C8500004C96    	  5147:                 cmpi.l #$00004C96,d5      * Check the Flag results
02:00003008 66FE            	  5148:                 bne.s *
                            	  5149: 
                            	  5150: 
                            	  5151: *  * Register to <EA>
02:0000300A 203C86738374    	  5152:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:00003010 223CFC55F2FE    	  5153:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00003016 243C86738374    	  5154:                 move.l #$86738374,d2
02:0000301C 7600            	  5155:                 moveq  #$00000000,d3
02:0000301E 7800            	  5156:                 moveq  #$00000000,d4       * Cumulative data results
02:00003020 7A00            	  5157:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003022 7C1E            	  5158:                 move.l #$0000001E,d6       * Inner loop counter
02:00003024 7E1D            	  5159:                 move.l #$0000001D,d7       * Outer loop counter
02:00003026 307C0100        	  5160:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5161: 
                            	  5162: 
                            	  5163: ADD_OUTER2:
                            	  5164: 
                            	  5165: *     BYTE
02:0000302A 2080            	  5166:                 move.l d0,(a0)
02:0000302C D310            	  5167:                 add.b d1,(a0)
02:0000302E 40C3            	  5168:                 move.w sr,d3
02:00003030 02830000000C    	  5169:                 andi.l #$0C,d3            * Isolate flags
02:00003036 DA83            	  5170:                 add.l d3,d5               * Copy flag results into accumulator
02:00003038 D890            	  5171:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5172: 
                            	  5173: *     WORD
02:0000303A 2080            	  5174:                 move.l d0,(a0)
02:0000303C D350            	  5175:                 add.w d1,(a0)
02:0000303E 40C3            	  5176:                 move.w sr,d3
02:00003040 02830000001F    	  5177:                 andi.l #$1F,d3            * Isolate flags
02:00003046 DA83            	  5178:                 add.l d3,d5               * Copy flag results into accumulator
02:00003048 D890            	  5179:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5180: 
                            	  5181: *     LONG
02:0000304A 2080            	  5182:                 move.l d0,(a0)
02:0000304C D390            	  5183:                 add.l d1,(a0)
02:0000304E 40C3            	  5184:                 move.w sr,d3
02:00003050 02830000000F    	  5185:                 andi.l #$0F,d3            * Isolate flags
02:00003056 DA83            	  5186:                 add.l d3,d5               * Copy flag results into accumulator
02:00003058 D890            	  5187:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5188: 
                            	  5189: 
02:0000305A E299            	  5190:                 ror.l #$1,d1
02:0000305C 51CEFFCC        	  5191:                 dbf d6,ADD_OUTER2
02:00003060 E29A            	  5192:                 ror.l #$1,d2
02:00003062 223C8167E123    	  5193:                 move.l #$8167E123,d1       * Initial Data-Y
02:00003068 7C1E            	  5194:                 move.l #$0000001E,d6       * Inner loop counter
02:0000306A 51CFFFBE        	  5195:                 dbf d7,ADD_OUTER2
                            	  5196: 
02:0000306E 0C846701B884    	  5197:                 cmpi.l #$6701B884,d4      * Check the data results
02:00003074 66FE            	  5198:                 bne.s *
02:00003076 0C8500005467    	  5199:                 cmpi.l #$00005467,d5      * Check the Flag results
02:0000307C 66FE            	  5200:                 bne.s *
                            	  5201: 
02:0000307E 4E75            	  5202:                 rts
                            	  5203: 
                            	  5204: *-----------------------------------------------------------
                            	  5205: *-----------------------------------------------------------
                            	  5206: * OPCODE : SUB
                            	  5207: *-----------------------------------------------------------
                            	  5208: *-----------------------------------------------------------
                            	  5209: 
                            	  5210: op_SUB:
                            	  5211: 
                            	  5212: *  * <EA> to Register
02:00003080 203CA5A5A5A5    	  5213:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003086 223C8167E123    	  5214:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:0000308C 243CA5A5A5A5    	  5215:                 move.l #$a5a5a5a5,d2
02:00003092 7600            	  5216:                 moveq  #$00000000,d3
02:00003094 7800            	  5217:                 moveq  #$00000000,d4       * Cumulative data results
02:00003096 7A00            	  5218:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003098 7C1E            	  5219:                 move.l #$0000001E,d6       * Inner loop counter
02:0000309A 7E1E            	  5220:                 move.l #$0000001E,d7       * Outer loop counter
02:0000309C 307C0100        	  5221:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5222: 
                            	  5223: 
                            	  5224: SUB_OUTER1:
                            	  5225: 
                            	  5226: *     BYTE
02:000030A0 2081            	  5227:                 move.l d1,(a0)
02:000030A2 9010            	  5228:                 sub.b (a0),d0
02:000030A4 40C3            	  5229:                 move.w sr,d3
02:000030A6 02830000001F    	  5230:                 andi.l #$1F,d3            * Isolate flags
02:000030AC DA83            	  5231:                 add.l d3,d5               * Copy flag results into accumulator
02:000030AE D880            	  5232:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5233: 
                            	  5234: *     WORD
02:000030B0 2081            	  5235:                 move.l d1,(a0)
02:000030B2 9050            	  5236:                 sub.w (a0),d0
02:000030B4 40C3            	  5237:                 move.w sr,d3
02:000030B6 02830000000C    	  5238:                 andi.l #$0C,d3            * Isolate flags
02:000030BC DA83            	  5239:                 add.l d3,d5               * Copy flag results into accumulator
02:000030BE D880            	  5240:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5241: 
                            	  5242: *     LONG
02:000030C0 2081            	  5243:                 move.l d1,(a0)
02:000030C2 9090            	  5244:                 sub.l (a0),d0
02:000030C4 40C3            	  5245:                 move.w sr,d3
02:000030C6 02830000000F    	  5246:                 andi.l #$0F,d3            * Isolate flags
02:000030CC DA83            	  5247:                 add.l d3,d5               * Copy flag results into accumulator
02:000030CE D880            	  5248:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5249: 
                            	  5250: 
02:000030D0 E299            	  5251:                 ror.l #$1,d1
02:000030D2 51CEFFCC        	  5252:                 dbf d6,SUB_OUTER1
02:000030D6 E29A            	  5253:                 ror.l #$1,d2
02:000030D8 223C8167E123    	  5254:                 move.l #$8167E123,d1       * Initial Data-Y
02:000030DE 7C1E            	  5255:                 move.l #$0000001E,d6       * Inner loop counter
02:000030E0 51CFFFBE        	  5256:                 dbf d7,SUB_OUTER1
                            	  5257: 
02:000030E4 0C841A8D14CF    	  5258:                 cmpi.l #$1A8D14CF,d4      * Check the data results
02:000030EA 66FE            	  5259:                 bne.s *
02:000030EC 0C8500004FC4    	  5260:                 cmpi.l #$00004FC4,d5      * Check the Flag results
02:000030F2 66FE            	  5261:                 bne.s *
                            	  5262: 
                            	  5263: 
                            	  5264: *  * Register to <EA>
02:000030F4 203C86738374    	  5265:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
02:000030FA 223CFC55F2FE    	  5266:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
02:00003100 243C86738374    	  5267:                 move.l #$86738374,d2
02:00003106 7600            	  5268:                 moveq  #$00000000,d3
02:00003108 7800            	  5269:                 moveq  #$00000000,d4       * Cumulative data results
02:0000310A 7A00            	  5270:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000310C 7C1E            	  5271:                 move.l #$0000001E,d6       * Inner loop counter
02:0000310E 7E1D            	  5272:                 move.l #$0000001D,d7       * Outer loop counter
02:00003110 307C0100        	  5273:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5274: 
                            	  5275: 
                            	  5276: SUB_OUTER2:
                            	  5277: 
                            	  5278: *     BYTE
02:00003114 2080            	  5279:                 move.l d0,(a0)
02:00003116 9310            	  5280:                 sub.b d1,(a0)
02:00003118 40C3            	  5281:                 move.w sr,d3
02:0000311A 02830000000C    	  5282:                 andi.l #$0C,d3            * Isolate flags
02:00003120 DA83            	  5283:                 add.l d3,d5               * Copy flag results into accumulator
02:00003122 D890            	  5284:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5285: 
                            	  5286: *     WORD
02:00003124 2080            	  5287:                 move.l d0,(a0)
02:00003126 9350            	  5288:                 sub.w d1,(a0)
02:00003128 40C3            	  5289:                 move.w sr,d3
02:0000312A 02830000001F    	  5290:                 andi.l #$1F,d3            * Isolate flags
02:00003130 DA83            	  5291:                 add.l d3,d5               * Copy flag results into accumulator
02:00003132 D890            	  5292:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5293: 
                            	  5294: *     LONG
02:00003134 2080            	  5295:                 move.l d0,(a0)
02:00003136 9390            	  5296:                 sub.l d1,(a0)
02:00003138 40C3            	  5297:                 move.w sr,d3
02:0000313A 02830000000F    	  5298:                 andi.l #$0F,d3            * Isolate flags
02:00003140 DA83            	  5299:                 add.l d3,d5               * Copy flag results into accumulator
02:00003142 D890            	  5300:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5301: 
                            	  5302: 
02:00003144 E299            	  5303:                 ror.l #$1,d1
02:00003146 51CEFFCC        	  5304:                 dbf d6,SUB_OUTER2
02:0000314A E29A            	  5305:                 ror.l #$1,d2
02:0000314C 223C8167E123    	  5306:                 move.l #$8167E123,d1       * Initial Data-Y
02:00003152 7C1E            	  5307:                 move.l #$0000001E,d6       * Inner loop counter
02:00003154 51CFFFBE        	  5308:                 dbf d7,SUB_OUTER2
                            	  5309: 
02:00003158 0C8436D38BEC    	  5310:                 cmpi.l #$36D38BEC,d4      * Check the data results
02:0000315E 66FE            	  5311:                 bne.s *
02:00003160 0C85000045A5    	  5312:                 cmpi.l #$000045A5,d5      * Check the Flag results
02:00003166 66FE            	  5313:                 bne.s *
                            	  5314: 
                            	  5315: 
                            	  5316: 
                            	  5317: 
02:00003168 4E75            	  5318:                 rts
                            	  5319: 
                            	  5320: 
                            	  5321: 
                            	  5322: *-----------------------------------------------------------
                            	  5323: *-----------------------------------------------------------
                            	  5324: * OPCODE : ADDA
                            	  5325: *-----------------------------------------------------------
                            	  5326: *-----------------------------------------------------------
                            	  5327: 
                            	  5328: op_ADDA:
                            	  5329: 
                            	  5330: *  * <EA> to Register
02:0000316A 203CA5A5A5A5    	  5331:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003170 223C8167E123    	  5332:                 move.l #$8167E123,d1
02:00003176 243CA5A5A5A5    	  5333:                 move.l #$a5a5a5a5,d2
02:0000317C 7600            	  5334:                 moveq  #$00000000,d3
02:0000317E 7800            	  5335:                 moveq  #$00000000,d4       * Cumulative data results
02:00003180 7A00            	  5336:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003182 7C1E            	  5337:                 move.l #$0000001E,d6       * Inner loop counter
02:00003184 7E1E            	  5338:                 move.l #$0000001E,d7       * Outer loop counter
02:00003186 307C0100        	  5339:                 move.l #$00000100,a0       * Address for memory EA operations
02:0000318A 227C8167E123    	  5340:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5341: 
                            	  5342: ADDA_OUTER1:
                            	  5343: 
                            	  5344: *     WORD
                            	  5345: *                move.l d1,(a0)       * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5346: *                adda.w (a0),a1
                            	  5347: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5348: 
                            	  5349: *     LONG
02:00003190 2081            	  5350:                 move.l d1,(a0)
02:00003192 D3D0            	  5351:                 adda.l (a0),a1
02:00003194 D889            	  5352:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5353: 
02:00003196 E299            	  5354:                 ror.l #$1,d1
02:00003198 51CEFFF6        	  5355:                 dbf d6,ADDA_OUTER1
02:0000319C E299            	  5356:                 ror.l #$1,d1
02:0000319E 2241            	  5357:                 move.l d1,a1
02:000031A0 223C8167E123    	  5358:                 move.l #$8167E123,d1       * Initial Data-Y
02:000031A6 7C1E            	  5359:                 move.l #$0000001E,d6       * Inner loop counter
02:000031A8 51CFFFE6        	  5360:                 dbf d7,ADDA_OUTER1
                            	  5361: 
02:000031AC 0C84AC04DB4C    	  5362:                 cmpi.l #$AC04DB4C,d4      * Check the data results
02:000031B2 66FE            	  5363:                 bne.s *
                            	  5364: 
                            	  5365: 
02:000031B4 4E75            	  5366:                 rts
                            	  5367: 
                            	  5368: 
                            	  5369: *-----------------------------------------------------------
                            	  5370: *-----------------------------------------------------------
                            	  5371: * OPCODE : SUBA
                            	  5372: *-----------------------------------------------------------
                            	  5373: *-----------------------------------------------------------
                            	  5374: 
                            	  5375: op_SUBA:
                            	  5376: 
                            	  5377: *  * <EA> to Register
02:000031B6 203CA5A5A5A5    	  5378:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:000031BC 223C8167E123    	  5379:                 move.l #$8167E123,d1
02:000031C2 243CA5A5A5A5    	  5380:                 move.l #$a5a5a5a5,d2
02:000031C8 7600            	  5381:                 moveq  #$00000000,d3
02:000031CA 7800            	  5382:                 moveq  #$00000000,d4       * Cumulative data results
02:000031CC 7A00            	  5383:                 moveq  #$00000000,d5       * Cumulative flag results
02:000031CE 7C1E            	  5384:                 move.l #$0000001E,d6       * Inner loop counter
02:000031D0 7E1E            	  5385:                 move.l #$0000001E,d7       * Outer loop counter
02:000031D2 307C0100        	  5386:                 move.l #$00000100,a0       * Address for memory EA operations
02:000031D6 227C8167E123    	  5387:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5388: 
                            	  5389: SUBA_OUTER1:
                            	  5390: 
                            	  5391: *     WORD
                            	  5392: *                move.l d1,(a0) * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5393: *                suba.w (a0),a1
                            	  5394: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5395: 
                            	  5396: *     LONG
02:000031DC 2081            	  5397:                 move.l d1,(a0)
02:000031DE 93D0            	  5398:                 suba.l (a0),a1
02:000031E0 D889            	  5399:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5400: 
02:000031E2 E299            	  5401:                 ror.l #$1,d1
02:000031E4 51CEFFF6        	  5402:                 dbf d6,SUBA_OUTER1
02:000031E8 E299            	  5403:                 ror.l #$1,d1
02:000031EA 2241            	  5404:                 move.l d1,a1
02:000031EC 223C8167E123    	  5405:                 move.l #$8167E123,d1       * Initial Data-Y
02:000031F2 7C1E            	  5406:                 move.l #$0000001E,d6       * Inner loop counter
02:000031F4 51CFFFE6        	  5407:                 dbf d7,SUBA_OUTER1
                            	  5408: 
02:000031F8 0C84E1E36D7A    	  5409:                 cmpi.l #$E1E36D7A,d4      * Check the data results
02:000031FE 66FE            	  5410:                 bne.s *
                            	  5411: 
                            	  5412: 
02:00003200 4E75            	  5413:                 rts
                            	  5414: 
                            	  5415: 
                            	  5416: 
                            	  5417: *-----------------------------------------------------------
                            	  5418: *-----------------------------------------------------------
                            	  5419: * OPCODE : ADDX
                            	  5420: *-----------------------------------------------------------
                            	  5421: *-----------------------------------------------------------
                            	  5422: 
                            	  5423: op_ADDX:
                            	  5424: 
                            	  5425: 
                            	  5426: *  * Register to Register
02:00003202 203CA5A5A5A5    	  5427:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003208 223C8167E123    	  5428:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:0000320E 243CA5A5A5A5    	  5429:                 move.l #$a5a5a5a5,d2
02:00003214 7600            	  5430:                 moveq  #$00000000,d3
02:00003216 7800            	  5431:                 moveq  #$00000000,d4       * Cumulative data results
02:00003218 7A00            	  5432:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000321A 7C1E            	  5433:                 move.l #$0000001E,d6       * Inner loop counter
02:0000321C 7E1E            	  5434:                 move.l #$0000001E,d7       * Outer loop counter
02:0000321E 307C0100        	  5435:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5436: 
                            	  5437: 
                            	  5438: ADDX_OUTER1:
                            	  5439: 
                            	  5440: *     BYTE
02:00003222 2002            	  5441:                 move.l d2,d0
02:00003224 D101            	  5442:                 addx.b d1,d0
02:00003226 40C3            	  5443:                 move.w sr,d3
02:00003228 02830000001F    	  5444:                 andi.l #$1F,d3            * Isolate flags
02:0000322E DA83            	  5445:                 add.l d3,d5               * Copy flag results into accumulator
02:00003230 D880            	  5446:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5447: 
                            	  5448: *     WORD
02:00003232 2002            	  5449:                 move.l d2,d0
02:00003234 D141            	  5450:                 addx.w d1,d0
02:00003236 40C3            	  5451:                 move.w sr,d3
02:00003238 02830000001F    	  5452:                 andi.l #$1F,d3            * Isolate flags
02:0000323E DA83            	  5453:                 add.l d3,d5               * Copy flag results into accumulator
02:00003240 D880            	  5454:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5455: 
                            	  5456: *     LONG
02:00003242 2002            	  5457:                 move.l d2,d0
02:00003244 D181            	  5458:                 addx.l d1,d0
02:00003246 40C3            	  5459:                 move.w sr,d3
02:00003248 02830000001F    	  5460:                 andi.l #$1F,d3            * Isolate flags
02:0000324E DA83            	  5461:                 add.l d3,d5               * Copy flag results into accumulator
02:00003250 D880            	  5462:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5463: 
02:00003252 E299            	  5464:                 ror.l #$1,d1
02:00003254 51CEFFCC        	  5465:                 dbf d6,ADDX_OUTER1
02:00003258 E29A            	  5466:                 ror.l #$1,d2
02:0000325A 223C8167E123    	  5467:                 move.l #$8167E123,d1       * Initial Data-Y
02:00003260 7C1E            	  5468:                 move.l #$0000001E,d6       * Inner loop counter
02:00003262 51CFFFBE        	  5469:                 dbf d7,ADDX_OUTER1
                            	  5470: 
02:00003266 0C844E96A4D9    	  5471:                 cmpi.l #$4E96A4D9,d4      * Check the data results
02:0000326C 66FE            	  5472:                 bne.s *
02:0000326E 0C85000085CD    	  5473:                 cmpi.l #$000085CD,d5      * Check the Flag results
02:00003274 66FE            	  5474:                 bne.s *
                            	  5475: 
                            	  5476: 
                            	  5477: 
                            	  5478: *     -(An),-(An)
                            	  5479: 
02:00003276 7000            	  5480:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
02:00003278 7200            	  5481:                 moveq  #$00000000,d1
02:0000327A 7400            	  5482:                 moveq  #$00000000,d2
02:0000327C 307C0100        	  5483:                 move.l #$00000100,a0       * Address for Data-X
02:00003280 327C0200        	  5484:                 move.l #$00000200,a1       * Address for Data-Y
02:00003284 20FC11FF5580    	  5485:                 move.l #$11FF5580,(a0)+   * Populate test data
02:0000328A 20FC1111FFFF    	  5486:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:00003290 20FC33333333    	  5487:                 move.l #$33333333,(a0)+   * Populate test data
02:00003296 20FC44444444    	  5488:                 move.l #$44444444,(a0)+   * Populate test data
02:0000329C 22FC80FF337F    	  5489:                 move.l #$80FF337F,(a1)+   * Populate test data
02:000032A2 22FCFFFF1111    	  5490:                 move.l #$FFFF1111,(a1)+   * Populate test data
02:000032A8 22FC33333333    	  5491:                 move.l #$33333333,(a1)+   * Populate test data
02:000032AE 22FC44444444    	  5492:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5493: 
                            	  5494: 
02:000032B4 7C0F            	  5495:                 move.l #$0000000F,d6       * Loop counter
                            	  5496: 
02:000032B6 D308            	  5497: ADDX_LOOP3:     addx.b -(a0),-(a1)
02:000032B8 40C3            	  5498:                 move.w sr,d3
02:000032BA 02830000000F    	  5499:                 andi.l #$0F,d3            * Isolate flags
02:000032C0 D083            	  5500:                 add.l d3,d0               * Copy flag results into accumulator
02:000032C2 D211            	  5501:                 add.b (a1),d1
02:000032C4 51CEFFF0        	  5502:                 dbf d6,ADDX_LOOP3
                            	  5503: 
                            	  5504: 
02:000032C8 307C0110        	  5505:                 move.l #$00000110,a0       * Address for Data-X
02:000032CC 327C0210        	  5506:                 move.l #$00000210,a1       * Address for Data-Y
02:000032D0 7C07            	  5507:                 moveq  #$00000007,d6       * Loop counter
                            	  5508: 
02:000032D2 D348            	  5509: ADDX_LOOP4:     addx.w -(a0),-(a1)
02:000032D4 40C3            	  5510:                 move.w sr,d3
02:000032D6 02830000000F    	  5511:                 andi.l #$0F,d3            * Isolate flags
02:000032DC D083            	  5512:                 add.l d3,d0               * Copy flag results into accumulator
02:000032DE D251            	  5513:                 add.w (a1),d1
02:000032E0 51CEFFF0        	  5514:                 dbf d6,ADDX_LOOP4
                            	  5515: 
                            	  5516: 
02:000032E4 307C0110        	  5517:                 move.l #$00000110,a0       * Address for Data-X
02:000032E8 327C0210        	  5518:                 move.l #$00000210,a1       * Address for Data-Y
02:000032EC 7C03            	  5519:                 moveq  #$00000003,d6       * Loop counter
                            	  5520: 
02:000032EE D388            	  5521: ADDX_LOOP5:     addx.l -(a0),-(a1)
02:000032F0 40C3            	  5522:                 move.w sr,d3
02:000032F2 02830000000F    	  5523:                 andi.l #$0F,d3            * Isolate flags
02:000032F8 D083            	  5524:                 add.l d3,d0               * Copy flag results into accumulator
02:000032FA D291            	  5525:                 add.l (a1),d1
02:000032FC 51CEFFF0        	  5526:                 dbf d6,ADDX_LOOP5
                            	  5527: 
                            	  5528: 
02:00003300 0C8000000095    	  5529:                 cmpi.l #$00000095,d0      * Check the flag results
02:00003306 66FE            	  5530:                 bne.s *
02:00003308 0C81C812A682    	  5531:                 cmpi.l #$C812A682,d1      * Check the data results
02:0000330E 66FE            	  5532:                 bne.s *
                            	  5533: 
02:00003310 4E75            	  5534:                 rts
                            	  5535: 
                            	  5536: 
                            	  5537: 
                            	  5538: 
                            	  5539: *-----------------------------------------------------------
                            	  5540: *-----------------------------------------------------------
                            	  5541: * OPCODE : SUBX
                            	  5542: *-----------------------------------------------------------
                            	  5543: *-----------------------------------------------------------
                            	  5544: 
                            	  5545: op_SUBX:
                            	  5546: 
                            	  5547: 
                            	  5548: *  * Register to Register
02:00003312 203CA5A5A5A5    	  5549:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
02:00003318 223C8167E123    	  5550:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
02:0000331E 243CA5A5A5A5    	  5551:                 move.l #$a5a5a5a5,d2
02:00003324 7600            	  5552:                 moveq  #$00000000,d3
02:00003326 7800            	  5553:                 moveq  #$00000000,d4       * Cumulative data results
02:00003328 7A00            	  5554:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000332A 7C1E            	  5555:                 move.l #$0000001E,d6       * Inner loop counter
02:0000332C 7E1E            	  5556:                 move.l #$0000001E,d7       * Outer loop counter
02:0000332E 307C0100        	  5557:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5558: 
                            	  5559: 
                            	  5560: SUBX_OUTER1:
                            	  5561: 
                            	  5562: *     BYTE
02:00003332 2002            	  5563:                 move.l d2,d0
02:00003334 9101            	  5564:                 subx.b d1,d0
02:00003336 40C3            	  5565:                 move.w sr,d3
02:00003338 02830000001F    	  5566:                 andi.l #$1F,d3            * Isolate flags
02:0000333E DA83            	  5567:                 add.l d3,d5               * Copy flag results into accumulator
02:00003340 D880            	  5568:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5569: 
                            	  5570: *     WORD
02:00003342 2002            	  5571:                 move.l d2,d0
02:00003344 9141            	  5572:                 subx.w d1,d0
02:00003346 40C3            	  5573:                 move.w sr,d3
02:00003348 02830000001F    	  5574:                 andi.l #$1F,d3            * Isolate flags
02:0000334E DA83            	  5575:                 add.l d3,d5               * Copy flag results into accumulator
02:00003350 D880            	  5576:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5577: 
                            	  5578: *     LONG
02:00003352 2002            	  5579:                 move.l d2,d0
02:00003354 9181            	  5580:                 subx.l d1,d0
02:00003356 40C3            	  5581:                 move.w sr,d3
02:00003358 02830000001F    	  5582:                 andi.l #$1F,d3            * Isolate flags
02:0000335E DA83            	  5583:                 add.l d3,d5               * Copy flag results into accumulator
02:00003360 D880            	  5584:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5585: 
02:00003362 E299            	  5586:                 ror.l #$1,d1
02:00003364 51CEFFCC        	  5587:                 dbf d6,SUBX_OUTER1
02:00003368 E29A            	  5588:                 ror.l #$1,d2
02:0000336A 223C8167E123    	  5589:                 move.l #$8167E123,d1       * Initial Data-Y
02:00003370 7C1E            	  5590:                 move.l #$0000001E,d6       * Inner loop counter
02:00003372 51CFFFBE        	  5591:                 dbf d7,SUBX_OUTER1
                            	  5592: 
02:00003376 0C84FCAA913E    	  5593:                 cmpi.l #$FCAA913E,d4      * Check the data results
02:0000337C 66FE            	  5594:                 bne.s *
02:0000337E 0C8500007E89    	  5595:                 cmpi.l #$00007E89,d5      * Check the Flag results
02:00003384 66FE            	  5596:                 bne.s *
                            	  5597: 
                            	  5598: 
                            	  5599: 
                            	  5600: *     -(An),-(An)
                            	  5601: 
02:00003386 7000            	  5602:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
02:00003388 7200            	  5603:                 moveq  #$00000000,d1
02:0000338A 7400            	  5604:                 moveq  #$00000000,d2
02:0000338C 307C0100        	  5605:                 move.l #$00000100,a0       * Address for Data-X
02:00003390 327C0200        	  5606:                 move.l #$00000200,a1       * Address for Data-Y
02:00003394 20FC11FF5580    	  5607:                 move.l #$11FF5580,(a0)+   * Populate test data
02:0000339A 20FC1111FFFF    	  5608:                 move.l #$1111FFFF,(a0)+   * Populate test data
02:000033A0 20FC80FF337F    	  5609:                 move.l #$80FF337F,(a0)+   * Populate test data
02:000033A6 20FC44444444    	  5610:                 move.l #$44444444,(a0)+   * Populate test data
02:000033AC 22FC80FF337F    	  5611:                 move.l #$80FF337F,(a1)+   * Populate test data
02:000033B2 22FC1111FFFF    	  5612:                 move.l #$1111FFFF,(a1)+   * Populate test data
02:000033B8 22FC33333333    	  5613:                 move.l #$33333333,(a1)+   * Populate test data
02:000033BE 22FC5580EECC    	  5614:                 move.l #$5580EECC,(a1)+   * Populate test data
                            	  5615: 
                            	  5616: 
02:000033C4 7C0F            	  5617:                 move.l #$0000000F,d6       * Loop counter
                            	  5618: 
02:000033C6 9308            	  5619: SUBX_LOOP3:     subx.b -(a0),-(a1)
02:000033C8 40C3            	  5620:                 move.w sr,d3
02:000033CA 02830000000F    	  5621:                 andi.l #$0F,d3            * Isolate flags
02:000033D0 D083            	  5622:                 add.l d3,d0               * Copy flag results into accumulator
02:000033D2 D211            	  5623:                 add.b (a1),d1
02:000033D4 51CEFFF0        	  5624:                 dbf d6,SUBX_LOOP3
                            	  5625: 
                            	  5626: 
02:000033D8 307C0110        	  5627:                 move.l #$00000110,a0       * Address for Data-X
02:000033DC 327C0210        	  5628:                 move.l #$00000210,a1       * Address for Data-Y
02:000033E0 7C07            	  5629:                 moveq  #$00000007,d6       * Loop counter
                            	  5630: 
02:000033E2 9348            	  5631: SUBX_LOOP4:     subx.w -(a0),-(a1)
02:000033E4 40C3            	  5632:                 move.w sr,d3
02:000033E6 02830000000F    	  5633:                 andi.l #$0F,d3            * Isolate flags
02:000033EC D083            	  5634:                 add.l d3,d0               * Copy flag results into accumulator
02:000033EE D251            	  5635:                 add.w (a1),d1
02:000033F0 51CEFFF0        	  5636:                 dbf d6,SUBX_LOOP4
                            	  5637: 
                            	  5638: 
02:000033F4 307C0110        	  5639:                 move.l #$00000110,a0       * Address for Data-X
02:000033F8 327C0210        	  5640:                 move.l #$00000210,a1       * Address for Data-Y
02:000033FC 7C03            	  5641:                 moveq  #$00000003,d6       * Loop counter
                            	  5642: 
02:000033FE 9388            	  5643: SUBX_LOOP5:     subx.l -(a0),-(a1)
02:00003400 40C3            	  5644:                 move.w sr,d3
02:00003402 02830000000F    	  5645:                 andi.l #$0F,d3            * Isolate flags
02:00003408 D083            	  5646:                 add.l d3,d0               * Copy flag results into accumulator
02:0000340A D291            	  5647:                 add.l (a1),d1
02:0000340C 51CEFFF0        	  5648:                 dbf d6,SUBX_LOOP5
                            	  5649: 
                            	  5650: 
02:00003410 0C80000000B1    	  5651:                 cmpi.l #$000000B1,d0      * Check the flag results
02:00003416 66FE            	  5652:                 bne.s *
02:00003418 0C8162C6F417    	  5653:                 cmpi.l #$62C6F417,d1      * Check the data results
02:0000341E 66FE            	  5654:                 bne.s *
                            	  5655: 
02:00003420 4E75            	  5656:                 rts
                            	  5657: 
                            	  5658: 
                            	  5659: *-----------------------------------------------------------
                            	  5660: *-----------------------------------------------------------
                            	  5661: * OPCODE : MULU
                            	  5662: *-----------------------------------------------------------
                            	  5663: *-----------------------------------------------------------
                            	  5664: 
                            	  5665: op_MULU:
                            	  5666: 
02:00003422 203CFE805501    	  5667:                 move.l #$FE805501,d0        * Initial
02:00003428 223C5697EDB6    	  5668:                 move.l #$5697EDB6,d1        * Initial Y
02:0000342E 243CFE805501    	  5669:                 move.l #$FE805501,d2
02:00003434 7600            	  5670:                 moveq  #$00000000,d3
02:00003436 7800            	  5671:                 moveq  #$00000000,d4        * Cumulative data results
02:00003438 7A00            	  5672:                 moveq  #$00000000,d5       * Cumulative flag results
02:0000343A 7C0E            	  5673:                 move.l #$0000000E,d6       * Inner loop counter
02:0000343C 7E0E            	  5674:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5675: 
                            	  5676: 
02:0000343E C0C1            	  5677: MULU_OUTER1:    mulu d1,d0
02:00003440 40C3            	  5678:                 move.w sr,d3
02:00003442 02830000000C    	  5679:                 andi.l #$0C,d3            * Isolate flags
02:00003448 DA83            	  5680:                 add.l d3,d5               * Copy flag results into accumulator
02:0000344A D880            	  5681:                 add.l d0,d4               * Copy data results into data accumulator
02:0000344C E299            	  5682:                 ror.l #$1,d1
                            	  5683: 
02:0000344E 51CEFFEE        	  5684:                 dbf d6,MULU_OUTER1
02:00003452 E29A            	  5685:                 ror.l #$1,d2
02:00003454 2002            	  5686:                 move.l d2,d0
02:00003456 7C0E            	  5687:                 move.l #$0000000E,d6       * Inner loop counter
02:00003458 51CFFFE4        	  5688:                 dbf d7,MULU_OUTER1
                            	  5689: 
02:0000345C 0C8476FB988C    	  5690:                 cmpi.l #$76FB988C,d4      * Check the data results
02:00003462 66FE            	  5691:                 bne.s *
                            	  5692: 
02:00003464 0C8500000170    	  5693:                 cmpi.l #$00000170,d5      * Check the Flag results
02:0000346A 66FE            	  5694:                 bne.s *
                            	  5695: 
                            	  5696: 
02:0000346C 4E75            	  5697:                 rts
                            	  5698: 
                            	  5699: 
                            	  5700: *-----------------------------------------------------------
                            	  5701: *-----------------------------------------------------------
                            	  5702: * OPCODE : MULS
                            	  5703: *-----------------------------------------------------------
                            	  5704: *-----------------------------------------------------------
                            	  5705: 
                            	  5706: op_MULS:
                            	  5707: 
02:0000346E 203CFE805501    	  5708:                 move.l #$FE805501,d0        * Initial
02:00003474 223C5697EDB6    	  5709:                 move.l #$5697EDB6,d1        * Initial Y
02:0000347A 243CFE805501    	  5710:                 move.l #$FE805501,d2
02:00003480 7600            	  5711:                 moveq  #$00000000,d3
02:00003482 7800            	  5712:                 moveq  #$00000000,d4        * Cumulative data results
02:00003484 7A00            	  5713:                 moveq  #$00000000,d5       * Cumulative flag results
02:00003486 7C0E            	  5714:                 move.l #$0000000E,d6       * Inner loop counter
02:00003488 7E0E            	  5715:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5716: 
                            	  5717: 
02:0000348A C1C1            	  5718: MULS_OUTER1:    muls d1,d0
02:0000348C 40C3            	  5719:                 move.w sr,d3
02:0000348E 02830000000C    	  5720:                 andi.l #$0C,d3            * Isolate flags
02:00003494 DA83            	  5721:                 add.l d3,d5               * Copy flag results into accumulator
02:00003496 D880            	  5722:                 add.l d0,d4               * Copy data results into data accumulator
02:00003498 E299            	  5723:                 ror.l #$1,d1
                            	  5724: 
02:0000349A 51CEFFEE        	  5725:                 dbf d6,MULS_OUTER1
02:0000349E E29A            	  5726:                 ror.l #$1,d2
02:000034A0 2002            	  5727:                 move.l d2,d0
02:000034A2 7C0E            	  5728:                 move.l #$0000000E,d6       * Inner loop counter
02:000034A4 51CFFFE4        	  5729:                 dbf d7,MULS_OUTER1
                            	  5730: 
02:000034A8 0C84D4E2988C    	  5731:                 cmpi.l #$D4E2988C,d4      * Check the data results
02:000034AE 66FE            	  5732:                 bne.s *
                            	  5733: 
02:000034B0 0C85000003E0    	  5734:                 cmpi.l #$000003E0,d5      * Check the Flag results
02:000034B6 66FE            	  5735:                 bne.s *
                            	  5736: 
                            	  5737: 
02:000034B8 4E75            	  5738:                 rts
                            	  5739: 
                            	  5740: 
                            	  5741: 
                            	  5742: *-----------------------------------------------------------
                            	  5743: *-----------------------------------------------------------
                            	  5744: * OPCODE : EXG
                            	  5745: *-----------------------------------------------------------
                            	  5746: *-----------------------------------------------------------
                            	  5747: 
                            	  5748: op_EXG:
02:000034BA 223CD1D1D1D1    	  5749:                 move.l #$d1d1d1d1,d1
02:000034C0 243CD2D2D2D2    	  5750:                 move.l #$d2d2d2d2,d2
02:000034C6 263CD3D3D3D3    	  5751:                 move.l #$d3d3d3d3,d3
02:000034CC 227CA1A1A1A1    	  5752:                 move.l #$a1a1a1a1,a1
02:000034D2 247CA2A2A2A2    	  5753:                 move.l #$a2a2a2a2,a2
02:000034D8 267CA3A3A3A3    	  5754:                 move.l #$a3a3a3a3,a3
                            	  5755: 
02:000034DE C342            	  5756:                 exg d1,d2
02:000034E0 C34A            	  5757:                 exg a1,a2
02:000034E2 C78B            	  5758:                 exg d3,a3
                            	  5759: 
02:000034E4 0C81D2D2D2D2    	  5760:                 cmpi.l #$d2d2d2d2,d1      * Check the results
02:000034EA 66FE            	  5761:                 bne.s *
02:000034EC 0C82D1D1D1D1    	  5762:                 cmpi.l #$d1d1d1d1,d2
02:000034F2 66FE            	  5763:                 bne.s *
02:000034F4 0C83A3A3A3A3    	  5764:                 cmpi.l #$a3a3a3a3,d3
02:000034FA 66FE            	  5765:                 bne.s *
                            	  5766: 
02:000034FC 2209            	  5767:                 move.l a1,d1
02:000034FE 240A            	  5768:                 move.l a2,d2
02:00003500 260B            	  5769:                 move.l a3,d3
                            	  5770: 
02:00003502 0C81A2A2A2A2    	  5771:                 cmpi.l #$a2a2a2a2,d1
02:00003508 66FE            	  5772:                 bne.s *
02:0000350A 0C82A1A1A1A1    	  5773:                 cmpi.l #$a1a1a1a1,d2
02:00003510 66FE            	  5774:                 bne.s *
02:00003512 0C83D3D3D3D3    	  5775:                 cmpi.l #$d3d3d3d3,d3
02:00003518 66FE            	  5776:                 bne.s *
                            	  5777: 
02:0000351A 4E75            	  5778:                 rts
                            	  5779: 
                            	  5780: 
                            	  5781: *-----------------------------------------------------------
                            	  5782: *-----------------------------------------------------------
                            	  5783: * OPCODE : ROx
                            	  5784: *-----------------------------------------------------------
                            	  5785: *-----------------------------------------------------------
                            	  5786: 
                            	  5787: *     Subroutine to check and accumulate the flags
02:0000351C 40C3            	  5788: ROx_FLAGS:      move.w sr,d3
02:0000351E 02830000000F    	  5789:                 andi.l #$0F,d3            * Isolate flags
02:00003524 DA83            	  5790:                 add.l d3,d5               * Copy flag results into accumulator
02:00003526 4E75            	  5791:                 rts
                            	  5792: 
                            	  5793: op_ROx:
                            	  5794: 
                            	  5795: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  5796: 
                            	  5797: *        BYTE LEFT
02:00003528 203C80018FF1    	  5798:                 move.l #$80018FF1,d0
02:0000352E 7A00            	  5799:                 moveq  #$00000000,d5
02:00003530 7C11            	  5800:                 moveq  #$00000011,d6
                            	  5801: ROx_LOOP1:
02:00003532 ED38            	  5802:                 rol.b d6,d0
02:00003534 61E6            	  5803:                 bsr ROx_FLAGS
02:00003536 51CEFFFA        	  5804:                 dbf d6,ROx_LOOP1
02:0000353A 0C8080018FE3    	  5805:                 cmpi.l #$80018FE3,d0
02:00003540 66FE            	  5806:                 bne.s *
02:00003542 0C850000006B    	  5807:                 cmpi.l #$0000006B,d5
02:00003548 66FE            	  5808:                 bne.s *
                            	  5809: 
                            	  5810: *        BYTE RIGHT
02:0000354A 203C80018FF1    	  5811:                 move.l #$80018FF1,d0
02:00003550 7C12            	  5812:                 moveq  #$00000012,d6
                            	  5813: ROx_LOOP2:
02:00003552 EC38            	  5814:                 ror.b d6,d0
02:00003554 61C6            	  5815:                 bsr ROx_FLAGS
02:00003556 51CEFFFA        	  5816:                 dbf d6,ROx_LOOP2
02:0000355A 0C8080018F3E    	  5817:                 cmpi.l #$80018F3E,d0
02:00003560 66FE            	  5818:                 bne.s *
02:00003562 0C85000000C5    	  5819:                 cmpi.l #$000000C5,d5
02:00003568 66FE            	  5820:                 bne.s *
                            	  5821: 
                            	  5822: 
                            	  5823: *        WORD LEFT
02:0000356A 203C80018FF1    	  5824:                 move.l #$80018FF1,d0
02:00003570 7C13            	  5825:                 moveq  #$00000013,d6
                            	  5826: ROx_LOOP3:
02:00003572 ED78            	  5827:                 rol.w d6,d0
02:00003574 61A6            	  5828:                 bsr ROx_FLAGS
02:00003576 51CEFFFA        	  5829:                 dbf d6,ROx_LOOP3
02:0000357A 0C80800163FC    	  5830:                 cmpi.l #$800163FC,d0
02:00003580 66FE            	  5831:                 bne.s *
02:00003582 0C8500000131    	  5832:                 cmpi.l #$00000131,d5
02:00003588 66FE            	  5833:                 bne.s *
                            	  5834: 
                            	  5835: *        WORD RIGHT
02:0000358A 203C80018FF1    	  5836:                 move.l #$80018FF1,d0
02:00003590 7C1E            	  5837:                 move.l #$0000001E,d6
                            	  5838: ROx_LOOP4:
02:00003592 EC78            	  5839:                 ror.w d6,d0
02:00003594 6186            	  5840:                 bsr ROx_FLAGS
02:00003596 51CEFFFA        	  5841:                 dbf d6,ROx_LOOP4
02:0000359A 0C808001C7F8    	  5842:                 cmpi.l #$8001C7F8,d0
02:000035A0 66FE            	  5843:                 bne.s *
02:000035A2 0C85000001DB    	  5844:                 cmpi.l #$000001DB,d5
02:000035A8 66FE            	  5845:                 bne.s *
                            	  5846: 
                            	  5847: 
                            	  5848: *        LONG LEFT
02:000035AA 203C80018FF1    	  5849:                 move.l #$80018FF1,d0
02:000035B0 7C15            	  5850:                 moveq  #$00000015,d6
                            	  5851: ROx_LOOP5:
02:000035B2 EDB8            	  5852:                 rol.l d6,d0
02:000035B4 6100FF66        	  5853:                 bsr ROx_FLAGS
02:000035B8 51CEFFF8        	  5854:                 dbf d6,ROx_LOOP5
02:000035BC 0C8000C7F8C0    	  5855:                 cmpi.l #$00C7F8C0,d0
02:000035C2 66FE            	  5856:                 bne.s *
02:000035C4 0C850000021A    	  5857:                 cmpi.l #$0000021A,d5
02:000035CA 66FE            	  5858:                 bne.s *
                            	  5859: 
                            	  5860: *        LONG RIGHT
02:000035CC 203C80018FF1    	  5861:                 move.l #$80018FF1,d0
02:000035D2 7C16            	  5862:                 moveq  #$00000016,d6
                            	  5863: ROx_LOOP6:
02:000035D4 ECB8            	  5864:                 ror.l d6,d0
02:000035D6 6100FF44        	  5865:                 bsr ROx_FLAGS
02:000035DA 51CEFFF8        	  5866:                 dbf d6,ROx_LOOP6
02:000035DE 0C80000C7F8C    	  5867:                 cmpi.l #$000C7F8C,d0
02:000035E4 66FE            	  5868:                 bne.s *
02:000035E6 0C8500000250    	  5869:                 cmpi.l #$00000250,d5
02:000035EC 66FE            	  5870:                 bne.s *
                            	  5871: 
                            	  5872: 
                            	  5873: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  5874: 
02:000035EE 203C80018FF1    	  5875:                 move.l #$80018FF1,d0
02:000035F4 7A00            	  5876:                 moveq  #$00000000,d5
                            	  5877: 
                            	  5878: *        BYTE LEFT
02:000035F6 E318            	  5879:                 rol.b #1,d0
02:000035F8 6100FF22        	  5880:                 bsr ROx_FLAGS
02:000035FC EB18            	  5881:                 rol.b #5,d0
02:000035FE 6100FF1C        	  5882:                 bsr ROx_FLAGS
02:00003602 EF18            	  5883:                 rol.b #7,d0
02:00003604 6100FF16        	  5884:                 bsr ROx_FLAGS
02:00003608 E118            	  5885:                 rol.b #8,d0
02:0000360A 6100FF10        	  5886:                 bsr ROx_FLAGS
02:0000360E 0C8080018F3E    	  5887:                 cmpi.l #$80018F3E,d0
02:00003614 66FE            	  5888:                 bne.s *
02:00003616 0C8500000009    	  5889:                 cmpi.l #$00000009,d5
02:0000361C 66FE            	  5890:                 bne.s *
                            	  5891: 
                            	  5892: *        BYTE RIGHT
02:0000361E E218            	  5893:                 ror.b #1,d0
02:00003620 6100FEFA        	  5894:                 bsr ROx_FLAGS
02:00003624 EA18            	  5895:                 ror.b #5,d0
02:00003626 6100FEF4        	  5896:                 bsr ROx_FLAGS
02:0000362A EE18            	  5897:                 ror.b #7,d0
02:0000362C 6100FEEE        	  5898:                 bsr ROx_FLAGS
02:00003630 E018            	  5899:                 ror.b #8,d0
02:00003632 6100FEE8        	  5900:                 bsr ROx_FLAGS
02:00003636 0C8080018FF1    	  5901:                 cmpi.l #$80018FF1,d0
02:0000363C 66FE            	  5902:                 bne.s *
02:0000363E 0C8500000024    	  5903:                 cmpi.l #$00000024,d5
02:00003644 66FE            	  5904:                 bne.s *
                            	  5905: 
                            	  5906: *        WORD LEFT
02:00003646 E358            	  5907:                 rol.w #1,d0
02:00003648 6100FED2        	  5908:                 bsr ROx_FLAGS
02:0000364C EB58            	  5909:                 rol.w #5,d0
02:0000364E 6100FECC        	  5910:                 bsr ROx_FLAGS
02:00003652 EF58            	  5911:                 rol.w #7,d0
02:00003654 6100FEC6        	  5912:                 bsr ROx_FLAGS
02:00003658 E158            	  5913:                 rol.w #8,d0
02:0000365A 6100FEC0        	  5914:                 bsr ROx_FLAGS
02:0000365E 0C808001FE31    	  5915:                 cmpi.l #$8001FE31,d0
02:00003664 66FE            	  5916:                 bne.s *
02:00003666 0C8500000037    	  5917:                 cmpi.l #$00000037,d5
02:0000366C 66FE            	  5918:                 bne.s *
                            	  5919: 
                            	  5920: *        WORD RIGHT
02:0000366E E258            	  5921:                 ror.w #1,d0
02:00003670 6100FEAA        	  5922:                 bsr ROx_FLAGS
02:00003674 EA58            	  5923:                 ror.w #5,d0
02:00003676 6100FEA4        	  5924:                 bsr ROx_FLAGS
02:0000367A EE58            	  5925:                 ror.w #7,d0
02:0000367C 6100FE9E        	  5926:                 bsr ROx_FLAGS
02:00003680 E058            	  5927:                 ror.w #8,d0
02:00003682 6100FE98        	  5928:                 bsr ROx_FLAGS
02:00003686 0C8080018FF1    	  5929:                 cmpi.l #$80018FF1,d0
02:0000368C 66FE            	  5930:                 bne.s *
02:0000368E 0C850000005B    	  5931:                 cmpi.l #$0000005B,d5
02:00003694 66FE            	  5932:                 bne.s *
                            	  5933: 
                            	  5934: *        LONG LEFT
02:00003696 E398            	  5935:                 rol.l #1,d0
02:00003698 6100FE82        	  5936:                 bsr ROx_FLAGS
02:0000369C EB98            	  5937:                 rol.l #5,d0
02:0000369E 6100FE7C        	  5938:                 bsr ROx_FLAGS
02:000036A2 EF98            	  5939:                 rol.l #7,d0
02:000036A4 6100FE76        	  5940:                 bsr ROx_FLAGS
02:000036A8 E198            	  5941:                 rol.l #8,d0
02:000036AA 6100FE70        	  5942:                 bsr ROx_FLAGS
02:000036AE 0C80FE300031    	  5943:                 cmpi.l #$FE300031,d0
02:000036B4 66FE            	  5944:                 bne.s *
02:000036B6 0C8500000065    	  5945:                 cmpi.l #$00000065,d5
02:000036BC 66FE            	  5946:                 bne.s *
                            	  5947: 
                            	  5948: *        LONG RIGHT
02:000036BE E298            	  5949:                 ror.l #1,d0
02:000036C0 6100FE5A        	  5950:                 bsr ROx_FLAGS
02:000036C4 EA98            	  5951:                 ror.l #5,d0
02:000036C6 6100FE54        	  5952:                 bsr ROx_FLAGS
02:000036CA EE98            	  5953:                 ror.l #7,d0
02:000036CC 6100FE4E        	  5954:                 bsr ROx_FLAGS
02:000036D0 E098            	  5955:                 ror.l #8,d0
02:000036D2 6100FE48        	  5956:                 bsr ROx_FLAGS
02:000036D6 0C8080018FF1    	  5957:                 cmpi.l #$80018FF1,d0
02:000036DC 66FE            	  5958:                 bne.s *
02:000036DE 0C8500000080    	  5959:                 cmpi.l #$00000080,d5
02:000036E4 66FE            	  5960:                 bne.s *
                            	  5961: 
                            	  5962: 
                            	  5963: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  5964: 
02:000036E6 7A00            	  5965:                 moveq  #$00000000,d5
02:000036E8 307C0100        	  5966:                 move.l #$00000100,a0
02:000036EC 30BC8FF1        	  5967:                 move.w #$8FF1,(a0)
                            	  5968: 
                            	  5969: *        WORD LEFT
02:000036F0 E7D0            	  5970:                 rol (a0)
02:000036F2 6100FE28        	  5971:                 bsr ROx_FLAGS
02:000036F6 E7D0            	  5972:                 rol (a0)
02:000036F8 6100FE22        	  5973:                 bsr ROx_FLAGS
02:000036FC E7D0            	  5974:                 rol (a0)
02:000036FE 6100FE1C        	  5975:                 bsr ROx_FLAGS
02:00003702 E7D0            	  5976:                 rol (a0)
02:00003704 6100FE16        	  5977:                 bsr ROx_FLAGS
02:00003708 3010            	  5978:                 move.w (a0),d0
02:0000370A 0C808001FF18    	  5979:                 cmpi.l #$8001FF18,d0
02:00003710 66FE            	  5980:                 bne.s *
02:00003712 0C8500000009    	  5981:                 cmpi.l #$00000009,d5
02:00003718 66FE            	  5982:                 bne.s *
                            	  5983: 
                            	  5984: *        WORD RIGHT
02:0000371A E6D0            	  5985:                 ror (a0)
02:0000371C 6100FDFE        	  5986:                 bsr ROx_FLAGS
02:00003720 E6D0            	  5987:                 ror (a0)
02:00003722 6100FDF8        	  5988:                 bsr ROx_FLAGS
02:00003726 E6D0            	  5989:                 ror (a0)
02:00003728 6100FDF2        	  5990:                 bsr ROx_FLAGS
02:0000372C E6D0            	  5991:                 ror (a0)
02:0000372E 6100FDEC        	  5992:                 bsr ROx_FLAGS
02:00003732 E6D0            	  5993:                 ror (a0)
02:00003734 6100FDE6        	  5994:                 bsr ROx_FLAGS
02:00003738 E6D0            	  5995:                 ror (a0)
02:0000373A 6100FDE0        	  5996:                 bsr ROx_FLAGS
02:0000373E 3010            	  5997:                 move.w (a0),d0
02:00003740 0C80800163FC    	  5998:                 cmpi.l #$800163FC,d0
02:00003746 66FE            	  5999:                 bne.s *
02:00003748 0C850000001B    	  6000:                 cmpi.l #$0000001B,d5
02:0000374E 66FE            	  6001:                 bne.s *
                            	  6002: 
02:00003750 4E75            	  6003:                 rts
                            	  6004: 
                            	  6005: 
                            	  6006: 
                            	  6007: *-----------------------------------------------------------
                            	  6008: *-----------------------------------------------------------
                            	  6009: * OPCODE : ROXx
                            	  6010: *-----------------------------------------------------------
                            	  6011: *-----------------------------------------------------------
                            	  6012: 
                            	  6013: *     Subroutine to check and accumulate the flags
02:00003752 40C3            	  6014: ROXx_FLAGS:     move.w sr,d3
02:00003754 02830000000F    	  6015:                 andi.l #$0F,d3            * Isolate flags
02:0000375A DA83            	  6016:                 add.l d3,d5               * Copy flag results into accumulator
02:0000375C 4E75            	  6017:                 rts
                            	  6018: 
                            	  6019: op_ROXx:
                            	  6020: 
                            	  6021: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6022: 
                            	  6023: *        BYTE LEFT
02:0000375E 203C80018FF1    	  6024:                 move.l #$80018FF1,d0
02:00003764 7A00            	  6025:                 moveq  #$00000000,d5
02:00003766 7C11            	  6026:                 moveq  #$00000011,d6
                            	  6027: ROXx_LOOP1:
02:00003768 ED30            	  6028:                 roxl.b d6,d0
02:0000376A 61E6            	  6029:                 bsr ROXx_FLAGS
02:0000376C 51CEFFFA        	  6030:                 dbf d6,ROXx_LOOP1
02:00003770 0C8080018FD0    	  6031:                 cmpi.l #$80018FD0,d0
02:00003776 66FE            	  6032:                 bne.s *
02:00003778 0C8500000042    	  6033:                 cmpi.l #$00000042,d5
02:0000377E 66FE            	  6034:                 bne.s *
                            	  6035: 
                            	  6036: *        BYTE RIGHT
02:00003780 203C80018FF1    	  6037:                 move.l #$80018FF1,d0
02:00003786 7C12            	  6038:                 moveq  #$00000012,d6
                            	  6039: ROXx_LOOP2:
02:00003788 EC30            	  6040:                 roxr.b d6,d0
02:0000378A 61C6            	  6041:                 bsr ROXx_FLAGS
02:0000378C 51CEFFFA        	  6042:                 dbf d6,ROXx_LOOP2
02:00003790 0C8080018F51    	  6043:                 cmpi.l #$80018F51,d0
02:00003796 66FE            	  6044:                 bne.s *
02:00003798 0C850000009C    	  6045:                 cmpi.l #$0000009C,d5
02:0000379E 66FE            	  6046:                 bne.s *
                            	  6047: 
                            	  6048: 
                            	  6049: *        WORD LEFT
02:000037A0 203C80018FF1    	  6050:                 move.l #$80018FF1,d0
02:000037A6 7C13            	  6051:                 moveq  #$00000013,d6
                            	  6052: ROXx_LOOP3:
02:000037A8 ED70            	  6053:                 roxl.w d6,d0
02:000037AA 61A6            	  6054:                 bsr ROXx_FLAGS
02:000037AC 51CEFFFA        	  6055:                 dbf d6,ROXx_LOOP3
02:000037B0 0C8080013980    	  6056:                 cmpi.l #$80013980,d0
02:000037B6 66FE            	  6057:                 bne.s *
02:000037B8 0C85000000C9    	  6058:                 cmpi.l #$000000C9,d5
02:000037BE 66FE            	  6059:                 bne.s *
                            	  6060: 
                            	  6061: *        WORD RIGHT
02:000037C0 203C80018FF1    	  6062:                 move.l #$80018FF1,d0
02:000037C6 7C1E            	  6063:                 move.l #$0000001E,d6
                            	  6064: ROXx_LOOP4:
02:000037C8 EC70            	  6065:                 roxr.w d6,d0
02:000037CA 6186            	  6066:                 bsr ROXx_FLAGS
02:000037CC 51CEFFFA        	  6067:                 dbf d6,ROXx_LOOP4
02:000037D0 0C8080010A1D    	  6068:                 cmpi.l #$80010A1D,d0
02:000037D6 66FE            	  6069:                 bne.s *
02:000037D8 0C850000014D    	  6070:                 cmpi.l #$0000014D,d5
02:000037DE 66FE            	  6071:                 bne.s *
                            	  6072: 
                            	  6073: 
                            	  6074: *        LONG LEFT
02:000037E0 203C80018FF1    	  6075:                 move.l #$80018FF1,d0
02:000037E6 7C15            	  6076:                 moveq  #$00000015,d6
                            	  6077: ROXx_LOOP5:
02:000037E8 EDB0            	  6078:                 roxl.l d6,d0
02:000037EA 6100FF66        	  6079:                 bsr ROXx_FLAGS
02:000037EE 51CEFFF8        	  6080:                 dbf d6,ROXx_LOOP5
02:000037F2 0C80800185D0    	  6081:                 cmpi.l #$800185D0,d0
02:000037F8 66FE            	  6082:                 bne.s *
02:000037FA 0C85000001A1    	  6083:                 cmpi.l #$000001A1,d5
02:00003800 66FE            	  6084:                 bne.s *
                            	  6085: 
                            	  6086: *        LONG RIGHT
02:00003802 203C80018FF1    	  6087:                 move.l #$80018FF1,d0
02:00003808 7C16            	  6088:                 moveq  #$00000016,d6
                            	  6089: ROXx_LOOP6:
02:0000380A ECB0            	  6090:                 roxr.l d6,d0
02:0000380C 6100FF44        	  6091:                 bsr ROXx_FLAGS
02:00003810 51CEFFF8        	  6092:                 dbf d6,ROXx_LOOP6
02:00003814 0C80082D8200    	  6093:                 cmpi.l #$082D8200,d0
02:0000381A 66FE            	  6094:                 bne.s *
02:0000381C 0C85000001DE    	  6095:                 cmpi.l #$000001DE,d5
02:00003822 66FE            	  6096:                 bne.s *
                            	  6097: 
                            	  6098: 
                            	  6099: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6100: 
02:00003824 203C80018FF1    	  6101:                 move.l #$80018FF1,d0
02:0000382A 7A00            	  6102:                 moveq  #$00000000,d5
                            	  6103: 
                            	  6104: *        BYTE LEFT
02:0000382C E310            	  6105:                 roxl.b #1,d0
02:0000382E 6100FF22        	  6106:                 bsr ROXx_FLAGS
02:00003832 EB10            	  6107:                 roxl.b #5,d0
02:00003834 6100FF1C        	  6108:                 bsr ROXx_FLAGS
02:00003838 EF10            	  6109:                 roxl.b #7,d0
02:0000383A 6100FF16        	  6110:                 bsr ROXx_FLAGS
02:0000383E E110            	  6111:                 roxl.b #8,d0
02:00003840 6100FF10        	  6112:                 bsr ROXx_FLAGS
02:00003844 0C8080018F09    	  6113:                 cmpi.l #$80018F09,d0
02:0000384A 66FE            	  6114:                 bne.s *
02:0000384C 0C850000000B    	  6115:                 cmpi.l #$0000000B,d5
02:00003852 66FE            	  6116:                 bne.s *
                            	  6117: 
                            	  6118: *        BYTE RIGHT
02:00003854 E210            	  6119:                 roxr.b #1,d0
02:00003856 6100FEFA        	  6120:                 bsr ROXx_FLAGS
02:0000385A EA10            	  6121:                 roxr.b #5,d0
02:0000385C 6100FEF4        	  6122:                 bsr ROXx_FLAGS
02:00003860 EE10            	  6123:                 roxr.b #7,d0
02:00003862 6100FEEE        	  6124:                 bsr ROXx_FLAGS
02:00003866 E010            	  6125:                 roxr.b #8,d0
02:00003868 6100FEE8        	  6126:                 bsr ROXx_FLAGS
02:0000386C 0C8080018F00    	  6127:                 cmpi.l #$80018F00,d0
02:00003872 66FE            	  6128:                 bne.s *
02:00003874 0C8500000015    	  6129:                 cmpi.l #$00000015,d5
02:0000387A 66FE            	  6130:                 bne.s *
                            	  6131: 
                            	  6132: *        WORD LEFT
02:0000387C E350            	  6133:                 roxl.w #1,d0
02:0000387E 6100FED2        	  6134:                 bsr ROXx_FLAGS
02:00003882 EB50            	  6135:                 roxl.w #5,d0
02:00003884 6100FECC        	  6136:                 bsr ROXx_FLAGS
02:00003888 EF50            	  6137:                 roxl.w #7,d0
02:0000388A 6100FEC6        	  6138:                 bsr ROXx_FLAGS
02:0000388E E150            	  6139:                 roxl.w #8,d0
02:00003890 6100FEC0        	  6140:                 bsr ROXx_FLAGS
02:00003894 0C808001B000    	  6141:                 cmpi.l #$8001B000,d0
02:0000389A 66FE            	  6142:                 bne.s *
02:0000389C 0C8500000027    	  6143:                 cmpi.l #$00000027,d5
02:000038A2 66FE            	  6144:                 bne.s *
                            	  6145: 
                            	  6146: *        WORD RIGHT
02:000038A4 E250            	  6147:                 roxr.w #1,d0
02:000038A6 6100FEAA        	  6148:                 bsr ROXx_FLAGS
02:000038AA EA50            	  6149:                 roxr.w #5,d0
02:000038AC 6100FEA4        	  6150:                 bsr ROXx_FLAGS
02:000038B0 EE50            	  6151:                 roxr.w #7,d0
02:000038B2 6100FE9E        	  6152:                 bsr ROXx_FLAGS
02:000038B6 E050            	  6153:                 roxr.w #8,d0
02:000038B8 6100FE98        	  6154:                 bsr ROXx_FLAGS
02:000038BC 0C8080010A00    	  6155:                 cmpi.l #$80010A00,d0
02:000038C2 66FE            	  6156:                 bne.s *
02:000038C4 0C8500000028    	  6157:                 cmpi.l #$00000028,d5
02:000038CA 66FE            	  6158:                 bne.s *
                            	  6159: 
                            	  6160: *        LONG LEFT
02:000038CC E390            	  6161:                 roxl.l #1,d0
02:000038CE 6100FE82        	  6162:                 bsr ROXx_FLAGS
02:000038D2 EB90            	  6163:                 roxl.l #5,d0
02:000038D4 6100FE7C        	  6164:                 bsr ROXx_FLAGS
02:000038D8 EF90            	  6165:                 roxl.l #7,d0
02:000038DA 6100FE76        	  6166:                 bsr ROXx_FLAGS
02:000038DE E190            	  6167:                 roxl.l #8,d0
02:000038E0 6100FE70        	  6168:                 bsr ROXx_FLAGS
02:000038E4 0C8040000010    	  6169:                 cmpi.l #$40000010,d0
02:000038EA 66FE            	  6170:                 bne.s *
02:000038EC 0C850000002A    	  6171:                 cmpi.l #$0000002A,d5
02:000038F2 66FE            	  6172:                 bne.s *
                            	  6173: 
                            	  6174: *        LONG RIGHT
02:000038F4 E290            	  6175:                 roxr.l #1,d0
02:000038F6 6100FE5A        	  6176:                 bsr ROXx_FLAGS
02:000038FA EA90            	  6177:                 roxr.l #5,d0
02:000038FC 6100FE54        	  6178:                 bsr ROXx_FLAGS
02:00003900 EE90            	  6179:                 roxr.l #7,d0
02:00003902 6100FE4E        	  6180:                 bsr ROXx_FLAGS
02:00003906 E090            	  6181:                 roxr.l #8,d0
02:00003908 6100FE48        	  6182:                 bsr ROXx_FLAGS
02:0000390C 0C8000010200    	  6183:                 cmpi.l #$00010200,d0
02:00003912 66FE            	  6184:                 bne.s *
02:00003914 0C8500000032    	  6185:                 cmpi.l #$00000032,d5
02:0000391A 66FE            	  6186:                 bne.s *
                            	  6187: 
                            	  6188: 
                            	  6189: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6190: 
02:0000391C 7A00            	  6191:                 moveq  #$00000000,d5
02:0000391E 307C0100        	  6192:                 move.l #$00000100,a0
02:00003922 30BC8FF1        	  6193:                 move.w #$8FF1,(a0)
                            	  6194: 
                            	  6195: *        WORD LEFT
02:00003926 E5D0            	  6196:                 roxl (a0)
02:00003928 6100FE28        	  6197:                 bsr ROXx_FLAGS
02:0000392C E5D0            	  6198:                 roxl (a0)
02:0000392E 6100FE22        	  6199:                 bsr ROXx_FLAGS
02:00003932 E5D0            	  6200:                 roxl (a0)
02:00003934 6100FE1C        	  6201:                 bsr ROXx_FLAGS
02:00003938 E5D0            	  6202:                 roxl (a0)
02:0000393A 6100FE16        	  6203:                 bsr ROXx_FLAGS
02:0000393E 3010            	  6204:                 move.w (a0),d0
02:00003940 0C800001FF10    	  6205:                 cmpi.l #$0001FF10,d0
02:00003946 66FE            	  6206:                 bne.s *
02:00003948 0C8500000009    	  6207:                 cmpi.l #$00000009,d5
02:0000394E 66FE            	  6208:                 bne.s *
                            	  6209: 
                            	  6210: *        WORD RIGHT
02:00003950 E4D0            	  6211:                 roxr (a0)
02:00003952 6100FDFE        	  6212:                 bsr ROXx_FLAGS
02:00003956 E4D0            	  6213:                 roxr (a0)
02:00003958 6100FDF8        	  6214:                 bsr ROXx_FLAGS
02:0000395C E4D0            	  6215:                 roxr (a0)
02:0000395E 6100FDF2        	  6216:                 bsr ROXx_FLAGS
02:00003962 E4D0            	  6217:                 roxr (a0)
02:00003964 6100FDEC        	  6218:                 bsr ROXx_FLAGS
02:00003968 E4D0            	  6219:                 roxr (a0)
02:0000396A 6100FDE6        	  6220:                 bsr ROXx_FLAGS
02:0000396E E4D0            	  6221:                 roxr (a0)
02:00003970 6100FDE0        	  6222:                 bsr ROXx_FLAGS
02:00003974 3010            	  6223:                 move.w (a0),d0
02:00003976 0C80000103FC    	  6224:                 cmpi.l #$000103FC,d0
02:0000397C 66FE            	  6225:                 bne.s *
02:0000397E 0C850000000A    	  6226:                 cmpi.l #$0000000A,d5
02:00003984 66FE            	  6227:                 bne.s *
                            	  6228: 
02:00003986 4E75            	  6229:                 rts
                            	  6230: 
                            	  6231: 
                            	  6232: 
                            	  6233: 
                            	  6234: *-----------------------------------------------------------
                            	  6235: *-----------------------------------------------------------
                            	  6236: * OPCODE : SHIFTS
                            	  6237: *-----------------------------------------------------------
                            	  6238: *-----------------------------------------------------------
                            	  6239: 
                            	  6240: *     Subroutine to check and accumulate the flags
02:00003988 40C3            	  6241: SHIFTS_FLAGS:   move.w sr,d3
02:0000398A 02830000000F    	  6242:                 andi.l #$0F,d3            * Isolate flags
02:00003990 DA83            	  6243:                 add.l d3,d5               * Copy flag results into accumulator
02:00003992 4E75            	  6244:                 rts
                            	  6245: 
                            	  6246: op_SHIFTS:
                            	  6247: 
                            	  6248: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6249: 
                            	  6250: *        BYTE LEFT
02:00003994 203C80018F81    	  6251:                 move.l #$80018F81,d0
02:0000399A 7A00            	  6252:                 moveq  #$00000000,d5
02:0000399C 7C02            	  6253:                 moveq  #$00000002,d6
                            	  6254: SHIFTS_LOOP1:
02:0000399E ED20            	  6255:                 asl.b d6,d0
02:000039A0 61E6            	  6256:                 bsr SHIFTS_FLAGS
02:000039A2 51CEFFFA        	  6257:                 dbf d6,SHIFTS_LOOP1
02:000039A6 0C8080018F08    	  6258:                 cmpi.l #$80018F08,d0
02:000039AC 66FE            	  6259:                 bne.s *
02:000039AE 0C8500000002    	  6260:                 cmpi.l #$00000002,d5
02:000039B4 66FE            	  6261:                 bne.s *
                            	  6262: 
                            	  6263: *        BYTE RIGHT
02:000039B6 203C80018F81    	  6264:                 move.l #$80018F81,d0
02:000039BC 7C02            	  6265:                 moveq  #$00000002,d6
                            	  6266: SHIFTS_LOOP2:
02:000039BE EC20            	  6267:                 asr.b d6,d0
02:000039C0 61C6            	  6268:                 bsr SHIFTS_FLAGS
02:000039C2 51CEFFFA        	  6269:                 dbf d6,SHIFTS_LOOP2
02:000039C6 0C8080018FF0    	  6270:                 cmpi.l #$80018FF0,d0
02:000039CC 66FE            	  6271:                 bne.s *
02:000039CE 0C850000001A    	  6272:                 cmpi.l #$0000001A,d5
02:000039D4 66FE            	  6273:                 bne.s *
                            	  6274: 
                            	  6275: 
                            	  6276: *        WORD LEFT
02:000039D6 203C80018FF1    	  6277:                 move.l #$80018FF1,d0
02:000039DC 7C02            	  6278:                 moveq  #$00000002,d6
                            	  6279: SHIFTS_LOOP3:
02:000039DE ED60            	  6280:                 asl.w d6,d0
02:000039E0 61A6            	  6281:                 bsr SHIFTS_FLAGS
02:000039E2 51CEFFFA        	  6282:                 dbf d6,SHIFTS_LOOP3
02:000039E6 0C8080017F88    	  6283:                 cmpi.l #$80017F88,d0
02:000039EC 66FE            	  6284:                 bne.s *
02:000039EE 0C850000001C    	  6285:                 cmpi.l #$0000001C,d5
02:000039F4 66FE            	  6286:                 bne.s *
                            	  6287: 
                            	  6288: *        WORD RIGHT
02:000039F6 203C80018FF1    	  6289:                 move.l #$80018FF1,d0
02:000039FC 7C02            	  6290:                 moveq  #$00000002,d6
                            	  6291: SHIFTS_LOOP4:
02:000039FE EC60            	  6292:                 asr.w d6,d0
02:00003A00 6186            	  6293:                 bsr SHIFTS_FLAGS
02:00003A02 51CEFFFA        	  6294:                 dbf d6,SHIFTS_LOOP4
02:00003A06 0C808001F1FE    	  6295:                 cmpi.l #$8001F1FE,d0
02:00003A0C 66FE            	  6296:                 bne.s *
02:00003A0E 0C8500000034    	  6297:                 cmpi.l #$00000034,d5
02:00003A14 66FE            	  6298:                 bne.s *
                            	  6299: 
                            	  6300: 
                            	  6301: *        LONG LEFT
02:00003A16 203C80018FF1    	  6302:                 move.l #$80018FF1,d0
02:00003A1C 7C02            	  6303:                 moveq  #$00000002,d6
                            	  6304: SHIFTS_LOOP5:
02:00003A1E EDA0            	  6305:                 asl.l d6,d0
02:00003A20 6100FF66        	  6306:                 bsr SHIFTS_FLAGS
02:00003A24 51CEFFF8        	  6307:                 dbf d6,SHIFTS_LOOP5
02:00003A28 0C80000C7F88    	  6308:                 cmpi.l #$000C7F88,d0
02:00003A2E 66FE            	  6309:                 bne.s *
02:00003A30 0C8500000036    	  6310:                 cmpi.l #$00000036,d5
02:00003A36 66FE            	  6311:                 bne.s *
                            	  6312: 
                            	  6313: *        LONG RIGHT
02:00003A38 203C80018FF1    	  6314:                 move.l #$80018FF1,d0
02:00003A3E 7C02            	  6315:                 moveq  #$00000002,d6
                            	  6316: SHIFTS_LOOP6:
02:00003A40 ECA0            	  6317:                 asr.l d6,d0
02:00003A42 6100FF44        	  6318:                 bsr SHIFTS_FLAGS
02:00003A46 51CEFFF8        	  6319:                 dbf d6,SHIFTS_LOOP6
02:00003A4A 0C80F00031FE    	  6320:                 cmpi.l #$F00031FE,d0
02:00003A50 66FE            	  6321:                 bne.s *
02:00003A52 0C850000004E    	  6322:                 cmpi.l #$0000004E,d5
02:00003A58 66FE            	  6323:                 bne.s *
                            	  6324: 
                            	  6325: 
                            	  6326: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6327: 
02:00003A5A 203C80018FF1    	  6328:                 move.l #$80018FF1,d0
02:00003A60 7A00            	  6329:                 moveq  #$00000000,d5
                            	  6330: 
                            	  6331: *        BYTE LEFT
02:00003A62 D000            	  6332:                 asl.b #1,d0
02:00003A64 6100FF22        	  6333:                 bsr SHIFTS_FLAGS
02:00003A68 E500            	  6334:                 asl.b #2,d0
02:00003A6A 6100FF1C        	  6335:                 bsr SHIFTS_FLAGS
02:00003A6E D000            	  6336:                 asl.b #1,d0
02:00003A70 6100FF16        	  6337:                 bsr SHIFTS_FLAGS
02:00003A74 E700            	  6338:                 asl.b #3,d0
02:00003A76 6100FF10        	  6339:                 bsr SHIFTS_FLAGS
02:00003A7A 0C8080018F80    	  6340:                 cmpi.l #$80018F80,d0
02:00003A80 66FE            	  6341:                 bne.s *
02:00003A82 0C850000001F    	  6342:                 cmpi.l #$0000001F,d5
02:00003A88 66FE            	  6343:                 bne.s *
                            	  6344: 
                            	  6345: *        BYTE RIGHT
02:00003A8A E200            	  6346:                 asr.b #1,d0
02:00003A8C 6100FEFA        	  6347:                 bsr SHIFTS_FLAGS
02:00003A90 E400            	  6348:                 asr.b #2,d0
02:00003A92 6100FEF4        	  6349:                 bsr SHIFTS_FLAGS
02:00003A96 E600            	  6350:                 asr.b #3,d0
02:00003A98 6100FEEE        	  6351:                 bsr SHIFTS_FLAGS
02:00003A9C E200            	  6352:                 asr.b #1,d0
02:00003A9E 6100FEE8        	  6353:                 bsr SHIFTS_FLAGS
02:00003AA2 0C8080018FFF    	  6354:                 cmpi.l #$80018FFF,d0
02:00003AA8 66FE            	  6355:                 bne.s *
02:00003AAA 0C850000003F    	  6356:                 cmpi.l #$0000003F,d5
02:00003AB0 66FE            	  6357:                 bne.s *
                            	  6358: 
                            	  6359: *        WORD LEFT
02:00003AB2 D040            	  6360:                 asl.w #1,d0
02:00003AB4 6100FED2        	  6361:                 bsr SHIFTS_FLAGS
02:00003AB8 E540            	  6362:                 asl.w #2,d0
02:00003ABA 6100FECC        	  6363:                 bsr SHIFTS_FLAGS
02:00003ABE E740            	  6364:                 asl.w #3,d0
02:00003AC0 6100FEC6        	  6365:                 bsr SHIFTS_FLAGS
02:00003AC4 EB40            	  6366:                 asl.w #5,d0
02:00003AC6 6100FEC0        	  6367:                 bsr SHIFTS_FLAGS
02:00003ACA 0C808001F800    	  6368:                 cmpi.l #$8001F800,d0
02:00003AD0 66FE            	  6369:                 bne.s *
02:00003AD2 0C8500000056    	  6370:                 cmpi.l #$00000056,d5
02:00003AD8 66FE            	  6371:                 bne.s *
                            	  6372: 
                            	  6373: *        WORD RIGHT
02:00003ADA EA40            	  6374:                 asr.w #5,d0
02:00003ADC 6100FEAA        	  6375:                 bsr SHIFTS_FLAGS
02:00003AE0 E240            	  6376:                 asr.w #1,d0
02:00003AE2 6100FEA4        	  6377:                 bsr SHIFTS_FLAGS
02:00003AE6 E440            	  6378:                 asr.w #2,d0
02:00003AE8 6100FE9E        	  6379:                 bsr SHIFTS_FLAGS
02:00003AEC E840            	  6380:                 asr.w #4,d0
02:00003AEE 6100FE98        	  6381:                 bsr SHIFTS_FLAGS
02:00003AF2 0C808001FFFF    	  6382:                 cmpi.l #$8001FFFF,d0
02:00003AF8 66FE            	  6383:                 bne.s *
02:00003AFA 0C8500000077    	  6384:                 cmpi.l #$00000077,d5
02:00003B00 66FE            	  6385:                 bne.s *
                            	  6386: 
                            	  6387: *        LONG LEFT
02:00003B02 203C80018FF1    	  6388:                 move.l #$80018FF1,d0
02:00003B08 D080            	  6389:                 asl.l #1,d0
02:00003B0A 6100FE7C        	  6390:                 bsr SHIFTS_FLAGS
02:00003B0E E580            	  6391:                 asl.l #2,d0
02:00003B10 6100FE76        	  6392:                 bsr SHIFTS_FLAGS
02:00003B14 EF80            	  6393:                 asl.l #7,d0
02:00003B16 6100FE70        	  6394:                 bsr SHIFTS_FLAGS
02:00003B1A E980            	  6395:                 asl.l #4,d0
02:00003B1C 6100FE6A        	  6396:                 bsr SHIFTS_FLAGS
02:00003B20 0C8063FC4000    	  6397:                 cmpi.l #$63FC4000,d0
02:00003B26 66FE            	  6398:                 bne.s *
02:00003B28 0C850000007A    	  6399:                 cmpi.l #$0000007A,d5
02:00003B2E 66FE            	  6400:                 bne.s *
                            	  6401: 
                            	  6402: *        LONG RIGHT
02:00003B30 203C80018FF1    	  6403:                 move.l #$80018FF1,d0
02:00003B36 E280            	  6404:                 asr.l #1,d0
02:00003B38 6100FE4E        	  6405:                 bsr SHIFTS_FLAGS
02:00003B3C EA80            	  6406:                 asr.l #5,d0
02:00003B3E 6100FE48        	  6407:                 bsr SHIFTS_FLAGS
02:00003B42 EE80            	  6408:                 asr.l #7,d0
02:00003B44 6100FE42        	  6409:                 bsr SHIFTS_FLAGS
02:00003B48 E080            	  6410:                 asr.l #8,d0
02:00003B4A 6100FE3C        	  6411:                 bsr SHIFTS_FLAGS
02:00003B4E 0C80FFFFFC00    	  6412:                 cmpi.l #$FFFFFC00,d0
02:00003B54 66FE            	  6413:                 bne.s *
02:00003B56 0C850000009C    	  6414:                 cmpi.l #$0000009C,d5
02:00003B5C 66FE            	  6415:                 bne.s *
                            	  6416: 
                            	  6417: 
                            	  6418: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6419: 
02:00003B5E 7A00            	  6420:                 moveq  #$00000000,d5
02:00003B60 307C0100        	  6421:                 move.l #$00000100,a0
02:00003B64 30BC8FF1        	  6422:                 move.w #$8FF1,(a0)
                            	  6423: 
                            	  6424: *        WORD LEFT
02:00003B68 E1D0            	  6425:                 asl  (a0)
02:00003B6A 6100FE1C        	  6426:                 bsr SHIFTS_FLAGS
02:00003B6E E1D0            	  6427:                 asl  (a0)
02:00003B70 6100FE16        	  6428:                 bsr SHIFTS_FLAGS
02:00003B74 E1D0            	  6429:                 asl  (a0)
02:00003B76 6100FE10        	  6430:                 bsr SHIFTS_FLAGS
02:00003B7A E1D0            	  6431:                 asl  (a0)
02:00003B7C 6100FE0A        	  6432:                 bsr SHIFTS_FLAGS
02:00003B80 3010            	  6433:                 move.w (a0),d0
02:00003B82 0C80FFFFFF10    	  6434:                 cmpi.l #$FFFFFF10,d0
02:00003B88 66FE            	  6435:                 bne.s *
02:00003B8A 0C850000000D    	  6436:                 cmpi.l #$0000000D,d5
02:00003B90 66FE            	  6437:                 bne.s *
                            	  6438: 
                            	  6439: *        WORD RIGHT
02:00003B92 E0D0            	  6440:                 asr (a0)
02:00003B94 6100FDF2        	  6441:                 bsr SHIFTS_FLAGS
02:00003B98 E0D0            	  6442:                 asr (a0)
02:00003B9A 6100FDEC        	  6443:                 bsr SHIFTS_FLAGS
02:00003B9E E0D0            	  6444:                 asr (a0)
02:00003BA0 6100FDE6        	  6445:                 bsr SHIFTS_FLAGS
02:00003BA4 E0D0            	  6446:                 asr (a0)
02:00003BA6 6100FDE0        	  6447:                 bsr SHIFTS_FLAGS
02:00003BAA E0D0            	  6448:                 asr (a0)
02:00003BAC 6100FDDA        	  6449:                 bsr SHIFTS_FLAGS
02:00003BB0 E0D0            	  6450:                 asr (a0)
02:00003BB2 6100FDD4        	  6451:                 bsr SHIFTS_FLAGS
02:00003BB6 3010            	  6452:                 move.w (a0),d0
02:00003BB8 0C80FFFFFFFC    	  6453:                 cmpi.l #$FFFFFFFC,d0
02:00003BBE 66FE            	  6454:                 bne.s *
02:00003BC0 0C850000003E    	  6455:                 cmpi.l #$0000003E,d5
02:00003BC6 66FE            	  6456:                 bne.s *
                            	  6457: 
02:00003BC8 4E75            	  6458:                 rts
                            	  6459: 
                            	  6460: 
                            	  6461: 
                            	  6462: *-----------------------------------------------------------
                            	  6463: *-----------------------------------------------------------
                            	  6464: * OPCODE : SHIFTS2
                            	  6465: *-----------------------------------------------------------
                            	  6466: *-----------------------------------------------------------
                            	  6467: 
                            	  6468: *     Subroutine to check and accumulate the flags
02:00003BCA 40C3            	  6469: SHIFTS2_FLAGS:  move.w sr,d3
02:00003BCC 02830000000F    	  6470:                 andi.l #$0F,d3            * Isolate flags
02:00003BD2 DA83            	  6471:                 add.l d3,d5               * Copy flag results into accumulator
02:00003BD4 4E75            	  6472:                 rts
                            	  6473: 
                            	  6474: op_SHIFTS2:
                            	  6475: 
                            	  6476: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6477: 
                            	  6478: *        BYTE LEFT
02:00003BD6 203C80018F81    	  6479:                 move.l #$80018F81,d0
02:00003BDC 7A00            	  6480:                 moveq  #$00000000,d5
02:00003BDE 7C02            	  6481:                 moveq  #$00000002,d6
                            	  6482: SHIFTS2_LOOP1:
02:00003BE0 ED28            	  6483:                 lsl.b d6,d0
02:00003BE2 61E6            	  6484:                 bsr SHIFTS2_FLAGS
02:00003BE4 51CEFFFA        	  6485:                 dbf d6,SHIFTS2_LOOP1
02:00003BE8 0C8080018F08    	  6486:                 cmpi.l #$80018F08,d0
02:00003BEE 66FE            	  6487:                 bne.s *
02:00003BF0 4A85            	  6488:                 cmpi.l #$00000000,d5
02:00003BF2 66FE            	  6489:                 bne.s *
                            	  6490: 
                            	  6491: *        BYTE RIGHT
02:00003BF4 203C80018F81    	  6492:                 move.l #$80018F81,d0
02:00003BFA 7C02            	  6493:                 moveq  #$00000002,d6
                            	  6494: SHIFTS2_LOOP2:
02:00003BFC EC28            	  6495:                 lsr.b d6,d0
02:00003BFE 61CA            	  6496:                 bsr SHIFTS2_FLAGS
02:00003C00 51CEFFFA        	  6497:                 dbf d6,SHIFTS2_LOOP2
02:00003C04 0C8080018F10    	  6498:                 cmpi.l #$80018F10,d0
02:00003C0A 66FE            	  6499:                 bne.s *
02:00003C0C 4A85            	  6500:                 cmpi.l #$00000000,d5
02:00003C0E 66FE            	  6501:                 bne.s *
                            	  6502: 
                            	  6503: 
                            	  6504: *        WORD LEFT
02:00003C10 203C80018FF1    	  6505:                 move.l #$80018FF1,d0
02:00003C16 7C02            	  6506:                 moveq  #$00000002,d6
                            	  6507: SHIFTS2_LOOP3:
02:00003C18 ED68            	  6508:                 lsl.w d6,d0
02:00003C1A 61AE            	  6509:                 bsr SHIFTS2_FLAGS
02:00003C1C 51CEFFFA        	  6510:                 dbf d6,SHIFTS2_LOOP3
02:00003C20 0C8080017F88    	  6511:                 cmpi.l #$80017F88,d0
02:00003C26 66FE            	  6512:                 bne.s *
02:00003C28 4A85            	  6513:                 cmpi.l #$00000000,d5
02:00003C2A 66FE            	  6514:                 bne.s *
                            	  6515: 
                            	  6516: *        WORD RIGHT
02:00003C2C 203C80018FF1    	  6517:                 move.l #$80018FF1,d0
02:00003C32 7C02            	  6518:                 moveq  #$00000002,d6
                            	  6519: SHIFTS2_LOOP4:
02:00003C34 EC68            	  6520:                 lsr.w d6,d0
02:00003C36 6192            	  6521:                 bsr SHIFTS2_FLAGS
02:00003C38 51CEFFFA        	  6522:                 dbf d6,SHIFTS2_LOOP4
02:00003C3C 0C80800111FE    	  6523:                 cmpi.l #$800111FE,d0
02:00003C42 66FE            	  6524:                 bne.s *
02:00003C44 4A85            	  6525:                 cmpi.l #$00000000,d5
02:00003C46 66FE            	  6526:                 bne.s *
                            	  6527: 
                            	  6528: 
                            	  6529: *        LONG LEFT
02:00003C48 203C80018FF1    	  6530:                 move.l #$80018FF1,d0
02:00003C4E 7C02            	  6531:                 moveq  #$00000002,d6
                            	  6532: SHIFTS2_LOOP5:
02:00003C50 EDA8            	  6533:                 lsl.l d6,d0
02:00003C52 6100FF76        	  6534:                 bsr SHIFTS2_FLAGS
02:00003C56 51CEFFF8        	  6535:                 dbf d6,SHIFTS2_LOOP5
02:00003C5A 0C80000C7F88    	  6536:                 cmpi.l #$000C7F88,d0
02:00003C60 66FE            	  6537:                 bne.s *
02:00003C62 4A85            	  6538:                 cmpi.l #$00000000,d5
02:00003C64 66FE            	  6539:                 bne.s *
                            	  6540: 
                            	  6541: *        LONG RIGHT
02:00003C66 203C80018FF1    	  6542:                 move.l #$80018FF1,d0
02:00003C6C 7C02            	  6543:                 moveq  #$00000002,d6
                            	  6544: SHIFTS2_LOOP6:
02:00003C6E ECA8            	  6545:                 lsr.l d6,d0
02:00003C70 6100FF58        	  6546:                 bsr SHIFTS2_FLAGS
02:00003C74 51CEFFF8        	  6547:                 dbf d6,SHIFTS2_LOOP6
02:00003C78 0C80100031FE    	  6548:                 cmpi.l #$100031FE,d0
02:00003C7E 66FE            	  6549:                 bne.s *
02:00003C80 4A85            	  6550:                 cmpi.l #$00000000,d5
02:00003C82 66FE            	  6551:                 bne.s *
                            	  6552: 
                            	  6553: 
                            	  6554: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6555: 
02:00003C84 203C80018FF1    	  6556:                 move.l #$80018FF1,d0
02:00003C8A 7A00            	  6557:                 moveq  #$00000000,d5
                            	  6558: 
                            	  6559: *        BYTE LEFT
02:00003C8C E308            	  6560:                 lsl.b #1,d0
02:00003C8E 6100FF3A        	  6561:                 bsr SHIFTS2_FLAGS
02:00003C92 E508            	  6562:                 lsl.b #2,d0
02:00003C94 6100FF34        	  6563:                 bsr SHIFTS2_FLAGS
02:00003C98 E308            	  6564:                 lsl.b #1,d0
02:00003C9A 6100FF2E        	  6565:                 bsr SHIFTS2_FLAGS
02:00003C9E E708            	  6566:                 lsl.b #3,d0
02:00003CA0 6100FF28        	  6567:                 bsr SHIFTS2_FLAGS
02:00003CA4 0C8080018F80    	  6568:                 cmpi.l #$80018F80,d0
02:00003CAA 66FE            	  6569:                 bne.s *
02:00003CAC 0C850000001B    	  6570:                 cmpi.l #$0000001B,d5
02:00003CB2 66FE            	  6571:                 bne.s *
                            	  6572: 
                            	  6573: *        BYTE RIGHT
02:00003CB4 E208            	  6574:                 lsr.b #1,d0
02:00003CB6 6100FF12        	  6575:                 bsr SHIFTS2_FLAGS
02:00003CBA E408            	  6576:                 lsr.b #2,d0
02:00003CBC 6100FF0C        	  6577:                 bsr SHIFTS2_FLAGS
02:00003CC0 E608            	  6578:                 lsr.b #3,d0
02:00003CC2 6100FF06        	  6579:                 bsr SHIFTS2_FLAGS
02:00003CC6 E208            	  6580:                 lsr.b #1,d0
02:00003CC8 6100FF00        	  6581:                 bsr SHIFTS2_FLAGS
02:00003CCC 0C8080018F01    	  6582:                 cmpi.l #$80018F01,d0
02:00003CD2 66FE            	  6583:                 bne.s *
02:00003CD4 0C850000001B    	  6584:                 cmpi.l #$0000001B,d5
02:00003CDA 66FE            	  6585:                 bne.s *
                            	  6586: 
                            	  6587: *        WORD LEFT
02:00003CDC E348            	  6588:                 lsl.w #1,d0
02:00003CDE 6100FEEA        	  6589:                 bsr SHIFTS2_FLAGS
02:00003CE2 E548            	  6590:                 lsl.w #2,d0
02:00003CE4 6100FEE4        	  6591:                 bsr SHIFTS2_FLAGS
02:00003CE8 E748            	  6592:                 lsl.w #3,d0
02:00003CEA 6100FEDE        	  6593:                 bsr SHIFTS2_FLAGS
02:00003CEE EB48            	  6594:                 lsl.w #5,d0
02:00003CF0 6100FED8        	  6595:                 bsr SHIFTS2_FLAGS
02:00003CF4 0C8080010800    	  6596:                 cmpi.l #$80010800,d0
02:00003CFA 66FE            	  6597:                 bne.s *
02:00003CFC 0C8500000025    	  6598:                 cmpi.l #$00000025,d5
02:00003D02 66FE            	  6599:                 bne.s *
                            	  6600: 
                            	  6601: *        WORD RIGHT
02:00003D04 EA48            	  6602:                 lsr.w #5,d0
02:00003D06 6100FEC2        	  6603:                 bsr SHIFTS2_FLAGS
02:00003D0A E248            	  6604:                 lsr.w #1,d0
02:00003D0C 6100FEBC        	  6605:                 bsr SHIFTS2_FLAGS
02:00003D10 E448            	  6606:                 lsr.w #2,d0
02:00003D12 6100FEB6        	  6607:                 bsr SHIFTS2_FLAGS
02:00003D16 E848            	  6608:                 lsr.w #4,d0
02:00003D18 6100FEB0        	  6609:                 bsr SHIFTS2_FLAGS
02:00003D1C 0C8080010000    	  6610:                 cmpi.l #$80010000,d0
02:00003D22 66FE            	  6611:                 bne.s *
02:00003D24 0C850000002A    	  6612:                 cmpi.l #$0000002A,d5
02:00003D2A 66FE            	  6613:                 bne.s *
                            	  6614: 
                            	  6615: *        LONG LEFT
02:00003D2C 203C80018FF1    	  6616:                 move.l #$80018FF1,d0
02:00003D32 E388            	  6617:                 lsl.l #1,d0
02:00003D34 6100FE94        	  6618:                 bsr SHIFTS2_FLAGS
02:00003D38 E588            	  6619:                 lsl.l #2,d0
02:00003D3A 6100FE8E        	  6620:                 bsr SHIFTS2_FLAGS
02:00003D3E EF88            	  6621:                 lsl.l #7,d0
02:00003D40 6100FE88        	  6622:                 bsr SHIFTS2_FLAGS
02:00003D44 E988            	  6623:                 lsl.l #4,d0
02:00003D46 6100FE82        	  6624:                 bsr SHIFTS2_FLAGS
02:00003D4A 0C8063FC4000    	  6625:                 cmpi.l #$63FC4000,d0
02:00003D50 66FE            	  6626:                 bne.s *
02:00003D52 0C850000002B    	  6627:                 cmpi.l #$0000002B,d5
02:00003D58 66FE            	  6628:                 bne.s *
                            	  6629: 
                            	  6630: *        LONG RIGHT
02:00003D5A 203C80018FF1    	  6631:                 move.l #$80018FF1,d0
02:00003D60 E288            	  6632:                 lsr.l #1,d0
02:00003D62 6100FE66        	  6633:                 bsr SHIFTS2_FLAGS
02:00003D66 EA88            	  6634:                 lsr.l #5,d0
02:00003D68 6100FE60        	  6635:                 bsr SHIFTS2_FLAGS
02:00003D6C EE88            	  6636:                 lsr.l #7,d0
02:00003D6E 6100FE5A        	  6637:                 bsr SHIFTS2_FLAGS
02:00003D72 E088            	  6638:                 lsr.l #8,d0
02:00003D74 6100FE54        	  6639:                 bsr SHIFTS2_FLAGS
02:00003D78 0C8000000400    	  6640:                 cmpi.l #$00000400,d0
02:00003D7E 66FE            	  6641:                 bne.s *
02:00003D80 0C850000002D    	  6642:                 cmpi.l #$0000002D,d5
02:00003D86 66FE            	  6643:                 bne.s *
                            	  6644: 
                            	  6645: 
                            	  6646: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6647: 
02:00003D88 7A00            	  6648:                 moveq  #$00000000,d5
02:00003D8A 307C0100        	  6649:                 move.l #$00000100,a0
02:00003D8E 30BC8FF1        	  6650:                 move.w #$8FF1,(a0)
                            	  6651: 
                            	  6652: *        WORD LEFT
02:00003D92 E3D0            	  6653:                 lsl  (a0)
02:00003D94 6100FE34        	  6654:                 bsr SHIFTS2_FLAGS
02:00003D98 E3D0            	  6655:                 lsl  (a0)
02:00003D9A 6100FE2E        	  6656:                 bsr SHIFTS2_FLAGS
02:00003D9E E3D0            	  6657:                 lsl  (a0)
02:00003DA0 6100FE28        	  6658:                 bsr SHIFTS2_FLAGS
02:00003DA4 E3D0            	  6659:                 lsl  (a0)
02:00003DA6 6100FE22        	  6660:                 bsr SHIFTS2_FLAGS
02:00003DAA 3010            	  6661:                 move.w (a0),d0
02:00003DAC 0C800000FF10    	  6662:                 cmpi.l #$0000FF10,d0
02:00003DB2 66FE            	  6663:                 bne.s *
02:00003DB4 0C8500000009    	  6664:                 cmpi.l #$00000009,d5
02:00003DBA 66FE            	  6665:                 bne.s *
                            	  6666: 
                            	  6667: *        WORD RIGHT
02:00003DBC E2D0            	  6668:                 lsr (a0)
02:00003DBE 6100FE0A        	  6669:                 bsr SHIFTS2_FLAGS
02:00003DC2 E2D0            	  6670:                 lsr (a0)
02:00003DC4 6100FE04        	  6671:                 bsr SHIFTS2_FLAGS
02:00003DC8 E2D0            	  6672:                 lsr (a0)
02:00003DCA 6100FDFE        	  6673:                 bsr SHIFTS2_FLAGS
02:00003DCE E2D0            	  6674:                 lsr (a0)
02:00003DD0 6100FDF8        	  6675:                 bsr SHIFTS2_FLAGS
02:00003DD4 E2D0            	  6676:                 lsr (a0)
02:00003DD6 6100FDF2        	  6677:                 bsr SHIFTS2_FLAGS
02:00003DDA E2D0            	  6678:                 lsr (a0)
02:00003DDC 6100FDEC        	  6679:                 bsr SHIFTS2_FLAGS
02:00003DE0 3010            	  6680:                 move.w (a0),d0
02:00003DE2 0C80000003FC    	  6681:                 cmpi.l #$000003FC,d0
02:00003DE8 66FE            	  6682:                 bne.s *
02:00003DEA 0C850000000A    	  6683:                 cmpi.l #$0000000A,d5
02:00003DF0 66FE            	  6684:                 bne.s *
                            	  6685: 
02:00003DF2 4E75            	  6686:                 rts
                            	  6687: 
                            	  6688: ;-----------------------------------------------------------
                            	  6689: ;-----------------------------------------------------------
                            	  6690: ; OPCODE : BSR / RTS
                            	  6691: ;-----------------------------------------------------------
                            	  6692: ;-----------------------------------------------------------
                            	  6693: 
                            	  6694: ;t3_bsr:
                            	  6695: ;	moveq	#3,d3
                            	  6696: ;	rts
                            	  6697: 
                            	  6698: ;t1_bsr:
                            	  6699: ;	moveq	#1,d1
                            	  6700: ;	rts
                            	  6701: 
                            	  6702: ;op_bsr:
                            	  6703: ;	bsr			t1_bsr
                            	  6704: ;	bsr			t2_bsr
                            	  6705: ;	bsr.w		t3_bsr
                            	  6706: ;	bsr.w		t4_bsr
                            	  6707: ;	cmpi.l	#1,d1
                            	  6708: ;	bne			*
                            	  6709: ;	cmpi.l	#2,d2
                            	  6710: ;	bne			*
                            	  6711: ;	cmpi.l	#3,d3
                            	  6712: ;	bne			*
                            	  6713: ;	cmpi.l	#4,d4
                            	  6714: ;	bne			*
                            	  6715: ;	rts
                            	  6716: 
                            	  6717: ;t2_bsr:
                            	  6718: ;	moveq	#2,d2
                            	  6719: ;	rts
                            	  6720: 	
                            	  6721: ;t4_bsr:
                            	  6722: ;	moveq	#4,d4
                            	  6723: ;	rts
                            	  6724: *    END
                            	  6725:     
                            	  6726: 

Source: "boot.asm"
                            	   782: 	include "TinyBasic.asm"

Source: "TinyBasic.asm"
                            	     1: ******************************************************************
                            	     2: *								 *
                            	     3: *		Tiny BASIC for the Motorola MC68000		 *
                            	     4: *								 *
                            	     5: * Derived from Palo Alto Tiny BASIC as published in the May 1976 *
                            	     6: * issue of Dr. Dobb's Journal.  Adapted to the 68000 by:         *
                            	     7: *	Gordon Brandly						 *
                            	     8: *	12147 - 51 Street					 *
                            	     9: *	Edmonton AB  T5W 3G8					 *
                            	    10: *	Canada							 *
                            	    11: *	(updated mailing address for 1996)			 *
                            	    12: *								 *
                            	    13: * This version is for MEX68KECB Educational Computer Board I/O.  *
                            	    14: *								 *
                            	    15: ******************************************************************
                            	    16: *    Copyright (C) 1984 by Gordon Brandly. This program may be	 *
                            	    17: *    freely distributed for personal use only. All commercial	 *
                            	    18: *		       rights are reserved.			 *
                            	    19: ******************************************************************
                            	    20: 
                            	    21: * Vers. 1.0  1984/7/17	- Original version by Gordon Brandly
                            	    22: *	1.1  1984/12/9	- Addition of '$' print term by Marvin Lipford
                            	    23: *	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                            	    24: 
                            	    25: *	OPT	FRS,BRS 	forward ref.'s & branches default to short
                            	    26: 
                            	    27: ;CR	EQU	$0D		ASCII equates
                            	    28: ;LF	EQU	$0A
                            	    29: ;TAB	EQU	$09
                            	    30: ;CTRLC	EQU	$03
                            	    31: ;CTRLH	EQU	$08
                            	    32: ;CTRLS	EQU	$13
                            	    33: ;CTRLX	EQU	$18
                            	    34: 
                            	    35: BUFLEN	EQU	80		length of keyboard input buffer
                            	    36: 	CODE
                            	    37: *	ORG	$10000		first free address using Tutor
                            	    38: *
                            	    39: * Standard jump table. You can change these addresses if you are
                            	    40: * customizing this interpreter for a different environment.
                            	    41: *
02:00003DF4 601E            	    42: START	BRA	CSTART		Cold Start entry point
02:00003DF6 6060            	    43: GOWARM	BRA	WSTART		Warm Start entry point
02:00003DF8 60000C0A        	    44: GOOUT	BRA OUTC		Jump to character-out routine
02:00003DFC 60000C22        	    45: GOIN	BRA INC		Jump to character-in routine
02:00003E00 60000C3E        	    46: GOAUXO	BRA	AUXOUT		Jump to auxiliary-out routine
02:00003E04 60000C4A        	    47: GOAUXI	BRA	AUXIN		Jump to auxiliary-in routine
02:00003E08 60000C66        	    48: GOBYE	BRA	BYEBYE		Jump to monitor, DOS, etc.
                            	    49: *
                            	    50: * Modifiable system constants:
                            	    51: *
02:00003E0C 00041000        	    52: TXTBGN	DC.L	$41000		beginning of program memory
02:00003E10 00041FF0        	    53: ENDMEM	DC.L	$41FF0		end of available memory
                            	    54: *
                            	    55: * The main interpreter starts here:
                            	    56: *
02:00003E14 2E7AFFFA        	    57: CSTART	MOVE.L	ENDMEM,SP	initialize stack pointer
02:00003E18 23FC00004A100000	    58: 	move.l	#OUTC1,OUTPTR
02:00003E20 4AC2
02:00003E22 23FC00004A2C0000	    59: 	move.l	#INC1,INPPTR
02:00003E2A 4ABE
02:00003E2C 4DFA0C46        	    60: 	LEA	INITMSG,A6	tell who we are
02:00003E30 61000BC6        	    61: 	BSR	PRMESG
02:00003E34 23FAFFD600004AE6	    62: 	MOVE.L	TXTBGN,TXTUNF	init. end-of-program pointer
02:00003E3C 203AFFD2        	    63: 	MOVE.L	ENDMEM,D0	get address of end of memory
02:00003E40 90BC00000800    	    64: 	SUB.L	#2048,D0	reserve 2K for the stack
02:00003E46 23C000004AEE    	    65: 	MOVE.L	D0,STKLMT
02:00003E4C 90BC0000006C    	    66: 	SUB.L	#108,D0 	reserve variable area (27 long words)
02:00003E52 23C000004AEA    	    67: 	MOVE.L	D0,VARBGN
02:00003E58 7000            	    68: WSTART	CLR.L	D0		initialize internal variables
02:00003E5A 23C000004AD2    	    69: 	MOVE.L	D0,LOPVAR
02:00003E60 23C000004ACA    	    70: 	MOVE.L	D0,STKGOS
02:00003E66 23C000004AC6    	    71: 	MOVE.L	D0,CURRNT	current line number pointer = 0
02:00003E6C 2E7AFFA2        	    72: 	MOVE.L	ENDMEM,SP	init S.P. again, just in case
02:00003E70 4DFA0C28        	    73: 	LEA	OKMSG,A6	display "OK"
02:00003E74 61000B82        	    74: 	bsr	PRMESG
02:00003E78 103C003E        	    75: ST3	MOVE.B	#'>',D0         Prompt with a '>' and
02:00003E7C 610008AC        	    76: 	bsr	GETLN		read a line.
02:00003E80 61000B1A        	    77: 	bsr	TOUPBUF 	convert to upper case
02:00003E84 2848            	    78: 	MOVE.L	A0,A4		save pointer to end of line
02:00003E86 41FA0C6A        	    79: 	LEA	BUFFER,A0	point to the beginning of line
02:00003E8A 61000ACE        	    80: 	bsr	TSTNUM		is there a number there?
02:00003E8E 61000B00        	    81: 	bsr	IGNBLK		skip trailing blanks
02:00003E92 4A41            	    82: 	TST	D1		does line no. exist? (or nonzero?)
02:00003E94 67000198        	    83: 	BEQ	DIRECT		if not, it's a direct statement
02:00003E98 B2BC0000FFFF    	    84: 	CMP.L	#$FFFF,D1	see if line no. is <= 16 bits
02:00003E9E 64000882        	    85: 	BCC	QHOW		if not, we've overflowed
02:00003EA2 1101            	    86: 	MOVE.B	D1,-(A0)	store the binary line no.
02:00003EA4 E059            	    87: 	ROR	#8,D1		(Kludge to store a word on a
02:00003EA6 1101            	    88: 	MOVE.B	D1,-(A0)	possible byte boundary)
02:00003EA8 E159            	    89: 	ROL	#8,D1
02:00003EAA 6100091C        	    90: 	bsr	FNDLN		find this line in save area
02:00003EAE 2A49            	    91: 	MOVE.L	A1,A5		save possible line pointer
02:00003EB0 6614            	    92: 	BNE	ST4		if not found, insert
02:00003EB2 6100093A        	    93: 	bsr	FNDNXT		find the next line (into A1)
02:00003EB6 244D            	    94: 	MOVE.L	A5,A2		pointer to line to be deleted
02:00003EB8 267A0C2C        	    95: 	MOVE.L	TXTUNF,A3	points to top of save area
02:00003EBC 61000940        	    96: 	bsr	MVUP		move up to delete
02:00003EC0 23CA00004AE6    	    97: 	MOVE.L	A2,TXTUNF	update the end pointer
02:00003EC6 200C            	    98: ST4	MOVE.L	A4,D0		calculate the length of new line
02:00003EC8 9088            	    99: 	SUB.L	A0,D0
02:00003ECA B0BC00000003    	   100: 	CMP.L	#3,D0		is it just a line no. & CR?
02:00003ED0 67A6            	   101: 	BEQ	ST3		if so, it was just a delete
02:00003ED2 267A0C12        	   102: 	MOVE.L	TXTUNF,A3	compute new end
02:00003ED6 2C4B            	   103: 	MOVE.L	A3,A6
02:00003ED8 D7C0            	   104: 	ADD.L	D0,A3
02:00003EDA 203A0C0E        	   105: 	MOVE.L	VARBGN,D0	see if there's enough room
02:00003EDE B08B            	   106: 	CMP.L	A3,D0
02:00003EE0 63000838        	   107: 	BLS	QSORRY		if not, say so
02:00003EE4 23CB00004AE6    	   108: 	MOVE.L	A3,TXTUNF	if so, store new end position
02:00003EEA 224E            	   109: 	MOVE.L	A6,A1		points to old unfilled area
02:00003EEC 244D            	   110: 	MOVE.L	A5,A2		points to beginning of move area
02:00003EEE 61000918        	   111: 	bsr	MVDOWN		move things out of the way
02:00003EF2 2248            	   112: 	MOVE.L	A0,A1		set up to do the insertion
02:00003EF4 244D            	   113: 	MOVE.L	A5,A2
02:00003EF6 264C            	   114: 	MOVE.L	A4,A3
02:00003EF8 61000904        	   115: 	bsr	MVUP		do it
02:00003EFC 6000FF7A        	   116: 	BRA	ST3		go back and get another line
                            	   117: 
                            	   118: *
                            	   119: *******************************************************************
                            	   120: *
                            	   121: * *** Tables *** DIRECT *** EXEC ***
                            	   122: *
                            	   123: * This section of the code tests a string against a table. When
                            	   124: * a match is found, control is transferred to the section of
                            	   125: * code according to the table.
                            	   126: *
                            	   127: * At 'EXEC', A0 should point to the string, A1 should point to
                            	   128: * the character table, and A2 should point to the execution
                            	   129: * table. At 'DIRECT', A0 should point to the string, A1 and
                            	   130: * A2 will be set up to point to TAB1 and TAB1_1, which are
                            	   131: * the tables of all direct and statement commands.
                            	   132: *
                            	   133: * A '.' in the string will terminate the test and the partial
                            	   134: * match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                            	   135: * 'PRIN.', or 'PRINT' will all match 'PRINT'.
                            	   136: *
                            	   137: * There are two tables: the character table and the execution
                            	   138: * table. The character table consists of any number of text items.
                            	   139: * Each item is a string of characters with the last character's
                            	   140: * high bit set to one. The execution table holds a 16-bit
                            	   141: * execution addresses that correspond to each entry in the
                            	   142: * character table.
                            	   143: *
                            	   144: * The end of the character table is a 0 byte which corresponds
                            	   145: * to the default routine in the execution table, which is
                            	   146: * executed if none of the other table items are matched.
                            	   147: *
                            	   148: * Character-matching tables:
                            	   149: TAB1
02:00003F00 3C434F          	   150: 	DC.B	'<CO',('M'+$80)
02:00003F03 CD
02:00003F04 3C434F          	   151: 	DC.B	'<CO',('N'+$80)
02:00003F07 CE
02:00003F08 3E434F          	   152: 	DC.B	'>CO',('M'+$80)
02:00003F0B CD
02:00003F0C 3E434F          	   153: 	DC.B	'>CO',('N'+$80)
02:00003F0F CE
02:00003F10 3C3E434F        	   154: 	DC.B	'<>CO',('M'+$80)
02:00003F14 CD
02:00003F15 3C3E434F        	   155: 	DC.B	'<>CO',('N'+$80)
02:00003F19 CE
02:00003F1A 4C4953          	   156: 	DC.B	'LIS',('T'+$80)         Direct commands
02:00003F1D D4
02:00003F1E 4C4F41          	   157: 	DC.B	'LOA',('D'+$80)
02:00003F21 C4
02:00003F22 4E45            	   158: 	DC.B	'NE',('W'+$80)
02:00003F24 D7
02:00003F25 5255            	   159: 	DC.B	'RU',('N'+$80)
02:00003F27 CE
02:00003F28 534156          	   160: 	DC.B	'SAV',('E'+$80)
02:00003F2B C5
02:00003F2C 4E4558          	   161: TAB2	DC.B	'NEX',('T'+$80)         Direct / statement
02:00003F2F D4
02:00003F30 4C45            	   162: 	DC.B	'LE',('T'+$80)
02:00003F32 D4
02:00003F33 49              	   163: 	DC.B	'I',('F'+$80)
02:00003F34 C6
02:00003F35 474F54          	   164: 	DC.B	'GOT',('O'+$80)
02:00003F38 CF
02:00003F39 474F5355        	   165: 	DC.B	'GOSU',('B'+$80)
02:00003F3D C2
02:00003F3E 5245545552      	   166: 	DC.B	'RETUR',('N'+$80)
02:00003F43 CE
02:00003F44 5245            	   167: 	DC.B	'RE',('M'+$80)
02:00003F46 CD
02:00003F47 464F            	   168: 	DC.B	'FO',('R'+$80)
02:00003F49 D2
02:00003F4A 494E5055        	   169: 	DC.B	'INPU',('T'+$80)
02:00003F4E D4
02:00003F4F 5052494E        	   170: 	DC.B	'PRIN',('T'+$80)
02:00003F53 D4
02:00003F54 504F4B          	   171: 	DC.B	'POK',('E'+$80)
02:00003F57 C5
02:00003F58 53544F          	   172: 	DC.B	'STO',('P'+$80)
02:00003F5B D0
02:00003F5C 4259            	   173: 	DC.B	'BY',('E'+$80)
02:00003F5E C5
02:00003F5F 43414C          	   174: 	DC.B	'CAL',('L'+$80)
02:00003F62 CC
02:00003F63 00              	   175: 	DC.B	0
02:00003F64 504545          	   176: TAB4	DC.B	'PEE',('K'+$80)         Functions
02:00003F67 CB
02:00003F68 524E            	   177: 	DC.B	'RN',('D'+$80)
02:00003F6A C4
02:00003F6B 4142            	   178: 	DC.B	'AB',('S'+$80)
02:00003F6D D3
02:00003F6E 53495A          	   179: 	DC.B	'SIZ',('E'+$80)
02:00003F71 C5
02:00003F72 00              	   180: 	DC.B	0
02:00003F73 54              	   181: TAB5	DC.B	'T',('O'+$80)           "TO" in "FOR"
02:00003F74 CF
02:00003F75 00              	   182: 	DC.B	0
02:00003F76 535445          	   183: TAB6	DC.B	'STE',('P'+$80)         "STEP" in "FOR"
02:00003F79 D0
02:00003F7A 00              	   184: 	DC.B	0
02:00003F7B 3E              	   185: TAB8	DC.B	'>',('='+$80)           Relational operators
02:00003F7C BD
02:00003F7D 3C              	   186: 	DC.B	'<',('>'+$80)
02:00003F7E BE
02:00003F7F BE              	   187: 	DC.B	('>'+$80)
02:00003F80 BD              	   188: 	DC.B	('='+$80)
02:00003F81 3C              	   189: 	DC.B	'<',('='+$80)
02:00003F82 BD
02:00003F83 BC              	   190: 	DC.B	('<'+$80)
02:00003F84 00              	   191: 	DC.B	0
02:00003F85 00              	   192: 	DC.B	0	<- for aligning on a word boundary
                            	   193: 
                            	   194: * Execution address tables:
                            	   195: TAB1_1	
02:00003F86 00004080        	   196: 	DC.L	INCOM
02:00003F8A 00004072        	   197: 	DC.L	INCON
02:00003F8E 00004098        	   198: 	DC.L	OUTCOM
02:00003F92 000040B0        	   199: 	DC.L	OUTCON
02:00003F96 0000408E        	   200: 	DC.L	IOCOM
02:00003F9A 000040A6        	   201: 	DC.L	IOCON
02:00003F9E 00004124        	   202: 	DC.L	LIST			Direct commands
02:00003FA2 0000437C        	   203: 	DC.L	LOAD
02:00003FA6 000040BE        	   204: 	DC.L	NEW
02:00003FAA 000040D2        	   205: 	DC.L	RUN
02:00003FAE 000043DC        	   206: 	DC.L	SAVE
02:00003FB2 0000427C        	   207: TAB2_1	DC.L	NEXT			Direct / statement
02:00003FB6 0000436C        	   208: 	DC.L	LET
02:00003FBA 000042D0        	   209: 	DC.L	IF
02:00003FBE 00004110        	   210: 	DC.L	GOTO
02:00003FC2 000041BC        	   211: 	DC.L	GOSUB
02:00003FC6 000041E8        	   212: 	DC.L	RETURN
02:00003FCA 000042CE        	   213: 	DC.L	REM
02:00003FCE 0000420A        	   214: 	DC.L	FOR
02:00003FD2 000042F8        	   215: 	DC.L	INPUT
02:00003FD6 00004150        	   216: 	DC.L	PRINT
02:00003FDA 0000445A        	   217: 	DC.L	POKE
02:00003FDE 000040CA        	   218: 	DC.L	STOP
02:00003FE2 00003E08        	   219: 	DC.L	GOBYE
02:00003FE6 00004472        	   220: 	DC.L	CALL
02:00003FEA 00004366        	   221: 	DC.L	DEFLT
02:00003FEE 0000463A        	   222: TAB4_1	DC.L	PEEK			Functions
02:00003FF2 00004646        	   223: 	DC.L	RND
02:00003FF6 0000467A        	   224: 	DC.L	ABS
02:00003FFA 0000468A        	   225: 	DC.L	SIZE
02:00003FFE 00004542        	   226: 	DC.L	XP40
02:00004002 00004224        	   227: TAB5_1	DC.L	FR1			"TO" in "FOR"
02:00004006 000046DA        	   228: 	DC.L	QWHAT
02:0000400A 0000423A        	   229: TAB6_1	DC.L	FR2			"STEP" in "FOR"
02:0000400E 00004240        	   230: 	DC.L	FR3
02:00004012 00004496        	   231: TAB8_1	DC.L	XP11	>=		Relational operators
02:00004016 0000449C        	   232: 	DC.L	XP12	<>
02:0000401A 000044A2        	   233: 	DC.L	XP13	>
02:0000401E 000044AE        	   234: 	DC.L	XP15	=
02:00004022 000044A8        	   235: 	DC.L	XP14	<=
02:00004026 000044B6        	   236: 	DC.L	XP16	<
02:0000402A 000044C6        	   237: 	DC.L	XP17
                            	   238: *
02:0000402E 43FAFED0        	   239: DIRECT	LEA	TAB1,A1
02:00004032 45FAFF52        	   240: 	LEA	TAB1_1,A2
02:00004036 61000958        	   241: EXEC	bsr	IGNBLK		ignore leading blanks
02:0000403A 2648            	   242: 	MOVE.L	A0,A3		save the pointer
02:0000403C 4202            	   243: 	CLR.B	D2		clear match flag
02:0000403E 1018            	   244: EXLP	MOVE.B	(A0)+,D0	get the program character
02:00004040 1211            	   245: 	MOVE.B	(A1),D1 	get the table character
02:00004042 6604            	   246: 	BNE	EXNGO		If end of table,
02:00004044 204B            	   247: 	MOVE.L	A3,A0		restore the text pointer and...
02:00004046 6024            	   248: 	BRA	EXGO		execute the default.
02:00004048 1600            	   249: EXNGO	MOVE.B	D0,D3		Else check for period...
02:0000404A C602            	   250: 	AND.B	D2,D3		and a match.
02:0000404C B63C002E        	   251: 	CMP.B	#'.',D3
02:00004050 671A            	   252: 	BEQ	EXGO		if so, execute
02:00004052 C23C007F        	   253: 	AND.B	#$7F,D1 	ignore the table's high bit
02:00004056 B200            	   254: 	CMP.B	D0,D1		is there a match?
02:00004058 670C            	   255: 	BEQ	EXMAT
02:0000405A 588A            	   256: 	ADDQ.L	#4,A2		if not, try the next entry
02:0000405C 204B            	   257: 	MOVE.L	A3,A0		reset the program pointer
02:0000405E 4202            	   258: 	CLR.B	D2		sorry, no match
02:00004060 4A19            	   259: EX1	TST.B	(A1)+		get to the end of the entry
02:00004062 6AFC            	   260: 	BPL	EX1
02:00004064 60D8            	   261: 	BRA	EXLP		back for more matching
02:00004066 74FF            	   262: EXMAT	MOVEQ	#-1,D2		we've got a match so far
02:00004068 4A19            	   263: 	TST.B	(A1)+		end of table entry?
02:0000406A 6AD2            	   264: 	BPL	EXLP		if not, go back for more
02:0000406C 97CB            	   265: EXGO	LEA	0,A3		execute the appropriate routine
02:0000406E 2652            	   266: 	MOVE.L	(A2),A3
02:00004070 4ED3            	   267: 	JMP	(A3)
                            	   268: *
                            	   269: *******************************************************************
                            	   270: * Console redirection
                            	   271: * <COM will redirect input to the COM port
                            	   272: * >COM will redirect output to the COM port
                            	   273: * <CON will redirect input to the console
                            	   274: * >CON will redirect output to the console
                            	   275: * <>COM will redirect input and output to the COM port
                            	   276: * <>CON will redirect input and output to the console
                            	   277: *******************************************************************
                            	   278: INCON
02:00004072 23FC00004A2C0000	   279: 	move.l	#INC1,INPPTR
02:0000407A 4ABE
02:0000407C 60000136        	   280: 	bra			FINISH
                            	   281: INCOM
02:00004080 23FC00004A500000	   282: 	move.l	#AUXIN,INPPTR
02:00004088 4ABE
02:0000408A 60000128        	   283: 	bra			FINISH
                            	   284: IOCOM
02:0000408E 23FC00004A500000	   285: 	move.l	#AUXIN,INPPTR
02:00004096 4ABE
                            	   286: OUTCOM
02:00004098 23FC00004A400000	   287: 	move.l	#AUXOUT,OUTPTR
02:000040A0 4AC2
02:000040A2 60000110        	   288: 	bra			FINISH
                            	   289: IOCON
02:000040A6 23FC00004A2C0000	   290: 	move.l	#INC1,INPPTR
02:000040AE 4ABE
                            	   291: OUTCON
02:000040B0 23FC00004A100000	   292: 	move.l	#OUTC1,OUTPTR
02:000040B8 4AC2
02:000040BA 600000F8        	   293: 	bra			FINISH
                            	   294: 
                            	   295: *******************************************************************
                            	   296: *
                            	   297: * What follows is the code to execute direct and statement
                            	   298: * commands. Control is transferred to these points via the command
                            	   299: * table lookup code of 'DIRECT' and 'EXEC' in the last section.
                            	   300: * After the command is executed, control is transferred to other
                            	   301: * sections as follows:
                            	   302: *
                            	   303: * For 'LIST', 'NEW', and 'STOP': go back to the warm start point.
                            	   304: * For 'RUN': go execute the first stored line if any; else go
                            	   305: * back to the warm start point.
                            	   306: * For 'GOTO' and 'GOSUB': go execute the target line.
                            	   307: * For 'RETURN' and 'NEXT'; go back to saved return line.
                            	   308: * For all others: if 'CURRNT' is 0, go to warm start; else go
                            	   309: * execute next command. (This is done in 'FINISH'.)
                            	   310: *
                            	   311: *******************************************************************
                            	   312: *
                            	   313: * *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                            	   314: *
                            	   315: * 'NEW<CR>' sets TXTUNF to point to TXTBGN
                            	   316: *
                            	   317: * 'STOP<CR>' goes back to WSTART
                            	   318: *
                            	   319: * 'RUN<CR>' finds the first stored line, stores its address
                            	   320: * in CURRNT, and starts executing it. Note that only those
                            	   321: * commands in TAB2 are legal for a stored program.
                            	   322: *
                            	   323: * There are 3 more entries in 'RUN':
                            	   324: * 'RUNNXL' finds next line, stores it's address and executes it.
                            	   325: * 'RUNTSL' stores the address of this line and executes it.
                            	   326: * 'RUNSML' continues the execution on same line.
                            	   327: *
                            	   328: * 'GOTO expr<CR>' evaluates the expression, finds the target
                            	   329: * line, and jumps to 'RUNTSL' to do it.
                            	   330: *
02:000040BE 61000608        	   331: NEW	bsr	ENDCHK
02:000040C2 23FAFD4800004AE6	   332: 	MOVE.L	TXTBGN,TXTUNF	set the end pointer
                            	   333: 
02:000040CA 610005FC        	   334: STOP	bsr	ENDCHK
02:000040CE 6000FD88        	   335: 	BRA	WSTART
                            	   336: 
02:000040D2 610005F4        	   337: RUN	bsr	ENDCHK
02:000040D6 207AFD34        	   338: 	MOVE.L	TXTBGN,A0	set pointer to beginning
02:000040DA 23C800004AC6    	   339: 	MOVE.L	A0,CURRNT
                            	   340: 
02:000040E0 4AB900004AC6    	   341: RUNNXL	TST.L	CURRNT		executing a program?
02:000040E6 6700FD70        	   342: 	beq	WSTART		if not, we've finished a direct stat.
02:000040EA 7200            	   343: 	CLR.L	D1		else find the next line number
02:000040EC 2248            	   344: 	MOVE.L	A0,A1
02:000040EE 610006E6        	   345: 	bsr	FNDLNP
02:000040F2 6500FD64        	   346: 	BCS	WSTART		if we've fallen off the end, stop
                            	   347: 
02:000040F6 23C900004AC6    	   348: RUNTSL	MOVE.L	A1,CURRNT	set CURRNT to point to the line no.
02:000040FC 2049            	   349: 	MOVE.L	A1,A0		set the text pointer to
02:000040FE 5488            	   350: 	ADDQ.L	#2,A0		the start of the line text
                            	   351: 
02:00004100 610008E4        	   352: RUNSML	bsr	CHKIO		see if a control-C was pressed
02:00004104 43FAFE26        	   353: 	LEA	TAB2,A1 	find command in TAB2
02:00004108 45FAFEA8        	   354: 	LEA	TAB2_1,A2
02:0000410C 6000FF28        	   355: 	BRA	EXEC		and execute it
                            	   356: 
02:00004110 61000374        	   357: GOTO	bsr	EXPR		evaluate the following expression
02:00004114 610005B2        	   358: 	bsr	ENDCHK		must find end of line
02:00004118 2200            	   359: 	MOVE.L	D0,D1
02:0000411A 610006AC        	   360: 	bsr	FNDLN		find the target line
02:0000411E 66000602        	   361: 	bne	QHOW		no such line no.
02:00004122 60D2            	   362: 	BRA	RUNTSL		go do it
                            	   363: 
                            	   364: *
                            	   365: *******************************************************************
                            	   366: *
                            	   367: * *** LIST *** PRINT ***
                            	   368: *
                            	   369: * LIST has two forms:
                            	   370: * 'LIST<CR>' lists all saved lines
                            	   371: * 'LIST #<CR>' starts listing at the line #
                            	   372: * Control-S pauses the listing, control-C stops it.
                            	   373: *
                            	   374: * PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                            	   375: * where '....' is a list of expressions, formats, back-arrows,
                            	   376: * and strings.	These items a separated by commas.
                            	   377: *
                            	   378: * A format is a pound sign followed by a number.  It controls
                            	   379: * the number of spaces the value of an expression is going to
                            	   380: * be printed in.  It stays effective for the rest of the print
                            	   381: * command unless changed by another format.  If no format is
                            	   382: * specified, 11 positions will be used.
                            	   383: *
                            	   384: * A string is quoted in a pair of single- or double-quotes.
                            	   385: *
                            	   386: * An underline (back-arrow) means generate a <CR> without a <LF>
                            	   387: *
                            	   388: * A <CR LF> is generated after the entire list has been printed
                            	   389: * or if the list is empty.  If the list ends with a semicolon,
                            	   390: * however, no <CR LF> is generated.
                            	   391: *
                            	   392: 
02:00004124 61000834        	   393: LIST	bsr	TSTNUM		see if there's a line no.
02:00004128 6100059E        	   394: 	bsr	ENDCHK		if not, we get a zero
02:0000412C 6100069A        	   395: 	bsr	FNDLN		find this or next line
02:00004130 65000082        	   396: LS1	BCS	FINISH		warm start if we passed the end
02:00004134 610007F2        	   397: 	bsr	PRTLN		print the line
02:00004138 610008AC        	   398: 	bsr	CHKIO		check for listing halt request
02:0000413C 670C            	   399: 	BEQ	LS3
02:0000413E B03C0013        	   400: 	CMP.B	#CTRLS,D0	pause the listing?
02:00004142 6606            	   401: 	BNE	LS3
02:00004144 610008A0        	   402: LS2	bsr	CHKIO		if so, wait for another keypress
02:00004148 67FA            	   403: 	BEQ	LS2
02:0000414A 6100068A        	   404: LS3	bsr	FNDLNP		find the next line
02:0000414E 60E0            	   405: 	BRA	LS1
                            	   406: 
02:00004150 383C000B        	   407: PRINT	MOVE	#11,D4		D4 = number of print spaces
02:00004154 610007EC        	   408: 	bsr	TSTC		if null list and ":"
02:00004158 3A              	   409: 	DC.B	':',PR2-*
02:00004159 07
02:0000415A 61000D04        	   410: 	bsr	CRLF		give CR-LF and continue
02:0000415E 60A0            	   411: 	BRA	RUNSML		execution on the same line
02:00004160 610007E0        	   412: PR2	bsr	TSTC		if null list and <CR>
02:00004164 0D              	   413: 	DC.B	CR,PR0-*
02:00004165 09
02:00004166 61000CF8        	   414: 	bsr	CRLF		also give CR-LF and
02:0000416A 6000FF74        	   415: 	BRA	RUNNXL		execute the next line
02:0000416E 610007D2        	   416: PR0	bsr	TSTC		else is it a format?
02:00004172 23              	   417: 	DC.B	'#',PR1-*
02:00004173 09
02:00004174 61000310        	   418: 	bsr	EXPR		yes, evaluate expression
02:00004178 3800            	   419: 	MOVE	D0,D4		and save it as print width
02:0000417A 6016            	   420: 	BRA	PR3		look for more to print
02:0000417C 610007C4        	   421: PR1	bsr	TSTC		is character expression? (MRL)
02:00004180 24              	   422: 	DC.B	'$',PR4-*
02:00004181 0B
02:00004182 61000302        	   423: 	bsr	EXPR		yep. Evaluate expression (MRL)
02:00004186 6100FC70        	   424: 	BSR	GOOUT		print low byte (MRL)
02:0000418A 6006            	   425: 	BRA	PR3		look for more. (MRL)
02:0000418C 610006E8        	   426: PR4	bsr	QTSTG		is it a string?
02:00004190 6012            	   427: 	BRA.S	PR8		if not, must be an expression
02:00004192 610007AE        	   428: PR3	bsr	TSTC		if ",", go find next
02:00004196 2C              	   429: 	DC.B	',',PR6-*
02:00004197 07
02:00004198 61000514        	   430: 	bsr	FIN		in the list.
02:0000419C 60D0            	   431: 	BRA	PR0
02:0000419E 61000CC0        	   432: PR6	bsr	CRLF		list ends here
02:000041A2 6010            	   433: 	BRA	FINISH
02:000041A4 3F04            	   434: PR8	MOVE	D4,-(SP)	save the width value
02:000041A6 610002DE        	   435: 	bsr	EXPR		evaluate the expression
02:000041AA 381F            	   436: 	MOVE	(SP)+,D4	restore the width
02:000041AC 2200            	   437: 	MOVE.L	D0,D1
02:000041AE 61000704        	   438: 	bsr	PRTNUM		print its value
02:000041B2 60DE            	   439: 	BRA	PR3		more to print?
                            	   440: 
02:000041B4 610004F8        	   441: FINISH	bsr	FIN		Check end of command
02:000041B8 60000520        	   442: 	BRA	QWHAT		print "What?" if wrong
                            	   443: 
                            	   444: *
                            	   445: *******************************************************************
                            	   446: *
                            	   447: * *** GOSUB *** & RETURN ***
                            	   448: *
                            	   449: * 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                            	   450: * except that the current text pointer, stack pointer, etc. are
                            	   451: * saved so that execution can be continued after the subroutine
                            	   452: * 'RETURN's.  In order that 'GOSUB' can be nested (and even
                            	   453: * recursive), the save area must be stacked.  The stack pointer
                            	   454: * is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                            	   455: * If we are in the main routine, 'STKGOS' is zero (this was done
                            	   456: * in the initialization section of the interpreter), but we still
                            	   457: * save it as a flag for no further 'RETURN's.
                            	   458: *
                            	   459: * 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                            	   460: * returns the execution to the command after the most recent
                            	   461: * 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                            	   462: * a 'GOSUB' and is thus an error.
                            	   463: *
02:000041BC 61000676        	   464: GOSUB	bsr	PUSHA		save the current 'FOR' parameters
02:000041C0 610002C4        	   465: 	bsr	EXPR		get line number
02:000041C4 2F08            	   466: 	MOVE.L	A0,-(SP)	save text pointer
02:000041C6 2200            	   467: 	MOVE.L	D0,D1
02:000041C8 610005FE        	   468: 	bsr	FNDLN		find the target line
02:000041CC 66000556        	   469: 	BNE	AHOW		if not there, say "How?"
02:000041D0 2F3A08F4        	   470: 	MOVE.L	CURRNT,-(SP)	found it, save old 'CURRNT'...
02:000041D4 2F3A08F4        	   471: 	MOVE.L	STKGOS,-(SP)	and 'STKGOS'
02:000041D8 42B900004AD2    	   472: 	CLR.L	LOPVAR		load new values
02:000041DE 23CF00004ACA    	   473: 	MOVE.L	SP,STKGOS
02:000041E4 6000FF10        	   474: 	BRA	RUNTSL
                            	   475: 
02:000041E8 610004DE        	   476: RETURN	bsr	ENDCHK		there should be just a <CR>
02:000041EC 223A08DC        	   477: 	MOVE.L	STKGOS,D1	get old stack pointer
02:000041F0 670004E8        	   478: 	BEQ	QWHAT		if zero, it doesn't exist
02:000041F4 2E41            	   479: 	MOVE.L	D1,SP		else restore it
02:000041F6 23DF00004ACA    	   480: 	MOVE.L	(SP)+,STKGOS	and the old 'STKGOS'
02:000041FC 23DF00004AC6    	   481: 	MOVE.L	(SP)+,CURRNT	and the old 'CURRNT'
02:00004202 205F            	   482: 	MOVE.L	(SP)+,A0	and the old text pointer
02:00004204 6100060A        	   483: 	bsr	POPA		and the old 'FOR' parameters
02:00004208 60AA            	   484: 	BRA	FINISH		and we are back home
                            	   485: 
                            	   486: *
                            	   487: *******************************************************************
                            	   488: *
                            	   489: * *** FOR *** & NEXT ***
                            	   490: *
                            	   491: * 'FOR' has two forms:
                            	   492: * 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                            	   493: * The second form means the same thing as the first form with a
                            	   494: * STEP of positive 1.  The interpreter will find the variable 'var'
                            	   495: * and set its value to the current value of 'exp1'.  It also
                            	   496: * evaluates 'exp2' and 'exp1' and saves all these together with
                            	   497: * the text pointer, etc. in the 'FOR' save area, which consisits of
                            	   498: * 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                            	   499: * already something in the save area (indicated by a non-zero
                            	   500: * 'LOPVAR'), then the old save area is saved on the stack before
                            	   501: * the new values are stored.  The interpreter will then dig in the
                            	   502: * stack and find out if this same variable was used in another
                            	   503: * currently active 'FOR' loop.  If that is the case, then the old
                            	   504: * 'FOR' loop is deactivated. (i.e. purged from the stack)
                            	   505: *
                            	   506: * 'NEXT var' serves as the logical (not necessarily physical) end
                            	   507: * of the 'FOR' loop.  The control variable 'var' is checked with
                            	   508: * the 'LOPVAR'.  If they are not the same, the interpreter digs in
                            	   509: * the stack to find the right one and purges all those that didn't
                            	   510: * match.  Either way, it then adds the 'STEP' to that variable and
                            	   511: * checks the result with against the limit value.  If it is within
                            	   512: * the limit, control loops back to the command following the
                            	   513: * 'FOR'.  If it's outside the limit, the save area is purged and
                            	   514: * execution continues.
                            	   515: *
02:0000420A 61000628        	   516: FOR	bsr	PUSHA		save the old 'FOR' save area
02:0000420E 61000484        	   517: 	bsr	SETVAL		set the control variable
02:00004212 23CE00004AD2    	   518: 	MOVE.L	A6,LOPVAR	save its address
02:00004218 43FAFD59        	   519: 	LEA	TAB5,A1 	use 'EXEC' to test for 'TO'
02:0000421C 45FAFDE4        	   520: 	LEA	TAB5_1,A2
02:00004220 6000FE14        	   521: 	BRA	EXEC
02:00004224 61000260        	   522: FR1	bsr	EXPR		evaluate the limit
02:00004228 23C000004ADA    	   523: 	MOVE.L	D0,LOPLMT	save that
02:0000422E 43FAFD46        	   524: 	LEA	TAB6,A1 	use 'EXEC' to look for the
02:00004232 45FAFDD6        	   525: 	LEA	TAB6_1,A2	word 'STEP'
02:00004236 6000FDFE        	   526: 	BRA	EXEC
02:0000423A 6100024A        	   527: FR2	bsr	EXPR		found it, get the step value
02:0000423E 6002            	   528: 	BRA	FR4
02:00004240 7001            	   529: FR3	MOVEQ	#1,D0		not found, step defaults to 1
02:00004242 23C000004AD6    	   530: FR4	MOVE.L	D0,LOPINC	save that too
02:00004248 23FA087C00004ADE	   531: FR5	MOVE.L	CURRNT,LOPLN	save address of current line number
02:00004250 23C800004AE2    	   532: 	MOVE.L	A0,LOPPT	and text pointer
02:00004256 2C4F            	   533: 	MOVE.L	SP,A6		dig into the stack to find 'LOPVAR'
02:00004258 6004            	   534: 	BRA	FR7
02:0000425A 4DEE0014        	   535: FR6	ADD.L	#20,A6		look at next stack frame
02:0000425E 2016            	   536: FR7	MOVE.L	(A6),D0 	is it zero?
02:00004260 6716            	   537: 	BEQ	FR8		if so, we're done
02:00004262 B0BA086E        	   538: 	CMP.L	LOPVAR,D0	same as current LOPVAR?
02:00004266 66F2            	   539: 	BNE	FR6		nope, look some more
02:00004268 244F            	   540: 	MOVE.L	SP,A2		Else remove 5 long words from...
02:0000426A 224E            	   541: 	MOVE.L	A6,A1		inside the stack.
02:0000426C 47F80014        	   542: 	LEA	20,A3
02:00004270 D7C9            	   543: 	ADD.L	A1,A3
02:00004272 61000594        	   544: 	bsr	MVDOWN
02:00004276 2E4B            	   545: 	MOVE.L	A3,SP		set the SP 5 long words up
02:00004278 6000FF3A        	   546: FR8	BRA	FINISH		and continue execution
                            	   547: 
02:0000427C 610002F0        	   548: NEXT	bsr	TSTV		get address of variable
02:00004280 65000458        	   549: 	BCS	QWHAT		if no variable, say "What?"
02:00004284 2240            	   550: 	MOVE.L	D0,A1		save variable's address
02:00004286 203A084A        	   551: NX0	MOVE.L	LOPVAR,D0	If 'LOPVAR' is zero, we never...
02:0000428A 6700044E        	   552: 	BEQ	QWHAT		had a FOR loop, so say "What?"
02:0000428E B3C0            	   553: 	CMP.L	D0,A1		else we check them
02:00004290 6706            	   554: 	BEQ	NX3		OK, they agree
02:00004292 6100057C        	   555: 	bsr	POPA		nope, let's see the next frame
02:00004296 60EE            	   556: 	BRA	NX0
02:00004298 2011            	   557: NX3	MOVE.L	(A1),D0 	get control variable's value
02:0000429A D0BA083A        	   558: 	ADD.L	LOPINC,D0	add in loop increment
02:0000429E 69000482        	   559: 	BVS	QHOW		say "How?" for 32-bit overflow
02:000042A2 2280            	   560: 	MOVE.L	D0,(A1) 	save control variable's new value
02:000042A4 223A0834        	   561: 	MOVE.L	LOPLMT,D1	get loop's limit value
02:000042A8 4AB900004AD6    	   562: 	TST.L	LOPINC
02:000042AE 6A02            	   563: 	BPL	NX1		branch if loop increment is positive
02:000042B0 C141            	   564: 	EXG	D0,D1
02:000042B2 B280            	   565: NX1	CMP.L	D0,D1		test against limit
02:000042B4 6D10            	   566: 	BLT	NX2		branch if outside limit
02:000042B6 23FA082600004AC6	   567: 	MOVE.L	LOPLN,CURRNT	Within limit, go back to the...
02:000042BE 207A0822        	   568: 	MOVE.L	LOPPT,A0	saved 'CURRNT' and text pointer.
02:000042C2 6000FEF0        	   569: 	BRA	FINISH
02:000042C6 61000548        	   570: NX2	bsr	POPA		purge this loop
02:000042CA 6000FEE8        	   571: 	BRA	FINISH
                            	   572: 
                            	   573: *
                            	   574: *******************************************************************
                            	   575: *
                            	   576: * *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                            	   577: *
                            	   578: * 'REM' can be followed by anything and is ignored by the
                            	   579: * interpreter.
                            	   580: *
                            	   581: * 'IF' is followed by an expression, as a condition and one or
                            	   582: * more commands (including other 'IF's) separated by colons.
                            	   583: * Note that the word 'THEN' is not used.  The interpreter evaluates
                            	   584: * the expression.  If it is non-zero, execution continues.  If it
                            	   585: * is zero, the commands that follow are ignored and execution
                            	   586: * continues on the next line.
                            	   587: *
                            	   588: * 'INPUT' is like the 'PRINT' command, and is followed by a list
                            	   589: * of items.  If the item is a string in single or double quotes,
                            	   590: * or is an underline (back arrow), it has the same effect as in
                            	   591: * 'PRINT'.  If an item is a variable, this variable name is
                            	   592: * printed out followed by a colon, then the interpreter waits for
                            	   593: * an expression to be typed in.  The variable is then set to the
                            	   594: * value of this expression.  If the variable is preceeded by a
                            	   595: * string (again in single or double quotes), the string will be
                            	   596: * displayed followed by a colon.  The interpreter the waits for an
                            	   597: * expression to be entered and sets the variable equal to the
                            	   598: * expression's value.  If the input expression is invalid, the
                            	   599: * interpreter will print "What?", "How?", or "Sorry" and reprint
                            	   600: * the prompt and redo the input.  The execution will not terminate
                            	   601: * unless you press control-C.  This is handled in 'INPERR'.
                            	   602: *
                            	   603: * 'LET' is followed by a list of items separated by commas.
                            	   604: * Each item consists of a variable, an equals sign, and an
                            	   605: * expression.  The interpreter evaluates the expression and sets
                            	   606: * the variable to that value.  The interpreter will also handle
                            	   607: * 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                            	   608: *
02:000042CE 600A            	   609: REM	BRA	IF2		skip the rest of the line
                            	   610: 
02:000042D0 610001B4        	   611: IF	bsr	EXPR		evaluate the expression
02:000042D4 4A80            	   612: IF1	TST.L	D0		is it zero?
02:000042D6 6600FE28        	   613: 	BNE	RUNSML		if not, continue
02:000042DA 2248            	   614: IF2	MOVE.L	A0,A1
02:000042DC 7200            	   615: 	CLR.L	D1
02:000042DE 61000510        	   616: 	bsr	FNDSKP		if so, skip the rest of the line
02:000042E2 6400FE12        	   617: 	BCC	RUNTSL		and run the next line
02:000042E6 6000FB70        	   618: 	BRA	WSTART		if no next line, do a warm start
                            	   619: 
02:000042EA 2E7A07E2        	   620: INPERR	MOVE.L	STKINP,SP	restore the old stack pointer
02:000042EE 23DF00004AC6    	   621: 	MOVE.L	(SP)+,CURRNT	and old 'CURRNT'
02:000042F4 588F            	   622: 	ADDQ.L	#4,SP
02:000042F6 205F            	   623: 	MOVE.L	(SP)+,A0	and old text pointer
                            	   624: 
02:000042F8 2F08            	   625: INPUT	MOVE.L	A0,-(SP)	save in case of error
02:000042FA 6100057A        	   626: 	bsr	QTSTG		is next item a string?
02:000042FE 600A            	   627: 	BRA.S	IP2		nope
02:00004300 6100026C        	   628: 	bsr	TSTV		yes, but is it followed by a variable?
02:00004304 6552            	   629: 	BCS	IP4		if not, branch
02:00004306 2440            	   630: 	MOVE.L	D0,A2		put away the variable's address
02:00004308 601A            	   631: 	BRA	IP3		if so, input to variable
02:0000430A 2F08            	   632: IP2	MOVE.L	A0,-(SP)	save for 'PRTSTG'
02:0000430C 61000260        	   633: 	bsr	TSTV		must be a variable now
02:00004310 650003C8        	   634: 	BCS	QWHAT		"What?" it isn't?
02:00004314 2440            	   635: 	MOVE.L	D0,A2		put away the variable's address
02:00004316 1410            	   636: 	MOVE.B	(A0),D2 	get ready for 'PRTSTG'
02:00004318 4200            	   637: 	CLR.B	D0
02:0000431A 1080            	   638: 	MOVE.B	D0,(A0)
02:0000431C 225F            	   639: 	MOVE.L	(SP)+,A1
02:0000431E 6100053A        	   640: 	bsr	PRTSTG		print string as prompt
02:00004322 1082            	   641: 	MOVE.B	D2,(A0) 	restore text
02:00004324 2F08            	   642: IP3	MOVE.L	A0,-(SP)	save in case of error
02:00004326 2F3A079E        	   643: 	MOVE.L	CURRNT,-(SP)	also save 'CURRNT'
02:0000432A 23FCFFFFFFFF0000	   644: 	MOVE.L	#-1,CURRNT	flag that we are in INPUT
02:00004332 4AC6
02:00004334 23CF00004ACE    	   645: 	MOVE.L	SP,STKINP	save the stack pointer too
02:0000433A 2F0A            	   646: 	MOVE.L	A2,-(SP)	save the variable address
02:0000433C 103C003A        	   647: 	MOVE.B	#':',D0         print a colon first
02:00004340 610003E8        	   648: 	bsr	GETLN		then get an input line
02:00004344 41FA07AC        	   649: 	LEA	BUFFER,A0	point to the buffer
02:00004348 6100013C        	   650: 	bsr	EXPR		evaluate the input
02:0000434C 245F            	   651: 	MOVE.L	(SP)+,A2	restore the variable address
02:0000434E 2480            	   652: 	MOVE.L	D0,(A2) 	save value in variable
02:00004350 23DF00004AC6    	   653: 	MOVE.L	(SP)+,CURRNT	restore old 'CURRNT'
02:00004356 205F            	   654: 	MOVE.L	(SP)+,A0	and the old text pointer
02:00004358 588F            	   655: IP4	ADDQ.L	#4,SP		clean up the stack
02:0000435A 610005E6        	   656: 	bsr	TSTC		is the next thing a comma?
02:0000435E 2C              	   657: 	DC.B	',',IP5-*
02:0000435F 03
02:00004360 6096            	   658: 	BRA	INPUT		yes, more items
02:00004362 6000FE50        	   659: IP5	BRA	FINISH
                            	   660: 
02:00004366 0C10000D        	   661: DEFLT	CMP.B	#CR,(A0)	empty line is OK
02:0000436A 670C            	   662: 	BEQ	LT1		else it is 'LET'
                            	   663: 
02:0000436C 61000326        	   664: LET	bsr	SETVAL		do the assignment
02:00004370 610005D0        	   665: 	bsr	TSTC		check for more 'LET' items
02:00004374 2C              	   666: 	DC.B	',',LT1-*
02:00004375 03
02:00004376 60F4            	   667: 	BRA	LET
02:00004378 6000FE3A        	   668: LT1	BRA	FINISH		until we are finished.
                            	   669: 
                            	   670: *
                            	   671: *******************************************************************
                            	   672: *
                            	   673: * *** LOAD *** & SAVE ***
                            	   674: *
                            	   675: * These two commands transfer a program to/from an auxiliary
                            	   676: * device such as a cassette, another computer, etc.  The program
                            	   677: * is converted to an easily-stored format: each line starts with
                            	   678: * a colon, the line no. as 4 hex digits, and the rest of the line.
                            	   679: * At the end, a line starting with an '@' sign is sent.  This
                            	   680: * format can be read back with a minimum of processing time by
                            	   681: * the 68000.
                            	   682: *
02:0000437C 207AFA8E        	   683: LOAD	MOVE.L	TXTBGN,A0	set pointer to start of prog. area
02:00004380 103C000D        	   684: 	MOVE.B	#CR,D0		For a CP/M host, tell it we're ready...
02:00004384 6100FA7A        	   685: 	BSR	GOAUXO		by sending a CR to finish PIP command.
                            	   686: LOD1	
02:00004388 6100FA7A        	   687: 	BSR	GOAUXI		look for start of line
02:0000438C 67FA            	   688: 	BEQ	LOD1
02:0000438E B03C0040        	   689: 	CMP.B	#'@',D0         end of program?
02:00004392 671E            	   690: 	BEQ	LODEND
02:00004394 B03C003A        	   691: 	CMP.B	#':',D0         if not, is it start of line?
02:00004398 66EE            	   692: 	BNE	LOD1		if not, wait for it
02:0000439A 6120            	   693: 	BSR	GBYTE		get first byte of line no.
02:0000439C 10C1            	   694: 	MOVE.B	D1,(A0)+	store it
02:0000439E 611C            	   695: 	BSR	GBYTE		get 2nd bye of line no.
02:000043A0 10C1            	   696: 	MOVE.B	D1,(A0)+	store that, too
                            	   697: LOD2
02:000043A2 6100FA60        	   698: 	BSR	GOAUXI		get another text char.
02:000043A6 67FA            	   699: 	BEQ	LOD2
02:000043A8 10C0            	   700: 	MOVE.B	D0,(A0)+	store it
02:000043AA B03C000D        	   701: 	CMP.B	#CR,D0		is it the end of the line?
02:000043AE 66F2            	   702: 	BNE	LOD2		if not, go back for more
02:000043B0 60D6            	   703: 	BRA	LOD1		if so, start a new line
                            	   704: LODEND
02:000043B2 23C800004AE6    	   705: 	MOVE.L	A0,TXTUNF	set end-of program pointer
02:000043B8 6000FA9E        	   706: 	BRA	WSTART		back to direct mode
                            	   707: 
                            	   708: GBYTE
02:000043BC 7401            	   709: 	MOVEQ	#1,D2		get two hex characters from auxiliary
02:000043BE 7200            	   710: 	CLR.L	D1		and store them as a byte in D1
                            	   711: GBYTE1	
02:000043C0 6100FA42        	   712: 	BSR	GOAUXI		get a char.
02:000043C4 67FA            	   713: 	BEQ	GBYTE1
02:000043C6 B03C0041        	   714: 	CMP.B	#'A',D0
02:000043CA 6502            	   715: 	BCS	GBYTE2
02:000043CC 5F00            	   716: 	SUBQ.B	#7,D0		if greater than 9, adjust
                            	   717: GBYTE2
02:000043CE C03C000F        	   718: 	AND.B	#$F,D0		strip ASCII
02:000043D2 E909            	   719: 	LSL.B	#4,D1		put nybble into the result
02:000043D4 8200            	   720: 	OR.B	D0,D1
02:000043D6 51CAFFE8        	   721: 	DBRA	D2,GBYTE1	get another char.
02:000043DA 4E75            	   722: 	RTS
                            	   723: 
                            	   724: SAVE
02:000043DC 207AFA2E        	   725: 	MOVE.L	TXTBGN,A0	set pointer to start of prog. area
02:000043E0 227A0704        	   726: 	MOVE.L	TXTUNF,A1	set pointer to end of prog. area
                            	   727: SAVE1	
02:000043E4 103C000D        	   728: 	MOVE.B	#CR,D0		send out a CR & LF (CP/M likes this)
02:000043E8 6100FA16        	   729: 	BSR	GOAUXO
02:000043EC 103C000A        	   730: 	MOVE.B	#LF,D0
02:000043F0 6100FA0E        	   731: 	BSR	GOAUXO
02:000043F4 B3C8            	   732: 	CMP.L	A0,A1		are we finished?
02:000043F6 631E            	   733: 	BLS	SAVEND
02:000043F8 103C003A        	   734: 	MOVE.B	#':',D0         if not, start a line
02:000043FC 6100FA02        	   735: 	BSR	GOAUXO
02:00004400 1218            	   736: 	MOVE.B	(A0)+,D1	send first half of line no.
02:00004402 6136            	   737: 	BSR	PBYTE
02:00004404 1218            	   738: 	MOVE.B	(A0)+,D1	and send 2nd half
02:00004406 6132            	   739: 	BSR	PBYTE
                            	   740: SAVE2
02:00004408 1018            	   741: 	MOVE.B	(A0)+,D0	get a text char.
02:0000440A B03C000D        	   742: 	CMP.B	#CR,D0		is it the end of the line?
02:0000440E 67D4            	   743: 	BEQ	SAVE1		if so, send CR & LF and start new line
02:00004410 6100F9EE        	   744: 	BSR	GOAUXO		send it out
02:00004414 60F2            	   745: 	BRA	SAVE2		go back for more text
                            	   746: SAVEND
02:00004416 103C0040        	   747: 	MOVE.B	#'@',D0         send end-of-program indicator
02:0000441A 6100F9E4        	   748: 	BSR	GOAUXO
02:0000441E 103C000D        	   749: 	MOVE.B	#CR,D0		followed by a CR & LF
02:00004422 6100F9DC        	   750: 	BSR	GOAUXO
02:00004426 103C000A        	   751: 	MOVE.B	#LF,D0
02:0000442A 6100F9D4        	   752: 	BSR	GOAUXO
02:0000442E 103C001A        	   753: 	MOVE.B	#$1A,D0 	and a control-Z to end the CP/M file
02:00004432 6100F9CC        	   754: 	BSR	GOAUXO
02:00004436 6000FA20        	   755: 	BRA	WSTART		then go do a warm start
                            	   756: 
02:0000443A 7401            	   757: PBYTE	MOVEQ	#1,D2		send two hex characters from D1's low byte
02:0000443C E919            	   758: PBYTE1	ROL.B	#4,D1		get the next nybble
02:0000443E 1001            	   759: 	MOVE.B	D1,D0
02:00004440 C03C000F        	   760: 	AND.B	#$F,D0		strip off garbage
02:00004444 D03C0030        	   761: 	ADD.B	#'0',D0         make it into ASCII
02:00004448 B03C0039        	   762: 	CMP.B	#'9',D0
02:0000444C 6302            	   763: 	BLS	PBYTE2
02:0000444E 5E00            	   764: 	ADDQ.B	#7,D0		adjust if greater than 9
02:00004450 6100F9AE        	   765: PBYTE2	BSR	GOAUXO		send it out
02:00004454 51CAFFE6        	   766: 	DBRA	D2,PBYTE1	then send the next nybble
02:00004458 4E75            	   767: 	RTS
                            	   768: 
                            	   769: *
                            	   770: *******************************************************************
                            	   771: *
                            	   772: * *** POKE *** & CALL ***
                            	   773: *
                            	   774: * 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                            	   775: * address specified by 'expr1'.
                            	   776: *
                            	   777: * 'CALL expr' jumps to the machine language subroutine whose
                            	   778: * starting address is specified by 'expr'.  The subroutine can use
                            	   779: * all registers but must leave the stack the way it found it.
                            	   780: * The subroutine returns to the interpreter by executing an RTS.
                            	   781: *
02:0000445A 612A            	   782: POKE	BSR	EXPR		get the memory address
02:0000445C 610004E4        	   783: 	bsr	TSTC		it must be followed by a comma
02:00004460 2C              	   784: 	DC.B	',',PKER-*
02:00004461 0D
02:00004462 2F00            	   785: 	MOVE.L	D0,-(SP)	save the address
02:00004464 6120            	   786: 	BSR	EXPR		get the byte to be POKE'd
02:00004466 225F            	   787: 	MOVE.L	(SP)+,A1	get the address back
02:00004468 1280            	   788: 	MOVE.B	D0,(A1) 	store the byte in memory
02:0000446A 6000FD48        	   789: 	BRA	FINISH
02:0000446E 6000026A        	   790: PKER	BRA	QWHAT		if no comma, say "What?"
                            	   791: 
02:00004472 6112            	   792: CALL	BSR	EXPR		get the subroutine's address
02:00004474 4A80            	   793: 	TST.L	D0		make sure we got a valid address
02:00004476 670002AA        	   794: 	BEQ	QHOW		if not, say "How?"
02:0000447A 2F08            	   795: 	MOVE.L	A0,-(SP)	save the text pointer
02:0000447C 2240            	   796: 	MOVE.L	D0,A1
02:0000447E 4E91            	   797: 	JSR	(A1)		jump to the subroutine
02:00004480 205F            	   798: 	MOVE.L	(SP)+,A0	restore the text pointer
02:00004482 6000FD30        	   799: 	BRA	FINISH
                            	   800: *
                            	   801: *******************************************************************
                            	   802: *
                            	   803: * *** EXPR ***
                            	   804: *
                            	   805: * 'EXPR' evaluates arithmetical or logical expressions.
                            	   806: * <EXPR>::=<EXPR2>
                            	   807: *	   <EXPR2><rel.op.><EXPR2>
                            	   808: * where <rel.op.> is one of the operators in TAB8 and the result
                            	   809: * of these operations is 1 if true and 0 if false.
                            	   810: * <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                            	   811: * where () are optional and (... are optional repeats.
                            	   812: * <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                            	   813: * <EXPR4>::=<variable>
                            	   814: *	    <function>
                            	   815: *	    (<EXPR>)
                            	   816: * <EXPR> is recursive so that the variable '@' can have an <EXPR>
                            	   817: * as an index, functions can have an <EXPR> as arguments, and
                            	   818: * <EXPR4> can be an <EXPR> in parenthesis.
                            	   819: *
02:00004486 6152            	   820: EXPR	BSR	EXPR2
02:00004488 2F00            	   821: 	MOVE.L	D0,-(SP)	save <EXPR2> value
02:0000448A 43FAFAEF        	   822: 	LEA	TAB8,A1 	look up a relational operator
02:0000448E 45FAFB82        	   823: 	LEA	TAB8_1,A2
02:00004492 6000FBA2        	   824: 	BRA	EXEC		go do it
                            	   825: 
02:00004496 6132            	   826: XP11	BSR	XP18		is it ">="?
02:00004498 6D24            	   827: 	BLT	XPRT0		no, return D0=0
02:0000449A 6026            	   828: 	BRA	XPRT1		else return D0=1
                            	   829: 
02:0000449C 612C            	   830: XP12	BSR	XP18		is it "<>"?
02:0000449E 671E            	   831: 	BEQ	XPRT0		no, return D0=0
02:000044A0 6020            	   832: 	BRA	XPRT1		else return D0=1
                            	   833: 
02:000044A2 6126            	   834: XP13	BSR	XP18		is it ">"?
02:000044A4 6F18            	   835: 	BLE	XPRT0		no, return D0=0
02:000044A6 601A            	   836: 	BRA	XPRT1		else return D0=1
                            	   837: 
02:000044A8 6120            	   838: XP14	BSR	XP18		is it "<="?
02:000044AA 6E12            	   839: 	BGT	XPRT0		no, return D0=0
02:000044AC 6014            	   840: 	BRA	XPRT1		else return D0=1
                            	   841: 
02:000044AE 611A            	   842: XP15	BSR	XP18		is it "="?
02:000044B0 660C            	   843: 	BNE	XPRT0		if not, return D0=0
02:000044B2 600E            	   844: 	BRA	XPRT1		else return D0=1
02:000044B4 4E75            	   845: XP15RT	RTS
                            	   846: 
02:000044B6 6112            	   847: XP16	BSR	XP18		is it "<"?
02:000044B8 6C04            	   848: 	BGE	XPRT0		if not, return D0=0
02:000044BA 6006            	   849: 	BRA	XPRT1		else return D0=1
02:000044BC 4E75            	   850: XP16RT	RTS
                            	   851: 
02:000044BE 7000            	   852: XPRT0	CLR.L	D0		return D0=0 (false)
02:000044C0 4E75            	   853: 	RTS
                            	   854: 
02:000044C2 7001            	   855: XPRT1	MOVEQ	#1,D0		return D0=1 (true)
02:000044C4 4E75            	   856: 	RTS
                            	   857: 
02:000044C6 201F            	   858: XP17	MOVE.L	(SP)+,D0	it's not a rel. operator
02:000044C8 4E75            	   859: 	RTS			return D0=<EXPR2>
                            	   860: 
02:000044CA 201F            	   861: XP18	MOVE.L	(SP)+,D0	reverse the top two stack items
02:000044CC 221F            	   862: 	MOVE.L	(SP)+,D1
02:000044CE 2F00            	   863: 	MOVE.L	D0,-(SP)
02:000044D0 2F01            	   864: 	MOVE.L	D1,-(SP)
02:000044D2 6106            	   865: 	BSR	EXPR2		do second <EXPR2>
02:000044D4 221F            	   866: 	MOVE.L	(SP)+,D1
02:000044D6 B280            	   867: 	CMP.L	D0,D1		compare with the first result
02:000044D8 4E75            	   868: 	RTS			return the result
                            	   869: 
02:000044DA 61000466        	   870: EXPR2	bsr	TSTC		negative sign?
02:000044DE 2D              	   871: 	DC.B	'-',XP21-*
02:000044DF 05
02:000044E0 7000            	   872: 	CLR.L	D0		yes, fake '0-'
02:000044E2 6022            	   873: 	BRA	XP26
02:000044E4 6100045C        	   874: XP21	bsr	TSTC		positive sign? ignore it
02:000044E8 2B              	   875: 	DC.B	'+',XP22-*
02:000044E9 01
02:000044EA 6122            	   876: XP22	BSR	EXPR3		first <EXPR3>
02:000044EC 61000454        	   877: XP23	bsr	TSTC		add?
02:000044F0 2B              	   878: 	DC.B	'+',XP25-*
02:000044F1 0F
02:000044F2 2F00            	   879: 	MOVE.L	D0,-(SP)	yes, save the value
02:000044F4 6118            	   880: 	BSR	EXPR3		get the second <EXPR3>
02:000044F6 221F            	   881: XP24	MOVE.L	(SP)+,D1
02:000044F8 D081            	   882: 	ADD.L	D1,D0		add it to the first <EXPR3>
02:000044FA 69000226        	   883: 	BVS	QHOW		branch if there's an overflow
02:000044FE 60EC            	   884: 	BRA	XP23		else go back for more operations
02:00004500 61000440        	   885: XP25	bsr	TSTC		subtract?
02:00004504 2D              	   886: 	DC.B	'-',XP42-*
02:00004505 63
02:00004506 2F00            	   887: XP26	MOVE.L	D0,-(SP)	yes, save the result of 1st <EXPR3>
02:00004508 6104            	   888: 	BSR	EXPR3		get second <EXPR3>
02:0000450A 4480            	   889: 	NEG.L	D0		change its sign
02:0000450C 60E8            	   890: 	JMP	XP24		and do an addition
                            	   891: 
02:0000450E 6126            	   892: EXPR3	BSR	EXPR4		get first <EXPR4>
02:00004510 61000430        	   893: XP31	bsr	TSTC		multiply?
02:00004514 2A              	   894: 	DC.B	'*',XP34-*
02:00004515 0D
02:00004516 2F00            	   895: 	MOVE.L	D0,-(SP)	yes, save that first result
02:00004518 611C            	   896: 	BSR	EXPR4		get second <EXPR4>
02:0000451A 221F            	   897: 	MOVE.L	(SP)+,D1
02:0000451C 6100009E        	   898: 	bsr	MULT32		multiply the two
02:00004520 60EE            	   899: 	BRA	XP31		then look for more terms
02:00004522 6100041E        	   900: XP34	bsr	TSTC		divide?
02:00004526 2F              	   901: 	DC.B	'/',XP42-*
02:00004527 41
02:00004528 2F00            	   902: 	MOVE.L	D0,-(SP)	save result of 1st <EXPR4>
02:0000452A 610A            	   903: 	BSR	EXPR4		get second <EXPR4>
02:0000452C 221F            	   904: 	MOVE.L	(SP)+,D1
02:0000452E C141            	   905: 	EXG	D0,D1
02:00004530 610000CC        	   906: 	bsr	DIV32		do the division
02:00004534 60DA            	   907: 	BRA	XP31		go back for any more terms
                            	   908: 
02:00004536 43FAFA2C        	   909: EXPR4	LEA	TAB4,A1 	find possible function
02:0000453A 45FAFAB2        	   910: 	LEA	TAB4_1,A2
02:0000453E 6000FAF6        	   911: 	BRA	EXEC
02:00004542 612A            	   912: XP40	BSR	TSTV		nope, not a function
02:00004544 6508            	   913: 	BCS	XP41		nor a variable
02:00004546 2240            	   914: 	MOVE.L	D0,A1
02:00004548 7000            	   915: 	CLR.L	D0
02:0000454A 2011            	   916: 	MOVE.L	(A1),D0 	if a variable, return its value in D0
02:0000454C 4E75            	   917: EXP4RT	RTS
02:0000454E 6100040A        	   918: XP41	bsr	TSTNUM		or is it a number?
02:00004552 2001            	   919: 	MOVE.L	D1,D0
02:00004554 4A42            	   920: 	TST	D2		(if not, # of digits will be zero)
02:00004556 66F4            	   921: 	BNE	EXP4RT		if so, return it in D0
02:00004558 610003E8        	   922: PARN	bsr	TSTC		else look for ( EXPR )
02:0000455C 28              	   923: 	DC.B	'(',XP43-*
02:0000455D 0D
02:0000455E 6100FF26        	   924: 	BSR	EXPR
02:00004562 610003DE        	   925: 	bsr	TSTC
02:00004566 29              	   926: 	DC.B	')',XP43-*
02:00004567 03
02:00004568 4E75            	   927: XP42	RTS
02:0000456A 6000016E        	   928: XP43	BRA	QWHAT		else say "What?"
                            	   929: 
                            	   930: *
                            	   931: * ===== Test for a valid variable name.  Returns Carry=1 if not
                            	   932: *	found, else returns Carry=0 and the address of the
                            	   933: *	variable in D0.
                            	   934: 
02:0000456E 61000420        	   935: TSTV	bsr	IGNBLK
02:00004572 7000            	   936: 	CLR.L	D0
02:00004574 1010            	   937: 	MOVE.B	(A0),D0 	look at the program text
02:00004576 903C0040        	   938: 	SUB.B	#'@',D0
02:0000457A 653E            	   939: 	BCS	TSTVRT		C=1: not a variable
02:0000457C 6626            	   940: 	BNE	TV1		branch if not "@" array
02:0000457E 5248            	   941: 	ADDQ	#1,A0		If it is, it should be
02:00004580 61D6            	   942: 	BSR	PARN		followed by (EXPR) as its index.
02:00004582 D080            	   943: 	ADD.L	D0,D0
02:00004584 6500019C        	   944: 	BCS	QHOW		say "How?" if index is too big
02:00004588 D080            	   945: 	ADD.L	D0,D0
02:0000458A 65000196        	   946: 	BCS	QHOW
02:0000458E 2F00            	   947: 	MOVE.L	D0,-(SP)	save the index
02:00004590 610000F8        	   948: 	bsr	SIZE		get amount of free memory
02:00004594 221F            	   949: 	MOVE.L	(SP)+,D1	get back the index
02:00004596 B081            	   950: 	CMP.L	D1,D0		see if there's enough memory
02:00004598 63000180        	   951: 	BLS	QSORRY		if not, say "Sorry"
02:0000459C 203A054C        	   952: 	MOVE.L	VARBGN,D0	put address of array element...
02:000045A0 9081            	   953: 	SUB.L	D1,D0		into D0
02:000045A2 4E75            	   954: 	RTS
02:000045A4 B03C001B        	   955: TV1	CMP.B	#27,D0		if not @, is it A through Z?
02:000045A8 0A3C0001        	   956: 	EOR	#1,CCR
02:000045AC 650C            	   957: 	BCS	TSTVRT		if not, set Carry and return
02:000045AE 5248            	   958: 	ADDQ	#1,A0		else bump the text pointer
02:000045B0 D040            	   959: 	ADD	D0,D0		compute the variable's address
02:000045B2 D040            	   960: 	ADD	D0,D0
02:000045B4 223A0534        	   961: 	MOVE.L	VARBGN,D1
02:000045B8 D041            	   962: 	ADD	D1,D0		and return it in D0 with Carry=0
02:000045BA 4E75            	   963: TSTVRT	RTS
                            	   964: 
                            	   965: *
                            	   966: * ===== Multiplies the 32 bit values in D0 and D1, returning
                            	   967: *	the 32 bit result in D0.
                            	   968: *
02:000045BC 2801            	   969: MULT32	MOVE.L	D1,D4
02:000045BE B184            	   970: 	EOR.L	D0,D4		see if the signs are the same
02:000045C0 4A80            	   971: 	TST.L	D0		take absolute value of D0
02:000045C2 6A02            	   972: 	BPL	MLT1
02:000045C4 4480            	   973: 	NEG.L	D0
02:000045C6 4A81            	   974: MLT1	TST.L	D1		take absolute value of D1
02:000045C8 6A02            	   975: 	BPL	MLT2
02:000045CA 4481            	   976: 	NEG.L	D1
02:000045CC B2BC0000FFFF    	   977: MLT2	CMP.L	#$FFFF,D1	is second argument <= 16 bits?
02:000045D2 630C            	   978: 	BLS	MLT3		OK, let it through
02:000045D4 C141            	   979: 	EXG	D0,D1		else swap the two arguments
02:000045D6 B2BC0000FFFF    	   980: 	CMP.L	#$FFFF,D1	and check 2nd argument again
02:000045DC 62000144        	   981: 	BHI	QHOW		one of them MUST be 16 bits
02:000045E0 3400            	   982: MLT3	MOVE	D0,D2		prepare for 32 bit X 16 bit multiply
02:000045E2 C4C1            	   983: 	MULU	D1,D2		multiply low word
02:000045E4 4840            	   984: 	SWAP	D0
02:000045E6 C0C1            	   985: 	MULU	D1,D0		multiply high word
02:000045E8 4840            	   986: 	SWAP	D0
                            	   987: *** Rick Murray's bug correction follows:
02:000045EA 4A40            	   988: 	TST	D0		if lower word not 0, then overflow
02:000045EC 66000134        	   989: 	BNE	QHOW		if overflow, say "How?"
02:000045F0 D082            	   990: 	ADD.L	D2,D0		D0 now holds the product
02:000045F2 6B00012E        	   991: 	BMI	QHOW		if sign bit set, it's an overflow
02:000045F6 4A84            	   992: 	TST.L	D4		were the signs the same?
02:000045F8 6A02            	   993: 	BPL	MLTRET
02:000045FA 4480            	   994: 	NEG.L	D0		if not, make the result negative
02:000045FC 4E75            	   995: MLTRET	RTS
                            	   996: 
                            	   997: *
                            	   998: * ===== Divide the 32 bit value in D0 by the 32 bit value in D1.
                            	   999: *	Returns the 32 bit quotient in D0, remainder in D1.
                            	  1000: *
02:000045FE 4A81            	  1001: DIV32	TST.L	D1		check for divide-by-zero
02:00004600 67000120        	  1002: 	BEQ	QHOW		if so, say "How?"
02:00004604 2401            	  1003: 	MOVE.L	D1,D2
02:00004606 2801            	  1004: 	MOVE.L	D1,D4
02:00004608 B184            	  1005: 	EOR.L	D0,D4		see if the signs are the same
02:0000460A 4A80            	  1006: 	TST.L	D0		take absolute value of D0
02:0000460C 6A02            	  1007: 	BPL	DIV1
02:0000460E 4480            	  1008: 	NEG.L	D0
02:00004610 4A81            	  1009: DIV1	TST.L	D1		take absolute value of D1
02:00004612 6A02            	  1010: 	BPL	DIV2
02:00004614 4481            	  1011: 	NEG.L	D1
02:00004616 761F            	  1012: DIV2	MOVEQ	#31,D3		iteration count for 32 bits
02:00004618 2200            	  1013: 	MOVE.L	D0,D1
02:0000461A 7000            	  1014: 	CLR.L	D0
02:0000461C D281            	  1015: DIV3	ADD.L	D1,D1		(This algorithm was translated from
02:0000461E D180            	  1016: 	ADDX.L	D0,D0		the divide routine in Ron Cain's
02:00004620 6708            	  1017: 	BEQ	DIV4		Small-C run time library.)
02:00004622 B082            	  1018: 	CMP.L	D2,D0
02:00004624 6B04            	  1019: 	BMI	DIV4
02:00004626 5281            	  1020: 	ADDQ.L	#1,D1
02:00004628 9082            	  1021: 	SUB.L	D2,D0
02:0000462A 51CBFFF0        	  1022: DIV4	DBRA	D3,DIV3
02:0000462E C141            	  1023: 	EXG	D0,D1		put rem. & quot. in proper registers
02:00004630 4A84            	  1024: 	TST.L	D4		were the signs the same?
02:00004632 6A04            	  1025: 	BPL	DIVRT
02:00004634 4480            	  1026: 	NEG.L	D0		if not, results are negative
02:00004636 4481            	  1027: 	NEG.L	D1
02:00004638 4E75            	  1028: DIVRT	RTS
                            	  1029: 
                            	  1030: *
                            	  1031: * ===== The PEEK function returns the byte stored at the address
                            	  1032: *	contained in the following expression.
                            	  1033: *
02:0000463A 6100FF1C        	  1034: PEEK	BSR	PARN		get the memory address
02:0000463E 2240            	  1035: 	MOVE.L	D0,A1
02:00004640 7000            	  1036: 	CLR.L	D0		upper 3 bytes will be zero
02:00004642 1011            	  1037: 	MOVE.B	(A1),D0 	get the addressed byte
02:00004644 4E75            	  1038: 	RTS			and return it
                            	  1039: 
                            	  1040: *
                            	  1041: * ===== The RND function returns a random number from 1 to
                            	  1042: *	the value of the following expression in D0.
                            	  1043: *
02:00004646 6100FF10        	  1044: RND	BSR	PARN		get the upper limit
02:0000464A 4A80            	  1045: 	TST.L	D0		it must be positive and non-zero
02:0000464C 670000D4        	  1046: 	BEQ	QHOW
02:00004650 6B0000D0        	  1047: 	BMI	QHOW
02:00004654 2200            	  1048: 	MOVE.L	D0,D1
02:00004656 227A0462        	  1049: 	MOVE.L	RANPNT,A1	get memory as a random number
02:0000465A B3FC00004ABA    	  1050: 	CMP.L	#LSTROM,A1
02:00004660 6504            	  1051: 	BCS	RA1
02:00004662 43FAF790        	  1052: 	LEA	START,A1	wrap around if end of program
02:00004666 2019            	  1053: RA1	MOVE.L	(A1)+,D0	get the slightly random number
02:00004668 0880001F        	  1054: 	BCLR	#31,D0		make sure it's positive
02:0000466C 23C900004ABA    	  1055: 	MOVE.L	A1,RANPNT	(even I can do better than this!)
02:00004672 618A            	  1056: 	BSR	DIV32		RND(n)=MOD(number,n)+1
02:00004674 2001            	  1057: 	MOVE.L	D1,D0		MOD is the remainder of the div.
02:00004676 5280            	  1058: 	ADDQ.L	#1,D0
02:00004678 4E75            	  1059: 	RTS
                            	  1060: 
                            	  1061: *
                            	  1062: * ===== The ABS function returns an absolute value in D0.
                            	  1063: *
02:0000467A 6100FEDC        	  1064: ABS	BSR	PARN		get the following expr.'s value
02:0000467E 4A80            	  1065: 	TST.L	D0
02:00004680 6A06            	  1066: 	BPL	ABSRT
02:00004682 4480            	  1067: 	NEG.L	D0		if negative, complement it
02:00004684 6B00009C        	  1068: 	BMI	QHOW		if still negative, it was too big
02:00004688 4E75            	  1069: ABSRT	RTS
                            	  1070: 
                            	  1071: *
                            	  1072: * ===== The SIZE function returns the size of free memory in D0.
                            	  1073: *
02:0000468A 203A045E        	  1074: SIZE	MOVE.L	VARBGN,D0	get the number of free bytes...
02:0000468E 90BA0456        	  1075: 	SUB.L	TXTUNF,D0	between 'TXTUNF' and 'VARBGN'
02:00004692 4E75            	  1076: 	RTS			return the number in D0
                            	  1077: 
                            	  1078: *
                            	  1079: *******************************************************************
                            	  1080: *
                            	  1081: * *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                            	  1082: *
                            	  1083: * 'SETVAL' expects a variable, followed by an equal sign and then
                            	  1084: * an expression.  It evaluates the expression and sets the variable
                            	  1085: * to that value.
                            	  1086: *
                            	  1087: * 'FIN' checks the end of a command.  If it ended with ":",
                            	  1088: * execution continues.	If it ended with a CR, it finds the
                            	  1089: * the next line and continues from there.
                            	  1090: *
                            	  1091: * 'ENDCHK' checks if a command is ended with a CR. This is
                            	  1092: * required in certain commands, such as GOTO, RETURN, STOP, etc.
                            	  1093: *
                            	  1094: * 'ERROR' prints the string pointed to by A0. It then prints the
                            	  1095: * line pointed to by CURRNT with a "?" inserted at where the
                            	  1096: * old text pointer (should be on top of the stack) points to.
                            	  1097: * Execution of Tiny BASIC is stopped and a warm start is done.
                            	  1098: * If CURRNT is zero (indicating a direct command), the direct
                            	  1099: * command is not printed. If CURRNT is -1 (indicating
                            	  1100: * 'INPUT' command in progress), the input line is not printed
                            	  1101: * and execution is not terminated but continues at 'INPERR'.
                            	  1102: *
                            	  1103: * Related to 'ERROR' are the following:
                            	  1104: * 'QWHAT' saves text pointer on stack and gets "What?" message.
                            	  1105: * 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                            	  1106: * 'QSORRY' and 'ASORRY' do the same kind of thing.
                            	  1107: * 'QHOW' and 'AHOW' also do this for "How?".
                            	  1108: *
02:00004694 6100FED8        	  1109: SETVAL	BSR	TSTV		variable name?
02:00004698 6540            	  1110: 	BCS	QWHAT		if not, say "What?"
02:0000469A 2F00            	  1111: 	MOVE.L	D0,-(SP)	save the variable's address
02:0000469C 610002A4        	  1112: 	bsr	TSTC		get past the "=" sign
02:000046A0 3D              	  1113: 	DC.B	'=',SV1-*
02:000046A1 0B
02:000046A2 6100FDE2        	  1114: 	BSR	EXPR		evaluate the expression
02:000046A6 2C5F            	  1115: 	MOVE.L	(SP)+,A6
02:000046A8 2C80            	  1116: 	MOVE.L	D0,(A6) 	and save its value in the variable
02:000046AA 4E75            	  1117: 	RTS
02:000046AC 602C            	  1118: SV1	BRA	QWHAT		if no "=" sign
                            	  1119: 
02:000046AE 61000292        	  1120: FIN	bsr	TSTC		*** FIN ***
02:000046B2 3A              	  1121: 	DC.B	':',FI1-*
02:000046B3 07
02:000046B4 588F            	  1122: 	ADDQ.L	#4,SP		if ":", discard return address
02:000046B6 6000FA48        	  1123: 	BRA	RUNSML		continue on the same line
02:000046BA 61000286        	  1124: FI1	bsr	TSTC		not ":", is it a CR?
02:000046BE 0D              	  1125: 	DC.B	CR,FI2-*
02:000046BF 07
02:000046C0 588F            	  1126: 	ADDQ.L	#4,SP		yes, purge return address
02:000046C2 6000FA1C        	  1127: 	BRA	RUNNXL		execute the next line
02:000046C6 4E75            	  1128: FI2	RTS			else return to the caller
                            	  1129: 
02:000046C8 610002C6        	  1130: ENDCHK	bsr	IGNBLK
02:000046CC 0C10003A        	  1131: 	CMP.B #':',(a0)
02:000046D0 6706            	  1132: 	BEQ ENDCHK1
02:000046D2 0C10000D        	  1133: 	CMP.B	#CR,(A0)	does it end with a CR?
02:000046D6 6602            	  1134: 	BNE	QWHAT		if not, say "WHAT?"
                            	  1135: ENDCHK1:
02:000046D8 4E75            	  1136: 	RTS
                            	  1137: 
02:000046DA 2F08            	  1138: QWHAT	MOVE.L	A0,-(SP)
02:000046DC 4DFA03CA        	  1139: AWHAT	LEA	WHTMSG,A6
02:000046E0 61000316        	  1140: ERROR	bsr	PRMESG		display the error message
02:000046E4 205F            	  1141: 	MOVE.L	(SP)+,A0	restore the text pointer
02:000046E6 203A03DE        	  1142: 	MOVE.L	CURRNT,D0	get the current line number
02:000046EA 6700F76C        	  1143: 	BEQ	WSTART		if zero, do a warm start
02:000046EE B0BCFFFFFFFF    	  1144: 	CMP.L	#-1,D0		is the line no. pointer = -1?
02:000046F4 6700FBF4        	  1145: 	BEQ	INPERR		if so, redo input
02:000046F8 1F10            	  1146: 	MOVE.B	(A0),-(SP)	save the char. pointed to
02:000046FA 4210            	  1147: 	CLR.B	(A0)		put a zero where the error is
02:000046FC 227A03C8        	  1148: 	MOVE.L	CURRNT,A1	point to start of current line
02:00004700 61000226        	  1149: 	bsr	PRTLN		display the line in error up to the 0
02:00004704 109F            	  1150: 	MOVE.B	(SP)+,(A0)	restore the character
02:00004706 103C003F        	  1151: 	MOVE.B	#'?',D0         display a "?"
02:0000470A 6100F6EC        	  1152: 	BSR	GOOUT
02:0000470E 4240            	  1153: 	CLR	D0
02:00004710 5389            	  1154: 	SUBQ.L	#1,A1		point back to the error char.
02:00004712 61000146        	  1155: 	bsr	PRTSTG		display the rest of the line
02:00004716 6000F740        	  1156: 	BRA	WSTART		and do a warm start
02:0000471A 2F08            	  1157: QSORRY	MOVE.L	A0,-(SP)
02:0000471C 4DFA0392        	  1158: ASORRY	LEA	SRYMSG,A6
02:00004720 60BE            	  1159: 	BRA	ERROR
02:00004722 2F08            	  1160: QHOW	MOVE.L	A0,-(SP)	Error: "How?"
02:00004724 4DFA037B        	  1161: AHOW	LEA	HOWMSG,A6
02:00004728 60B6            	  1162: 	BRA	ERROR
                            	  1163: *
                            	  1164: *******************************************************************
                            	  1165: *
                            	  1166: * *** GETLN *** FNDLN (& friends) ***
                            	  1167: *
                            	  1168: * 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                            	  1169: * the character in D0 (given by the caller), then it fills the
                            	  1170: * buffer and echos. It ignores LF's but still echos
                            	  1171: * them back. Control-H is used to delete the last character
                            	  1172: * entered (if there is one), and control-X is used to delete the
                            	  1173: * whole line and start over again. CR signals the end of a line,
                            	  1174: * and causes 'GETLN' to return.
                            	  1175: *
                            	  1176: * 'FNDLN' finds a line with a given line no. (in D1) in the
                            	  1177: * text save area.  A1 is used as the text pointer. If the line
                            	  1178: * is found, A1 will point to the beginning of that line
                            	  1179: * (i.e. the high byte of the line no.), and flags are NC & Z.
                            	  1180: * If that line is not there and a line with a higher line no.
                            	  1181: * is found, A1 points there and flags are NC & NZ. If we reached
                            	  1182: * the end of the text save area and cannot find the line, flags
                            	  1183: * are C & NZ.
                            	  1184: * 'FNDLN' will initialize A1 to the beginning of the text save
                            	  1185: * area to start the search. Some other entries of this routine
                            	  1186: * will not initialize A1 and do the search.
                            	  1187: * 'FNDLNP' will start with A1 and search for the line no.
                            	  1188: * 'FNDNXT' will bump A1 by 2, find a CR and then start search.
                            	  1189: * 'FNDSKP' uses A1 to find a CR, and then starts the search.
                            	  1190: *
02:0000472A 6100F6CC        	  1191: GETLN	BSR	GOOUT		display the prompt
02:0000472E 103C0020        	  1192: 	MOVE.B	#' ',D0         and a space
02:00004732 6100F6C4        	  1193: 	BSR	GOOUT
02:00004736 41FA03BA        	  1194: 	LEA	BUFFER,A0	A0 is the buffer pointer
02:0000473A 610002AA        	  1195: GL1	bsr	CHKIO		check keyboard
02:0000473E 67FA            	  1196: 	BEQ	GL1		wait for a char. to come in
02:00004740 B03C0008        	  1197: 	CMP.B	#CTRLH,D0	delete last character?
02:00004744 6726            	  1198: 	BEQ	GL3		if so
02:00004746 B03C0018        	  1199: 	CMP.B	#CTRLX,D0	delete the whole line?
02:0000474A 6744            	  1200: 	BEQ	GL4		if so
02:0000474C B03C000D        	  1201: 	CMP.B	#CR,D0		accept a CR
02:00004750 6706            	  1202: 	BEQ	GL2
02:00004752 B03C0020        	  1203: 	CMP.B	#' ',D0         if other control char., discard it
02:00004756 65E2            	  1204: 	BCS	GL1
02:00004758 10C0            	  1205: GL2	MOVE.B	D0,(A0)+	save the char.
02:0000475A 6100F69C        	  1206: 	BSR	GOOUT		echo the char back out
02:0000475E B03C000D        	  1207: 	CMP.B	#CR,D0		if it's a CR, end the line
02:00004762 675C            	  1208: 	BEQ	GL7
02:00004764 B1FC00004B41    	  1209: 	CMP.L	#(BUFFER+BUFLEN-1),A0	any more room?
02:0000476A 65CE            	  1210: 	BCS	GL1		yes: get some more, else delete last char.
02:0000476C 103C0008        	  1211: GL3	MOVE.B	#CTRLH,D0	delete a char. if possible
02:00004770 6100F686        	  1212: 	BSR	GOOUT
02:00004774 103C0020        	  1213: 	MOVE.B	#' ',D0
02:00004778 6100F67E        	  1214: 	BSR	GOOUT
02:0000477C B1FC00004AF2    	  1215: 	CMP.L	#BUFFER,A0	any char.'s left?
02:00004782 63B6            	  1216: 	BLS	GL1		if not
02:00004784 103C0008        	  1217: 	MOVE.B	#CTRLH,D0	if so, finish the BS-space-BS sequence
02:00004788 6100F66E        	  1218: 	BSR	GOOUT
02:0000478C 5388            	  1219: 	SUBQ.L	#1,A0		decrement the text pointer
02:0000478E 60AA            	  1220: 	BRA	GL1		back for more
02:00004790 2208            	  1221: GL4	MOVE.L	A0,D1		delete the whole line
02:00004792 92BC00004AF2    	  1222: 	SUB.L	#BUFFER,D1	figure out how many backspaces we need
02:00004798 671E            	  1223: 	BEQ	GL6		if none needed, branch
02:0000479A 5341            	  1224: 	SUBQ	#1,D1		adjust for DBRA
02:0000479C 103C0008        	  1225: GL5	MOVE.B	#CTRLH,D0	and display BS-space-BS sequences
02:000047A0 6100F656        	  1226: 	BSR	GOOUT
02:000047A4 103C0020        	  1227: 	MOVE.B	#' ',D0
02:000047A8 6100F64E        	  1228: 	BSR	GOOUT
02:000047AC 103C0008        	  1229: 	MOVE.B	#CTRLH,D0
02:000047B0 6100F646        	  1230: 	BSR	GOOUT
02:000047B4 51C9FFE6        	  1231: 	DBRA	D1,GL5
02:000047B8 41FA0338        	  1232: GL6	LEA	BUFFER,A0	reinitialize the text pointer
02:000047BC 6000FF7C        	  1233: 	BRA	GL1		and go back for more
02:000047C0 103C000A        	  1234: GL7	MOVE.B	#LF,D0		echo a LF for the CR
02:000047C4 6000F632        	  1235: 	BRA	GOOUT
                            	  1236: 
02:000047C8 B2BC0000FFFF    	  1237: FNDLN	CMP.L	#$FFFF,D1	line no. must be < 65535
02:000047CE 6400FF52        	  1238: 	BCC	QHOW
02:000047D2 227AF638        	  1239: 	MOVE.L	TXTBGN,A1	init. the text save pointer
                            	  1240: 
02:000047D6 247A030E        	  1241: FNDLNP	MOVE.L	TXTUNF,A2	check if we passed the end
02:000047DA 538A            	  1242: 	SUBQ.L	#1,A2
02:000047DC B5C9            	  1243: 	CMP.L	A1,A2
02:000047DE 650C            	  1244: 	BCS	FNDRET		if so, return with Z=0 & C=1
02:000047E0 1411            	  1245: 	MOVE.B	(A1),D2	if not, get a line no.
02:000047E2 E14A            	  1246: 	LSL	#8,D2
02:000047E4 14290001        	  1247: 	MOVE.B	1(A1),D2
02:000047E8 B441            	  1248: 	CMP.W	D1,D2		is this the line we want?
02:000047EA 6502            	  1249: 	BCS	FNDNXT		no, not there yet
02:000047EC 4E75            	  1250: FNDRET	RTS			return the cond. codes
                            	  1251: 
02:000047EE 5489            	  1252: FNDNXT	ADDQ.L	#2,A1		find the next line
                            	  1253: 
                            	  1254: FNDSKP	
02:000047F0 0C19000D        	  1255: 	CMP.B	#CR,(A1)+	try to find a CR
02:000047F4 67E0            	  1256: 	BEQ		FNDLNP
02:000047F6 B3FA02EE        	  1257: 	CMP.L	TXTUNF,A1
02:000047FA 65F4            	  1258: 	BLO		FNDSKP
02:000047FC 60D8            	  1259: 	BRA		FNDLNP		check if end of text
                            	  1260: 
                            	  1261: *
                            	  1262: *******************************************************************
                            	  1263: *
                            	  1264: * *** MVUP *** MVDOWN *** POPA *** PUSHA ***
                            	  1265: *
                            	  1266: * 'MVUP' moves a block up from where A1 points to where A2 points
                            	  1267: * until A1=A3
                            	  1268: *
                            	  1269: * 'MVDOWN' moves a block down from where A1 points to where A3
                            	  1270: * points until A1=A2
                            	  1271: *
                            	  1272: * 'POPA' restores the 'FOR' loop variable save area from the stack
                            	  1273: *
                            	  1274: * 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                            	  1275: *
02:000047FE B7C9            	  1276: MVUP	CMP.L	A1,A3		see the above description
02:00004800 6704            	  1277: 	BEQ	MVRET
02:00004802 14D9            	  1278: 	MOVE.B	(A1)+,(A2)+
02:00004804 60F8            	  1279: 	BRA	MVUP
02:00004806 4E75            	  1280: MVRET	RTS
                            	  1281: 
02:00004808 B5C9            	  1282: MVDOWN	CMP.L	A1,A2		see the above description
02:0000480A 67FA            	  1283: 	BEQ	MVRET
02:0000480C 1721            	  1284: 	MOVE.B	-(A1),-(A3)
02:0000480E 60F8            	  1285: 	BRA	MVDOWN
                            	  1286: 
02:00004810 2C5F            	  1287: POPA	MOVE.L	(SP)+,A6	A6 = return address
02:00004812 23DF00004AD2    	  1288: 	MOVE.L	(SP)+,LOPVAR	restore LOPVAR, but zero means no more
02:00004818 6718            	  1289: 	BEQ	PP1
02:0000481A 23DF00004AD6    	  1290: 	MOVE.L	(SP)+,LOPINC	if not zero, restore the rest
02:00004820 23DF00004ADA    	  1291: 	MOVE.L	(SP)+,LOPLMT
02:00004826 23DF00004ADE    	  1292: 	MOVE.L	(SP)+,LOPLN
02:0000482C 23DF00004AE2    	  1293: 	MOVE.L	(SP)+,LOPPT
02:00004832 4ED6            	  1294: PP1	JMP	(A6)		return
                            	  1295: 
02:00004834 223A02B8        	  1296: PUSHA	MOVE.L	STKLMT,D1	Are we running out of stack room?
02:00004838 928F            	  1297: 	SUB.L	SP,D1
02:0000483A 6400FEDE        	  1298: 	BCC	QSORRY		if so, say we're sorry
02:0000483E 2C5F            	  1299: 	MOVE.L	(SP)+,A6	else get the return address
02:00004840 223A0290        	  1300: 	MOVE.L	LOPVAR,D1	save loop variables
02:00004844 6710            	  1301: 	BEQ	PU1		if LOPVAR is zero, that's all
02:00004846 2F3A029A        	  1302: 	MOVE.L	LOPPT,-(SP)	else save all the others
02:0000484A 2F3A0292        	  1303: 	MOVE.L	LOPLN,-(SP)
02:0000484E 2F3A028A        	  1304: 	MOVE.L	LOPLMT,-(SP)
02:00004852 2F3A0282        	  1305: 	MOVE.L	LOPINC,-(SP)
02:00004856 2F01            	  1306: PU1	MOVE.L	D1,-(SP)
02:00004858 4ED6            	  1307: 	JMP	(A6)		return
                            	  1308: 
                            	  1309: *
                            	  1310: *******************************************************************
                            	  1311: *
                            	  1312: * *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                            	  1313: *
                            	  1314: * 'PRTSTG' prints a string pointed to by A1. It stops printing
                            	  1315: * and returns to the caller when either a CR is printed or when
                            	  1316: * the next byte is the same as what was passed in D0 by the
                            	  1317: * caller.
                            	  1318: *
                            	  1319: * 'QTSTG' looks for an underline (back-arrow on some systems),
                            	  1320: * single-quote, or double-quote.  If none of these are found, returns
                            	  1321: * to the caller.  If underline, outputs a CR without a LF.  If single
                            	  1322: * or double quote, prints the quoted string and demands a matching
                            	  1323: * end quote.  After the printing, the next 2 bytes of the caller are
                            	  1324: * skipped over (usually a short branch instruction).
                            	  1325: *
                            	  1326: * 'PRTNUM' prints the 32 bit number in D1, leading blanks are added if
                            	  1327: * needed to pad the number of spaces to the number in D4.
                            	  1328: * However, if the number of digits is larger than the no. in
                            	  1329: * D4, all digits are printed anyway. Negative sign is also
                            	  1330: * printed and counted in, positive sign is not.
                            	  1331: *
                            	  1332: * 'PRTLN' prints the saved text line pointed to by A1
                            	  1333: * with line no. and all.
                            	  1334: *
02:0000485A 1200            	  1335: PRTSTG	MOVE.B	D0,D1		save the stop character
02:0000485C 1019            	  1336: PS1	MOVE.B	(A1)+,D0	get a text character
02:0000485E B200            	  1337: 	CMP.B	D0,D1		same as stop character?
02:00004860 6712            	  1338: 	BEQ	PRTRET		if so, return
02:00004862 6100F594        	  1339: 	BSR	GOOUT		display the char.
02:00004866 B03C000D        	  1340: 	CMP.B	#CR,D0		is it a C.R.?
02:0000486A 66F0            	  1341: 	BNE	PS1		no, go back for more
02:0000486C 103C000A        	  1342: 	MOVE.B	#LF,D0		yes, add a L.F.
02:00004870 6100F586        	  1343: 	BSR	GOOUT
02:00004874 4E75            	  1344: PRTRET	RTS			then return
                            	  1345: 
02:00004876 610000CA        	  1346: QTSTG	bsr	TSTC		*** QTSTG ***
02:0000487A 22              	  1347: 	DC.B	'"',QT3-*
02:0000487B 19
02:0000487C 103C0022        	  1348: 	MOVE.B	#'"',D0         it is a "
02:00004880 2248            	  1349: QT1	MOVE.L	A0,A1
02:00004882 61D6            	  1350: 	BSR	PRTSTG		print until another
02:00004884 2049            	  1351: 	MOVE.L	A1,A0
02:00004886 225F            	  1352: 	MOVE.L	(SP)+,A1	pop return address
02:00004888 B03C000A        	  1353: 	CMP.B	#LF,D0		was last one a CR?
02:0000488C 6700F852        	  1354: 	BEQ	RUNNXL		if so, run next line
02:00004890 5489            	  1355: QT2	ADDQ.L	#2,A1		skip 2 bytes on return
02:00004892 4ED1            	  1356: 	JMP	(A1)		return
02:00004894 610000AC        	  1357: QT3	bsr	TSTC		is it a single quote?
02:00004898 27              	  1358: 	DC.B	'''',QT4-*
02:00004899 07
02:0000489A 103C0027        	  1359: 	MOVE.B	#'''',D0        if so, do same as above
02:0000489E 60E0            	  1360: 	BRA	QT1
02:000048A0 610000A0        	  1361: QT4	bsr	TSTC		is it an underline?
02:000048A4 5F              	  1362: 	DC.B	'_',QT5-*
02:000048A5 0D
02:000048A6 103C000D        	  1363: 	MOVE.B	#CR,D0		if so, output a CR without LF
02:000048AA 6100F54C        	  1364: 	bsr	GOOUT
02:000048AE 225F            	  1365: 	MOVE.L	(SP)+,A1	pop return address
02:000048B0 60DE            	  1366: 	BRA	QT2
02:000048B2 4E75            	  1367: QT5	RTS			none of the above
                            	  1368: 
02:000048B4 2601            	  1369: PRTNUM	MOVE.L	D1,D3		save the number for later
02:000048B6 3F04            	  1370: 	MOVE	D4,-(SP)	save the width value
02:000048B8 1F3C00FF        	  1371: 	MOVE.B	#$FF,-(SP)	flag for end of digit string
02:000048BC 4A81            	  1372: 	TST.L	D1		is it negative?
02:000048BE 6A04            	  1373: 	BPL	PN1		if not
02:000048C0 4481            	  1374: 	NEG.L	D1		else make it positive
02:000048C2 5344            	  1375: 	SUBQ	#1,D4		one less for width count
02:000048C4 82FC000A        	  1376: PN1	DIVU	#10,D1		get the next digit
02:000048C8 690A            	  1377: 	BVS	PNOV		overflow flag set?
02:000048CA 2001            	  1378: 	MOVE.L	D1,D0		if not, save remainder
02:000048CC C2BC0000FFFF    	  1379: 	AND.L	#$FFFF,D1	strip the remainder
02:000048D2 601A            	  1380: 	BRA	TOASCII 	skip the overflow stuff
02:000048D4 3001            	  1381: PNOV	MOVE	D1,D0		prepare for long word division
02:000048D6 4241            	  1382: 	CLR.W	D1		zero out low word
02:000048D8 4841            	  1383: 	SWAP	D1		high word into low
02:000048DA 82FC000A        	  1384: 	DIVU	#10,D1		divide high word
02:000048DE 3401            	  1385: 	MOVE	D1,D2		save quotient
02:000048E0 3200            	  1386: 	MOVE	D0,D1		low word into low
02:000048E2 82FC000A        	  1387: 	DIVU	#10,D1		divide low word
02:000048E6 2001            	  1388: 	MOVE.L	D1,D0		D0 = remainder
02:000048E8 4841            	  1389: 	SWAP	D1		R/Q becomes Q/R
02:000048EA 3202            	  1390: 	MOVE	D2,D1		D1 is low/high
02:000048EC 4841            	  1391: 	SWAP	D1		D1 is finally high/low
02:000048EE 4840            	  1392: TOASCII SWAP	D0		get remainder
02:000048F0 1F00            	  1393: 	MOVE.B	D0,-(SP)	stack it as a digit
02:000048F2 4840            	  1394: 	SWAP	D0
02:000048F4 5344            	  1395: 	SUBQ	#1,D4		decrement width count
02:000048F6 4A81            	  1396: 	TST.L	D1		if quotient is zero, we're done
02:000048F8 66CA            	  1397: 	BNE	PN1
02:000048FA 5344            	  1398: 	SUBQ	#1,D4		adjust padding count for DBRA
02:000048FC 6B0C            	  1399: 	BMI	PN4		skip padding if not needed
02:000048FE 103C0020        	  1400: PN3	MOVE.B	#' ',D0         display the required leading spaces
02:00004902 6100F4F4        	  1401: 	BSR	GOOUT
02:00004906 51CCFFF6        	  1402: 	DBRA	D4,PN3
02:0000490A 4A83            	  1403: PN4	TST.L	D3		is number negative?
02:0000490C 6A08            	  1404: 	BPL	PN5
02:0000490E 103C002D        	  1405: 	MOVE.B	#'-',D0         if so, display the sign
02:00004912 6100F4E4        	  1406: 	BSR	GOOUT
02:00004916 101F            	  1407: PN5	MOVE.B	(SP)+,D0	now unstack the digits and display
02:00004918 6B0A            	  1408: 	BMI	PNRET		until the flag code is reached
02:0000491A D03C0030        	  1409: 	ADD.B	#'0',D0         make into ASCII
02:0000491E 6100F4D8        	  1410: 	BSR	GOOUT
02:00004922 60F2            	  1411: 	BRA	PN5
02:00004924 381F            	  1412: PNRET	MOVE	(SP)+,D4	restore width value
02:00004926 4E75            	  1413: 	RTS
                            	  1414: 
02:00004928 7200            	  1415: PRTLN	CLR.L	D1
02:0000492A 1219            	  1416: 	MOVE.B	(A1)+,D1	get the binary line number
02:0000492C E149            	  1417: 	LSL	#8,D1
02:0000492E 1219            	  1418: 	MOVE.B	(A1)+,D1
02:00004930 7805            	  1419: 	MOVEQ	#5,D4		display a 5 digit line no.
02:00004932 6180            	  1420: 	BSR	PRTNUM
02:00004934 103C0020        	  1421: 	MOVE.B	#' ',D0         followed by a blank
02:00004938 6100F4BE        	  1422: 	BSR	GOOUT
02:0000493C 4240            	  1423: 	CLR	D0		stop char. is a zero
02:0000493E 6000FF1A        	  1424: 	BRA	PRTSTG		display the rest of the line
                            	  1425: 
                            	  1426: *
                            	  1427: * ===== Test text byte following the call to this subroutine. If it
                            	  1428: *	equals the byte pointed to by A0, return to the code following
                            	  1429: *	the call. If they are not equal, branch to the point
                            	  1430: *	indicated by the offset byte following the text byte.
                            	  1431: *
02:00004942 614C            	  1432: TSTC	BSR	IGNBLK		ignore leading blanks
02:00004944 225F            	  1433: 	MOVE.L	(SP)+,A1	get the return address
02:00004946 1219            	  1434: 	MOVE.B	(A1)+,D1	get the byte to compare
02:00004948 B210            	  1435: 	CMP.B	(A0),D1 	is it = to what A0 points to?
02:0000494A 6708            	  1436: 	BEQ	TC1		if so
02:0000494C 7200            	  1437: 	CLR.L	D1		If not, add the second
02:0000494E 1211            	  1438: 	MOVE.B	(A1),D1 	byte following the call to
02:00004950 D3C1            	  1439: 	ADD.L	D1,A1		the return address.
02:00004952 4ED1            	  1440: 	JMP	(A1)		jump to the routine
02:00004954 5288            	  1441: TC1	ADDQ.L	#1,A0		if equal, bump text pointer
02:00004956 5289            	  1442: 	ADDQ.L	#1,A1		Skip the 2 bytes following
02:00004958 4ED1            	  1443: 	JMP	(A1)		the call and continue.
                            	  1444: 
                            	  1445: *
                            	  1446: * ===== See if the text pointed to by A0 is a number. If so,
                            	  1447: *	return the number in D1 and the number of digits in D2,
                            	  1448: *	else return zero in D1 and D2.
                            	  1449: *
02:0000495A 7200            	  1450: TSTNUM	CLR.L	D1		initialize return parameters
02:0000495C 4242            	  1451: 	CLR	D2
02:0000495E 6130            	  1452: 	BSR	IGNBLK		skip over blanks
02:00004960 0C100030        	  1453: TN1	CMP.B	#'0',(A0)       is it less than zero?
02:00004964 6528            	  1454: 	BCS	TSNMRET 	if so, that's all
02:00004966 0C100039        	  1455: 	CMP.B	#'9',(A0)       is it greater than nine?
02:0000496A 6222            	  1456: 	BHI	TSNMRET 	if so, return
02:0000496C B2BC0CCCCCCC    	  1457: 	CMP.L	#214748364,D1	see if there's room for new digit
02:00004972 6400FDAE        	  1458: 	BCC	QHOW		if not, we've overflowd
02:00004976 2001            	  1459: 	MOVE.L	D1,D0		quickly multiply result by 10
02:00004978 D281            	  1460: 	ADD.L	D1,D1
02:0000497A D281            	  1461: 	ADD.L	D1,D1
02:0000497C D280            	  1462: 	ADD.L	D0,D1
02:0000497E D281            	  1463: 	ADD.L	D1,D1
02:00004980 1018            	  1464: 	MOVE.B	(A0)+,D0	add in the new digit
02:00004982 C0BC0000000F    	  1465: 	AND.L	#$F,D0
02:00004988 D280            	  1466: 	ADD.L	D0,D1
02:0000498A 5242            	  1467: 	ADDQ	#1,D2		increment the no. of digits
02:0000498C 60D2            	  1468: 	BRA	TN1
02:0000498E 4E75            	  1469: TSNMRET RTS
                            	  1470: 
                            	  1471: *
                            	  1472: * ===== Skip over blanks in the text pointed to by A0.
                            	  1473: *
02:00004990 0C100020        	  1474: IGNBLK	CMP.B	#' ',(A0)       see if it's a space
02:00004994 6604            	  1475: 	BNE	IGBRET		if so, swallow it
02:00004996 5288            	  1476: IGB1	ADDQ.L	#1,A0		increment the text pointer
02:00004998 60F6            	  1477: 	BRA	IGNBLK
02:0000499A 4E75            	  1478: IGBRET	RTS
                            	  1479: 
                            	  1480: *
                            	  1481: * ===== Convert the line of text in the input buffer to upper
                            	  1482: *	case (except for stuff between quotes).
                            	  1483: *
02:0000499C 41FA0154        	  1484: TOUPBUF LEA	BUFFER,A0	set up text pointer
02:000049A0 4201            	  1485: 	CLR.B	D1		clear quote flag
                            	  1486: TOUPB1	
02:000049A2 1018            	  1487: 	MOVE.B	(A0)+,D0	get the next text char.
02:000049A4 B03C000D        	  1488: 	CMP.B	#CR,D0		is it end of line?
02:000049A8 6718            	  1489: 	BEQ	TOUPBRT 	if so, return
02:000049AA B03C0022        	  1490: 	CMP.B	#'"',D0         a double quote?
02:000049AE 6714            	  1491: 	BEQ	DOQUO
02:000049B0 B03C0027        	  1492: 	CMP.B	#'''',D0        or a single quote?
02:000049B4 670E            	  1493: 	BEQ	DOQUO
02:000049B6 4A01            	  1494: 	TST.B	D1		inside quotes?
02:000049B8 66E8            	  1495: 	BNE	TOUPB1		if so, do the next one
02:000049BA 6118            	  1496: 	BSR	TOUPPER 	convert to upper case
02:000049BC 1100            	  1497: 	MOVE.B	D0,-(A0)	store it
02:000049BE 5288            	  1498: 	ADDQ.L	#1,A0
02:000049C0 60E0            	  1499: 	BRA	TOUPB1		and go back for more
                            	  1500: TOUPBRT
02:000049C2 4E75            	  1501: 	RTS
                            	  1502: 
02:000049C4 4A01            	  1503: DOQUO	TST.B	D1		are we inside quotes?
02:000049C6 6604            	  1504: 	BNE	DOQUO1
02:000049C8 1200            	  1505: 	MOVE.B	D0,D1		if not, toggle inside-quotes flag
02:000049CA 60D6            	  1506: 	BRA	TOUPB1
02:000049CC B200            	  1507: DOQUO1	CMP.B	D0,D1		make sure we're ending proper quote
02:000049CE 66D2            	  1508: 	BNE	TOUPB1		if not, ignore it
02:000049D0 4201            	  1509: 	CLR.B	D1		else clear quote flag
02:000049D2 60CE            	  1510: 	BRA	TOUPB1
                            	  1511: 
                            	  1512: *
                            	  1513: * ===== Convert the character in D0 to upper case
                            	  1514: *
02:000049D4 B03C0061        	  1515: TOUPPER CMP.B	#'a',D0         is it < 'a'?
02:000049D8 650A            	  1516: 	BCS	TOUPRET
02:000049DA B03C007A        	  1517: 	CMP.B	#'z',D0         or > 'z'?
02:000049DE 6204            	  1518: 	BHI	TOUPRET
02:000049E0 903C0020        	  1519: 	SUB.B	#32,D0		if not, make it upper case
02:000049E4 4E75            	  1520: TOUPRET RTS
                            	  1521: 
                            	  1522: *
                            	  1523: * 'CHKIO' checks the input. If there's no input, it will return
                            	  1524: * to the caller with the Z flag set. If there is input, the Z
                            	  1525: * flag is cleared and the input byte is in D0. However, if a
                            	  1526: * control-C is read, 'CHKIO' will warm-start BASIC and will not
                            	  1527: * return to the caller.
                            	  1528: *
02:000049E6 6100F414        	  1529: CHKIO	bsr	GOIN		get input if possible
02:000049EA 670A            	  1530: 	BEQ	CHKRET		if Zero, no input
02:000049EC B03C0003        	  1531: 	CMP.B	#CTRLC,D0	is it control-C?
02:000049F0 6604            	  1532: 	BNE	CHKRET		if not
02:000049F2 6000F464        	  1533: 	BRA	WSTART		if so, do a warm start
02:000049F6 4E75            	  1534: CHKRET	RTS
                            	  1535: 
                            	  1536: *
                            	  1537: * ===== Display a CR-LF sequence
                            	  1538: *
                            	  1539: ;CRLF	LEA	CLMSG,A6
                            	  1540: 
                            	  1541: *
                            	  1542: * ===== Display a zero-ended string pointed to by register A6
                            	  1543: *
02:000049F8 101E            	  1544: PRMESG	MOVE.B	(A6)+,D0	get the char.
02:000049FA 6706            	  1545: 	BEQ	PRMRET		if it's zero, we're done
02:000049FC 6100F3FA        	  1546: 	BSR	GOOUT		else display it
02:00004A00 60F6            	  1547: 	BRA	PRMESG
02:00004A02 4E75            	  1548: PRMRET	RTS
                            	  1549: 
                            	  1550: ******************************************************
                            	  1551: * The following routines are the only ones that need *
                            	  1552: * to be changed for a different I/O environment.     *
                            	  1553: ******************************************************
                            	  1554: 
                            	  1555: *
                            	  1556: * ===== Output character to the console (Port 1) from register D0
                            	  1557: *	(Preserves all registers.)
                            	  1558: *
                            	  1559: OUTC
02:00004A04 2F0E            	  1560: 	move.l	a6,-(a7)
02:00004A06 2C7A00BA        	  1561: 	move.l	OUTPTR,a6
02:00004A0A 4E96            	  1562: 	jsr			(a6)
02:00004A0C 2C5F            	  1563: 	move.l	(a7)+,a6
02:00004A0E 4E75            	  1564: 	rts
                            	  1565: 
                            	  1566: OUTC1
02:00004A10 48E7C000        	  1567: 	movem.l		d0/d1,-(a7)
02:00004A14 2200            	  1568: 	move.l		d0,d1
02:00004A16 7006            	  1569: 	moveq.l		#6,d0
02:00004A18 4E4F            	  1570: 	trap			#15
02:00004A1A 4CDF0003        	  1571: 	movem.l		(a7)+,d0/d1
02:00004A1E 4E75            	  1572: 	rts
                            	  1573: 
                            	  1574: *OUTC	BTST	#1,$10040	is port 1 ready for a character?
                            	  1575: *	BEQ	OUTC		if not, wait for it
                            	  1576: *	MOVE.B	D0,$10042	out it goes.
                            	  1577: *	RTS
                            	  1578: 
                            	  1579: *
                            	  1580: * ===== Input a character from the console into register D0 (or
                            	  1581: *	return Zero status if there's no character available).
                            	  1582: *
                            	  1583: INC
02:00004A20 2F0E            	  1584: 	move.l	a6,-(a7)
02:00004A22 2C7A009A        	  1585: 	move.l	INPPTR,a6
02:00004A26 4E96            	  1586: 	jsr			(a6)
02:00004A28 2C5F            	  1587: 	move.l	(a7)+,a6
02:00004A2A 4E75            	  1588: 	rts
                            	  1589: 
                            	  1590: INC1
02:00004A2C 2F01            	  1591: 	move.l	d1,-(a7)
02:00004A2E 7005            	  1592: 	moveq.l	#5,d0			* function 5 GetKey
02:00004A30 4E4F            	  1593: 	trap		#15
02:00004A32 2001            	  1594: 	move.l	d1,d0
02:00004A34 221F            	  1595: 	move.l	(a7)+,d1
02:00004A36 0C0000FF        	  1596: 	cmpi.b	#-1,d0
02:00004A3A 6602            	  1597: 	bne			.0001
02:00004A3C 4200            	  1598: 	clr.b		d0
                            	  1599: .0001:
02:00004A3E 4E75            	  1600: 	rts
                            	  1601: 
                            	  1602: *INC	BTST	#0,$10040	is character ready?
                            	  1603: *	BEQ	INCRET		if not, return Zero status
                            	  1604: *	MOVE.B	$10042,D0	else get the character
                            	  1605: *	AND.B	#$7F,D0 	zero out the high bit
                            	  1606: *INCRET	RTS
                            	  1607: 
                            	  1608: *
                            	  1609: * ===== Output character to the host (Port 2) from register D0
                            	  1610: *	(Preserves all registers.)
                            	  1611: *
                            	  1612: AUXOUT:
02:00004A40 48E7C000        	  1613: 	movem.l	d0/d1,-(a7)
02:00004A44 2200            	  1614: 	move.l	d0,d1
02:00004A46 7022            	  1615: 	moveq		#34,d0
02:00004A48 4E4F            	  1616: 	trap		#15
02:00004A4A 4CDF0003        	  1617: 	movem.l	(a7)+,d0/d1
02:00004A4E 4E75            	  1618: 	rts
                            	  1619: 
                            	  1620: *AUXOUT	BTST	#1,$10041	is port 2 ready for a character?
                            	  1621: *	BEQ	AUXOUT		if not, wait for it
                            	  1622: *	MOVE.B	D0,$10043	out it goes.
                            	  1623: *	RTS
                            	  1624: 
                            	  1625: *
                            	  1626: * ===== Input a character from the host into register D0 (or
                            	  1627: *	return Zero status if there's no character available).
                            	  1628: *
                            	  1629: AUXIN:
02:00004A50 2F01            	  1630: 	move.l	d1,-(a7)
02:00004A52 7024            	  1631: 	moveq		#36,d0				; serial get char from buffer
02:00004A54 4E4F            	  1632: 	trap		#15
02:00004A56 2001            	  1633: 	move.l	d1,d0
02:00004A58 221F            	  1634: 	move.l	(a7)+,d1
02:00004A5A 0C40FFFF        	  1635: 	cmpi.w	#-1,d0
02:00004A5E 670A            	  1636: 	beq			.0001
02:00004A60 0200007F        	  1637: 	andi.b	#$7F,d0				; clear high bit
02:00004A64 4880            	  1638: 	ext.w		d0						; return character in d0
02:00004A66 48C0            	  1639: 	ext.l		d0
02:00004A68 4E75            	  1640: 	rts
                            	  1641: .0001:
02:00004A6A 7000            	  1642: 	moveq		#0,d0					; return zf=1 if no character available
02:00004A6C 4E75            	  1643: 	rts
                            	  1644: 
                            	  1645: ;AUXIN
                            	  1646: *AUXIN	BTST	#0,$10041	is character ready?
                            	  1647: *	BEQ	AXIRET		if not, return Zero status
                            	  1648: *	MOVE.B	$10043,D0	else get the character
                            	  1649: *	AND.B	#$7F,D0 	zero out the high bit
02:00004A6E 4E75            	  1650: AXIRET	RTS
                            	  1651: 
                            	  1652: *
                            	  1653: * ===== Return to the resident monitor, operating system, etc.
                            	  1654: *
                            	  1655: BYEBYE	
02:00004A70 6000116E        	  1656: 	bra		Monitor
                            	  1657: ;	MOVE.B	#228,D7 	return to Tutor
                            	  1658: ;	TRAP	#14
                            	  1659: 
02:00004A74 0D              	  1660: INITMSG DC.B	CR,LF,'Gordo''s MC68000 Tiny BASIC, v1.2',CR,LF,LF,0
02:00004A75 0A
02:00004A76 476F72646F277320
02:00004A7E 4D43363830303020
02:00004A86 54696E7920424153
02:00004A8E 49432C2076312E32
02:00004A96 0D
02:00004A97 0A
02:00004A98 0A
02:00004A99 00
02:00004A9A 0D              	  1661: OKMSG	DC.B	CR,LF,'OK',CR,LF,0
02:00004A9B 0A
02:00004A9C 4F4B
02:00004A9E 0D
02:00004A9F 0A
02:00004AA0 00
02:00004AA1 486F773F        	  1662: HOWMSG	DC.B	'How?',CR,LF,0
02:00004AA5 0D
02:00004AA6 0A
02:00004AA7 00
02:00004AA8 576861743F      	  1663: WHTMSG	DC.B	'What?',CR,LF,0
02:00004AAD 0D
02:00004AAE 0A
02:00004AAF 00
02:00004AB0 536F7272792E    	  1664: SRYMSG	DC.B	'Sorry.'
02:00004AB6 0D              	  1665: CLMSG	DC.B	CR,LF,0
02:00004AB7 0A
02:00004AB8 00
02:00004AB9 00              	  1666: 	DC.B	0	<- for aligning on a word boundary
                            	  1667: LSTROM	EQU	*		end of possible ROM area
                            	  1668: *
                            	  1669: * Internal variables follow:
                            	  1670: *
02:00004ABA 00003DF4        	  1671: RANPNT	DC.L	START		random number pointer
02:00004ABE 00000000        	  1672: INPPTR	DS.L	1		input pointer
02:00004AC2 00000000        	  1673: OUTPTR	DS.L	1 	output pointer
02:00004AC6 00000000        	  1674: CURRNT	DS.L	1		Current line pointer
02:00004ACA 00000000        	  1675: STKGOS	DS.L	1		Saves stack pointer in 'GOSUB'
02:00004ACE 00000000        	  1676: STKINP	DS.L	1		Saves stack pointer during 'INPUT'
02:00004AD2 00000000        	  1677: LOPVAR	DS.L	1		'FOR' loop save area
02:00004AD6 00000000        	  1678: LOPINC	DS.L	1		increment
02:00004ADA 00000000        	  1679: LOPLMT	DS.L	1		limit
02:00004ADE 00000000        	  1680: LOPLN	DS.L	1		line number
02:00004AE2 00000000        	  1681: LOPPT	DS.L	1		text pointer
02:00004AE6 00000000        	  1682: TXTUNF	DS.L	1		points to unfilled text area
02:00004AEA 00000000        	  1683: VARBGN	DS.L	1		points to variable area
02:00004AEE 00000000        	  1684: STKLMT	DS.L	1		holds lower limit for stack growth
02:00004AF2 00              	  1685: BUFFER	DS.B	BUFLEN		Keyboard input buffer
02:00004AF3 *
                            	  1686: TXT	EQU	*		Beginning of program area
                            	  1687: ;	END
                            	  1688: 

Source: "boot.asm"
                            	   783: 	include "..\Femtiki\source\kernel\Femtiki.x68"

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     1: 	include "..\Femtiki\const.x68"

Source: "..\Femtiki\const.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: TS_NONE			EQU		0
                            	    38: TS_READY		EQU		1
                            	    39: TS_DEAD			EQU		2
                            	    40: TS_MSGRDY		EQU		4
                            	    41: TS_WAITMSG	EQU		8
                            	    42: TS_TIMEOUT	EQU		16
                            	    43: TS_PREEMPT	EQU		32
                            	    44: TS_RUNNING	EQU		128
                            	    45: 
                            	    46: ; error codes
                            	    47: E_Ok		EQU		$00
                            	    48: E_Arg		EQU		$01
                            	    49: E_Func  EQU    $02
                            	    50: E_BadMbx	EQU		$04
                            	    51: E_QueFull	EQU		$05
                            	    52: E_NoThread	EQU		$06
                            	    53: E_NotAlloc	EQU		$09
                            	    54: E_NoMsg		EQU		$0b
                            	    55: E_Timeout	EQU		$10
                            	    56: E_BadAlarm	EQU		$11
                            	    57: E_NotOwner	EQU		$12
                            	    58: E_QueStrategy EQU		$13
                            	    59: E_DCBInUse	EQU		$19
                            	    60: ; Device driver errors
                            	    61: E_BadDevNum	EQU		$20
                            	    62: E_NoDev		EQU		$21
                            	    63: E_BadDevOp	EQU		$22
                            	    64: E_ReadError	EQU		$23
                            	    65: E_WriteError EQU		$24
                            	    66: E_BadBlockNum	EQU	$25
                            	    67: E_TooManyBlocks	EQU	$26
                            	    68: 
                            	    69: ; resource errors
                            	    70: E_NoMoreMbx	EQU		$40
                            	    71: E_NoMoreMsgBlks	EQU	$41
                            	    72: E_NoMoreAlarmBlks	EQU $44
                            	    73: E_NoMoreTCBs	EQU	$45
                            	    74: E_NoMem		EQU 12
                            	    75: 
                            	    76: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     2: 	include "..\Femtiki\config.x68"

Source: "..\Femtiki\config.x68"
                            	     1: MAX_TID		EQU		4095
                            	     2: NR_TCB		EQU		4096
                            	     3: NTASK     EQU   4096    ; number of threads allowed
                            	     4: LOG_TCBSZ	EQU		8
                            	     5: LOG_PGSZ	EQU		10
                            	     6: LOG_ACBSZ EQU   12
                            	     7: OSPAGES		EQU		16			; pages of memory dedicated to OS
                            	     8: PAGESZ    EQU   16384  	; size of a page of memory
                            	     9: MEMSZ     EQU   32768   ; pages
                            	    10: MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                            	    11: NR_MSG		EQU		21842		; number of messages available
                            	    12: NR_MBX		EQU		9792
                            	    13: 
                            	    14: 
                            	    15: 
                            	    16: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     3: 	include "..\Femtiki\types.x68"

Source: "..\Femtiki\types.x68"
                            	     1: ; Thread Control Block
                            	     2: TCBMagic    EQU		$0000
                            	     3: TCBRegs  		EQU   $0004		; register set storage area
                            	     4: TCBUSP			EQU		$0044
                            	     5: TCBSSP			EQU		$0048
                            	     6: TCBSR				EQU		$004C
                            	     7: TCBPC				EQU		$0050
                            	     8: TCBStatus		EQU		$0054
                            	     9: TCBPriority	EQU		$0055
                            	    10: TCBWaitMbx	EQU		$0056
                            	    11: TCBHasFocus EQU   $005A
                            	    12: TCBStackBot	EQU		$005C
                            	    13: TCBMsgD1		EQU		$0060
                            	    14: TCBMsgD2		EQU		$0064
                            	    15: TCBMsgD3		EQU		$0068
                            	    16: TCBStartTick	EQU	$006C
                            	    17: TCBEndTick	EQU		$0070
                            	    18: TCBTicks		EQU		$0074
                            	    19: TCBException	EQU	$0078
                            	    20: TCBNext			EQU		$007C
                            	    21: TCBPrev			EQU		$0080
                            	    22: TCBAffinity	EQU		$0084
                            	    23: TCBTimeout	EQU		$0088
                            	    24: TCBtid      EQU   $008C
                            	    25: TCBmid      EQU   $0090
                            	    26: TCBappid    EQU   $0094
                            	    27: TCBOpMode   EQU   $0098
                            	    28: TCBMbxNext  EQU   $009C
                            	    29: TCBMbxPrev  EQU   $00A0
                            	    30: TCBThreadNum  EQU   $00A4
                            	    31: TCBAcbNext	EQU		$00A8
                            	    32: TCBAcbPrev	EQU		$00AC
                            	    33: TCBhMailboxes	EQU		$00B0
                            	    34: TCBName			EQU		$00C0
                            	    35: TCB_SIZE		EQU		$0100
                            	    36: 
                            	    37: MBC_MAGIC		equ		0
                            	    38: MBX_OWNER		equ		4		; tid of owning task
                            	    39: MBX_LINK    equ   8
                            	    40: MBX_TQHEAD  equ   12   ; link field for free list shared with task queue head
                            	    41: MBX_TQTAIL  equ   16
                            	    42: MBX_MQHEAD	equ		20
                            	    43: MBX_MQTAIL	equ		24
                            	    44: MBX_SIZE		equ		32
                            	    45: 
                            	    46: MSG_MAGIC   equ   0
                            	    47: MSG_LINK	  equ		4
                            	    48: MSG_RETADR  equ   8
                            	    49: MSG_TGTADR  equ   12
                            	    50: MSG_TYPE    equ   16
                            	    51: MSG_D1		  equ		20
                            	    52: MSG_D2		  equ		24
                            	    53: MSG_D3		  equ		28
                            	    54: MSG_SIZE	  equ		32
                            	    55: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     4: 
                            	     5: 	code
                            	     6: 	even
                            	     7: ;------------------------------------------------------------------------------
                            	     8: ; Initialize the Femtiki OS.
                            	     9: ;------------------------------------------------------------------------------
                            	    10: 
                            	    11: FemtikiInit:
02:00004B42 203C20010000    	    12: 	move.l #tcbs,d0
02:00004B48 4E7B0013        	    13: 	movec d0,tcba
02:00004B4C 7000            	    14: 	moveq #0,d0
02:00004B4E 4E7B0012        	    15: 	movec d0,tr
02:00004B52 7007            	    16: 	moveq #7,d0
02:00004B54 41F900100320    	    17: 	lea readyQ,a0
                            	    18: .clearReadyQ
02:00004B5A 4298            	    19: 	clr.l (a0)+
02:00004B5C 51C8FFFC        	    20: 	dbra d0,.clearReadyQ
02:00004B60 42390010031C    	    21: 	clr.b QueueCycle
02:00004B66 4E7A0013        	    22: 	movec tcba,d0
02:00004B6A 2040            	    23: 	move.l d0,a0
02:00004B6C 203C0003FFFF    	    24: 	move.l #TCB_SIZE*NR_TCB/4-1,d0
                            	    25: .clearTCBs
02:00004B72 4298            	    26: 	clr.l (a0)+
02:00004B74 51C8FFFC        	    27: 	dbra d0,.clearTCBs
                            	    28: FemtikiInitIRQ:
02:00004B78 43FA01F2        	    29: 	lea FemtikiTimerIRQ,a1						; Set timer IRQ vector to Femtiki
02:00004B7C 4E7A8801        	    30: 	movec vbr,a0
02:00004B80 21490078        	    31: 	move.l a1,30*4(a0)								; vector #30
02:00004B84 4E75            	    32: 	rts
                            	    33: 
                            	    34: ;------------------------------------------------------------------------------
                            	    35: ; Operating system call dispatcher.
                            	    36: ; On entry, the task state has been saved including the system stack pointer,
                            	    37: ; in the task control block.
                            	    38: ;------------------------------------------------------------------------------
                            	    39: 
                            	    40: OSCallTable
02:00004B86 0000            	    41: 	dc.w		0
                            	    42: 
                            	    43: 	even
                            	    44: CallOS:
02:00004B88 2F08            	    45: 	move.l	a0,-(a7)
02:00004B8A 207900100224    	    46: 	move.l	RunningTCB,a0
02:00004B90 48E8FFFF0004    	    47: 	movem.l d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,TCBRegs(a0)
02:00004B96 225F            	    48: 	move.l	(a7)+,a1
02:00004B98 21490020        	    49: 	move.l	a1,32(a0)
02:00004B9C 4E7A9800        	    50: 	movec		usp,a1
02:00004BA0 21490044        	    51: 	move.l	a1,TCBUSP(a0)
02:00004BA4 301F            	    52: 	move.w	(a7)+,d0					; pop the status register
02:00004BA6 3140004C        	    53: 	move.w	d0,TCBSR(a0)			; save in TCB
02:00004BAA 225F            	    54: 	move.l	(a7)+,a1					; pop the program counter
02:00004BAC 5489            	    55: 	lea	2(a1),a1							; increment past inline callno argument
02:00004BAE 21490050        	    56: 	move.l	a1,TCBPC(a0)			; save PC in TCB
02:00004BB2 214F0048        	    57: 	move.l	a7,TCBSSP(a0)			; finally save SSP
02:00004BB6 3029FFFE        	    58: 	move.w	-2(a1),d0					; d0 = call number
02:00004BBA E548            	    59: 	lsl.w		#2,d0							; make into table index
02:00004BBC 43FAFFC8        	    60: 	lea			OSCallTable,a1
02:00004BC0 22710000        	    61: 	move.l	(a1,d0.w),a1
02:00004BC4 4E91            	    62: 	jsr			(a1)							; call the OS function
                            	    63: 	; Restore the thread context and return
02:00004BC6 207900100224    	    64: 	move.l	RunningTCB,a0
02:00004BCC 2E780048        	    65: 	move.l	TCBSSP,a7
02:00004BD0 2F280050        	    66: 	move.l	TCBPC(a0),-(a7)		; setup the PC and the SR on the stack
02:00004BD4 3F28004C        	    67: 	move.w	TCBSR(a0),-(a7)		; prep for RTE
02:00004BD8 20380044        	    68: 	move.l	TCBUSP,d0					; restore user stack pointer
02:00004BDC 4E7B0800        	    69: 	movec		d0,usp
02:00004BE0 4CE800FF0004    	    70: 	movem.l	TCBRegs(a0),d0/d1/d2/d3/d4/d5/d6/d7
02:00004BE6 4CE87E00002C    	    71: 	movem.l TCBRegs+40(a0),a1/a2/a3/a4/a5/a6
02:00004BEC 20680024        	    72: 	move.l	TCBRegs+32(a0),a0
02:00004BF0 4E73            	    73: 	rte
                            	    74: 
                            	    75: ;------------------------------------------------------------------------------
                            	    76: ; Get a pointer to the currently running TCB.
                            	    77: ;------------------------------------------------------------------------------
                            	    78: 
                            	    79: GetRunningTCBPointer:
02:00004BF2 48E7C000        	    80: 	movem.l d0/d1,-(a7)
02:00004BF6 4E7A0012        	    81: 	movec tr,d0
02:00004BFA 028000000FFF    	    82: 	andi.l #MAX_TID,d0		; limit to # threads
02:00004C00 4E7A1013        	    83: 	movec tcba,d1
02:00004C04 E188            	    84: 	lsl.l #8,d0
02:00004C06 D081            	    85: 	add.l d1,d0
02:00004C08 2040            	    86: 	move.l d0,a0
02:00004C0A 4CDF0003        	    87: 	movem.l (a7)+,d0/d1
02:00004C0E 4E75            	    88: 	rts
                            	    89: 
                            	    90: ;------------------------------------------------------------------------------
                            	    91: ; Convert a TCB handle into a pointer.
                            	    92: ;------------------------------------------------------------------------------
                            	    93: 
                            	    94: TCBHandleToPointer:
02:00004C10 2F01            	    95: 	move.l d1,-(a7)
02:00004C12 028000000FFF    	    96: 	andi.l #MAX_TID,d0		; limit to # threads
02:00004C18 4E7A1013        	    97: 	movec tcba,d1
02:00004C1C E188            	    98: 	lsl.l #8,d0
02:00004C1E D280            	    99: 	add.l d0,d1
02:00004C20 2041            	   100: 	move.l d1,a0
02:00004C22 E088            	   101: 	lsr.l #8,d0						; restore d0
02:00004C24 221F            	   102: 	move.l (a7)+,d1
02:00004C26 4E75            	   103: 	rts
                            	   104: 
                            	   105: ;------------------------------------------------------------------------------
                            	   106: ; Convert a TCB pointer into a handle.
                            	   107: ;------------------------------------------------------------------------------
                            	   108: 
                            	   109: PointerToTCBHandle:
02:00004C28 2F01            	   110: 	move.l d1,-(a7)				; save d1
02:00004C2A 4E7A1013        	   111: 	movec tcba,d1
02:00004C2E 91C1            	   112: 	sub.l d1,a0
02:00004C30 2008            	   113: 	move.l a0,d0
02:00004C32 E088            	   114: 	lsr.l #8,d0
02:00004C34 221F            	   115: 	move.l (a7)+,d1				; restore d1
02:00004C36 4E75            	   116: 	rts
                            	   117: 
                            	   118: ; ----------------------------------------------------------------------------
                            	   119: ; Select a thread to run. Relatively easy. All that needs to be done is to
                            	   120: ; keep popping the queue until a valid running task is found. There should
                            	   121: ; always be at least one thread in the queue.
                            	   122: ;
                            	   123: ; Modifies:
                            	   124: ;		none
                            	   125: ; Returns:
                            	   126: ;		d0 = handle of the next thread to run
                            	   127: ; ----------------------------------------------------------------------------
                            	   128: 
                            	   129: SelectThreadToRun:
                            	   130: .0001										; keep popping tasks from the readyQ until a valid one
02:00004C38 61000092        	   131: 	bsr	PopReadyQueue			; is found.
02:00004C3C 2048            	   132: 	move.l a0,a0					; tst.l a0
02:00004C3E 670C            	   133: 	beq	.0002
02:00004C40 0C2800800054    	   134: 	cmpi.b #TS_RUNNING,TCBStatus(a0)	; ensure the thread is to be running
02:00004C46 66F0            	   135: 	bne	.0001													; if not, go get the next thread
02:00004C48 61DE            	   136: 	bsr PointerToTCBHandle
02:00004C4A 6012            	   137: 	bra	InsertIntoReadyQueue					; insert thread back into queue
                            	   138: 	; Nothing in queues? There is supposed to be. Add the OS task to the queue.
                            	   139: .0002
02:00004C4C 4E7A8013        	   140: 	movec tcba,a0
02:00004C50 117C00800054    	   141: 	move.b #TS_RUNNING,TCBStatus(a0)	; flag as RUNNING
02:00004C56 117C00040055    	   142: 	move.b #4,TCBPriority(a0)					; OS has normal priority
02:00004C5C 7000            	   143: 	moveq #0,d0												; fast pointer to handle
                            	   144: 	; fall through to insert
                            	   145: 
                            	   146: ; ----------------------------------------------------------------------------
                            	   147: ; Insert thread into ready queue. The thread is added at the tail of the 
                            	   148: ; queue. The queue is a doubly linked list.
                            	   149: ;
                            	   150: ; Parameters:
                            	   151: ;		d0 = TCB handle
                            	   152: ; Returns:
                            	   153: ;		d0 = TCB handle
                            	   154: ; ----------------------------------------------------------------------------
                            	   155: 
                            	   156: InsertIntoReadyQueue:
02:00004C5E 48E7C0F0        	   157: 	movem.l	d0/d1/a0/a1/a2/a3,-(a7)
02:00004C62 61AC            	   158: 	bsr TCBHandleToPointer
02:00004C64 7025            	   159: 	moveq #37,d0
02:00004C66 7207            	   160: 	moveq #TCB_SEMA,d1				; lock semaphore
02:00004C68 4E4F            	   161: 	trap #15
02:00004C6A 20280055        	   162: 	move.l TCBPriority(a0),d0
02:00004C6E 02400007        	   163: 	andi.w #7,d0
02:00004C72 E548            	   164: 	lsl.w	#2,d0
02:00004C74 43F900100320    	   165: 	lea	readyQ,a1
02:00004C7A 26712000        	   166: 	move.l (a1,d2.w),a3
02:00004C7E 6720            	   167: 	beq .qempty
02:00004C80 246B0080        	   168: 	move.l TCBPrev(a3),a2
02:00004C84 214B007C        	   169: 	move.l a3,TCBNext(a0)
02:00004C88 214A0080        	   170: 	move.l a2,TCBPrev(a0)
02:00004C8C 206A007C        	   171: 	move.l TCBNext(a2),a0
02:00004C90 206B0080        	   172: 	move.l TCBPrev(a3),a0
                            	   173: .xit:
02:00004C94 7026            	   174: 	moveq #38,d0
02:00004C96 7207            	   175: 	moveq #TCB_SEMA,d1				; unlock semaphore
02:00004C98 4E4F            	   176: 	trap #15
02:00004C9A 4CDF0F03        	   177: 	movem.l	(a7)+,d0/d1/a0/a1/a2/a3
02:00004C9E 4E75            	   178: 	rts
                            	   179: .qempty
02:00004CA0 23880000        	   180: 	move.l a0,(a1,d0.w)
02:00004CA4 2148007C        	   181: 	move.l a0,TCBNext(a0)
02:00004CA8 21480080        	   182: 	move.l a0,TCBPrev(a0)
02:00004CAC 60E6            	   183: 	bra .xit
                            	   184: 
                            	   185: ; ----------------------------------------------------------------------------
                            	   186: ; Remove a thread from the ready queue. Simple. Just mark the thread as not
                            	   187: ; running and it will be removed automatically the next time it is switched
                            	   188: ; to.
                            	   189: ;
                            	   190: ; Parameters:
                            	   191: ;		d0 = TCB handle
                            	   192: ; Returns:
                            	   193: ;		none
                            	   194: ; ----------------------------------------------------------------------------
                            	   195: 
                            	   196: RemoveFromReadyQueue:
02:00004CAE 2F08            	   197: 	move.l a0,-(a7)											; save a0
02:00004CB0 C0BC00000FFF    	   198: 	and.l #MAX_TID,d0										; limit to # of threads
02:00004CB6 6100FF58        	   199: 	bsr TCBHandleToPointer							; a0 = pointer to TCB
02:00004CBA 0228007F0054    	   200: 	andi.b #$7F,TCBStatus(a0)						; set status no longer running
02:00004CC0 205F            	   201: 	move.l (a7)+,a0											; restore a0
02:00004CC2 4E75            	   202: 	rts	
                            	   203: 
                            	   204: ; ----------------------------------------------------------------------------
                            	   205: ; Register Usage
                            	   206: ;		d0 = queue counter
                            	   207: ;		d1 = index into list of queues
                            	   208: ;		a0 = pointer to list of queues
                            	   209: ;		a3 = pointer to TCB at head of queue
                            	   210: ; Parameters:
                            	   211: ;		none
                            	   212: ; Returns:
                            	   213: ;		a0 = pointer to TCB, NULL if none on list
                            	   214: ; ----------------------------------------------------------------------------
                            	   215: 
                            	   216: StartQ
02:00004CC4 01              	   217: 	dc.b 1,2,3,4,1,5,6,7
02:00004CC5 02
02:00004CC6 03
02:00004CC7 04
02:00004CC8 01
02:00004CC9 05
02:00004CCA 06
02:00004CCB 07
                            	   218: 
                            	   219: 	even
                            	   220: PopReadyQueue:
02:00004CCC 48E7C070        	   221: 	movem.l	d0/d1/a1/a2/a3,-(a7)
02:00004CD0 7025            	   222: 	moveq #37,d0
02:00004CD2 7207            	   223: 	moveq #TCB_SEMA,d1			; lock semaphore
02:00004CD4 4E4F            	   224: 	trap #15
02:00004CD6 7007            	   225: 	moveq #7,d0
                            	   226: 	; One in four tries pick a different priority to start searching from. 
02:00004CD8 12390010031C    	   227: 	move.b QueueCycle,d1		; increment Queue cycle counter
02:00004CDE 5201            	   228: 	addi.b #1,d1
02:00004CE0 02010007        	   229: 	andi.b #7,d1
02:00004CE4 13C10010031C    	   230: 	move.b d1,QueueCycle
02:00004CEA 6612            	   231: 	bne	.0001
02:00004CEC 43FAFFD6        	   232: 	lea StartQ,a1
02:00004CF0 4881            	   233: 	ext.w d1
02:00004CF2 12311000        	   234: 	move.b (a1,d1.w),d1
02:00004CF6 02410007        	   235: 	andi.w #7,d1						; limit to number of queues
02:00004CFA E549            	   236: 	lsl.w #2,d1							; make into lword index
02:00004CFC 6002            	   237: 	bra .0002
                            	   238: .0001
02:00004CFE 7200            	   239: 	moveq #0,d1							; start at Queue #0
                            	   240: .0002
02:00004D00 41F900100320    	   241: 	lea readyQ,a0						; a0 = pointer to list of ready queues
02:00004D06 26701000        	   242: 	move.l (a0,d1.w),a3			; a3 = head of list
02:00004D0A 6732            	   243: 	beq .nextQ							; anything on list?, if not go next queue
02:00004D0C 226B007C        	   244: 	move.l TCBNext(a3),a1		; remove head of list from list
02:00004D10 B7C9            	   245: 	cmpa.l a1,a3						; removing last TCB?
02:00004D12 6726            	   246: 	beq .removeLast
02:00004D14 246B0080        	   247: 	move.l TCBPrev(a3),a2
02:00004D18 24690080        	   248: 	move.l TCBPrev(a1),a2
02:00004D1C 226A007C        	   249: 	move.l TCBNext(a2),a1
                            	   250: .0003
02:00004D20 21891000        	   251: 	move.l	a1,(a0,d1.w)		; reset head of list to next
                            	   252: .0004
02:00004D24 204B            	   253: 	move.l a3,a0						; a0 = old head of list (returned)
02:00004D26 2148007C        	   254: 	move.l a0,TCBNext(a0)		; point links back to self
02:00004D2A 21480080        	   255: 	move.l a0,TCBPrev(a0)
02:00004D2E 7026            	   256: 	moveq #38,d0
02:00004D30 7207            	   257: 	moveq #TCB_SEMA,d1			; unlock semaphore
02:00004D32 4E4F            	   258: 	trap #15
02:00004D34 4CDF0E03        	   259: 	movem.l	(a7)+,d0/d1/a1/a2/a3
02:00004D38 4E75            	   260: 	rts
                            	   261: .removeLast
02:00004D3A 93C9            	   262: 	move.l #0,a1						; set head to zero when removing last
02:00004D3C 60E2            	   263: 	bra .0003
                            	   264: .nextQ
02:00004D3E 5841            	   265: 	addi.w #4,d1						; increment queue number by lword
02:00004D40 0241001C        	   266: 	andi.w #$1C,d1					; limit to number of queues
02:00004D44 51C8FFBA        	   267: 	dbra d0,.0002						; go back and check the next queue
02:00004D48 60DA            	   268: 	bra	.0004								; return NULL pointer if nothing in any queue
                            	   269: 
                            	   270: ; ----------------------------------------------------------------------------
                            	   271: ; Update the IRQ live indicator on screen.
                            	   272: ; ----------------------------------------------------------------------------
                            	   273: 
                            	   274: UpdateIRQLive:
02:00004D4A 227900040004    	   275: 	move.l TextScr,a1					; a1 = screen address
02:00004D50 2411            	   276: 	move.l (a1),d2
02:00004D52 E15A            	   277: 	rol.w	#8,d2								; reverse byte order of d2
02:00004D54 4842            	   278: 	swap d2
02:00004D56 E15A            	   279: 	rol.w	#8,d2
02:00004D58 06010030        	   280: 	addi.b #'0',d1						; binary to ascii core number
02:00004D5C D202            	   281: 	add.b	d2,d1
02:00004D5E E159            	   282: 	rol.w	#8,d1								; put bytes back in order
02:00004D60 4841            	   283: 	swap d1
02:00004D62 E159            	   284: 	rol.w	#8,d1
02:00004D64 23410004        	   285: 	move.l d1,4(a1)						; update onscreen IRQ flag
02:00004D68 5291            	   286: 	addi.l #1,(a1)						; flashy colors
02:00004D6A 4E75            	   287: 	rts
                            	   288: 
                            	   289: ; ----------------------------------------------------------------------------
                            	   290: ; Femtiki IRQ service routine. This is where a thread switch can occur so,
                            	   291: ; the thread context is saved and restored.
                            	   292: ; ----------------------------------------------------------------------------
                            	   293: 
                            	   294: FemtikiTimerIRQ:
02:00004D6C 2F00            	   295: 	move.l d0,-(a7)
02:00004D6E 2F08            	   296: 	move.l a0,-(a7)
02:00004D70 4E7A0012        	   297: 	movec tr,d0
02:00004D74 6100FE9A        	   298: 	bsr TCBHandleToPointer				; a0 = pointer to TCB
02:00004D78 48D0FFFF        	   299: 	movem.l #$FFFF,(a0)						; save all registers
02:00004D7C 201F            	   300: 	move.l (a7)+,d0
02:00004D7E 21400020        	   301: 	move.l d0,32(a0)							; save original a0 value
02:00004D82 201F            	   302: 	move.l (a7)+,d0
02:00004D84 2080            	   303: 	move.l d0,(a0)								; save original d0 value
02:00004D86 2E7C00040BFC    	   304: 	move.l #TimerStack,a7					; reset stack pointer
02:00004D8C 4E7A1FE0        	   305: 	movec	coreno,d1								; d1 = core number
02:00004D90 0C010002        	   306: 	cmpi.b #2,d1
02:00004D94 660A            	   307: 	bne.s	.0002
02:00004D96 23FC1D000000FD09	   308: 	move.l #$1D000000,PLIC+$14		; reset edge sense circuit
02:00004D9E 0014
                            	   309: .0002
02:00004DA0 61A8            	   310: 	bsr UpdateIRQLive							; Update IRQ live indicator
                            	   311: ;	bsr ReceiveMsg								; Check for RPC
02:00004DA2 6100FE4E        	   312: 	bsr GetRunningTCBPointer			; a0 = pointer to running TCB
02:00004DA6 4E7A0FF0        	   313: 	movec tick,d0									; Update time accounting
02:00004DAA 21400070        	   314: 	move.l d0,TCBEndTick(a0)			; compute number of ticks thread was running
02:00004DAE 90A8006C        	   315: 	sub.l	TCBStartTick(a0),d0
02:00004DB2 D1A80074        	   316: 	add.l	d0,TCBTicks(a0)					; add to cumulative ticks
02:00004DB6 117C00200054    	   317: 	move.b #TS_PREEMPT,TCBStatus(a0)	; set thread status to PREEMPT
02:00004DBC 6100FE7A        	   318: 	bsr	SelectThreadToRun					; d0 = TCB handle
02:00004DC0 4E7B0012        	   319: 	movec d0,tr										; set running thread number in tr
02:00004DC4 6100FE2C        	   320: 	bsr GetRunningTCBPointer			; a0 = pointer to TCB
02:00004DC8 117C00800054    	   321: 	move.b #TS_RUNNING,TCBStatus(a0)	; set thread status to RUNNING
02:00004DCE 4E7A0FF0        	   322: 	movec	tick,d0
02:00004DD2 2140006C        	   323: 	move.l d0,TCBStartTick(a0)		; record starting tick
02:00004DD6 4CD0FFFF        	   324: 	movem.l (a0),#$FFFF						; restore all registers
02:00004DDA 4E73            	   325: 	rte														; and return
                            	   326: 

Source: "boot.asm"
                            	   784: 
                            	   785: ; -----------------------------------------------------------------------------
                            	   786: ; Gets the screen color in d0 and d1.
                            	   787: ; -----------------------------------------------------------------------------
                            	   788: 
                            	   789: get_screen_color:
02:00004DDC 203900040084    	   790: 	move.l	fgColor,d0			; get foreground color
02:00004DE2 EB80            	   791: 	asl.l		#5,d0						; shift into position
02:00004DE4 008040000000    	   792: 	ori.l		#$40000000,d0		; set priority
02:00004DEA 223900040088    	   793: 	move.l	bkColor,d1
02:00004DF0 E089            	   794: 	lsr.l		#8,d1
02:00004DF2 E089            	   795: 	lsr.l		#8,d1
02:00004DF4 02810000001F    	   796: 	andi.l	#31,d1					; mask off extra bits
02:00004DFA 8081            	   797: 	or.l		d1,d0						; set background color bits in upper long word
02:00004DFC 223900040088    	   798: 	move.l	bkColor,d1			; get background color
02:00004E02 E181            	   799: 	asl.l		#8,d1						; shift into position for display ram
02:00004E04 E181            	   800: 	asl.l		#8,d1
02:00004E06 4E75            	   801: 	rts
                            	   802: 
                            	   803: ; -----------------------------------------------------------------------------
                            	   804: ; -----------------------------------------------------------------------------
                            	   805: 
                            	   806: get_screen_address:
02:00004E08 207900040004    	   807: 	move.l	TextScr,a0
02:00004E0E 4E75            	   808: 	rts
                            	   809: 	
                            	   810: ; -----------------------------------------------------------------------------
                            	   811: ; -----------------------------------------------------------------------------
                            	   812: 
                            	   813: clear_screen:
02:00004E10 48E7E080        	   814: 	movem.l	d0/d1/d2/a0,-(a7)
02:00004E14 4E7A0FE0        	   815: 	movec		coreno,d0
02:00004E18 4840            	   816: 	swap		d0	
02:00004E1A 7205            	   817: 	moveq		#SCREEN_SEMA,d1
02:00004E1C 6100B3F0        	   818: 	bsr			LockSemaphore
02:00004E20 61E6            	   819: 	bsr			get_screen_address	; a0 = pointer to screen area
02:00004E22 10390004008C    	   820: 	move.b	TextRows,d0					; d0 = rows
02:00004E28 14390004008D    	   821: 	move.b	TextCols,d2					; d2 = cols
02:00004E2E 4880            	   822: 	ext.w		d0									; convert to word
02:00004E30 4882            	   823: 	ext.w		d2									; convert to word
02:00004E32 C4C0            	   824: 	mulu		d0,d2								; d2 = number of character cells to clear
02:00004E34 61A6            	   825: 	bsr			get_screen_color		; get the color bits
02:00004E36 00410020        	   826: 	ori.w		#32,d1							; load space character
02:00004E3A E159            	   827: 	rol.w		#8,d1								; swap endian, text controller expects little endian
02:00004E3C 4841            	   828: 	swap		d1
02:00004E3E E159            	   829: 	rol.w		#8,d1
02:00004E40 E158            	   830: 	rol.w		#8,d0								; swap endian
02:00004E42 4840            	   831: 	swap		d0
02:00004E44 E158            	   832: 	rol.w		#8,d0
                            	   833: loop3:
02:00004E46 20C1            	   834: 	move.l	d1,(a0)+						; copy char plus bkcolor to cell
02:00004E48 20C0            	   835: 	move.l	d0,(a0)+					; copy fgcolor to cell
02:00004E4A 51CAFFFA        	   836: 	dbra		d2,loop3
02:00004E4E 4E7A0FE0        	   837: 	movec		coreno,d0
02:00004E52 4840            	   838: 	swap		d0	
02:00004E54 7205            	   839: 	moveq		#SCREEN_SEMA,d1
02:00004E56 6100B3F2        	   840: 	bsr			UnlockSemaphore
02:00004E5A 4CDF0107        	   841: 	movem.l	(a7)+,d0/d1/d2/a0
02:00004E5E 4E75            	   842: 	rts
                            	   843: 
                            	   844: CRLF:
02:00004E60 2F01            	   845: 	move.l	d1,-(a7)
02:00004E62 123C000D        	   846: 	move.b	#13,d1
02:00004E66 6142            	   847: 	bsr			DisplayChar
02:00004E68 123C000A        	   848: 	move.b	#10,d1
02:00004E6C 613C            	   849: 	bsr			DisplayChar
02:00004E6E 221F            	   850: 	move.l	(a7)+,d1
02:00004E70 4E75            	   851: 	rts
                            	   852: 
                            	   853: ;------------------------------------------------------------------------------
                            	   854: ;------------------------------------------------------------------------------
                            	   855: 
                            	   856: UpdateTextPos:
02:00004E72 103900040000    	   857: 	move.b	CursorRow,d0		; compute screen location
02:00004E78 0240007F        	   858: 	andi.w	#$7f,d0
02:00004E7C 14390004008D    	   859: 	move.b	TextCols,d2
02:00004E82 4882            	   860: 	ext.w		d2
02:00004E84 C0C2            	   861: 	mulu.w	d2,d0
02:00004E86 2600            	   862: 	move.l	d0,d3
02:00004E88 143900040001    	   863: 	move.b	CursorCol,d2
02:00004E8E 024200FF        	   864: 	andi.w	#$ff,d2
02:00004E92 D042            	   865: 	add.w		d2,d0
02:00004E94 33C000040002    	   866: 	move.w	d0,TextPos			; save cursor pos
02:00004E9A 4E75            	   867: 	rts
                            	   868: 
                            	   869: ;------------------------------------------------------------------------------
                            	   870: ; Calculate screen memory location from CursorRow,CursorCol.
                            	   871: ; Destroys d0,d2,a0
                            	   872: ;------------------------------------------------------------------------------
                            	   873: 
                            	   874: CalcScreenLoc:
02:00004E9C 61D4            	   875: 	bsr			UpdateTextPos
02:00004E9E 48C0            	   876: 	ext.l		d0								; make it into a long
02:00004EA0 E780            	   877: 	asl.l		#3,d0							; 8 bytes per char
02:00004EA2 6100FF64        	   878: 	bsr			get_screen_address
02:00004EA6 D1C0            	   879: 	add.l		d0,a0							; a0 = screen location
02:00004EA8 4E75            	   880: 	rts
                            	   881: 
                            	   882: ;------------------------------------------------------------------------------
                            	   883: ; Display a character on the screen
                            	   884: ; d1.b = char to display
                            	   885: ;------------------------------------------------------------------------------
                            	   886: 
                            	   887: DisplayChar:
02:00004EAA 48E77000        	   888: 	movem.l	d1/d2/d3,-(a7)
02:00004EAE 4E7A2FE0        	   889: 	movec		coreno,d2
02:00004EB2 0C020002        	   890: 	cmpi.b	#2,d2
                            	   891: ;	bne.s		.0001
                            	   892: ;	bsr			SerialPutChar
                            	   893: .0001:
02:00004EB6 0281000000FF    	   894: 	andi.l	#$ff,d1				; zero out upper bytes of d1
02:00004EBC 0C01000D        	   895: 	cmpi.b	#13,d1				; carriage return ?
02:00004EC0 6610            	   896: 	bne			dccr
02:00004EC2 423900040001    	   897: 	clr.b		CursorCol			; just set cursor column to zero on a CR
                            	   898: dcx14:
02:00004EC8 610002AE        	   899: 	bsr			SyncCursor		; set position in text controller
                            	   900: dcx7:
02:00004ECC 4CDF000E        	   901: 	movem.l	(a7)+,d1/d2/d3
02:00004ED0 4E75            	   902: 	rts
                            	   903: dccr:
02:00004ED2 0C010091        	   904: 	cmpi.b	#$91,d1			; cursor right ?
02:00004ED6 6618            	   905: 	bne.s   dcx6
02:00004ED8 14390004008D    	   906: 	move.b	TextCols,d2
02:00004EDE 5302            	   907: 	sub.b		#1,d2
02:00004EE0 943900040001    	   908: 	sub.b		CursorCol,d2
02:00004EE6 67E4            	   909: 	beq.s		dcx7
02:00004EE8 523900040001    	   910: 	addi.b	#1,CursorCol
02:00004EEE 60D8            	   911: 	bra.s		dcx14
                            	   912: dcx6:
02:00004EF0 0C010090        	   913: 	cmpi.b	#$90,d1			; cursor up ?
02:00004EF4 6610            	   914: 	bne.s		dcx8
02:00004EF6 4A3900040000    	   915: 	cmpi.b	#0,CursorRow
02:00004EFC 67CE            	   916: 	beq.s		dcx7
02:00004EFE 533900040000    	   917: 	subi.b	#1,CursorRow
02:00004F04 60C2            	   918: 	bra.s		dcx14
                            	   919: dcx8:
02:00004F06 0C010093        	   920: 	cmpi.b	#$93,d1			; cursor left?
02:00004F0A 6610            	   921: 	bne.s		dcx9
02:00004F0C 4A3900040001    	   922: 	cmpi.b	#0,CursorCol
02:00004F12 67B8            	   923: 	beq.s		dcx7
02:00004F14 533900040001    	   924: 	subi.b	#1,CursorCol
02:00004F1A 60AC            	   925: 	bra.s		dcx14
                            	   926: dcx9:
02:00004F1C 0C010092        	   927: 	cmpi.b	#$92,d1			; cursor down ?
02:00004F20 6618            	   928: 	bne.s		dcx10
02:00004F22 14390004008C    	   929: 	move.b	TextRows,d2
02:00004F28 5302            	   930: 	sub.b		#1,d2
02:00004F2A B43900040000    	   931: 	cmp.b		CursorRow,d2
02:00004F30 679A            	   932: 	beq.s		dcx7
02:00004F32 523900040000    	   933: 	addi.b	#1,CursorRow
02:00004F38 608E            	   934: 	bra.s		dcx14
                            	   935: dcx10:
02:00004F3A 0C010094        	   936: 	cmpi.b	#$94,d1			; cursor home ?
02:00004F3E 661C            	   937: 	bne.s		dcx11
02:00004F40 4A3900040001    	   938: 	cmpi.b	#0,CursorCol
02:00004F46 670A            	   939: 	beq.s		dcx12
02:00004F48 423900040001    	   940: 	clr.b		CursorCol
02:00004F4E 6000FF78        	   941: 	bra			dcx14
                            	   942: dcx12:
02:00004F52 423900040000    	   943: 	clr.b		CursorRow
02:00004F58 6000FF6E        	   944: 	bra			dcx14
                            	   945: dcx11:
02:00004F5C 48E7E080        	   946: 	movem.l	d0/d1/d2/a0,-(a7)
02:00004F60 0C010099        	   947: 	cmpi.b	#$99,d1			; delete ?
02:00004F64 675C            	   948: 	beq.s		doDelete
02:00004F66 0C010008        	   949: 	cmpi.b	#CTRLH,d1			; backspace ?
02:00004F6A 6748            	   950: 	beq.s   doBackspace
02:00004F6C 0C010018        	   951: 	cmpi.b	#CTRLX,d1			; delete line ?
02:00004F70 6700008C        	   952: 	beq			doCtrlX
02:00004F74 0C01000A        	   953: 	cmpi.b	#10,d1		; linefeed ?
02:00004F78 6728            	   954: 	beq.s		dclf
                            	   955: 
                            	   956: 	; regular char
02:00004F7A 6100FF20        	   957: 	bsr			CalcScreenLoc	; a0 = screen location
02:00004F7E 2401            	   958: 	move.l	d1,d2					; d2 = char
02:00004F80 6100FE5A        	   959: 	bsr			get_screen_color	; d0,d1 = color
02:00004F84 8282            	   960: 	or.l		d2,d1					; d1 = char + color
02:00004F86 E159            	   961: 	rol.w		#8,d1					; text controller expects little endian data
02:00004F88 4841            	   962: 	swap		d1
02:00004F8A E159            	   963: 	rol.w		#8,d1
02:00004F8C 2081            	   964: 	move.l	d1,(a0)
02:00004F8E E158            	   965: 	rol.w		#8,d0					; swap bytes
02:00004F90 4840            	   966: 	swap		d0						; swap halfs
02:00004F92 E158            	   967: 	rol.w		#8,d0					; swap remaining bytes
02:00004F94 21400004        	   968: 	move.l	d0,4(a0)
02:00004F98 61000088        	   969: 	bsr			IncCursorPos
02:00004F9C 610001DA        	   970: 	bsr			SyncCursor
02:00004FA0 6008            	   971: 	bra			dcx4
                            	   972: dclf:
02:00004FA2 6100009E        	   973: 	bsr			IncCursorRow
                            	   974: dcx16:
02:00004FA6 610001D0        	   975: 	bsr			SyncCursor
                            	   976: dcx4:
02:00004FAA 4CDF0107        	   977: 	movem.l	(a7)+,d0/d1/d2/a0		; get back a0
02:00004FAE 4CDF000E        	   978: 	movem.l	(a7)+,d1/d2/d3
02:00004FB2 4E75            	   979: 	rts
                            	   980: 
                            	   981: 	;---------------------------
                            	   982: 	; CTRL-H: backspace
                            	   983: 	;---------------------------
                            	   984: doBackspace:
02:00004FB4 4A3900040001    	   985: 	cmpi.b	#0,CursorCol		; if already at start of line
02:00004FBA 67EE            	   986: 	beq.s   dcx4						; nothing to do
02:00004FBC 533900040001    	   987: 	subi.b	#1,CursorCol		; decrement column
                            	   988: 
                            	   989: 	;---------------------------
                            	   990: 	; Delete key
                            	   991: 	;---------------------------
                            	   992: doDelete:
02:00004FC2 48E7C080        	   993: 	movem.l	d0/d1/a0,-(a7)	; save off screen location
02:00004FC6 6100FED4        	   994: 	bsr		  CalcScreenLoc		; a0 = screen location
02:00004FCA 103900040001    	   995: 	move.b	CursorCol,d0
                            	   996: .0001:
02:00004FD0 20A80008        	   997: 	move.l	8(a0),(a0)		; pull remaining characters on line over 1
02:00004FD4 2168000C0004    	   998: 	move.l	12(a0),4(a0)	; pull remaining characters on line over 1
02:00004FDA 5088            	   999: 	lea			8(a0),a0
02:00004FDC 5200            	  1000: 	addi.b	#1,d0
02:00004FDE B0390004008D    	  1001: 	cmp.b		TextCols,d0
02:00004FE4 65EA            	  1002: 	blo.s		.0001
02:00004FE6 6100FDF4        	  1003: 	bsr			get_screen_color
02:00004FEA 323C0020        	  1004: 	move.w	#' ',d1				; terminate line with a space
02:00004FEE E159            	  1005: 	rol.w		#8,d1
02:00004FF0 4841            	  1006: 	swap		d1
02:00004FF2 E159            	  1007: 	rol.w		#8,d1
02:00004FF4 2141FFF8        	  1008: 	move.l	d1,-8(a0)
02:00004FF8 4CDF0103        	  1009: 	movem.l	(a7)+,d0/d1/a0
02:00004FFC 60A8            	  1010: 	bra.s		dcx16				; finished
                            	  1011: 
                            	  1012: 	;---------------------------
                            	  1013: 	; CTRL-X: erase line
                            	  1014: 	;---------------------------
                            	  1015: doCtrlX:
02:00004FFE 423900040001    	  1016: 	clr.b		CursorCol			; Reset cursor to start of line
02:00005004 10390004008D    	  1017: 	move.b	TextCols,d0			; and display TextCols number of spaces
02:0000500A 4880            	  1018: 	ext.w		d0
02:0000500C 48C0            	  1019: 	ext.l		d0
02:0000500E 123C0020        	  1020: 	move.b	#' ',d1				; d1 = space char
                            	  1021: .0001:
                            	  1022: 	; DisplayChar is called recursively here
                            	  1023: 	; It's safe to do because we know it won't recurse again due to the
                            	  1024: 	; fact we know the character being displayed is a space char
02:00005012 6100FE96        	  1025: 	bsr		DisplayChar			
02:00005016 5340            	  1026: 	subq	#1,d0
02:00005018 66F8            	  1027: 	bne.s	.0001
02:0000501A 423900040001    	  1028: 	clr.b	CursorCol			; now really go back to start of line
02:00005020 6084            	  1029: 	bra.s	dcx16				; we're done
                            	  1030: 
                            	  1031: ;------------------------------------------------------------------------------
                            	  1032: ; Increment the cursor position, scroll the screen if needed.
                            	  1033: ;------------------------------------------------------------------------------
                            	  1034: 
                            	  1035: IncCursorPos:
02:00005022 527900040002    	  1036: 	addi.w	#1,TextCurpos
02:00005028 523900040001    	  1037: 	addi.b	#1,CursorCol
02:0000502E 10390004008D    	  1038: 	move.b	TextCols,d0
02:00005034 B03900040001    	  1039: 	cmp.b		CursorCol,d0
02:0000503A 6438            	  1040: 	bhs.s		icc1
02:0000503C 423900040001    	  1041: 	clr.b		CursorCol
                            	  1042: IncCursorRow:
02:00005042 523900040000    	  1043: 	addi.b	#1,CursorRow
02:00005048 10390004008C    	  1044: 	move.b	TextRows,d0
02:0000504E B03900040000    	  1045: 	cmp.b		CursorRow,d0
02:00005054 621E            	  1046: 	bhi.s		icc1
02:00005056 10390004008C    	  1047: 	move.b	TextRows,d0
02:0000505C 13C000040000    	  1048: 	move.b	d0,CursorRow		; in case CursorRow is way over
02:00005062 533900040000    	  1049: 	subi.b	#1,CursorRow
02:00005068 4880            	  1050: 	ext.w		d0
02:0000506A D040            	  1051: 	asl.w		#1,d0
02:0000506C 917900040002    	  1052: 	sub.w		d0,TextCurpos
02:00005072 6102            	  1053: 	bsr			ScrollUp
                            	  1054: icc1:
02:00005074 4E75            	  1055: 	rts
                            	  1056: 
                            	  1057: ;------------------------------------------------------------------------------
                            	  1058: ; Scroll screen up.
                            	  1059: ;------------------------------------------------------------------------------
                            	  1060: 
                            	  1061: ScrollUp:
02:00005076 48E7C084        	  1062: 	movem.l	d0/d1/a0/a5,-(a7)		; save off some regs
02:0000507A 4E7A0FE0        	  1063: 	movec		coreno,d0
02:0000507E 4840            	  1064: 	swap		d0	
02:00005080 7205            	  1065: 	moveq		#SCREEN_SEMA,d1
02:00005082 6100B18A        	  1066: 	bsr			LockSemaphore
02:00005086 6100FD80        	  1067: 	bsr			get_screen_address
02:0000508A 2A48            	  1068: 	move.l	a0,a5								; a5 = pointer to text screen
                            	  1069: .0003:								
02:0000508C 10390004008D    	  1070: 	move.b	TextCols,d0					; d0 = columns
02:00005092 12390004008C    	  1071: 	move.b	TextRows,d1					; d1 = rows
02:00005098 4880            	  1072: 	ext.w		d0									; make cols into a word value
02:0000509A 4881            	  1073: 	ext.w		d1									; make rows into a word value
02:0000509C E740            	  1074: 	asl.w		#3,d0								; make into cell index
02:0000509E 41F50000        	  1075: 	lea			0(a5,d0.w),a0				; a0 = pointer to second row of text screen
02:000050A2 E648            	  1076: 	lsr.w		#3,d0								; get back d0
02:000050A4 5341            	  1077: 	subq		#1,d1								; number of rows-1
02:000050A6 C0C1            	  1078: 	mulu		d1,d0								; d0 = count of characters to move
                            	  1079: .0001:
02:000050A8 2AD8            	  1080: 	move.l	(a0)+,(a5)+					; each char is 64 bits
02:000050AA 2AD8            	  1081: 	move.l	(a0)+,(a5)+	
02:000050AC 51C8FFFA        	  1082: 	dbra		d0,.0001
02:000050B0 4E7A0FE0        	  1083: 	movec		coreno,d0
02:000050B4 4840            	  1084: 	swap		d0	
02:000050B6 7205            	  1085: 	moveq		#SCREEN_SEMA,d1
02:000050B8 6100B190        	  1086: 	bsr			UnlockSemaphore
02:000050BC 4CDF2103        	  1087: 	movem.l	(a7)+,d0/d1/a0/a5
                            	  1088: 	; Fall through into blanking out last line
                            	  1089: 
                            	  1090: ;------------------------------------------------------------------------------
                            	  1091: ; Blank out the last line on the screen.
                            	  1092: ;------------------------------------------------------------------------------
                            	  1093: 
                            	  1094: BlankLastLine:
02:000050C0 48E7E080        	  1095: 	movem.l	d0/d1/d2/a0,-(a7)
02:000050C4 4E7A0FE0        	  1096: 	movec		coreno,d0
02:000050C8 4840            	  1097: 	swap		d0	
02:000050CA 7205            	  1098: 	moveq		#SCREEN_SEMA,d1
02:000050CC 6100B140        	  1099: 	bsr			LockSemaphore
02:000050D0 6100FD36        	  1100: 	bsr			get_screen_address
02:000050D4 10390004008C    	  1101: 	move.b	TextRows,d0					; d0 = rows
02:000050DA 12390004008D    	  1102: 	move.b	TextCols,d1					; d1 = columns
02:000050E0 4880            	  1103: 	ext.w		d0
02:000050E2 4881            	  1104: 	ext.w		d1
02:000050E4 5340            	  1105: 	subq		#1,d0								; last row = #rows-1
02:000050E6 C0C1            	  1106: 	mulu		d1,d0								; d0 = index of last line
02:000050E8 E748            	  1107: 	lsl.w		#3,d0								; *8 bytes per char
02:000050EA 41F00000        	  1108: 	lea			(a0,d0.w),a0				; point a0 to last row
02:000050EE 14390004008D    	  1109: 	move.b	TextCols,d2					; number of text cells to clear
02:000050F4 4882            	  1110: 	ext.w		d2
02:000050F6 5342            	  1111: 	subi.w	#1,d2								; count must be one less than desired
02:000050F8 6100FCE2        	  1112: 	bsr			get_screen_color		; d0,d1 = screen color
02:000050FC 323C0020        	  1113: 	move.w	#32,d1							; set the character for display in low 16 bits
02:00005100 61001508        	  1114: 	bsr			rbo									; reverse the byte order
02:00005104 E158            	  1115: 	rol.w		#8,d0
02:00005106 4840            	  1116: 	swap		d0
02:00005108 E158            	  1117: 	rol.w		#8,d0
                            	  1118: .0001:
02:0000510A 20C0            	  1119: 	move.l	d0,(a0)+
02:0000510C 20C1            	  1120: 	move.l	d1,(a0)+
02:0000510E 51CAFFFA        	  1121: 	dbra		d2,.0001
02:00005112 4E7A0FE0        	  1122: 	movec		coreno,d0
02:00005116 4840            	  1123: 	swap		d0	
02:00005118 7205            	  1124: 	moveq		#SCREEN_SEMA,d1
02:0000511A 6100B12E        	  1125: 	bsr			UnlockSemaphore
02:0000511E 4CDF0107        	  1126: 	movem.l	(a7)+,d0/d1/d2/a0
02:00005122 4E75            	  1127: 	rts
                            	  1128: 
                            	  1129: ;------------------------------------------------------------------------------
                            	  1130: ; Display a string on the screen.
                            	  1131: ;------------------------------------------------------------------------------
                            	  1132: 
                            	  1133: DisplayString:
02:00005124 48E7C040        	  1134: 	movem.l	d0/d1/a1,-(a7)
                            	  1135: dspj1:
02:00005128 7200            	  1136: 	clr.l		d1						; clear upper bits of d1
02:0000512A 1219            	  1137: 	move.b	(a1)+,d1			; move string char into d1
02:0000512C 6706            	  1138: 	beq.s		dsret					; is it end of string ?
02:0000512E 6100FD7A        	  1139: 	bsr			DisplayChar		; display character
02:00005132 60F4            	  1140: 	bra.s		dspj1					; go back for next character
                            	  1141: dsret:
02:00005134 4CDF0203        	  1142: 	movem.l	(a7)+,d0/d1/a1
02:00005138 4E75            	  1143: 	rts
                            	  1144: 
                            	  1145: ;------------------------------------------------------------------------------
                            	  1146: ; Display a string on the screen followed by carriage return / linefeed.
                            	  1147: ;------------------------------------------------------------------------------
                            	  1148: 
                            	  1149: DisplayStringCRLF:
02:0000513A 61E8            	  1150: 	bsr		DisplayString
02:0000513C 6000FD22        	  1151: 	bra		CRLF
                            	  1152: 
                            	  1153: ;------------------------------------------------------------------------------
                            	  1154: ; Display a string on the screen limited to 255 chars max.
                            	  1155: ;------------------------------------------------------------------------------
                            	  1156: 
                            	  1157: DisplayStringLimited:
02:00005140 48E7E040        	  1158: 	movem.l	d0/d1/d2/a1,-(a7)
02:00005144 3401            	  1159: 	move.w	d1,d2					; d2 = max count
02:00005146 024200FF        	  1160: 	andi.w	#$00FF,d2			; limit to 255 chars
02:0000514A 600A            	  1161: 	bra.s		.0003					; enter loop at bottom
                            	  1162: .0001:
02:0000514C 7200            	  1163: 	clr.l		d1						; clear upper bits of d1
02:0000514E 1219            	  1164: 	move.b	(a1)+,d1			; move string char into d1
02:00005150 6708            	  1165: 	beq.s		.0002					; is it end of string ?
02:00005152 6100FD56        	  1166: 	bsr			DisplayChar		; display character
                            	  1167: .0003:
02:00005156 51CAFFF4        	  1168: 	dbra		d2,.0001			; go back for next character
                            	  1169: .0002:
02:0000515A 4CDF0207        	  1170: 	movem.l	(a7)+,d0/d1/d2/a1
02:0000515E 4E75            	  1171: 	rts
                            	  1172: 
                            	  1173: DisplayStringLimitedCRLF:
02:00005160 61DE            	  1174: 	bsr		DisplayStringLimited
02:00005162 6000FCFC        	  1175: 	bra		CRLF
                            	  1176: 	
                            	  1177: ;------------------------------------------------------------------------------
                            	  1178: ; Set cursor position to top left of screen.
                            	  1179: ;
                            	  1180: ; Parameters:
                            	  1181: ;		<none>
                            	  1182: ; Returns:
                            	  1183: ;		<none>
                            	  1184: ; Registers Affected:
                            	  1185: ;		<none>
                            	  1186: ;------------------------------------------------------------------------------
                            	  1187: 
                            	  1188: HomeCursor:
02:00005166 423900040000    	  1189: 	clr.b		CursorRow
02:0000516C 423900040001    	  1190: 	clr.b		CursorCol
02:00005172 427900040002    	  1191: 	clr.w		TextPos
                            	  1192: 	; fall through
                            	  1193: 
                            	  1194: ;------------------------------------------------------------------------------
                            	  1195: ; SyncCursor:
                            	  1196: ;
                            	  1197: ; Sync the hardware cursor's position to the text cursor position but only for
                            	  1198: ; the core with the IO focus.
                            	  1199: ;
                            	  1200: ; Parameters:
                            	  1201: ;		<none>
                            	  1202: ; Returns:
                            	  1203: ;		<none>
                            	  1204: ; Registers Affected:
                            	  1205: ;		<none>
                            	  1206: ;------------------------------------------------------------------------------
                            	  1207: 
                            	  1208: SyncCursor:
02:00005178 48E7A000        	  1209: 	movem.l	d0/d2,-(a7)
02:0000517C 6100FCF4        	  1210: 	bsr			UpdateTextPos
02:00005180 4E7A2FE0        	  1211: 	movec		coreno,d2
02:00005184 B43900100000    	  1212: 	cmp.b		IOFocus,d2
02:0000518A 6610            	  1213: 	bne.s		.0001
02:0000518C 5542            	  1214: 	subi.w	#2,d2						; factor in location of screen in controller
02:0000518E C4FC0800        	  1215: 	mulu		#2048,d2				; 2048 cells per screen
02:00005192 D042            	  1216: 	add.w		d2,d0
02:00005194 E158            	  1217: 	rol.w		#8,d0						; swap byte order
02:00005196 33C0FD03FF24    	  1218: 	move.w	d0,TEXTREG+$24
                            	  1219: .0001:	
02:0000519C 4CDF0005        	  1220: 	movem.l	(a7)+,d0/d2
02:000051A0 4E75            	  1221: 	rts
                            	  1222: 
                            	  1223: ;==============================================================================
                            	  1224: ; TRAP #15 handler
                            	  1225: ;
                            	  1226: ; Parameters:
                            	  1227: ;		d0.w = function number to perform
                            	  1228: ;==============================================================================
                            	  1229: 
                            	  1230: TRAP15:
02:000051A2 48E78080        	  1231: 	movem.l	d0/a0,-(a7)
02:000051A6 41FA0010        	  1232: 	lea			T15DispatchTable,a0
02:000051AA E580            	  1233: 	asl.l		#2,d0
02:000051AC 20700000        	  1234: 	move.l	(a0,d0.w),a0
02:000051B0 4E90            	  1235: 	jsr			(a0)
02:000051B2 4CDF0101        	  1236: 	movem.l	(a7)+,d0/a0
02:000051B6 4E73            	  1237: 	rte
                            	  1238: 
                            	  1239: 		align	2
                            	  1240: T15DispatchTable:
02:000051B8 00005160        	  1241: 	dc.l	DisplayStringLimitedCRLF
02:000051BC 00005140        	  1242: 	dc.l	DisplayStringLimited
02:000051C0 0000528E        	  1243: 	dc.l	StubRout
02:000051C4 0000528E        	  1244: 	dc.l	StubRout
02:000051C8 0000528E        	  1245: 	dc.l	StubRout
02:000051CC 000054E2        	  1246: 	dc.l	GetKey
02:000051D0 00004EAA        	  1247: 	dc.l	DisplayChar
02:000051D4 000054D6        	  1248: 	dc.l	CheckForKey
02:000051D8 0000528E        	  1249: 	dc.l	StubRout
02:000051DC 0000528E        	  1250: 	dc.l	StubRout
                            	  1251: 	; 10
02:000051E0 0000528E        	  1252: 	dc.l	StubRout
02:000051E4 00005258        	  1253: 	dc.l	Cursor1
02:000051E8 000054CE        	  1254: 	dc.l	SetKeyboardEcho
02:000051EC 0000513A        	  1255: 	dc.l	DisplayStringCRLF
02:000051F0 00005124        	  1256: 	dc.l	DisplayString
02:000051F4 0000528E        	  1257: 	dc.l	StubRout
02:000051F8 0000528E        	  1258: 	dc.l	StubRout
02:000051FC 0000528E        	  1259: 	dc.l	StubRout
02:00005200 0000528E        	  1260: 	dc.l	StubRout
02:00005204 0000528E        	  1261: 	dc.l	StubRout
                            	  1262: 	; 20
02:00005208 0000528E        	  1263: 	dc.l	StubRout
02:0000520C 0000528E        	  1264: 	dc.l	StubRout
02:00005210 0000528E        	  1265: 	dc.l	StubRout
02:00005214 0000528E        	  1266: 	dc.l	StubRout
02:00005218 0000528E        	  1267: 	dc.l	StubRout
02:0000521C 0000528E        	  1268: 	dc.l	StubRout
02:00005220 0000528E        	  1269: 	dc.l	StubRout
02:00005224 0000528E        	  1270: 	dc.l	StubRout
02:00005228 0000528E        	  1271: 	dc.l	StubRout
02:0000522C 0000528E        	  1272: 	dc.l	StubRout
                            	  1273: 	; 30
02:00005230 0000528E        	  1274: 	dc.l	StubRout
02:00005234 0000528E        	  1275: 	dc.l	StubRout
02:00005238 000052A2        	  1276: 	dc.l	rotate_iofocus
02:0000523C 000066F4        	  1277: 	dc.l	SerialPeekCharDirect
02:00005240 0000670E        	  1278: 	dc.l	SerialPutChar
02:00005244 000066BC        	  1279: 	dc.l	SerialPeekChar
02:00005248 00006644        	  1280: 	dc.l	SerialGetChar
02:0000524C 00000266        	  1281: 	dc.l	T15LockSemaphore
02:00005250 0000026C        	  1282: 	dc.l	T15UnlockSemaphore
02:00005254 00006F12        	  1283: 	dc.l	prtflt
                            	  1284: 
                            	  1285: ;------------------------------------------------------------------------------
                            	  1286: ; Cursor positioning / Clear screen
                            	  1287: ; - out of range settings are ignored
                            	  1288: ;
                            	  1289: ; Parameters:
                            	  1290: ;		d1.w cursor position, bits 0 to 7 are row, bits 8 to 15 are column.
                            	  1291: ;	Returns:
                            	  1292: ;		none
                            	  1293: ;------------------------------------------------------------------------------
                            	  1294: 
                            	  1295: Cursor1:
02:00005258 2F01            	  1296: 	move.l		d1,-(a7)
02:0000525A 0C41FF00        	  1297: 	cmpi.w		#$FF00,d1
02:0000525E 6608            	  1298: 	bne.s			.0002
02:00005260 6100FBAE        	  1299: 	bsr				clear_screen
02:00005264 6000FF00        	  1300: 	bra				HomeCursor
                            	  1301: .0002:
02:00005268 B2390004008C    	  1302: 	cmp.b			TextRows,d1		; if cursor pos out of range, ignore setting
02:0000526E 6406            	  1303: 	bhs.s			.0003
02:00005270 13C100040000    	  1304: 	move.b		d1,CursorRow
                            	  1305: .0003:
02:00005276 E059            	  1306: 	ror.w			#8,d1
02:00005278 B2390004008D    	  1307: 	cmp.b			TextCols,d1
02:0000527E 6406            	  1308: 	bhs.s			.0001
02:00005280 13C100040001    	  1309: 	move.b		d1,CursorCol
                            	  1310: .0001:
02:00005286 6100FEF0        	  1311: 	bsr				SyncCursor		; update hardware cursor
02:0000528A 221F            	  1312: 	move.l		(a7)+,d1
02:0000528C 4E75            	  1313: 	rts
                            	  1314: 
                            	  1315: ;------------------------------------------------------------------------------
                            	  1316: ; Stub routine for unimplemented functionality.
                            	  1317: ;------------------------------------------------------------------------------
                            	  1318: 
                            	  1319: StubRout:
02:0000528E 4E75            	  1320: 	rts
                            	  1321: 
                            	  1322: ;------------------------------------------------------------------------------
                            	  1323: ; Select a specific IO focus.
                            	  1324: ;------------------------------------------------------------------------------
                            	  1325: 
                            	  1326: select_iofocus:
02:00005290 0C010002        	  1327: 	cmpi.b	#2,d1
02:00005294 650A            	  1328: 	blo.s		.0001
02:00005296 0C010009        	  1329: 	cmpi.b	#9,d1
02:0000529A 6204            	  1330: 	bhi.s		.0001
02:0000529C 2001            	  1331: 	move.l	d1,d0
02:0000529E 6014            	  1332: 	bra.s		select_focus1
                            	  1333: .0001:
02:000052A0 4E75            	  1334: 	rts
                            	  1335: 
                            	  1336: ;------------------------------------------------------------------------------
                            	  1337: ; Rotate the IO focus, done when ALT-Tab is pressed.
                            	  1338: ;
                            	  1339: ; Modifies:
                            	  1340: ;		d0, IOFocus BIOS variable
                            	  1341: ;------------------------------------------------------------------------------
                            	  1342: 
                            	  1343: rotate_iofocus:
02:000052A2 103900100000    	  1344: 	move.b	IOFocus,d0				; d0 = focus, we can trash d0
02:000052A8 5200            	  1345: 	add.b		#1,d0							; increment the focus
02:000052AA B03C0009        	  1346: 	cmp.b		#9,d0							; limit to 2 to 9
02:000052AE 6304            	  1347: 	bls.s		.0001
02:000052B0 103C0002        	  1348: 	move.b	#2,d0
                            	  1349: .0001:
                            	  1350: select_focus1:
02:000052B4 13C000100000    	  1351: 	move.b	d0,IOFocus				; set IO focus
02:000052BA 5500            	  1352: 	subi.b	#2,d0							; screen is 0 to 7, focus is 2 to 9
02:000052BC 4880            	  1353: 	ext.w		d0								; make into long value
02:000052BE C0FC0800        	  1354: 	mulu		#2048,d0					; * 2048	cells per screen
02:000052C2 E158            	  1355: 	rol.w		#8,d0							; swap byte order
02:000052C4 33C0FD03FF28    	  1356: 	move.w	d0,TEXTREG+$28		; update screen address in text controller
02:000052CA 6000FEAC        	  1357: 	bra			SyncCursor				; set cursor position
                            	  1358: 
                            	  1359: ;==============================================================================
                            	  1360: ; PLIC - platform level interrupt controller
                            	  1361: ;
                            	  1362: ; Register layout:
                            	  1363: ;   bits 0 to 7  = cause code to issue (vector number)
                            	  1364: ;   bits 8 to 11 = irq level to issue
                            	  1365: ;   bit 16 = irq enable
                            	  1366: ;   bit 17 = edge sensitivity
                            	  1367: ;   bit 18 = 0=vpa, 1=inta
                            	  1368: ;		bit 24 to 29 target core
                            	  1369: ;
                            	  1370: ; Note byte order must be reversed for PLIC.
                            	  1371: ;==============================================================================
                            	  1372: 
                            	  1373: init_plic:
02:000052CE 41F9FD090000    	  1374: 	lea		PLIC,a0						; a0 points to PLIC
02:000052D4 43E800F4        	  1375: 	lea		$80+4*29(a0),a1		; point to timer registers (29)
02:000052D8 22BC0006033F    	  1376: 	move.l	#$0006033F,(a1)	; initialize, core=63,edge sensitive,enabled,irq6,vpa
02:000052DE 5889            	  1377: 	lea			4(a1),a1				; point to keyboard registers (30)
02:000052E0 22BC3C060502    	  1378: 	move.l	#$3C060502,(a1)	; core=2,level sensitive,enabled,irq6,inta
02:000052E6 5889            	  1379: 	lea			4(a1),a1				; point to nmi button register (31)
02:000052E8 22BC00070302    	  1380: 	move.l	#$00070302,(a1)	; initialize, core=2,edge sensitive,enabled,irq7,vpa
02:000052EE 43E800C0        	  1381: 	lea		$80+4*16(a0),a1		; a1 points to ACIA register
02:000052F2 22BC3D030502    	  1382: 	move.l	#$3D030502,(a1)	; core=2,level sensitive,enabled,irq3,inta	
02:000052F8 43E80090        	  1383: 	lea		$80+4*4(a0),a1		; a1 points to io_bitmap irq
02:000052FC 22BC3B060702    	  1384: 	move.l	#$3B060702,(a1)	; core=2,edge sensitive,enabled,irq6,inta	
02:00005302 4E75            	  1385: 	rts
                            	  1386: 
                            	  1387: ;==============================================================================
                            	  1388: ; Keyboard stuff
                            	  1389: ;
                            	  1390: ; KeyState2_
                            	  1391: ; 876543210
                            	  1392: ; ||||||||+ = shift
                            	  1393: ; |||||||+- = alt
                            	  1394: ; ||||||+-- = control
                            	  1395: ; |||||+--- = numlock
                            	  1396: ; ||||+---- = capslock
                            	  1397: ; |||+----- = scrolllock
                            	  1398: ; ||+------ =
                            	  1399: ; |+------- = 
                            	  1400: ; +-------- = extended
                            	  1401: ;
                            	  1402: ;==============================================================================
                            	  1403: 
                            	  1404: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1405: ; Get ID - get the keyboards identifier code.
                            	  1406: ;
                            	  1407: ; Parameters: none
                            	  1408: ; Returns: d = $AB83, $00 on fail
                            	  1409: ; Modifies: d, KeybdID updated
                            	  1410: ; Stack Space: 2 words
                            	  1411: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1412: 
                            	  1413: KeybdGetID:
02:00005304 323C00F2        	  1414: 	move.w	#$F2,d1
02:00005308 61000494        	  1415: 	bsr			KeybdSendByte
02:0000530C 6100019A        	  1416: 	bsr			KeybdWaitTx
02:00005310 61000176        	  1417: 	bsr			KeybdRecvByte
02:00005314 08010007        	  1418: 	btst		#7,d1
02:00005318 6624            	  1419: 	bne			kgnotKbd
02:0000531A 0C0100AB        	  1420: 	cmpi.b	#$AB,d1
02:0000531E 661E            	  1421: 	bne			kgnotKbd
02:00005320 61000166        	  1422: 	bsr			KeybdRecvByte
02:00005324 08010007        	  1423: 	btst		#7,d1
02:00005328 6614            	  1424: 	bne			kgnotKbd
02:0000532A 0C010083        	  1425: 	cmpi.b	#$83,d1
02:0000532E 660E            	  1426: 	bne			kgnotKbd
02:00005330 223C0000AB83    	  1427: 	move.l	#$AB83,d1
                            	  1428: kgid1:
02:00005336 33C100100016    	  1429: 	move.w	d1,KeybdID
02:0000533C 4E75            	  1430: 	rts
                            	  1431: kgnotKbd:
02:0000533E 7200            	  1432: 	moveq		#0,d1
02:00005340 60F4            	  1433: 	bra			kgid1
                            	  1434: 
                            	  1435: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1436: ; Set the LEDs on the keyboard.
                            	  1437: ;
                            	  1438: ; Parameters:
                            	  1439: ;		d1.b = LED state
                            	  1440: ;	Modifies:
                            	  1441: ;		none
                            	  1442: ; Returns:
                            	  1443: ;		none
                            	  1444: ; Stack Space:
                            	  1445: ;		1 long word
                            	  1446: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1447: 
                            	  1448: KeybdSetLED:
02:00005342 2F01            	  1449: 	move.l	d1,-(a7)
02:00005344 123C00ED        	  1450: 	move.b	#$ED,d1
02:00005348 61000454        	  1451: 	bsr			KeybdSendByte
02:0000534C 6100015A        	  1452: 	bsr			KeybdWaitTx
02:00005350 61000136        	  1453: 	bsr			KeybdRecvByte
02:00005354 4A01            	  1454: 	tst.b		d1
02:00005356 6B12            	  1455: 	bmi			.0001
02:00005358 0C0100FA        	  1456: 	cmpi.b	#$FA,d1
02:0000535C 2217            	  1457: 	move.l	(a7),d1
02:0000535E 6100043E        	  1458: 	bsr			KeybdSendByte
02:00005362 61000144        	  1459: 	bsr			KeybdWaitTx
02:00005366 61000120        	  1460: 	bsr			KeybdRecvByte
                            	  1461: .0001:
02:0000536A 221F            	  1462: 	move.l	(a7)+,d1
02:0000536C 4E75            	  1463: 	rts
                            	  1464: 
                            	  1465: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1466: ; Initialize the keyboard.
                            	  1467: ;
                            	  1468: ; Parameters:
                            	  1469: ;		none
                            	  1470: ;	Modifies:
                            	  1471: ;		none
                            	  1472: ; Returns:
                            	  1473: ;		none
                            	  1474: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1475: 
                            	  1476: _KeybdInit:
                            	  1477: KeybdInit:
                            	  1478: ;	movem.l	d0/d1/d3/a1,-(a7)
02:0000536E 42390010000F    	  1479: 	clr.b	_KeyState1		; records key up/down state
02:00005374 423900100010    	  1480: 	clr.b	_KeyState2		; records shift,ctrl,alt state
02:0000537A 4E75            	  1481: 	rts
                            	  1482: 
02:0000537C 61000444        	  1483: 	bsr			Wait300ms
02:00005380 610000EC        	  1484: 	bsr			_KeybdGetStatus	; wait for response from keyboard
02:00005384 4A01            	  1485: 	tst.b		d1
02:00005386 6A0C            	  1486: 	bpl			.0001					; is input buffer full ? no, branch
02:00005388 610000EE        	  1487: 	bsr			_KeybdGetScancode
02:0000538C 0C0100AA        	  1488: 	cmpi.b	#$AA,d1				; keyboard Okay
02:00005390 6700008A        	  1489: 	beq			kbdi0005
                            	  1490: .0001:
02:00005394 760A            	  1491: 	moveq		#10,d3
                            	  1492: kbdi0002:
02:00005396 6100040E        	  1493: 	bsr			Wait10ms
02:0000539A 4239FD0FFE01    	  1494: 	clr.b		KEYBD+1				; clear receive register (write $00 to status reg)
02:000053A0 72FF            	  1495: 	moveq		#-1,d1				; send reset code to keyboard
02:000053A2 13C1FD0FFE01    	  1496: 	move.b	d1,KEYBD+1		; write $FF to status reg to clear TX state
02:000053A8 610003F4        	  1497: 	bsr			KeybdSendByte	; now write ($FF) to transmit register for reset
02:000053AC 610000FA        	  1498: 	bsr			KeybdWaitTx		; wait until no longer busy
02:000053B0 4A81            	  1499: 	tst.l		d1
02:000053B2 6B000082        	  1500: 	bmi			kbdiXmitBusy
02:000053B6 610000D0        	  1501: 	bsr			KeybdRecvByte	; look for an ACK ($FA)
02:000053BA 0C0100FA        	  1502: 	cmpi.b	#$FA,d1
02:000053BE 6604            	  1503: 	bne			.0001
02:000053C0 610000C6        	  1504: 	bsr			KeybdRecvByte	; look for BAT completion code ($AA)
                            	  1505: .0001:
02:000053C4 0C0100FC        	  1506: 	cmpi.b	#$FC,d1				; reset error ?
02:000053C8 672A            	  1507: 	beq			kbdiTryAgain
02:000053CA 0C0100AA        	  1508: 	cmpi.b	#$AA,d1				; reset complete okay ?
02:000053CE 6624            	  1509: 	bne			kbdiTryAgain
                            	  1510: 
                            	  1511: 	; After a reset, scan code set #2 should be active
                            	  1512: .config:
02:000053D0 323C00F0        	  1513: 	move.w	#$F0,d1			; send scan code select
02:000053D4 13C1FD0FFF00    	  1514: 	move.b	d1,leds
02:000053DA 610003C2        	  1515: 	bsr			KeybdSendByte
02:000053DE 610000C8        	  1516: 	bsr			KeybdWaitTx
02:000053E2 4A81            	  1517: 	tst.l		d1
02:000053E4 6B50            	  1518: 	bmi			kbdiXmitBusy
02:000053E6 610000A0        	  1519: 	bsr			KeybdRecvByte	; wait for response from keyboard
02:000053EA 4A41            	  1520: 	tst.w		d1
02:000053EC 6B06            	  1521: 	bmi			kbdiTryAgain
02:000053EE 0C0100FA        	  1522: 	cmpi.b	#$FA,d1				; ACK
02:000053F2 670E            	  1523: 	beq			kbdi0004
                            	  1524: kbdiTryAgain:
02:000053F4 51CBFFA0        	  1525: 	dbra		d3,kbdi0002
                            	  1526: .keybdErr:
02:000053F8 43FA004A        	  1527: 	lea			msgBadKeybd,a1
02:000053FC 6100FD3C        	  1528: 	bsr			DisplayStringCRLF
02:00005400 601E            	  1529: 	bra			ledxit
                            	  1530: kbdi0004:
02:00005402 7202            	  1531: 	moveq		#2,d1			; select scan code set #2
02:00005404 61000398        	  1532: 	bsr			KeybdSendByte
02:00005408 6100009E        	  1533: 	bsr			KeybdWaitTx
02:0000540C 4A81            	  1534: 	tst.l		d1
02:0000540E 6B26            	  1535: 	bmi			kbdiXmitBusy
02:00005410 6176            	  1536: 	bsr			KeybdRecvByte	; wait for response from keyboard
02:00005412 4A41            	  1537: 	tst.w		d1
02:00005414 6BDE            	  1538: 	bmi			kbdiTryAgain
02:00005416 0C0100FA        	  1539: 	cmpi.b	#$FA,d1
02:0000541A 66D8            	  1540: 	bne			kbdiTryAgain
                            	  1541: kbdi0005:
02:0000541C 6100FEE6        	  1542: 	bsr			KeybdGetID
                            	  1543: ledxit:
02:00005420 7207            	  1544: 	moveq		#$07,d1
02:00005422 6100FF1E        	  1545: 	bsr			KeybdSetLED
02:00005426 6100039A        	  1546: 	bsr			Wait300ms
02:0000542A 7200            	  1547: 	moveq		#$00,d1
02:0000542C 6100FF14        	  1548: 	bsr			KeybdSetLED
02:00005430 4CDF020B        	  1549: 	movem.l	(a7)+,d0/d1/d3/a1
02:00005434 4E75            	  1550: 	rts
                            	  1551: kbdiXmitBusy:
02:00005436 43FA001B        	  1552: 	lea			msgXmitBusy,a1
02:0000543A 6100FCFE        	  1553: 	bsr			DisplayStringCRLF
02:0000543E 4CDF020B        	  1554: 	movem.l	(a7)+,d0/d1/d3/a1
02:00005442 4E75            	  1555: 	rts
                            	  1556: 	
                            	  1557: msgBadKeybd:
02:00005444 4B6579626F617264	  1558: 	dc.b		"Keyboard error",0
02:0000544C 206572726F72
02:00005452 00
                            	  1559: msgXmitBusy:
02:00005453 4B6579626F617264	  1560: 	dc.b		"Keyboard transmitter stuck",0
02:0000545B 207472616E736D69
02:00005463 7474657220737475
02:0000546B 636B
02:0000546D 00
                            	  1561: 
                            	  1562: 	even
                            	  1563: _KeybdGetStatus:
02:0000546E 7200            	  1564: 	moveq		#0,d1
02:00005470 1239FD0FFE01    	  1565: 	move.b	KEYBD+1,d1
02:00005476 4E75            	  1566: 	rts
                            	  1567: 
                            	  1568: ; Get the scancode from the keyboard port
                            	  1569: 
                            	  1570: _KeybdGetScancode:
02:00005478 7200            	  1571: 	moveq		#0,d1
02:0000547A 1239FD0FFE00    	  1572: 	move.b	KEYBD,d1				; get the scan code
02:00005480 4239FD0FFE01    	  1573: 	move.b	#0,KEYBD+1			; clear receive register
02:00005486 4E75            	  1574: 	rts
                            	  1575: 
                            	  1576: ; Recieve a byte from the keyboard, used after a command is sent to the
                            	  1577: ; keyboard in order to wait for a response.
                            	  1578: ;
                            	  1579: KeybdRecvByte:
02:00005488 2F03            	  1580: 	move.l	d3,-(a7)
02:0000548A 363C0064        	  1581: 	move.w	#100,d3		; wait up to 1s
                            	  1582: .0003:
02:0000548E 61DE            	  1583: 	bsr			_KeybdGetStatus	; wait for response from keyboard
02:00005490 4A01            	  1584: 	tst.b		d1
02:00005492 6B0E            	  1585: 	bmi			.0004			; is input buffer full ? yes, branch
02:00005494 61000310        	  1586: 	bsr			Wait10ms	; wait a bit
02:00005498 51CBFFF4        	  1587: 	dbra		d3,.0003	; go back and try again
02:0000549C 261F            	  1588: 	move.l	(a7)+,d3
02:0000549E 72FF            	  1589: 	moveq		#-1,d1		; return -1
02:000054A0 4E75            	  1590: 	rts
                            	  1591: .0004:
02:000054A2 61D4            	  1592: 	bsr			_KeybdGetScancode
02:000054A4 261F            	  1593: 	move.l	(a7)+,d3
02:000054A6 4E75            	  1594: 	rts
                            	  1595: 
                            	  1596: 
                            	  1597: ; Wait until the keyboard transmit is complete
                            	  1598: ; Returns -1 if timedout, 0 if transmit completed
                            	  1599: ;
                            	  1600: KeybdWaitTx:
02:000054A8 48E73000        	  1601: 	movem.l	d2/d3,-(a7)
02:000054AC 7664            	  1602: 	moveq		#100,d3		; wait a max of 1s
                            	  1603: .0001:
02:000054AE 61BE            	  1604: 	bsr			_KeybdGetStatus
02:000054B0 08010006        	  1605: 	btst		#6,d1				; check for transmit complete bit
02:000054B4 6610            	  1606: 	bne	    .0002				; branch if bit set
02:000054B6 610002EE        	  1607: 	bsr			Wait10ms		; delay a little bit
02:000054BA 51CBFFF2        	  1608: 	dbra		d3,.0001		; go back and try again
02:000054BE 4CDF000C        	  1609: 	movem.l	(a7)+,d2/d3
02:000054C2 72FF            	  1610: 	moveq		#-1,d1			; return -1
02:000054C4 4E75            	  1611: 	rts
                            	  1612: .0002:
02:000054C6 4CDF000C        	  1613: 	movem.l	(a7)+,d2/d3
02:000054CA 7200            	  1614: 	moveq	#0,d1		; return 0
02:000054CC 4E75            	  1615: 	rts
                            	  1616: 
                            	  1617: ;------------------------------------------------------------------------------
                            	  1618: ; d1.b 0=echo off, non-zero = echo on
                            	  1619: ;------------------------------------------------------------------------------
                            	  1620: 
                            	  1621: SetKeyboardEcho:
02:000054CE 13C10004000C    	  1622: 	move.b	d1,KeybdEcho
02:000054D4 4E75            	  1623: 	rts
                            	  1624: 
                            	  1625: ;------------------------------------------------------------------------------
                            	  1626: ; Get key pending status into d1.b
                            	  1627: ;
                            	  1628: ; Returns:
                            	  1629: ;		d1.b = 1 if a key is available, otherwise zero.
                            	  1630: ;------------------------------------------------------------------------------
                            	  1631: 
                            	  1632: CheckForKey:
02:000054D6 7200            	  1633: 	moveq.l	#0,d1					; clear high order bits
                            	  1634: ;	move.b	KEYBD+1,d1		; get keyboard port status
                            	  1635: ;	smi.b		d1						; set true/false
                            	  1636: ;	andi.b	#1,d1					; return true (1) if key available, 0 otherwise
02:000054D8 4A3900100013    	  1637: 	tst.b		_KeybdCnt
02:000054DE 56C1            	  1638: 	sne.b		d1
02:000054E0 4E75            	  1639: 	rts
                            	  1640: 
                            	  1641: ;------------------------------------------------------------------------------
                            	  1642: ; GetKey
                            	  1643: ; 	Get a character from the keyboard. 
                            	  1644: ;
                            	  1645: ; Modifies:
                            	  1646: ;		d1
                            	  1647: ; Returns:
                            	  1648: ;		d1 = -1 if no key available or not in focus, otherwise key
                            	  1649: ;------------------------------------------------------------------------------
                            	  1650: 
                            	  1651: GetKey:
02:000054E2 2F00            	  1652: 	move.l	d0,-(a7)					; push d0
02:000054E4 123900100000    	  1653: 	move.b	IOFocus,d1				; Check if the core has the IO focus
02:000054EA 4E7A0FE0        	  1654: 	movec.l	coreno,d0
02:000054EE B200            	  1655: 	cmp.b		d0,d1
02:000054F0 6622            	  1656: 	bne.s		.0004							; go return no key available, if not in focus
02:000054F2 6132            	  1657: 	bsr			KeybdGetCharNoWait	; get a character
02:000054F4 4A81            	  1658: 	tst.l		d1						; was a key available?
02:000054F6 6B1C            	  1659: 	bmi.s		.0004
02:000054F8 4A390004000C    	  1660: 	tst.b		KeybdEcho					; is keyboard echo on ?
02:000054FE 6710            	  1661: 	beq.s		.0003							; no echo, just return the key
02:00005500 0C01000D        	  1662: 	cmpi.b	#CR,d1						; convert CR keystroke into CRLF
02:00005504 6606            	  1663: 	bne.s		.0005
02:00005506 6100F958        	  1664: 	bsr			CRLF
02:0000550A 6004            	  1665: 	bra.s		.0003
                            	  1666: .0005:
02:0000550C 6100F99C        	  1667: 	bsr			DisplayChar
                            	  1668: .0003:
02:00005510 201F            	  1669: 	move.l	(a7)+,d0					; pop d0
02:00005512 4E75            	  1670: 	rts												; return key
                            	  1671: ; Return -1 indicating no char was available
                            	  1672: .0004:
02:00005514 201F            	  1673: 	move.l	(a7)+,d0					; pop d0
02:00005516 72FF            	  1674: 	moveq		#-1,d1						; return no key available
02:00005518 4E75            	  1675: 	rts
                            	  1676: 
                            	  1677: CheckForCtrlC:
02:0000551A 610A            	  1678: 	bsr			KeybdGetCharNoWait
02:0000551C 0C010003        	  1679: 	cmpi.b	#CTRLC,d1
02:00005520 670006BE        	  1680: 	beq			Monitor
02:00005524 4E75            	  1681: 	rts
                            	  1682: 
                            	  1683: ;------------------------------------------------------------------------------
                            	  1684: ;------------------------------------------------------------------------------
                            	  1685: 
                            	  1686: KeybdGetCharNoWait:
02:00005526 42390004000D    	  1687: 	clr.b	KeybdWaitFlag
02:0000552C 6008            	  1688: 	bra		KeybdGetChar
                            	  1689: 
                            	  1690: KeybdGetCharWait:
02:0000552E 13FC00FF0004000D	  1691: 	move.b	#-1,KeybdWaitFlag
                            	  1692: 
                            	  1693: KeybdGetChar:
02:00005536 48E7B080        	  1694: 	movem.l	d0/d2/d3/a0,-(a7)
                            	  1695: .0003:
02:0000553A 4E7A0FE0        	  1696: 	movec		coreno,d0
02:0000553E 4840            	  1697: 	swap		d0
02:00005540 7203            	  1698: 	moveq		#KEYBD_SEMA,d1
02:00005542 6100ACCA        	  1699: 	bsr			LockSemaphore
02:00005546 143900100013    	  1700: 	move.b	_KeybdCnt,d2		; get count of buffered scan codes
02:0000554C 673E            	  1701: 	beq.s		.0015						;
02:0000554E 143900100011    	  1702: 	move.b	_KeybdHead,d2		; d2 = buffer head
02:00005554 4882            	  1703: 	ext.w		d2
02:00005556 41F900100020    	  1704: 	lea			_KeybdBuf,a0		; a0 = pointer to keyboard buffer
02:0000555C 7200            	  1705: 	clr.l		d1
02:0000555E 12302000        	  1706: 	move.b	(a0,d2.w),d1		; d1 = scan code from buffer
02:00005562 5202            	  1707: 	addi.b	#1,d2						; increment keyboard head index
02:00005564 0202001F        	  1708: 	andi.b	#31,d2					; and wrap around at buffer size
02:00005568 13C200100011    	  1709: 	move.b	d2,_KeybdHead
02:0000556E 533900100013    	  1710: 	subi.b	#1,_KeybdCnt		; decrement count of scan codes in buffer
02:00005574 C342            	  1711: 	exg			d1,d2						; save scancode value in d2
02:00005576 4E7A0FE0        	  1712: 	movec		coreno,d0
02:0000557A 4840            	  1713: 	swap		d0
02:0000557C 7203            	  1714: 	moveq		#KEYBD_SEMA,d1
02:0000557E 6100ACCA        	  1715: 	bsr			UnlockSemaphore
02:00005582 C541            	  1716: 	exg			d2,d1						; restore scancode value
02:00005584 6026            	  1717: 	bra			.0001						; go process scan code
                            	  1718: .0014:
02:00005586 6100FEE6        	  1719: 	bsr		_KeybdGetStatus		; check keyboard status for key available
02:0000558A 6B1C            	  1720: 	bmi		.0006							; yes, go process
                            	  1721: .0015:
02:0000558C 4E7A0FE0        	  1722: 	movec		coreno,d0
02:00005590 4840            	  1723: 	swap		d0
02:00005592 7203            	  1724: 	moveq		#KEYBD_SEMA,d1
02:00005594 6100ACB4        	  1725: 	bsr			UnlockSemaphore
02:00005598 4A390004000D    	  1726: 	tst.b		KeybdWaitFlag			; are we willing to wait for a key ?
02:0000559E 6B9A            	  1727: 	bmi			.0003							; yes, branch back
02:000055A0 4CDF010D        	  1728: 	movem.l	(a7)+,d0/d2/d3/a0
02:000055A4 72FF            	  1729: 	moveq		#-1,d1						; flag no char available
02:000055A6 4E75            	  1730: 	rts
                            	  1731: .0006:
02:000055A8 6100FECE        	  1732: 	bsr		_KeybdGetScancode
                            	  1733: .0001:
02:000055AC 33FC0001FD0FFF00	  1734: 	move.w	#1,leds
02:000055B4 B23C00F0        	  1735: 	cmp.b	#SC_KEYUP,d1
02:000055B8 670000C0        	  1736: 	beq		.doKeyup
02:000055BC B23C00E0        	  1737: 	cmp.b	#SC_EXTEND,d1
02:000055C0 670000C4        	  1738: 	beq		.doExtend
02:000055C4 B23C0014        	  1739: 	cmp.b	#SC_CTRL,d1
02:000055C8 670000C8        	  1740: 	beq		.doCtrl
02:000055CC B23C0012        	  1741: 	cmp.b	#SC_LSHIFT,d1
02:000055D0 6700012A        	  1742: 	beq		.doShift
02:000055D4 B23C0059        	  1743: 	cmp.b	#SC_RSHIFT,d1
02:000055D8 67000122        	  1744: 	beq		.doShift
02:000055DC B23C0077        	  1745: 	cmp.b	#SC_NUMLOCK,d1
02:000055E0 67000142        	  1746: 	beq		.doNumLock
02:000055E4 B23C0058        	  1747: 	cmp.b	#SC_CAPSLOCK,d1
02:000055E8 67000148        	  1748: 	beq		.doCapsLock
02:000055EC B23C007E        	  1749: 	cmp.b	#SC_SCROLLLOCK,d1
02:000055F0 6700014E        	  1750: 	beq		.doScrollLock
02:000055F4 B23C0011        	  1751: 	cmp.b   #SC_ALT,d1
02:000055F8 670000C0        	  1752: 	beq     .doAlt
02:000055FC 14390010000F    	  1753: 	move.b	_KeyState1,d2			; check key up/down
02:00005602 42390010000F    	  1754: 	move.b	#0,_KeyState1			; clear keyup status
02:00005608 4A02            	  1755: 	tst.b	d2
02:0000560A 6600FF2E        	  1756: 	bne	    .0003					; ignore key up
02:0000560E B23C000D        	  1757: 	cmp.b   #SC_TAB,d1
02:00005612 670000CE        	  1758: 	beq     .doTab
                            	  1759: .0013:
02:00005616 143900100010    	  1760: 	move.b	_KeyState2,d2
02:0000561C 6A1A            	  1761: 	bpl		.0010					; is it extended code ?
02:0000561E C43C007F        	  1762: 	and.b	#$7F,d2					; clear extended bit
02:00005622 13C200100010    	  1763: 	move.b	d2,_KeyState2
02:00005628 42390010000F    	  1764: 	move.b	#0,_KeyState1			; clear keyup
02:0000562E 41FA04C0        	  1765: 	lea		_keybdExtendedCodes,a0
02:00005632 12301000        	  1766: 	move.b	(a0,d1.w),d1
02:00005636 6034            	  1767: 	bra		.0008
                            	  1768: .0010:
02:00005638 08020002        	  1769: 	btst	#2,d2					; is it CTRL code ?
02:0000563C 670E            	  1770: 	beq		.0009
02:0000563E C27C007F        	  1771: 	and.w	#$7F,d1
02:00005642 41FA042C        	  1772: 	lea		_keybdControlCodes,a0
02:00005646 12301000        	  1773: 	move.b	(a0,d1.w),d1
02:0000564A 6020            	  1774: 	bra		.0008
                            	  1775: .0009:
02:0000564C 08020000        	  1776: 	btst	#0,d2					; is it shift down ?
02:00005650 670A            	  1777: 	beq  	.0007
02:00005652 41FA031C        	  1778: 	lea		_shiftedScanCodes,a0
02:00005656 12301000        	  1779: 	move.b	(a0,d1.w),d1
02:0000565A 6010            	  1780: 	bra		.0008
                            	  1781: .0007:
02:0000565C 41FA0212        	  1782: 	lea		_unshiftedScanCodes,a0
02:00005660 12301000        	  1783: 	move.b	(a0,d1.w),d1
02:00005664 33FC0202FD0FFF00	  1784: 	move.w	#$0202,leds
                            	  1785: .0008:
02:0000566C 33FC0303FD0FFF00	  1786: 	move.w	#$0303,leds
02:00005674 4CDF010D        	  1787: 	movem.l	(a7)+,d0/d2/d3/a0
02:00005678 4E75            	  1788: 	rts
                            	  1789: .doKeyup:
02:0000567A 13FC00FF0010000F	  1790: 	move.b	#-1,_KeyState1
02:00005682 6000FEB6        	  1791: 	bra		.0003
                            	  1792: .doExtend:
02:00005686 0039008000100010	  1793: 	or.b	#$80,_KeyState2
02:0000568E 6000FEAA        	  1794: 	bra		.0003
                            	  1795: .doCtrl:
02:00005692 12390010000F    	  1796: 	move.b	_KeyState1,d1
02:00005698 42390010000F    	  1797: 	clr.b	_KeyState1
02:0000569E 4A01            	  1798: 	tst.b	d1
02:000056A0 6A0C            	  1799: 	bpl.s	.0004
02:000056A2 08B9000200100010	  1800: 	bclr	#2,_KeyState2
02:000056AA 6000FE8E        	  1801: 	bra		.0003
                            	  1802: .0004:
02:000056AE 08F9000200100010	  1803: 	bset	#2,_KeyState2
02:000056B6 6000FE82        	  1804: 	bra		.0003
                            	  1805: .doAlt:
02:000056BA 12390010000F    	  1806: 	move.b	_KeyState1,d1
02:000056C0 42390010000F    	  1807: 	clr.b	_KeyState1
02:000056C6 4A01            	  1808: 	tst.b	d1
02:000056C8 6A0C            	  1809: 	bpl		.0011
02:000056CA 08B9000100100010	  1810: 	bclr	#1,_KeyState2
02:000056D2 6000FE66        	  1811: 	bra		.0003
                            	  1812: .0011:
02:000056D6 08F9000100100010	  1813: 	bset	#1,_KeyState2
02:000056DE 6000FE5A        	  1814: 	bra		.0003
                            	  1815: .doTab:
02:000056E2 2F01            	  1816: 	move.l	d1,-(a7)
02:000056E4 123900100010    	  1817:   move.b  _KeyState2,d1
02:000056EA 08010001        	  1818:   btst	#1,d1                 ; is ALT down ?
02:000056EE 6706            	  1819:   beq     .0012
                            	  1820: ;    	inc     _iof_switch
02:000056F0 221F            	  1821:   move.l	(a7)+,d1
02:000056F2 6000FE46        	  1822:   bra     .0003
                            	  1823: .0012:
02:000056F6 221F            	  1824:   move.l	(a7)+,d1
02:000056F8 6000FF1C        	  1825:   bra     .0013
                            	  1826: .doShift:
02:000056FC 12390010000F    	  1827: 	move.b	_KeyState1,d1
02:00005702 42390010000F    	  1828: 	clr.b	_KeyState1
02:00005708 4A01            	  1829: 	tst.b	d1
02:0000570A 6A0C            	  1830: 	bpl.s	.0005
02:0000570C 08B9000000100010	  1831: 	bclr	#0,_KeyState2
02:00005714 6000FE24        	  1832: 	bra		.0003
                            	  1833: .0005:
02:00005718 08F9000000100010	  1834: 	bset	#0,_KeyState2
02:00005720 6000FE18        	  1835: 	bra		.0003
                            	  1836: .doNumLock:
02:00005724 0879000400100010	  1837: 	bchg	#4,_KeyState2
02:0000572C 6120            	  1838: 	bsr		KeybdSetLEDStatus
02:0000572E 6000FE0A        	  1839: 	bra		.0003
                            	  1840: .doCapsLock:
02:00005732 0879000500100010	  1841: 	bchg	#5,_KeyState2
02:0000573A 6112            	  1842: 	bsr		KeybdSetLEDStatus
02:0000573C 6000FDFC        	  1843: 	bra		.0003
                            	  1844: .doScrollLock:
02:00005740 0879000600100010	  1845: 	bchg	#6,_KeyState2
02:00005748 6104            	  1846: 	bsr		KeybdSetLEDStatus
02:0000574A 6000FDEE        	  1847: 	bra		.0003
                            	  1848: 
                            	  1849: KeybdSetLEDStatus:
02:0000574E 48E73000        	  1850: 	movem.l	d2/d3,-(a7)
02:00005752 42390010000E    	  1851: 	clr.b		KeybdLEDs
02:00005758 0839000400100010	  1852: 	btst		#4,_KeyState2
02:00005760 6708            	  1853: 	beq.s		.0002
02:00005762 13FC00020010000E	  1854: 	move.b	#2,KeybdLEDs
                            	  1855: .0002:
02:0000576A 0839000500100010	  1856: 	btst		#5,_KeyState2
02:00005772 6708            	  1857: 	beq.s		.0003
02:00005774 08F900020010000E	  1858: 	bset		#2,KeybdLEDs
                            	  1859: .0003:
02:0000577C 0839000600100010	  1860: 	btst		#6,_KeyState2
02:00005784 6708            	  1861: 	beq.s		.0004
02:00005786 08F900000010000E	  1862: 	bset		#0,KeybdLEDs
                            	  1863: .0004:
02:0000578E 12390010000E    	  1864: 	move.b	KeybdLEDs,d1
02:00005794 6100FBAC        	  1865: 	bsr			KeybdSetLED
02:00005798 4CDF000C        	  1866: 	movem.l	(a7)+,d2/d3
02:0000579C 4E75            	  1867: 	rts
                            	  1868: 
                            	  1869: KeybdSendByte:
02:0000579E 13C1FD0FFE00    	  1870: 	move.b	d1,KEYBD
02:000057A4 4E75            	  1871: 	rts
                            	  1872: 	
                            	  1873: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1874: ; Wait for 10 ms
                            	  1875: ;
                            	  1876: ; Parameters: none
                            	  1877: ; Returns: none
                            	  1878: ; Modifies: none
                            	  1879: ; Stack Space: 2 long words
                            	  1880: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1881: 
                            	  1882: Wait10ms:
02:000057A6 48E7C000        	  1883: 	movem.l	d0/d1,-(a7)
02:000057AA 4E7A0FF0        	  1884: 	movec		tick,d0
02:000057AE 068000061A80    	  1885: 	addi.l	#400000,d0			; 400,000 cycles at 40MHz
                            	  1886: .0001:
02:000057B4 4E7A1FF0        	  1887: 	movec		tick,d1
02:000057B8 B081            	  1888: 	cmp.l		d1,d0
02:000057BA 62F8            	  1889: 	bhi			.0001
02:000057BC 4CDF0003        	  1890: 	movem.l	(a7)+,d0/d1
02:000057C0 4E75            	  1891: 	rts
                            	  1892: 
                            	  1893: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1894: ; Wait for 300 ms
                            	  1895: ;
                            	  1896: ; Parameters: none
                            	  1897: ; Returns: none
                            	  1898: ; Modifies: none
                            	  1899: ; Stack Space: 2 long words
                            	  1900: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1901: 
                            	  1902: Wait300ms:
02:000057C2 48E7C000        	  1903: 	movem.l	d0/d1,-(a7)
02:000057C6 4E7A0FF0        	  1904: 	movec		tick,d0
02:000057CA 068000B71B00    	  1905: 	addi.l	#12000000,d0			; 12,000,000 cycles at 40MHz
                            	  1906: .0001:
02:000057D0 4E7A1FF0        	  1907: 	movec		tick,d1
02:000057D4 B081            	  1908: 	cmp.l		d1,d0
02:000057D6 62F8            	  1909: 	bhi			.0001
02:000057D8 4CDF0003        	  1910: 	movem.l	(a7)+,d0/d1
02:000057DC 4E75            	  1911: 	rts
                            	  1912: 
                            	  1913: ;--------------------------------------------------------------------------
                            	  1914: ; Keyboard IRQ routine.
                            	  1915: ;
                            	  1916: ; Returns:
                            	  1917: ; 	d1 = -1 if keyboard routine handled interrupt, otherwise positive.
                            	  1918: ;--------------------------------------------------------------------------
                            	  1919: 
                            	  1920: KeybdIRQ:
02:000057DE 46FC2600        	  1921: 	move.w	#$2600,sr					; disable lower interrupts
02:000057E2 48E7C080        	  1922: 	movem.l	d0/d1/a0,-(a7)
02:000057E6 6100FC86        	  1923: 	bsr			_KeybdGetStatus		; check if keyboard
02:000057EA 4A01            	  1924: 	tst.b		d1
02:000057EC 6A7C            	  1925: 	bpl			.0001							; branch if not keyboard
02:000057EE 4E7A0FE0        	  1926: 	movec		coreno,d0
02:000057F2 4840            	  1927: 	swap		d0
02:000057F4 7203            	  1928: 	moveq		#KEYBD_SEMA,d1
02:000057F6 6100AA16        	  1929: 	bsr			LockSemaphore
02:000057FA 0839000100100010	  1930: 	btst		#1,_KeyState2			; Is Alt down?
02:00005802 6728            	  1931: 	beq.s		.0003
02:00005804 1039FD0FFE00    	  1932: 	move.b	KEYBD,d0					; get scan code
02:0000580A 0C00000D        	  1933: 	cmpi.b	#SC_TAB,d0				; is Alt-Tab?
02:0000580E 661C            	  1934: 	bne.s		.0003
02:00005810 6100FC66        	  1935: 	bsr			_KeybdGetScancode	; grab the scan code (clears interrupt)
02:00005814 6100FA8C        	  1936: 	bsr			rotate_iofocus
02:00005818 423900100011    	  1937: 	clr.b		_KeybdHead				; clear keyboard buffer
02:0000581E 423900100012    	  1938: 	clr.b		_KeybdTail
02:00005824 423900100013    	  1939: 	clr.b		_KeybdCnt
02:0000582A 6032            	  1940: 	bra			.0002							; do not store Alt-Tab
                            	  1941: .0003:
                            	  1942: 	; Insert keyboard scan code into raw keyboard buffer
02:0000582C 6100FC4A        	  1943: 	bsr			_KeybdGetScancode	; grab the scan code (clears interrupt)
02:00005830 0C39002000100013	  1944: 	cmpi.b	#32,_KeybdCnt			; see if keyboard buffer full
02:00005838 6424            	  1945: 	bhs.s		.0002
02:0000583A 103900100012    	  1946: 	move.b	_KeybdTail,d0			; keyboard buffer not full, add to tail
02:00005840 4880            	  1947: 	ext.w		d0
02:00005842 41F900100020    	  1948: 	lea			_KeybdBuf,a0			; a0 = pointer to buffer
02:00005848 11810000        	  1949: 	move.b	d1,(a0,d0.w)			; put scancode in buffer
02:0000584C 5200            	  1950: 	addi.b	#1,d0							; increment tail index
02:0000584E 0200001F        	  1951: 	andi.b	#31,d0						; wrap at buffer limit
02:00005852 13C000100012    	  1952: 	move.b	d0,_KeybdTail			; update tail index
02:00005858 523900100013    	  1953: 	addi.b	#1,_KeybdCnt			; increment buffer count
                            	  1954: .0002:
02:0000585E 4E7A0FE0        	  1955: 	movec		coreno,d0
02:00005862 4840            	  1956: 	swap		d0
02:00005864 7203            	  1957: 	moveq		#KEYBD_SEMA,d1
02:00005866 6100A9E2        	  1958: 	bsr			UnlockSemaphore
                            	  1959: .0001:
02:0000586A 4CDF0103        	  1960: 	movem.l	(a7)+,d0/d1/a0		; return
02:0000586E 4E73            	  1961: 	rte
                            	  1962: 
                            	  1963: ;--------------------------------------------------------------------------
                            	  1964: ; PS2 scan codes to ascii conversion tables.
                            	  1965: ;--------------------------------------------------------------------------
                            	  1966: ;
                            	  1967: _unshiftedScanCodes:
02:00005870 2E              	  1968: 	dc.b	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
02:00005871 A9
02:00005872 2E
02:00005873 A5
02:00005874 A3
02:00005875 A1
02:00005876 A2
02:00005877 AC
02:00005878 2E              	  1969: 	dc.b	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
02:00005879 AA
02:0000587A A8
02:0000587B A6
02:0000587C A4
02:0000587D 09
02:0000587E 60
02:0000587F 2E
02:00005880 2E              	  1970: 	dc.b	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
02:00005881 2E
02:00005882 2E
02:00005883 2E
02:00005884 2E
02:00005885 71
02:00005886 31
02:00005887 2E
02:00005888 2E              	  1971: 	dc.b	$2e,$2e,$7a,$73,$61,$77,$32,$2e
02:00005889 2E
02:0000588A 7A
02:0000588B 73
02:0000588C 61
02:0000588D 77
02:0000588E 32
02:0000588F 2E
02:00005890 2E              	  1972: 	dc.b	$2e,$63,$78,$64,$65,$34,$33,$2e
02:00005891 63
02:00005892 78
02:00005893 64
02:00005894 65
02:00005895 34
02:00005896 33
02:00005897 2E
02:00005898 2E              	  1973: 	dc.b	$2e,$20,$76,$66,$74,$72,$35,$2e
02:00005899 20
02:0000589A 76
02:0000589B 66
02:0000589C 74
02:0000589D 72
02:0000589E 35
02:0000589F 2E
02:000058A0 2E              	  1974: 	dc.b	$2e,$6e,$62,$68,$67,$79,$36,$2e
02:000058A1 6E
02:000058A2 62
02:000058A3 68
02:000058A4 67
02:000058A5 79
02:000058A6 36
02:000058A7 2E
02:000058A8 2E              	  1975: 	dc.b	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
02:000058A9 2E
02:000058AA 6D
02:000058AB 6A
02:000058AC 75
02:000058AD 37
02:000058AE 38
02:000058AF 2E
02:000058B0 2E              	  1976: 	dc.b	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
02:000058B1 2C
02:000058B2 6B
02:000058B3 69
02:000058B4 6F
02:000058B5 30
02:000058B6 39
02:000058B7 2E
02:000058B8 2E              	  1977: 	dc.b	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
02:000058B9 2E
02:000058BA 2F
02:000058BB 6C
02:000058BC 3B
02:000058BD 70
02:000058BE 2D
02:000058BF 2E
02:000058C0 2E              	  1978: 	dc.b	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
02:000058C1 2E
02:000058C2 27
02:000058C3 2E
02:000058C4 5B
02:000058C5 3D
02:000058C6 2E
02:000058C7 2E
02:000058C8 AD              	  1979: 	dc.b	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
02:000058C9 2E
02:000058CA 0D
02:000058CB 5D
02:000058CC 2E
02:000058CD 5C
02:000058CE 2E
02:000058CF 2E
02:000058D0 2E              	  1980: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:000058D1 2E
02:000058D2 2E
02:000058D3 2E
02:000058D4 2E
02:000058D5 2E
02:000058D6 08
02:000058D7 2E
02:000058D8 2E              	  1981: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
02:000058D9 95
02:000058DA 2E
02:000058DB 93
02:000058DC 94
02:000058DD 2E
02:000058DE 2E
02:000058DF 2E
02:000058E0 98              	  1982: 	dc.b	$98,$7f,$92,$2e,$91,$90,$1b,$af
02:000058E1 7F
02:000058E2 92
02:000058E3 2E
02:000058E4 91
02:000058E5 90
02:000058E6 1B
02:000058E7 AF
02:000058E8 AB              	  1983: 	dc.b	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
02:000058E9 2E
02:000058EA 97
02:000058EB 2E
02:000058EC 2E
02:000058ED 96
02:000058EE AE
02:000058EF 2E
                            	  1984: 
02:000058F0 2E              	  1985: 	dc.b	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
02:000058F1 2E
02:000058F2 2E
02:000058F3 A7
02:000058F4 2E
02:000058F5 2E
02:000058F6 2E
02:000058F7 2E
02:000058F8 2E              	  1986: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000058F9 2E
02:000058FA 2E
02:000058FB 2E
02:000058FC 2E
02:000058FD 2E
02:000058FE 2E
02:000058FF 2E
02:00005900 2E              	  1987: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005901 2E
02:00005902 2E
02:00005903 2E
02:00005904 2E
02:00005905 2E
02:00005906 2E
02:00005907 2E
02:00005908 2E              	  1988: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005909 2E
02:0000590A 2E
02:0000590B 2E
02:0000590C 2E
02:0000590D 2E
02:0000590E 2E
02:0000590F 2E
02:00005910 2E              	  1989: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005911 2E
02:00005912 2E
02:00005913 2E
02:00005914 2E
02:00005915 2E
02:00005916 2E
02:00005917 2E
02:00005918 2E              	  1990: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005919 2E
02:0000591A 2E
02:0000591B 2E
02:0000591C 2E
02:0000591D 2E
02:0000591E 2E
02:0000591F 2E
02:00005920 2E              	  1991: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005921 2E
02:00005922 2E
02:00005923 2E
02:00005924 2E
02:00005925 2E
02:00005926 2E
02:00005927 2E
02:00005928 2E              	  1992: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005929 2E
02:0000592A 2E
02:0000592B 2E
02:0000592C 2E
02:0000592D 2E
02:0000592E 2E
02:0000592F 2E
02:00005930 2E              	  1993: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005931 2E
02:00005932 2E
02:00005933 2E
02:00005934 2E
02:00005935 2E
02:00005936 2E
02:00005937 2E
02:00005938 2E              	  1994: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005939 2E
02:0000593A 2E
02:0000593B 2E
02:0000593C 2E
02:0000593D 2E
02:0000593E 2E
02:0000593F 2E
02:00005940 2E              	  1995: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005941 2E
02:00005942 2E
02:00005943 2E
02:00005944 2E
02:00005945 2E
02:00005946 2E
02:00005947 2E
02:00005948 2E              	  1996: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005949 2E
02:0000594A 2E
02:0000594B 2E
02:0000594C 2E
02:0000594D 2E
02:0000594E 2E
02:0000594F 2E
02:00005950 2E              	  1997: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005951 2E
02:00005952 2E
02:00005953 2E
02:00005954 2E
02:00005955 2E
02:00005956 2E
02:00005957 2E
02:00005958 2E              	  1998: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005959 2E
02:0000595A 2E
02:0000595B 2E
02:0000595C 2E
02:0000595D 2E
02:0000595E 2E
02:0000595F 2E
02:00005960 2E              	  1999: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005961 2E
02:00005962 2E
02:00005963 2E
02:00005964 2E
02:00005965 2E
02:00005966 2E
02:00005967 2E
02:00005968 2E              	  2000: 	dc.b	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
02:00005969 2E
02:0000596A FA
02:0000596B 2E
02:0000596C 2E
02:0000596D 2E
02:0000596E 2E
02:0000596F 2E
                            	  2001: 
                            	  2002: _shiftedScanCodes:
02:00005970 2E              	  2003: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005971 2E
02:00005972 2E
02:00005973 2E
02:00005974 2E
02:00005975 2E
02:00005976 2E
02:00005977 2E
02:00005978 2E              	  2004: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
02:00005979 2E
02:0000597A 2E
02:0000597B 2E
02:0000597C 2E
02:0000597D 09
02:0000597E 7E
02:0000597F 2E
02:00005980 2E              	  2005: 	dc.b	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
02:00005981 2E
02:00005982 2E
02:00005983 2E
02:00005984 2E
02:00005985 51
02:00005986 21
02:00005987 2E
02:00005988 2E              	  2006: 	dc.b	$2e,$2e,$5a,$53,$41,$57,$40,$2e
02:00005989 2E
02:0000598A 5A
02:0000598B 53
02:0000598C 41
02:0000598D 57
02:0000598E 40
02:0000598F 2E
02:00005990 2E              	  2007: 	dc.b	$2e,$43,$58,$44,$45,$24,$23,$2e
02:00005991 43
02:00005992 58
02:00005993 44
02:00005994 45
02:00005995 24
02:00005996 23
02:00005997 2E
02:00005998 2E              	  2008: 	dc.b	$2e,$20,$56,$46,$54,$52,$25,$2e
02:00005999 20
02:0000599A 56
02:0000599B 46
02:0000599C 54
02:0000599D 52
02:0000599E 25
02:0000599F 2E
02:000059A0 2E              	  2009: 	dc.b	$2e,$4e,$42,$48,$47,$59,$5e,$2e
02:000059A1 4E
02:000059A2 42
02:000059A3 48
02:000059A4 47
02:000059A5 59
02:000059A6 5E
02:000059A7 2E
02:000059A8 2E              	  2010: 	dc.b	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
02:000059A9 2E
02:000059AA 4D
02:000059AB 4A
02:000059AC 55
02:000059AD 26
02:000059AE 2A
02:000059AF 2E
02:000059B0 2E              	  2011: 	dc.b	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
02:000059B1 3C
02:000059B2 4B
02:000059B3 49
02:000059B4 4F
02:000059B5 29
02:000059B6 28
02:000059B7 2E
02:000059B8 2E              	  2012: 	dc.b	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
02:000059B9 3E
02:000059BA 3F
02:000059BB 4C
02:000059BC 3A
02:000059BD 50
02:000059BE 5F
02:000059BF 2E
02:000059C0 2E              	  2013: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
02:000059C1 2E
02:000059C2 22
02:000059C3 2E
02:000059C4 7B
02:000059C5 2B
02:000059C6 2E
02:000059C7 2E
02:000059C8 2E              	  2014: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
02:000059C9 2E
02:000059CA 0D
02:000059CB 7D
02:000059CC 2E
02:000059CD 7C
02:000059CE 2E
02:000059CF 2E
02:000059D0 2E              	  2015: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:000059D1 2E
02:000059D2 2E
02:000059D3 2E
02:000059D4 2E
02:000059D5 2E
02:000059D6 08
02:000059D7 2E
02:000059D8 2E              	  2016: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059D9 2E
02:000059DA 2E
02:000059DB 2E
02:000059DC 2E
02:000059DD 2E
02:000059DE 2E
02:000059DF 2E
02:000059E0 2E              	  2017: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
02:000059E1 7F
02:000059E2 2E
02:000059E3 2E
02:000059E4 2E
02:000059E5 2E
02:000059E6 1B
02:000059E7 2E
02:000059E8 2E              	  2018: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059E9 2E
02:000059EA 2E
02:000059EB 2E
02:000059EC 2E
02:000059ED 2E
02:000059EE 2E
02:000059EF 2E
                            	  2019: 
02:000059F0 2E              	  2020: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059F1 2E
02:000059F2 2E
02:000059F3 2E
02:000059F4 2E
02:000059F5 2E
02:000059F6 2E
02:000059F7 2E
02:000059F8 2E              	  2021: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:000059F9 2E
02:000059FA 2E
02:000059FB 2E
02:000059FC 2E
02:000059FD 2E
02:000059FE 2E
02:000059FF 2E
02:00005A00 2E              	  2022: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A01 2E
02:00005A02 2E
02:00005A03 2E
02:00005A04 2E
02:00005A05 2E
02:00005A06 2E
02:00005A07 2E
02:00005A08 2E              	  2023: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A09 2E
02:00005A0A 2E
02:00005A0B 2E
02:00005A0C 2E
02:00005A0D 2E
02:00005A0E 2E
02:00005A0F 2E
02:00005A10 2E              	  2024: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A11 2E
02:00005A12 2E
02:00005A13 2E
02:00005A14 2E
02:00005A15 2E
02:00005A16 2E
02:00005A17 2E
02:00005A18 2E              	  2025: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A19 2E
02:00005A1A 2E
02:00005A1B 2E
02:00005A1C 2E
02:00005A1D 2E
02:00005A1E 2E
02:00005A1F 2E
02:00005A20 2E              	  2026: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A21 2E
02:00005A22 2E
02:00005A23 2E
02:00005A24 2E
02:00005A25 2E
02:00005A26 2E
02:00005A27 2E
02:00005A28 2E              	  2027: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A29 2E
02:00005A2A 2E
02:00005A2B 2E
02:00005A2C 2E
02:00005A2D 2E
02:00005A2E 2E
02:00005A2F 2E
02:00005A30 2E              	  2028: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A31 2E
02:00005A32 2E
02:00005A33 2E
02:00005A34 2E
02:00005A35 2E
02:00005A36 2E
02:00005A37 2E
02:00005A38 2E              	  2029: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A39 2E
02:00005A3A 2E
02:00005A3B 2E
02:00005A3C 2E
02:00005A3D 2E
02:00005A3E 2E
02:00005A3F 2E
02:00005A40 2E              	  2030: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A41 2E
02:00005A42 2E
02:00005A43 2E
02:00005A44 2E
02:00005A45 2E
02:00005A46 2E
02:00005A47 2E
02:00005A48 2E              	  2031: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A49 2E
02:00005A4A 2E
02:00005A4B 2E
02:00005A4C 2E
02:00005A4D 2E
02:00005A4E 2E
02:00005A4F 2E
02:00005A50 2E              	  2032: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A51 2E
02:00005A52 2E
02:00005A53 2E
02:00005A54 2E
02:00005A55 2E
02:00005A56 2E
02:00005A57 2E
02:00005A58 2E              	  2033: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A59 2E
02:00005A5A 2E
02:00005A5B 2E
02:00005A5C 2E
02:00005A5D 2E
02:00005A5E 2E
02:00005A5F 2E
02:00005A60 2E              	  2034: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A61 2E
02:00005A62 2E
02:00005A63 2E
02:00005A64 2E
02:00005A65 2E
02:00005A66 2E
02:00005A67 2E
02:00005A68 2E              	  2035: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A69 2E
02:00005A6A 2E
02:00005A6B 2E
02:00005A6C 2E
02:00005A6D 2E
02:00005A6E 2E
02:00005A6F 2E
                            	  2036: 
                            	  2037: ; control
                            	  2038: _keybdControlCodes:
02:00005A70 2E              	  2039: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005A71 2E
02:00005A72 2E
02:00005A73 2E
02:00005A74 2E
02:00005A75 2E
02:00005A76 2E
02:00005A77 2E
02:00005A78 2E              	  2040: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
02:00005A79 2E
02:00005A7A 2E
02:00005A7B 2E
02:00005A7C 2E
02:00005A7D 09
02:00005A7E 7E
02:00005A7F 2E
02:00005A80 2E              	  2041: 	dc.b	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
02:00005A81 2E
02:00005A82 2E
02:00005A83 2E
02:00005A84 2E
02:00005A85 11
02:00005A86 21
02:00005A87 2E
02:00005A88 2E              	  2042: 	dc.b	$2e,$2e,$1a,$13,$01,$17,$40,$2e
02:00005A89 2E
02:00005A8A 1A
02:00005A8B 13
02:00005A8C 01
02:00005A8D 17
02:00005A8E 40
02:00005A8F 2E
02:00005A90 2E              	  2043: 	dc.b	$2e,$03,$18,$04,$05,$24,$23,$2e
02:00005A91 03
02:00005A92 18
02:00005A93 04
02:00005A94 05
02:00005A95 24
02:00005A96 23
02:00005A97 2E
02:00005A98 2E              	  2044: 	dc.b	$2e,$20,$16,$06,$14,$12,$25,$2e
02:00005A99 20
02:00005A9A 16
02:00005A9B 06
02:00005A9C 14
02:00005A9D 12
02:00005A9E 25
02:00005A9F 2E
02:00005AA0 2E              	  2045: 	dc.b	$2e,$0e,$02,$08,$07,$19,$5e,$2e
02:00005AA1 0E
02:00005AA2 02
02:00005AA3 08
02:00005AA4 07
02:00005AA5 19
02:00005AA6 5E
02:00005AA7 2E
02:00005AA8 2E              	  2046: 	dc.b	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
02:00005AA9 2E
02:00005AAA 0D
02:00005AAB 0A
02:00005AAC 15
02:00005AAD 26
02:00005AAE 2A
02:00005AAF 2E
02:00005AB0 2E              	  2047: 	dc.b	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
02:00005AB1 3C
02:00005AB2 0B
02:00005AB3 09
02:00005AB4 0F
02:00005AB5 29
02:00005AB6 28
02:00005AB7 2E
02:00005AB8 2E              	  2048: 	dc.b	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
02:00005AB9 3E
02:00005ABA 3F
02:00005ABB 0C
02:00005ABC 3A
02:00005ABD 10
02:00005ABE 5F
02:00005ABF 2E
02:00005AC0 2E              	  2049: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
02:00005AC1 2E
02:00005AC2 22
02:00005AC3 2E
02:00005AC4 7B
02:00005AC5 2B
02:00005AC6 2E
02:00005AC7 2E
02:00005AC8 2E              	  2050: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
02:00005AC9 2E
02:00005ACA 0D
02:00005ACB 7D
02:00005ACC 2E
02:00005ACD 7C
02:00005ACE 2E
02:00005ACF 2E
02:00005AD0 2E              	  2051: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
02:00005AD1 2E
02:00005AD2 2E
02:00005AD3 2E
02:00005AD4 2E
02:00005AD5 2E
02:00005AD6 08
02:00005AD7 2E
02:00005AD8 2E              	  2052: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AD9 2E
02:00005ADA 2E
02:00005ADB 2E
02:00005ADC 2E
02:00005ADD 2E
02:00005ADE 2E
02:00005ADF 2E
02:00005AE0 2E              	  2053: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
02:00005AE1 7F
02:00005AE2 2E
02:00005AE3 2E
02:00005AE4 2E
02:00005AE5 2E
02:00005AE6 1B
02:00005AE7 2E
02:00005AE8 2E              	  2054: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AE9 2E
02:00005AEA 2E
02:00005AEB 2E
02:00005AEC 2E
02:00005AED 2E
02:00005AEE 2E
02:00005AEF 2E
                            	  2055: 
                            	  2056: _keybdExtendedCodes:
02:00005AF0 2E              	  2057: 	dc.b	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
02:00005AF1 2E
02:00005AF2 2E
02:00005AF3 2E
02:00005AF4 A3
02:00005AF5 A1
02:00005AF6 A2
02:00005AF7 2E
02:00005AF8 2E              	  2058: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005AF9 2E
02:00005AFA 2E
02:00005AFB 2E
02:00005AFC 2E
02:00005AFD 2E
02:00005AFE 2E
02:00005AFF 2E
02:00005B00 2E              	  2059: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B01 2E
02:00005B02 2E
02:00005B03 2E
02:00005B04 2E
02:00005B05 2E
02:00005B06 2E
02:00005B07 2E
02:00005B08 2E              	  2060: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B09 2E
02:00005B0A 2E
02:00005B0B 2E
02:00005B0C 2E
02:00005B0D 2E
02:00005B0E 2E
02:00005B0F 2E
02:00005B10 2E              	  2061: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B11 2E
02:00005B12 2E
02:00005B13 2E
02:00005B14 2E
02:00005B15 2E
02:00005B16 2E
02:00005B17 2E
02:00005B18 2E              	  2062: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B19 2E
02:00005B1A 2E
02:00005B1B 2E
02:00005B1C 2E
02:00005B1D 2E
02:00005B1E 2E
02:00005B1F 2E
02:00005B20 2E              	  2063: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B21 2E
02:00005B22 2E
02:00005B23 2E
02:00005B24 2E
02:00005B25 2E
02:00005B26 2E
02:00005B27 2E
02:00005B28 2E              	  2064: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B29 2E
02:00005B2A 2E
02:00005B2B 2E
02:00005B2C 2E
02:00005B2D 2E
02:00005B2E 2E
02:00005B2F 2E
02:00005B30 2E              	  2065: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B31 2E
02:00005B32 2E
02:00005B33 2E
02:00005B34 2E
02:00005B35 2E
02:00005B36 2E
02:00005B37 2E
02:00005B38 2E              	  2066: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B39 2E
02:00005B3A 2E
02:00005B3B 2E
02:00005B3C 2E
02:00005B3D 2E
02:00005B3E 2E
02:00005B3F 2E
02:00005B40 2E              	  2067: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B41 2E
02:00005B42 2E
02:00005B43 2E
02:00005B44 2E
02:00005B45 2E
02:00005B46 2E
02:00005B47 2E
02:00005B48 2E              	  2068: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B49 2E
02:00005B4A 2E
02:00005B4B 2E
02:00005B4C 2E
02:00005B4D 2E
02:00005B4E 2E
02:00005B4F 2E
02:00005B50 2E              	  2069: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
02:00005B51 2E
02:00005B52 2E
02:00005B53 2E
02:00005B54 2E
02:00005B55 2E
02:00005B56 2E
02:00005B57 2E
02:00005B58 2E              	  2070: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
02:00005B59 95
02:00005B5A 2E
02:00005B5B 93
02:00005B5C 94
02:00005B5D 2E
02:00005B5E 2E
02:00005B5F 2E
02:00005B60 98              	  2071: 	dc.b	$98,$99,$92,$2e,$91,$90,$2e,$2e
02:00005B61 99
02:00005B62 92
02:00005B63 2E
02:00005B64 91
02:00005B65 90
02:00005B66 2E
02:00005B67 2E
02:00005B68 2E              	  2072: 	dc.b	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
02:00005B69 2E
02:00005B6A 97
02:00005B6B 2E
02:00005B6C 2E
02:00005B6D 96
02:00005B6E 2E
02:00005B6F 2E
                            	  2073: 
                            	  2074: ;==============================================================================
                            	  2075: ;==============================================================================
                            	  2076: ; Monitor
                            	  2077: ;==============================================================================
                            	  2078: ;==============================================================================
                            	  2079: 
                            	  2080: cmdString:
02:00005B70 BF              	  2081: 	dc.b	'?'+$80						; ? display help
02:00005B71 CC              	  2082: 	dc.b	'L'+$80						; L load S19 file
02:00005B72 46              	  2083: 	dc.b	'F','B'+$80				; FB fill with byte
02:00005B73 C2
02:00005B74 46              	  2084: 	dc.b	'F','W'+$80				; FW fill with wyde
02:00005B75 D7
02:00005B76 46              	  2085: 	dc.b	'F','L'+$80				; FL fill with long wyde
02:00005B77 CC
02:00005B78 42              	  2086: 	dc.b	'B','A'+$80				; BA start Tiny Basic
02:00005B79 C1
02:00005B7A 42              	  2087: 	dc.b	'B','R'+$80				; BR breakpoint
02:00005B7B D2
02:00005B7C 44              	  2088: 	dc.b	'D','R'+$80				; DR dump registers
02:00005B7D D2
02:00005B7E C4              	  2089: 	dc.b	'D'+$80						; D dump memory
02:00005B7F CA              	  2090: 	dc.b	'J'+$80						; J jump to code
02:00005B80 BA              	  2091: 	dc.b	':'+$80						; : edit memory
02:00005B81 434C            	  2092: 	dc.b	"CL",'S'+$80			; CLS clear screen
02:00005B83 D3
02:00005B84 434F52          	  2093: 	dc.b	"COR",'E'+$80			; CORE <n> switch to core
02:00005B87 C5
02:00005B88 5446            	  2094: 	dc.b	"TF",'P'+$80			; TFP test fp
02:00005B8A D0
02:00005B8B 545241          	  2095: 	dc.b  "TRA",'M'+$80			; TRAM test RAM
02:00005B8E CD
02:00005B8F 54              	  2096: 	dc.b	'T','R'+$80				; TR test serial receive
02:00005B90 D2
02:00005B91 D4              	  2097: 	dc.b	'T'+$80						; T test CPU
02:00005B92 D3              	  2098: 	dc.b	'S'+$80						; S send serial
02:00005B93 52455345        	  2099: 	dc.b	"RESE",'T'+$80		; RESET <n>
02:00005B97 D4
02:00005B98 434C4F43        	  2100: 	dc.b	"CLOC",'K'+$80		; CLOCK <n>
02:00005B9C CB
02:00005B9D D2              	  2101: 	dc.b	'R'+$80						; R receive serial
                            	  2102: 
                            	  2103: 	align	2
                            	  2104: cmdTable:
02:00005BA0 5D9C            	  2105: 	dc.w	cmdHelp
02:00005BA2 63EE            	  2106: 	dc.w	cmdLoadS19
02:00005BA4 6026            	  2107: 	dc.w	cmdFillB
02:00005BA6 604A            	  2108: 	dc.w	cmdFillW
02:00005BA8 606E            	  2109: 	dc.w	cmdFillL
02:00005BAA 5C9A            	  2110: 	dc.w	cmdTinyBasic
02:00005BAC 5C76            	  2111: 	dc.w	cmdBreakpoint
02:00005BAE 61A0            	  2112: 	dc.w	cmdDumpRegs
02:00005BB0 6112            	  2113: 	dc.w	cmdDumpMemory
02:00005BB2 6104            	  2114: 	dc.w	cmdJump
02:00005BB4 60A4            	  2115: 	dc.w	cmdEditMemory
02:00005BB6 5CAE            	  2116: 	dc.w	cmdClearScreen
02:00005BB8 5CBA            	  2117: 	dc.w	cmdCore
02:00005BBA 5CDE            	  2118: 	dc.w  cmdTestFP
02:00005BBC 6334            	  2119: 	dc.w  cmdTestRAM
02:00005BBE 624A            	  2120: 	dc.w	cmdTestSerialReceive
02:00005BC0 5C9E            	  2121: 	dc.w	cmdTestCPU
02:00005BC2 5FC2            	  2122: 	dc.w	cmdSendSerial
02:00005BC4 5D4A            	  2123: 	dc.w	cmdReset
02:00005BC6 5D2C            	  2124: 	dc.w	cmdClock
02:00005BC8 5FF2            	  2125: 	dc.w	cmdReceiveSerial	
02:00005BCA 5BE0            	  2126: 	dc.w	cmdMonitor
                            	  2127: 
                            	  2128: ; Get a word from screen memory and swap byte order
                            	  2129: 
                            	  2130: FromScreen:
02:00005BCC 2210            	  2131: 	move.l	(a0),d1
02:00005BCE 61000A3A        	  2132: 	bsr			rbo
02:00005BD2 5088            	  2133: 	lea			8(a0),a0	; increment screen pointer
02:00005BD4 4E75            	  2134: 	rts
                            	  2135: 
                            	  2136: StartMon:
02:00005BD6 427900040202    	  2137: 	clr.w		NumSetBreakpoints
02:00005BDC 61000F08        	  2138: 	bsr			ClearBreakpointList
                            	  2139: cmdMonitor:
                            	  2140: Monitor:
                            	  2141: 	; Reset the stack pointer on each entry into the monitor
02:00005BE0 2E7C00040FFC    	  2142: 	move.l	#$40FFC,sp	; reset core's stack
02:00005BE6 46FC2200        	  2143: 	move.w	#$2200,sr		; enable level 2 and higher interrupts
02:00005BEA 4E7A0FE0        	  2144: 	movec		coreno,d0
02:00005BEE 4840            	  2145: 	swap		d0
02:00005BF0 7201            	  2146: 	moveq		#1,d1
02:00005BF2 6100A656        	  2147: 	bsr			UnlockSemaphore
02:00005BF6 42390004000C    	  2148: 	clr.b		KeybdEcho		; turn off keyboard echo
                            	  2149: PromptLn:
02:00005BFC 6100F262        	  2150: 	bsr			CRLF
02:00005C00 123C0024        	  2151: 	move.b	#'$',d1
02:00005C04 6100F2A4        	  2152: 	bsr			DisplayChar
                            	  2153: 
                            	  2154: ; Get characters until a CR is keyed
                            	  2155: ;
                            	  2156: Prompt3:
02:00005C08 6100F8D8        	  2157: 	bsr			GetKey
02:00005C0C 0C0100FF        	  2158: 	cmpi.b	#-1,d1
02:00005C10 67F6            	  2159: 	beq.s		Prompt3
02:00005C12 0C01000D        	  2160: 	cmpi.b	#CR,d1
02:00005C16 6706            	  2161: 	beq.s		Prompt1
02:00005C18 6100F290        	  2162: 	bsr			DisplayChar
02:00005C1C 60EA            	  2163: 	bra.s		Prompt3
                            	  2164: 
                            	  2165: ; Process the screen line that the CR was keyed on
                            	  2166: 
                            	  2167: Prompt1:
02:00005C1E 423900040001    	  2168: 	clr.b		CursorCol			; go back to the start of the line
02:00005C24 6100F276        	  2169: 	bsr			CalcScreenLoc	; a0 = screen memory location
                            	  2170: .0001:
02:00005C28 61A2            	  2171: 	bsr			FromScreen		; grab character off screen
02:00005C2A 0C010024        	  2172: 	cmpi.b	#'$',d1				; skip over '$' prompt character
02:00005C2E 67F8            	  2173: 	beq.s		.0001
                            	  2174: 	
                            	  2175: ; Dispatch based on command string
                            	  2176: 
                            	  2177: cmdDispatch:
02:00005C30 45FAFF3E        	  2178: 	lea			cmdString,a2
02:00005C34 7800            	  2179: 	clr.l		d4						; command counter
02:00005C36 5188            	  2180: 	lea			-8(a0),a0			; backup a character
02:00005C38 2648            	  2181: 	move.l	a0,a3					; a3 = start of command on screen
                            	  2182: .checkNextCmd:
02:00005C3A 6190            	  2183: 	bsr			FromScreen		; d1 = char from input screen
02:00005C3C 1A1A            	  2184: 	move.b	(a2)+,d5
02:00005C3E BB01            	  2185: 	eor.b		d5,d1					; does it match with command string?
02:00005C40 67F8            	  2186: 	beq.s		.checkNextCmd	; If it does, keep matching for longest match
02:00005C42 0C010080        	  2187: 	cmpi.b	#$80,d1				; didn't match, was it the end of the command?
02:00005C46 6724            	  2188: 	beq.s		.foundCmd
02:00005C48 4A2AFFFF        	  2189: 	tst.b		-1(a2)				; was end of table hit?
02:00005C4C 6712            	  2190: 	beq.s		.endOfTable
02:00005C4E 5444            	  2191: 	addi.w	#2,d4					; increment command counter
02:00005C50 204B            	  2192: 	move.l	a3,a0					; reset input pointer
02:00005C52 4A2AFFFF        	  2193: 	tst.b		-1(a2)				; were we at the end of the command?
02:00005C56 6BE2            	  2194: 	bmi.s		.checkNextCmd	; if were at end continue, otherwise scan for enf of cmd
                            	  2195: .scanToEndOfCmd
02:00005C58 4A1A            	  2196: 	tst.b		(a2)+					; scan to end of command
02:00005C5A 6704            	  2197: 	beq.s		.endOfTable
02:00005C5C 6AFA            	  2198: 	bpl.s		.scanToEndOfCmd
02:00005C5E 6BDA            	  2199: 	bmi.s		.checkNextCmd
                            	  2200: .endOfTable
02:00005C60 43FA029A        	  2201: 	lea			msgUnknownCmd,a1
02:00005C64 6100F4D4        	  2202: 	bsr			DisplayStringCRLF
02:00005C68 6000FF76        	  2203: 	bra			Monitor
                            	  2204: .foundCmd:
02:00005C6C 43FAFF32        	  2205: 	lea			cmdTable,a1		; a1 = pointer to command address table
02:00005C70 32714000        	  2206: 	move.w	(a1,d4.w),a1	; fetch command routine address from table
02:00005C74 4ED1            	  2207: 	jmp			(a1)					; go execute command
                            	  2208: 
                            	  2209: cmdBreakpoint:
02:00005C76 6100041A        	  2210: 	bsr			ignBlanks
02:00005C7A 6100FF50        	  2211: 	bsr			FromScreen
02:00005C7E 0C01002B        	  2212: 	cmpi.b	#'+',d1
02:00005C82 67000D70        	  2213: 	beq			ArmBreakpoint
02:00005C86 0C01002D        	  2214: 	cmpi.b	#'-',d1
02:00005C8A 67000DE6        	  2215: 	beq			DisarmBreakpoint
02:00005C8E 0C01004C        	  2216: 	cmpi.b	#'L',d1
02:00005C92 67000E32        	  2217: 	beq			ListBreakpoints
02:00005C96 6000FF48        	  2218: 	bra			Monitor
                            	  2219: 
                            	  2220: cmdTinyBasic:
02:00005C9A 6000E178        	  2221: 	bra			CSTART
                            	  2222: 
                            	  2223: cmdTestCPU:
02:00005C9E 6100A612        	  2224: 	bsr			cpu_test
02:00005CA2 43FA1422        	  2225: 	lea			msg_test_done,a1
02:00005CA6 6100F492        	  2226: 	bsr			DisplayStringCRLF
02:00005CAA 6000FF34        	  2227: 	bra			Monitor
                            	  2228: 
                            	  2229: cmdClearScreen:
02:00005CAE 61000954        	  2230: 	bsr			ClearScreen
02:00005CB2 6100F4B2        	  2231: 	bsr			HomeCursor
02:00005CB6 6000FF28        	  2232: 	bra			Monitor
                            	  2233: 
                            	  2234: cmdCore:
02:00005CBA 610003D6        	  2235: 	bsr			ignBlanks
02:00005CBE 6100FF0C        	  2236: 	bsr			FromScreen
02:00005CC2 0C010032        	  2237: 	cmpi.b	#'2',d1					; check range
02:00005CC6 6500FF18        	  2238: 	blo			Monitor
02:00005CCA 0C010039        	  2239: 	cmpi.b	#'9',d1
02:00005CCE 6200FF10        	  2240: 	bhi			Monitor
02:00005CD2 04010030        	  2241: 	subi.b	#'0',d1					; convert ascii to binary
02:00005CD6 6100F5B8        	  2242: 	bsr			select_iofocus
02:00005CDA 6000FF04        	  2243: 	bra			Monitor
                            	  2244: 
                            	  2245: cmdTestFP:
02:00005CDE 610003B2        	  2246: 	bsr ignBlanks
02:00005CE2 61000586        	  2247: 	bsr GetHexNumber
02:00005CE6 2601            	  2248: 	move.l d1,d3
02:00005CE8 610003A8        	  2249: 	bsr ignBlanks
02:00005CEC 6100057C        	  2250: 	bsr GetHexNumber
02:00005CF0 2401            	  2251: 	move.l d1,d2
02:00005CF2 6100F16C        	  2252: 	bsr CRLF
02:00005CF6 F2034000        	  2253: 	fmove.l d3,fp0					; this should do I2FP
                            	  2254: ;	moveq #39,d0
                            	  2255: ;	moveq #40,d1
                            	  2256: ;	moveq #30,d2
                            	  2257: ;	moveq #'e',d3
                            	  2258: ;	trap #15
                            	  2259: ;	bsr CRLF
02:00005CFA F2024080        	  2260: 	fmove.l d2,fp1					; this should do I2FP
02:00005CFE F2396C00000402C0	  2261: 	fmove.p fp0,fpBuf
02:00005D06 F2396C80000402D0	  2262: 	fmove.p fp1,fpBuf+16
02:00005D0E F2000422        	  2263: 	fadd fp1,fp0
02:00005D12 F2396C00000402E0	  2264: 	fmove.p fp0,fpBuf+32
02:00005D1A 7027            	  2265: 	moveq #39,d0
02:00005D1C 7228            	  2266: 	moveq #40,d1
02:00005D1E 741E            	  2267: 	moveq #30,d2
02:00005D20 7665            	  2268: 	moveq #'e',d3
02:00005D22 4E4F            	  2269: 	trap #15
02:00005D24 6100F13A        	  2270: 	bsr CRLF
02:00005D28 6000FEB6        	  2271: 	bra Monitor
                            	  2272: 		
                            	  2273: ;-------------------------------------------------------------------------------
                            	  2274: ; CLOCK <n>
                            	  2275: ;    Set the clock register to n which will turn off or on clocks to the CPUs.
                            	  2276: ;-------------------------------------------------------------------------------
                            	  2277: 
                            	  2278: cmdClock:
02:00005D2C 61000364        	  2279: 	bsr			ignBlanks
02:00005D30 61000538        	  2280: 	bsr			GetHexNumber
02:00005D34 4A00            	  2281: 	tst.b		d0							; was there a number?
02:00005D36 6700FEA8        	  2282: 	beq			Monitor
02:00005D3A 00400004        	  2283: 	ori.w		#4,d0						; primary core's clock cannot be turned off
02:00005D3E E159            	  2284: 	rol.w		#8,d1						; switch byte order
02:00005D40 33C1FD0FFC02    	  2285: 	move.w	d1,RST_REG+2
02:00005D46 6000FE98        	  2286: 	bra			Monitor
                            	  2287: 
                            	  2288: ;-------------------------------------------------------------------------------
                            	  2289: ; RESET <n>
                            	  2290: ;    Reset the specified core. Resetting the core automatically turns on the 
                            	  2291: ; core's clock.
                            	  2292: ;-------------------------------------------------------------------------------
                            	  2293: 
                            	  2294: cmdReset:
02:00005D4A 61000346        	  2295: 	bsr			ignBlanks
02:00005D4E 6100FE7C        	  2296: 	bsr			FromScreen
02:00005D52 0C010032        	  2297: 	cmpi.b	#'2',d1					; check range
02:00005D56 6500FE88        	  2298: 	blo			Monitor
02:00005D5A 0C010039        	  2299: 	cmpi.b	#'9',d1
02:00005D5E 6200FE80        	  2300: 	bhi			Monitor
02:00005D62 04010030        	  2301: 	subi.b	#'0',d1					; convert ascii to binary
02:00005D66 E349            	  2302: 	lsl.w		#1,d1						; make into index
02:00005D68 43FA0012        	  2303: 	lea			tblPow2,a1
02:00005D6C 32311000        	  2304: 	move.w	(a1,d1.w),d1
02:00005D70 E159            	  2305: 	rol.w		#8,d1						; reverse byte order
02:00005D72 33C1FD0FFC00    	  2306: 	move.w	d1,RST_REG
02:00005D78 6000FE66        	  2307: 	bra			Monitor
                            	  2308: 
                            	  2309: tblPow2:
02:00005D7C 0001            	  2310: 	dc.w		1
02:00005D7E 0002            	  2311: 	dc.w		2
02:00005D80 0004            	  2312: 	dc.w		4
02:00005D82 0008            	  2313: 	dc.w		8
02:00005D84 0010            	  2314: 	dc.w		16
02:00005D86 0020            	  2315: 	dc.w		32
02:00005D88 0040            	  2316: 	dc.w		64
02:00005D8A 0080            	  2317: 	dc.w		128
02:00005D8C 0100            	  2318: 	dc.w		256
02:00005D8E 0200            	  2319: 	dc.w		512
02:00005D90 0400            	  2320: 	dc.w		1024
02:00005D92 0800            	  2321: 	dc.w		2048
02:00005D94 1000            	  2322: 	dc.w		4096
02:00005D96 2000            	  2323: 	dc.w		8192
02:00005D98 4000            	  2324: 	dc.w		16384
02:00005D9A 8000            	  2325: 	dc.w		32768
                            	  2326: 	even
                            	  2327: 	
                            	  2328: cmdHelp:
                            	  2329: DisplayHelp:
02:00005D9C 43FA000A        	  2330: 	lea			HelpMsg,a1
02:00005DA0 6100F382        	  2331: 	bsr			DisplayString
02:00005DA4 6000FE3A        	  2332: 	bra			Monitor
                            	  2333: 
                            	  2334: HelpMsg:
02:00005DA8 3F203D2044697370	  2335: 	dc.b	"? = Display help",LF,CR
02:00005DB0 6C61792068656C70
02:00005DB8 0A
02:00005DB9 0D
02:00005DBA 434F5245206E203D	  2336: 	dc.b  "CORE n = switch to core n, n = 2 to 7",LF,CR
02:00005DC2 2073776974636820
02:00005DCA 746F20636F726520
02:00005DD2 6E2C206E203D2032
02:00005DDA 20746F2037
02:00005DDF 0A
02:00005DE0 0D
02:00005DE1 5245534554206E20	  2337: 	dc.b  "RESET n = reset core n",LF,CR
02:00005DE9 3D20726573657420
02:00005DF1 636F7265206E
02:00005DF7 0A
02:00005DF8 0D
02:00005DF9 434C53203D20636C	  2338: 	dc.b	"CLS = clear screen",LF,CR
02:00005E01 6561722073637265
02:00005E09 656E
02:00005E0B 0A
02:00005E0C 0D
02:00005E0D 3A203D2045646974	  2339: 	dc.b	": = Edit memory bytes",LF,CR
02:00005E15 206D656D6F727920
02:00005E1D 6279746573
02:00005E22 0A
02:00005E23 0D
02:00005E24 4642203D2046696C	  2340: 	dc.b	"FB = Fill memory bytes, FW, FL",LF,CR
02:00005E2C 6C206D656D6F7279
02:00005E34 2062797465732C20
02:00005E3C 46572C20464C
02:00005E42 0A
02:00005E43 0D
02:00005E44 4C203D204C6F6164	  2341: 	dc.b	"L = Load S19 file",LF,CR
02:00005E4C 205331392066696C
02:00005E54 65
02:00005E55 0A
02:00005E56 0D
02:00005E57 44203D2044756D70	  2342: 	dc.b	"D = Dump memory, DR = dump registers",LF,CR
02:00005E5F 206D656D6F72792C
02:00005E67 204452203D206475
02:00005E6F 6D70207265676973
02:00005E77 74657273
02:00005E7B 0A
02:00005E7C 0D
02:00005E7D 4241203D20737461	  2343: 	dc.b	"BA = start tiny basic",LF,CR
02:00005E85 72742074696E7920
02:00005E8D 6261736963
02:00005E92 0A
02:00005E93 0D
02:00005E94 4252203D20736574	  2344: 	dc.b  "BR = set breakpoint",LF,CR
02:00005E9C 20627265616B706F
02:00005EA4 696E74
02:00005EA7 0A
02:00005EA8 0D
02:00005EA9 4A203D204A756D70	  2345: 	dc.b	"J = Jump to code",LF,CR
02:00005EB1 20746F20636F6465
02:00005EB9 0A
02:00005EBA 0D
02:00005EBB 53203D2073656E64	  2346: 	dc.b  "S = send to serial port",LF,CR
02:00005EC3 20746F2073657269
02:00005ECB 616C20706F7274
02:00005ED2 0A
02:00005ED3 0D
02:00005ED4 54203D2063707520	  2347: 	dc.b	"T = cpu test program",LF,CR
02:00005EDC 746573742070726F
02:00005EE4 6772616D
02:00005EE8 0A
02:00005EE9 0D
02:00005EEA 5452414D203D2074	  2348: 	dc.b	"TRAM = test RAM",LF,CR,0
02:00005EF2 6573742052414D
02:00005EF9 0A
02:00005EFA 0D
02:00005EFB 00
                            	  2349: 
                            	  2350: msgUnknownCmd:
02:00005EFC 636F6D6D616E6420	  2351: 	dc.b	"command unknown",0
02:00005F04 756E6B6E6F776E
02:00005F0B 00
                            	  2352: 
                            	  2353: msgHello:
02:00005F0C 0A              	  2354: 	dc.b	LF,CR,"Hello World!",LF,CR,0
02:00005F0D 0D
02:00005F0E 48656C6C6F20576F
02:00005F16 726C6421
02:00005F1A 0A
02:00005F1B 0D
02:00005F1C 00
                            	  2355: 	even
                            	  2356: 
                            	  2357: ;------------------------------------------------------------------------------
                            	  2358: ; This routine borrowed from Gordo's Tiny Basic interpreter.
                            	  2359: ; Used to fetch a command line. (Not currently used).
                            	  2360: ;
                            	  2361: ; d0.b	- command prompt
                            	  2362: ;------------------------------------------------------------------------------
                            	  2363: 
                            	  2364: GetCmdLine:
02:00005F1E 6100EF8A        	  2365: 		bsr		DisplayChar		; display prompt
02:00005F22 103C0020        	  2366: 		move.b	#' ',d0
02:00005F26 6100EF82        	  2367: 		bsr		DisplayChar
02:00005F2A 41F900040040    	  2368: 		lea		CmdBuf,a0
                            	  2369: .0001:
02:00005F30 6100F5B0        	  2370: 		bsr		GetKey
02:00005F34 B03C0008        	  2371: 		cmp.b	#CTRLH,d0
02:00005F38 6728            	  2372: 		beq.s	.0003
02:00005F3A B03C0018        	  2373: 		cmp.b	#CTRLX,d0
02:00005F3E 6746            	  2374: 		beq.s	.0004
02:00005F40 B03C000D        	  2375: 		cmp.b	#CR,d0
02:00005F44 6706            	  2376: 		beq.s	.0002
02:00005F46 B03C0020        	  2377: 		cmp.b	#' ',d0
02:00005F4A 65E4            	  2378: 		bcs.s	.0001
                            	  2379: .0002:
02:00005F4C 1080            	  2380: 		move.b	d0,(a0)
02:00005F4E 5088            	  2381: 		lea			8(a0),a0
02:00005F50 6100EF58        	  2382: 		bsr		DisplayChar
02:00005F54 B03C000D        	  2383: 		cmp.b	#CR,d0
02:00005F58 675E            	  2384: 		beq		.0007
02:00005F5A B1FC0004007F    	  2385: 		cmp.l	#CmdBufEnd-1,a0
02:00005F60 65CE            	  2386: 		bcs.s	.0001
                            	  2387: .0003:
02:00005F62 103C0008        	  2388: 		move.b	#CTRLH,d0
02:00005F66 6100EF42        	  2389: 		bsr		DisplayChar
02:00005F6A 103C0020        	  2390: 		move.b	#' ',d0
02:00005F6E 6100EF3A        	  2391: 		bsr		DisplayChar
02:00005F72 B1FC00040040    	  2392: 		cmp.l	#CmdBuf,a0
02:00005F78 63B6            	  2393: 		bls.s	.0001
02:00005F7A 103C0008        	  2394: 		move.b	#CTRLH,d0
02:00005F7E 6100EF2A        	  2395: 		bsr		DisplayChar
02:00005F82 5388            	  2396: 		subq.l	#1,a0
02:00005F84 60AA            	  2397: 		bra.s	.0001
                            	  2398: .0004:
02:00005F86 2208            	  2399: 		move.l	a0,d1
02:00005F88 92BC00040040    	  2400: 		sub.l	#CmdBuf,d1
02:00005F8E 671E            	  2401: 		beq.s	.0006
02:00005F90 5341            	  2402: 		subq	#1,d1
                            	  2403: .0005:
02:00005F92 103C0008        	  2404: 		move.b	#CTRLH,d0
02:00005F96 6100EF12        	  2405: 		bsr		DisplayChar
02:00005F9A 103C0020        	  2406: 		move.b	#' ',d0
02:00005F9E 6100EF0A        	  2407: 		bsr		DisplayChar
02:00005FA2 103C0008        	  2408: 		move.b	#CTRLH,d0
02:00005FA6 6100EF02        	  2409: 		bsr		DisplayChar
02:00005FAA 51C9FFE6        	  2410: 		dbra	d1,.0005
                            	  2411: .0006:
02:00005FAE 41F900040040    	  2412: 		lea		CmdBuf,a0
02:00005FB4 6000FF7A        	  2413: 		bra		.0001
                            	  2414: .0007:
02:00005FB8 103C000A        	  2415: 		move.b	#LF,d0
02:00005FBC 6100EEEC        	  2416: 		bsr		DisplayChar
02:00005FC0 4E75            	  2417: 		rts
                            	  2418: 
                            	  2419: ;------------------------------------------------------------------------------
                            	  2420: ; S <address> <length>
                            	  2421: ; Send data buffer to serial port
                            	  2422: ; S 40000 40
                            	  2423: ;------------------------------------------------------------------------------
                            	  2424: 
                            	  2425: cmdSendSerial:
02:00005FC2 610000CE        	  2426: 	bsr			ignBlanks
02:00005FC6 610002A2        	  2427: 	bsr			GetHexNumber
02:00005FCA 6700FC14        	  2428: 	beq			Monitor
02:00005FCE 2C01            	  2429: 	move.l	d1,d6					; d6 points to buffer
02:00005FD0 610000C0        	  2430: 	bsr			ignBlanks
02:00005FD4 61000294        	  2431: 	bsr			GetHexNumber
02:00005FD8 6602            	  2432: 	bne.s		.0003
02:00005FDA 7210            	  2433: 	moveq		#16,d1
                            	  2434: .0003:
02:00005FDC 2246            	  2435: 	move.l	d6,a1					; a1 points to buffer
02:00005FDE 2401            	  2436: 	move.l	d1,d2					; d2 = count of bytes to send
02:00005FE0 6008            	  2437: 	bra.s		.0002					; enter loop at bottom
                            	  2438: .0001:
02:00005FE2 1219            	  2439: 	move.b	(a1)+,d1
02:00005FE4 303C0022        	  2440: 	move.w	#34,d0				; serial putchar
02:00005FE8 4E4F            	  2441: 	trap		#15
                            	  2442: .0002:
02:00005FEA 51CAFFF6        	  2443: 	dbra		d2,.0001
02:00005FEE 6000FBF0        	  2444: 	bra			Monitor
                            	  2445: 		
                            	  2446: ;------------------------------------------------------------------------------
                            	  2447: ; R <address> <length>
                            	  2448: ; Send data buffer to serial port
                            	  2449: ; R 10000 40
                            	  2450: ;------------------------------------------------------------------------------
                            	  2451: 
                            	  2452: cmdReceiveSerial:
02:00005FF2 6100009E        	  2453: 	bsr			ignBlanks
02:00005FF6 61000272        	  2454: 	bsr			GetHexNumber
02:00005FFA 6700FBE4        	  2455: 	beq			Monitor
02:00005FFE 2C01            	  2456: 	move.l	d1,d6					; d6 points to buffer
02:00006000 61000090        	  2457: 	bsr			ignBlanks
02:00006004 61000264        	  2458: 	bsr			GetHexNumber
02:00006008 6602            	  2459: 	bne.s		.0003
02:0000600A 7210            	  2460: 	moveq		#16,d1
                            	  2461: .0003:
02:0000600C 2246            	  2462: 	move.l	d6,a1					; a1 points to buffer
02:0000600E 2401            	  2463: 	move.l	d1,d2					; d2 = count of bytes to send
02:00006010 600C            	  2464: 	bra.s		.0002					; enter loop at bottom
                            	  2465: .0001:
02:00006012 303C0024        	  2466: 	move.w	#36,d0				; serial peek char
02:00006016 4E4F            	  2467: 	trap		#15
02:00006018 4A81            	  2468: 	tst.l		d1
02:0000601A 6BF6            	  2469: 	bmi.s		.0001
02:0000601C 12C1            	  2470: 	move.b	d1,(a1)+
                            	  2471: .0002:
02:0000601E 51CAFFF2        	  2472: 	dbra		d2,.0001
02:00006022 6000FBBC        	  2473: 	bra			Monitor
                            	  2474: 		
                            	  2475: ;------------------------------------------------------------------------------
                            	  2476: ; Fill memory
                            	  2477: ;
                            	  2478: ; FB = fill bytes		FB 00000010 100 FF	; fill starting at 10 for 256 bytes
                            	  2479: ; FW = fill words
                            	  2480: ; FL = fill longs
                            	  2481: ; F = fill bytes
                            	  2482: ;------------------------------------------------------------------------------
                            	  2483: 
                            	  2484: cmdFillB:
02:00006026 616A            	  2485: 	bsr			ignBlanks
02:00006028 61000240        	  2486: 	bsr			GetHexNumber
02:0000602C 2241            	  2487: 	move.l	d1,a1					; a1 = start
02:0000602E 6162            	  2488: 	bsr			ignBlanks
02:00006030 61000238        	  2489: 	bsr			GetHexNumber
02:00006034 2601            	  2490: 	move.l	d1,d3					; d3 = count
02:00006036 6700FBA8        	  2491: 	beq			Monitor
02:0000603A 6156            	  2492: 	bsr			ignBlanks
02:0000603C 6100022C        	  2493: 	bsr			GetHexNumber	; fill value
                            	  2494: .fmem:
02:00006040 12C1            	  2495: 	move.b	d1,(a1)+
02:00006042 5383            	  2496: 	sub.l		#1,d3
02:00006044 66FA            	  2497: 	bne.s		.fmem
02:00006046 6000FB98        	  2498: 	bra			Monitor
                            	  2499: 	
                            	  2500: cmdFillW:
02:0000604A 6146            	  2501: 	bsr			ignBlanks
02:0000604C 6100021C        	  2502: 	bsr			GetHexNumber
02:00006050 2241            	  2503: 	move.l	d1,a1					; a1 = start
02:00006052 613E            	  2504: 	bsr			ignBlanks
02:00006054 61000214        	  2505: 	bsr			GetHexNumber
02:00006058 2601            	  2506: 	move.l	d1,d3					; d3 = count
02:0000605A 6700FB84        	  2507: 	beq			Monitor
02:0000605E 6132            	  2508: 	bsr			ignBlanks
02:00006060 61000208        	  2509: 	bsr			GetHexNumber	; fill value
                            	  2510: .fmem:
02:00006064 32C1            	  2511: 	move.w	d1,(a1)+
02:00006066 5383            	  2512: 	sub.l		#1,d3
02:00006068 66FA            	  2513: 	bne.s		.fmem
02:0000606A 6000FB74        	  2514: 	bra			Monitor
                            	  2515: 	
                            	  2516: cmdFillL:
02:0000606E 6122            	  2517: 	bsr			ignBlanks
02:00006070 610001F8        	  2518: 	bsr			GetHexNumber
02:00006074 2241            	  2519: 	move.l	d1,a1					; a1 = start
02:00006076 611A            	  2520: 	bsr			ignBlanks
02:00006078 610001F0        	  2521: 	bsr			GetHexNumber
02:0000607C 2601            	  2522: 	move.l	d1,d3					; d3 = count
02:0000607E 6700FB60        	  2523: 	beq			Monitor
02:00006082 610E            	  2524: 	bsr			ignBlanks
02:00006084 610001E4        	  2525: 	bsr			GetHexNumber	; fill value
                            	  2526: .fmem:
02:00006088 22C1            	  2527: 	move.l	d1,(a1)+
02:0000608A 5383            	  2528: 	sub.l		#1,d3
02:0000608C 66FA            	  2529: 	bne.s		.fmem
02:0000608E 6000FB50        	  2530: 	bra			Monitor
                            	  2531: 	
                            	  2532: ;------------------------------------------------------------------------------
                            	  2533: ; Modifies:
                            	  2534: ;	a0	- text pointer
                            	  2535: ;------------------------------------------------------------------------------
                            	  2536: 
                            	  2537: ignBlanks:
02:00006092 2F01            	  2538: 	move.l	d1,-(a7)
                            	  2539: .0001:
02:00006094 6100FB36        	  2540: 	bsr			FromScreen
02:00006098 0C010020        	  2541: 	cmpi.b	#' ',d1
02:0000609C 67F6            	  2542: 	beq.s		.0001
02:0000609E 5188            	  2543: 	lea			-8(a0),a0
02:000060A0 221F            	  2544: 	move.l	(a7)+,d1
02:000060A2 4E75            	  2545: 	rts
                            	  2546: 
                            	  2547: ;------------------------------------------------------------------------------
                            	  2548: ; Edit memory byte.
                            	  2549: ;    Bytes are built into long words in case the memory is only longword
                            	  2550: ; accessible.
                            	  2551: ;------------------------------------------------------------------------------
                            	  2552: 
                            	  2553: cmdEditMemory:
02:000060A4 61EC            	  2554: 	bsr			ignBlanks
02:000060A6 610001C2        	  2555: 	bsr			GetHexNumber
02:000060AA 2241            	  2556: 	move.l	d1,a1
                            	  2557: edtmem1:
02:000060AC 7400            	  2558: 	clr.l		d2
02:000060AE 61E2            	  2559: 	bsr			ignBlanks
02:000060B0 610001B8        	  2560: 	bsr			GetHexNumber
02:000060B4 1401            	  2561: 	move.b	d1,d2
                            	  2562: ;	move.b	d1,(a1)+
02:000060B6 61DA            	  2563: 	bsr			ignBlanks
02:000060B8 610001B0        	  2564: 	bsr			GetHexNumber
02:000060BC E18A            	  2565: 	lsl.l		#8,d2
02:000060BE 1401            	  2566: 	move.b	d1,d2
                            	  2567: ;	move.b	d1,(a1)+
02:000060C0 61D0            	  2568: 	bsr			ignBlanks
02:000060C2 610001A6        	  2569: 	bsr			GetHexNumber
02:000060C6 E18A            	  2570: 	lsl.l		#8,d2
02:000060C8 1401            	  2571: 	move.b	d1,d2
                            	  2572: ;	move.b	d1,(a1)+
02:000060CA 61C6            	  2573: 	bsr			ignBlanks
02:000060CC 6100019C        	  2574: 	bsr			GetHexNumber
02:000060D0 E18A            	  2575: 	lsl.l		#8,d2
02:000060D2 1401            	  2576: 	move.b	d1,d2
02:000060D4 22C2            	  2577: 	move.l	d2,(a1)+
                            	  2578: ;	move.b	d1,(a1)+
02:000060D6 7400            	  2579: 	clr.l		d2
02:000060D8 61B8            	  2580: 	bsr			ignBlanks
02:000060DA 6100018E        	  2581: 	bsr			GetHexNumber
02:000060DE 1401            	  2582: 	move.b	d1,d2
                            	  2583: ;	move.b	d1,(a1)+
02:000060E0 61B0            	  2584: 	bsr			ignBlanks
02:000060E2 61000186        	  2585: 	bsr			GetHexNumber
02:000060E6 E18A            	  2586: 	lsl.l		#8,d2
02:000060E8 1401            	  2587: 	move.b	d1,d2
                            	  2588: ;	move.b	d1,(a1)+
02:000060EA 61A6            	  2589: 	bsr			ignBlanks
02:000060EC 6100017C        	  2590: 	bsr			GetHexNumber
02:000060F0 E18A            	  2591: 	lsl.l		#8,d2
02:000060F2 1401            	  2592: 	move.b	d1,d2
                            	  2593: ;	move.b	d1,(a1)+
02:000060F4 619C            	  2594: 	bsr			ignBlanks
02:000060F6 61000172        	  2595: 	bsr			GetHexNumber
02:000060FA E18A            	  2596: 	lsl.l		#8,d2
02:000060FC 1401            	  2597: 	move.b	d1,d2
                            	  2598: ;	move.b	d1,(a1)+
02:000060FE 22C2            	  2599: 	move.l	d2,(a1)+
02:00006100 6000FADE        	  2600: 	bra			Monitor
                            	  2601: 
                            	  2602: ;------------------------------------------------------------------------------
                            	  2603: ; Execute code at the specified address.
                            	  2604: ;------------------------------------------------------------------------------
                            	  2605: 
                            	  2606: cmdJump:
                            	  2607: ExecuteCode:
02:00006104 618C            	  2608: 	bsr			ignBlanks
02:00006106 61000162        	  2609: 	bsr			GetHexNumber
02:0000610A 2041            	  2610: 	move.l	d1,a0
02:0000610C 4E90            	  2611: 	jsr			(a0)
02:0000610E 6000FAD0        	  2612: 	bra     Monitor
                            	  2613: 
                            	  2614: ;------------------------------------------------------------------------------
                            	  2615: ; Do a memory dump of the requested location.
                            	  2616: ; D 0800 0850
                            	  2617: ;------------------------------------------------------------------------------
                            	  2618: 
                            	  2619: cmdDumpMemory:
02:00006112 6100FF7E        	  2620: 	bsr			ignBlanks
02:00006116 61000152        	  2621: 	bsr			GetHexNumber
02:0000611A 6700FAC4        	  2622: 	beq			Monitor			; was there a number ? no, other garbage, just ignore
02:0000611E 2601            	  2623: 	move.l	d1,d3				; save off start of range
02:00006120 6100FF70        	  2624: 	bsr			ignBlanks
02:00006124 61000144        	  2625: 	bsr			GetHexNumber
02:00006128 6608            	  2626: 	bne.s		DumpMem1
02:0000612A 2203            	  2627: 	move.l	d3,d1
02:0000612C 068100000040    	  2628: 	addi.l	#64,d1			; no end specified, just dump 64 bytes
                            	  2629: DumpMem1:
02:00006132 2043            	  2630: 	move.l	d3,a0
02:00006134 2241            	  2631: 	move.l	d1,a1
02:00006136 6100ED28        	  2632: 	bsr			CRLF
                            	  2633: .0001:
02:0000613A B3C8            	  2634: 	cmpa.l	a0,a1
02:0000613C 6300FAA2        	  2635: 	bls			Monitor
02:00006140 6102            	  2636: 	bsr			DisplayMem
02:00006142 60F6            	  2637: 	bra.s		.0001
                            	  2638: 
                            	  2639: ;------------------------------------------------------------------------------
                            	  2640: ; Display memory dump in a format suitable for edit.
                            	  2641: ;
                            	  2642: ;	:12345678 00 11 22 33 44 55 66 77  "........"
                            	  2643: ;
                            	  2644: ; Modifies:
                            	  2645: ;		d1,d2,a0
                            	  2646: ;------------------------------------------------------------------------------
                            	  2647: 
                            	  2648: DisplayMem:
02:00006144 123C003A        	  2649: 	move.b	#':',d1
02:00006148 6100ED60        	  2650: 	bsr			DisplayChar
02:0000614C 2208            	  2651: 	move.l	a0,d1
02:0000614E 6100019A        	  2652: 	bsr			DisplayTetra
02:00006152 7407            	  2653: 	moveq		#7,d2
                            	  2654: dspmem1:
02:00006154 123C0020        	  2655: 	move.b	#' ',d1
02:00006158 6100ED50        	  2656: 	bsr			DisplayChar
02:0000615C 1218            	  2657: 	move.b	(a0)+,d1
02:0000615E 61000196        	  2658: 	bsr			DisplayByte
02:00006162 51CAFFF0        	  2659: 	dbra		d2,dspmem1
02:00006166 61000168        	  2660: 	bsr			DisplayTwoSpaces
02:0000616A 123C0022        	  2661: 	move.b	#34,d1
02:0000616E 6100ED3A        	  2662: 	bsr			DisplayChar
02:00006172 5188            	  2663: 	lea			-8(a0),a0
02:00006174 7407            	  2664: 	moveq		#7,d2
                            	  2665: .0002:	
02:00006176 1218            	  2666: 	move.b	(a0)+,d1
02:00006178 B23C0020        	  2667: 	cmp.b		#' ',d1
02:0000617C 6506            	  2668: 	blo.s		.0003
02:0000617E B23C007F        	  2669: 	cmp.b		#127,d1
02:00006182 6304            	  2670: 	bls.s		.0001
                            	  2671: .0003:
02:00006184 123C002E        	  2672: 	move.b	#'.',d1
                            	  2673: .0001:
02:00006188 6100ED20        	  2674: 	bsr			DisplayChar
02:0000618C 51CAFFE8        	  2675: 	dbra		d2,.0002
02:00006190 123C0022        	  2676: 	move.b	#34,d1
02:00006194 6100ED14        	  2677: 	bsr			DisplayChar
02:00006198 6100F380        	  2678: 	bsr			CheckForCtrlC
02:0000619C 6000ECC2        	  2679: 	bra			CRLF
                            	  2680: 
                            	  2681: ;------------------------------------------------------------------------------
                            	  2682: ; Dump Registers
                            	  2683: ;    The dump is in a format that allows the register value to be edited.
                            	  2684: ;
                            	  2685: ; RegD0 12345678
                            	  2686: ; RegD1 77777777
                            	  2687: ;	... etc
                            	  2688: ;------------------------------------------------------------------------------
                            	  2689: 
                            	  2690: cmdDumpRegs:
02:000061A0 6100ECBE        	  2691: 	bsr			CRLF
02:000061A4 303C000F        	  2692: 	move.w	#15,d0					; number of registers-1
02:000061A8 41FA007A        	  2693: 	lea			msg_reglist,a0	;
02:000061AC 43FA0072        	  2694: 	lea			msg_regs,a1
02:000061B0 45F900040100    	  2695: 	lea			Regsave,a2			; a2 points to register save area
                            	  2696: .0001:
02:000061B6 6100EF6C        	  2697: 	bsr			DisplayString
02:000061BA 1218            	  2698: 	move.b	(a0)+,d1
02:000061BC 6100ECEC        	  2699: 	bsr			DisplayChar
02:000061C0 1218            	  2700: 	move.b	(a0)+,d1
02:000061C2 6100ECE6        	  2701: 	bsr			DisplayChar
02:000061C6 6100011A        	  2702: 	bsr			DisplaySpace
02:000061CA 221A            	  2703: 	move.l	(a2)+,d1
02:000061CC 6100011C        	  2704: 	bsr			DisplayTetra
02:000061D0 6100EC8E        	  2705: 	bsr			CRLF
02:000061D4 51C8FFE0        	  2706: 	dbra		d0,.0001
02:000061D8 6100EF4A        	  2707: 	bsr			DisplayString
02:000061DC 1218            	  2708: 	move.b	(a0)+,d1
02:000061DE 6100ECCA        	  2709: 	bsr			DisplayChar
02:000061E2 1218            	  2710: 	move.b	(a0)+,d1
02:000061E4 6100ECC4        	  2711: 	bsr			DisplayChar
02:000061E8 610000F8        	  2712: 	bsr			DisplaySpace
02:000061EC 223900040144    	  2713: 	move.l	Regsave+$44,d1
02:000061F2 610000F6        	  2714: 	bsr			DisplayTetra
02:000061F6 6100EC68        	  2715: 	bsr			CRLF
02:000061FA 6100EF28        	  2716: 	bsr			DisplayString
02:000061FE 1218            	  2717: 	move.b	(a0)+,d1
02:00006200 6100ECA8        	  2718: 	bsr			DisplayChar
02:00006204 1218            	  2719: 	move.b	(a0)+,d1
02:00006206 6100ECA2        	  2720: 	bsr			DisplayChar
02:0000620A 610000D6        	  2721: 	bsr			DisplaySpace
02:0000620E 323900040140    	  2722: 	move.w	Regsave+$40,d1
02:00006214 610000DA        	  2723: 	bsr			DisplayWyde
02:00006218 6100EC46        	  2724: 	bsr			CRLF
02:0000621C 6000F9C2        	  2725: 	bra			Monitor
                            	  2726: 
                            	  2727: msg_regs:
02:00006220 526567          	  2728: 	dc.b	"Reg",0
02:00006223 00
                            	  2729: msg_reglist:
02:00006224 4430443144324433	  2730: 	dc.b	"D0D1D2D3D4D5D6D7A0A1A2A3A4A5A6A7PCSR",0
02:0000622C 4434443544364437
02:00006234 4130413141324133
02:0000623C 4134413541364137
02:00006244 50435352
02:00006248 00
                            	  2731: 
                            	  2732: 	align	1
                            	  2733: 
                            	  2734: ;------------------------------------------------------------------------------
                            	  2735: ;------------------------------------------------------------------------------
                            	  2736: 
                            	  2737: cmdTestSerialReceive:
                            	  2738: .0002:
02:0000624A 7024            	  2739: 	moveq		#36,d0				; serial get char from buffer
02:0000624C 4E4F            	  2740: 	trap		#15
                            	  2741: ;	bsr			SerialPeekCharDirect
02:0000624E 4A41            	  2742: 	tst.w		d1
02:00006250 6B0A            	  2743: 	bmi.s		.0001
02:00006252 0C01001A        	  2744: 	cmpi.b	#CTRLZ,d1
02:00006256 670A            	  2745: 	beq			.0003
02:00006258 6100EC50        	  2746: 	bsr			DisplayChar
                            	  2747: .0001:	
02:0000625C 6100F2BC        	  2748: 	bsr			CheckForCtrlC
02:00006260 60E8            	  2749: 	bra			.0002
                            	  2750: .0003:
02:00006262 6100F10A        	  2751: 	bsr			_KeybdInit
02:00006266 6000F978        	  2752: 	bra			Monitor
                            	  2753: 
                            	  2754: ;------------------------------------------------------------------------------
                            	  2755: ; Get a hexidecimal number. Maximum of eight digits.
                            	  2756: ;
                            	  2757: ; Returns:
                            	  2758: ;		d0 = number of digits
                            	  2759: ;		d1 = value of number
                            	  2760: ;		zf = number of digits == 0
                            	  2761: ;------------------------------------------------------------------------------
                            	  2762: 
                            	  2763: GetHexNumber:
02:0000626A 2F02            	  2764: 	move.l	d2,-(a7)
02:0000626C 7400            	  2765: 	clr.l		d2
02:0000626E 7000            	  2766: 	moveq		#0,d0
                            	  2767: .0002:
02:00006270 6100F95A        	  2768: 	bsr			FromScreen
02:00006274 6120            	  2769: 	bsr			AsciiToHexNybble
02:00006276 B23C00FF        	  2770: 	cmp.b		#$ff,d1
02:0000627A 6712            	  2771: 	beq.s		.0001
02:0000627C E98A            	  2772: 	lsl.l		#4,d2
02:0000627E 02810000000F    	  2773: 	andi.l	#$0f,d1
02:00006284 8481            	  2774: 	or.l		d1,d2
02:00006286 5240            	  2775: 	addq		#1,d0
02:00006288 0C000008        	  2776: 	cmpi.b	#8,d0
02:0000628C 65E2            	  2777: 	blo.s		.0002
                            	  2778: .0001:
02:0000628E 2202            	  2779: 	move.l	d2,d1
02:00006290 241F            	  2780: 	move.l	(a7)+,d2
02:00006292 4A00            	  2781: 	tst.b		d0
02:00006294 4E75            	  2782: 	rts	
                            	  2783: 
                            	  2784: ;------------------------------------------------------------------------------
                            	  2785: ; Convert ASCII character in the range '0' to '9', 'a' tr 'f' or 'A' to 'F'
                            	  2786: ; to a hex nybble.
                            	  2787: ;------------------------------------------------------------------------------
                            	  2788: 
                            	  2789: AsciiToHexNybble:
02:00006296 0C010030        	  2790: 	cmpi.b	#'0',d1
02:0000629A 6530            	  2791: 	blo.s		gthx3
02:0000629C 0C010039        	  2792: 	cmpi.b	#'9',d1
02:000062A0 6206            	  2793: 	bhi.s		gthx5
02:000062A2 04010030        	  2794: 	subi.b	#'0',d1
02:000062A6 4E75            	  2795: 	rts
                            	  2796: gthx5:
02:000062A8 0C010041        	  2797: 	cmpi.b	#'A',d1
02:000062AC 651E            	  2798: 	blo.s		gthx3
02:000062AE 0C010046        	  2799: 	cmpi.b	#'F',d1
02:000062B2 6206            	  2800: 	bhi.s		gthx6
02:000062B4 060100C9        	  2801: 	addi.b	#10-'A',d1
02:000062B8 4E75            	  2802: 	rts
                            	  2803: gthx6:
02:000062BA 0C010061        	  2804: 	cmpi.b	#'a',d1
02:000062BE 650C            	  2805: 	blo.s		gthx3
02:000062C0 0C010066        	  2806: 	cmpi.b	#'f',d1
02:000062C4 6206            	  2807: 	bhi.s		gthx3
02:000062C6 060100A9        	  2808: 	addi.b	#10-'a',d1
02:000062CA 4E75            	  2809: 	rts
                            	  2810: gthx3:
02:000062CC 72FF            	  2811: 	moveq	#-1,d1		; not a hex number
02:000062CE 4E75            	  2812: 	rts
                            	  2813: 
                            	  2814: ;------------------------------------------------------------------------------
                            	  2815: ;------------------------------------------------------------------------------
                            	  2816: 
                            	  2817: DisplayTwoSpaces:
02:000062D0 2F01            	  2818: 	move.l	d1,-(a7)
02:000062D2 123C0020        	  2819: 	move.b	#' ',d1
02:000062D6 6100EBD2        	  2820: 	bsr			DisplayChar
                            	  2821: dspspc1:
02:000062DA 6100EBCE        	  2822: 	bsr			DisplayChar
02:000062DE 221F            	  2823: 	move.l	(a7)+,d1
02:000062E0 4E75            	  2824: 	rts
                            	  2825: 
                            	  2826: DisplaySpace:
02:000062E2 2F01            	  2827: 	move.l	d1,-(a7)
02:000062E4 123C0020        	  2828: 	move.b	#' ',d1
02:000062E8 60F0            	  2829: 	bra			dspspc1
                            	  2830: 
                            	  2831: ;------------------------------------------------------------------------------
                            	  2832: ; Display the 32 bit word in D1.L
                            	  2833: ;------------------------------------------------------------------------------
                            	  2834: 
                            	  2835: DisplayTetra:
02:000062EA 4841            	  2836: 	swap	d1
02:000062EC 6102            	  2837: 	bsr		DisplayWyde
02:000062EE 4841            	  2838: 	swap	d1
                            	  2839: 
                            	  2840: ;------------------------------------------------------------------------------
                            	  2841: ; Display the byte in D1.W
                            	  2842: ;------------------------------------------------------------------------------
                            	  2843: 
                            	  2844: DisplayWyde:
02:000062F0 E059            	  2845: 	ror.w		#8,d1
02:000062F2 6102            	  2846: 	bsr			DisplayByte
02:000062F4 E159            	  2847: 	rol.w		#8,d1
                            	  2848: 
                            	  2849: ;------------------------------------------------------------------------------
                            	  2850: ; Display the byte in D1.B
                            	  2851: ;------------------------------------------------------------------------------
                            	  2852: 
                            	  2853: DisplayByte:
02:000062F6 E819            	  2854: 	ror.b		#4,d1
02:000062F8 6102            	  2855: 	bsr			DisplayNybble
02:000062FA E919            	  2856: 	rol.b		#4,d1
                            	  2857: 
                            	  2858: ;------------------------------------------------------------------------------
                            	  2859: ; Display nybble in D1.B
                            	  2860: ;------------------------------------------------------------------------------
                            	  2861: 
                            	  2862: DisplayNybble:
02:000062FC 2F01            	  2863: 	move.l	d1,-(a7)
02:000062FE 0201000F        	  2864: 	andi.b	#$F,d1
02:00006302 06010030        	  2865: 	addi.b	#'0',d1
02:00006306 0C010039        	  2866: 	cmpi.b	#'9',d1
02:0000630A 6302            	  2867: 	bls.s		.0001
02:0000630C 5E01            	  2868: 	addi.b	#7,d1
                            	  2869: .0001:
02:0000630E 6100EB9A        	  2870: 	bsr			DisplayChar
02:00006312 221F            	  2871: 	move.l	(a7)+,d1
02:00006314 4E75            	  2872: 	rts
                            	  2873: 
                            	  2874: ;------------------------------------------------------------------------------
                            	  2875: ;------------------------------------------------------------------------------
                            	  2876: ;
                            	  2877: ;DisplayHexNumber:
                            	  2878: ;	move.w	#$A6A6,leds		; diagnostics
                            	  2879: ;	move.l	#VDGREG,a6
                            	  2880: ;	move.w	#7,d2		; number-1 of digits to display
                            	  2881: ;disphnum1:
                            	  2882: ;	move.b	d1,d0		; get digit into d0.b
                            	  2883: ;	andi.w	#$0f,d0
                            	  2884: ;	cmpi.w	#$09,d0
                            	  2885: ;	bls.s	disphnum2
                            	  2886: ;	addi.w	#7,d0
                            	  2887: ;disphnum2:
                            	  2888: ;	addi.w	#$30,d0	; convert to display char
                            	  2889: ;	move.w	d2,d3		; char count into d3
                            	  2890: ;	asl.w	#3,d3		; scale * 8
                            	  2891: ;disphnum3:
                            	  2892: ;	move.w	$42C(a6),d4			; read character queue index into d4
                            	  2893: ;	cmp.w	#28,d4					; allow up 28 entries to be in progress
                            	  2894: ;	bhs.s	disphnum3				; branch if too many chars queued
                            	  2895: ;	ext.w	d0						; zero out high order bits
                            	  2896: ;	move.w	d0,$420(a6)			; set char code
                            	  2897: ;	move.w	#WHITE,$422(a6)		; set fg color
                            	  2898: ;	move.w	#DARK_BLUE,$424(a6)	; set bk color
                            	  2899: ;	move.w	d3,$426(a6)			; set x pos
                            	  2900: ;	move.w	#8,$428(a6)			; set y pos
                            	  2901: ;	move.w	#$0707,$42A(a6)		; set font x,y extent
                            	  2902: ;	move.w	#0,$42E(a6)			; pulse character queue write signal
                            	  2903: ;	ror.l	#4,d1					; rot to next digit
                            	  2904: ;	dbeq	d2,disphnum1
                            	  2905: ;	jmp		(a5)
                            	  2906: 
                            	  2907: ;===============================================================================
                            	  2908: ;    Perform ram test. (Uses checkerboard testing).
                            	  2909: ; 
                            	  2910: ;    Local ram, which does not get tested, is used for the stack.
                            	  2911: ;===============================================================================
                            	  2912: 
                            	  2913: DisplayAddr:
02:00006316 2208            	  2914: 	move.l a0,d1
02:00006318 E089            	  2915: 	lsr.l #8,d1
02:0000631A E089            	  2916: 	lsr.l #8,d1
02:0000631C E889            	  2917: 	lsr.l #4,d1
02:0000631E 04410200        	  2918: 	subi.w #512,d1
02:00006322 A2C10000        	  2919: 	bin2bcd d1
02:00006326 61C8            	  2920: 	bsr	DisplayWyde
02:00006328 123C000D        	  2921: 	move.b #CR,d1
02:0000632C 6000EB7C        	  2922: 	bra DisplayChar
02:00006330 08000083        	  2923: 	btst #$83,d0
                            	  2924: 	
                            	  2925: cmdTestRAM:
                            	  2926: ramtest:
02:00006334 33FCA5A5FD0FFF00	  2927: 	move.w	#$A5A5,leds		; diagnostics
02:0000633C 263CAAAAAAAA    	  2928:   move.l #$aaaaaaaa,d3
02:00006342 283C55555555    	  2929:   move.l #$55555555,d4
02:00006348 612C            	  2930:   bsr ramtest0
                            	  2931:   ; switch checkerboard pattern and repeat test.
02:0000634A C744            	  2932:   exg d3,d4
02:0000634C 6128            	  2933:   bsr ramtest0
                            	  2934: 	; Save last ram address in end of memory pointer.
                            	  2935: rmtst5:
02:0000634E 7025            	  2936: 	moveq #37,d0					; lock semaphore
02:00006350 7206            	  2937: 	moveq #MEMORY_SEMA,d1
02:00006352 4E4F            	  2938: 	trap #15
02:00006354 23C800100004    	  2939:   move.l a0,memend
                            	  2940: 	; Create very first memory block.
02:0000635A 41E8FFF4        	  2941:   suba.l #12,a0
02:0000635E 23C820000004    	  2942:   move.l a0,$20000004		; length of block
02:00006364 23FC465245452000	  2943:   move.l #$46524545,$20000000
02:0000636C 0000
02:0000636E 7026            	  2944: 	moveq #38,d0					; unlock semaphore
02:00006370 7206            	  2945: 	moveq #MEMORY_SEMA,d1
02:00006372 4E4F            	  2946: 	trap #15
02:00006374 4E75            	  2947:   rts
                            	  2948: 
                            	  2949: ramtest0:
02:00006376 2003            	  2950: 	move.l d3,d0
02:00006378 207C20000000    	  2951:   movea.l #$20000000,a0
                            	  2952: ;-----------------------------------------------------------
                            	  2953: ;   Write checkerboard pattern to ram then read it back to
                            	  2954: ; find the highest usable ram address (maybe). This address
                            	  2955: ; must be lower than the start of the rom (0xe00000).
                            	  2956: ;-----------------------------------------------------------
                            	  2957: ramtest1:
02:0000637E 20C3            	  2958:   move.l d3,(a0)+
02:00006380 20C4            	  2959:   move.l d4,(a0)+
02:00006382 2208            	  2960:   move.l a0,d1
02:00006384 4A41            	  2961:   tst.w	d1
02:00006386 6606            	  2962:   bne.s rmtst1
02:00006388 618C            	  2963:   bsr DisplayAddr
02:0000638A 6100F18E        	  2964:   bsr CheckForCtrlC
                            	  2965: rmtst1:
02:0000638E B1FC3FFFFFF8    	  2966:   cmpa.l #$3FFFFFF8,a0
02:00006394 65E8            	  2967:   blo.s ramtest1
02:00006396 6100EAC8        	  2968:   bsr	CRLF
                            	  2969: ;------------------------------------------------------
                            	  2970: ;   Save maximum useable address for later comparison.
                            	  2971: ;------------------------------------------------------
                            	  2972: ramtest6:
02:0000639A 33FCA7A7FD0FFF00	  2973: 	move.w	#$A7A7,leds		; diagnostics
02:000063A2 2448            	  2974:   movea.l a0,a2
02:000063A4 207C20000000    	  2975:   movea.l #$20000000,a0
                            	  2976: ;--------------------------------------------
                            	  2977: ;   Read back checkerboard pattern from ram.
                            	  2978: ;--------------------------------------------
                            	  2979: ramtest2
02:000063AA 2A18            	  2980:   move.l (a0)+,d5
02:000063AC 2C18            	  2981:   move.l (a0)+,d6
02:000063AE B1CA            	  2982:   cmpa.l a2,a0
02:000063B0 643A            	  2983:   bhs.s	ramtest3
02:000063B2 2208            	  2984:   move.l a0,d1
02:000063B4 4A41            	  2985:   tst.w	d1
02:000063B6 6608            	  2986:   bne.s	rmtst2
02:000063B8 6100FF5C        	  2987:   bsr	DisplayAddr
02:000063BC 6100F15C        	  2988: 	bsr CheckForCtrlC
                            	  2989: rmtst2
02:000063C0 BA83            	  2990:   cmp.l d3,d5
02:000063C2 6604            	  2991:   bne.s rmtst3
02:000063C4 BC84            	  2992:   cmp.l d4,d6
02:000063C6 67E2            	  2993:   beq.s ramtest2
                            	  2994: ;----------------------------------
                            	  2995: ; Report error in ram.
                            	  2996: ;----------------------------------
                            	  2997: rmtst3
02:000063C8 6100EA96        	  2998: 	bsr CRLF
02:000063CC 7245            	  2999: 	moveq	#'E',d1
02:000063CE 6100EADA        	  3000: 	bsr DisplayChar
02:000063D2 6100FF0E        	  3001: 	bsr DisplaySpace
02:000063D6 2208            	  3002: 	move.l a0,d1
02:000063D8 6100FF10        	  3003: 	bsr DisplayTetra
02:000063DC 6100FF04        	  3004: 	bsr DisplaySpace
02:000063E0 2205            	  3005: 	move.l d5,d1
02:000063E2 6100FF06        	  3006: 	bsr DisplayTetra
02:000063E6 6100F132        	  3007: 	bsr CheckForCtrlC
02:000063EA 60BE            	  3008: 	bra ramtest2
                            	  3009: ramtest3
02:000063EC 4E75            	  3010: 	rts
                            	  3011: 
                            	  3012: ;==============================================================================
                            	  3013: ; Load an S19 format file
                            	  3014: ;==============================================================================
                            	  3015: 
                            	  3016: cmdLoadS19:
02:000063EE 6100EA70        	  3017: 	bsr			CRLF
02:000063F2 6012            	  3018: 	bra			ProcessRec
                            	  3019: NextRec:
02:000063F4 610001DC        	  3020: 	bsr			sGetChar
02:000063F8 0C01000A        	  3021: 	cmpi.b	#LF,d1
02:000063FC 66F6            	  3022: 	bne			NextRec
02:000063FE 123C002E        	  3023: 	move.b	#'.',d1
02:00006402 6100EAA6        	  3024: 	bsr			DisplayChar
                            	  3025: ProcessRec:
02:00006406 6100F112        	  3026: 	bsr			CheckForCtrlC	; check for CTRL-C once per record
02:0000640A 610001C6        	  3027: 	bsr			sGetChar
02:0000640E 0C01000D        	  3028: 	cmpi.b	#CR,d1
02:00006412 67F2            	  3029: 	beq.s		ProcessRec
02:00006414 423900100150    	  3030: 	clr.b		S19Checksum
02:0000641A 1801            	  3031: 	move.b	d1,d4
02:0000641C 0C04001A        	  3032: 	cmpi.b	#CTRLZ,d4			; CTRL-Z ?
02:00006420 6700F7BE        	  3033: 	beq			Monitor
02:00006424 0C040053        	  3034: 	cmpi.b	#'S',d4				; All records must begin with an 'S'
02:00006428 66CA            	  3035: 	bne.s		NextRec
02:0000642A 610001A6        	  3036: 	bsr			sGetChar
02:0000642E 1801            	  3037: 	move.b	d1,d4
02:00006430 0C040030        	  3038: 	cmpi.b	#'0',d4				; Record type must be between '0' and '9'
02:00006434 65BE            	  3039: 	blo.s		NextRec
02:00006436 0C040039        	  3040: 	cmpi.b	#'9',d4				; d4 = record type
02:0000643A 62B8            	  3041: 	bhi.s		NextRec
02:0000643C 61000194        	  3042: 	bsr			sGetChar			; get byte count for record
02:00006440 6100FE54        	  3043: 	bsr			AsciiToHexNybble
02:00006444 1401            	  3044: 	move.b	d1,d2
02:00006446 6100018A        	  3045: 	bsr			sGetChar
02:0000644A 6100FE4A        	  3046: 	bsr			AsciiToHexNybble
02:0000644E E90A            	  3047: 	lsl.b		#4,d2
02:00006450 8202            	  3048: 	or.b		d2,d1					; d1 = byte count
02:00006452 1601            	  3049: 	move.b	d1,d3					; d3 = byte count
02:00006454 D73900100150    	  3050: 	add.b		d3,S19Checksum
02:0000645A 0C040030        	  3051: 	cmpi.b	#'0',d4				; manufacturer ID record, ignore
02:0000645E 6794            	  3052: 	beq			NextRec
02:00006460 0C040031        	  3053: 	cmpi.b	#'1',d4
02:00006464 670000A2        	  3054: 	beq			ProcessS1
02:00006468 0C040032        	  3055: 	cmpi.b	#'2',d4
02:0000646C 6700009E        	  3056: 	beq			ProcessS2
02:00006470 0C040033        	  3057: 	cmpi.b	#'3',d4
02:00006474 6700009A        	  3058: 	beq			ProcessS3
02:00006478 0C040035        	  3059: 	cmpi.b	#'5',d4				; record count record, ignore
02:0000647C 6700FF76        	  3060: 	beq			NextRec
02:00006480 0C040037        	  3061: 	cmpi.b	#'7',d4
02:00006484 6700008E        	  3062: 	beq			ProcessS7
02:00006488 0C040038        	  3063: 	cmpi.b	#'8',d4
02:0000648C 67000096        	  3064: 	beq			ProcessS8
02:00006490 0C040039        	  3065: 	cmpi.b	#'9',d4
02:00006494 6700009E        	  3066: 	beq			ProcessS9
02:00006498 6000FF5A        	  3067: 	bra			NextRec
                            	  3068: 
                            	  3069: pcssxa:
02:0000649C 2209            	  3070: 	move.l	a1,d1
02:0000649E 6100FE4A        	  3071: 	bsr			DisplayTetra
02:000064A2 123C000D        	  3072: 	move.b	#CR,d1
02:000064A6 6100EA02        	  3073: 	bsr			DisplayChar
02:000064AA 024300FF        	  3074: 	andi.w	#$ff,d3
02:000064AE 5343            	  3075: 	subi.w	#1,d3			; one less for dbra
                            	  3076: .0001:
02:000064B0 7400            	  3077: 	clr.l		d2
02:000064B2 6100011E        	  3078: 	bsr			sGetChar
02:000064B6 6100FDDE        	  3079: 	bsr			AsciiToHexNybble
02:000064BA E98A            	  3080: 	lsl.l		#4,d2
02:000064BC 8401            	  3081: 	or.b		d1,d2
02:000064BE 61000112        	  3082: 	bsr			sGetChar
02:000064C2 6100FDD2        	  3083: 	bsr			AsciiToHexNybble
02:000064C6 E98A            	  3084: 	lsl.l		#4,d2
02:000064C8 8401            	  3085: 	or.b		d1,d2
02:000064CA D53900100150    	  3086: 	add.b		d2,S19Checksum
02:000064D0 12C2            	  3087: 	move.b	d2,(a1)+			; move byte to memory
02:000064D2 51CBFFDC        	  3088: 	dbra		d3,.0001
                            	  3089: 	; Get the checksum byte
02:000064D6 7400            	  3090: 	clr.l		d2
02:000064D8 610000F8        	  3091: 	bsr			sGetChar
02:000064DC 6100FDB8        	  3092: 	bsr			AsciiToHexNybble
02:000064E0 E98A            	  3093: 	lsl.l		#4,d2
02:000064E2 8401            	  3094: 	or.b		d1,d2
02:000064E4 610000EC        	  3095: 	bsr			sGetChar
02:000064E8 6100FDAC        	  3096: 	bsr			AsciiToHexNybble
02:000064EC E98A            	  3097: 	lsl.l		#4,d2
02:000064EE 8401            	  3098: 	or.b		d1,d2
02:000064F0 4602            	  3099: 	eor.b		#$FF,d2
02:000064F2 B43900100150    	  3100: 	cmp.b		S19Checksum,d2
02:000064F8 6700FEFA        	  3101: 	beq			NextRec
02:000064FC 123C0045        	  3102: 	move.b	#'E',d1
02:00006500 6100E9A8        	  3103: 	bsr			DisplayChar
02:00006504 6000FEEE        	  3104: 	bra			NextRec
                            	  3105: 
                            	  3106: ProcessS1:
02:00006508 613A            	  3107: 	bsr			S19Get16BitAddress
02:0000650A 6090            	  3108: 	bra			pcssxa
                            	  3109: ProcessS2:
02:0000650C 6144            	  3110: 	bsr			S19Get24BitAddress
02:0000650E 608C            	  3111: 	bra			pcssxa
                            	  3112: ProcessS3:
02:00006510 614C            	  3113: 	bsr			S19Get32BitAddress
02:00006512 6088            	  3114: 	bra			pcssxa
                            	  3115: ProcessS7:
02:00006514 6148            	  3116: 	bsr			S19Get32BitAddress
02:00006516 23C900040008    	  3117: 	move.l	a1,S19StartAddress
02:0000651C 6100EE50        	  3118: 	bsr			_KeybdInit
02:00006520 6000F6BE        	  3119: 	bra			Monitor
                            	  3120: ProcessS8:
02:00006524 612C            	  3121: 	bsr			S19Get24BitAddress
02:00006526 23C900040008    	  3122: 	move.l	a1,S19StartAddress
02:0000652C 6100EE40        	  3123: 	bsr			_KeybdInit
02:00006530 6000F6AE        	  3124: 	bra			Monitor
                            	  3125: ProcessS9:
02:00006534 610E            	  3126: 	bsr			S19Get16BitAddress
02:00006536 23C900040008    	  3127: 	move.l	a1,S19StartAddress
02:0000653C 6100EE30        	  3128: 	bsr			_KeybdInit
02:00006540 6000F69E        	  3129: 	bra			Monitor
                            	  3130: 
                            	  3131: S19Get16BitAddress:
02:00006544 7400            	  3132: 	clr.l		d2
02:00006546 6100008A        	  3133: 	bsr			sGetChar
02:0000654A 6100FD4A        	  3134: 	bsr			AsciiToHexNybble
02:0000654E 1401            	  3135: 	move.b	d1,d2
02:00006550 603E            	  3136: 	bra			S1932b
                            	  3137: 
                            	  3138: S19Get24BitAddress:
02:00006552 7400            	  3139: 	clr.l		d2
02:00006554 617C            	  3140: 	bsr			sGetChar
02:00006556 6100FD3E        	  3141: 	bsr			AsciiToHexNybble
02:0000655A 1401            	  3142: 	move.b	d1,d2
02:0000655C 601E            	  3143: 	bra			S1932a
                            	  3144: 
                            	  3145: S19Get32BitAddress:
02:0000655E 7400            	  3146: 	clr.l		d2
02:00006560 6170            	  3147: 	bsr			sGetChar
02:00006562 6100FD32        	  3148: 	bsr			AsciiToHexNybble
02:00006566 1401            	  3149: 	move.b	d1,d2
02:00006568 6168            	  3150: 	bsr			sGetChar
02:0000656A 6100FD2A        	  3151: 	bsr			AsciiToHexNybble
02:0000656E E98A            	  3152: 	lsl.l		#4,d2
02:00006570 8401            	  3153: 	or.b		d1,d2
02:00006572 615E            	  3154: 	bsr			sGetChar
02:00006574 6100FD20        	  3155: 	bsr			AsciiToHexNybble
02:00006578 E98A            	  3156: 	lsl.l		#4,d2
02:0000657A 8401            	  3157: 	or.b		d1,d2
                            	  3158: S1932a:
02:0000657C 6154            	  3159: 	bsr			sGetChar
02:0000657E 6100FD16        	  3160: 	bsr			AsciiToHexNybble
02:00006582 E98A            	  3161: 	lsl.l		#4,d2
02:00006584 8401            	  3162: 	or.b		d1,d2
02:00006586 614A            	  3163: 	bsr			sGetChar
02:00006588 6100FD0C        	  3164: 	bsr			AsciiToHexNybble
02:0000658C E98A            	  3165: 	lsl.l		#4,d2
02:0000658E 8401            	  3166: 	or.b		d1,d2
                            	  3167: S1932b:
02:00006590 6140            	  3168: 	bsr			sGetChar
02:00006592 6100FD02        	  3169: 	bsr			AsciiToHexNybble
02:00006596 E98A            	  3170: 	lsl.l		#4,d2
02:00006598 8401            	  3171: 	or.b		d1,d2
02:0000659A 6136            	  3172: 	bsr			sGetChar
02:0000659C 6100FCF8        	  3173: 	bsr			AsciiToHexNybble
02:000065A0 E98A            	  3174: 	lsl.l		#4,d2
02:000065A2 8401            	  3175: 	or.b		d1,d2
02:000065A4 612C            	  3176: 	bsr			sGetChar
02:000065A6 6100FCEE        	  3177: 	bsr			AsciiToHexNybble
02:000065AA E98A            	  3178: 	lsl.l		#4,d2
02:000065AC 8401            	  3179: 	or.b		d1,d2
02:000065AE 7800            	  3180: 	clr.l		d4
02:000065B0 2242            	  3181: 	move.l	d2,a1
                            	  3182: 	; Add bytes from address value to checksum
02:000065B2 D53900100150    	  3183: 	add.b		d2,S19Checksum
02:000065B8 E08A            	  3184: 	lsr.l		#8,d2
02:000065BA D53900100150    	  3185: 	add.b		d2,S19Checksum
02:000065C0 E08A            	  3186: 	lsr.l		#8,d2
02:000065C2 D53900100150    	  3187: 	add.b		d2,S19Checksum
02:000065C8 E08A            	  3188: 	lsr.l		#8,d2
02:000065CA D53900100150    	  3189: 	add.b		d2,S19Checksum
02:000065D0 4E75            	  3190: 	rts
                            	  3191: 
                            	  3192: ;------------------------------------------------------------------------------
                            	  3193: ; Get a character from auxillary input. Waiting for a character is limited to
                            	  3194: ; 32000 tries. If a character is not available within the limit, then a return
                            	  3195: ; to the monitor is done.
                            	  3196: ;
                            	  3197: ;	Parameters:
                            	  3198: ;		none
                            	  3199: ; Returns:
                            	  3200: ;		d1 = character from receive buffer or -1 if no char available
                            	  3201: ;------------------------------------------------------------------------------
                            	  3202: 
                            	  3203: sGetChar:
02:000065D2 48E7A000        	  3204: 	movem.l	d0/d2,-(a7)
02:000065D6 343C7D00        	  3205: 	move.w	#32000,d2
                            	  3206: .0001:
02:000065DA 7024            	  3207: 	moveq		#36,d0				; serial get char from buffer
02:000065DC 4E4F            	  3208: 	trap		#15
02:000065DE 4A41            	  3209: 	tst.w		d1						; was there a char available?
02:000065E0 6A10            	  3210: 	bpl.s		.0002
02:000065E2 51CAFFF6        	  3211: 	dbra		d2,.0001			; no - try again
02:000065E6 4CDF0005        	  3212: 	movem.l	(a7)+,d0/d2
                            	  3213: .0003:
02:000065EA 6100ED82        	  3214: 	bsr			_KeybdInit
02:000065EE 6000F5F0        	  3215: 	bra			Monitor				; ran out of tries
                            	  3216: .0002:
02:000065F2 4CDF0005        	  3217: 	movem.l	(a7)+,d0/d2
02:000065F6 0C01001A        	  3218: 	cmpi.b	#CTRLZ,d1			; receive end of file?
02:000065FA 67EE            	  3219: 	beq			.0003
02:000065FC 4E75            	  3220: 	rts
                            	  3221: 
                            	  3222: AudioInputTest:
02:000065FE 4E75            	  3223: 	rts
                            	  3224: BouncingBalls:
02:00006600 4E75            	  3225: 	rts
                            	  3226: GraphicsDemo:
02:00006602 4E75            	  3227: 	rts
                            	  3228: ClearScreen:
02:00006604 6000E80A        	  3229: 	bra		clear_screen
02:00006608 4E75            	  3230: 	rts
                            	  3231: 
                            	  3232: ;------------------------------------------------------------------------------
                            	  3233: ; Reverse the order of bytes in d1.
                            	  3234: ;------------------------------------------------------------------------------
                            	  3235: 
                            	  3236: rbo:
02:0000660A E159            	  3237: 	rol.w		#8,d1
02:0000660C 4841            	  3238: 	swap		d1
02:0000660E E159            	  3239: 	rol.w		#8,d1
02:00006610 4E75            	  3240: 	rts
                            	  3241: 
                            	  3242: ;==============================================================================
                            	  3243: ; Serial I/O routines
                            	  3244: ;==============================================================================
                            	  3245: 
                            	  3246: ;------------------------------------------------------------------------------
                            	  3247: ; Initialize the serial port an enhanced 6551 circuit.
                            	  3248: ;
                            	  3249: ; Select internal baud rate clock divider for 9600 baud
                            	  3250: ; Reset fifos, set threshold to 3/4 full on transmit and 3/4 empty on receive
                            	  3251: ; Note that the byte order is swapped.
                            	  3252: ;------------------------------------------------------------------------------
                            	  3253: 
                            	  3254: SerialInit:
02:00006612 427900100162    	  3255: 	clr.w		SerHeadRcv					; clear receive buffer indexes
02:00006618 427900100160    	  3256: 	clr.w		SerTailRcv
02:0000661E 423900100164    	  3257: 	clr.b		SerRcvXon						; and Xon,Xoff flags
02:00006624 423900100165    	  3258: 	clr.b		SerRcvXoff
02:0000662A 203C09000000    	  3259: 	move.l	#$09000000,d0				; dtr,rts active, rxint enabled, no parity
02:00006630 23C0FD060008    	  3260: 	move.l	d0,ACIA+ACIA_CMD
                            	  3261: ;	move.l	#$1E00F700,d0				; fifos enabled
02:00006636 203C1E000000    	  3262: 	move.l	#$1E000000,d0				; fifos disabled
02:0000663C 23C0FD06000C    	  3263: 	move.l	d0,ACIA+ACIA_CTRL
02:00006642 4E75            	  3264: 	rts
                            	  3265: ;	move.l	#$0F000000,d0				; transmit a break for a while
                            	  3266: ;	move.l	d0,ACIA+ACIA_CMD
                            	  3267: ;	move.l	#300000,d2					; wait 100 ms
                            	  3268: ;	bra			.0001
                            	  3269: ;.0003:
                            	  3270: ;	swap		d2
                            	  3271: ;.0001:
                            	  3272: ;	nop
                            	  3273: ;	dbra		d2,.0001
                            	  3274: ;.0002:
                            	  3275: ;	swap		d2
                            	  3276: ;	dbra		d2,.0003
                            	  3277: ;	move.l	#$07000000,d0				; clear break
                            	  3278: ;	move.l	d0,ACIA+ACIA_CMD
                            	  3279: ;	rts
                            	  3280: 	
                            	  3281: ;------------------------------------------------------------------------------
                            	  3282: ; SerialGetChar
                            	  3283: ;
                            	  3284: ; Check the serial port buffer to see if there's a char available. If there's
                            	  3285: ; a char available then return it. If the buffer is almost empty then send an
                            	  3286: ; XON.
                            	  3287: ;
                            	  3288: ; Stack Space:
                            	  3289: ;		2 long words
                            	  3290: ; Parameters:
                            	  3291: ;		none
                            	  3292: ; Modifies:
                            	  3293: ;		d0,a0
                            	  3294: ; Returns:
                            	  3295: ;		d1 = character or -1
                            	  3296: ;------------------------------------------------------------------------------
                            	  3297: 
                            	  3298: SerialGetChar:
02:00006644 2F02            	  3299: 	move.l		d2,-(a7)
02:00006646 4E7A0FE0        	  3300: 	movec			coreno,d0
02:0000664A 4840            	  3301: 	swap			d0
02:0000664C 7202            	  3302: 	moveq			#SERIAL_SEMA,d1
02:0000664E 61009BBE        	  3303: 	bsr				LockSemaphore
02:00006652 610000DE        	  3304: 	bsr				SerialRcvCount			; check number of chars in receive buffer
02:00006656 0C400008        	  3305: 	cmpi.w		#8,d0								; less than 8?
02:0000665A 621C            	  3306: 	bhi				.sgc2
02:0000665C 4A3900100164    	  3307: 	tst.b			SerRcvXon						; skip sending XON if already sent
02:00006662 6614            	  3308: 	bne	  		.sgc2            		; XON already sent?
02:00006664 123C0011        	  3309: 	move.b		#XON,d1							; if <8 send an XON
02:00006668 423900100165    	  3310: 	clr.b			SerRcvXoff					; clear XOFF status
02:0000666E 13C100100164    	  3311: 	move.b		d1,SerRcvXon				; flag so we don't send it multiple times
02:00006674 61000098        	  3312: 	bsr				SerialPutChar				; send it
                            	  3313: .sgc2:
02:00006678 323900100162    	  3314: 	move.w		SerHeadRcv,d1				; check if anything is in buffer
02:0000667E B27900100160    	  3315: 	cmp.w			SerTailRcv,d1
02:00006684 6720            	  3316: 	beq				.NoChars						; no?
02:00006686 41F900101000    	  3317: 	lea				SerRcvBuf,a0
02:0000668C 12301000        	  3318: 	move.b		(a0,d1.w),d1				; get byte from buffer
02:00006690 527900100162    	  3319: 	addi.w		#1,SerHeadRcv
02:00006696 02790FFF00100162	  3320: 	andi.w		#$FFF,SerHeadRcv		; 4k wrap around
02:0000669E 0281000000FF    	  3321: 	andi.l		#$FF,d1
02:000066A4 6002            	  3322: 	bra				.Xit
                            	  3323: .NoChars:
02:000066A6 72FF            	  3324: 	moveq			#-1,d1
                            	  3325: .Xit:
02:000066A8 C342            	  3326: 	exg				d1,d2
02:000066AA 4E7A0FE0        	  3327: 	movec			coreno,d0
02:000066AE 4840            	  3328: 	swap			d0
02:000066B0 7202            	  3329: 	moveq			#SERIAL_SEMA,d1
02:000066B2 61009B96        	  3330: 	bsr				UnlockSemaphore
02:000066B6 C541            	  3331: 	exg				d2,d1
02:000066B8 241F            	  3332: 	move.l		(a7)+,d2
02:000066BA 4E75            	  3333: 	rts
                            	  3334: 
                            	  3335: ;------------------------------------------------------------------------------
                            	  3336: ; SerialPeekChar
                            	  3337: ;
                            	  3338: ; Check the serial port buffer to see if there's a char available. If there's
                            	  3339: ; a char available then return it. But don't update the buffer indexes. No need
                            	  3340: ; to send an XON here.
                            	  3341: ;
                            	  3342: ; Stack Space:
                            	  3343: ;		0 words
                            	  3344: ; Parameters:
                            	  3345: ;		none
                            	  3346: ; Modifies:
                            	  3347: ;		d0,d2,a0
                            	  3348: ; Returns:
                            	  3349: ;		d1 = character or -1
                            	  3350: ;------------------------------------------------------------------------------
                            	  3351: 
                            	  3352: SerialPeekChar:
02:000066BC 4E7A0FE0        	  3353: 	movec		coreno,d0
02:000066C0 4840            	  3354: 	swap		d0
02:000066C2 7202            	  3355: 	moveq		#SERIAL_SEMA,d1
02:000066C4 61009B48        	  3356: 	bsr			LockSemaphore
02:000066C8 343900100162    	  3357: 	move.w	SerHeadRcv,d2		; check if anything is in buffer
02:000066CE B47900100160    	  3358: 	cmp.w		SerTailRcv,d2
02:000066D4 670C            	  3359: 	beq			.NoChars				; no?
02:000066D6 41F900101000    	  3360: 	lea			SerRcvBuf,a0
02:000066DC 14302000        	  3361: 	move.b	(a0,d2.w),d2		; get byte from buffer
02:000066E0 6002            	  3362: 	bra			.Xit
                            	  3363: .NoChars:
02:000066E2 74FF            	  3364: 	moveq		#-1,d2
                            	  3365: .Xit:
02:000066E4 4E7A0FE0        	  3366: 	movec		coreno,d0
02:000066E8 4840            	  3367: 	swap		d0
02:000066EA 7202            	  3368: 	moveq		#SERIAL_SEMA,d1
02:000066EC 61009B20        	  3369: 	bsr			LockSemaphore
02:000066F0 3202            	  3370: 	move		d2,d1
02:000066F2 4E75            	  3371: 	rts
                            	  3372: 
                            	  3373: ;------------------------------------------------------------------------------
                            	  3374: ; SerialPeekChar
                            	  3375: ;		Get a character directly from the I/O port. This bypasses the input
                            	  3376: ; buffer.
                            	  3377: ;
                            	  3378: ; Stack Space:
                            	  3379: ;		0 words
                            	  3380: ; Parameters:
                            	  3381: ;		none
                            	  3382: ; Modifies:
                            	  3383: ;		d
                            	  3384: ; Returns:
                            	  3385: ;		d1 = character or -1
                            	  3386: ;------------------------------------------------------------------------------
                            	  3387: 
                            	  3388: SerialPeekCharDirect:
02:000066F4 1239FD060004    	  3389: 	move.b	ACIA+ACIA_STAT,d1	; get serial status
02:000066FA 08010003        	  3390: 	btst		#3,d1							; look for Rx not empty
02:000066FE 670A            	  3391: 	beq.s		.0001
02:00006700 7200            	  3392: 	moveq.l	#0,d1							; clear upper bits of return value
02:00006702 1239FD060000    	  3393: 	move.b	ACIA+ACIA_RX,d1		; get data from ACIA
02:00006708 4E75            	  3394: 	rts												; return
                            	  3395: .0001:
02:0000670A 72FF            	  3396: 	moveq		#-1,d1
02:0000670C 4E75            	  3397: 	rts
                            	  3398: 
                            	  3399: ;------------------------------------------------------------------------------
                            	  3400: ; SerialPutChar
                            	  3401: ;    Put a character to the serial transmitter. This routine blocks until the
                            	  3402: ; transmitter is empty. 
                            	  3403: ;
                            	  3404: ; Stack Space
                            	  3405: ;		0 words
                            	  3406: ; Parameters:
                            	  3407: ;		d1.b = character to put
                            	  3408: ; Modifies:
                            	  3409: ;		none
                            	  3410: ;------------------------------------------------------------------------------
                            	  3411: 
                            	  3412: SerialPutChar:
02:0000670E 48E7C000        	  3413: 	movem.l	d0/d1,-(a7)				; push d0,d1
                            	  3414: .0001:
02:00006712 1039FD060004    	  3415: 	move.b	ACIA+ACIA_STAT,d0	; wait until the uart indicates tx empty
02:00006718 08000004        	  3416: 	btst		#4,d0							; bit #4 of the status reg
02:0000671C 67F4            	  3417: 	beq.s		.0001			    		; branch if transmitter is not empty
02:0000671E 13C1FD060000    	  3418: 	move.b	d1,ACIA+ACIA_TX		; send the byte
02:00006724 4CDF0003        	  3419: 	movem.l	(a7)+,d0/d1				; pop d0,d1
02:00006728 4E75            	  3420: 	rts
                            	  3421: 	
                            	  3422: ;------------------------------------------------------------------------------
                            	  3423: ; Reverse the order of bytes in d1.
                            	  3424: ;------------------------------------------------------------------------------
                            	  3425: 
                            	  3426: SerialRbo:
02:0000672A E159            	  3427: 	rol.w		#8,d1
02:0000672C 4841            	  3428: 	swap		d1
02:0000672E E159            	  3429: 	rol.w		#8,d1
02:00006730 4E75            	  3430: 	rts
                            	  3431: 
                            	  3432: ;------------------------------------------------------------------------------
                            	  3433: ; Calculate number of character in input buffer
                            	  3434: ;
                            	  3435: ; Returns:
                            	  3436: ;		d0 = number of bytes in buffer.
                            	  3437: ;------------------------------------------------------------------------------
                            	  3438: 
                            	  3439: SerialRcvCount:
02:00006732 303900100160    	  3440: 	move.w	SerTailRcv,d0
02:00006738 907900100162    	  3441: 	sub.w		SerHeadRcv,d0
02:0000673E 6C10            	  3442: 	bge			.0001
02:00006740 303C1000        	  3443: 	move.w	#$1000,d0
02:00006744 907900100162    	  3444: 	sub.w		SerHeadRcv,d0
02:0000674A D07900100160    	  3445: 	add.w		SerTailRcv,d0
                            	  3446: .0001:
02:00006750 4E75            	  3447: 	rts
                            	  3448: 
                            	  3449: ;------------------------------------------------------------------------------
                            	  3450: ; Serial IRQ routine
                            	  3451: ;
                            	  3452: ; Keeps looping as long as it finds characters in the ACIA recieve buffer/fifo.
                            	  3453: ; Received characters are buffered. If the buffer becomes full, new characters
                            	  3454: ; will be lost.
                            	  3455: ;
                            	  3456: ; Parameters:
                            	  3457: ;		none
                            	  3458: ; Modifies:
                            	  3459: ;		none
                            	  3460: ; Returns:
                            	  3461: ;		d1 = -1 if IRQ handled, otherwise zero
                            	  3462: ;------------------------------------------------------------------------------
                            	  3463: 
                            	  3464: SerialIRQ:
02:00006752 46FC2300        	  3465: 	move.w	#$2300,sr						; disable lower level IRQs
02:00006756 48E7E080        	  3466: 	movem.l	d0/d1/d2/a0,-(a7)
02:0000675A 4E7A0FE0        	  3467: 	movec		coreno,d0
02:0000675E 4840            	  3468: 	swap		d0
02:00006760 7202            	  3469: 	moveq		#SERIAL_SEMA,d1
02:00006762 61009AAA        	  3470: 	bsr			LockSemaphore
                            	  3471: sirqNxtByte:
02:00006766 1239FD060004    	  3472: 	move.b	ACIA+ACIA_STAT,d1		; check the status
02:0000676C 08010003        	  3473: 	btst		#3,d1								; bit 3 = rx full
02:00006770 6756            	  3474: 	beq			notRxInt
02:00006772 1239FD060000    	  3475: 	move.b	ACIA+ACIA_RX,d1
                            	  3476: sirq0001:
02:00006778 303900100160    	  3477: 	move.w	SerTailRcv,d0				; check if recieve buffer full
02:0000677E 5240            	  3478: 	addi.w	#1,d0
02:00006780 02400FFF        	  3479: 	andi.w	#$FFF,d0
02:00006784 B07900100162    	  3480: 	cmp.w		SerHeadRcv,d0
02:0000678A 673C            	  3481: 	beq			sirqRxFull
02:0000678C 33C000100160    	  3482: 	move.w	d0,SerTailRcv				; update tail pointer
02:00006792 5340            	  3483: 	subi.w	#1,d0								; backup
02:00006794 02400FFF        	  3484: 	andi.w	#$FFF,d0
02:00006798 41F900101000    	  3485: 	lea			SerRcvBuf,a0				; a0 = buffer address
02:0000679E 11810000        	  3486: 	move.b	d1,(a0,d0.w)				; store recieved byte in buffer
02:000067A2 4A3900100165    	  3487: 	tst.b		SerRcvXoff					; check if xoff already sent
02:000067A8 66BC            	  3488: 	bne			sirqNxtByte
02:000067AA 6186            	  3489: 	bsr			SerialRcvCount			; if more than 4080 chars in buffer
02:000067AC 0C400FF0        	  3490: 	cmpi.w	#4080,d0
02:000067B0 65B4            	  3491: 	blo			sirqNxtByte
02:000067B2 123C0013        	  3492: 	move.b	#XOFF,d1						; send an XOFF
02:000067B6 423900100164    	  3493: 	clr.b		SerRcvXon						; clear XON status
02:000067BC 13C100100165    	  3494: 	move.b	d1,SerRcvXoff				; set XOFF status
02:000067C2 6100FF4A        	  3495: 	bsr			SerialPutChar				; send XOFF
02:000067C6 609E            	  3496: 	bra			sirqNxtByte     		; check the status for another byte
                            	  3497: sirqRxFull:
                            	  3498: notRxInt:
02:000067C8 4E7A0FE0        	  3499: 	movec		coreno,d0
02:000067CC 4840            	  3500: 	swap		d0
02:000067CE 7202            	  3501: 	moveq		#SERIAL_SEMA,d1
02:000067D0 61009A78        	  3502: 	bsr			UnlockSemaphore
02:000067D4 4CDF0107        	  3503: 	movem.l	(a7)+,d0/d1/d2/a0
02:000067D8 4E73            	  3504: 	rte
                            	  3505: 
                            	  3506: nmeSerial:
02:000067DA 53657269616C    	  3507: 	dc.b		"Serial",0
02:000067E0 00
                            	  3508: 
                            	  3509: ;===============================================================================
                            	  3510: ; Generic I2C routines
                            	  3511: ;===============================================================================
                            	  3512: 
                            	  3513: 	even
                            	  3514: ; i2c
                            	  3515: i2c_setup:
                            	  3516: ;		lea		I2C,a6				
                            	  3517: ;		move.w	#19,I2C_PREL(a6)	; setup prescale for 400kHz clock
                            	  3518: ;		move.w	#0,I2C_PREH(a6)
                            	  3519: init_i2c:
02:000067E2 4DF9FD069000    	  3520: 	lea	I2C2,a6				
02:000067E8 1CBC0013        	  3521: 	move.b #19,I2C_PREL(a6)	; setup prescale for 400kHz clock, 40MHz master
02:000067EC 422E0001        	  3522: 	move.b #0,I2C_PREH(a6)
02:000067F0 4E75            	  3523: 	rts
                            	  3524: 
                            	  3525: ; Wait for I2C transfer to complete
                            	  3526: ;
                            	  3527: ; Parameters
                            	  3528: ; 	a6 - I2C controller base address
                            	  3529: 
                            	  3530: i2c_wait_tip:
02:000067F2 2F00            	  3531: 	move.l d0,-(a7)
                            	  3532: .0001				
02:000067F4 102E0004        	  3533: 	move.b I2C_STAT(a6),d0		; wait for tip to clear
02:000067F8 08000001        	  3534: 	btst #1,d0
02:000067FC 66F6            	  3535: 	bne.s	.0001
02:000067FE 201F            	  3536: 	move.l (a7)+,d0
02:00006800 4E75            	  3537: 	rts
                            	  3538: 
                            	  3539: ; Parameters
                            	  3540: ;	d0.b - data to transmit
                            	  3541: ;	d1.b - command value
                            	  3542: ;	a6	 - I2C controller base address
                            	  3543: ;
                            	  3544: i2c_wr_cmd:
02:00006802 1D400003        	  3545: 	move.b d0,I2C_TXR(a6)
02:00006806 1D410004        	  3546: 	move.b d1,I2C_CMD(a6)
02:0000680A 61E6            	  3547: 	bsr	i2c_wait_tip
02:0000680C 102E0004        	  3548: 	move.b I2C_STAT(a6),d0
02:00006810 4E75            	  3549: 	rts
                            	  3550: 
                            	  3551: i2c_xmit1:
02:00006812 2F00            	  3552: 	move.l d0,-(a7)
02:00006814 1D7C00010002    	  3553: 	move.b #1,I2C_CTRL(a6)		; enable the core
02:0000681A 7076            	  3554: 	moveq	#$76,d0				; set slave address = %0111011
02:0000681C 323C0090        	  3555: 	move.w #$90,d1				; set STA, WR
02:00006820 61E0            	  3556: 	bsr i2c_wr_cmd
02:00006822 610C            	  3557: 	bsr	i2c_wait_rx_nack
02:00006824 201F            	  3558: 	move.l (a7)+,d0
02:00006826 323C0050        	  3559: 	move.w #$50,d1				; set STO, WR
02:0000682A 61D6            	  3560: 	bsr i2c_wr_cmd
02:0000682C 61000002        	  3561: 	bsr	i2c_wait_rx_nack
                            	  3562: 
                            	  3563: i2c_wait_rx_nack:
02:00006830 2F00            	  3564: 	move.l d0,-(a7)
                            	  3565: .0001						
02:00006832 102E0004        	  3566: 	move.b I2C_STAT(a6),d0		; wait for RXack = 0
02:00006836 08000007        	  3567: 	btst #7,d0
02:0000683A 66F6            	  3568: 	bne.s	.0001
02:0000683C 201F            	  3569: 	move.l (a7)+,d0
02:0000683E 4E75            	  3570: 	rts
                            	  3571: 
                            	  3572: ;===============================================================================
                            	  3573: ; Realtime clock routines
                            	  3574: ;===============================================================================
                            	  3575: 
                            	  3576: rtc_read:
02:00006840 2C7CFD069000    	  3577: 	movea.l	#I2C2,a6
02:00006846 4BF900100200    	  3578: 	lea	RTCBuf,a5
02:0000684C 1D7C00800002    	  3579: 	move.b	#$80,I2C_CTRL(a6)	; enable I2C
02:00006852 103C00DE        	  3580: 	move.b	#$DE,d0				; read address, write op
02:00006856 123C0090        	  3581: 	move.b	#$90,d1				; STA + wr bit
02:0000685A 61A6            	  3582: 	bsr	i2c_wr_cmd
02:0000685C 4A00            	  3583: 	tst.b	d0
02:0000685E 6B66            	  3584: 	bmi	.rxerr
02:00006860 4200            	  3585: 	move.b #$00,d0				; address zero
02:00006862 123C0010        	  3586: 	move.b #$10,d1				; wr bit
02:00006866 619A            	  3587: 	bsr	i2c_wr_cmd
02:00006868 4A00            	  3588: 	tst.b	d0
02:0000686A 6B5A            	  3589: 	bmi	.rxerr
02:0000686C 103C00DF        	  3590: 	move.b #$DF,d0				; read address, read op
02:00006870 123C0090        	  3591: 	move.b #$90,d1				; STA + wr bit
02:00006874 618C            	  3592: 	bsr i2c_wr_cmd
02:00006876 4A00            	  3593: 	tst.b	d0
02:00006878 6B4C            	  3594: 	bmi	.rxerr
                            	  3595: 		
02:0000687A 343C0020        	  3596: 	move.w #$20,d2
                            	  3597: .0001
02:0000687E 1D7C00200004    	  3598: 	move.b #$20,I2C_CMD(a6)	; rd bit
02:00006884 6100FF6C        	  3599: 	bsr	i2c_wait_tip
02:00006888 61A6            	  3600: 	bsr	i2c_wait_rx_nack
02:0000688A 102E0004        	  3601: 	move.b I2C_STAT(a6),d0
02:0000688E 4A00            	  3602: 	tst.b	d0
02:00006890 6B34            	  3603: 	bmi	.rxerr
02:00006892 102E0003        	  3604: 	move.b I2C_RXR(a6),d0
02:00006896 1B802000        	  3605: 	move.b d0,(a5,d2.w)
02:0000689A 5242            	  3606: 	addi.w #1,d2
02:0000689C 0C42005F        	  3607: 	cmpi.w #$5F,d2
02:000068A0 66DC            	  3608: 	bne	.0001
02:000068A2 1D7C00680004    	  3609: 	move.b #$68,I2C_CMD(a6)	; STO, rd bit + nack
02:000068A8 6100FF48        	  3610: 	bsr i2c_wait_tip
02:000068AC 6182            	  3611: 	bsr i2c_wait_rx_nack
02:000068AE 102E0004        	  3612: 	move.b I2C_STAT(a6),d0
02:000068B2 4A00            	  3613: 	tst.b	d0
02:000068B4 6B10            	  3614: 	bmi	.rxerr
02:000068B6 102E0003        	  3615: 	move.b I2C_RXR(a6),d0
02:000068BA 1B802000        	  3616: 	move.b d0,(a5,d2.w)
02:000068BE 422E0002        	  3617: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
02:000068C2 7000            	  3618: 	moveq	#0,d0
02:000068C4 4E75            	  3619: 	rts
                            	  3620: .rxerr
02:000068C6 422E0002        	  3621: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
02:000068CA 4E75            	  3622: 	rts
                            	  3623: 
                            	  3624: rtc_write:
02:000068CC 2C7CFD069000    	  3625: 	movea.l	#I2C2,a6
02:000068D2 4BF900100200    	  3626: 	lea	RTCBuf,a5
02:000068D8 1D7C00800002    	  3627: 	move.b #$80,I2C_CTRL(a6)	; enable I2C
02:000068DE 103C00DE        	  3628: 	move.b #$DE,d0				; read address, write op
02:000068E2 123C0090        	  3629: 	move.b #$90,d1				; STA + wr bit
02:000068E6 6100FF1A        	  3630: 	bsr	i2c_wr_cmd
02:000068EA 4A00            	  3631: 	tst.b	d0
02:000068EC 6B42            	  3632: 	bmi	.rxerr
02:000068EE 4200            	  3633: 	move.b #$00,d0				; address zero
02:000068F0 123C0010        	  3634: 	move.b #$10,d1				; wr bit
02:000068F4 6100FF0C        	  3635: 	bsr	i2c_wr_cmd
02:000068F8 4A00            	  3636: 	tst.b	d0
02:000068FA 6B34            	  3637: 	bmi	.rxerr
02:000068FC 343C0020        	  3638: 	move.w #$20,d2
                            	  3639: .0001
02:00006900 10352000        	  3640: 	move.b (a5,d2.w),d0
02:00006904 123C0010        	  3641: 	move.b #$10,d1
02:00006908 6100FEF8        	  3642: 	bsr	i2c_wr_cmd
02:0000690C 4A00            	  3643: 	tst.b	d0
02:0000690E 6B20            	  3644: 	bmi	.rxerr
02:00006910 5242            	  3645: 	addi.w #1,d2
02:00006912 0C42005F        	  3646: 	cmpi.w #$5F,d2
02:00006916 66E8            	  3647: 	bne.s	.0001
02:00006918 10352000        	  3648: 	move.b (a5,d2.w),d0
02:0000691C 123C0050        	  3649: 	move.b #$50,d1				; STO, wr bit
02:00006920 6100FEE0        	  3650: 	bsr	i2c_wr_cmd
02:00006924 4A00            	  3651: 	tst.b	d0
02:00006926 6B08            	  3652: 	bmi	.rxerr
02:00006928 422E0002        	  3653: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
02:0000692C 7000            	  3654: 	moveq	#0,d0
02:0000692E 4E75            	  3655: 	rts
                            	  3656: .rxerr:
02:00006930 422E0002        	  3657: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
02:00006934 4E75            	  3658: 	rts
                            	  3659: 
                            	  3660: msgRtcReadFail:
02:00006936 5254432072656164	  3661: 	dc.b	"RTC read/write failed.",$0A,$0D,$00
02:0000693E 2F77726974652066
02:00006946 61696C65642E
02:0000694C 0A
02:0000694D 0D
02:0000694E 00
                            	  3662: 
                            	  3663: 	even
                            	  3664: 
                            	  3665: ;------------------------------------------------------------------------------
                            	  3666: ;------------------------------------------------------------------------------
                            	  3667: 	even
                            	  3668: 
                            	  3669: bus_err:
                            	  3670: .0001:
02:00006950 4E71            	  3671: 	nop
02:00006952 60FC            	  3672: 	bra			.0001
                            	  3673: 
                            	  3674: trap3:
                            	  3675: 	; First save all registers
02:00006954 48F9FFFF00040100	  3676: 	movem.l		d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
02:0000695C 33DF00040140    	  3677: 	move.w		(a7)+,Regsave+$40
02:00006962 23DF00040144    	  3678: 	move.l		(a7)+,Regsave+$44
02:00006968 2E7C00040FFC    	  3679: 	move.l		#$40FFC,a7			; reset stack pointer
02:0000696E 46FC2500        	  3680: 	move.w		#$2500,sr				; enable interrupts
02:00006972 303900040202    	  3681: 	move.w		NumSetBreakpoints,d0
02:00006978 5340            	  3682: 	subi.w		#1,d0
02:0000697A 41F900040220    	  3683: 	lea				Breakpoints,a0
02:00006980 223900040144    	  3684: 	move.l		Regsave+$44,d1
                            	  3685: .0001:
02:00006986 B298            	  3686: 	cmp.l			(a0)+,d1
02:00006988 6708            	  3687: 	beq.s			ProcessBreakpoint
02:0000698A 51C8FFFA        	  3688: 	dbra			d0,.0001
02:0000698E 6000F250        	  3689: 	bra				Monitor					; not a breakpoint
                            	  3690: ProcessBreakpoint:
02:00006992 6104            	  3691: 	bsr				DisarmAllBreakpoints
02:00006994 6000F80A        	  3692: 	bra				cmdDumpRegs
                            	  3693: 
                            	  3694: ;------------------------------------------------------------------------------
                            	  3695: ; DisarmAllBreakpoints, used when entering the monitor.
                            	  3696: ;------------------------------------------------------------------------------
                            	  3697: 
                            	  3698: DisarmAllBreakpoints:
02:00006998 48E780E0        	  3699: 	movem.l	d0/a0/a1/a2,-(a7)			; stack some regs
02:0000699C 303900040202    	  3700: 	move.w	NumSetBreakpoints,d0	; d0 = number of breakpoints that are set
02:000069A2 0C400008        	  3701: 	cmpi.w	#numBreakpoints,d0		; check for valid number
02:000069A6 641A            	  3702: 	bhs.s		.0001
02:000069A8 45F900040220    	  3703: 	lea			Breakpoints,a2				; a2 = pointer to breakpoint address table
02:000069AE 41F900040280    	  3704: 	lea			BreakpointWords,a0		; a0 = pointer to breakpoint instruction word table
02:000069B4 6004            	  3705: 	bra.s		.0003									; enter loop at bottom
                            	  3706: .0002:
02:000069B6 225A            	  3707: 	move.l	(a2)+,a1							; a1 = address of breakpoint
02:000069B8 3298            	  3708: 	move.w	(a0)+,(a1)						; copy instruction word back to code
                            	  3709: .0003:
02:000069BA 51C8FFFA        	  3710: 	dbra		d0,.0002
02:000069BE 4CDF0701        	  3711: 	movem.l	(a7)+,d0/a0/a1/a2			; restore regs
                            	  3712: .0001:
02:000069C2 4E75            	  3713: 	rts	
                            	  3714: 
                            	  3715: ;------------------------------------------------------------------------------
                            	  3716: ; ArmAllBreakpoints, used when entering the monitor.
                            	  3717: ;------------------------------------------------------------------------------
                            	  3718: 
                            	  3719: ArmAllBreakpoints:
02:000069C4 48E780E0        	  3720: 	movem.l		d0/a0/a1/a2,-(a7)			; stack some regs
02:000069C8 303900040202    	  3721: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:000069CE 0C400008        	  3722: 	cmpi.w		#numBreakpoints,d0		; is the number valid?
02:000069D2 641E            	  3723: 	bhs.s			.0001
02:000069D4 45F900040220    	  3724: 	lea				Breakpoints,a2				; a2 = pointer to breakpoint address table
02:000069DA 41F900040280    	  3725: 	lea				BreakpointWords,a0		; a0 = pointer to instruction word table
02:000069E0 6008            	  3726: 	bra.s			.0003									; enter loop at bottom
                            	  3727: .0002:
02:000069E2 225A            	  3728: 	move.l		(a2)+,a1							; a1 = address of breakpoint
02:000069E4 3091            	  3729: 	move.w		(a1),(a0)							; copy instruction word to table
02:000069E6 30FC4E43        	  3730: 	move.w		#$4E43,(a0)+					; set instruction = TRAP3
                            	  3731: .0003:
02:000069EA 51C8FFF6        	  3732: 	dbra			d0,.0002
02:000069EE 4CDF0701        	  3733: 	movem.l		(a7)+,d0/a0/a1/a2			; restore regs
                            	  3734: .0001:
02:000069F2 4E75            	  3735: 	rts	
                            	  3736: 
                            	  3737: ;------------------------------------------------------------------------------
                            	  3738: ;------------------------------------------------------------------------------
                            	  3739: 
                            	  3740: ArmBreakpoint:
02:000069F4 48E7E0E0        	  3741: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
02:000069F8 303900040202    	  3742: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:000069FE 0C400008        	  3743: 	cmpi.w		#numBreakpoints,d0		; check if too many
02:00006A02 645A            	  3744: 	bhs.s			.0001
02:00006A04 527900040202    	  3745: 	addi.w		#1,NumSetBreakpoints	; increment number of breakpoints
02:00006A0A 2400            	  3746: 	move.l		d0,d2
02:00006A0C 6100F684        	  3747: 	bsr				ignBlanks
02:00006A10 6100F858        	  3748: 	bsr				GetHexNumber
02:00006A14 6748            	  3749: 	beq.s			.0001									; was there an address?
02:00006A16 08010000        	  3750: 	btst			#0,d1									; address value must be even
02:00006A1A 6642            	  3751: 	bne.s			.0001
                            	  3752: 	; See if the breakpoint is in the table already
02:00006A1C 43F900040220    	  3753: 	lea				Breakpoints,a1				; a1 points to breakpoint table
02:00006A22 343C0007        	  3754: 	move.w		#numBreakpoints-1,d2
                            	  3755: .0002:
02:00006A26 B299            	  3756: 	cmp.l			(a1)+,d1
02:00006A28 673A            	  3757: 	beq.s			.0003									; breakpoint is in table already
02:00006A2A 51CAFFFA        	  3758: 	dbra			d2,.0002
                            	  3759: 	; Add breakpoint to table
                            	  3760: 	; Search for empty entry
02:00006A2E 43F900040220    	  3761: 	lea				Breakpoints,a1				; a1 = pointer to breakpoint address table
02:00006A34 4242            	  3762: 	clr.w			d2										; d2 = count
                            	  3763: .0006:
02:00006A36 4A91            	  3764: 	tst.l			(a1)									; is the entry empty?
02:00006A38 670C            	  3765: 	beq.s			.0005									; branch if found empty entry
02:00006A3A 5889            	  3766: 	lea				4(a1),a1							; point to next entry
02:00006A3C 5242            	  3767: 	addi.w		#1,d2									; increment count
02:00006A3E 0C420008        	  3768: 	cmpi.w		#numBreakpoints,d2		; safety: check against max number
02:00006A42 65F2            	  3769: 	blo.s			.0006
02:00006A44 6018            	  3770: 	bra.s			.0001									; what? no empty entries found, table corrupt?
                            	  3771: .0005:
02:00006A46 E542            	  3772: 	asl.w			#2,d2									; d2 = long word index
02:00006A48 23812000        	  3773: 	move.l		d1,(a1,d2.w)					; move breakpoint address to table
02:00006A4C 2441            	  3774: 	move.l		d1,a2
02:00006A4E E24A            	  3775: 	lsr.w			#1,d2									; d2 = word index
                            	  3776: .0004:
02:00006A50 43F900040280    	  3777: 	lea				BreakpointWords,a1
02:00006A56 33922000        	  3778: 	move.w		(a2),(a1,d2.w)				; copy instruction word to table
02:00006A5A 34BC4E43        	  3779: 	move.w		#$4E43,(a2)						; replace word with TRAP3
                            	  3780: .0001:
02:00006A5E 4CDF0707        	  3781: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
02:00006A62 4E75            	  3782: 	rts
                            	  3783: .0003:
02:00006A64 2469FFFC        	  3784: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
02:00006A68 0C524E43        	  3785: 	cmpi.w		#$4E43,(a2)						; see if breakpoint already armed
02:00006A6C 67F0            	  3786: 	beq.s			.0001
02:00006A6E D482            	  3787: 	asl.l			#1,d2									; d2 = word index
02:00006A70 60DE            	  3788: 	bra.s			.0004
                            	  3789: 
                            	  3790: 
                            	  3791: ;------------------------------------------------------------------------------
                            	  3792: ;------------------------------------------------------------------------------
                            	  3793: 
                            	  3794: DisarmBreakpoint:
02:00006A72 48E7E0E0        	  3795: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
02:00006A76 303900040202    	  3796: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
02:00006A7C 0C400008        	  3797: 	cmpi.w		#numBreakpoints,d0		; check if too many
02:00006A80 623E            	  3798: 	bhi.s			.0001
02:00006A82 2400            	  3799: 	move.l		d0,d2
02:00006A84 6100F60C        	  3800: 	bsr				ignBlanks
02:00006A88 6100F7E0        	  3801: 	bsr				GetHexNumber
02:00006A8C 6732            	  3802: 	beq.s			.0001									; was there an address?
02:00006A8E 08010000        	  3803: 	btst			#0,d1									; address value must be even
02:00006A92 662C            	  3804: 	bne.s			.0001
                            	  3805: 	; See if the breakpoint is in the table already
02:00006A94 43F900040220    	  3806: 	lea				Breakpoints,a1				; a1 points to breakpoint table
02:00006A9A 5342            	  3807: 	subi.w		#1,d2
                            	  3808: .0002:
02:00006A9C B299            	  3809: 	cmp.l			(a1)+,d1
02:00006A9E 6706            	  3810: 	beq.s			.0003									; breakpoint is in table already
02:00006AA0 51CAFFFA        	  3811: 	dbra			d2,.0002
02:00006AA4 601A            	  3812: 	bra				.0001									; breakpoint was not in table
                            	  3813: .0003:
                            	  3814: 	; Remove breakpoint from table
02:00006AA6 537900040202    	  3815: 	subi.w		#1,NumSetBreakpoints	; decrement number of breakpoints
02:00006AAC 2469FFFC        	  3816: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
02:00006AB0 42A9FFFC        	  3817: 	clr.l			-4(a1)								; empty out breakpoint
02:00006AB4 43F900040280    	  3818: 	lea				BreakpointWords,a1
02:00006ABA D482            	  3819: 	asl.l			#1,d2									; d2 = word index
02:00006ABC 34B12000        	  3820: 	move.w		(a1,d2.w),(a2)				; copy instruction from table back to code
                            	  3821: .0001:
02:00006AC0 4CDF0707        	  3822: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
02:00006AC4 4E75            	  3823: 	rts
                            	  3824: 
                            	  3825: ;------------------------------------------------------------------------------
                            	  3826: ;------------------------------------------------------------------------------
                            	  3827: 
                            	  3828: ListBreakpoints:
02:00006AC6 6100E398        	  3829: 	bsr			CRLF
02:00006ACA 343C0008        	  3830: 	move.w	#numBreakpoints,d2
02:00006ACE 43F900040220    	  3831: 	lea			Breakpoints,a1
                            	  3832: .0001:
02:00006AD4 2219            	  3833: 	move.l	(a1)+,d1
02:00006AD6 6100F812        	  3834: 	bsr			DisplayTetra
02:00006ADA 6100E384        	  3835: 	bsr			CRLF
02:00006ADE 51CAFFF4        	  3836: 	dbra		d2,.0001
02:00006AE2 6000F0FC        	  3837: 	bra			Monitor
                            	  3838: 
                            	  3839: ;------------------------------------------------------------------------------
                            	  3840: ;------------------------------------------------------------------------------
                            	  3841: 
                            	  3842: ClearBreakpointList:
02:00006AE6 343C0008        	  3843: 	move.w	#numBreakpoints,d2
02:00006AEA 43F900040220    	  3844: 	lea			Breakpoints,a1
                            	  3845: .0001:
02:00006AF0 4299            	  3846: 	clr.l		(a1)+
02:00006AF2 51CAFFFC        	  3847: 	dbra		d2,.0001
02:00006AF6 4E75            	  3848: 	rts
                            	  3849: 
                            	  3850: ;------------------------------------------------------------------------------
                            	  3851: ; SendMsg
                            	  3852: ; 00100xy0
                            	  3853: ;
                            	  3854: ; Parameters:
                            	  3855: ;		d1 = target core number
                            	  3856: ;		d2 = argument 1
                            	  3857: ;		d3 = argument 2
                            	  3858: ;		d4 = argument 3
                            	  3859: ;
                            	  3860: ;------------------------------------------------------------------------------
                            	  3861: 
                            	  3862: SendMsg:
02:00006AF8 48E70440        	  3863: 	movem.l	d5/a1,-(a7)
02:00006AFC E149            	  3864: 	lsl.w		#8,d1
02:00006AFE 4E7A5FE0        	  3865: 	movec		coreno,d5
02:00006B02 E94D            	  3866: 	lsl.w		#4,d5
02:00006B04 8245            	  3867: 	or.w		d5,d1
02:00006B06 43F900100000    	  3868: 	lea			$00100000,a1
02:00006B0C 4AB11000        	  3869: 	tst.l		0(a1,d1.w)
02:00006B10 661C            	  3870: 	bne			.msgFull
02:00006B12 4E7A5FE0        	  3871: 	movec		coreno,d5
02:00006B16 23851000        	  3872: 	move.l	d5,0(a1,d1.w)
02:00006B1A 23821004        	  3873: 	move.l	d2,4(a1,d1.w)
02:00006B1E 23831008        	  3874: 	move.l	d3,8(a1,d1.w)
02:00006B22 2384100C        	  3875: 	move.l	d4,12(a1,d1.w)
02:00006B26 4CDF0220        	  3876: 	movem.l	(a7)+,d5/a1
02:00006B2A 7200            	  3877: 	moveq		#0,d1
02:00006B2C 4E75            	  3878: 	rts
                            	  3879: .msgFull:
02:00006B2E 4CDF0220        	  3880: 	movem.l	(a7)+,d5/a1
02:00006B32 72FF            	  3881: 	moveq		#-1,d1
02:00006B34 4E75            	  3882: 	rts
                            	  3883: 
                            	  3884: ;------------------------------------------------------------------------------
                            	  3885: ; ReceiveMsg
                            	  3886: ;		Scan the message table for messages and dispatch them.
                            	  3887: ; 00100xy0
                            	  3888: ;
                            	  3889: ; Parameters:
                            	  3890: ;------------------------------------------------------------------------------
                            	  3891: 
                            	  3892: ReceiveMsg:
02:00006B36 48E77F40        	  3893: 	movem.l		d1/d2/d3/d4/d5/d6/d7/a1,-(a7)
02:00006B3A 43F900100000    	  3894: 	lea				$00100000,a1
02:00006B40 4E7A5FE0        	  3895: 	movec			coreno,d5
02:00006B44 E14D            	  3896: 	lsl.w			#8,d5
02:00006B46 7C02            	  3897: 	moveq			#2,d6
                            	  3898: .nextCore:
02:00006B48 3E06            	  3899: 	move.w		d6,d7
02:00006B4A E94F            	  3900: 	lsl.w			#4,d7
02:00006B4C DE45            	  3901: 	add.w			d5,d7
02:00006B4E 4AB17000        	  3902: 	tst.l			0(a1,d7.w)			; Is there a message from core d6?
02:00006B52 6716            	  3903: 	beq				.noMsg
02:00006B54 22317000        	  3904: 	move.l		0(a1,d7.w),d1
02:00006B58 24317004        	  3905: 	move.l		4(a1,d7.w),d2
02:00006B5C 26317008        	  3906: 	move.l		8(a1,d7.w),d3
02:00006B60 2831700C        	  3907: 	move.l		12(a1,d7.w),d4
02:00006B64 42B17000        	  3908: 	clr.l			0(a1,d7.w)			; indicate message was received
02:00006B68 610E            	  3909: 	bsr				DispatchMsg
                            	  3910: .noMsg:
02:00006B6A 5246            	  3911: 	addq			#1,d6
02:00006B6C BC7C0009        	  3912: 	cmp.w			#9,d6
02:00006B70 63D6            	  3913: 	bls				.nextCore
02:00006B72 4CDF02FE        	  3914: 	movem.l		(a7)+,d1/d2/d3/d4/d5/d6/d7/a1
02:00006B76 4E75            	  3915: 	rts
                            	  3916: 
                            	  3917: ;------------------------------------------------------------------------------
                            	  3918: ;------------------------------------------------------------------------------
                            	  3919: 
                            	  3920: DispatchMsg:
02:00006B78 4E75            	  3921: 	rts
                            	  3922: 
                            	  3923: ;------------------------------------------------------------------------------
                            	  3924: ; a0 = pointer to string buffer
                            	  3925: ; d6 = exponent
                            	  3926: ;------------------------------------------------------------------------------
                            	  3927: 	align 4
                            	  3928: 	if 0
                            	  3929: _dfOne	dc.w $25ff,$c000,$0000,$0000,$0000,$0000,$0000,$0000
                            	  3930: _dfTen	dc.w $2600,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                            	  3931: _dfMil  dc.w $2601,$4000,$0000,$0000,$0000,$0000,$0000,$0000
                            	  3932: 	endif
02:00006B80 25FF0000        	  3933: _dfOne	dc.l $25ff0000,$00000000,$00000000
02:00006B84 00000000
02:00006B88 00000000
02:00006B8C 2600C000        	  3934: _dfTen	dc.l $2600C000,$00000000,$00000000
02:00006B90 00000000
02:00006B94 00000000
02:00006B98 2606DDFA        	  3935: _dfMil  dc.l $2606DDFA,$1C000000,$00000000
02:00006B9C 1C000000
02:00006BA0 00000000
                            	  3936: 
02:00006BA4 4E614E          	  3937: _msgNan	dc.b "NaN",0
02:00006BA7 00
02:00006BA8 496E66          	  3938: _msgInf dc.b "Inf",0
02:00006BAB 00
                            	  3939: 
                            	  3940: ;------------------------------------------------------------------------------
                            	  3941: ; Parameters:
                            	  3942: ;		fp0 = dbl
                            	  3943: ;------------------------------------------------------------------------------
                            	  3944: 
                            	  3945: ;	if (dbl < 1.0) {
                            	  3946: ;		while (dbl < 1.0) {
                            	  3947: ;			dbl *= 1000000.0;
                            	  3948: ;			exp -= 6;  
                            	  3949: ;		}
                            	  3950: ;	}
                            	  3951: 
                            	  3952: _MakeBig:
02:00006BAC F23A4C80FFD0    	  3953: 	fmove.p _dfOne,fp1
02:00006BB2 F23A4D00FFE2    	  3954: 	fmove.p _dfMil,fp2
                            	  3955: .0002
02:00006BB8 F2000438        	  3956: 	fcmp fp1,fp0						; is fp0 > 1?
02:00006BBC F293000E        	  3957: 	fbge .0001							; yes, return
02:00006BC0 F23C402600000006	  3958: 	fscale.l #6,fp0					; multiply fp0 by a million
02:00006BC8 5D46            	  3959: 	subi.w #6,d6						; decrement exponent by six
02:00006BCA 60EC            	  3960: 	bra .0002								; keep trying until number is > 1
                            	  3961: .0001
02:00006BCC 4E75            	  3962: 	rts
                            	  3963: 	
                            	  3964: ;------------------------------------------------------------------------------
                            	  3965: ; Parameters:
                            	  3966: ;		fp0 = dbl
                            	  3967: ;------------------------------------------------------------------------------
                            	  3968: 
                            	  3969: ;	// The following is similar to using log10() and pow() functions.
                            	  3970: ;	// Now dbl is >= 1.0
                            	  3971: ;	// Create a number dbl2 on the same order of magnitude as dbl, but
                            	  3972: ;	// less than dbl.
                            	  3973: ;	dbl2 = 1.0;
                            	  3974: ;	dbla = dbl2;
                            	  3975: ;	if (dbl > dbl2) {	// dbl > 1.0 ?
                            	  3976: ;		while (dbl2 <= dbl) {
                            	  3977: ;			dbla = dbl2;
                            	  3978: ;			dbl2 *= 10.0;	// increase power of 10
                            	  3979: ;			exp++;
                            	  3980: ;		}
                            	  3981: ;		// The above loop goes one too far, we want the last value less
                            	  3982: ;		// than dbl.
                            	  3983: ;		dbl2 = dbla;
                            	  3984: ;		exp--;
                            	  3985: ;	}
                            	  3986: 
                            	  3987: _LessThanDbl:
02:00006BCE F23A4D00FFAE    	  3988: 	fmove.p _dfOne,fp2	; setup fp2 = 1
02:00006BD4 F23A4C80FFB4    	  3989: 	fmove.p _dfTen,fp1	; setup fp1 = 10
02:00006BDA F2000838        	  3990: 	fcmp fp2,fp0				; if (dbl > dbl2)
02:00006BDE F2950020        	  3991: 	fble .0004
                            	  3992: .0006
02:00006BE2 F2000138        	  3993: 	fcmp fp0,fp2				; while (dbl2 <= dbl)
02:00006BE6 F292000E        	  3994: 	fbgt .0005
02:00006BEA F23C412600000001	  3995: 	fscale.l #1,fp2			; dbl2 *= 10 (increase exponent by one)
02:00006BF2 5246            	  3996: 	addi.w #1,d6				; exp++
02:00006BF4 60EC            	  3997: 	bra .0006
                            	  3998: .0005
02:00006BF6 F23C4126FFFFFFFF	  3999: 	fscale.l #-1,fp2		; dbl2 /= 10 (decrease exponent by one)
02:00006BFE 5346            	  4000: 	subi.w #1,d6				; exp--;
                            	  4001: .0004	
02:00006C00 F2396C0000040600	  4002: 	fmove.p fp0,_fpWork
02:00006C08 F2396D000004060C	  4003: 	fmove.p fp2,_fpWork+12
02:00006C10 4E75            	  4004: 	rts
                            	  4005: 
                            	  4006: ;------------------------------------------------------------------------------
                            	  4007: ; Parameters:
                            	  4008: ;		d6 = exponent
                            	  4009: ;------------------------------------------------------------------------------
                            	  4010: 
                            	  4011: ; if (exp >= 0 && exp < 6) {
                            	  4012: ;   digits_before_decpt = exp+1;
                            	  4013: ;		exp = 0;
                            	  4014: ;	}
                            	  4015: ;	else if (exp >= -6)
                            	  4016: ;		digits_before_decpt = 1;
                            	  4017: ;	else
                            	  4018: ;		digits_before_decpt = -1;
                            	  4019: 
                            	  4020: _ComputeDigitsBeforeDecpt:
02:00006C12 4A46            	  4021: 	tst.w d6
02:00006C14 6B14            	  4022: 	bmi .0007
02:00006C16 0C460006        	  4023: 	cmpi.w #6,d6
02:00006C1A 6C0E            	  4024: 	bge .0007
02:00006C1C 3006            	  4025: 	move.w d6,d0
02:00006C1E 5240            	  4026: 	addi.w #1,d0
02:00006C20 33C000040510    	  4027: 	move.w d0,_digits_before_decpt	
02:00006C26 4246            	  4028: 	clr.w d6
02:00006C28 6018            	  4029: 	bra .0008
                            	  4030: .0007
02:00006C2A 0C46FFFA        	  4031: 	cmpi.w #-6,d6
02:00006C2E 6D0A            	  4032: 	blt .0009
02:00006C30 33FC000100040510	  4033: 	move.w #1,_digits_before_decpt
02:00006C38 6008            	  4034: 	bra .0008
                            	  4035: .0009
02:00006C3A 33FCFFFF00040510	  4036: 	move.w #-1,_digits_before_decpt
                            	  4037: .0008
02:00006C42 4E75            	  4038: 	rts
                            	  4039: 
                            	  4040: ;------------------------------------------------------------------------------
                            	  4041: ; Parameters:
                            	  4042: ;		d6 = exponent
                            	  4043: ;------------------------------------------------------------------------------
                            	  4044: 
                            	  4045: ;	// Spit out a leading zero before the decimal point for a small number.
                            	  4046: ;  if (exp < -6) {
                            	  4047: ;		 buf[ndx] = '0';
                            	  4048: ;		 ndx++;
                            	  4049: ;    buf[ndx] = '.';
                            	  4050: ;    ndx++;
                            	  4051: ;  }
                            	  4052: _LeadingZero:
02:00006C44 0C46FFFA        	  4053: 	cmpi.w #-6,d6
02:00006C48 6C08            	  4054: 	bge .0010
02:00006C4A 10FC0030        	  4055: 	move.b #'0',(a0)+
02:00006C4E 10FC002E        	  4056: 	move.b #'.',(a0)+
                            	  4057: .0010
02:00006C52 4E75            	  4058: 	rts
                            	  4059: 
                            	  4060: ;------------------------------------------------------------------------------
                            	  4061: ; Register Usage
                            	  4062: ;		d1 = digit
                            	  4063: ;		fp0 = dbl
                            	  4064: ;		fp2 = dbl2
                            	  4065: ; Parameters:
                            	  4066: ;------------------------------------------------------------------------------
                            	  4067: 
                            	  4068: ;	// Now loop processing one digit at a time.
                            	  4069: ;  for (nn = 0; nn < 25 && precision > 0; nn++) {
                            	  4070: ;    digit = 0;
                            	  4071: ;		dbla = dbl;
                            	  4072: ;		// dbl is on the same order of magnitude as dbl2 so
                            	  4073: ;		// a repeated subtract can be used to find the digit.
                            	  4074: ;    while (dbl >= dbl2) {
                            	  4075: ;      dbl -= dbl2;
                            	  4076: ;      digit++;
                            	  4077: ;    }
                            	  4078: ;    buf[ndx] = digit + '0';
                            	  4079: ;		// Now go back and perform just a single subtract and
                            	  4080: ;		// a multiply to find out how much to reduce dbl by.
                            	  4081: ;		// This should improve the accuracy
                            	  4082: ;		if (digit > 2)
                            	  4083: ;			dbl = dbla - dbl2 * digit;
                            	  4084: ;    ndx++;
                            	  4085: ;    digits_before_decpt--;
                            	  4086: ;    if (digits_before_decpt==0) {
                            	  4087: ;			buf[ndx] = '.';
                            	  4088: ;			ndx++;
                            	  4089: ;    }
                            	  4090: ;    else if (digits_before_decpt < 0)
                            	  4091: ;      precision--;
                            	  4092: ;		// Shift the next digit to be tested into position.
                            	  4093: ;    dbl *= 10.0;
                            	  4094: ;  }
                            	  4095: 	
                            	  4096: _SpitOutDigits:
02:00006C54 303C0018        	  4097: 	move.w #24,d0		; d0 = nn
                            	  4098: .0017	
02:00006C58 4AB900040514    	  4099: 	tst.l _precision
02:00006C5E 6F6A            	  4100: 	ble .0011
02:00006C60 7200            	  4101: 	moveq #0,d1			; digit = 0
02:00006C62 F2000380        	  4102: 	fmove fp0,fp7		; dbla = dbl
                            	  4103: .0013
02:00006C66 F2000838        	  4104: 	fcmp fp2,fp0
02:00006C6A F294000A        	  4105: 	fblt .0012
02:00006C6E F2000828        	  4106: 	fsub fp2,fp0		; dbl -= dbl2
02:00006C72 5201            	  4107: 	addi.b #1,d1
02:00006C74 60F0            	  4108: 	bra .0013
                            	  4109: .0012
02:00006C76 06010030        	  4110: 	addi.b #'0',d1
02:00006C7A 1081            	  4111: 	move.b d1,(a0)
02:00006C7C 04010030        	  4112: 	subi.b #'0',d1
02:00006C80 0C010002        	  4113: 	cmpi.b #2,d1
02:00006C84 6F14            	  4114: 	ble .0014
02:00006C86 4881            	  4115: 	ext.w d1
02:00006C88 48C1            	  4116: 	ext.l d1
02:00006C8A F2014180        	  4117: 	fmove.l d1,fp3
02:00006C8E F20009A3        	  4118: 	fmul fp2,fp3		; fp3 = dbl2 * digit
02:00006C92 F2001C00        	  4119: 	fmove fp7,fp0
02:00006C96 F2000C28        	  4120: 	fsub fp3,fp0		; dbl = dbla - dbl2 * digit
                            	  4121: .0014
02:00006C9A 5248            	  4122: 	addq #1,a0			; ndx++
02:00006C9C 537900040510    	  4123: 	subi.w #1,_digits_before_decpt
02:00006CA2 4A7900040510    	  4124: 	tst.w _digits_before_decpt
02:00006CA8 6604            	  4125: 	bne .0015
02:00006CAA 10FC002E        	  4126: 	move.b #'.',(a0)+
                            	  4127: .0015
02:00006CAE 4A7900040510    	  4128: 	tst.w _digits_before_decpt
02:00006CB4 6C06            	  4129: 	bge .0016
02:00006CB6 53B900040514    	  4130: 	subi.l #1,_precision
                            	  4131: .0016
02:00006CBC F23A4D80FECC    	  4132: 	fmove.p _dfTen,fp3
02:00006CC2 F2000C23        	  4133: 	fmul fp3,fp0
02:00006CC6 51C8FF90        	  4134: 	dbra d0,.0017
                            	  4135: .0011	
02:00006CCA 4E75            	  4136: 	rts
                            	  4137: 
                            	  4138: ;------------------------------------------------------------------------------
                            	  4139: ; If the number ends in a decimal point, trim off the point.
                            	  4140: ;------------------------------------------------------------------------------
                            	  4141: 
                            	  4142: _TrimTrailingPoint:
02:00006CCC 0C28002EFFFF    	  4143: 	cmpi.b #'.',-1(a0)
02:00006CD2 6602            	  4144: 	bne .0001
02:00006CD4 4220            	  4145: 	move.b #0,-(a0)
                            	  4146: .0001
02:00006CD6 4E75            	  4147: 	rts
                            	  4148: 	
                            	  4149: ;------------------------------------------------------------------------------
                            	  4150: ;------------------------------------------------------------------------------
                            	  4151: 
                            	  4152: ;	// Trim trailing zeros from the number
                            	  4153: ;  do {
                            	  4154: ;      ndx--;
                            	  4155: ;  } while(buf[ndx]=='0');
                            	  4156: ;  ndx++;
                            	  4157: 
                            	  4158: _TrimTrailingZeros:
                            	  4159: .0018	
02:00006CD8 0C200030        	  4160: 	cmpi.b #'0',-(a0)		; if the last digit was a zero, backup
02:00006CDC 67FA            	  4161: 	beq .0018
02:00006CDE 5248            	  4162: 	addq #1,a0					; now advance by one
02:00006CE0 4210            	  4163: 	move.b #0,(a0)			; NULL terminate string
02:00006CE2 4E75            	  4164: 	rts
                            	  4165: 
                            	  4166: ;------------------------------------------------------------------------------
                            	  4167: ;------------------------------------------------------------------------------
                            	  4168: 
                            	  4169: ;	// Spit out +/-E
                            	  4170: ;  buf[ndx] = E;
                            	  4171: ;  ndx++;
                            	  4172: ;  if (exp < 0) {
                            	  4173: ;    buf[ndx]='-';
                            	  4174: ;    ndx++;
                            	  4175: ;    exp = -exp;
                            	  4176: ;  }
                            	  4177: ;  else {
                            	  4178: ;		buf[ndx]='+';
                            	  4179: ;		ndx++;
                            	  4180: ;  }
                            	  4181: 
                            	  4182: _SpitOutE:	
02:00006CE4 10F90004050C    	  4183: 	move.b _E,(a0)+
02:00006CEA 4A46            	  4184: 	tst.w d6
02:00006CEC 6C08            	  4185: 	bge .0021
02:00006CEE 10FC002D        	  4186: 	move.b #'-',(a0)+
02:00006CF2 4446            	  4187: 	neg.w d6
02:00006CF4 6004            	  4188: 	bra .0022
                            	  4189: .0021
02:00006CF6 10FC002B        	  4190: 	move.b #'+',(a0)+
                            	  4191: .0022
02:00006CFA 4E75            	  4192: 	rts
                            	  4193: 
                            	  4194: ;------------------------------------------------------------------------------
                            	  4195: ;------------------------------------------------------------------------------
                            	  4196: 
                            	  4197: _ExtractExpDigits:
                            	  4198: _ExtractExp1000sDigit:
02:00006CFC 4201            	  4199: 	clr.b d1						; this needed here only for 96 bit floats
02:00006CFE 423900040504    	  4200: 	clr.b _digit
                            	  4201: .0026
02:00006D04 0C4603E8        	  4202: 	cmpi.w #1000,d6
02:00006D08 6D0C            	  4203: 	blt .0027
02:00006D0A 044603E8        	  4204: 	subi.w #1000,d6
02:00006D0E 523900040504    	  4205: 	addi.b #1,_digit
02:00006D14 60EE            	  4206: 	bra .0026
                            	  4207: .0027
02:00006D16 143900040504    	  4208: 	move.b _digit,d2
02:00006D1C 1E02            	  4209: 	move.b d2,d7
02:00006D1E 8E01            	  4210: 	or.b d1,d7
02:00006D20 6708            	  4211: 	beq .0028
02:00006D22 1E02            	  4212: 	move.b d2,d7
02:00006D24 06070030        	  4213: 	addi.b #'0',d7
02:00006D28 10C7            	  4214: 	move.b d7,(a0)+
                            	  4215: .0028
                            	  4216: 
                            	  4217: ;------------------------------------------------------------------------------
                            	  4218: ;------------------------------------------------------------------------------
                            	  4219: 
                            	  4220: _ExtractExp100sDigit:
02:00006D2A 423900040504    	  4221: 	clr.b _digit
                            	  4222: .0029
02:00006D30 0C460064        	  4223: 	cmpi.w #100,d6
02:00006D34 6D0C            	  4224: 	blt .0030
02:00006D36 04460064        	  4225: 	subi.w #100,d6
02:00006D3A 523900040504    	  4226: 	addi.b #1,_digit
02:00006D40 60EE            	  4227: 	bra .0029
                            	  4228: .0030
02:00006D42 163900040504    	  4229: 	move.b _digit,d3
02:00006D48 1E03            	  4230: 	move.b d3,d7
02:00006D4A 8E02            	  4231: 	or.b d2,d7
02:00006D4C 8E01            	  4232: 	or.b d1,d7
02:00006D4E 6708            	  4233: 	beq .0031
02:00006D50 1E03            	  4234: 	move.b d3,d7
02:00006D52 06070030        	  4235: 	addi.b #'0',d7
02:00006D56 10C7            	  4236: 	move.b d7,(a0)+
                            	  4237: .0031
                            	  4238: 
                            	  4239: ;------------------------------------------------------------------------------
                            	  4240: ;------------------------------------------------------------------------------
                            	  4241: 
                            	  4242: _ExtractExp10sDigit:
02:00006D58 423900040504    	  4243: 	clr.b _digit
                            	  4244: .0032
02:00006D5E 0C46000A        	  4245: 	cmpi.w #10,d6
02:00006D62 6D0C            	  4246: 	blt .0033
02:00006D64 0446000A        	  4247: 	subi.w #10,d6
02:00006D68 523900040504    	  4248: 	addi.b #1,_digit
02:00006D6E 60EE            	  4249: 	bra .0032
                            	  4250: .0033
02:00006D70 183900040504    	  4251: 	move.b _digit,d4
02:00006D76 1E04            	  4252: 	move.b d4,d7
02:00006D78 8E03            	  4253: 	or.b d3,d7
02:00006D7A 8E02            	  4254: 	or.b d2,d7
02:00006D7C 8E01            	  4255: 	or.b d1,d7
02:00006D7E 6708            	  4256: 	beq .0034
02:00006D80 1E04            	  4257: 	move.b d4,d7
02:00006D82 06070030        	  4258: 	addi.b #'0',d7
02:00006D86 10C7            	  4259: 	move.b d7,(a0)+
                            	  4260: .0034
                            	  4261: 
                            	  4262: ;------------------------------------------------------------------------------
                            	  4263: ;------------------------------------------------------------------------------
                            	  4264: 
                            	  4265: _ExtractExp1sDigit:
02:00006D88 423900040504    	  4266: 	clr.b _digit
                            	  4267: .0035
02:00006D8E 0C460001        	  4268: 	cmpi.w #1,d6
02:00006D92 6D0A            	  4269: 	blt .0036
02:00006D94 5346            	  4270: 	subi.w #1,d6
02:00006D96 523900040504    	  4271: 	addi.b #1,_digit
02:00006D9C 60F0            	  4272: 	bra .0035
                            	  4273: .0036
02:00006D9E 1A3900040504    	  4274: 	move.b _digit,d5
02:00006DA4 1E05            	  4275: 	move.b d5,d7
02:00006DA6 06070030        	  4276: 	addi.b #'0',d7
02:00006DAA 10C7            	  4277: 	move.b d7,(a0)+
02:00006DAC 4210            	  4278: 	move.b #0,(a0)
02:00006DAE 4E75            	  4279: 	rts
                            	  4280: 
                            	  4281: ;------------------------------------------------------------------------------
                            	  4282: ;------------------------------------------------------------------------------
                            	  4283: 
                            	  4284: ;	// Now pad the number on the left or right as requested.
                            	  4285: ;  // pad left
                            	  4286: ;  if (width > 0) {
                            	  4287: ;    if (ndx < width) {
                            	  4288: ;      for (nn = 39; nn >= width-ndx; nn--)
                            	  4289: ;        buf[nn] = buf[nn-(width-ndx)];
                            	  4290: ;      for (; nn >= 0; nn--)
                            	  4291: ;        buf[nn] = ' ';
                            	  4292: ;    }
                            	  4293: ;  }
                            	  4294: 	
                            	  4295: _PadLeft:
02:00006DB0 4A3900040508    	  4296: 	tst.b _width
02:00006DB6 6F3E            	  4297: 	ble .0041
02:00006DB8 2008            	  4298: 	move.l a0,d0
02:00006DBA 90BC00040520    	  4299: 	sub.l #_fpBuf,d0	; d0 = ndx
02:00006DC0 B03900040508    	  4300: 	cmp.b _width,d0
02:00006DC6 6C2E            	  4301: 	bge .0041
02:00006DC8 323C0031        	  4302: 	move.w #49,d1			; d1 = nn
                            	  4303: .0040
02:00006DCC 143900040508    	  4304: 	move.b _width,d2
02:00006DD2 4882            	  4305: 	ext.w d2
02:00006DD4 9440            	  4306: 	sub.w d0,d2				; d2 = width-ndx
02:00006DD6 B242            	  4307: 	cmp.w d2,d1
02:00006DD8 6D0E            	  4308: 	blt .0039
02:00006DDA 3601            	  4309: 	move.w d1,d3			; d3 = nn
02:00006DDC 9642            	  4310: 	sub.w d2,d3				; d3 = nn-(width-ndx)
02:00006DDE 11B030001000    	  4311: 	move.b (a0,d3.w),(a0,d1.w)
02:00006DE4 5341            	  4312: 	subi.w #1,d1
02:00006DE6 60E4            	  4313: 	bra .0040
                            	  4314: .0039
02:00006DE8 4A41            	  4315: 	tst.w d1
02:00006DEA 6B0A            	  4316: 	bmi .0041
02:00006DEC 11BC00201000    	  4317: 	move.b #' ',(a0,d1.w)
02:00006DF2 5341            	  4318: 	subi.w #1,d1
02:00006DF4 60F2            	  4319: 	bra .0039
                            	  4320: .0041
02:00006DF6 4E75            	  4321: 	rts
                            	  4322: 
                            	  4323: ;------------------------------------------------------------------------------
                            	  4324: ; Returns:
                            	  4325: ;		d0 = length of string
                            	  4326: ;------------------------------------------------------------------------------
                            	  4327: 
                            	  4328: ;  // pad right
                            	  4329: ;  if (width < 0) {
                            	  4330: ;    width = -width;
                            	  4331: ;    while (ndx < width) {
                            	  4332: ;      buf[ndx]=' ';
                            	  4333: ;      ndx++;
                            	  4334: ;    }
                            	  4335: ;    buf[ndx]='\0';
                            	  4336: ;  }
                            	  4337: ;  return (ndx);
                            	  4338: 
                            	  4339: _PadRight:
02:00006DF8 4A3900040508    	  4340: 	tst.b _width
02:00006DFE 6A24            	  4341: 	bpl .0042
02:00006E00 443900040508    	  4342: 	neg.b _width
02:00006E06 2008            	  4343: 	move.l a0,d0
02:00006E08 90BC00040520    	  4344: 	sub.l #_fpBuf,d0	; d0 = ndx
                            	  4345: .0044
02:00006E0E B03900040508    	  4346: 	cmp.b _width,d0
02:00006E14 6C0A            	  4347: 	bge .0043
02:00006E16 11BC00200000    	  4348: 	move.b #' ',(a0,d0.w)
02:00006E1C 5240            	  4349: 	addi.w #1,d0
02:00006E1E 60EE            	  4350: 	bra .0044
                            	  4351: .0043
02:00006E20 42300000        	  4352: 	move.b #0,(a0,d0.w)
                            	  4353: .0042
02:00006E24 4880            	  4354: 	ext.w d0
02:00006E26 48C0            	  4355: 	ext.l d0
02:00006E28 4E75            	  4356: 	rts
                            	  4357: 
                            	  4358: ;------------------------------------------------------------------------------
                            	  4359: ;------------------------------------------------------------------------------
                            	  4360: 
                            	  4361: _IsZero:
02:00006E2A 7000            	  4362: 	clr.l d0								; d0 = 0
02:00006E2C 103900040600    	  4363: 	move.b _fpWork,d0				; get sign, combo
02:00006E32 0200007F        	  4364: 	andi.b #$7f,d0					; ignore sign bit
02:00006E36 803900040601    	  4365: 	or.b _fpWork+1,d0				; check all bytes for zero
02:00006E3C 807900040602    	  4366: 	or.w _fpWork+2,d0
02:00006E42 807900040604    	  4367: 	or.w _fpWork+4,d0
02:00006E48 807900040606    	  4368: 	or.w _fpWork+6,d0
02:00006E4E 807900040608    	  4369: 	or.w _fpWork+8,d0
02:00006E54 80790004060A    	  4370: 	or.w _fpWork+10,d0
02:00006E5A 4E75            	  4371: 	rts
                            	  4372: 
                            	  4373: ;------------------------------------------------------------------------------
                            	  4374: ; Output a string representation of a decimal floating point number to a 
                            	  4375: ; buffer.
                            	  4376: ;
                            	  4377: ; Parameters:
                            	  4378: ;		fp0 = number to convert
                            	  4379: ;------------------------------------------------------------------------------
                            	  4380: 
                            	  4381: _sprtflt:
02:00006E5C F2396C0000040600	  4382: 	fmove.p fp0,_fpWork
02:00006E64 103900040600    	  4383: 	move.b _fpWork,d0				; get sign+combo
02:00006E6A 0200007C        	  4384: 	andi.b #$7C,d0					; mask for combo bits
02:00006E6E 0C00007C        	  4385: 	cmpi.b #$7C,d0					; is it the Nan combo?
02:00006E72 660A            	  4386: 	bne .notNan
02:00006E74 23FAFD2E00040520	  4387: 	move.l _msgNan,_fpBuf		; output "Nan"
02:00006E7C 4E75            	  4388: 	rts
                            	  4389: .notNan
02:00006E7E 0C000078        	  4390: 	cmpi.b #$78,d0					; is it infinity combo?
02:00006E82 660A            	  4391: 	bne .notInf
02:00006E84 23FAFD2200040520	  4392: 	move.l _msgInf,_fpBuf		; output "Inf"
02:00006E8C 4E75            	  4393: 	rts
                            	  4394: .notInf
                            	  4395: .0001
02:00006E8E 41F900040520    	  4396: 	lea _fpBuf,a0						; a0 = pointer to string buffer
02:00006E94 4A3900040600    	  4397: 	tst.b _fpWork						; is number negative?
02:00006E9A 6A04            	  4398: 	bpl .0002
02:00006E9C 10FC002D        	  4399: 	move.b #'-',(a0)+				; yes, output '-'
                            	  4400: .0002
02:00006EA0 6188            	  4401: 	bsr _IsZero							; check if number is zero
02:00006EA2 4A40            	  4402: 	tst.w d0
02:00006EA4 6608            	  4403: 	bne .0003
02:00006EA6 10FC0030        	  4404: 	move.b #'0',(a0)+				; if zero output "0"
02:00006EAA 4218            	  4405: 	clr.b (a0)+
02:00006EAC 4E75            	  4406: 	rts	
                            	  4407: 	; Now the fun begins
                            	  4408: .0003
02:00006EAE 7C00            	  4409: 	clr.l d6
02:00006EB0 6100FCFA        	  4410: 	bsr _MakeBig
02:00006EB4 6100FD18        	  4411: 	bsr _LessThanDbl
02:00006EB8 6100FD58        	  4412: 	bsr _ComputeDigitsBeforeDecpt
02:00006EBC 6100FD86        	  4413: 	bsr _LeadingZero
02:00006EC0 6100FD92        	  4414: 	bsr _SpitOutDigits
02:00006EC4 6100FE12        	  4415: 	bsr _TrimTrailingZeros
                            	  4416: 
                            	  4417: 	; If the number ends with a '.' remove the '.'
02:00006EC8 0C28002EFFFF    	  4418: 	cmpi.b #'.',-1(a0)
02:00006ECE 6606            	  4419: 	bne .0005
02:00006ED0 4228FFFF        	  4420: 	move.b #0,-1(a0)
02:00006ED4 5348            	  4421: 	subq #1,a0
                            	  4422: 
                            	  4423: .0005
                            	  4424: 	; If the number ends in .0 get rid of the .0
02:00006ED6 0C280030FFFF    	  4425: 	cmpi.b #'0',-1(a0)
02:00006EDC 660E            	  4426: 	bne .0004
02:00006EDE 0C28002EFFFE    	  4427: 	cmpi.b #'.',-2(a0)
02:00006EE4 6606            	  4428: 	bne .0004
02:00006EE6 4228FFFE        	  4429: 	move.b #0,-2(a0)
02:00006EEA 5348            	  4430: 	subq #1,a0
                            	  4431: .0004
                            	  4432: 
                            	  4433: ;	// Make sure we have at least one digit after the decimal point.
                            	  4434: ;	if (buf[ndx-1]=='.') {
                            	  4435: ;		buf[ndx]='0';
                            	  4436: ;		ndx++;
                            	  4437: ;    buf[ndx]='\0';
                            	  4438: ;	}
                            	  4439: 
02:00006EEC 0C28002EFFFF    	  4440: 	cmpi.b #'.',-1(a0)
02:00006EF2 6606            	  4441: 	bne .0019
02:00006EF4 10F80030        	  4442: 	move.b '0',(a0)+
02:00006EF8 4210            	  4443: 	move.b #0,(a0)
                            	  4444: .0019
                            	  4445: 
                            	  4446: ;	// If the number is times 10^0 don't output the exponent
                            	  4447: ;  if (exp==0) {
                            	  4448: ;    buf[ndx]='\0';
                            	  4449: ;    goto prt;
                            	  4450: ;  }
                            	  4451: 	
02:00006EFA 4A46            	  4452: 	tst.w d6
02:00006EFC 6604            	  4453: 	bne .0020
02:00006EFE 4210            	  4454: 	move.b #0,(a0)			; NULL terminate string
02:00006F00 6008            	  4455: 	bra .prt						; goto padding number
                            	  4456: .0020
                            	  4457: 
02:00006F02 6100FDE0        	  4458: 	bsr _SpitOutE
02:00006F06 6100FDF4        	  4459: 	bsr _ExtractExpDigits
                            	  4460: 
                            	  4461: .prt
02:00006F0A 6100FEA4        	  4462: 	bsr _PadLeft
02:00006F0E 6000FEE8        	  4463: 	bra _PadRight
                            	  4464: 
                            	  4465: ;------------------------------------------------------------------------------
                            	  4466: ; Trap #15, function 39
                            	  4467: ;
                            	  4468: ; Parameters
                            	  4469: ;		fp0 0 number to print
                            	  4470: ;		d1 = width of print field
                            	  4471: ;		d2 = precision
                            	  4472: ;		d3 = 'E' or 'e'
                            	  4473: ;------------------------------------------------------------------------------
                            	  4474: 
                            	  4475: prtflt:
02:00006F12 48E7E040        	  4476: 	movem.l d0/d1/d2/a1,-(a7)
02:00006F16 F2276C00        	  4477: 	fmove.p fp0,-(a7)
02:00006F1A 13C100040508    	  4478: 	move.b d1,_width
02:00006F20 23C200040514    	  4479: 	move.l d2,_precision
02:00006F26 13C30004050C    	  4480: 	move.b d3,_E
02:00006F2C 6100FF2E        	  4481: 	bsr _sprtflt
02:00006F30 43F900040520    	  4482: 	lea _fpBuf,a1
02:00006F36 6100E1EC        	  4483: 	bsr DisplayString
02:00006F3A F21F4C00        	  4484: 	fmove.p (a7)+,fp0
02:00006F3E 4CDF0207        	  4485: 	movem.l (a7)+,d0/d1/d2/a1
02:00006F42 4E75            	  4486: 	rts
                            	  4487: 
                            	  4488: ;------------------------------------------------------------------------------
                            	  4489: ;------------------------------------------------------------------------------
                            	  4490: 
                            	  4491: InitIRQ:
02:00006F44 7006            	  4492: 	moveq		#6,d0
02:00006F46 41FAE896        	  4493: 	lea			KeybdIRQ,a0
02:00006F4A 610C            	  4494: 	bsr			InstallIRQ
02:00006F4C 41FA003A        	  4495: 	lea			TickIRQ,a0
02:00006F50 6106            	  4496: 	bsr			InstallIRQ
02:00006F52 7003            	  4497: 	moveq		#3,d0
02:00006F54 41FAF7FC        	  4498: 	lea			SerialIRQ,a0
                            	  4499: 	; fall through
                            	  4500: 
                            	  4501: ;------------------------------------------------------------------------------
                            	  4502: ; Install an IRQ handler.
                            	  4503: ;
                            	  4504: ; Parameters:
                            	  4505: ;		d0 = IRQ level
                            	  4506: ;		a0 = pointer to IRQ routine
                            	  4507: ; Returns:
                            	  4508: ;		d1 = -1 if successfully added, 0 otherwise
                            	  4509: ;		nf = 1, zf = 0 if successfully added, otherwise nf = 0, zf = 1
                            	  4510: ;------------------------------------------------------------------------------
                            	  4511: 
                            	  4512: InstallIRQ:
02:00006F58 2F00            	  4513: 	move.l	d0,-(a7)					; save working register
02:00006F5A 43F80400        	  4514: 	lea			InstalledIRQ,a1		; a1 points to installed IRQ list
02:00006F5E EB48            	  4515: 	lsl.w		#5,d0							; multiply by 8 long words per IRQ level
                            	  4516: .nextSpot:
02:00006F60 B1F10000        	  4517: 	cmpa.l	(a1,d0.w),a0			; Is the IRQ already installed?
02:00006F64 6716            	  4518: 	beq.s		.found
02:00006F66 4AB10000        	  4519: 	tst.l		(a1,d0.w)					; test for an empty spot
02:00006F6A 670C            	  4520: 	beq.s		.foundSpot
02:00006F6C 5840            	  4521: 	addi.w	#4,d0							; increment to next slot
02:00006F6E 3200            	  4522: 	move.w	d0,d1
02:00006F70 0241001F        	  4523: 	andi.w	#$1F,d1						; check to see if spots exhausted
02:00006F74 670C            	  4524: 	beq.s		.noEmpties
02:00006F76 60E8            	  4525: 	bra.s		.nextSpot
                            	  4526: .foundSpot:
02:00006F78 23880000        	  4527: 	move.l	a0,(a1,d0.w)			; add IRQ routine to table
                            	  4528: .found:
02:00006F7C 201F            	  4529: 	move.l	(a7)+,d0
02:00006F7E 72FF            	  4530: 	moveq		#-1,d1						; return success
02:00006F80 4E75            	  4531: 	rts
                            	  4532: .noEmpties:
02:00006F82 201F            	  4533: 	move.l	(a7)+,d0
02:00006F84 7200            	  4534: 	moveq		#0,d1							; return failed to add
02:00006F86 4E75            	  4535: 	rts
                            	  4536: 	
                            	  4537: 
                            	  4538: ;------------------------------------------------------------------------------
                            	  4539: ;------------------------------------------------------------------------------
                            	  4540: 
                            	  4541: TickIRQ:
02:00006F88 46FC2600        	  4542: 	move.w	#$2600,sr					; disable lower level IRQs
02:00006F8C 48E76080        	  4543: 	movem.l	d1/d2/a0,-(a7)
                            	  4544: 	; ToDo: detect a tick interrupt
                            	  4545: ;	move.l	PLIC+$00,d1
                            	  4546: ;	rol.l		#8,d1
                            	  4547: ;	cmpi.b	#29,d1
                            	  4548: ;	bne.s		.notTick
02:00006F90 4E7A1FE0        	  4549: 	movec		coreno,d1					; d1 = core number
02:00006F94 0C010002        	  4550: 	cmpi.b	#2,d1
02:00006F98 660A            	  4551: 	bne.s		.0001
02:00006F9A 23FC1D000000FD09	  4552: 	move.l	#$1D000000,PLIC+$14	; reset edge sense circuit
02:00006FA2 0014
                            	  4553: .0001:	
02:00006FA4 207900040004    	  4554: 	move.l	TextScr,a0				; a0 = screen address
02:00006FAA 2410            	  4555: 	move.l	(a0),d2
02:00006FAC E15A            	  4556: 	rol.w		#8,d2							; reverse byte order of d2
02:00006FAE 4842            	  4557: 	swap		d2
02:00006FB0 E15A            	  4558: 	rol.w		#8,d2
02:00006FB2 06010030        	  4559: 	addi.b	#'0',d1						; binary to ascii core number
02:00006FB6 D202            	  4560: 	add.b		d2,d1
02:00006FB8 E159            	  4561: 	rol.w		#8,d1							; put bytes back in order
02:00006FBA 4841            	  4562: 	swap		d1
02:00006FBC E159            	  4563: 	rol.w		#8,d1
02:00006FBE 21410004        	  4564: 	move.l	d1,4(a0)					; update onscreen IRQ flag
02:00006FC2 5290            	  4565: 	addi.l	#1,(a0)						; flashy colors
                            	  4566: ; addi.l	#1,40(a0)					; nice effect
02:00006FC4 6100FB70        	  4567: 	bsr			ReceiveMsg
02:00006FC8 4CDF0106        	  4568: 	movem.l	(a7)+,d1/d2/a0
02:00006FCC 4E73            	  4569: 	rte
                            	  4570: ;.notTick:
                            	  4571: ;	movem.l	(a7)+,d1/a0
                            	  4572: ;	rte
                            	  4573: ;------------------------------------------------------------------------------
                            	  4574: ;------------------------------------------------------------------------------
                            	  4575: 
                            	  4576: irq3_rout:
02:00006FCE 48E7C0C0        	  4577: 	movem.l	d0/d1/a0/a1,-(a7)
02:00006FD2 41F80460        	  4578: 	lea			InstalledIRQ+8*4*3,a0
02:00006FD6 6008            	  4579: 	bra			irq_rout
                            	  4580: 
                            	  4581: irq6_rout:
02:00006FD8 48E7C0C0        	  4582: 	movem.l	d0/d1/a0/a1,-(a7)
02:00006FDC 41F804C0        	  4583: 	lea			InstalledIRQ+8*4*6,a0
                            	  4584: irq_rout:
02:00006FE0 7007            	  4585: 	moveq		#7,d0
                            	  4586: .nextHandler:
02:00006FE2 2258            	  4587: 	move.l	(a0)+,a1
02:00006FE4 6706            	  4588: 	beq.s		.0003
02:00006FE6 4E91            	  4589: 	jsr			(a1)
02:00006FE8 4A81            	  4590: 	tst.l		d1								; was IRQ handled?
02:00006FEA 6B04            	  4591: 	bmi.s		.0002							; first one to return handled quits loop
                            	  4592: .0003:
02:00006FEC 51C8FFF4        	  4593: 	dbra		d0,.nextHandler
                            	  4594: .0002:
02:00006FF0 4CDF0303        	  4595: 	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  4596: 
                            	  4597: SpuriousIRQ:
02:00006FF4 4E73            	  4598: 	rte
                            	  4599: 
                            	  4600: ;	bsr			KeybdIRQ
                            	  4601: ;	tst.l		d1								; handled by KeybdIRQ?
                            	  4602: ;	bmi.s		.0002							; if yes, go return
                            	  4603: ;.0001:
                            	  4604: ;	move.l	#$1D000000,PLIC+$14	; reset edge sense circuit
                            	  4605: ;	move.l	TextScr,a0				; a0 = screen address
                            	  4606: ;	addi.l	#1,40(a0)					; update onscreen IRQ flag
                            	  4607: ;.0002:	
                            	  4608: ;	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  4609: ;	rte
                            	  4610: 
                            	  4611: nmi_rout:
02:00006FF6 48E7C080        	  4612: 	movem.l	d0/d1/a0,-(a7)
02:00006FFA 123C004E        	  4613: 	move.b	#'N',d1
02:00006FFE 6100DEAA        	  4614: 	bsr			DisplayChar
02:00007002 4CDF0103        	  4615: 	movem.l	(a7)+,d0/d1/a0		; return
02:00007006 4E73            	  4616: 	rte
                            	  4617: 
                            	  4618: brdisp_trap:
02:00007008 48F9FFFF00040100	  4619: 	movem.l	d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
02:00007010 33DF00040140    	  4620: 	move.w	(a7)+,Regsave+$40
02:00007016 23DF00040144    	  4621: 	move.l	(a7)+,Regsave+$44
02:0000701C 2E7C00040FFC    	  4622: 	move.l	#$40FFC,a7			; reset stack pointer
02:00007022 46FC2500        	  4623: 	move.w	#$2500,sr				; enable interrupts
02:00007026 43FA008C        	  4624: 	lea			msg_bad_branch_disp,a1
02:0000702A 6100E0F8        	  4625: 	bsr			DisplayString
02:0000702E 6100F2B2        	  4626: 	bsr			DisplaySpace
02:00007032 223900040144    	  4627: 	move.l	Regsave+$44,d1	; exception address
02:00007038 6100F2B0        	  4628: 	bsr			DisplayTetra		; and display it
                            	  4629: ;	move.l	(sp)+,d1				; pop format word 68010 mode only
02:0000703C 6000F162        	  4630: 	bra			cmdDumpRegs
                            	  4631: 
                            	  4632: illegal_trap:
02:00007040 544F            	  4633: 	addq		#2,sp						; get rid of sr
02:00007042 221F            	  4634: 	move.l	(sp)+,d1				; pop exception address
02:00007044 6100F2A4        	  4635: 	bsr			DisplayTetra		; and display it
02:00007048 43FA0058        	  4636: 	lea			msg_illegal,a1	; followed by message
02:0000704C 6100E0D6        	  4637: 	bsr			DisplayString
                            	  4638: .0001:
02:00007050 60FE            	  4639: 	bra			.0001
02:00007052 6000EB8C        	  4640: 	bra			Monitor
                            	  4641: 	
                            	  4642: io_irq:
02:00007056 544F            	  4643: 	addq #2,sp
02:00007058 221F            	  4644: 	move.l (sp)+,d1
02:0000705A 6100F28E        	  4645: 	bsr DisplayTetra
02:0000705E 43FA0076        	  4646: 	lea msg_io_access,a1
02:00007062 6100E0C0        	  4647: 	bsr DisplayString
02:00007066 6000F138        	  4648: 	bra cmdDumpRegs
                            	  4649: 
                            	  4650: ; -----------------------------------------------------------------------------
                            	  4651: ; -----------------------------------------------------------------------------
                            	  4652: 
                            	  4653: msg_start:
02:0000706A 46656D74696B6920	  4654: 	dc.b	"Femtiki rf68k Multi-core OS Starting",LF,CR,0
02:00007072 726636386B204D75
02:0000707A 6C74692D636F7265
02:00007082 204F532053746172
02:0000708A 74696E67
02:0000708E 0A
02:0000708F 0D
02:00007090 00
                            	  4655: ;	dc.b	"rf68k System Starting",CR,LF,0
                            	  4656: msg_core_start:
02:00007091 20636F7265207374	  4657: 	dc.b	" core starting",CR,LF,0
02:00007099 617274696E67
02:0000709F 0D
02:000070A0 0A
02:000070A1 00
                            	  4658: msg_illegal:
02:000070A2 20696C6C6567616C	  4659: 	dc.b	" illegal opcode",CR,LF,0
02:000070AA 206F70636F6465
02:000070B1 0D
02:000070B2 0A
02:000070B3 00
                            	  4660: msg_bad_branch_disp:
02:000070B4 206272616E636820	  4661: 	dc.b	" branch selfref: ",0
02:000070BC 73656C667265663A
02:000070C4 20
02:000070C5 00
                            	  4662: msg_test_done:
02:000070C6 2043505520746573	  4663: 	dc.b	" CPU test done.",0
02:000070CE 7420646F6E652E
02:000070D5 00
                            	  4664: msg_io_access
02:000070D6 20756E7065726D69	  4665: 	dc.b " unpermitted access to I/O",0
02:000070DE 7474656420616363
02:000070E6 65737320746F2049
02:000070EE 2F4F
02:000070F0 00
                            	  4666: 
                            	  4667: 
                            	  4668: 


Symbols by name:
ABCD_INNER1                     02:00002622
ABCD_INNER2                     02:00002690
ABCD_NO_C1                      02:0000263E
ABCD_NO_C2                      02:00002646
ABCD_NO_C3                      02:000026AC
ABCD_NO_C4                      02:000026B4
ABCD_OUTER1                     02:00002620
ABCD_OUTER2                     02:0000268E
ABS                             02:0000467A
ABSRT                           02:00004688
ACIA                             E:FD060000
ACIA_CMD                         E:00000008
ACIA_CTRL                        E:0000000C
ACIA_RX                          E:00000000
ACIA_STAT                        E:00000004
ACIA_TX                          E:00000000
ADDA_OUTER1                     02:00003190
ADDQ_LOOP1                      02:000029AA
ADDQ_LOOP2                      02:000029E8
ADDQ_LOOP3                      02:00002A1E
ADDX_LOOP3                      02:000032B6
ADDX_LOOP4                      02:000032D2
ADDX_LOOP5                      02:000032EE
ADDX_OUTER1                     02:00003222
ADD_OUTER1                      02:00002FB6
ADD_OUTER2                      02:0000302A
AHOW                            02:00004724
ALL_DONE                        02:00000394
AND_OUTER1                      02:00002CD4
AND_OUTER2                      02:00002D48
ASORRY                          02:0000471C
AUXIN                           02:00004A50
AUXOUT                          02:00004A40
AWHAT                           02:000046DC
AXIRET                          02:00004A6E
ArmAllBreakpoints               02:000069C4
ArmBreakpoint                   02:000069F4
AsciiToHexNybble                02:00006296
AudioInputTest                  02:000065FE
BCC1                            02:000028C8
BCC10                           02:0000291A
BCC11                           02:00002922
BCC12                           02:0000292C
BCC13                           02:00002934
BCC14                           02:0000293E
BCC2                            02:000028D2
BCC3                            02:000028DA
BCC4                            02:000028E4
BCC5                            02:000028EC
BCC6                            02:000028F6
BCC7                            02:000028FE
BCC8                            02:00002908
BCC9                            02:00002910
BSR_CLOSE1                      02:00001468
BSR_CLOSE2                      02:0000149E
BSR_FAR1                        02:00000396
BSR_FAR2                        02:000028B8
BUFFER                          02:00004AF2
BUFLEN                           E:00000050
BYEBYE                          02:00004A70
BlankLastLine                   02:000050C0
BouncingBalls                   02:00006600
BreakpointWords                  E:00040280
Breakpoints                      E:00040220
CALL                            02:00004472
CHKIO                           02:000049E6
CHKRET                          02:000049F6
CLMSG                           02:00004AB6
CMPA_OUTER1                     02:00002EAA
CMPM_LOOP1                      02:00002F38
CMPM_LOOP2                      02:00002F52
CMPM_LOOP3                      02:00002F6C
CMP_OUTER1                      02:00002E34
CR                               E:0000000D
CRLF                            02:00004E60
CSTART                          02:00003E14
CTRLC                            E:00000003
CTRLH                            E:00000008
CTRLS                            E:00000013
CTRLX                            E:00000018
CTRLZ                            E:0000001A
CURRNT                          02:00004AC6
CalcScreenLoc                   02:00004E9C
CallOS                          02:00004B88
CheckForCtrlC                   02:0000551A
CheckForKey                     02:000054D6
ClearBreakpointList             02:00006AE6
ClearScreen                     02:00006604
CmdBuf                           E:00040040
CmdBufEnd                        E:00040080
Cursor1                         02:00005258
CursorCol                        E:00040001
CursorRow                        E:00040000
DBCC_LOOP1                      02:00002948
DBCC_LOOP2                      02:00002956
DEFLT                           02:00004366
DIRECT                          02:0000402E
DIV1                            02:00004610
DIV2                            02:00004616
DIV3                            02:0000461C
DIV32                           02:000045FE
DIV4                            02:0000462A
DIVRT                           02:00004638
DIVS_OUTER1                     02:00002B94
DIVU_OUTER1                     02:00002B42
DOQUO                           02:000049C4
DOQUO1                          02:000049CC
Delay3s                         02:00000272
Delay3s2                        02:00000296
DisarmAllBreakpoints            02:00006998
DisarmBreakpoint                02:00006A72
DispatchMsg                     02:00006B78
DisplayAddr                     02:00006316
DisplayByte                     02:000062F6
DisplayChar                     02:00004EAA
DisplayHelp                     02:00005D9C
DisplayMem                      02:00006144
DisplayNybble                   02:000062FC
DisplaySpace                    02:000062E2
DisplayString                   02:00005124
DisplayStringCRLF               02:0000513A
DisplayStringLimited            02:00005140
DisplayStringLimitedCRLF        02:00005160
DisplayTetra                    02:000062EA
DisplayTwoSpaces                02:000062D0
DisplayWyde                     02:000062F0
DumpMem1                        02:00006132
ENDCHK                          02:000046C8
ENDCHK1                         02:000046D8
ENDMEM                          02:00003E10
EOR_OUTER2                      02:00002DBE
ERROR                           02:000046E0
EX1                             02:00004060
EXCEPTION_6                     02:0000039E
EXCEPTION_7                     02:000003A6
EXEC                            02:00004036
EXGO                            02:0000406C
EXLP                            02:0000403E
EXMAT                           02:00004066
EXNGO                           02:00004048
EXP4RT                          02:0000454C
EXPR                            02:00004486
EXPR2                           02:000044DA
EXPR3                           02:0000450E
EXPR4                           02:00004536
ExecuteCode                     02:00006104
FI1                             02:000046BA
FI2                             02:000046C6
FIN                             02:000046AE
FINISH                          02:000041B4
FNDLN                           02:000047C8
FNDLNP                          02:000047D6
FNDNXT                          02:000047EE
FNDRET                          02:000047EC
FNDSKP                          02:000047F0
FOR                             02:0000420A
FR1                             02:00004224
FR2                             02:0000423A
FR3                             02:00004240
FR4                             02:00004242
FR5                             02:00004248
FR6                             02:0000425A
FR7                             02:0000425E
FR8                             02:00004278
FemtikiInit                     02:00004B42
FemtikiInitIRQ                  02:00004B78
FemtikiTimerIRQ                 02:00004D6C
ForceUnlockSemaphore            02:00000230
FromScreen                      02:00005BCC
GBYTE                           02:000043BC
GBYTE1                          02:000043C0
GBYTE2                          02:000043CE
GETLN                           02:0000472A
GL1                             02:0000473A
GL2                             02:00004758
GL3                             02:0000476C
GL4                             02:00004790
GL5                             02:0000479C
GL6                             02:000047B8
GL7                             02:000047C0
GOAUXI                          02:00003E04
GOAUXO                          02:00003E00
GOBYE                           02:00003E08
GOIN                            02:00003DFC
GOOUT                           02:00003DF8
GOSUB                           02:000041BC
GOTO                            02:00004110
GOWARM                          02:00003DF6
GetCmdLine                      02:00005F1E
GetHexNumber                    02:0000626A
GetKey                          02:000054E2
GetRunningTCBPointer            02:00004BF2
GraphicsDemo                    02:00006602
HAS_MMU                          E:00000000
HOWMSG                          02:00004AA1
HelpMsg                         02:00005DA8
HomeCursor                      02:00005166
I2C2                             E:FD069000
I2C_CMD                          E:00000004
I2C_CTRL                         E:00000002
I2C_PREH                         E:00000001
I2C_PREL                         E:00000000
I2C_RXR                          E:00000003
I2C_STAT                         E:00000004
I2C_TXR                          E:00000003
IF                              02:000042D0
IF1                             02:000042D4
IF2                             02:000042DA
IGB1                            02:00004996
IGBRET                          02:0000499A
IGNBLK                          02:00004990
INC                             02:00004A20
INC1                            02:00004A2C
INCOM                           02:00004080
INCON                           02:00004072
INITMSG                         02:00004A74
INPERR                          02:000042EA
INPPTR                          02:00004ABE
INPUT                           02:000042F8
IOCOM                           02:0000408E
IOCON                           02:000040A6
IOFocus                          E:00100000
IP2                             02:0000430A
IP3                             02:00004324
IP4                             02:00004358
IP5                             02:00004362
IncCursorPos                    02:00005022
IncCursorRow                    02:00005042
InitIOPBitmap                   02:00000112
InitIRQ                         02:00006F44
InitRand                        02:00000162
InitSemaphores                  02:000001E8
InsertIntoReadyQueue            02:00004C5E
InstallIRQ                      02:00006F58
InstalledIRQ                     A:00000400
KEYBD                            E:FD0FFE00
KEYBD_SEMA                       E:00000003
KeybdEcho                        E:0004000C
KeybdGetChar                    02:00005536
KeybdGetCharNoWait              02:00005526
KeybdGetCharWait                02:0000552E
KeybdGetID                      02:00005304
KeybdID                          E:00100016
KeybdIRQ                        02:000057DE
KeybdInit                       02:0000536E
KeybdLEDs                        E:0010000E
KeybdRecvByte                   02:00005488
KeybdSendByte                   02:0000579E
KeybdSetLED                     02:00005342
KeybdSetLEDStatus               02:0000574E
KeybdWaitFlag                    E:0004000D
KeybdWaitTx                     02:000054A8
LEA1                            02:00001E74
LET                             02:0000436C
LF                               E:0000000A
LIST                            02:00004124
LOAD                            02:0000437C
LOD1                            02:00004388
LOD2                            02:000043A2
LODEND                          02:000043B2
LOPINC                          02:00004AD6
LOPLMT                          02:00004ADA
LOPLN                           02:00004ADE
LOPPT                           02:00004AE2
LOPVAR                          02:00004AD2
LS1                             02:00004130
LS2                             02:00004144
LS3                             02:0000414A
LSTROM                          02:00004ABA
LT1                             02:00004378
ListBreakpoints                 02:00006AC6
LockSemaphore                   02:0000020E
MAX_TID                          E:00000FFF
MEMORY_SEMA                      E:00000006
MLT1                            02:000045C6
MLT2                            02:000045CC
MLT3                            02:000045E0
MLTRET                          02:000045FC
MMU                              E:FDC00000
MOVE1                           02:00001AE2
MOVE2                           02:00001A66
MOVE3                           02:00001B62
MOVE4                           02:00001CBC
MULS_OUTER1                     02:0000348A
MULT32                          02:000045BC
MULU_OUTER1                     02:0000343E
MVDOWN                          02:00004808
MVRET                           02:00004806
MVUP                            02:000047FE
Monitor                         02:00005BE0
NBCD_LOOP                       02:00002808
NBCD_LOOP1                      02:0000284E
NBCD_NO_C                       02:00002814
NBCD_NO_C1                      02:00002862
NBCD_NO_Z                       02:00002818
NBCD_NO_Z1                      02:00002866
NEW                             02:000040BE
NEXT                            02:0000427C
NR_TCB                           E:00001000
NX0                             02:00004286
NX1                             02:000042B2
NX2                             02:000042C6
NX3                             02:00004298
NextRec                         02:000063F4
NumSetBreakpoints                E:00040202
OKMSG                           02:00004A9A
OR_OUTER1                       02:00002BEA
OR_OUTER2                       02:00002C5E
OSCallTable                     02:00004B86
OUTC                            02:00004A04
OUTC1                           02:00004A10
OUTCOM                          02:00004098
OUTCON                          02:000040B0
OUTPTR                          02:00004AC2
PARN                            02:00004558
PBYTE                           02:0000443A
PBYTE1                          02:0000443C
PBYTE2                          02:00004450
PEEK                            02:0000463A
PKER                            02:0000446E
PLIC                             E:FD090000
PN1                             02:000048C4
PN3                             02:000048FE
PN4                             02:0000490A
PN5                             02:00004916
PNOV                            02:000048D4
PNRET                           02:00004924
POKE                            02:0000445A
POPA                            02:00004810
PP1                             02:00004832
PR0                             02:0000416E
PR1                             02:0000417C
PR2                             02:00004160
PR3                             02:00004192
PR4                             02:0000418C
PR6                             02:0000419E
PR8                             02:000041A4
PRINT                           02:00004150
PRMESG                          02:000049F8
PRMRET                          02:00004A02
PRTLN                           02:00004928
PRTNUM                          02:000048B4
PRTRET                          02:00004874
PRTSTG                          02:0000485A
PS1                             02:0000485C
PU1                             02:00004856
PUSHA                           02:00004834
PointerToTCBHandle              02:00004C28
PopReadyQueue                   02:00004CCC
ProcessBreakpoint               02:00006992
ProcessRec                      02:00006406
ProcessS1                       02:00006508
ProcessS2                       02:0000650C
ProcessS3                       02:00006510
ProcessS7                       02:00006514
ProcessS8                       02:00006524
ProcessS9                       02:00006534
Prompt1                         02:00005C1E
Prompt3                         02:00005C08
PromptLn                        02:00005BFC
QHOW                            02:00004722
QSORRY                          02:0000471A
QT1                             02:00004880
QT2                             02:00004890
QT3                             02:00004894
QT4                             02:000048A0
QT5                             02:000048B2
QTSTG                           02:00004876
QWHAT                           02:000046DA
QueueCycle                       E:0010031C
RA1                             02:00004666
RAND_MW                          E:FD0FFD0C
RAND_MZ                          E:FD0FFD08
RAND_NUM                         E:FD0FFD00
RAND_SEMA                        E:00000004
RAND_STRM                        E:FD0FFD04
RANPNT                          02:00004ABA
REM                             02:000042CE
RETURN                          02:000041E8
RND                             02:00004646
ROXx_FLAGS                      02:00003752
ROXx_LOOP1                      02:00003768
ROXx_LOOP2                      02:00003788
ROXx_LOOP3                      02:000037A8
ROXx_LOOP4                      02:000037C8
ROXx_LOOP5                      02:000037E8
ROXx_LOOP6                      02:0000380A
ROx_FLAGS                       02:0000351C
ROx_LOOP1                       02:00003532
ROx_LOOP2                       02:00003552
ROx_LOOP3                       02:00003572
ROx_LOOP4                       02:00003592
ROx_LOOP5                       02:000035B2
ROx_LOOP6                       02:000035D4
RST_REG                          E:FD0FFC00
RTCBuf                           E:00100200
RTR_DONE                        02:000028AA
RUN                             02:000040D2
RUNNXL                          02:000040E0
RUNSML                          02:00004100
RUNTSL                          02:000040F6
RandGetNum                      02:000001A2
RandInit                        02:00000162
RandWait                        02:000001D2
ReceiveMsg                      02:00006B36
Regsave                          E:00040100
RemoveFromReadyQueue            02:00004CAE
RunningTCB                       E:00100224
S1932a                          02:0000657C
S1932b                          02:00006590
S19Checksum                      E:00100150
S19Get16BitAddress              02:00006544
S19Get24BitAddress              02:00006552
S19Get32BitAddress              02:0000655E
S19StartAddress                  E:00040008
SAVE                            02:000043DC
SAVE1                           02:000043E4
SAVE2                           02:00004408
SAVEND                          02:00004416
SBCD_INNER1                     02:0000271A
SBCD_INNER2                     02:00002788
SBCD_NO_C1                      02:00002736
SBCD_NO_C2                      02:0000273E
SBCD_NO_C3                      02:000027A4
SBCD_NO_C4                      02:000027AC
SBCD_OUTER1                     02:00002718
SBCD_OUTER2                     02:00002786
SCREEN_SEMA                      E:00000005
SC_ALT                           E:00000011
SC_CAPSLOCK                      E:00000058
SC_CTRL                          E:00000014
SC_EXTEND                        E:000000E0
SC_KEYUP                         E:000000F0
SC_LSHIFT                        E:00000012
SC_NUMLOCK                       E:00000077
SC_RSHIFT                        E:00000059
SC_SCROLLLOCK                    E:0000007E
SC_TAB                           E:0000000D
SERIAL_SEMA                      E:00000002
SETVAL                          02:00004694
SHIFTS2_FLAGS                   02:00003BCA
SHIFTS2_LOOP1                   02:00003BE0
SHIFTS2_LOOP2                   02:00003BFC
SHIFTS2_LOOP3                   02:00003C18
SHIFTS2_LOOP4                   02:00003C34
SHIFTS2_LOOP5                   02:00003C50
SHIFTS2_LOOP6                   02:00003C6E
SHIFTS_FLAGS                    02:00003988
SHIFTS_LOOP1                    02:0000399E
SHIFTS_LOOP2                    02:000039BE
SHIFTS_LOOP3                    02:000039DE
SHIFTS_LOOP4                    02:000039FE
SHIFTS_LOOP5                    02:00003A1E
SHIFTS_LOOP6                    02:00003A40
SIZE                            02:0000468A
SRYMSG                          02:00004AB0
ST3                             02:00003E78
ST4                             02:00003EC6
START                           02:00003DF4
STKGOS                          02:00004ACA
STKINP                          02:00004ACE
STKLMT                          02:00004AEE
STOP                            02:000040CA
SUBA_OUTER1                     02:000031DC
SUBQ_LOOP1                      02:00002A68
SUBQ_LOOP2                      02:00002AA2
SUBQ_LOOP3                      02:00002AD8
SUBX_LOOP3                      02:000033C6
SUBX_LOOP4                      02:000033E2
SUBX_LOOP5                      02:000033FE
SUBX_OUTER1                     02:00003332
SUB_OUTER1                      02:000030A0
SUB_OUTER2                      02:00003114
SV1                             02:000046AC
ScrollUp                        02:00005076
SelectThreadToRun               02:00004C38
SendMsg                         02:00006AF8
SerHeadRcv                       E:00100162
SerRcvBuf                        E:00101000
SerRcvXoff                       E:00100165
SerRcvXon                        E:00100164
SerTailRcv                       E:00100160
SerialGetChar                   02:00006644
SerialIRQ                       02:00006752
SerialInit                      02:00006612
SerialPeekChar                  02:000066BC
SerialPeekCharDirect            02:000066F4
SerialPutChar                   02:0000670E
SerialRbo                       02:0000672A
SerialRcvCount                  02:00006732
SetKeyboardEcho                 02:000054CE
SpuriousIRQ                     02:00006FF4
StartMon                        02:00005BD6
StartQ                          02:00004CC4
StubRout                        02:0000528E
SyncCursor                      02:00005178
T15DispatchTable                02:000051B8
T15LockSemaphore                02:00000266
T15UnlockSemaphore              02:0000026C
TAB1                            02:00003F00
TAB1_1                          02:00003F86
TAB2                            02:00003F2C
TAB2_1                          02:00003FB2
TAB4                            02:00003F64
TAB4_1                          02:00003FEE
TAB5                            02:00003F73
TAB5_1                          02:00004002
TAB6                            02:00003F76
TAB6_1                          02:0000400A
TAB8                            02:00003F7B
TAB8_1                          02:00004012
TC1                             02:00004954
TCBEndTick                       E:00000070
TCBHandleToPointer              02:00004C10
TCBNext                          E:0000007C
TCBPC                            E:00000050
TCBPrev                          E:00000080
TCBPriority                      E:00000055
TCBRegs                          E:00000004
TCBSR                            E:0000004C
TCBSSP                           E:00000048
TCBStartTick                     E:0000006C
TCBStatus                        E:00000054
TCBTicks                         E:00000074
TCBUSP                           E:00000044
TCB_SEMA                         E:00000007
TCB_SIZE                         E:00000100
TEXTREG                          E:FD03FF00
TN1                             02:00004960
TOASCII                         02:000048EE
TOUPB1                          02:000049A2
TOUPBRT                         02:000049C2
TOUPBUF                         02:0000499C
TOUPPER                         02:000049D4
TOUPRET                         02:000049E4
TRAP15                          02:000051A2
TSNMRET                         02:0000498E
TSTC                            02:00004942
TSTNUM                          02:0000495A
TSTV                            02:0000456E
TSTVRT                          02:000045BA
TS_PREEMPT                       E:00000020
TS_RUNNING                       E:00000080
TV1                             02:000045A4
TXT                             02:00004B42
TXTBGN                          02:00003E0C
TXTUNF                          02:00004AE6
TextCols                         E:0004008D
TextCurpos                       E:00040002
TextPos                          E:00040002
TextRows                         E:0004008C
TextScr                          E:00040004
TickIRQ                         02:00006F88
TimerStack                       E:00040BFC
UnlockSemaphore                 02:0000024A
UpdateIRQLive                   02:00004D4A
UpdateTextPos                   02:00004E72
VARBGN                          02:00004AEA
WHTMSG                          02:00004AA8
WSTART                          02:00003E58
Wait10ms                        02:000057A6
Wait300ms                       02:000057C2
XOFF                             E:00000013
XON                              E:00000011
XP11                            02:00004496
XP12                            02:0000449C
XP13                            02:000044A2
XP14                            02:000044A8
XP15                            02:000044AE
XP15RT                          02:000044B4
XP16                            02:000044B6
XP16RT                          02:000044BC
XP17                            02:000044C6
XP18                            02:000044CA
XP21                            02:000044E4
XP22                            02:000044EA
XP23                            02:000044EC
XP24                            02:000044F6
XP25                            02:00004500
XP26                            02:00004506
XP31                            02:00004510
XP34                            02:00004522
XP40                            02:00004542
XP41                            02:0000454E
XP42                            02:00004568
XP43                            02:0000456A
XPRT0                           02:000044BE
XPRT1                           02:000044C2
_ComputeDigitsBeforeDecpt       02:00006C12
_E                               E:0004050C
_ExtractExp1000sDigit           02:00006CFC
_ExtractExp100sDigit            02:00006D2A
_ExtractExp10sDigit             02:00006D58
_ExtractExp1sDigit              02:00006D88
_ExtractExpDigits               02:00006CFC
_IsZero                         02:00006E2A
_KeyState1                       E:0010000F
_KeyState2                       E:00100010
_KeybdBuf                        E:00100020
_KeybdCnt                        E:00100013
_KeybdGetScancode               02:00005478
_KeybdGetStatus                 02:0000546E
_KeybdHead                       E:00100011
_KeybdInit                      02:0000536E
_KeybdTail                       E:00100012
_LeadingZero                    02:00006C44
_LessThanDbl                    02:00006BCE
_MakeBig                        02:00006BAC
_PadLeft                        02:00006DB0
_PadRight                       02:00006DF8
_SpitOutDigits                  02:00006C54
_SpitOutE                       02:00006CE4
_TrimTrailingPoint              02:00006CCC
_TrimTrailingZeros              02:00006CD8
_dfMil                          02:00006B98
_dfOne                          02:00006B80
_dfTen                          02:00006B8C
_digit                           E:00040504
_digits_before_decpt             E:00040510
_fpBuf                           E:00040520
_fpWork                          E:00040600
_keybdControlCodes              02:00005A70
_keybdExtendedCodes             02:00005AF0
_msgInf                         02:00006BA8
_msgNan                         02:00006BA4
_precision                       E:00040514
_shiftedScanCodes               02:00005970
_sprtflt                        02:00006E5C
_unshiftedScanCodes             02:00005870
_width                           E:00040508
bkColor                          E:00040088
brdisp_trap                     02:00007008
bus_err                         02:00006950
clear_screen                    02:00004E10
cmdBreakpoint                   02:00005C76
cmdClearScreen                  02:00005CAE
cmdClock                        02:00005D2C
cmdCore                         02:00005CBA
cmdDispatch                     02:00005C30
cmdDumpMemory                   02:00006112
cmdDumpRegs                     02:000061A0
cmdEditMemory                   02:000060A4
cmdFillB                        02:00006026
cmdFillL                        02:0000606E
cmdFillW                        02:0000604A
cmdHelp                         02:00005D9C
cmdJump                         02:00006104
cmdLoadS19                      02:000063EE
cmdMonitor                      02:00005BE0
cmdReceiveSerial                02:00005FF2
cmdReset                        02:00005D4A
cmdSendSerial                   02:00005FC2
cmdString                       02:00005B70
cmdTable                        02:00005BA0
cmdTestCPU                      02:00005C9E
cmdTestFP                       02:00005CDE
cmdTestRAM                      02:00006334
cmdTestSerialReceive            02:0000624A
cmdTinyBasic                    02:00005C9A
cpu_test                        02:000002B2
dccr                            02:00004ED2
dclf                            02:00004FA2
dcx10                           02:00004F3A
dcx11                           02:00004F5C
dcx12                           02:00004F52
dcx14                           02:00004EC8
dcx16                           02:00004FA6
dcx4                            02:00004FAA
dcx6                            02:00004EF0
dcx7                            02:00004ECC
dcx8                            02:00004F06
dcx9                            02:00004F1C
dly3s1                          02:00000282
dly3s2                          02:00000280
doBackspace                     02:00004FB4
doCtrlX                         02:00004FFE
doDelete                        02:00004FC2
do_nothing                      02:0000010C
dspj1                           02:00005128
dspmem1                         02:00006154
dspspc1                         02:000062DA
dsret                           02:00005134
edtmem1                         02:000060AC
fgColor                          E:00040084
fpBuf                            E:000402C0
get_screen_address              02:00004E08
get_screen_color                02:00004DDC
gthx3                           02:000062CC
gthx5                           02:000062A8
gthx6                           02:000062BA
i2c_setup                       02:000067E2
i2c_wait_rx_nack                02:00006830
i2c_wait_tip                    02:000067F2
i2c_wr_cmd                      02:00006802
i2c_xmit1                       02:00006812
icc1                            02:00005074
ignBlanks                       02:00006092
illegal_trap                    02:00007040
init_i2c                        02:000067E2
init_plic                       02:000052CE
io_irq                          02:00007056
irq3_rout                       02:00006FCE
irq6_rout                       02:00006FD8
irq_rout                        02:00006FE0
kbdi0002                        02:00005396
kbdi0004                        02:00005402
kbdi0005                        02:0000541C
kbdiTryAgain                    02:000053F4
kbdiXmitBusy                    02:00005436
kgid1                           02:00005336
kgnotKbd                        02:0000533E
leds                             E:FD0FFF00
ledxit                          02:00005420
loop1                           02:000000DE
loop2                           02:000000DC
loop3                           02:00004E46
memend                           E:00100004
msgBadKeybd                     02:00005444
msgHello                        02:00005F0C
msgRtcReadFail                  02:00006936
msgUnknownCmd                   02:00005EFC
msgXmitBusy                     02:00005453
msg_bad_branch_disp             02:000070B4
msg_core_start                  02:00007091
msg_illegal                     02:000070A2
msg_io_access                   02:000070D6
msg_reglist                     02:00006224
msg_regs                        02:00006220
msg_start                       02:0000706A
msg_test_done                   02:000070C6
nmeSerial                       02:000067DA
nmi_rout                        02:00006FF6
notRxInt                        02:000067C8
numBreakpoints                   E:00000008
op_ABCD                         02:00002600
op_ADD                          02:00002F96
op_ADDA                         02:0000316A
op_ADDQ                         02:00002996
op_ADDX                         02:00003202
op_ADD_I                        02:0000168E
op_AND                          02:00002CB4
op_ANDI_TO_CCR                  02:0000043E
op_ANDI_TO_SR                   02:00000464
op_BCC                          02:000028C0
op_BCHG                         02:00000834
op_BCLR                         02:00000B9C
op_BOOL_I                       02:000012BE
op_BSET                         02:00000EEA
op_BSR                          02:00001470
op_BTST                         02:0000048A
op_BTST0                        02:00000614
op_BTST1                        02:00000620
op_BTST10                       02:00000668
op_BTST11                       02:00000670
op_BTST12                       02:00000676
op_BTST2                        02:00000628
op_BTST20                       02:000007CE
op_BTST21                       02:000007D8
op_BTST22                       02:000007DE
op_BTST23                       02:000007E4
op_BTST24                       02:000007EA
op_BTST25                       02:000007F0
op_BTST26                       02:000007F6
op_BTST27                       02:000007FC
op_BTST28                       02:00000802
op_BTST29                       02:00000808
op_BTST3                        02:00000630
op_BTST30                       02:0000080E
op_BTST31                       02:00000814
op_BTST32                       02:00000818
op_BTST4                        02:00000638
op_BTST5                        02:00000640
op_BTST6                        02:00000648
op_BTST7                        02:00000650
op_BTST8                        02:00000658
op_BTST9                        02:00000660
op_CHK                          02:00001F1A
op_CMP                          02:00002E14
op_CMPA                         02:00002E8A
op_CMPM                         02:00002EF0
op_CMP_I                        02:000014A6
op_DBCC                         02:00002940
op_DIVS                         02:00002B78
op_DIVU                         02:00002B26
op_EOR                          02:00002D9E
op_EORI_TO_CCR                  02:000003F2
op_EORI_TO_SR                   02:00000418
op_EXG                          02:000034BA
op_EXT                          02:00001D9A
op_LEAPEA                       02:00001DDC
op_LINKS                        02:00001EEC
op_MOVE                         02:0000199A
op_MOVEM                        02:000022E2
op_MOVEP                        02:00001232
op_MOVEQ                        02:00002B0A
op_MOVE_USP                     02:00001F0A
op_MOVE_xxx_FLAGS               02:00001BA6
op_MULS                         02:0000346E
op_MULU                         02:00003422
op_NBCD                         02:000027F0
op_NEGS                         02:00001F54
op_OR                           02:00002BCA
op_ORI_TO_CCR                   02:000003AE
op_ORI_TO_SR                    02:000003D0
op_ROXx                         02:0000375E
op_ROx                          02:00003528
op_RTR                          02:0000289E
op_SBCD                         02:000026F8
op_SCC                          02:00002966
op_SHIFTS                       02:00003994
op_SHIFTS2                      02:00003BD6
op_SUB                          02:00003080
op_SUBA                         02:000031B6
op_SUBQ                         02:00002A50
op_SUBX                         02:00003312
op_SUB_I                        02:00001814
op_SWAP                         02:00001DC6
op_TAS                          02:00001E88
op_TRAPV                        02:00002882
op_TST                          02:00001EAE
pcssxa                          02:0000649C
prtflt                          02:00006F12
ramtest                         02:00006334
ramtest0                        02:00006376
ramtest1                        02:0000637E
ramtest2                        02:000063AA
ramtest3                        02:000063EC
ramtest6                        02:0000639A
rbo                             02:0000660A
readyQ                           E:00100320
rmtst1                          02:0000638E
rmtst2                          02:000063C0
rmtst3                          02:000063C8
rmtst5                          02:0000634E
rotate_iofocus                  02:000052A2
rtc_read                        02:00006840
rtc_write                       02:000068CC
sGetChar                        02:000065D2
select_focus1                   02:000052B4
select_iofocus                  02:00005290
semamem                          E:FD050000
sirq0001                        02:00006778
sirqNxtByte                     02:00006766
sirqRxFull                      02:000067C8
start                           02:00000000
start_other                     02:000000F0
tblPow2                         02:00005D7C
tcbs                             E:20010000
trap3                           02:00006954

Symbols by value:
FD03FF00 TEXTREG
FD050000 semamem
FD060000 ACIA
FD069000 I2C2
FD090000 PLIC
FD0FFC00 RST_REG
FD0FFD00 RAND_NUM
FD0FFD04 RAND_STRM
FD0FFD08 RAND_MZ
FD0FFD0C RAND_MW
FD0FFE00 KEYBD
FD0FFF00 leds
FDC00000 MMU
00000000 I2C_PREL
00000000 ACIA_TX
00000000 ACIA_RX
00000000 start
00000000 HAS_MMU
00000001 I2C_PREH
00000002 SERIAL_SEMA
00000002 I2C_CTRL
00000003 I2C_TXR
00000003 KEYBD_SEMA
00000003 I2C_RXR
00000003 CTRLC
00000004 I2C_CMD
00000004 RAND_SEMA
00000004 ACIA_STAT
00000004 I2C_STAT
00000004 TCBRegs
00000005 SCREEN_SEMA
00000006 MEMORY_SEMA
00000007 TCB_SEMA
00000008 numBreakpoints
00000008 ACIA_CMD
00000008 CTRLH
0000000A LF
0000000C ACIA_CTRL
0000000D SC_TAB
0000000D CR
00000011 SC_ALT
00000011 XON
00000012 SC_LSHIFT
00000013 CTRLS
00000013 XOFF
00000014 SC_CTRL
00000018 CTRLX
0000001A CTRLZ
00000020 TS_PREEMPT
00000044 TCBUSP
00000048 TCBSSP
0000004C TCBSR
00000050 BUFLEN
00000050 TCBPC
00000054 TCBStatus
00000055 TCBPriority
00000058 SC_CAPSLOCK
00000059 SC_RSHIFT
0000006C TCBStartTick
00000070 TCBEndTick
00000074 TCBTicks
00000077 SC_NUMLOCK
0000007C TCBNext
0000007E SC_SCROLLLOCK
00000080 TS_RUNNING
00000080 TCBPrev
000000DC loop2
000000DE loop1
000000E0 SC_EXTEND
000000F0 SC_KEYUP
000000F0 start_other
00000100 TCB_SIZE
0000010C do_nothing
00000112 InitIOPBitmap
00000162 InitRand
00000162 RandInit
000001A2 RandGetNum
000001D2 RandWait
000001E8 InitSemaphores
0000020E LockSemaphore
00000230 ForceUnlockSemaphore
0000024A UnlockSemaphore
00000266 T15LockSemaphore
0000026C T15UnlockSemaphore
00000272 Delay3s
00000280 dly3s2
00000282 dly3s1
00000296 Delay3s2
000002B2 cpu_test
00000394 ALL_DONE
00000396 BSR_FAR1
0000039E EXCEPTION_6
000003A6 EXCEPTION_7
000003AE op_ORI_TO_CCR
000003D0 op_ORI_TO_SR
000003F2 op_EORI_TO_CCR
00000400 InstalledIRQ
00000418 op_EORI_TO_SR
0000043E op_ANDI_TO_CCR
00000464 op_ANDI_TO_SR
0000048A op_BTST
00000614 op_BTST0
00000620 op_BTST1
00000628 op_BTST2
00000630 op_BTST3
00000638 op_BTST4
00000640 op_BTST5
00000648 op_BTST6
00000650 op_BTST7
00000658 op_BTST8
00000660 op_BTST9
00000668 op_BTST10
00000670 op_BTST11
00000676 op_BTST12
000007CE op_BTST20
000007D8 op_BTST21
000007DE op_BTST22
000007E4 op_BTST23
000007EA op_BTST24
000007F0 op_BTST25
000007F6 op_BTST26
000007FC op_BTST27
00000802 op_BTST28
00000808 op_BTST29
0000080E op_BTST30
00000814 op_BTST31
00000818 op_BTST32
00000834 op_BCHG
00000B9C op_BCLR
00000EEA op_BSET
00000FFF MAX_TID
00001000 NR_TCB
00001232 op_MOVEP
000012BE op_BOOL_I
00001468 BSR_CLOSE1
00001470 op_BSR
0000149E BSR_CLOSE2
000014A6 op_CMP_I
0000168E op_ADD_I
00001814 op_SUB_I
0000199A op_MOVE
00001A66 MOVE2
00001AE2 MOVE1
00001B62 MOVE3
00001BA6 op_MOVE_xxx_FLAGS
00001CBC MOVE4
00001D9A op_EXT
00001DC6 op_SWAP
00001DDC op_LEAPEA
00001E74 LEA1
00001E88 op_TAS
00001EAE op_TST
00001EEC op_LINKS
00001F0A op_MOVE_USP
00001F1A op_CHK
00001F54 op_NEGS
000022E2 op_MOVEM
00002600 op_ABCD
00002620 ABCD_OUTER1
00002622 ABCD_INNER1
0000263E ABCD_NO_C1
00002646 ABCD_NO_C2
0000268E ABCD_OUTER2
00002690 ABCD_INNER2
000026AC ABCD_NO_C3
000026B4 ABCD_NO_C4
000026F8 op_SBCD
00002718 SBCD_OUTER1
0000271A SBCD_INNER1
00002736 SBCD_NO_C1
0000273E SBCD_NO_C2
00002786 SBCD_OUTER2
00002788 SBCD_INNER2
000027A4 SBCD_NO_C3
000027AC SBCD_NO_C4
000027F0 op_NBCD
00002808 NBCD_LOOP
00002814 NBCD_NO_C
00002818 NBCD_NO_Z
0000284E NBCD_LOOP1
00002862 NBCD_NO_C1
00002866 NBCD_NO_Z1
00002882 op_TRAPV
0000289E op_RTR
000028AA RTR_DONE
000028B8 BSR_FAR2
000028C0 op_BCC
000028C8 BCC1
000028D2 BCC2
000028DA BCC3
000028E4 BCC4
000028EC BCC5
000028F6 BCC6
000028FE BCC7
00002908 BCC8
00002910 BCC9
0000291A BCC10
00002922 BCC11
0000292C BCC12
00002934 BCC13
0000293E BCC14
00002940 op_DBCC
00002948 DBCC_LOOP1
00002956 DBCC_LOOP2
00002966 op_SCC
00002996 op_ADDQ
000029AA ADDQ_LOOP1
000029E8 ADDQ_LOOP2
00002A1E ADDQ_LOOP3
00002A50 op_SUBQ
00002A68 SUBQ_LOOP1
00002AA2 SUBQ_LOOP2
00002AD8 SUBQ_LOOP3
00002B0A op_MOVEQ
00002B26 op_DIVU
00002B42 DIVU_OUTER1
00002B78 op_DIVS
00002B94 DIVS_OUTER1
00002BCA op_OR
00002BEA OR_OUTER1
00002C5E OR_OUTER2
00002CB4 op_AND
00002CD4 AND_OUTER1
00002D48 AND_OUTER2
00002D9E op_EOR
00002DBE EOR_OUTER2
00002E14 op_CMP
00002E34 CMP_OUTER1
00002E8A op_CMPA
00002EAA CMPA_OUTER1
00002EF0 op_CMPM
00002F38 CMPM_LOOP1
00002F52 CMPM_LOOP2
00002F6C CMPM_LOOP3
00002F96 op_ADD
00002FB6 ADD_OUTER1
0000302A ADD_OUTER2
00003080 op_SUB
000030A0 SUB_OUTER1
00003114 SUB_OUTER2
0000316A op_ADDA
00003190 ADDA_OUTER1
000031B6 op_SUBA
000031DC SUBA_OUTER1
00003202 op_ADDX
00003222 ADDX_OUTER1
000032B6 ADDX_LOOP3
000032D2 ADDX_LOOP4
000032EE ADDX_LOOP5
00003312 op_SUBX
00003332 SUBX_OUTER1
000033C6 SUBX_LOOP3
000033E2 SUBX_LOOP4
000033FE SUBX_LOOP5
00003422 op_MULU
0000343E MULU_OUTER1
0000346E op_MULS
0000348A MULS_OUTER1
000034BA op_EXG
0000351C ROx_FLAGS
00003528 op_ROx
00003532 ROx_LOOP1
00003552 ROx_LOOP2
00003572 ROx_LOOP3
00003592 ROx_LOOP4
000035B2 ROx_LOOP5
000035D4 ROx_LOOP6
00003752 ROXx_FLAGS
0000375E op_ROXx
00003768 ROXx_LOOP1
00003788 ROXx_LOOP2
000037A8 ROXx_LOOP3
000037C8 ROXx_LOOP4
000037E8 ROXx_LOOP5
0000380A ROXx_LOOP6
00003988 SHIFTS_FLAGS
00003994 op_SHIFTS
0000399E SHIFTS_LOOP1
000039BE SHIFTS_LOOP2
000039DE SHIFTS_LOOP3
000039FE SHIFTS_LOOP4
00003A1E SHIFTS_LOOP5
00003A40 SHIFTS_LOOP6
00003BCA SHIFTS2_FLAGS
00003BD6 op_SHIFTS2
00003BE0 SHIFTS2_LOOP1
00003BFC SHIFTS2_LOOP2
00003C18 SHIFTS2_LOOP3
00003C34 SHIFTS2_LOOP4
00003C50 SHIFTS2_LOOP5
00003C6E SHIFTS2_LOOP6
00003DF4 START
00003DF6 GOWARM
00003DF8 GOOUT
00003DFC GOIN
00003E00 GOAUXO
00003E04 GOAUXI
00003E08 GOBYE
00003E0C TXTBGN
00003E10 ENDMEM
00003E14 CSTART
00003E58 WSTART
00003E78 ST3
00003EC6 ST4
00003F00 TAB1
00003F2C TAB2
00003F64 TAB4
00003F73 TAB5
00003F76 TAB6
00003F7B TAB8
00003F86 TAB1_1
00003FB2 TAB2_1
00003FEE TAB4_1
00004002 TAB5_1
0000400A TAB6_1
00004012 TAB8_1
0000402E DIRECT
00004036 EXEC
0000403E EXLP
00004048 EXNGO
00004060 EX1
00004066 EXMAT
0000406C EXGO
00004072 INCON
00004080 INCOM
0000408E IOCOM
00004098 OUTCOM
000040A6 IOCON
000040B0 OUTCON
000040BE NEW
000040CA STOP
000040D2 RUN
000040E0 RUNNXL
000040F6 RUNTSL
00004100 RUNSML
00004110 GOTO
00004124 LIST
00004130 LS1
00004144 LS2
0000414A LS3
00004150 PRINT
00004160 PR2
0000416E PR0
0000417C PR1
0000418C PR4
00004192 PR3
0000419E PR6
000041A4 PR8
000041B4 FINISH
000041BC GOSUB
000041E8 RETURN
0000420A FOR
00004224 FR1
0000423A FR2
00004240 FR3
00004242 FR4
00004248 FR5
0000425A FR6
0000425E FR7
00004278 FR8
0000427C NEXT
00004286 NX0
00004298 NX3
000042B2 NX1
000042C6 NX2
000042CE REM
000042D0 IF
000042D4 IF1
000042DA IF2
000042EA INPERR
000042F8 INPUT
0000430A IP2
00004324 IP3
00004358 IP4
00004362 IP5
00004366 DEFLT
0000436C LET
00004378 LT1
0000437C LOAD
00004388 LOD1
000043A2 LOD2
000043B2 LODEND
000043BC GBYTE
000043C0 GBYTE1
000043CE GBYTE2
000043DC SAVE
000043E4 SAVE1
00004408 SAVE2
00004416 SAVEND
0000443A PBYTE
0000443C PBYTE1
00004450 PBYTE2
0000445A POKE
0000446E PKER
00004472 CALL
00004486 EXPR
00004496 XP11
0000449C XP12
000044A2 XP13
000044A8 XP14
000044AE XP15
000044B4 XP15RT
000044B6 XP16
000044BC XP16RT
000044BE XPRT0
000044C2 XPRT1
000044C6 XP17
000044CA XP18
000044DA EXPR2
000044E4 XP21
000044EA XP22
000044EC XP23
000044F6 XP24
00004500 XP25
00004506 XP26
0000450E EXPR3
00004510 XP31
00004522 XP34
00004536 EXPR4
00004542 XP40
0000454C EXP4RT
0000454E XP41
00004558 PARN
00004568 XP42
0000456A XP43
0000456E TSTV
000045A4 TV1
000045BA TSTVRT
000045BC MULT32
000045C6 MLT1
000045CC MLT2
000045E0 MLT3
000045FC MLTRET
000045FE DIV32
00004610 DIV1
00004616 DIV2
0000461C DIV3
0000462A DIV4
00004638 DIVRT
0000463A PEEK
00004646 RND
00004666 RA1
0000467A ABS
00004688 ABSRT
0000468A SIZE
00004694 SETVAL
000046AC SV1
000046AE FIN
000046BA FI1
000046C6 FI2
000046C8 ENDCHK
000046D8 ENDCHK1
000046DA QWHAT
000046DC AWHAT
000046E0 ERROR
0000471A QSORRY
0000471C ASORRY
00004722 QHOW
00004724 AHOW
0000472A GETLN
0000473A GL1
00004758 GL2
0000476C GL3
00004790 GL4
0000479C GL5
000047B8 GL6
000047C0 GL7
000047C8 FNDLN
000047D6 FNDLNP
000047EC FNDRET
000047EE FNDNXT
000047F0 FNDSKP
000047FE MVUP
00004806 MVRET
00004808 MVDOWN
00004810 POPA
00004832 PP1
00004834 PUSHA
00004856 PU1
0000485A PRTSTG
0000485C PS1
00004874 PRTRET
00004876 QTSTG
00004880 QT1
00004890 QT2
00004894 QT3
000048A0 QT4
000048B2 QT5
000048B4 PRTNUM
000048C4 PN1
000048D4 PNOV
000048EE TOASCII
000048FE PN3
0000490A PN4
00004916 PN5
00004924 PNRET
00004928 PRTLN
00004942 TSTC
00004954 TC1
0000495A TSTNUM
00004960 TN1
0000498E TSNMRET
00004990 IGNBLK
00004996 IGB1
0000499A IGBRET
0000499C TOUPBUF
000049A2 TOUPB1
000049C2 TOUPBRT
000049C4 DOQUO
000049CC DOQUO1
000049D4 TOUPPER
000049E4 TOUPRET
000049E6 CHKIO
000049F6 CHKRET
000049F8 PRMESG
00004A02 PRMRET
00004A04 OUTC
00004A10 OUTC1
00004A20 INC
00004A2C INC1
00004A40 AUXOUT
00004A50 AUXIN
00004A6E AXIRET
00004A70 BYEBYE
00004A74 INITMSG
00004A9A OKMSG
00004AA1 HOWMSG
00004AA8 WHTMSG
00004AB0 SRYMSG
00004AB6 CLMSG
00004ABA LSTROM
00004ABA RANPNT
00004ABE INPPTR
00004AC2 OUTPTR
00004AC6 CURRNT
00004ACA STKGOS
00004ACE STKINP
00004AD2 LOPVAR
00004AD6 LOPINC
00004ADA LOPLMT
00004ADE LOPLN
00004AE2 LOPPT
00004AE6 TXTUNF
00004AEA VARBGN
00004AEE STKLMT
00004AF2 BUFFER
00004B42 TXT
00004B42 FemtikiInit
00004B78 FemtikiInitIRQ
00004B86 OSCallTable
00004B88 CallOS
00004BF2 GetRunningTCBPointer
00004C10 TCBHandleToPointer
00004C28 PointerToTCBHandle
00004C38 SelectThreadToRun
00004C5E InsertIntoReadyQueue
00004CAE RemoveFromReadyQueue
00004CC4 StartQ
00004CCC PopReadyQueue
00004D4A UpdateIRQLive
00004D6C FemtikiTimerIRQ
00004DDC get_screen_color
00004E08 get_screen_address
00004E10 clear_screen
00004E46 loop3
00004E60 CRLF
00004E72 UpdateTextPos
00004E9C CalcScreenLoc
00004EAA DisplayChar
00004EC8 dcx14
00004ECC dcx7
00004ED2 dccr
00004EF0 dcx6
00004F06 dcx8
00004F1C dcx9
00004F3A dcx10
00004F52 dcx12
00004F5C dcx11
00004FA2 dclf
00004FA6 dcx16
00004FAA dcx4
00004FB4 doBackspace
00004FC2 doDelete
00004FFE doCtrlX
00005022 IncCursorPos
00005042 IncCursorRow
00005074 icc1
00005076 ScrollUp
000050C0 BlankLastLine
00005124 DisplayString
00005128 dspj1
00005134 dsret
0000513A DisplayStringCRLF
00005140 DisplayStringLimited
00005160 DisplayStringLimitedCRLF
00005166 HomeCursor
00005178 SyncCursor
000051A2 TRAP15
000051B8 T15DispatchTable
00005258 Cursor1
0000528E StubRout
00005290 select_iofocus
000052A2 rotate_iofocus
000052B4 select_focus1
000052CE init_plic
00005304 KeybdGetID
00005336 kgid1
0000533E kgnotKbd
00005342 KeybdSetLED
0000536E _KeybdInit
0000536E KeybdInit
00005396 kbdi0002
000053F4 kbdiTryAgain
00005402 kbdi0004
0000541C kbdi0005
00005420 ledxit
00005436 kbdiXmitBusy
00005444 msgBadKeybd
00005453 msgXmitBusy
0000546E _KeybdGetStatus
00005478 _KeybdGetScancode
00005488 KeybdRecvByte
000054A8 KeybdWaitTx
000054CE SetKeyboardEcho
000054D6 CheckForKey
000054E2 GetKey
0000551A CheckForCtrlC
00005526 KeybdGetCharNoWait
0000552E KeybdGetCharWait
00005536 KeybdGetChar
0000574E KeybdSetLEDStatus
0000579E KeybdSendByte
000057A6 Wait10ms
000057C2 Wait300ms
000057DE KeybdIRQ
00005870 _unshiftedScanCodes
00005970 _shiftedScanCodes
00005A70 _keybdControlCodes
00005AF0 _keybdExtendedCodes
00005B70 cmdString
00005BA0 cmdTable
00005BCC FromScreen
00005BD6 StartMon
00005BE0 cmdMonitor
00005BE0 Monitor
00005BFC PromptLn
00005C08 Prompt3
00005C1E Prompt1
00005C30 cmdDispatch
00005C76 cmdBreakpoint
00005C9A cmdTinyBasic
00005C9E cmdTestCPU
00005CAE cmdClearScreen
00005CBA cmdCore
00005CDE cmdTestFP
00005D2C cmdClock
00005D4A cmdReset
00005D7C tblPow2
00005D9C cmdHelp
00005D9C DisplayHelp
00005DA8 HelpMsg
00005EFC msgUnknownCmd
00005F0C msgHello
00005F1E GetCmdLine
00005FC2 cmdSendSerial
00005FF2 cmdReceiveSerial
00006026 cmdFillB
0000604A cmdFillW
0000606E cmdFillL
00006092 ignBlanks
000060A4 cmdEditMemory
000060AC edtmem1
00006104 cmdJump
00006104 ExecuteCode
00006112 cmdDumpMemory
00006132 DumpMem1
00006144 DisplayMem
00006154 dspmem1
000061A0 cmdDumpRegs
00006220 msg_regs
00006224 msg_reglist
0000624A cmdTestSerialReceive
0000626A GetHexNumber
00006296 AsciiToHexNybble
000062A8 gthx5
000062BA gthx6
000062CC gthx3
000062D0 DisplayTwoSpaces
000062DA dspspc1
000062E2 DisplaySpace
000062EA DisplayTetra
000062F0 DisplayWyde
000062F6 DisplayByte
000062FC DisplayNybble
00006316 DisplayAddr
00006334 ramtest
00006334 cmdTestRAM
0000634E rmtst5
00006376 ramtest0
0000637E ramtest1
0000638E rmtst1
0000639A ramtest6
000063AA ramtest2
000063C0 rmtst2
000063C8 rmtst3
000063EC ramtest3
000063EE cmdLoadS19
000063F4 NextRec
00006406 ProcessRec
0000649C pcssxa
00006508 ProcessS1
0000650C ProcessS2
00006510 ProcessS3
00006514 ProcessS7
00006524 ProcessS8
00006534 ProcessS9
00006544 S19Get16BitAddress
00006552 S19Get24BitAddress
0000655E S19Get32BitAddress
0000657C S1932a
00006590 S1932b
000065D2 sGetChar
000065FE AudioInputTest
00006600 BouncingBalls
00006602 GraphicsDemo
00006604 ClearScreen
0000660A rbo
00006612 SerialInit
00006644 SerialGetChar
000066BC SerialPeekChar
000066F4 SerialPeekCharDirect
0000670E SerialPutChar
0000672A SerialRbo
00006732 SerialRcvCount
00006752 SerialIRQ
00006766 sirqNxtByte
00006778 sirq0001
000067C8 sirqRxFull
000067C8 notRxInt
000067DA nmeSerial
000067E2 i2c_setup
000067E2 init_i2c
000067F2 i2c_wait_tip
00006802 i2c_wr_cmd
00006812 i2c_xmit1
00006830 i2c_wait_rx_nack
00006840 rtc_read
000068CC rtc_write
00006936 msgRtcReadFail
00006950 bus_err
00006954 trap3
00006992 ProcessBreakpoint
00006998 DisarmAllBreakpoints
000069C4 ArmAllBreakpoints
000069F4 ArmBreakpoint
00006A72 DisarmBreakpoint
00006AC6 ListBreakpoints
00006AE6 ClearBreakpointList
00006AF8 SendMsg
00006B36 ReceiveMsg
00006B78 DispatchMsg
00006B80 _dfOne
00006B8C _dfTen
00006B98 _dfMil
00006BA4 _msgNan
00006BA8 _msgInf
00006BAC _MakeBig
00006BCE _LessThanDbl
00006C12 _ComputeDigitsBeforeDecpt
00006C44 _LeadingZero
00006C54 _SpitOutDigits
00006CCC _TrimTrailingPoint
00006CD8 _TrimTrailingZeros
00006CE4 _SpitOutE
00006CFC _ExtractExp1000sDigit
00006CFC _ExtractExpDigits
00006D2A _ExtractExp100sDigit
00006D58 _ExtractExp10sDigit
00006D88 _ExtractExp1sDigit
00006DB0 _PadLeft
00006DF8 _PadRight
00006E2A _IsZero
00006E5C _sprtflt
00006F12 prtflt
00006F44 InitIRQ
00006F58 InstallIRQ
00006F88 TickIRQ
00006FCE irq3_rout
00006FD8 irq6_rout
00006FE0 irq_rout
00006FF4 SpuriousIRQ
00006FF6 nmi_rout
00007008 brdisp_trap
00007040 illegal_trap
00007056 io_irq
0000706A msg_start
00007091 msg_core_start
000070A2 msg_illegal
000070B4 msg_bad_branch_disp
000070C6 msg_test_done
000070D6 msg_io_access
00040000 CursorRow
00040001 CursorCol
00040002 TextCurpos
00040002 TextPos
00040004 TextScr
00040008 S19StartAddress
0004000C KeybdEcho
0004000D KeybdWaitFlag
00040040 CmdBuf
00040080 CmdBufEnd
00040084 fgColor
00040088 bkColor
0004008C TextRows
0004008D TextCols
00040100 Regsave
00040202 NumSetBreakpoints
00040220 Breakpoints
00040280 BreakpointWords
000402C0 fpBuf
00040504 _digit
00040508 _width
0004050C _E
00040510 _digits_before_decpt
00040514 _precision
00040520 _fpBuf
00040600 _fpWork
00040BFC TimerStack
00100000 IOFocus
00100004 memend
0010000E KeybdLEDs
0010000F _KeyState1
00100010 _KeyState2
00100011 _KeybdHead
00100012 _KeybdTail
00100013 _KeybdCnt
00100016 KeybdID
00100020 _KeybdBuf
00100150 S19Checksum
00100160 SerTailRcv
00100162 SerHeadRcv
00100164 SerRcvXon
00100165 SerRcvXoff
00100200 RTCBuf
00100224 RunningTCB
0010031C QueueCycle
00100320 readyQ
00101000 SerRcvBuf
20010000 tcbs

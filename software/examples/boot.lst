Sections:
00: "CODE" (0-C6B7)
01: "DATA" (0-700)


Source: "boot.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022-2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;-------------------------------------------------------------------------------
                            	    37: ;
                            	    38: ; system memory map
                            	    39: ;
                            	    40: ;
                            	    41: ; 00000000 +----------------+      <+
                            	    42: ;          | startup sp,pc  | 8 B   |
                            	    43: ; 00000008 +----------------+       |
                            	    44: ;					 |    vectors     | pair shared+
                            	    45: ; 00000400 +----------------+       |
                            	    46: ;					 |   bios mem     |       |
                            	    47: ; 00001000 +----------------+       |
                            	    48: ;					 |   bios code    |       |
                            	    49: ; 00020000 +----------------+      <+
                            	    50: ;					 |    unused      |
                            	    51: ; 00040000 +----------------+
                            	    52: ;					 |   local ram    |
                            	    53: ; 00048000 +----------------+
                            	    54: ;					 |    unused      |
                            	    55: ; 00100000 +----------------+
                            	    56: ;					 |   global ram   |
                            	    57: ; 00101000 +----------------+
                            	    58: ;					 | serial rcvbuf  |
                            	    59: ; 00102000 +----------------+
                            	    60: ;          | serial xmitbuf |
                            	    61: ; 00103000 +----------------+
                            	    62: ;					 |    unused      |
                            	    63: ; 40000000 +----------------+
                            	    64: ;          |                |
                            	    65: ;          |                |
                            	    66: ;          |                |
                            	    67: ;          :  dram memory   : 1GB MB
                            	    68: ;          |                |
                            	    69: ;          |                |
                            	    70: ;          |                |
                            	    71: ; 80000000 +----------------+
                            	    72: ;          |                |
                            	    73: ;          :     unused     :
                            	    74: ;          |                |
                            	    75: ; FD000000 +----------------+
                            	    76: ;          |                |
                            	    77: ;          :    I/O area    : 1.0 M
                            	    78: ;          |                |
                            	    79: ; FFE00000 +----------------+
                            	    80: ;          |                |
                            	    81: ;          :     unused     :
                            	    82: ;          |                |
                            	    83: ; FFFFFFFF +----------------+
                            	    84: ;
                            	    85: ;-------------------------------------------------------------------------------
                            	    86: ;
                            	    87: HAS_MMU equ 0
                            	    88: NCORES equ 4
                            	    89: 
                            	    90: CTRLC	EQU		$03
                            	    91: CTRLH	EQU		$08
                            	    92: CTRLS	EQU		$13
                            	    93: CTRLX	EQU		$18
                            	    94: CTRLZ	EQU		$1A
                            	    95: LF		EQU		$0A
                            	    96: CR		EQU		$0D
                            	    97: XON		EQU		$11
                            	    98: XOFF	EQU		$13
                            	    99: EOT		EQU		$04
                            	   100: BLANK EQU		$20
                            	   101: 
                            	   102: SC_F12  EQU    $07
                            	   103: SC_C    EQU    $21
                            	   104: SC_T    EQU    $2C
                            	   105: SC_Z    EQU    $1A
                            	   106: SC_KEYUP	EQU		$F0
                            	   107: SC_EXTEND   EQU		$E0
                            	   108: SC_CTRL		EQU		$14
                            	   109: SC_RSHIFT	EQU		$59
                            	   110: SC_NUMLOCK	EQU		$77
                            	   111: SC_SCROLLLOCK	EQU	$7E
                            	   112: SC_CAPSLOCK		EQU	$58
                            	   113: SC_ALT		EQU		$11
                            	   114: SC_LSHIFT	EQU		$12
                            	   115: SC_DEL		EQU		$71		; extend
                            	   116: SC_LCTRL	EQU		$58
                            	   117: SC_TAB      EQU		$0D
                            	   118: 
                            	   119: 	include "..\Femtiki\device.x68"

Source: "..\Femtiki\device.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: DEV_INIT equ 0
                            	    38: DEV_STAT equ 1
                            	    39: DEV_PUTCHAR equ 2
                            	    40: DEV_PUTBUF equ 3
                            	    41: DEV_GETCHAR equ 4
                            	    42: DEV_GETBUF equ 5
                            	    43: DEV_SETINPOS equ 6
                            	    44: DEV_SETOUTPOS equ 7
                            	    45: DEV_GETCHAR_DIRECT equ 8
                            	    46: DEV_PEEKCHAR equ 9
                            	    47: DEV_PEEKCHAR_DIRECT equ 10
                            	    48: DEV_PUTCHAR_DIRECT equ 11
                            	    49: 
                            	    50: DCB_MAGIC equ	0			; 'DCB'
                            	    51: DCB_NAME	equ 4			; 15 chars+NULL
                            	    52: DCB_CMDPROC	equ 24	; 8 byte pointer to command processor
                            	    53: DCB_OUTPOS equ 32
                            	    54: DCB_INPOS equ 36
                            	    55: DCB_INBUFPTR equ 40
                            	    56: DCB_OUTBUFPTR equ 44
                            	    57: DCB_INBUFSIZE equ 48
                            	    58: DCB_OUTBUFSIZE equ 52
                            	    59: DCB_INROWS equ 56
                            	    60: DCB_INCOLS equ 57
                            	    61: DCB_OUTROWS equ 58
                            	    62: DCB_OUTCOLS equ 59
                            	    63: DCB_LASTERC equ 60
                            	    64: DCB_SIZE equ 64
                            	    65: 
                            	    66: ;Standard Devices are:
                            	    67: 
                            	    68: ;#		Device					Standard name
                            	    69: 
                            	    70: ;0		NULL device 			NUL		(OS built-in)
                            	    71: ;1		Keyboard (sequential)	KBD		(OS built-in, ReadOnly)
                            	    72: ;2		Video (sequential)		VID		(OS built-in, WriteOnly)
                            	    73: ;3		Printer (parallel 1)	LPT		(OS built-in)
                            	    74: ;4		Printer (parallel 2)	LPT2	(OS built-in)
                            	    75: ;5		RS-232 1				COM1	(OS built-in)
                            	    76: ;6		RS-232 2				COM2	(OS built-in)
                            	    77: ;7		RS-232 3				COM3	(OS built-in)
                            	    78: ;8		RS-232 4				COM4	(OS built-in)
                            	    79: ;9
                            	    80: ;10		Floppy					FD0 	(OS built-in)
                            	    81: ;11		Floppy					FD1 	(OS built-in)
                            	    82: ;12		Hard disk				HD0 	(OS built-in)
                            	    83: ;13		Hard disk				HD1 	(OS built-in)
                            	    84: ;14
                            	    85: ;15
                            	    86: ;16
                            	    87: ;17
                            	    88: ;18
                            	    89: ;19
                            	    90: ;20
                            	    91: ;21
                            	    92: ;22
                            	    93: ;23
                            	    94: 

Source: "boot.x68"
                            	   120: 	include "..\Femtiki\FemtikiTop.x68"

Source: "..\Femtiki\FemtikiTop.x68"
                            	     1: 	include "..\Femtiki\const.x68"

Source: "..\Femtiki\const.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: TS_NONE			EQU		0
                            	    38: TS_READY		EQU		1
                            	    39: TS_DEAD			EQU		2
                            	    40: TS_MSGRDY		EQU		4
                            	    41: TS_WAITMSG	EQU		8
                            	    42: TS_TIMEOUT	EQU		16
                            	    43: TS_PREEMPT	EQU		32
                            	    44: TS_RUNNING	EQU		128
                            	    45: 
                            	    46: ; error codes
                            	    47: E_Ok		EQU		$00
                            	    48: E_Arg		EQU		$01
                            	    49: E_Func  EQU    $02
                            	    50: E_BadMbx	EQU		$04
                            	    51: E_QueFull	EQU		$05
                            	    52: E_NoThread	EQU		$06
                            	    53: E_NotAlloc	EQU		$09
                            	    54: E_NotSupported EQU $0A
                            	    55: E_NoMsg		EQU		$0b
                            	    56: E_Timeout	EQU		$10
                            	    57: E_BadAlarm	EQU		$11
                            	    58: E_NotOwner	EQU		$12
                            	    59: E_QueStrategy EQU		$13
                            	    60: E_DCBInUse	EQU		$19
                            	    61: ; Device driver errors
                            	    62: E_BadDevNum	EQU		$20
                            	    63: E_NoDev		EQU		$21
                            	    64: E_BadDevOp	EQU		$22
                            	    65: E_ReadError	EQU		$23
                            	    66: E_WriteError EQU		$24
                            	    67: E_BadBlockNum	EQU	$25
                            	    68: E_TooManyBlocks	EQU	$26
                            	    69: 
                            	    70: ; resource errors
                            	    71: E_NoMoreMbx	EQU		$40
                            	    72: E_NoMoreMsgBlks	EQU	$41
                            	    73: E_NoMoreAlarmBlks	EQU $44
                            	    74: E_NoMoreTCBs	EQU	$45
                            	    75: E_NoMem		EQU 12
                            	    76: 
                            	    77: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     2: 	include "..\Femtiki\config.x68"

Source: "..\Femtiki\config.x68"
                            	     1: MAX_TID		EQU		4095
                            	     2: NR_TCB		EQU		4096
                            	     3: NTASK     EQU   4096    ; number of threads allowed
                            	     4: LOG_TCBSZ	EQU		8
                            	     5: LOG_PGSZ	EQU		10
                            	     6: LOG_ACBSZ EQU   12
                            	     7: OSPAGES		EQU		16			; pages of memory dedicated to OS
                            	     8: PAGESZ    EQU   16384  	; size of a page of memory
                            	     9: MEMSZ     EQU   32768   ; pages
                            	    10: MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                            	    11: NR_MSG		EQU		21842		; number of messages available
                            	    12: NR_MBX		EQU		9792
                            	    13: 
                            	    14: 
                            	    15: 
                            	    16: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     3: 	include "..\Femtiki\types.x68"

Source: "..\Femtiki\types.x68"
                            	     1: ; Thread Control Block
                            	     2: TCBMagic    EQU		$0000
                            	     3: TCBRegs  		EQU   $0004		; register set storage area
                            	     4: TCBUSP			EQU		$0044
                            	     5: TCBSSP			EQU		$0048
                            	     6: TCBSR				EQU		$004C
                            	     7: TCBPC				EQU		$0050
                            	     8: TCBStatus		EQU		$0054
                            	     9: TCBPriority	EQU		$0055
                            	    10: TCBWaitMbx	EQU		$0056
                            	    11: TCBHasFocus EQU   $005A
                            	    12: TCBStackBot	EQU		$005C
                            	    13: TCBMsgD1		EQU		$0060
                            	    14: TCBMsgD2		EQU		$0064
                            	    15: TCBMsgD3		EQU		$0068
                            	    16: TCBStartTick	EQU	$006C
                            	    17: TCBEndTick	EQU		$0070
                            	    18: TCBTicks		EQU		$0074
                            	    19: TCBException	EQU	$0078
                            	    20: TCBNext			EQU		$007C
                            	    21: TCBPrev			EQU		$0080
                            	    22: TCBAffinityBase	EQU	$0082
                            	    23: TCBAffinity	EQU		$0084
                            	    24: TCBTimeout	EQU		$0088
                            	    25: TCBtid      EQU   $008C
                            	    26: TCBmid      EQU   $0090
                            	    27: TCBappid    EQU   $0094
                            	    28: TCBOpMode   EQU   $0098
                            	    29: TCBMbxNext  EQU   $009C
                            	    30: TCBMbxPrev  EQU   $00A0
                            	    31: TCBThreadNum  EQU   $00A4
                            	    32: TCBAcbNext	EQU		$00A8
                            	    33: TCBAcbPrev	EQU		$00AC
                            	    34: TCBhMailboxes	EQU		$00B0
                            	    35: TCBName			EQU		$00C0
                            	    36: TCB_SIZE		EQU		$0100
                            	    37: 
                            	    38: MBX_MAGIC		equ		0
                            	    39: MBX_OWNER		equ		4		; tid of owning task
                            	    40: MBX_LINK    equ   8
                            	    41: MBX_TQHEAD  equ   12   ; link field for free list shared with task queue head
                            	    42: MBX_TQTAIL  equ   16
                            	    43: MBX_MQHEAD	equ		20
                            	    44: MBX_MQTAIL	equ		24
                            	    45: MBX_SIZE		equ		32
                            	    46: 
                            	    47: MSG_MAGIC   equ   0
                            	    48: MSG_LINK	  equ		4
                            	    49: MSG_RETADR  equ   8
                            	    50: MSG_TGTADR  equ   12
                            	    51: MSG_TYPE    equ   16
                            	    52: MSG_D1		  equ		20
                            	    53: MSG_D2		  equ		24
                            	    54: MSG_D3		  equ		28
                            	    55: MSG_SIZE	  equ		32
                            	    56: 
                            	    57: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     4: 
                            	     5: 	include "..\Femtiki\source\kernel\Femtiki_vars.x68"

Source: "..\Femtiki\source\kernel\Femtiki_vars.x68"
                            	     1: 
                            	     2: PAMShareCounts	EQU	$20000000	; one byte for each physical page of memory
                            	     3: tcbs						EQU	$20010000	; 4095*256 = 1MB
                            	     4: tcbs_end				EQU	$20020000
                            	     5: messages				EQU	$20020000	; 32*8192 (680*16=21760 messages)
                            	     6: messages_end		EQU	$20060000
                            	     7: mailboxes				EQU	$20060000
                            	     8: mailboxes_end		EQU	$20078000	;	12*8192 (816*12=9792 mailboxes)
                            	     9: acbs						EQU	$20080000	; 32*2*8192 =512kB
                            	    10: acbs_end				EQU	$20100000
                            	    11: 
                            	    12: 
                            	    13: sys_stacks			EQU	$DF0000
                            	    14: 
                            	    15: FemtikiVars			EQU	$00100200
                            	    16: PAMLastAllocate2	EQU		$00100218
                            	    17: RunningAID		EQU		$00100220
                            	    18: RunningTCB			EQU		$00100224
                            	    19: ACBPtrs				EQU		$00100228
                            	    20: MidStackBottoms	EQU		$00100264
                            	    21: FemtikiInited	EQU		$00100284
                            	    22: missed_ticks	EQU		$00100288
                            	    23: IOFocusList		EQU		$0010028C
                            	    24: IOFocusID			EQU		$001002AC
                            	    25: iof_switch		EQU		$001002AD
                            	    26: nMessage			EQU		$001002AE
                            	    27: nMailbox			EQU		$001002B0
                            	    28: hKeybdMbx			EQU		$001002BA
                            	    29: hFocusSwitchMbx		EQU		$001002BC
                            	    30: BIOS_RespMbx	EQU		$001002BE
                            	    31: hasUltraHighPriorityTasks	EQU		$001002C0
                            	    32: im_save				EQU		$001002C2
                            	    33: sp_tmp				EQU		$001002C4
                            	    34: startQNdx			EQU		$001002C6
                            	    35: NPAGES				EQU		$001002D8
                            	    36: syspages			EQU		$001002DA
                            	    37: mmu_FreeMaps	EQU		$001002E0
                            	    38: mmu_entries		EQU		$00100300
                            	    39: freelist			EQU		$00100302
                            	    40: hSearchMap		EQU		$00100304
                            	    41: OSActive			EQU		$00100305
                            	    42: FreeACB				EQU		$00100308
                            	    43: FreeTCB				EQU		$0010030C
                            	    44: FreeMSG				EQU		$00100310
                            	    45: FreeMBX				EQU		$00100314
                            	    46: TimeoutList		EQU		$00100318
                            	    47: QueueCycle    EQU   $0010031C
                            	    48: readyQ				EQU		$00100320		; 32 bytes per queue per core, 2 cores for now
                            	    49: readyQEnd			EQU		$00100360
                            	    50: FemtikiVars_end	EQU	$00100400
                            	    51: 
                            	    52: ;gc_stack		rmb		512
                            	    53: ;gc_pc				fcdw		0
                            	    54: ;gc_omapno		fcw			0
                            	    55: ;gc_mapno		fcw			0
                            	    56: ;gc_dl				fcw			0
                            	    57: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     6: 	code
                            	     7: 	even
                            	     8: 	include "..\Femtiki\source\kernel\tcb.x68"

Source: "..\Femtiki\source\kernel\tcb.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;------------------------------------------------------------------------------
                            	    38: ; Initialize variables related to TCBs.
                            	    39: ;------------------------------------------------------------------------------
                            	    40: 
                            	    41: TCBInit:
00:00000000 41F920010000    	    42: 	lea tcbs,a0
00:00000006 4E7B8013        	    43: 	movec a0,tcba
00:0000000A 700F            	    44: 	moveq #2*8-1,d0		; 2 cores, 32 bytes (8 lwords) per queue
00:0000000C 72FF            	    45: 	moveq #-1,d1			; value to set
00:0000000E 41F900100320    	    46: 	lea readyQ,a0			; clear out ready queue
                            	    47: .0001
00:00000014 20C1            	    48: 	move.l d1,(a0)+
00:00000016 51C8FFFC        	    49: 	dbra d0,.0001
00:0000001A 203C0003FFFF    	    50: 	move.l #TCB_SIZE*NR_TCB/4-1,d0
                            	    51: .clearTCBs
00:00000020 4298            	    52: 	clr.l (a0)+
00:00000022 51C8FFFC        	    53: 	dbra d0,.clearTCBs
00:00000026 4E75            	    54: 	rts
                            	    55: 
                            	    56: ;------------------------------------------------------------------------------
                            	    57: ; Convert a TCB handle into a pointer.
                            	    58: ;
                            	    59: ; Parameters:
                            	    60: ;		d0 = TCB handle
                            	    61: ; Returns:
                            	    62: ;		a0 = pointer to TCB
                            	    63: ;------------------------------------------------------------------------------
                            	    64: 
                            	    65: TCBHandleToPointer:
00:00000028 2F01            	    66: 	move.l d1,-(a7)
00:0000002A 028000000FFF    	    67: 	andi.l #MAX_TID,d0		; limit to # threads
00:00000030 4E7A1013        	    68: 	movec tcba,d1
00:00000034 E188            	    69: 	lsl.l #8,d0
00:00000036 D280            	    70: 	add.l d0,d1
00:00000038 2041            	    71: 	move.l d1,a0
00:0000003A E088            	    72: 	lsr.l #8,d0						; restore d0
00:0000003C 221F            	    73: 	move.l (a7)+,d1
00:0000003E 4E75            	    74: 	rts
                            	    75: 
                            	    76: ;------------------------------------------------------------------------------
                            	    77: ; Convert a TCB pointer into a handle.
                            	    78: ;
                            	    79: ; Parameters:
                            	    80: ;		a0 = TCB pointer
                            	    81: ; Returns:
                            	    82: ;		d0 = TCB handle
                            	    83: ;------------------------------------------------------------------------------
                            	    84: 
                            	    85: TCBPointerToHandle:
00:00000040 2F01            	    86: 	move.l d1,-(a7)				; save d1
00:00000042 4E7A1013        	    87: 	movec tcba,d1
00:00000046 91C1            	    88: 	sub.l d1,a0
00:00000048 2008            	    89: 	move.l a0,d0
00:0000004A E088            	    90: 	lsr.l #8,d0
00:0000004C 221F            	    91: 	move.l (a7)+,d1				; restore d1
00:0000004E 4E75            	    92: 	rts
                            	    93: 
                            	    94: ;------------------------------------------------------------------------------
                            	    95: ; Internal TCB allocation function.
                            	    96: ;
                            	    97: ; Parameters:
                            	    98: ;		none
                            	    99: ; Returns:
                            	   100: ;		d0 = handle for allocated TCB, NULL if none available
                            	   101: ;------------------------------------------------------------------------------
                            	   102: 
                            	   103: TCBIAlloc:
00:00000050 30390010030C    	   104: 	move.w FreeTCB,d0				; d1 = Free handle
00:00000056 6714            	   105: 	beq .0001
00:00000058 2F08            	   106: 	move.l a0,-(sp)
00:0000005A 61CC            	   107: 	bsr TCBHandleToPointer	; convert to pointer
00:0000005C 3228007C        	   108: 	move.w TCBNext(a0),d1		; d1 = next on free list
00:00000060 33C10010030C    	   109: 	move.w d1,FreeTCB				; update head of free list
00:00000066 61D8            	   110: 	bsr TCBPointerToHandle	; convert pointer to handle
00:00000068 205F            	   111: 	move.l (sp)+,a0
00:0000006A 4E75            	   112: 	rts
                            	   113: 	; Here there was no free TCB available. Return a NULL
                            	   114: .0001
00:0000006C 4E75            	   115: 	rts
                            	   116: 	
                            	   117: ;------------------------------------------------------------------------------
                            	   118: ; TCB allocation function. Locks the system semaphore during allocation.
                            	   119: ;
                            	   120: ; Parameters:
                            	   121: ;		none
                            	   122: ; Returns:
                            	   123: ;		d0 = handle for allocated TCB, NULL if none available
                            	   124: ;		d1 = E_Ok
                            	   125: ;------------------------------------------------------------------------------
                            	   126: 
                            	   127: TCBAlloc:
00:0000006E 61000326        	   128: 	bsr LockSysSemaphore
00:00000072 61DC            	   129: 	bsr	TCBIAlloc
00:00000074 61000330        	   130: 	bsr UnlockSysSemaphore
00:00000078 7200            	   131: 	moveq #E_Ok,d1
00:0000007A 4E75            	   132: 	rts
                            	   133: 	
                            	   134: ;------------------------------------------------------------------------------
                            	   135: ; Internal TCB free function.
                            	   136: ;
                            	   137: ; Modifies:
                            	   138: ;		none
                            	   139: ; Parameters:
                            	   140: ;		d0 = handle to TCB
                            	   141: ; Returns:
                            	   142: ;		d0 = handle to TCB
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: TCBIFree:
00:0000007C 2F08            	   146: 	move.l a0,-(sp)
00:0000007E 61A8            	   147: 	bsr TCBHandleToPointer
00:00000080 31790010030C007C	   148: 	move.w FreeTCB,TCBNext(a0)
00:00000088 33C00010030C    	   149: 	move.w d0,FreeTCB
00:0000008E 205F            	   150: 	move.l (sp)+,a0
00:00000090 4E75            	   151: 	rts
                            	   152: 
                            	   153: ;------------------------------------------------------------------------------
                            	   154: ; TCB free function. Locks the system sempaphore while freeing.
                            	   155: ;
                            	   156: ; Modifies:
                            	   157: ;		none
                            	   158: ; Parameters:
                            	   159: ;		d0 = handle to TCB
                            	   160: ; Returns:
                            	   161: ;		d0 = handle to TCB
                            	   162: ;		d1 = E_Ok
                            	   163: ;------------------------------------------------------------------------------
                            	   164: 
                            	   165: TCBFree:
00:00000092 61000302        	   166: 	bsr LockSysSemaphore
00:00000096 61E4            	   167: 	bsr TCBIFree
00:00000098 6100030C        	   168: 	bsr UnlockSysSemaphore
00:0000009C 7200            	   169: 	moveq #E_Ok,d1
00:0000009E 4E75            	   170: 	rts
                            	   171: 
                            	   172: ;------------------------------------------------------------------------------
                            	   173: ; Given an affinity, chose the core number to run on.
                            	   174: ;
                            	   175: ; Parameters:
                            	   176: ;		a0 = pointer to TCB
                            	   177: ;	Returns:
                            	   178: ;		d0 = core number to run on
                            	   179: ;------------------------------------------------------------------------------
                            	   180: 
                            	   181: TCBAffineChose:
00:000000A0 48E75000        	   182: 	movem.l d1/d3,-(sp)
00:000000A4 363C001F        	   183: 	move.w #31,d3										; limit number of bit selects to 32
00:000000A8 12280082        	   184: 	move.b TCBAffinityBase(a0),d1		; d1 = starting bit
00:000000AC 20280084        	   185: 	move.l TCBAffinity(a0),d0				; d0 = affinity mask
                            	   186: .0002
00:000000B0 0300            	   187: 	btst.l d1,d0										; is bit d1 set?
00:000000B2 6610            	   188: 	bne .0001												; if set, exit loop
00:000000B4 5241            	   189: 	addq #1,d1
00:000000B6 51CBFFF8        	   190: 	dbra d3,.0002
                            	   191: 	; no bits set? How?
00:000000BA 117C00020082    	   192: 	move.b #2,TCBAffinityBase(a0)
00:000000C0 7000            	   193: 	moveq #0,d0											; just return core #2 (0)
00:000000C2 4E75            	   194: 	rts
                            	   195: .0001
00:000000C4 1001            	   196: 	move.b d1,d0
00:000000C6 5500            	   197: 	subi.b #2,d0										; cores start at #2
00:000000C8 4880            	   198: 	ext.w d0
00:000000CA 48C0            	   199: 	ext.l d0
00:000000CC 5241            	   200: 	addq #1,d1											; increment bit selection for next time
00:000000CE 11410082        	   201: 	move.b d1,TCBAffinityBase(a0)		; and store in TCB
00:000000D2 4CDF000A        	   202: 	movem.l (sp)+,d1/d3
00:000000D6 4E75            	   203: 	rts
                            	   204: 
                            	   205: ;------------------------------------------------------------------------------
                            	   206: ; Insert thread into ready queue. The thread is added at the tail of the 
                            	   207: ; queue. The queue is a doubly linked list.
                            	   208: ;
                            	   209: ; Stack Space:
                            	   210: ;		8 lwords
                            	   211: ; Modifies:
                            	   212: ;		none
                            	   213: ; Parameters:
                            	   214: ;		d0 = thread id to insert
                            	   215: ; Returns:
                            	   216: ;		d0 = TCB handle
                            	   217: ; ----------------------------------------------------------------------------
                            	   218: 
                            	   219: TCBInsertIntoReadyQueue:
00:000000D8 48E770F0        	   220: 	movem.l d1-d3/a0-a3,-(sp)
00:000000DC 2400            	   221: 	move.l d0,d2											; d2 = thread to insert
00:000000DE 6100FF48        	   222: 	bsr TCBHandleToPointer
00:000000E2 2648            	   223: 	move.l a0,a3											; a3 = TCB pointer of thread to insert
00:000000E4 610002B0        	   224: 	bsr LockSysSemaphore
00:000000E8 002800800054    	   225: 	ori.b #TS_RUNNING,TCBStatus(a0)
00:000000EE 61B0            	   226: 	bsr TCBAffineChose								; Chose which cores queue to use
00:000000F0 EB88            	   227: 	lsl.l #5,d0												; 32 bytes per readyQ head/tail per core
00:000000F2 7200            	   228: 	clr.l d1
00:000000F4 12280055        	   229: 	move.b TCBPriority(a0),d1					; d1 = priority
00:000000F8 028100000007    	   230: 	andi.l #7,d1
00:000000FE E589            	   231: 	lsl.l #2,d1												; 4 bytes per priority level
00:00000100 D280            	   232: 	add.l d0,d1												; add in base queue
00:00000102 D2BC00100320    	   233: 	add.l #readyQ,d1									; add in start of ready queues
00:00000108 2241            	   234: 	move.l d1,a1
00:0000010A 30290004        	   235: 	move.w 4(a1),d0										; d0 = tail entry
00:0000010E 3600            	   236: 	move.w d0,d3											; d3 = tail entry
00:00000110 4A40            	   237: 	tst.w d0
00:00000112 6D20            	   238: 	blt .qempty
00:00000114 6100FF12        	   239: 	bsr TCBHandleToPointer						; a0 = pointer to tail
00:00000118 2448            	   240: 	move.l a0,a2
00:0000011A 2038007C        	   241: 	move.l TCBNext,d0
00:0000011E 6100FF08        	   242: 	bsr TCBHandleToPointer						; a0 = tail->next
00:00000122 21420080        	   243: 	move.l d2,TCBPrev(a0)							; tail->next->prev = new entry
00:00000126 2542007C        	   244: 	move.l d2,TCBNext(a2)							; tail->next = new entry
00:0000012A 2740007C        	   245: 	move.l d0,TCBNext(a3)							; new entry->next = tail->next
00:0000012E 27430080        	   246: 	move.l d3,TCBPrev(a3)							; new entry->prev = tail
00:00000132 6012            	   247: 	bra .0002
                            	   248: .qempty
00:00000134 4A51            	   249: 	tst.w (a1)												; check if there is a list head
00:00000136 6C0E            	   250: 	bge .0002													; head with no tail -> list corrupt
00:00000138 33420004        	   251: 	move.w d2,4(a1)										; head and tail equal new entry
00:0000013C 3282            	   252: 	move.w d2,(a1)
00:0000013E 3742007C        	   253: 	move.w d2,TCBNext(a3)							; next and prev of new entry point to self
00:00000142 37420080        	   254: 	move.w d2,TCBPrev(a3)
                            	   255: 	; Head but no tail, list corrupt?
                            	   256: .0002
00:00000146 6100025E        	   257: 	bsr UnlockSysSemaphore
00:0000014A 4CDF0F0E        	   258: 	movem.l (sp)+,d1-d3/a0-a3
00:0000014E 4E75            	   259: 	rts
                            	   260: 
                            	   261: ;------------------------------------------------------------------------------
                            	   262: ; Remove a thread from the ready queue. Actual removal is not done here, it
                            	   263: ; is done the next time the thread is selected to run. Just mark the thread as
                            	   264: ; not running.
                            	   265: ;
                            	   266: ; Parameters:
                            	   267: ;		d0 = thread id to remove
                            	   268: ; Returns:
                            	   269: ;		none
                            	   270: ; -----------------------------------------------------------------------------
                            	   271: 
                            	   272: TCBRemoveFromReadyQueue:
00:00000150 4A40            	   273: 	cmpi.w #0,d0
00:00000152 6D1C            	   274: 	blt .0001
00:00000154 028000000FFF    	   275: 	andi.l #MAX_TID,d0									; limit to # of threads
00:0000015A 2F08            	   276: 	move.l a0,-(sp)
00:0000015C 6100FECA        	   277: 	bsr	TCBHandleToPointer
00:00000160 61000234        	   278: 	bsr LockSysSemaphore
00:00000164 0228007F0054    	   279: 	andi.b #TS_RUNNING^$FF,TCBStatus(a0)
00:0000016A 6100023A        	   280: 	bsr UnlockSysSemaphore
00:0000016E 205F            	   281: 	move.l (sp)+,a0
                            	   282: .0001
00:00000170 4E75            	   283: 	rts
                            	   284: 	
                            	   285: ; ----------------------------------------------------------------------------
                            	   286: ; Register Usage
                            	   287: ;		d0 = temporary
                            	   288: ;		d1 = index into list of queues
                            	   289: ;		d2 = index to queue set
                            	   290: ;		d4 = queue counter, goes from 7 down to 0
                            	   291: ;		d5 = temporary
                            	   292: ;		d6 = next on list
                            	   293: ;		a0 = temporary pointer to TCB
                            	   294: ;		a1 = pointer to queue
                            	   295: ;		a2 = pointer to old head of list
                            	   296: ;		a3 = pointer to TCB at head of queue
                            	   297: ; Modifies:
                            	   298: ;		none
                            	   299: ; Parameters:
                            	   300: ;		none
                            	   301: ; Returns:
                            	   302: ;		a0 = pointer to TCB, NULL if none on list
                            	   303: ;		d0 = TCB handle
                            	   304: ; ----------------------------------------------------------------------------
                            	   305: 
                            	   306: StartQ
00:00000172 01              	   307: 	dc.b 1,2,3,4,1,5,6,7
00:00000173 02
00:00000174 03
00:00000175 04
00:00000176 01
00:00000177 05
00:00000178 06
00:00000179 07
                            	   308: 
                            	   309: 	even
                            	   310: TCBPopReadyQueue:
00:0000017A 48E77E70        	   311: 	movem.l	d1-d6/a1-a3,-(a7)
00:0000017E 4E7A2FE0        	   312: 	movec coreno,d2					; select the queue set based on the core number
00:00000182 5502            	   313: 	subi.b #2,d2						; cores start at #2
00:00000184 EB8A            	   314: 	lsl.l #5,d2							; d2 = index to queue set, 32 bytes per queue set
00:00000186 7807            	   315: 	moveq #7,d4							; d4 = queue count
00:00000188 6100020C        	   316: 	bsr LockSysSemaphore
                            	   317: 	; One in four tries pick a different priority to start searching from. 
00:0000018C 12390010031C    	   318: 	move.b QueueCycle,d1		; increment Queue cycle counter
00:00000192 5201            	   319: 	addi.b #1,d1
00:00000194 02010007        	   320: 	andi.b #7,d1
00:00000198 13C10010031C    	   321: 	move.b d1,QueueCycle
00:0000019E 6612            	   322: 	bne	.0001
00:000001A0 43FAFFD0        	   323: 	lea StartQ,a1
00:000001A4 4881            	   324: 	ext.w d1
00:000001A6 12311000        	   325: 	move.b (a1,d1.w),d1
00:000001AA 02410007        	   326: 	andi.w #7,d1						; limit to number of queues
00:000001AE E549            	   327: 	lsl.w #2,d1							; make into lword index
00:000001B0 6002            	   328: 	bra .0002
                            	   329: .0001
00:000001B2 7200            	   330: 	moveq #0,d1							; start at Queue #0
                            	   331: .0002
00:000001B4 43F900100320    	   332: 	lea readyQ,a1						; a1 = pointer to list of ready queues
00:000001BA D3C2            	   333: 	add.l d2,a1							; a1 = pointer to queue set
00:000001BC 36311000        	   334: 	move.w (a1,d1.w),d3			; d3 = old head of list
00:000001C0 6D4E            	   335: 	blt .nextQ							; anything on list?, if not go next queue
00:000001C2 3003            	   336: 	move.w d3,d0						; d0 = old head of list
00:000001C4 6100FE62        	   337: 	bsr TCBHandleToPointer
00:000001C8 2448            	   338: 	move.l a0,a2						; a2 = pointer to old head of list
00:000001CA 3A2A007C        	   339: 	move.w TCBNext(a2),d5		; remove head of list from list
00:000001CE BA80            	   340: 	cmp.l d0,d5							; removing last TCB?
00:000001D0 6736            	   341: 	beq .removeLast
00:000001D2 3C05            	   342: 	move.w d5,d6						; d6 = next on list
00:000001D4 3005            	   343: 	move.w d5,d0						; d0 = next on list
00:000001D6 6100FE50        	   344: 	bsr TCBHandleToPointer	; a0 = pointer to next TCB on list
00:000001DA 3A2A0080        	   345: 	move.w TCBPrev(a2),d5		; d5 = previous TCB from head
00:000001DE 31450080        	   346: 	move.w d5,TCBPrev(a0)		; next->prev = head->prev
00:000001E2 3005            	   347: 	move.w d5,d0
00:000001E4 6100FE42        	   348: 	bsr TCBHandleToPointer	; a0 = pointer to previous TCB from head
00:000001E8 3146007C        	   349: 	move.w d6,TCBNext(a0)		; head->prev->next = next
                            	   350: .0003
00:000001EC 33861000        	   351: 	move.w d6,(a1,d1.w)			; reset head of list to next
00:000001F0 3543007C        	   352: 	move.w d3,TCBNext(a2)		; point links back to self
00:000001F4 35430080        	   353: 	move.w d3,TCBPrev(a2)
00:000001F8 3003            	   354: 	move.w d3,d0						; return handle in d0
00:000001FA 48C0            	   355: 	ext.l d0
00:000001FC 204A            	   356: 	move.l a2,a0						; return pointer in a0
                            	   357: .0004
00:000001FE 610001A6        	   358: 	bsr UnlockSysSemaphore
00:00000202 4CDF0E7E        	   359: 	movem.l	(a7)+,d1-d6/a1-a3
00:00000206 4E75            	   360: 	rts
                            	   361: .removeLast
00:00000208 7CFF            	   362: 	moveq #-1,d6						; set head to negative when removing last
00:0000020A 33861002        	   363: 	move.w d6,2(a1,d1.w)		; tail = negative
00:0000020E 60DC            	   364: 	bra .0003
                            	   365: .nextQ
00:00000210 5841            	   366: 	addi.w #4,d1						; increment queue number by lword
00:00000212 0241001C        	   367: 	andi.w #$1C,d1					; limit to number of queues
00:00000216 51CCFF9C        	   368: 	dbra d4,.0002						; go back and check the next queue
00:0000021A 70FF            	   369: 	moveq #-1,d0						; return handle < 0 if nothing in any queue
00:0000021C 91C8            	   370: 	suba.l a0,a0						; and NULL pointer
00:0000021E 60DE            	   371: 	bra	.0004								; return NULL pointer if nothing in any queue
                            	   372: 
                            	   373: ;------------------------------------------------------------------------------
                            	   374: ; Remove a thread from the timeout list.
                            	   375: ; Called when a mailbox is freed and a thread is waiting at the
                            	   376: ; mailbox.
                            	   377: ;
                            	   378: ; Parameters:
                            	   379: ;		B = task id to remove
                            	   380: ; Modifies:
                            	   381: ;		none
                            	   382: ; Returns:
                            	   383: ;		none
                            	   384: ;------------------------------------------------------------------------------
                            	   385: 	if 0
                            	   386: RemoveFromTimeoutList:
                            	   387: 	pshs	d,w,x,y,u
                            	   388: 	cmpb	TimeoutList			; head of list?
                            	   389: 	beq		0001f
                            	   390: 	lbsr	TCBHandleToPointer
                            	   391: 	tfr		d,x
                            	   392: 	ldb		TCBNext,x
                            	   393: 	clra
                            	   394: 	tfr		d,u
                            	   395: 	ldf		TCBPrev,x
                            	   396: 	lbsr	TCBHandleToPointer
                            	   397: 	tfr		d,y
                            	   398: 	stf		TCBPrev,y
                            	   399: 	tfr		f,b
                            	   400: 	clra
                            	   401: 	lbsr	TCBHandleToPointer
                            	   402: 	tfr		d,y
                            	   403: 	tfr		u,d
                            	   404: 	stb		TCBNext,y
                            	   405: 	bra		0002f
                            	   406: 	; Removing from head of timeout list
                            	   407: 0001:
                            	   408: 	lbsr	TCBHandleToPointer
                            	   409: 	tfr		d,x
                            	   410: 	ldb		TCBNext,x
                            	   411: 	stb		TimeoutList		; set new head of list
                            	   412: 	clra
                            	   413: 	lbsr	TCBHandleToPointer
                            	   414: 	tfr		d,y
                            	   415: 	clrb
                            	   416: 	stb		TCBPrev,y			; next->prev = NULL
                            	   417: 0002:
                            	   418: 	clrd
                            	   419: 	std		TCBNext,x			; next = NULL
                            	   420: 	std		TCBPrev,x			; prev = NULL
                            	   421: 	puls	d,w,x,y,u,pc
                            	   422: 	
                            	   423: ;// ----------------------------------------------------------------------------
                            	   424: ;// Pop the top entry from the timeout list.
                            	   425: ;// ----------------------------------------------------------------------------
                            	   426: ;
                            	   427: ;hTCB PopTimeoutList()
                            	   428: ;{
                            	   429: ;    TCB *p;
                            	   430: ;    hTCB h;
                            	   431: ;
                            	   432: ;    h = TimeoutList;
                            	   433: ;    if (TimeoutList > 0 && TimeoutList < NR_TCB) {
                            	   434: ;        TimeoutList = tcbs[TimeoutList].next;
                            	   435: ;        if (TimeoutList >= 0 && TimeoutList < NR_TCB) {
                            	   436: ;            tcbs[TimeoutList].prev = h->prev;
                            	   437: ;            h->prev->next = TimeoutList;
                            	   438: ;        }
                            	   439: ;    }
                            	   440: ;    return h;
                            	   441: ;}
                            	   442: ;
                            	   443: ; Returns:
                            	   444: ;		B = task at top of list
                            	   445: ;
                            	   446: 
                            	   447: PopTimeoutList:
                            	   448: 	pshs	w,x,y
                            	   449: 	ldb		TimeoutList
                            	   450: 	pshs	b
                            	   451: 	beq		0001f
                            	   452: 	cmpb	#NR_TCB
                            	   453: 	bhs		0001f
                            	   454: 	bsr		TCBHandleToPointer
                            	   455: 	tfr		d,x
                            	   456: 	ldb		TCBNext,x
                            	   457: 	tfr		b,f
                            	   458: 	lde		TCBPrev,x
                            	   459: 	stb		TimeoutList
                            	   460: 	beq		0001f
                            	   461: 	cmpb	#NR_TCB
                            	   462: 	bhs		0001f
                            	   463: 	bsr		TCBHandleToPointer
                            	   464: 	tfr		d,y
                            	   465: 	ste		TCBPrev,y
                            	   466: 	tfr		e,b
                            	   467: 	bsr		TCBHandleToPointer
                            	   468: 	tfr		d,y
                            	   469: 	stf		TCBNext,y
                            	   470: 	clr		TCBPrev,x
                            	   471: 	clr		TCBNext,x
                            	   472: 0001:
                            	   473: 	puls	b
                            	   474: 	puls	x,y,w,pc
                            	   475: 
                            	   476: ; ----------------------------------------------------------------------------
                            	   477: ; ----------------------------------------------------------------------------
                            	   478: DispTwoSpace:
                            	   479: 	bsr	DispSpace
                            	   480: DispSpace:
                            	   481: 	ldb		#' '
                            	   482: 	swi
                            	   483: 	fcb		MF_OUTCH
                            	   484: 	rts
                            	   485: 
                            	   486: DumpTCBs:
                            	   487: 	swi
                            	   488: 	fcb		MF_CRLF
                            	   489: 	ldb		#1
                            	   490: 0002:
                            	   491: 	lbsr	TCBHandleToPointer
                            	   492: 	tfr		d,x
                            	   493: 	ldb		TCBtid,x
                            	   494: 	swi
                            	   495: 	fcb		MF_DisplayByteAsHex
                            	   496: 	bsr		DispSpace
                            	   497: 	ldb		TCBStatus,x
                            	   498: 	swi
                            	   499: 	fcb		MF_DisplayByteAsHex
                            	   500: 	bsr		DispTwoSpace
                            	   501: 	swi
                            	   502: 	fcb		MF_CRLF
                            	   503: 	ldb		TCBNext,x
                            	   504: 	beq		0001f
                            	   505: 	bra		0002b
                            	   506: 0001:
                            	   507: 	rts
                            	   508: 	
                            	   509: fcb	"TID Stat"
                            	   510: 	endif
                            	   511: 
                            	   512: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     9: 	include "..\Femtiki\source\kernel\Femtiki.x68"

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     1: 	code
                            	     2: 	even
                            	     3: ;------------------------------------------------------------------------------
                            	     4: ; Initialize the Femtiki OS.
                            	     5: ;------------------------------------------------------------------------------
                            	     6: 
                            	     7: FemtikiInit:
00:00000220 7000            	     8: 	moveq #0,d0
00:00000222 4E7B0012        	     9: 	movec d0,tr
00:00000226 6100FDD8        	    10: 	bsr TCBInit
00:0000022A 42390010031C    	    11: 	clr.b QueueCycle
                            	    12: FemtikiInitIRQ:
00:00000230 43FA00DC        	    13: 	lea FemtikiTimerIRQ,a1						; Set timer IRQ vector to Femtiki
00:00000234 4E7A8801        	    14: 	movec vbr,a0
00:00000238 21490078        	    15: 	move.l a1,30*4(a0)								; vector #30
00:0000023C 4E75            	    16: 	rts
                            	    17: 
                            	    18: ;------------------------------------------------------------------------------
                            	    19: ; Operating system call dispatcher.
                            	    20: ; On entry, the task state has been saved including the system stack pointer,
                            	    21: ; in the task control block.
                            	    22: ;------------------------------------------------------------------------------
                            	    23: 
                            	    24: OSCallTable
00:0000023E 0000            	    25: 	dc.w		0
                            	    26: 
                            	    27: 	even
                            	    28: CallOS:
00:00000240 2F08            	    29: 	move.l	a0,-(a7)
00:00000242 207900100224    	    30: 	move.l	RunningTCB,a0
00:00000248 48E8FFFF0004    	    31: 	movem.l d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,TCBRegs(a0)
00:0000024E 225F            	    32: 	move.l	(a7)+,a1
00:00000250 21490020        	    33: 	move.l	a1,32(a0)
00:00000254 4E7A9800        	    34: 	movec		usp,a1
00:00000258 21490044        	    35: 	move.l	a1,TCBUSP(a0)
00:0000025C 301F            	    36: 	move.w	(a7)+,d0					; pop the status register
00:0000025E 3140004C        	    37: 	move.w	d0,TCBSR(a0)			; save in TCB
00:00000262 225F            	    38: 	move.l	(a7)+,a1					; pop the program counter
00:00000264 5489            	    39: 	lea	2(a1),a1							; increment past inline callno argument
00:00000266 21490050        	    40: 	move.l	a1,TCBPC(a0)			; save PC in TCB
00:0000026A 214F0048        	    41: 	move.l	a7,TCBSSP(a0)			; finally save SSP
00:0000026E 3029FFFE        	    42: 	move.w	-2(a1),d0					; d0 = call number
00:00000272 E548            	    43: 	lsl.w		#2,d0							; make into table index
00:00000274 43FAFFC8        	    44: 	lea			OSCallTable,a1
00:00000278 22710000        	    45: 	move.l	(a1,d0.w),a1
00:0000027C 4E91            	    46: 	jsr			(a1)							; call the OS function
                            	    47: 	; Restore the thread context and return
00:0000027E 207900100224    	    48: 	move.l	RunningTCB,a0
00:00000284 2E780048        	    49: 	move.l	TCBSSP,a7
00:00000288 2F280050        	    50: 	move.l	TCBPC(a0),-(a7)		; setup the PC and the SR on the stack
00:0000028C 3F28004C        	    51: 	move.w	TCBSR(a0),-(a7)		; prep for RTE
00:00000290 20380044        	    52: 	move.l	TCBUSP,d0					; restore user stack pointer
00:00000294 4E7B0800        	    53: 	movec		d0,usp
00:00000298 4CE800FF0004    	    54: 	movem.l	TCBRegs(a0),d0/d1/d2/d3/d4/d5/d6/d7
00:0000029E 4CE87E00002C    	    55: 	movem.l TCBRegs+40(a0),a1/a2/a3/a4/a5/a6
00:000002A4 20680024        	    56: 	move.l	TCBRegs+32(a0),a0
00:000002A8 4E73            	    57: 	rte
                            	    58: 
                            	    59: ;------------------------------------------------------------------------------
                            	    60: ; Get a pointer to the currently running TCB.
                            	    61: ;
                            	    62: ; Returns:
                            	    63: ;		a0 = pointer to running TCB
                            	    64: ;------------------------------------------------------------------------------
                            	    65: 
                            	    66: GetRunningTCBPointer:
00:000002AA 48E7C000        	    67: 	movem.l d0/d1,-(a7)
00:000002AE 4E7A0012        	    68: 	movec tr,d0
00:000002B2 6100FD74        	    69: 	bsr TCBHandleToPointer
00:000002B6 028000000FFF    	    70: 	andi.l #MAX_TID,d0		; limit to # threads
00:000002BC 4CDF0003        	    71: 	movem.l (a7)+,d0/d1
00:000002C0 4E75            	    72: 	rts
                            	    73: 
                            	    74: ; ----------------------------------------------------------------------------
                            	    75: ; Select a thread to run. Relatively easy. All that needs to be done is to
                            	    76: ; keep popping the queue until a valid running task is found. There should
                            	    77: ; always be at least one thread in the queue.
                            	    78: ;
                            	    79: ; Modifies:
                            	    80: ;		none
                            	    81: ; Returns:
                            	    82: ;		d0 = handle of the next thread to run
                            	    83: ; ----------------------------------------------------------------------------
                            	    84: 
                            	    85: SelectThreadToRun:
                            	    86: .0001										; keep popping tasks from the readyQ until a valid one
00:000002C2 6100FEB6        	    87: 	bsr	TCBPopReadyQueue	; is found.
00:000002C6 4A40            	    88: 	tst.w d0
00:000002C8 6B0C            	    89: 	bmi	.0002
00:000002CA 0C2800800054    	    90: 	cmpi.b #TS_RUNNING,TCBStatus(a0)	; ensure the thread is to be running
00:000002D0 66F0            	    91: 	bne	.0001													; if not, go get the next thread
00:000002D2 6000FE04        	    92: 	bra	TCBInsertIntoReadyQueue				; insert thread back into queue
                            	    93: 	; Nothing in queues? There is supposed to be. Add the OS task to the queue.
                            	    94: .0002
00:000002D6 4E7A8013        	    95: 	movec tcba,a0
00:000002DA 117C00800054    	    96: 	move.b #TS_RUNNING,TCBStatus(a0)	; flag as RUNNING
00:000002E0 117C00040055    	    97: 	move.b #4,TCBPriority(a0)					; OS has normal priority
00:000002E6 7000            	    98: 	moveq #0,d0												; fast pointer to handle
00:000002E8 6000FDEE        	    99: 	bra TCBInsertIntoReadyQueue
                            	   100: 
                            	   101: ; ----------------------------------------------------------------------------
                            	   102: ; Update the IRQ live indicator on screen.
                            	   103: ; ----------------------------------------------------------------------------
                            	   104: 
                            	   105: UpdateIRQLive:
00:000002EC 227900040004    	   106: 	move.l TextScr,a1					; a1 = screen address
00:000002F2 2411            	   107: 	move.l (a1),d2
00:000002F4 E15A            	   108: 	rol.w	#8,d2								; reverse byte order of d2
00:000002F6 4842            	   109: 	swap d2
00:000002F8 E15A            	   110: 	rol.w	#8,d2
00:000002FA 06010030        	   111: 	addi.b #'0',d1						; binary to ascii core number
00:000002FE D202            	   112: 	add.b	d2,d1
00:00000300 E159            	   113: 	rol.w	#8,d1								; put bytes back in order
00:00000302 4841            	   114: 	swap d1
00:00000304 E159            	   115: 	rol.w	#8,d1
00:00000306 23410004        	   116: 	move.l d1,4(a1)						; update onscreen IRQ flag
00:0000030A 5291            	   117: 	addi.l #1,(a1)						; flashy colors
00:0000030C 4E75            	   118: 	rts
                            	   119: 
                            	   120: ; ----------------------------------------------------------------------------
                            	   121: ; Femtiki IRQ service routine. This is where a thread switch can occur so,
                            	   122: ; the thread context is saved and restored.
                            	   123: ; ----------------------------------------------------------------------------
                            	   124: 
                            	   125: FemtikiTimerIRQ:
00:0000030E 46FC2600        	   126: 	move.w #$2600,sr							; disable lower level IRQs
00:00000312 2F00            	   127: 	move.l d0,-(a7)
00:00000314 2F08            	   128: 	move.l a0,-(a7)
00:00000316 6192            	   129: 	bsr GetRunningTCBPointer			; a0 = pointer to running TCB
00:00000318 48E8FFFF0004    	   130: 	movem.l #$FFFF,TCBRegs(a0)		; save all registers
00:0000031E 201F            	   131: 	move.l (a7)+,d0
00:00000320 21400020        	   132: 	move.l d0,32(a0)							; save original a0 value
00:00000324 201F            	   133: 	move.l (a7)+,d0
00:00000326 2080            	   134: 	move.l d0,(a0)								; save original d0 value
00:00000328 4E7A0800        	   135: 	movec usp,d0									; save user stack pointer
00:0000032C 21400044        	   136: 	move.l d0,TCBUSP(a0)
00:00000330 2E7C00040BFC    	   137: 	move.l #TimerStack,a7					; reset stack pointer
00:00000336 4E7A1FE0        	   138: 	movec	coreno,d1								; d1 = core number
00:0000033A 0C010002        	   139: 	cmpi.b #2,d1
00:0000033E 6612            	   140: 	bne.s	.0002
00:00000340 23FC1D000000FD09	   141: 	move.l #$1D000000,PLIC+$14		; reset edge sense circuit
00:00000348 0014
00:0000034A 13FC0001000400A0	   142: 	move.b #1,IRQFlag							; set IRQ flag for TinyBasic shell
                            	   143: .0002
00:00000352 6198            	   144: 	bsr UpdateIRQLive							; Update IRQ live indicator
                            	   145: ;	bsr ReceiveMsg								; Check for RPC
00:00000354 4E7A0FF0        	   146: 	movec tick,d0									; Update time accounting
00:00000358 21400070        	   147: 	move.l d0,TCBEndTick(a0)			; compute number of ticks thread was running
00:0000035C 90A8006C        	   148: 	sub.l	TCBStartTick(a0),d0
00:00000360 D1A80074        	   149: 	add.l	d0,TCBTicks(a0)					; add to cumulative ticks
00:00000364 117C00200054    	   150: 	move.b #TS_PREEMPT,TCBStatus(a0)	; set thread status to PREEMPT
00:0000036A 6100FF56        	   151: 	bsr	SelectThreadToRun					; d0 = TCB handle
00:0000036E 4E7B0012        	   152: 	movec d0,tr										; set running thread number in tr
00:00000372 6100FF36        	   153: 	bsr GetRunningTCBPointer			; a0 = pointer to TCB
00:00000376 117C00800054    	   154: 	move.b #TS_RUNNING,TCBStatus(a0)	; set thread status to RUNNING
00:0000037C 4E7A0FF0        	   155: 	movec	tick,d0
00:00000380 2140006C        	   156: 	move.l d0,TCBStartTick(a0)		; record starting tick
00:00000384 20280044        	   157: 	move.l TCBUSP(a0),d0					; restore user stack pointer
00:00000388 4E7B0800        	   158: 	movec d0,usp
00:0000038C 4CE8FFFF0004    	   159: 	movem.l TCBRegs(a0),#$FFFF		; restore all registers
00:00000392 504F            	   160: 	addq #8,sp										; "pop" d0/a0, saved stack pointer is off by 8
00:00000394 4E73            	   161: 	rte														; and return
                            	   162: 
                            	   163: 	include "..\Femtiki\source\kernel\Semaphore.x68"

Source: "..\Femtiki\source\kernel\Semaphore.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;-------------------------------------------------------------------------------
                            	    38: ; Lock the system semaphore. Call the BIOS.
                            	    39: ;
                            	    40: ; Parameters:
                            	    41: ;		none
                            	    42: ; Returns:
                            	    43: ;		none
                            	    44: ;-------------------------------------------------------------------------------
                            	    45: 
                            	    46: LockSysSemaphore:
00:00000396 48E7C000        	    47: 	movem.l d0/d1,-(sp)
00:0000039A 7025            	    48: 	moveq #37,d0				; lock semaphore
00:0000039C 7208            	    49: 	moveq #FMTK_SEMA,d1
00:0000039E 4E4F            	    50: 	trap #15
00:000003A0 4CDF0003        	    51: 	movem.l (sp)+,d0/d1
00:000003A4 4E75            	    52: 	rts
                            	    53: 
                            	    54: 
                            	    55: ;-------------------------------------------------------------------------------
                            	    56: ; Unlock the system semaphore.
                            	    57: ;
                            	    58: ; Parameters:
                            	    59: ;		none
                            	    60: ; Returns:
                            	    61: ;		none
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: UnlockSysSemaphore:
00:000003A6 48E7C000        	    65: 	movem.l d0/d1,-(sp)
00:000003AA 7026            	    66: 	moveq #38,d0				; unlock semaphore
00:000003AC 7208            	    67: 	moveq #FMTK_SEMA,d1
00:000003AE 4E4F            	    68: 	trap #15
00:000003B0 4CDF0003        	    69: 	movem.l (sp)+,d0/d1
00:000003B4 4E75            	    70: 	rts
                            	    71: 
                            	    72: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	   164: 
                            	   165: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	    10: 

Source: "boot.x68"
                            	   121: 
                            	   122: DDATA EQU $FFFFFFF0     ; DS.L    3
                            	   123: HISPC EQU $FFFFFFFC     ; DS.L    1
                            	   124: SCREEN_FORMAT = 1
                            	   125: 
                            	   126: 	if HAS_MMU
                            	   127: TEXTREG		EQU	$1E3FF00	; virtual addresses
                            	   128: txtscreen	EQU	$1E00000
                            	   129: semamem		EQU	$1E50000
                            	   130: ACIA			EQU	$1E60000
                            	   131: ACIA_RX		EQU	0
                            	   132: ACIA_TX		EQU	0
                            	   133: ACIA_STAT	EQU	4
                            	   134: ACIA_CMD	EQU	8
                            	   135: ACIA_CTRL	EQU	12
                            	   136: I2C2 			equ $01E69000
                            	   137: I2C_PREL 	equ 0
                            	   138: I2C_PREH 	equ 1
                            	   139: I2C_CTRL 	equ 2
                            	   140: I2C_RXR 	equ 3
                            	   141: I2C_TXR 	equ 3
                            	   142: I2C_CMD 	equ 4
                            	   143: I2C_STAT 	equ 4
                            	   144: PLIC			EQU	$1E90000
                            	   145: MMU				EQU $FDC00000	; physical address
                            	   146: leds			EQU	$1EFFF00	; virtual addresses
                            	   147: keybd			EQU	$1EFFE00
                            	   148: KEYBD			EQU	$1EFFE00
                            	   149: RAND			EQU	$1EFFD00
                            	   150: RAND_NUM	EQU	$1EFFD00
                            	   151: RAND_STRM	EQU	$1EFFD04
                            	   152: RAND_MZ		EQU $1EFFD08
                            	   153: RAND_MW		EQU	$1EFFD0C
                            	   154: RST_REG		EQU	$1EFFC00
                            	   155: IO_BITMAP	EQU $1F00000
                            	   156: 	else
                            	   157: TEXTREG		EQU	$FD080000
                            	   158: txtscreen	EQU	$FD000000
                            	   159: semamem		EQU	$FD050000
                            	   160: ACIA			EQU	$FD060000
                            	   161: ACIA_RX		EQU	0
                            	   162: ACIA_TX		EQU	0
                            	   163: ACIA_STAT	EQU	4
                            	   164: ACIA_CMD	EQU	8
                            	   165: ACIA_CTRL	EQU	12
                            	   166: I2C2 			equ $FD069000
                            	   167: I2C_PREL 	equ 0
                            	   168: I2C_PREH 	equ 1
                            	   169: I2C_CTRL 	equ 2
                            	   170: I2C_RXR 	equ 3
                            	   171: I2C_TXR 	equ 3
                            	   172: I2C_CMD 	equ 4
                            	   173: I2C_STAT 	equ 4
                            	   174: PLIC			EQU	$FD090000
                            	   175: MMU				EQU $FDC00000	; physical address
                            	   176: leds			EQU	$FD0FFF00	; virtual addresses
                            	   177: keybd			EQU	$FD0FFE00
                            	   178: KEYBD			EQU	$FD0FFE00
                            	   179: RAND			EQU	$FD0FFD00
                            	   180: RAND_NUM	EQU	$FD0FFD00
                            	   181: RAND_STRM	EQU	$FD0FFD04
                            	   182: RAND_MZ		EQU $FD0FFD08
                            	   183: RAND_MW		EQU	$FD0FFD0C
                            	   184: RST_REG		EQU	$FD0FFC00
                            	   185: IO_BITMAP	EQU $FD100000
                            	   186: FRAMEBUF	EQU	$FD200000
                            	   187: 	endif
                            	   188: 
                            	   189: SERIAL_SEMA	EQU	2
                            	   190: KEYBD_SEMA	EQU	3
                            	   191: RAND_SEMA		EQU	4
                            	   192: SCREEN_SEMA	EQU	5
                            	   193: MEMORY_SEMA EQU 6
                            	   194: TCB_SEMA 		EQU	7
                            	   195: FMTK_SEMA		EQU	8
                            	   196: 
                            	   197: macIRQ_proc	macro arg1
                            	   198: 	dc.l IRQ_proc\1
                            	   199: endm
                            	   200: 
                            	   201: macIRQ_proc_label	macro arg1
                            	   202: IRQ_proc\1:
                            	   203: endm
                            	   204: 
                            	   205: 	data
                            	   206: 	; 0
01:00000000 00040FFC        	   207: 	dc.l		$00040FFC
01:00000004 000003B8        	   208: 	dc.l		start
01:00000008 000084A8        	   209: 	dc.l		bus_err
01:0000000C 000088A0        	   210: 	dc.l		addr_err
01:00000010 000088EE        	   211: 	dc.l		illegal_trap		* ILLEGAL instruction
01:00000014 00000000        	   212: 	dc.l		0
01:00000018 0000082C        	   213: 	dc.l		chk_exception		; CHK
01:0000001C 00000972        	   214: 	dc.l		EXCEPTION_7			* TRAPV
01:00000020 00000000        	   215: 	dc.l		0
01:00000024 00000000        	   216: 	dc.l		0
                            	   217: 	
                            	   218: 	; 10
01:00000028 00000000        	   219: 	dc.l		0
01:0000002C 00000000        	   220: 	dc.l		0
01:00000030 00000000        	   221: 	dc.l		0
01:00000034 00000000        	   222: 	dc.l		0
01:00000038 00000000        	   223: 	dc.l		0
01:0000003C 00000000        	   224: 	dc.l		0
01:00000040 00000000        	   225: 	dc.l		0
01:00000044 00000000        	   226: 	dc.l		0
01:00000048 00000000        	   227: 	dc.l		0
01:0000004C 00000000        	   228: 	dc.l		0
                            	   229: 	
                            	   230: 	; 20
01:00000050 00000000        	   231: 	dc.l		0
01:00000054 00000000        	   232: 	dc.l		0
01:00000058 00000000        	   233: 	dc.l		0
01:0000005C 00000000        	   234: 	dc.l		0
01:00000060 0000888C        	   235: 	dc.l		SpuriousIRQ
01:00000064 00000000        	   236: 	dc.l		0
01:00000068 00000000        	   237: 	dc.l		0
01:0000006C 0000885A        	   238: 	dc.l		irq3_rout
01:00000070 00000000        	   239: 	dc.l		0
01:00000074 00000000        	   240: 	dc.l		0
                            	   241: 	
                            	   242: 	; 30
01:00000078 00008818        	   243: 	dc.l		TickIRQ						; IRQ 30 - timer / keyboard
01:0000007C 0000888E        	   244: 	dc.l		nmi_rout
01:00000080 00008762        	   245: 	dc.l		io_trap						; TRAP zero
01:00000084 00000000        	   246: 	dc.l		0
01:00000088 00000000        	   247: 	dc.l		0
01:0000008C 000084C2        	   248: 	dc.l		trap3							; breakpoint
01:00000090 00000000        	   249: 	dc.l		0
01:00000094 00000000        	   250: 	dc.l		0
01:00000098 00000000        	   251: 	dc.l		0
01:0000009C 00000000        	   252: 	dc.l		0
                            	   253: 
                            	   254: 	; 40
01:000000A0 00000000        	   255: 	dc.l		0
01:000000A4 00000000        	   256: 	dc.l		0
01:000000A8 00000000        	   257: 	dc.l		0
01:000000AC 00000000        	   258: 	dc.l		0
01:000000B0 00000000        	   259: 	dc.l		0
01:000000B4 00000000        	   260: 	dc.l		0
01:000000B8 00000000        	   261: 	dc.l		0
01:000000BC 00005DA0        	   262: 	dc.l		TRAP15
01:000000C0 00000000        	   263: 	dc.l		0
01:000000C4 00000000        	   264: 	dc.l		0
                            	   265: 
                            	   266: 	; 50	
01:000000C8 00000000        	   267: 	dc.l		0
01:000000CC 00000000        	   268: 	dc.l		0
01:000000D0 00000000        	   269: 	dc.l		0
01:000000D4 00000000        	   270: 	dc.l		0
01:000000D8 00000000        	   271: 	dc.l		0
01:000000DC 00000000        	   272: 	dc.l		0
01:000000E0 00000000        	   273: 	dc.l		0
01:000000E4 00000000        	   274: 	dc.l		0
01:000000E8 00000000        	   275: 	dc.l		0
01:000000EC 00008904        	   276: 	dc.l		io_irq
                            	   277: 
                            	   278: 	; 60
01:000000F0 0000693C        	   279: 	dc.l		KeybdIRQ
01:000000F4 0000824C        	   280: 	dc.l		SerialIRQ
01:000000F8 00000000        	   281: 	dc.l		0
01:000000FC 000088B6        	   282: 	dc.l		brdisp_trap
                            	   283: 	
                            	   284: 	; 64
                            	   285: 
                            	   286: IRQ_trampolines:
                            	   287: ;	rept 192
                            	   288: ;	macIRQ_proc REPTN
                            	   289: ;	endr
                            	   290: 
                            	   291: 	org			$400
                            	   292: 
                            	   293: irq_list_tbl:
                            	   294: 	rept 192
                            	   295: 	dc.l 0
                            	   296: 	dc.l 0
                            	   297: 	endr
01:00000400 00000000        	     1R 	dc.l 0
01:00000404 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000408 00000000        	     1R 	dc.l 0
01:0000040C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000410 00000000        	     1R 	dc.l 0
01:00000414 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000418 00000000        	     1R 	dc.l 0
01:0000041C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000420 00000000        	     1R 	dc.l 0
01:00000424 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000428 00000000        	     1R 	dc.l 0
01:0000042C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000430 00000000        	     1R 	dc.l 0
01:00000434 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000438 00000000        	     1R 	dc.l 0
01:0000043C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000440 00000000        	     1R 	dc.l 0
01:00000444 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000448 00000000        	     1R 	dc.l 0
01:0000044C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000450 00000000        	     1R 	dc.l 0
01:00000454 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000458 00000000        	     1R 	dc.l 0
01:0000045C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000460 00000000        	     1R 	dc.l 0
01:00000464 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000468 00000000        	     1R 	dc.l 0
01:0000046C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000470 00000000        	     1R 	dc.l 0
01:00000474 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000478 00000000        	     1R 	dc.l 0
01:0000047C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000480 00000000        	     1R 	dc.l 0
01:00000484 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000488 00000000        	     1R 	dc.l 0
01:0000048C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000490 00000000        	     1R 	dc.l 0
01:00000494 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000498 00000000        	     1R 	dc.l 0
01:0000049C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004A0 00000000        	     1R 	dc.l 0
01:000004A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004A8 00000000        	     1R 	dc.l 0
01:000004AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004B0 00000000        	     1R 	dc.l 0
01:000004B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004B8 00000000        	     1R 	dc.l 0
01:000004BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004C0 00000000        	     1R 	dc.l 0
01:000004C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004C8 00000000        	     1R 	dc.l 0
01:000004CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004D0 00000000        	     1R 	dc.l 0
01:000004D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004D8 00000000        	     1R 	dc.l 0
01:000004DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004E0 00000000        	     1R 	dc.l 0
01:000004E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004E8 00000000        	     1R 	dc.l 0
01:000004EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004F0 00000000        	     1R 	dc.l 0
01:000004F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004F8 00000000        	     1R 	dc.l 0
01:000004FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000500 00000000        	     1R 	dc.l 0
01:00000504 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000508 00000000        	     1R 	dc.l 0
01:0000050C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000510 00000000        	     1R 	dc.l 0
01:00000514 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000518 00000000        	     1R 	dc.l 0
01:0000051C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000520 00000000        	     1R 	dc.l 0
01:00000524 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000528 00000000        	     1R 	dc.l 0
01:0000052C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000530 00000000        	     1R 	dc.l 0
01:00000534 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000538 00000000        	     1R 	dc.l 0
01:0000053C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000540 00000000        	     1R 	dc.l 0
01:00000544 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000548 00000000        	     1R 	dc.l 0
01:0000054C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000550 00000000        	     1R 	dc.l 0
01:00000554 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000558 00000000        	     1R 	dc.l 0
01:0000055C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000560 00000000        	     1R 	dc.l 0
01:00000564 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000568 00000000        	     1R 	dc.l 0
01:0000056C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000570 00000000        	     1R 	dc.l 0
01:00000574 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000578 00000000        	     1R 	dc.l 0
01:0000057C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000580 00000000        	     1R 	dc.l 0
01:00000584 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000588 00000000        	     1R 	dc.l 0
01:0000058C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000590 00000000        	     1R 	dc.l 0
01:00000594 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000598 00000000        	     1R 	dc.l 0
01:0000059C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005A0 00000000        	     1R 	dc.l 0
01:000005A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005A8 00000000        	     1R 	dc.l 0
01:000005AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005B0 00000000        	     1R 	dc.l 0
01:000005B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005B8 00000000        	     1R 	dc.l 0
01:000005BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005C0 00000000        	     1R 	dc.l 0
01:000005C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005C8 00000000        	     1R 	dc.l 0
01:000005CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005D0 00000000        	     1R 	dc.l 0
01:000005D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005D8 00000000        	     1R 	dc.l 0
01:000005DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005E0 00000000        	     1R 	dc.l 0
01:000005E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005E8 00000000        	     1R 	dc.l 0
01:000005EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005F0 00000000        	     1R 	dc.l 0
01:000005F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005F8 00000000        	     1R 	dc.l 0
01:000005FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000600 00000000        	     1R 	dc.l 0
01:00000604 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000608 00000000        	     1R 	dc.l 0
01:0000060C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000610 00000000        	     1R 	dc.l 0
01:00000614 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000618 00000000        	     1R 	dc.l 0
01:0000061C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000620 00000000        	     1R 	dc.l 0
01:00000624 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000628 00000000        	     1R 	dc.l 0
01:0000062C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000630 00000000        	     1R 	dc.l 0
01:00000634 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000638 00000000        	     1R 	dc.l 0
01:0000063C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000640 00000000        	     1R 	dc.l 0
01:00000644 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000648 00000000        	     1R 	dc.l 0
01:0000064C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000650 00000000        	     1R 	dc.l 0
01:00000654 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000658 00000000        	     1R 	dc.l 0
01:0000065C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000660 00000000        	     1R 	dc.l 0
01:00000664 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000668 00000000        	     1R 	dc.l 0
01:0000066C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000670 00000000        	     1R 	dc.l 0
01:00000674 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000678 00000000        	     1R 	dc.l 0
01:0000067C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000680 00000000        	     1R 	dc.l 0
01:00000684 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000688 00000000        	     1R 	dc.l 0
01:0000068C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000690 00000000        	     1R 	dc.l 0
01:00000694 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000698 00000000        	     1R 	dc.l 0
01:0000069C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006A0 00000000        	     1R 	dc.l 0
01:000006A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006A8 00000000        	     1R 	dc.l 0
01:000006AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006B0 00000000        	     1R 	dc.l 0
01:000006B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006B8 00000000        	     1R 	dc.l 0
01:000006BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006C0 00000000        	     1R 	dc.l 0
01:000006C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006C8 00000000        	     1R 	dc.l 0
01:000006CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006D0 00000000        	     1R 	dc.l 0
01:000006D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006D8 00000000        	     1R 	dc.l 0
01:000006DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006E0 00000000        	     1R 	dc.l 0
01:000006E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006E8 00000000        	     1R 	dc.l 0
01:000006EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006F0 00000000        	     1R 	dc.l 0
01:000006F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006F8 00000000        	     1R 	dc.l 0
01:000006FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000700 00000000        	     1R 	dc.l 0
01:00000704 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000708 00000000        	     1R 	dc.l 0
01:0000070C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000710 00000000        	     1R 	dc.l 0
01:00000714 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000718 00000000        	     1R 	dc.l 0
01:0000071C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000720 00000000        	     1R 	dc.l 0
01:00000724 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000728 00000000        	     1R 	dc.l 0
01:0000072C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000730 00000000        	     1R 	dc.l 0
01:00000734 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000738 00000000        	     1R 	dc.l 0
01:0000073C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000740 00000000        	     1R 	dc.l 0
01:00000744 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000748 00000000        	     1R 	dc.l 0
01:0000074C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000750 00000000        	     1R 	dc.l 0
01:00000754 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000758 00000000        	     1R 	dc.l 0
01:0000075C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000760 00000000        	     1R 	dc.l 0
01:00000764 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000768 00000000        	     1R 	dc.l 0
01:0000076C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000770 00000000        	     1R 	dc.l 0
01:00000774 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000778 00000000        	     1R 	dc.l 0
01:0000077C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000780 00000000        	     1R 	dc.l 0
01:00000784 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000788 00000000        	     1R 	dc.l 0
01:0000078C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000790 00000000        	     1R 	dc.l 0
01:00000794 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000798 00000000        	     1R 	dc.l 0
01:0000079C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007A0 00000000        	     1R 	dc.l 0
01:000007A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007A8 00000000        	     1R 	dc.l 0
01:000007AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007B0 00000000        	     1R 	dc.l 0
01:000007B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007B8 00000000        	     1R 	dc.l 0
01:000007BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007C0 00000000        	     1R 	dc.l 0
01:000007C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007C8 00000000        	     1R 	dc.l 0
01:000007CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007D0 00000000        	     1R 	dc.l 0
01:000007D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007D8 00000000        	     1R 	dc.l 0
01:000007DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007E0 00000000        	     1R 	dc.l 0
01:000007E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007E8 00000000        	     1R 	dc.l 0
01:000007EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007F0 00000000        	     1R 	dc.l 0
01:000007F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007F8 00000000        	     1R 	dc.l 0
01:000007FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000800 00000000        	     1R 	dc.l 0
01:00000804 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000808 00000000        	     1R 	dc.l 0
01:0000080C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000810 00000000        	     1R 	dc.l 0
01:00000814 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000818 00000000        	     1R 	dc.l 0
01:0000081C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000820 00000000        	     1R 	dc.l 0
01:00000824 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000828 00000000        	     1R 	dc.l 0
01:0000082C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000830 00000000        	     1R 	dc.l 0
01:00000834 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000838 00000000        	     1R 	dc.l 0
01:0000083C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000840 00000000        	     1R 	dc.l 0
01:00000844 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000848 00000000        	     1R 	dc.l 0
01:0000084C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000850 00000000        	     1R 	dc.l 0
01:00000854 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000858 00000000        	     1R 	dc.l 0
01:0000085C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000860 00000000        	     1R 	dc.l 0
01:00000864 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000868 00000000        	     1R 	dc.l 0
01:0000086C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000870 00000000        	     1R 	dc.l 0
01:00000874 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000878 00000000        	     1R 	dc.l 0
01:0000087C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000880 00000000        	     1R 	dc.l 0
01:00000884 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000888 00000000        	     1R 	dc.l 0
01:0000088C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000890 00000000        	     1R 	dc.l 0
01:00000894 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000898 00000000        	     1R 	dc.l 0
01:0000089C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008A0 00000000        	     1R 	dc.l 0
01:000008A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008A8 00000000        	     1R 	dc.l 0
01:000008AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008B0 00000000        	     1R 	dc.l 0
01:000008B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008B8 00000000        	     1R 	dc.l 0
01:000008BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008C0 00000000        	     1R 	dc.l 0
01:000008C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008C8 00000000        	     1R 	dc.l 0
01:000008CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008D0 00000000        	     1R 	dc.l 0
01:000008D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008D8 00000000        	     1R 	dc.l 0
01:000008DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008E0 00000000        	     1R 	dc.l 0
01:000008E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008E8 00000000        	     1R 	dc.l 0
01:000008EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008F0 00000000        	     1R 	dc.l 0
01:000008F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008F8 00000000        	     1R 	dc.l 0
01:000008FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000900 00000000        	     1R 	dc.l 0
01:00000904 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000908 00000000        	     1R 	dc.l 0
01:0000090C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000910 00000000        	     1R 	dc.l 0
01:00000914 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000918 00000000        	     1R 	dc.l 0
01:0000091C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000920 00000000        	     1R 	dc.l 0
01:00000924 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000928 00000000        	     1R 	dc.l 0
01:0000092C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000930 00000000        	     1R 	dc.l 0
01:00000934 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000938 00000000        	     1R 	dc.l 0
01:0000093C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000940 00000000        	     1R 	dc.l 0
01:00000944 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000948 00000000        	     1R 	dc.l 0
01:0000094C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000950 00000000        	     1R 	dc.l 0
01:00000954 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000958 00000000        	     1R 	dc.l 0
01:0000095C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000960 00000000        	     1R 	dc.l 0
01:00000964 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000968 00000000        	     1R 	dc.l 0
01:0000096C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000970 00000000        	     1R 	dc.l 0
01:00000974 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000978 00000000        	     1R 	dc.l 0
01:0000097C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000980 00000000        	     1R 	dc.l 0
01:00000984 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000988 00000000        	     1R 	dc.l 0
01:0000098C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000990 00000000        	     1R 	dc.l 0
01:00000994 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000998 00000000        	     1R 	dc.l 0
01:0000099C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009A0 00000000        	     1R 	dc.l 0
01:000009A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009A8 00000000        	     1R 	dc.l 0
01:000009AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009B0 00000000        	     1R 	dc.l 0
01:000009B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009B8 00000000        	     1R 	dc.l 0
01:000009BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009C0 00000000        	     1R 	dc.l 0
01:000009C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009C8 00000000        	     1R 	dc.l 0
01:000009CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009D0 00000000        	     1R 	dc.l 0
01:000009D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009D8 00000000        	     1R 	dc.l 0
01:000009DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009E0 00000000        	     1R 	dc.l 0
01:000009E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009E8 00000000        	     1R 	dc.l 0
01:000009EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009F0 00000000        	     1R 	dc.l 0
01:000009F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009F8 00000000        	     1R 	dc.l 0
01:000009FC 00000000        	     2R 	dc.l 0
                            	     3R 	
                            	   298: 
                            	   299: 	org			$A00
                            	   300: 
                            	   301: ;-------------------------------------------------------------------------------
                            	   302: ;-------------------------------------------------------------------------------
                            	   303: 
                            	   304: ; BIOS variables which must be local (not shared) to each core
                            	   305: 
                            	   306: CursorRow	equ		$40000
                            	   307: CursorCol	equ		$40001
                            	   308: TextPos		equ		$40002
                            	   309: TextCurpos	equ	$40002
                            	   310: TextScr			equ	$40004
                            	   311: S19StartAddress	equ	$40008
                            	   312: KeybdEcho		equ	$4000C
                            	   313: KeybdWaitFlag	equ	$4000D
                            	   314: CmdBuf			equ $40040
                            	   315: CmdBufEnd		equ	$40080
                            	   316: fgColor			equ	$40084
                            	   317: bkColor			equ	$40088
                            	   318: TextRows		equ	$4008C
                            	   319: TextCols		equ	$4008D
                            	   320: _fpTextIncr	equ $40094
                            	   321: _canary			equ $40098
                            	   322: tickcnt			equ $4009C
                            	   323: IRQFlag			equ $400A0
                            	   324: InputDevice	equ $400A4
                            	   325: OutputDevice	equ $400A8
                            	   326: Regsave			equ	$40100
                            	   327: numBreakpoints	equ		8
                            	   328: BreakpointFlag	equ		$40200
                            	   329: NumSetBreakpoints	equ	$40202	; to $40203
                            	   330: Breakpoints			equ		$40220	; to $40240
                            	   331: BreakpointWords	equ		$40280	; to $402A0
                            	   332: fpBuf       equ $402C0
                            	   333: ;RunningTCB  equ $40300
                            	   334: _exp equ $40500
                            	   335: _digit equ $40504
                            	   336: _width equ $40508
                            	   337: _E equ $4050C
                            	   338: _digits_before_decpt equ $40510
                            	   339: _precision equ $40514
                            	   340: _fpBuf equ $40520	; to $40560
                            	   341: _fpWork equ $40600
                            	   342: _dasmbuf	equ	$40800
                            	   343: OFFSET equ $40880
                            	   344: pen_color equ $40890
                            	   345: gr_x equ $40894
                            	   346: gr_y equ $40898
                            	   347: gr_width equ $4089C
                            	   348: gr_height equ $408A0
                            	   349: gr_bitmap_screen equ $408A4
                            	   350: gr_raster_op equ $408A8
                            	   351: gr_double_buffer equ $408AC
                            	   352: gr_bitmap_buffer equ $408B0
                            	   353: sys_switches equ $408B8
                            	   354: EightPixels equ $40100000	; to $40200020
                            	   355: 
                            	   356: null_dcb equ $0040A00		; 0
                            	   357: keybd_dcb equ $0040A40	; 1
                            	   358: con_dcb equ $0040A80		; 2
                            	   359: err_dcb equ $0040AC0		; 3
                            	   360: serial_dcb equ $0040B40	; 5
                            	   361: 
                            	   362: TimerStack	equ	$40BFC
                            	   363: 
                            	   364: ; Keyboard buffer is in shared memory
                            	   365: IOFocus			EQU	$00100000
                            	   366: memend			equ $00100004
                            	   367: KeybdLEDs		equ	$0010000E
                            	   368: _KeyState1	equ	$0010000F
                            	   369: _KeyState2	equ	$00100010
                            	   370: _KeybdHead	equ	$00100011
                            	   371: _KeybdTail	equ	$00100012
                            	   372: _KeybdCnt		equ	$00100013
                            	   373: KeybdID			equ	$00100018
                            	   374: _Keybd_tick	equ $0001001C
                            	   375: _KeybdBuf		equ	$00100020
                            	   376: _KeybdOBuf	equ	$00100080
                            	   377: S19Checksum	equ	$00100150
                            	   378: SerTailRcv	equ	$00100160
                            	   379: SerHeadRcv	equ	$00100162
                            	   380: SerRcvXon		equ	$00100164
                            	   381: SerRcvXoff	equ	$00100165
                            	   382: SerTailXmit	equ	$00100166
                            	   383: SerHeadXmit	equ	$00100168
                            	   384: SerXmitXoff	equ	$0010016A
                            	   385: SerRcvBuf		equ	$00101000
                            	   386: SerXmitBuf	equ	$00102000
                            	   387: RTCBuf			equ $00100200	; to $0010023F
                            	   388: 
                            	   389: 	code
                            	   390: 	align		2
                            	   391: start:
                            	   392: ;	fadd (a0)+,fp2
00:000003B8 46FC2700        	   393: 	move.w #$2700,sr					; enable level 6 and higher interrupts
00:000003BC 7000            	   394: 	moveq #0,d0								; set address space zero
00:000003BE 4E7B0003        	   395: 	movec d0,asid
                            	   396: 	; Setup circuit select signals
00:000003C2 203CFDC00000    	   397: 	move.l #MMU,d0
00:000003C8 4E7B0014        	   398: 	movec d0,mmus
                            	   399: 	if HAS_MMU
                            	   400: 		move.l #$01F00000,d0			; set virtual address for iop bitmap
                            	   401: 		movec d0,iops
                            	   402: 		move.l #$01E00000,d0			; set virtual address for io block
                            	   403: 		movec d0,ios
                            	   404: 	else
00:000003CC 203CFD100000    	   405: 		move.l #$FD100000,d0			; set virtual address for iop bitmap
00:000003D2 4E7B0016        	   406: 		movec d0,iops
00:000003D6 203CFD000000    	   407: 		move.l #$FD000000,d0			; set virtual address for io block
00:000003DC 4E7B0015        	   408: 		movec d0,ios
                            	   409: 	endif
                            	   410: ;	move.l $4000000C,d0
00:000003E0 4E7A0FE0        	   411: 	movec coreno,d0							; set initial value of thread register
00:000003E4 4840            	   412: 	swap d0											; coreno in high eight bits
00:000003E6 E188            	   413: 	lsl.l #8,d0
00:000003E8 4E7B0012        	   414: 	movec d0,tr
                            	   415: 	; Prepare local variable storage
00:000003EC 303C03FF        	   416: 	move.w #1023,d0						; 1024 longs to clear
00:000003F0 41F900040000    	   417: 	lea	$40000,a0							; non shared local memory address
                            	   418: .0111:
00:000003F6 4298            	   419: 	clr.l	(a0)+								; clear the memory area
00:000003F8 51C8FFFC        	   420: 	dbra d0,.0111
00:000003FC 6100015C        	   421: 	bsr setup_null
00:00000400 61005F3A        	   422: 	bsr setup_keybd
00:00000404 61000184        	   423: 	bsr setup_console
00:00000408 61007BB2        	   424: 	bsr setup_serial
00:0000040C 13FC0002000400A8	   425: 	move.b #2,OutputDevice		; select text screen output
                            	   426: 	if (SCREEN_FORMAT==1)
00:00000414 23FC000000FF0004	   427: 		move.l #$0000ff,fgColor		; set foreground / background color (white)
00:0000041C 0084
00:0000041E 23FC000000020004	   428: 		move.l #$000002,bkColor		; medium blue
00:00000426 0088
                            	   429: 	else
                            	   430: 		move.l #$1fffff,fgColor		; set foreground / background color (white)
                            	   431: 		move.l #$00003f,bkColor		; medium blue
                            	   432: 	endif
00:00000428 4E7A0FE0        	   433: 	movec.l	coreno,d0					; get core number (2 to 9)
00:0000042C 5500            	   434: 	subi.b #2,d0							; adjust (0 to 7)
                            	   435: 	if (SCREEN_FORMAT==1)
00:0000042E C0FC2000        	   436: 		mulu #8192,d0						; compute screen location
                            	   437: 	else
                            	   438: 		mulu #16384,d0						; compute screen location
                            	   439: 	endif
                            	   440: 	if HAS_MMU
                            	   441: 		addi.l #$01E00000,d0
                            	   442: 	else
00:00000432 0680FD000000    	   443: 		addi.l #$FD000000,d0
                            	   444: 	endif
00:00000438 23C000040004    	   445: 	move.l d0,TextScr
00:0000043E 13FC00400004008D	   446: 	move.b #64,TextCols				; set rows and columns
00:00000446 13FC00200004008C	   447: 	move.b #32,TextRows
00:0000044E 4E7A0FE0        	   448: 	movec.l	coreno,d0					; get core number
00:00000452 0C000002        	   449: 	cmpi.b #2,d0
00:00000456 660000DA        	   450: 	bne	start_other
00:0000045A 6100020A        	   451: 	bsr init_framebuf
00:0000045E 42B9000408B8    	   452: 	clr.l sys_switches
00:00000464 33FC1F0000040890	   453: 	move.w #$1f00,pen_color		; blue pen
00:0000046C 42B900040894    	   454: 	clr.l gr_x
00:00000472 42B900040898    	   455: 	clr.l gr_y
00:00000478 13FC0001000408A8	   456: 	move.b #1,gr_raster_op		; op = copy
00:00000480 33FC03200004089C	   457: 	move.w #800,gr_width
00:00000488 33FC0258000408A0	   458: 	move.w #600,gr_height
00:00000490 23FC400000000004	   459: 	move.l #$40000000,gr_bitmap_screen
00:00000498 08A4
00:0000049A 23FC401000000004	   460: 	move.l #$40100000,gr_bitmap_buffer
00:000004A2 08B0
00:000004A4 23FC00000040FD20	   461: 	move.l #$00000040,FRAMEBUF+16	; base addr 1
00:000004AC 0010
00:000004AE 23FC00001040FD20	   462: 	move.l #$00001040,FRAMEBUF+24	; base addr 2
00:000004B6 0018
00:000004B8 13C000100000    	   463: 	move.b d0,IOFocus					; Set the IO focus in global memory
                            	   464: 	if HAS_MMU
                            	   465: 		bsr InitMMU							; Can't access anything till this is done'
                            	   466: 	endif
00:000004BE 610001D0        	   467: 	bsr	InitIOPBitmap					; not going to get far without this
00:000004C2 610002BE        	   468: 	bsr	InitSemaphores
00:000004C6 61000214        	   469: 	bsr	InitRand
00:000004CA 61000250        	   470: 	bsr RandGetNum
00:000004CE 0281FFFFFF00    	   471: 	andi.l #$FFFFFF00,d1
00:000004D4 23C100040098    	   472: 	move.l d1,_canary
00:000004DA 4E7B1020        	   473: 	movec d1,canary
00:000004DE 61000362        	   474: 	bsr	Delay3s						; give devices time to reset
00:000004E2 61005546        	   475: 	bsr	clear_screen
                            	   476: 
00:000004E6 61005F90        	   477: 	bsr	_KeybdInit
                            	   478: ;	bsr	InitIRQ
00:000004EA 61007BAC        	   479: 	bsr	SerialInit
                            	   480: ;	bsr init_i2c
                            	   481: ;	bsr rtc_read
                            	   482: 
                            	   483: 	; Write startup message to screen
                            	   484: 
00:000004EE 43F900008918    	   485: 	lea	msg_start,a1
00:000004F4 61005822        	   486: 	bsr	DisplayString
                            	   487: ;	bsr	FemtikiInit
00:000004F8 4E7A0FE0        	   488: 	movec	coreno,d0
00:000004FC 4840            	   489: 	swap d0
00:000004FE 7201            	   490: 	moveq	#1,d1
00:00000500 610002E2        	   491: 	bsr	UnlockSemaphore	; allow another cpu access
00:00000504 7200            	   492: 	moveq	#0,d1
00:00000506 610002DC        	   493: 	bsr	UnlockSemaphore	; allow other cpus to proceed
00:0000050A 33FCA4A4FD0FFF00	   494: 	move.w #$A4A4,leds			; diagnostics
00:00000512 61005DF2        	   495: 	bsr	init_plic				; initialize platform level interrupt controller
00:00000516 6000688A        	   496: 	bra	StartMon
00:0000051A 61000366        	   497: 	bsr	cpu_test
                            	   498: ;	lea	brdisp_trap,a0	; set brdisp trap vector
                            	   499: ;	move.l	a0,64*4
                            	   500: 
                            	   501: loop2:
00:0000051E 70FF            	   502: 	move.l	#-1,d0
                            	   503: loop1:
00:00000520 2200            	   504: 	move.l	d0,d1
00:00000522 E089            	   505: 	lsr.l		#8,d1
00:00000524 E089            	   506: 	lsr.l		#8,d1
00:00000526 13C1FD0FFF00    	   507: 	move.b	d1,leds
00:0000052C 51C8FFF2        	   508: 	dbra		d0,loop1
00:00000530 60EC            	   509: 	bra			loop2
                            	   510: 
                            	   511: start_other:
00:00000532 61000332        	   512: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:00000536 6100032E        	   513: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:0000053A 6100032A        	   514: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:0000053E 610054EA        	   515: 	bsr			clear_screen
00:00000542 4E7A1FE0        	   516: 	movec		coreno,d1
00:00000546 61007728        	   517: 	bsr			DisplayByte
00:0000054A 43F90000893F    	   518: 	lea			msg_core_start,a1
00:00000550 610057C6        	   519: 	bsr			DisplayString
                            	   520: ;	bsr			FemtikiInitIRQ
                            	   521: do_nothing:	
00:00000554 6000684C        	   522: 	bra			StartMon
00:00000558 60FA            	   523: 	bra			do_nothing
                            	   524: 
                            	   525: ;------------------------------------------------------------------------------
                            	   526: ; Initialize the MMU to allow thread #0 access to IO
                            	   527: ;------------------------------------------------------------------------------
                            	   528: 	if HAS_MMU
                            	   529: 	align 2
                            	   530: mmu_adrtbl:	; virtual address[24:16], physical address[31:16] bytes reversed!
                            	   531: 	dc.l	$0010,$10000300	; global scratch pad
                            	   532: 	dc.l	$01E0,$00FD0300	
                            	   533: 	dc.l	$01E1,$01FD0300
                            	   534: 	dc.l	$01E2,$02FD0300
                            	   535: 	dc.l  $01E3,$03FD0300
                            	   536: 	dc.l	$01E5,$05FD0300
                            	   537: 	dc.l	$01E6,$06FD0300
                            	   538: 	dc.l	$01E9,$09FD0300
                            	   539: 	dc.l	$01EF,$0FFD0300
                            	   540: 	dc.l	$01F0,$10FD0300
                            	   541: 	dc.l  $01FF,$FFFF0300	; all ones output for IRQ ack needed
                            	   542: 
                            	   543: 	even
                            	   544: InitMMU:
                            	   545: 	lea MMU+8,a0				; first 128kB is local RAM
                            	   546: 	move.l #$32000,d2		; map all pages to DRAM
                            	   547: 	move.l #510,d0			; then override for IO later
                            	   548: .0002
                            	   549: 	move.l d2,d1
                            	   550: 	bsr rbo
                            	   551: 	move.l d1,(a0)+
                            	   552: 	addi.w #1,d2				; increment DRAM page number
                            	   553: 	dbra d0,.0002
                            	   554: 	lea MMU,a0					; now program IO access
                            	   555: 	lea mmu_adrtbl,a1
                            	   556: 	moveq #10,d0
                            	   557: .0001
                            	   558: 	move.l (a1)+,d2
                            	   559: 	lsl.l #2,d2
                            	   560: 	move.l (a1)+,(a0,d2.w)
                            	   561: 	dbra d0,.0001
                            	   562: 	rts	
                            	   563: 	endif
                            	   564: 
                            	   565: ;------------------------------------------------------------------------------
                            	   566: ; Setup the NULL device
                            	   567: ;------------------------------------------------------------------------------
                            	   568: 
                            	   569: null_init:
                            	   570: setup_null:
00:0000055A 701F            	   571: 	moveq #31,d0
00:0000055C 41F900040A00    	   572: 	lea.l null_dcb,a0
                            	   573: .0001:
00:00000562 4298            	   574: 	clr.l (a0)+
00:00000564 51C8FFFC        	   575: 	dbra d0,.0001
00:00000568 23FC204243440004	   576: 	move.l #$20424344,null_dcb+DCB_MAGIC				; 'DCB'
00:00000570 0A00
00:00000572 23FC4C4C554E0004	   577: 	move.l #$4C4C554E,null_dcb+DCB_NAME					; 'NULL'
00:0000057A 0A04
00:0000057C 23FC000005880004	   578: 	move.l #null_cmdproc,null_dcb+DCB_CMDPROC
00:00000584 0A18
                            	   579: null_ret:
00:00000586 4E75            	   580: 	rts
                            	   581: 
                            	   582: null_cmdproc:
00:00000588 4E75            	   583: 	rts
                            	   584: 
                            	   585: ;------------------------------------------------------------------------------
                            	   586: ; Setup the console device
                            	   587: ; stdout = text screen controller
                            	   588: ;------------------------------------------------------------------------------
                            	   589: 
                            	   590: console_init:
                            	   591: setup_console:
00:0000058A 701F            	   592: 	moveq #31,d0
00:0000058C 41F900040A80    	   593: 	lea.l con_dcb,a0
                            	   594: .0001:
00:00000592 4298            	   595: 	clr.l (a0)+
00:00000594 51C8FFFC        	   596: 	dbra d0,.0001
00:00000598 23FC204243440004	   597: 	move.l #$20424344,con_dcb+DCB_MAGIC				; 'DCB'
00:000005A0 0A80
00:000005A2 23FC204E4F430004	   598: 	move.l #$204E4F43,con_dcb+DCB_NAME				; 'CON'
00:000005AA 0A84
00:000005AC 23FC000006280004	   599: 	move.l #console_cmdproc,con_dcb+DCB_CMDPROC
00:000005B4 0A98
00:000005B6 4E7A0FE0        	   600: 	movec.l	coreno,d0					; get core number (2 to 9)
00:000005BA 5500            	   601: 	subi.b #2,d0							; adjust (0 to 7)
00:000005BC C0FC4000        	   602: 	mulu #16384,d0						; compute screen location
                            	   603: 	if HAS_MMU
                            	   604: 		addi.l #$01E00000,d0
                            	   605: 	else
00:000005C0 0680FD000000    	   606: 		addi.l #$FD000000,d0
                            	   607: 	endif
00:000005C6 23C000040AA8    	   608: 	move.l d0,con_dcb+DCB_INBUFPTR
00:000005CC 23C000040AAC    	   609: 	move.l d0,con_dcb+DCB_OUTBUFPTR
00:000005D2 23FC000040000004	   610: 	move.l #16384,con_dcb+DCB_INBUFSIZE
00:000005DA 0AB0
00:000005DC 23FC000040000004	   611: 	move.l #16384,con_dcb+DCB_OUTBUFSIZE
00:000005E4 0AB4
00:000005E6 13FC004000040ABB	   612: 	move.b #64,con_dcb+DCB_OUTCOLS	; set rows and columns
00:000005EE 13FC002000040ABA	   613: 	move.b #32,con_dcb+DCB_OUTROWS
00:000005F6 13FC004000040AB9	   614: 	move.b #64,con_dcb+DCB_INCOLS		; set rows and columns
00:000005FE 13FC002000040AB8	   615: 	move.b #32,con_dcb+DCB_INROWS
00:00000606 4E75            	   616: 	rts
                            	   617: 
                            	   618: 	align 2
                            	   619: CON_CMDTBL:
00:00000608 0000058A        	   620: 	dc.l console_init
00:0000060C 0000064E        	   621: 	dc.l console_stat
00:00000610 00000652        	   622: 	dc.l console_putchar
00:00000614 00000662        	   623: 	dc.l console_putbuf
00:00000618 0000065A        	   624: 	dc.l console_getchar
00:0000061C 00000662        	   625: 	dc.l console_getbuf
00:00000620 00000662        	   626: 	dc.l console_set_inpos
00:00000624 00000662        	   627: 	dc.l console_set_outpos
                            	   628: 
                            	   629: console_cmdproc:
00:00000628 0C060008        	   630: 	cmpi.b #8,d6
00:0000062C 641C            	   631: 	bhs.s .0001
00:0000062E 4A06            	   632: 	tst.b d6
00:00000630 6B18            	   633: 	bmi.s .0001
00:00000632 48E70280        	   634: 	movem.l d6/a0,-(a7)
00:00000636 E506            	   635: 	asl.b #2,d6
00:00000638 4886            	   636: 	ext.w d6
00:0000063A 41FAFFCC        	   637: 	lea CON_CMDTBL,a0
00:0000063E 20706000        	   638: 	move.l (a0,d6.w),a0
00:00000642 4E90            	   639: 	jsr (a0)
00:00000644 4CDF0140        	   640: 	movem.l (a7)+,d6/a0
00:00000648 4E75            	   641: 	rts
                            	   642: .0001:
00:0000064A 7002            	   643: 	moveq #E_Func,d0
00:0000064C 4E75            	   644: 	rts
                            	   645: 
                            	   646: console_stat:
00:0000064E 7000            	   647: 	moveq #E_Ok,d0
00:00000650 4E75            	   648: 	rts
                            	   649: 
                            	   650: console_putchar:
00:00000652 61005464        	   651: 	bsr DisplayChar
00:00000656 7000            	   652: 	moveq #E_Ok,d0
00:00000658 4E75            	   653: 	rts
                            	   654: 
                            	   655: console_getchar:
00:0000065A 6100673C        	   656: 	bsr FromScreen
00:0000065E 7000            	   657: 	moveq #E_Ok,d0
00:00000660 4E75            	   658: 	rts
                            	   659: 
                            	   660: console_putbuf:
                            	   661: console_getbuf:
                            	   662: console_set_inpos:
                            	   663: console_set_outpos:
00:00000662 700A            	   664: 	moveq #E_NotSupported,d0
00:00000664 4E75            	   665: 	rts
                            	   666: 
                            	   667: ;------------------------------------------------------------------------------
                            	   668: ;------------------------------------------------------------------------------
                            	   669: 
                            	   670: init_framebuf:
00:00000666 4E75            	   671: 	rts
00:00000668 13FC0001FD200000	   672: 	move.b #1,FRAMEBUF+0		; turn on frame buffer
00:00000670 13FC0001FD200001	   673: 	move.b #1,FRAMEBUF+1		; color depth 16 BPP
00:00000678 13FC0011FD200002	   674: 	move.b #$11,FRAMEBUF+2	; hres 1:1 vres 1:1
00:00000680 4E75            	   675: 	rts
                            	   676: 
                            	   677: ;------------------------------------------------------------------------------
                            	   678: ;------------------------------------------------------------------------------
                            	   679: 
                            	   680: GlobalReadLong:
00:00000682 2210            	   681: 		move.l (a0),d1
00:00000684 4E75            	   682: 		rts
00:00000686 6004            	   683: 		bra nd1
                            	   684: GlobalWriteLong:
00:00000688 2081            	   685: 		move.l d1,(a0)
00:0000068A 4E75            	   686: 		rts
                            	   687: net_delay:
                            	   688: 		bra nd1
                            	   689: nd1	bra nd2
                            	   690: nd2 bra nd3
                            	   691: nd3 bra nd4
00:0000068C 4E71            	   692: nd4	nop
00:0000068E 4E75            	   693: 		rts
                            	   694: 	
                            	   695: 
                            	   696: ;------------------------------------------------------------------------------
                            	   697: ; The IO bitmap needs to be initialized to allow access to IO.
                            	   698: ;------------------------------------------------------------------------------
                            	   699: 
                            	   700: InitIOPBitmap:
00:00000690 7600            	   701: 	moveq #0,d3				; d3 = asid value
00:00000692 303C003F        	   702: 	move.w #63,d0			; 64 bitmaps to setup
00:00000696 4E7A8016        	   703: 	movec iops,a0			; a0 = IOP bitmap address
00:0000069A 2248            	   704: 	movea.l a0,a1			; a1 = table address
                            	   705: .0004
00:0000069C 4A03            	   706: 	tst.b d3
00:0000069E 57C1            	   707: 	seq d1						; set entire bitmap for asid 0, otherwise clear entire bitmap
00:000006A0 4881            	   708: 	ext.w	d1					; make into a long value
00:000006A2 48C1            	   709: 	ext.l d1
00:000006A4 383C007F        	   710: 	move.w #127,d4
                            	   711: .0001
00:000006A8 22C1            	   712: 	move.l d1,(a1)+		; set or clear entire table
00:000006AA 51CCFFFC        	   713: 	dbra d4,.0001
00:000006AE 72FF            	   714: 	moveq #-1,d1
00:000006B0 214100A0        	   715: 	move.l d1,160(a0)	; all io address spaces have access to semaphores
00:000006B4 214100A4        	   716: 	move.l d1,164(a0)
00:000006B8 214100A8        	   717: 	move.l d1,168(a0)
00:000006BC 214100AC        	   718: 	move.l d1,172(a0)
00:000006C0 214101FC        	   719: 	move.l d1,508(a0)	; all io address spaces access random # generator
00:000006C4 4840            	   720: 	swap d0
00:000006C6 303C001F        	   721: 	move.w #31,d0			; 32 long words for the screen area per bitmap
                            	   722: .0003
00:000006CA 20C1            	   723: 	move.l d1,(a0)+		; all cores have access to a screen
00:000006CC 51C8FFFC        	   724: 	dbra d0,.0003
00:000006D0 4840            	   725: 	swap d0
00:000006D2 5203            	   726: 	addi.b #1,d3			; do next address space
00:000006D4 2049            	   727: 	movea.l a1,a0			; a0 points to area for next address space
00:000006D6 51C8FFC4        	   728: 	dbra d0,.0004
00:000006DA 4E75            	   729: 	rts	
                            	   730: 	
                            	   731: ;------------------------------------------------------------------------------
                            	   732: ; RandInit
                            	   733: ; 	Initialize random number generator.
                            	   734: ;
                            	   735: ; Modifies:
                            	   736: ;		none
                            	   737: ; Parameters:
                            	   738: ;		none
                            	   739: ;	Returns:
                            	   740: ;		none
                            	   741: ;------------------------------------------------------------------------------
                            	   742: 
                            	   743: InitRand:
                            	   744: RandInit:
00:000006DC 48E7C000        	   745: 	movem.l	d0/d1,-(a7)
00:000006E0 7025            	   746: 	moveq #37,d0								; lock semaphore
00:000006E2 7204            	   747: 	moveq	#RAND_SEMA,d1
00:000006E4 4E4F            	   748: 	trap #15
00:000006E6 4E7A0FE0        	   749: 	movec coreno,d0							; d0 = core number
00:000006EA ED88            	   750: 	lsl.l	#6,d0									; allow 64 streams per core
00:000006EC 23C0FD0FFD04    	   751: 	move.l d0,RAND_STRM					; select the stream
00:000006F2 23FC12345678FD0F	   752: 	move.l #$12345678,RAND_MZ		; initialize to some value
00:000006FA FD08
00:000006FC 23FC98765432FD0F	   753: 	move.l #$98765432,RAND_MW
00:00000704 FD0C
00:00000706 23FC2E5BF271FD0F	   754: 	move.l #777777777,RAND_NUM	; generate first number
00:0000070E FD00
00:00000710 7026            	   755: 	moveq #38,d0								; unlock semaphore
00:00000712 7204            	   756: 	moveq	#RAND_SEMA,d1
00:00000714 4E4F            	   757: 	trap #15
00:00000716 4CDF0003        	   758: 	movem.l	(a7)+,d0/d1
00:0000071A 4E75            	   759: 	rts
                            	   760: 
                            	   761: ;------------------------------------------------------------------------------
                            	   762: ; Returns
                            	   763: ;		d1 = random integer
                            	   764: ;------------------------------------------------------------------------------
                            	   765: 
                            	   766: RandGetNum:
00:0000071C 48E7A000        	   767: 	movem.l	d0/d2,-(a7)
00:00000720 7204            	   768: 	moveq #RAND_SEMA,d1
00:00000722 610000DC        	   769: 	bsr T15LockSemaphore
00:00000726 4E7A0FE0        	   770: 	movec	coreno,d0
00:0000072A ED88            	   771: 	lsl.l	#6,d0
00:0000072C 23C0FD0FFD04    	   772: 	move.l d0,RAND_STRM					; select the stream
00:00000732 2439FD0FFD00    	   773: 	move.l RAND_NUM,d2					; d2 = random number
00:00000738 42B9FD0FFD00    	   774: 	clr.l	RAND_NUM							; generate next number
00:0000073E 610000C6        	   775: 	bsr T15UnlockSemaphore
00:00000742 2202            	   776: 	move.l d2,d1
00:00000744 4CDF0005        	   777: 	movem.l	(a7)+,d0/d2
00:00000748 4E75            	   778: 	rts
                            	   779: 
                            	   780: ;------------------------------------------------------------------------------
                            	   781: ; Modifies:
                            	   782: ;		none
                            	   783: ; Returns
                            	   784: ;		fp0 = random float between 0 and 1.
                            	   785: ;------------------------------------------------------------------------------
                            	   786: 
                            	   787: _GetRand:
00:0000074A 2F01            	   788: 	move.l d1,-(sp)
00:0000074C F2276880        	   789: 	fmove.x fp1,-(sp)
00:00000750 61CA            	   790: 	bsr RandGetNum
00:00000752 E289            	   791: 	lsr.l #1,d1									; make number between 0 and 2^31
00:00000754 F2014000        	   792: 	fmove.l d1,fp0
00:00000758 F23C40807FFFFFFF	   793: 	fmove.l #$7FFFFFFF,fp1			; divide by 2^31
00:00000760 F2000420        	   794: 	fdiv fp1,fp0
00:00000764 F21F4880        	   795: 	fmove.x (sp)+,fp1
00:00000768 221F            	   796: 	move.l (sp)+,d1
00:0000076A 4E75            	   797: 	rts
                            	   798: 
                            	   799: ;------------------------------------------------------------------------------
                            	   800: ; RandWait
                            	   801: ;    Wait some random number of clock cycles before returning.
                            	   802: ;------------------------------------------------------------------------------
                            	   803: 
                            	   804: RandWait:
00:0000076C 48E7C000        	   805: 	movem.l	d0/d1,-(a7)
00:00000770 61AA            	   806: 	bsr			RandGetNum
00:00000772 0241000F        	   807: 	andi.w	#15,d1
                            	   808: .0001:
00:00000776 4E71            	   809: 	nop
00:00000778 51C9FFFC        	   810: 	dbra		d1,.0001
00:0000077C 4CDF0003        	   811: 	movem.l	(a7)+,d0/d1
00:00000780 4E75            	   812: 	rts
                            	   813: 
                            	   814: ;------------------------------------------------------------------------------
                            	   815: ; Initialize semaphores
                            	   816: ; - all semaphores are set to unlocked except the first one, which is locked
                            	   817: ; for core #2.
                            	   818: ;
                            	   819: ; Parameters:
                            	   820: ;		<none>
                            	   821: ; Modifies:
                            	   822: ;		<none>
                            	   823: ; Returns:
                            	   824: ;		<none>
                            	   825: ;------------------------------------------------------------------------------
                            	   826: 
                            	   827: InitSemaphores:
00:00000782 48E74080        	   828: 	movem.l	d1/a0,-(a7)
00:00000786 41F9FD050000    	   829: 	lea			semamem,a0
00:0000078C 217C000200002000	   830: 	move.l	#$20000,$2000(a0)	; lock the first semaphore for core #2, thread #0
00:00000794 323C00FE        	   831: 	move.w	#254,d1
                            	   832: .0001:
00:00000798 5888            	   833: 	lea			4(a0),a0
00:0000079A 42A82000        	   834: 	clr.l		$2000(a0)					; write zeros to unlock
00:0000079E 51C9FFF8        	   835: 	dbra		d1,.0001
00:000007A2 4CDF0102        	   836: 	movem.l	(a7)+,d1/a0
00:000007A6 4E75            	   837: 	rts
                            	   838: 
                            	   839: ; -----------------------------------------------------------------------------
                            	   840: ; Parameters:
                            	   841: ;		d1 semaphore number
                            	   842: ;
                            	   843: ; Side Effects:
                            	   844: ;		increments semaphore, saturates at 255
                            	   845: ;
                            	   846: ; Returns:	
                            	   847: ; 	z flag set if semaphore was zero
                            	   848: ; -----------------------------------------------------------------------------
                            	   849: 
                            	   850: ;IncrementSemaphore:
                            	   851: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   852: ;	lea			semamem,a0			; point to semaphore memory
                            	   853: ;	ext.w		d1							; make d1 word value
                            	   854: ;	asl.w		#4,d1						; align to memory
                            	   855: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   856: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   857: ;	rts
                            	   858: 	
                            	   859: ; -----------------------------------------------------------------------------
                            	   860: ; Parameters:
                            	   861: ;		d1 semaphore number
                            	   862: ;
                            	   863: ; Side Effects:
                            	   864: ;		decrements semaphore, saturates at zero
                            	   865: ;
                            	   866: ; Returns:	
                            	   867: ; 	z flag set if semaphore was zero
                            	   868: ; -----------------------------------------------------------------------------
                            	   869: 
                            	   870: ;DecrementSemaphore:
                            	   871: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   872: ;	lea			semamem,a0			; point to semaphore memory
                            	   873: ;	andi.w	#255,d1					; make d1 word value
                            	   874: ;	asl.w		#4,d1						; align to memory
                            	   875: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   876: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   877: ;	rts
                            	   878: 
                            	   879: ; -----------------------------------------------------------------------------
                            	   880: ; Lock a semaphore
                            	   881: ;
                            	   882: ; Parameters:
                            	   883: ;		d0 = key
                            	   884: ;		d1 = semaphore number
                            	   885: ; -----------------------------------------------------------------------------
                            	   886: 
                            	   887: LockSemaphore:
00:000007A8 4E75            	   888: 	rts
00:000007AA 48E74080        	   889: 	movem.l	d1/a0,-(a7)			; save registers
00:000007AE 41F9FD050000    	   890: 	lea			semamem,a0			; point to semaphore memory lock area
00:000007B4 024100FF        	   891: 	andi.w	#255,d1					; make d1 word value
00:000007B8 E549            	   892: 	lsl.w		#2,d1						; align to memory
                            	   893: .0001
00:000007BA 21801000        	   894: 	move.l	d0,(a0,d1.w)		; try and write the semaphore
00:000007BE B0B01000        	   895: 	cmp.l		(a0,d1.w),d0		; did it lock?
00:000007C2 66F6            	   896: 	bne.s		.0001						; no, try again
00:000007C4 4CDF0102        	   897: 	movem.l	(a7)+,a0/d1			; restore regs
00:000007C8 4E75            	   898: 	rts
                            	   899: 	
                            	   900: ; -----------------------------------------------------------------------------
                            	   901: ; Unlocks a semaphore even if not the owner.
                            	   902: ;
                            	   903: ; Parameters:
                            	   904: ;		d1 semaphore number
                            	   905: ; -----------------------------------------------------------------------------
                            	   906: 
                            	   907: ForceUnlockSemaphore:
00:000007CA 48E74080        	   908: 	movem.l	d1/a0,-(a7)				; save registers
00:000007CE 41F9FD053000    	   909: 	lea			semamem+$3000,a0	; point to semaphore memory read/write area
00:000007D4 024100FF        	   910: 	andi.w	#255,d1						; make d1 word value
00:000007D8 E549            	   911: 	lsl.w		#2,d1							; align to memory
00:000007DA 42B01000        	   912: 	clr.l		(a0,d1.w)					; write zero to unlock
00:000007DE 4CDF0102        	   913: 	movem.l	(a7)+,a0/d1				; restore regs
00:000007E2 4E75            	   914: 	rts
                            	   915: 
                            	   916: ; -----------------------------------------------------------------------------
                            	   917: ; Unlocks a semaphore. Must be the owner to have effect.
                            	   918: ; Three cases:
                            	   919: ;	1) the owner, the semaphore will be reset to zero
                            	   920: ;	2) not the owner, the write will be ignored
                            	   921: ; 3) already unlocked, the write will be ignored
                            	   922: ;
                            	   923: ; Parameters:
                            	   924: ;		d0 = key
                            	   925: ;		d1 = semaphore number
                            	   926: ; -----------------------------------------------------------------------------
                            	   927: 
                            	   928: UnlockSemaphore:
00:000007E4 60E4            	   929: 	bra ForceUnlockSemaphore
00:000007E6 48E74080        	   930: 	movem.l	d1/a0,-(a7)				; save registers
00:000007EA 41F9FD051000    	   931: 	lea			semamem+$1000,a0	; point to semaphore memory unlock area
00:000007F0 024100FF        	   932: 	andi.w	#255,d1						; make d1 word value
00:000007F4 E549            	   933: 	lsl.w		#2,d1							; align to memory
00:000007F6 21801000        	   934: 	move.l	d0,(a0,d1.w)			; write matching value to unlock
00:000007FA 4CDF0102        	   935: 	movem.l	(a7)+,a0/d1				; restore regs
00:000007FE 4E75            	   936: 	rts
                            	   937: 
                            	   938: ; -----------------------------------------------------------------------------
                            	   939: ; Parameters:
                            	   940: ;		d1 = semaphore to lock / unlock
                            	   941: ; -----------------------------------------------------------------------------
                            	   942: 
                            	   943: T15LockSemaphore:	
00:00000800 4E7A0012        	   944: 	movec tr,d0
00:00000804 60A2            	   945: 	bra LockSemaphore
                            	   946: 
                            	   947: T15UnlockSemaphore:
00:00000806 4E7A0012        	   948: 	movec tr,d0
00:0000080A 60D8            	   949: 	bra UnlockSemaphore
                            	   950: 
                            	   951: T15GetFloat:
00:0000080C 2049            	   952: 	move.l a1,a0
00:0000080E 2001            	   953: 	move.l d1,d0
00:00000810 61007386        	   954: 	bsr _GetFloat
00:00000814 2248            	   955: 	move.l a0,a1
00:00000816 2200            	   956: 	move.l d0,d1
00:00000818 4E75            	   957: 	rts
                            	   958: 
                            	   959: T15Abort:
00:0000081A 61007454        	   960: 	bsr DisplayByte
00:0000081E 43F9000089BA    	   961: 	lea msgStackCanary,a1
00:00000824 61005508        	   962: 	bsr DisplayStringCRLF
00:00000828 60006582        	   963: 	bra Monitor
                            	   964: 
                            	   965: chk_exception:
00:0000082C 222F0002        	   966: 	move.l 2(sp),d1
00:00000830 61007432        	   967: 	bsr DisplayTetra
00:00000834 43F9000089AC    	   968: 	lea msgChk,a1
00:0000083A 610054F2        	   969: 	bsr DisplayStringCRLF
00:0000083E 6000656C        	   970: 	bra Monitor
                            	   971: 
                            	   972: ; -----------------------------------------------------------------------------
                            	   973: ; Delay for a few seconds to allow some I/O reset operations to take place.
                            	   974: ; -----------------------------------------------------------------------------
                            	   975: 
                            	   976: Delay3s:
00:00000842 203C002DC6C0    	   977: 	move.l	#3000000,d0		; this should take a few seconds to loop
00:00000848 41F9FD0FFF00    	   978: 	lea			leds,a0				; a0 = address of LED output register
00:0000084E 6002            	   979: 	bra			dly3s1				; branch to the loop
                            	   980: dly3s2:	
00:00000850 4840            	   981: 	swap		d0						; loop is larger than 16-bits
                            	   982: dly3s1:
00:00000852 2200            	   983: 	move.l	d0,d1					; the counter cycles fast, so use upper bits for display
00:00000854 E199            	   984: 	rol.l		#8,d1					; could use swap here, but lets test rol
00:00000856 E199            	   985: 	rol.l		#8,d1
00:00000858 1081            	   986: 	move.b	d1,(a0)				; set the LEDs
00:0000085A 51C8FFF6        	   987: 	dbra		d0,dly3s1			; decrement and branch back
00:0000085E 4840            	   988: 	swap		d0
00:00000860 51C8FFEE        	   989: 	dbra		d0,dly3s2
00:00000864 4E75            	   990: 	rts
                            	   991: 
                            	   992: Delay3s2:
00:00000866 4E7A0FE0        	   993: 	movec		coreno,d0			; vary delay by core to stagger startup
00:0000086A E188            	   994: 	lsl.l		#8,d0
00:0000086C 0680002DC6C0    	   995: 	addi.l	#3000000,d0		; this should take a few seconds to loop
00:00000872 6002            	   996: 	bra			.0001					; branch to the loop
                            	   997: .0002	
00:00000874 4840            	   998: 	swap		d0						; loop is larger than 16-bits
                            	   999: .0001
00:00000876 51C8FFFE        	  1000: 	dbra		d0,.0001			; decrement and branch back
00:0000087A 4840            	  1001: 	swap		d0
00:0000087C 51C8FFF6        	  1002: 	dbra		d0,.0002
00:00000880 4E75            	  1003: 	rts
                            	  1004: 
                            	  1005: 	include "cputest.x68"

Source: "cputest.x68"
                            	     1: ;; @name cputest.s Tests 68000 cpu
                            	     2: ;
                            	     3: ; Based on https://github.com/MicroCoreLabs/Projects/blob/master/MCL68/MC68000_Test_Code/MC68000_test_all_opcodes.X68
                            	     4: ;
                            	     5: ; Converted into a CD-i system ROM image by CD-i Fan:
                            	     6: ; - comment lines must start in first column
                            	     7: ; - replaced org instructions by suitable rept
                            	     8: ; - copy vectors to low memory at startup
                            	     9: ; - replaced jsr/jmp by bsr/bra for position independence
                            	    10: ; - replaced move.l by moveq whenever possible
                            	    11: ; - converted branches to short form whenever possible (e.g. beq => beq.s)
                            	    12: ; - added immediate suffix to opcodes where required (e.g. and => andi)
                            	    13: ; The last three modifications are required to make the test work;
                            	    14: ; apparently the original assembler was somewhat smarter then
                            	    15: ; the Microware OS-9 assembler and did this automatically.
                            	    16: ;
                            	    17: ; In some cases the opcodes of the test are used as test data!
                            	    18: ;
                            	    19: ; Original file header follows.
                            	    20: ;
                            	    21: ;  File Name   :  MCL68 Opcode Tests
                            	    22: ;  Used on     :
                            	    23: ;  Author      :  Ted Fried, MicroCore Labs
                            	    24: ;  Creation    :  7/14/2020
                            	    25: ;
                            	    26: ;   Description:
                            	    27: ;   ============
                            	    28: ;
                            	    29: ;  Program to test all of the Motorola 68000's opcodes.
                            	    30: ;
                            	    31: ;  If failures are detected, the code will immediately loop on itself.
                            	    32: ;  All addressing modes, data sizes, and opcode combinations are tested.
                            	    33: ;
                            	    34: ;  This code was developed using the Easy68K simulator where all tests passed!
                            	    35: ;
                            	    36: ;------------------------------------------------------------------------
                            	    37: ;
                            	    38: ; Modification History:
                            	    39: ; =====================
                            	    40: ;
                            	    41: ; Revision 1 7/14/2020
                            	    42: ; Initial revision
                            	    43: ;
                            	    44: ;
                            	    45: ;------------------------------------------------------------------------
                            	    46: ;
                            	    47: ; Copyright (c) 2020 Ted Fried
                            	    48: ;
                            	    49: ; Permission is hereby granted, free of charge, to any person obtaining a copy
                            	    50: ; of this software and associated documentation files (the "Software"), to deal
                            	    51: ; in the Software without restriction, including without limitation the rights
                            	    52: ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                            	    53: ; copies of the Software, and to permit persons to whom the Software is
                            	    54: ; furnished to do so, subject to the following conditions:
                            	    55: ;
                            	    56: ; The above copyright notice and this permission notice shall be included in all
                            	    57: ; copies or substantial portions of the Software.
                            	    58: ;
                            	    59: ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            	    60: ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            	    61: ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            	    62: ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            	    63: ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                            	    64: ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                            	    65: ; SOFTWARE.
                            	    66: 
                            	    67: ; Modified for rf68000 project (c) 2022 Robert Finch
                            	    68: 
                            	    69: ;	data
                            	    70: ;	dc.l		$0001FFFC						; top of local ram area
                            	    71: ;	dc.l		start
                            	    72: 
                            	    73: ;    org $1000												; code starts at $400 in local ram
                            	    74: *start:
                            	    75: ;	move.l	$FFFFFFE0,d0		; get core number
                            	    76: ;	cmpi.b	#2,d0
                            	    77: ;	bne			do_nothing
                            	    78: 
                            	    79: ;	lea			EXCEPTION_6,a0	; check exception vector
                            	    80: ;	move.l	a0,6*4
                            	    81: ;	lea			EXCEPTION_7,a0	; TRAPV exception vector
                            	    82: ;	move.l	a0,7*4
                            	    83: 
                            	    84: cpu_test:
00:00000882 610000F6        	    85: 	bsr	op_ORI_TO_CCR
00:00000886 61000114        	    86: 	bsr	op_ORI_TO_SR
00:0000088A 61000132        	    87: 	bsr	op_EORI_TO_CCR
00:0000088E 61000154        	    88: 	bsr	op_EORI_TO_SR
00:00000892 61000176        	    89: 	bsr	op_ANDI_TO_CCR
00:00000896 61000198        	    90: 	bsr	op_ANDI_TO_SR
00:0000089A 610001BA        	    91: 	bsr	op_BTST
00:0000089E 61000560        	    92: 	bsr	op_BCHG
00:000008A2 610008C4        	    93: 	bsr	op_BCLR
00:000008A6 61000C0E        	    94: 	bsr	op_BSET
00:000008AA 61000F52        	    95: 	bsr op_MOVEP
00:000008AE 61000FDA        	    96: 	bsr op_BOOL_I
00:000008B2 610011BE        	    97: 	bsr op_CMP_I
00:000008B6 610013A2        	    98: 	bsr op_ADD_I
00:000008BA 61001524        	    99: 	bsr op_SUB_I
00:000008BE 610016A6        	   100: 	bsr op_MOVE
00:000008C2 610018AE        	   101: 	bsr op_MOVE_xxx_FLAGS
00:000008C6 61001A9E        	   102: 	bsr op_EXT
00:000008CA 61001AC6        	   103: 	bsr op_SWAP
00:000008CE 61001AD8        	   104: 	bsr op_LEAPEA
00:000008D2 61001B80        	   105: 	bsr op_TAS
00:000008D6 61001BA2        	   106: 	bsr op_TST
00:000008DA 61001BDC        	   107: 	bsr op_LINKS
00:000008DE 61001BF6        	   108: 	bsr op_MOVE_USP
00:000008E2 61001C02        	   109: 	bsr op_CHK
00:000008E6 61001C48        	   110: 	bsr op_NEGS
00:000008EA 61001FD2        	   111: 	bsr op_MOVEM
                            	   112: ;	bsr op_ABCD
                            	   113: ;	bsr op_SBCD
                            	   114: ;	bsr op_NBCD
00:000008EE 6100256E        	   115: 	bsr op_TRAPV
00:000008F2 61002586        	   116: 	bsr op_RTR
00:000008F6 61001144        	   117: 	bsr op_BSR
00:000008FA 610025A0        	   118: 	bsr op_BCC
00:000008FE 6100261C        	   119: 	bsr op_DBCC
00:00000902 6100263E        	   120: 	bsr op_SCC
00:00000906 6100266A        	   121: 	bsr op_ADDQ
00:0000090A 61002720        	   122: 	bsr op_SUBQ
00:0000090E 610027D6        	   123: 	bsr op_MOVEQ
                            	   124: ;	bsr op_DIVU
                            	   125: ;	bsr op_DIVS
00:00000912 61002892        	   126: 	bsr op_OR
00:00000916 61002978        	   127: 	bsr op_AND
00:0000091A 61002A5E        	   128: 	bsr op_EOR
00:0000091E 61002AD0        	   129: 	bsr op_CMP
00:00000922 61002B42        	   130: 	bsr op_CMPA
00:00000926 61002BA4        	   131: 	bsr op_CMPM
00:0000092A 61002C46        	   132: 	bsr op_ADD
00:0000092E 61002D2C        	   133: 	bsr op_SUB
00:00000932 61002E12        	   134: 	bsr op_ADDA
00:00000936 61002E5A        	   135: 	bsr op_SUBA
00:0000093A 61002EA2        	   136: 	bsr op_ADDX	
00:0000093E 61002FAE        	   137: 	bsr op_SUBX
00:00000942 610030BA        	   138: 	bsr op_MULU
00:00000946 61003102        	   139: 	bsr op_MULS
00:0000094A 6100314A        	   140: 	bsr op_EXG
00:0000094E 610031B4        	   141: 	bsr op_ROx
00:00000952 610033E6        	   142: 	bsr op_ROXx
00:00000956 61003618        	   143: 	bsr op_SHIFTS
00:0000095A 61003856        	   144: 	bsr op_SHIFTS2
                            	   145: 
00:0000095E 4E75            	   146: 	rts
                            	   147: 	bra ALL_DONE
                            	   148: 
                            	   149: * Loop here when all tests pass
                            	   150: *
                            	   151: 
00:00000960 60FE            	   152: ALL_DONE: bra.s ALL_DONE
                            	   153: 
00:00000962 263C33333333    	   154: BSR_FAR1:       move.l #$33333333,d3
00:00000968 4E75            	   155:                 rts
                            	   156: 
                            	   157: ;	moveq		#-1,d0
                            	   158: ;	move.l	d0,$FD0FFF00
                            	   159: ;do_nothing:
                            	   160: ;	bra			*		
                            	   161: 
                            	   162: 
                            	   163: ;' Exception Vector = 6   CHK Instruction
                            	   164: ;
                            	   165: ;	align	4
                            	   166: EXCEPTION_6:
00:0000096A 2C3CEEEE0006    	   167: 	move.l #$EEEE0006,d6      * Set d6 to the exception vector
00:00000970 4E73            	   168: 	rte
                            	   169: 
                            	   170: ; Exception Vector = 7   TRAPV Instruction
                            	   171: ;
                            	   172: ;	align	4
                            	   173: EXCEPTION_7:
00:00000972 203C12345678    	   174: 	move.l #$12345678,d0      * Set d6 to the exception vector
00:00000978 4E73            	   175: 	rte
                            	   176: 
                            	   177: ;-----------------------------------------------------------
                            	   178: ;-----------------------------------------------------------
                            	   179: ; OPCODE : ORI_TO_CCR
                            	   180: ;-----------------------------------------------------------
                            	   181: ;-----------------------------------------------------------
                            	   182: op_ORI_TO_CCR:
                            	   183: 
00:0000097A 003C00FF        	   184:     ori.b #$FF,CCR
00:0000097E 6AFE            	   185:     bpl.s *                   ; branch if Z clear
00:00000980 66FE            	   186:     bne.s *                   ; branch if N clear
00:00000982 68FE            	   187:     bvc.s *                   ; branch if V clear
00:00000984 64FE            	   188:     bcc.s *                   ; branch if C clear
                            	   189: 
00:00000986 44FC0000        	   190:     move #$00,CCR
00:0000098A 003C0000        	   191:     ori.b #$00,CCR
00:0000098E 67FE            	   192:     beq.s *                   ; branch if Z set
00:00000990 6BFE            	   193:     bmi.s *                   ; branch if N set
00:00000992 69FE            	   194:     bvs.s *                   ; branch if V set
00:00000994 65FE            	   195:     bcs.s *                   ; branch if C set
                            	   196: 
00:00000996 46FC2700        	   197:     move.w #$2700,SR          ; Put flags back to initial value
                            	   198: 
00:0000099A 4E75            	   199:     rts
                            	   200: 
                            	   201: ;-----------------------------------------------------------
                            	   202: ;-----------------------------------------------------------
                            	   203: ; OPCODE : ORI_TO_SR
                            	   204: ;-----------------------------------------------------------
                            	   205: ;-----------------------------------------------------------
                            	   206: 
                            	   207: op_ORI_TO_SR:
                            	   208: 
00:0000099C 007C2FFF        	   209:     ori.w #$2FFF,SR
00:000009A0 6AFE            	   210:     bpl.s *                   * branch if Z clear
00:000009A2 66FE            	   211:     bne.s *                   * branch if N clear
00:000009A4 68FE            	   212:     bvc.s *                   * branch if V clear
00:000009A6 64FE            	   213:     bcc.s *                   * branch if C clear
                            	   214: 
00:000009A8 46FC2000        	   215:     move.w #$2000,SR
00:000009AC 007C0000        	   216:     ori.w #$0000,SR
00:000009B0 67FE            	   217:     beq.s *                   * branch if Z set
00:000009B2 6BFE            	   218:     bmi.s *                   * branch if N set
00:000009B4 69FE            	   219:     bvs.s *                   * branch if V set
00:000009B6 65FE            	   220:     bcs.s *                   * branch if C set
                            	   221: 
00:000009B8 46FC2700        	   222:     move.w #$2700,sr         * Put flags back to initial value
                            	   223: 
00:000009BC 4E75            	   224:     rts
                            	   225: ; 
                            	   226: ;-----------------------------------------------------------
                            	   227: ;-----------------------------------------------------------
                            	   228: ; OPCODE : EORI_TO_CCR
                            	   229: ;-----------------------------------------------------------
                            	   230: ;-----------------------------------------------------------
                            	   231: op_EORI_TO_CCR:
                            	   232: 
00:000009BE 44FC0000        	   233:     move #$00,CCR
00:000009C2 0A3C00FF        	   234:     eori.b #$FF,CCR
00:000009C6 6AFE            	   235:     bpl.s *                   ; branch if Z clear
00:000009C8 66FE            	   236:     bne.s *                   ; branch if N clear
00:000009CA 68FE            	   237:     bvc.s *                   ; branch if V clear
00:000009CC 64FE            	   238:     bcc.s *                   ; branch if C clear
                            	   239: 
00:000009CE 44FC0000        	   240:     move #$00,CCR
00:000009D2 0A3C0000        	   241:     eori.b #$00,CCR
00:000009D6 67FE            	   242:     beq.s *                   ; branch if Z set
00:000009D8 6BFE            	   243:     bmi.s *                   ; branch if N set
00:000009DA 69FE            	   244:     bvs.s *                   ; branch if V set
00:000009DC 65FE            	   245:     bcs.s *                   ; branch if C set
                            	   246: 
00:000009DE 46FC2700        	   247:     move.w #$2700,sr           ; Put flags back to initial value
                            	   248: 
00:000009E2 4E75            	   249:     rts
                            	   250: 
                            	   251: 
                            	   252: 
                            	   253: *-----------------------------------------------------------
                            	   254: *-----------------------------------------------------------
                            	   255: * OPCODE : EORI_TO_SR
                            	   256: *-----------------------------------------------------------
                            	   257: *-----------------------------------------------------------
                            	   258: op_EORI_TO_SR:
                            	   259: 
00:000009E4 46FC2000        	   260:     move.w #$2000,SR
00:000009E8 0A7C0FFF        	   261:     eori.w #$0FFF,SR
00:000009EC 6AFE            	   262:     bpl.s *                   * branch if Z clear
00:000009EE 66FE            	   263:     bne.s *                   * branch if N clear
00:000009F0 68FE            	   264:     bvc.s *                   * branch if V clear
00:000009F2 64FE            	   265:     bcc.s *                   * branch if C clear
                            	   266: 
00:000009F4 46FC2000        	   267:     move.w #$2000,SR
00:000009F8 0A7C0000        	   268:     eori.w #$0000,SR
00:000009FC 67FE            	   269:     beq.s *                   * branch if Z set
00:000009FE 6BFE            	   270:     bmi.s *                   * branch if N set
00:00000A00 69FE            	   271:     bvs.s *                   * branch if V set
00:00000A02 65FE            	   272:     bcs.s *                   * branch if C set
                            	   273: 
00:00000A04 46FC2700        	   274:     move.w #$2700,sr          * Put flags back to initial value
                            	   275: 
00:00000A08 4E75            	   276:     rts
                            	   277: 
                            	   278: 
                            	   279: 
                            	   280: *-----------------------------------------------------------
                            	   281: *-----------------------------------------------------------
                            	   282: * OPCODE : ANDI_TO_CCR
                            	   283: *-----------------------------------------------------------
                            	   284: *-----------------------------------------------------------
                            	   285: op_ANDI_TO_CCR:
                            	   286: 
00:00000A0A 44FC00FF        	   287:     move #$FF,CCR
00:00000A0E 023C00FF        	   288:     andi.b #$FF,CCR
00:00000A12 6AFE            	   289:     bpl.s *                   * branch if Z clear
00:00000A14 66FE            	   290:     bne.s *                   * branch if N clear
00:00000A16 68FE            	   291:     bvc.s *                   * branch if V clear
00:00000A18 64FE            	   292:     bcc.s *                   * branch if C clear
                            	   293: 
00:00000A1A 44FC00FF        	   294:     move #$FF,CCR
00:00000A1E 023C0000        	   295:     andi.b #$00,CCR
00:00000A22 67FE            	   296:     beq.s *                   * branch if Z set
00:00000A24 6BFE            	   297:     bmi.s *                   * branch if N set
00:00000A26 69FE            	   298:     bvs.s *                   * branch if V set
00:00000A28 65FE            	   299:     bcs.s *                   * branch if C set
                            	   300: 
00:00000A2A 46FC2700        	   301:     move #$2700,SR           * Put flags back to initial value
                            	   302: 
00:00000A2E 4E75            	   303:     rts
                            	   304: 
                            	   305: 
                            	   306: 
                            	   307: *-----------------------------------------------------------
                            	   308: *-----------------------------------------------------------
                            	   309: * OPCODE : ANDI_TO_SR
                            	   310: *-----------------------------------------------------------
                            	   311: *-----------------------------------------------------------
                            	   312: op_ANDI_TO_SR:
00:00000A30 46FC20FF        	   313:     move.w #$20FF,SR
00:00000A34 027CFFFF        	   314:     andi.w #$FFFF,SR
00:00000A38 6AFE            	   315:     bpl.s *                   * branch if Z clear
00:00000A3A 66FE            	   316:     bne.s *                   * branch if N clear
00:00000A3C 68FE            	   317:     bvc.s *                   * branch if V clear
00:00000A3E 64FE            	   318:     bcc.s *                   * branch if C clear
                            	   319: 
00:00000A40 46FC20FF        	   320:     move.w #$20FF,SR
00:00000A44 027CFF00        	   321:     andi.w #$FF00,SR
00:00000A48 67FE            	   322:     beq.s *                   * branch if Z set
00:00000A4A 6BFE            	   323:     bmi.s *                   * branch if N set
00:00000A4C 69FE            	   324:     bvs.s *                   * branch if V set
00:00000A4E 65FE            	   325:     bcs.s *                   * branch if C set
                            	   326: 
00:00000A50 46FC2700        	   327:     move.w #$2700,sr           * Put flags back to initial value
                            	   328: 
00:00000A54 4E75            	   329:     rts
                            	   330: 
                            	   331: 
                            	   332: *-----------------------------------------------------------
                            	   333: *-----------------------------------------------------------
                            	   334: * OPCODE : BTST
                            	   335: *-----------------------------------------------------------
                            	   336: *-----------------------------------------------------------
                            	   337: op_BTST:
                            	   338: 
                            	   339: *  Bit Number.s Static
                            	   340: 
                            	   341: *             EA = Dn  - LONG only
00:00000A56 203C80000001    	   342:             move.l #$80000001,d0      * populate test data
00:00000A5C 08000000        	   343:             btst.l #0,d0
00:00000A60 67FE            	   344:             beq.s *               * branch if Z set
00:00000A62 08000001        	   345:             btst.l #1,d0              *
00:00000A66 66FE            	   346:             bne.s *               * branch if Z clear
00:00000A68 0800001F        	   347:             btst.l #31,d0             *
00:00000A6C 67FE            	   348:             beq.s *               * branch if Z set
                            	   349: 
                            	   350: 
                            	   351: *             EA = (An)  - BYTE only
00:00000A6E 307C0100        	   352:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000A72 10BC0081        	   353:             move.b #$81,(a0)          * populate test data
00:00000A76 1210            	   354:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00000A78 08100000        	   355:             btst.b #0,(a0)
00:00000A7C 67FE            	   356:             beq.s *               * branch if Z set
00:00000A7E 08100001        	   357:             btst.b #1,(a0)            *
00:00000A82 66FE            	   358:             bne.s *               * branch if Z clear
00:00000A84 08100007        	   359:             btst.b #7,(a0)            *
00:00000A88 67FE            	   360:             beq.s *               * branch if Z set
                            	   361: 
                            	   362: 
                            	   363: *             EA = (An)+  - BYTE only
00:00000A8A 307C0100        	   364:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000A8E 10FC0001        	   365:             move.b #$01,(a0)+         * populate test data
00:00000A92 10FC00FC        	   366:             move.b #$FC,(a0)+         * populate test data
00:00000A96 10FC0080        	   367:             move.b #$80,(a0)+         * populate test data
00:00000A9A 307C0100        	   368:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000A9E 08180000        	   369:             btst.b #0,(a0)+
00:00000AA2 67FE            	   370:             beq.s *               * branch if Z set
00:00000AA4 08180001        	   371:             btst.b #1,(a0)+           *
00:00000AA8 66FE            	   372:             bne.s *               * branch if Z clear
00:00000AAA 08180007        	   373:             btst.b #7,(a0)+           *
00:00000AAE 67FE            	   374:             beq.s *               * branch if Z set
                            	   375: 
                            	   376: 
                            	   377: *             EA = -(An)  - BYTE only
00:00000AB0 307C0100        	   378:             move.l #$00000100,a0      * point to memory to address
00:00000AB4 10FC0080        	   379:             move.b #$80,(a0)+         * populate test data
00:00000AB8 10FC00FC        	   380:             move.b #$FC,(a0)+         * populate test data
00:00000ABC 10FC0001        	   381:             move.b #$01,(a0)+         * populate test data
00:00000AC0 307C0103        	   382:             move.l #$00000103,a0      * point to memory to address
00:00000AC4 08200000        	   383:             btst.b #0,-(a0)
00:00000AC8 67FE            	   384:             beq.s *               * branch if Z set
00:00000ACA 08200001        	   385:             btst.b #1,-(a0)           *
00:00000ACE 66FE            	   386:             bne.s *               * branch if Z clear
00:00000AD0 08200007        	   387:             btst.b #7,-(a0)           *
00:00000AD4 67FE            	   388:             beq.s *               * branch if Z set
                            	   389: 
                            	   390: 
                            	   391: *             EA = n(An)  - BYTE only
00:00000AD6 307C0100        	   392:             move.l #$00000100,a0      * point to memory to address
00:00000ADA 10FC0001        	   393:             move.b #$01,(a0)+         * populate test data
00:00000ADE 10FC00FC        	   394:             move.b #$FC,(a0)+         * populate test data
00:00000AE2 10FC0080        	   395:             move.b #$80,(a0)+         * populate test data
00:00000AE6 307C0100        	   396:             move.l #$00000100,a0      * point to memory to address
00:00000AEA 08100000        	   397:             btst.b #0,0(a0)
00:00000AEE 67FE            	   398:             beq.s *               * branch if Z set
00:00000AF0 082800010001    	   399:             btst.b #1,1(a0)           *
00:00000AF6 66FE            	   400:             bne.s *               * branch if Z clear
00:00000AF8 082800070002    	   401:             btst.b #7,2(a0)           *
00:00000AFE 67FE            	   402:             beq.s *               * branch if Z set
                            	   403: 
                            	   404: 
                            	   405: *             EA = n(An,R.W)  - BYTE only
00:00000B00 307C0100        	   406:             move.l #$00000100,a0      * point to memory to address
00:00000B04 93C9            	   407:             move.l #$00000000,a1      * point to memory to address
00:00000B06 347C0001        	   408:             move.l #$00000001,a2      * point to memory to address
00:00000B0A 7000            	   409:             moveq  #$00000000,d0      * point to memory to address
00:00000B0C 7201            	   410:             moveq  #$00000001,d1      * point to memory to address
00:00000B0E 083000000000    	   411:             btst.b #0,0(a0,d0.w)
00:00000B14 67FE            	   412:             beq.s *               * branch if Z set
00:00000B16 083000011000    	   413:             btst.b #1,0(a0,d1.w)      *
00:00000B1C 66FE            	   414:             bne.s *               * branch if Z clear
00:00000B1E 083000071001    	   415:             btst.b #7,1(a0,d1.w)      *
00:00000B24 67FE            	   416:             beq.s *               * branch if Z set
                            	   417: *             EA = n(An,R.L)  - BYTE only
00:00000B26 083000000800    	   418:             btst.b #0,0(a0,d0.l)
00:00000B2C 67FE            	   419:             beq.s *               * branch if Z set
00:00000B2E 083000011800    	   420:             btst.b #1,0(a0,d1.l)      *
00:00000B34 66FE            	   421:             bne.s *               * branch if Z clear
00:00000B36 083000071801    	   422:             btst.b #7,1(a0,d1.l)      *
00:00000B3C 67FE            	   423:             beq.s *               * branch if Z set
                            	   424: *             EA = n(An,A.W)  - BYTE only
00:00000B3E 083000009000    	   425:             btst.b #0,0(a0,a1.w)
00:00000B44 67FE            	   426:             beq.s *               * branch if Z set
00:00000B46 08300001A000    	   427:             btst.b #1,0(a0,a2.w)      *
00:00000B4C 66FE            	   428:             bne.s *               * branch if Z clear
00:00000B4E 08300007A001    	   429:             btst.b #7,1(a0,a2.w)      *
00:00000B54 67FE            	   430:             beq.s *               * branch if Z set
                            	   431: *             EA = n(An,A.L)  - BYTE only
00:00000B56 083000009800    	   432:             btst.b #0,0(a0,a1.l)
00:00000B5C 67FE            	   433:             beq.s *               * branch if Z set
00:00000B5E 08300001A800    	   434:             btst.b #1,0(a0,a2.l)      *
00:00000B64 66FE            	   435:             bne.s *               * branch if Z clear
00:00000B66 08300007A801    	   436:             btst.b #7,1(a0,a2.l)      *
00:00000B6C 67FE            	   437:             beq.s *               * branch if Z set
                            	   438: 
                            	   439: 
                            	   440: *             EA = x.W  - BYTE only
00:00000B6E 083800000100    	   441:             btst.b #0,$0100
00:00000B74 67FE            	   442:             beq.s *               * branch if Z set
00:00000B76 083800010101    	   443:             btst.b #1,$0101           *
00:00000B7C 66FE            	   444:             bne.s *               * branch if Z clear
00:00000B7E 083800070102    	   445:             btst.b #7,$0102           *
00:00000B84 67FE            	   446:             beq.s *               * branch if Z set
                            	   447: 
                            	   448: 
                            	   449: *             EA = x.L  - BYTE only
00:00000B86 207C0000F100    	   450:             move.l #$F100,a0      * point to memory to address 0x100
00:00000B8C 10FC0001        	   451:             move.b #$01,(a0)+         * populate test data
00:00000B90 10FC00FC        	   452:             move.b #$FC,(a0)+         * populate test data
00:00000B94 10FC0080        	   453:             move.b #$80,(a0)+         * populate test data
00:00000B98 083900000000F100	   454:             btst.b #0,$F100
00:00000BA0 67FE            	   455:             beq.s *               * branch if Z set
00:00000BA2 083900010000F101	   456:             btst.b #1,$F101       *
00:00000BAA 66FE            	   457:             bne.s *               * branch if Z clear
00:00000BAC 083900070000F102	   458:             btst.b #7,$F102       *
00:00000BB4 67FE            	   459:             beq.s *               * branch if Z set
                            	   460: 
                            	   461: 
                            	   462: *             EA = x(PC)  - BYTE only
00:00000BB6 4BFAFE9E        	   463:             lea op_BTST(pc),a5
00:00000BBA 083A0000FE98    	   464:             btst.b #0,op_BTST(pc)
00:00000BC0 66FE            	   465:             bne.s *               * branch if Z clear
00:00000BC2 083A0003001A    	   466:             btst.b #3,op_BTST0(pc)     *
00:00000BC8 67FE            	   467:             beq.s *               * branch if Z set
00:00000BCA 083A00060074    	   468:             btst.b #6,op_BTST12(pc)    *
00:00000BD0 67FE            	   469:             beq.s *               * branch if Z set
                            	   470: 
                            	   471: 
                            	   472: *             EA = n(PC,R.W)  - BYTE only
00:00000BD2 307C0100        	   473:             move.l #$00000100,a0      * point to memory to address
00:00000BD6 93C9            	   474:             move.l #$00000000,a1      * point to memory to address
00:00000BD8 347C0001        	   475:             move.l #$00000001,a2      * point to memory to address
00:00000BDC 7000            	   476:             moveq  #$00000000,d0      * point to memory to address
00:00000BDE 7201            	   477:             moveq  #$00000001,d1      * point to memory to address
                            	   478: 
00:00000BE0 083B000000FC    	   479: op_BTST0:   btst.b #0,op_BTST0(pc,d0.w)
00:00000BE6 66FE            	   480:             bne.s *               * branch if Z clear
                            	   481: 
00:00000BE8 4BFB1002        	   482:             lea op_BTST1(pc,d1.w),a5
00:00000BEC 083B000110FC    	   483: op_BTST1:   btst.b #1,op_BTST1(pc,d1.w)      *
00:00000BF2 67FE            	   484:             beq.s *               * branch if Z set
00:00000BF4 083B000710FC    	   485: op_BTST2:   btst.b #7,op_BTST2(pc,d1.w)      *
00:00000BFA 66FE            	   486:             bne.s *               * branch if Z clear
                            	   487: *             EA = n(PC,R.L)  - BYTE only
00:00000BFC 083B000008FC    	   488: op_BTST3:   btst.b #0,op_BTST3(pc,d0.l)
00:00000C02 66FE            	   489:             bne.s *               * branch if Z clear
00:00000C04 083B000118FC    	   490: op_BTST4:   btst.b #1,op_BTST4(pc,d1.l)      *
00:00000C0A 67FE            	   491:             beq.s *               * branch if Z set
00:00000C0C 083B000718FC    	   492: op_BTST5:   btst.b #7,op_BTST5(pc,d1.l)      *
00:00000C12 66FE            	   493:             bne.s *               * branch if Z clear
                            	   494: *             EA = n(PC,A.W)  - BYTE only
00:00000C14 083B000090FC    	   495: op_BTST6    btst.b #0,op_BTST6(pc,a1.w)
00:00000C1A 66FE            	   496:             bne.s *               * branch if Z clear
00:00000C1C 083B0001A0FC    	   497: op_BTST7:   btst.b #1,op_BTST7(pc,a2.w)      *
00:00000C22 67FE            	   498:             beq.s *               * branch if Z set
00:00000C24 083B0007A0FC    	   499: op_BTST8:   btst.b #7,op_BTST8(pc,a2.w)      *
00:00000C2A 66FE            	   500:             bne.s *               * branch if Z clear
                            	   501: *             EA = n(PC,A.L)  - BYTE only
00:00000C2C 083B000098FC    	   502: op_BTST9:   btst.b #0,op_BTST9(pc,a1.l)
00:00000C32 66FE            	   503:             bne.s *               * branch if Z clear
00:00000C34 083B0001A8FC    	   504: op_BTST10:  btst.b #1,op_BTST10(pc,a2.l)      *
00:00000C3A 67FE            	   505:             beq.s *               * branch if Z set
00:00000C3C 083B0007A8FC    	   506: op_BTST11:  btst.b #7,op_BTST11(pc,a2.l)      *
00:00000C42 66FE            	   507: op_BTST12:  bne.s *               * branch if Z clear
                            	   508: 
                            	   509: 
                            	   510: 
                            	   511: * Bit Number.s Dynamic
                            	   512: 
                            	   513: *             EA = Dn  - LONG only
00:00000C44 203C80000001    	   514:             move.l #$80000001,d0      * populate test data
00:00000C4A 7A00            	   515:             move.l #0,d5              * populate bit.s number to test
00:00000C4C 7C01            	   516:             move.l #1,d6              * populate bit.s number to test
00:00000C4E 7E1F            	   517:             move.l #31,d7              * populate bit.s number to test
                            	   518: 
00:00000C50 0B00            	   519:             btst.l d5,d0
00:00000C52 67FE            	   520:             beq.s *               * branch if Z set
00:00000C54 0D00            	   521:             btst.l d6,d0              *
00:00000C56 66FE            	   522:             bne.s *               * branch if Z clear
00:00000C58 0F00            	   523:             btst.l d7,d0             *
00:00000C5A 67FE            	   524:             beq.s *               * branch if Z set
                            	   525: 
                            	   526: 
                            	   527: *             EA = (An)  - BYTE only
00:00000C5C 7A00            	   528:             move.l #0,d5              * populate bit.s number to test
00:00000C5E 7C01            	   529:             move.l #1,d6              * populate bit.s number to test
00:00000C60 7E07            	   530:             move.l #7,d7              * populate bit.s number to test
00:00000C62 307C0100        	   531:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000C66 10BC0081        	   532:             move.b #$81,(a0)          * populate test data
00:00000C6A 1210            	   533:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00000C6C 0B10            	   534:             btst.b d5,(a0)
00:00000C6E 67FE            	   535:             beq.s *               * branch if Z set
00:00000C70 0D10            	   536:             btst.b d6,(a0)            *
00:00000C72 66FE            	   537:             bne.s *               * branch if Z clear
00:00000C74 0F10            	   538:             btst.b d7,(a0)            *
00:00000C76 67FE            	   539:             beq.s *               * branch if Z set
                            	   540: 
                            	   541: * ---
                            	   542: 
                            	   543: 
                            	   544: *             EA = (An)+  - BYTE only
00:00000C78 307C0100        	   545:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000C7C 10FC0001        	   546:             move.b #$01,(a0)+         * populate test data
00:00000C80 10FC00FC        	   547:             move.b #$FC,(a0)+         * populate test data
00:00000C84 10FC0080        	   548:             move.b #$80,(a0)+         * populate test data
00:00000C88 307C0100        	   549:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000C8C 0B18            	   550:             btst.b d5,(a0)+
00:00000C8E 67FE            	   551:             beq.s *               * branch if Z set
00:00000C90 0D18            	   552:             btst.b d6,(a0)+           *
00:00000C92 66FE            	   553:             bne.s *               * branch if Z clear
00:00000C94 0F18            	   554:             btst.b d7,(a0)+           *
00:00000C96 67FE            	   555:             beq.s *               * branch if Z set
                            	   556: 
                            	   557: 
                            	   558: *             EA = -(An)  - BYTE only
00:00000C98 307C0100        	   559:             move.l #$00000100,a0      * point to memory to address
00:00000C9C 10FC0080        	   560:             move.b #$80,(a0)+         * populate test data
00:00000CA0 10FC00FC        	   561:             move.b #$FC,(a0)+         * populate test data
00:00000CA4 10FC0001        	   562:             move.b #$01,(a0)+         * populate test data
00:00000CA8 307C0103        	   563:             move.l #$00000103,a0      * point to memory to address
00:00000CAC 0B20            	   564:             btst.b d5,-(a0)
00:00000CAE 67FE            	   565:             beq.s *               * branch if Z set
00:00000CB0 0D20            	   566:             btst.b d6,-(a0)           *
00:00000CB2 66FE            	   567:             bne.s *               * branch if Z clear
00:00000CB4 0F20            	   568:             btst.b d7,-(a0)           *
00:00000CB6 67FE            	   569:             beq.s *               * branch if Z set
                            	   570: 
                            	   571: 
                            	   572: *             EA = n(An)  - BYTE only
00:00000CB8 307C0100        	   573:             move.l #$00000100,a0      * point to memory to address
00:00000CBC 10FC0001        	   574:             move.b #$01,(a0)+         * populate test data
00:00000CC0 10FC00FC        	   575:             move.b #$FC,(a0)+         * populate test data
00:00000CC4 10FC0080        	   576:             move.b #$80,(a0)+         * populate test data
00:00000CC8 307C0100        	   577:             move.l #$00000100,a0      * point to memory to address
00:00000CCC 0B10            	   578:             btst.b d5,0(a0)
00:00000CCE 67FE            	   579:             beq.s *               * branch if Z set
00:00000CD0 0D280001        	   580:             btst.b d6,1(a0)           *
00:00000CD4 66FE            	   581:             bne.s *               * branch if Z clear
00:00000CD6 0F280002        	   582:             btst.b d7,2(a0)           *
00:00000CDA 67FE            	   583:             beq.s *               * branch if Z set
                            	   584: 
                            	   585: 
                            	   586: *             EA = n(An,R.W)  - BYTE only
00:00000CDC 307C0100        	   587:             move.l #$00000100,a0      * point to memory to address
00:00000CE0 93C9            	   588:             move.l #$00000000,a1      * point to memory to address
00:00000CE2 347C0001        	   589:             move.l #$00000001,a2      * point to memory to address
00:00000CE6 7000            	   590:             moveq  #$00000000,d0      * point to memory to address
00:00000CE8 7201            	   591:             moveq  #$00000001,d1      * point to memory to address
00:00000CEA 0B300000        	   592:             btst.b d5,0(a0,d0.w)
00:00000CEE 67FE            	   593:             beq.s *               * branch if Z set
00:00000CF0 0D301000        	   594:             btst.b d6,0(a0,d1.w)      *
00:00000CF4 66FE            	   595:             bne.s *               * branch if Z clear
00:00000CF6 0F301001        	   596:             btst.b d7,1(a0,d1.w)      *
00:00000CFA 67FE            	   597:             beq.s *               * branch if Z set
                            	   598: *             EA = n(An,R.L)  - BYTE only
00:00000CFC 0B300800        	   599:             btst.b d5,0(a0,d0.l)
00:00000D00 67FE            	   600:             beq.s *               * branch if Z set
00:00000D02 0D301800        	   601:             btst.b d6,0(a0,d1.l)      *
00:00000D06 66FE            	   602:             bne.s *               * branch if Z clear
00:00000D08 0F301801        	   603:             btst.b d7,1(a0,d1.l)      *
00:00000D0C 67FE            	   604:             beq.s *               * branch if Z set
                            	   605: *             EA = n(An,A.W)  - BYTE only
00:00000D0E 0B309000        	   606:             btst.b d5,0(a0,a1.w)
00:00000D12 67FE            	   607:             beq.s *               * branch if Z set
00:00000D14 0D30A000        	   608:             btst.b d6,0(a0,a2.w)      *
00:00000D18 66FE            	   609:             bne.s *               * branch if Z clear
00:00000D1A 0F30A001        	   610:             btst.b d7,1(a0,a2.w)      *
00:00000D1E 67FE            	   611:             beq.s *               * branch if Z set
                            	   612: *             EA = n(An,A.L)  - BYTE only
00:00000D20 0B309800        	   613:             btst.b d5,0(a0,a1.l)
00:00000D24 67FE            	   614:             beq.s *               * branch if Z set
00:00000D26 0D30A800        	   615:             btst.b d6,0(a0,a2.l)      *
00:00000D2A 66FE            	   616:             bne.s *               * branch if Z clear
00:00000D2C 0F30A801        	   617:             btst.b d7,1(a0,a2.l)      *
00:00000D30 67FE            	   618:             beq.s *               * branch if Z set
                            	   619: 
                            	   620: 
                            	   621: *             EA = x.W  - BYTE only
00:00000D32 0B380100        	   622:             btst.b d5,$0100
00:00000D36 67FE            	   623:             beq.s *               * branch if Z set
00:00000D38 0D380101        	   624:             btst.b d6,$0101           *
00:00000D3C 66FE            	   625:             bne.s *               * branch if Z clear
00:00000D3E 0F380102        	   626:             btst.b d7,$0102           *
00:00000D42 67FE            	   627:             beq.s *               * branch if Z set
                            	   628: 
                            	   629: 
                            	   630: *             EA = x.L  - BYTE only
00:00000D44 207C0000F100    	   631:             move.l #$F100,a0      * point to memory to address 0x100
00:00000D4A 10FC0001        	   632:             move.b #$01,(a0)+         * populate test data
00:00000D4E 10FC00FC        	   633:             move.b #$FC,(a0)+         * populate test data
00:00000D52 10FC0080        	   634:             move.b #$80,(a0)+         * populate test data
00:00000D56 0B390000F100    	   635:             btst.b d5,$F100
00:00000D5C 67FE            	   636:             beq.s *               * branch if Z set
00:00000D5E 0D390000F101    	   637:             btst.b d6,$F101       *
00:00000D64 66FE            	   638:             bne.s *               * branch if Z clear
00:00000D66 0F390000F102    	   639:             btst.b d7,$F102       *
00:00000D6C 67FE            	   640:             beq.s *               * branch if Z set
                            	   641: 
                            	   642: 
                            	   643: *             EA = x(PC)  - BYTE only
00:00000D6E 7C03            	   644:             move.l #3,d6              * populate bit.s number to test
00:00000D70 7E06            	   645:             move.l #6,d7              * populate bit.s number to test
00:00000D72 4BFAFCE2        	   646:             lea op_BTST(pc),a5
00:00000D76 0B3AFCDE        	   647:             btst.b d5,op_BTST(pc)
00:00000D7A 66FE            	   648:             bne.s *               * branch if Z clear
00:00000D7C 0D3AFE62        	   649:             btst.b d6,op_BTST0(pc)     *
00:00000D80 67FE            	   650:             beq.s *               * branch if Z set
00:00000D82 0F3AFEBE        	   651:             btst.b d7,op_BTST12(pc)    *
00:00000D86 67FE            	   652:             beq.s *               * branch if Z set
                            	   653: 
                            	   654: 
                            	   655: *             EA = n(PC,R.W)  - BYTE only
00:00000D88 307C0100        	   656:             move.l #$00000100,a0      * point to memory to address
00:00000D8C 93C9            	   657:             move.l #$00000000,a1      * point to memory to address
00:00000D8E 347C0001        	   658:             move.l #$00000001,a2      * point to memory to address
00:00000D92 7000            	   659:             moveq  #$00000000,d0      * point to memory to address
00:00000D94 7201            	   660:             moveq  #$00000001,d1      * point to memory to address
00:00000D96 7C01            	   661:             move.l #1,d6              * populate bit.s number to test
00:00000D98 7E07            	   662:             move.l #7,d7              * populate bit.s number to test
                            	   663: 
00:00000D9A 0B3B00FE        	   664: op_BTST20:  btst.b d5,op_BTST20(pc,d0.w)
00:00000D9E 67FE            	   665:             beq.s *               * branch if Z set
00:00000DA0 4BFB1002        	   666:             lea op_BTST21(pc,d1.w),a5
00:00000DA4 0D3B10FE        	   667: op_BTST21:  btst.b d6,op_BTST21(pc,d1.w)      *
00:00000DA8 67FE            	   668:             beq.s *               * branch if Z set
00:00000DAA 0F3B10FE        	   669: op_BTST22:  btst.b d7,op_BTST22(pc,d1.w)      *
00:00000DAE 66FE            	   670:             bne.s *               * branch if Z clear
                            	   671: *             EA = n(PC,R.L)  - BYTE only
00:00000DB0 0B3B08FE        	   672: op_BTST23:  btst.b d5,op_BTST23(pc,d0.l)
00:00000DB4 67FE            	   673:             beq.s *               * branch if Z set
00:00000DB6 0D3B18FE        	   674: op_BTST24: btst.b d6,op_BTST24(pc,d1.l)      *
00:00000DBA 67FE            	   675:             beq.s *               * branch if Z set
00:00000DBC 0F3B18FE        	   676: op_BTST25  btst.b d7,op_BTST25(pc,d1.l)      *
00:00000DC0 66FE            	   677:             bne.s *               * branch if Z clear
                            	   678: *             EA = n(PC,A.W)  - BYTE only
00:00000DC2 0B3B90FE        	   679: op_BTST26   btst.b d5,op_BTST26(pc,a1.w)
00:00000DC6 67FE            	   680:             beq.s *               * branch if Z set
00:00000DC8 0D3BA0FE        	   681: op_BTST27:  btst.b d6,op_BTST27(pc,a2.w)      *
00:00000DCC 67FE            	   682:             beq.s *               * branch if Z set
00:00000DCE 0F3BA0FE        	   683: op_BTST28:  btst.b d7,op_BTST28(pc,a2.w)      *
00:00000DD2 66FE            	   684:             bne.s *               * branch if Z clear
                            	   685: *             EA = n(PC,A.L)  - BYTE only
00:00000DD4 0B3B98FE        	   686: op_BTST29:  btst.b d5,op_BTST29(pc,a1.l)
00:00000DD8 67FE            	   687:             beq.s *               * branch if Z set
00:00000DDA 0D3BA8FE        	   688: op_BTST30:  btst.b d6,op_BTST30(pc,a2.l)      *
00:00000DDE 67FE            	   689:             beq.s *               * branch if Z set
00:00000DE0 0F3BA8FE        	   690: op_BTST31:  btst.b d7,op_BTST31(pc,a2.l)      *
00:00000DE4 66FE            	   691: op_BTST32:  bne.s *               * branch if Z clear
                            	   692: 
                            	   693: *             EA = #x  - BYTE only
                            	   694: 
00:00000DE6 7A00            	   695:             move.l #0,d5              * populate bit.s number to test
00:00000DE8 7C03            	   696:             move.l #3,d6              * populate bit.s number to test
00:00000DEA 7E07            	   697:             move.l #7,d7              * populate bit.s number to test
                            	   698: 
00:00000DEC 0B3C0088        	   699:             btst.b d5,#$88
00:00000DF0 66FE            	   700:             bne.s *               * branch if Z clear
00:00000DF2 0D3C0088        	   701:             btst.b d6,#$88
00:00000DF6 67FE            	   702:             beq.s *               * branch if Z set
00:00000DF8 0F3C0088        	   703:             btst.b d7,#$88
00:00000DFC 67FE            	   704:             beq.s *               * branch if Z set
                            	   705: 
                            	   706: 
00:00000DFE 4E75            	   707:     rts
                            	   708: 
                            	   709: *-----------------------------------------------------------
                            	   710: *-----------------------------------------------------------
                            	   711: * OPCODE : BCHG
                            	   712: *-----------------------------------------------------------
                            	   713: *-----------------------------------------------------------
                            	   714: op_BCHG:
                            	   715: 
                            	   716: 
                            	   717: *  Bit Number.s Static
                            	   718: 
                            	   719: *             EA = Dn  - LONG only
00:00000E00 203C80000001    	   720:             move.l #$80000001,d0      * populate test data
00:00000E06 08400000        	   721:             bchg.l #0,d0
00:00000E0A 67FE            	   722:             beq.s *               * branch if Z set
00:00000E0C 08400001        	   723:             bchg.l #1,d0              *
00:00000E10 66FE            	   724:             bne.s *               * branch if Z clear
00:00000E12 0840001F        	   725:             bchg.l #31,d0             *
00:00000E16 67FE            	   726:             beq.s *               * branch if Z set
00:00000E18 0C8000000002    	   727:             cmpi.l #$00000002,d0
00:00000E1E 66FE            	   728:             bne.s *               * branch if Z clear
                            	   729: 
                            	   730: 
                            	   731: *             EA = (An)  - BYTE only
00:00000E20 307C0100        	   732:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000E24 10BC0081        	   733:             move.b #$81,(a0)          * populate test data
00:00000E28 1210            	   734:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00000E2A 08500000        	   735:             bchg.b #0,(a0)
00:00000E2E 67FE            	   736:             beq.s *               * branch if Z set
00:00000E30 08500001        	   737:             bchg.b #1,(a0)            *
00:00000E34 66FE            	   738:             bne.s *               * branch if Z clear
00:00000E36 08500007        	   739:             bchg.b #7,(a0)            *
00:00000E3A 67FE            	   740:             beq.s *               * branch if Z set
00:00000E3C 0C100002        	   741:             cmpi.b #$02,(a0)
00:00000E40 66FE            	   742:             bne.s *               * branch if Z clear
                            	   743: 
                            	   744: *             EA = (An)+  - BYTE only
00:00000E42 307C0100        	   745:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000E46 10FC0001        	   746:             move.b #$01,(a0)+         * populate test data
00:00000E4A 10FC00FC        	   747:             move.b #$FC,(a0)+         * populate test data
00:00000E4E 10FC0080        	   748:             move.b #$80,(a0)+         * populate test data
00:00000E52 307C0100        	   749:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000E56 08580000        	   750:             bchg.b #0,(a0)+
00:00000E5A 67FE            	   751:             beq.s *               * branch if Z set
00:00000E5C 08580001        	   752:             bchg.b #1,(a0)+           *
00:00000E60 66FE            	   753:             bne.s *               * branch if Z clear
00:00000E62 08580007        	   754:             bchg.b #7,(a0)+           *
00:00000E66 67FE            	   755:             beq.s *               * branch if Z set
00:00000E68 307C0100        	   756:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000E6C 4A18            	   757:             cmpi.b #$00,(a0)+
00:00000E6E 66FE            	   758:             bne.s *               * branch if Z clear
00:00000E70 0C1800FE        	   759:             cmpi.b #$FE,(a0)+
00:00000E74 66FE            	   760:             bne.s *               * branch if Z clear
00:00000E76 4A18            	   761:             cmpi.b #$00,(a0)+
00:00000E78 66FE            	   762:             bne.s *               * branch if Z clear
                            	   763: 
                            	   764: *             EA = -(An)  - BYTE only
00:00000E7A 307C0100        	   765:             move.l #$00000100,a0      * point to memory to address
00:00000E7E 10FC0080        	   766:             move.b #$80,(a0)+         * populate test data
00:00000E82 10FC00FC        	   767:             move.b #$FC,(a0)+         * populate test data
00:00000E86 10FC0001        	   768:             move.b #$01,(a0)+         * populate test data
00:00000E8A 307C0103        	   769:             move.l #$00000103,a0      * point to memory to address
00:00000E8E 08600000        	   770:             bchg.b #0,-(a0)
00:00000E92 67FE            	   771:             beq.s *               * branch if Z set
00:00000E94 08600001        	   772:             bchg.b #1,-(a0)           *
00:00000E98 66FE            	   773:             bne.s *               * branch if Z clear
00:00000E9A 08600007        	   774:             bchg.b #7,-(a0)           *
00:00000E9E 67FE            	   775:             beq.s *               * branch if Z set
00:00000EA0 307C0103        	   776:             move.l #$00000103,a0      * point to memory to address 0x100
00:00000EA4 4A20            	   777:             cmpi.b #$00,-(a0)
00:00000EA6 66FE            	   778:             bne.s *               * branch if Z clear
00:00000EA8 0C2000FE        	   779:             cmpi.b #$FE,-(a0)
00:00000EAC 66FE            	   780:             bne.s *               * branch if Z clear
00:00000EAE 4A20            	   781:             cmpi.b #$00,-(a0)
00:00000EB0 66FE            	   782:             bne.s *               * branch if Z clear
                            	   783: 
                            	   784: 
                            	   785: *             EA = n(An)  - BYTE only
00:00000EB2 307C0100        	   786:             move.l #$00000100,a0      * point to memory to address
00:00000EB6 10FC0001        	   787:             move.b #$01,(a0)+         * populate test data
00:00000EBA 10FC00FC        	   788:             move.b #$FC,(a0)+         * populate test data
00:00000EBE 10FC0080        	   789:             move.b #$80,(a0)+         * populate test data
00:00000EC2 307C0100        	   790:             move.l #$00000100,a0      * point to memory to address
00:00000EC6 08500000        	   791:             bchg.b #0,0(a0)
00:00000ECA 67FE            	   792:             beq.s *               * branch if Z set
00:00000ECC 086800010001    	   793:             bchg.b #1,1(a0)           *
00:00000ED2 66FE            	   794:             bne.s *               * branch if Z clear
00:00000ED4 086800070002    	   795:             bchg.b #7,2(a0)           *
00:00000EDA 67FE            	   796:             beq.s *               * branch if Z set
00:00000EDC 307C0100        	   797:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000EE0 4A18            	   798:             cmpi.b #$00,(a0)+
00:00000EE2 66FE            	   799:             bne.s *               * branch if Z clear
00:00000EE4 0C1800FE        	   800:             cmpi.b #$FE,(a0)+
00:00000EE8 66FE            	   801:             bne.s *               * branch if Z clear
00:00000EEA 4A18            	   802:             cmpi.b #$00,(a0)+
00:00000EEC 66FE            	   803:             bne.s *               * branch if Z clear
                            	   804: 
                            	   805: 
                            	   806: *             EA = n(An,D.W)  - BYTE only
00:00000EEE 307C0100        	   807:             move.l #$00000100,a0      * point to memory to address
00:00000EF2 93C9            	   808:             move.l #$00000000,a1      * point to memory to address
00:00000EF4 347C0001        	   809:             move.l #$00000001,a2      * point to memory to address
00:00000EF8 7000            	   810:             moveq  #$00000000,d0      * point to memory to address
00:00000EFA 7201            	   811:             moveq  #$00000001,d1      * point to memory to address
00:00000EFC 087000000000    	   812:             bchg.b #0,0(a0,d0.w)
00:00000F02 66FE            	   813:             bne.s *               * branch if Z clear
00:00000F04 087000011000    	   814:             bchg.b #1,0(a0,d1.w)      *
00:00000F0A 67FE            	   815:             beq.s *               * branch if Z set
00:00000F0C 087000071001    	   816:             bchg.b #7,1(a0,d1.w)      *
00:00000F12 66FE            	   817:             bne.s *               * branch if Z clear
                            	   818: *             EA = n(An,D.L)  - BYTE only
00:00000F14 087000000800    	   819:             bchg.b #0,0(a0,d0.l)
00:00000F1A 67FE            	   820:             beq.s *               * branch if Z set
00:00000F1C 087000011800    	   821:             bchg.b #1,0(a0,d1.l)      *
00:00000F22 66FE            	   822:             bne.s *               * branch if Z clear
00:00000F24 087000071801    	   823:             bchg.b #7,1(a0,d1.l)      *
00:00000F2A 67FE            	   824:             beq.s *               * branch if Z set
                            	   825: *             EA = n(An,A.W)  - BYTE only
00:00000F2C 087000009000    	   826:             bchg.b #0,0(a0,a1.w)
00:00000F32 66FE            	   827:             bne.s *               * branch if Z clear
00:00000F34 08700001A000    	   828:             bchg.b #1,0(a0,a2.w)      *
00:00000F3A 67FE            	   829:             beq.s *               * branch if Z set
00:00000F3C 08700007A001    	   830:             bchg.b #7,1(a0,a2.w)      *
00:00000F42 66FE            	   831:             bne.s *               * branch if Z clear
                            	   832: *             EA = n(An,A.L)  - BYTE only
00:00000F44 087000009800    	   833:             bchg.b #0,0(a0,a1.l)
00:00000F4A 67FE            	   834:             beq.s *               * branch if Z set
00:00000F4C 08700001A800    	   835:             bchg.b #1,0(a0,a2.l)      *
00:00000F52 66FE            	   836:             bne.s *               * branch if Z clear
00:00000F54 08700007A801    	   837:             bchg.b #7,1(a0,a2.l)      *
00:00000F5A 67FE            	   838:             beq.s *               * branch if Z set
00:00000F5C 307C0100        	   839:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000F60 4A18            	   840:             cmpi.b #$00,(a0)+
00:00000F62 66FE            	   841:             bne.s *               * branch if Z clear
00:00000F64 0C1800FE        	   842:             cmpi.b #$FE,(a0)+
00:00000F68 66FE            	   843:             bne.s *               * branch if Z clear
00:00000F6A 4A18            	   844:             cmpi.b #$00,(a0)+
00:00000F6C 66FE            	   845:             bne.s *               * branch if Z clear
                            	   846: 
                            	   847: 
                            	   848: *             EA = x.W  - BYTE only
00:00000F6E 087800000100    	   849:             bchg.b #0,$0100
00:00000F74 66FE            	   850:             bne.s *               * branch if Z clear
00:00000F76 087800010101    	   851:             bchg.b #1,$0101           *
00:00000F7C 67FE            	   852:             beq.s *               * branch if Z set
00:00000F7E 087800070102    	   853:             bchg.b #7,$0102           *
00:00000F84 66FE            	   854:             bne.s *               * branch if Z clear
00:00000F86 307C0100        	   855:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000F8A 0C180001        	   856:             cmpi.b #$01,(a0)+
00:00000F8E 66FE            	   857:             bne.s *               * branch if Z clear
00:00000F90 0C1800FC        	   858:             cmpi.b #$FC,(a0)+
00:00000F94 66FE            	   859:             bne.s *               * branch if Z clear
00:00000F96 0C180080        	   860:             cmpi.b #$80,(a0)+
00:00000F9A 66FE            	   861:             bne.s *               * branch if Z clear
                            	   862: 
                            	   863: *             EA = x.L  - BYTE only
00:00000F9C 207C0000F100    	   864:             move.l #$F100,a0      * point to memory to address 0x100
00:00000FA2 10FC0001        	   865:             move.b #$01,(a0)+         * populate test data
00:00000FA6 10FC00FC        	   866:             move.b #$FC,(a0)+         * populate test data
00:00000FAA 10FC0080        	   867:             move.b #$80,(a0)+         * populate test data
00:00000FAE 087900000000F100	   868:             bchg.b #0,$F100
00:00000FB6 67FE            	   869:             beq.s *               * branch if Z set
00:00000FB8 087900010000F101	   870:             bchg.b #1,$F101       *
00:00000FC0 66FE            	   871:             bne.s *               * branch if Z clear
00:00000FC2 087900070000F102	   872:             bchg.b #7,$F102       *
00:00000FCA 67FE            	   873:             beq.s *               * branch if Z set
00:00000FCC 307C0100        	   874:             move.l #$00000100,a0      * point to memory to address 0x100
00:00000FD0 0C180001        	   875:             cmpi.b #$01,(a0)+
00:00000FD4 66FE            	   876:             bne.s *               * branch if Z clear
00:00000FD6 0C1800FC        	   877:             cmpi.b #$FC,(a0)+
00:00000FDA 66FE            	   878:             bne.s *               * branch if Z clear
00:00000FDC 0C180080        	   879:             cmpi.b #$80,(a0)+
00:00000FE0 66FE            	   880:             bne.s *               * branch if Z clear
                            	   881: 
                            	   882: 
                            	   883: * Bit Number.s Dynamic
                            	   884: 
                            	   885: *             EA = Dn  - LONG only
00:00000FE2 203C80000001    	   886:             move.l #$80000001,d0      * populate test data
00:00000FE8 7A00            	   887:             move.l #0,d5              * populate bit.s number to test
00:00000FEA 7C01            	   888:             move.l #1,d6              * populate bit.s number to test
00:00000FEC 7E1F            	   889:             move.l #31,d7              * populate bit.s number to test
                            	   890: 
00:00000FEE 0B40            	   891:             bchg.l d5,d0
00:00000FF0 67FE            	   892:             beq.s *               * branch if Z set
00:00000FF2 0D40            	   893:             bchg.l d6,d0              *
00:00000FF4 66FE            	   894:             bne.s *               * branch if Z clear
00:00000FF6 0F40            	   895:             bchg.l d7,d0             *
00:00000FF8 67FE            	   896:             beq.s *               * branch if Z set
00:00000FFA 0C8000000002    	   897:             cmpi.l #$00000002,d0
00:00001000 66FE            	   898:             bne.s *               * branch if Z clear
                            	   899: 
                            	   900: 
                            	   901: *             EA = (An)  - BYTE only
00:00001002 7A00            	   902:             move.l #0,d5              * populate bit.s number to test
00:00001004 7C01            	   903:             move.l #1,d6              * populate bit.s number to test
00:00001006 7E07            	   904:             move.l #7,d7              * populate bit.s number to test
00:00001008 307C0100        	   905:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000100C 10BC0081        	   906:             move.b #$81,(a0)          * populate test data
00:00001010 1210            	   907:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00001012 0B50            	   908:             bchg.b d5,(a0)
00:00001014 67FE            	   909:             beq.s *               * branch if Z set
00:00001016 0D50            	   910:             bchg.b d6,(a0)            *
00:00001018 66FE            	   911:             bne.s *               * branch if Z clear
00:0000101A 0F50            	   912:             bchg.b d7,(a0)            *
00:0000101C 67FE            	   913:             beq.s *               * branch if Z set
00:0000101E 0C100002        	   914:             cmpi.b #$02,(a0)
00:00001022 66FE            	   915:             bne.s *               * branch if Z clear
                            	   916: 
                            	   917: 
                            	   918: *             EA = (An)+  - BYTE only
00:00001024 307C0100        	   919:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001028 10FC0001        	   920:             move.b #$01,(a0)+         * populate test data
00:0000102C 10FC00FC        	   921:             move.b #$FC,(a0)+         * populate test data
00:00001030 10FC0080        	   922:             move.b #$80,(a0)+         * populate test data
00:00001034 307C0100        	   923:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001038 0B58            	   924:             bchg.b d5,(a0)+
00:0000103A 67FE            	   925:             beq.s *               * branch if Z set
00:0000103C 0D58            	   926:             bchg.b d6,(a0)+           *
00:0000103E 66FE            	   927:             bne.s *               * branch if Z clear
00:00001040 0F58            	   928:             bchg.b d7,(a0)+           *
00:00001042 67FE            	   929:             beq.s *               * branch if Z set
00:00001044 307C0100        	   930:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001048 4A18            	   931:             cmpi.b #$00,(a0)+
00:0000104A 66FE            	   932:             bne.s *               * branch if Z clear
00:0000104C 0C1800FE        	   933:             cmpi.b #$FE,(a0)+
00:00001050 66FE            	   934:             bne.s *               * branch if Z clear
00:00001052 4A18            	   935:             cmpi.b #$00,(a0)+
00:00001054 66FE            	   936:             bne.s *               * branch if Z clear
                            	   937: 
                            	   938: *             EA = -(An)  - BYTE only
00:00001056 307C0100        	   939:             move.l #$00000100,a0      * point to memory to address
00:0000105A 10FC0080        	   940:             move.b #$80,(a0)+         * populate test data
00:0000105E 10FC00FC        	   941:             move.b #$FC,(a0)+         * populate test data
00:00001062 10FC0001        	   942:             move.b #$01,(a0)+         * populate test data
00:00001066 307C0103        	   943:             move.l #$00000103,a0      * point to memory to address
00:0000106A 0B60            	   944:             bchg.b d5,-(a0)
00:0000106C 67FE            	   945:             beq.s *               * branch if Z set
00:0000106E 0D60            	   946:             bchg.b d6,-(a0)           *
00:00001070 66FE            	   947:             bne.s *               * branch if Z clear
00:00001072 0F60            	   948:             bchg.b d7,-(a0)           *
00:00001074 67FE            	   949:             beq.s *               * branch if Z set
00:00001076 307C0103        	   950:             move.l #$00000103,a0      * point to memory to address 0x100
00:0000107A 4A20            	   951:             cmpi.b #$00,-(a0)
00:0000107C 66FE            	   952:             bne.s *               * branch if Z clear
00:0000107E 0C2000FE        	   953:             cmpi.b #$FE,-(a0)
00:00001082 66FE            	   954:             bne.s *               * branch if Z clear
00:00001084 4A20            	   955:             cmpi.b #$00,-(a0)
00:00001086 66FE            	   956:             bne.s *               * branch if Z clear
                            	   957: 
                            	   958: *             EA = n(An)  - BYTE only
00:00001088 307C0100        	   959:             move.l #$00000100,a0      * point to memory to address
00:0000108C 10FC0001        	   960:             move.b #$01,(a0)+         * populate test data
00:00001090 10FC00FC        	   961:             move.b #$FC,(a0)+         * populate test data
00:00001094 10FC0080        	   962:             move.b #$80,(a0)+         * populate test data
00:00001098 307C0100        	   963:             move.l #$00000100,a0      * point to memory to address
00:0000109C 0B50            	   964:             bchg.b d5,0(a0)
00:0000109E 67FE            	   965:             beq.s *               * branch if Z set
00:000010A0 0D680001        	   966:             bchg.b d6,1(a0)           *
00:000010A4 66FE            	   967:             bne.s *               * branch if Z clear
00:000010A6 0F680002        	   968:             bchg.b d7,2(a0)           *
00:000010AA 67FE            	   969:             beq.s *               * branch if Z set
00:000010AC 307C0100        	   970:             move.l #$00000100,a0      * point to memory to address 0x100
00:000010B0 4A18            	   971:             cmpi.b #$00,(a0)+
00:000010B2 66FE            	   972:             bne.s *               * branch if Z clear
00:000010B4 0C1800FE        	   973:             cmpi.b #$FE,(a0)+
00:000010B8 66FE            	   974:             bne.s *               * branch if Z clear
00:000010BA 4A18            	   975:             cmpi.b #$00,(a0)+
00:000010BC 66FE            	   976:             bne.s *               * branch if Z clear
                            	   977: 
                            	   978: *             EA = n(An,R.W)  - BYTE only
00:000010BE 307C0100        	   979:             move.l #$00000100,a0      * point to memory to address
00:000010C2 93C9            	   980:             move.l #$00000000,a1      * point to memory to address
00:000010C4 347C0001        	   981:             move.l #$00000001,a2      * point to memory to address
00:000010C8 7000            	   982:             moveq  #$00000000,d0      * point to memory to address
00:000010CA 7201            	   983:             moveq  #$00000001,d1      * point to memory to address
00:000010CC 0B700000        	   984:             bchg.b d5,0(a0,d0.w)
00:000010D0 66FE            	   985:             bne.s *               * branch if Z clear
00:000010D2 0D701000        	   986:             bchg.b d6,0(a0,d1.w)      *
00:000010D6 67FE            	   987:             beq.s *               * branch if Z set
00:000010D8 0F701001        	   988:             bchg.b d7,1(a0,d1.w)      *
00:000010DC 66FE            	   989:             bne.s *               * branch if Z clear
                            	   990: *             EA = n(An,R.L)  - BYTE only
00:000010DE 0B700800        	   991:             bchg.b d5,0(a0,d0.l)
00:000010E2 67FE            	   992:             beq.s *               * branch if Z set
00:000010E4 0D701800        	   993:             bchg.b d6,0(a0,d1.l)      *
00:000010E8 66FE            	   994:             bne.s *               * branch if Z clear
00:000010EA 0F701801        	   995:             bchg.b d7,1(a0,d1.l)      *
00:000010EE 67FE            	   996:             beq.s *               * branch if Z set
                            	   997: *             EA = n(An,A.W)  - BYTE only
00:000010F0 0B709000        	   998:             bchg.b d5,0(a0,a1.w)
00:000010F4 66FE            	   999:             bne.s *               * branch if Z clear
00:000010F6 0D70A000        	  1000:             bchg.b d6,0(a0,a2.w)      *
00:000010FA 67FE            	  1001:             beq.s *               * branch if Z set
00:000010FC 0F70A001        	  1002:             bchg.b d7,1(a0,a2.w)      *
00:00001100 66FE            	  1003:             bne.s *               * branch if Z clear
                            	  1004: *             EA = n(An,A.L)  - BYTE only
00:00001102 0B709800        	  1005:             bchg.b d5,0(a0,a1.l)
00:00001106 67FE            	  1006:             beq.s *               * branch if Z set
00:00001108 0D70A800        	  1007:             bchg.b d6,0(a0,a2.l)      *
00:0000110C 66FE            	  1008:             bne.s *               * branch if Z clear
00:0000110E 0F70A801        	  1009:             bchg.b d7,1(a0,a2.l)      *
00:00001112 67FE            	  1010:             beq.s *               * branch if Z set
00:00001114 4A18            	  1011:             cmpi.b #$00,(a0)+
00:00001116 66FE            	  1012:             bne.s *               * branch if Z clear
                            	  1013: 
                            	  1014: *             EA = x.W  - BYTE only
00:00001118 0B780100        	  1015:             bchg.b d5,$0100
00:0000111C 66FE            	  1016:             bne.s *               * branch if Z clear
00:0000111E 0D780101        	  1017:             bchg.b d6,$0101           *
00:00001122 67FE            	  1018:             beq.s *               * branch if Z set
00:00001124 0F780102        	  1019:             bchg.b d7,$0102           *
00:00001128 66FE            	  1020:             bne.s *               * branch if Z clear
00:0000112A 0C1800FC        	  1021:             cmpi.b #$FC,(a0)+
00:0000112E 66FE            	  1022:             bne.s *               * branch if Z clear
                            	  1023: 
                            	  1024: *             EA = x.L  - BYTE only
00:00001130 207C0000F100    	  1025:             move.l #$F100,a0      * point to memory to address 0x100
00:00001136 10FC0001        	  1026:             move.b #$01,(a0)+         * populate test data
00:0000113A 10FC00FC        	  1027:             move.b #$FC,(a0)+         * populate test data
00:0000113E 10FC0080        	  1028:             move.b #$80,(a0)+         * populate test data
00:00001142 0B790000F100    	  1029:             bchg.b d5,$F100
00:00001148 67FE            	  1030:             beq.s *               * branch if Z set
00:0000114A 0D790000F101    	  1031:             bchg.b d6,$F101       *
00:00001150 66FE            	  1032:             bne.s *               * branch if Z clear
00:00001152 0F790000F102    	  1033:             bchg.b d7,$F102       *
00:00001158 67FE            	  1034:             beq.s *               * branch if Z set
00:0000115A 207C0000F101    	  1035:             move.l #$F101,a0      * point to memory to address 0x100
00:00001160 0C1000FE        	  1036:             cmpi.b #$FE,(a0)
00:00001164 66FE            	  1037:             bne.s *               * branch if Z clear
                            	  1038: 
                            	  1039: 
00:00001166 4E75            	  1040:     rts
                            	  1041: 
                            	  1042: *-----------------------------------------------------------
                            	  1043: *-----------------------------------------------------------
                            	  1044: * OPCODE : BCLR
                            	  1045: *-----------------------------------------------------------
                            	  1046: *-----------------------------------------------------------
                            	  1047: op_BCLR:
                            	  1048: 
                            	  1049: 
                            	  1050: *  Bit Number.s Static
                            	  1051: 
                            	  1052: *             EA = Dn  - LONG only
00:00001168 203CFF0000FF    	  1053:             move.l #$FF0000FF,d0      * populate test data
00:0000116E 08800000        	  1054:             bclr.l #0,d0
00:00001172 67FE            	  1055:             beq.s *               * branch if Z set
00:00001174 08800001        	  1056:             bclr.l #1,d0              *
00:00001178 67FE            	  1057:             beq.s *               * branch if Z set
00:0000117A 0880000F        	  1058:             bclr.l #15,d0             *
00:0000117E 66FE            	  1059:             bne.s *               * branch if Z clear
00:00001180 0880001F        	  1060:             bclr.l #31,d0             *
00:00001184 67FE            	  1061:             beq.s *               * branch if Z set
00:00001186 0C807F0000FC    	  1062:             cmpi.l #$7F0000FC,d0
00:0000118C 66FE            	  1063:             bne.s *               * branch if Z clear
                            	  1064: 
                            	  1065: 
                            	  1066: *             EA = (An)  - BYTE only
00:0000118E 307C0100        	  1067:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001192 10BC000F        	  1068:             move.b #$0F,(a0)          * populate test data
00:00001196 08900000        	  1069:             bclr.b #0,(a0)
00:0000119A 67FE            	  1070:             beq.s *               * branch if Z set
00:0000119C 08900007        	  1071:             bclr.b #7,(a0)            *
00:000011A0 66FE            	  1072:             bne.s *               * branch if Z clear
00:000011A2 0C10000E        	  1073:             cmpi.b #$0E,(a0)
00:000011A6 66FE            	  1074:             bne.s *               * branch if Z clear
                            	  1075: 
                            	  1076: *             EA = (An)+  - BYTE only
00:000011A8 307C0100        	  1077:             move.l #$00000100,a0      * point to memory to address 0x100
00:000011AC 10FC0001        	  1078:             move.b #$01,(a0)+         * populate test data
00:000011B0 4218            	  1079:             move.b #$00,(a0)+         * populate test data
00:000011B2 307C0100        	  1080:             move.l #$00000100,a0      * point to memory to address 0x100
00:000011B6 08980000        	  1081:             bclr.b #0,(a0)+
00:000011BA 67FE            	  1082:             beq.s *               * branch if Z set
00:000011BC 08980001        	  1083:             bclr.b #1,(a0)+           *
00:000011C0 66FE            	  1084:             bne.s *               * branch if Z clear
00:000011C2 307C0100        	  1085:             move.l #$00000100,a0      * point to memory to address 0x100
00:000011C6 4A18            	  1086:             cmpi.b #$00,(a0)+
00:000011C8 66FE            	  1087:             bne.s *               * branch if Z clear
00:000011CA 4A18            	  1088:             cmpi.b #$00,(a0)+
00:000011CC 66FE            	  1089:             bne.s *               * branch if Z clear
                            	  1090: 
                            	  1091: 
                            	  1092: *             EA = -(An)  - BYTE only
00:000011CE 307C0100        	  1093:             move.l #$00000100,a0      * point to memory to address
00:000011D2 10FC0001        	  1094:             move.b #$01,(a0)+         * populate test data
00:000011D6 10FC0080        	  1095:             move.b #$80,(a0)+         * populate test data
00:000011DA 08A00007        	  1096:             bclr.b #7,-(a0)
00:000011DE 67FE            	  1097:             beq.s *               * branch if Z set
00:000011E0 08A00000        	  1098:             bclr.b #0,-(a0)           *
00:000011E4 67FE            	  1099:             beq.s *               * branch if Z set
00:000011E6 307C0102        	  1100:             move.l #$00000102,a0      * point to memory to address 0x100
00:000011EA 4A20            	  1101:             cmpi.b #$00,-(a0)
00:000011EC 66FE            	  1102:             bne.s *               * branch if Z clear
00:000011EE 4A20            	  1103:             cmpi.b #$00,-(a0)
00:000011F0 66FE            	  1104:             bne.s *               * branch if Z clear
                            	  1105: 
                            	  1106: 
                            	  1107: *             EA = n(An)  - BYTE only
00:000011F2 307C0100        	  1108:             move.l #$00000100,a0      * point to memory to address
00:000011F6 10FC00FF        	  1109:             move.b #$FF,(a0)+         * populate test data
00:000011FA 10FC00FF        	  1110:             move.b #$FF,(a0)+         * populate test data
00:000011FE 307C0100        	  1111:             move.l #$00000100,a0      * point to memory to address
00:00001202 08900000        	  1112:             bclr.b #0,0(a0)
00:00001206 67FE            	  1113:             beq.s *               * branch if Z set
00:00001208 08A800040001    	  1114:             bclr.b #4,1(a0)           *
00:0000120E 67FE            	  1115:             beq.s *               * branch if Z set
00:00001210 307C0100        	  1116:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001214 0C1800FE        	  1117:             cmpi.b #$FE,(a0)+
00:00001218 66FE            	  1118:             bne.s *               * branch if Z clear
00:0000121A 0C1800EF        	  1119:             cmpi.b #$EF,(a0)+
00:0000121E 66FE            	  1120:             bne.s *               * branch if Z clear
                            	  1121: 
                            	  1122: 
                            	  1123: *             EA = n(An,D.W)  - BYTE only
00:00001220 307C0100        	  1124:             move.l #$00000100,a0      * point to memory to address
00:00001224 93C9            	  1125:             move.l #$00000000,a1      * point to memory to address
00:00001226 347C0001        	  1126:             move.l #$00000001,a2      * point to memory to address
00:0000122A 7000            	  1127:             moveq  #$00000000,d0      * point to memory to address
00:0000122C 7201            	  1128:             moveq  #$00000001,d1      * point to memory to address
00:0000122E 10FC00FF        	  1129:             move.b #$FF,(a0)+         * populate test data
00:00001232 10FC00FF        	  1130:             move.b #$FF,(a0)+         * populate test data
00:00001236 307C0100        	  1131:             move.l #$00000100,a0      * point to memory to address
00:0000123A 08B000000000    	  1132:             bclr.b #0,0(a0,d0.w)
00:00001240 67FE            	  1133:             beq.s *               * branch if Z set
00:00001242 08B000011000    	  1134:             bclr.b #1,0(a0,d1.w)      *
00:00001248 67FE            	  1135:             beq.s *               * branch if Z set
00:0000124A 08B000021001    	  1136:             bclr.b #2,1(a0,d1.w)      *
00:00001250 66FE            	  1137:             bne.s *               * branch if Z clear
                            	  1138: *             EA = n(An,D.L)  - BYTE only
00:00001252 08B000030800    	  1139:             bclr.b #3,0(a0,d0.l)
00:00001258 67FE            	  1140:             beq.s *               * branch if Z set
00:0000125A 08B000041800    	  1141:             bclr.b #4,0(a0,d1.l)      *
00:00001260 67FE            	  1142:             beq.s *               * branch if Z set
00:00001262 08B000051801    	  1143:             bclr.b #5,1(a0,d1.l)      *
00:00001268 66FE            	  1144:             bne.s *               * branch if Z clear
                            	  1145: *             EA = n(An,A.W)  - BYTE only
00:0000126A 08B000069000    	  1146:             bclr.b #6,0(a0,a1.w)
00:00001270 67FE            	  1147:             beq.s *               * branch if Z set
00:00001272 08B00001A000    	  1148:             bclr.b #1,0(a0,a2.w)      *
00:00001278 66FE            	  1149:             bne.s *               * branch if Z clear
00:0000127A 08B00007A001    	  1150:             bclr.b #7,1(a0,a2.w)      *
00:00001280 67FE            	  1151:             beq.s *               * branch if Z set
                            	  1152: *             EA = n(An,A.L)  - BYTE only
00:00001282 08B000009800    	  1153:             bclr.b #0,0(a0,a1.l)
00:00001288 66FE            	  1154:             bne.s *               * branch if Z clear
00:0000128A 08B00000A800    	  1155:             bclr.b #0,0(a0,a2.l)      *
00:00001290 67FE            	  1156:             beq.s *               * branch if Z set
00:00001292 08B00001A801    	  1157:             bclr.b #1,1(a0,a2.l)      *
00:00001298 66FE            	  1158:             bne.s *               * branch if Z clear
00:0000129A 307C0100        	  1159:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000129E 0C1800B6        	  1160:             cmpi.b #$B6,(a0)+
00:000012A2 66FE            	  1161:             bne.s *               * branch if Z clear
00:000012A4 0C1800EC        	  1162:             cmpi.b #$EC,(a0)+
00:000012A8 66FE            	  1163:             bne.s *               * branch if Z clear
00:000012AA 0C180059        	  1164:             cmpi.b #$59,(a0)+
00:000012AE 67FE            	  1165:             beq.s *               * branch if Z set
                            	  1166: 
                            	  1167: 
                            	  1168: *             EA = x.W  - BYTE only
00:000012B0 307C0100        	  1169:             move.l #$00000100,a0      * point to memory to address
00:000012B4 10FC00FF        	  1170:             move.b #$FF,(a0)+         * populate test data
00:000012B8 08B800000100    	  1171:             bclr.b #0,$0100
00:000012BE 67FE            	  1172:             beq.s *               * branch if Z set
00:000012C0 08B800010100    	  1173:             bclr.b #1,$0100           *
00:000012C6 67FE            	  1174:             beq.s *               * branch if Z set
00:000012C8 307C0100        	  1175:             move.l #$00000100,a0      * point to memory to address 0x100
00:000012CC 0C1800FC        	  1176:             cmpi.b #$FC,(a0)+
00:000012D0 66FE            	  1177:             bne.s *               * branch if Z clear
                            	  1178: 
                            	  1179: 
                            	  1180: *             EA = x.L  - BYTE only
00:000012D2 207C0000F100    	  1181:             move.l #$F100,a0      * point to memory to address 0x100
00:000012D8 10BC00FF        	  1182:             move.b #$FF,(a0)          * populate test data
00:000012DC 08B900000000F100	  1183:             bclr.b #0,$F100
00:000012E4 67FE            	  1184:             beq.s *               * branch if Z set
00:000012E6 08B900010000F100	  1185:             bclr.b #1,$F100       *
00:000012EE 67FE            	  1186:             beq.s *               * branch if Z set
00:000012F0 08B900020000F100	  1187:             bclr.b #2,$F100       *
00:000012F8 67FE            	  1188:             beq.s *               * branch if Z set
00:000012FA 207C0000F100    	  1189:             move.l #$F100,a0      * point to memory to address 0x100
00:00001300 0C1800F8        	  1190:             cmpi.b #$F8,(a0)+
00:00001304 66FE            	  1191:             bne.s *               * branch if Z clear
                            	  1192: 
                            	  1193: 
                            	  1194: * Bit Number.s Dynamic
                            	  1195: 
                            	  1196: *             EA = Dn  - LONG only
00:00001306 203CFF00FF00    	  1197:             move.l #$FF00FF00,d0      * populate test data
00:0000130C 7A00            	  1198:             move.l #0,d5              * populate bit.s number to test
00:0000130E 7C01            	  1199:             move.l #1,d6              * populate bit.s number to test
00:00001310 7E1F            	  1200:             move.l #31,d7              * populate bit.s number to test
                            	  1201: 
00:00001312 0B80            	  1202:             bclr.l d5,d0
00:00001314 66FE            	  1203:             bne.s *               * branch if Z clear
00:00001316 0D80            	  1204:             bclr.l d6,d0              *
00:00001318 66FE            	  1205:             bne.s *               * branch if Z clear
00:0000131A 0F80            	  1206:             bclr.l d7,d0             *
00:0000131C 67FE            	  1207:             beq.s *               * branch if Z set
00:0000131E 0C807F00FF00    	  1208:             cmpi.l #$7F00FF00,d0
00:00001324 66FE            	  1209:             bne.s *               * branch if Z clear
                            	  1210: 
                            	  1211: 
                            	  1212: *             EA = (An)  - BYTE only
00:00001326 7A00            	  1213:             move.l #0,d5              * populate bit.s number to test
00:00001328 7C01            	  1214:             move.l #1,d6              * populate bit.s number to test
00:0000132A 7E07            	  1215:             move.l #7,d7              * populate bit.s number to test
00:0000132C 307C0100        	  1216:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001330 10BC0081        	  1217:             move.b #$81,(a0)          * populate test data
00:00001334 0B90            	  1218:             bclr.b d5,(a0)
00:00001336 67FE            	  1219:             beq.s *               * branch if Z set
00:00001338 0D90            	  1220:             bclr.b d6,(a0)            *
00:0000133A 66FE            	  1221:             bne.s *               * branch if Z clear
00:0000133C 0F90            	  1222:             bclr.b d7,(a0)            *
00:0000133E 67FE            	  1223:             beq.s *               * branch if Z set
00:00001340 4A10            	  1224:             cmpi.b #$00,(a0)
00:00001342 66FE            	  1225:             bne.s *               * branch if Z clear
                            	  1226: 
                            	  1227: 
                            	  1228: *             EA = (An)+  - BYTE only
00:00001344 307C0100        	  1229:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001348 10FC0001        	  1230:             move.b #$01,(a0)+         * populate test data
00:0000134C 10FC00FC        	  1231:             move.b #$FC,(a0)+         * populate test data
00:00001350 10FC0080        	  1232:             move.b #$80,(a0)+         * populate test data
00:00001354 307C0100        	  1233:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001358 0B98            	  1234:             bclr.b d5,(a0)+
00:0000135A 67FE            	  1235:             beq.s *               * branch if Z set
00:0000135C 0D98            	  1236:             bclr.b d6,(a0)+           *
00:0000135E 66FE            	  1237:             bne.s *               * branch if Z clear
00:00001360 0F98            	  1238:             bclr.b d7,(a0)+           *
00:00001362 67FE            	  1239:             beq.s *               * branch if Z set
00:00001364 307C0100        	  1240:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001368 4A18            	  1241:             cmpi.b #$00,(a0)+
00:0000136A 66FE            	  1242:             bne.s *               * branch if Z clear
00:0000136C 0C1800FC        	  1243:             cmpi.b #$FC,(a0)+
00:00001370 66FE            	  1244:             bne.s *               * branch if Z clear
00:00001372 4A18            	  1245:             cmpi.b #$00,(a0)+
00:00001374 66FE            	  1246:             bne.s *               * branch if Z clear
                            	  1247: 
                            	  1248: *             EA = -(An)  - BYTE only
00:00001376 307C0100        	  1249:             move.l #$00000100,a0      * point to memory to address
00:0000137A 10FC0080        	  1250:             move.b #$80,(a0)+         * populate test data
00:0000137E 10FC00FC        	  1251:             move.b #$FC,(a0)+         * populate test data
00:00001382 10FC0001        	  1252:             move.b #$01,(a0)+         * populate test data
00:00001386 307C0103        	  1253:             move.l #$00000103,a0      * point to memory to address
00:0000138A 0BA0            	  1254:             bclr.b d5,-(a0)
00:0000138C 67FE            	  1255:             beq.s *               * branch if Z set
00:0000138E 0DA0            	  1256:             bclr.b d6,-(a0)           *
00:00001390 66FE            	  1257:             bne.s *               * branch if Z clear
00:00001392 0FA0            	  1258:             bclr.b d7,-(a0)           *
00:00001394 67FE            	  1259:             beq.s *               * branch if Z set
00:00001396 307C0103        	  1260:             move.l #$00000103,a0      * point to memory to address 0x100
00:0000139A 4A20            	  1261:             cmpi.b #$00,-(a0)
00:0000139C 66FE            	  1262:             bne.s *               * branch if Z clear
00:0000139E 0C2000FC        	  1263:             cmpi.b #$FC,-(a0)
00:000013A2 66FE            	  1264:             bne.s *               * branch if Z clear
00:000013A4 4A20            	  1265:             cmpi.b #$00,-(a0)
00:000013A6 66FE            	  1266:             bne.s *               * branch if Z clear
                            	  1267: 
                            	  1268: *             EA = n(An)  - BYTE only
00:000013A8 307C0100        	  1269:             move.l #$00000100,a0      * point to memory to address
00:000013AC 10FC0001        	  1270:             move.b #$01,(a0)+         * populate test data
00:000013B0 10FC00FC        	  1271:             move.b #$FC,(a0)+         * populate test data
00:000013B4 10FC0080        	  1272:             move.b #$80,(a0)+         * populate test data
00:000013B8 307C0100        	  1273:             move.l #$00000100,a0      * point to memory to address
00:000013BC 0B90            	  1274:             bclr.b d5,0(a0)
00:000013BE 67FE            	  1275:             beq.s *               * branch if Z set
00:000013C0 0DA80001        	  1276:             bclr.b d6,1(a0)           *
00:000013C4 66FE            	  1277:             bne.s *               * branch if Z clear
00:000013C6 0FA80002        	  1278:             bclr.b d7,2(a0)           *
00:000013CA 67FE            	  1279:             beq.s *               * branch if Z set
00:000013CC 307C0100        	  1280:             move.l #$00000100,a0      * point to memory to address 0x100
00:000013D0 4A18            	  1281:             cmpi.b #$00,(a0)+
00:000013D2 66FE            	  1282:             bne.s *               * branch if Z clear
00:000013D4 0C1800FC        	  1283:             cmpi.b #$FC,(a0)+
00:000013D8 66FE            	  1284:             bne.s *               * branch if Z clear
00:000013DA 4A18            	  1285:             cmpi.b #$00,(a0)+
00:000013DC 66FE            	  1286:             bne.s *               * branch if Z clear
                            	  1287: 
                            	  1288: *             EA = n(An,R.W)  - BYTE only
00:000013DE 307C0100        	  1289:             move.l #$00000100,a0      * point to memory to address
00:000013E2 10FC00FF        	  1290:             move.b #$FF,(a0)+         * populate test data
00:000013E6 10FC00FF        	  1291:             move.b #$FF,(a0)+         * populate test data
00:000013EA 10FC00FF        	  1292:             move.b #$FF,(a0)+         * populate test data
00:000013EE 307C0103        	  1293:             move.l #$00000103,a0      * point to memory to address
00:000013F2 307C0100        	  1294:             move.l #$00000100,a0      * point to memory to address
00:000013F6 93C9            	  1295:             move.l #$00000000,a1      * point to memory to address
00:000013F8 347C0001        	  1296:             move.l #$00000001,a2      * point to memory to address
00:000013FC 7000            	  1297:             moveq  #$00000000,d0      * point to memory to address
00:000013FE 7201            	  1298:             moveq  #$00000001,d1      * point to memory to address
00:00001400 0BB00000        	  1299:             bclr.b d5,0(a0,d0.w)
00:00001404 67FE            	  1300:             beq.s *               * branch if Z set
00:00001406 0DB01000        	  1301:             bclr.b d6,0(a0,d1.w)      *
00:0000140A 67FE            	  1302:             beq.s *               * branch if Z set
00:0000140C 0FB01001        	  1303:             bclr.b d7,1(a0,d1.w)      *
00:00001410 67FE            	  1304:             beq.s *               * branch if Z set
                            	  1305: *             EA = n(An,R.L)  - BYTE only
00:00001412 0BB00800        	  1306:             bclr.b d5,0(a0,d0.l)
00:00001416 66FE            	  1307:             bne.s *               * branch if Z clear
00:00001418 0DB01800        	  1308:             bclr.b d6,0(a0,d1.l)      *
00:0000141C 66FE            	  1309:             bne.s *               * branch if Z clear
00:0000141E 0FB01801        	  1310:             bclr.b d7,1(a0,d1.l)      *
00:00001422 66FE            	  1311:             bne.s *               * branch if Z clear
                            	  1312: *             EA = n(An,A.W)  - BYTE only
00:00001424 0BB09000        	  1313:             bclr.b d5,0(a0,a1.w)
00:00001428 66FE            	  1314:             bne.s *               * branch if Z clear
00:0000142A 0DB0A000        	  1315:             bclr.b d6,0(a0,a2.w)      *
00:0000142E 66FE            	  1316:             bne.s *               * branch if Z clear
00:00001430 0FB0A001        	  1317:             bclr.b d7,1(a0,a2.w)      *
00:00001434 66FE            	  1318:             bne.s *               * branch if Z clear
                            	  1319: *             EA = n(An,A.L)  - BYTE only
00:00001436 0BB09800        	  1320:             bclr.b d5,0(a0,a1.l)
00:0000143A 66FE            	  1321:             bne.s *               * branch if Z clear
00:0000143C 0DB0A800        	  1322:             bclr.b d6,0(a0,a2.l)      *
00:00001440 66FE            	  1323:             bne.s *               * branch if Z clear
00:00001442 0FB0A801        	  1324:             bclr.b d7,1(a0,a2.l)      *
00:00001446 66FE            	  1325:             bne.s *               * branch if Z clear
00:00001448 307C0100        	  1326:             move.l #$00000100,a0      * point to memory to address
00:0000144C 0C1000FE        	  1327:             cmpi.b #$FE,(a0)
00:00001450 66FE            	  1328:             bne.s *               * branch if Z clear
                            	  1329: 
                            	  1330: *             EA = x.W  - BYTE only
00:00001452 307C0100        	  1331:             move.l #$00000100,a0      * point to memory to address
00:00001456 10FC00FF        	  1332:             move.b #$FF,(a0)+         * populate test data
00:0000145A 10FC00FF        	  1333:             move.b #$FF,(a0)+         * populate test data
00:0000145E 10FC00FF        	  1334:             move.b #$FF,(a0)+         * populate test data
00:00001462 0BB80100        	  1335:             bclr.b d5,$0100
00:00001466 67FE            	  1336:             beq.s *               * branch if Z set
00:00001468 0DB80101        	  1337:             bclr.b d6,$0101           *
00:0000146C 67FE            	  1338:             beq.s *               * branch if Z set
00:0000146E 0FB80102        	  1339:             bclr.b d7,$0102           *
00:00001472 67FE            	  1340:             beq.s *               * branch if Z set
00:00001474 307C0100        	  1341:             move.l #$00000100,a0      * point to memory to address
00:00001478 0C1800FE        	  1342:             cmpi.b #$FE,(a0)+
00:0000147C 66FE            	  1343:             bne.s *               * branch if Z clear
                            	  1344: 
                            	  1345: *             EA = x.L  - BYTE only
00:0000147E 207C0000F100    	  1346:             move.l #$F100,a0      * point to memory to address 0x100
00:00001484 10FC0001        	  1347:             move.b #$01,(a0)+         * populate test data
00:00001488 10FC00FC        	  1348:             move.b #$FC,(a0)+         * populate test data
00:0000148C 10FC0080        	  1349:             move.b #$80,(a0)+         * populate test data
00:00001490 0BB90000F100    	  1350:             bclr.b d5,$F100
00:00001496 67FE            	  1351:             beq.s *               * branch if Z set
00:00001498 0DB90000F101    	  1352:             bclr.b d6,$F101       *
00:0000149E 66FE            	  1353:             bne.s *               * branch if Z clear
00:000014A0 0FB90000F102    	  1354:             bclr.b d7,$F102       *
00:000014A6 67FE            	  1355:             beq.s *               * branch if Z set
00:000014A8 207C0000F101    	  1356:             move.l #$F101,a0      * point to memory to address 0x100
00:000014AE 0C1000FC        	  1357:             cmpi.b #$FC,(a0)
00:000014B2 66FE            	  1358:             bne.s *               * branch if Z clear
                            	  1359: 
                            	  1360: 
                            	  1361: 
00:000014B4 4E75            	  1362:     rts
                            	  1363: 
                            	  1364: *-----------------------------------------------------------
                            	  1365: *-----------------------------------------------------------
                            	  1366: * OPCODE : BSET
                            	  1367: *-----------------------------------------------------------
                            	  1368: *-----------------------------------------------------------
                            	  1369: op_BSET:
                            	  1370: 
                            	  1371: 
                            	  1372: *  Bit Number.s Static
                            	  1373: 
                            	  1374: *             EA = Dn  - LONG only
00:000014B6 7000            	  1375:             moveq  #$00000000,d0      * populate test data
00:000014B8 08C00000        	  1376:             bset.l #0,d0
00:000014BC 66FE            	  1377:             bne.s *               * branch if Z clear
00:000014BE 08C00001        	  1378:             bset.l #1,d0              *
00:000014C2 66FE            	  1379:             bne.s *               * branch if Z clear
00:000014C4 08C0000F        	  1380:             bset.l #15,d0             *
00:000014C8 66FE            	  1381:             bne.s *               * branch if Z clear
00:000014CA 08C0001F        	  1382:             bset.l #31,d0             *
00:000014CE 66FE            	  1383:             bne.s *               * branch if Z clear
00:000014D0 0C8080008003    	  1384:             cmpi.l #$80008003,d0
00:000014D6 66FE            	  1385:             bne.s *               * branch if Z clear
                            	  1386: 
                            	  1387: 
                            	  1388: *             EA = (An)  - BYTE only
00:000014D8 307C0100        	  1389:             move.l #$00000100,a0      * point to memory to address 0x100
00:000014DC 4210            	  1390:             move.b #$00,(a0)          * populate test data
00:000014DE 08D00000        	  1391:             bset.b #0,(a0)
00:000014E2 66FE            	  1392:             bne.s *               * branch if Z clear
00:000014E4 08D00007        	  1393:             bset.b #7,(a0)            *
00:000014E8 66FE            	  1394:             bne.s *               * branch if Z clear
00:000014EA 0C100081        	  1395:             cmpi.b #$81,(a0)
00:000014EE 66FE            	  1396:             bne.s *               * branch if Z clear
                            	  1397: 
                            	  1398: *             EA = (An)+  - BYTE only
00:000014F0 307C0100        	  1399:             move.l #$00000100,a0      * point to memory to address 0x100
00:000014F4 4218            	  1400:             move.b #$00,(a0)+         * populate test data
00:000014F6 4218            	  1401:             move.b #$00,(a0)+         * populate test data
00:000014F8 307C0100        	  1402:             move.l #$00000100,a0      * point to memory to address 0x100
00:000014FC 08D80000        	  1403:             bset.b #0,(a0)+
00:00001500 66FE            	  1404:             bne.s *               * branch if Z clear
00:00001502 08D80001        	  1405:             bset.b #1,(a0)+           *
00:00001506 66FE            	  1406:             bne.s *               * branch if Z clear
00:00001508 307C0100        	  1407:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000150C 0C180001        	  1408:             cmpi.b #$01,(a0)+
00:00001510 66FE            	  1409:             bne.s *               * branch if Z clear
00:00001512 0C180002        	  1410:             cmpi.b #$02,(a0)+
00:00001516 66FE            	  1411:             bne.s *               * branch if Z clear
                            	  1412: 
                            	  1413: 
                            	  1414: *             EA = -(An)  - BYTE only
00:00001518 307C0100        	  1415:             move.l #$00000100,a0      * point to memory to address
00:0000151C 4218            	  1416:             move.b #$00,(a0)+         * populate test data
00:0000151E 4218            	  1417:             move.b #$00,(a0)+         * populate test data
00:00001520 08E00007        	  1418:             bset.b #7,-(a0)
00:00001524 66FE            	  1419:             bne.s *               * branch if Z clear
00:00001526 08E00000        	  1420:             bset.b #0,-(a0)           *
00:0000152A 66FE            	  1421:             bne.s *               * branch if Z clear
00:0000152C 307C0102        	  1422:             move.l #$00000102,a0      * point to memory to address 0x100
00:00001530 0C200080        	  1423:             cmpi.b #$80,-(a0)
00:00001534 66FE            	  1424:             bne.s *               * branch if Z clear
00:00001536 0C200001        	  1425:             cmpi.b #$01,-(a0)
00:0000153A 66FE            	  1426:             bne.s *               * branch if Z clear
                            	  1427: 
                            	  1428: 
                            	  1429: *             EA = n(An)  - BYTE only
00:0000153C 307C0100        	  1430:             move.l #$00000100,a0      * point to memory to address
00:00001540 4218            	  1431:             move.b #$00,(a0)+         * populate test data
00:00001542 4218            	  1432:             move.b #$00,(a0)+         * populate test data
00:00001544 307C0100        	  1433:             move.l #$00000100,a0      * point to memory to address
00:00001548 08D00000        	  1434:             bset.b #0,0(a0)
00:0000154C 66FE            	  1435:             bne.s *               * branch if Z clear
00:0000154E 08E800040001    	  1436:             bset.b #4,1(a0)           *
00:00001554 66FE            	  1437:             bne.s *               * branch if Z clear
00:00001556 307C0100        	  1438:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000155A 0C180001        	  1439:             cmpi.b #$01,(a0)+
00:0000155E 66FE            	  1440:             bne.s *               * branch if Z clear
00:00001560 0C180010        	  1441:             cmpi.b #$10,(a0)+
00:00001564 66FE            	  1442:             bne.s *               * branch if Z clear
                            	  1443: 
                            	  1444: 
                            	  1445: *             EA = n(An,D.W)  - BYTE only
00:00001566 307C0100        	  1446:             move.l #$00000100,a0      * point to memory to address
00:0000156A 93C9            	  1447:             move.l #$00000000,a1      * point to memory to address
00:0000156C 347C0004        	  1448:             move.l #$00000004,a2      * point to memory to address
00:00001570 7000            	  1449:             moveq  #$00000000,d0      * point to memory to address
00:00001572 7201            	  1450:             moveq  #$00000001,d1      * point to memory to address
00:00001574 4218            	  1451:             move.b #$00,(a0)+         * populate test data
00:00001576 4218            	  1452:             move.b #$00,(a0)+         * populate test data
00:00001578 4218            	  1453:             move.b #$00,(a0)+         * populate test data
00:0000157A 4218            	  1454:             move.b #$00,(a0)+         * populate test data
00:0000157C 4218            	  1455:             move.b #$00,(a0)+         * populate test data
00:0000157E 4218            	  1456:             move.b #$00,(a0)+         * populate test data
00:00001580 4218            	  1457:             move.b #$00,(a0)+         * populate test data
00:00001582 4218            	  1458:             move.b #$00,(a0)+         * populate test data
00:00001584 4218            	  1459:             move.b #$00,(a0)+         * populate test data
00:00001586 4218            	  1460:             move.b #$00,(a0)+         * populate test data
00:00001588 307C0100        	  1461:             move.l #$00000100,a0      * point to memory to address
00:0000158C 08F000000000    	  1462:             bset.b #0,0(a0,d0.w)
00:00001592 66FE            	  1463:             bne.s *               * branch if Z clear
00:00001594 08F000011000    	  1464:             bset.b #1,0(a0,d1.w)      *
00:0000159A 66FE            	  1465:             bne.s *               * branch if Z clear
00:0000159C 08F000021001    	  1466:             bset.b #2,1(a0,d1.w)      *
00:000015A2 66FE            	  1467:             bne.s *               * branch if Z clear
                            	  1468: *             EA = n(An,D.L)  - BYTE only
00:000015A4 08F000030802    	  1469:             bset.b #3,2(a0,d0.l)
00:000015AA 66FE            	  1470:             bne.s *               * branch if Z clear
00:000015AC 08F000041800    	  1471:             bset.b #4,0(a0,d1.l)      *
00:000015B2 66FE            	  1472:             bne.s *               * branch if Z clear
00:000015B4 08F000051801    	  1473:             bset.b #5,1(a0,d1.l)      *
00:000015BA 66FE            	  1474:             bne.s *               * branch if Z clear
                            	  1475: *             EA = n(An,A.W)  - BYTE only
00:000015BC 08F000069000    	  1476:             bset.b #6,0(a0,a1.w)
00:000015C2 66FE            	  1477:             bne.s *               * branch if Z clear
00:000015C4 08F00001A000    	  1478:             bset.b #1,0(a0,a2.w)      *
00:000015CA 66FE            	  1479:             bne.s *               * branch if Z clear
00:000015CC 08F00007A001    	  1480:             bset.b #7,1(a0,a2.w)      *
00:000015D2 66FE            	  1481:             bne.s *               * branch if Z clear
                            	  1482: *             EA = n(An,A.L)  - BYTE only
00:000015D4 08F00000A802    	  1483:             bset.b #0,2(a0,a2.l)
00:000015DA 66FE            	  1484:             bne.s *               * branch if Z clear
00:000015DC 08F00000A803    	  1485:             bset.b #0,3(a0,a2.l)      *
00:000015E2 66FE            	  1486:             bne.s *               * branch if Z clear
00:000015E4 08F00001A804    	  1487:             bset.b #1,4(a0,a2.l)      *
00:000015EA 66FE            	  1488:             bne.s *               * branch if Z clear
00:000015EC 307C0100        	  1489:             move.l #$00000100,a0      * point to memory to address 0x100
00:000015F0 0C9841122C00    	  1490:             cmpi.l #$41122C00,(a0)+
00:000015F6 66FE            	  1491:             bne.s *               * branch if Z clear
00:000015F8 0C9802800101    	  1492:             cmpi.l #$02800101,(a0)+
00:000015FE 66FE            	  1493:             bne.s *
                            	  1494: 
                            	  1495: 
                            	  1496: 
                            	  1497: *             EA = x.W  - BYTE only
00:00001600 307C0100        	  1498:             move.l #$00000100,a0      * point to memory to address
00:00001604 4218            	  1499:             move.b #$00,(a0)+         * populate test data
00:00001606 08F800000100    	  1500:             bset.b #0,$0100
00:0000160C 66FE            	  1501:             bne.s *               * branch if Z clear
00:0000160E 08F800010100    	  1502:             bset.b #1,$0100           *
00:00001614 66FE            	  1503:             bne.s *               * branch if Z clear
00:00001616 307C0100        	  1504:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000161A 0C180003        	  1505:             cmpi.b #$03,(a0)+
00:0000161E 66FE            	  1506:             bne.s *
                            	  1507: 
                            	  1508: 
                            	  1509: *             EA = x.L  - BYTE only
00:00001620 207C0000F100    	  1510:             move.l #$F100,a0      * point to memory to address 0x100
00:00001626 4210            	  1511:             move.b #$00,(a0)          * populate test data
00:00001628 08F900000000F100	  1512:             bset.b #0,$F100
00:00001630 66FE            	  1513:             bne.s *               * branch if Z clear
00:00001632 08F900010000F100	  1514:             bset.b #1,$F100       *
00:0000163A 66FE            	  1515:             bne.s *               * branch if Z clear
00:0000163C 08F900020000F100	  1516:             bset.b #2,$F100       *
00:00001644 66FE            	  1517:             bne.s *               * branch if Z clear
00:00001646 207C0000F100    	  1518:             move.l #$F100,a0      * point to memory to address 0x100
00:0000164C 0C180007        	  1519:             cmpi.b #$07,(a0)+
00:00001650 66FE            	  1520:             bne.s *
                            	  1521: 
                            	  1522: 
                            	  1523: * Bit Number.s Dynamic
                            	  1524: 
                            	  1525: *             EA = Dn  - LONG only
00:00001652 7000            	  1526:             moveq  #$00000000,d0      * populate test data
00:00001654 7A00            	  1527:             move.l #0,d5              * populate bit.s number to test
00:00001656 7C01            	  1528:             move.l #1,d6              * populate bit.s number to test
00:00001658 7E1F            	  1529:             move.l #31,d7              * populate bit.s number to test
                            	  1530: 
00:0000165A 0BC0            	  1531:             bset.l d5,d0
00:0000165C 66FE            	  1532:             bne.s *               * branch if Z clear
00:0000165E 0DC0            	  1533:             bset.l d6,d0              *
00:00001660 66FE            	  1534:             bne.s *               * branch if Z clear
00:00001662 0FC0            	  1535:             bset.l d7,d0             *
00:00001664 66FE            	  1536:             bne.s *               * branch if Z clear
00:00001666 0C8080000003    	  1537:             cmpi.l #$80000003,d0
00:0000166C 66FE            	  1538:             bne.s *               * branch if Z clear
                            	  1539: 
                            	  1540: 
                            	  1541: *             EA = (An)  - BYTE only
00:0000166E 7A00            	  1542:             move.l #0,d5              * populate bit.s number to test
00:00001670 7C01            	  1543:             move.l #1,d6              * populate bit.s number to test
00:00001672 7E07            	  1544:             move.l #7,d7              * populate bit.s number to test
00:00001674 307C0100        	  1545:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001678 4210            	  1546:             move.b #$00,(a0)          * populate test data
00:0000167A 0BD0            	  1547:             bset.b d5,(a0)
00:0000167C 66FE            	  1548:             bne.s *               * branch if Z clear
00:0000167E 0DD0            	  1549:             bset.b d6,(a0)            *
00:00001680 66FE            	  1550:             bne.s *               * branch if Z clear
00:00001682 0FD0            	  1551:             bset.b d7,(a0)            *
00:00001684 66FE            	  1552:             bne.s *               * branch if Z clear
00:00001686 0C100083        	  1553:             cmpi.b #$83,(a0)
00:0000168A 66FE            	  1554:             bne.s *               * branch if Z clear
                            	  1555: 
                            	  1556: 
                            	  1557: *             EA = (An)+  - BYTE only
00:0000168C 307C0100        	  1558:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001690 4218            	  1559:             move.b #$00,(a0)+         * populate test data
00:00001692 4218            	  1560:             move.b #$00,(a0)+         * populate test data
00:00001694 4218            	  1561:             move.b #$00,(a0)+         * populate test data
00:00001696 307C0100        	  1562:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000169A 0BD8            	  1563:             bset.b d5,(a0)+
00:0000169C 66FE            	  1564:             bne.s *               * branch if Z clear
00:0000169E 0DD8            	  1565:             bset.b d6,(a0)+           *
00:000016A0 66FE            	  1566:             bne.s *               * branch if Z clear
00:000016A2 0FD8            	  1567:             bset.b d7,(a0)+           *
00:000016A4 66FE            	  1568:             bne.s *               * branch if Z clear
00:000016A6 307C0100        	  1569:             move.l #$00000100,a0      * point to memory to address 0x100
00:000016AA 0C180001        	  1570:             cmpi.b #$01,(a0)+
00:000016AE 66FE            	  1571:             bne.s *               * branch if Z clear
00:000016B0 0C180002        	  1572:             cmpi.b #$02,(a0)+
00:000016B4 66FE            	  1573:             bne.s *               * branch if Z clear
00:000016B6 0C180080        	  1574:             cmpi.b #$80,(a0)+
00:000016BA 66FE            	  1575:             bne.s *               * branch if Z clear
                            	  1576: 
                            	  1577: *             EA = -(An)  - BYTE only
00:000016BC 307C0100        	  1578:             move.l #$00000100,a0      * point to memory to address
00:000016C0 4218            	  1579:             move.b #$00,(a0)+         * populate test data
00:000016C2 4218            	  1580:             move.b #$00,(a0)+         * populate test data
00:000016C4 4218            	  1581:             move.b #$00,(a0)+         * populate test data
00:000016C6 307C0103        	  1582:             move.l #$00000103,a0      * point to memory to address
00:000016CA 0BE0            	  1583:             bset.b d5,-(a0)
00:000016CC 66FE            	  1584:             bne.s *               * branch if Z clear
00:000016CE 0DE0            	  1585:             bset.b d6,-(a0)           *
00:000016D0 66FE            	  1586:             bne.s *               * branch if Z clear
00:000016D2 0FE0            	  1587:             bset.b d7,-(a0)           *
00:000016D4 66FE            	  1588:             bne.s *               * branch if Z clear
00:000016D6 307C0103        	  1589:             move.l #$00000103,a0      * point to memory to address 0x100
00:000016DA 0C200001        	  1590:             cmpi.b #$01,-(a0)
00:000016DE 66FE            	  1591:             bne.s *               * branch if Z clear
00:000016E0 0C200002        	  1592:             cmpi.b #$02,-(a0)
00:000016E4 66FE            	  1593:             bne.s *               * branch if Z clear
00:000016E6 0C200080        	  1594:             cmpi.b #$80,-(a0)
00:000016EA 66FE            	  1595:             bne.s *               * branch if Z clear
                            	  1596: 
                            	  1597: *             EA = n(An)  - BYTE only
00:000016EC 307C0100        	  1598:             move.l #$00000100,a0      * point to memory to address
00:000016F0 4218            	  1599:             move.b #$00,(a0)+         * populate test data
00:000016F2 4218            	  1600:             move.b #$00,(a0)+         * populate test data
00:000016F4 4218            	  1601:             move.b #$00,(a0)+         * populate test data
00:000016F6 307C0100        	  1602:             move.l #$00000100,a0      * point to memory to address
00:000016FA 0BD0            	  1603:             bset.b d5,0(a0)
00:000016FC 66FE            	  1604:             bne.s *               * branch if Z clear
00:000016FE 0DE80001        	  1605:             bset.b d6,1(a0)           *
00:00001702 66FE            	  1606:             bne.s *               * branch if Z clear
00:00001704 0FE80002        	  1607:             bset.b d7,2(a0)           *
00:00001708 66FE            	  1608:             bne.s *               * branch if Z clear
00:0000170A 307C0100        	  1609:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000170E 0C180001        	  1610:             cmpi.b #$01,(a0)+
00:00001712 66FE            	  1611:             bne.s *               * branch if Z clear
00:00001714 0C180002        	  1612:             cmpi.b #$02,(a0)+
00:00001718 66FE            	  1613:             bne.s *               * branch if Z clear
00:0000171A 0C180080        	  1614:             cmpi.b #$80,(a0)+
00:0000171E 66FE            	  1615:             bne.s *               * branch if Z clear
                            	  1616: 
                            	  1617: *             EA = n(An,R.W)  - BYTE only
00:00001720 307C0100        	  1618:             move.l #$00000100,a0      * point to memory to address
00:00001724 4218            	  1619:             move.b #$00,(a0)+         * populate test data
00:00001726 4218            	  1620:             move.b #$00,(a0)+         * populate test data
00:00001728 4218            	  1621:             move.b #$00,(a0)+         * populate test data
00:0000172A 4218            	  1622:             move.b #$00,(a0)+         * populate test data
00:0000172C 4218            	  1623:             move.b #$00,(a0)+         * populate test data
00:0000172E 4218            	  1624:             move.b #$00,(a0)+         * populate test data
00:00001730 4218            	  1625:             move.b #$00,(a0)+         * populate test data
00:00001732 4218            	  1626:             move.b #$00,(a0)+         * populate test data
00:00001734 4218            	  1627:             move.b #$00,(a0)+         * populate test data
00:00001736 4218            	  1628:             move.b #$00,(a0)+         * populate test data
00:00001738 4218            	  1629:             move.b #$00,(a0)+         * populate test data
00:0000173A 4218            	  1630:             move.b #$00,(a0)+         * populate test data
00:0000173C 307C0100        	  1631:             move.l #$00000100,a0      * point to memory to address
00:00001740 93C9            	  1632:             move.l #$00000000,a1      * point to memory to address
00:00001742 347C0001        	  1633:             move.l #$00000001,a2      * point to memory to address
00:00001746 7000            	  1634:             moveq  #$00000000,d0      * point to memory to address
00:00001748 7201            	  1635:             moveq  #$00000001,d1      * point to memory to address
00:0000174A 0BF00000        	  1636:             bset.b d5,0(a0,d0.w)
00:0000174E 66FE            	  1637:             bne.s *               * branch if Z clear
00:00001750 0DF01000        	  1638:             bset.b d6,0(a0,d1.w)      *
00:00001754 66FE            	  1639:             bne.s *               * branch if Z clear
00:00001756 0FF01001        	  1640:             bset.b d7,1(a0,d1.w)      *
00:0000175A 66FE            	  1641:             bne.s *               * branch if Z clear
                            	  1642: *             EA = n(An,R.L)  - BYTE only
00:0000175C 0BF00802        	  1643:             bset.b d5,2(a0,d0.l)
00:00001760 66FE            	  1644:             bne.s *               * branch if Z clear
00:00001762 0DF01803        	  1645:             bset.b d6,3(a0,d1.l)      *
00:00001766 66FE            	  1646:             bne.s *               * branch if Z clear
00:00001768 0FF01804        	  1647:             bset.b d7,4(a0,d1.l)      *
00:0000176C 66FE            	  1648:             bne.s *               * branch if Z clear
                            	  1649: *             EA = n(An,A.W)  - BYTE only
00:0000176E 0BF09005        	  1650:             bset.b d5,5(a0,a1.w)
00:00001772 66FE            	  1651:             bne.s *               * branch if Z clear
00:00001774 0DF0A006        	  1652:             bset.b d6,6(a0,a2.w)      *
00:00001778 66FE            	  1653:             bne.s *               * branch if Z clear
00:0000177A 0FF0A007        	  1654:             bset.b d7,7(a0,a2.w)      *
00:0000177E 66FE            	  1655:             bne.s *               * branch if Z clear
                            	  1656: *             EA = n(An,A.L)  - BYTE only
00:00001780 0BF09808        	  1657:             bset.b d5,8(a0,a1.l)
00:00001784 66FE            	  1658:             bne.s *               * branch if Z clear
00:00001786 0DF0A809        	  1659:             bset.b d6,9(a0,a2.l)      *
00:0000178A 66FE            	  1660:             bne.s *               * branch if Z clear
00:0000178C 0FF0A80A        	  1661:             bset.b d7,10(a0,a2.l)      *
00:00001790 66FE            	  1662:             bne.s *               * branch if Z clear
00:00001792 307C0100        	  1663:             move.l #$00000100,a0      * point to memory to address 0x100
00:00001796 0C9801028100    	  1664:             cmpi.l #$01028100,(a0)+
00:0000179C 66FE            	  1665:             bne.s *               * branch if Z clear
00:0000179E 0C9802810002    	  1666:             cmpi.l #$02810002,(a0)+
00:000017A4 66FE            	  1667:             bne.s *
                            	  1668: 
                            	  1669: 
                            	  1670: *             EA = x.W  - BYTE only
00:000017A6 307C0100        	  1671:             move.l #$00000100,a0      * point to memory to address
00:000017AA 4218            	  1672:             move.b #$00,(a0)+         * populate test data
00:000017AC 4218            	  1673:             move.b #$00,(a0)+         * populate test data
00:000017AE 4218            	  1674:             move.b #$00,(a0)+         * populate test data
00:000017B0 0BF80100        	  1675:             bset.b d5,$0100
00:000017B4 66FE            	  1676:             bne.s *               * branch if Z clear
00:000017B6 0DF80100        	  1677:             bset.b d6,$0100           *
00:000017BA 66FE            	  1678:             bne.s *               * branch if Z clear
00:000017BC 0FF80100        	  1679:             bset.b d7,$0100           *
00:000017C0 66FE            	  1680:             bne.s *               * branch if Z clear
00:000017C2 307C0100        	  1681:             move.l #$00000100,a0      * point to memory to address
00:000017C6 0C180083        	  1682:             cmpi.b #$83,(a0)+
00:000017CA 66FE            	  1683:             bne.s *               * branch if Z clear
                            	  1684: 
                            	  1685: *             EA = x.L  - BYTE only
00:000017CC 207C0000F100    	  1686:             move.l #$F100,a0      * point to memory to address 0x100
00:000017D2 4218            	  1687:             move.b #$00,(a0)+         * populate test data
00:000017D4 4218            	  1688:             move.b #$00,(a0)+         * populate test data
00:000017D6 4218            	  1689:             move.b #$00,(a0)+         * populate test data
00:000017D8 0BF90000F100    	  1690:             bset.b d5,$F100
00:000017DE 66FE            	  1691:             bne.s *               * branch if Z clear
00:000017E0 0DF90000F100    	  1692:             bset.b d6,$F100       *
00:000017E6 66FE            	  1693:             bne.s *               * branch if Z clear
00:000017E8 0FF90000F100    	  1694:             bset.b d7,$F100       *
00:000017EE 66FE            	  1695:             bne.s *               * branch if Z clear
00:000017F0 207C0000F100    	  1696:             move.l #$F100,a0      * point to memory to address 0x100
00:000017F6 0C100083        	  1697:             cmpi.b #$83,(a0)
00:000017FA 66FE            	  1698:             bne.s *               * branch if Z clear
                            	  1699: 
                            	  1700: 
00:000017FC 4E75            	  1701:     rts
                            	  1702: 
                            	  1703: *-----------------------------------------------------------
                            	  1704: *-----------------------------------------------------------
                            	  1705: * OPCODE : MOVEP
                            	  1706: *-----------------------------------------------------------
                            	  1707: *-----------------------------------------------------------
                            	  1708: op_MOVEP:
                            	  1709: 
                            	  1710: * Dn --> x(An)
00:000017FE 307C0100        	  1711:             move.l #$00000100,a0
00:00001802 203C12345678    	  1712:             move.l #$12345678,d0
00:00001808 223CAABBCCDD    	  1713:             move.l #$AABBCCDD,d1
00:0000180E 4290            	  1714:             move.l #0,(a0)
00:00001810 42A80004        	  1715:             move.l #0,4(a0)
                            	  1716: 
00:00001814 01880000        	  1717:             movep.w d0,0(a0)      * even offset
00:00001818 03880001        	  1718:             movep.w d1,1(a0)      * odd offset
                            	  1719: 
00:0000181C 01C80004        	  1720:             movep.l d0,4(a0)      * even offset
00:00001820 03C80005        	  1721:             movep.l d1,5(a0)      * odd offset
                            	  1722: 
00:00001824 0C9056CC78DD    	  1723:             cmpi.l #$56CC78DD,(a0)
00:0000182A 66FE            	  1724:             bne.s *
00:0000182C 0CA812AA34BB0004	  1725:             cmpi.l #$12AA34BB,4(a0)
00:00001834 66FE            	  1726:             bne.s *
00:00001836 0CA856CC78DD0008	  1727:             cmpi.l #$56CC78DD,8(a0)
00:0000183E 66FE            	  1728:             bne.s *
                            	  1729: 
                            	  1730: 
                            	  1731: * x(An)--> Dn
00:00001840 203C5A5A5A5A    	  1732:             move.l #$5a5a5a5a,d0
00:00001846 223C5A5A5A5A    	  1733:             move.l #$5a5a5a5a,d1
00:0000184C 243C5A5A5A5A    	  1734:             move.l #$5a5a5a5a,d2
00:00001852 263C5A5A5A5A    	  1735:             move.l #$5a5a5a5a,d3
                            	  1736: 
00:00001858 01080000        	  1737:             movep.w 0(a0),d0      * even offset
00:0000185C 03080001        	  1738:             movep.w 1(a0),d1      * odd offset
                            	  1739: 
00:00001860 05480004        	  1740:             movep.l 4(a0),d2      * even offset
00:00001864 07480005        	  1741:             movep.l 5(a0),d3      * odd offset
                            	  1742: 
00:00001868 0C805A5A5678    	  1743:             cmpi.l #$5a5a5678,d0
00:0000186E 66FE            	  1744:             bne.s *
00:00001870 0C815A5ACCDD    	  1745:             cmpi.l #$5a5aCCDD,d1
00:00001876 66FE            	  1746:             bne.s *
00:00001878 0C8212345678    	  1747:             cmpi.l #$12345678,d2
00:0000187E 66FE            	  1748:             bne.s *
00:00001880 0C83AABBCCDD    	  1749:             cmpi.l #$AABBCCDD,d3
00:00001886 66FE            	  1750:             bne.s *
                            	  1751: 
00:00001888 4E75            	  1752:             rts
                            	  1753: 
                            	  1754: 
                            	  1755: 
                            	  1756: *-----------------------------------------------------------
                            	  1757: *-----------------------------------------------------------
                            	  1758: * OPCODE : BOOL_I
                            	  1759: *-----------------------------------------------------------
                            	  1760: *-----------------------------------------------------------
                            	  1761: op_BOOL_I:
                            	  1762: 
                            	  1763: *     Dn -- BYTE
00:0000188A 203C12345678    	  1764:             move.l #$12345678,d0
00:00001890 44FC000F        	  1765:             move.w #$000F,CCR          * pre-set Flags
00:00001894 000000FF        	  1766:             ori.b  #$FF,d0
00:00001898 0A00005A        	  1767:             eori.b #$5A,d0
00:0000189C 020000F0        	  1768:             andi.b #$F0,d0
00:000018A0 69FE            	  1769:             bvs.s *                       * Check V,C are cleared
00:000018A2 65FE            	  1770:             bcs.s *
00:000018A4 6AFE            	  1771:             bpl.s *                       * Verify if N flag is set
00:000018A6 4200            	  1772:             andi.b #$00,d0
00:000018A8 6BFE            	  1773:             bmi.s *                       * Verify if N flag is cleared
00:000018AA 66FE            	  1774:             bne.s *                       * Verify if Z flag is set
                            	  1775: 
                            	  1776: *     Dn -- WORD
00:000018AC 223C12345678    	  1777:             move.l #$12345678,d1
00:000018B2 44FC000F        	  1778:             move.w #$000F,CCR          * pre-set Flags
00:000018B6 0041FFFF        	  1779:             ori.w  #$FFFF,d1
00:000018BA 0A415A5A        	  1780:             eori.w #$5A5A,d1
00:000018BE 0241F0F0        	  1781:             andi.w #$F0F0,d1
00:000018C2 69FE            	  1782:             bvs.s *                       * Check V,C are cleared
00:000018C4 65FE            	  1783:             bcs.s *
00:000018C6 6AFE            	  1784:             bpl.s *                       * Verify if N flag is set
00:000018C8 4241            	  1785:             andi.w #$0000,d1
00:000018CA 6BFE            	  1786:             bmi.s *                       * Verify if N flag is cleared
00:000018CC 66FE            	  1787:             bne.s *                       * Verify if Z flag is set
                            	  1788: 
                            	  1789: *     Dn -- LONG
00:000018CE 243C12345678    	  1790:             move.l #$12345678,d2
00:000018D4 44FC000F        	  1791:             move.w #$000F,CCR          * pre-set Flags
00:000018D8 0082FFFFFFFF    	  1792:             ori.l  #$FFFFFFFF,d2
00:000018DE 0A825A5A5A5A    	  1793:             eori.l #$5A5A5A5A,d2
00:000018E4 0282F0F0F0F0    	  1794:             andi.l #$F0F0F0F0,d2
00:000018EA 69FE            	  1795:             bvs.s *                       * Check V,C are cleared
00:000018EC 65FE            	  1796:             bcs.s *
00:000018EE 6AFE            	  1797:             bpl.s *                       * Verify if N flag is set
00:000018F0 4282            	  1798:             andi.l #$00000000,d2
00:000018F2 6BFE            	  1799:             bmi.s *                       * Verify if N flag is cleared
00:000018F4 66FE            	  1800:             bne.s *                       * Verify if Z flag is set
                            	  1801: 
                            	  1802: 
                            	  1803: *     (An) -- BYTE
00:000018F6 307C0100        	  1804:             move.l #$00000100,a0
00:000018FA 20BC12345678    	  1805:             move.l #$12345678,(a0)
00:00001900 44FC000F        	  1806:             move.w #$000F,CCR          * pre-set Flags
00:00001904 001000FF        	  1807:             ori.b  #$FF,(a0)
00:00001908 0A10005A        	  1808:             eori.b #$5A,(a0)
00:0000190C 021000F0        	  1809:             andi.b #$F0,(a0)
00:00001910 69FE            	  1810:             bvs.s *                       * Check V,C are cleared
00:00001912 65FE            	  1811:             bcs.s *
00:00001914 6AFE            	  1812:             bpl.s *                       * Verify if N flag is set
00:00001916 4210            	  1813:             andi.b #$00,(a0)
00:00001918 6BFE            	  1814:             bmi.s *                       * Verify if N flag is cleared
00:0000191A 66FE            	  1815:             bne.s *                       * Verify if Z flag is set
00:0000191C 4A10            	  1816:             cmpi.b #$00,(a0)
00:0000191E 66FE            	  1817:             bne.s *                       * Verify if Z flag is set
                            	  1818: 
                            	  1819: *     (An) -- WORD
00:00001920 20BC12345678    	  1820:             move.l #$12345678,(a0)
00:00001926 44FC000F        	  1821:             move.w #$000F,CCR          * pre-set Flags
00:0000192A 0050FFFF        	  1822:             ori.w  #$FFFF,(a0)
00:0000192E 0A505A5A        	  1823:             eori.w #$5A5A,(a0)
00:00001932 0250F0F0        	  1824:             andi.w #$F0F0,(a0)
00:00001936 69FE            	  1825:             bvs.s *                       * Check V,C are cleared
00:00001938 65FE            	  1826:             bcs.s *
00:0000193A 6AFE            	  1827:             bpl.s *                       * Verify if N flag is set
00:0000193C 4250            	  1828:             andi.w #$0000,(a0)
00:0000193E 6BFE            	  1829:             bmi.s *                       * Verify if N flag is cleared
00:00001940 66FE            	  1830:             bne.s *                       * Verify if Z flag is set
00:00001942 4A50            	  1831:             cmpi.w #$00,(a0)
00:00001944 66FE            	  1832:             bne.s *                       * Verify if Z flag is set
                            	  1833: 
                            	  1834: *     (An) -- LONG
00:00001946 20BC12345678    	  1835:             move.l #$12345678,(a0)
00:0000194C 44FC000F        	  1836:             move.w #$000F,CCR          * pre-set Flags
00:00001950 0090FFFFFFFF    	  1837:             ori.l  #$FFFFFFFF,(a0)
00:00001956 0A905A5A5A5A    	  1838:             eori.l #$5A5A5A5A,(a0)
00:0000195C 0290F0F0F0F0    	  1839:             andi.l #$F0F0F0F0,(a0)
00:00001962 69FE            	  1840:             bvs.s *                       * Check V,C are cleared
00:00001964 65FE            	  1841:             bcs.s *
00:00001966 6AFE            	  1842:             bpl.s *                       * Verify if N flag is set
00:00001968 4290            	  1843:             andi.l #$00000000,(a0)
00:0000196A 6BFE            	  1844:             bmi.s *                       * Verify if N flag is cleared
00:0000196C 66FE            	  1845:             bne.s *                       * Verify if Z flag is set
00:0000196E 4A90            	  1846:             cmpi.l #$00,(a0)
00:00001970 66FE            	  1847:             bne.s *                       * Verify if Z flag is set
                            	  1848: 
                            	  1849: 
                            	  1850: 
                            	  1851: *     (An)+ -- BYTE
00:00001972 307C0100        	  1852:             move.l #$00000100,a0
00:00001976 20BC00A5FF88    	  1853:             move.l #$00A5FF88,(a0)
00:0000197C 44FC000F        	  1854:             move.w #$000F,CCR          * pre-set Flags
                            	  1855: 
00:00001980 001800F5        	  1856:             ori.b  #$F5,(a0)+
00:00001984 6AFE            	  1857:             bpl.s *                       * Verify if N flag is set
00:00001986 67FE            	  1858:             beq.s *                       * Verify if Z flag is cleared
                            	  1859: 
00:00001988 4618            	  1860:             eori.b #$FF,(a0)+
00:0000198A 6BFE            	  1861:             bmi.s *                       * Verify if N flag is cleared
00:0000198C 67FE            	  1862:             beq.s *                       * Verify if Z flag is cleared
                            	  1863: 
00:0000198E 021800AA        	  1864:             andi.b #$AA,(a0)+
00:00001992 6AFE            	  1865:             bpl.s *                       * Verify if N flag is set
00:00001994 67FE            	  1866:             beq.s *                       * Verify if Z flag is cleared
                            	  1867: 
00:00001996 307C0100        	  1868:             move.l #$00000100,a0
00:0000199A 0C90F55AAA88    	  1869:             cmpi.l #$F55AAA88,(a0)
00:000019A0 66FE            	  1870:             bne.s *                       * Verify if Z flag is set
                            	  1871: 
                            	  1872: 
                            	  1873: *     (An)+ -- WORD
00:000019A2 307C0100        	  1874:             move.l #$00000100,a0
00:000019A6 327C0104        	  1875:             move.l #$00000104,a1
00:000019AA 20BC00005A5A    	  1876:             move.l #$00005a5a,(a0)
00:000019B0 22BC12345678    	  1877:             move.l #$12345678,(a1)
00:000019B6 44FC000F        	  1878:             move.w #$000F,CCR          * pre-set Flags
                            	  1879: 
00:000019BA 00585678        	  1880:             ori.w  #$5678,(a0)+
00:000019BE 6BFE            	  1881:             bmi.s *                       * Verify if N flag is cleared
00:000019C0 67FE            	  1882:             beq.s *                       * Verify if Z flag is cleared
                            	  1883: 
00:000019C2 4658            	  1884:             eori.w #$FFFF,(a0)+
00:000019C4 6AFE            	  1885:             bpl.s *                       * Verify if N flag is set
00:000019C6 67FE            	  1886:             beq.s *                       * Verify if Z flag is cleared
                            	  1887: 
00:000019C8 0258A55A        	  1888:             andi.w #$A55A,(a0)+
00:000019CC 6BFE            	  1889:             bmi.s *                       * Verify if N flag is cleared
00:000019CE 67FE            	  1890:             beq.s *                       * Verify if Z flag is cleared
                            	  1891: 
00:000019D0 307C0100        	  1892:             move.l #$00000100,a0
00:000019D4 0C905678A5A5    	  1893:             cmpi.l #$5678a5a5,(a0)
00:000019DA 307C0104        	  1894:             move.l #$00000104,a0
00:000019DE 0C9000105678    	  1895:             cmpi.l #$00105678,(a0)
00:000019E4 66FE            	  1896:             bne.s *                       * Verify if Z flag is set
                            	  1897: 
                            	  1898: *     (An)+ -- LONG
00:000019E6 307C0100        	  1899:             move.l #$00000100,a0
00:000019EA 4298            	  1900:             move.l #$00000000,(a0)+
00:000019EC 20FC5A5A5A5A    	  1901:             move.l #$5a5a5a5a,(a0)+
00:000019F2 20FCFFFFFFFF    	  1902:             move.l #$FFFFFFFF,(a0)+
00:000019F8 307C0100        	  1903:             move.l #$00000100,a0
00:000019FC 44FC000F        	  1904:             move.w #$000F,CCR          * pre-set Flags
                            	  1905: 
00:00001A00 009812345678    	  1906:             ori.l  #$12345678,(a0)+
00:00001A06 6BFE            	  1907:             bmi.s *                       * Verify if N flag is cleared
00:00001A08 67FE            	  1908:             beq.s *                       * Verify if Z flag is cleared
                            	  1909: 
00:00001A0A 4698            	  1910:             eori.l #$FFFFFFFF,(a0)+
00:00001A0C 6AFE            	  1911:             bpl.s *                       * Verify if N flag is set
00:00001A0E 67FE            	  1912:             beq.s *                       * Verify if Z flag is cleared
                            	  1913: 
00:00001A10 0298A5A5A55A    	  1914:             andi.l #$A5A5A55A,(a0)+
00:00001A16 6AFE            	  1915:             bpl.s *                       * Verify if N flag is set
00:00001A18 67FE            	  1916:             beq.s *                       * Verify if Z flag is cleared
                            	  1917: 
00:00001A1A 307C0100        	  1918:             move.l #$00000100,a0
00:00001A1E 0C9812345678    	  1919:             cmpi.l #$12345678,(a0)+
00:00001A24 0C98A5A5A5A5    	  1920:             cmpi.l #$a5a5a5a5,(a0)+
00:00001A2A 0C98A5A5A55A    	  1921:             cmpi.l #$a5a5a55a,(a0)+
00:00001A30 66FE            	  1922:             bne.s *                       * Verify if Z flag is set
                            	  1923: 
00:00001A32 4E75            	  1924:             rts
                            	  1925: 
                            	  1926: 
                            	  1927: *-----------------------------------------------------------
                            	  1928: *-----------------------------------------------------------
                            	  1929: * OPCODE : BSR
                            	  1930: *-----------------------------------------------------------
                            	  1931: *-----------------------------------------------------------
                            	  1932: 
                            	  1933: 
00:00001A34 223C11111111    	  1934: BSR_CLOSE1:     move.l #$11111111,d1
00:00001A3A 4E75            	  1935:                 rts
                            	  1936: 
                            	  1937: 
                            	  1938: 
00:00001A3C 61F6            	  1939: op_BSR:         bsr BSR_CLOSE1        * Negative 8-bit.s displacement
00:00001A3E 612A            	  1940:                 bsr BSR_CLOSE2        * Positive 8-bit.s displacement
00:00001A40 6100EF20        	  1941:                 bsr.w BSR_FAR1          * Negative 16-bit.s displacement
00:00001A44 6100144E        	  1942:                 bsr.w BSR_FAR2          * Positive 16-bit.s displacement
                            	  1943: 
00:00001A48 0C8111111111    	  1944:                 cmpi.l #$11111111,d1
00:00001A4E 66FE            	  1945:                 bne.s *
00:00001A50 0C8222222222    	  1946:                 cmpi.l #$22222222,d2
00:00001A56 66FE            	  1947:                 bne.s *
00:00001A58 0C8333333333    	  1948:                 cmpi.l #$33333333,d3
00:00001A5E 66FE            	  1949:                 bne.s *
00:00001A60 0C8444444444    	  1950:                 cmpi.l #$44444444,d4
00:00001A66 66FE            	  1951:                 bne.s *
                            	  1952: 
00:00001A68 4E75            	  1953:                 rts
                            	  1954: 
                            	  1955: 
00:00001A6A 243C22222222    	  1956: BSR_CLOSE2:     move.l #$22222222,d2
00:00001A70 4E75            	  1957:                 rts
                            	  1958: 
                            	  1959: *-----------------------------------------------------------
                            	  1960: *-----------------------------------------------------------
                            	  1961: * OPCODE : op_CMP_I
                            	  1962: *-----------------------------------------------------------
                            	  1963: *-----------------------------------------------------------
                            	  1964: op_CMP_I:
                            	  1965: 
00:00001A72 307C0100        	  1966:             move.l #$00000100,a0
00:00001A76 20BC00000100    	  1967:             move.l #$00000100,(a0)
                            	  1968: 
                            	  1969: *     REGISTER - BYTE
00:00001A7C 7080            	  1970:             move.l #$FFFFFF80,d0
00:00001A7E 0C000080        	  1971:             cmpi.b #$80,d0
00:00001A82 66FE            	  1972:             bne.s *                       * Check Z Flag  beq/bne
00:00001A84 6BFE            	  1973:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001A86 65FE            	  1974:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001A88 69FE            	  1975:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1976: 
00:00001A8A 223CFFFFF000    	  1977:             move.l #$FFFFF000,d1
00:00001A90 4A01            	  1978:             cmpi.b #$00,d1
00:00001A92 66FE            	  1979:             bne.s *                       * Check Z Flag  beq/bne
00:00001A94 6BFE            	  1980:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001A96 65FE            	  1981:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001A98 69FE            	  1982:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1983: 
00:00001A9A 7481D442        	  1984:             move.l #$FFFFFF02,d2
00:00001A9E 0C0200FF        	  1985:             cmpi.b #$FF,d2
00:00001AA2 67FE            	  1986:             beq.s *                       * Check Z Flag  beq/bne
00:00001AA4 6BFE            	  1987:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001AA6 64FE            	  1988:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001AA8 69FE            	  1989:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1990: 
00:00001AAA 263CFFFFFF7F    	  1991:             move.l #$FFFFFF7F,d3
00:00001AB0 0C0300FF        	  1992:             cmpi.b #$FF,d3
00:00001AB4 67FE            	  1993:             beq.s *                       * Check Z Flag  beq/bne
00:00001AB6 6AFE            	  1994:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001AB8 64FE            	  1995:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001ABA 68FE            	  1996:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  1997: 
                            	  1998: 
                            	  1999: *     REGISTER - WORD
00:00001ABC 203CFFFF8000    	  2000:             move.l #$FFFF8000,d0
00:00001AC2 0C408000        	  2001:             cmpi.w #$8000,d0
00:00001AC6 66FE            	  2002:             bne.s *                       * Check Z Flag  beq/bne
00:00001AC8 6BFE            	  2003:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001ACA 65FE            	  2004:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001ACC 69FE            	  2005:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2006: 
00:00001ACE 223CFFF00000    	  2007:             move.l #$FFF00000,d1
00:00001AD4 4A41            	  2008:             cmpi.w #$0000,d1
00:00001AD6 66FE            	  2009:             bne.s *                       * Check Z Flag  beq/bne
00:00001AD8 6BFE            	  2010:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001ADA 65FE            	  2011:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001ADC 69FE            	  2012:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2013: 
00:00001ADE 243CFFFF0002    	  2014:             move.l #$FFFF0002,d2
00:00001AE4 0C42FFFF        	  2015:             cmpi.w #$FFFF,d2
00:00001AE8 67FE            	  2016:             beq.s *                       * Check Z Flag  beq/bne
00:00001AEA 6BFE            	  2017:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001AEC 64FE            	  2018:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001AEE 69FE            	  2019:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2020: 
00:00001AF0 263CFFFF7FFF    	  2021:             move.l #$FFFF7FFF,d3
00:00001AF6 0C43FFFF        	  2022:             cmpi.w #$FFFF,d3
00:00001AFA 67FE            	  2023:             beq.s *                       * Check Z Flag  beq/bne
00:00001AFC 6AFE            	  2024:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001AFE 64FE            	  2025:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001B00 68FE            	  2026:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2027: 
                            	  2028: *     REGISTER - LONG
00:00001B02 203C80000000    	  2029:             move.l #$80000000,d0
00:00001B08 0C8080000000    	  2030:             cmpi.l #$80000000,d0
00:00001B0E 66FE            	  2031:             bne.s *                       * Check Z Flag  beq/bne
00:00001B10 6BFE            	  2032:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001B12 65FE            	  2033:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001B14 69FE            	  2034:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2035: 
00:00001B16 7200            	  2036:             moveq  #$00000000,d1
00:00001B18 4A81            	  2037:             cmpi.l #$00000000,d1
00:00001B1A 66FE            	  2038:             bne.s *                       * Check Z Flag  beq/bne
00:00001B1C 6BFE            	  2039:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001B1E 65FE            	  2040:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001B20 69FE            	  2041:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2042: 
00:00001B22 7402            	  2043:             moveq  #$00000002,d2
00:00001B24 0C82FFFFFFFF    	  2044:             cmpi.l #$FFFFFFFF,d2
00:00001B2A 67FE            	  2045:             beq.s *                       * Check Z Flag  beq/bne
00:00001B2C 6BFE            	  2046:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001B2E 64FE            	  2047:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001B30 69FE            	  2048:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2049: 
00:00001B32 263C7FFFFFFF    	  2050:             move.l #$7FFFFFFF,d3
00:00001B38 0C83FFFFFFFF    	  2051:             cmpi.l #$FFFFFFFF,d3
00:00001B3E 67FE            	  2052:             beq.s *                       * Check Z Flag  beq/bne
00:00001B40 6AFE            	  2053:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001B42 64FE            	  2054:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001B44 68FE            	  2055:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2056: 
                            	  2057: 
                            	  2058: 
                            	  2059: 
                            	  2060: *     EA=x(An,Dn) - BYTE
00:00001B46 307C0100        	  2061:             move.l #$00000100,a0
00:00001B4A 7E04            	  2062:             moveq  #$00000004,d7
                            	  2063: 
00:00001B4C 21BCFFFFFF80700C	  2064:             move.l #$FFFFFF80,12(a0,d7)
00:00001B54 21BCFFFFFF80700C	  2065:             move.l #$FFFFFF80,12(a0,d7)
00:00001B5C 0C300080700F    	  2066:             cmpi.b #$80,15(a0,d7)
00:00001B62 66FE            	  2067:             bne.s *                       * Check Z Flag  beq/bne
00:00001B64 6BFE            	  2068:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001B66 65FE            	  2069:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001B68 69FE            	  2070:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2071: 
00:00001B6A 21BCFFFFF000700C	  2072:             move.l #$FFFFF000,12(a0,d7)
00:00001B72 4A30700F        	  2073:             cmpi.b #$00,15(a0,d7)
00:00001B76 66FE            	  2074:             bne.s *                       * Check Z Flag  beq/bne
00:00001B78 6BFE            	  2075:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001B7A 65FE            	  2076:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001B7C 69FE            	  2077:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2078: 
00:00001B7E 21BCFFFFFF02700C	  2079:             move.l #$FFFFFF02,12(a0,d7)
00:00001B86 0C3000FF700F    	  2080:             cmpi.b #$FF,15(a0,d7)
00:00001B8C 67FE            	  2081:             beq.s *                       * Check Z Flag  beq/bne
00:00001B8E 6BFE            	  2082:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001B90 64FE            	  2083:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001B92 69FE            	  2084:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2085: 
00:00001B94 21BCFFFFFF7F700C	  2086:             move.l #$FFFFFF7F,12(a0,d7)
00:00001B9C 0C3000FF700F    	  2087:             cmpi.b #$FF,15(a0,d7)
00:00001BA2 67FE            	  2088:             beq.s *                       * Check Z Flag  beq/bne
00:00001BA4 6AFE            	  2089:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001BA6 64FE            	  2090:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001BA8 68FE            	  2091:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2092: 
                            	  2093: 
                            	  2094: *     EA=x(An,Dn) - WORD
00:00001BAA 21BCFFFF8000700C	  2095:             move.l #$FFFF8000,12(a0,d7)
00:00001BB2 0C708000700E    	  2096:             cmpi.w #$8000,14(a0,d7)
00:00001BB8 66FE            	  2097:             bne.s *                       * Check Z Flag  beq/bne
00:00001BBA 6BFE            	  2098:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001BBC 65FE            	  2099:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001BBE 69FE            	  2100:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2101: 
00:00001BC0 21BCFFF00000700C	  2102:             move.l #$FFF00000,12(a0,d7)
00:00001BC8 4A70700E        	  2103:             cmpi.w #$0000,14(a0,d7)
00:00001BCC 66FE            	  2104:             bne.s *                       * Check Z Flag  beq/bne
00:00001BCE 6BFE            	  2105:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001BD0 65FE            	  2106:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001BD2 69FE            	  2107:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2108: 
00:00001BD4 21BCFFFF0002700C	  2109:             move.l #$FFFF0002,12(a0,d7)
00:00001BDC 0C70FFFF700E    	  2110:             cmpi.w #$FFFF,14(a0,d7)
00:00001BE2 67FE            	  2111:             beq.s *                       * Check Z Flag  beq/bne
00:00001BE4 6BFE            	  2112:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001BE6 64FE            	  2113:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001BE8 69FE            	  2114:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2115: 
00:00001BEA 21BCFFFF7FFF700C	  2116:             move.l #$FFFF7FFF,12(a0,d7)
00:00001BF2 0C70FFFF700E    	  2117:             cmpi.w #$FFFF,14(a0,d7)
00:00001BF8 67FE            	  2118:             beq.s *                       * Check Z Flag  beq/bne
00:00001BFA 6AFE            	  2119:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001BFC 64FE            	  2120:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001BFE 68FE            	  2121:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2122: 
                            	  2123: *     EA=x(An,Dn) - LONG
00:00001C00 21BC80000000700C	  2124:             move.l #$80000000,12(a0,d7)
00:00001C08 0CB080000000700C	  2125:             cmpi.l #$80000000,12(a0,d7)
00:00001C10 66FE            	  2126:             bne.s *                       * Check Z Flag  beq/bne
00:00001C12 6BFE            	  2127:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001C14 65FE            	  2128:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001C16 69FE            	  2129:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2130: 
00:00001C18 42B0700C        	  2131:             move.l #$00000000,12(a0,d7)
00:00001C1C 4AB0700C        	  2132:             cmpi.l #$00000000,12(a0,d7)
00:00001C20 66FE            	  2133:             bne.s *                       * Check Z Flag  beq/bne
00:00001C22 6BFE            	  2134:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001C24 65FE            	  2135:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001C26 69FE            	  2136:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2137: 
00:00001C28 21BC00000002700C	  2138:             move.l #$00000002,12(a0,d7)
00:00001C30 0CB0FFFFFFFF700C	  2139:             cmpi.l #$FFFFFFFF,12(a0,d7)
00:00001C38 67FE            	  2140:             beq.s *                       * Check Z Flag  beq/bne
00:00001C3A 6BFE            	  2141:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001C3C 64FE            	  2142:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001C3E 69FE            	  2143:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2144: 
00:00001C40 21BC7FFFFFFF700C	  2145:             move.l #$7FFFFFFF,12(a0,d7)
00:00001C48 0CB0FFFFFFFF700C	  2146:             cmpi.l #$FFFFFFFF,12(a0,d7)
00:00001C50 67FE            	  2147:             beq.s *                       * Check Z Flag  beq/bne
00:00001C52 6AFE            	  2148:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001C54 64FE            	  2149:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001C56 68FE            	  2150:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2151: 
                            	  2152: 
                            	  2153: 
                            	  2154: 
00:00001C58 4E75            	  2155:             rts
                            	  2156: 
                            	  2157: 
                            	  2158: 
                            	  2159: *-----------------------------------------------------------
                            	  2160: *-----------------------------------------------------------
                            	  2161: * OPCODE : ADD_I
                            	  2162: *-----------------------------------------------------------
                            	  2163: *-----------------------------------------------------------
                            	  2164: op_ADD_I:
                            	  2165: 
                            	  2166: *     EA = Dn  - Byte
00:00001C5A 203C12345678    	  2167:             move.l #$12345678,d0      * populate test data
00:00001C60 06000000        	  2168:             addi.b #0,d0
00:00001C64 67FE            	  2169:             beq.s *                       * Check Z Flag  beq/bne
00:00001C66 6BFE            	  2170:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001C68 65FE            	  2171:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001C6A 69FE            	  2172:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001C6C 06000010        	  2173:             addi.b #$10,d0
00:00001C70 67FE            	  2174:             beq.s *                       * Check Z Flag  beq/bne
00:00001C72 6AFE            	  2175:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001C74 65FE            	  2176:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001C76 68FE            	  2177:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001C78 060000A5        	  2178:             addi.b #$A5,d0
00:00001C7C 67FE            	  2179:             beq.s *                       * Check Z Flag  beq/bne
00:00001C7E 6BFE            	  2180:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001C80 64FE            	  2181:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001C82 68FE            	  2182:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001C84 0C00002D        	  2183:             cmpi.b #$2D,d0
00:00001C88 66FE            	  2184:             bne.s *                       * Check Z Flag  beq/bne
                            	  2185: 
                            	  2186: *     EA = Dn  - WORD
00:00001C8A 203C12345678    	  2187:             move.l #$12345678,d0      * populate test data
00:00001C90 06400000        	  2188:             addi.w #0,d0
00:00001C94 67FE            	  2189:             beq.s *                       * Check Z Flag  beq/bne
00:00001C96 6BFE            	  2190:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001C98 65FE            	  2191:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001C9A 69FE            	  2192:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001C9C 06407000        	  2193:             addi.w #$7000,d0
00:00001CA0 67FE            	  2194:             beq.s *                       * Check Z Flag  beq/bne
00:00001CA2 6AFE            	  2195:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001CA4 65FE            	  2196:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001CA6 68FE            	  2197:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001CA8 0640A55A        	  2198:             addi.w #$A55A,d0
00:00001CAC 67FE            	  2199:             beq.s *                       * Check Z Flag  beq/bne
00:00001CAE 6BFE            	  2200:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001CB0 64FE            	  2201:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001CB2 68FE            	  2202:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001CB4 0C406BD2        	  2203:             cmpi.w #$6BD2,d0
00:00001CB8 66FE            	  2204:             bne.s *                       * Check Z Flag  beq/bne
                            	  2205: 
                            	  2206: *     EA = Dn  - LONG
00:00001CBA 203C12345678    	  2207:             move.l #$12345678,d0      * populate test data
00:00001CC0 068000000000    	  2208:             addi.l #0,d0
00:00001CC6 67FE            	  2209:             beq.s *                       * Check Z Flag  beq/bne
00:00001CC8 6BFE            	  2210:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001CCA 65FE            	  2211:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001CCC 69FE            	  2212:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001CCE 0680F0000000    	  2213:             addi.l #$F0000000,d0
00:00001CD4 67FE            	  2214:             beq.s *                       * Check Z Flag  beq/bne
00:00001CD6 6BFE            	  2215:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001CD8 64FE            	  2216:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001CDA 69FE            	  2217:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001CDC 0680855AA55A    	  2218:             addi.l #$855AA55A,d0
00:00001CE2 67FE            	  2219:             beq.s *                       * Check Z Flag  beq/bne
00:00001CE4 6AFE            	  2220:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001CE6 65FE            	  2221:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001CE8 69FE            	  2222:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001CEA 0680A0000000    	  2223:             addi.l #$A0000000,d0
00:00001CF0 68FE            	  2224:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001CF2 0C80278EFBD2    	  2225:             cmpi.l #$278EFBD2,d0
00:00001CF8 66FE            	  2226:             bne.s *                       * Check Z Flag  beq/bne
                            	  2227: 
                            	  2228: 
                            	  2229: 
                            	  2230: *     EA = x.L  - Byte
00:00001CFA 207C0000F100    	  2231:             move.l #$F100,a0      * populate test data
00:00001D00 20BC12345678    	  2232:             move.l #$12345678,(a0)     * populate test data
00:00001D06 063900000000F103	  2233:             addi.b #0,$F103
00:00001D0E 67FE            	  2234:             beq.s *                       * Check Z Flag  beq/bne
00:00001D10 6BFE            	  2235:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001D12 65FE            	  2236:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001D14 69FE            	  2237:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001D16 063900100000F103	  2238:             addi.b #$10,$F103
00:00001D1E 67FE            	  2239:             beq.s *                       * Check Z Flag  beq/bne
00:00001D20 6AFE            	  2240:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001D22 65FE            	  2241:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001D24 68FE            	  2242:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001D26 063900A50000F103	  2243:             addi.b #$A5,$F103
00:00001D2E 67FE            	  2244:             beq.s *                       * Check Z Flag  beq/bne
00:00001D30 6BFE            	  2245:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001D32 64FE            	  2246:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001D34 68FE            	  2247:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001D36 0C39002D0000F103	  2248:             cmpi.b #$2D,$F103
00:00001D3E 66FE            	  2249:             bne.s *                       * Check Z Flag  beq/bne
                            	  2250: 
                            	  2251: *     EA = x.L- WORD
00:00001D40 207C0000F100    	  2252:             move.l #$F100,a0      * populate test data
00:00001D46 20BC12345678    	  2253:             move.l #$12345678,(a0)     * populate test data
00:00001D4C 067900000000F100	  2254:             addi.w #0,$F100
00:00001D54 67FE            	  2255:             beq.s *                       * Check Z Flag  beq/bne
00:00001D56 6BFE            	  2256:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001D58 65FE            	  2257:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001D5A 69FE            	  2258:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001D5C 067970000000F100	  2259:             addi.w #$7000,$F100
00:00001D64 67FE            	  2260:             beq.s *                       * Check Z Flag  beq/bne
00:00001D66 6AFE            	  2261:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001D68 65FE            	  2262:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001D6A 68FE            	  2263:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001D6C 0679A55A0000F100	  2264:             addi.w #$A55A,$F100
00:00001D74 67FE            	  2265:             beq.s *                       * Check Z Flag  beq/bne
00:00001D76 6BFE            	  2266:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001D78 64FE            	  2267:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001D7A 68FE            	  2268:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001D7C 0C79278E0000F100	  2269:             cmpi.w #$278E,$F100
00:00001D84 66FE            	  2270:             bne.s *                       * Check Z Flag  beq/bne
                            	  2271: 
                            	  2272: *     EA = x.L- LONG
00:00001D86 23FC123456780000	  2273:             move.l #$12345678,$F100  * populate test data
00:00001D8E F100
00:00001D90 06B9000000000000	  2274:             addi.l #0,$F100
00:00001D98 F100
00:00001D9A 67FE            	  2275:             beq.s *                       * Check Z Flag  beq/bne
00:00001D9C 6BFE            	  2276:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001D9E 65FE            	  2277:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001DA0 69FE            	  2278:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001DA2 06B9F00000000000	  2279:             addi.l #$F0000000,$F100
00:00001DAA F100
00:00001DAC 67FE            	  2280:             beq.s *                       * Check Z Flag  beq/bne
00:00001DAE 6BFE            	  2281:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001DB0 64FE            	  2282:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001DB2 69FE            	  2283:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001DB4 06B9855AA55A0000	  2284:             addi.l #$855AA55A,$F100
00:00001DBC F100
00:00001DBE 67FE            	  2285:             beq.s *                       * Check Z Flag  beq/bne
00:00001DC0 6AFE            	  2286:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001DC2 65FE            	  2287:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001DC4 69FE            	  2288:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001DC6 06B9A00000000000	  2289:             addi.l #$A0000000,$F100
00:00001DCE F100
00:00001DD0 68FE            	  2290:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001DD2 0CB9278EFBD20000	  2291:             cmpi.l #$278EFBD2,$F100
00:00001DDA F100
00:00001DDC 66FE            	  2292:             bne.s *                       * Check Z Flag  beq/bne
                            	  2293: 
00:00001DDE 4E75            	  2294:             rts
                            	  2295: 
                            	  2296: 
                            	  2297: *-----------------------------------------------------------
                            	  2298: *-----------------------------------------------------------
                            	  2299: * OPCODE : SUB_I
                            	  2300: *-----------------------------------------------------------
                            	  2301: *-----------------------------------------------------------
                            	  2302: op_SUB_I:
                            	  2303: 
                            	  2304: *     EA = Dn  - Byte
00:00001DE0 203C12345678    	  2305:             move.l #$12345678,d0      * populate test data
00:00001DE6 04000000        	  2306:             subi.b #0,d0
00:00001DEA 67FE            	  2307:             beq.s *                       * Check Z Flag  beq/bne
00:00001DEC 6BFE            	  2308:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001DEE 65FE            	  2309:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001DF0 69FE            	  2310:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001DF2 04000010        	  2311:             subi.b #$10,d0
00:00001DF6 67FE            	  2312:             beq.s *                       * Check Z Flag  beq/bne
00:00001DF8 6BFE            	  2313:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001DFA 65FE            	  2314:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001DFC 69FE            	  2315:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001DFE 040000A5        	  2316:             subi.b #$A5,d0
00:00001E02 67FE            	  2317:             beq.s *                       * Check Z Flag  beq/bne
00:00001E04 6AFE            	  2318:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001E06 64FE            	  2319:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001E08 68FE            	  2320:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001E0A 0C0000C3        	  2321:             cmpi.b #$C3,d0
00:00001E0E 66FE            	  2322:             bne.s *                       * Check Z Flag  beq/bne
                            	  2323: 
                            	  2324: *     EA = Dn  - WORD
00:00001E10 203C12345678    	  2325:             move.l #$12345678,d0      * populate test data
00:00001E16 04400000        	  2326:             subi.w #0,d0
00:00001E1A 67FE            	  2327:             beq.s *                       * Check Z Flag  beq/bne
00:00001E1C 6BFE            	  2328:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001E1E 65FE            	  2329:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001E20 69FE            	  2330:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001E22 04407000        	  2331:             subi.w #$7000,d0
00:00001E26 67FE            	  2332:             beq.s *                       * Check Z Flag  beq/bne
00:00001E28 6AFE            	  2333:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001E2A 64FE            	  2334:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001E2C 69FE            	  2335:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001E2E 0440A55A        	  2336:             subi.w #$A55A,d0
00:00001E32 67FE            	  2337:             beq.s *                       * Check Z Flag  beq/bne
00:00001E34 6BFE            	  2338:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001E36 65FE            	  2339:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001E38 69FE            	  2340:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001E3A 0C40411E        	  2341:             cmpi.w #$411E,d0
00:00001E3E 66FE            	  2342:             bne.s *                       * Check Z Flag  beq/bne
                            	  2343: 
                            	  2344: *     EA = Dn  - LONG
00:00001E40 203C12345678    	  2345:             move.l #$12345678,d0      * populate test data
00:00001E46 048000000000    	  2346:             subi.l #0,d0
00:00001E4C 67FE            	  2347:             beq.s *                       * Check Z Flag  beq/bne
00:00001E4E 6BFE            	  2348:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001E50 65FE            	  2349:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001E52 69FE            	  2350:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001E54 0480F0000000    	  2351:             subi.l #$F0000000,d0
00:00001E5A 67FE            	  2352:             beq.s *                       * Check Z Flag  beq/bne
00:00001E5C 6BFE            	  2353:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001E5E 64FE            	  2354:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001E60 69FE            	  2355:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001E62 0480855AA55A    	  2356:             subi.l #$855AA55A,d0
00:00001E68 67FE            	  2357:             beq.s *                       * Check Z Flag  beq/bne
00:00001E6A 6AFE            	  2358:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001E6C 64FE            	  2359:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001E6E 68FE            	  2360:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001E70 0480A0000000    	  2361:             subi.l #$A0000000,d0
00:00001E76 69FE            	  2362:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001E78 0C80FCD9B11E    	  2363:             cmpi.l #$FCD9B11E,d0
00:00001E7E 66FE            	  2364:             bne.s *                       * Check Z Flag  beq/bne
                            	  2365: 
                            	  2366: 
                            	  2367: 
                            	  2368: *     EA = x.L  - Byte
00:00001E80 207C0000F100    	  2369:             move.l #$F100,a0      * populate test data
00:00001E86 20BC12345678    	  2370:             move.l #$12345678,(a0)     * populate test data
00:00001E8C 043900000000F103	  2371:             subi.b #0,$F103
00:00001E94 67FE            	  2372:             beq.s *                       * Check Z Flag  beq/bne
00:00001E96 6BFE            	  2373:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001E98 65FE            	  2374:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001E9A 69FE            	  2375:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001E9C 043900100000F103	  2376:             subi.b #$10,$F103
00:00001EA4 67FE            	  2377:             beq.s *                       * Check Z Flag  beq/bne
00:00001EA6 6BFE            	  2378:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001EA8 65FE            	  2379:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001EAA 69FE            	  2380:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001EAC 043900A50000F103	  2381:             subi.b #$A5,$F103
00:00001EB4 67FE            	  2382:             beq.s *                       * Check Z Flag  beq/bne
00:00001EB6 6AFE            	  2383:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001EB8 64FE            	  2384:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001EBA 68FE            	  2385:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001EBC 0C3900C30000F103	  2386:             cmpi.b #$C3,$F103
00:00001EC4 66FE            	  2387:             bne.s *                       * Check Z Flag  beq/bne
                            	  2388: 
                            	  2389: *     EA = x.L- WORD
00:00001EC6 207C0000F100    	  2390:             move.l #$F100,a0      * populate test data
00:00001ECC 20BC12345678    	  2391:             move.l #$12345678,(a0)     * populate test data
00:00001ED2 047900000000F100	  2392:             subi.w #0,$F100
00:00001EDA 67FE            	  2393:             beq.s *                       * Check Z Flag  beq/bne
00:00001EDC 6BFE            	  2394:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001EDE 65FE            	  2395:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001EE0 69FE            	  2396:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001EE2 047970000000F100	  2397:             subi.w #$7000,$F100
00:00001EEA 67FE            	  2398:             beq.s *                       * Check Z Flag  beq/bne
00:00001EEC 6AFE            	  2399:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001EEE 64FE            	  2400:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001EF0 69FE            	  2401:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001EF2 0479A55A0000F100	  2402:             subi.w #$A55A,$F100
00:00001EFA 67FE            	  2403:             beq.s *                       * Check Z Flag  beq/bne
00:00001EFC 6AFE            	  2404:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001EFE 64FE            	  2405:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001F00 69FE            	  2406:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001F02 0C79FCDA0000F100	  2407:             cmpi.w #$FCDA,$F100
00:00001F0A 66FE            	  2408:             bne.s *                       * Check Z Flag  beq/bne
                            	  2409: 
                            	  2410: *     EA = x.L- LONG
00:00001F0C 23FC123456780000	  2411:             move.l #$12345678,$F100  * populate test data
00:00001F14 F100
00:00001F16 04B9000000000000	  2412:             subi.l #0,$F100
00:00001F1E F100
00:00001F20 67FE            	  2413:             beq.s *                       * Check Z Flag  beq/bne
00:00001F22 6BFE            	  2414:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001F24 65FE            	  2415:             bcs.s *                       * Check C Flag  bcc/bcs
00:00001F26 69FE            	  2416:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001F28 04B9F00000000000	  2417:             subi.l #$F0000000,$F100
00:00001F30 F100
00:00001F32 67FE            	  2418:             beq.s *                       * Check Z Flag  beq/bne
00:00001F34 6BFE            	  2419:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001F36 64FE            	  2420:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001F38 69FE            	  2421:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001F3A 04B9855AA55A0000	  2422:             subi.l #$855AA55A,$F100
00:00001F42 F100
00:00001F44 67FE            	  2423:             beq.s *                       * Check Z Flag  beq/bne
00:00001F46 6AFE            	  2424:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001F48 64FE            	  2425:             bcc.s *                       * Check C Flag  bcc/bcs
00:00001F4A 68FE            	  2426:             bvc.s *                       * Check V Flag  bvc/bvs
00:00001F4C 04B9A00000000000	  2427:             subi.l #$A0000000,$F100
00:00001F54 F100
00:00001F56 69FE            	  2428:             bvs.s *                       * Check V Flag  bvc/bvs
00:00001F58 0CB9FCD9B11E0000	  2429:             cmpi.l #$FCD9B11E,$F100
00:00001F60 F100
00:00001F62 66FE            	  2430:             bne.s *                       * Check Z Flag  beq/bne
                            	  2431: 
00:00001F64 4E75            	  2432:             rts
                            	  2433: 
                            	  2434: 
                            	  2435: 
                            	  2436: *-----------------------------------------------------------
                            	  2437: *-----------------------------------------------------------
                            	  2438: * OPCODE : MOVE
                            	  2439: *-----------------------------------------------------------
                            	  2440: *-----------------------------------------------------------
                            	  2441: op_MOVE:
00:00001F66 203C11223344    	  2442:             move.l #$11223344,d0
00:00001F6C 223C55667788    	  2443:             move.l #$55667788,d1
00:00001F72 243C8899AABB    	  2444:             move.l #$8899aabb,d2
00:00001F78 263CCCDDEEFF    	  2445:             move.l #$ccddeeff,d3
00:00001F7E 7800            	  2446:             moveq  #$00000000,d4
00:00001F80 7A00            	  2447:             moveq  #$00000000,d5
00:00001F82 7C00            	  2448:             moveq  #$00000000,d6
00:00001F84 7E00            	  2449:             moveq  #$00000000,d7
00:00001F86 207C44332211    	  2450:             move.l #$44332211,a0
00:00001F8C 227C88776655    	  2451:             move.l #$88776655,a1
00:00001F92 247CBBAA9988    	  2452:             move.l #$bbaa9988,a2
00:00001F98 267CFFEEDDCC    	  2453:             move.l #$ffeeddcc,a3
                            	  2454: 
00:00001F9E 1800            	  2455:             move.b d0,d4              * BYTE - DATA REGISTER
00:00001FA0 67FE            	  2456:             beq.s *                       * Check Z Flag  beq/bne
00:00001FA2 6BFE            	  2457:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001FA4 0C8400000044    	  2458:             cmpi.l #$00000044,d4
00:00001FAA 66FE            	  2459:             bne.s *                       * Check Z Flag  beq/bne
                            	  2460: 
00:00001FAC 3A01            	  2461:             move.w d1,d5              * WORD - DATA REGISTER
00:00001FAE 67FE            	  2462:             beq.s *                       * Check Z Flag  beq/bne
00:00001FB0 6BFE            	  2463:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001FB2 0C8500007788    	  2464:             cmpi.l #$00007788,d5
00:00001FB8 66FE            	  2465:             bne.s *                       * Check Z Flag  beq/bne
                            	  2466: 
00:00001FBA 2C02            	  2467:             move.l d2,d6              * LONG - DATA REGISTER
00:00001FBC 67FE            	  2468:             beq.s *                       * Check Z Flag  beq/bne
00:00001FBE 6AFE            	  2469:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001FC0 0C868899AABB    	  2470:             cmpi.l #$8899aabb,d6
00:00001FC6 66FE            	  2471:             bne.s *                       * Check Z Flag  beq/bne
                            	  2472: 
00:00001FC8 3A09            	  2473:             move.w a1,d5              * WORD - ADDRESS REGISTER
00:00001FCA 67FE            	  2474:             beq.s *                       * Check Z Flag  beq/bne
00:00001FCC 6BFE            	  2475:             bmi.s *                       * Check N Flag  bmi/bpl
00:00001FCE 0C8500006655    	  2476:             cmpi.l #$00006655,d5
00:00001FD4 66FE            	  2477:             bne.s *                       * Check Z Flag  beq/bne
                            	  2478: 
00:00001FD6 2C0A            	  2479:             move.l a2,d6              * LONG - ADDRESS REGISTER
00:00001FD8 67FE            	  2480:             beq.s *                       * Check Z Flag  beq/bne
00:00001FDA 6AFE            	  2481:             bpl.s *                       * Check N Flag  bmi/bpl
00:00001FDC 0C86BBAA9988    	  2482:             cmpi.l #$bbaa9988,d6
00:00001FE2 66FE            	  2483:             bne.s *                       * Check Z Flag  beq/bne
                            	  2484: 
                            	  2485: 
00:00001FE4 3842            	  2486:             movea.w d2,a4             * WORD - ADDRESS REGISTER as SOURCE ## MOVEA
00:00001FE6 B9C2            	  2487:             cmpa.l d2,a4
00:00001FE8 67FE            	  2488:             beq.s *                       * Check Z Flag  beq/bne ## comopare fails because A4 was sign extended
                            	  2489: 
00:00001FEA 2A41            	  2490:             movea.l d1,a5             * LONG - ADDRESS REGISTER as SOURCE ## MOVEA
00:00001FEC BBC1            	  2491:             cmpa.l d1,a5
00:00001FEE 66FE            	  2492:             bne.s *                       * Check Z Flag  beq/bne
                            	  2493: 
                            	  2494: 
                            	  2495: 
                            	  2496: *   Too mamy EA combinations to test,so we focus on a few of the more complicted EA's
                            	  2497: 
00:00001FF0 203C11223344    	  2498:             move.l #$11223344,d0
00:00001FF6 223C00010100    	  2499:             move.l #$00010100,d1
00:00001FFC 243C8899AABB    	  2500:             move.l #$8899aabb,d2
00:00002002 7601            	  2501:             moveq  #$00000001,d3
00:00002004 7800            	  2502:             moveq  #$00000000,d4
00:00002006 7A00            	  2503:             moveq  #$00000000,d5
00:00002008 7C00            	  2504:             moveq  #$00000000,d6
00:0000200A 7E00            	  2505:             moveq  #$00000000,d7
00:0000200C 91C8            	  2506:             move.l #$00000000,a0
00:0000200E 227C00010100    	  2507:             move.l #$00010100,a1
                            	  2508: 
                            	  2509: *     x(An,AL) --> x.L
00:00002014 11BC005A9804    	  2510:             move.b #$5A,4(a0,a1.l)    * BYTE
00:0000201A 47F09804        	  2511:             lea 4(a0,a1.l),a3
00:0000201E 13F0980400010105	  2512:             move.b 4(a0,a1.l),$00010105
00:00002026 67FE            	  2513:             beq.s *                       * Check Z Flag  beq/bne
00:00002028 6BFE            	  2514:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000202A 0C30005A9805    	  2515:             cmpi.b #$5A,5(a0,a1.l)
00:00002030 66FE            	  2516:             bne.s *                       * Check Z Flag  beq/bne
                            	  2517: 
                            	  2518: *     x.L --> n(An,Dw)
00:00002032 11B9000101051007	  2519: MOVE2:      move.b  $00010105,7(a0,d1.w)    * BYTE
00:0000203A 67FE            	  2520:             beq.s *                       * Check Z Flag  beq/bne
00:0000203C 6BFE            	  2521:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000203E 0C30005A1007    	  2522:             cmpi.b #$5A,7(a0,d1.w)
00:00002044 66FE            	  2523:             bne.s *                       * Check Z Flag  beq/bne
                            	  2524: 
                            	  2525: *     x(PC,Ds) --> x.w
00:00002046 11FB30660100    	  2526:             move.b  MOVE1(pc,d3.w),$0100 * BYTE
00:0000204C 67FE            	  2527:             beq.s *                       * Check Z Flag  beq/bne
00:0000204E 6AFE            	  2528:             bpl.s *                       * Check N Flag  bmi/bpl
00:00002050 0C3900B900002033	  2529:             cmpi.b #$B9,1+MOVE2
00:00002058 66FE            	  2530:             bne.s *                       * Check Z Flag  beq/bne
                            	  2531: 
                            	  2532: *     #x -->    n(An,AL)
00:0000205A 11BC00781007    	  2533:             move.b  #$78,7(a0,d1.w)    * BYTE
00:00002060 67FE            	  2534:             beq.s *                       * Check Z Flag  beq/bne
00:00002062 6BFE            	  2535:             bmi.s *                       * Check N Flag  bmi/bpl
00:00002064 0C3000781007    	  2536:             cmpi.b #$78,7(a0,d1.w)
00:0000206A 66FE            	  2537:             bne.s *                       * Check Z Flag  beq/bne
                            	  2538: 
00:0000206C 203C11223344    	  2539:             move.l #$11223344,d0
00:00002072 223C00010100    	  2540:             move.l #$00010100,d1
00:00002078 243C8899AABB    	  2541:             move.l #$8899aabb,d2
00:0000207E 7602            	  2542:             moveq  #$00000002,d3
00:00002080 7800            	  2543:             moveq  #$00000000,d4
00:00002082 7A00            	  2544:             moveq  #$00000000,d5
00:00002084 7C00            	  2545:             moveq  #$00000000,d6
00:00002086 7E00            	  2546:             moveq  #$00000000,d7
00:00002088 91C8            	  2547:             move.l #$00000000,a0
00:0000208A 227C00010100    	  2548:             move.l #$00010100,a1
                            	  2549: 
                            	  2550: *     x(An,AL) --> x.L
00:00002090 31BC5A5A9804    	  2551:             move.w #$5A5A,4(a0,a1.l)    * WORD
00:00002096 49F09804        	  2552:             lea 4(a0,a1.l),a4
00:0000209A 33F0980400010104	  2553:             move.w 4(a0,a1.l),$00010104
00:000020A2 67FE            	  2554:             beq.s *                       * Check Z Flag  beq/bne
00:000020A4 6BFE            	  2555:             bmi.s *                       * Check N Flag  bmi/bpl
00:000020A6 0C705A5A9804    	  2556:             cmpi.w #$5A5A,4(a0,a1.l)
00:000020AC 66FE            	  2557:             bne.s *                       * Check Z Flag  beq/bne
                            	  2558: 
                            	  2559: *     x.L --> n(An,Dw)
00:000020AE 31B9000101041006	  2560: MOVE1:      move.w  $00010104,6(a0,d1.w)    * WORD
00:000020B6 67FE            	  2561:             beq.s *                       * Check Z Flag  beq/bne
00:000020B8 6BFE            	  2562:             bmi.s *                       * Check N Flag  bmi/bpl
00:000020BA 0C705A5A1006    	  2563:             cmpi.w #$5A5A,6(a0,d1.w)
00:000020C0 66FE            	  2564:             bne.s *                       * Check Z Flag  beq/bne
                            	  2565: 
                            	  2566: *     x(PC,Ds) --> x.w
00:000020C2 31FB30EA0100    	  2567:             move.w  MOVE1(pc,d3),$0100 * WORD
00:000020C8 67FE            	  2568:             beq.s *                       * Check Z Flag  beq/bne
00:000020CA 6BFE            	  2569:             bmi.s *                       * Check N Flag  bmi/bpl
00:000020CC 0C7967FE000020B6	  2570:             cmpi.w #$67FE,8+MOVE1
00:000020D4 66FE            	  2571:             bne.s *                       * Check Z Flag  beq/bne
                            	  2572: 
                            	  2573: *     #x -->    n(An,AL)
00:000020D6 31BC78781006    	  2574:             move.w  #$7878,6(a0,d1.w)    * WORD
00:000020DC 67FE            	  2575:             beq.s *                       * Check Z Flag  beq/bne
00:000020DE 6BFE            	  2576:             bmi.s *                       * Check N Flag  bmi/bpl
00:000020E0 0C7078781006    	  2577:             cmpi.w #$7878,6(a0,d1.w)
00:000020E6 66FE            	  2578:             bne.s *                       * Check Z Flag  beq/bne
                            	  2579: 
                            	  2580: * ---
                            	  2581: 
00:000020E8 203C11223344    	  2582:             move.l #$11223344,d0
00:000020EE 223C00010100    	  2583:             move.l #$00010100,d1
00:000020F4 243C8899AABB    	  2584:             move.l #$8899aabb,d2
00:000020FA 7602            	  2585:             moveq  #$00000002,d3
00:000020FC 7800            	  2586:             moveq  #$00000000,d4
00:000020FE 7A00            	  2587:             moveq  #$00000000,d5
00:00002100 7C00            	  2588:             moveq  #$00000000,d6
00:00002102 7E00            	  2589:             moveq  #$00000000,d7
00:00002104 91C8            	  2590:             move.l #$00000000,a0
00:00002106 227C00010100    	  2591:             move.l #$00010100,a1
                            	  2592: 
                            	  2593: *     x(An,AL) --> x.L
00:0000210C 21BC5A5A12349804	  2594:             move.l #$5A5A1234,4(a0,a1.l)    * LONG
00:00002114 49F09804        	  2595:             lea 4(a0,a1.l),a4
00:00002118 23F0980400010104	  2596:             move.l 4(a0,a1.l),$00010104
00:00002120 67FE            	  2597:             beq.s *                       * Check Z Flag  beq/bne
00:00002122 6BFE            	  2598:             bmi.s *                       * Check N Flag  bmi/bpl
00:00002124 0CB05A5A12349804	  2599:             cmpi.l #$5A5A1234,4(a0,a1.l)
00:0000212C 66FE            	  2600:             bne.s *                       * Check Z Flag  beq/bne
                            	  2601: 
                            	  2602: *     x.L --> n(An,Dw)
00:0000212E 21B9000101041006	  2603: MOVE3:      move.l  $00010104,6(a0,d1.w)    * LONG
00:00002136 67FE            	  2604:             beq.s *                       * Check Z Flag  beq/bne
00:00002138 6BFE            	  2605:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000213A 0CB05A5A12341006	  2606:             cmpi.l #$5A5A1234,6(a0,d1.w)
00:00002142 66FE            	  2607:             bne.s *                       * Check Z Flag  beq/bne
                            	  2608: 
                            	  2609: *     x(PC,Ds) --> x.w
00:00002144 21FB30E80100    	  2610:             move.l  MOVE3(pc,d3),$0100 * LONG
00:0000214A 67FE            	  2611:             beq.s *                       * Check Z Flag  beq/bne
00:0000214C 6BFE            	  2612:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000214E 0CB967FE6BFE0000	  2613:             cmpi.l #$67FE6BFE,8+MOVE3
00:00002156 2136
00:00002158 66FE            	  2614:             bne.s *                       * Check Z Flag  beq/bne
                            	  2615: 
                            	  2616: *     #x -->    n(An,AL)
00:0000215A 21BC787823231006	  2617:             move.l  #$78782323,6(a0,d1.w)    * LONG
00:00002162 67FE            	  2618:             beq.s *                       * Check Z Flag  beq/bne
00:00002164 6BFE            	  2619:             bmi.s *                       * Check N Flag  bmi/bpl
00:00002166 0CB0787823231006	  2620:             cmpi.l #$78782323,6(a0,d1.w)
00:0000216E 66FE            	  2621:             bne.s *                       * Check Z Flag  beq/bne
                            	  2622: 
                            	  2623: 
00:00002170 4E75            	  2624:          rts
                            	  2625: 
                            	  2626: 
                            	  2627: *-----------------------------------------------------------
                            	  2628: *-----------------------------------------------------------
                            	  2629: * OPCODE : MOVE_xxx_FLAGS
                            	  2630: *-----------------------------------------------------------
                            	  2631: *-----------------------------------------------------------
                            	  2632: op_MOVE_xxx_FLAGS:
                            	  2633: 
                            	  2634: *     Move_To_SR
                            	  2635: 
                            	  2636: *     Dn
                            	  2637: 
00:00002172 303C2FFF        	  2638:             move.w #$2FFF,d0
00:00002176 46C0            	  2639:             move.w d0,SR
00:00002178 6AFE            	  2640:             bpl.s *           * branch if Z clear
00:0000217A 66FE            	  2641:             bne.s *           * branch if N clear
00:0000217C 68FE            	  2642:             bvc.s *           * branch if V clear
00:0000217E 64FE            	  2643:             bcc.s *           * branch if C clear
00:00002180 303C2F00        	  2644:             move.w #$2F00,d0
00:00002184 44C0            	  2645:             move d0,CCR
00:00002186 67FE            	  2646:             beq.s *           * branch if Z set
00:00002188 6BFE            	  2647:             bmi.s *           * branch if N set
00:0000218A 69FE            	  2648:             bvs.s *           * branch if V set
00:0000218C 65FE            	  2649:             bcs.s *           * branch if C set
                            	  2650: 
00:0000218E 303C2000        	  2651:             move.w #$2000,d0
00:00002192 46C0            	  2652:             move.w d0,SR
00:00002194 67FE            	  2653:             beq.s *           * branch if Z set
00:00002196 6BFE            	  2654:             bmi.s *           * branch if N set
00:00002198 69FE            	  2655:             bvs.s *           * branch if V set
00:0000219A 65FE            	  2656:             bcs.s *           * branch if C set
                            	  2657: 
                            	  2658: *     (An)
00:0000219C 307C0100        	  2659:             move.l #$00000100,a0
00:000021A0 30BC2FFF        	  2660:             move.w #$2FFF,(a0)
00:000021A4 46D0            	  2661:             move.w (a0),SR
00:000021A6 6AFE            	  2662:             bpl.s *           * branch if Z clear
00:000021A8 66FE            	  2663:             bne.s *           * branch if N clear
00:000021AA 68FE            	  2664:             bvc.s *           * branch if V clear
00:000021AC 64FE            	  2665:             bcc.s *           * branch if C clear
                            	  2666: 
00:000021AE 30BC2000        	  2667:             move.w #$2000,(a0)
00:000021B2 46D0            	  2668:             move.w (a0),SR
00:000021B4 67FE            	  2669:             beq.s *           * branch if Z set
00:000021B6 6BFE            	  2670:             bmi.s *           * branch if N set
00:000021B8 69FE            	  2671:             bvs.s *           * branch if V set
00:000021BA 65FE            	  2672:             bcs.s *           * branch if C set
                            	  2673: 
                            	  2674: *     (An)+
00:000021BC 307C0100        	  2675:             move.l #$00000100,a0
00:000021C0 30BC2FFF        	  2676:             move.w #$2FFF,(a0)
00:000021C4 46D8            	  2677:             move.w (a0)+,SR
00:000021C6 6AFE            	  2678:             bpl.s *           * branch if Z clear
00:000021C8 66FE            	  2679:             bne.s *           * branch if N clear
00:000021CA 68FE            	  2680:             bvc.s *           * branch if V clear
00:000021CC 64FE            	  2681:             bcc.s *           * branch if C clear
                            	  2682: 
00:000021CE 30BC2000        	  2683:             move.w #$2000,(a0)
00:000021D2 46D8            	  2684:             move.w (a0)+,SR
00:000021D4 67FE            	  2685:             beq.s *           * branch if Z set
00:000021D6 6BFE            	  2686:             bmi.s *           * branch if N set
00:000021D8 69FE            	  2687:             bvs.s *           * branch if V set
00:000021DA 65FE            	  2688:             bcs.s *           * branch if C set
                            	  2689: 
                            	  2690: *     -(An)
00:000021DC 307C0102        	  2691:             move.l #$00000102,a0
00:000021E0 30BC2FFF        	  2692:             move.w #$2FFF,(a0)
00:000021E4 46D8            	  2693:             move.w (a0)+,SR
00:000021E6 6AFE            	  2694:             bpl.s *           * branch if Z clear
00:000021E8 66FE            	  2695:             bne.s *           * branch if N clear
00:000021EA 68FE            	  2696:             bvc.s *           * branch if V clear
00:000021EC 64FE            	  2697:             bcc.s *           * branch if C clear
                            	  2698: 
00:000021EE 30BC2000        	  2699:             move.w #$2000,(a0)
00:000021F2 46D8            	  2700:             move.w (a0)+,SR
00:000021F4 67FE            	  2701:             beq.s *           * branch if Z set
00:000021F6 6BFE            	  2702:             bmi.s *           * branch if N set
00:000021F8 69FE            	  2703:             bvs.s *           * branch if V set
00:000021FA 65FE            	  2704:             bcs.s *           * branch if C set
                            	  2705: 
                            	  2706: *     n(An)
00:000021FC 307C0102        	  2707:             move.l #$00000102,a0
00:00002200 317C2FFF0002    	  2708:             move.w #$2FFF,2(a0)
00:00002206 46E80002        	  2709:             move.w 2(a0),SR
00:0000220A 6AFE            	  2710:             bpl.s *           * branch if Z clear
00:0000220C 66FE            	  2711:             bne.s *           * branch if N clear
00:0000220E 68FE            	  2712:             bvc.s *           * branch if V clear
00:00002210 64FE            	  2713:             bcc.s *           * branch if C clear
                            	  2714: 
00:00002212 317C20000002    	  2715:             move.w #$2000,2(a0)
00:00002218 46E80002        	  2716:             move.w 2(a0),SR
00:0000221C 67FE            	  2717:             beq.s *           * branch if Z set
00:0000221E 6BFE            	  2718:             bmi.s *           * branch if N set
00:00002220 69FE            	  2719:             bvs.s *           * branch if V set
00:00002222 65FE            	  2720:             bcs.s *           * branch if C set
                            	  2721: 
                            	  2722: *     n(An,Rn.l)
00:00002224 307C0100        	  2723:             move.l #$00000100,a0
00:00002228 7002            	  2724:             moveq  #$00000002,d0
00:0000222A 31BC2FFF0802    	  2725:             move.w #$2FFF,2(a0,d0.l)
00:00002230 46F00802        	  2726:             move.w 2(a0,d0.l),SR
00:00002234 6AFE            	  2727:             bpl.s *           * branch if Z clear
00:00002236 66FE            	  2728:             bne.s *           * branch if N clear
00:00002238 68FE            	  2729:             bvc.s *           * branch if V clear
00:0000223A 64FE            	  2730:             bcc.s *           * branch if C clear
                            	  2731: 
00:0000223C 31BC20000802    	  2732:             move.w #$2000,2(a0,d0.l)
00:00002242 46F00802        	  2733:             move.w 2(a0,d0.l),SR
00:00002246 67FE            	  2734:             beq.s *           * branch if Z set
00:00002248 6BFE            	  2735:             bmi.s *           * branch if N set
00:0000224A 69FE            	  2736:             bvs.s *           * branch if V set
00:0000224C 65FE            	  2737:             bcs.s *           * branch if C set
                            	  2738: 
                            	  2739: *     x.W
00:0000224E 31FC2FFF0100    	  2740:             move.w #$2FFF,$0100
00:00002254 46F80100        	  2741:             move.w $0100,SR
00:00002258 6AFE            	  2742:             bpl.s *           * branch if Z clear
00:0000225A 66FE            	  2743:             bne.s *           * branch if N clear
00:0000225C 68FE            	  2744:             bvc.s *           * branch if V clear
00:0000225E 64FE            	  2745:             bcc.s *           * branch if C clear
                            	  2746: 
00:00002260 31FC20000100    	  2747:             move.w #$2000,$0100
00:00002266 46F80100        	  2748:             move.w $0100,SR
00:0000226A 67FE            	  2749:             beq.s *           * branch if Z set
00:0000226C 6BFE            	  2750:             bmi.s *           * branch if N set
00:0000226E 69FE            	  2751:             bvs.s *           * branch if V set
00:00002270 65FE            	  2752:             bcs.s *           * branch if C set
                            	  2753: 
                            	  2754: *     x.L
00:00002272 33FC2FFF00010100	  2755:             move.w #$2FFF,$00010100
00:0000227A 46F900010100    	  2756:             move.w $00010100,SR
00:00002280 6AFE            	  2757:             bpl.s *           * branch if Z clear
00:00002282 66FE            	  2758:             bne.s *           * branch if N clear
00:00002284 68FE            	  2759:             bvc.s *           * branch if V clear
00:00002286 64FE            	  2760:             bcc.s *           * branch if C clear
                            	  2761: 
00:00002288 33FC200000010100	  2762: MOVE4:      move.w #$2000,$00010100
00:00002290 46F900010100    	  2763:             move.w $00010100,SR
00:00002296 67FE            	  2764:             beq.s *           * branch if Z set
00:00002298 6BFE            	  2765:             bmi.s *           * branch if N set
00:0000229A 69FE            	  2766:             bvs.s *           * branch if V set
00:0000229C 65FE            	  2767:             bcs.s *           * branch if C set
                            	  2768: 
                            	  2769: *     x(PC)
00:0000229E 46FAFFEA        	  2770:             move.w MOVE4+2(pc),SR
00:000022A2 67FE            	  2771:             beq.s *           * branch if Z set
00:000022A4 6BFE            	  2772:             bmi.s *           * branch if N set
00:000022A6 69FE            	  2773:             bvs.s *           * branch if V set
00:000022A8 65FE            	  2774:             bcs.s *           * branch if C set
                            	  2775: 
                            	  2776: *     x(PC,d0.l)
00:000022AA 7000            	  2777:             moveq  #$00000000,d0
00:000022AC 46FB08DC        	  2778:             move.w MOVE4+2(pc,d0.l),SR
00:000022B0 67FE            	  2779:             beq.s *           * branch if Z set
00:000022B2 6BFE            	  2780:             bmi.s *           * branch if N set
00:000022B4 69FE            	  2781:             bvs.s *           * branch if V set
00:000022B6 65FE            	  2782:             bcs.s *           * branch if C set
00:000022B8 44FB08D0        	  2783:             move MOVE4+2(pc,d0.l),CCR
00:000022BC 67FE            	  2784:             beq.s *           * branch if Z set
00:000022BE 6BFE            	  2785:             bmi.s *           * branch if N set
00:000022C0 69FE            	  2786:             bvs.s *           * branch if V set
00:000022C2 65FE            	  2787:             bcs.s *           * branch if C set
                            	  2788: 
                            	  2789: *     #x
00:000022C4 46FC2FFF        	  2790:             move.w #$2FFF,SR
00:000022C8 66FE            	  2791:             bne.s *           * branch if Z clear
00:000022CA 6AFE            	  2792:             bpl.s *           * branch if N clear
00:000022CC 68FE            	  2793:             bvc.s *           * branch if V clear
00:000022CE 64FE            	  2794:             bcc.s *           * branch if C clear
                            	  2795: 
                            	  2796: 
                            	  2797: 
                            	  2798: *  MOVE_From_SR
                            	  2799: 
                            	  2800: 
                            	  2801: 
                            	  2802: *     Dn
00:000022D0 46FC275A        	  2803:             move.w #$275A,SR          * Initial value
00:000022D4 40C0            	  2804:             move.w SR,d0
00:000022D6 0C40271A        	  2805:             cmpi.w #$271A,d0
                            	  2806: * The following fails because sr bits are implemented and non-zero so later code works.           
                            	  2807: *            bne.s *                   * branch if Z set
                            	  2808: 
                            	  2809: *     (An)
00:000022DA 307C0100        	  2810:             move.l #$00000100,a0
00:000022DE 46FC275A        	  2811:             move.w #$275A,SR          * Initial value
00:000022E2 40D0            	  2812:             move.w SR,(a0)
00:000022E4 0C50275A        	  2813:             cmpi.w #$275A,(a0)
00:000022E8 66FE            	  2814:             bne.s *                   * branch if Z set
                            	  2815: 
                            	  2816: *     (An)+
00:000022EA 307C0100        	  2817:             move.l #$00000100,a0
00:000022EE 46FC257A        	  2818:             move.w #$257A,SR          * Initial value
00:000022F2 40D8            	  2819:             move.w SR,(a0)+
00:000022F4 307C0100        	  2820:             move.l #$00000100,a0
00:000022F8 0C58257A        	  2821:             cmpi.w #$257A,(a0)+
00:000022FC 66FE            	  2822:             bne.s *                   * branch if Z set
                            	  2823: 
                            	  2824: *     -(An)
00:000022FE 307C0102        	  2825:             move.l #$00000102,a0
00:00002302 46FC2766        	  2826:             move.w #$2766,SR          * Initial value
00:00002306 40E0            	  2827:             move.w SR,-(a0)
00:00002308 307C0100        	  2828:             move.l #$00000100,a0
00:0000230C 0C502766        	  2829:             cmpi.w #$2766,(a0)
00:00002310 66FE            	  2830:             bne.s *                   * branch if Z set
                            	  2831: 
                            	  2832: *     x(An)
00:00002312 307C0102        	  2833:             move.l #$00000102,a0
00:00002316 46FC2733        	  2834:             move.w #$2733,SR          * Initial value
00:0000231A 40E80004        	  2835:             move.w SR,4(a0)
00:0000231E 0C6827330004    	  2836:             cmpi.w #$2733,4(a0)
00:00002324 66FE            	  2837:             bne.s *                   * branch if Z set
                            	  2838: 
                            	  2839: *     x(An,rn)
00:00002326 307C0102        	  2840:             move.l #$00000102,a0
00:0000232A 7004            	  2841:             moveq  #$00000004,d0
00:0000232C 46FC275A        	  2842:             move.w #$275a,SR          * Initial value
00:00002330 40F00804        	  2843:             move.w SR,4(a0,d0.l)
00:00002334 0C70275A0804    	  2844:             cmpi.w #$275a,4(a0,d0.l)
00:0000233A 66FE            	  2845:             bne.s *                   * branch if Z set
                            	  2846: 
                            	  2847: *     x.W
00:0000233C 46FC2777        	  2848:             move.w #$2777,SR          * Initial value
00:00002340 40F80102        	  2849:             move.w SR,$0102
00:00002344 0C7827770102    	  2850:             cmpi.w #$2777,$0102
00:0000234A 66FE            	  2851:             bne.s *                   * branch if Z set
                            	  2852: 
                            	  2853: *     x.L
00:0000234C 46FC2777        	  2854:             move.w #$2777,SR          * Initial value
00:00002350 40F900010102    	  2855:             move.w SR,$10102
00:00002356 0C79277700010102	  2856:             cmpi.w #$2777,$10102
00:0000235E 66FE            	  2857:             bne.s *                   * branch if Z set
                            	  2858: 
                            	  2859: 
                            	  2860: 
00:00002360 46FC2700        	  2861:             move.w #$2700,SR          * Put flags back to initial value
                            	  2862: 
00:00002364 4E75            	  2863:             rts
                            	  2864: 
                            	  2865: 
                            	  2866: *-----------------------------------------------------------
                            	  2867: *-----------------------------------------------------------
                            	  2868: * OPCODE : EXT
                            	  2869: *-----------------------------------------------------------
                            	  2870: *-----------------------------------------------------------
                            	  2871: op_EXT:
                            	  2872: 
00:00002366 707F            	  2873:             move.l #$0000007F,d0
00:00002368 223C00008FFF    	  2874:             move.l #$00008FFF,d1
00:0000236E 7400            	  2875:             moveq  #$00000000,d2
                            	  2876: 
00:00002370 4880            	  2877:             ext.w d0
00:00002372 6BFE            	  2878:             bmi.s *                   * Check N Flag  bmi/bpl
00:00002374 67FE            	  2879:             beq.s *                   * Check Z Flag  beq/bne
00:00002376 0C800000007F    	  2880:             cmpi.l #$0000007F,d0
00:0000237C 66FE            	  2881:             bne.s *                   * branch if Z set
                            	  2882: 
00:0000237E 48C1            	  2883:             ext.l d1
00:00002380 6AFE            	  2884:             bpl.s *                   * Check N Flag  bmi/bpl
00:00002382 67FE            	  2885:             beq.s *                   * Check Z Flag  beq/bne
00:00002384 0C81FFFF8FFF    	  2886:             cmpi.l #$FFFF8FFF,d1
00:0000238A 66FE            	  2887:             bne.s *                   * branch if Z set
                            	  2888: 
00:0000238C 48C2            	  2889:             ext.l d2
00:0000238E 66FE            	  2890:             bne.s *                   * Check Z Flag  beq/bne
                            	  2891: 
                            	  2892: 
                            	  2893: 
00:00002390 4E75            	  2894:             rts
                            	  2895: 
                            	  2896: 
                            	  2897: *-----------------------------------------------------------
                            	  2898: *-----------------------------------------------------------
                            	  2899: * OPCODE : SWAP
                            	  2900: *-----------------------------------------------------------
                            	  2901: *-----------------------------------------------------------
                            	  2902: op_SWAP:
                            	  2903: 
00:00002392 203C12345678    	  2904:             move.l #$12345678,d0
                            	  2905: 
00:00002398 4840            	  2906:             swap d0
00:0000239A 6BFE            	  2907:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000239C 67FE            	  2908:             beq.s *                   * Check Z Flag  beq/bne
00:0000239E 0C8056781234    	  2909:             cmpi.l #$56781234,d0
00:000023A4 66FE            	  2910:             bne.s *                   * branch if Z set
                            	  2911: 
                            	  2912: 
                            	  2913: 
00:000023A6 4E75            	  2914:             rts
                            	  2915: 
                            	  2916: 
                            	  2917: *-----------------------------------------------------------
                            	  2918: *-----------------------------------------------------------
                            	  2919: * OPCODE : LEA_PEA
                            	  2920: *-----------------------------------------------------------
                            	  2921: *-----------------------------------------------------------
                            	  2922: op_LEAPEA:
                            	  2923: 
00:000023A8 207C00345678    	  2924:             move.l #$00345678,a0
00:000023AE 7800            	  2925:             moveq  #$00000000,d4
                            	  2926: 
                            	  2927: *     (An)
00:000023B0 4DD0            	  2928:             lea (a0),a6
00:000023B2 200E            	  2929:             move.l a6,d0
00:000023B4 0C8000345678    	  2930:             cmpi.l #$00345678,d0
00:000023BA 66FE            	  2931:             bne.s *                   * branch if Z set
00:000023BC 4850            	  2932:             pea (a0)
00:000023BE 0C9700345678    	  2933:             cmpi.l #$00345678,(a7)
00:000023C4 66FE            	  2934:             bne.s *                   * branch if Z set
                            	  2935:             * This was without a specifier which the assembler defaulted to .w
00:000023C6 588F            	  2936:             addq.l #4,a7            * Restore Stack Pointer
                            	  2937: 
                            	  2938: *     x(An)
00:000023C8 4DE80004        	  2939:             lea 4(a0),a6
00:000023CC 200E            	  2940:             move.l a6,d0
00:000023CE 0C800034567C    	  2941:             cmpi.l #$0034567C,d0
00:000023D4 66FE            	  2942:             bne.s *                   * branch if Z set
00:000023D6 48680004        	  2943:             pea 4(a0)
00:000023DA 0C970034567C    	  2944:             cmpi.l #$0034567C,(a7)
00:000023E0 66FE            	  2945:             bne.s *                   * branch if Z set
                            	  2946:             * This was without a specifier which the assembler defaulted to .w
00:000023E2 588F            	  2947:             addq.l #4,a7            * Restore Stack Pointer
                            	  2948: 
                            	  2949: *     x(An,Dn.l)
00:000023E4 4DF04004        	  2950:             lea 4(a0,d4),a6
00:000023E8 200E            	  2951:             move.l a6,d0
00:000023EA 0C800034567C    	  2952:             cmpi.l #$0034567C,d0
00:000023F0 66FE            	  2953:             bne.s *                   * branch if Z set
00:000023F2 48704804        	  2954:             pea 4(a0,d4.l)
00:000023F6 0C970034567C    	  2955:             cmpi.l #$0034567C,(a7)
00:000023FC 66FE            	  2956:             bne.s *                   * branch if Z set
                            	  2957:             * This was without a specifier which the assembler defaulted to .w
00:000023FE 588F            	  2958:             addq.l #4,a7            * Restore Stack Pointer
                            	  2959: 
                            	  2960: *     x.W
00:00002400 4DF81234        	  2961:             lea $1234,a6
00:00002404 200E            	  2962:             move.l a6,d0
00:00002406 0C401234        	  2963:             cmpi.w #$1234,d0
00:0000240A 66FE            	  2964:             bne.s *                   * branch if Z set
00:0000240C 48781234        	  2965:             pea $1234
00:00002410 0C9700001234    	  2966:             cmpi.l #$00001234,(a7)
00:00002416 66FE            	  2967:             bne.s *                   * branch if Z set
                            	  2968:             * This was without a specifier which the assembler defaulted to .w
00:00002418 588F            	  2969:             addq.l #4,a7            * Restore Stack Pointer
                            	  2970: 
                            	  2971: *     x.L
00:0000241A 4DF900345678    	  2972:             lea $00345678,a6
00:00002420 200E            	  2973:             move.l a6,d0
00:00002422 B08E            	  2974:             cmp.l a6,d0
00:00002424 66FE            	  2975:             bne.s *                   * branch if Z set
00:00002426 487900345678    	  2976:             pea $00345678
00:0000242C 0C9700345678    	  2977:             cmpi.l #$00345678,(a7)
00:00002432 66FE            	  2978:             bne.s *                   * branch if Z set
                            	  2979:             * This was without a specifier which the assembler defaulted to .w
00:00002434 588F            	  2980:             addq.l #4,a7            * Restore Stack Pointer
                            	  2981: 
                            	  2982: *     x(PC)
00:00002436 4DFA0008        	  2983:             lea LEA1(pc),a6
00:0000243A 200E            	  2984:             move.l a6,d0
00:0000243C B08E            	  2985:             cmp.l a6,d0
00:0000243E 66FE            	  2986:             bne.s *                   * branch if Z set
00:00002440 487AFFFE        	  2987: LEA1:       pea LEA1(pc)
00:00002444 0C970000241E    	  2988:             cmpi.l #$0000241E,(a7)
00:0000244A 67FE            	  2989:             beq.s *                   * branch if Z clear
                            	  2990:             * This was without a specifier which the assembler defaulted to .w
00:0000244C 588F            	  2991:             addq.l #4,a7              * Restore Stack Pointer
                            	  2992: 
                            	  2993: 
                            	  2994: 
                            	  2995: 
00:0000244E 46FC2700        	  2996:             move.w #$2700,sr          * Put flags back to initial value
                            	  2997: 
00:00002452 4E75            	  2998:             rts
                            	  2999:  	
                            	  3000: 
                            	  3001: 
                            	  3002: *-----------------------------------------------------------
                            	  3003: *-----------------------------------------------------------
                            	  3004: * OPCODE : LEA_TAS
                            	  3005: *-----------------------------------------------------------
                            	  3006: *-----------------------------------------------------------
                            	  3007: op_TAS:
                            	  3008: 
                            	  3009: *     Test just one addressing mode
                            	  3010: 
00:00002454 307C0100        	  3011:             move.l #$00000100,a0
                            	  3012: 
                            	  3013: *     (An)
00:00002458 4210            	  3014:             move.b #$00,(a0)
00:0000245A 6BFE            	  3015:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000245C 66FE            	  3016:             bne.s *                   * Check Z Flag  beq/bne
00:0000245E 4AD0            	  3017:             tas (a0)
00:00002460 0C100080        	  3018:             cmpi.b #$80,(a0)
00:00002464 66FE            	  3019:             bne.s *                   * branch if Z set
00:00002466 10BC00F5        	  3020:             move.b #$F5,(a0)
00:0000246A 4AD0            	  3021:             tas (a0)
00:0000246C 6AFE            	  3022:             bpl.s *                   * Check N Flag  bmi/bpl
00:0000246E 67FE            	  3023:             beq.s *                   * Check Z Flag  beq/bne
00:00002470 4AD0            	  3024:             tas (a0)
00:00002472 0C1000F5        	  3025:             cmpi.b #$F5,(a0)
00:00002476 66FE            	  3026:             bne.s *                   * branch if Z set
                            	  3027: 
00:00002478 4E75            	  3028:             rts
                            	  3029: 
                            	  3030: 
                            	  3031: *-----------------------------------------------------------
                            	  3032: *-----------------------------------------------------------
                            	  3033: * OPCODE : LEA_TST
                            	  3034: *-----------------------------------------------------------
                            	  3035: *-----------------------------------------------------------
                            	  3036: op_TST:
                            	  3037: 
                            	  3038: *     Test just one addressing mode
                            	  3039: 
00:0000247A 307C0100        	  3040:             move.l #$00000100,a0
                            	  3041: 
                            	  3042: *     (An) - BYTE
00:0000247E 4210            	  3043:             move.b #$00,(a0)
00:00002480 4A10            	  3044:             tst.b (a0)
00:00002482 6BFE            	  3045:             bmi.s *                   * Check N Flag  bmi/bpl
00:00002484 66FE            	  3046:             bne.s *                   * Check Z Flag  beq/bne
00:00002486 10BC00F5        	  3047:             move.b #$F5,(a0)
00:0000248A 4A10            	  3048:             tst.b (a0)
00:0000248C 6AFE            	  3049:             bpl.s *                   * Check N Flag  bmi/bpl
00:0000248E 67FE            	  3050:             beq.s *                   * Check Z Flag  beq/bne
                            	  3051: 
                            	  3052: *     (An) - WORD
00:00002490 4250            	  3053:             move.w #$0000,(a0)
00:00002492 4A50            	  3054:             tst.w (a0)
00:00002494 6BFE            	  3055:             bmi.s *                   * Check N Flag  bmi/bpl
00:00002496 66FE            	  3056:             bne.s *                   * Check Z Flag  beq/bne
00:00002498 30BCF567        	  3057:             move.w #$F567,(a0)
00:0000249C 4A50            	  3058:             tst.w (a0)
00:0000249E 6AFE            	  3059:             bpl.s *                   * Check N Flag  bmi/bpl
00:000024A0 67FE            	  3060:             beq.s *                   * Check Z Flag  beq/bne
                            	  3061: 
                            	  3062: *     (An) - LONG
00:000024A2 4290            	  3063:             move.l #$00000000,(a0)
00:000024A4 4A90            	  3064:             tst.l (a0)
00:000024A6 6BFE            	  3065:             bmi.s *                   * Check N Flag  bmi/bpl
00:000024A8 66FE            	  3066:             bne.s *                   * Check Z Flag  beq/bne
00:000024AA 20BCF56789AB    	  3067:             move.l #$F56789ab,(a0)
00:000024B0 4A90            	  3068:             tst.l (a0)
00:000024B2 6AFE            	  3069:             bpl.s *                   * Check N Flag  bmi/bpl
00:000024B4 67FE            	  3070:             beq.s *                   * Check Z Flag  beq/bne
                            	  3071: 
                            	  3072: 
00:000024B6 4E75            	  3073:             rts
                            	  3074: 
                            	  3075: 
                            	  3076: *-----------------------------------------------------------
                            	  3077: *-----------------------------------------------------------
                            	  3078: * OPCODE : LINKS
                            	  3079: *-----------------------------------------------------------
                            	  3080: *-----------------------------------------------------------
                            	  3081: op_LINKS:
                            	  3082: 
00:000024B8 207C11223344    	  3083:             move.l #$11223344,a0
00:000024BE 203C11223344    	  3084:             move.l #$11223344,d0
00:000024C4 4E500000        	  3085:             link a0,#$0
00:000024C8 0C9711223344    	  3086:             cmpi.l #$11223344,(a7)
                            	  3087: 
00:000024CE 4E58            	  3088:             unlk a0
00:000024D0 B1C0            	  3089:             cmp.l d0,a0
00:000024D2 66FE            	  3090:             bne.s *                   * branch if Z set
                            	  3091: 
00:000024D4 4E75            	  3092:             rts
                            	  3093: 
                            	  3094: *-----------------------------------------------------------
                            	  3095: *-----------------------------------------------------------
                            	  3096: * OPCODE : MOVE_USP
                            	  3097: *-----------------------------------------------------------
                            	  3098: *-----------------------------------------------------------
                            	  3099: op_MOVE_USP:
                            	  3100: 
00:000024D6 207C11223344    	  3101:             move.l #$11223344,a0
00:000024DC 4E60            	  3102:             move a0,USP
00:000024DE 4E69            	  3103:             move USP,a1
00:000024E0 B3C8            	  3104:             cmp.l a0,a1
00:000024E2 66FE            	  3105:             bne.s *                   * branch if Z set
                            	  3106: 
00:000024E4 4E75            	  3107:             rts
                            	  3108: 
                            	  3109: 
                            	  3110: *-----------------------------------------------------------
                            	  3111: *-----------------------------------------------------------
                            	  3112: * OPCODE : CHK
                            	  3113: *-----------------------------------------------------------
                            	  3114: *-----------------------------------------------------------
                            	  3115: 
                            	  3116: op_CHK:
                            	  3117: 
00:000024E6 20780018        	  3118: 	move.l 6*4,a0							; get check vector
00:000024EA 21FC0000096A0018	  3119: 	move.l #EXCEPTION_6,6*4		; set vector
00:000024F2 303C1122        	  3120: 	move.w #$1122,d0
00:000024F6 323C1122        	  3121: 	move.w #$1122,d1
00:000024FA 4380            	  3122: 	chk d0,d1
                            	  3123: 
00:000024FC 4E71            	  3124: 	nop
00:000024FE 4E71            	  3125: 	nop
                            	  3126: 
00:00002500 323C1122        	  3127: 	move.w #$1122,d1
00:00002504 43BC1122        	  3128: 	chk #$1122,d1
                            	  3129: 
00:00002508 323C1122        	  3130: 	move.w #$1122,d1
00:0000250C 43BC007A        	  3131: 	chk #00122,d1
00:00002510 BCBCEEEE0006    	  3132: 	cmp.l #$EEEE0006,d6
00:00002516 66FE            	  3133: 	bne.s *                   ; branch if Z set
                            	  3134: 
00:00002518 303C1122        	  3135: 	move.w #$1122,d0
00:0000251C 323C8000        	  3136: 	move.w #$8000,d1
00:00002520 4380            	  3137: 	chk d0,d1
00:00002522 BCBCEEEE0006    	  3138: 	cmp.l #$EEEE0006,d6
00:00002528 66FE            	  3139: 	bne.s *                   ; branch if Z set
                            	  3140: 
00:0000252A 21C80018        	  3141: 	move.l a0,6*4							; restore old vector
00:0000252E 4E75            	  3142: 	rts
                            	  3143: 
                            	  3144: 
                            	  3145: *-----------------------------------------------------------
                            	  3146: *-----------------------------------------------------------
                            	  3147: * OPCODE : NEGS
                            	  3148: *-----------------------------------------------------------
                            	  3149: *-----------------------------------------------------------
                            	  3150: op_NEGS:
                            	  3151: 
                            	  3152: *     NOT - BYTE
00:00002530 307C0100        	  3153:             move.l #$00000100,a0
00:00002534 7000            	  3154:             moveq  #$00000000,d0
00:00002536 4600            	  3155:             not.b d0
00:00002538 6AFE            	  3156:             bpl.s *                   * Check N Flag  bmi/bpl
00:0000253A 67FE            	  3157:             beq.s *                   * Check Z Flag  beq/bne
00:0000253C 4600            	  3158:             not.b d0
00:0000253E 6BFE            	  3159:             bmi.s *                   * Check N Flag  bmi/bpl
00:00002540 66FE            	  3160:             bne.s *                   * Check Z Flag  beq/bne
00:00002542 4A00            	  3161:             cmpi.b #$00,d0
00:00002544 66FE            	  3162:             bne.s *                   * Check Z Flag  beq/bne
00:00002546 10BC0080        	  3163:             move.b #$80,(a0)
00:0000254A 4610            	  3164:             not.b (a0)
00:0000254C 6BFE            	  3165:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000254E 67FE            	  3166:             beq.s *                   * Check Z Flag  beq/bne
00:00002550 4610            	  3167:             not.b (a0)
00:00002552 6AFE            	  3168:             bpl.s *                   * Check N Flag  bmi/bpl
00:00002554 67FE            	  3169:             beq.s *                   * Check Z Flag  beq/bne
00:00002556 0C100080        	  3170:             cmpi.b #$80,(a0)
00:0000255A 66FE            	  3171:             bne.s *                   * Check Z Flag  beq/bne
                            	  3172: 
                            	  3173: *     NOT - WORD
00:0000255C 307C0100        	  3174:             move.l #$00000100,a0
00:00002560 7000            	  3175:             moveq  #$00000000,d0
00:00002562 4640            	  3176:             not.w d0
00:00002564 6AFE            	  3177:             bpl.s *                   * Check N Flag  bmi/bpl
00:00002566 67FE            	  3178:             beq.s *                   * Check Z Flag  beq/bne
00:00002568 4640            	  3179:             not.w d0
00:0000256A 6BFE            	  3180:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000256C 66FE            	  3181:             bne.s *                   * Check Z Flag  beq/bne
00:0000256E 4A40            	  3182:             cmpi.w #$0000,d0
00:00002570 66FE            	  3183:             bne.s *                   * Check Z Flag  beq/bne
00:00002572 30BC5A5A        	  3184:             move.w #$5a5a,(a0)
00:00002576 4650            	  3185:             not.w (a0)
00:00002578 6AFE            	  3186:             bpl.s *                   * Check N Flag  bmi/bpl
00:0000257A 67FE            	  3187:             beq.s *                   * Check Z Flag  beq/bne
00:0000257C 4650            	  3188:             not.w (a0)
00:0000257E 6BFE            	  3189:             bmi.s *                   * Check N Flag  bmi/bpl
00:00002580 67FE            	  3190:             beq.s *                   * Check Z Flag  beq/bne
00:00002582 0C505A5A        	  3191:             cmpi.w #$5a5a,(a0)
00:00002586 66FE            	  3192:             bne.s *                   * Check Z Flag  beq/bne
                            	  3193: 
                            	  3194: *     NOT - LONG
00:00002588 307C0100        	  3195:             move.l #$00000100,a0
00:0000258C 7000            	  3196:             moveq  #$00000000,d0
00:0000258E 4680            	  3197:             not.l d0
00:00002590 6AFE            	  3198:             bpl.s *                   * Check N Flag  bmi/bpl
00:00002592 67FE            	  3199:             beq.s *                   * Check Z Flag  beq/bne
00:00002594 4680            	  3200:             not.l d0
00:00002596 6BFE            	  3201:             bmi.s *                   * Check N Flag  bmi/bpl
00:00002598 66FE            	  3202:             bne.s *                   * Check Z Flag  beq/bne
00:0000259A 4A80            	  3203:             cmpi.l #$00000000,d0
00:0000259C 66FE            	  3204:             bne.s *                   * Check Z Flag  beq/bne
00:0000259E 20BC5A5A1234    	  3205:             move.l #$5a5a1234,(a0)
00:000025A4 4690            	  3206:             not.l (a0)
00:000025A6 6AFE            	  3207:             bpl.s *                   * Check N Flag  bmi/bpl
00:000025A8 67FE            	  3208:             beq.s *                   * Check Z Flag  beq/bne
00:000025AA 4690            	  3209:             not.l (a0)
00:000025AC 6BFE            	  3210:             bmi.s *                   * Check N Flag  bmi/bpl
00:000025AE 67FE            	  3211:             beq.s *                   * Check Z Flag  beq/bne
00:000025B0 0C905A5A1234    	  3212:             cmpi.l #$5a5a1234,(a0)
00:000025B6 66FE            	  3213:             bne.s *                   * Check Z Flag  beq/bne
                            	  3214: 
                            	  3215: * -----
                            	  3216: 
                            	  3217: *     NEG - BYTE
00:000025B8 307C0100        	  3218:             move.l #$00000100,a0
00:000025BC 7000            	  3219:             moveq  #$00000000,d0
00:000025BE 7240D241        	  3220:             move.l #$00000080,d1
00:000025C2 4400            	  3221:             neg.b d0
00:000025C4 6BFE            	  3222:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000025C6 66FE            	  3223:             bne.s *                   * Check Z Flag  beq/bne 1
00:000025C8 65FE            	  3224:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:000025CA 69FE            	  3225:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000025CC 4401            	  3226:             neg.b d1
00:000025CE 6AFE            	  3227:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000025D0 67FE            	  3228:             beq.s *                   * Check Z Flag  beq/bne 0
00:000025D2 64FE            	  3229:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000025D4 68FE            	  3230:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:000025D6 0C010080        	  3231:             cmpi.b #$80,d1
00:000025DA 66FE            	  3232:             bne.s *                   * Check Z Flag  beq/bne
00:000025DC 10BC007F        	  3233:             move.b #$7F,(a0)
00:000025E0 4410            	  3234:             neg.b (a0)
00:000025E2 6AFE            	  3235:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000025E4 67FE            	  3236:             beq.s *                   * Check Z Flag  beq/bne 0
00:000025E6 64FE            	  3237:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000025E8 69FE            	  3238:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000025EA 10BC00F5        	  3239:             move.b #$F5,(a0)
00:000025EE 4410            	  3240:             neg.b (a0)
00:000025F0 6BFE            	  3241:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000025F2 67FE            	  3242:             beq.s *                   * Check Z Flag  beq/bne 0
00:000025F4 64FE            	  3243:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000025F6 69FE            	  3244:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000025F8 0C10000B        	  3245:             cmpi.b #$0B,(a0)
00:000025FC 66FE            	  3246:             bne.s *                   * Check Z Flag  beq/bne
                            	  3247: 
                            	  3248: * -----
                            	  3249: 
                            	  3250: *     NEG - WORD
00:000025FE 307C0100        	  3251:             move.l #$00000100,a0
00:00002602 7000            	  3252:             moveq  #$00000000,d0
00:00002604 223C00008000    	  3253:             move.l #$00008000,d1
00:0000260A 4440            	  3254:             neg.w d0
00:0000260C 6BFE            	  3255:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:0000260E 66FE            	  3256:             bne.s *                   * Check Z Flag  beq/bne 1
00:00002610 65FE            	  3257:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:00002612 69FE            	  3258:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002614 4441            	  3259:             neg.w d1
00:00002616 6AFE            	  3260:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00002618 67FE            	  3261:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000261A 64FE            	  3262:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000261C 68FE            	  3263:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:0000261E 0C418000        	  3264:             cmpi.w #$8000,d1
00:00002622 66FE            	  3265:             bne.s *                   * Check Z Flag  beq/bne
00:00002624 30BC7FFF        	  3266:             move.w #$7FFF,(a0)
00:00002628 4450            	  3267:             neg.w (a0)
00:0000262A 6AFE            	  3268:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:0000262C 67FE            	  3269:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000262E 64FE            	  3270:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002630 69FE            	  3271:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002632 30BCF578        	  3272:             move.w #$F578,(a0)
00:00002636 4450            	  3273:             neg.w (a0)
00:00002638 6BFE            	  3274:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:0000263A 67FE            	  3275:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000263C 64FE            	  3276:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000263E 69FE            	  3277:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002640 0C500A88        	  3278:             cmpi.w #$0A88,(a0)
00:00002644 66FE            	  3279:             bne.s *                   * Check Z Flag  beq/bne
                            	  3280: 
                            	  3281: * -----
                            	  3282: 
                            	  3283: *     NEG - LONG
00:00002646 307C0100        	  3284:             move.l #$00000100,a0
00:0000264A 7000            	  3285:             moveq  #$00000000,d0
00:0000264C 223C80000000    	  3286:             move.l #$80000000,d1
00:00002652 4480            	  3287:             neg.l d0
00:00002654 6BFE            	  3288:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00002656 66FE            	  3289:             bne.s *                   * Check Z Flag  beq/bne 1
00:00002658 65FE            	  3290:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:0000265A 69FE            	  3291:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000265C 4481            	  3292:             neg.l d1
00:0000265E 6AFE            	  3293:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00002660 67FE            	  3294:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002662 64FE            	  3295:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002664 68FE            	  3296:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:00002666 0C8180000000    	  3297:             cmpi.l #$80000000,d1
00:0000266C 66FE            	  3298:             bne.s *                   * Check Z Flag  beq/bne
00:0000266E 20BC7FFFFFFF    	  3299:             move.l #$7FFFFFFF,(a0)
00:00002674 4490            	  3300:             neg.l (a0)
00:00002676 6AFE            	  3301:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00002678 67FE            	  3302:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000267A 64FE            	  3303:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000267C 69FE            	  3304:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000267E 20BCF5781234    	  3305:             move.l #$F5781234,(a0)
00:00002684 4490            	  3306:             neg.l (a0)
00:00002686 6BFE            	  3307:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00002688 67FE            	  3308:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000268A 64FE            	  3309:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000268C 69FE            	  3310:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000268E 0C900A87EDCC    	  3311:             cmpi.l #$0A87EDCC,(a0)
00:00002694 66FE            	  3312:             bne.s *                   * Check Z Flag  beq/bne
                            	  3313: 
                            	  3314: 
                            	  3315: * -----
                            	  3316: 
                            	  3317: *     NEGX - BYTE
00:00002696 307C0100        	  3318:             move.l #$00000100,a0
00:0000269A 7000            	  3319:             moveq  #$00000000,d0
00:0000269C 7240D241        	  3320:             move.l #$00000080,d1
00:000026A0 003C0010        	  3321:             ori.b #$10,CCR        * Set X Flag
00:000026A4 4000            	  3322:             negx.b d0
00:000026A6 6AFE            	  3323:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:000026A8 67FE            	  3324:             beq.s *                   * Check Z Flag  beq/bne 1
00:000026AA 64FE            	  3325:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:000026AC 69FE            	  3326:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000026AE 023C00EF        	  3327:             andi.b #$EF,CCR       * Clear X Flag
00:000026B2 4000            	  3328:             negx.b d0
00:000026B4 6BFE            	  3329:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000026B6 67FE            	  3330:             beq.s *                   * Check Z Flag  beq/bne 1
00:000026B8 64FE            	  3331:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:000026BA 69FE            	  3332:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000026BC 003C0010        	  3333:             ori.b #$10,CCR        * Set X Flag
00:000026C0 4001            	  3334:             negx.b d1
00:000026C2 6BFE            	  3335:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:000026C4 67FE            	  3336:             beq.s *                   * Check Z Flag  beq/bne 0
00:000026C6 64FE            	  3337:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000026C8 69FE            	  3338:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:000026CA 0C01007F        	  3339:             cmpi.b #$7F,d1
00:000026CE 66FE            	  3340:             bne.s *                   * Check Z Flag  beq/bne
00:000026D0 023C00EF        	  3341:             andi.b #$EF,CCR       * Clear X Flag
00:000026D4 4001            	  3342:             negx.b d1
00:000026D6 6AFE            	  3343:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000026D8 67FE            	  3344:             beq.s *                   * Check Z Flag  beq/bne 0
00:000026DA 64FE            	  3345:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000026DC 69FE            	  3346:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:000026DE 0C010081        	  3347:             cmpi.b #$81,d1
00:000026E2 66FE            	  3348:             bne.s *                   * Check Z Flag  beq/bne
00:000026E4 10BC007F        	  3349:             move.b #$7F,(a0)
00:000026E8 003C0010        	  3350:             ori.b #$10,CCR        * Set X Flag
00:000026EC 4010            	  3351:             negx.b (a0)
00:000026EE 6AFE            	  3352:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000026F0 67FE            	  3353:             beq.s *                   * Check Z Flag  beq/bne 0
00:000026F2 64FE            	  3354:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3355:             * I think overflow should happen here.
                            	  3356: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:000026F4 10BC007F        	  3357:             move.b #$7F,(a0)
00:000026F8 023C00EF        	  3358:             andi.b #$EF,CCR       * Clear X Flag
00:000026FC 4010            	  3359:             negx.b (a0)
00:000026FE 6AFE            	  3360:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00002700 67FE            	  3361:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002702 64FE            	  3362:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002704 69FE            	  3363:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002706 10BC00F5        	  3364:             move.b #$F5,(a0)
00:0000270A 003C0010        	  3365:             ori.b #$10,CCR        * Set X Flag
00:0000270E 4010            	  3366:             negx.b (a0)
00:00002710 6BFE            	  3367:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00002712 67FE            	  3368:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002714 64FE            	  3369:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002716 69FE            	  3370:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002718 0C10000A        	  3371:             cmpi.b #$0A,(a0)
00:0000271C 66FE            	  3372:             bne.s *                   * Check Z Flag  beq/bne
00:0000271E 023C00EF        	  3373:             andi.b #$EF,CCR       * Clear X Flag
00:00002722 4010            	  3374:             negx.b (a0)
00:00002724 6AFE            	  3375:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:00002726 67FE            	  3376:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002728 64FE            	  3377:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000272A 69FE            	  3378:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000272C 0C1000F6        	  3379:             cmpi.b #$F6,(a0)
00:00002730 66FE            	  3380:             bne.s *                   * Check Z Flag  beq/bne
                            	  3381: 
                            	  3382: 
                            	  3383: 
                            	  3384: * -----
                            	  3385: 
                            	  3386: *     NEGX - WORD
00:00002732 307C0100        	  3387:             move.l #$00000100,a0
00:00002736 7000            	  3388:             moveq  #$00000000,d0
00:00002738 223C00008000    	  3389:             move.l #$00008000,d1
00:0000273E 003C0010        	  3390:             ori.b #$10,CCR        * Set X Flag
00:00002742 4040            	  3391:             negx.w d0
00:00002744 6AFE            	  3392:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:00002746 67FE            	  3393:             beq.s *                   * Check Z Flag  beq/bne 1
00:00002748 64FE            	  3394:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:0000274A 69FE            	  3395:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000274C 023C00EF        	  3396:             andi.b #$EF,CCR       * Clear X Flag
00:00002750 4040            	  3397:             negx.w d0
00:00002752 6BFE            	  3398:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00002754 67FE            	  3399:             beq.s *                   * Check Z Flag  beq/bne 1
00:00002756 64FE            	  3400:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:00002758 69FE            	  3401:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000275A 003C0010        	  3402:             ori.b #$10,CCR        * Set X Flag
00:0000275E 4041            	  3403:             negx.w d1
00:00002760 6BFE            	  3404:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:00002762 67FE            	  3405:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002764 64FE            	  3406:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002766 69FE            	  3407:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:00002768 0C417FFF        	  3408:             cmpi.w #$7FFF,d1
00:0000276C 66FE            	  3409:             bne.s *                   * Check Z Flag  beq/bne
00:0000276E 023C00EF        	  3410:             andi.b #$EF,CCR       * Clear X Flag
00:00002772 4041            	  3411:             negx.w d1
00:00002774 6AFE            	  3412:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00002776 67FE            	  3413:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002778 64FE            	  3414:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000277A 69FE            	  3415:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:0000277C 0C418001        	  3416:             cmpi.w #$8001,d1
00:00002780 66FE            	  3417:             bne.s *                   * Check Z Flag  beq/bne
00:00002782 30BC7FFF        	  3418:             move.w #$7FFF,(a0)
00:00002786 003C0010        	  3419:             ori.b #$10,CCR        * Set X Flag
00:0000278A 4050            	  3420:             negx.w (a0)
00:0000278C 6AFE            	  3421:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:0000278E 67FE            	  3422:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002790 64FE            	  3423:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3424: ***            
                            	  3425: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002792 30BCF567        	  3426:             move.w #$F567,(a0)
00:00002796 023C00EF        	  3427:             andi.b #$EF,CCR       * Clear X Flag
00:0000279A 4050            	  3428:             negx.w (a0)
00:0000279C 6BFE            	  3429:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:0000279E 67FE            	  3430:             beq.s *                   * Check Z Flag  beq/bne 0
00:000027A0 64FE            	  3431:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000027A2 69FE            	  3432:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000027A4 30BCF567        	  3433:             move.w #$F567,(a0)
00:000027A8 003C0010        	  3434:             ori.b #$10,CCR        * Set X Flag
00:000027AC 4050            	  3435:             negx.w (a0)
00:000027AE 6BFE            	  3436:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000027B0 67FE            	  3437:             beq.s *                   * Check Z Flag  beq/bne 0
00:000027B2 64FE            	  3438:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000027B4 69FE            	  3439:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000027B6 0C500A98        	  3440:             cmpi.w #$0A98,(a0)
00:000027BA 66FE            	  3441:             bne.s *                   * Check Z Flag  beq/bne
00:000027BC 023C00EF        	  3442:             andi.b #$EF,CCR       * Clear X Flag
00:000027C0 4050            	  3443:             negx.w (a0)
00:000027C2 6AFE            	  3444:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:000027C4 67FE            	  3445:             beq.s *                   * Check Z Flag  beq/bne 0
00:000027C6 64FE            	  3446:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000027C8 69FE            	  3447:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000027CA 0C50F568        	  3448:             cmpi.w #$F568,(a0)
00:000027CE 66FE            	  3449:             bne.s *                   * Check Z Flag  beq/bne
                            	  3450: 
                            	  3451: 
                            	  3452: * -----
                            	  3453: 
                            	  3454: *     NEGX - LONG
00:000027D0 307C0100        	  3455:             move.l #$00000100,a0
00:000027D4 7000            	  3456:             moveq  #$00000000,d0
00:000027D6 223C80000000    	  3457:             move.l #$80000000,d1
00:000027DC 003C0010        	  3458:             ori.b #$10,CCR        * Set X Flag
00:000027E0 4080            	  3459:             negx.l d0
00:000027E2 6AFE            	  3460:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:000027E4 67FE            	  3461:             beq.s *                   * Check Z Flag  beq/bne 1
00:000027E6 64FE            	  3462:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:000027E8 69FE            	  3463:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000027EA 023C00EF        	  3464:             andi.b #$EF,CCR       * Clear X Flag
00:000027EE 4080            	  3465:             negx.l d0
00:000027F0 6BFE            	  3466:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000027F2 67FE            	  3467:             beq.s *                   * Check Z Flag  beq/bne 1
00:000027F4 64FE            	  3468:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:000027F6 69FE            	  3469:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000027F8 003C0010        	  3470:             ori.b #$10,CCR        * Set X Flag
00:000027FC 4081            	  3471:             negx.l d1
00:000027FE 6BFE            	  3472:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:00002800 67FE            	  3473:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002802 64FE            	  3474:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002804 69FE            	  3475:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:00002806 0C817FFFFFFF    	  3476:             cmpi.l #$7FFFFFFF,d1
00:0000280C 66FE            	  3477:             bne.s *                   * Check Z Flag  beq/bne
00:0000280E 023C00EF        	  3478:             andi.b #$EF,CCR       * Clear X Flag
00:00002812 4081            	  3479:             negx.l d1
00:00002814 6AFE            	  3480:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00002816 67FE            	  3481:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002818 64FE            	  3482:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3483: ****            
                            	  3484: *            bvs.s *                   * Check V Flag  bvc/bvs 0
00:0000281A 0C8180000001    	  3485:             cmpi.l #$80000001,d1
00:00002820 66FE            	  3486:             bne.s *                   * Check Z Flag  beq/bne
00:00002822 20BC00007FFF    	  3487:             move.l #$7FFF,(a0)
00:00002828 003C0010        	  3488:             ori.b #$10,CCR        * Set X Flag
00:0000282C 4090            	  3489:             negx.l (a0)
00:0000282E 6AFE            	  3490:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00002830 67FE            	  3491:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002832 64FE            	  3492:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3493: ****            
                            	  3494: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002834 20BCF5671234    	  3495:             move.l #$F5671234,(a0)
00:0000283A 023C00EF        	  3496:             andi.b #$EF,CCR       * Clear X Flag
00:0000283E 4090            	  3497:             negx.l (a0)
00:00002840 6BFE            	  3498:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:00002842 67FE            	  3499:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002844 64FE            	  3500:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002846 69FE            	  3501:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002848 20BCF5675678    	  3502:             move.l #$F5675678,(a0)
00:0000284E 003C0010        	  3503:             ori.b #$10,CCR        * Set X Flag
00:00002852 4090            	  3504:             negx.l (a0)
00:00002854 6BFE            	  3505:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00002856 67FE            	  3506:             beq.s *                   * Check Z Flag  beq/bne 0
00:00002858 64FE            	  3507:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000285A 69FE            	  3508:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000285C 0C900A98A987    	  3509:             cmpi.l #$0A98A987,(a0)
00:00002862 66FE            	  3510:             bne.s *                   * Check Z Flag  beq/bne
00:00002864 023C00EF        	  3511:             andi.b #$EF,CCR       * Clear X Flag
00:00002868 4090            	  3512:             negx.l (a0)
00:0000286A 6AFE            	  3513:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:0000286C 67FE            	  3514:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000286E 64FE            	  3515:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00002870 69FE            	  3516:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00002872 0C90F5675679    	  3517:             cmpi.l #$F5675679,(a0)
00:00002878 66FE            	  3518:             bne.s *                   * Check Z Flag  beq/bne
                            	  3519: 
                            	  3520: 
                            	  3521: * -----
                            	  3522: 
                            	  3523: *     CLR - BYTE
00:0000287A 307C0100        	  3524:             move.l #$00000100,a0
00:0000287E 203C12345678    	  3525:             move.l #$12345678,d0
00:00002884 223C12345678    	  3526:             move.l #$12345678,d1
00:0000288A 243C12345678    	  3527:             move.l #$12345678,d2
00:00002890 283C12345600    	  3528:             move.l #$12345600,d4
00:00002896 2A3C12340000    	  3529:             move.l #$12340000,d5
00:0000289C 7C00            	  3530:             moveq  #$00000000,d6
                            	  3531: 
00:0000289E 4200            	  3532:             clr.b d0
00:000028A0 66FE            	  3533:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028A2 6BFE            	  3534:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000028A4 B880            	  3535:             cmp.l d0,d4
00:000028A6 66FE            	  3536:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3537: 
00:000028A8 4241            	  3538:             clr.w d1
00:000028AA 66FE            	  3539:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028AC 6BFE            	  3540:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000028AE BA81            	  3541:             cmp.l d1,d5
00:000028B0 66FE            	  3542:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3543: 
00:000028B2 7400            	  3544:             clr.l d2
00:000028B4 66FE            	  3545:             bne.s *                   * Check Z Flag  beq/bne 0
00:000028B6 6BFE            	  3546:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000028B8 BC82            	  3547:             cmp.l d2,d6
00:000028BA 66FE            	  3548:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3549: 
00:000028BC 4E75            	  3550:             rts
                            	  3551: 
                            	  3552: 
                            	  3553: 
                            	  3554: *-----------------------------------------------------------
                            	  3555: *-----------------------------------------------------------
                            	  3556: * OPCODE : MOVEM
                            	  3557: *-----------------------------------------------------------
                            	  3558: *-----------------------------------------------------------
                            	  3559: op_MOVEM:
                            	  3560: 
                            	  3561: *     WORD  Registers --> Memory
00:000028BE 203C0000D0D0    	  3562:             move.l #$0000d0d0,d0
00:000028C4 223C0000D1D1    	  3563:             move.l #$0000d1d1,d1
00:000028CA 243C0000D2D2    	  3564:             move.l #$0000d2d2,d2
00:000028D0 263C0000D3D3    	  3565:             move.l #$0000d3d3,d3
00:000028D6 283C0000D4D4    	  3566:             move.l #$0000d4d4,d4
00:000028DC 2A3C0000D5D5    	  3567:             move.l #$0000d5d5,d5
00:000028E2 2C3C0000D6D6    	  3568:             move.l #$0000d6d6,d6
00:000028E8 2E3C0000D7D7    	  3569:             move.l #$0000d7d7,d7
00:000028EE 307C0A0A        	  3570:             move.l #$00000a0a,a0
00:000028F2 327C1A1A        	  3571:             move.l #$00001a1a,a1
00:000028F6 347C2A2A        	  3572:             move.l #$00002a2a,a2
00:000028FA 367C3A3A        	  3573:             move.l #$00003a3a,a3
00:000028FE 387C4A4A        	  3574:             move.l #$00004a4a,a4
00:00002902 3A7C5A5A        	  3575:             move.l #$00005a5a,a5
00:00002906 3C7C6A6A        	  3576:             move.l #$00006a6a,a6
                            	  3577: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3578: 
00:0000290A 48B8FFFF0100    	  3579:             movem.w D0-D7/A0-A7,$00000100
                            	  3580: 
00:00002910 307C0100        	  3581:             move.l #$00000100,a0
                            	  3582: 
00:00002914 B058            	  3583:             cmp.w (a0)+,d0
00:00002916 66FE            	  3584:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002918 B258            	  3585:             cmp.w (a0)+,d1
00:0000291A 66FE            	  3586:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000291C B458            	  3587:             cmp.w (a0)+,d2
00:0000291E 66FE            	  3588:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002920 B658            	  3589:             cmp.w (a0)+,d3
00:00002922 66FE            	  3590:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002924 B858            	  3591:             cmp.w (a0)+,d4
00:00002926 66FE            	  3592:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002928 BA58            	  3593:             cmp.w (a0)+,d5
00:0000292A 66FE            	  3594:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000292C BC58            	  3595:             cmp.w (a0)+,d6
00:0000292E 66FE            	  3596:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002930 BE58            	  3597:             cmp.w (a0)+,d7
00:00002932 66FE            	  3598:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3599: 
00:00002934 0C580A0A        	  3600:             cmpi.w #$0A0A,(a0)+    * Because we are using a0 as a pointer
00:00002938 66FE            	  3601:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3602: 
00:0000293A B2D8            	  3603:             cmp.w (a0)+,a1
00:0000293C 66FE            	  3604:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000293E B4D8            	  3605:             cmp.w (a0)+,a2
00:00002940 66FE            	  3606:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002942 B6D8            	  3607:             cmp.w (a0)+,a3
00:00002944 66FE            	  3608:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002946 B8D8            	  3609:             cmp.w (a0)+,a4
00:00002948 66FE            	  3610:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000294A BAD8            	  3611:             cmp.w (a0)+,a5
00:0000294C 66FE            	  3612:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000294E BCD8            	  3613:             cmp.w (a0)+,a6
00:00002950 66FE            	  3614:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3615: 
                            	  3616: 
                            	  3617: 
                            	  3618: 
                            	  3619: *     LONG  Registers --> Memory
00:00002952 203CD0D0D0D0    	  3620:             move.l #$d0d0d0d0,d0
00:00002958 223CD1D1D1D1    	  3621:             move.l #$d1d1d1d1,d1
00:0000295E 243CD2D2D2D2    	  3622:             move.l #$d2d2d2d2,d2
00:00002964 263CD3D3D3D3    	  3623:             move.l #$d3d3d3d3,d3
00:0000296A 283CD4D4D4D4    	  3624:             move.l #$d4d4d4d4,d4
00:00002970 2A3CD5D5D5D5    	  3625:             move.l #$d5d5d5d5,d5
00:00002976 2C3CD6D6D6D6    	  3626:             move.l #$d6d6d6d6,d6
00:0000297C 2E3CD7D7D7D7    	  3627:             move.l #$d7d7d7d7,d7
00:00002982 207C0A0A0A0A    	  3628:             move.l #$0a0a0a0a,a0
00:00002988 227C1A1A1A1A    	  3629:             move.l #$1a1a1a1a,a1
00:0000298E 247C2A2A2A2A    	  3630:             move.l #$2a2a2a2a,a2
00:00002994 267C3A3A3A3A    	  3631:             move.l #$3a3a3a3a,a3
00:0000299A 287C4A4A4A4A    	  3632:             move.l #$4a4a4a4a,a4
00:000029A0 2A7C5A5A5A5A    	  3633:             move.l #$5a5a5a5a,a5
00:000029A6 2C7C6A6A6A6A    	  3634:             move.l #$6a6a6a6a,a6
                            	  3635: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3636: 
                            	  3637: 
00:000029AC 48F8FFFF0120    	  3638:             movem.l D0-D7/A0-A7,$00000120
                            	  3639: 
00:000029B2 307C0120        	  3640:             move.l #$00000120,a0
                            	  3641: 
00:000029B6 B098            	  3642:             cmp.l (a0)+,d0
00:000029B8 66FE            	  3643:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029BA B298            	  3644:             cmp.l (a0)+,d1
00:000029BC 66FE            	  3645:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029BE B498            	  3646:             cmp.l (a0)+,d2
00:000029C0 66FE            	  3647:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029C2 B698            	  3648:             cmp.l (a0)+,d3
00:000029C4 66FE            	  3649:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029C6 B898            	  3650:             cmp.l (a0)+,d4
00:000029C8 66FE            	  3651:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029CA BA98            	  3652:             cmp.l (a0)+,d5
00:000029CC 66FE            	  3653:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029CE BC98            	  3654:             cmp.l (a0)+,d6
00:000029D0 66FE            	  3655:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029D2 BE98            	  3656:             cmp.l (a0)+,d7
00:000029D4 66FE            	  3657:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3658: 
00:000029D6 0C980A0A0A0A    	  3659:             cmpi.l #$0A0A0A0A,(a0)+    * Because we are using a0 as a pointer
00:000029DC 66FE            	  3660:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3661: 
00:000029DE B3D8            	  3662:             cmp.l (a0)+,a1
00:000029E0 66FE            	  3663:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029E2 B5D8            	  3664:             cmp.l (a0)+,a2
00:000029E4 66FE            	  3665:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029E6 B7D8            	  3666:             cmp.l (a0)+,a3
00:000029E8 66FE            	  3667:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029EA B9D8            	  3668:             cmp.l (a0)+,a4
00:000029EC 66FE            	  3669:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029EE BBD8            	  3670:             cmp.l (a0)+,a5
00:000029F0 66FE            	  3671:             bne.s *                   * Check Z Flag  beq/bne 0
00:000029F2 BDD8            	  3672:             cmp.l (a0)+,a6
00:000029F4 66FE            	  3673:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3674: *      ----
                            	  3675: 
                            	  3676: 
                            	  3677: *     WORD  Registers --> Memory  -(An) EA Mode
00:000029F6 203C0000D0D0    	  3678:             move.l #$0000d0d0,d0
00:000029FC 223C0000D1D1    	  3679:             move.l #$0000d1d1,d1
00:00002A02 243C0000D2D2    	  3680:             move.l #$0000d2d2,d2
00:00002A08 263C0000D3D3    	  3681:             move.l #$0000d3d3,d3
00:00002A0E 283C0000D4D4    	  3682:             move.l #$0000d4d4,d4
00:00002A14 2A3C0000D5D5    	  3683:             move.l #$0000d5d5,d5
00:00002A1A 2C3C0000D6D6    	  3684:             move.l #$0000d6d6,d6
00:00002A20 2E3C0000D7D7    	  3685:             move.l #$0000d7d7,d7
00:00002A26 307C0A0A        	  3686:             move.l #$00000a0a,a0
00:00002A2A 327C1A1A        	  3687:             move.l #$00001a1a,a1
00:00002A2E 347C2A2A        	  3688:             move.l #$00002a2a,a2
00:00002A32 367C3A3A        	  3689:             move.l #$00003a3a,a3
00:00002A36 387C4A4A        	  3690:             move.l #$00004a4a,a4
00:00002A3A 3A7C5A5A        	  3691:             move.l #$00005a5a,a5
00:00002A3E 3C7C6A6A        	  3692:             move.l #$00006a6a,a6
                            	  3693: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3694: 
00:00002A42 307C01A0        	  3695:             move.l #$000001A0,a0
00:00002A46 48A0FFFF        	  3696:             movem.w D0-D7/A0-A7,-(a0)
                            	  3697: 
00:00002A4A 307C019E        	  3698:             move.l #$0000019E,a0
                            	  3699: 
00:00002A4E BCE0            	  3700:             cmp.w -(a0),a6
00:00002A50 66FE            	  3701:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A52 BAE0            	  3702:             cmp.w -(a0),a5
00:00002A54 66FE            	  3703:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A56 B8E0            	  3704:             cmp.w -(a0),a4
00:00002A58 66FE            	  3705:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A5A B6E0            	  3706:             cmp.w -(a0),a3
00:00002A5C 66FE            	  3707:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A5E B4E0            	  3708:             cmp.w -(a0),a2
00:00002A60 66FE            	  3709:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A62 B2E0            	  3710:             cmp.w -(a0),a1
00:00002A64 66FE            	  3711:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A66 B0E0            	  3712:             cmp.w -(a0),a0
                            	  3713: *            bne.s *                   * Check Z Flag  beq/bne 0
00:00002A68 BE60            	  3714:             cmp.w -(a0),d7
00:00002A6A 66FE            	  3715:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A6C BC60            	  3716:             cmp.w -(a0),d6
00:00002A6E 66FE            	  3717:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A70 BA60            	  3718:             cmp.w -(a0),d5
00:00002A72 66FE            	  3719:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A74 B860            	  3720:             cmp.w -(a0),d4
00:00002A76 66FE            	  3721:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A78 B660            	  3722:             cmp.w -(a0),d3
00:00002A7A 66FE            	  3723:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A7C B460            	  3724:             cmp.w -(a0),d2
00:00002A7E 66FE            	  3725:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A80 B260            	  3726:             cmp.w -(a0),d1
00:00002A82 66FE            	  3727:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002A84 B060            	  3728:             cmp.w -(a0),d0
00:00002A86 66FE            	  3729:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3730: 
                            	  3731: 
                            	  3732: 
                            	  3733: 
                            	  3734: *     LONG  Registers --> Memory   -(An) EA Mode
00:00002A88 203CD0D0D0D0    	  3735:             move.l #$d0d0d0d0,d0
00:00002A8E 223CD1D1D1D1    	  3736:             move.l #$d1d1d1d1,d1
00:00002A94 243CD2D2D2D2    	  3737:             move.l #$d2d2d2d2,d2
00:00002A9A 263CD3D3D3D3    	  3738:             move.l #$d3d3d3d3,d3
00:00002AA0 283CD4D4D4D4    	  3739:             move.l #$d4d4d4d4,d4
00:00002AA6 2A3CD5D5D5D5    	  3740:             move.l #$d5d5d5d5,d5
00:00002AAC 2C3CD6D6D6D6    	  3741:             move.l #$d6d6d6d6,d6
00:00002AB2 2E3CD7D7D7D7    	  3742:             move.l #$d7d7d7d7,d7
00:00002AB8 207C0A0A0A0A    	  3743:             move.l #$0a0a0a0a,a0
00:00002ABE 227C1A1A1A1A    	  3744:             move.l #$1a1a1a1a,a1
00:00002AC4 247C2A2A2A2A    	  3745:             move.l #$2a2a2a2a,a2
00:00002ACA 267C3A3A3A3A    	  3746:             move.l #$3a3a3a3a,a3
00:00002AD0 287C4A4A4A4A    	  3747:             move.l #$4a4a4a4a,a4
00:00002AD6 2A7C5A5A5A5A    	  3748:             move.l #$5a5a5a5a,a5
00:00002ADC 2C7C6A6A6A6A    	  3749:             move.l #$6a6a6a6a,a6
                            	  3750: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3751: 
                            	  3752: 
00:00002AE2 307C01A0        	  3753:             move.l #$000001A0,a0
00:00002AE6 48E0FFFF        	  3754:             movem.l D0-D7/A0-A7,-(a0)
                            	  3755: 
00:00002AEA 307C019C        	  3756:             move.l #$0000019C,a0
                            	  3757: 
00:00002AEE BDE0            	  3758:             cmp.l -(a0),a6
00:00002AF0 66FE            	  3759:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002AF2 BBE0            	  3760:             cmp.l -(a0),a5
00:00002AF4 66FE            	  3761:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002AF6 B9E0            	  3762:             cmp.l -(a0),a4
00:00002AF8 66FE            	  3763:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002AFA B7E0            	  3764:             cmp.l -(a0),a3
00:00002AFC 66FE            	  3765:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002AFE B5E0            	  3766:             cmp.l -(a0),a2
00:00002B00 66FE            	  3767:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B02 B3E0            	  3768:             cmp.l -(a0),a1
00:00002B04 66FE            	  3769:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B06 B1E0            	  3770:             cmp.l -(a0),a0
                            	  3771: *            bne.s *                   * Check Z Flag  beq/bne 0
00:00002B08 BEA0            	  3772:             cmp.l -(a0),d7
00:00002B0A 66FE            	  3773:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B0C BCA0            	  3774:             cmp.l -(a0),d6
00:00002B0E 66FE            	  3775:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B10 BAA0            	  3776:             cmp.l -(a0),d5
00:00002B12 66FE            	  3777:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B14 B8A0            	  3778:             cmp.l -(a0),d4
00:00002B16 66FE            	  3779:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B18 B6A0            	  3780:             cmp.l -(a0),d3
00:00002B1A 66FE            	  3781:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B1C B4A0            	  3782:             cmp.l -(a0),d2
00:00002B1E 66FE            	  3783:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B20 B2A0            	  3784:             cmp.l -(a0),d1
00:00002B22 66FE            	  3785:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B24 B0A0            	  3786:             cmp.l -(a0),d0
00:00002B26 66FE            	  3787:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3788: 
                            	  3789: 
                            	  3790: 
                            	  3791: *     ----
                            	  3792: 
                            	  3793: *     WORD - Memory --> Registers
00:00002B28 7000            	  3794:             moveq  #$00000000,d0
00:00002B2A 7200            	  3795:             moveq  #$00000000,d1
00:00002B2C 7400            	  3796:             moveq  #$00000000,d2
00:00002B2E 7600            	  3797:             moveq  #$00000000,d3
00:00002B30 7800            	  3798:             moveq  #$00000000,d4
00:00002B32 7A00            	  3799:             moveq  #$00000000,d5
00:00002B34 7C00            	  3800:             moveq  #$00000000,d6
00:00002B36 7E00            	  3801:             moveq  #$00000000,d7
00:00002B38 91C8            	  3802:             move.l #$00000000,a0
00:00002B3A 93C9            	  3803:             move.l #$00000000,a1
00:00002B3C 95CA            	  3804:             move.l #$00000000,a2
00:00002B3E 97CB            	  3805:             move.l #$00000000,a3
00:00002B40 99CC            	  3806:             move.l #$00000000,a4
00:00002B42 9BCD            	  3807:             move.l #$00000000,a5
00:00002B44 9DCE            	  3808:             move.l #$00000000,a6
                            	  3809: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3810: 
00:00002B46 4CB82A550100    	  3811:             movem.w $00000100,D0/D2/D4/D6/A1/A3/A5
                            	  3812: 
00:00002B4C B0BCFFFFD0D0    	  3813:             cmp.l #$FFFFD0D0,d0
00:00002B52 66FE            	  3814:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B54 B4BCFFFFD1D1    	  3815:             cmp.l #$FFFFD1D1,d2
00:00002B5A 66FE            	  3816:             bne.s *                  * Check Z Flag  beq/bne 0
00:00002B5C B8BCFFFFD2D2    	  3817:             cmp.l #$FFFFD2D2,d4
00:00002B62 66FE            	  3818:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B64 BCBCFFFFD3D3    	  3819:             cmp.l #$FFFFD3D3,d6
00:00002B6A 66FE            	  3820:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B6C B2FCD4D4        	  3821:             cmp.l #$FFFFD4D4,a1
00:00002B70 66FE            	  3822:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B72 B6FCD5D5        	  3823:             cmp.l #$FFFFD5D5,a3
00:00002B76 66FE            	  3824:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002B78 BAFCD6D6        	  3825:             cmp.l #$FFFFD6D6,a5
00:00002B7C 66FE            	  3826:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3827: 
                            	  3828: 
                            	  3829: *     LONG - Memory --> Registers
00:00002B7E 7000            	  3830:             moveq  #$00000000,d0
00:00002B80 7200            	  3831:             moveq  #$00000000,d1
00:00002B82 7400            	  3832:             moveq  #$00000000,d2
00:00002B84 7600            	  3833:             moveq  #$00000000,d3
00:00002B86 7800            	  3834:             moveq  #$00000000,d4
00:00002B88 7A00            	  3835:             moveq  #$00000000,d5
00:00002B8A 7C00            	  3836:             moveq  #$00000000,d6
00:00002B8C 7E00            	  3837:             moveq  #$00000000,d7
00:00002B8E 91C8            	  3838:             move.l #$00000000,a0
00:00002B90 93C9            	  3839:             move.l #$00000000,a1
00:00002B92 95CA            	  3840:             move.l #$00000000,a2
00:00002B94 97CB            	  3841:             move.l #$00000000,a3
00:00002B96 99CC            	  3842:             move.l #$00000000,a4
00:00002B98 9BCD            	  3843:             move.l #$00000000,a5
00:00002B9A 9DCE            	  3844:             move.l #$00000000,a6
                            	  3845: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3846: 
00:00002B9C 4CF82A550120    	  3847:             movem.l $00000120,D0/D2/D4/D6/A1/A3/A5
                            	  3848: 
00:00002BA2 B0BCD0D0D0D0    	  3849:             cmp.l #$D0D0D0D0,d0
00:00002BA8 66FE            	  3850:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002BAA B4BCD1D1D1D1    	  3851:             cmp.l #$D1D1D1D1,d2
00:00002BB0 66FE            	  3852:             bne.s *                  * Check Z Flag  beq/bne 0
00:00002BB2 B8BCD2D2D2D2    	  3853:             cmp.l #$D2D2D2D2,d4
00:00002BB8 66FE            	  3854:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002BBA BCBCD3D3D3D3    	  3855:             cmp.l #$D3D3D3D3,d6
00:00002BC0 66FE            	  3856:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002BC2 B3FCD4D4D4D4    	  3857:             cmp.l #$D4D4D4D4,a1
00:00002BC8 66FE            	  3858:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002BCA B7FCD5D5D5D5    	  3859:             cmp.l #$D5D5D5D5,a3
00:00002BD0 66FE            	  3860:             bne.s *                   * Check Z Flag  beq/bne 0
00:00002BD2 BBFCD6D6D6D6    	  3861:             cmp.l #$D6D6D6D6,a5
00:00002BD8 66FE            	  3862:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3863: 
00:00002BDA 4E75            	  3864:             rts
                            	  3865: 
                            	  3866: 
                            	  3867: *-----------------------------------------------------------
                            	  3868: *-----------------------------------------------------------
                            	  3869: * OPCODE : ABCD
                            	  3870: *-----------------------------------------------------------
                            	  3871: *-----------------------------------------------------------
                            	  3872: op_ABCD:
                            	  3873: 
                            	  3874: *     Test with X Flag CLEARED
00:00002BDC 307C0110        	  3875:                 move.l #$00000110,a0 * Address pointer-X
00:00002BE0 327C0120        	  3876:                 move.l #$00000120,a1 * Address pointer-Y
00:00002BE4 7000            	  3877:                 moveq  #$00000000,d0 * BCD byte-X
00:00002BE6 7200            	  3878:                 moveq  #$00000000,d1 * BCD byte-Y
00:00002BE8 7400            	  3879:                 moveq  #$00000000,d2
00:00002BEA 7600            	  3880:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00002BEC 7800            	  3881:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00002BEE 7A00            	  3882:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00002BF0 2C3C00000099    	  3883:                 move.l #$00000099,d6 * Inner loop counter
00:00002BF6 2E3C00000099    	  3884:                 move.l #$00000099,d7 * Outer loop counter
                            	  3885: 
00:00002BFC 2007            	  3886: ABCD_OUTER1:    move.l d7,d0
00:00002BFE 2206            	  3887: ABCD_INNER1:    move.l d6,d1
00:00002C00 023C00EF        	  3888:                 andi.b #$EF,CCR     * Clear X Flag
00:00002C04 307C0110        	  3889:                 move.l #$00000110,a0 * Address pointer-X
00:00002C08 327C0120        	  3890:                 move.l #$00000120,a1 * Address pointer-Y
00:00002C0C 1140FFFF        	  3891:                 move.b d0,-1(a0)
00:00002C10 1341FFFF        	  3892:                 move.b d1,-1(a1)
                            	  3893: 
00:00002C14 C300            	  3894:                 abcd d0,d1
00:00002C16 6402            	  3895:                 bcc.s ABCD_NO_C1          * Check C Flag  bcc/bcs 0
00:00002C18 5284            	  3896:                 add.l #1,d4
00:00002C1A DA81            	  3897: ABCD_NO_C1:     add.l d1,d5
                            	  3898: 
00:00002C1C C308            	  3899:                 abcd -(a0),-(a1)
00:00002C1E 6402            	  3900:                 bcc.s ABCD_NO_C2          * Check C Flag  bcc/bcs 0
00:00002C20 5284            	  3901:                 add.l #1,d4
00:00002C22 D611            	  3902: ABCD_NO_C2:     add.b (a1),d3
                            	  3903: 
                            	  3904: 
00:00002C24 51CEFFD8        	  3905:                 dbf d6,ABCD_INNER1
00:00002C28 2C3C00000099    	  3906:                 move.l #$00000099,d6
00:00002C2E 51CFFFCC        	  3907:                 dbf d7,ABCD_OUTER1
00:00002C32 0C8400005AFC    	  3908:                 cmpi.l #$00005AFC,d4  * Check the cumulative results
00:00002C38 66FE            	  3909:                 bne.s *
00:00002C3A 0C85001C9A34    	  3910:                 cmpi.l #$001C9A34,d5
00:00002C40 66FE            	  3911:                 bne.s *
00:00002C42 0C8300000034    	  3912:                 cmpi.l #$00000034,d3
00:00002C48 66FE            	  3913:                 bne.s *
                            	  3914: 
                            	  3915: *     Test with X Flag SET
00:00002C4A 307C0110        	  3916:                 move.l #$00000110,a0 * Address pointer-X
00:00002C4E 327C0120        	  3917:                 move.l #$00000120,a1 * Address pointer-Y
00:00002C52 7000            	  3918:                 moveq  #$00000000,d0 * BCD byte-X
00:00002C54 7200            	  3919:                 moveq  #$00000000,d1 * BCD byte-Y
00:00002C56 7400            	  3920:                 moveq  #$00000000,d2
00:00002C58 7600            	  3921:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00002C5A 7800            	  3922:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00002C5C 7A00            	  3923:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00002C5E 2C3C00000099    	  3924:                 move.l #$00000099,d6 * Inner loop counter
00:00002C64 2E3C00000099    	  3925:                 move.l #$00000099,d7 * Outer loop counter
                            	  3926: 
00:00002C6A 2007            	  3927: ABCD_OUTER2:    move.l d7,d0
00:00002C6C 2206            	  3928: ABCD_INNER2:    move.l d6,d1
00:00002C6E 003C0010        	  3929:                 ori.b #$10,CCR      * Set X Flag
00:00002C72 307C0110        	  3930:                 move.l #$00000110,a0 * Address pointer-X
00:00002C76 327C0120        	  3931:                 move.l #$00000120,a1 * Address pointer-Y
00:00002C7A 1140FFFF        	  3932:                 move.b d0,-1(a0)
00:00002C7E 1341FFFF        	  3933:                 move.b d1,-1(a1)
                            	  3934: 
00:00002C82 C300            	  3935:                 abcd d0,d1
00:00002C84 6402            	  3936:                 bcc.s ABCD_NO_C3          * Check C Flag  bcc/bcs 0
00:00002C86 5284            	  3937:                 add.l #1,d4
00:00002C88 DA81            	  3938: ABCD_NO_C3:     add.l d1,d5
                            	  3939: 
00:00002C8A C308            	  3940:                 abcd -(a0),-(a1)
00:00002C8C 6402            	  3941:                 bcc.s ABCD_NO_C4          * Check C Flag  bcc/bcs 0
00:00002C8E 5284            	  3942:                 add.l #1,d4
00:00002C90 D611            	  3943: ABCD_NO_C4:     add.b (a1),d3
                            	  3944: 
                            	  3945: 
00:00002C92 51CEFFD8        	  3946:                 dbf d6,ABCD_INNER2
00:00002C96 2C3C00000099    	  3947:                 move.l #$00000099,d6
00:00002C9C 51CFFFCC        	  3948:                 dbf d7,ABCD_OUTER2
00:00002CA0 0C8400005B60    	  3949:                 cmpi.l #$00005B60,d4  * Check the cumulative results
00:00002CA6 66FE            	  3950:                 bne.s *
00:00002CA8 0C85001CCFC8    	  3951:                 cmpi.l #$001CCFC8,d5
00:00002CAE 66FE            	  3952:                 bne.s *
00:00002CB0 0C8300000034    	  3953:                 cmpi.l #$00000034,d3
00:00002CB6 66FE            	  3954:                 bne.s *
                            	  3955: 
                            	  3956: *             Quick check of Z Flag
00:00002CB8 4200            	  3957:                 move.b #$00,d0
00:00002CBA 4201            	  3958:                 move.b #$00,d1
00:00002CBC 44FC0000        	  3959:                 move #$00,CCR              * Set Z flag to 0
00:00002CC0 C101            	  3960:                 abcd d1,d0                  * Should NOT set Z Flag to 1
00:00002CC2 67FE            	  3961:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3962: 
00:00002CC4 103C0001        	  3963:                 move.b #$01,d0
00:00002CC8 4201            	  3964:                 move.b #$00,d1
00:00002CCA 44FC0004        	  3965:                 move #$04,CCR              * Set Z flag to 0
00:00002CCE C101            	  3966:                 abcd d1,d0                  * Should NOT set Z Flag to 1
00:00002CD0 67FE            	  3967:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3968: 
00:00002CD2 4E75            	  3969:                 rts
                            	  3970: 
                            	  3971: *-----------------------------------------------------------
                            	  3972: *-----------------------------------------------------------
                            	  3973: * OPCODE : SBCD
                            	  3974: *-----------------------------------------------------------
                            	  3975: *-----------------------------------------------------------
                            	  3976: op_SBCD:
                            	  3977: 
                            	  3978: *     Test with X Flag CLEARED
00:00002CD4 307C0110        	  3979:                 move.l #$00000110,a0 * Address pointer-X
00:00002CD8 327C0120        	  3980:                 move.l #$00000120,a1 * Address pointer-Y
00:00002CDC 7000            	  3981:                 moveq  #$00000000,d0 * BCD byte-X
00:00002CDE 7200            	  3982:                 moveq  #$00000000,d1 * BCD byte-Y
00:00002CE0 7400            	  3983:                 moveq  #$00000000,d2
00:00002CE2 7600            	  3984:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00002CE4 7800            	  3985:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00002CE6 7A00            	  3986:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00002CE8 2C3C00000099    	  3987:                 move.l #$00000099,d6 * Inner loop counter
00:00002CEE 2E3C00000099    	  3988:                 move.l #$00000099,d7 * Outer loop counter
                            	  3989: 
00:00002CF4 2007            	  3990: SBCD_OUTER1:    move.l d7,d0
00:00002CF6 2206            	  3991: SBCD_INNER1:    move.l d6,d1
00:00002CF8 023C00EF        	  3992:                 andi.b #$EF,CCR     * Clear X Flag
00:00002CFC 307C0110        	  3993:                 move.l #$00000110,a0 * Address pointer-X
00:00002D00 327C0120        	  3994:                 move.l #$00000120,a1 * Address pointer-Y
00:00002D04 1140FFFF        	  3995:                 move.b d0,-1(a0)
00:00002D08 1341FFFF        	  3996:                 move.b d1,-1(a1)
                            	  3997: 
00:00002D0C 8300            	  3998:                 sbcd d0,d1
00:00002D0E 6402            	  3999:                 bcc.s SBCD_NO_C1          * Check C Flag  bcc/bcs 0
00:00002D10 5284            	  4000:                 add.l #1,d4
00:00002D12 DA81            	  4001: SBCD_NO_C1:     add.l d1,d5
                            	  4002: 
00:00002D14 8308            	  4003:                 sbcd -(a0),-(a1)
00:00002D16 6402            	  4004:                 bcc.s SBCD_NO_C2          * Check C Flag  bcc/bcs 0
00:00002D18 5284            	  4005:                 add.l #1,d4
00:00002D1A D611            	  4006: SBCD_NO_C2:     add.b (a1),d3
                            	  4007: 
                            	  4008: 
00:00002D1C 51CEFFD8        	  4009:                 dbf d6,SBCD_INNER1
00:00002D20 2C3C00000099    	  4010:                 move.l #$00000099,d6
00:00002D26 51CFFFCC        	  4011:                 dbf d7,SBCD_OUTER1
00:00002D2A 0C8400005C0A    	  4012:                 cmpi.l #$00005C0A,d4  * Check the cumulative results
00:00002D30 66FE            	  4013:                 bne.s *
00:00002D32 0C85001C459E    	  4014:                 cmpi.l #$001C459E,d5
00:00002D38 66FE            	  4015:                 bne.s *
00:00002D3A 0C830000009E    	  4016:                 cmpi.l #$0000009E,d3
00:00002D40 66FE            	  4017:                 bne.s *
                            	  4018: 
                            	  4019: *     Test with X Flag SET
00:00002D42 307C0110        	  4020:                 move.l #$00000110,a0 * Address pointer-X
00:00002D46 327C0120        	  4021:                 move.l #$00000120,a1 * Address pointer-Y
00:00002D4A 7000            	  4022:                 moveq  #$00000000,d0 * BCD byte-X
00:00002D4C 7200            	  4023:                 moveq  #$00000000,d1 * BCD byte-Y
00:00002D4E 7400            	  4024:                 moveq  #$00000000,d2
00:00002D50 7600            	  4025:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00002D52 7800            	  4026:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00002D54 7A00            	  4027:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00002D56 2C3C00000099    	  4028:                 move.l #$00000099,d6 * Inner loop counter
00:00002D5C 2E3C00000099    	  4029:                 move.l #$00000099,d7 * Outer loop counter
                            	  4030: 
00:00002D62 2007            	  4031: SBCD_OUTER2:    move.l d7,d0
00:00002D64 2206            	  4032: SBCD_INNER2:    move.l d6,d1
00:00002D66 003C0010        	  4033:                 ori.b #$10,CCR      * Set X Flag
00:00002D6A 307C0110        	  4034:                 move.l #$00000110,a0 * Address pointer-X
00:00002D6E 327C0120        	  4035:                 move.l #$00000120,a1 * Address pointer-Y
00:00002D72 1140FFFF        	  4036:                 move.b d0,-1(a0)
00:00002D76 1341FFFF        	  4037:                 move.b d1,-1(a1)
                            	  4038: 
00:00002D7A 8300            	  4039:                 sbcd d0,d1
00:00002D7C 6402            	  4040:                 bcc.s SBCD_NO_C3          * Check C Flag  bcc/bcs 0
00:00002D7E 5284            	  4041:                 add.l #1,d4
00:00002D80 DA81            	  4042: SBCD_NO_C3:     add.l d1,d5
                            	  4043: 
00:00002D82 8308            	  4044:                 sbcd -(a0),-(a1)
00:00002D84 6402            	  4045:                 bcc.s SBCD_NO_C4          * Check C Flag  bcc/bcs 0
00:00002D86 5284            	  4046:                 add.l #1,d4
00:00002D88 D611            	  4047: SBCD_NO_C4:     add.b (a1),d3
                            	  4048: 
00:00002D8A 51CEFFD8        	  4049:                 dbf d6,SBCD_INNER2
00:00002D8E 2C3C00000099    	  4050:                 move.l #$00000099,d6
00:00002D94 51CFFFCC        	  4051:                 dbf d7,SBCD_OUTER2
00:00002D98 0C8400005CA4    	  4052:                 cmpi.l #$00005CA4,d4  * Check the cumulative results
00:00002D9E 66FE            	  4053:                 bne.s *
00:00002DA0 0C85001C5C66    	  4054:                 cmpi.l #$001C5C66,d5
00:00002DA6 66FE            	  4055:                 bne.s *
00:00002DA8 0C830000009E    	  4056:                 cmpi.l #$0000009E,d3
00:00002DAE 66FE            	  4057:                 bne.s *
                            	  4058: 
                            	  4059: 
                            	  4060: *             Quick check of Z Flag
00:00002DB0 4200            	  4061:                 move.b #$00,d0
00:00002DB2 4201            	  4062:                 move.b #$00,d1
00:00002DB4 44FC0000        	  4063:                 move #$00,CCR              * Set Z flag to 0
00:00002DB8 8101            	  4064:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
00:00002DBA 67FE            	  4065:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4066: 
00:00002DBC 103C0001        	  4067:                 move.b #$01,d0
00:00002DC0 4201            	  4068:                 move.b #$00,d1
00:00002DC2 44FC0004        	  4069:                 move #$04,CCR              * Set Z flag to 0
00:00002DC6 8101            	  4070:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
00:00002DC8 67FE            	  4071:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4072: 
00:00002DCA 4E75            	  4073:                 rts
                            	  4074: 
                            	  4075: *-----------------------------------------------------------
                            	  4076: *-----------------------------------------------------------
                            	  4077: * OPCODE : NBCD
                            	  4078: *-----------------------------------------------------------
                            	  4079: *-----------------------------------------------------------
                            	  4080: op_NBCD:
                            	  4081: 
                            	  4082: *        NBCD to a  Register
                            	  4083: 
00:00002DCC 7000            	  4084:                 moveq  #$00000000,d0 * BCD byte
00:00002DCE 7200            	  4085:                 moveq  #$00000000,d1
00:00002DD0 7400            	  4086:                 moveq  #$00000000,d2
00:00002DD2 7600            	  4087:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
00:00002DD4 7800            	  4088:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00002DD6 7A00            	  4089:                 moveq  #$00000000,d5 * Cumulative BCD results
00:00002DD8 2C3C00000099    	  4090:                 move.l #$00000099,d6
00:00002DDE 2E3C00000099    	  4091:                 move.l #$00000099,d7 * Loop counter
                            	  4092: 
00:00002DE4 2007            	  4093: NBCD_LOOP:      move.l d7,d0
00:00002DE6 44FC0004        	  4094:                 move #$04,CCR        * Set Z flag to 0
                            	  4095: 
00:00002DEA 4800            	  4096:                 nbcd d0
                            	  4097: 
00:00002DEC 6402            	  4098:                 bcc.s NBCD_NO_C         * Check C Flag
00:00002DEE 5284            	  4099:                 add.l #1,d4
00:00002DF0 6602            	  4100: NBCD_NO_C:      bne.s NBCD_NO_Z         * Check Z Flag
00:00002DF2 5283            	  4101:                 add.l #1,d3
00:00002DF4 DA80            	  4102: NBCD_NO_Z:      add.l d0,d5         * Add results into d5
                            	  4103: 
00:00002DF6 51CFFFEC        	  4104:                 dbf d7,NBCD_LOOP
                            	  4105: 
00:00002DFA 0C8300000001    	  4106:                 cmpi.l #$00000001,d3  * Check the cumulative results
00:00002E00 66FE            	  4107:                 bne.s *
00:00002E02 0C8400000099    	  4108:                 cmpi.l #$00000099,d4
00:00002E08 66FE            	  4109:                 bne.s *
00:00002E0A 0C8500002E3B    	  4110:                 cmpi.l #$00002E3B,d5
00:00002E10 66FE            	  4111:                 bne.s *
                            	  4112: 
                            	  4113: 
                            	  4114: *        NBCD to a memory location
                            	  4115: 
00:00002E12 7000            	  4116:                 moveq  #$00000000,d0 * BCD byte
00:00002E14 7200            	  4117:                 moveq  #$00000000,d1
00:00002E16 7400            	  4118:                 moveq  #$00000000,d2
00:00002E18 7600            	  4119:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
00:00002E1A 7800            	  4120:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00002E1C 7A00            	  4121:                 moveq  #$00000000,d5 * Cumulative BCD results
00:00002E1E 2C3C00000099    	  4122:                 move.l #$00000099,d6
00:00002E24 2E3C00000099    	  4123:                 move.l #$00000099,d7 * Loop counter
                            	  4124: 
00:00002E2A 11C70100        	  4125: NBCD_LOOP1:     move.b d7,$00000100
00:00002E2E 44FC0004        	  4126:                 move #$04,CCR        * Set Z flag to 0
                            	  4127: 
00:00002E32 48380100        	  4128:                 nbcd $00000100
00:00002E36 10380100        	  4129:                 move.b $00000100,d0
                            	  4130: 
00:00002E3A 6402            	  4131:                 bcc.s NBCD_NO_C1        * Check C Flag
00:00002E3C 5284            	  4132:                 add.l #1,d4
00:00002E3E 6602            	  4133: NBCD_NO_C1:     bne.s NBCD_NO_Z1        * Check Z Flag
00:00002E40 5283            	  4134:                 add.l #1,d3
00:00002E42 DA80            	  4135: NBCD_NO_Z1:     add.l d0,d5         * Add results into d5
                            	  4136: 
00:00002E44 51CFFFE4        	  4137:                 dbf d7,NBCD_LOOP1
                            	  4138: 
00:00002E48 0C8300000001    	  4139:                 cmpi.l #$00000001,d3  * Check the cumulative results
00:00002E4E 66FE            	  4140:                 bne.s *
00:00002E50 4A84            	  4141:                 cmpi.l #$00000000,d4
00:00002E52 66FE            	  4142:                 bne.s *
00:00002E54 0C8500002E3B    	  4143:                 cmpi.l #$00002E3B,d5
00:00002E5A 66FE            	  4144:                 bne.s *
                            	  4145: 
                            	  4146: 
00:00002E5C 4E75            	  4147:                 rts
                            	  4148: 
                            	  4149: 
                            	  4150: 
                            	  4151: *-----------------------------------------------------------
                            	  4152: *-----------------------------------------------------------
                            	  4153: * OPCODE : TRAPV
                            	  4154: *-----------------------------------------------------------
                            	  4155: *-----------------------------------------------------------
                            	  4156: op_TRAPV:
                            	  4157: 
                            	  4158: *     TRAPV will set d0 to 12345678 if V flag is set
                            	  4159: 
00:00002E5E 7000            	  4160:                 moveq  #$00000000,d0 * Clear d0
                            	  4161: 
00:00002E60 44FC0000        	  4162:                 move #$00,CCR        * Clear V flag
00:00002E64 4E76            	  4163:                 trapv
00:00002E66 4A80            	  4164:                 cmpi.l #$00000000,d0  * Check of d0 was updated (should not be_)
00:00002E68 66FE            	  4165:                 bne.s *
                            	  4166: 
00:00002E6A 44FC0002        	  4167:                 move #$02,CCR        * Set V flag
00:00002E6E 4E76            	  4168:                 trapv
00:00002E70 0C8012345678    	  4169:                 cmpi.l #$12345678,d0  * Check of d0 was updated (should not be_)
00:00002E76 66FE            	  4170:                 bne.s *
                            	  4171: 
                            	  4172: 
00:00002E78 4E75            	  4173:                 rts
                            	  4174: 
                            	  4175: 
                            	  4176: 
                            	  4177: *-----------------------------------------------------------
                            	  4178: *-----------------------------------------------------------
                            	  4179: * OPCODE : RTR
                            	  4180: *-----------------------------------------------------------
                            	  4181: *-----------------------------------------------------------
                            	  4182: 
                            	  4183: op_RTR:
                            	  4184: 
                            	  4185: *     Leventhal claims only 5 LSB's are popped from the stack to the CCR
                            	  4186: 
00:00002E7A 41FA000A        	  4187:                 lea 		RTR_DONE,a0
00:00002E7E 2F08            	  4188:                 move.l 	a0,-(a7)     * push destination PC to the stack
00:00002E80 3F3CFF15        	  4189:                 move.w 	#$FF15,-(a7)       * push flags=0xFFFF to the stack
00:00002E84 4E77            	  4190:                 rtr
                            	  4191: 
00:00002E86 40C0            	  4192: RTR_DONE:       move.w SR,d0
00:00002E88 0240001F        	  4193:                 andi.w #$1F,d0
00:00002E8C 0C400015        	  4194:                 cmpi.w #$15,d0
00:00002E90 66FE            	  4195:                 bne.s *
                            	  4196: 
00:00002E92 4E75            	  4197:                 rts
                            	  4198: 
                            	  4199: 
00:00002E94 283C44444444    	  4200: BSR_FAR2:       move.l #$44444444,d4
00:00002E9A 4E75            	  4201:                 rts
                            	  4202: 
                            	  4203: 
                            	  4204: *-----------------------------------------------------------
                            	  4205: *-----------------------------------------------------------
                            	  4206: * OPCODE : BCC
                            	  4207: *-----------------------------------------------------------
                            	  4208: *-----------------------------------------------------------
                            	  4209: 
00:00002E9C 44FC0000        	  4210: op_BCC:         move #$00,CCR
00:00002EA0 6202            	  4211:                 bhi.s BCC1            * Higher Than         C=0 AND Z=0
00:00002EA2 60FE            	  4212:                 bra.s *
                            	  4213: 
00:00002EA4 44FC0001        	  4214: BCC1:           move #$01,CCR
00:00002EA8 63000004        	  4215:                 bls.w BCC2            * Lower or Same       C=1 OR Z=1
00:00002EAC 60FE            	  4216:                 bra.s *
                            	  4217: 
00:00002EAE 44FC0000        	  4218: BCC2:           move #$00,CCR
00:00002EB2 6402            	  4219:                 bcc.s BCC3            * Carry Clear         C=0
00:00002EB4 60FE            	  4220:                 bra.s *
                            	  4221: 
00:00002EB6 44FC0001        	  4222: BCC3:           move #$01,CCR
00:00002EBA 65000004        	  4223:                 bcs.w BCC4            * Carry Set           C=1
00:00002EBE 60FE            	  4224:                 bra.s *
                            	  4225: 
00:00002EC0 44FC0000        	  4226: BCC4:           move #$00,CCR
00:00002EC4 6602            	  4227:                 bne.s BCC5            * Not Equal           Z=0
00:00002EC6 60FE            	  4228:                 bra.s *
                            	  4229: 
00:00002EC8 44FC0004        	  4230: BCC5:           move #$04,CCR
00:00002ECC 67000004        	  4231:                 beq.w BCC6            * Equal               Z=1
00:00002ED0 60FE            	  4232:                 bra.s *
                            	  4233: 
00:00002ED2 44FC0000        	  4234: BCC6:           move #$00,CCR
00:00002ED6 6802            	  4235:                 bvc.s BCC7            * V Clear             V=0
00:00002ED8 60FE            	  4236:                 bra.s *
                            	  4237: 
00:00002EDA 44FC0002        	  4238: BCC7:           move #$02,CCR
00:00002EDE 69000004        	  4239:                 bvs.w BCC8            * V Set               V=1
00:00002EE2 60FE            	  4240:                 bra.s *
                            	  4241: 
00:00002EE4 44FC0000        	  4242: BCC8:           move #$00,CCR
00:00002EE8 6A02            	  4243:                 bpl.s BCC9            * Plus                N=0
00:00002EEA 60FE            	  4244:                 bra.s *
                            	  4245: 
00:00002EEC 44FC0008        	  4246: BCC9:           move #$08,CCR
00:00002EF0 6B000004        	  4247:                 bmi.w BCC10           * Minus               N=1
00:00002EF4 60FE            	  4248:                 bra.s *
                            	  4249: 
00:00002EF6 44FC0000        	  4250: BCC10:          move #$00,CCR
00:00002EFA 6C02            	  4251:                 bge.s BCC11           * Greater or Equal    N=V
00:00002EFC 60FE            	  4252:                 bra.s *
                            	  4253: 
00:00002EFE 44FC0002        	  4254: BCC11:          move #$02,CCR
00:00002F02 6D000004        	  4255:                 blt.w BCC12           * Less Than           N!=V
00:00002F06 60FE            	  4256:                 bra.s *
                            	  4257: 
00:00002F08 44FC000A        	  4258: BCC12:          move #$0A,CCR
00:00002F0C 6E02            	  4259:                 bgt.s BCC13           * Greater Than        N=V  AND Z=0
00:00002F0E 60FE            	  4260:                 bra.s *
                            	  4261: 
00:00002F10 44FC0006        	  4262: BCC13:          move #$06,CCR
00:00002F14 6F000004        	  4263:                 ble.w BCC14           * Less Than or Equal  N!=V AND Z=1
00:00002F18 60FE            	  4264:                 bra.s *
                            	  4265: 
                            	  4266: 
00:00002F1A 4E75            	  4267: BCC14:          rts
                            	  4268: 
                            	  4269: 
                            	  4270: *-----------------------------------------------------------
                            	  4271: *-----------------------------------------------------------
                            	  4272: * OPCODE : DBCC
                            	  4273: *-----------------------------------------------------------
                            	  4274: *-----------------------------------------------------------
                            	  4275: 
00:00002F1C 7003            	  4276: op_DBCC:        moveq  #$00000003,d0    * Loop counter
00:00002F1E 7200            	  4277:                 moveq  #$00000000,d1    * Accumulator
00:00002F20 44FC0000        	  4278:                 move #$00,CCR
                            	  4279: 
00:00002F24 5201            	  4280: DBCC_LOOP1:     addi.b #$1,d1
00:00002F26 51C8FFFC        	  4281:                 dbf d0,DBCC_LOOP1
                            	  4282: 
00:00002F2A 0C8100000004    	  4283:                 cmpi.l #$00000004,d1  * Check Accumulator results
00:00002F30 66FE            	  4284:                 bne.s *
                            	  4285: 
00:00002F32 5201            	  4286: DBCC_LOOP2:     addi.b #$1,d1
00:00002F34 54C8FFFC        	  4287:                 dbcc d0,DBCC_LOOP2    * Dont loop
                            	  4288: 
00:00002F38 0C8100000005    	  4289:                 cmpi.l #$00000005,d1  * Check Accumulator results
00:00002F3E 66FE            	  4290:                 bne.s *
                            	  4291: 
00:00002F40 4E75            	  4292:                 rts
                            	  4293: 
                            	  4294: 
                            	  4295: *-----------------------------------------------------------
                            	  4296: *-----------------------------------------------------------
                            	  4297: * OPCODE : SCC
                            	  4298: *-----------------------------------------------------------
                            	  4299: *-----------------------------------------------------------
                            	  4300: 
00:00002F42 44FC0001        	  4301: op_SCC:         move #$01,CCR
00:00002F46 54F900010000    	  4302:                 scc $00010000                   * Clear the EA byte
00:00002F4C 4A3900010000    	  4303:                 cmpi.b #$00,$00010000
00:00002F52 66FE            	  4304:                 bne.s *
                            	  4305: 
00:00002F54 44FC0000        	  4306:                 move #$00,CCR
00:00002F58 54F900010000    	  4307:                 scc $00010000                   * Set the EA byte to 0xFF
00:00002F5E 0C3900FF00010000	  4308:                 cmpi.b #$FF,$00010000
00:00002F66 66FE            	  4309:                 bne.s *
                            	  4310: 
00:00002F68 54C0            	  4311: 								scc d0													* Test setting a data register
00:00002F6A 0C0000FF        	  4312: 								cmpi.b #$FF,d0
00:00002F6E 66FE            	  4313: 								bne.s *
00:00002F70 4E75            	  4314:                 rts
                            	  4315: 
                            	  4316: 
                            	  4317: 
                            	  4318: *-----------------------------------------------------------
                            	  4319: *-----------------------------------------------------------
                            	  4320: * OPCODE : ADDQ
                            	  4321: *-----------------------------------------------------------
                            	  4322: *-----------------------------------------------------------
                            	  4323: 
                            	  4324: op_ADDQ:
                            	  4325: 
                            	  4326: *     BYTE
00:00002F72 203C000000FF    	  4327:                 move.l #$000000FF,d0    * Loop counter
00:00002F78 7200            	  4328:                 moveq  #$00000000,d1    * Flag results accumulator
00:00002F7A 7400            	  4329:                 moveq  #$00000000,d2    * Data results accumulator
00:00002F7C 7600            	  4330:                 moveq  #$00000000,d3
00:00002F7E 7800            	  4331:                 moveq  #$00000000,d4
00:00002F80 7A00            	  4332:                 moveq  #$00000000,d5
00:00002F82 7C00            	  4333:                 moveq  #$00000000,d6
00:00002F84 7E00            	  4334:                 moveq  #$00000000,d7
                            	  4335: 
00:00002F86 5605            	  4336: ADDQ_LOOP1:     addq.b #3,d5
00:00002F88 40C6            	  4337:                 move.w SR,d6
00:00002F8A 02860000001F    	  4338:                 andi.l #$1F,d6        * Isolate flags
00:00002F90 D286            	  4339:                 add.l d6,d1           * Copy flag results into accumulator
00:00002F92 D485            	  4340:                 add.l d5,d2           * Copy data results into data accumulator
00:00002F94 51C8FFF0        	  4341:                 dbf d0,ADDQ_LOOP1
                            	  4342: 
00:00002F98 0C810000043D    	  4343:                 cmpi.l #$0000043D,d1
00:00002F9E 66FE            	  4344:                 bne.s *
00:00002FA0 0C8200007F80    	  4345:                 cmpi.l #$00007F80,d2
00:00002FA6 66FE            	  4346:                 bne.s *
                            	  4347: 
                            	  4348: 
                            	  4349: *     WORD
00:00002FA8 203C000000FF    	  4350:                 move.l #$000000FF,d0    * Loop counter
00:00002FAE 7200            	  4351:                 moveq  #$00000000,d1    * Flag results accumulator
00:00002FB0 7400            	  4352:                 moveq  #$00000000,d2    * Data results accumulator
00:00002FB2 7600            	  4353:                 moveq  #$00000000,d3
00:00002FB4 7800            	  4354:                 moveq  #$00000000,d4
00:00002FB6 2A3C0000FFF0    	  4355:                 move.l #$0000FFF0,d5
00:00002FBC 7C00            	  4356:                 moveq  #$00000000,d6
00:00002FBE 7E00            	  4357:                 moveq  #$00000000,d7
00:00002FC0 307C0100        	  4358:                 move.l #$00000100,a0
                            	  4359: 
00:00002FC4 5A45            	  4360: ADDQ_LOOP2:     addq.w #5,d5
00:00002FC6 40C6            	  4361:                 move.w SR,d6
00:00002FC8 02860000001F    	  4362:                 andi.l #$1F,d6        * Isolate flags
00:00002FCE D286            	  4363:                 add.l d6,d1           * Copy flag results into accumulator
00:00002FD0 D485            	  4364:                 add.l d5,d2           * Copy data results into data accumulator
00:00002FD2 51C8FFF0        	  4365:                 dbf d0,ADDQ_LOOP2
                            	  4366: 
00:00002FD6 0C8100000029    	  4367:                 cmpi.l #$00000029,d1
00:00002FDC 66FE            	  4368:                 bne.s *
00:00002FDE 0C8200057280    	  4369:                 cmpi.l #$00057280,d2
00:00002FE4 66FE            	  4370:                 bne.s *
                            	  4371: 
                            	  4372: 
                            	  4373: *     LONG
00:00002FE6 203C000000FF    	  4374:                 move.l #$000000FF,d0    * Loop counter
00:00002FEC 7200            	  4375:                 moveq  #$00000000,d1    * Flag results accumulator
00:00002FEE 7400            	  4376:                 moveq  #$00000000,d2    * Data results accumulator
00:00002FF0 7600            	  4377:                 moveq  #$00000000,d3
00:00002FF2 7800            	  4378:                 moveq  #$00000000,d4
00:00002FF4 7AF0            	  4379:                 move.l #$FFFFFFF0,d5
00:00002FF6 7C00            	  4380:                 moveq  #$00000000,d6
00:00002FF8 7E00            	  4381:                 moveq  #$00000000,d7
                            	  4382: 
00:00002FFA 5285            	  4383: ADDQ_LOOP3:     addq.l #1,d5
00:00002FFC 40C6            	  4384:                 move.w SR,d6
00:00002FFE 02860000001F    	  4385:                 andi.l #$1F,d6        * Isolate flags
00:00003004 D286            	  4386:                 add.l d6,d1           * Copy flag results into accumulator
00:00003006 D485            	  4387:                 add.l d5,d2           * Copy data results into data accumulator
00:00003008 51C8FFF0        	  4388:                 dbf d0,ADDQ_LOOP3
                            	  4389: 
00:0000300C 0C810000008D    	  4390:                 cmpi.l #$0000008D,d1
00:00003012 66FE            	  4391:                 bne.s *
00:00003014 0C8200007080    	  4392:                 cmpi.l #$00007080,d2
00:0000301A 66FE            	  4393:                 bne.s *
                            	  4394: 
                            	  4395: *     Check that Flags are not updated for Address registers
00:0000301C 207C0000FFFF    	  4396:                 move.l #$0000FFFF,a0
00:00003022 44FC0000        	  4397:                 move #$00,CCR         * Clear flags
00:00003026 5E48            	  4398:                 addq.w #$7,a0
00:00003028 65FE            	  4399:                 bcs.s *
                            	  4400: 
00:0000302A 4E75            	  4401:                 rts
                            	  4402: 
                            	  4403: 
                            	  4404: 
                            	  4405: *-----------------------------------------------------------
                            	  4406: *-----------------------------------------------------------
                            	  4407: * OPCODE : SUBQ
                            	  4408: *-----------------------------------------------------------
                            	  4409: *-----------------------------------------------------------
                            	  4410: 
                            	  4411: op_SUBQ:
                            	  4412: 
                            	  4413: *     BYTE
00:0000302C 203C000000FF    	  4414:                 move.l #$000000FF,d0    * Loop counter
00:00003032 7200            	  4415:                 moveq  #$00000000,d1    * Flag results accumulator
00:00003034 243C00001234    	  4416:                 move.l #$00001234,d2    * Data results accumulator
00:0000303A 7600            	  4417:                 moveq  #$00000000,d3
00:0000303C 7800            	  4418:                 moveq  #$00000000,d4
00:0000303E 7A12            	  4419:                 moveq  #$00000012,d5
00:00003040 7C00            	  4420:                 moveq  #$00000000,d6
00:00003042 7E00            	  4421:                 moveq  #$00000000,d7
                            	  4422: 
00:00003044 5305            	  4423: SUBQ_LOOP1:     subq.b #1,d5
00:00003046 40C6            	  4424:                 move.w SR,d6
00:00003048 02860000001F    	  4425:                 andi.l #$1F,d6        * Isolate flags
00:0000304E D286            	  4426:                 add.l d6,d1           * Copy flag results into accumulator
00:00003050 D485            	  4427:                 add.l d5,d2           * Copy data results into data accumulator
00:00003052 51C8FFF0        	  4428:                 dbf d0,SUBQ_LOOP1
                            	  4429: 
00:00003056 0C8100000417    	  4430:                 cmpi.l #$00000417,d1
00:0000305C 66FE            	  4431:                 bne.s *
00:0000305E 0C82000091B4    	  4432:                 cmpi.l #$000091B4,d2
00:00003064 66FE            	  4433:                 bne.s *
                            	  4434: 
                            	  4435: 
                            	  4436: *     WORD
00:00003066 203C000000FF    	  4437:                 move.l #$000000FF,d0    * Loop counter
00:0000306C 7200            	  4438:                 moveq  #$00000000,d1    * Flag results accumulator
00:0000306E 7400            	  4439:                 moveq  #$00000000,d2    * Data results accumulator
00:00003070 7600            	  4440:                 moveq  #$00000000,d3
00:00003072 7800            	  4441:                 moveq  #$00000000,d4
00:00003074 7A02            	  4442:                 moveq  #$00000002,d5
00:00003076 7C00            	  4443:                 moveq  #$00000000,d6
00:00003078 7E00            	  4444:                 moveq  #$00000000,d7
00:0000307A 307C0100        	  4445:                 move.l #$00000100,a0
                            	  4446: 
00:0000307E 5B45            	  4447: SUBQ_LOOP2:     subq.w #5,d5
00:00003080 40C6            	  4448:                 move.w SR,d6
00:00003082 02860000001F    	  4449:                 andi.l #$1F,d6        * Isolate flags
00:00003088 D286            	  4450:                 add.l d6,d1           * Copy flag results into accumulator
00:0000308A D485            	  4451:                 add.l d5,d2           * Copy data results into data accumulator
00:0000308C 51C8FFF0        	  4452:                 dbf d0,SUBQ_LOOP2
                            	  4453: 
00:00003090 0C8100000811    	  4454:                 cmpi.l #$00000811,d1
00:00003096 66FE            	  4455:                 bne.s *
00:00003098 0C8200FD7F80    	  4456:                 cmpi.l #$00FD7F80,d2
00:0000309E 66FE            	  4457:                 bne.s *
                            	  4458: 
                            	  4459: 
                            	  4460: *     LONG
00:000030A0 203C000000FF    	  4461:                 move.l #$000000FF,d0    * Loop counter
00:000030A6 7200            	  4462:                 moveq  #$00000000,d1    * Flag results accumulator
00:000030A8 7400            	  4463:                 moveq  #$00000000,d2    * Data results accumulator
00:000030AA 7600            	  4464:                 moveq  #$00000000,d3
00:000030AC 7800            	  4465:                 moveq  #$00000000,d4
00:000030AE 7A07            	  4466:                 moveq  #$00000007,d5
00:000030B0 7C00            	  4467:                 moveq  #$00000000,d6
00:000030B2 7E00            	  4468:                 moveq  #$00000000,d7
                            	  4469: 
00:000030B4 5385            	  4470: SUBQ_LOOP3:     subq.l #1,d5
00:000030B6 40C6            	  4471:                 move.w SR,d6
00:000030B8 02860000001F    	  4472:                 andi.l #$1F,d6        * Isolate flags
00:000030BE D286            	  4473:                 add.l d6,d1           * Copy flag results into accumulator
00:000030C0 D485            	  4474:                 add.l d5,d2           * Copy data results into data accumulator
00:000030C2 51C8FFF0        	  4475:                 dbf d0,SUBQ_LOOP3
                            	  4476: 
00:000030C6 0C81000007DD    	  4477:                 cmpi.l #$000007DD,d1
00:000030CC 66FE            	  4478:                 bne.s *
00:000030CE 0C82FFFF8680    	  4479:                 cmpi.l #$FFFF8680,d2
00:000030D4 66FE            	  4480:                 bne.s *
                            	  4481: 
                            	  4482: *     Check that Flags are not updated for Address registers
00:000030D6 207C0001FFFF    	  4483:                 move.l #$0001FFFF,a0
00:000030DC 44FC0000        	  4484:                 move #$00,CCR         * Clear flags
00:000030E0 5F48            	  4485:                 subq.w #$7,a0
00:000030E2 65FE            	  4486:                 bcs.s *
                            	  4487: 
00:000030E4 4E75            	  4488:                 rts
                            	  4489: 
                            	  4490: 
                            	  4491: 
                            	  4492: 
                            	  4493: *-----------------------------------------------------------
                            	  4494: *-----------------------------------------------------------
                            	  4495: * OPCODE : MOVEQ
                            	  4496: *-----------------------------------------------------------
                            	  4497: *-----------------------------------------------------------
                            	  4498: 
                            	  4499: op_MOVEQ:
00:000030E6 7000            	  4500:                 moveq  #$00000000,d0
00:000030E8 7000            	  4501:                 moveq #$0,d0
00:000030EA 66FE            	  4502:                 bne.s *
00:000030EC 4A80            	  4503:                 cmpi.l #$00000000,d0
00:000030EE 66FE            	  4504:                 bne.s *
                            	  4505: 
00:000030F0 7000            	  4506:                 moveq  #$00000000,d0
00:000030F2 7080            	  4507:                 moveq #-128,d0
00:000030F4 67FE            	  4508:                 beq.s *
00:000030F6 6AFE            	  4509:                 bpl.s *
00:000030F8 0C80FFFFFF80    	  4510:                 cmpi.l #$FFFFFF80,d0
00:000030FE 66FE            	  4511:                 bne.s *
                            	  4512: 
                            	  4513: 
00:00003100 4E75            	  4514:                 rts
                            	  4515: 
                            	  4516: 
                            	  4517: *-----------------------------------------------------------
                            	  4518: *-----------------------------------------------------------
                            	  4519: * OPCODE : DIVU
                            	  4520: *-----------------------------------------------------------
                            	  4521: *-----------------------------------------------------------
                            	  4522: 
                            	  4523: op_DIVU:
                            	  4524: 
00:00003102 203CA5A5A5A5    	  4525:                 move.l #$a5a5a5a5,d0        * Initial Numerator
00:00003108 223C00005A5A    	  4526:                 move.l #$00005a5a,d1        * Initial Divisor
00:0000310E 243CA5A5A5A5    	  4527:                 move.l #$a5a5a5a5,d2
00:00003114 7600            	  4528:                 moveq  #$00000000,d3
00:00003116 7800            	  4529:                 moveq  #$00000000,d4        * Cumulative data results
00:00003118 7A00            	  4530:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000311A 7C0E            	  4531:                 move.l #$0000000E,d6       * Inner loop counter
00:0000311C 7E1E            	  4532:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4533: 
                            	  4534: 
00:0000311E 80C1            	  4535: DIVU_OUTER1:    divu d1,d0               * !! Easy68K C not always cleared
00:00003120 40C3            	  4536:                 move.w SR,d3
00:00003122 02830000000C    	  4537:                 andi.l #$0C,d3            * Isolate flags
00:00003128 DA83            	  4538:                 add.l d3,d5               * Copy flag results into accumulator
00:0000312A D880            	  4539:                 add.l d0,d4               * Copy data results into data accumulator
00:0000312C E289            	  4540:                 lsr.l #$1,d1
                            	  4541: 
00:0000312E 51CEFFEE        	  4542:                 dbf d6,DIVU_OUTER1
00:00003132 E28A            	  4543:                 lsr.l #$1,d2
00:00003134 2002            	  4544:                 move.l d2,d0
00:00003136 223C00005A5A    	  4545:                 move.l #$00005a5a,d1       * Initial Divisor
00:0000313C 7C0E            	  4546:                 move.l #$0000000E,d6       * Inner loop counter
00:0000313E 51CFFFDE        	  4547:                 dbf d7,DIVU_OUTER1
                            	  4548: 
00:00003142 0C8492FEDB89    	  4549:                 cmpi.l #$92FEDB89,d4      * Check the data results
00:00003148 66FE            	  4550:                 bne.s *
                            	  4551: 
00:0000314A 0C8500000110    	  4552:                 cmpi.l #$00000110,d5      * Check the Flag results
00:00003150 66FE            	  4553:                 bne.s *
                            	  4554: 
                            	  4555: 
00:00003152 4E75            	  4556:                 rts
                            	  4557: 
                            	  4558: 
                            	  4559: 
                            	  4560: *-----------------------------------------------------------
                            	  4561: *-----------------------------------------------------------
                            	  4562: * OPCODE : DIVS
                            	  4563: *-----------------------------------------------------------
                            	  4564: *-----------------------------------------------------------
                            	  4565: 
                            	  4566: op_DIVS:
                            	  4567: 
00:00003154 203CA5A5A5A5    	  4568: 	move.l #$a5a5a5a5,d0        * Initial Numerator
00:0000315A 223C00005A5A    	  4569: 	move.l #$00005a5a,d1        * Initial Divisor
00:00003160 243CA5A5A5A5    	  4570: 	move.l #$a5a5a5a5,d2
00:00003166 7600            	  4571: 	moveq  #$00000000,d3
00:00003168 7800            	  4572: 	moveq  #$00000000,d4        * Cumulative data results
00:0000316A 7A00            	  4573: 	moveq  #$00000000,d5       * Cumulative flag results
00:0000316C 7C0E            	  4574: 	move.l #$0000000E,d6       * Inner loop counter
00:0000316E 7E1E            	  4575: 	move.l #$0000001E,d7       * Outer loop counter
                            	  4576: 
                            	  4577: DIVS_OUTER1:
00:00003170 81C1            	  4578: 	divs d1,d0               * !! Easy68K C not always cleared
00:00003172 40C3            	  4579: 	move.w SR,d3
00:00003174 02830000000C    	  4580: 	andi.l #$0C,d3            * Isolate flags
00:0000317A DA83            	  4581: 	add.l d3,d5               * Copy flag results into accumulator
00:0000317C D880            	  4582: 	add.l d0,d4               * Copy data results into data accumulator
00:0000317E E289            	  4583: 	lsr.l #$1,d1
                            	  4584: 
00:00003180 51CEFFEE        	  4585: 	dbf d6,DIVS_OUTER1
00:00003184 E28A            	  4586: 	lsr.l #$1,d2
00:00003186 2002            	  4587: 	move.l d2,d0
00:00003188 223C00005A5A    	  4588: 	move.l #$00005a5a,d1       * Initial Divisor
00:0000318E 7C0E            	  4589: 	move.l #$0000000E,d6       * Inner loop counter
00:00003190 51CFFFDE        	  4590: 	dbf d7,DIVS_OUTER1
                            	  4591: 
00:00003194 0C844EC5D057    	  4592: 	cmpi.l #$4EC5D057,d4      * Check the data results
00:0000319A 66FE            	  4593: 	bne.s *
                            	  4594: 
00:0000319C 0C8500000038    	  4595: 	cmpi.l #$00000038,d5      * Check the Flag results
00:000031A2 66FE            	  4596: 	bne.s *
00:000031A4 4E75            	  4597: 	rts
                            	  4598: 
                            	  4599: 
                            	  4600: *-----------------------------------------------------------
                            	  4601: *-----------------------------------------------------------
                            	  4602: * OPCODE : OR
                            	  4603: *-----------------------------------------------------------
                            	  4604: *-----------------------------------------------------------
                            	  4605: 
                            	  4606: op_OR:
                            	  4607: 
                            	  4608: *  * <EA> to Register
                            	  4609: 
00:000031A6 203CA5A5A5A5    	  4610:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000031AC 223C8167E123    	  4611:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:000031B2 243CA5A5A5A5    	  4612:                 move.l #$a5a5a5a5,d2
00:000031B8 7600            	  4613:                 moveq  #$00000000,d3
00:000031BA 7800            	  4614:                 moveq  #$00000000,d4       * Cumulative data results
00:000031BC 7A00            	  4615:                 moveq  #$00000000,d5       * Cumulative flag results
00:000031BE 7C1E            	  4616:                 move.l #$0000001E,d6       * Inner loop counter
00:000031C0 7E1E            	  4617:                 move.l #$0000001E,d7       * Outer loop counter
00:000031C2 307C0100        	  4618:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4619: 
                            	  4620: 
                            	  4621: OR_OUTER1:
                            	  4622: 
                            	  4623: *     BYTE
00:000031C6 2081            	  4624:                 move.l d1,(a0)
00:000031C8 8010            	  4625:                 or.b (a0),d0
00:000031CA 40C3            	  4626:                 move.w SR,d3
00:000031CC 02830000000C    	  4627:                 andi.l #$0C,d3            * Isolate flags
00:000031D2 DA83            	  4628:                 add.l d3,d5               * Copy flag results into accumulator
00:000031D4 D880            	  4629:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4630: 
                            	  4631: *     WORD
00:000031D6 2081            	  4632:                 move.l d1,(a0)
00:000031D8 8050            	  4633:                 or.w (a0),d0
00:000031DA 40C3            	  4634:                 move.w SR,d3
00:000031DC 02830000000C    	  4635:                 andi.l #$0C,d3            * Isolate flags
00:000031E2 DA83            	  4636:                 add.l d3,d5               * Copy flag results into accumulator
00:000031E4 D880            	  4637:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4638: 
                            	  4639: *     LONG
00:000031E6 2081            	  4640:                 move.l d1,(a0)
00:000031E8 8090            	  4641:                 or.l (a0),d0
00:000031EA 40C3            	  4642:                 move.w SR,d3
00:000031EC 02830000000F    	  4643:                 andi.l #$0F,d3            * Isolate flags
00:000031F2 DA83            	  4644:                 add.l d3,d5               * Copy flag results into accumulator
00:000031F4 D880            	  4645:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4646: 
                            	  4647: 
00:000031F6 E289            	  4648:                 lsr.l #$1,d1
00:000031F8 51CEFFCC        	  4649:                 dbf d6,OR_OUTER1
00:000031FC E28A            	  4650:                 lsr.l #$1,d2
00:000031FE 223C8167E123    	  4651:                 move.l #$8167E123,d1       * Initial Data-Y
00:00003204 7C1E            	  4652:                 move.l #$0000001E,d6       * Inner loop counter
00:00003206 51CFFFBE        	  4653:                 dbf d7,OR_OUTER1
                            	  4654: 
00:0000320A 0C8476EAC803    	  4655:                 cmpi.l #$76EAC803,d4      * Check the data results
00:00003210 66FE            	  4656:                 bne.s *
00:00003212 0C8500005A18    	  4657:                 cmpi.l #$00005A18,d5      * Check the Flag results
00:00003218 66FE            	  4658:                 bne.s *
                            	  4659: 
                            	  4660: 
                            	  4661: *  * Register to <EA>
                            	  4662: 
00:0000321A 203C86738374    	  4663:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:00003220 223CFC55F2FE    	  4664:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:00003226 243C86738374    	  4665:                 move.l #$86738374,d2
00:0000322C 7600            	  4666:                 moveq  #$00000000,d3
00:0000322E 7800            	  4667:                 moveq  #$00000000,d4       * Cumulative data results
00:00003230 7A00            	  4668:                 moveq  #$00000000,d5       * Cumulative flag results
00:00003232 7C1E            	  4669:                 move.l #$0000001E,d6       * Inner loop counter
00:00003234 7E1D            	  4670:                 move.l #$0000001D,d7       * Outer loop counter
00:00003236 307C0100        	  4671:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4672: 
                            	  4673: 
                            	  4674: OR_OUTER2:
                            	  4675: 
                            	  4676: *     BYTE
00:0000323A 2080            	  4677:                 move.l d0,(a0)
00:0000323C 8310            	  4678:                 or.b d1,(a0)
00:0000323E 40C3            	  4679:                 move.w SR,d3
00:00003240 02830000000C    	  4680:                 andi.l #$0C,d3            * Isolate flags
00:00003246 DA83            	  4681:                 add.l d3,d5               * Copy flag results into accumulator
00:00003248 D890            	  4682:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4683: 
                            	  4684: *     WORD
00:0000324A 2080            	  4685:                 move.l d0,(a0)
00:0000324C 8350            	  4686:                 or.w d1,(a0)
00:0000324E 40C3            	  4687:                 move.w SR,d3
00:00003250 02830000000C    	  4688:                 andi.l #$0C,d3            * Isolate flags
00:00003256 DA83            	  4689:                 add.l d3,d5               * Copy flag results into accumulator
00:00003258 D890            	  4690:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4691: 
                            	  4692: *     LONG
00:0000325A 2080            	  4693:                 move.l d0,(a0)
00:0000325C 8390            	  4694:                 or.l d1,(a0)
00:0000325E 40C3            	  4695:                 move.w SR,d3
00:00003260 02830000000F    	  4696:                 andi.l #$0F,d3            * Isolate flags
00:00003266 DA83            	  4697:                 add.l d3,d5               * Copy flag results into accumulator
00:00003268 D890            	  4698:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4699: 
                            	  4700: 
00:0000326A E289            	  4701:                 lsr.l #$1,d1
00:0000326C 51CEFFCC        	  4702:                 dbf d6,OR_OUTER2
00:00003270 E28A            	  4703:                 lsr.l #$1,d2
00:00003272 223C8167E123    	  4704:                 move.l #$8167E123,d1       * Initial Data-Y
00:00003278 7C1E            	  4705:                 move.l #$0000001E,d6       * Inner loop counter
00:0000327A 51CFFFBE        	  4706:                 dbf d7,OR_OUTER2
                            	  4707: 
00:0000327E 0C84FA82B9E4    	  4708:                 cmpi.l #$FA82B9E4,d4      * Check the data results
00:00003284 66FE            	  4709:                 bne.s *
00:00003286 0C8500005730    	  4710:                 cmpi.l #$00005730,d5      * Check the Flag results
00:0000328C 66FE            	  4711:                 bne.s *
                            	  4712: 
                            	  4713: 
00:0000328E 4E75            	  4714:                 rts
                            	  4715: 
                            	  4716: 
                            	  4717: 
                            	  4718: *-----------------------------------------------------------
                            	  4719: *-----------------------------------------------------------
                            	  4720: * OPCODE : AND
                            	  4721: *-----------------------------------------------------------
                            	  4722: *-----------------------------------------------------------
                            	  4723: 
                            	  4724: op_AND:
                            	  4725: 
                            	  4726: *  * <EA> to Register
                            	  4727: 
00:00003290 203CA5A5A5A5    	  4728:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00003296 223C8167E123    	  4729:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:0000329C 243CA5A5A5A5    	  4730:                 move.l #$a5a5a5a5,d2
00:000032A2 7600            	  4731:                 moveq  #$00000000,d3
00:000032A4 7800            	  4732:                 moveq  #$00000000,d4       * Cumulative data results
00:000032A6 7A00            	  4733:                 moveq  #$00000000,d5       * Cumulative flag results
00:000032A8 7C1E            	  4734:                 move.l #$0000001E,d6       * Inner loop counter
00:000032AA 7E1E            	  4735:                 move.l #$0000001E,d7       * Outer loop counter
00:000032AC 307C0100        	  4736:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4737: 
                            	  4738: 
                            	  4739: AND_OUTER1:
                            	  4740: 
                            	  4741: *     BYTE
00:000032B0 2081            	  4742:                 move.l d1,(a0)
00:000032B2 C010            	  4743:                 and.b (a0),d0
00:000032B4 40C3            	  4744:                 move.w sr,d3
00:000032B6 02830000000C    	  4745:                 andi.l #$0C,d3            * Isolate flags
00:000032BC DA83            	  4746:                 add.l d3,d5               * Copy flag results into accumulator
00:000032BE D880            	  4747:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4748: 
                            	  4749: *     WORD
00:000032C0 2081            	  4750:                 move.l d1,(a0)
00:000032C2 C050            	  4751:                 and.w (a0),d0
00:000032C4 40C3            	  4752:                 move.w sr,d3
00:000032C6 02830000000C    	  4753:                 andi.l #$0C,d3            * Isolate flags
00:000032CC DA83            	  4754:                 add.l d3,d5               * Copy flag results into accumulator
00:000032CE D880            	  4755:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4756: 
                            	  4757: *     LONG
00:000032D0 2081            	  4758:                 move.l d1,(a0)
00:000032D2 C090            	  4759:                 and.l (a0),d0
00:000032D4 40C3            	  4760:                 move.w sr,d3
00:000032D6 02830000000F    	  4761:                 andi.l #$0F,d3            * Isolate flags
00:000032DC DA83            	  4762:                 add.l d3,d5               * Copy flag results into accumulator
00:000032DE D880            	  4763:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4764: 
                            	  4765: 
00:000032E0 E289            	  4766:                 lsr.l #$1,d1
00:000032E2 51CEFFCC        	  4767:                 dbf d6,AND_OUTER1
00:000032E6 E28A            	  4768:                 lsr.l #$1,d2
00:000032E8 223C8167E123    	  4769:                 move.l #$8167E123,d1       * Initial Data-Y
00:000032EE 7C1E            	  4770:                 move.l #$0000001E,d6       * Inner loop counter
00:000032F0 51CFFFBE        	  4771:                 dbf d7,AND_OUTER1
                            	  4772: 
00:000032F4 0C84CF212883    	  4773:                 cmpi.l #$CF212883,d4      * Check the data results
00:000032FA 66FE            	  4774:                 bne.s *
00:000032FC 0C8500002D10    	  4775:                 cmpi.l #$00002D10,d5      * Check the Flag results
00:00003302 66FE            	  4776:                 bne.s *
                            	  4777: 
                            	  4778: 
                            	  4779: *  * Register to <EA>
                            	  4780: 
00:00003304 203C86738374    	  4781:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:0000330A 223CFC55F2FE    	  4782:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:00003310 243C86738374    	  4783:                 move.l #$86738374,d2
00:00003316 7600            	  4784:                 moveq  #$00000000,d3
00:00003318 7800            	  4785:                 moveq  #$00000000,d4       * Cumulative data results
00:0000331A 7A00            	  4786:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000331C 7C1E            	  4787:                 move.l #$0000001E,d6       * Inner loop counter
00:0000331E 7E1D            	  4788:                 move.l #$0000001D,d7       * Outer loop counter
00:00003320 307C0100        	  4789:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4790: 
                            	  4791: 
                            	  4792: AND_OUTER2:
                            	  4793: 
                            	  4794: *     BYTE
00:00003324 2080            	  4795:                 move.l d0,(a0)
00:00003326 C310            	  4796:                 and.b d1,(a0)
00:00003328 40C3            	  4797:                 move.w sr,d3
00:0000332A 02830000000C    	  4798:                 andi.l #$0C,d3            * Isolate flags
00:00003330 DA83            	  4799:                 add.l d3,d5               * Copy flag results into accumulator
00:00003332 D890            	  4800:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4801: 
                            	  4802: *     WORD
00:00003334 2080            	  4803:                 move.l d0,(a0)
00:00003336 C350            	  4804:                 and.w d1,(a0)
00:00003338 40C3            	  4805:                 move.w sr,d3
00:0000333A 02830000000C    	  4806:                 andi.l #$0C,d3            * Isolate flags
00:00003340 DA83            	  4807:                 add.l d3,d5               * Copy flag results into accumulator
00:00003342 D890            	  4808:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4809: 
                            	  4810: *     LONG
00:00003344 2080            	  4811:                 move.l d0,(a0)
00:00003346 C390            	  4812:                 and.l d1,(a0)
00:00003348 40C3            	  4813:                 move.w sr,d3
00:0000334A 02830000000F    	  4814:                 andi.l #$0F,d3            * Isolate flags
00:00003350 DA83            	  4815:                 add.l d3,d5               * Copy flag results into accumulator
00:00003352 D890            	  4816:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4817: 
                            	  4818: 
00:00003354 E289            	  4819:                 lsr.l #$1,d1
00:00003356 51CEFFCC        	  4820:                 dbf d6,AND_OUTER2
00:0000335A E28A            	  4821:                 lsr.l #$1,d2
00:0000335C 223C8167E123    	  4822:                 move.l #$8167E123,d1       * Initial Data-Y
00:00003362 7C1E            	  4823:                 move.l #$0000001E,d6       * Inner loop counter
00:00003364 51CFFFBE        	  4824:                 dbf d7,AND_OUTER2
                            	  4825: 
00:00003368 0C844A3DE544    	  4826:                 cmpi.l #$4A3DE544,d4      * Check the data results
00:0000336E 66FE            	  4827:                 bne.s *
00:00003370 0C85000018E8    	  4828:                 cmpi.l #$000018E8,d5      * Check the Flag results
00:00003376 66FE            	  4829:                 bne.s *
                            	  4830: 
                            	  4831: 
00:00003378 4E75            	  4832:                 rts
                            	  4833: 
                            	  4834: 
                            	  4835: 
                            	  4836: *-----------------------------------------------------------
                            	  4837: *-----------------------------------------------------------
                            	  4838: * OPCODE : EOR
                            	  4839: *-----------------------------------------------------------
                            	  4840: *-----------------------------------------------------------
                            	  4841: 
                            	  4842: op_EOR:
                            	  4843: 
                            	  4844: *  * Register to <EA>
                            	  4845: 
00:0000337A 203C86738374    	  4846:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:00003380 223CFC55F2FE    	  4847:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:00003386 243C86738374    	  4848:                 move.l #$86738374,d2
00:0000338C 7600            	  4849:                 moveq  #$00000000,d3
00:0000338E 7800            	  4850:                 moveq  #$00000000,d4       * Cumulative data results
00:00003390 7A00            	  4851:                 moveq  #$00000000,d5       * Cumulative flag results
00:00003392 7C1E            	  4852:                 move.l #$0000001E,d6       * Inner loop counter
00:00003394 7E1D            	  4853:                 move.l #$0000001D,d7       * Outer loop counter
00:00003396 307C0100        	  4854:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4855: 
                            	  4856: 
                            	  4857: EOR_OUTER2:
                            	  4858: 
                            	  4859: *     BYTE
00:0000339A 2080            	  4860:                 move.l d0,(a0)
00:0000339C B310            	  4861:                 eor.b d1,(a0)
00:0000339E 40C3            	  4862:                 move.w sr,d3
00:000033A0 02830000000C    	  4863:                 andi.l #$0C,d3            * Isolate flags
00:000033A6 DA83            	  4864:                 add.l d3,d5               * Copy flag results into accumulator
00:000033A8 D890            	  4865:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4866: 
                            	  4867: *     WORD
00:000033AA 2080            	  4868:                 move.l d0,(a0)
00:000033AC B350            	  4869:                 eor.w d1,(a0)
00:000033AE 40C3            	  4870:                 move.w sr,d3
00:000033B0 02830000000C    	  4871:                 andi.l #$0C,d3            * Isolate flags
00:000033B6 DA83            	  4872:                 add.l d3,d5               * Copy flag results into accumulator
00:000033B8 D890            	  4873:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4874: 
                            	  4875: *     LONG
00:000033BA 2080            	  4876:                 move.l d0,(a0)
00:000033BC B390            	  4877:                 eor.l d1,(a0)
00:000033BE 40C3            	  4878:                 move.w sr,d3
00:000033C0 02830000000F    	  4879:                 andi.l #$0F,d3            * Isolate flags
00:000033C6 DA83            	  4880:                 add.l d3,d5               * Copy flag results into accumulator
00:000033C8 D890            	  4881:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4882: 
                            	  4883: 
00:000033CA E289            	  4884:                 lsr.l #$1,d1
00:000033CC 51CEFFCC        	  4885:                 dbf d6,EOR_OUTER2
00:000033D0 E28A            	  4886:                 lsr.l #$1,d2
00:000033D2 223C8167E123    	  4887:                 move.l #$8167E123,d1       * Initial Data-Y
00:000033D8 7C1E            	  4888:                 move.l #$0000001E,d6       * Inner loop counter
00:000033DA 51CFFFBE        	  4889:                 dbf d7,EOR_OUTER2
                            	  4890: 
00:000033DE 0C8455C5EB70    	  4891:                 cmpi.l #$55C5EB70,d4      * Check the data results
00:000033E4 66FE            	  4892:                 bne.s *
00:000033E6 0C8500004430    	  4893:                 cmpi.l #$00004430,d5      * Check the Flag results
00:000033EC 66FE            	  4894:                 bne.s *
                            	  4895: 
                            	  4896: 
00:000033EE 4E75            	  4897:                 rts
                            	  4898: 
                            	  4899: 
                            	  4900: *-----------------------------------------------------------
                            	  4901: *-----------------------------------------------------------
                            	  4902: * OPCODE : CMP
                            	  4903: *-----------------------------------------------------------
                            	  4904: *-----------------------------------------------------------
                            	  4905: 
                            	  4906: op_CMP:
                            	  4907: 
                            	  4908: 
                            	  4909: *  * <EA> to Register
                            	  4910: 
00:000033F0 203CA5A5A5A5    	  4911:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000033F6 223C8167E123    	  4912:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:000033FC 243CA5A5A5A5    	  4913:                 move.l #$a5a5a5a5,d2
00:00003402 7600            	  4914:                 moveq  #$00000000,d3
00:00003404 7800            	  4915:                 moveq  #$00000000,d4       * Cumulative data results
00:00003406 7A00            	  4916:                 moveq  #$00000000,d5       * Cumulative flag results
00:00003408 7C1E            	  4917:                 move.l #$0000001E,d6       * Inner loop counter
00:0000340A 7E1E            	  4918:                 move.l #$0000001E,d7       * Outer loop counter
00:0000340C 307C0100        	  4919:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4920: 
                            	  4921: 
                            	  4922: CMP_OUTER1:
                            	  4923: 
                            	  4924: *     BYTE
00:00003410 2081            	  4925:                 move.l d1,(a0)
00:00003412 B010            	  4926:                 cmp.b (a0),d0
00:00003414 40C3            	  4927:                 move.w sr,d3
00:00003416 02830000000F    	  4928:                 andi.l #$0F,d3            * Isolate flags
00:0000341C DA83            	  4929:                 add.l d3,d5               * Copy flag results into accumulator
00:0000341E D880            	  4930:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4931: 
                            	  4932: *     WORD
00:00003420 2081            	  4933:                 move.l d1,(a0)
00:00003422 B050            	  4934:                 cmp.w (a0),d0
00:00003424 40C3            	  4935:                 move.w sr,d3
00:00003426 02830000000F    	  4936:                 andi.l #$0F,d3            * Isolate flags
00:0000342C DA83            	  4937:                 add.l d3,d5               * Copy flag results into accumulator
00:0000342E D880            	  4938:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4939: 
                            	  4940: *     LONG
00:00003430 2081            	  4941:                 move.l d1,(a0)
00:00003432 B090            	  4942:                 cmp.l (a0),d0
00:00003434 40C3            	  4943:                 move.w sr,d3
00:00003436 02830000000F    	  4944:                 andi.l #$0F,d3            * Isolate flags
00:0000343C DA83            	  4945:                 add.l d3,d5               * Copy flag results into accumulator
00:0000343E D880            	  4946:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4947: 
                            	  4948: 
00:00003440 E289            	  4949:                 lsr.l #$1,d1
00:00003442 51CEFFCC        	  4950:                 dbf d6,CMP_OUTER1
00:00003446 E28A            	  4951:                 lsr.l #$1,d2
00:00003448 223C8167E123    	  4952:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000344E 7C1E            	  4953:                 move.l #$0000001E,d6       * Inner loop counter
00:00003450 51CFFFBE        	  4954:                 dbf d7,CMP_OUTER1
                            	  4955: 
00:00003454 0C847878712F    	  4956:                 cmpi.l #$7878712F,d4      * Check the data results
00:0000345A 66FE            	  4957:                 bne.s *
00:0000345C 0C8500005502    	  4958:                 cmpi.l #$00005502,d5      * Check the Flag results
00:00003462 66FE            	  4959:                 bne.s *
                            	  4960: 
                            	  4961: 
                            	  4962: 
00:00003464 4E75            	  4963:                 rts
                            	  4964: 
                            	  4965: 
                            	  4966: *-----------------------------------------------------------
                            	  4967: *-----------------------------------------------------------
                            	  4968: * OPCODE : CMPA
                            	  4969: *-----------------------------------------------------------
                            	  4970: *-----------------------------------------------------------
                            	  4971: 
                            	  4972: op_CMPA:
                            	  4973: 
                            	  4974: 
                            	  4975: *  * <EA> to Register
                            	  4976: 
00:00003466 207CA5A5A5A5    	  4977:                 move.l #$a5a5a5a5,a0       * Initial Data-X  Inner loop
00:0000346C 223C8167E123    	  4978:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00003472 243CA5A5A5A5    	  4979:                 move.l #$a5a5a5a5,d2
00:00003478 7600            	  4980:                 moveq  #$00000000,d3
00:0000347A 7800            	  4981:                 moveq  #$00000000,d4       * Cumulative data results
00:0000347C 7A00            	  4982:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000347E 7C1E            	  4983:                 move.l #$0000001E,d6       * Inner loop counter
00:00003480 7E1E            	  4984:                 move.l #$0000001E,d7       * Outer loop counter
00:00003482 327C0100        	  4985:                 move.l #$00000100,a1       * Address for memory EA operations
                            	  4986: 
                            	  4987: 
                            	  4988: CMPA_OUTER1:
                            	  4989: 
                            	  4990: 
                            	  4991: *     WORD
00:00003486 2281            	  4992:                 move.l d1,(a1)
00:00003488 B0D1            	  4993:                 cmpa.w (a1),a0
00:0000348A 40C3            	  4994:                 move.w sr,d3
00:0000348C 02830000000F    	  4995:                 andi.l #$0F,d3            * Isolate flags
00:00003492 DA83            	  4996:                 add.l d3,d5               * Copy flag results into accumulator
00:00003494 D888            	  4997:                 add.l a0,d4               * Copy data results into data accumulator
                            	  4998: 
                            	  4999: *     LONG
00:00003496 2281            	  5000:                 move.l d1,(a1)
00:00003498 B1D1            	  5001:                 cmpa.l (a1),a0
00:0000349A 40C3            	  5002:                 move.w sr,d3
00:0000349C 02830000000F    	  5003:                 andi.l #$0F,d3            * Isolate flags
00:000034A2 DA83            	  5004:                 add.l d3,d5               * Copy flag results into accumulator
00:000034A4 D888            	  5005:                 add.l a0,d4               * Copy data results into data accumulator
                            	  5006: 
                            	  5007: 
00:000034A6 E289            	  5008:                 lsr.l #$1,d1
00:000034A8 51CEFFDC        	  5009:                 dbf d6,CMPA_OUTER1
00:000034AC E28A            	  5010:                 lsr.l #$1,d2
00:000034AE 223C8167E123    	  5011:                 move.l #$8167E123,d1       * Initial Data-Y
00:000034B4 7C1E            	  5012:                 move.l #$0000001E,d6       * Inner loop counter
00:000034B6 51CFFFCE        	  5013:                 dbf d7,CMPA_OUTER1
                            	  5014: 
00:000034BA 0C84A5A5A0CA    	  5015:                 cmpi.l #$a5a5a0ca,d4      * Check the data results
00:000034C0 66FE            	  5016:                 bne.s *
00:000034C2 0C8500003A7D    	  5017:                 cmpi.l #$00003A7D,d5      * Check the Flag results
00:000034C8 66FE            	  5018:                 bne.s *
                            	  5019: 
                            	  5020: 
00:000034CA 4E75            	  5021:                 rts
                            	  5022: 
                            	  5023: 
                            	  5024: 
                            	  5025: *-----------------------------------------------------------
                            	  5026: *-----------------------------------------------------------
                            	  5027: * OPCODE : CMPM
                            	  5028: *-----------------------------------------------------------
                            	  5029: *-----------------------------------------------------------
                            	  5030: 
                            	  5031: op_CMPM:
                            	  5032: 
00:000034CC 307C0100        	  5033:                 move.l #$00000100,a0       * Address for Data-X
00:000034D0 327C0200        	  5034:                 move.l #$00000200,a1       * Address for Data-Y
00:000034D4 7000            	  5035:                 moveq  #$00000000,d0
00:000034D6 7200            	  5036:                 moveq  #$00000000,d1
00:000034D8 7400            	  5037:                 moveq  #$00000000,d2
                            	  5038: 
00:000034DA 20FC11FF5580    	  5039:                 move.l #$11FF5580,(a0)+   * Populate test data
00:000034E0 20FC1111FFFF    	  5040:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:000034E6 20FC33333333    	  5041:                 move.l #$33333333,(a0)+   * Populate test data
00:000034EC 20FC44444444    	  5042:                 move.l #$44444444,(a0)+   * Populate test data
                            	  5043: 
00:000034F2 22FC80FF337F    	  5044:                 move.l #$80FF337F,(a1)+   * Populate test data
00:000034F8 22FCFFFF1111    	  5045:                 move.l #$FFFF1111,(a1)+   * Populate test data
00:000034FE 22FC33333333    	  5046:                 move.l #$33333333,(a1)+   * Populate test data
00:00003504 22FC44444444    	  5047:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5048: 
00:0000350A 307C0100        	  5049:                 move.l #$00000100,a0       * Address for Data-X
00:0000350E 327C0200        	  5050:                 move.l #$00000200,a1       * Address for Data-Y
00:00003512 7C0F            	  5051:                 move.l #$0000000F,d6       * Loop counter
                            	  5052: 
00:00003514 B308            	  5053: CMPM_LOOP1:     cmpm.b (a0)+,(a1)+
00:00003516 40C3            	  5054:                 move.w sr,d3
00:00003518 02830000000F    	  5055:                 andi.l #$0F,d3            * Isolate flags
00:0000351E D083            	  5056:                 add.l d3,d0               * Copy flag results into accumulator
00:00003520 51CEFFF2        	  5057:                 dbf d6,CMPM_LOOP1
                            	  5058: 
                            	  5059: 
00:00003524 307C0100        	  5060:                 move.l #$00000100,a0       * Address for Data-X
00:00003528 327C0200        	  5061:                 move.l #$00000200,a1       * Address for Data-Y
00:0000352C 7C07            	  5062:                 moveq  #$00000007,d6       * Loop counter
                            	  5063: 
00:0000352E B348            	  5064: CMPM_LOOP2:     cmpm.w (a0)+,(a1)+
00:00003530 40C3            	  5065:                 move.w sr,d3
00:00003532 02830000000F    	  5066:                 andi.l #$0F,d3            * Isolate flags
00:00003538 D283            	  5067:                 add.l d3,d1               * Copy flag results into accumulator
00:0000353A 51CEFFF2        	  5068:                 dbf d6,CMPM_LOOP2
                            	  5069: 
                            	  5070: 
00:0000353E 307C0100        	  5071:                 move.l #$00000100,a0       * Address for Data-X
00:00003542 327C0200        	  5072:                 move.l #$00000200,a1       * Address for Data-Y
00:00003546 7C03            	  5073:                 moveq  #$00000003,d6       * Loop counter
                            	  5074: 
00:00003548 B388            	  5075: CMPM_LOOP3:     cmpm.l (a0)+,(a1)+
00:0000354A 40C3            	  5076:                 move.w sr,d3
00:0000354C 02830000000F    	  5077:                 andi.l #$0F,d3            * Isolate flags
00:00003552 D483            	  5078:                 add.l d3,d2               * Copy flag results into accumulator
00:00003554 51CEFFF2        	  5079:                 dbf d6,CMPM_LOOP3
                            	  5080: 
                            	  5081: 
00:00003558 0C800000004C    	  5082:                 cmpi.l #$0000004C,d0      * Check the data results
00:0000355E 66FE            	  5083:                 bne.s *
00:00003560 0C8100000024    	  5084:                 cmpi.l #$00000024,d1
00:00003566 66FE            	  5085:                 bne.s *
00:00003568 0C8200000012    	  5086:                 cmpi.l #$00000012,d2
00:0000356E 66FE            	  5087:                 bne.s *
                            	  5088: 
00:00003570 4E75            	  5089:                 rts
                            	  5090: 
                            	  5091: 
                            	  5092: *-----------------------------------------------------------
                            	  5093: *-----------------------------------------------------------
                            	  5094: * OPCODE : ADD
                            	  5095: *-----------------------------------------------------------
                            	  5096: *-----------------------------------------------------------
                            	  5097: 
                            	  5098: op_ADD:
                            	  5099: 
                            	  5100: 
                            	  5101: *  * <EA> to Register
00:00003572 203CA5A5A5A5    	  5102:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00003578 223C8167E123    	  5103:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:0000357E 243CA5A5A5A5    	  5104:                 move.l #$a5a5a5a5,d2
00:00003584 7600            	  5105:                 moveq  #$00000000,d3
00:00003586 7800            	  5106:                 moveq  #$00000000,d4       * Cumulative data results
00:00003588 7A00            	  5107:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000358A 7C1E            	  5108:                 move.l #$0000001E,d6       * Inner loop counter
00:0000358C 7E1E            	  5109:                 move.l #$0000001E,d7       * Outer loop counter
00:0000358E 307C0100        	  5110:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5111: 
                            	  5112: 
                            	  5113: ADD_OUTER1:
                            	  5114: 
                            	  5115: *     BYTE
00:00003592 2081            	  5116:                 move.l d1,(a0)
00:00003594 D010            	  5117:                 add.b (a0),d0
00:00003596 40C3            	  5118:                 move.w sr,d3
00:00003598 02830000001F    	  5119:                 andi.l #$1F,d3            * Isolate flags
00:0000359E DA83            	  5120:                 add.l d3,d5               * Copy flag results into accumulator
00:000035A0 D880            	  5121:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5122: 
                            	  5123: *     WORD
00:000035A2 2081            	  5124:                 move.l d1,(a0)
00:000035A4 D050            	  5125:                 add.w (a0),d0
00:000035A6 40C3            	  5126:                 move.w sr,d3
00:000035A8 02830000000C    	  5127:                 andi.l #$0C,d3            * Isolate flags
00:000035AE DA83            	  5128:                 add.l d3,d5               * Copy flag results into accumulator
00:000035B0 D880            	  5129:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5130: 
                            	  5131: *     LONG
00:000035B2 2081            	  5132:                 move.l d1,(a0)
00:000035B4 D090            	  5133:                 add.l (a0),d0
00:000035B6 40C3            	  5134:                 move.w sr,d3
00:000035B8 02830000000F    	  5135:                 andi.l #$0F,d3            * Isolate flags
00:000035BE DA83            	  5136:                 add.l d3,d5               * Copy flag results into accumulator
00:000035C0 D880            	  5137:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5138: 
                            	  5139: 
00:000035C2 E299            	  5140:                 ror.l #$1,d1
00:000035C4 51CEFFCC        	  5141:                 dbf d6,ADD_OUTER1
00:000035C8 E29A            	  5142:                 ror.l #$1,d2
00:000035CA 223C8167E123    	  5143:                 move.l #$8167E123,d1       * Initial Data-Y
00:000035D0 7C1E            	  5144:                 move.l #$0000001E,d6       * Inner loop counter
00:000035D2 51CFFFBE        	  5145:                 dbf d7,ADD_OUTER1
                            	  5146: 
00:000035D6 0C8423ED428F    	  5147:                 cmpi.l #$23ED428F,d4      * Check the data results
00:000035DC 66FE            	  5148:                 bne.s *
00:000035DE 0C8500004C96    	  5149:                 cmpi.l #$00004C96,d5      * Check the Flag results
00:000035E4 66FE            	  5150:                 bne.s *
                            	  5151: 
                            	  5152: 
                            	  5153: *  * Register to <EA>
00:000035E6 203C86738374    	  5154:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:000035EC 223CFC55F2FE    	  5155:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:000035F2 243C86738374    	  5156:                 move.l #$86738374,d2
00:000035F8 7600            	  5157:                 moveq  #$00000000,d3
00:000035FA 7800            	  5158:                 moveq  #$00000000,d4       * Cumulative data results
00:000035FC 7A00            	  5159:                 moveq  #$00000000,d5       * Cumulative flag results
00:000035FE 7C1E            	  5160:                 move.l #$0000001E,d6       * Inner loop counter
00:00003600 7E1D            	  5161:                 move.l #$0000001D,d7       * Outer loop counter
00:00003602 307C0100        	  5162:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5163: 
                            	  5164: 
                            	  5165: ADD_OUTER2:
                            	  5166: 
                            	  5167: *     BYTE
00:00003606 2080            	  5168:                 move.l d0,(a0)
00:00003608 D310            	  5169:                 add.b d1,(a0)
00:0000360A 40C3            	  5170:                 move.w sr,d3
00:0000360C 02830000000C    	  5171:                 andi.l #$0C,d3            * Isolate flags
00:00003612 DA83            	  5172:                 add.l d3,d5               * Copy flag results into accumulator
00:00003614 D890            	  5173:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5174: 
                            	  5175: *     WORD
00:00003616 2080            	  5176:                 move.l d0,(a0)
00:00003618 D350            	  5177:                 add.w d1,(a0)
00:0000361A 40C3            	  5178:                 move.w sr,d3
00:0000361C 02830000001F    	  5179:                 andi.l #$1F,d3            * Isolate flags
00:00003622 DA83            	  5180:                 add.l d3,d5               * Copy flag results into accumulator
00:00003624 D890            	  5181:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5182: 
                            	  5183: *     LONG
00:00003626 2080            	  5184:                 move.l d0,(a0)
00:00003628 D390            	  5185:                 add.l d1,(a0)
00:0000362A 40C3            	  5186:                 move.w sr,d3
00:0000362C 02830000000F    	  5187:                 andi.l #$0F,d3            * Isolate flags
00:00003632 DA83            	  5188:                 add.l d3,d5               * Copy flag results into accumulator
00:00003634 D890            	  5189:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5190: 
                            	  5191: 
00:00003636 E299            	  5192:                 ror.l #$1,d1
00:00003638 51CEFFCC        	  5193:                 dbf d6,ADD_OUTER2
00:0000363C E29A            	  5194:                 ror.l #$1,d2
00:0000363E 223C8167E123    	  5195:                 move.l #$8167E123,d1       * Initial Data-Y
00:00003644 7C1E            	  5196:                 move.l #$0000001E,d6       * Inner loop counter
00:00003646 51CFFFBE        	  5197:                 dbf d7,ADD_OUTER2
                            	  5198: 
00:0000364A 0C846701B884    	  5199:                 cmpi.l #$6701B884,d4      * Check the data results
00:00003650 66FE            	  5200:                 bne.s *
00:00003652 0C8500005467    	  5201:                 cmpi.l #$00005467,d5      * Check the Flag results
00:00003658 66FE            	  5202:                 bne.s *
                            	  5203: 
00:0000365A 4E75            	  5204:                 rts
                            	  5205: 
                            	  5206: *-----------------------------------------------------------
                            	  5207: *-----------------------------------------------------------
                            	  5208: * OPCODE : SUB
                            	  5209: *-----------------------------------------------------------
                            	  5210: *-----------------------------------------------------------
                            	  5211: 
                            	  5212: op_SUB:
                            	  5213: 
                            	  5214: *  * <EA> to Register
00:0000365C 203CA5A5A5A5    	  5215:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00003662 223C8167E123    	  5216:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00003668 243CA5A5A5A5    	  5217:                 move.l #$a5a5a5a5,d2
00:0000366E 7600            	  5218:                 moveq  #$00000000,d3
00:00003670 7800            	  5219:                 moveq  #$00000000,d4       * Cumulative data results
00:00003672 7A00            	  5220:                 moveq  #$00000000,d5       * Cumulative flag results
00:00003674 7C1E            	  5221:                 move.l #$0000001E,d6       * Inner loop counter
00:00003676 7E1E            	  5222:                 move.l #$0000001E,d7       * Outer loop counter
00:00003678 307C0100        	  5223:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5224: 
                            	  5225: 
                            	  5226: SUB_OUTER1:
                            	  5227: 
                            	  5228: *     BYTE
00:0000367C 2081            	  5229:                 move.l d1,(a0)
00:0000367E 9010            	  5230:                 sub.b (a0),d0
00:00003680 40C3            	  5231:                 move.w sr,d3
00:00003682 02830000001F    	  5232:                 andi.l #$1F,d3            * Isolate flags
00:00003688 DA83            	  5233:                 add.l d3,d5               * Copy flag results into accumulator
00:0000368A D880            	  5234:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5235: 
                            	  5236: *     WORD
00:0000368C 2081            	  5237:                 move.l d1,(a0)
00:0000368E 9050            	  5238:                 sub.w (a0),d0
00:00003690 40C3            	  5239:                 move.w sr,d3
00:00003692 02830000000C    	  5240:                 andi.l #$0C,d3            * Isolate flags
00:00003698 DA83            	  5241:                 add.l d3,d5               * Copy flag results into accumulator
00:0000369A D880            	  5242:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5243: 
                            	  5244: *     LONG
00:0000369C 2081            	  5245:                 move.l d1,(a0)
00:0000369E 9090            	  5246:                 sub.l (a0),d0
00:000036A0 40C3            	  5247:                 move.w sr,d3
00:000036A2 02830000000F    	  5248:                 andi.l #$0F,d3            * Isolate flags
00:000036A8 DA83            	  5249:                 add.l d3,d5               * Copy flag results into accumulator
00:000036AA D880            	  5250:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5251: 
                            	  5252: 
00:000036AC E299            	  5253:                 ror.l #$1,d1
00:000036AE 51CEFFCC        	  5254:                 dbf d6,SUB_OUTER1
00:000036B2 E29A            	  5255:                 ror.l #$1,d2
00:000036B4 223C8167E123    	  5256:                 move.l #$8167E123,d1       * Initial Data-Y
00:000036BA 7C1E            	  5257:                 move.l #$0000001E,d6       * Inner loop counter
00:000036BC 51CFFFBE        	  5258:                 dbf d7,SUB_OUTER1
                            	  5259: 
00:000036C0 0C841A8D14CF    	  5260:                 cmpi.l #$1A8D14CF,d4      * Check the data results
00:000036C6 66FE            	  5261:                 bne.s *
00:000036C8 0C8500004FC4    	  5262:                 cmpi.l #$00004FC4,d5      * Check the Flag results
00:000036CE 66FE            	  5263:                 bne.s *
                            	  5264: 
                            	  5265: 
                            	  5266: *  * Register to <EA>
00:000036D0 203C86738374    	  5267:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:000036D6 223CFC55F2FE    	  5268:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:000036DC 243C86738374    	  5269:                 move.l #$86738374,d2
00:000036E2 7600            	  5270:                 moveq  #$00000000,d3
00:000036E4 7800            	  5271:                 moveq  #$00000000,d4       * Cumulative data results
00:000036E6 7A00            	  5272:                 moveq  #$00000000,d5       * Cumulative flag results
00:000036E8 7C1E            	  5273:                 move.l #$0000001E,d6       * Inner loop counter
00:000036EA 7E1D            	  5274:                 move.l #$0000001D,d7       * Outer loop counter
00:000036EC 307C0100        	  5275:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5276: 
                            	  5277: 
                            	  5278: SUB_OUTER2:
                            	  5279: 
                            	  5280: *     BYTE
00:000036F0 2080            	  5281:                 move.l d0,(a0)
00:000036F2 9310            	  5282:                 sub.b d1,(a0)
00:000036F4 40C3            	  5283:                 move.w sr,d3
00:000036F6 02830000000C    	  5284:                 andi.l #$0C,d3            * Isolate flags
00:000036FC DA83            	  5285:                 add.l d3,d5               * Copy flag results into accumulator
00:000036FE D890            	  5286:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5287: 
                            	  5288: *     WORD
00:00003700 2080            	  5289:                 move.l d0,(a0)
00:00003702 9350            	  5290:                 sub.w d1,(a0)
00:00003704 40C3            	  5291:                 move.w sr,d3
00:00003706 02830000001F    	  5292:                 andi.l #$1F,d3            * Isolate flags
00:0000370C DA83            	  5293:                 add.l d3,d5               * Copy flag results into accumulator
00:0000370E D890            	  5294:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5295: 
                            	  5296: *     LONG
00:00003710 2080            	  5297:                 move.l d0,(a0)
00:00003712 9390            	  5298:                 sub.l d1,(a0)
00:00003714 40C3            	  5299:                 move.w sr,d3
00:00003716 02830000000F    	  5300:                 andi.l #$0F,d3            * Isolate flags
00:0000371C DA83            	  5301:                 add.l d3,d5               * Copy flag results into accumulator
00:0000371E D890            	  5302:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5303: 
                            	  5304: 
00:00003720 E299            	  5305:                 ror.l #$1,d1
00:00003722 51CEFFCC        	  5306:                 dbf d6,SUB_OUTER2
00:00003726 E29A            	  5307:                 ror.l #$1,d2
00:00003728 223C8167E123    	  5308:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000372E 7C1E            	  5309:                 move.l #$0000001E,d6       * Inner loop counter
00:00003730 51CFFFBE        	  5310:                 dbf d7,SUB_OUTER2
                            	  5311: 
00:00003734 0C8436D38BEC    	  5312:                 cmpi.l #$36D38BEC,d4      * Check the data results
00:0000373A 66FE            	  5313:                 bne.s *
00:0000373C 0C85000045A5    	  5314:                 cmpi.l #$000045A5,d5      * Check the Flag results
00:00003742 66FE            	  5315:                 bne.s *
                            	  5316: 
                            	  5317: 
                            	  5318: 
                            	  5319: 
00:00003744 4E75            	  5320:                 rts
                            	  5321: 
                            	  5322: 
                            	  5323: 
                            	  5324: *-----------------------------------------------------------
                            	  5325: *-----------------------------------------------------------
                            	  5326: * OPCODE : ADDA
                            	  5327: *-----------------------------------------------------------
                            	  5328: *-----------------------------------------------------------
                            	  5329: 
                            	  5330: op_ADDA:
                            	  5331: 
                            	  5332: *  * <EA> to Register
00:00003746 203CA5A5A5A5    	  5333:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:0000374C 223C8167E123    	  5334:                 move.l #$8167E123,d1
00:00003752 243CA5A5A5A5    	  5335:                 move.l #$a5a5a5a5,d2
00:00003758 7600            	  5336:                 moveq  #$00000000,d3
00:0000375A 7800            	  5337:                 moveq  #$00000000,d4       * Cumulative data results
00:0000375C 7A00            	  5338:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000375E 7C1E            	  5339:                 move.l #$0000001E,d6       * Inner loop counter
00:00003760 7E1E            	  5340:                 move.l #$0000001E,d7       * Outer loop counter
00:00003762 307C0100        	  5341:                 move.l #$00000100,a0       * Address for memory EA operations
00:00003766 227C8167E123    	  5342:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5343: 
                            	  5344: ADDA_OUTER1:
                            	  5345: 
                            	  5346: *     WORD
                            	  5347: *                move.l d1,(a0)       * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5348: *                adda.w (a0),a1
                            	  5349: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5350: 
                            	  5351: *     LONG
00:0000376C 2081            	  5352:                 move.l d1,(a0)
00:0000376E D3D0            	  5353:                 adda.l (a0),a1
00:00003770 D889            	  5354:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5355: 
00:00003772 E299            	  5356:                 ror.l #$1,d1
00:00003774 51CEFFF6        	  5357:                 dbf d6,ADDA_OUTER1
00:00003778 E299            	  5358:                 ror.l #$1,d1
00:0000377A 2241            	  5359:                 move.l d1,a1
00:0000377C 223C8167E123    	  5360:                 move.l #$8167E123,d1       * Initial Data-Y
00:00003782 7C1E            	  5361:                 move.l #$0000001E,d6       * Inner loop counter
00:00003784 51CFFFE6        	  5362:                 dbf d7,ADDA_OUTER1
                            	  5363: 
00:00003788 0C84AC04DB4C    	  5364:                 cmpi.l #$AC04DB4C,d4      * Check the data results
00:0000378E 66FE            	  5365:                 bne.s *
                            	  5366: 
                            	  5367: 
00:00003790 4E75            	  5368:                 rts
                            	  5369: 
                            	  5370: 
                            	  5371: *-----------------------------------------------------------
                            	  5372: *-----------------------------------------------------------
                            	  5373: * OPCODE : SUBA
                            	  5374: *-----------------------------------------------------------
                            	  5375: *-----------------------------------------------------------
                            	  5376: 
                            	  5377: op_SUBA:
                            	  5378: 
                            	  5379: *  * <EA> to Register
00:00003792 203CA5A5A5A5    	  5380:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00003798 223C8167E123    	  5381:                 move.l #$8167E123,d1
00:0000379E 243CA5A5A5A5    	  5382:                 move.l #$a5a5a5a5,d2
00:000037A4 7600            	  5383:                 moveq  #$00000000,d3
00:000037A6 7800            	  5384:                 moveq  #$00000000,d4       * Cumulative data results
00:000037A8 7A00            	  5385:                 moveq  #$00000000,d5       * Cumulative flag results
00:000037AA 7C1E            	  5386:                 move.l #$0000001E,d6       * Inner loop counter
00:000037AC 7E1E            	  5387:                 move.l #$0000001E,d7       * Outer loop counter
00:000037AE 307C0100        	  5388:                 move.l #$00000100,a0       * Address for memory EA operations
00:000037B2 227C8167E123    	  5389:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5390: 
                            	  5391: SUBA_OUTER1:
                            	  5392: 
                            	  5393: *     WORD
                            	  5394: *                move.l d1,(a0) * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5395: *                suba.w (a0),a1
                            	  5396: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5397: 
                            	  5398: *     LONG
00:000037B8 2081            	  5399:                 move.l d1,(a0)
00:000037BA 93D0            	  5400:                 suba.l (a0),a1
00:000037BC D889            	  5401:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5402: 
00:000037BE E299            	  5403:                 ror.l #$1,d1
00:000037C0 51CEFFF6        	  5404:                 dbf d6,SUBA_OUTER1
00:000037C4 E299            	  5405:                 ror.l #$1,d1
00:000037C6 2241            	  5406:                 move.l d1,a1
00:000037C8 223C8167E123    	  5407:                 move.l #$8167E123,d1       * Initial Data-Y
00:000037CE 7C1E            	  5408:                 move.l #$0000001E,d6       * Inner loop counter
00:000037D0 51CFFFE6        	  5409:                 dbf d7,SUBA_OUTER1
                            	  5410: 
00:000037D4 0C84E1E36D7A    	  5411:                 cmpi.l #$E1E36D7A,d4      * Check the data results
00:000037DA 66FE            	  5412:                 bne.s *
                            	  5413: 
                            	  5414: 
00:000037DC 4E75            	  5415:                 rts
                            	  5416: 
                            	  5417: 
                            	  5418: 
                            	  5419: *-----------------------------------------------------------
                            	  5420: *-----------------------------------------------------------
                            	  5421: * OPCODE : ADDX
                            	  5422: *-----------------------------------------------------------
                            	  5423: *-----------------------------------------------------------
                            	  5424: 
                            	  5425: op_ADDX:
                            	  5426: 
                            	  5427: 
                            	  5428: *  * Register to Register
00:000037DE 203CA5A5A5A5    	  5429:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000037E4 223C8167E123    	  5430:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:000037EA 243CA5A5A5A5    	  5431:                 move.l #$a5a5a5a5,d2
00:000037F0 7600            	  5432:                 moveq  #$00000000,d3
00:000037F2 7800            	  5433:                 moveq  #$00000000,d4       * Cumulative data results
00:000037F4 7A00            	  5434:                 moveq  #$00000000,d5       * Cumulative flag results
00:000037F6 7C1E            	  5435:                 move.l #$0000001E,d6       * Inner loop counter
00:000037F8 7E1E            	  5436:                 move.l #$0000001E,d7       * Outer loop counter
00:000037FA 307C0100        	  5437:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5438: 
                            	  5439: 
                            	  5440: ADDX_OUTER1:
                            	  5441: 
                            	  5442: *     BYTE
00:000037FE 2002            	  5443:                 move.l d2,d0
00:00003800 D101            	  5444:                 addx.b d1,d0
00:00003802 40C3            	  5445:                 move.w sr,d3
00:00003804 02830000001F    	  5446:                 andi.l #$1F,d3            * Isolate flags
00:0000380A DA83            	  5447:                 add.l d3,d5               * Copy flag results into accumulator
00:0000380C D880            	  5448:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5449: 
                            	  5450: *     WORD
00:0000380E 2002            	  5451:                 move.l d2,d0
00:00003810 D141            	  5452:                 addx.w d1,d0
00:00003812 40C3            	  5453:                 move.w sr,d3
00:00003814 02830000001F    	  5454:                 andi.l #$1F,d3            * Isolate flags
00:0000381A DA83            	  5455:                 add.l d3,d5               * Copy flag results into accumulator
00:0000381C D880            	  5456:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5457: 
                            	  5458: *     LONG
00:0000381E 2002            	  5459:                 move.l d2,d0
00:00003820 D181            	  5460:                 addx.l d1,d0
00:00003822 40C3            	  5461:                 move.w sr,d3
00:00003824 02830000001F    	  5462:                 andi.l #$1F,d3            * Isolate flags
00:0000382A DA83            	  5463:                 add.l d3,d5               * Copy flag results into accumulator
00:0000382C D880            	  5464:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5465: 
00:0000382E E299            	  5466:                 ror.l #$1,d1
00:00003830 51CEFFCC        	  5467:                 dbf d6,ADDX_OUTER1
00:00003834 E29A            	  5468:                 ror.l #$1,d2
00:00003836 223C8167E123    	  5469:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000383C 7C1E            	  5470:                 move.l #$0000001E,d6       * Inner loop counter
00:0000383E 51CFFFBE        	  5471:                 dbf d7,ADDX_OUTER1
                            	  5472: 
00:00003842 0C844E96A4D9    	  5473:                 cmpi.l #$4E96A4D9,d4      * Check the data results
00:00003848 66FE            	  5474:                 bne.s *
00:0000384A 0C85000085CD    	  5475:                 cmpi.l #$000085CD,d5      * Check the Flag results
00:00003850 66FE            	  5476:                 bne.s *
                            	  5477: 
                            	  5478: 
                            	  5479: 
                            	  5480: *     -(An),-(An)
                            	  5481: 
00:00003852 7000            	  5482:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
00:00003854 7200            	  5483:                 moveq  #$00000000,d1
00:00003856 7400            	  5484:                 moveq  #$00000000,d2
00:00003858 307C0100        	  5485:                 move.l #$00000100,a0       * Address for Data-X
00:0000385C 327C0200        	  5486:                 move.l #$00000200,a1       * Address for Data-Y
00:00003860 20FC11FF5580    	  5487:                 move.l #$11FF5580,(a0)+   * Populate test data
00:00003866 20FC1111FFFF    	  5488:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:0000386C 20FC33333333    	  5489:                 move.l #$33333333,(a0)+   * Populate test data
00:00003872 20FC44444444    	  5490:                 move.l #$44444444,(a0)+   * Populate test data
00:00003878 22FC80FF337F    	  5491:                 move.l #$80FF337F,(a1)+   * Populate test data
00:0000387E 22FCFFFF1111    	  5492:                 move.l #$FFFF1111,(a1)+   * Populate test data
00:00003884 22FC33333333    	  5493:                 move.l #$33333333,(a1)+   * Populate test data
00:0000388A 22FC44444444    	  5494:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5495: 
                            	  5496: 
00:00003890 7C0F            	  5497:                 move.l #$0000000F,d6       * Loop counter
                            	  5498: 
00:00003892 D308            	  5499: ADDX_LOOP3:     addx.b -(a0),-(a1)
00:00003894 40C3            	  5500:                 move.w sr,d3
00:00003896 02830000000F    	  5501:                 andi.l #$0F,d3            * Isolate flags
00:0000389C D083            	  5502:                 add.l d3,d0               * Copy flag results into accumulator
00:0000389E D211            	  5503:                 add.b (a1),d1
00:000038A0 51CEFFF0        	  5504:                 dbf d6,ADDX_LOOP3
                            	  5505: 
                            	  5506: 
00:000038A4 307C0110        	  5507:                 move.l #$00000110,a0       * Address for Data-X
00:000038A8 327C0210        	  5508:                 move.l #$00000210,a1       * Address for Data-Y
00:000038AC 7C07            	  5509:                 moveq  #$00000007,d6       * Loop counter
                            	  5510: 
00:000038AE D348            	  5511: ADDX_LOOP4:     addx.w -(a0),-(a1)
00:000038B0 40C3            	  5512:                 move.w sr,d3
00:000038B2 02830000000F    	  5513:                 andi.l #$0F,d3            * Isolate flags
00:000038B8 D083            	  5514:                 add.l d3,d0               * Copy flag results into accumulator
00:000038BA D251            	  5515:                 add.w (a1),d1
00:000038BC 51CEFFF0        	  5516:                 dbf d6,ADDX_LOOP4
                            	  5517: 
                            	  5518: 
00:000038C0 307C0110        	  5519:                 move.l #$00000110,a0       * Address for Data-X
00:000038C4 327C0210        	  5520:                 move.l #$00000210,a1       * Address for Data-Y
00:000038C8 7C03            	  5521:                 moveq  #$00000003,d6       * Loop counter
                            	  5522: 
00:000038CA D388            	  5523: ADDX_LOOP5:     addx.l -(a0),-(a1)
00:000038CC 40C3            	  5524:                 move.w sr,d3
00:000038CE 02830000000F    	  5525:                 andi.l #$0F,d3            * Isolate flags
00:000038D4 D083            	  5526:                 add.l d3,d0               * Copy flag results into accumulator
00:000038D6 D291            	  5527:                 add.l (a1),d1
00:000038D8 51CEFFF0        	  5528:                 dbf d6,ADDX_LOOP5
                            	  5529: 
                            	  5530: 
00:000038DC 0C8000000095    	  5531:                 cmpi.l #$00000095,d0      * Check the flag results
00:000038E2 66FE            	  5532:                 bne.s *
00:000038E4 0C81C812A682    	  5533:                 cmpi.l #$C812A682,d1      * Check the data results
00:000038EA 66FE            	  5534:                 bne.s *
                            	  5535: 
00:000038EC 4E75            	  5536:                 rts
                            	  5537: 
                            	  5538: 
                            	  5539: 
                            	  5540: 
                            	  5541: *-----------------------------------------------------------
                            	  5542: *-----------------------------------------------------------
                            	  5543: * OPCODE : SUBX
                            	  5544: *-----------------------------------------------------------
                            	  5545: *-----------------------------------------------------------
                            	  5546: 
                            	  5547: op_SUBX:
                            	  5548: 
                            	  5549: 
                            	  5550: *  * Register to Register
00:000038EE 203CA5A5A5A5    	  5551:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000038F4 223C8167E123    	  5552:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:000038FA 243CA5A5A5A5    	  5553:                 move.l #$a5a5a5a5,d2
00:00003900 7600            	  5554:                 moveq  #$00000000,d3
00:00003902 7800            	  5555:                 moveq  #$00000000,d4       * Cumulative data results
00:00003904 7A00            	  5556:                 moveq  #$00000000,d5       * Cumulative flag results
00:00003906 7C1E            	  5557:                 move.l #$0000001E,d6       * Inner loop counter
00:00003908 7E1E            	  5558:                 move.l #$0000001E,d7       * Outer loop counter
00:0000390A 307C0100        	  5559:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5560: 
                            	  5561: 
                            	  5562: SUBX_OUTER1:
                            	  5563: 
                            	  5564: *     BYTE
00:0000390E 2002            	  5565:                 move.l d2,d0
00:00003910 9101            	  5566:                 subx.b d1,d0
00:00003912 40C3            	  5567:                 move.w sr,d3
00:00003914 02830000001F    	  5568:                 andi.l #$1F,d3            * Isolate flags
00:0000391A DA83            	  5569:                 add.l d3,d5               * Copy flag results into accumulator
00:0000391C D880            	  5570:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5571: 
                            	  5572: *     WORD
00:0000391E 2002            	  5573:                 move.l d2,d0
00:00003920 9141            	  5574:                 subx.w d1,d0
00:00003922 40C3            	  5575:                 move.w sr,d3
00:00003924 02830000001F    	  5576:                 andi.l #$1F,d3            * Isolate flags
00:0000392A DA83            	  5577:                 add.l d3,d5               * Copy flag results into accumulator
00:0000392C D880            	  5578:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5579: 
                            	  5580: *     LONG
00:0000392E 2002            	  5581:                 move.l d2,d0
00:00003930 9181            	  5582:                 subx.l d1,d0
00:00003932 40C3            	  5583:                 move.w sr,d3
00:00003934 02830000001F    	  5584:                 andi.l #$1F,d3            * Isolate flags
00:0000393A DA83            	  5585:                 add.l d3,d5               * Copy flag results into accumulator
00:0000393C D880            	  5586:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5587: 
00:0000393E E299            	  5588:                 ror.l #$1,d1
00:00003940 51CEFFCC        	  5589:                 dbf d6,SUBX_OUTER1
00:00003944 E29A            	  5590:                 ror.l #$1,d2
00:00003946 223C8167E123    	  5591:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000394C 7C1E            	  5592:                 move.l #$0000001E,d6       * Inner loop counter
00:0000394E 51CFFFBE        	  5593:                 dbf d7,SUBX_OUTER1
                            	  5594: 
00:00003952 0C84FCAA913E    	  5595:                 cmpi.l #$FCAA913E,d4      * Check the data results
00:00003958 66FE            	  5596:                 bne.s *
00:0000395A 0C8500007E89    	  5597:                 cmpi.l #$00007E89,d5      * Check the Flag results
00:00003960 66FE            	  5598:                 bne.s *
                            	  5599: 
                            	  5600: 
                            	  5601: 
                            	  5602: *     -(An),-(An)
                            	  5603: 
00:00003962 7000            	  5604:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
00:00003964 7200            	  5605:                 moveq  #$00000000,d1
00:00003966 7400            	  5606:                 moveq  #$00000000,d2
00:00003968 307C0100        	  5607:                 move.l #$00000100,a0       * Address for Data-X
00:0000396C 327C0200        	  5608:                 move.l #$00000200,a1       * Address for Data-Y
00:00003970 20FC11FF5580    	  5609:                 move.l #$11FF5580,(a0)+   * Populate test data
00:00003976 20FC1111FFFF    	  5610:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:0000397C 20FC80FF337F    	  5611:                 move.l #$80FF337F,(a0)+   * Populate test data
00:00003982 20FC44444444    	  5612:                 move.l #$44444444,(a0)+   * Populate test data
00:00003988 22FC80FF337F    	  5613:                 move.l #$80FF337F,(a1)+   * Populate test data
00:0000398E 22FC1111FFFF    	  5614:                 move.l #$1111FFFF,(a1)+   * Populate test data
00:00003994 22FC33333333    	  5615:                 move.l #$33333333,(a1)+   * Populate test data
00:0000399A 22FC5580EECC    	  5616:                 move.l #$5580EECC,(a1)+   * Populate test data
                            	  5617: 
                            	  5618: 
00:000039A0 7C0F            	  5619:                 move.l #$0000000F,d6       * Loop counter
                            	  5620: 
00:000039A2 9308            	  5621: SUBX_LOOP3:     subx.b -(a0),-(a1)
00:000039A4 40C3            	  5622:                 move.w sr,d3
00:000039A6 02830000000F    	  5623:                 andi.l #$0F,d3            * Isolate flags
00:000039AC D083            	  5624:                 add.l d3,d0               * Copy flag results into accumulator
00:000039AE D211            	  5625:                 add.b (a1),d1
00:000039B0 51CEFFF0        	  5626:                 dbf d6,SUBX_LOOP3
                            	  5627: 
                            	  5628: 
00:000039B4 307C0110        	  5629:                 move.l #$00000110,a0       * Address for Data-X
00:000039B8 327C0210        	  5630:                 move.l #$00000210,a1       * Address for Data-Y
00:000039BC 7C07            	  5631:                 moveq  #$00000007,d6       * Loop counter
                            	  5632: 
00:000039BE 9348            	  5633: SUBX_LOOP4:     subx.w -(a0),-(a1)
00:000039C0 40C3            	  5634:                 move.w sr,d3
00:000039C2 02830000000F    	  5635:                 andi.l #$0F,d3            * Isolate flags
00:000039C8 D083            	  5636:                 add.l d3,d0               * Copy flag results into accumulator
00:000039CA D251            	  5637:                 add.w (a1),d1
00:000039CC 51CEFFF0        	  5638:                 dbf d6,SUBX_LOOP4
                            	  5639: 
                            	  5640: 
00:000039D0 307C0110        	  5641:                 move.l #$00000110,a0       * Address for Data-X
00:000039D4 327C0210        	  5642:                 move.l #$00000210,a1       * Address for Data-Y
00:000039D8 7C03            	  5643:                 moveq  #$00000003,d6       * Loop counter
                            	  5644: 
00:000039DA 9388            	  5645: SUBX_LOOP5:     subx.l -(a0),-(a1)
00:000039DC 40C3            	  5646:                 move.w sr,d3
00:000039DE 02830000000F    	  5647:                 andi.l #$0F,d3            * Isolate flags
00:000039E4 D083            	  5648:                 add.l d3,d0               * Copy flag results into accumulator
00:000039E6 D291            	  5649:                 add.l (a1),d1
00:000039E8 51CEFFF0        	  5650:                 dbf d6,SUBX_LOOP5
                            	  5651: 
                            	  5652: 
00:000039EC 0C80000000B1    	  5653:                 cmpi.l #$000000B1,d0      * Check the flag results
00:000039F2 66FE            	  5654:                 bne.s *
00:000039F4 0C8162C6F417    	  5655:                 cmpi.l #$62C6F417,d1      * Check the data results
00:000039FA 66FE            	  5656:                 bne.s *
                            	  5657: 
00:000039FC 4E75            	  5658:                 rts
                            	  5659: 
                            	  5660: 
                            	  5661: *-----------------------------------------------------------
                            	  5662: *-----------------------------------------------------------
                            	  5663: * OPCODE : MULU
                            	  5664: *-----------------------------------------------------------
                            	  5665: *-----------------------------------------------------------
                            	  5666: 
                            	  5667: op_MULU:
                            	  5668: 
00:000039FE 203CFE805501    	  5669:                 move.l #$FE805501,d0        * Initial
00:00003A04 223C5697EDB6    	  5670:                 move.l #$5697EDB6,d1        * Initial Y
00:00003A0A 243CFE805501    	  5671:                 move.l #$FE805501,d2
00:00003A10 7600            	  5672:                 moveq  #$00000000,d3
00:00003A12 7800            	  5673:                 moveq  #$00000000,d4        * Cumulative data results
00:00003A14 7A00            	  5674:                 moveq  #$00000000,d5       * Cumulative flag results
00:00003A16 7C0E            	  5675:                 move.l #$0000000E,d6       * Inner loop counter
00:00003A18 7E0E            	  5676:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5677: 
                            	  5678: 
00:00003A1A C0C1            	  5679: MULU_OUTER1:    mulu d1,d0
00:00003A1C 40C3            	  5680:                 move.w sr,d3
00:00003A1E 02830000000C    	  5681:                 andi.l #$0C,d3            * Isolate flags
00:00003A24 DA83            	  5682:                 add.l d3,d5               * Copy flag results into accumulator
00:00003A26 D880            	  5683:                 add.l d0,d4               * Copy data results into data accumulator
00:00003A28 E299            	  5684:                 ror.l #$1,d1
                            	  5685: 
00:00003A2A 51CEFFEE        	  5686:                 dbf d6,MULU_OUTER1
00:00003A2E E29A            	  5687:                 ror.l #$1,d2
00:00003A30 2002            	  5688:                 move.l d2,d0
00:00003A32 7C0E            	  5689:                 move.l #$0000000E,d6       * Inner loop counter
00:00003A34 51CFFFE4        	  5690:                 dbf d7,MULU_OUTER1
                            	  5691: 
00:00003A38 0C8476FB988C    	  5692:                 cmpi.l #$76FB988C,d4      * Check the data results
00:00003A3E 66FE            	  5693:                 bne.s *
                            	  5694: 
00:00003A40 0C8500000170    	  5695:                 cmpi.l #$00000170,d5      * Check the Flag results
00:00003A46 66FE            	  5696:                 bne.s *
                            	  5697: 
                            	  5698: 
00:00003A48 4E75            	  5699:                 rts
                            	  5700: 
                            	  5701: 
                            	  5702: *-----------------------------------------------------------
                            	  5703: *-----------------------------------------------------------
                            	  5704: * OPCODE : MULS
                            	  5705: *-----------------------------------------------------------
                            	  5706: *-----------------------------------------------------------
                            	  5707: 
                            	  5708: op_MULS:
                            	  5709: 
00:00003A4A 203CFE805501    	  5710:                 move.l #$FE805501,d0        * Initial
00:00003A50 223C5697EDB6    	  5711:                 move.l #$5697EDB6,d1        * Initial Y
00:00003A56 243CFE805501    	  5712:                 move.l #$FE805501,d2
00:00003A5C 7600            	  5713:                 moveq  #$00000000,d3
00:00003A5E 7800            	  5714:                 moveq  #$00000000,d4        * Cumulative data results
00:00003A60 7A00            	  5715:                 moveq  #$00000000,d5       * Cumulative flag results
00:00003A62 7C0E            	  5716:                 move.l #$0000000E,d6       * Inner loop counter
00:00003A64 7E0E            	  5717:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5718: 
                            	  5719: 
00:00003A66 C1C1            	  5720: MULS_OUTER1:    muls d1,d0
00:00003A68 40C3            	  5721:                 move.w sr,d3
00:00003A6A 02830000000C    	  5722:                 andi.l #$0C,d3            * Isolate flags
00:00003A70 DA83            	  5723:                 add.l d3,d5               * Copy flag results into accumulator
00:00003A72 D880            	  5724:                 add.l d0,d4               * Copy data results into data accumulator
00:00003A74 E299            	  5725:                 ror.l #$1,d1
                            	  5726: 
00:00003A76 51CEFFEE        	  5727:                 dbf d6,MULS_OUTER1
00:00003A7A E29A            	  5728:                 ror.l #$1,d2
00:00003A7C 2002            	  5729:                 move.l d2,d0
00:00003A7E 7C0E            	  5730:                 move.l #$0000000E,d6       * Inner loop counter
00:00003A80 51CFFFE4        	  5731:                 dbf d7,MULS_OUTER1
                            	  5732: 
00:00003A84 0C84D4E2988C    	  5733:                 cmpi.l #$D4E2988C,d4      * Check the data results
00:00003A8A 66FE            	  5734:                 bne.s *
                            	  5735: 
00:00003A8C 0C85000003E0    	  5736:                 cmpi.l #$000003E0,d5      * Check the Flag results
00:00003A92 66FE            	  5737:                 bne.s *
                            	  5738: 
                            	  5739: 
00:00003A94 4E75            	  5740:                 rts
                            	  5741: 
                            	  5742: 
                            	  5743: 
                            	  5744: *-----------------------------------------------------------
                            	  5745: *-----------------------------------------------------------
                            	  5746: * OPCODE : EXG
                            	  5747: *-----------------------------------------------------------
                            	  5748: *-----------------------------------------------------------
                            	  5749: 
                            	  5750: op_EXG:
00:00003A96 223CD1D1D1D1    	  5751:                 move.l #$d1d1d1d1,d1
00:00003A9C 243CD2D2D2D2    	  5752:                 move.l #$d2d2d2d2,d2
00:00003AA2 263CD3D3D3D3    	  5753:                 move.l #$d3d3d3d3,d3
00:00003AA8 227CA1A1A1A1    	  5754:                 move.l #$a1a1a1a1,a1
00:00003AAE 247CA2A2A2A2    	  5755:                 move.l #$a2a2a2a2,a2
00:00003AB4 267CA3A3A3A3    	  5756:                 move.l #$a3a3a3a3,a3
                            	  5757: 
00:00003ABA C342            	  5758:                 exg d1,d2
00:00003ABC C34A            	  5759:                 exg a1,a2
00:00003ABE C78B            	  5760:                 exg d3,a3
                            	  5761: 
00:00003AC0 0C81D2D2D2D2    	  5762:                 cmpi.l #$d2d2d2d2,d1      * Check the results
00:00003AC6 66FE            	  5763:                 bne.s *
00:00003AC8 0C82D1D1D1D1    	  5764:                 cmpi.l #$d1d1d1d1,d2
00:00003ACE 66FE            	  5765:                 bne.s *
00:00003AD0 0C83A3A3A3A3    	  5766:                 cmpi.l #$a3a3a3a3,d3
00:00003AD6 66FE            	  5767:                 bne.s *
                            	  5768: 
00:00003AD8 2209            	  5769:                 move.l a1,d1
00:00003ADA 240A            	  5770:                 move.l a2,d2
00:00003ADC 260B            	  5771:                 move.l a3,d3
                            	  5772: 
00:00003ADE 0C81A2A2A2A2    	  5773:                 cmpi.l #$a2a2a2a2,d1
00:00003AE4 66FE            	  5774:                 bne.s *
00:00003AE6 0C82A1A1A1A1    	  5775:                 cmpi.l #$a1a1a1a1,d2
00:00003AEC 66FE            	  5776:                 bne.s *
00:00003AEE 0C83D3D3D3D3    	  5777:                 cmpi.l #$d3d3d3d3,d3
00:00003AF4 66FE            	  5778:                 bne.s *
                            	  5779: 
00:00003AF6 4E75            	  5780:                 rts
                            	  5781: 
                            	  5782: 
                            	  5783: *-----------------------------------------------------------
                            	  5784: *-----------------------------------------------------------
                            	  5785: * OPCODE : ROx
                            	  5786: *-----------------------------------------------------------
                            	  5787: *-----------------------------------------------------------
                            	  5788: 
                            	  5789: *     Subroutine to check and accumulate the flags
00:00003AF8 40C3            	  5790: ROx_FLAGS:      move.w sr,d3
00:00003AFA 02830000000F    	  5791:                 andi.l #$0F,d3            * Isolate flags
00:00003B00 DA83            	  5792:                 add.l d3,d5               * Copy flag results into accumulator
00:00003B02 4E75            	  5793:                 rts
                            	  5794: 
                            	  5795: op_ROx:
                            	  5796: 
                            	  5797: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  5798: 
                            	  5799: *        BYTE LEFT
00:00003B04 203C80018FF1    	  5800:                 move.l #$80018FF1,d0
00:00003B0A 7A00            	  5801:                 moveq  #$00000000,d5
00:00003B0C 7C11            	  5802:                 moveq  #$00000011,d6
                            	  5803: ROx_LOOP1:
00:00003B0E ED38            	  5804:                 rol.b d6,d0
00:00003B10 61E6            	  5805:                 bsr ROx_FLAGS
00:00003B12 51CEFFFA        	  5806:                 dbf d6,ROx_LOOP1
00:00003B16 0C8080018FE3    	  5807:                 cmpi.l #$80018FE3,d0
00:00003B1C 66FE            	  5808:                 bne.s *
00:00003B1E 0C850000006B    	  5809:                 cmpi.l #$0000006B,d5
00:00003B24 66FE            	  5810:                 bne.s *
                            	  5811: 
                            	  5812: *        BYTE RIGHT
00:00003B26 203C80018FF1    	  5813:                 move.l #$80018FF1,d0
00:00003B2C 7C12            	  5814:                 moveq  #$00000012,d6
                            	  5815: ROx_LOOP2:
00:00003B2E EC38            	  5816:                 ror.b d6,d0
00:00003B30 61C6            	  5817:                 bsr ROx_FLAGS
00:00003B32 51CEFFFA        	  5818:                 dbf d6,ROx_LOOP2
00:00003B36 0C8080018F3E    	  5819:                 cmpi.l #$80018F3E,d0
00:00003B3C 66FE            	  5820:                 bne.s *
00:00003B3E 0C85000000C5    	  5821:                 cmpi.l #$000000C5,d5
00:00003B44 66FE            	  5822:                 bne.s *
                            	  5823: 
                            	  5824: 
                            	  5825: *        WORD LEFT
00:00003B46 203C80018FF1    	  5826:                 move.l #$80018FF1,d0
00:00003B4C 7C13            	  5827:                 moveq  #$00000013,d6
                            	  5828: ROx_LOOP3:
00:00003B4E ED78            	  5829:                 rol.w d6,d0
00:00003B50 61A6            	  5830:                 bsr ROx_FLAGS
00:00003B52 51CEFFFA        	  5831:                 dbf d6,ROx_LOOP3
00:00003B56 0C80800163FC    	  5832:                 cmpi.l #$800163FC,d0
00:00003B5C 66FE            	  5833:                 bne.s *
00:00003B5E 0C8500000131    	  5834:                 cmpi.l #$00000131,d5
00:00003B64 66FE            	  5835:                 bne.s *
                            	  5836: 
                            	  5837: *        WORD RIGHT
00:00003B66 203C80018FF1    	  5838:                 move.l #$80018FF1,d0
00:00003B6C 7C1E            	  5839:                 move.l #$0000001E,d6
                            	  5840: ROx_LOOP4:
00:00003B6E EC78            	  5841:                 ror.w d6,d0
00:00003B70 6186            	  5842:                 bsr ROx_FLAGS
00:00003B72 51CEFFFA        	  5843:                 dbf d6,ROx_LOOP4
00:00003B76 0C808001C7F8    	  5844:                 cmpi.l #$8001C7F8,d0
00:00003B7C 66FE            	  5845:                 bne.s *
00:00003B7E 0C85000001DB    	  5846:                 cmpi.l #$000001DB,d5
00:00003B84 66FE            	  5847:                 bne.s *
                            	  5848: 
                            	  5849: 
                            	  5850: *        LONG LEFT
00:00003B86 203C80018FF1    	  5851:                 move.l #$80018FF1,d0
00:00003B8C 7C15            	  5852:                 moveq  #$00000015,d6
                            	  5853: ROx_LOOP5:
00:00003B8E EDB8            	  5854:                 rol.l d6,d0
00:00003B90 6100FF66        	  5855:                 bsr ROx_FLAGS
00:00003B94 51CEFFF8        	  5856:                 dbf d6,ROx_LOOP5
00:00003B98 0C8000C7F8C0    	  5857:                 cmpi.l #$00C7F8C0,d0
00:00003B9E 66FE            	  5858:                 bne.s *
00:00003BA0 0C850000021A    	  5859:                 cmpi.l #$0000021A,d5
00:00003BA6 66FE            	  5860:                 bne.s *
                            	  5861: 
                            	  5862: *        LONG RIGHT
00:00003BA8 203C80018FF1    	  5863:                 move.l #$80018FF1,d0
00:00003BAE 7C16            	  5864:                 moveq  #$00000016,d6
                            	  5865: ROx_LOOP6:
00:00003BB0 ECB8            	  5866:                 ror.l d6,d0
00:00003BB2 6100FF44        	  5867:                 bsr ROx_FLAGS
00:00003BB6 51CEFFF8        	  5868:                 dbf d6,ROx_LOOP6
00:00003BBA 0C80000C7F8C    	  5869:                 cmpi.l #$000C7F8C,d0
00:00003BC0 66FE            	  5870:                 bne.s *
00:00003BC2 0C8500000250    	  5871:                 cmpi.l #$00000250,d5
00:00003BC8 66FE            	  5872:                 bne.s *
                            	  5873: 
                            	  5874: 
                            	  5875: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  5876: 
00:00003BCA 203C80018FF1    	  5877:                 move.l #$80018FF1,d0
00:00003BD0 7A00            	  5878:                 moveq  #$00000000,d5
                            	  5879: 
                            	  5880: *        BYTE LEFT
00:00003BD2 E318            	  5881:                 rol.b #1,d0
00:00003BD4 6100FF22        	  5882:                 bsr ROx_FLAGS
00:00003BD8 EB18            	  5883:                 rol.b #5,d0
00:00003BDA 6100FF1C        	  5884:                 bsr ROx_FLAGS
00:00003BDE EF18            	  5885:                 rol.b #7,d0
00:00003BE0 6100FF16        	  5886:                 bsr ROx_FLAGS
00:00003BE4 E118            	  5887:                 rol.b #8,d0
00:00003BE6 6100FF10        	  5888:                 bsr ROx_FLAGS
00:00003BEA 0C8080018F3E    	  5889:                 cmpi.l #$80018F3E,d0
00:00003BF0 66FE            	  5890:                 bne.s *
00:00003BF2 0C8500000009    	  5891:                 cmpi.l #$00000009,d5
00:00003BF8 66FE            	  5892:                 bne.s *
                            	  5893: 
                            	  5894: *        BYTE RIGHT
00:00003BFA E218            	  5895:                 ror.b #1,d0
00:00003BFC 6100FEFA        	  5896:                 bsr ROx_FLAGS
00:00003C00 EA18            	  5897:                 ror.b #5,d0
00:00003C02 6100FEF4        	  5898:                 bsr ROx_FLAGS
00:00003C06 EE18            	  5899:                 ror.b #7,d0
00:00003C08 6100FEEE        	  5900:                 bsr ROx_FLAGS
00:00003C0C E018            	  5901:                 ror.b #8,d0
00:00003C0E 6100FEE8        	  5902:                 bsr ROx_FLAGS
00:00003C12 0C8080018FF1    	  5903:                 cmpi.l #$80018FF1,d0
00:00003C18 66FE            	  5904:                 bne.s *
00:00003C1A 0C8500000024    	  5905:                 cmpi.l #$00000024,d5
00:00003C20 66FE            	  5906:                 bne.s *
                            	  5907: 
                            	  5908: *        WORD LEFT
00:00003C22 E358            	  5909:                 rol.w #1,d0
00:00003C24 6100FED2        	  5910:                 bsr ROx_FLAGS
00:00003C28 EB58            	  5911:                 rol.w #5,d0
00:00003C2A 6100FECC        	  5912:                 bsr ROx_FLAGS
00:00003C2E EF58            	  5913:                 rol.w #7,d0
00:00003C30 6100FEC6        	  5914:                 bsr ROx_FLAGS
00:00003C34 E158            	  5915:                 rol.w #8,d0
00:00003C36 6100FEC0        	  5916:                 bsr ROx_FLAGS
00:00003C3A 0C808001FE31    	  5917:                 cmpi.l #$8001FE31,d0
00:00003C40 66FE            	  5918:                 bne.s *
00:00003C42 0C8500000037    	  5919:                 cmpi.l #$00000037,d5
00:00003C48 66FE            	  5920:                 bne.s *
                            	  5921: 
                            	  5922: *        WORD RIGHT
00:00003C4A E258            	  5923:                 ror.w #1,d0
00:00003C4C 6100FEAA        	  5924:                 bsr ROx_FLAGS
00:00003C50 EA58            	  5925:                 ror.w #5,d0
00:00003C52 6100FEA4        	  5926:                 bsr ROx_FLAGS
00:00003C56 EE58            	  5927:                 ror.w #7,d0
00:00003C58 6100FE9E        	  5928:                 bsr ROx_FLAGS
00:00003C5C E058            	  5929:                 ror.w #8,d0
00:00003C5E 6100FE98        	  5930:                 bsr ROx_FLAGS
00:00003C62 0C8080018FF1    	  5931:                 cmpi.l #$80018FF1,d0
00:00003C68 66FE            	  5932:                 bne.s *
00:00003C6A 0C850000005B    	  5933:                 cmpi.l #$0000005B,d5
00:00003C70 66FE            	  5934:                 bne.s *
                            	  5935: 
                            	  5936: *        LONG LEFT
00:00003C72 E398            	  5937:                 rol.l #1,d0
00:00003C74 6100FE82        	  5938:                 bsr ROx_FLAGS
00:00003C78 EB98            	  5939:                 rol.l #5,d0
00:00003C7A 6100FE7C        	  5940:                 bsr ROx_FLAGS
00:00003C7E EF98            	  5941:                 rol.l #7,d0
00:00003C80 6100FE76        	  5942:                 bsr ROx_FLAGS
00:00003C84 E198            	  5943:                 rol.l #8,d0
00:00003C86 6100FE70        	  5944:                 bsr ROx_FLAGS
00:00003C8A 0C80FE300031    	  5945:                 cmpi.l #$FE300031,d0
00:00003C90 66FE            	  5946:                 bne.s *
00:00003C92 0C8500000065    	  5947:                 cmpi.l #$00000065,d5
00:00003C98 66FE            	  5948:                 bne.s *
                            	  5949: 
                            	  5950: *        LONG RIGHT
00:00003C9A E298            	  5951:                 ror.l #1,d0
00:00003C9C 6100FE5A        	  5952:                 bsr ROx_FLAGS
00:00003CA0 EA98            	  5953:                 ror.l #5,d0
00:00003CA2 6100FE54        	  5954:                 bsr ROx_FLAGS
00:00003CA6 EE98            	  5955:                 ror.l #7,d0
00:00003CA8 6100FE4E        	  5956:                 bsr ROx_FLAGS
00:00003CAC E098            	  5957:                 ror.l #8,d0
00:00003CAE 6100FE48        	  5958:                 bsr ROx_FLAGS
00:00003CB2 0C8080018FF1    	  5959:                 cmpi.l #$80018FF1,d0
00:00003CB8 66FE            	  5960:                 bne.s *
00:00003CBA 0C8500000080    	  5961:                 cmpi.l #$00000080,d5
00:00003CC0 66FE            	  5962:                 bne.s *
                            	  5963: 
                            	  5964: 
                            	  5965: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  5966: 
00:00003CC2 7A00            	  5967:                 moveq  #$00000000,d5
00:00003CC4 307C0100        	  5968:                 move.l #$00000100,a0
00:00003CC8 30BC8FF1        	  5969:                 move.w #$8FF1,(a0)
                            	  5970: 
                            	  5971: *        WORD LEFT
00:00003CCC E7D0            	  5972:                 rol (a0)
00:00003CCE 6100FE28        	  5973:                 bsr ROx_FLAGS
00:00003CD2 E7D0            	  5974:                 rol (a0)
00:00003CD4 6100FE22        	  5975:                 bsr ROx_FLAGS
00:00003CD8 E7D0            	  5976:                 rol (a0)
00:00003CDA 6100FE1C        	  5977:                 bsr ROx_FLAGS
00:00003CDE E7D0            	  5978:                 rol (a0)
00:00003CE0 6100FE16        	  5979:                 bsr ROx_FLAGS
00:00003CE4 3010            	  5980:                 move.w (a0),d0
00:00003CE6 0C808001FF18    	  5981:                 cmpi.l #$8001FF18,d0
00:00003CEC 66FE            	  5982:                 bne.s *
00:00003CEE 0C8500000009    	  5983:                 cmpi.l #$00000009,d5
00:00003CF4 66FE            	  5984:                 bne.s *
                            	  5985: 
                            	  5986: *        WORD RIGHT
00:00003CF6 E6D0            	  5987:                 ror (a0)
00:00003CF8 6100FDFE        	  5988:                 bsr ROx_FLAGS
00:00003CFC E6D0            	  5989:                 ror (a0)
00:00003CFE 6100FDF8        	  5990:                 bsr ROx_FLAGS
00:00003D02 E6D0            	  5991:                 ror (a0)
00:00003D04 6100FDF2        	  5992:                 bsr ROx_FLAGS
00:00003D08 E6D0            	  5993:                 ror (a0)
00:00003D0A 6100FDEC        	  5994:                 bsr ROx_FLAGS
00:00003D0E E6D0            	  5995:                 ror (a0)
00:00003D10 6100FDE6        	  5996:                 bsr ROx_FLAGS
00:00003D14 E6D0            	  5997:                 ror (a0)
00:00003D16 6100FDE0        	  5998:                 bsr ROx_FLAGS
00:00003D1A 3010            	  5999:                 move.w (a0),d0
00:00003D1C 0C80800163FC    	  6000:                 cmpi.l #$800163FC,d0
00:00003D22 66FE            	  6001:                 bne.s *
00:00003D24 0C850000001B    	  6002:                 cmpi.l #$0000001B,d5
00:00003D2A 66FE            	  6003:                 bne.s *
                            	  6004: 
00:00003D2C 4E75            	  6005:                 rts
                            	  6006: 
                            	  6007: 
                            	  6008: 
                            	  6009: *-----------------------------------------------------------
                            	  6010: *-----------------------------------------------------------
                            	  6011: * OPCODE : ROXx
                            	  6012: *-----------------------------------------------------------
                            	  6013: *-----------------------------------------------------------
                            	  6014: 
                            	  6015: *     Subroutine to check and accumulate the flags
00:00003D2E 40C3            	  6016: ROXx_FLAGS:     move.w sr,d3
00:00003D30 02830000000F    	  6017:                 andi.l #$0F,d3            * Isolate flags
00:00003D36 DA83            	  6018:                 add.l d3,d5               * Copy flag results into accumulator
00:00003D38 4E75            	  6019:                 rts
                            	  6020: 
                            	  6021: op_ROXx:
                            	  6022: 
                            	  6023: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6024: 
                            	  6025: *        BYTE LEFT
00:00003D3A 203C80018FF1    	  6026:                 move.l #$80018FF1,d0
00:00003D40 7A00            	  6027:                 moveq  #$00000000,d5
00:00003D42 7C11            	  6028:                 moveq  #$00000011,d6
                            	  6029: ROXx_LOOP1:
00:00003D44 ED30            	  6030:                 roxl.b d6,d0
00:00003D46 61E6            	  6031:                 bsr ROXx_FLAGS
00:00003D48 51CEFFFA        	  6032:                 dbf d6,ROXx_LOOP1
00:00003D4C 0C8080018FD0    	  6033:                 cmpi.l #$80018FD0,d0
00:00003D52 66FE            	  6034:                 bne.s *
00:00003D54 0C8500000042    	  6035:                 cmpi.l #$00000042,d5
00:00003D5A 66FE            	  6036:                 bne.s *
                            	  6037: 
                            	  6038: *        BYTE RIGHT
00:00003D5C 203C80018FF1    	  6039:                 move.l #$80018FF1,d0
00:00003D62 7C12            	  6040:                 moveq  #$00000012,d6
                            	  6041: ROXx_LOOP2:
00:00003D64 EC30            	  6042:                 roxr.b d6,d0
00:00003D66 61C6            	  6043:                 bsr ROXx_FLAGS
00:00003D68 51CEFFFA        	  6044:                 dbf d6,ROXx_LOOP2
00:00003D6C 0C8080018F51    	  6045:                 cmpi.l #$80018F51,d0
00:00003D72 66FE            	  6046:                 bne.s *
00:00003D74 0C850000009C    	  6047:                 cmpi.l #$0000009C,d5
00:00003D7A 66FE            	  6048:                 bne.s *
                            	  6049: 
                            	  6050: 
                            	  6051: *        WORD LEFT
00:00003D7C 203C80018FF1    	  6052:                 move.l #$80018FF1,d0
00:00003D82 7C13            	  6053:                 moveq  #$00000013,d6
                            	  6054: ROXx_LOOP3:
00:00003D84 ED70            	  6055:                 roxl.w d6,d0
00:00003D86 61A6            	  6056:                 bsr ROXx_FLAGS
00:00003D88 51CEFFFA        	  6057:                 dbf d6,ROXx_LOOP3
00:00003D8C 0C8080013980    	  6058:                 cmpi.l #$80013980,d0
00:00003D92 66FE            	  6059:                 bne.s *
00:00003D94 0C85000000C9    	  6060:                 cmpi.l #$000000C9,d5
00:00003D9A 66FE            	  6061:                 bne.s *
                            	  6062: 
                            	  6063: *        WORD RIGHT
00:00003D9C 203C80018FF1    	  6064:                 move.l #$80018FF1,d0
00:00003DA2 7C1E            	  6065:                 move.l #$0000001E,d6
                            	  6066: ROXx_LOOP4:
00:00003DA4 EC70            	  6067:                 roxr.w d6,d0
00:00003DA6 6186            	  6068:                 bsr ROXx_FLAGS
00:00003DA8 51CEFFFA        	  6069:                 dbf d6,ROXx_LOOP4
00:00003DAC 0C8080010A1D    	  6070:                 cmpi.l #$80010A1D,d0
00:00003DB2 66FE            	  6071:                 bne.s *
00:00003DB4 0C850000014D    	  6072:                 cmpi.l #$0000014D,d5
00:00003DBA 66FE            	  6073:                 bne.s *
                            	  6074: 
                            	  6075: 
                            	  6076: *        LONG LEFT
00:00003DBC 203C80018FF1    	  6077:                 move.l #$80018FF1,d0
00:00003DC2 7C15            	  6078:                 moveq  #$00000015,d6
                            	  6079: ROXx_LOOP5:
00:00003DC4 EDB0            	  6080:                 roxl.l d6,d0
00:00003DC6 6100FF66        	  6081:                 bsr ROXx_FLAGS
00:00003DCA 51CEFFF8        	  6082:                 dbf d6,ROXx_LOOP5
00:00003DCE 0C80800185D0    	  6083:                 cmpi.l #$800185D0,d0
00:00003DD4 66FE            	  6084:                 bne.s *
00:00003DD6 0C85000001A1    	  6085:                 cmpi.l #$000001A1,d5
00:00003DDC 66FE            	  6086:                 bne.s *
                            	  6087: 
                            	  6088: *        LONG RIGHT
00:00003DDE 203C80018FF1    	  6089:                 move.l #$80018FF1,d0
00:00003DE4 7C16            	  6090:                 moveq  #$00000016,d6
                            	  6091: ROXx_LOOP6:
00:00003DE6 ECB0            	  6092:                 roxr.l d6,d0
00:00003DE8 6100FF44        	  6093:                 bsr ROXx_FLAGS
00:00003DEC 51CEFFF8        	  6094:                 dbf d6,ROXx_LOOP6
00:00003DF0 0C80082D8200    	  6095:                 cmpi.l #$082D8200,d0
00:00003DF6 66FE            	  6096:                 bne.s *
00:00003DF8 0C85000001DE    	  6097:                 cmpi.l #$000001DE,d5
00:00003DFE 66FE            	  6098:                 bne.s *
                            	  6099: 
                            	  6100: 
                            	  6101: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6102: 
00:00003E00 203C80018FF1    	  6103:                 move.l #$80018FF1,d0
00:00003E06 7A00            	  6104:                 moveq  #$00000000,d5
                            	  6105: 
                            	  6106: *        BYTE LEFT
00:00003E08 E310            	  6107:                 roxl.b #1,d0
00:00003E0A 6100FF22        	  6108:                 bsr ROXx_FLAGS
00:00003E0E EB10            	  6109:                 roxl.b #5,d0
00:00003E10 6100FF1C        	  6110:                 bsr ROXx_FLAGS
00:00003E14 EF10            	  6111:                 roxl.b #7,d0
00:00003E16 6100FF16        	  6112:                 bsr ROXx_FLAGS
00:00003E1A E110            	  6113:                 roxl.b #8,d0
00:00003E1C 6100FF10        	  6114:                 bsr ROXx_FLAGS
00:00003E20 0C8080018F09    	  6115:                 cmpi.l #$80018F09,d0
00:00003E26 66FE            	  6116:                 bne.s *
00:00003E28 0C850000000B    	  6117:                 cmpi.l #$0000000B,d5
00:00003E2E 66FE            	  6118:                 bne.s *
                            	  6119: 
                            	  6120: *        BYTE RIGHT
00:00003E30 E210            	  6121:                 roxr.b #1,d0
00:00003E32 6100FEFA        	  6122:                 bsr ROXx_FLAGS
00:00003E36 EA10            	  6123:                 roxr.b #5,d0
00:00003E38 6100FEF4        	  6124:                 bsr ROXx_FLAGS
00:00003E3C EE10            	  6125:                 roxr.b #7,d0
00:00003E3E 6100FEEE        	  6126:                 bsr ROXx_FLAGS
00:00003E42 E010            	  6127:                 roxr.b #8,d0
00:00003E44 6100FEE8        	  6128:                 bsr ROXx_FLAGS
00:00003E48 0C8080018F00    	  6129:                 cmpi.l #$80018F00,d0
00:00003E4E 66FE            	  6130:                 bne.s *
00:00003E50 0C8500000015    	  6131:                 cmpi.l #$00000015,d5
00:00003E56 66FE            	  6132:                 bne.s *
                            	  6133: 
                            	  6134: *        WORD LEFT
00:00003E58 E350            	  6135:                 roxl.w #1,d0
00:00003E5A 6100FED2        	  6136:                 bsr ROXx_FLAGS
00:00003E5E EB50            	  6137:                 roxl.w #5,d0
00:00003E60 6100FECC        	  6138:                 bsr ROXx_FLAGS
00:00003E64 EF50            	  6139:                 roxl.w #7,d0
00:00003E66 6100FEC6        	  6140:                 bsr ROXx_FLAGS
00:00003E6A E150            	  6141:                 roxl.w #8,d0
00:00003E6C 6100FEC0        	  6142:                 bsr ROXx_FLAGS
00:00003E70 0C808001B000    	  6143:                 cmpi.l #$8001B000,d0
00:00003E76 66FE            	  6144:                 bne.s *
00:00003E78 0C8500000027    	  6145:                 cmpi.l #$00000027,d5
00:00003E7E 66FE            	  6146:                 bne.s *
                            	  6147: 
                            	  6148: *        WORD RIGHT
00:00003E80 E250            	  6149:                 roxr.w #1,d0
00:00003E82 6100FEAA        	  6150:                 bsr ROXx_FLAGS
00:00003E86 EA50            	  6151:                 roxr.w #5,d0
00:00003E88 6100FEA4        	  6152:                 bsr ROXx_FLAGS
00:00003E8C EE50            	  6153:                 roxr.w #7,d0
00:00003E8E 6100FE9E        	  6154:                 bsr ROXx_FLAGS
00:00003E92 E050            	  6155:                 roxr.w #8,d0
00:00003E94 6100FE98        	  6156:                 bsr ROXx_FLAGS
00:00003E98 0C8080010A00    	  6157:                 cmpi.l #$80010A00,d0
00:00003E9E 66FE            	  6158:                 bne.s *
00:00003EA0 0C8500000028    	  6159:                 cmpi.l #$00000028,d5
00:00003EA6 66FE            	  6160:                 bne.s *
                            	  6161: 
                            	  6162: *        LONG LEFT
00:00003EA8 E390            	  6163:                 roxl.l #1,d0
00:00003EAA 6100FE82        	  6164:                 bsr ROXx_FLAGS
00:00003EAE EB90            	  6165:                 roxl.l #5,d0
00:00003EB0 6100FE7C        	  6166:                 bsr ROXx_FLAGS
00:00003EB4 EF90            	  6167:                 roxl.l #7,d0
00:00003EB6 6100FE76        	  6168:                 bsr ROXx_FLAGS
00:00003EBA E190            	  6169:                 roxl.l #8,d0
00:00003EBC 6100FE70        	  6170:                 bsr ROXx_FLAGS
00:00003EC0 0C8040000010    	  6171:                 cmpi.l #$40000010,d0
00:00003EC6 66FE            	  6172:                 bne.s *
00:00003EC8 0C850000002A    	  6173:                 cmpi.l #$0000002A,d5
00:00003ECE 66FE            	  6174:                 bne.s *
                            	  6175: 
                            	  6176: *        LONG RIGHT
00:00003ED0 E290            	  6177:                 roxr.l #1,d0
00:00003ED2 6100FE5A        	  6178:                 bsr ROXx_FLAGS
00:00003ED6 EA90            	  6179:                 roxr.l #5,d0
00:00003ED8 6100FE54        	  6180:                 bsr ROXx_FLAGS
00:00003EDC EE90            	  6181:                 roxr.l #7,d0
00:00003EDE 6100FE4E        	  6182:                 bsr ROXx_FLAGS
00:00003EE2 E090            	  6183:                 roxr.l #8,d0
00:00003EE4 6100FE48        	  6184:                 bsr ROXx_FLAGS
00:00003EE8 0C8000010200    	  6185:                 cmpi.l #$00010200,d0
00:00003EEE 66FE            	  6186:                 bne.s *
00:00003EF0 0C8500000032    	  6187:                 cmpi.l #$00000032,d5
00:00003EF6 66FE            	  6188:                 bne.s *
                            	  6189: 
                            	  6190: 
                            	  6191: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6192: 
00:00003EF8 7A00            	  6193:                 moveq  #$00000000,d5
00:00003EFA 307C0100        	  6194:                 move.l #$00000100,a0
00:00003EFE 30BC8FF1        	  6195:                 move.w #$8FF1,(a0)
                            	  6196: 
                            	  6197: *        WORD LEFT
00:00003F02 E5D0            	  6198:                 roxl (a0)
00:00003F04 6100FE28        	  6199:                 bsr ROXx_FLAGS
00:00003F08 E5D0            	  6200:                 roxl (a0)
00:00003F0A 6100FE22        	  6201:                 bsr ROXx_FLAGS
00:00003F0E E5D0            	  6202:                 roxl (a0)
00:00003F10 6100FE1C        	  6203:                 bsr ROXx_FLAGS
00:00003F14 E5D0            	  6204:                 roxl (a0)
00:00003F16 6100FE16        	  6205:                 bsr ROXx_FLAGS
00:00003F1A 3010            	  6206:                 move.w (a0),d0
00:00003F1C 0C800001FF10    	  6207:                 cmpi.l #$0001FF10,d0
00:00003F22 66FE            	  6208:                 bne.s *
00:00003F24 0C8500000009    	  6209:                 cmpi.l #$00000009,d5
00:00003F2A 66FE            	  6210:                 bne.s *
                            	  6211: 
                            	  6212: *        WORD RIGHT
00:00003F2C E4D0            	  6213:                 roxr (a0)
00:00003F2E 6100FDFE        	  6214:                 bsr ROXx_FLAGS
00:00003F32 E4D0            	  6215:                 roxr (a0)
00:00003F34 6100FDF8        	  6216:                 bsr ROXx_FLAGS
00:00003F38 E4D0            	  6217:                 roxr (a0)
00:00003F3A 6100FDF2        	  6218:                 bsr ROXx_FLAGS
00:00003F3E E4D0            	  6219:                 roxr (a0)
00:00003F40 6100FDEC        	  6220:                 bsr ROXx_FLAGS
00:00003F44 E4D0            	  6221:                 roxr (a0)
00:00003F46 6100FDE6        	  6222:                 bsr ROXx_FLAGS
00:00003F4A E4D0            	  6223:                 roxr (a0)
00:00003F4C 6100FDE0        	  6224:                 bsr ROXx_FLAGS
00:00003F50 3010            	  6225:                 move.w (a0),d0
00:00003F52 0C80000103FC    	  6226:                 cmpi.l #$000103FC,d0
00:00003F58 66FE            	  6227:                 bne.s *
00:00003F5A 0C850000000A    	  6228:                 cmpi.l #$0000000A,d5
00:00003F60 66FE            	  6229:                 bne.s *
                            	  6230: 
00:00003F62 4E75            	  6231:                 rts
                            	  6232: 
                            	  6233: 
                            	  6234: 
                            	  6235: 
                            	  6236: *-----------------------------------------------------------
                            	  6237: *-----------------------------------------------------------
                            	  6238: * OPCODE : SHIFTS
                            	  6239: *-----------------------------------------------------------
                            	  6240: *-----------------------------------------------------------
                            	  6241: 
                            	  6242: *     Subroutine to check and accumulate the flags
00:00003F64 40C3            	  6243: SHIFTS_FLAGS:   move.w sr,d3
00:00003F66 02830000000F    	  6244:                 andi.l #$0F,d3            * Isolate flags
00:00003F6C DA83            	  6245:                 add.l d3,d5               * Copy flag results into accumulator
00:00003F6E 4E75            	  6246:                 rts
                            	  6247: 
                            	  6248: op_SHIFTS:
                            	  6249: 
                            	  6250: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6251: 
                            	  6252: *        BYTE LEFT
00:00003F70 203C80018F81    	  6253:                 move.l #$80018F81,d0
00:00003F76 7A00            	  6254:                 moveq  #$00000000,d5
00:00003F78 7C02            	  6255:                 moveq  #$00000002,d6
                            	  6256: SHIFTS_LOOP1:
00:00003F7A ED20            	  6257:                 asl.b d6,d0
00:00003F7C 61E6            	  6258:                 bsr SHIFTS_FLAGS
00:00003F7E 51CEFFFA        	  6259:                 dbf d6,SHIFTS_LOOP1
00:00003F82 0C8080018F08    	  6260:                 cmpi.l #$80018F08,d0
00:00003F88 66FE            	  6261:                 bne.s *
00:00003F8A 0C8500000002    	  6262:                 cmpi.l #$00000002,d5
00:00003F90 66FE            	  6263:                 bne.s *
                            	  6264: 
                            	  6265: *        BYTE RIGHT
00:00003F92 203C80018F81    	  6266:                 move.l #$80018F81,d0
00:00003F98 7C02            	  6267:                 moveq  #$00000002,d6
                            	  6268: SHIFTS_LOOP2:
00:00003F9A EC20            	  6269:                 asr.b d6,d0
00:00003F9C 61C6            	  6270:                 bsr SHIFTS_FLAGS
00:00003F9E 51CEFFFA        	  6271:                 dbf d6,SHIFTS_LOOP2
00:00003FA2 0C8080018FF0    	  6272:                 cmpi.l #$80018FF0,d0
00:00003FA8 66FE            	  6273:                 bne.s *
00:00003FAA 0C850000001A    	  6274:                 cmpi.l #$0000001A,d5
00:00003FB0 66FE            	  6275:                 bne.s *
                            	  6276: 
                            	  6277: 
                            	  6278: *        WORD LEFT
00:00003FB2 203C80018FF1    	  6279:                 move.l #$80018FF1,d0
00:00003FB8 7C02            	  6280:                 moveq  #$00000002,d6
                            	  6281: SHIFTS_LOOP3:
00:00003FBA ED60            	  6282:                 asl.w d6,d0
00:00003FBC 61A6            	  6283:                 bsr SHIFTS_FLAGS
00:00003FBE 51CEFFFA        	  6284:                 dbf d6,SHIFTS_LOOP3
00:00003FC2 0C8080017F88    	  6285:                 cmpi.l #$80017F88,d0
00:00003FC8 66FE            	  6286:                 bne.s *
00:00003FCA 0C850000001C    	  6287:                 cmpi.l #$0000001C,d5
00:00003FD0 66FE            	  6288:                 bne.s *
                            	  6289: 
                            	  6290: *        WORD RIGHT
00:00003FD2 203C80018FF1    	  6291:                 move.l #$80018FF1,d0
00:00003FD8 7C02            	  6292:                 moveq  #$00000002,d6
                            	  6293: SHIFTS_LOOP4:
00:00003FDA EC60            	  6294:                 asr.w d6,d0
00:00003FDC 6186            	  6295:                 bsr SHIFTS_FLAGS
00:00003FDE 51CEFFFA        	  6296:                 dbf d6,SHIFTS_LOOP4
00:00003FE2 0C808001F1FE    	  6297:                 cmpi.l #$8001F1FE,d0
00:00003FE8 66FE            	  6298:                 bne.s *
00:00003FEA 0C8500000034    	  6299:                 cmpi.l #$00000034,d5
00:00003FF0 66FE            	  6300:                 bne.s *
                            	  6301: 
                            	  6302: 
                            	  6303: *        LONG LEFT
00:00003FF2 203C80018FF1    	  6304:                 move.l #$80018FF1,d0
00:00003FF8 7C02            	  6305:                 moveq  #$00000002,d6
                            	  6306: SHIFTS_LOOP5:
00:00003FFA EDA0            	  6307:                 asl.l d6,d0
00:00003FFC 6100FF66        	  6308:                 bsr SHIFTS_FLAGS
00:00004000 51CEFFF8        	  6309:                 dbf d6,SHIFTS_LOOP5
00:00004004 0C80000C7F88    	  6310:                 cmpi.l #$000C7F88,d0
00:0000400A 66FE            	  6311:                 bne.s *
00:0000400C 0C8500000036    	  6312:                 cmpi.l #$00000036,d5
00:00004012 66FE            	  6313:                 bne.s *
                            	  6314: 
                            	  6315: *        LONG RIGHT
00:00004014 203C80018FF1    	  6316:                 move.l #$80018FF1,d0
00:0000401A 7C02            	  6317:                 moveq  #$00000002,d6
                            	  6318: SHIFTS_LOOP6:
00:0000401C ECA0            	  6319:                 asr.l d6,d0
00:0000401E 6100FF44        	  6320:                 bsr SHIFTS_FLAGS
00:00004022 51CEFFF8        	  6321:                 dbf d6,SHIFTS_LOOP6
00:00004026 0C80F00031FE    	  6322:                 cmpi.l #$F00031FE,d0
00:0000402C 66FE            	  6323:                 bne.s *
00:0000402E 0C850000004E    	  6324:                 cmpi.l #$0000004E,d5
00:00004034 66FE            	  6325:                 bne.s *
                            	  6326: 
                            	  6327: 
                            	  6328: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6329: 
00:00004036 203C80018FF1    	  6330:                 move.l #$80018FF1,d0
00:0000403C 7A00            	  6331:                 moveq  #$00000000,d5
                            	  6332: 
                            	  6333: *        BYTE LEFT
00:0000403E D000            	  6334:                 asl.b #1,d0
00:00004040 6100FF22        	  6335:                 bsr SHIFTS_FLAGS
00:00004044 E500            	  6336:                 asl.b #2,d0
00:00004046 6100FF1C        	  6337:                 bsr SHIFTS_FLAGS
00:0000404A D000            	  6338:                 asl.b #1,d0
00:0000404C 6100FF16        	  6339:                 bsr SHIFTS_FLAGS
00:00004050 E700            	  6340:                 asl.b #3,d0
00:00004052 6100FF10        	  6341:                 bsr SHIFTS_FLAGS
00:00004056 0C8080018F80    	  6342:                 cmpi.l #$80018F80,d0
00:0000405C 66FE            	  6343:                 bne.s *
00:0000405E 0C850000001F    	  6344:                 cmpi.l #$0000001F,d5
00:00004064 66FE            	  6345:                 bne.s *
                            	  6346: 
                            	  6347: *        BYTE RIGHT
00:00004066 E200            	  6348:                 asr.b #1,d0
00:00004068 6100FEFA        	  6349:                 bsr SHIFTS_FLAGS
00:0000406C E400            	  6350:                 asr.b #2,d0
00:0000406E 6100FEF4        	  6351:                 bsr SHIFTS_FLAGS
00:00004072 E600            	  6352:                 asr.b #3,d0
00:00004074 6100FEEE        	  6353:                 bsr SHIFTS_FLAGS
00:00004078 E200            	  6354:                 asr.b #1,d0
00:0000407A 6100FEE8        	  6355:                 bsr SHIFTS_FLAGS
00:0000407E 0C8080018FFF    	  6356:                 cmpi.l #$80018FFF,d0
00:00004084 66FE            	  6357:                 bne.s *
00:00004086 0C850000003F    	  6358:                 cmpi.l #$0000003F,d5
00:0000408C 66FE            	  6359:                 bne.s *
                            	  6360: 
                            	  6361: *        WORD LEFT
00:0000408E D040            	  6362:                 asl.w #1,d0
00:00004090 6100FED2        	  6363:                 bsr SHIFTS_FLAGS
00:00004094 E540            	  6364:                 asl.w #2,d0
00:00004096 6100FECC        	  6365:                 bsr SHIFTS_FLAGS
00:0000409A E740            	  6366:                 asl.w #3,d0
00:0000409C 6100FEC6        	  6367:                 bsr SHIFTS_FLAGS
00:000040A0 EB40            	  6368:                 asl.w #5,d0
00:000040A2 6100FEC0        	  6369:                 bsr SHIFTS_FLAGS
00:000040A6 0C808001F800    	  6370:                 cmpi.l #$8001F800,d0
00:000040AC 66FE            	  6371:                 bne.s *
00:000040AE 0C8500000056    	  6372:                 cmpi.l #$00000056,d5
00:000040B4 66FE            	  6373:                 bne.s *
                            	  6374: 
                            	  6375: *        WORD RIGHT
00:000040B6 EA40            	  6376:                 asr.w #5,d0
00:000040B8 6100FEAA        	  6377:                 bsr SHIFTS_FLAGS
00:000040BC E240            	  6378:                 asr.w #1,d0
00:000040BE 6100FEA4        	  6379:                 bsr SHIFTS_FLAGS
00:000040C2 E440            	  6380:                 asr.w #2,d0
00:000040C4 6100FE9E        	  6381:                 bsr SHIFTS_FLAGS
00:000040C8 E840            	  6382:                 asr.w #4,d0
00:000040CA 6100FE98        	  6383:                 bsr SHIFTS_FLAGS
00:000040CE 0C808001FFFF    	  6384:                 cmpi.l #$8001FFFF,d0
00:000040D4 66FE            	  6385:                 bne.s *
00:000040D6 0C8500000077    	  6386:                 cmpi.l #$00000077,d5
00:000040DC 66FE            	  6387:                 bne.s *
                            	  6388: 
                            	  6389: *        LONG LEFT
00:000040DE 203C80018FF1    	  6390:                 move.l #$80018FF1,d0
00:000040E4 D080            	  6391:                 asl.l #1,d0
00:000040E6 6100FE7C        	  6392:                 bsr SHIFTS_FLAGS
00:000040EA E580            	  6393:                 asl.l #2,d0
00:000040EC 6100FE76        	  6394:                 bsr SHIFTS_FLAGS
00:000040F0 EF80            	  6395:                 asl.l #7,d0
00:000040F2 6100FE70        	  6396:                 bsr SHIFTS_FLAGS
00:000040F6 E980            	  6397:                 asl.l #4,d0
00:000040F8 6100FE6A        	  6398:                 bsr SHIFTS_FLAGS
00:000040FC 0C8063FC4000    	  6399:                 cmpi.l #$63FC4000,d0
00:00004102 66FE            	  6400:                 bne.s *
00:00004104 0C850000007A    	  6401:                 cmpi.l #$0000007A,d5
00:0000410A 66FE            	  6402:                 bne.s *
                            	  6403: 
                            	  6404: *        LONG RIGHT
00:0000410C 203C80018FF1    	  6405:                 move.l #$80018FF1,d0
00:00004112 E280            	  6406:                 asr.l #1,d0
00:00004114 6100FE4E        	  6407:                 bsr SHIFTS_FLAGS
00:00004118 EA80            	  6408:                 asr.l #5,d0
00:0000411A 6100FE48        	  6409:                 bsr SHIFTS_FLAGS
00:0000411E EE80            	  6410:                 asr.l #7,d0
00:00004120 6100FE42        	  6411:                 bsr SHIFTS_FLAGS
00:00004124 E080            	  6412:                 asr.l #8,d0
00:00004126 6100FE3C        	  6413:                 bsr SHIFTS_FLAGS
00:0000412A 0C80FFFFFC00    	  6414:                 cmpi.l #$FFFFFC00,d0
00:00004130 66FE            	  6415:                 bne.s *
00:00004132 0C850000009C    	  6416:                 cmpi.l #$0000009C,d5
00:00004138 66FE            	  6417:                 bne.s *
                            	  6418: 
                            	  6419: 
                            	  6420: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6421: 
00:0000413A 7A00            	  6422:                 moveq  #$00000000,d5
00:0000413C 307C0100        	  6423:                 move.l #$00000100,a0
00:00004140 30BC8FF1        	  6424:                 move.w #$8FF1,(a0)
                            	  6425: 
                            	  6426: *        WORD LEFT
00:00004144 E1D0            	  6427:                 asl  (a0)
00:00004146 6100FE1C        	  6428:                 bsr SHIFTS_FLAGS
00:0000414A E1D0            	  6429:                 asl  (a0)
00:0000414C 6100FE16        	  6430:                 bsr SHIFTS_FLAGS
00:00004150 E1D0            	  6431:                 asl  (a0)
00:00004152 6100FE10        	  6432:                 bsr SHIFTS_FLAGS
00:00004156 E1D0            	  6433:                 asl  (a0)
00:00004158 6100FE0A        	  6434:                 bsr SHIFTS_FLAGS
00:0000415C 3010            	  6435:                 move.w (a0),d0
00:0000415E 0C80FFFFFF10    	  6436:                 cmpi.l #$FFFFFF10,d0
00:00004164 66FE            	  6437:                 bne.s *
00:00004166 0C850000000D    	  6438:                 cmpi.l #$0000000D,d5
00:0000416C 66FE            	  6439:                 bne.s *
                            	  6440: 
                            	  6441: *        WORD RIGHT
00:0000416E E0D0            	  6442:                 asr (a0)
00:00004170 6100FDF2        	  6443:                 bsr SHIFTS_FLAGS
00:00004174 E0D0            	  6444:                 asr (a0)
00:00004176 6100FDEC        	  6445:                 bsr SHIFTS_FLAGS
00:0000417A E0D0            	  6446:                 asr (a0)
00:0000417C 6100FDE6        	  6447:                 bsr SHIFTS_FLAGS
00:00004180 E0D0            	  6448:                 asr (a0)
00:00004182 6100FDE0        	  6449:                 bsr SHIFTS_FLAGS
00:00004186 E0D0            	  6450:                 asr (a0)
00:00004188 6100FDDA        	  6451:                 bsr SHIFTS_FLAGS
00:0000418C E0D0            	  6452:                 asr (a0)
00:0000418E 6100FDD4        	  6453:                 bsr SHIFTS_FLAGS
00:00004192 3010            	  6454:                 move.w (a0),d0
00:00004194 0C80FFFFFFFC    	  6455:                 cmpi.l #$FFFFFFFC,d0
00:0000419A 66FE            	  6456:                 bne.s *
00:0000419C 0C850000003E    	  6457:                 cmpi.l #$0000003E,d5
00:000041A2 66FE            	  6458:                 bne.s *
                            	  6459: 
00:000041A4 4E75            	  6460:                 rts
                            	  6461: 
                            	  6462: 
                            	  6463: 
                            	  6464: *-----------------------------------------------------------
                            	  6465: *-----------------------------------------------------------
                            	  6466: * OPCODE : SHIFTS2
                            	  6467: *-----------------------------------------------------------
                            	  6468: *-----------------------------------------------------------
                            	  6469: 
                            	  6470: *     Subroutine to check and accumulate the flags
00:000041A6 40C3            	  6471: SHIFTS2_FLAGS:  move.w sr,d3
00:000041A8 02830000000F    	  6472:                 andi.l #$0F,d3            * Isolate flags
00:000041AE DA83            	  6473:                 add.l d3,d5               * Copy flag results into accumulator
00:000041B0 4E75            	  6474:                 rts
                            	  6475: 
                            	  6476: op_SHIFTS2:
                            	  6477: 
                            	  6478: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6479: 
                            	  6480: *        BYTE LEFT
00:000041B2 203C80018F81    	  6481:                 move.l #$80018F81,d0
00:000041B8 7A00            	  6482:                 moveq  #$00000000,d5
00:000041BA 7C02            	  6483:                 moveq  #$00000002,d6
                            	  6484: SHIFTS2_LOOP1:
00:000041BC ED28            	  6485:                 lsl.b d6,d0
00:000041BE 61E6            	  6486:                 bsr SHIFTS2_FLAGS
00:000041C0 51CEFFFA        	  6487:                 dbf d6,SHIFTS2_LOOP1
00:000041C4 0C8080018F08    	  6488:                 cmpi.l #$80018F08,d0
00:000041CA 66FE            	  6489:                 bne.s *
00:000041CC 4A85            	  6490:                 cmpi.l #$00000000,d5
00:000041CE 66FE            	  6491:                 bne.s *
                            	  6492: 
                            	  6493: *        BYTE RIGHT
00:000041D0 203C80018F81    	  6494:                 move.l #$80018F81,d0
00:000041D6 7C02            	  6495:                 moveq  #$00000002,d6
                            	  6496: SHIFTS2_LOOP2:
00:000041D8 EC28            	  6497:                 lsr.b d6,d0
00:000041DA 61CA            	  6498:                 bsr SHIFTS2_FLAGS
00:000041DC 51CEFFFA        	  6499:                 dbf d6,SHIFTS2_LOOP2
00:000041E0 0C8080018F10    	  6500:                 cmpi.l #$80018F10,d0
00:000041E6 66FE            	  6501:                 bne.s *
00:000041E8 4A85            	  6502:                 cmpi.l #$00000000,d5
00:000041EA 66FE            	  6503:                 bne.s *
                            	  6504: 
                            	  6505: 
                            	  6506: *        WORD LEFT
00:000041EC 203C80018FF1    	  6507:                 move.l #$80018FF1,d0
00:000041F2 7C02            	  6508:                 moveq  #$00000002,d6
                            	  6509: SHIFTS2_LOOP3:
00:000041F4 ED68            	  6510:                 lsl.w d6,d0
00:000041F6 61AE            	  6511:                 bsr SHIFTS2_FLAGS
00:000041F8 51CEFFFA        	  6512:                 dbf d6,SHIFTS2_LOOP3
00:000041FC 0C8080017F88    	  6513:                 cmpi.l #$80017F88,d0
00:00004202 66FE            	  6514:                 bne.s *
00:00004204 4A85            	  6515:                 cmpi.l #$00000000,d5
00:00004206 66FE            	  6516:                 bne.s *
                            	  6517: 
                            	  6518: *        WORD RIGHT
00:00004208 203C80018FF1    	  6519:                 move.l #$80018FF1,d0
00:0000420E 7C02            	  6520:                 moveq  #$00000002,d6
                            	  6521: SHIFTS2_LOOP4:
00:00004210 EC68            	  6522:                 lsr.w d6,d0
00:00004212 6192            	  6523:                 bsr SHIFTS2_FLAGS
00:00004214 51CEFFFA        	  6524:                 dbf d6,SHIFTS2_LOOP4
00:00004218 0C80800111FE    	  6525:                 cmpi.l #$800111FE,d0
00:0000421E 66FE            	  6526:                 bne.s *
00:00004220 4A85            	  6527:                 cmpi.l #$00000000,d5
00:00004222 66FE            	  6528:                 bne.s *
                            	  6529: 
                            	  6530: 
                            	  6531: *        LONG LEFT
00:00004224 203C80018FF1    	  6532:                 move.l #$80018FF1,d0
00:0000422A 7C02            	  6533:                 moveq  #$00000002,d6
                            	  6534: SHIFTS2_LOOP5:
00:0000422C EDA8            	  6535:                 lsl.l d6,d0
00:0000422E 6100FF76        	  6536:                 bsr SHIFTS2_FLAGS
00:00004232 51CEFFF8        	  6537:                 dbf d6,SHIFTS2_LOOP5
00:00004236 0C80000C7F88    	  6538:                 cmpi.l #$000C7F88,d0
00:0000423C 66FE            	  6539:                 bne.s *
00:0000423E 4A85            	  6540:                 cmpi.l #$00000000,d5
00:00004240 66FE            	  6541:                 bne.s *
                            	  6542: 
                            	  6543: *        LONG RIGHT
00:00004242 203C80018FF1    	  6544:                 move.l #$80018FF1,d0
00:00004248 7C02            	  6545:                 moveq  #$00000002,d6
                            	  6546: SHIFTS2_LOOP6:
00:0000424A ECA8            	  6547:                 lsr.l d6,d0
00:0000424C 6100FF58        	  6548:                 bsr SHIFTS2_FLAGS
00:00004250 51CEFFF8        	  6549:                 dbf d6,SHIFTS2_LOOP6
00:00004254 0C80100031FE    	  6550:                 cmpi.l #$100031FE,d0
00:0000425A 66FE            	  6551:                 bne.s *
00:0000425C 4A85            	  6552:                 cmpi.l #$00000000,d5
00:0000425E 66FE            	  6553:                 bne.s *
                            	  6554: 
                            	  6555: 
                            	  6556: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6557: 
00:00004260 203C80018FF1    	  6558:                 move.l #$80018FF1,d0
00:00004266 7A00            	  6559:                 moveq  #$00000000,d5
                            	  6560: 
                            	  6561: *        BYTE LEFT
00:00004268 E308            	  6562:                 lsl.b #1,d0
00:0000426A 6100FF3A        	  6563:                 bsr SHIFTS2_FLAGS
00:0000426E E508            	  6564:                 lsl.b #2,d0
00:00004270 6100FF34        	  6565:                 bsr SHIFTS2_FLAGS
00:00004274 E308            	  6566:                 lsl.b #1,d0
00:00004276 6100FF2E        	  6567:                 bsr SHIFTS2_FLAGS
00:0000427A E708            	  6568:                 lsl.b #3,d0
00:0000427C 6100FF28        	  6569:                 bsr SHIFTS2_FLAGS
00:00004280 0C8080018F80    	  6570:                 cmpi.l #$80018F80,d0
00:00004286 66FE            	  6571:                 bne.s *
00:00004288 0C850000001B    	  6572:                 cmpi.l #$0000001B,d5
00:0000428E 66FE            	  6573:                 bne.s *
                            	  6574: 
                            	  6575: *        BYTE RIGHT
00:00004290 E208            	  6576:                 lsr.b #1,d0
00:00004292 6100FF12        	  6577:                 bsr SHIFTS2_FLAGS
00:00004296 E408            	  6578:                 lsr.b #2,d0
00:00004298 6100FF0C        	  6579:                 bsr SHIFTS2_FLAGS
00:0000429C E608            	  6580:                 lsr.b #3,d0
00:0000429E 6100FF06        	  6581:                 bsr SHIFTS2_FLAGS
00:000042A2 E208            	  6582:                 lsr.b #1,d0
00:000042A4 6100FF00        	  6583:                 bsr SHIFTS2_FLAGS
00:000042A8 0C8080018F01    	  6584:                 cmpi.l #$80018F01,d0
00:000042AE 66FE            	  6585:                 bne.s *
00:000042B0 0C850000001B    	  6586:                 cmpi.l #$0000001B,d5
00:000042B6 66FE            	  6587:                 bne.s *
                            	  6588: 
                            	  6589: *        WORD LEFT
00:000042B8 E348            	  6590:                 lsl.w #1,d0
00:000042BA 6100FEEA        	  6591:                 bsr SHIFTS2_FLAGS
00:000042BE E548            	  6592:                 lsl.w #2,d0
00:000042C0 6100FEE4        	  6593:                 bsr SHIFTS2_FLAGS
00:000042C4 E748            	  6594:                 lsl.w #3,d0
00:000042C6 6100FEDE        	  6595:                 bsr SHIFTS2_FLAGS
00:000042CA EB48            	  6596:                 lsl.w #5,d0
00:000042CC 6100FED8        	  6597:                 bsr SHIFTS2_FLAGS
00:000042D0 0C8080010800    	  6598:                 cmpi.l #$80010800,d0
00:000042D6 66FE            	  6599:                 bne.s *
00:000042D8 0C8500000025    	  6600:                 cmpi.l #$00000025,d5
00:000042DE 66FE            	  6601:                 bne.s *
                            	  6602: 
                            	  6603: *        WORD RIGHT
00:000042E0 EA48            	  6604:                 lsr.w #5,d0
00:000042E2 6100FEC2        	  6605:                 bsr SHIFTS2_FLAGS
00:000042E6 E248            	  6606:                 lsr.w #1,d0
00:000042E8 6100FEBC        	  6607:                 bsr SHIFTS2_FLAGS
00:000042EC E448            	  6608:                 lsr.w #2,d0
00:000042EE 6100FEB6        	  6609:                 bsr SHIFTS2_FLAGS
00:000042F2 E848            	  6610:                 lsr.w #4,d0
00:000042F4 6100FEB0        	  6611:                 bsr SHIFTS2_FLAGS
00:000042F8 0C8080010000    	  6612:                 cmpi.l #$80010000,d0
00:000042FE 66FE            	  6613:                 bne.s *
00:00004300 0C850000002A    	  6614:                 cmpi.l #$0000002A,d5
00:00004306 66FE            	  6615:                 bne.s *
                            	  6616: 
                            	  6617: *        LONG LEFT
00:00004308 203C80018FF1    	  6618:                 move.l #$80018FF1,d0
00:0000430E E388            	  6619:                 lsl.l #1,d0
00:00004310 6100FE94        	  6620:                 bsr SHIFTS2_FLAGS
00:00004314 E588            	  6621:                 lsl.l #2,d0
00:00004316 6100FE8E        	  6622:                 bsr SHIFTS2_FLAGS
00:0000431A EF88            	  6623:                 lsl.l #7,d0
00:0000431C 6100FE88        	  6624:                 bsr SHIFTS2_FLAGS
00:00004320 E988            	  6625:                 lsl.l #4,d0
00:00004322 6100FE82        	  6626:                 bsr SHIFTS2_FLAGS
00:00004326 0C8063FC4000    	  6627:                 cmpi.l #$63FC4000,d0
00:0000432C 66FE            	  6628:                 bne.s *
00:0000432E 0C850000002B    	  6629:                 cmpi.l #$0000002B,d5
00:00004334 66FE            	  6630:                 bne.s *
                            	  6631: 
                            	  6632: *        LONG RIGHT
00:00004336 203C80018FF1    	  6633:                 move.l #$80018FF1,d0
00:0000433C E288            	  6634:                 lsr.l #1,d0
00:0000433E 6100FE66        	  6635:                 bsr SHIFTS2_FLAGS
00:00004342 EA88            	  6636:                 lsr.l #5,d0
00:00004344 6100FE60        	  6637:                 bsr SHIFTS2_FLAGS
00:00004348 EE88            	  6638:                 lsr.l #7,d0
00:0000434A 6100FE5A        	  6639:                 bsr SHIFTS2_FLAGS
00:0000434E E088            	  6640:                 lsr.l #8,d0
00:00004350 6100FE54        	  6641:                 bsr SHIFTS2_FLAGS
00:00004354 0C8000000400    	  6642:                 cmpi.l #$00000400,d0
00:0000435A 66FE            	  6643:                 bne.s *
00:0000435C 0C850000002D    	  6644:                 cmpi.l #$0000002D,d5
00:00004362 66FE            	  6645:                 bne.s *
                            	  6646: 
                            	  6647: 
                            	  6648: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6649: 
00:00004364 7A00            	  6650:                 moveq  #$00000000,d5
00:00004366 307C0100        	  6651:                 move.l #$00000100,a0
00:0000436A 30BC8FF1        	  6652:                 move.w #$8FF1,(a0)
                            	  6653: 
                            	  6654: *        WORD LEFT
00:0000436E E3D0            	  6655:                 lsl  (a0)
00:00004370 6100FE34        	  6656:                 bsr SHIFTS2_FLAGS
00:00004374 E3D0            	  6657:                 lsl  (a0)
00:00004376 6100FE2E        	  6658:                 bsr SHIFTS2_FLAGS
00:0000437A E3D0            	  6659:                 lsl  (a0)
00:0000437C 6100FE28        	  6660:                 bsr SHIFTS2_FLAGS
00:00004380 E3D0            	  6661:                 lsl  (a0)
00:00004382 6100FE22        	  6662:                 bsr SHIFTS2_FLAGS
00:00004386 3010            	  6663:                 move.w (a0),d0
00:00004388 0C800000FF10    	  6664:                 cmpi.l #$0000FF10,d0
00:0000438E 66FE            	  6665:                 bne.s *
00:00004390 0C8500000009    	  6666:                 cmpi.l #$00000009,d5
00:00004396 66FE            	  6667:                 bne.s *
                            	  6668: 
                            	  6669: *        WORD RIGHT
00:00004398 E2D0            	  6670:                 lsr (a0)
00:0000439A 6100FE0A        	  6671:                 bsr SHIFTS2_FLAGS
00:0000439E E2D0            	  6672:                 lsr (a0)
00:000043A0 6100FE04        	  6673:                 bsr SHIFTS2_FLAGS
00:000043A4 E2D0            	  6674:                 lsr (a0)
00:000043A6 6100FDFE        	  6675:                 bsr SHIFTS2_FLAGS
00:000043AA E2D0            	  6676:                 lsr (a0)
00:000043AC 6100FDF8        	  6677:                 bsr SHIFTS2_FLAGS
00:000043B0 E2D0            	  6678:                 lsr (a0)
00:000043B2 6100FDF2        	  6679:                 bsr SHIFTS2_FLAGS
00:000043B6 E2D0            	  6680:                 lsr (a0)
00:000043B8 6100FDEC        	  6681:                 bsr SHIFTS2_FLAGS
00:000043BC 3010            	  6682:                 move.w (a0),d0
00:000043BE 0C80000003FC    	  6683:                 cmpi.l #$000003FC,d0
00:000043C4 66FE            	  6684:                 bne.s *
00:000043C6 0C850000000A    	  6685:                 cmpi.l #$0000000A,d5
00:000043CC 66FE            	  6686:                 bne.s *
                            	  6687: 
00:000043CE 4E75            	  6688:                 rts
                            	  6689: 
                            	  6690: ;-----------------------------------------------------------
                            	  6691: ;-----------------------------------------------------------
                            	  6692: ; OPCODE : BSR / RTS
                            	  6693: ;-----------------------------------------------------------
                            	  6694: ;-----------------------------------------------------------
                            	  6695: 
                            	  6696: ;t3_bsr:
                            	  6697: ;	moveq	#3,d3
                            	  6698: ;	rts
                            	  6699: 
                            	  6700: ;t1_bsr:
                            	  6701: ;	moveq	#1,d1
                            	  6702: ;	rts
                            	  6703: 
                            	  6704: ;op_bsr:
                            	  6705: ;	bsr			t1_bsr
                            	  6706: ;	bsr			t2_bsr
                            	  6707: ;	bsr.w		t3_bsr
                            	  6708: ;	bsr.w		t4_bsr
                            	  6709: ;	cmpi.l	#1,d1
                            	  6710: ;	bne			*
                            	  6711: ;	cmpi.l	#2,d2
                            	  6712: ;	bne			*
                            	  6713: ;	cmpi.l	#3,d3
                            	  6714: ;	bne			*
                            	  6715: ;	cmpi.l	#4,d4
                            	  6716: ;	bne			*
                            	  6717: ;	rts
                            	  6718: 
                            	  6719: ;t2_bsr:
                            	  6720: ;	moveq	#2,d2
                            	  6721: ;	rts
                            	  6722: 	
                            	  6723: ;t4_bsr:
                            	  6724: ;	moveq	#4,d4
                            	  6725: ;	rts
                            	  6726: *    END
                            	  6727:     
                            	  6728: 

Source: "boot.x68"
                            	  1006: 	include "TinyBasicFlt.x68"

Source: "TinyBasicFlt.x68"
                            	     1: ******************************************************************
                            	     2: *								 *
                            	     3: *		Tiny Float BASIC for the Motorola MC68000		 *
                            	     4: *								 *
                            	     5: * Derived from Palo Alto Tiny BASIC as published in the May 1976 *
                            	     6: * issue of Dr. Dobb's Journal.  Adapted to the 68000 by:         *
                            	     7: *	Gordon Brandly						 *
                            	     8: *								 *
                            	     9: ******************************************************************
                            	    10: *    Copyright (C) 1984 by Gordon Brandly. This program may be	 *
                            	    11: *    freely distributed for personal use only. All commercial	 *
                            	    12: *		       rights are reserved.			 *
                            	    13: ******************************************************************
                            	    14: * Modified (c) 2022 for the rf68000. Robert Finch
                            	    15: * Numerics changed to floating-point
                            	    16: * added string handling
                            	    17: ******************************************************************
                            	    18: 
                            	    19: * Vers. 1.0  1984/7/17	- Original version by Gordon Brandly
                            	    20: *	1.1  1984/12/9	- Addition of '$' print term by Marvin Lipford
                            	    21: *	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                            	    22: 
                            	    23: *	OPT	FRS,BRS 	forward ref.'s & branches default to short
                            	    24: 
                            	    25: ;CR	EQU	$0D		ASCII equates
                            	    26: ;LF	EQU	$0A
                            	    27: ;TAB	EQU	$09
                            	    28: ;CTRLC	EQU	$03
                            	    29: ;CTRLH	EQU	$08
                            	    30: ;CTRLS	EQU	$13
                            	    31: ;CTRLX	EQU	$18
                            	    32: 
                            	    33: DT_NONE equ 0
                            	    34: DT_NUMERIC equ 1
                            	    35: DT_STRING equ 2		; string descriptor
                            	    36: DT_TEXTPTR equ 3	; pointer into program text
                            	    37: 
                            	    38: BUFLEN	EQU	80		length of keyboard input buffer
                            	    39: STRAREASIZE	EQU	2048	; size of string area
                            	    40: 	CODE
                            	    41: *	ORG	$10000		first free address using Tutor
                            	    42: *
                            	    43: * Standard jump table. You can change these addresses if you are
                            	    44: * customizing this interpreter for a different environment.
                            	    45: *
00:000043D0 6020            	    46: START	BRA	CSTART		Cold Start entry point
00:000043D2 60000088        	    47: GOWARM	BRA	WSTART		Warm Start entry point
00:000043D6 60001460        	    48: GOOUT	BRA OUTC		Jump to character-out routine
00:000043DA 6000146C        	    49: GOIN	BRA INC		Jump to character-in routine
00:000043DE 60001488        	    50: GOAUXO	BRA	AUXOUT		Jump to auxiliary-out routine
00:000043E2 60001498        	    51: GOAUXI	BRA	AUXIN		Jump to auxiliary-in routine
00:000043E6 600014B4        	    52: GOBYE	BRA	BYEBYE		Jump to monitor, DOS, etc.
                            	    53: *
                            	    54: * Modifiable system constants:
                            	    55: *
00:000043EA 00041000        	    56: TXTBGN	DC.L	$41000		beginning of program memory
00:000043EE 00047FF0        	    57: ENDMEM	DC.L	$47FF0		end of available memory
                            	    58: *
                            	    59: * The main interpreter starts here:
                            	    60: *
                            	    61: CSTART
00:000043F2 2E7AFFFA        	    62: 	MOVE.L ENDMEM,SP	initialize stack pointer
00:000043F6 23FC000058540000	    63: 	move.l #INC1,INPPTR
00:000043FE 590C
00:00004400 4239000400A4    	    64: 	move.b #0,InputDevice
00:00004406 13FC0001000400A8	    65: 	move.b #1,OutputDevice
00:0000440E 23FC000000010004	    66: 	move.l #1,_fpTextIncr
00:00004416 0094
00:00004418 4DFA1490        	    67: 	LEA	INITMSG,A6	tell who we are
00:0000441C 61001402        	    68: 	BSR	PRMESG
00:00004420 23FAFFC80000595C	    69: 	MOVE.L TXTBGN,TXTUNF	init. end-of-program pointer
00:00004428 203AFFC4        	    70: 	MOVE.L ENDMEM,D0	get address of end of memory
00:0000442C 23FAFFC000005918	    71: 	move.l ENDMEM,STKFP
00:00004434 90BC00001000    	    72: 	SUB.L	#4096,D0	reserve 4K for the stack
00:0000443A 23C00000594C    	    73: 	MOVE.L D0,STRSTK
00:00004440 D0BC00000020    	    74: 	ADD.L #32,D0
00:00004446 23C000005964    	    75: 	MOVE.L D0,STKLMT
00:0000444C 90BC00000200    	    76: 	SUB.L	#512,D0 	reserve variable area (32 16 byte floats)
00:00004452 23C000005960    	    77: 	MOVE.L D0,VARBGN
00:00004458 610000C2        	    78: 	bsr ClearStringArea
                            	    79: WSTART
00:0000445C 7000            	    80: 	CLR.L	D0		initialize internal variables
00:0000445E 23FC000000010004	    81: 	move.l #1,_fpTextIncr
00:00004466 0094
00:00004468 42B900005948    	    82: 	clr.l IRQROUT
00:0000446E 23C000005924    	    83: 	MOVE.L	D0,LOPVAR
00:00004474 23C00000591C    	    84: 	MOVE.L	D0,STKGOS
00:0000447A 23C000005914    	    85: 	MOVE.L	D0,CURRNT	; current line number pointer = 0
00:00004480 2E7AFF6C        	    86: 	MOVE.L ENDMEM,SP	; init S.P. again, just in case
00:00004484 610000B6        	    87: 	bsr ClearStringStack
00:00004488 4DFA1444        	    88: 	LEA	OKMSG,A6			; display "OK"
00:0000448C 61001392        	    89: 	bsr	PRMESG
                            	    90: ST3
00:00004490 103C003E        	    91: 	MOVE.B	#'>',D0         Prompt with a '>' and
00:00004494 610010CE        	    92: 	bsr	GETLN		read a line.
00:00004498 6100132A        	    93: 	bsr	TOUPBUF 	convert to upper case
00:0000449C 2848            	    94: 	MOVE.L	A0,A4		save pointer to end of line
00:0000449E 41FA14CC        	    95: 	LEA	BUFFER,A0	point to the beginning of line
00:000044A2 610012CA        	    96: 	bsr	TSTNUM		is there a number there?
00:000044A6 61001312        	    97: 	bsr	IGNBLK		skip trailing blanks
00:000044AA F2016080        	    98: 	FMOVE.L FP1,D1
00:000044AE 4A82            	    99: 	TST.L D2			; does line no. exist? (or nonzero?)
00:000044B0 67000246        	   100: 	BEQ	DIRECT		; if not, it's a direct statement
00:000044B4 B2BC0000FFFF    	   101: 	CMP.L	#$FFFF,D1	see if line no. is <= 16 bits
00:000044BA 6400109A        	   102: 	BCC	QHOW		if not, we've overflowed
00:000044BE 1101            	   103: 	MOVE.B	D1,-(A0)	store the binary line no.
00:000044C0 E059            	   104: 	ROR	#8,D1		(Kludge to store a word on a
00:000044C2 1101            	   105: 	MOVE.B	D1,-(A0)	possible byte boundary)
00:000044C4 E159            	   106: 	ROL	#8,D1
00:000044C6 6100113A        	   107: 	bsr	FNDLN		find this line in save area
00:000044CA 2A49            	   108: 	MOVE.L	A1,A5		save possible line pointer
00:000044CC 6614            	   109: 	BNE	ST4		if not found, insert
00:000044CE 61001158        	   110: 	bsr	FNDNXT		find the next line (into A1)
00:000044D2 244D            	   111: 	MOVE.L	A5,A2		pointer to line to be deleted
00:000044D4 267A1486        	   112: 	MOVE.L	TXTUNF,A3	points to top of save area
00:000044D8 6100115E        	   113: 	bsr	MVUP		move up to delete
00:000044DC 23CA0000595C    	   114: 	MOVE.L	A2,TXTUNF	update the end pointer
                            	   115: ST4
00:000044E2 200C            	   116: 	MOVE.L	A4,D0		calculate the length of new line
00:000044E4 9088            	   117: 	SUB.L	A0,D0
00:000044E6 B0BC00000003    	   118: 	CMP.L	#3,D0		is it just a line no. & CR?
00:000044EC 6FA2            	   119: 	BLE	ST3		if so, it was just a delete
00:000044EE 267A146C        	   120: 	MOVE.L TXTUNF,A3	compute new end
00:000044F2 2C4B            	   121: 	MOVE.L A3,A6
00:000044F4 D7C0            	   122: 	ADD.L	D0,A3
00:000044F6 203A145C        	   123: 	MOVE.L StrArea,D0	see if there's enough room
00:000044FA B08B            	   124: 	CMP.L	A3,D0
00:000044FC 63001050        	   125: 	BLS	QSORRY		if not, say so
00:00004500 23CB0000595C    	   126: 	MOVE.L	A3,TXTUNF	if so, store new end position
00:00004506 224E            	   127: 	MOVE.L	A6,A1		points to old unfilled area
00:00004508 244D            	   128: 	MOVE.L	A5,A2		points to beginning of move area
00:0000450A 61001140        	   129: 	bsr	MVDOWN		move things out of the way
00:0000450E 2248            	   130: 	MOVE.L	A0,A1		set up to do the insertion
00:00004510 244D            	   131: 	MOVE.L	A5,A2
00:00004512 264C            	   132: 	MOVE.L	A4,A3
00:00004514 61001122        	   133: 	bsr	MVUP		do it
00:00004518 6000FF76        	   134: 	BRA	ST3		go back and get another line
                            	   135: 
                            	   136: ClearStringArea:
00:0000451C 203A1442        	   137: 	move.l VARBGN,d0
00:00004520 90BC00000800    	   138: 	SUB.L #STRAREASIZE,D0
00:00004526 23C000005954    	   139: 	MOVE.L D0,StrArea
00:0000452C 23C000005958    	   140: 	MOVE.L D0,LastStr
00:00004532 207A1420        	   141: 	move.l StrArea,a0
00:00004536 4298            	   142: 	clr.l (a0)+
00:00004538 4298            	   143: 	clr.l (a0)+
00:0000453A 4E75            	   144: 	rts
                            	   145: 
                            	   146: ClearStringStack:
00:0000453C 7007            	   147: 	moveq #7,d0
00:0000453E 227A140C        	   148: 	move.l STRSTK,a1
                            	   149: .0001
00:00004542 4299            	   150: 	clr.l (a1)+				; clear the string stack
00:00004544 51C8FFFC        	   151: 	dbra d0,.0001
00:00004548 23C900005950    	   152: 	move.l a1,StrSp		; set string stack stack pointer
00:0000454E 4E75            	   153: 	rts
                            	   154: 
                            	   155: 	even
                            	   156: 
                            	   157: *******************************************************************
                            	   158: *
                            	   159: * *** Tables *** DIRECT *** EXEC ***
                            	   160: *
                            	   161: * This section of the code tests a string against a table. When
                            	   162: * a match is found, control is transferred to the section of
                            	   163: * code according to the table.
                            	   164: *
                            	   165: * At 'EXEC', A0 should point to the string, A1 should point to
                            	   166: * the character table, and A2 should point to the execution
                            	   167: * table. At 'DIRECT', A0 should point to the string, A1 and
                            	   168: * A2 will be set up to point to TAB1 and TAB1_1, which are
                            	   169: * the tables of all direct and statement commands.
                            	   170: *
                            	   171: * A '.' in the string will terminate the test and the partial
                            	   172: * match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                            	   173: * 'PRIN.', or 'PRINT' will all match 'PRINT'.
                            	   174: *
                            	   175: * There are two tables: the character table and the execution
                            	   176: * table. The character table consists of any number of text items.
                            	   177: * Each item is a string of characters with the last character's
                            	   178: * high bit set to one. The execution table holds a 16-bit
                            	   179: * execution addresses that correspond to each entry in the
                            	   180: * character table.
                            	   181: *
                            	   182: * The end of the character table is a 0 byte which corresponds
                            	   183: * to the default routine in the execution table, which is
                            	   184: * executed if none of the other table items are matched.
                            	   185: *
                            	   186: * Character-matching tables:
                            	   187: TAB1
00:00004550 3C434F          	   188: 	DC.B	'<CO',('M'+$80)
00:00004553 CD
00:00004554 3C434F          	   189: 	DC.B	'<CO',('N'+$80)
00:00004557 CE
00:00004558 3E434F          	   190: 	DC.B	'>CO',('M'+$80)
00:0000455B CD
00:0000455C 3E434F          	   191: 	DC.B	'>CO',('N'+$80)
00:0000455F CE
00:00004560 3C3E434F        	   192: 	DC.B	'<>CO',('M'+$80)
00:00004564 CD
00:00004565 3C3E434F        	   193: 	DC.B	'<>CO',('N'+$80)
00:00004569 CE
00:0000456A 4C4953          	   194: 	DC.B	'LIS',('T'+$80)         Direct commands
00:0000456D D4
00:0000456E 4C4F41          	   195: 	DC.B	'LOA',('D'+$80)
00:00004571 C4
00:00004572 4E45            	   196: 	DC.B	'NE',('W'+$80)
00:00004574 D7
00:00004575 5255            	   197: 	DC.B	'RU',('N'+$80)
00:00004577 CE
00:00004578 534156          	   198: 	DC.B	'SAV',('E'+$80)
00:0000457B C5
00:0000457C 434C            	   199: 	DC.B 	'CL',('S'+$80)
00:0000457E D3
                            	   200: TAB2
00:0000457F 4E4558          	   201: 	DC.B	'NEX',('T'+$80)         Direct / statement
00:00004582 D4
00:00004583 4C45            	   202: 	DC.B	'LE',('T'+$80)
00:00004585 D4
00:00004586 49              	   203: 	DC.B	'I',('F'+$80)
00:00004587 C6
00:00004588 474F54          	   204: 	DC.B	'GOT',('O'+$80)
00:0000458B CF
00:0000458C 474F5355        	   205: 	DC.B	'GOSU',('B'+$80)
00:00004590 C2
00:00004591 5245545552      	   206: 	DC.B	'RETUR',('N'+$80)
00:00004596 CE
00:00004597 5245            	   207: 	DC.B	'RE',('M'+$80)
00:00004599 CD
00:0000459A 464F            	   208: 	DC.B	'FO',('R'+$80)
00:0000459C D2
00:0000459D 494E5055        	   209: 	DC.B	'INPU',('T'+$80)
00:000045A1 D4
00:000045A2 5052494E        	   210: 	DC.B	'PRIN',('T'+$80)
00:000045A6 D4
00:000045A7 504F4B          	   211: 	DC.B	'POK',('E'+$80)
00:000045AA C5
00:000045AB 53544F          	   212: 	DC.B	'STO',('P'+$80)
00:000045AE D0
00:000045AF 4259            	   213: 	DC.B	'BY',('E'+$80)
00:000045B1 C5
00:000045B2 43414C          	   214: 	DC.B	'CAL',('L'+$80)
00:000045B5 CC
00:000045B6 4F4E4952        	   215: 	DC.B	'ONIR',('Q'+$80)
00:000045BA D1
00:000045BB 00              	   216: 	DC.B	0
                            	   217: TAB4
00:000045BC 504545          	   218: 	DC.B	'PEE',('K'+$80)         Functions
00:000045BF CB
00:000045C0 524E            	   219: 	DC.B	'RN',('D'+$80)
00:000045C2 C4
00:000045C3 4142            	   220: 	DC.B	'AB',('S'+$80)
00:000045C5 D3
00:000045C6 53495A          	   221: 	DC.B	'SIZ',('E'+$80)
00:000045C9 C5
00:000045CA 544943          	   222: 	DC.B	'TIC',('K'+$80)
00:000045CD CB
00:000045CE 434F52454E      	   223: 	DC.B	'COREN',('O'+$80)
00:000045D3 CF
00:000045D4 4C454654        	   224: 	DC.B	'LEFT',('$'+$80)
00:000045D8 A4
00:000045D9 5249474854      	   225: 	DC.B	'RIGHT',('$'+$80)
00:000045DE A4
00:000045DF 4D4944          	   226: 	DC.B	'MID',('$'+$80)
00:000045E2 A4
00:000045E3 4C45            	   227: 	DC.B	'LE',('N'+$80)
00:000045E5 CE
00:000045E6 494E            	   228: 	DC.B	'IN',('T'+$80)
00:000045E8 D4
00:000045E9 434852          	   229: 	DC.B	'CHR',('$'+$80)
00:000045EC A4
00:000045ED 00              	   230: 	DC.B	0
                            	   231: TAB5
00:000045EE 54              	   232: 	DC.B	'T',('O'+$80)           "TO" in "FOR"
00:000045EF CF
00:000045F0 00              	   233: 	DC.B	0
                            	   234: TAB6
00:000045F1 535445          	   235: 	DC.B	'STE',('P'+$80)         "STEP" in "FOR"
00:000045F4 D0
00:000045F5 00              	   236: 	DC.B	0
                            	   237: TAB8
00:000045F6 3E              	   238: 	DC.B	'>',('='+$80)           Relational operators
00:000045F7 BD
00:000045F8 3C              	   239: 	DC.B	'<',('>'+$80)
00:000045F9 BE
00:000045FA BE              	   240: 	DC.B	('>'+$80)
00:000045FB BD              	   241: 	DC.B	('='+$80)
00:000045FC 3C              	   242: 	DC.B	'<',('='+$80)
00:000045FD BD
00:000045FE BC              	   243: 	DC.B	('<'+$80)
00:000045FF 00              	   244: 	DC.B	0
00:00004600 00              	   245: 	DC.B	0	<- for aligning on a word boundary
                            	   246: TAB9
00:00004601 414E            	   247: 	DC.B	'AN',('D'+$80)
00:00004603 C4
00:00004604 00              	   248: 	DC.B	0
                            	   249: TAB10
00:00004605 4F              	   250: 	DC.B	'O',('R'+$80)
00:00004606 D2
00:00004607 00              	   251: 	DC.B	0
                            	   252: TAB11
00:00004608 4D4F            	   253: 	DC.B	'MO',('D'+$80)
00:0000460A C4
00:0000460B 00              	   254: 	DC.B	0
00:0000460C 00              	   255: 	DC.B	0
                            	   256: 
                            	   257: ; Execution address tables:
                            	   258: 	align 2
                            	   259: TAB1_1	
00:00004610 00004750        	   260: 	DC.L	INCOM
00:00004614 00004742        	   261: 	DC.L	INCON
00:00004618 00004768        	   262: 	DC.L	OUTCOM
00:0000461C 0000477E        	   263: 	DC.L	OUTCON
00:00004620 0000475E        	   264: 	DC.L	IOCOM
00:00004624 00004774        	   265: 	DC.L	IOCON
00:00004628 00004868        	   266: 	DC.L	LIST			Direct commands
00:0000462C 00004B46        	   267: 	DC.L	LOAD
00:00004630 0000478A        	   268: 	DC.L	NEW
00:00004634 000047A6        	   269: 	DC.L	RUN
00:00004638 00004BA6        	   270: 	DC.L	SAVE
00:0000463C 0000582C        	   271: 	DC.L	CLS
                            	   272: TAB2_1
00:00004640 00004A04        	   273: 	DC.L	NEXT			Direct / statement
00:00004644 00004B36        	   274: 	DC.L	LET
00:00004648 00004A70        	   275: 	DC.L	IF
00:0000464C 00004820        	   276: 	DC.L	GOTO
00:00004650 0000491E        	   277: 	DC.L	GOSUB
00:00004654 00004958        	   278: 	DC.L	RETURN
00:00004658 00004A6E        	   279: 	DC.L	REM
00:0000465C 00004984        	   280: 	DC.L	FOR
00:00004660 00004A98        	   281: 	DC.L	INPUT
00:00004664 00004894        	   282: 	DC.L	PRINT
00:00004668 00004C24        	   283: 	DC.L	POKE
00:0000466C 0000479E        	   284: 	DC.L	STOP
00:00004670 000043E6        	   285: 	DC.L	GOBYE
00:00004674 00004C9E        	   286: 	DC.L	CALL
00:00004678 00004834        	   287: 	DC.L	ONIRQ
00:0000467C 00004B2E        	   288: 	DC.L	DEFLT
                            	   289: TAB4_1
00:00004680 0000524E        	   290: 	DC.L	PEEK			; Functions
00:00004684 000052B6        	   291: 	DC.L	RND
00:00004688 000052E0        	   292: 	DC.L	ABS
00:0000468C 000052EC        	   293: 	DC.L	SIZE
00:00004690 000052FC        	   294: 	DC.L	TICK
00:00004694 00005308        	   295: 	DC.L	CORENO
00:00004698 0000541A        	   296: 	DC.L	LEFT
00:0000469C 00005426        	   297: 	DC.L	RIGHT
00:000046A0 00005350        	   298: 	DC.L	MID
00:000046A4 0000544E        	   299: 	DC.L	LEN
00:000046A8 00005474        	   300: 	DC.L	INT
00:000046AC 0000548A        	   301: 	DC.L  CHR
00:000046B0 00004F58        	   302: 	DC.L	XP40
                            	   303: TAB5_1
00:000046B4 0000499E        	   304: 	DC.L	FR1			; "TO" in "FOR"
00:000046B8 0000550E        	   305: 	DC.L	QWHAT
                            	   306: TAB6_1
00:000046BC 000049B6        	   307: 	DC.L	FR2			; "STEP" in "FOR"
00:000046C0 000049BC        	   308: 	DC.L	FR3
                            	   309: TAB8_1
00:000046C4 00004D8E        	   310: 	DC.L	XP11	>=		Relational operators
00:000046C8 00004D9A        	   311: 	DC.L	XP12	<>
00:000046CC 00004DA6        	   312: 	DC.L	XP13	>
00:000046D0 00004DBE        	   313: 	DC.L	XP15	=
00:000046D4 00004DB2        	   314: 	DC.L	XP14	<=
00:000046D8 00004DCC        	   315: 	DC.L	XP16	<
00:000046DC 00004DEA        	   316: 	DC.L	XP17
                            	   317: TAB9_1
00:000046E0 00004D4C        	   318: 	DC.L	XP_AND
00:000046E4 00004D62        	   319: 	DC.L	XP_ANDX
                            	   320: TAB10_1
00:000046E8 00004D24        	   321: 	DC.L	XP_OR
00:000046EC 00004D62        	   322: 	DC.L	XP_ORX
                            	   323: TAB11_1
00:000046F0 00004F2A        	   324: 	DC.L	XP_MOD
00:000046F4 00004EF4        	   325: 	DC.L	XP31
                            	   326: 	even
                            	   327: 	
                            	   328: DIRECT
00:000046F8 33FC000100005968	   329: 	move.w #1,DIRFLG
00:00004700 43FAFE4E        	   330: 	LEA	TAB1,A1
00:00004704 45FAFF0A        	   331: 	LEA	TAB1_1,A2
                            	   332: EXEC
00:00004708 610010B0        	   333: 	bsr	IGNBLK				; ignore leading blanks
00:0000470C 2648            	   334: 	MOVE.L A0,A3			; save the pointer
00:0000470E 4202            	   335: 	CLR.B	D2					; clear match flag
                            	   336: EXLP
00:00004710 1018            	   337: 	MOVE.B (A0)+,D0	 	; get the program character
00:00004712 1211            	   338: 	MOVE.B (A1),D1 		; get the table character
00:00004714 6604            	   339: 	BNE	EXNGO					; If end of table,
00:00004716 204B            	   340: 	MOVE.L A3,A0			; restore the text pointer and...
00:00004718 6024            	   341: 	BRA	EXGO					; execute the default.
                            	   342: EXNGO
00:0000471A 1600            	   343: 	MOVE.B D0,D3		 	; Else check for period...
00:0000471C C602            	   344: 	AND.B	D2,D3				; and a match.
00:0000471E B63C002E        	   345: 	CMP.B	#'.',D3
00:00004722 671A            	   346: 	BEQ	EXGO					; if so, execute
00:00004724 C23C007F        	   347: 	AND.B	#$7F,D1 		; ignore the table's high bit
00:00004728 B200            	   348: 	CMP.B	D0,D1				; is there a match?
00:0000472A 670C            	   349: 	BEQ	EXMAT
00:0000472C 588A            	   350: 	ADDQ.L #4,A2			; if not, try the next entry
00:0000472E 204B            	   351: 	MOVE.L A3,A0			; reset the program pointer
00:00004730 4202            	   352: 	CLR.B	D2					; sorry, no match
                            	   353: EX1
00:00004732 4A19            	   354: 	TST.B	(A1)+				; get to the end of the entry
00:00004734 6AFC            	   355: 	BPL	EX1
00:00004736 60D8            	   356: 	BRA	EXLP					; back for more matching
                            	   357: EXMAT
00:00004738 74FF            	   358: 	MOVEQ	#-1,D2			; we've got a match so far
00:0000473A 4A19            	   359: 	TST.B	(A1)+				; end of table entry?
00:0000473C 6AD2            	   360: 	BPL	EXLP					; if not, go back for more
                            	   361: EXGO
00:0000473E 2652            	   362: 	MOVE.L (A2),A3		; execute the appropriate routine
00:00004740 4ED3            	   363: 	JMP	(A3)
                            	   364: 
                            	   365: *******************************************************************
                            	   366: * Console redirection
                            	   367: * <COM will redirect input to the COM port
                            	   368: * >COM will redirect output to the COM port
                            	   369: * <CON will redirect input to the console
                            	   370: * >CON will redirect output to the console
                            	   371: * <>COM will redirect input and output to the COM port
                            	   372: * <>CON will redirect input and output to the console
                            	   373: *******************************************************************
                            	   374: INCON
00:00004742 23FC000058540000	   375: 	move.l	#INC1,INPPTR
00:0000474A 590C
00:0000474C 600001C8        	   376: 	bra			FINISH
                            	   377: INCOM
00:00004750 23FC0000587C0000	   378: 	move.l	#AUXIN,INPPTR
00:00004758 590C
00:0000475A 600001BA        	   379: 	bra			FINISH
                            	   380: IOCOM
00:0000475E 23FC0000587C0000	   381: 	move.l	#AUXIN,INPPTR
00:00004766 590C
                            	   382: OUTCOM
00:00004768 13FC0002000400A8	   383: 	move.b #2,OutputDevice
00:00004770 600001A4        	   384: 	bra	FINISH
                            	   385: IOCON
00:00004774 23FC000058540000	   386: 	move.l	#INC1,INPPTR
00:0000477C 590C
                            	   387: OUTCON
00:0000477E 13FC0001000400A8	   388: 	move.b #1,OutputDevice
00:00004786 6000018E        	   389: 	bra	FINISH
                            	   390: 
                            	   391: *******************************************************************
                            	   392: *
                            	   393: * What follows is the code to execute direct and statement
                            	   394: * commands. Control is transferred to these points via the command
                            	   395: * table lookup code of 'DIRECT' and 'EXEC' in the last section.
                            	   396: * After the command is executed, control is transferred to other
                            	   397: * sections as follows:
                            	   398: *
                            	   399: * For 'LIST', 'NEW', and 'STOP': go back to the warm start point.
                            	   400: * For 'RUN': go execute the first stored line if any; else go
                            	   401: * back to the warm start point.
                            	   402: * For 'GOTO' and 'GOSUB': go execute the target line.
                            	   403: * For 'RETURN' and 'NEXT'; go back to saved return line.
                            	   404: * For all others: if 'CURRNT' is 0, go to warm start; else go
                            	   405: * execute next command. (This is done in 'FINISH'.)
                            	   406: *
                            	   407: *******************************************************************
                            	   408: *
                            	   409: * *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                            	   410: *
                            	   411: * 'NEW<CR>' sets TXTUNF to point to TXTBGN
                            	   412: *
                            	   413: * 'STOP<CR>' goes back to WSTART
                            	   414: *
                            	   415: * 'RUN<CR>' finds the first stored line, stores its address
                            	   416: * in CURRNT, and starts executing it. Note that only those
                            	   417: * commands in TAB2 are legal for a stored program.
                            	   418: *
                            	   419: * There are 3 more entries in 'RUN':
                            	   420: * 'RUNNXL' finds next line, stores it's address and executes it.
                            	   421: * 'RUNTSL' stores the address of this line and executes it.
                            	   422: * 'RUNSML' continues the execution on same line.
                            	   423: *
                            	   424: * 'GOTO expr<CR>' evaluates the expression, finds the target
                            	   425: * line, and jumps to 'RUNTSL' to do it.
                            	   426: *
                            	   427: NEW
00:0000478A 61000D70        	   428: 	bsr	ENDCHK
00:0000478E 23FAFC5A0000595C	   429: 	MOVE.L TXTBGN,TXTUNF	set the end pointer
00:00004796 6100FD84        	   430: 	bsr ClearStringArea
00:0000479A 6100FDA0        	   431: 	bsr ClearStringStack
                            	   432: 
                            	   433: STOP
00:0000479E 61000D5C        	   434: 	bsr	ENDCHK
00:000047A2 6000FCB8        	   435: 	BRA	WSTART
                            	   436: 
                            	   437: RUN
00:000047A6 427900005968    	   438: 	clr.w DIRFLG
00:000047AC 61000D4E        	   439: 	bsr	ENDCHK
00:000047B0 207AFC38        	   440: 	MOVE.L	TXTBGN,A0	set pointer to beginning
00:000047B4 23C800005914    	   441: 	MOVE.L	A0,CURRNT
                            	   442: 
                            	   443: RUNNXL
00:000047BA 4AB900005914    	   444: 	TST.L	CURRNT		; executing a program?
00:000047C0 6700FC9A        	   445: 	beq	WSTART			; if not, we've finished a direct stat.
00:000047C4 4AB900005948    	   446: 	tst.l	IRQROUT		; are we handling IRQ's ?
00:000047CA 672E            	   447: 	beq	RUN1
00:000047CC 4A39000400A0    	   448: 	tst.b IRQFlag		; was there an IRQ ?
00:000047D2 6726            	   449: 	beq	RUN1
00:000047D4 4239000400A0    	   450: 	clr.b IRQFlag
                            	   451: 
                            	   452: 	; same code as GOSUB	
                            	   453: ;	sub.l #128,sp		; allocate storage for local variables
                            	   454: ;	move.l STKFP,-(sp)
                            	   455: ;	move.l sp,STKFP
00:000047DA 61000EB4        	   456: 	bsr	PUSHA				; save the current 'FOR' parameters
00:000047DE 2F08            	   457: 	MOVE.L A0,-(SP)	; save text pointer
00:000047E0 2F3A1132        	   458: 	MOVE.L CURRNT,-(SP)	found it, save old 'CURRNT'...
00:000047E4 2F3A1136        	   459: 	MOVE.L STKGOS,-(SP)	and 'STKGOS'
00:000047E8 42B900005924    	   460: 	CLR.L	LOPVAR		; load new values
00:000047EE 23CF0000591C    	   461: 	MOVE.L SP,STKGOS
                            	   462: 
00:000047F4 227A1152        	   463: 	move.l IRQROUT,a1
00:000047F8 600C            	   464: 	bra	RUNTSL
                            	   465: RUN1
00:000047FA 7200            	   466: 	CLR.L	D1			; else find the next line number
00:000047FC 2248            	   467: 	MOVE.L A0,A1
00:000047FE 61000E10        	   468: 	bsr	FNDLNP
00:00004802 6500FC58        	   469: 	BCS	WSTART		; if we've fallen off the end, stop
                            	   470: 
                            	   471: RUNTSL
00:00004806 23C900005914    	   472: 	MOVE.L	A1,CURRNT	set CURRNT to point to the line no.
00:0000480C 2049            	   473: 	MOVE.L	A1,A0		set the text pointer to
00:0000480E 5488            	   474: 	ADDQ.L	#2,A0		the start of the line text
                            	   475: 
                            	   476: RUNSML
00:00004810 61000FFC        	   477: 	bsr	CHKIO		see if a control-C was pressed
00:00004814 43FAFD69        	   478: 	LEA	TAB2,A1 	find command in TAB2
00:00004818 45FAFE26        	   479: 	LEA	TAB2_1,A2
00:0000481C 6000FEEA        	   480: 	BRA	EXEC		and execute it
                            	   481: 
                            	   482: GOTO	
00:00004820 610004E0        	   483: 	bsr	INT_EXPR	; evaluate the following expression
00:00004824 61000CD6        	   484: 	bsr	ENDCHK		; must find end of line
00:00004828 2200            	   485: 	move.l d0,d1
00:0000482A 61000DD6        	   486: 	bsr	FNDLN			; find the target line
00:0000482E 66000D26        	   487: 	bne	QHOW			; no such line no.
00:00004832 60D2            	   488: 	bra	RUNTSL		; go do it
                            	   489: 
                            	   490: ;******************************************************************
                            	   491: ; ONIRQ <line number>
                            	   492: ; ONIRQ sets up an interrupt handler which acts like a specialized
                            	   493: ; subroutine call. ONIRQ is coded like a GOTO that never executes.
                            	   494: ;******************************************************************
                            	   495: 
                            	   496: ONIRQ:
00:00004834 610004CC        	   497: 	bsr	INT_EXPR		; evaluate the following expression
00:00004838 61000CC2        	   498: 	bsr ENDCHK			; must find end of line
00:0000483C 2200            	   499: 	move.l d0,d1
00:0000483E 61000DC2        	   500: 	bsr FNDLN				; find the target line
00:00004842 660A            	   501: 	bne	ONIRQ1
00:00004844 42B900005948    	   502: 	clr.l IRQROUT
00:0000484A 600000CA        	   503: 	bra	FINISH
                            	   504: ONIRQ1:
00:0000484E 23C900005948    	   505: 	move.l a1,IRQROUT
00:00004854 600000C0        	   506: 	jmp	FINISH
                            	   507: 
                            	   508: 
                            	   509: WAITIRQ:
00:00004858 61000FB4        	   510: 	jsr	CHKIO				; see if a control-C was pressed
00:0000485C 4A39000400A0    	   511: 	tst.b IRQFlag
00:00004862 67F4            	   512: 	beq	WAITIRQ
00:00004864 600000B0        	   513: 	jmp	FINISH
                            	   514: 
                            	   515: *******************************************************************
                            	   516: *
                            	   517: * *** LIST *** PRINT ***
                            	   518: *
                            	   519: * LIST has two forms:
                            	   520: * 'LIST<CR>' lists all saved lines
                            	   521: * 'LIST #<CR>' starts listing at the line #
                            	   522: * Control-S pauses the listing, control-C stops it.
                            	   523: *
                            	   524: * PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                            	   525: * where '....' is a list of expressions, formats, back-arrows,
                            	   526: * and strings.	These items a separated by commas.
                            	   527: *
                            	   528: * A format is a pound sign followed by a number.  It controls
                            	   529: * the number of spaces the value of an expression is going to
                            	   530: * be printed in.  It stays effective for the rest of the print
                            	   531: * command unless changed by another format.  If no format is
                            	   532: * specified, 11 positions will be used.
                            	   533: *
                            	   534: * A string is quoted in a pair of single- or double-quotes.
                            	   535: *
                            	   536: * An underline (back-arrow) means generate a <CR> without a <LF>
                            	   537: *
                            	   538: * A <CR LF> is generated after the entire list has been printed
                            	   539: * or if the list is empty.  If the list ends with a semicolon,
                            	   540: * however, no <CR LF> is generated.
                            	   541: *
                            	   542: 
                            	   543: LIST	
00:00004868 61000F04        	   544: 	bsr	TSTNUM		see if there's a line no.
00:0000486C 61000C8E        	   545: 	bsr	ENDCHK		if not, we get a zero
00:00004870 61000D90        	   546: 	bsr	FNDLN		find this or next line
                            	   547: LS1
00:00004874 650000A0        	   548: 	BCS	FINISH		warm start if we passed the end
00:00004878 61000EBE        	   549: 	bsr	PRTLN		print the line
00:0000487C 61000F90        	   550: 	bsr	CHKIO		check for listing halt request
00:00004880 670C            	   551: 	BEQ	LS3
00:00004882 B03C0013        	   552: 	CMP.B	#CTRLS,D0	pause the listing?
00:00004886 6606            	   553: 	BNE	LS3
                            	   554: LS2
00:00004888 61000F84        	   555: 	bsr	CHKIO		if so, wait for another keypress
00:0000488C 67FA            	   556: 	BEQ	LS2
                            	   557: LS3
00:0000488E 61000D80        	   558: 	bsr	FNDLNP		find the next line
00:00004892 60E0            	   559: 	BRA	LS1
                            	   560: 
                            	   561: PRINT	
00:00004894 780B            	   562: 	MOVE.L #11,D4		D4 = number of print spaces
00:00004896 61000EBE        	   563: 	bsr	TSTC		if null list and ":"
00:0000489A 3A              	   564: 	DC.B	':',PR2-*
00:0000489B 09
00:0000489C 610011C8        	   565: 	bsr	CRLF		give CR-LF and continue
00:000048A0 6000FF6E        	   566: 	BRA	RUNSML		execution on the same line
                            	   567: PR2	
00:000048A4 61000EB0        	   568: 	bsr	TSTC		if null list and <CR>
00:000048A8 0D              	   569: 	DC.B	CR,PR0-*
00:000048A9 09
00:000048AA 610011BA        	   570: 	bsr	CRLF		also give CR-LF and
00:000048AE 6000FF0A        	   571: 	BRA	RUNNXL		execute the next line
                            	   572: PR0
00:000048B2 61000EA2        	   573: 	bsr	TSTC				; else is it a format?
00:000048B6 23              	   574: 	dc.b '#',PR1-*
00:000048B7 09
00:000048B8 61000448        	   575: 	bsr	INT_EXPR		; yes, evaluate expression
00:000048BC 2800            	   576: 	move.l d0,d4		; and save it as print width
00:000048BE 600E            	   577: 	bra	PR3					; look for more to print
                            	   578: PR1
00:000048C0 61000E94        	   579: 	bsr	TSTC				; is character expression? (MRL)
00:000048C4 24              	   580: 	dc.b '$',PR8-*
00:000048C5 1B
00:000048C6 6100043A        	   581: 	bsr	INT_EXPR		; yep. Evaluate expression (MRL)
00:000048CA 6100FB0A        	   582: 	bsr	GOOUT				; print low byte (MRL)
                            	   583: 	bra	PR3					; look for more. (MRL)
                            	   584: PR3
00:000048CE 61000E86        	   585: 	bsr	TSTC						; if ",", go find next
00:000048D2 2C              	   586: 	dc.b ',',PR6-*
00:000048D3 07
00:000048D4 61000C0C        	   587: 	bsr	FIN							; in the list.
00:000048D8 60D8            	   588: 	BRA	PR0
                            	   589: PR6
00:000048DA 6100118A        	   590: 	bsr	CRLF						; list ends here
00:000048DE 6036            	   591: 	BRA	FINISH
                            	   592: PR8
00:000048E0 2F04            	   593: 	move.l d4,-(SP)			; save the width value
00:000048E2 61000430        	   594: 	bsr	EXPR						; evaluate the expression
00:000048E6 281F            	   595: 	move.l (sp)+,d4			; restore the width
00:000048E8 0C8000000002    	   596: 	cmpi.l #DT_STRING,d0	; is it a string?
00:000048EE 670C            	   597: 	beq PR9
00:000048F0 F2000080        	   598: 	fmove fp0,fp1
00:000048F4 7823            	   599: 	move.l #35,d4
00:000048F6 61000DF6        	   600: 	bsr	PRTNUM					; print its value
00:000048FA 60D2            	   601: 	bra	PR3							; more to print?
                            	   602: 	; Print a string
                            	   603: PR9
00:000048FC F239680000040600	   604: 	fmove.x fp0,_fpWork
00:00004904 323900040600    	   605: 	move.w _fpWork,d1
00:0000490A 227900040604    	   606: 	move.l _fpWork+4,a1
00:00004910 61000DD6        	   607: 	bsr PRTSTR2
00:00004914 60B8            	   608: 	bra PR3
                            	   609: 
                            	   610: FINISH
00:00004916 61000BCA        	   611: 	bsr	FIN			; Check end of command
00:0000491A 60000BF2        	   612: 	BRA	QWHAT		; print "What?" if wrong
                            	   613: 
                            	   614: ;******************************************************************
                            	   615: ;
                            	   616: ; *** GOSUB *** & RETURN ***
                            	   617: ;
                            	   618: ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                            	   619: ; except that the current text pointer, stack pointer, etc. are
                            	   620: ; saved so that execution can be continued after the subroutine
                            	   621: ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                            	   622: ; recursive), the save area must be stacked.  The stack pointer
                            	   623: ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                            	   624: ; If we are in the main routine, 'STKGOS' is zero (this was done
                            	   625: ; in the initialization section of the interpreter), but we still
                            	   626: ; save it as a flag for no further 'RETURN's.
                            	   627: ;
                            	   628: ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                            	   629: ; returns the execution to the command after the most recent
                            	   630: ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                            	   631: ; a 'GOSUB' and is thus an error.
                            	   632: 
                            	   633: GOSUB:
00:0000491E 4FEFFF80        	   634: 	sub.l #128,sp		; allocate storage for local variables
00:00004922 2F3A0FF4        	   635: 	move.l STKFP,-(sp)
00:00004926 23CF00005918    	   636: 	move.l sp,STKFP
00:0000492C 61000D62        	   637: 	bsr	PUSHA				; save the current 'FOR' parameters
00:00004930 610003D0        	   638: 	bsr	INT_EXPR		; get line number
00:00004934 2F08            	   639: 	MOVE.L	A0,-(SP)	save text pointer
00:00004936 2200            	   640: 	move.l	d0,d1
00:00004938 61000CC8        	   641: 	bsr	FNDLN		find the target line
00:0000493C 66000C1A        	   642: 	BNE	AHOW		if not there, say "How?"
00:00004940 2F3A0FD2        	   643: 	MOVE.L	CURRNT,-(SP)	found it, save old 'CURRNT'...
00:00004944 2F3A0FD6        	   644: 	MOVE.L	STKGOS,-(SP)	and 'STKGOS'
00:00004948 42B900005924    	   645: 	CLR.L	LOPVAR		load new values
00:0000494E 23CF0000591C    	   646: 	MOVE.L	SP,STKGOS
00:00004954 6000FEB0        	   647: 	BRA	RUNTSL
                            	   648: 
                            	   649: RETURN:
00:00004958 61000BA2        	   650: 	bsr	ENDCHK					; there should be just a <CR>
00:0000495C 223A0FBE        	   651: 	MOVE.L	STKGOS,D1		; get old stack pointer
00:00004960 67000BAC        	   652: 	BEQ	QWHAT						; if zero, it doesn't exist
00:00004964 2E41            	   653: 	MOVE.L	D1,SP				; else restore it
00:00004966 23DF0000591C    	   654: 	MOVE.L	(SP)+,STKGOS	; and the old 'STKGOS'
00:0000496C 23DF00005914    	   655: 	MOVE.L	(SP)+,CURRNT	; and the old 'CURRNT'
00:00004972 205F            	   656: 	MOVE.L	(SP)+,A0		; and the old text pointer
00:00004974 61000CDE        	   657: 	bsr	POPA						; and the old 'FOR' parameters
                            	   658: ;	move.l STKFP,sp
00:00004978 23DF00005918    	   659: 	move.l (sp)+,STKFP
00:0000497E 4FEF0080        	   660: 	add.l #128,sp				; remove local variable storage
00:00004982 6092            	   661: 	BRA	FINISH					; and we are back home
                            	   662: 
                            	   663: *******************************************************************
                            	   664: *
                            	   665: * *** FOR *** & NEXT ***
                            	   666: *
                            	   667: * 'FOR' has two forms:
                            	   668: * 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                            	   669: * The second form means the same thing as the first form with a
                            	   670: * STEP of positive 1.  The interpreter will find the variable 'var'
                            	   671: * and set its value to the current value of 'exp1'.  It also
                            	   672: * evaluates 'exp2' and 'exp1' and saves all these together with
                            	   673: * the text pointer, etc. in the 'FOR' save area, which consisits of
                            	   674: * 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                            	   675: * already something in the save area (indicated by a non-zero
                            	   676: * 'LOPVAR'), then the old save area is saved on the stack before
                            	   677: * the new values are stored.  The interpreter will then dig in the
                            	   678: * stack and find out if this same variable was used in another
                            	   679: * currently active 'FOR' loop.  If that is the case, then the old
                            	   680: * 'FOR' loop is deactivated. (i.e. purged from the stack)
                            	   681: *
                            	   682: * 'NEXT var' serves as the logical (not necessarily physical) end
                            	   683: * of the 'FOR' loop.  The control variable 'var' is checked with
                            	   684: * the 'LOPVAR'.  If they are not the same, the interpreter digs in
                            	   685: * the stack to find the right one and purges all those that didn't
                            	   686: * match.  Either way, it then adds the 'STEP' to that variable and
                            	   687: * checks the result with against the limit value.  If it is within
                            	   688: * the limit, control loops back to the command following the
                            	   689: * 'FOR'.  If it's outside the limit, the save area is purged and
                            	   690: * execution continues.
                            	   691: 
                            	   692: FOR
00:00004984 61000D0A        	   693: 	bsr	PUSHA			; save the old 'FOR' save area
00:00004988 61000B38        	   694: 	bsr	SETVAL		; set the control variable
00:0000498C 23CE00005924    	   695: 	move.l a6,LOPVAR		; save its address
00:00004992 43FAFC5A        	   696: 	LEA	TAB5,A1 	; use 'EXEC' to test for 'TO'
00:00004996 45FAFD1C        	   697: 	LEA	TAB5_1,A2
00:0000499A 6000FD6C        	   698: 	BRA	EXEC
                            	   699: FR1	
00:0000499E 61000354        	   700: 	bsr	NUM_EXPR		; evaluate the limit
00:000049A2 F239680000005934	   701: 	FMOVE.X	FP0,LOPLMT	; save that
00:000049AA 43FAFC45        	   702: 	LEA	TAB6,A1 		; use 'EXEC' to look for the
00:000049AE 45FAFD0C        	   703: 	LEA	TAB6_1,A2		; word 'STEP'
00:000049B2 6000FD54        	   704: 	BRA	EXEC
                            	   705: FR2
00:000049B6 6100033C        	   706: 	bsr	NUM_EXPR		found it, get the step value
00:000049BA 6006            	   707: 	BRA	FR4
                            	   708: FR3
00:000049BC F23C58000001    	   709: 	FMOVE.B #1,FP0	; not found, step defaults to 1
                            	   710: FR4
00:000049C2 F239680000005928	   711: 	FMOVE.X	FP0,LOPINC	save that too
                            	   712: FR5	
00:000049CA 23FA0F4800005940	   713: 	MOVE.L	CURRNT,LOPLN	save address of current line number
00:000049D2 23C800005944    	   714: 	MOVE.L	A0,LOPPT	and text pointer
00:000049D8 2C4F            	   715: 	MOVE.L	SP,A6		dig into the stack to find 'LOPVAR'
00:000049DA 600C            	   716: 	BRA	FR7
                            	   717: FR6
00:000049DC 4DEE0024        	   718: 	lea 36(a6),a6			; look at next stack frame
00:000049E0 BDFAFA0C        	   719: 	cmp.l ENDMEM,a6		; safety check
00:000049E4 64000B28        	   720: 	bhs QWHAT
                            	   721: FR7
00:000049E8 2016            	   722: 	MOVE.L	(A6),D0 	; is it zero?
00:000049EA 6714            	   723: 	BEQ	FR8						; if so, we're done
00:000049EC B0BA0F36        	   724: 	CMP.L	LOPVAR,D0		; same as current LOPVAR?
00:000049F0 66EA            	   725: 	BNE	FR6						; nope, look some more
00:000049F2 244F            	   726: 	MOVE.L	SP,A2			; Else remove 9 long words from...
00:000049F4 224E            	   727: 	MOVE.L	A6,A1			; inside the stack.
00:000049F6 47E90024        	   728: 	lea	36(a1),a3
00:000049FA 61000C50        	   729: 	bsr	MVDOWN
00:000049FE 2E4B            	   730: 	MOVE.L	A3,SP		set the SP 9 long words up
                            	   731: FR8
00:00004A00 6000FF14        	   732: 	BRA	FINISH		and continue execution
                            	   733: 
                            	   734: NEXT	
00:00004A04 6100078A        	   735: 	bsr	TSTV						; get address of variable
00:00004A08 65000B04        	   736: 	bcs	QWHAT						; if no variable, say "What?"
00:00004A0C 2240            	   737: 	move.l d0,a1				; save variable's address
                            	   738: NX0
00:00004A0E 203A0F14        	   739: 	move.l LOPVAR,D0		; If 'LOPVAR' is zero, we never...
00:00004A12 67000AFA        	   740: 	beq	QWHAT						; had a FOR loop, so say "What?"
00:00004A16 B3C0            	   741: 	cmp.l	d0,a1					; else we check them
00:00004A18 6706            	   742: 	beq	NX3							; OK, they agree
00:00004A1A 61000C38        	   743: 	bsr	POPA						; nope, let's see the next frame
00:00004A1E 60EE            	   744: 	bra	NX0
                            	   745: NX3	
00:00004A20 F22948000004    	   746: 	fmove.x	4(a1),fp0		; get control variable's value
00:00004A26 F23A48220EFE    	   747: 	fadd.x LOPINC,fp0		; add in loop increment
                            	   748: ;	BVS	QHOW		say "How?" for 32-bit overflow
00:00004A2C F22968000004    	   749: 	fmove.x	fp0,4(a1)		; save control variable's new value
00:00004A32 F23A48800EFE    	   750: 	fmove.x	LOPLMT,fp1	; get loop's limit value
00:00004A38 F23A503A0EEC    	   751: 	ftst LOPINC
00:00004A3E F293000E        	   752: 	FBGE NX1				; branch if loop increment is positive
00:00004A42 F2276800        	   753: 	FMOVE.X FP0,-(a7)	; exchange FP0,FP1
00:00004A46 F2000400        	   754: 	FMOVE.X FP1,FP0
00:00004A4A F21F4880        	   755: 	FMOVE.X (a7)+,FP1
                            	   756: NX1	
00:00004A4E F20000B8        	   757: 	FCMP FP0,FP1		;	test against limit
00:00004A52 F2940012        	   758: 	FBLT NX2				; branch if outside limit
00:00004A56 23FA0EE800005914	   759: 	MOVE.L LOPLN,CURRNT	Within limit, go back to the...
00:00004A5E 207A0EE4        	   760: 	MOVE.L LOPPT,A0	saved 'CURRNT' and text pointer.
00:00004A62 6000FEB2        	   761: 	BRA	FINISH
                            	   762: NX2
00:00004A66 61000BEC        	   763: 	bsr	POPA		purge this loop
00:00004A6A 6000FEAA        	   764: 	BRA	FINISH
                            	   765: 
                            	   766: *******************************************************************
                            	   767: *
                            	   768: * *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                            	   769: *
                            	   770: * 'REM' can be followed by anything and is ignored by the
                            	   771: * interpreter.
                            	   772: *
                            	   773: * 'IF' is followed by an expression, as a condition and one or
                            	   774: * more commands (including other 'IF's) separated by colons.
                            	   775: * Note that the word 'THEN' is not used.  The interpreter evaluates
                            	   776: * the expression.  If it is non-zero, execution continues.  If it
                            	   777: * is zero, the commands that follow are ignored and execution
                            	   778: * continues on the next line.
                            	   779: *
                            	   780: * 'INPUT' is like the 'PRINT' command, and is followed by a list
                            	   781: * of items.  If the item is a string in single or double quotes,
                            	   782: * or is an underline (back arrow), it has the same effect as in
                            	   783: * 'PRINT'.  If an item is a variable, this variable name is
                            	   784: * printed out followed by a colon, then the interpreter waits for
                            	   785: * an expression to be typed in.  The variable is then set to the
                            	   786: * value of this expression.  If the variable is preceeded by a
                            	   787: * string (again in single or double quotes), the string will be
                            	   788: * displayed followed by a colon.  The interpreter the waits for an
                            	   789: * expression to be entered and sets the variable equal to the
                            	   790: * expression's value.  If the input expression is invalid, the
                            	   791: * interpreter will print "What?", "How?", or "Sorry" and reprint
                            	   792: * the prompt and redo the input.  The execution will not terminate
                            	   793: * unless you press control-C.  This is handled in 'INPERR'.
                            	   794: *
                            	   795: * 'LET' is followed by a list of items separated by commas.
                            	   796: * Each item consists of a variable, an equals sign, and an
                            	   797: * expression.  The interpreter evaluates the expression and sets
                            	   798: * the variable to that value.  The interpreter will also handle
                            	   799: * 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                            	   800: 
                            	   801: REM
00:00004A6E 600A            	   802: 	BRA	IF2		skip the rest of the line
                            	   803: 
                            	   804: IF
00:00004A70 61000290        	   805: 	bsr	INT_EXPR		evaluate the expression
                            	   806: IF1
00:00004A74 4A80            	   807: 	TST.L	d0		is it zero?
00:00004A76 6600FD98        	   808: 	BNE	RUNSML		if not, continue
                            	   809: IF2
00:00004A7A 2248            	   810: 	MOVE.L	A0,A1
00:00004A7C 7200            	   811: 	CLR.L	D1
00:00004A7E 61000BAA        	   812: 	bsr	FNDSKP		if so, skip the rest of the line
00:00004A82 6400FD82        	   813: 	BCC	RUNTSL		and run the next line
00:00004A86 6000F9D4        	   814: 	BRA	WSTART		if no next line, do a warm start
                            	   815: 
00:00004A8A 2E7A0E94        	   816: INPERR	MOVE.L	STKINP,SP	restore the old stack pointer
00:00004A8E 23DF00005914    	   817: 	MOVE.L	(SP)+,CURRNT	and old 'CURRNT'
00:00004A94 588F            	   818: 	ADDQ.L	#4,SP
00:00004A96 205F            	   819: 	MOVE.L	(SP)+,A0	and old text pointer
                            	   820: 
                            	   821: INPUT	
00:00004A98 2F08            	   822: 	MOVE.L	A0,-(SP)	save in case of error
00:00004A9A 61000278        	   823: 	bsr EXPR
00:00004A9E 0C000002        	   824: 	cmpi.b #DT_STRING,d0
00:00004AA2 6622            	   825: 	bne IP6
00:00004AA4 F239680000040600	   826: 	fmove.x fp0,_fpWork
00:00004AAC 323900040600    	   827: 	move.w _fpWork,d1
00:00004AB2 227900040604    	   828: 	move.l _fpWork+4,a1
00:00004AB8 61000C2E        	   829: 	bsr PRTSTR2
                            	   830: ;	bsr	QTSTG		is next item a string?
                            	   831: ;	BRA.S	IP2		nope
                            	   832: IP7
00:00004ABC 610006D2        	   833: 	bsr	TSTV		yes, but is it followed by a variable?
00:00004AC0 655C            	   834: 	BCS	IP4		if not, branch
00:00004AC2 2440            	   835: 	MOVE.L	D0,A2		put away the variable's address
00:00004AC4 601E            	   836: 	BRA	IP3		if so, input to variable
                            	   837: IP6
00:00004AC6 2057            	   838: 	move.l (sp),a0	; restore text pointer
00:00004AC8 60F2            	   839: 	bra IP7
                            	   840: IP2
00:00004ACA 2F08            	   841: 	MOVE.L	A0,-(SP)	save for 'PRTSTG'
00:00004ACC 610006C2        	   842: 	bsr	TSTV		must be a variable now
00:00004AD0 65000A3C        	   843: 	BCS	QWHAT		"What?" it isn't?
00:00004AD4 2440            	   844: 	MOVE.L	D0,A2		put away the variable's address
00:00004AD6 1410            	   845: 	MOVE.B	(A0),D2 	get ready for 'PRTSTG'
00:00004AD8 4200            	   846: 	CLR.B	D0
00:00004ADA 1080            	   847: 	MOVE.B	D0,(A0)
00:00004ADC 225F            	   848: 	MOVE.L	(SP)+,A1
00:00004ADE 61000BE6        	   849: 	bsr	PRTSTG		print string as prompt
00:00004AE2 1082            	   850: 	MOVE.B	D2,(A0) 	restore text
                            	   851: IP3
00:00004AE4 2F08            	   852: 	MOVE.L	A0,-(SP)	save in case of error
00:00004AE6 2F3A0E2C        	   853: 	MOVE.L	CURRNT,-(SP)	also save 'CURRNT'
00:00004AEA 23FCFFFFFFFF0000	   854: 	MOVE.L	#-1,CURRNT	flag that we are in INPUT
00:00004AF2 5914
00:00004AF4 23CF00005920    	   855: 	MOVE.L	SP,STKINP	save the stack pointer too
00:00004AFA 2F0A            	   856: 	MOVE.L	A2,-(SP)	save the variable address
00:00004AFC 103C003A        	   857: 	MOVE.B	#':',D0         print a colon first
00:00004B00 61000A62        	   858: 	bsr	GETLN		then get an input line
00:00004B04 41FA0E66        	   859: 	LEA	BUFFER,A0	point to the buffer
00:00004B08 6100020A        	   860: 	bsr	EXPR		evaluate the input
00:00004B0C 245F            	   861: 	MOVE.L	(SP)+,A2	restore the variable address
00:00004B0E 2480            	   862: 	move.l d0,(a2)			; save data type
00:00004B10 F22A68000004    	   863: 	FMOVE.X	FP0,4(A2) 	; save value in variable
00:00004B16 23DF00005914    	   864: 	MOVE.L	(SP)+,CURRNT	restore old 'CURRNT'
00:00004B1C 205F            	   865: 	MOVE.L	(SP)+,A0	and the old text pointer
                            	   866: IP4
00:00004B1E 588F            	   867: 	ADDQ.L	#4,SP		clean up the stack
00:00004B20 61000C34        	   868: 	bsr	TSTC		is the next thing a comma?
00:00004B24 2C              	   869: 	DC.B	',',IP5-*
00:00004B25 05
00:00004B26 6000FF70        	   870: 	BRA	INPUT		yes, more items
                            	   871: IP5
00:00004B2A 6000FDEA        	   872: 	BRA	FINISH
                            	   873: 
                            	   874: DEFLT
00:00004B2E 0C10000D        	   875: 	CMP.B	#CR,(A0)	; empty line is OK
00:00004B32 6700FDE2        	   876: 	BEQ	FINISH			; else it is 'LET'
                            	   877: 
                            	   878: LET
00:00004B36 6100098A        	   879: 	bsr	SETVAL		 	; do the assignment
00:00004B3A 61000C1A        	   880: 	bsr	TSTC				; check for more 'LET' items
00:00004B3E 2C              	   881: 	DC.B	',',LT1-*
00:00004B3F 03
00:00004B40 60F4            	   882: 	BRA	LET
                            	   883: LT1
00:00004B42 6000FDD2        	   884: 	BRA	FINISH			; until we are finished.
                            	   885: 
                            	   886: 
                            	   887: *******************************************************************
                            	   888: *
                            	   889: * *** LOAD *** & SAVE ***
                            	   890: *
                            	   891: * These two commands transfer a program to/from an auxiliary
                            	   892: * device such as a cassette, another computer, etc.  The program
                            	   893: * is converted to an easily-stored format: each line starts with
                            	   894: * a colon, the line no. as 4 hex digits, and the rest of the line.
                            	   895: * At the end, a line starting with an '@' sign is sent.  This
                            	   896: * format can be read back with a minimum of processing time by
                            	   897: * the 68000.
                            	   898: *
                            	   899: LOAD	
00:00004B46 207AF8A2        	   900: 	MOVE.L TXTBGN,A0	set pointer to start of prog. area
00:00004B4A 103C000D        	   901: 	MOVE.B #CR,D0		For a CP/M host, tell it we're ready...
00:00004B4E 6100F88E        	   902: 	BSR	GOAUXO		by sending a CR to finish PIP command.
                            	   903: LOD1	
00:00004B52 6100F88E        	   904: 	BSR	GOAUXI		look for start of line
00:00004B56 67FA            	   905: 	BEQ	LOD1
00:00004B58 B03C0040        	   906: 	CMP.B	#'@',D0         end of program?
00:00004B5C 671E            	   907: 	BEQ	LODEND
00:00004B5E B03C003A        	   908: 	CMP.B	#':',D0         if not, is it start of line?
00:00004B62 66EE            	   909: 	BNE	LOD1		if not, wait for it
00:00004B64 6120            	   910: 	BSR	GBYTE		get first byte of line no.
00:00004B66 10C1            	   911: 	MOVE.B	D1,(A0)+	store it
00:00004B68 611C            	   912: 	BSR	GBYTE		get 2nd bye of line no.
00:00004B6A 10C1            	   913: 	MOVE.B	D1,(A0)+	store that, too
                            	   914: LOD2
00:00004B6C 6100F874        	   915: 	BSR	GOAUXI		get another text char.
00:00004B70 67FA            	   916: 	BEQ	LOD2
00:00004B72 10C0            	   917: 	MOVE.B	D0,(A0)+	store it
00:00004B74 B03C000D        	   918: 	CMP.B	#CR,D0		is it the end of the line?
00:00004B78 66F2            	   919: 	BNE	LOD2		if not, go back for more
00:00004B7A 60D6            	   920: 	BRA	LOD1		if so, start a new line
                            	   921: LODEND
00:00004B7C 23C80000595C    	   922: 	MOVE.L	A0,TXTUNF	set end-of program pointer
00:00004B82 6000F8D8        	   923: 	BRA	WSTART		back to direct mode
                            	   924: 
                            	   925: GBYTE
00:00004B86 7401            	   926: 	MOVEQ	#1,D2		get two hex characters from auxiliary
00:00004B88 7200            	   927: 	CLR.L	D1		and store them as a byte in D1
                            	   928: GBYTE1	
00:00004B8A 6100F856        	   929: 	BSR	GOAUXI		get a char.
00:00004B8E 67FA            	   930: 	BEQ	GBYTE1
00:00004B90 B03C0041        	   931: 	CMP.B	#'A',D0
00:00004B94 6502            	   932: 	BCS	GBYTE2
00:00004B96 5F00            	   933: 	SUBQ.B	#7,D0		if greater than 9, adjust
                            	   934: GBYTE2
00:00004B98 C03C000F        	   935: 	AND.B	#$F,D0		strip ASCII
00:00004B9C E909            	   936: 	LSL.B	#4,D1		put nybble into the result
00:00004B9E 8200            	   937: 	OR.B	D0,D1
00:00004BA0 51CAFFE8        	   938: 	DBRA	D2,GBYTE1	get another char.
00:00004BA4 4E75            	   939: 	RTS
                            	   940: 
                            	   941: SAVE
00:00004BA6 207AF842        	   942: 	MOVE.L	TXTBGN,A0	set pointer to start of prog. area
00:00004BAA 227A0DB0        	   943: 	MOVE.L	TXTUNF,A1	set pointer to end of prog. area
                            	   944: SAVE1	
00:00004BAE 103C000D        	   945: 	MOVE.B	#CR,D0		send out a CR & LF (CP/M likes this)
00:00004BB2 6100F82A        	   946: 	BSR	GOAUXO
00:00004BB6 103C000A        	   947: 	MOVE.B	#LF,D0
00:00004BBA 6100F822        	   948: 	BSR	GOAUXO
00:00004BBE B3C8            	   949: 	CMP.L	A0,A1		are we finished?
00:00004BC0 631E            	   950: 	BLS	SAVEND
00:00004BC2 103C003A        	   951: 	MOVE.B	#':',D0         if not, start a line
00:00004BC6 6100F816        	   952: 	BSR	GOAUXO
00:00004BCA 1218            	   953: 	MOVE.B	(A0)+,D1	send first half of line no.
00:00004BCC 6136            	   954: 	BSR	PBYTE
00:00004BCE 1218            	   955: 	MOVE.B	(A0)+,D1	and send 2nd half
00:00004BD0 6132            	   956: 	BSR	PBYTE
                            	   957: SAVE2
00:00004BD2 1018            	   958: 	MOVE.B	(A0)+,D0	get a text char.
00:00004BD4 B03C000D        	   959: 	CMP.B	#CR,D0		is it the end of the line?
00:00004BD8 67D4            	   960: 	BEQ	SAVE1		if so, send CR & LF and start new line
00:00004BDA 6100F802        	   961: 	BSR	GOAUXO		send it out
00:00004BDE 60F2            	   962: 	BRA	SAVE2		go back for more text
                            	   963: SAVEND
00:00004BE0 103C0040        	   964: 	MOVE.B	#'@',D0         send end-of-program indicator
00:00004BE4 6100F7F8        	   965: 	BSR	GOAUXO
00:00004BE8 103C000D        	   966: 	MOVE.B	#CR,D0		followed by a CR & LF
00:00004BEC 6100F7F0        	   967: 	BSR	GOAUXO
00:00004BF0 103C000A        	   968: 	MOVE.B	#LF,D0
00:00004BF4 6100F7E8        	   969: 	BSR	GOAUXO
00:00004BF8 103C001A        	   970: 	MOVE.B	#$1A,D0 	and a control-Z to end the CP/M file
00:00004BFC 6100F7E0        	   971: 	BSR	GOAUXO
00:00004C00 6000F85A        	   972: 	BRA	WSTART		then go do a warm start
                            	   973: 
00:00004C04 7401            	   974: PBYTE	MOVEQ	#1,D2		send two hex characters from D1's low byte
00:00004C06 E919            	   975: PBYTE1	ROL.B	#4,D1		get the next nybble
00:00004C08 1001            	   976: 	MOVE.B	D1,D0
00:00004C0A C03C000F        	   977: 	AND.B	#$F,D0		strip off garbage
00:00004C0E D03C0030        	   978: 	ADD.B	#'0',D0         make it into ASCII
00:00004C12 B03C0039        	   979: 	CMP.B	#'9',D0
00:00004C16 6302            	   980: 	BLS	PBYTE2
00:00004C18 5E00            	   981: 	ADDQ.B	#7,D0		adjust if greater than 9
00:00004C1A 6100F7C2        	   982: PBYTE2	BSR	GOAUXO		send it out
00:00004C1E 51CAFFE6        	   983: 	DBRA	D2,PBYTE1	then send the next nybble
00:00004C22 4E75            	   984: 	RTS
                            	   985: 
                            	   986: *******************************************************************
                            	   987: *
                            	   988: * *** POKE *** & CALL ***
                            	   989: *
                            	   990: * 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                            	   991: * address specified by 'expr1'.
                            	   992: *
                            	   993: * 'CALL expr' jumps to the machine language subroutine whose
                            	   994: * starting address is specified by 'expr'.  The subroutine can use
                            	   995: * all registers but must leave the stack the way it found it.
                            	   996: * The subroutine returns to the interpreter by executing an RTS.
                            	   997: *
                            	   998: POKE
00:00004C24 1E3C0042        	   999: 	move.b #'B',d7
00:00004C28 1210            	  1000: 	move.b (a0),d1
00:00004C2A 0C01002E        	  1001: 	cmpi.b #'.',d1
00:00004C2E 6620            	  1002: 	bne .0001
00:00004C30 5248            	  1003: 	addq #1,a0
00:00004C32 1210            	  1004: 	move.b (a0),d1
00:00004C34 0C010042        	  1005: 	cmpi.b #'B',d1
00:00004C38 6712            	  1006: 	beq .0002
00:00004C3A 0C010057        	  1007: 	cmpi.b #'W',d1
00:00004C3E 670C            	  1008: 	beq .0002
00:00004C40 0C01004C        	  1009: 	cmpi.b #'L',d1
00:00004C44 6706            	  1010: 	beq .0002
00:00004C46 0C010046        	  1011: 	cmpi.b #'F',d1
00:00004C4A 664E            	  1012: 	bne	PKER
                            	  1013: .0002
00:00004C4C 5248            	  1014: 	addq #1,a0
00:00004C4E 1E01            	  1015: 	move.b d1,d7
                            	  1016: .0001
00:00004C50 610000B0        	  1017: 	BSR	INT_EXPR		get the memory address
00:00004C54 61000B00        	  1018: 	bsr	TSTC		it must be followed by a comma
00:00004C58 2C              	  1019: 	DC.B	',',PKER-*
00:00004C59 41
00:00004C5A 2F00            	  1020: 	move.l d0,-(sp)		; save the address
00:00004C5C 61000096        	  1021: 	BSR	NUM_EXPR			; get the value to be POKE'd
00:00004C60 225F            	  1022: 	move.l	(sp)+,a1	; get the address back
00:00004C62 0C070042        	  1023: 	CMPI.B #'B',D7
00:00004C66 6608            	  1024: 	BNE .0003
00:00004C68 F2117800        	  1025: 	FMOVE.B	FP0,(A1) 	store the byte in memory
00:00004C6C 6000FCA8        	  1026: 	BRA	FINISH
                            	  1027: .0003
00:00004C70 0C070057        	  1028: 	CMPI.B #'W',d7
00:00004C74 6608            	  1029: 	BNE .0004
00:00004C76 F2117000        	  1030: 	FMOVE.W FP0,(A1)
00:00004C7A 6000FC9A        	  1031: 	BRA FINISH
                            	  1032: .0004
00:00004C7E 0C07004C        	  1033: 	CMPI.B #'L',D7
00:00004C82 6608            	  1034: 	BNE .0005
00:00004C84 F2116000        	  1035: 	FMOVE.L FP0,(A1)
00:00004C88 6000FC8C        	  1036: 	BRA FINISH
                            	  1037: .0005
00:00004C8C 0C070046        	  1038: 	CMPI.B #'F',D7
00:00004C90 6608            	  1039: 	BNE .0006
00:00004C92 F2116800        	  1040: 	FMOVE.X FP0,(A1)
00:00004C96 6000FC7E        	  1041: 	BRA FINISH
                            	  1042: .0006
                            	  1043: PKER
00:00004C9A 60000872        	  1044: 	BRA	QWHAT		if no comma, say "What?"
                            	  1045: 
                            	  1046: CALL	
00:00004C9E 6162            	  1047: 	BSR	INT_EXPR		; get the subroutine's address
00:00004CA0 4A80            	  1048: 	TST.l d0				; make sure we got a valid address
00:00004CA2 670008B2        	  1049: 	BEQ QHOW				; if not, say "How?"
00:00004CA6 2F08            	  1050: 	MOVE.L A0,-(SP)	; save the text pointer
00:00004CA8 2240            	  1051: 	MOVE.L D0,A1
00:00004CAA 4E91            	  1052: 	JSR	(A1)				; jump to the subroutine
00:00004CAC 205F            	  1053: 	MOVE.L (SP)+,A0	; restore the text pointer
00:00004CAE 6000FC66        	  1054: 	BRA	FINISH
                            	  1055: 
                            	  1056: ;******************************************************************
                            	  1057: ;
                            	  1058: ; *** EXPR ***
                            	  1059: ;
                            	  1060: ; 'EXPR' evaluates arithmetical or logical expressions.
                            	  1061: ; <EXPR>::=<EXPR2>
                            	  1062: ;	   <EXPR2><rel.op.><EXPR2>
                            	  1063: ; where <rel.op.> is one of the operators in TAB8 and the result
                            	  1064: ; of these operations is 1 if true and 0 if false.
                            	  1065: ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                            	  1066: ; where () are optional and (... are optional repeats.
                            	  1067: ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                            	  1068: ; <EXPR4>::=<variable>
                            	  1069: ;	    <function>
                            	  1070: ;	    (<EXPR>)
                            	  1071: ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                            	  1072: ; as an index, functions can have an <EXPR> as arguments, and
                            	  1073: ; <EXPR4> can be an <EXPR> in parenthesis.
                            	  1074: 
                            	  1075: ;-------------------------------------------------------------------------------
                            	  1076: ; Push a value on the stack.
                            	  1077: ;-------------------------------------------------------------------------------
                            	  1078: 
                            	  1079: XP_PUSH:
00:00004CB2 225F            	  1080: 	move.l (sp)+,a1				; a1 = return address
00:00004CB4 2F3900040098    	  1081: 	move.l _canary,-(sp)	; push the canary
00:00004CBA 4FEFFFF0        	  1082: 	sub.l #16,sp					; allocate for value
00:00004CBE 2E80            	  1083: 	move.l d0,(sp)				; push data type
00:00004CC0 F22F68000004    	  1084: 	fmove.x fp0,4(sp)			; and value
00:00004CC6 4ED1            	  1085: 	jmp (a1)
                            	  1086: 
                            	  1087: ;-------------------------------------------------------------------------------
                            	  1088: ; Pop value from stack into first operand.
                            	  1089: ;-------------------------------------------------------------------------------
                            	  1090: 	
                            	  1091: XP_POP:
00:00004CC8 225F            	  1092: 	move.l (sp)+,a1			; get return address
00:00004CCA 2017            	  1093: 	move.l (sp),d0			; pop data type
00:00004CCC F22F48000004    	  1094: 	fmove.x 4(sp),fp0		; and data element
00:00004CD2 4FEF0010        	  1095: 	add.l #16,sp
00:00004CD6 A2970003        	  1096: 	cchk (sp)						; check the canary
00:00004CDA 588F            	  1097: 	add.l #4,sp					; pop canary	
00:00004CDC 4ED1            	  1098: 	jmp (a1)
                            	  1099: 
                            	  1100: ;-------------------------------------------------------------------------------
                            	  1101: ; Pop value from stack into second operand.
                            	  1102: ;-------------------------------------------------------------------------------
                            	  1103: 
                            	  1104: XP_POP1:
00:00004CDE 225F            	  1105: 	move.l (sp)+,a1			; get return address
00:00004CE0 2217            	  1106: 	move.l (sp),d1			; pop data type
00:00004CE2 F22F48800004    	  1107: 	fmove.x 4(sp),fp1		; and data element
00:00004CE8 4FEF0010        	  1108: 	add.l #16,sp
00:00004CEC A2970003        	  1109: 	cchk (sp)						; check the canary
00:00004CF0 588F            	  1110: 	add.l #4,sp					; pop canary
00:00004CF2 4ED1            	  1111: 	jmp (a1)
                            	  1112: 
                            	  1113: ;-------------------------------------------------------------------------------
                            	  1114: ; Get and expression and make sure it is numeric.
                            	  1115: ;-------------------------------------------------------------------------------
                            	  1116: 
                            	  1117: NUM_EXPR:
00:00004CF4 611E            	  1118: 	bsr EXPR
00:00004CF6 0C8000000001    	  1119: 	cmpi.l #DT_NUMERIC,d0
00:00004CFC 66000860        	  1120: 	bne ETYPE
00:00004D00 4E75            	  1121: 	rts
                            	  1122: 
                            	  1123: ;-------------------------------------------------------------------------------
                            	  1124: ; Get and expression and make sure it is numeric. Convert to integer.
                            	  1125: ;-------------------------------------------------------------------------------
                            	  1126: 
                            	  1127: INT_EXPR:
00:00004D02 6110            	  1128: 	bsr EXPR
00:00004D04 0C8000000001    	  1129: 	cmpi.l #DT_NUMERIC,d0
00:00004D0A 66000852        	  1130: 	bne ETYPE
00:00004D0E F2006000        	  1131: 	fmove.l fp0,d0
00:00004D12 4E75            	  1132: 	rts
                            	  1133: 
                            	  1134: ;-------------------------------------------------------------------------------
                            	  1135: ; The top level of the expression parser.
                            	  1136: ; Get an expression, string or numeric.
                            	  1137: ;
                            	  1138: ; EXEC will smash a lot of regs, so push the current expression value before
                            	  1139: ; doing EXEC
                            	  1140: ;-------------------------------------------------------------------------------
                            	  1141: 
                            	  1142: EXPR:
                            	  1143: EXPR_OR:
00:00004D14 6124            	  1144: 	BSR EXPR_AND
00:00004D16 619A            	  1145: 	BSR XP_PUSH
00:00004D18 43FAF8EB        	  1146: 	LEA TAB10,A1
00:00004D1C 45FAF9CA        	  1147: 	LEA TAB10_1,A2
00:00004D20 6000F9E6        	  1148: 	BRA EXEC
                            	  1149: 	
                            	  1150: ;-------------------------------------------------------------------------------
                            	  1151: ; Boolean 'Or' level
                            	  1152: ;-------------------------------------------------------------------------------
                            	  1153: 
                            	  1154: XP_OR:
00:00004D24 6114            	  1155: 	BSR EXPR_AND
00:00004D26 61B6            	  1156: 	bsr XP_POP1
00:00004D28 613E            	  1157: 	bsr CheckNumeric
00:00004D2A F2016080        	  1158: 	FMOVE.L FP1,D1
00:00004D2E F2006000        	  1159: 	FMOVE.L FP0,D0
00:00004D32 8081            	  1160: 	OR.L D1,D0
00:00004D34 F2004000        	  1161: 	FMOVE.L D0,FP0
00:00004D38 4E75            	  1162: 	rts
                            	  1163: 	
                            	  1164: ;-------------------------------------------------------------------------------
                            	  1165: ; Boolean 'And' level
                            	  1166: ;-------------------------------------------------------------------------------
                            	  1167: 
                            	  1168: EXPR_AND:
00:00004D3A 613E            	  1169: 	bsr EXPR_REL
00:00004D3C 6100FF74        	  1170: 	bsr XP_PUSH
00:00004D40 43FAF8BF        	  1171: 	LEA TAB9,A1
00:00004D44 45FAF99A        	  1172: 	LEA TAB9_1,A2
00:00004D48 6000F9BE        	  1173: 	BRA EXEC
                            	  1174: 
                            	  1175: XP_AND:
00:00004D4C 612C            	  1176: 	BSR EXPR_REL
00:00004D4E 618E            	  1177: 	bsr XP_POP1
00:00004D50 6116            	  1178: 	bsr CheckNumeric
00:00004D52 F2016080        	  1179: 	FMOVE.L FP1,D1
00:00004D56 F2006000        	  1180: 	FMOVE.L FP0,D0
00:00004D5A C081            	  1181: 	AND.L D1,D0
00:00004D5C F2004000        	  1182: 	FMOVE.L D0,FP0
00:00004D60 4E75            	  1183: 	RTS
                            	  1184: 	
                            	  1185: XP_ANDX:
                            	  1186: XP_ORX
00:00004D62 6100FF64        	  1187: 	bsr XP_POP
00:00004D66 4E75            	  1188: 	rts
                            	  1189: 
                            	  1190: ;-------------------------------------------------------------------------------
                            	  1191: ; Check that two numeric values are being used.
                            	  1192: ;-------------------------------------------------------------------------------
                            	  1193: 
                            	  1194: CheckNumeric:
00:00004D68 0C010001        	  1195: 	CMPI.B #DT_NUMERIC,D1
00:00004D6C 660007F0        	  1196: 	BNE ETYPE
00:00004D70 0C000001        	  1197: 	CMPI.B #DT_NUMERIC,D0
00:00004D74 660007E8        	  1198: 	BNE ETYPE
00:00004D78 4E75            	  1199: 	RTS
                            	  1200: 
                            	  1201: ;-------------------------------------------------------------------------------
                            	  1202: ; Relational operator level, <,<=,>=,>,=,<>
                            	  1203: ;-------------------------------------------------------------------------------
                            	  1204: 
                            	  1205: EXPR_REL:
00:00004D7A 61000088        	  1206: 	bsr	EXPR2
00:00004D7E 6100FF32        	  1207: 	bsr XP_PUSH
00:00004D82 43FAF872        	  1208: 	LEA	TAB8,A1 				; look up a relational operator
00:00004D86 45FAF93C        	  1209: 	LEA	TAB8_1,A2
00:00004D8A 6000F97C        	  1210: 	bra	EXEC		go do it
                            	  1211: 
                            	  1212: XP11:
00:00004D8E 6100FF38        	  1213: 	bsr XP_POP
00:00004D92 615C            	  1214: 	BSR	XP18		is it ">="?
00:00004D94 F2940044        	  1215: 	FBLT XPRT0		no, return D0=0
00:00004D98 6048            	  1216: 	BRA	XPRT1		else return D0=1
                            	  1217: 
                            	  1218: XP12:
00:00004D9A 6100FF2C        	  1219: 	bsr XP_POP
00:00004D9E 6150            	  1220: 	BSR	XP18		is it "<>"?
00:00004DA0 F2810038        	  1221: 	FBEQ XPRT0		no, return D0=0
00:00004DA4 603C            	  1222: 	BRA	XPRT1		else return D0=1
                            	  1223: 
                            	  1224: XP13:
00:00004DA6 6100FF20        	  1225: 	bsr XP_POP
00:00004DAA 6144            	  1226: 	BSR	XP18		is it ">"?
00:00004DAC F295002C        	  1227: 	FBLE XPRT0		no, return D0=0
00:00004DB0 6030            	  1228: 	BRA	XPRT1		else return D0=1
                            	  1229: 
                            	  1230: XP14:
00:00004DB2 6100FF14        	  1231: 	bsr XP_POP
00:00004DB6 6138            	  1232: 	BSR	XP18		;is it "<="?
00:00004DB8 F2920020        	  1233: 	FBGT XPRT0	;	no, return D0=0
00:00004DBC 6024            	  1234: 	BRA	XPRT1		;else return D0=1
                            	  1235: 
                            	  1236: XP15:
00:00004DBE 6100FF08        	  1237: 	bsr XP_POP
00:00004DC2 612C            	  1238: 	BSR	XP18		; is it "="?
00:00004DC4 F28E0014        	  1239: 	FBNE XPRT0	;	if not, return D0=0
00:00004DC8 6018            	  1240: 	BRA	XPRT1		;else return D0=1
                            	  1241: XP15RT
00:00004DCA 4E75            	  1242: 	RTS
                            	  1243: 
                            	  1244: XP16:
00:00004DCC 6100FEFA        	  1245: 	bsr XP_POP
00:00004DD0 611E            	  1246: 	BSR	XP18		; is it "<"?
00:00004DD2 F2930006        	  1247: 	FBGE XPRT0	;	if not, return D0=0
00:00004DD6 600A            	  1248: 	BRA	XPRT1		; else return D0=1
00:00004DD8 4E75            	  1249: 	RTS
                            	  1250: 
                            	  1251: XPRT0:
00:00004DDA F23C58000000    	  1252: 	FMOVE.B #0,FP0	; return fp0 = 0 (false)
00:00004DE0 4E75            	  1253: 	RTS
                            	  1254: 
                            	  1255: XPRT1:
00:00004DE2 F23C58000001    	  1256: 	FMOVE.B #1,FP0	; return fp0 = 1 (true)
00:00004DE8 4E75            	  1257: 	RTS
                            	  1258: 
                            	  1259: XP17:								; it's not a rel. operator
00:00004DEA 6100FEDC        	  1260: 	bsr XP_POP				;	return FP0=<EXPR2>
00:00004DEE 4E75            	  1261: 	rts
                            	  1262: 
                            	  1263: XP18:
00:00004DF0 6100FEC0        	  1264: 	bsr XP_PUSH
00:00004DF4 610E            	  1265: 	bsr	EXPR2					; do second <EXPR2>
00:00004DF6 6100FEE6        	  1266: 	bsr XP_POP1
00:00004DFA 6100FF6C        	  1267: 	bsr CheckNumeric
00:00004DFE F20000B8        	  1268: 	fcmp fp0,fp1			; compare with the first result
00:00004E02 4E75            	  1269: 	rts								; return the result
                            	  1270: 
                            	  1271: ;-------------------------------------------------------------------------------
                            	  1272: ; Add/Subtract operator level, +,-
                            	  1273: ;-------------------------------------------------------------------------------
                            	  1274: 
                            	  1275: EXPR2
00:00004E04 61000950        	  1276: 	bsr	TSTC		; negative sign?
00:00004E08 2D              	  1277: 	DC.B	'-',XP21-*
00:00004E09 09
00:00004E0A F23C58000000    	  1278: 	FMOVE.B #0,FP0
00:00004E10 604C            	  1279: 	BRA	XP26
                            	  1280: XP21	
00:00004E12 61000942        	  1281: 	bsr	TSTC		; positive sign? ignore it
00:00004E16 2B              	  1282: 	DC.B	'+',XP22-*
00:00004E17 01
                            	  1283: XP22
00:00004E18 610000C8        	  1284: 	BSR	EXPR3		; first <EXPR3>
                            	  1285: XP23
00:00004E1C 61000938        	  1286: 	bsr	TSTC		; add?
00:00004E20 2B              	  1287: 	DC.B	'+',XP25-*
00:00004E21 37
00:00004E22 6100FE8E        	  1288: 	bsr XP_PUSH
00:00004E26 610000BA        	  1289: 	BSR	EXPR3					; get the second <EXPR3>
                            	  1290: XP24
00:00004E2A 6100FEB2        	  1291: 	bsr XP_POP1
00:00004E2E B03C0001        	  1292: 	CMP.B #DT_NUMERIC,d0
00:00004E32 660C            	  1293: 	BNE .notNum
00:00004E34 B23C0001        	  1294: 	CMP.B #DT_NUMERIC,d1
00:00004E38 6606            	  1295: 	BNE .notNum
00:00004E3A F2000422        	  1296: 	FADD FP1,FP0			; add it to the first <EXPR3>
                            	  1297: ;	FBVS	QHOW		branch if there's an overflow
00:00004E3E 60DC            	  1298: 	BRA	XP23		else go back for more operations
                            	  1299: .notNum
00:00004E40 B0BC00000002    	  1300: 	cmp.l #DT_STRING,d0
00:00004E46 66000716        	  1301: 	bne ETYPE
00:00004E4A B2BC00000002    	  1302: 	cmp.l #DT_STRING,d1
00:00004E50 6600070C        	  1303: 	bne ETYPE
00:00004E54 611E            	  1304: 	bsr ConcatString
00:00004E56 4E75            	  1305: 	rts
                            	  1306: 
                            	  1307: XP25
00:00004E58 610008FC        	  1308: 	bsr	TSTC							; subtract?
00:00004E5C 2D              	  1309: 	dc.b	'-',XP27-*
00:00004E5D 15
                            	  1310: XP26
00:00004E5E 6100FE52        	  1311: 	bsr XP_PUSH
00:00004E62 617E            	  1312: 	BSR	EXPR3					; get second <EXPR3>
00:00004E64 0C000001        	  1313: 	cmpi.b #DT_NUMERIC,d0
00:00004E68 660006F4        	  1314: 	bne ETYPE
00:00004E6C F200001A        	  1315: 	FNEG FP0					; change its sign
00:00004E70 60B8            	  1316: 	JMP	XP24					; and do an addition
                            	  1317: 
                            	  1318: XP27
00:00004E72 4E75            	  1319: 	rts
                            	  1320: 
                            	  1321: ;-------------------------------------------------------------------------------
                            	  1322: ; Concatonate strings, for the '+' operator.
                            	  1323: ;
                            	  1324: ; Parameters:
                            	  1325: ;		fp0 = holds string descriptor for second string
                            	  1326: ;		fp1 = holds string descriptor for first string
                            	  1327: ;	Returns:
                            	  1328: ;		fp0 = string descriptor for combined strings
                            	  1329: ;-------------------------------------------------------------------------------
                            	  1330: 
                            	  1331: ConcatString:
00:00004E74 F239688000040600	  1332: 	fmove.x fp1,_fpWork		; save first string descriptor to memory
00:00004E7C F239680000040610	  1333: 	fmove.x fp0,_fpWork+16; save second string descriptor to memory
00:00004E84 343900040600    	  1334: 	move.w _fpWork,d2			; d2 = length of first string
00:00004E8A D47900040610    	  1335: 	add.w	_fpWork+16,d2		; add length of second string
00:00004E90 48C2            	  1336: 	ext.l d2							; make d2 a long word
00:00004E92 61000164        	  1337: 	bsr AllocateString		; allocate
00:00004E96 2849            	  1338: 	move.l a1,a4					; a4 = allocated string, saved for later
00:00004E98 2449            	  1339: 	move.l a1,a2					; a2 = allocated string
00:00004E9A 3542FFFE        	  1340: 	move.w d2,-2(a2)			; save length of new string (a2)
00:00004E9E 227900040604    	  1341: 	move.l _fpWork+4,a1		; a1 = pointer to string text of first string
00:00004EA4 2649            	  1342: 	move.l a1,a3					; compute pointer to end of first string
00:00004EA6 363900040600    	  1343: 	move.w _fpWork,d3			; d3 = length of first string
00:00004EAC 48C3            	  1344: 	ext.l d3
00:00004EAE D7C3            	  1345: 	add.l d3,a3						; add length of first string
00:00004EB0 61000786        	  1346: 	bsr MVUP							; move from A1 to A2 until A1=A3
00:00004EB4 227900040614    	  1347: 	move.l _fpWork+20,a1	; a1 = pointer to second string text
00:00004EBA 2649            	  1348: 	move.l a1,a3
00:00004EBC 363900040610    	  1349: 	move.w _fpWork+16,d3	; d3 = length of second string
00:00004EC2 48C3            	  1350: 	ext.l d3
00:00004EC4 D7C3            	  1351: 	add.l d3,a3						; a3 points to end of second string
00:00004EC6 61000770        	  1352: 	bsr MVUP							; concatonate on second string
00:00004ECA 33C200040600    	  1353: 	move.w d2,_fpWork			; save total string length in fp work
00:00004ED0 23CC00040604    	  1354: 	move.l a4,_fpWork+4		; save pointer in fp work area
00:00004ED6 7002            	  1355: 	moveq #DT_STRING,d0		; set return data type = string
00:00004ED8 F239480000040600	  1356: 	fmove.x _fpWork,fp0		; fp0 = string descriptor
00:00004EE0 4E75            	  1357: 	rts
                            	  1358: 
                            	  1359: ;-------------------------------------------------------------------------------
                            	  1360: ; Multiply / Divide operator level, *,/,mod
                            	  1361: ;-------------------------------------------------------------------------------
                            	  1362: 
                            	  1363: EXPR3
00:00004EE2 6168            	  1364: 	bsr	EXPR4					; get first <EXPR4>
                            	  1365: XP36
00:00004EE4 6100FDCC        	  1366: 	bsr XP_PUSH
                            	  1367: XP30
00:00004EE8 43FAF71E        	  1368: 	lea TAB11,a1
00:00004EEC 45FAF802        	  1369: 	lea TAB11_1,a2
00:00004EF0 6000F816        	  1370: 	bra EXEC
                            	  1371: XP31
00:00004EF4 61000860        	  1372: 	bsr	TSTC					; multiply?
00:00004EF8 2A              	  1373: 	dc.b	'*',XP34-*
00:00004EF9 11
00:00004EFA 6150            	  1374: 	bsr	EXPR4					; get second <EXPR4>
00:00004EFC 6100FDE0        	  1375: 	bsr XP_POP1
00:00004F00 6100FE66        	  1376: 	bsr CheckNumeric
00:00004F04 F2000423        	  1377: 	fmul fp1,fp0			; multiply the two
00:00004F08 60DA            	  1378: 	bra	XP36					; then look for more terms
                            	  1379: XP34
00:00004F0A 6100084A        	  1380: 	bsr	TSTC					; divide?
00:00004F0E 2F              	  1381: 	dc.b	'/',XP35-*
00:00004F0F 15
00:00004F10 613A            	  1382: 	bsr	EXPR4					; get second <EXPR4>
00:00004F12 6100FDCA        	  1383: 	bsr XP_POP1
00:00004F16 6100FE50        	  1384: 	bsr CheckNumeric
00:00004F1A F20000A0        	  1385: 	fdiv fp0,fp1			; do the division
00:00004F1E F2000400        	  1386: 	fmove fp1,fp0
00:00004F22 60C0            	  1387: 	bra	XP36					; go back for any more terms
                            	  1388: XP35
00:00004F24 6100FDA2        	  1389: 	bsr XP_POP
00:00004F28 4E75            	  1390: 	rts
                            	  1391: XP_MOD:
00:00004F2A 6120            	  1392: 	bsr EXPR4
00:00004F2C 6100FDB0        	  1393: 	bsr XP_POP1
00:00004F30 F20000A0        	  1394: 	fdiv fp0,fp1			; divide
00:00004F34 F2006080        	  1395: 	fmove.l fp1,d0		; convert to integer
00:00004F38 F2004180        	  1396: 	fmove.l d0,fp3		; convert back to float
00:00004F3C F20001A3        	  1397: 	fmul fp0,fp3			; multiply quotient times divisor
00:00004F40 F2000CA8        	  1398: 	fsub fp3,fp1			; subtract from original number
00:00004F44 F2000400        	  1399: 	fmove.x fp1,fp0		; return difference in fp0
00:00004F48 7001            	  1400: 	moveq #DT_NUMERIC,d0
00:00004F4A 6098            	  1401: 	bra XP36					; go back and check for more multiply ops
                            	  1402: 	
                            	  1403: ;-------------------------------------------------------------------------------
                            	  1404: ; Lowest Level of expression evaluation.
                            	  1405: ;	Check for
                            	  1406: ;		a function or
                            	  1407: ;		a variable or
                            	  1408: ;		a number or
                            	  1409: ;		a string or
                            	  1410: ;		( expr )
                            	  1411: ;-------------------------------------------------------------------------------
                            	  1412: 
                            	  1413: EXPR4
00:00004F4C 43FAF66E        	  1414: 	LEA	TAB4,A1 			; find possible function
00:00004F50 45FAF72E        	  1415: 	LEA	TAB4_1,A2
00:00004F54 6000F7B2        	  1416: 	BRA	EXEC
                            	  1417: XP40
00:00004F58 61000236        	  1418: 	bsr	TSTV					; nope, not a function
00:00004F5C 650C            	  1419: 	bcs	XP41					; nor a variable
00:00004F5E 2240            	  1420: 	move.l d0,a1			; a1 = variable address
00:00004F60 2011            	  1421: 	move.l (a1),d0		; return type in d0
00:00004F62 F22948000004    	  1422: 	fmove.x 4(a1),fp0	; if a variable, return its value in fp0
                            	  1423: EXP4RT
00:00004F68 4E75            	  1424: 	rts
                            	  1425: XP41
00:00004F6A 61000802        	  1426: 	bsr	TSTNUM				; or is it a number?
00:00004F6E F2000400        	  1427: 	fmove fp1,fp0
00:00004F72 0C8000000001    	  1428: 	cmpi.l #DT_NUMERIC,d0
00:00004F78 67EE            	  1429: 	beq	EXP4RT				; if so, return it in FP0
                            	  1430: XPSTNG
00:00004F7A 610007DA        	  1431: 	bsr TSTC					; is it a string constant?
00:00004F7E 22              	  1432: 	dc.b '"',XP44-*
00:00004F7F 57
00:00004F80 163C0022        	  1433: 	move.b #'"',d3
                            	  1434: XP45
00:00004F84 2248            	  1435: 	move.l a0,a1			; record start of string in a1
00:00004F86 243C000001FF    	  1436: 	move.l #511,d2		; max 512 characters
                            	  1437: .0003	
00:00004F8C 1018            	  1438: 	move.b (a0)+,d0		; get a character
00:00004F8E 670E            	  1439: 	beq .0001					; should not be a NULL
00:00004F90 0C00000D        	  1440: 	cmpi.b #CR,d0			; CR means the end of line was hit without a close quote
00:00004F94 6708            	  1441: 	beq .0001
00:00004F96 B003            	  1442: 	cmp.b d3,d0				; close quote?
00:00004F98 6708            	  1443: 	beq .0002
00:00004F9A 51CAFFF0        	  1444: 	dbra d2,.0003			; no close quote, go back for next char
                            	  1445: .0001
00:00004F9E 600005B6        	  1446: 	bra QHOW
                            	  1447: .0002
00:00004FA2 2008            	  1448: 	move.l a0,d0				; d0 = end of string pointer
00:00004FA4 9089            	  1449: 	sub.l a1,d0					; compute string length + 1
00:00004FA6 5340            	  1450: 	subq #1,d0					; subtract out closing quote
00:00004FA8 2400            	  1451: 	move.l d0,d2				; d2 = string length
00:00004FAA 2649            	  1452: 	move.l a1,a3				; a3 = pointer to string text
00:00004FAC 614A            	  1453: 	bsr AllocateString
00:00004FAE 2449            	  1454: 	move.l a1,a2				; a2 points to new text area
00:00004FB0 2849            	  1455: 	move.l a1,a4				; save a1 for later
00:00004FB2 224B            	  1456: 	move.l a3,a1				; a1 = pointer to string in program
00:00004FB4 3542FFFE        	  1457: 	move.w d2,-2(a2)		; copy length into place
00:00004FB8 D7C2            	  1458: 	add.l d2,a3					; a3 points to end of string
00:00004FBA 6100067C        	  1459: 	bsr MVUP						; move from A1 to A2 until A1=A3
00:00004FBE 33C200040600    	  1460: 	move.w d2,_fpWork		; copy length into place
00:00004FC4 23CC00040604    	  1461: 	move.l a4,_fpWork+4	; copy pointer to text into place
00:00004FCA F239480000040600	  1462: 	fmove.x _fpWork,fp0	; put string descriptor into fp0
00:00004FD2 7002            	  1463: 	moveq #DT_STRING,d0	; return string data type
00:00004FD4 4E75            	  1464: 	rts
                            	  1465: XP44
00:00004FD6 6100077E        	  1466: 	bsr TSTC					; alternate string constant?
00:00004FDA 27              	  1467: 	dc.b '''',PARN-*
00:00004FDB 07
00:00004FDC 163C0027        	  1468: 	move.b #'''',d3
00:00004FE0 60A2            	  1469: 	bra XP45
                            	  1470: PARN
00:00004FE2 61000772        	  1471: 	bsr	TSTC					; else look for ( EXPR )
00:00004FE6 28              	  1472: 	dc.b '(',XP43-*
00:00004FE7 0D
00:00004FE8 6100FD2A        	  1473: 	bsr	EXPR
00:00004FEC 61000768        	  1474: 	bsr	TSTC
00:00004FF0 29              	  1475: 	dc.b ')',XP43-*
00:00004FF1 03
                            	  1476: XP42	
00:00004FF2 4E75            	  1477: 	rts
                            	  1478: XP43
00:00004FF4 60000518        	  1479: 	bra	QWHAT					; else say "What?"
                            	  1480: 
                            	  1481: ;-------------------------------------------------------------------------------	
                            	  1482: ; Allocate storage for a string variable.
                            	  1483: ;
                            	  1484: ; Parameters:
                            	  1485: ;		d2 = number of bytes needed
                            	  1486: ; Returns:
                            	  1487: ;		a1 = pointer to string text area
                            	  1488: ;-------------------------------------------------------------------------------	
                            	  1489: 
                            	  1490: AllocateString:
00:00004FF8 48E7383C        	  1491: 	movem.l d2-d4/a2-a5,-(sp)
00:00004FFC 283A0962        	  1492: 	move.l VARBGN,d4
00:00005000 227A0956        	  1493: 	move.l LastStr,a1			; a1 = last string
00:00005004 3611            	  1494: 	move.w (a1),d3				; d3 = length of last string (0)
00:00005006 48C3            	  1495: 	ext.l d3
00:00005008 9883            	  1496: 	sub.l d3,d4						; subtract off length
00:0000500A 5784            	  1497: 	subq.l #3,d4					; size of length field+1 for rounding
00:0000500C 9889            	  1498: 	sub.l a1,d4						; and start position
00:0000500E B484            	  1499: 	cmp.l d4,d2						; is there enough room?
00:00005010 6224            	  1500: 	bhi .needMoreRoom
                            	  1501: .0001
00:00005012 227A0944        	  1502: 	move.l LastStr,a1
00:00005016 2649            	  1503: 	move.l a1,a3
00:00005018 5489            	  1504: 	addq.l #2,a1					; point a1 to text part of string
00:0000501A 3682            	  1505: 	move.w d2,(a3)				; save the length
00:0000501C D7C2            	  1506: 	add.l d2,a3
00:0000501E 568B            	  1507: 	addq.l #3,a3					; 2 for length field, 1 for rounding
00:00005020 260B            	  1508: 	move.l a3,d3
00:00005022 0283FFFFFFFE    	  1509: 	andi.l #$FFFFFFFE,d3	; make pointer even wyde
00:00005028 23CB00005958    	  1510: 	move.l a3,LastStr			; set new last str position
00:0000502E 4253            	  1511: 	clr.w (a3)						; set zero length
00:00005030 4CDF3C1C        	  1512: 	movem.l (sp)+,d2-d4/a2-a5
00:00005034 4E75            	  1513: 	rts
                            	  1514: .needMoreRoom
00:00005036 611E            	  1515: 	bsr GarbageCollectStrings
00:00005038 283A0926        	  1516: 	move.l VARBGN,d4			; d4 = start of variables
00:0000503C 227A091A        	  1517: 	move.l LastStr,a1			; a1 = pointer to last string
00:00005040 3611            	  1518: 	move.w (a1),d3				; d3 = length of last string (likely 0)
00:00005042 48C3            	  1519: 	ext.l d3
00:00005044 D689            	  1520: 	add.l a1,d3						; d3 = pointer past end of last string
00:00005046 5683            	  1521: 	addq.l #3,d3					; 2 for length, 1 for rounding
00:00005048 9883            	  1522: 	sub.l d3,d4						; free = VARBGN - LastStr+length of (LastStr)
00:0000504A B484            	  1523: 	cmp.l d4,d2						; request < free?
00:0000504C 65C4            	  1524: 	blo .0001
00:0000504E 4DFA089C        	  1525: 	lea NOSTRING,a6
00:00005052 600004C0        	  1526: 	bra ERROR
                            	  1527: 		
                            	  1528: ;-------------------------------------------------------------------------------	
                            	  1529: ; Garbage collect strings. This copies all strings in use to the lower end of
                            	  1530: ; the string area and adjusts the string pointers in variables and on the
                            	  1531: ; stack to point to the new location.
                            	  1532: ;
                            	  1533: ; Modifies:
                            	  1534: ;		none
                            	  1535: ;-------------------------------------------------------------------------------	
                            	  1536: 
                            	  1537: GarbageCollectStrings:
00:00005056 48E70074        	  1538: 	movem.l a1/a2/a3/a5,-(sp)
00:0000505A 227A08F8        	  1539: 	move.l StrArea,a1			; source area pointer
00:0000505E 247A08F4        	  1540: 	move.l StrArea,a2			; target area pointer
00:00005062 2A7A08F4        	  1541: 	move.l LastStr,a5
                            	  1542: .0001
00:00005066 6140            	  1543: 	bsr StringInVar				; check if the string is used by a variable
00:00005068 6506            	  1544: 	bcs .moveString
00:0000506A 610000A6        	  1545: 	bsr StringOnStack			; check if string is on string expression stack
00:0000506E 641C            	  1546: 	bcc .nextString				; if not on stack or in a var then move to next string
                            	  1547: 	
                            	  1548: 	; The string is in use, copy to active string area
                            	  1549: .moveString:
00:00005070 610000D0        	  1550: 	bsr UpdateStringPointers	; update pointer to string on stack or in variable
00:00005074 611C            	  1551: 	bsr NextString				; a3 = pointer to next string
00:00005076 610005CA        	  1552: 	bsr MVUPW							; will copy the length and string text
                            	  1553: .0005
00:0000507A B3CD            	  1554: 	cmp.l a5,a1						; is it the last string?
00:0000507C 63E8            	  1555: 	bls .0001
00:0000507E 23CA00005958    	  1556: 	move.l a2,LastStr			; update last string pointer
00:00005084 4252            	  1557: 	clr.w (a2)						; set zero length
00:00005086 4CDF2E00        	  1558: 	movem.l (sp)+,a1/a2/a3/a5
00:0000508A 4E75            	  1559: 	rts
                            	  1560: .nextString:
00:0000508C 6104            	  1561: 	bsr NextString
00:0000508E 224B            	  1562: 	move.l a3,a1
00:00005090 60E8            	  1563: 	bra .0005
                            	  1564: 
                            	  1565: ;-------------------------------------------------------------------------------	
                            	  1566: ; Parameters:
                            	  1567: ;		a1 - pointer to current string
                            	  1568: ; Returns:
                            	  1569: ;		a3 - pointer to next string
                            	  1570: ;-------------------------------------------------------------------------------	
                            	  1571: 
                            	  1572: NextString:
00:00005092 2F04            	  1573: 	move.l d4,-(sp)
00:00005094 3811            	  1574: 	move.w (a1),d4				; d4 = string length
00:00005096 48C4            	  1575: 	ext.l d4							; make d4 long
00:00005098 5684            	  1576: 	addq.l #3,d4					; plus 2 for length field, 1 for rounding
00:0000509A D889            	  1577: 	add.l a1,d4
00:0000509C 0284FFFFFFFE    	  1578: 	andi.l #$FFFFFFFE,d4	; make even wyde address
00:000050A2 2644            	  1579: 	move.l d4,a3
00:000050A4 281F            	  1580: 	move.l (sp)+,d4
00:000050A6 4E75            	  1581: 	rts
                            	  1582: 
                            	  1583: ;-------------------------------------------------------------------------------	
                            	  1584: ; Check if a variable is using a string
                            	  1585: ;
                            	  1586: ; Modifies:
                            	  1587: ;		d2,d3,a4
                            	  1588: ; Parameters:
                            	  1589: ;		a1 = pointer to string descriptor
                            	  1590: ; Returns:
                            	  1591: ;		cf = 1 if string in use, 0 otherwise
                            	  1592: ;-------------------------------------------------------------------------------	
                            	  1593: 
                            	  1594: StringInVar:
                            	  1595: 	; check global vars
00:000050A8 287A08B6        	  1596: 	move.l VARBGN,a4
00:000050AC 761F            	  1597: 	moveq #31,d3			; 32 vars
00:000050AE 6116            	  1598: 	bsr SIV1
                            	  1599: 	; now check local vars
00:000050B0 287A0866        	  1600: 	move.l STKFP,a4
                            	  1601: .0001
00:000050B4 588C            	  1602: 	addq.l #4,a4			; point to variable area
00:000050B6 7607            	  1603: 	moveq #7,d3
00:000050B8 610C            	  1604: 	bsr SIV1					; check variable area
00:000050BA 286CFFFC        	  1605: 	move.l -4(a4),a4	; get previous frame pointer
00:000050BE B9FAF32E        	  1606: 	cmp.l ENDMEM,a4
00:000050C2 65F0            	  1607: 	blo .0001
00:000050C4 4E75            	  1608: 	rts
                            	  1609: 
                            	  1610: ;-------------------------------------------------------------------------------	
                            	  1611: ; SIV1 - string in variable helper. This routine does a two-up return if the
                            	  1612: ; string is found in a variable. No need to keep searching.
                            	  1613: ;
                            	  1614: ; Modifies:
                            	  1615: ;		d2,d3,a4
                            	  1616: ; Parameters:
                            	  1617: ;		d3 = number of variables-1 to check
                            	  1618: ;		a4 = string space
                            	  1619: ;		a1 = pointer to string descriptor
                            	  1620: ; Returns:
                            	  1621: ;		cf = 1 if string in use, 0 otherwise
                            	  1622: ;-------------------------------------------------------------------------------	
                            	  1623: 
                            	  1624: SIV1:
                            	  1625: .0003
00:000050C6 0C9400000002    	  1626: 	cmp.l #DT_STRING,(a4)
00:000050CC 6612            	  1627: 	bne .0004
00:000050CE 242C0008        	  1628: 	move.l 8(a4),d2
00:000050D2 5582            	  1629: 	subq.l #2,d2
00:000050D4 B3C2            	  1630: 	cmp.l d2,a1
00:000050D6 6608            	  1631: 	bne .0004
00:000050D8 588F            	  1632: 	addq.l #4,sp			; pop return address
00:000050DA 003C0001        	  1633: 	ori #1,ccr
00:000050DE 4E75            	  1634: 	rts								; do two up return
                            	  1635: .0004
00:000050E0 508C            	  1636: 	addq.l #8,a4			;  increment pointer by 16
00:000050E2 508C            	  1637: 	addq.l #8,a4
00:000050E4 51CBFFE0        	  1638: 	dbra d3,.0003
00:000050E8 023C00FE        	  1639: 	andi #$FE,ccr
00:000050EC 4E75            	  1640: 	rts
                            	  1641: 
                            	  1642: ;-------------------------------------------------------------------------------	
                            	  1643: ; Check if a value could be a pointer into the string area.
                            	  1644: ; Even if the data type indicated a string, it may not be. It could just be a
                            	  1645: ; coincidence. So check that the pointer portion is pointing into string
                            	  1646: ; memory. It is extremely unlikely to have a data type and a valid pointer
                            	  1647: ; match and it not be a string.
                            	  1648: ;
                            	  1649: ; Returns
                            	  1650: ;		d3 = pointer to string
                            	  1651: ;		cf=1 if points into string area, 0 otherwise
                            	  1652: ;-------------------------------------------------------------------------------	
                            	  1653: 
                            	  1654: PointsIntoStringArea:
00:000050EE 0C9400000002    	  1655: 	cmp.l #DT_STRING,(a4)		; is it a string data type?
00:000050F4 6616            	  1656: 	bne .0001
00:000050F6 262C0008        	  1657: 	move.l 8(a4),d3					; likely a string if
00:000050FA B6BA0858        	  1658: 	cmp.l StrArea,d3				; flagged as a string, and pointer is into string area
00:000050FE 650C            	  1659: 	blo .0001
00:00005100 B6BA085E        	  1660: 	cmp.l VARBGN,d3
00:00005104 6406            	  1661: 	bhs .0001
00:00005106 003C0001        	  1662: 	ori #1,ccr
00:0000510A 4E75            	  1663: 	rts
                            	  1664: .0001
00:0000510C 023C00FE        	  1665: 	andi #$FE,ccr
00:00005110 4E75            	  1666: 	rts
                            	  1667: 
                            	  1668: ;-------------------------------------------------------------------------------	
                            	  1669: ; Check if the string is a temporary on stack
                            	  1670: ;
                            	  1671: ; Parameters:
                            	  1672: ;		a3 = pointer to old string text area
                            	  1673: ; Returns:
                            	  1674: ;		cf = 1 if string in use, 0 otherwise
                            	  1675: ;-------------------------------------------------------------------------------	
                            	  1676: 
                            	  1677: StringOnStack:
00:00005112 48E72028        	  1678: 	movem.l d2/a2/a4,-(sp)
00:00005116 7607            	  1679: 	moveq #7,d3
00:00005118 284F            	  1680: 	move.l sp,a4
                            	  1681: .0002
00:0000511A 61D2            	  1682: 	bsr PointsIntoStringArea
00:0000511C 6408            	  1683: 	bcc .0003
00:0000511E 242C0008        	  1684: 	move.l 8(a4),d2			; d2 = string text pointer
00:00005122 B7C2            	  1685: 	cmp.l d2,a3					; compare string pointers
00:00005124 6712            	  1686: 	beq .0001						; same pointer?
                            	  1687: .0003
00:00005126 588C            	  1688: 	addq.l #4,a4				; bump pointer into stack
00:00005128 B9FAF2C4        	  1689: 	cmp.l ENDMEM,a4			; have we hit end of stack yet?
00:0000512C 65EC            	  1690: 	blo .0002
00:0000512E 4CDF1404        	  1691: 	movem.l (sp)+,d2/a2/a4
00:00005132 023C00FE        	  1692: 	andi #$FE,ccr
00:00005136 4E75            	  1693: 	rts
                            	  1694: .0001
00:00005138 4CDF1404        	  1695: 	movem.l (sp)+,d2/a2/a4
00:0000513C 003C0001        	  1696: 	ori #1,ccr
00:00005140 4E75            	  1697: 	rts
                            	  1698: 	
                            	  1699: ;-------------------------------------------------------------------------------	
                            	  1700: ; Update pointers to string to point to new area. All string areas must be
                            	  1701: ; completely checked because there may be more than one pointer to the string.
                            	  1702: ;
                            	  1703: ; Modifies:
                            	  1704: ;		d2,d3,d4,a4
                            	  1705: ; Parameters:
                            	  1706: ;		a1 = old pointer to string
                            	  1707: ;		a2 = new pointer to string
                            	  1708: ;-------------------------------------------------------------------------------	
                            	  1709: 
                            	  1710: UpdateStringPointers:
00:00005142 2F0B            	  1711: 	move.l a3,-(sp)
00:00005144 47E90002        	  1712: 	lea 2(a1),a3						; a3 points to old string text area
                            	  1713: 	; check global variable space
00:00005148 287A0816        	  1714: 	move.l VARBGN,a4
00:0000514C 761F            	  1715: 	moveq #31,d3						; 32 vars to check
00:0000514E 611E            	  1716: 	bsr USP1
                            	  1717: 	; check stack for strings
00:00005150 284F            	  1718: 	move.l sp,a4						; start at stack bottom and work towards top
                            	  1719: .0002
00:00005152 619A            	  1720: 	bsr PointsIntoStringArea
00:00005154 640C            	  1721: 	bcc .0001
                            	  1722: 	; Here we probably have a string, one last check
00:00005156 B68A            	  1723: 	cmp.l a2,d3							; should be >= a2 as we are packing the space
00:00005158 6508            	  1724: 	blo .0001
00:0000515A 294A0008        	  1725: 	move.l a2,8(a4)					; update pointer on stack with new address
00:0000515E 546C0008        	  1726: 	addi.w #2,8(a4)					; bump up to text part of string
                            	  1727: .0001
00:00005162 588C            	  1728: 	addq.l #4,a4
00:00005164 B9FAF288        	  1729: 	cmp.l ENDMEM,a4
00:00005168 65E8            	  1730: 	blo .0002
00:0000516A 265F            	  1731: 	move.l (sp)+,a3
00:0000516C 4E75            	  1732: 	rts
                            	  1733: 
                            	  1734: ;-------------------------------------------------------------------------------	
                            	  1735: ; Both global and local variable spaces are updated in the same manner.
                            	  1736: ;
                            	  1737: ; Parameters:
                            	  1738: ;		a1 = old pointer to string
                            	  1739: ;		a2 = new pointer to string
                            	  1740: ;		a4 = start of string space
                            	  1741: ;		d3 = number of string variables
                            	  1742: ;-------------------------------------------------------------------------------	
                            	  1743: 
                            	  1744: USP1:
                            	  1745: .0002
00:0000516E 0C9400000002    	  1746: 	cmp.l #DT_STRING,(a4)		; check the data type
00:00005174 6610            	  1747: 	bne .0001								; not a string, go to next
00:00005176 242C0008        	  1748: 	move.l 8(a4),d2					; d2 = pointer to string text
00:0000517A B7C2            	  1749: 	cmp.l d2,a3							; does pointer match old pointer?
00:0000517C 6608            	  1750: 	bne .0001
00:0000517E 294A0008        	  1751: 	move.l a2,8(a4)					; copy in new pointer
00:00005182 54AC0008        	  1752: 	addi.l #2,8(a4)					; point to string text
                            	  1753: .0001
00:00005186 508C            	  1754: 	addq.l #8,a4						; increment pointer by 16
00:00005188 508C            	  1755: 	addq.l #8,a4
00:0000518A 51CBFFE2        	  1756: 	dbra d3,.0002
00:0000518E 4E75            	  1757: 	rts
                            	  1758: 
                            	  1759: ;-------------------------------------------------------------------------------	
                            	  1760: ; ===== Test for a valid variable name.  Returns Carry=1 if not
                            	  1761: ;	found, else returns Carry=0 and the address of the
                            	  1762: ;	variable in D0.
                            	  1763: 
                            	  1764: TSTV:
00:00005190 61000628        	  1765: 	bsr	IGNBLK
00:00005194 7000            	  1766: 	CLR.L	D0
00:00005196 1010            	  1767: 	MOVE.B (A0),D0 	 	; look at the program text
00:00005198 903C0040        	  1768: 	SUB.B	#'@',D0
00:0000519C 6572            	  1769: 	BCS	TSTVRT				; C=1: not a variable
00:0000519E 6638            	  1770: 	BNE	TV1						; branch if not "@" array
00:000051A0 5248            	  1771: 	ADDQ #1,A0				; If it is, it should be
00:000051A2 6100FE3E        	  1772: 	BSR	PARN					; followed by (EXPR) as its index.
00:000051A6 D080            	  1773: 	ADD.L	D0,D0
00:000051A8 650003AC        	  1774: 	BCS	QHOW					; say "How?" if index is too big
00:000051AC D080            	  1775: 	ADD.L	D0,D0
00:000051AE 650003A6        	  1776: 	BCS	QHOW
00:000051B2 D080            	  1777: 	ADD.L	D0,D0
00:000051B4 650003A0        	  1778: 	BCS	QHOW
00:000051B8 D080            	  1779: 	ADD.L	D0,D0
00:000051BA 6500039A        	  1780: 	BCS	QHOW
00:000051BE 2F00            	  1781: 	move.l d0,-(sp)		; save the index
00:000051C0 6100012A        	  1782: 	bsr	SIZE					; get amount of free memory
00:000051C4 221F            	  1783: 	move.l (sp)+,d1		; get back the index
00:000051C6 F2006000        	  1784: 	fmove.l fp0,d0		; convert to integer
00:000051CA B081            	  1785: 	cmp.l	d1,d0				; see if there's enough memory
00:000051CC 63000380        	  1786: 	bls	QSORRY				; if not, say "Sorry"
00:000051D0 203A078E        	  1787: 	move.l VARBGN,d0	; put address of array element...
00:000051D4 9081            	  1788: 	sub.l	d1,d0				; into D0
00:000051D6 4E75            	  1789: 	rts
                            	  1790: TV1
00:000051D8 B03C001B        	  1791: 	CMP.B	#27,D0			; if not @, is it A through Z?
00:000051DC 0A3C0001        	  1792: 	EOR	#1,CCR
00:000051E0 652E            	  1793: 	BCS	TSTVRT				; if not, set Carry and return
00:000051E2 5248            	  1794: 	ADDQ #1,A0				; else bump the text pointer
00:000051E4 0C00004C        	  1795: 	cmpi.b #'L',d0		; is it a local? L0 to L7
00:000051E8 661E            	  1796: 	bne TV2
00:000051EA 1010            	  1797: 	move.b (a0),d0
00:000051EC 0C000030        	  1798: 	cmpi.b #'0',d0
00:000051F0 6516            	  1799: 	blo TV2
00:000051F2 0C000037        	  1800: 	cmpi.b #'7',d0
00:000051F6 6210            	  1801: 	bhi TV2
00:000051F8 903C0030        	  1802: 	sub.b #'0',d0
00:000051FC 5248            	  1803: 	addq #1,a0			; bump text pointer
00:000051FE E988            	  1804: 	lsl.l #4,d0			; *16 bytes per var
00:00005200 D0BA0716        	  1805: 	add.l STKFP,d0
00:00005204 5880            	  1806: 	add.l #4,d0
00:00005206 4E75            	  1807: 	rts
                            	  1808: TV2
00:00005208 E988            	  1809: 	LSL.L #4,D0			; compute the variable's address
00:0000520A 223A0754        	  1810: 	MOVE.L VARBGN,D1
00:0000520E D081            	  1811: 	ADD.L	D1,D0			; and return it in D0 with Carry=0
                            	  1812: TSTVRT
00:00005210 4E75            	  1813: 	RTS
                            	  1814: 
                            	  1815: 
                            	  1816: * ===== Divide the 32 bit value in D0 by the 32 bit value in D1.
                            	  1817: *	Returns the 32 bit quotient in D0, remainder in D1.
                            	  1818: *
                            	  1819: DIV32
00:00005212 4A81            	  1820: 	TST.L	D1		check for divide-by-zero
00:00005214 67000340        	  1821: 	BEQ	QHOW		if so, say "How?"
00:00005218 2401            	  1822: 	MOVE.L	D1,D2
00:0000521A 2801            	  1823: 	MOVE.L	D1,D4
00:0000521C B184            	  1824: 	EOR.L	D0,D4		see if the signs are the same
00:0000521E 4A80            	  1825: 	TST.L	D0		take absolute value of D0
00:00005220 6A02            	  1826: 	BPL	DIV1
00:00005222 4480            	  1827: 	NEG.L	D0
00:00005224 4A81            	  1828: DIV1	TST.L	D1		take absolute value of D1
00:00005226 6A02            	  1829: 	BPL	DIV2
00:00005228 4481            	  1830: 	NEG.L	D1
00:0000522A 761F            	  1831: DIV2	MOVEQ	#31,D3		iteration count for 32 bits
00:0000522C 2200            	  1832: 	MOVE.L	D0,D1
00:0000522E 7000            	  1833: 	CLR.L	D0
00:00005230 D281            	  1834: DIV3	ADD.L	D1,D1		(This algorithm was translated from
00:00005232 D180            	  1835: 	ADDX.L	D0,D0		; the divide routine in Ron Cain's
00:00005234 6708            	  1836: 	BEQ	DIV4		Small-C run time library.)
00:00005236 B082            	  1837: 	CMP.L	D2,D0
00:00005238 6B04            	  1838: 	BMI	DIV4
00:0000523A 5281            	  1839: 	ADDQ.L	#1,D1
00:0000523C 9082            	  1840: 	SUB.L	D2,D0
00:0000523E 51CBFFF0        	  1841: DIV4	DBRA	D3,DIV3
00:00005242 C141            	  1842: 	EXG	D0,D1		put rem. & quot. in proper registers
00:00005244 4A84            	  1843: 	TST.L	D4		were the signs the same?
00:00005246 6A04            	  1844: 	BPL	DIVRT
00:00005248 4480            	  1845: 	NEG.L	D0		if not, results are negative
00:0000524A 4481            	  1846: 	NEG.L	D1
00:0000524C 4E75            	  1847: DIVRT	RTS
                            	  1848: 
                            	  1849: 
                            	  1850: ; ===== The PEEK function returns the byte stored at the address
                            	  1851: ;	contained in the following expression.
                            	  1852: 
                            	  1853: PEEK
00:0000524E 1E3C0042        	  1854: 	MOVE.B #'B',d7
00:00005252 1210            	  1855: 	MOVE.B (a0),d1
00:00005254 0C01002E        	  1856: 	CMPI.B #'.',d1
00:00005258 6604            	  1857: 	BNE .0001
00:0000525A 5248            	  1858: 	ADDQ #1,a0
00:0000525C 1E18            	  1859: 	move.b (a0)+,d7
                            	  1860: .0001
00:0000525E 6100FD82        	  1861: 	BSR	PARN		get the memory address
00:00005262 0C8000000001    	  1862: 	cmpi.l #DT_NUMERIC,d0
00:00005268 660002F4        	  1863: 	bne ETYPE
00:0000526C F2006000        	  1864: 	FMOVE.L FP0,D0
00:00005270 2240            	  1865: 	MOVE.L D0,A1
00:00005272 0C070042        	  1866: 	cmpi.b #'B',d7
00:00005276 660C            	  1867: 	bne .0002
                            	  1868: .0005
00:00005278 7000            	  1869: 	CLR.L	D0				; upper 3 bytes will be zero
00:0000527A 1011            	  1870: 	MOVE.B (A1),D0
00:0000527C F2005800        	  1871: 	FMOVE.B	D0,FP0 	; get the addressed byte
00:00005280 7001            	  1872: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00005282 4E75            	  1873: 	RTS							; and return it
                            	  1874: .0002
00:00005284 0C070057        	  1875: 	cmpi.b #'W',d7
00:00005288 660C            	  1876: 	bne .0003
00:0000528A 7000            	  1877: 	CLR.L d0
00:0000528C 3011            	  1878: 	MOVE.W (A1),D0
00:0000528E F2005000        	  1879: 	FMOVE.W	D0,FP0	;	get the addressed word
00:00005292 7001            	  1880: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00005294 4E75            	  1881: 	RTS							; and return it
                            	  1882: .0003
00:00005296 0C07004C        	  1883: 	cmpi.b #'L',d7
00:0000529A 660C            	  1884: 	bne .0004
00:0000529C 7000            	  1885: 	CLR.L d0
00:0000529E 2011            	  1886: 	MOVE.L (A1),D0
00:000052A0 F2004000        	  1887: 	FMOVE.L	D0,FP0 	; get the lword
00:000052A4 7001            	  1888: 	moveq #DT_NUMERIC,d0					; data type is a number
00:000052A6 4E75            	  1889: 	RTS							; and return it
                            	  1890: .0004
00:000052A8 0C070046        	  1891: 	cmpi.b #'F',d7
00:000052AC 66CA            	  1892: 	bne .0005
00:000052AE F2114800        	  1893: 	FMOVE.X	(A1),FP0 		; get the addressed float
00:000052B2 7001            	  1894: 	moveq #DT_NUMERIC,d0					; data type is a number
00:000052B4 4E75            	  1895: 	RTS			and return it
                            	  1896: 
                            	  1897: ;-------------------------------------------------------------------------------
                            	  1898: ; The RND function returns a random number from 0 to the value of the following
                            	  1899: ; expression in fp0.
                            	  1900: ;-------------------------------------------------------------------------------
                            	  1901: 
                            	  1902: RND:
00:000052B6 6100FD2A        	  1903: 	bsr	PARN								; get the upper limit
00:000052BA 0C8000000001    	  1904: 	cmpi.l #DT_NUMERIC,d0		; must be numeric
00:000052C0 6600029C        	  1905: 	bne ETYPE
00:000052C4 F200003A        	  1906: 	ftst.x fp0							; it must be positive and non-zero
00:000052C8 F281028C        	  1907: 	fbeq QHOW
00:000052CC F2940288        	  1908: 	fblt QHOW
00:000052D0 F2000100        	  1909: 	fmove fp0,fp2
00:000052D4 7028            	  1910: 	moveq #40,d0						; function #40 get random float
00:000052D6 4E4F            	  1911: 	trap #15
00:000052D8 F2000823        	  1912: 	fmul fp2,fp0
00:000052DC 7001            	  1913: 	moveq #DT_NUMERIC,d0		; data type is a number
00:000052DE 4E75            	  1914: 	rts
                            	  1915: 
                            	  1916: ; ===== The ABS function returns an absolute value in D0.
                            	  1917: 
                            	  1918: ABS:	
00:000052E0 6100FD00        	  1919: 	bsr	PARN			; get the following expr.'s value
00:000052E4 F2000018        	  1920: 	fabs.x fp0
00:000052E8 7001            	  1921: 	moveq #DT_NUMERIC,d0					; data type is a number
00:000052EA 4E75            	  1922: 	rts
                            	  1923: 
                            	  1924: ; ===== The SIZE function returns the size of free memory in D0.
                            	  1925: 
                            	  1926: SIZE:
00:000052EC 203A0666        	  1927: 	move.l StrArea,d0		; get the number of free bytes...
00:000052F0 90BA066A        	  1928: 	sub.l	 TXTUNF,d0		; between 'TXTUNF' and 'StrArea'
00:000052F4 F2004000        	  1929: 	fmove.l d0,fp0
00:000052F8 7001            	  1930: 	moveq #DT_NUMERIC,d0	; data type is a number
00:000052FA 4E75            	  1931: 	rts										; return the number in fp0
                            	  1932: 	
                            	  1933: ; ===== The TICK function returns the processor tick register in D0.
                            	  1934: 
                            	  1935: TICK:
00:000052FC 4E7A0FF0        	  1936: 	movec tick,d0
00:00005300 F2004000        	  1937: 	fmove.l d0,fp0
00:00005304 7001            	  1938: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00005306 4E75            	  1939: 	rts
                            	  1940: 
                            	  1941: ; ===== The CORENO function returns the core number in D0.
                            	  1942: 
                            	  1943: CORENO:
00:00005308 4E7A0FE0        	  1944: 	movec coreno,d0
00:0000530C F2004000        	  1945: 	fmove.l d0,fp0
00:00005310 7001            	  1946: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00005312 4E75            	  1947: 	rts
                            	  1948: 
                            	  1949: ;-------------------------------------------------------------------------------
                            	  1950: ; Get a pair of argments for the LEFT$ and RIGHT$ functions.
                            	  1951: ; 	(STRING, NUM)
                            	  1952: ; Returns:
                            	  1953: ;		fp0 = number
                            	  1954: ;		fp1 = string
                            	  1955: ;-------------------------------------------------------------------------------
                            	  1956: 
                            	  1957: LorRArgs:
00:00005314 61000440        	  1958: 	bsr	TSTC						; else look for ( STRING EXPR, NUM EXPR )
00:00005318 28              	  1959: 	dc.b	'(',LorR1-*
00:00005319 33
00:0000531A 6100F9F8        	  1960: 	bsr	EXPR
00:0000531E 0C8000000002    	  1961: 	cmpi.l #DT_STRING,d0
00:00005324 66000238        	  1962: 	bne ETYPE
00:00005328 6100F988        	  1963: 	bsr XP_PUSH
00:0000532C 61000428        	  1964: 	bsr TSTC
00:00005330 2C              	  1965: 	dc.b ',',LorR1-*
00:00005331 1B
00:00005332 6100F9E0        	  1966: 	bsr EXPR
00:00005336 0C8000000001    	  1967: 	cmpi.l #DT_NUMERIC,d0
00:0000533C 66000220        	  1968: 	bne ETYPE
00:00005340 61000414        	  1969: 	bsr	TSTC
00:00005344 29              	  1970: 	dc.b	')',LorR1-*
00:00005345 07
00:00005346 6100F996        	  1971: 	bsr XP_POP1
00:0000534A 4E75            	  1972: 	rts
                            	  1973: LorR1
00:0000534C 60000208        	  1974: 	bra QHOW
                            	  1975: 	
                            	  1976: ;-------------------------------------------------------------------------------
                            	  1977: ; MID$ function gets a substring of characters from start position for
                            	  1978: ; requested length.
                            	  1979: ;-------------------------------------------------------------------------------
                            	  1980: 
                            	  1981: MID:
00:00005350 61000404        	  1982: 	bsr	TSTC						; look for ( STRING EXPR, NUM EXPR [, NUM_EXPR] )
00:00005354 28              	  1983: 	dc.b	'(',MID1-*
00:00005355 C1
00:00005356 6100F9BC        	  1984: 	bsr	EXPR
00:0000535A 0C8000000002    	  1985: 	cmpi.l #DT_STRING,d0
00:00005360 660001FC        	  1986: 	bne ETYPE
00:00005364 6100F94C        	  1987: 	bsr XP_PUSH
00:00005368 610003EC        	  1988: 	bsr TSTC
00:0000536C 2C              	  1989: 	dc.b ',',MID1-*
00:0000536D A9
00:0000536E 6100F9A4        	  1990: 	bsr EXPR
00:00005372 0C8000000001    	  1991: 	cmpi.l #DT_NUMERIC,d0
00:00005378 660001E4        	  1992: 	bne ETYPE
00:0000537C 6100F934        	  1993: 	bsr XP_PUSH
00:00005380 7A02            	  1994: 	moveq #2,d5
00:00005382 610003D2        	  1995: 	bsr	TSTC
00:00005386 2C              	  1996: 	dc.b ',',MID2-*
00:00005387 11
00:00005388 6100F98A        	  1997: 	bsr EXPR
00:0000538C 0C8000000001    	  1998: 	cmpi.l #DT_NUMERIC,d0
00:00005392 660001CA        	  1999: 	bne ETYPE
00:00005396 7A03            	  2000: 	moveq #3,d5					; d5 indicates 3 params
                            	  2001: MID2
00:00005398 610003BC        	  2002: 	bsr TSTC
00:0000539C 29              	  2003: 	dc.b ')',MID1-*
00:0000539D 79
00:0000539E 6100F93E        	  2004: 	bsr XP_POP1
00:000053A2 0C050003        	  2005: 	cmpi.b #3,d5				; did we have 3 arguments?
00:000053A6 6708            	  2006: 	beq MID5						; branch if did
00:000053A8 F23C40000000FFFF	  2007: 	fmove.l #$FFFF,fp0	; set length = max
                            	  2008: MID5
00:000053B0 F2000500        	  2009: 	fmove.x fp1,fp2			; fp2 = start pos
00:000053B4 6100F928        	  2010: 	bsr XP_POP1					; fp1 = string descriptor
                            	  2011: ;-------------------------------------------------------------------------------
                            	  2012: ; Perform MID$ function
                            	  2013: ; 	fp1 = string descriptor
                            	  2014: ; 	fp2 = starting position
                            	  2015: ; 	fp0 = length
                            	  2016: ;-------------------------------------------------------------------------------
                            	  2017: DOMID
00:000053B8 F239688000040600	  2018: 	fmove.x fp1,_fpWork	; _fpWork = string descriptor
00:000053C0 F2036100        	  2019: 	fmove.l fp2,d3			; d3 = start pos
00:000053C4 B67900040600    	  2020: 	cmp.w _fpWork,d3		; is start pos < length
00:000053CA 6400018A        	  2021: 	bhs QHOW
00:000053CE F2026000        	  2022: 	fmove.l fp0,d2			; d2=length
00:000053D2 D682            	  2023: 	add.l d2,d3					; start pos + length < string length?
00:000053D4 B47900040600    	  2024: 	cmp.w _fpWork,d2
00:000053DA 6308            	  2025: 	bls MID4
00:000053DC 343900040600    	  2026: 	move.w _fpWork,d2		; move string length to d2
00:000053E2 48C2            	  2027: 	ext.l d2
                            	  2028: MID4
00:000053E4 6100FC12        	  2029: 	bsr AllocateString	; a1 = pointer to new string
00:000053E8 2449            	  2030: 	move.l a1,a2				; a2 = pointer to new string
00:000053EA 227900040604    	  2031: 	move.l _fpWork+4,a1	; a1 = pointer to string
00:000053F0 F2036100        	  2032: 	fmove.l fp2,d3			; d3 = start pos
00:000053F4 D3C3            	  2033: 	add.l d3,a1					; a1 = pointer to start pos
00:000053F6 33C200040600    	  2034: 	move.w d2,_fpWork		; length
00:000053FC 23CA00040604    	  2035: 	move.l a2,_fpWork+4	; prep to return target string
00:00005402 2649            	  2036: 	move.l a1,a3				; a3 = pointer to start pos
00:00005404 D7C2            	  2037: 	add.l d2,a3					; a3 = pointer to end pos
00:00005406 61000230        	  2038: 	bsr MVUP						; move A1 to A2 until A1 = A3
00:0000540A 7002            	  2039: 	moveq #DT_STRING,d0	; data type is a string
00:0000540C F239480000040600	  2040: 	fmove.x _fpWork,fp0	; string descriptor in fp0
00:00005414 4E75            	  2041: 	rts
                            	  2042: MID1
00:00005416 6000013E        	  2043: 	bra QHOW
                            	  2044: 	
                            	  2045: ;-------------------------------------------------------------------------------
                            	  2046: ; LEFT$ function truncates the string after fp0 characters.
                            	  2047: ; Just like MID$ but with a zero starting postion.
                            	  2048: ;-------------------------------------------------------------------------------
                            	  2049: 	
                            	  2050: LEFT:
00:0000541A 6100FEF8        	  2051: 	bsr LorRArgs				; get arguments
00:0000541E F23C59000000    	  2052: 	fmove.b #0,fp2			; start pos = 0
00:00005424 6092            	  2053: 	bra DOMID
                            	  2054: 
                            	  2055: ;-------------------------------------------------------------------------------
                            	  2056: ; RIGHT$ function gets the rightmost characters.
                            	  2057: ; The start position must be calculated based on the number of characters
                            	  2058: ; requested and the string length.
                            	  2059: ;-------------------------------------------------------------------------------
                            	  2060: 
                            	  2061: RIGHT:
00:00005426 6100FEEC        	  2062: 	bsr LorRArgs				; get arguments
00:0000542A F2026000        	  2063: 	fmove.l fp0,d2			; d2 = required length
00:0000542E F239688000040600	  2064: 	fmove.x fp1,_fpWork	; _fpWork = string descriptor
00:00005436 363900040600    	  2065: 	move.w _fpWork,d3		; d3 = string length
00:0000543C 48C3            	  2066: 	ext.l d3						; make d3 a long
00:0000543E B682            	  2067: 	cmp.l d2,d3					; is length > right
00:00005440 6202            	  2068: 	bhi .0001
00:00005442 7400            	  2069: 	moveq #0,d2					; we want all the characters if length <= right
                            	  2070: .0001
00:00005444 9682            	  2071: 	sub.l d2,d3					; d3 = startpos = length - right
00:00005446 F2034100        	  2072: 	fmove.l d3,fp2			; fp2 = start position
00:0000544A 6000FF6C        	  2073: 	bra DOMID
                            	  2074: 
                            	  2075: ;-------------------------------------------------------------------------------
                            	  2076: ; LEN( EXPR ) returns the length of a string expression.
                            	  2077: ;-------------------------------------------------------------------------------
                            	  2078: 
                            	  2079: LEN:
00:0000544E 6100FB92        	  2080: 	bsr PARN
00:00005452 0C8000000002    	  2081: 	cmpi.l #DT_STRING,d0
00:00005458 66000104        	  2082: 	bne ETYPE
00:0000545C F239680000040600	  2083: 	fmove.x fp0,_fpWork
00:00005464 303900040600    	  2084: 	move.w _fpWork,d0
00:0000546A 48C0            	  2085: 	ext.l d0
00:0000546C F2005000        	  2086: 	fmove.w d0,fp0
00:00005470 7001            	  2087: 	moveq #DT_NUMERIC,d0
00:00005472 4E75            	  2088: 	rts
                            	  2089: 
                            	  2090: ;-------------------------------------------------------------------------------
                            	  2091: ; INT( EXPR ) returns the integer value of the expression.
                            	  2092: ; the expression must be in the range of a 32-bit integer.
                            	  2093: ;-------------------------------------------------------------------------------
                            	  2094: 
                            	  2095: INT:
00:00005474 6100FB6C        	  2096: 	bsr PARN
00:00005478 0C8000000001    	  2097: 	cmpi.l #DT_NUMERIC,d0
00:0000547E 660000DE        	  2098: 	bne ETYPE
00:00005482 F2000003        	  2099: 	fintrz fp0,fp0
                            	  2100: ;	fmove.l fp0,d0
                            	  2101: ;	fmove.l d0,fp0
00:00005486 7001            	  2102: 	moveq #DT_NUMERIC,d0
00:00005488 4E75            	  2103: 	rts
                            	  2104: 
                            	  2105: 
                            	  2106: ;-------------------------------------------------------------------------------
                            	  2107: ; CHR$( EXPR ) returns a one byte string containing the character.
                            	  2108: ;-------------------------------------------------------------------------------
                            	  2109: 
                            	  2110: CHR:
00:0000548A 6100FB56        	  2111: 	bsr PARN
00:0000548E 0C8000000001    	  2112: 	cmpi.l #DT_NUMERIC,d0
00:00005494 660000C8        	  2113: 	bne ETYPE
00:00005498 F2006000        	  2114: 	fmove.l fp0,d0
00:0000549C 7401            	  2115: 	moveq #1,d2
00:0000549E 6100FB58        	  2116: 	bsr AllocateString
00:000054A2 1280            	  2117: 	move.b d0,(a1)
00:000054A4 42290001        	  2118: 	clr.b 1(a1)
00:000054A8 7002            	  2119: 	moveq #DT_STRING,d0
00:000054AA 23C900040604    	  2120: 	move.l a1,_fpWork+4
00:000054B0 33FC000100040600	  2121: 	move.w #1,_fpWork
00:000054B8 F239480000040600	  2122: 	fmove.x _fpWork,fp0
00:000054C0 4E75            	  2123: 	rts
                            	  2124: 
                            	  2125: ********************************************************************
                            	  2126: *
                            	  2127: * *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                            	  2128: *
                            	  2129: * 'SETVAL' expects a variable, followed by an equal sign and then
                            	  2130: * an expression.  It evaluates the expression and sets the variable
                            	  2131: * to that value.
                            	  2132: *
                            	  2133: * 'FIN' checks the end of a command.  If it ended with ":",
                            	  2134: * execution continues.	If it ended with a CR, it finds the
                            	  2135: * the next line and continues from there.
                            	  2136: *
                            	  2137: * 'ENDCHK' checks if a command is ended with a CR. This is
                            	  2138: * required in certain commands, such as GOTO, RETURN, STOP, etc.
                            	  2139: *
                            	  2140: * 'ERROR' prints the string pointed to by A0. It then prints the
                            	  2141: * line pointed to by CURRNT with a "?" inserted at where the
                            	  2142: * old text pointer (should be on top of the stack) points to.
                            	  2143: * Execution of Tiny BASIC is stopped and a warm start is done.
                            	  2144: * If CURRNT is zero (indicating a direct command), the direct
                            	  2145: * command is not printed. If CURRNT is -1 (indicating
                            	  2146: * 'INPUT' command in progress), the input line is not printed
                            	  2147: * and execution is not terminated but continues at 'INPERR'.
                            	  2148: *
                            	  2149: * Related to 'ERROR' are the following:
                            	  2150: * 'QWHAT' saves text pointer on stack and gets "What?" message.
                            	  2151: * 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                            	  2152: * 'QSORRY' and 'ASORRY' do the same kind of thing.
                            	  2153: * 'QHOW' and 'AHOW' also do this for "How?".
                            	  2154: 
                            	  2155: ; SETVAL
                            	  2156: ; Returns:
                            	  2157: ;		a6 pointer to variable
                            	  2158: 
                            	  2159: SETVAL	
00:000054C2 6100FCCC        	  2160: 	bsr	TSTV					; variable name?
00:000054C6 6546            	  2161: 	bcs	QWHAT					; if not, say "What?"
00:000054C8 2F00            	  2162: 	move.l d0,-(sp)		; save the variable's address
00:000054CA 6100028A        	  2163: 	bsr	TSTC					; get past the "=" sign
00:000054CE 3D              	  2164: 	dc.b	'=',SV1-*
00:000054CF 11
00:000054D0 6100F842        	  2165: 	bsr	EXPR					; evaluate the expression
00:000054D4 2C5F            	  2166: 	move.l (sp)+,a6
00:000054D6 2C80            	  2167: 	move.l d0,(a6)		; save type
00:000054D8 F22E68000004    	  2168: 	fmove.x fp0,4(a6) ; and save its value in the variable
00:000054DE 4E75            	  2169: 	rts
                            	  2170: SV1
00:000054E0 602C            	  2171: 	bra	QWHAT					; if no "=" sign
                            	  2172: 
                            	  2173: FIN
00:000054E2 61000272        	  2174: 	bsr	TSTC					; *** FIN ***
00:000054E6 3A              	  2175: 	DC.B ':',FI1-*
00:000054E7 07
00:000054E8 588F            	  2176: 	ADDQ.L #4,SP			; if ":", discard return address
00:000054EA 6000F324        	  2177: 	BRA	RUNSML				; continue on the same line
                            	  2178: FI1
00:000054EE 61000266        	  2179: 	bsr	TSTC					; not ":", is it a CR?
00:000054F2 0D              	  2180: 	DC.B	CR,FI2-*
00:000054F3 07
00:000054F4 588F            	  2181: 	ADDQ.L #4,SP			; yes, purge return address
00:000054F6 6000F2C2        	  2182: 	BRA	RUNNXL				; execute the next line
                            	  2183: FI2
00:000054FA 4E75            	  2184: 	RTS								; else return to the caller
                            	  2185: 
                            	  2186: ENDCHK
00:000054FC 610002BC        	  2187: 	bsr	IGNBLK
00:00005500 0C10003A        	  2188: 	CMP.B #':',(a0)
00:00005504 6706            	  2189: 	BEQ ENDCHK1
00:00005506 0C10000D        	  2190: 	CMP.B	#CR,(A0)		; does it end with a CR?
00:0000550A 6602            	  2191: 	BNE	QWHAT					; if not, say "WHAT?"
                            	  2192: ENDCHK1:
00:0000550C 4E75            	  2193: 	RTS
                            	  2194: 
                            	  2195: QWHAT
00:0000550E 2F08            	  2196: 	MOVE.L A0,-(SP)
                            	  2197: AWHAT
00:00005510 4DFA03CA        	  2198: 	LEA	WHTMSG,A6
                            	  2199: ERROR
00:00005514 6100030A        	  2200: 	bsr	PRMESG		display the error message
00:00005518 205F            	  2201: 	MOVE.L	(SP)+,A0	restore the text pointer
00:0000551A 203A03F8        	  2202: 	MOVE.L	CURRNT,D0	get the current line number
00:0000551E 6700EF3C        	  2203: 	BEQ	WSTART		if zero, do a warm start
00:00005522 B0BCFFFFFFFF    	  2204: 	CMP.L	#-1,D0		is the line no. pointer = -1?
00:00005528 6700F560        	  2205: 	BEQ	INPERR		if so, redo input
00:0000552C 1F10            	  2206: 	MOVE.B	(A0),-(SP)	save the char. pointed to
00:0000552E 4210            	  2207: 	CLR.B	(A0)		put a zero where the error is
00:00005530 227A03E2        	  2208: 	MOVE.L	CURRNT,A1	point to start of current line
00:00005534 61000202        	  2209: 	bsr	PRTLN		display the line in error up to the 0
00:00005538 109F            	  2210: 	MOVE.B	(SP)+,(A0)	restore the character
00:0000553A 103C003F        	  2211: 	MOVE.B	#'?',D0         display a "?"
00:0000553E 6100EE96        	  2212: 	BSR	GOOUT
00:00005542 4240            	  2213: 	CLR	D0
00:00005544 5389            	  2214: 	SUBQ.L	#1,A1		point back to the error char.
00:00005546 6100017E        	  2215: 	bsr	PRTSTG		display the rest of the line
00:0000554A 6000EF10        	  2216: 	BRA	WSTART		and do a warm start
                            	  2217: QSORRY
00:0000554E 2F08            	  2218: 	MOVE.L	A0,-(SP)
                            	  2219: ASORRY
00:00005550 4DFA03AC        	  2220: 	LEA	SRYMSG,A6
00:00005554 60BE            	  2221: 	BRA	ERROR
                            	  2222: QHOW
00:00005556 2F08            	  2223: 	MOVE.L	A0,-(SP)	Error: "How?"
                            	  2224: AHOW
00:00005558 4DFA037B        	  2225: 	LEA	HOWMSG,A6
00:0000555C 60B6            	  2226: 	BRA	ERROR
                            	  2227: ETYPE
00:0000555E 4DFA0384        	  2228: 	lea TYPMSG,a6
00:00005562 60B0            	  2229: 	bra ERROR
                            	  2230: 
                            	  2231: *******************************************************************
                            	  2232: *
                            	  2233: * *** GETLN *** FNDLN (& friends) ***
                            	  2234: *
                            	  2235: * 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                            	  2236: * the character in D0 (given by the caller), then it fills the
                            	  2237: * buffer and echos. It ignores LF's but still echos
                            	  2238: * them back. Control-H is used to delete the last character
                            	  2239: * entered (if there is one), and control-X is used to delete the
                            	  2240: * whole line and start over again. CR signals the end of a line,
                            	  2241: * and causes 'GETLN' to return.
                            	  2242: *
                            	  2243: * 'FNDLN' finds a line with a given line no. (in D1) in the
                            	  2244: * text save area.  A1 is used as the text pointer. If the line
                            	  2245: * is found, A1 will point to the beginning of that line
                            	  2246: * (i.e. the high byte of the line no.), and flags are NC & Z.
                            	  2247: * If that line is not there and a line with a higher line no.
                            	  2248: * is found, A1 points there and flags are NC & NZ. If we reached
                            	  2249: * the end of the text save area and cannot find the line, flags
                            	  2250: * are C & NZ.
                            	  2251: * 'FNDLN' will initialize A1 to the beginning of the text save
                            	  2252: * area to start the search. Some other entries of this routine
                            	  2253: * will not initialize A1 and do the search.
                            	  2254: * 'FNDLNP' will start with A1 and search for the line no.
                            	  2255: * 'FNDNXT' will bump A1 by 2, find a CR and then start search.
                            	  2256: * 'FNDSKP' uses A1 to find a CR, and then starts the search.
                            	  2257: 
                            	  2258: GETLN
00:00005564 6100EE70        	  2259: 	BSR	GOOUT		display the prompt
00:00005568 103C0020        	  2260: 	MOVE.B	#' ',D0         and a space
00:0000556C 6100EE68        	  2261: 	BSR	GOOUT
00:00005570 41FA03FA        	  2262: 	LEA	BUFFER,A0	A0 is the buffer pointer
                            	  2263: GL1
00:00005574 61000298        	  2264: 	bsr	CHKIO		check keyboard
00:00005578 67FA            	  2265: 	BEQ	GL1		wait for a char. to come in
00:0000557A B03C0008        	  2266: 	CMP.B	#CTRLH,D0	delete last character?
00:0000557E 6726            	  2267: 	BEQ	GL3		if so
00:00005580 B03C0018        	  2268: 	CMP.B	#CTRLX,D0	delete the whole line?
00:00005584 6744            	  2269: 	BEQ	GL4		if so
00:00005586 B03C000D        	  2270: 	CMP.B	#CR,D0		accept a CR
00:0000558A 6706            	  2271: 	BEQ	GL2
00:0000558C B03C0020        	  2272: 	CMP.B	#' ',D0         if other control char., discard it
00:00005590 65E2            	  2273: 	BCS	GL1
                            	  2274: GL2
00:00005592 10C0            	  2275: 	MOVE.B	D0,(A0)+	save the char.
00:00005594 6100EE40        	  2276: 	BSR	GOOUT		echo the char back out
00:00005598 B03C000D        	  2277: 	CMP.B	#CR,D0		if it's a CR, end the line
00:0000559C 675C            	  2278: 	BEQ	GL7
00:0000559E B1FC000059BB    	  2279: 	CMP.L	#(BUFFER+BUFLEN-1),A0	any more room?
00:000055A4 65CE            	  2280: 	BCS	GL1		yes: get some more, else delete last char.
                            	  2281: GL3
00:000055A6 103C0008        	  2282: 	MOVE.B	#CTRLH,D0	delete a char. if possible
00:000055AA 6100EE2A        	  2283: 	BSR	GOOUT
00:000055AE 103C0020        	  2284: 	MOVE.B	#' ',D0
00:000055B2 6100EE22        	  2285: 	BSR	GOOUT
00:000055B6 B1FC0000596C    	  2286: 	CMP.L	#BUFFER,A0	any char.'s left?
00:000055BC 63B6            	  2287: 	BLS	GL1		if not
00:000055BE 103C0008        	  2288: 	MOVE.B	#CTRLH,D0	if so, finish the BS-space-BS sequence
00:000055C2 6100EE12        	  2289: 	BSR	GOOUT
00:000055C6 5388            	  2290: 	SUBQ.L	#1,A0		decrement the text pointer
00:000055C8 60AA            	  2291: 	BRA	GL1		back for more
                            	  2292: GL4
00:000055CA 2208            	  2293: 	MOVE.L	A0,D1		delete the whole line
00:000055CC 92BC0000596C    	  2294: 	SUB.L	#BUFFER,D1	figure out how many backspaces we need
00:000055D2 671E            	  2295: 	BEQ	GL6		if none needed, branch
00:000055D4 5341            	  2296: 	SUBQ	#1,D1		adjust for DBRA
                            	  2297: GL5
00:000055D6 103C0008        	  2298: 	MOVE.B	#CTRLH,D0	and display BS-space-BS sequences
00:000055DA 6100EDFA        	  2299: 	BSR	GOOUT
00:000055DE 103C0020        	  2300: 	MOVE.B	#' ',D0
00:000055E2 6100EDF2        	  2301: 	BSR	GOOUT
00:000055E6 103C0008        	  2302: 	MOVE.B	#CTRLH,D0
00:000055EA 6100EDEA        	  2303: 	BSR	GOOUT
00:000055EE 51C9FFE6        	  2304: 	DBRA	D1,GL5
                            	  2305: GL6
00:000055F2 41FA0378        	  2306: 	LEA	BUFFER,A0	reinitialize the text pointer
00:000055F6 6000FF7C        	  2307: 	BRA	GL1		and go back for more
                            	  2308: GL7
00:000055FA 103C000A        	  2309: 	MOVE.B	#LF,D0		echo a LF for the CR
00:000055FE 6000EDD6        	  2310: 	BRA	GOOUT
                            	  2311: 
                            	  2312: FNDLN
00:00005602 B2BC0000FFFF    	  2313: 	CMP.L	#$FFFF,D1	line no. must be < 65535
00:00005608 6400FF4C        	  2314: 	BCC	QHOW
00:0000560C 227AEDDC        	  2315: 	MOVE.L	TXTBGN,A1	init. the text save pointer
                            	  2316: 
                            	  2317: FNDLNP
00:00005610 247A034A        	  2318: 	MOVE.L	TXTUNF,A2	check if we passed the end
00:00005614 538A            	  2319: 	SUBQ.L	#1,A2
00:00005616 B5C9            	  2320: 	CMP.L	A1,A2
00:00005618 650C            	  2321: 	BCS	FNDRET		if so, return with Z=0 & C=1
00:0000561A 1411            	  2322: 	MOVE.B	(A1),D2	if not, get a line no.
00:0000561C E14A            	  2323: 	LSL	#8,D2
00:0000561E 14290001        	  2324: 	MOVE.B	1(A1),D2
00:00005622 B441            	  2325: 	CMP.W	D1,D2		is this the line we want?
00:00005624 6502            	  2326: 	BCS	FNDNXT		no, not there yet
                            	  2327: FNDRET
00:00005626 4E75            	  2328: 	RTS			return the cond. codes
                            	  2329: 
                            	  2330: FNDNXT
00:00005628 5489            	  2331: 	ADDQ.L	#2,A1		find the next line
                            	  2332: 
                            	  2333: FNDSKP	
00:0000562A 0C19000D        	  2334: 	CMP.B	#CR,(A1)+	try to find a CR
00:0000562E 67E0            	  2335: 	BEQ		FNDLNP
00:00005630 B3FA032A        	  2336: 	CMP.L	TXTUNF,A1
00:00005634 65F4            	  2337: 	BLO		FNDSKP
00:00005636 60D8            	  2338: 	BRA		FNDLNP		check if end of text
                            	  2339: 
                            	  2340: ;******************************************************************
                            	  2341: ;
                            	  2342: ; *** MVUP *** MVDOWN *** POPA *** PUSHA ***
                            	  2343: ;
                            	  2344: ; 'MVUP' moves a block up from where A1 points to where A2 points
                            	  2345: ; until A1=A3
                            	  2346: ;
                            	  2347: ; 'MVDOWN' moves a block down from where A1 points to where A3
                            	  2348: ; points until A1=A2
                            	  2349: ;
                            	  2350: ; 'POPA' restores the 'FOR' loop variable save area from the stack
                            	  2351: ;
                            	  2352: ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                            	  2353: ;
                            	  2354: 
                            	  2355: MVUP
00:00005638 B7C9            	  2356: 	CMP.L	A1,A3					; see the above description
00:0000563A 6304            	  2357: 	BLS	MVRET
00:0000563C 14D9            	  2358: 	MOVE.B	(A1)+,(A2)+
00:0000563E 60F8            	  2359: 	BRA	MVUP
                            	  2360: MVRET
00:00005640 4E75            	  2361: 	RTS
                            	  2362: 
                            	  2363: ; For string movements only suitable in some circumstances
                            	  2364: 
                            	  2365: MVUPW
00:00005642 B3CB            	  2366: 	cmp.l a3,a1
00:00005644 6404            	  2367: 	bhs .0001
00:00005646 34D9            	  2368: 	move.w (a1)+,(a2)+
00:00005648 60F8            	  2369: 	bra MVUPW
                            	  2370: .0001
00:0000564A 4E75            	  2371: 	rts
                            	  2372: 
                            	  2373: MVDOWN
00:0000564C B5C9            	  2374: 	CMP.L	A1,A2		see the above description
00:0000564E 67F0            	  2375: 	BEQ	MVRET
00:00005650 1721            	  2376: 	MOVE.B	-(A1),-(A3)
00:00005652 60F8            	  2377: 	BRA	MVDOWN
                            	  2378: 
                            	  2379: POPA
00:00005654 2C5F            	  2380: 	MOVE.L	(SP)+,A6			; A6 = return address
00:00005656 23DF00005924    	  2381: 	MOVE.L	(SP)+,LOPVAR	restore LOPVAR, but zero means no more
00:0000565C 6730            	  2382: 	BEQ	.0001
00:0000565E 23DF00005930    	  2383: 	MOVE.L	(SP)+,LOPINC+8	if not zero, restore the rest
00:00005664 23DF0000592C    	  2384: 	MOVE.L	(SP)+,LOPINC+4
00:0000566A 23DF00005928    	  2385: 	MOVE.L	(SP)+,LOPINC
00:00005670 23DF0000593C    	  2386: 	MOVE.L	(SP)+,LOPLMT+8
00:00005676 23DF00005938    	  2387: 	MOVE.L	(SP)+,LOPLMT+4
00:0000567C 23DF00005934    	  2388: 	MOVE.L	(SP)+,LOPLMT
00:00005682 23DF00005940    	  2389: 	MOVE.L	(SP)+,LOPLN
00:00005688 23DF00005944    	  2390: 	MOVE.L	(SP)+,LOPPT
                            	  2391: .0001
00:0000568E 4ED6            	  2392: 	JMP	(A6)		return
                            	  2393: 
                            	  2394: PUSHA
00:00005690 223A02D2        	  2395: 	MOVE.L	STKLMT,D1		; Are we running out of stack room?
00:00005694 928F            	  2396: 	SUB.L	SP,D1
00:00005696 6400FEB6        	  2397: 	BCC	QSORRY					; if so, say we're sorry
00:0000569A 2C5F            	  2398: 	MOVE.L	(SP)+,A6		; else get the return address
00:0000569C 223A0286        	  2399: 	MOVE.L	LOPVAR,D1		; save loop variables
00:000056A0 6720            	  2400: 	BEQ	.0001						; if LOPVAR is zero, that's all
00:000056A2 2F3A02A0        	  2401: 	MOVE.L	LOPPT,-(SP)	; else save all the others
00:000056A6 2F3A0298        	  2402: 	MOVE.L	LOPLN,-(SP)
00:000056AA 2F3A0288        	  2403: 	MOVE.L	LOPLMT,-(SP)
00:000056AE 2F3A0288        	  2404: 	MOVE.L	LOPLMT+4,-(SP)
00:000056B2 2F3A0288        	  2405: 	MOVE.L	LOPLMT+8,-(SP)
00:000056B6 2F3A0270        	  2406: 	MOVE.L	LOPINC,-(SP)
00:000056BA 2F3A0270        	  2407: 	MOVE.L	LOPINC+4,-(SP)
00:000056BE 2F3A0270        	  2408: 	MOVE.L	LOPINC+8,-(SP)
                            	  2409: .0001
00:000056C2 2F01            	  2410: 	MOVE.L	D1,-(SP)
00:000056C4 4ED6            	  2411: 	JMP	(A6)		return
                            	  2412: 
                            	  2413: *******************************************************************
                            	  2414: *
                            	  2415: * *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                            	  2416: *
                            	  2417: * 'PRTSTG' prints a string pointed to by A1. It stops printing
                            	  2418: * and returns to the caller when either a CR is printed or when
                            	  2419: * the next byte is the same as what was passed in D0 by the
                            	  2420: * caller.
                            	  2421: *
                            	  2422: * 'QTSTG' looks for an underline (back-arrow on some systems),
                            	  2423: * single-quote, or double-quote.  If none of these are found, returns
                            	  2424: * to the caller.  If underline, outputs a CR without a LF.  If single
                            	  2425: * or double quote, prints the quoted string and demands a matching
                            	  2426: * end quote.  After the printing, the next 2 bytes of the caller are
                            	  2427: * skipped over (usually a short branch instruction).
                            	  2428: *
                            	  2429: * 'PRTNUM' prints the 32 bit number in D1, leading blanks are added if
                            	  2430: * needed to pad the number of spaces to the number in D4.
                            	  2431: * However, if the number of digits is larger than the no. in
                            	  2432: * D4, all digits are printed anyway. Negative sign is also
                            	  2433: * printed and counted in, positive sign is not.
                            	  2434: *
                            	  2435: * 'PRTLN' prints the saved text line pointed to by A1
                            	  2436: * with line no. and all.
                            	  2437: *
                            	  2438: PRTSTG:
00:000056C6 1200            	  2439: 	MOVE.B	D0,D1		save the stop character
                            	  2440: PS1
00:000056C8 1019            	  2441: 	MOVE.B	(A1)+,D0	get a text character
00:000056CA B200            	  2442: 	CMP.B	D0,D1		same as stop character?
00:000056CC 6712            	  2443: 	BEQ	PRTRET		if so, return
00:000056CE 6100ED06        	  2444: 	BSR	GOOUT		display the char.
00:000056D2 B03C000D        	  2445: 	CMP.B	#CR,D0		is it a C.R.?
00:000056D6 66F0            	  2446: 	BNE	PS1		no, go back for more
00:000056D8 103C000A        	  2447: 	MOVE.B	#LF,D0		yes, add a L.F.
00:000056DC 6100ECF8        	  2448: 	BSR	GOOUT
                            	  2449: PRTRET
00:000056E0 4E75            	  2450: 	RTS			then return
                            	  2451: 
                            	  2452: PRTSTR2a
00:000056E2 1019            	  2453: 	move.b (a1)+,d0
00:000056E4 6100ECF0        	  2454: 	bsr GOOUT
                            	  2455: PRTSTR2:
00:000056E8 51C9FFF8        	  2456: 	dbra d1,PRTSTR2a
00:000056EC 4E75            	  2457: 	rts
                            	  2458: 	
                            	  2459: 	if 0
                            	  2460: QTSTG
                            	  2461: 	bsr	TSTC		*** QTSTG ***
                            	  2462: 	DC.B	'"',QT3-*
                            	  2463: 	MOVE.B	#'"',D0         it is a "
                            	  2464: QT1
                            	  2465: 	MOVE.L	A0,A1
                            	  2466: 	BSR	PRTSTG		print until another
                            	  2467: 	MOVE.L	A1,A0
                            	  2468: 	MOVE.L	(SP)+,A1	pop return address
                            	  2469: 	CMP.B	#LF,D0		was last one a CR?
                            	  2470: 	BEQ	RUNNXL		if so, run next line
                            	  2471: QT2
                            	  2472: 	ADDQ.L	#2,A1		skip 2 bytes on return
                            	  2473: 	JMP	(A1)		return
                            	  2474: QT3
                            	  2475: 	bsr	TSTC		is it a single quote?
                            	  2476: 	DC.B	'''',QT4-*
                            	  2477: 	MOVE.B	#'''',D0        if so, do same as above
                            	  2478: 	BRA	QT1
                            	  2479: QT4
                            	  2480: 	bsr	TSTC		is it an underline?
                            	  2481: 	DC.B	'_',QT5-*
                            	  2482: 	MOVE.B	#CR,D0		if so, output a CR without LF
                            	  2483: 	bsr	GOOUT
                            	  2484: 	MOVE.L	(SP)+,A1	pop return address
                            	  2485: 	BRA	QT2
                            	  2486: QT5
                            	  2487: 	RTS			none of the above
                            	  2488: 	endif
                            	  2489: 
                            	  2490: PRTNUM:
00:000056EE 4E52FFD0        	  2491: 	link a2,#-48
00:000056F2 217900040098002C	  2492: 	move.l _canary,44(a0)
00:000056FA 48D7020F        	  2493: 	movem.l d0/d1/d2/d3/a1,(sp)
00:000056FE F22F68000014    	  2494: 	fmove.x fp0,20(sp)
00:00005704 F22F68800020    	  2495: 	fmove.x fp1,32(sp)
00:0000570A F2000400        	  2496: 	fmove.x fp1,fp0					; fp0 = number to print
00:0000570E 43F900040520    	  2497: 	lea _fpBuf,a1						; a1 = pointer to buffer to use
00:00005714 7027            	  2498: 	moveq #39,d0						; d0 = function #39 print float
00:00005716 2204            	  2499: 	move.l d4,d1						; d1 = width
00:00005718 2404            	  2500: 	move.l d4,d2						; d2 = precision max
00:0000571A 7665            	  2501: 	moveq #'e',d3
00:0000571C 4E4F            	  2502: 	trap #15
00:0000571E 4CD7020F        	  2503: 	movem.l (sp),d0/d1/d2/d3/a1
00:00005722 F22F48000014    	  2504: 	fmove.x 20(sp),fp0
00:00005728 F22F48800020    	  2505: 	fmove.x 32(sp),fp1
00:0000572E A2A80003002C    	  2506: 	cchk 44(a0)
00:00005734 4E5A            	  2507: 	unlk a2
00:00005736 4E75            	  2508: 	rts
                            	  2509: 
                            	  2510: ; Debugging
                            	  2511: 	if 0
                            	  2512: PRTFP0:
                            	  2513: 	link a2,#-48
                            	  2514: 	move.l _canary,44(a0)
                            	  2515: 	movem.l d0/d1/d2/d3/a1,(sp)
                            	  2516: 	fmove.x fp0,20(sp)
                            	  2517: 	lea _fpBuf,a1						; a1 = pointer to buffer to use
                            	  2518: 	moveq #39,d0						; d0 = function #39 print float
                            	  2519: 	moveq #30,d1						; d1 = width
                            	  2520: 	moveq #25,d2						; d2 = precision max
                            	  2521: 	moveq #'e',d3
                            	  2522: 	trap #15
                            	  2523: 	movem.l (sp),d0/d1/d2/d3/a1
                            	  2524: 	fmove.x 20(sp),fp0
                            	  2525: 	cchk 44(a0)
                            	  2526: 	unlk a2
                            	  2527: 	rts
                            	  2528: 	endif
                            	  2529: 
                            	  2530: PRTLN:
00:00005738 7200            	  2531: 	CLR.L	D1
00:0000573A 1219            	  2532: 	MOVE.B (A1)+,D1	get the binary line number
00:0000573C E149            	  2533: 	LSL	#8,D1
00:0000573E 1219            	  2534: 	MOVE.B (A1)+,D1
00:00005740 F2015080        	  2535: 	FMOVE.W D1,FP1
00:00005744 7805            	  2536: 	MOVEQ	#5,D4			; display a 5 digit line no.
00:00005746 61A6            	  2537: 	BSR	PRTNUM
00:00005748 103C0020        	  2538: 	MOVE.B	#' ',D0         followed by a blank
00:0000574C 6100EC88        	  2539: 	BSR	GOOUT
00:00005750 4240            	  2540: 	CLR	D0		stop char. is a zero
00:00005752 6000FF72        	  2541: 	BRA	PRTSTG		display the rest of the line
                            	  2542: 
                            	  2543: 
                            	  2544: ; ===== Test text byte following the call to this subroutine. If it
                            	  2545: ; equals the byte pointed to by A0, return to the code following
                            	  2546: ; the call. If they are not equal, branch to the point
                            	  2547: ;	indicated by the offset byte following the text byte.
                            	  2548: 
                            	  2549: TSTC:
00:00005756 6162            	  2550: 	BSR	IGNBLK				; ignore leading blanks
00:00005758 225F            	  2551: 	MOVE.L (SP)+,A1		; get the return address
00:0000575A 1219            	  2552: 	MOVE.B (A1)+,D1		; get the byte to compare
00:0000575C B210            	  2553: 	CMP.B	(A0),D1 		;	is it = to what A0 points to?
00:0000575E 6708            	  2554: 	BEQ	TC1						; if so
00:00005760 7200            	  2555: 	CLR.L	D1					; If not, add the second
00:00005762 1211            	  2556: 	MOVE.B (A1),D1 		; byte following the call to
00:00005764 D3C1            	  2557: 	ADD.L	D1,A1				; the return address.
00:00005766 4ED1            	  2558: 	JMP	(A1)					; jump to the routine
                            	  2559: TC1
00:00005768 5288            	  2560: 	ADDQ.L #1,A0			; if equal, bump text pointer
00:0000576A 5289            	  2561: 	ADDQ.L #1,A1			; Skip the 2 bytes following
00:0000576C 4ED1            	  2562: 	JMP	(A1)					; the call and continue.
                            	  2563: 
                            	  2564: 
                            	  2565: ; ===== See if the text pointed to by A0 is a number. If so,
                            	  2566: ;	return the number in FP1 and the number of digits in D2,
                            	  2567: ;	else return zero in FP1 and D2.
                            	  2568: ; If text is not a number, then A0 is not updated, otherwise
                            	  2569: ; A0 is advanced past the number. Note A0 is always updated
                            	  2570: ; past leading spaces.
                            	  2571: 
                            	  2572: TSTNUM
00:0000576E 4E52FFE0        	  2573: 	link a2,#-32
00:00005772 2F7900040098001C	  2574: 	move.l _canary,28(sp)
00:0000577A 48D70202        	  2575: 	movem.l d1/a1,(sp)
00:0000577E F22F68000010    	  2576: 	fmove.x fp0,16(sp)
00:00005784 7029            	  2577: 	moveq #41,d0						; function #41, get float
00:00005786 7201            	  2578: 	moveq #1,d1							; d1 = input stride
00:00005788 2248            	  2579: 	move.l a0,a1						; a1 = pointer to input buffer
00:0000578A 4E4F            	  2580: 	trap #15								; call BIOS get float function
00:0000578C 2049            	  2581: 	move.l a1,a0						; set text pointer
00:0000578E 7001            	  2582: 	moveq #DT_NUMERIC,d0		; default data type = number
00:00005790 F2000080        	  2583: 	fmove.x fp0,fp1					; return expected in fp1
00:00005794 4A41            	  2584: 	tst.w d1								; check if a number (digits > 0?)
00:00005796 6706            	  2585: 	beq .0002
00:00005798 7400            	  2586: 	clr.l d2								; d2.l = 0
00:0000579A 3401            	  2587: 	move.w d1,d2						; d2 = number of digits
00:0000579C 6008            	  2588: 	bra .0001
                            	  2589: .0002											; not a number, return with orignal text pointer
00:0000579E 7000            	  2590: 	moveq #0,d0							; data type = not a number
00:000057A0 7400            	  2591: 	moveq #0,d2							; d2 = 0
00:000057A2 F2024080        	  2592: 	fmove.l d2,fp1					; return a zero
                            	  2593: .0001
00:000057A6 4CD70202        	  2594: 	movem.l (sp),d1/a1
00:000057AA F22F48000010    	  2595: 	fmove.x 16(sp),fp0
00:000057B0 A2AF0003001C    	  2596: 	cchk 28(sp)
00:000057B6 4E5A            	  2597: 	unlk a2
00:000057B8 4E75            	  2598: 	rts
                            	  2599: 		
                            	  2600: ; ===== Skip over blanks in the text pointed to by A0.
                            	  2601: 
                            	  2602: IGNBLK
00:000057BA 0C180020        	  2603: 	CMP.B	#' ',(A0)+		; see if it's a space
00:000057BE 67FA            	  2604: 	BEQ	IGNBLK					; if so, swallow it
00:000057C0 5388            	  2605: 	SUBQ.L #1,A0				; decrement the text pointer
00:000057C2 4E75            	  2606: 	RTS
                            	  2607: 
                            	  2608: *
                            	  2609: * ===== Convert the line of text in the input buffer to upper
                            	  2610: *	case (except for stuff between quotes).
                            	  2611: *
00:000057C4 41FA01A6        	  2612: TOUPBUF LEA	BUFFER,A0	set up text pointer
00:000057C8 4201            	  2613: 	CLR.B	D1		clear quote flag
                            	  2614: TOUPB1	
00:000057CA 1018            	  2615: 	MOVE.B	(A0)+,D0	get the next text char.
00:000057CC B03C000D        	  2616: 	CMP.B	#CR,D0		is it end of line?
00:000057D0 6718            	  2617: 	BEQ	TOUPBRT 	if so, return
00:000057D2 B03C0022        	  2618: 	CMP.B	#'"',D0         a double quote?
00:000057D6 6714            	  2619: 	BEQ	DOQUO
00:000057D8 B03C0027        	  2620: 	CMP.B	#'''',D0        or a single quote?
00:000057DC 670E            	  2621: 	BEQ	DOQUO
00:000057DE 4A01            	  2622: 	TST.B	D1		inside quotes?
00:000057E0 66E8            	  2623: 	BNE	TOUPB1		if so, do the next one
00:000057E2 6118            	  2624: 	BSR	TOUPPER 	convert to upper case
00:000057E4 1100            	  2625: 	MOVE.B	D0,-(A0)	store it
00:000057E6 5288            	  2626: 	ADDQ.L	#1,A0
00:000057E8 60E0            	  2627: 	BRA	TOUPB1		and go back for more
                            	  2628: TOUPBRT
00:000057EA 4E75            	  2629: 	RTS
                            	  2630: 
00:000057EC 4A01            	  2631: DOQUO	TST.B	D1		are we inside quotes?
00:000057EE 6604            	  2632: 	BNE	DOQUO1
00:000057F0 1200            	  2633: 	MOVE.B	D0,D1		if not, toggle inside-quotes flag
00:000057F2 60D6            	  2634: 	BRA	TOUPB1
00:000057F4 B200            	  2635: DOQUO1	CMP.B	D0,D1		make sure we're ending proper quote
00:000057F6 66D2            	  2636: 	BNE	TOUPB1		if not, ignore it
00:000057F8 4201            	  2637: 	CLR.B	D1		else clear quote flag
00:000057FA 60CE            	  2638: 	BRA	TOUPB1
                            	  2639: 
                            	  2640: *
                            	  2641: * ===== Convert the character in D0 to upper case
                            	  2642: *
00:000057FC B03C0061        	  2643: TOUPPER CMP.B	#'a',D0         is it < 'a'?
00:00005800 650A            	  2644: 	BCS	TOUPRET
00:00005802 B03C007A        	  2645: 	CMP.B	#'z',D0         or > 'z'?
00:00005806 6204            	  2646: 	BHI	TOUPRET
00:00005808 903C0020        	  2647: 	SUB.B	#32,D0		if not, make it upper case
00:0000580C 4E75            	  2648: TOUPRET RTS
                            	  2649: 
                            	  2650: *
                            	  2651: * 'CHKIO' checks the input. If there's no input, it will return
                            	  2652: * to the caller with the Z flag set. If there is input, the Z
                            	  2653: * flag is cleared and the input byte is in D0. However, if a
                            	  2654: * control-C is read, 'CHKIO' will warm-start BASIC and will not
                            	  2655: * return to the caller.
                            	  2656: *
                            	  2657: CHKIO
00:0000580E 6100EBCA        	  2658: 	bsr	GOIN		get input if possible
00:00005812 670A            	  2659: 	BEQ	CHKRET		if Zero, no input
00:00005814 B03C0003        	  2660: 	CMP.B	#CTRLC,D0	is it control-C?
00:00005818 6604            	  2661: 	BNE	CHKRET		if not
00:0000581A 6000EC40        	  2662: 	BRA	WSTART		if so, do a warm start
                            	  2663: CHKRET
00:0000581E 4E75            	  2664: 	RTS
                            	  2665: 
                            	  2666: *
                            	  2667: * ===== Display a CR-LF sequence
                            	  2668: *
                            	  2669: ;CRLF	LEA	CLMSG,A6
                            	  2670: 
                            	  2671: 
                            	  2672: ; ===== Display a zero-ended string pointed to by register A6
                            	  2673: 
                            	  2674: PRMESG
00:00005820 101E            	  2675: 	MOVE.B (A6)+,D0		; get the char.
00:00005822 6706            	  2676: 	BEQ	PRMRET				; if it's zero, we're done
00:00005824 6100EBB0        	  2677: 	BSR	GOOUT					; else display it
00:00005828 60F6            	  2678: 	BRA	PRMESG
                            	  2679: PRMRET
00:0000582A 4E75            	  2680: 	RTS
                            	  2681: 
                            	  2682: ******************************************************
                            	  2683: * The following routines are the only ones that need *
                            	  2684: * to be changed for a different I/O environment.     *
                            	  2685: ******************************************************
                            	  2686: 
                            	  2687: ; ===== Clear screen and home cursor
                            	  2688: 
                            	  2689: CLS:
00:0000582C 700B            	  2690: 	moveq #11,d0			; set cursor position
00:0000582E 323CFF00        	  2691: 	move.w #$FF00,d1	; home cursor and clear screen
00:00005832 4E4F            	  2692: 	trap #15
00:00005834 6000F0E0        	  2693: 	bra FINISH
                            	  2694: 
                            	  2695: ; ===== Output character to the console (Port 1) from register D0
                            	  2696: ;(Preserves all registers.)
                            	  2697: 
                            	  2698: OUTC:
00:00005838 48E7C000        	  2699: 	movem.l d0/d1,-(sp)
00:0000583C 2200            	  2700: 	move.l d0,d1
00:0000583E 7006            	  2701: 	moveq #6,d0
00:00005840 4E4F            	  2702: 	trap #15
00:00005842 4CDF0003        	  2703: 	movem.l (sp)+,d0/d1
00:00005846 4E75            	  2704: 	rts
                            	  2705: 
                            	  2706: * ===== Input a character from the console into register D0 (or
                            	  2707: *	return Zero status if there's no character available).
                            	  2708: *
                            	  2709: INC
00:00005848 2F0E            	  2710: 	move.l	a6,-(a7)
00:0000584A 2C7A00C0        	  2711: 	move.l	INPPTR,a6
00:0000584E 4E96            	  2712: 	jsr			(a6)
00:00005850 2C5F            	  2713: 	move.l	(a7)+,a6
00:00005852 4E75            	  2714: 	rts
                            	  2715: 
                            	  2716: INC1
00:00005854 2F01            	  2717: 	move.l	d1,-(a7)
00:00005856 7005            	  2718: 	moveq.l	#5,d0			* function 5 GetKey
00:00005858 4E4F            	  2719: 	trap		#15
00:0000585A 2001            	  2720: 	move.l	d1,d0
00:0000585C 221F            	  2721: 	move.l	(a7)+,d1
00:0000585E 0C0000FF        	  2722: 	cmpi.b	#-1,d0
00:00005862 6602            	  2723: 	bne			.0001
00:00005864 4200            	  2724: 	clr.b		d0
                            	  2725: .0001:
00:00005866 4E75            	  2726: 	rts
                            	  2727: 
                            	  2728: *INC	BTST	#0,$10040	is character ready?
                            	  2729: *	BEQ	INCRET		if not, return Zero status
                            	  2730: *	MOVE.B	$10042,D0	else get the character
                            	  2731: *	AND.B	#$7F,D0 	zero out the high bit
                            	  2732: *INCRET	RTS
                            	  2733: 
                            	  2734: * ===== Output character to the host (Port 2) from register D0
                            	  2735: *	(Preserves all registers.)
                            	  2736: *
                            	  2737: AUXOUT:
00:00005868 13FC0002000400A8	  2738: 	move.b #2,OutputDevice
00:00005870 61C6            	  2739: 	bsr OUTC
00:00005872 13FC0001000400A8	  2740: 	move.b #1,OutputDevice
00:0000587A 4E75            	  2741: 	rts
                            	  2742: 
                            	  2743: *AUXOUT	BTST	#1,$10041	is port 2 ready for a character?
                            	  2744: *	BEQ	AUXOUT		if not, wait for it
                            	  2745: *	MOVE.B	D0,$10043	out it goes.
                            	  2746: *	RTS
                            	  2747: 
                            	  2748: *
                            	  2749: * ===== Input a character from the host into register D0 (or
                            	  2750: *	return Zero status if there's no character available).
                            	  2751: *
                            	  2752: AUXIN:
00:0000587C 2F01            	  2753: 	move.l	d1,-(a7)
00:0000587E 7024            	  2754: 	moveq		#36,d0				; serial get char from buffer
00:00005880 4E4F            	  2755: 	trap		#15
00:00005882 2001            	  2756: 	move.l	d1,d0
00:00005884 221F            	  2757: 	move.l	(a7)+,d1
00:00005886 0C40FFFF        	  2758: 	cmpi.w	#-1,d0
00:0000588A 670A            	  2759: 	beq			.0001
00:0000588C 0200007F        	  2760: 	andi.b	#$7F,d0				; clear high bit
00:00005890 4880            	  2761: 	ext.w		d0						; return character in d0
00:00005892 48C0            	  2762: 	ext.l		d0
00:00005894 4E75            	  2763: 	rts
                            	  2764: .0001:
00:00005896 7000            	  2765: 	moveq		#0,d0					; return zf=1 if no character available
00:00005898 4E75            	  2766: 	rts
                            	  2767: 
                            	  2768: ;AUXIN
                            	  2769: *AUXIN	BTST	#0,$10041	is character ready?
                            	  2770: *	BEQ	AXIRET		if not, return Zero status
                            	  2771: *	MOVE.B	$10043,D0	else get the character
                            	  2772: *	AND.B	#$7F,D0 	zero out the high bit
00:0000589A 4E75            	  2773: AXIRET	RTS
                            	  2774: 
                            	  2775: ; ===== Return to the resident monitor, operating system, etc.
                            	  2776: ;
                            	  2777: BYEBYE	
00:0000589C 23FC000000080004	  2778: 	move.l #8,_fpTextIncr
00:000058A4 0094
00:000058A6 60001504        	  2779: 	bra		Monitor
                            	  2780: ;	MOVE.B	#228,D7 	return to Tutor
                            	  2781: ;	TRAP	#14
                            	  2782: 
00:000058AA 0D              	  2783: INITMSG DC.B	CR,LF,'MC68000 Tiny Float BASIC, v1.0',CR,LF,LF,0
00:000058AB 0A
00:000058AC 4D43363830303020
00:000058B4 54696E7920466C6F
00:000058BC 6174204241534943
00:000058C4 2C2076312E30
00:000058CA 0D
00:000058CB 0A
00:000058CC 0A
00:000058CD 00
00:000058CE 0D              	  2784: OKMSG	DC.B	CR,LF,'OK',CR,LF,0
00:000058CF 0A
00:000058D0 4F4B
00:000058D2 0D
00:000058D3 0A
00:000058D4 00
00:000058D5 486F773F        	  2785: HOWMSG	DC.B	'How?',CR,LF,0
00:000058D9 0D
00:000058DA 0A
00:000058DB 00
00:000058DC 576861743F      	  2786: WHTMSG	DC.B	'What?',CR,LF,0
00:000058E1 0D
00:000058E2 0A
00:000058E3 00
00:000058E4 547970653F      	  2787: TYPMSG	DC.B	'Type?',CR,LF,0
00:000058E9 0D
00:000058EA 0A
00:000058EB 00
00:000058EC 4E6F20737472696E	  2788: NOSTRING	DC.B 'No string space',CR,LF,0
00:000058F4 67207370616365
00:000058FB 0D
00:000058FC 0A
00:000058FD 00
00:000058FE 536F7272792E    	  2789: SRYMSG	DC.B	'Sorry.'
00:00005904 0D              	  2790: CLMSG	DC.B	CR,LF,0
00:00005905 0A
00:00005906 00
00:00005907 00              	  2791: 	DC.B	0	<- for aligning on a word boundary
                            	  2792: LSTROM	EQU	*		end of possible ROM area
                            	  2793: *
                            	  2794: * Internal variables follow:
                            	  2795: *
                            	  2796: 	align 2
00:00005908 000043D0        	  2797: RANPNT	DC.L	START		random number pointer
00:0000590C 00000000        	  2798: INPPTR	DS.L	1		input pointer
00:00005910 00000000        	  2799: OUTPTR	DS.L	1 	output pointer
00:00005914 00000000        	  2800: CURRNT	DS.L	1		; Current line pointer
00:00005918 00000000        	  2801: STKFP		DS.L	1		; saves frame pointer
00:0000591C 00000000        	  2802: STKGOS	DS.L	1		Saves stack pointer in 'GOSUB'
00:00005920 00000000        	  2803: STKINP	DS.L	1		Saves stack pointer during 'INPUT'
00:00005924 00000000        	  2804: LOPVAR	DS.L	1		'FOR' loop save area
00:00005928 00000000        	  2805: LOPINC	DS.L	3		increment
00:0000592C *
00:00005934 00000000        	  2806: LOPLMT	DS.L	3		limit
00:00005938 *
00:00005940 00000000        	  2807: LOPLN	DS.L	1		line number
00:00005944 00000000        	  2808: LOPPT	DS.L	1		text pointer
00:00005948 00000000        	  2809: IRQROUT	DS.L	1
00:0000594C 00000000        	  2810: STRSTK	DS.L	1		; string pointer stack area, 8 entries
00:00005950 00000000        	  2811: StrSp		DS.L	1		; string stack stack pointer
00:00005954 00000000        	  2812: StrArea	DS.L	1		; pointer to string area
00:00005958 00000000        	  2813: LastStr	DS.L	1		; pointer to last used string in area
00:0000595C 00000000        	  2814: TXTUNF	DS.L	1		points to unfilled text area
00:00005960 00000000        	  2815: VARBGN	DS.L	1		points to variable area
00:00005964 00000000        	  2816: STKLMT	DS.L	1		holds lower limit for stack growth
00:00005968 00000000        	  2817: DIRFLG	DS.L	1		; indicates 1=DIRECT mode
00:0000596C 00              	  2818: BUFFER	DS.B	BUFLEN		Keyboard input buffer
00:0000596D *
                            	  2819: TXT	EQU	*		Beginning of program area
                            	  2820: ;	END
                            	  2821: 

Source: "boot.x68"
                            	  1007: 
                            	  1008: ; -----------------------------------------------------------------------------
                            	  1009: ; -----------------------------------------------------------------------------
                            	  1010: 
                            	  1011: set_text_mode:
00:000059BC 7040            	  1012: 	moveq #64,d0
00:000059BE 13C0FD080000    	  1013: 	move.b d0,TEXTREG					; number of columns
00:000059C4 7020            	  1014: 	moveq #32,d0
00:000059C6 13C0FD080001    	  1015: 	move.b d0,TEXTREG+1				; number of rows
00:000059CC 7000            	  1016: 	moveq #0,d0
00:000059CE 13C0FD080003    	  1017: 	move.b d0,TEXTREG+3				; text mode
00:000059D4 7011            	  1018: 	moveq #17,d0
00:000059D6 13C0FD080008    	  1019: 	move.b d0,TEXTREG+8				; max row scan
00:000059DC 700B            	  1020: 	moveq #11,d0
00:000059DE 13C0FD08000A    	  1021: 	move.b d0,TEXTREG+10			; max pix
00:000059E4 4E75            	  1022: 	rts
                            	  1023: 	
                            	  1024: set_graphics_mode:
00:000059E6 7064            	  1025: 	moveq #100,d0
00:000059E8 13C0FD080000    	  1026: 	move.b d0,TEXTREG					; number of columns
00:000059EE 704B            	  1027: 	moveq #75,d0
00:000059F0 13C0FD080001    	  1028: 	move.b d0,TEXTREG+1				; number of rows
00:000059F6 7001            	  1029: 	moveq #1,d0
00:000059F8 13C0FD080003    	  1030: 	move.b d0,TEXTREG+3				; graphics mode
00:000059FE 7007            	  1031: 	moveq #7,d0
00:00005A00 13C0FD080008    	  1032: 	move.b d0,TEXTREG+8				; max row scan
00:00005A06 7007            	  1033: 	moveq #7,d0
00:00005A08 13C0FD08000A    	  1034: 	move.b d0,TEXTREG+10			; max pix
00:00005A0E 4E75            	  1035: 	rts
                            	  1036: 	
                            	  1037: ; -----------------------------------------------------------------------------
                            	  1038: ; Gets the screen color in d0 and d1.
                            	  1039: ; -----------------------------------------------------------------------------
                            	  1040: 
                            	  1041: get_screen_color:
                            	  1042: 	if (SCREEN_FORMAT==1)
00:00005A10 203900040084    	  1043: 		move.l fgColor,d0				; get foreground color in bits 0 to 7
00:00005A16 E180            	  1044: 		asl.l #8,d0							; foreground color in bits 8 to 15
00:00005A18 80B900040088    	  1045: 		or.l bkColor,d0					;
00:00005A1E 4840            	  1046: 		swap d0									; foreground color in bits 24 to 31, bk in 16 to 23
                            	  1047: 	else
                            	  1048: 		move.l	fgColor,d0			; get foreground color
                            	  1049: 		asl.l		#5,d0						; shift into position
                            	  1050: 		ori.l		#$40000000,d0		; set priority
                            	  1051: 		move.l	bkColor,d1
                            	  1052: 		lsr.l		#8,d1
                            	  1053: 		lsr.l		#8,d1
                            	  1054: 		andi.l	#31,d1					; mask off extra bits
                            	  1055: 		or.l		d1,d0						; set background color bits in upper long word
                            	  1056: 		move.l	bkColor,d1			; get background color
                            	  1057: 		asl.l		#8,d1						; shift into position for display ram
                            	  1058: 		asl.l		#8,d1
                            	  1059: 	endif
00:00005A20 4E75            	  1060: 	rts
                            	  1061: 
                            	  1062: ; -----------------------------------------------------------------------------
                            	  1063: ; -----------------------------------------------------------------------------
                            	  1064: 
                            	  1065: get_screen_address:
00:00005A22 207900040004    	  1066: 	move.l	TextScr,a0
00:00005A28 4E75            	  1067: 	rts
                            	  1068: 	
                            	  1069: ; -----------------------------------------------------------------------------
                            	  1070: ; -----------------------------------------------------------------------------
                            	  1071: 
                            	  1072: clear_screen:
00:00005A2A 48E7E080        	  1073: 	movem.l	d0/d1/d2/a0,-(a7)
00:00005A2E 4E7A0FE0        	  1074: 	movec		coreno,d0
00:00005A32 4840            	  1075: 	swap		d0	
                            	  1076: ;	moveq		#SCREEN_SEMA,d1
                            	  1077: ;	bsr			LockSemaphore
00:00005A34 61EC            	  1078: 	bsr	get_screen_address			; a0 = pointer to screen area
00:00005A36 10390004008C    	  1079: 	move.b	TextRows,d0					; d0 = rows
00:00005A3C 14390004008D    	  1080: 	move.b	TextCols,d2					; d2 = cols
00:00005A42 4880            	  1081: 	ext.w		d0									; convert to word
00:00005A44 4882            	  1082: 	ext.w		d2									; convert to word
00:00005A46 C4C0            	  1083: 	mulu d0,d2									; d2 = number of character cells to clear
00:00005A48 61C6            	  1084: 	bsr	get_screen_color				; get the color bits
                            	  1085: 	if (SCREEN_FORMAT==1)
00:00005A4A 00400020        	  1086: 		ori.w #32,d0
00:00005A4E E158            	  1087: 		rol.w #8,d0
00:00005A50 4840            	  1088: 		swap d0
00:00005A52 E158            	  1089: 		rol.w #8,d0
                            	  1090: loop3:
00:00005A54 20C0            	  1091: 		move.l d0,(a0)+						; copy to cell
                            	  1092: 	else
                            	  1093: 		ori.w	#32,d1							; load space character
                            	  1094: 		rol.w	#8,d1								; swap endian, text controller expects little endian
                            	  1095: 		swap d1
                            	  1096: 		rol.w	#8,d1
                            	  1097: 		rol.w	#8,d0								; swap endian
                            	  1098: 		swap d0
                            	  1099: 		rol.w	#8,d0
                            	  1100: loop3:
                            	  1101: 		move.l d1,(a0)+						; copy char plus bkcolor to cell
                            	  1102: 		move.l d0,(a0)+						; copy fgcolor to cell
                            	  1103: 	endif
00:00005A56 51CAFFFC        	  1104: 	dbra d2,loop3
00:00005A5A 4E7A0FE0        	  1105: 	movec coreno,d0
00:00005A5E 4840            	  1106: 	swap d0	
                            	  1107: ;	moveq #SCREEN_SEMA,d1
                            	  1108: ;	bsr UnlockSemaphore
00:00005A60 4CDF0107        	  1109: 	movem.l (a7)+,d0/d1/d2/a0
00:00005A64 4E75            	  1110: 	rts
                            	  1111: 
                            	  1112: CRLF:
00:00005A66 48E7C000        	  1113: 	movem.l d0/d1,-(a7)
00:00005A6A 123C000D        	  1114: 	move.b #13,d1
00:00005A6E 7006            	  1115: 	moveq #6,d0						; output character function
00:00005A70 4E4F            	  1116: 	trap #15
00:00005A72 123C000A        	  1117: 	move.b #10,d1
00:00005A76 7006            	  1118: 	moveq #6,d0						; output character function
00:00005A78 4E4F            	  1119: 	trap #15
00:00005A7A 4CDF0003        	  1120: 	movem.l (a7)+,d0/d1
00:00005A7E 4E75            	  1121: 	rts
                            	  1122: 
                            	  1123: ;------------------------------------------------------------------------------
                            	  1124: ;------------------------------------------------------------------------------
                            	  1125: 
                            	  1126: UpdateTextPos:
00:00005A80 103900040000    	  1127: 	move.b	CursorRow,d0		; compute screen location
00:00005A86 0240007F        	  1128: 	andi.w	#$7f,d0
00:00005A8A 14390004008D    	  1129: 	move.b	TextCols,d2
00:00005A90 4882            	  1130: 	ext.w		d2
00:00005A92 C0C2            	  1131: 	mulu.w	d2,d0
00:00005A94 2600            	  1132: 	move.l	d0,d3
00:00005A96 143900040001    	  1133: 	move.b	CursorCol,d2
00:00005A9C 024200FF        	  1134: 	andi.w	#$ff,d2
00:00005AA0 D042            	  1135: 	add.w		d2,d0
00:00005AA2 33C000040002    	  1136: 	move.w	d0,TextPos			; save cursor pos
00:00005AA8 4E75            	  1137: 	rts
                            	  1138: 
                            	  1139: ;------------------------------------------------------------------------------
                            	  1140: ; Calculate screen memory location from CursorRow,CursorCol.
                            	  1141: ; Destroys d0,d2,a0
                            	  1142: ;------------------------------------------------------------------------------
                            	  1143: 
                            	  1144: CalcScreenLoc:
00:00005AAA 61D4            	  1145: 	bsr	UpdateTextPos
00:00005AAC 48C0            	  1146: 	ext.l	d0									;	 make it into a long
                            	  1147: 	if (SCREEN_FORMAT==1)
00:00005AAE E580            	  1148: 		asl.l #2,d0							; 4 bytes per char
                            	  1149: 	else
                            	  1150: 		asl.l	#3,d0							; 8 bytes per char
                            	  1151: 	endif
00:00005AB0 6100FF70        	  1152: 	bsr	get_screen_address
00:00005AB4 D1C0            	  1153: 	add.l	d0,a0								; a0 = screen location
00:00005AB6 4E75            	  1154: 	rts
                            	  1155: 
                            	  1156: ;------------------------------------------------------------------------------
                            	  1157: ; Display a character on the screen
                            	  1158: ; d1.b = char to display
                            	  1159: ;------------------------------------------------------------------------------
                            	  1160: 
                            	  1161: DisplayChar:
00:00005AB8 48E77000        	  1162: 	movem.l	d1/d2/d3,-(a7)
00:00005ABC 4E7A2FE0        	  1163: 	movec		coreno,d2
00:00005AC0 0C020002        	  1164: 	cmpi.b	#2,d2
                            	  1165: ;	bne.s		.0001
                            	  1166: ;	bsr			SerialPutChar
                            	  1167: .0001:
00:00005AC4 0281000000FF    	  1168: 	andi.l	#$ff,d1				; zero out upper bytes of d1
00:00005ACA 0C01000D        	  1169: 	cmpi.b	#13,d1				; carriage return ?
00:00005ACE 6610            	  1170: 	bne			dccr
00:00005AD0 423900040001    	  1171: 	clr.b		CursorCol			; just set cursor column to zero on a CR
                            	  1172: dcx14:
00:00005AD6 61000294        	  1173: 	bsr			SyncCursor		; set position in text controller
                            	  1174: dcx7:
00:00005ADA 4CDF000E        	  1175: 	movem.l	(a7)+,d1/d2/d3
00:00005ADE 4E75            	  1176: 	rts
                            	  1177: dccr:
00:00005AE0 0C010091        	  1178: 	cmpi.b	#$91,d1			; cursor right ?
00:00005AE4 6618            	  1179: 	bne.s   dcx6
00:00005AE6 14390004008D    	  1180: 	move.b	TextCols,d2
00:00005AEC 5302            	  1181: 	sub.b		#1,d2
00:00005AEE 943900040001    	  1182: 	sub.b		CursorCol,d2
00:00005AF4 67E4            	  1183: 	beq.s		dcx7
00:00005AF6 523900040001    	  1184: 	addi.b	#1,CursorCol
00:00005AFC 60D8            	  1185: 	bra.s		dcx14
                            	  1186: dcx6:
00:00005AFE 0C010090        	  1187: 	cmpi.b	#$90,d1			; cursor up ?
00:00005B02 6610            	  1188: 	bne.s		dcx8
00:00005B04 4A3900040000    	  1189: 	cmpi.b	#0,CursorRow
00:00005B0A 67CE            	  1190: 	beq.s		dcx7
00:00005B0C 533900040000    	  1191: 	subi.b	#1,CursorRow
00:00005B12 60C2            	  1192: 	bra.s		dcx14
                            	  1193: dcx8:
00:00005B14 0C010093        	  1194: 	cmpi.b	#$93,d1			; cursor left?
00:00005B18 6610            	  1195: 	bne.s		dcx9
00:00005B1A 4A3900040001    	  1196: 	cmpi.b	#0,CursorCol
00:00005B20 67B8            	  1197: 	beq.s		dcx7
00:00005B22 533900040001    	  1198: 	subi.b	#1,CursorCol
00:00005B28 60AC            	  1199: 	bra.s		dcx14
                            	  1200: dcx9:
00:00005B2A 0C010092        	  1201: 	cmpi.b	#$92,d1			; cursor down ?
00:00005B2E 6618            	  1202: 	bne.s		dcx10
00:00005B30 14390004008C    	  1203: 	move.b	TextRows,d2
00:00005B36 5302            	  1204: 	sub.b		#1,d2
00:00005B38 B43900040000    	  1205: 	cmp.b		CursorRow,d2
00:00005B3E 679A            	  1206: 	beq.s		dcx7
00:00005B40 523900040000    	  1207: 	addi.b	#1,CursorRow
00:00005B46 608E            	  1208: 	bra.s		dcx14
                            	  1209: dcx10:
00:00005B48 0C010094        	  1210: 	cmpi.b	#$94,d1			; cursor home ?
00:00005B4C 661C            	  1211: 	bne.s		dcx11
00:00005B4E 4A3900040001    	  1212: 	cmpi.b	#0,CursorCol
00:00005B54 670A            	  1213: 	beq.s		dcx12
00:00005B56 423900040001    	  1214: 	clr.b		CursorCol
00:00005B5C 6000FF78        	  1215: 	bra			dcx14
                            	  1216: dcx12:
00:00005B60 423900040000    	  1217: 	clr.b		CursorRow
00:00005B66 6000FF6E        	  1218: 	bra			dcx14
                            	  1219: dcx11:
00:00005B6A 48E7E080        	  1220: 	movem.l	d0/d1/d2/a0,-(a7)
00:00005B6E 0C010099        	  1221: 	cmpi.b	#$99,d1			; delete ?
00:00005B72 6750            	  1222: 	beq.s		doDelete
00:00005B74 0C010008        	  1223: 	cmpi.b	#CTRLH,d1			; backspace ?
00:00005B78 673C            	  1224: 	beq.s   doBackspace
00:00005B7A 0C010018        	  1225: 	cmpi.b	#CTRLX,d1			; delete line ?
00:00005B7E 677A            	  1226: 	beq			doCtrlX
00:00005B80 0C01000A        	  1227: 	cmpi.b	#10,d1		; linefeed ?
00:00005B84 671E            	  1228: 	beq.s		dclf
                            	  1229: 
                            	  1230: 	; regular char
00:00005B86 6100FF22        	  1231: 	bsr			CalcScreenLoc	; a0 = screen location
00:00005B8A 2401            	  1232: 	move.l	d1,d2					; d2 = char
00:00005B8C 6100FE82        	  1233: 	bsr			get_screen_color	; d0,d1 = color
                            	  1234: 	if (SCREEN_FORMAT==1)
00:00005B90 8081            	  1235: 		or.l d1,d0
00:00005B92 E158            	  1236: 		rol.w	#8,d0					; swap bytes
00:00005B94 4840            	  1237: 		swap d0							; swap halfs
00:00005B96 E158            	  1238: 		rol.w	#8,d0					; swap remaining bytes
00:00005B98 20C0            	  1239: 		move.l d0,(a0)+
                            	  1240: 	else
                            	  1241: 		or.l		d2,d1					; d1 = char + color
                            	  1242: 		rol.w		#8,d1					; text controller expects little endian data
                            	  1243: 		swap		d1
                            	  1244: 		rol.w		#8,d1
                            	  1245: 		move.l d1,(a0)+
                            	  1246: 		rol.w		#8,d0					; swap bytes
                            	  1247: 		swap		d0						; swap halfs
                            	  1248: 		rol.w		#8,d0					; swap remaining bytes
                            	  1249: 		move.l d0,(a0)+
                            	  1250: 	endif
00:00005B9A 61000082        	  1251: 	bsr	IncCursorPos
00:00005B9E 610001CC        	  1252: 	bsr	SyncCursor
00:00005BA2 6008            	  1253: 	bra	dcx4
                            	  1254: dclf:
00:00005BA4 61000098        	  1255: 	bsr			IncCursorRow
                            	  1256: dcx16:
00:00005BA8 610001C2        	  1257: 	bsr			SyncCursor
                            	  1258: dcx4:
00:00005BAC 4CDF0107        	  1259: 	movem.l	(a7)+,d0/d1/d2/a0		; get back a0
00:00005BB0 4CDF000E        	  1260: 	movem.l	(a7)+,d1/d2/d3
00:00005BB4 4E75            	  1261: 	rts
                            	  1262: 
                            	  1263: 	;---------------------------
                            	  1264: 	; CTRL-H: backspace
                            	  1265: 	;---------------------------
                            	  1266: doBackspace:
00:00005BB6 4A3900040001    	  1267: 	cmpi.b	#0,CursorCol		; if already at start of line
00:00005BBC 67EE            	  1268: 	beq.s   dcx4						; nothing to do
00:00005BBE 533900040001    	  1269: 	subi.b	#1,CursorCol		; decrement column
                            	  1270: 
                            	  1271: 	;---------------------------
                            	  1272: 	; Delete key
                            	  1273: 	;---------------------------
                            	  1274: doDelete:
00:00005BC4 48E7C080        	  1275: 	movem.l	d0/d1/a0,-(a7)	; save off screen location
00:00005BC8 6100FEE0        	  1276: 	bsr	CalcScreenLoc				; a0 = screen location
00:00005BCC 103900040001    	  1277: 	move.b CursorCol,d0
                            	  1278: .0001:
                            	  1279: 	if (SCREEN_FORMAT==1)
00:00005BD2 20A80004        	  1280: 		move.l 4(a0),(a0)				; pull remaining characters on line over 1
00:00005BD6 5888            	  1281: 		adda.l #4,a0
                            	  1282: 	else
                            	  1283: 		move.l 8(a0),(a0)				; pull remaining characters on line over 1
                            	  1284: 		move.l 12(a0),4(a0)
                            	  1285: 		adda.l #8,a0
                            	  1286: 	endif
00:00005BD8 5200            	  1287: 	addi.b #1,d0
00:00005BDA B0390004008D    	  1288: 	cmp.b	TextCols,d0
00:00005BE0 65F0            	  1289: 	blo.s	.0001
00:00005BE2 6100FE2C        	  1290: 	bsr	get_screen_color
                            	  1291: 	if (SCREEN_FORMAT==1)
00:00005BE6 303C0020        	  1292: 		move.w #' ',d0
00:00005BEA E158            	  1293: 		rol.w	#8,d0
00:00005BEC 4840            	  1294: 		swap d0
00:00005BEE E158            	  1295: 		rol.w	#8,d0
00:00005BF0 2140FFFC        	  1296: 		move.l d0,-4(a0)
                            	  1297: 	else
                            	  1298: 		move.w #' ',d1					; terminate line with a space
                            	  1299: 		rol.w	#8,d1
                            	  1300: 		swap d1
                            	  1301: 		rol.w	#8,d1
                            	  1302: 		move.l d1,-8(a0)
                            	  1303: 	endif
00:00005BF4 4CDF0103        	  1304: 	movem.l	(a7)+,d0/d1/a0
00:00005BF8 60AE            	  1305: 	bra.s		dcx16				; finished
                            	  1306: 
                            	  1307: 	;---------------------------
                            	  1308: 	; CTRL-X: erase line
                            	  1309: 	;---------------------------
                            	  1310: doCtrlX:
00:00005BFA 423900040001    	  1311: 	clr.b	CursorCol			; Reset cursor to start of line
00:00005C00 10390004008D    	  1312: 	move.b TextCols,d0	; and display TextCols number of spaces
00:00005C06 4880            	  1313: 	ext.w	d0
00:00005C08 48C0            	  1314: 	ext.l	d0
00:00005C0A 123C0020        	  1315: 	move.b #' ',d1			; d1 = space char
                            	  1316: .0001:
                            	  1317: 	; DisplayChar is called recursively here
                            	  1318: 	; It's safe to do because we know it won't recurse again due to the
                            	  1319: 	; fact we know the character being displayed is a space char
00:00005C0E 61002B7A        	  1320: 	bsr	OutputChar			
00:00005C12 5340            	  1321: 	subq #1,d0
00:00005C14 66F8            	  1322: 	bne.s	.0001
00:00005C16 423900040001    	  1323: 	clr.b	CursorCol			; now really go back to start of line
00:00005C1C 608A            	  1324: 	bra	dcx16						; we're done
                            	  1325: 
                            	  1326: ;------------------------------------------------------------------------------
                            	  1327: ; Increment the cursor position, scroll the screen if needed.
                            	  1328: ;------------------------------------------------------------------------------
                            	  1329: 
                            	  1330: IncCursorPos:
00:00005C1E 527900040002    	  1331: 	addi.w	#1,TextCurpos
00:00005C24 523900040001    	  1332: 	addi.b	#1,CursorCol
00:00005C2A 10390004008D    	  1333: 	move.b	TextCols,d0
00:00005C30 B03900040001    	  1334: 	cmp.b		CursorCol,d0
00:00005C36 6438            	  1335: 	bhs.s		icc1
00:00005C38 423900040001    	  1336: 	clr.b		CursorCol
                            	  1337: IncCursorRow:
00:00005C3E 523900040000    	  1338: 	addi.b	#1,CursorRow
00:00005C44 10390004008C    	  1339: 	move.b	TextRows,d0
00:00005C4A B03900040000    	  1340: 	cmp.b		CursorRow,d0
00:00005C50 621E            	  1341: 	bhi.s		icc1
00:00005C52 10390004008C    	  1342: 	move.b	TextRows,d0
00:00005C58 13C000040000    	  1343: 	move.b	d0,CursorRow		; in case CursorRow is way over
00:00005C5E 533900040000    	  1344: 	subi.b	#1,CursorRow
00:00005C64 4880            	  1345: 	ext.w		d0
00:00005C66 D040            	  1346: 	asl.w		#1,d0
00:00005C68 917900040002    	  1347: 	sub.w		d0,TextCurpos
00:00005C6E 6102            	  1348: 	bsr			ScrollUp
                            	  1349: icc1:
00:00005C70 4E75            	  1350: 	rts
                            	  1351: 
                            	  1352: ;------------------------------------------------------------------------------
                            	  1353: ; Scroll screen up.
                            	  1354: ;------------------------------------------------------------------------------
                            	  1355: 
                            	  1356: ScrollUp:
00:00005C72 48E7C084        	  1357: 	movem.l	d0/d1/a0/a5,-(a7)		; save off some regs
00:00005C76 4E7A0FE0        	  1358: 	movec	coreno,d0
00:00005C7A 4840            	  1359: 	swap d0	
00:00005C7C 7205            	  1360: 	moveq	#SCREEN_SEMA,d1
00:00005C7E 6100AB28        	  1361: 	bsr	LockSemaphore
00:00005C82 6100FD9E        	  1362: 	bsr	get_screen_address
00:00005C86 2A48            	  1363: 	move.l a0,a5								; a5 = pointer to text screen
                            	  1364: .0003:								
00:00005C88 10390004008D    	  1365: 	move.b TextCols,d0					; d0 = columns
00:00005C8E 12390004008C    	  1366: 	move.b TextRows,d1					; d1 = rows
00:00005C94 4880            	  1367: 	ext.w d0										;	make cols into a word value
00:00005C96 4881            	  1368: 	ext.w	d1										; make rows into a word value
                            	  1369: 	if (SCREEN_FORMAT==1)
00:00005C98 E540            	  1370: 		asl.w	#2,d0								; make into cell index
                            	  1371: 	else
                            	  1372: 		asl.w	#3,d0								; make into cell index
                            	  1373: 	endif
00:00005C9A 41F50000        	  1374: 	lea	0(a5,d0.w),a0						; a0 = pointer to second row of text screen
                            	  1375: 	if (SCREEN_FORMAT==1)
00:00005C9E E448            	  1376: 		lsr.w	#2,d0								; get back d0
                            	  1377: 	else
                            	  1378: 		lsr.w	#3,d0								; get back d0
                            	  1379: 	endif
00:00005CA0 5341            	  1380: 	subq #1,d1									; number of rows-1
00:00005CA2 C0C1            	  1381: 	mulu d1,d0									; d0 = count of characters to move
                            	  1382: 	if (SCREEN_FORMAT==1)
                            	  1383: 	else
                            	  1384: 		add.l d0,d0									; d0*2 2 longs per char
                            	  1385: 	endif
                            	  1386: .0001:
00:00005CA4 2AD8            	  1387: 	move.l (a0)+,(a5)+
00:00005CA6 51C8FFFC        	  1388: 	dbra d0,.0001
00:00005CAA 4E7A0FE0        	  1389: 	movec coreno,d0
00:00005CAE 4840            	  1390: 	swap d0	
00:00005CB0 7205            	  1391: 	moveq #SCREEN_SEMA,d1
00:00005CB2 6100AB30        	  1392: 	bsr UnlockSemaphore
00:00005CB6 4CDF2103        	  1393: 	movem.l (a7)+,d0/d1/a0/a5
                            	  1394: 	; Fall through into blanking out last line
                            	  1395: 
                            	  1396: ;------------------------------------------------------------------------------
                            	  1397: ; Blank out the last line on the screen.
                            	  1398: ;------------------------------------------------------------------------------
                            	  1399: 
                            	  1400: BlankLastLine:
00:00005CBA 48E7E080        	  1401: 	movem.l	d0/d1/d2/a0,-(a7)
00:00005CBE 4E7A0FE0        	  1402: 	movec	coreno,d0
00:00005CC2 4840            	  1403: 	swap d0	
00:00005CC4 7205            	  1404: 	moveq	#SCREEN_SEMA,d1
00:00005CC6 6100AAE0        	  1405: 	bsr	LockSemaphore
00:00005CCA 6100FD56        	  1406: 	bsr	get_screen_address
00:00005CCE 10390004008C    	  1407: 	move.b TextRows,d0					; d0 = rows
00:00005CD4 12390004008D    	  1408: 	move.b TextCols,d1					; d1 = columns
00:00005CDA 4880            	  1409: 	ext.w	d0
00:00005CDC 4881            	  1410: 	ext.w	d1
00:00005CDE 5340            	  1411: 	subq #1,d0									; last row = #rows-1
00:00005CE0 C0C1            	  1412: 	mulu d1,d0									; d0 = index of last line
                            	  1413: 	if (SCREEN_FORMAT==1)
00:00005CE2 E548            	  1414: 		lsl.w	#2,d0								; *4 bytes per char
                            	  1415: 	else
                            	  1416: 		lsl.w	#3,d0								; *8 bytes per char
                            	  1417: 	endif
00:00005CE4 41F00000        	  1418: 	lea	(a0,d0.w),a0						; point a0 to last row
00:00005CE8 14390004008D    	  1419: 	move.b TextCols,d2					; number of text cells to clear
00:00005CEE 4882            	  1420: 	ext.w	d2
00:00005CF0 5342            	  1421: 	subi.w #1,d2								; count must be one less than desired
00:00005CF2 6100FD1C        	  1422: 	bsr	get_screen_color				; d0,d1 = screen color
                            	  1423: 	if (SCREEN_FORMAT==1)
00:00005CF6 103C0020        	  1424: 		move.b #32,d0
                            	  1425: 	else
                            	  1426: 		move.b #32,d1								; set the character for display in low 16 bits
                            	  1427: 		bsr	rbo											; reverse the byte order
                            	  1428: 	endif
00:00005CFA E158            	  1429: 	rol.w	#8,d0
00:00005CFC 4840            	  1430: 	swap d0
00:00005CFE E158            	  1431: 	rol.w	#8,d0
                            	  1432: .0001:
                            	  1433: 	if (SCREEN_FORMAT==1)
00:00005D00 20C0            	  1434: 		move.l d0,(a0)+
                            	  1435: 	else
                            	  1436: 		move.l d0,(a0)+
                            	  1437: 		move.l d1,(a0)+
                            	  1438: 	endif
00:00005D02 51CAFFFC        	  1439: 	dbra d2,.0001
00:00005D06 4E7A0FE0        	  1440: 	movec	coreno,d0
00:00005D0A 4840            	  1441: 	swap d0	
00:00005D0C 7205            	  1442: 	moveq #SCREEN_SEMA,d1
00:00005D0E 6100AAD4        	  1443: 	bsr UnlockSemaphore
00:00005D12 4CDF0107        	  1444: 	movem.l	(a7)+,d0/d1/d2/a0
00:00005D16 4E75            	  1445: 	rts
                            	  1446: 
                            	  1447: ;------------------------------------------------------------------------------
                            	  1448: ; Display a string on standard output.
                            	  1449: ;------------------------------------------------------------------------------
                            	  1450: 
                            	  1451: DisplayString:
00:00005D18 48E7C040        	  1452: 	movem.l	d0/d1/a1,-(a7)
                            	  1453: dspj1:
00:00005D1C 7200            	  1454: 	clr.l d1							; clear upper bits of d1
00:00005D1E 1219            	  1455: 	move.b (a1)+,d1				; move string char into d1
00:00005D20 6706            	  1456: 	beq.s dsret						; is it end of string ?
00:00005D22 7006            	  1457: 	moveq #6,d0						; output character function
00:00005D24 4E4F            	  1458: 	trap #15
00:00005D26 60F4            	  1459: 	bra.s	dspj1						; go back for next character
                            	  1460: dsret:
00:00005D28 4CDF0203        	  1461: 	movem.l	(a7)+,d0/d1/a1
00:00005D2C 4E75            	  1462: 	rts
                            	  1463: 
                            	  1464: ;------------------------------------------------------------------------------
                            	  1465: ; Display a string on the screen followed by carriage return / linefeed.
                            	  1466: ;------------------------------------------------------------------------------
                            	  1467: 
                            	  1468: DisplayStringCRLF:
00:00005D2E 61E8            	  1469: 	bsr		DisplayString
00:00005D30 6000FD34        	  1470: 	bra		CRLF
                            	  1471: 
                            	  1472: ;------------------------------------------------------------------------------
                            	  1473: ; Display a string on the screen limited to 255 chars max.
                            	  1474: ;------------------------------------------------------------------------------
                            	  1475: 
                            	  1476: DisplayStringLimited:
00:00005D34 48E7E040        	  1477: 	movem.l	d0/d1/d2/a1,-(a7)
00:00005D38 3401            	  1478: 	move.w	d1,d2					; d2 = max count
00:00005D3A 024200FF        	  1479: 	andi.w	#$00FF,d2			; limit to 255 chars
00:00005D3E 600A            	  1480: 	bra.s		.0003					; enter loop at bottom
                            	  1481: .0001:
00:00005D40 7200            	  1482: 	clr.l d1							; clear upper bits of d1
00:00005D42 1219            	  1483: 	move.b (a1)+,d1				; move string char into d1
00:00005D44 6708            	  1484: 	beq.s .0002						; is it end of string ?
00:00005D46 7006            	  1485: 	moveq #6,d0						; output character function
00:00005D48 4E4F            	  1486: 	trap #15
                            	  1487: .0003:
00:00005D4A 51CAFFF4        	  1488: 	dbra		d2,.0001			; go back for next character
                            	  1489: .0002:
00:00005D4E 4CDF0207        	  1490: 	movem.l	(a7)+,d0/d1/d2/a1
00:00005D52 4E75            	  1491: 	rts
                            	  1492: 
                            	  1493: DisplayStringLimitedCRLF:
00:00005D54 61DE            	  1494: 	bsr		DisplayStringLimited
00:00005D56 6000FD0E        	  1495: 	bra		CRLF
                            	  1496: 	
                            	  1497: ;------------------------------------------------------------------------------
                            	  1498: ; Set cursor position to top left of screen.
                            	  1499: ;
                            	  1500: ; Parameters:
                            	  1501: ;		<none>
                            	  1502: ; Returns:
                            	  1503: ;		<none>
                            	  1504: ; Registers Affected:
                            	  1505: ;		<none>
                            	  1506: ;------------------------------------------------------------------------------
                            	  1507: 
                            	  1508: HomeCursor:
00:00005D5A 423900040000    	  1509: 	clr.b		CursorRow
00:00005D60 423900040001    	  1510: 	clr.b		CursorCol
00:00005D66 427900040002    	  1511: 	clr.w		TextPos
                            	  1512: 	; fall through
                            	  1513: 
                            	  1514: ;------------------------------------------------------------------------------
                            	  1515: ; SyncCursor:
                            	  1516: ;
                            	  1517: ; Sync the hardware cursor's position to the text cursor position but only for
                            	  1518: ; the core with the IO focus.
                            	  1519: ;
                            	  1520: ; Parameters:
                            	  1521: ;		<none>
                            	  1522: ; Returns:
                            	  1523: ;		<none>
                            	  1524: ; Registers Affected:
                            	  1525: ;		<none>
                            	  1526: ;------------------------------------------------------------------------------
                            	  1527: 
                            	  1528: SyncCursor:
00:00005D6C 48E7E080        	  1529: 	movem.l	d0/d1/d2/a0,-(a7)
00:00005D70 6100FD0E        	  1530: 	bsr	UpdateTextPos
00:00005D74 7200            	  1531: 	clr.l d1
00:00005D76 3200            	  1532: 	move.w d0,d1
00:00005D78 4E7A2FE0        	  1533: 	movec	coreno,d2
00:00005D7C B43900100000    	  1534: 	cmp.b	IOFocus,d2
00:00005D82 6616            	  1535: 	bne.s .0001
00:00005D84 5542            	  1536: 	subi.w #2,d2				; factor in location of screen in controller
00:00005D86 C4FC0800        	  1537: 	mulu #2048,d2				; 2048 cells per screen
00:00005D8A D282            	  1538: 	add.l	d2,d1
00:00005D8C E159            	  1539: 	rol.w	#8,d1					; swap byte order
00:00005D8E 4841            	  1540: 	swap d1
00:00005D90 E159            	  1541: 	rol.w #8,d1
00:00005D92 41F9FD080024    	  1542: 	lea TEXTREG+$24,a0
00:00005D98 2081            	  1543: 	move.l d1,(a0)
                            	  1544: .0001:	
00:00005D9A 4CDF0107        	  1545: 	movem.l	(a7)+,a0/d0/d1/d2
00:00005D9E 4E75            	  1546: 	rts
                            	  1547: 
                            	  1548: ;==============================================================================
                            	  1549: ; TRAP #15 handler
                            	  1550: ;
                            	  1551: ; Parameters:
                            	  1552: ;		d0.w = function number to perform
                            	  1553: ;==============================================================================
                            	  1554: 
                            	  1555: TRAP15:
00:00005DA0 48E78080        	  1556: 	movem.l	d0/a0,-(a7)
00:00005DA4 41FA0012        	  1557: 	lea T15DispatchTable,a0
00:00005DA8 E580            	  1558: 	asl.l #2,d0
00:00005DAA 20700000        	  1559: 	move.l (a0,d0.w),a0
00:00005DAE 4E90            	  1560: 	jsr (a0)
00:00005DB0 4CDF0101        	  1561: 	movem.l (a7)+,d0/a0
00:00005DB4 4E73            	  1562: 	rte
                            	  1563: 
                            	  1564: 		align	2
                            	  1565: T15DispatchTable:
00:00005DB8 00005D54        	  1566: 	dc.l	DisplayStringLimitedCRLF
00:00005DBC 00005D34        	  1567: 	dc.l	DisplayStringLimited
00:00005DC0 000062C2        	  1568: 	dc.l	StubRout
00:00005DC4 000062C2        	  1569: 	dc.l	StubRout
00:00005DC8 000062C2        	  1570: 	dc.l	StubRout
00:00005DCC 00006638        	  1571: 	dc.l	GetKey
00:00005DD0 0000878A        	  1572: 	dc.l	OutputChar
00:00005DD4 0000662C        	  1573: 	dc.l	CheckForKey
00:00005DD8 00005F58        	  1574: 	dc.l	GetTick
00:00005DDC 000062C2        	  1575: 	dc.l	StubRout
                            	  1576: 	; 10
00:00005DE0 000062C2        	  1577: 	dc.l	StubRout
00:00005DE4 0000628A        	  1578: 	dc.l	Cursor1
00:00005DE8 00006624        	  1579: 	dc.l	SetKeyboardEcho
00:00005DEC 00005D2E        	  1580: 	dc.l	DisplayStringCRLF
00:00005DF0 00005D18        	  1581: 	dc.l	DisplayString
00:00005DF4 000062C2        	  1582: 	dc.l	StubRout
00:00005DF8 000062C2        	  1583: 	dc.l	StubRout
00:00005DFC 000062C2        	  1584: 	dc.l	StubRout
00:00005E00 000062C2        	  1585: 	dc.l	StubRout
00:00005E04 0000662C        	  1586: 	dc.l	CheckForKey
                            	  1587: 	; 20
00:00005E08 000062C2        	  1588: 	dc.l	StubRout
00:00005E0C 000062C2        	  1589: 	dc.l	StubRout
00:00005E10 000062C2        	  1590: 	dc.l	StubRout
00:00005E14 000062C2        	  1591: 	dc.l	StubRout
00:00005E18 000062C2        	  1592: 	dc.l	StubRout
00:00005E1C 000062C2        	  1593: 	dc.l	StubRout
00:00005E20 000062C2        	  1594: 	dc.l	StubRout
00:00005E24 000062C2        	  1595: 	dc.l	StubRout
00:00005E28 000062C2        	  1596: 	dc.l	StubRout
00:00005E2C 000062C2        	  1597: 	dc.l	StubRout
                            	  1598: 	; 30
00:00005E30 000062C2        	  1599: 	dc.l	StubRout
00:00005E34 000062C2        	  1600: 	dc.l	StubRout
00:00005E38 00005F48        	  1601: 	dc.l	SimHardware	;rotate_iofocus
00:00005E3C 0000818A        	  1602: 	dc.l	SerialPeekCharDirect
00:00005E40 000081A4        	  1603: 	dc.l	SerialPutChar
00:00005E44 0000814E        	  1604: 	dc.l	SerialPeekChar
00:00005E48 000080D6        	  1605: 	dc.l	SerialGetChar
00:00005E4C 00000800        	  1606: 	dc.l	T15LockSemaphore
00:00005E50 00000806        	  1607: 	dc.l	T15UnlockSemaphore
00:00005E54 000086E8        	  1608: 	dc.l	prtflt
                            	  1609: 	; 40
00:00005E58 0000074A        	  1610: 	dc.l  _GetRand
00:00005E5C 0000080C        	  1611: 	dc.l	T15GetFloat
00:00005E60 0000081A        	  1612: 	dc.l	T15Abort
00:00005E64 0000872E        	  1613: 	dc.l	T15FloatToString
00:00005E68 000062C2        	  1614: 	dc.l	StubRout
00:00005E6C 000062C2        	  1615: 	dc.l	StubRout
00:00005E70 000062C2        	  1616: 	dc.l	StubRout
00:00005E74 000062C2        	  1617: 	dc.l	StubRout
00:00005E78 000062C2        	  1618: 	dc.l	StubRout
00:00005E7C 000062C2        	  1619: 	dc.l	StubRout
                            	  1620: 	; 50
00:00005E80 000062C2        	  1621: 	dc.l	StubRout
00:00005E84 000062C2        	  1622: 	dc.l	StubRout
00:00005E88 000062C2        	  1623: 	dc.l	StubRout
00:00005E8C 000062C2        	  1624: 	dc.l	StubRout
00:00005E90 000062C2        	  1625: 	dc.l	StubRout
00:00005E94 000062C2        	  1626: 	dc.l	StubRout
00:00005E98 000062C2        	  1627: 	dc.l	StubRout
00:00005E9C 000062C2        	  1628: 	dc.l	StubRout
00:00005EA0 000062C2        	  1629: 	dc.l	StubRout
00:00005EA4 000062C2        	  1630: 	dc.l	StubRout
                            	  1631: 	; 60
00:00005EA8 000062C2        	  1632: 	dc.l	StubRout
00:00005EAC 000062C2        	  1633: 	dc.l	StubRout
00:00005EB0 000062C2        	  1634: 	dc.l	StubRout
00:00005EB4 000062C2        	  1635: 	dc.l	StubRout
00:00005EB8 000062C2        	  1636: 	dc.l	StubRout
00:00005EBC 000062C2        	  1637: 	dc.l	StubRout
00:00005EC0 000062C2        	  1638: 	dc.l	StubRout
00:00005EC4 000062C2        	  1639: 	dc.l	StubRout
00:00005EC8 000062C2        	  1640: 	dc.l	StubRout
00:00005ECC 000062C2        	  1641: 	dc.l	StubRout
                            	  1642: 	; 70
00:00005ED0 000062C2        	  1643: 	dc.l	StubRout
00:00005ED4 000062C2        	  1644: 	dc.l	StubRout
00:00005ED8 000062C2        	  1645: 	dc.l	StubRout
00:00005EDC 000062C2        	  1646: 	dc.l	StubRout
00:00005EE0 000062C2        	  1647: 	dc.l	StubRout
00:00005EE4 000062C2        	  1648: 	dc.l	StubRout
00:00005EE8 000062C2        	  1649: 	dc.l	StubRout
00:00005EEC 000062C2        	  1650: 	dc.l	StubRout
00:00005EF0 000062C2        	  1651: 	dc.l	StubRout
00:00005EF4 000062C2        	  1652: 	dc.l	StubRout
                            	  1653: 	; 80
00:00005EF8 00005F82        	  1654: 	dc.l	SetPenColor
00:00005EFC 000062C2        	  1655: 	dc.l	StubRout
00:00005F00 000062C2        	  1656: 	dc.l	StubRout
00:00005F04 000062C2        	  1657: 	dc.l	StubRout
00:00005F08 000062C2        	  1658: 	dc.l	StubRout
00:00005F0C 000061AC        	  1659: 	dc.l	DrawToXY
00:00005F10 0000619E        	  1660: 	dc.l	MoveToXY
00:00005F14 000062C2        	  1661: 	dc.l	StubRout
00:00005F18 000062C2        	  1662: 	dc.l	StubRout
00:00005F1C 000062C2        	  1663: 	dc.l	StubRout
                            	  1664: 	; 90
00:00005F20 000062C2        	  1665: 	dc.l	StubRout
00:00005F24 000062C2        	  1666: 	dc.l	StubRout
00:00005F28 00005F60        	  1667: 	dc.l	SetDrawMode
00:00005F2C 000062C2        	  1668: 	dc.l	StubRout
00:00005F30 00005F8A        	  1669: 	dc.l	GRBufferToScreen
00:00005F34 000062C2        	  1670: 	dc.l	StubRout
00:00005F38 000062C2        	  1671: 	dc.l	StubRout
00:00005F3C 000062C2        	  1672: 	dc.l	StubRout
00:00005F40 000062C2        	  1673: 	dc.l	StubRout
00:00005F44 000062C2        	  1674: 	dc.l	StubRout
                            	  1675: 
                            	  1676: ;------------------------------------------------------------------------------
                            	  1677: 
                            	  1678: SimHardware:
00:00005F48 0C410003        	  1679: 	cmpi.w #3,d1
00:00005F4C 6608            	  1680: 	bne.s .0001
00:00005F4E 223C000408B8    	  1681: 	move.l #sys_switches,d1
00:00005F54 4E75            	  1682: 	rts
                            	  1683: .0001:
00:00005F56 4E75            	  1684: 	rts
                            	  1685: 
                            	  1686: ;------------------------------------------------------------------------------
                            	  1687: ;
                            	  1688: GetTick:
00:00005F58 22390004009C    	  1689: 	move.l tickcnt,d1
00:00005F5E 4E75            	  1690: 	rts
                            	  1691: 
                            	  1692: ;------------------------------------------------------------------------------
                            	  1693: ;
                            	  1694: SetDrawMode:
00:00005F60 0C41000A        	  1695: 	cmpi.w #10,d1
00:00005F64 660A            	  1696: 	bne.s .0001
00:00005F66 13FC0005000408A8	  1697: 	move.b #5,gr_raster_op			; 'OR' operation
00:00005F6E 4E75            	  1698: 	rts
                            	  1699: .0001:
00:00005F70 0C410011        	  1700: 	cmpi.w #17,d1
00:00005F74 660A            	  1701: 	bne.s .0002
00:00005F76 33FC0001000408AC	  1702: 	move.w #1,gr_double_buffer
00:00005F7E 4E75            	  1703: 	rts
                            	  1704: .0002:
00:00005F80 4E75            	  1705: 	rts
                            	  1706: 	
                            	  1707: SetPenColor:
00:00005F82 23C100040890    	  1708: 	move.l d1,pen_color
00:00005F88 4E75            	  1709: 	rts
                            	  1710: 
                            	  1711: ;------------------------------------------------------------------------------
                            	  1712: ; Page flip between two buffers.
                            	  1713: ;------------------------------------------------------------------------------
                            	  1714: 
                            	  1715: GRBufferToScreen:
00:00005F8A 48E700C0        	  1716: 	movem.l a0/a1,-(a7)
00:00005F8E 0A390001FD200003	  1717: 	eor.b #1,FRAMEBUF+3					; page flip
00:00005F96 2279000408B0    	  1718: 	move.l gr_bitmap_buffer,a1
00:00005F9C 2079000408A4    	  1719: 	move.l gr_bitmap_screen,a0
00:00005FA2 23C8000408B0    	  1720: 	move.l a0,gr_bitmap_buffer
00:00005FA8 23C9000408A4    	  1721: 	move.l a1,gr_bitmap_screen
00:00005FAE 205F225F        	  1722: 	movem.l (a7)+,a0/a1
00:00005FB2 4E75            	  1723: 	rts
                            	  1724: 
                            	  1725: ; The following copies the buffer, why? Not needed if page flipping.
                            	  1726: ;	movem.l d0/a0/a1,-(a7)
                            	  1727: ;	move.l gr_bitmap_buffer,a1
                            	  1728: ;	move.l gr_bitmap_screen,a0
                            	  1729: ;	move.w gr_width,d0
                            	  1730: ;	mulu gr_height,d0
                            	  1731: ;	lsr.l #4,d0							; moving 16 pixels per iteration
                            	  1732: ;	move.l #0,$BFFFFFF8			; set burst length zero
                            	  1733: ;	bra.s .loop
                            	  1734: ;.loop2:
                            	  1735: ;	swap d0
                            	  1736: ;.loop:
                            	  1737: ;	move.l a1,$BFFFFFF0			; set source address
                            	  1738: ;	tst.l $BFFFFFFC					; do a read op, no value needed
                            	  1739: ;	move.l a0,$BFFFFFF4			; set destination address
                            	  1740: ;	move.l d0,$BFFFFFFC			; do a write operation (any value)
                            	  1741: ;	dbra d0,.loop
                            	  1742: ;	swap d0									; might go over 32/64 kB
                            	  1743: ;	dbra d0,.loop2
                            	  1744: ;	movem.l (a7)+,d0/a0/a1
                            	  1745: ;	rts
                            	  1746: 
                            	  1747: ; Write the first eight pixels with the pen color.
                            	  1748: ; Load the pixel buffer with the eight pixels.
                            	  1749: 
                            	  1750: clear_bitmap_screen4:
00:00005FB4 48E7C080        	  1751: 	movem.l d0/d1/a0,-(a7)
00:00005FB8 2079000408B0    	  1752: 	move.l gr_bitmap_buffer,a0
00:00005FBE 303900040890    	  1753: 	move.w pen_color,d0
00:00005FC4 4840            	  1754: 	swap d0
00:00005FC6 303900040890    	  1755: 	move.w pen_color,d0
00:00005FCC 323C0008        	  1756: 	move.w #8,d1
                            	  1757: .loop3:
00:00005FD0 20C0            	  1758: 	move.l d0,(a0)+
00:00005FD2 51C9FFFC        	  1759: 	dbra d1,.loop3
00:00005FD6 2079000408B0    	  1760: 	move.l gr_bitmap_buffer,a0
00:00005FDC 23C8BFFFFFF0    	  1761: 	move.l a0,$BFFFFFF0			; load data hold with eight pixels
00:00005FE2 42B9BFFFFFF8    	  1762: 	move.l #0,$BFFFFFF8			; set burst length zero
00:00005FE8 4AB9BFFFFFFC    	  1763: 	tst.l $BFFFFFFC					; load up the values (read)
00:00005FEE 30390004089C    	  1764: 	move.w gr_width,d0
00:00005FF4 C0F9000408A0    	  1765: 	mulu gr_height,d0
00:00005FFA E888            	  1766: 	lsr.l #4,d0							; moving 16 pixels per iteration
00:00005FFC 6002            	  1767: 	bra.s .loop
                            	  1768: .loop2:
00:00005FFE 4840            	  1769: 	swap d0
                            	  1770: .loop:
00:00006000 23C8BFFFFFF4    	  1771: 	move.l a0,$BFFFFFF4			; set destination address
00:00006006 23C0BFFFFFFC    	  1772: 	move.l d0,$BFFFFFFC			; write any value
00:0000600C 41E80020        	  1773: 	add.l #32,a0						; advance pointer
00:00006010 51C8FFEE        	  1774: 	dbra d0,.loop
00:00006014 4840            	  1775: 	swap d0
00:00006016 51C8FFE6        	  1776: 	dbra d0,.loop2
00:0000601A 4CDF0103        	  1777: 	movem.l (a7)+,d0/d1/a0
00:0000601E 4E75            	  1778: 	rts
                            	  1779: 
                            	  1780: ; The following code using bursts of 1k pixels did not work (hardware).
                            	  1781: ;
                            	  1782: ;clear_bitmap_screen2:
                            	  1783: ;	move.l gr_bitmap_screen,a0
                            	  1784: ;clear_bitmap_screen3:
                            	  1785: ;	movem.l d0/d2/a0,-(a7)
                            	  1786: ;	move.l #$3F3F3F3F,$BFFFFFF4	; 32x64 byte burst
                            	  1787: ;	move.w pen_color,d0
                            	  1788: ;	swap d0
                            	  1789: ;	move.w pen_color,d0
                            	  1790: ;	move.w gr_width,d2		; calc. number of pixels on screen
                            	  1791: ;	mulu gr_height,d2
                            	  1792: ;	add.l #1023,d2				; rounding up
                            	  1793: ;	lsr.l #8,d2						; divide by 1024 pixel update
                            	  1794: ;	lsr.l #2,d2
                            	  1795: ;.0001:
                            	  1796: ;	move.l a0,$BFFFFFF8		; write update address
                            	  1797: ;	add.l #2048,a0				; update pointer
                            	  1798: ;	move.l d0,$BFFFFFFC		; trigger burst write of 2048 bytes
                            	  1799: ;	dbra d2,.0001
                            	  1800: ;	movem.l (a7)+,d0/d2/a0
                            	  1801: ;	rts
                            	  1802: 
                            	  1803: ; More conventional but slow way of clearing the screen.
                            	  1804: ;
                            	  1805: ;clear_bitmap_screen:
                            	  1806: ;	move.l gr_bitmap_screen,a0
                            	  1807: ;clear_bitmap_screen1:
                            	  1808: ;	movem.l d0/d2/a0,-(a7)
                            	  1809: ;	move.w pen_color,d0
                            	  1810: ;	swap d0
                            	  1811: ;	move.w pen_color,d0
                            	  1812: ;	move.w gr_width,d2		; calc. number of pixels on screen
                            	  1813: ;	mulu gr_height,d2			; 800x600 = 480000
                            	  1814: ;	bra.s .0001
                            	  1815: ;.0002:
                            	  1816: ;	swap d2
                            	  1817: ;.0001:
                            	  1818: ;	move.l d0,(a0)+
                            	  1819: ;	dbra d2,.0001
                            	  1820: ;	swap d2
                            	  1821: ;	dbra d2,.0002
                            	  1822: ;	movem.l (a7)+,d0/d2/a0
                            	  1823: ;	rts
                            	  1824: 
                            	  1825: TestBitmap:
00:00006020 6192            	  1826: 	bsr clear_bitmap_screen4
00:00006022 705E            	  1827: 	moveq #94,d0							; page flip (display blank screen)
00:00006024 4E4F            	  1828: 	trap #15
00:00006026 33FC007C00040890	  1829: 	move.w #$007c,pen_color		; red pen
00:0000602E 42B900040894    	  1830: 	clr.l gr_x
                            	  1831: ;	clr.l gr_y
00:00006034 23FC000000010004	  1832: 	move.l #1,gr_y
00:0000603C 0898
00:0000603E 263C0000031F    	  1833: 	move.l #799,d3
00:00006044 7801            	  1834: 	move.l #1,d4
00:00006046 610001E2        	  1835: 	bsr DrawHorizTo
00:0000604A 42B900040894    	  1836: 	clr.l gr_x
00:00006050 42B900040898    	  1837: 	clr.l gr_y
00:00006056 7600            	  1838: 	move.l #0,d3
00:00006058 283C00000257    	  1839: 	move.l #599,d4
00:0000605E 610001FA        	  1840: 	bsr DrawVertTo
00:00006062 33FCE00100040890	  1841: 	move.w #$E001,pen_color		; green pen
00:0000606A 23FC000000020004	  1842: 	move.l #2,gr_x
00:00006072 0894
00:00006074 42B900040898    	  1843: 	clr.l gr_y
00:0000607A 7602            	  1844: 	move.l #2,d3
00:0000607C 283C00000257    	  1845: 	move.l #599,d4
00:00006082 610001D6        	  1846: 	bsr DrawVertTo
00:00006086 42B900040894    	  1847: 	clr.l gr_x
00:0000608C 42B900040898    	  1848: 	clr.l gr_y
00:00006092 263C0000031F    	  1849: 	move.l #799,d3
00:00006098 283C00000257    	  1850: 	move.l #599,d4
00:0000609E 6100010C        	  1851: 	bsr DrawToXY
00:000060A2 705E            	  1852: 	moveq #94,d0							; page flip again
00:000060A4 4E4F            	  1853: 	trap #15
00:000060A6 60000D04        	  1854: 	bra Monitor
                            	  1855: 
                            	  1856: ;------------------------------------------------------------------------------
                            	  1857: ; Plot on bitmap screen using current pen color.
                            	  1858: ;
                            	  1859: ;	Parameters:
                            	  1860: ;		d1 = x co-ordinate
                            	  1861: ;		d2 = y co-ordinate
                            	  1862: ;------------------------------------------------------------------------------
                            	  1863: 	
                            	  1864: ;parameter OPBLACK = 4'd0;
                            	  1865: ;parameter OPCOPY = 4'd1;
                            	  1866: ;parameter OPINV = 4'd2;
                            	  1867: ;parameter OPAND = 4'd4;
                            	  1868: ;parameter OPOR = 4'd5;
                            	  1869: ;parameter OPXOR = 4'd6;
                            	  1870: ;parameter OPANDN = 4'd7;
                            	  1871: ;parameter OPNAND = 4'd8;
                            	  1872: ;parameter OPNOR = 4'd9;
                            	  1873: ;parameter OPXNOR = 4'd10;
                            	  1874: ;parameter OPORN = 4'd11;
                            	  1875: ;parameter OPWHITE = 4'd15;
                            	  1876: 
                            	  1877: ;---------------------------------------------------------------------
                            	  1878: ; The following uses point plot hardware built into the frame buffer.
                            	  1879: ;---------------------------------------------------------------------
                            	  1880: 
                            	  1881: plot:
00:000060AA 2F08            	  1882: 	move.l a0,-(a7)
00:000060AC 207CFD200000    	  1883: 	move.l #FRAMEBUF,a0
                            	  1884: .0001:
00:000060B2 4A280028        	  1885: 	tst.b 40(a0)									; wait for any previous command to finish
00:000060B6 66FA            	  1886: 	bne.s .0001										; Then set:
00:000060B8 31410020        	  1887: 	move.w d1,32(a0)							; pixel x co-ord
00:000060BC 31420022        	  1888: 	move.w d2,34(a0)							; pixel y co-ord
00:000060C0 317900040890002C	  1889: 	move.w pen_color,44(a0)				; pixel color
00:000060C8 1179000408A80029	  1890: 	move.b gr_raster_op,41(a0)		; set raster operation
00:000060D0 117C00020028    	  1891: 	move.b #2,40(a0)							; point plot command
00:000060D6 205F            	  1892: 	move.l (a7)+,a0
00:000060D8 4E75            	  1893: 	rts
                            	  1894: 
                            	  1895: ;-------------------------------------------
                            	  1896: ; In case of lacking hardware plot
                            	  1897: ;-------------------------------------------
                            	  1898: 	align 2
                            	  1899: plottbl:
00:000060DC 00006188        	  1900: 	dc.l plot_black
00:000060E0 0000617A        	  1901: 	dc.l plot_copy
00:000060E4 0000617A        	  1902: 	dc.l plot_copy
00:000060E8 00006166        	  1903: 	dc.l plot_and
00:000060EC 0000613C        	  1904: 	dc.l plot_or
00:000060F0 00006150        	  1905: 	dc.l plot_xor
00:000060F4 0000617A        	  1906: 	dc.l plot_copy
00:000060F8 0000617A        	  1907: 	dc.l plot_copy
00:000060FC 0000617A        	  1908: 	dc.l plot_copy
00:00006100 0000617A        	  1909: 	dc.l plot_copy
00:00006104 0000617A        	  1910: 	dc.l plot_copy
00:00006108 0000617A        	  1911: 	dc.l plot_copy
00:0000610C 0000617A        	  1912: 	dc.l plot_copy
00:00006110 0000617A        	  1913: 	dc.l plot_copy
00:00006114 00006192        	  1914: 	dc.l plot_white
                            	  1915: 
                            	  1916: plot_sw:
00:00006118 48E778C0        	  1917: 	movem.l d1/d2/d3/d4/a0/a1,-(a7)
00:0000611C C4F90004089C    	  1918: 	mulu gr_width,d2							; multiply y by screen width
                            	  1919: ;	move.l d1,d3
                            	  1920: ;	andi.l #30,d3
                            	  1921: ;	moveq #30,d4
                            	  1922: ;	sub.l d4,d3
                            	  1923: ;	andi.l #$FFFFFFE0,d1
                            	  1924: ;	or.l d3,d1
00:00006122 48C1            	  1925: 	ext.l d1											; clear high-order word of x
00:00006124 D481            	  1926: 	add.l d1,d2										; add in x co-ord
00:00006126 D482            	  1927: 	add.l d2,d2										; *2 for 16 BPP
00:00006128 2079000408B0    	  1928: 	move.l gr_bitmap_buffer,a0		; where the draw occurs
00:0000612E 3639000408A8    	  1929: 	move.w gr_raster_op,d3
00:00006134 E54B            	  1930: 	lsl.w #2,d3
00:00006136 227B30A4        	  1931: 	move.l plottbl(pc,d3.w),a1
00:0000613A 4ED1            	  1932: 	jmp (a1)
                            	  1933: plot_or:
00:0000613C 38302800        	  1934: 	move.w (a0,d2.l),d4	
00:00006140 887900040890    	  1935: 	or.w pen_color,d4
00:00006146 31842800        	  1936: 	move.w d4,(a0,d2.l)
00:0000614A 4CDF031E        	  1937: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:0000614E 4E75            	  1938: 	rts
                            	  1939: plot_xor:
00:00006150 38302800        	  1940: 	move.w (a0,d2.l),d4
00:00006154 363900040890    	  1941: 	move.w pen_color,d3	
00:0000615A B744            	  1942: 	eor.w d3,d4
00:0000615C 31842800        	  1943: 	move.w d4,(a0,d2.l)
00:00006160 4CDF031E        	  1944: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00006164 4E75            	  1945: 	rts
                            	  1946: plot_and:
00:00006166 38302800        	  1947: 	move.w (a0,d2.l),d4	
00:0000616A C87900040890    	  1948: 	and.w pen_color,d4
00:00006170 31842800        	  1949: 	move.w d4,(a0,d2.l)
00:00006174 4CDF031E        	  1950: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00006178 4E75            	  1951: 	rts
                            	  1952: plot_copy:
00:0000617A 31B9000408902800	  1953: 	move.w pen_color,(a0,d2.l)
00:00006182 4CDF031E        	  1954: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00006186 4E75            	  1955: 	rts
                            	  1956: plot_black:
00:00006188 42702800        	  1957: 	clr.w (a0,d2.l)
00:0000618C 4CDF031E        	  1958: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00006190 4E75            	  1959: 	rts
                            	  1960: plot_white:
00:00006192 31BCFF7F2800    	  1961: 	move.w #$FF7F,(a0,d2.l)
00:00006198 4CDF031E        	  1962: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:0000619C 4E75            	  1963: 	rts
                            	  1964: 
                            	  1965: ;------------------------------------------------------------------------------
                            	  1966: ; Set graphics cursor position.
                            	  1967: ;------------------------------------------------------------------------------
                            	  1968: 
                            	  1969: MoveToXY:
00:0000619E 23C300040894    	  1970: 	move.l d3,gr_x
00:000061A4 23C400040898    	  1971: 	move.l d4,gr_y
00:000061AA 4E75            	  1972: 	rts
                            	  1973: 
                            	  1974: ;------------------------------------------------------------------------------
                            	  1975: ; Draw a line from the current graphics position to x1,y1.
                            	  1976: ;
                            	  1977: ; Register Usage:
                            	  1978: ;		d1 = x0
                            	  1979: ;		d2 = y0
                            	  1980: ;		d3 = x1
                            	  1981: ;		d4 = y1
                            	  1982: ;		d5 = dx
                            	  1983: ;		d6 = dy
                            	  1984: ;		d7 = sx
                            	  1985: ;		d0 = sy
                            	  1986: ;		a0 = err
                            	  1987: ;		a1 = 2*err
                            	  1988: ;------------------------------------------------------------------------------
                            	  1989: 
                            	  1990: DrawToXY:
00:000061AC 48E7E7C0        	  1991: 	movem.l d0/d1/d2/d5/d6/d7/a0/a1,-(a7)
00:000061B0 223900040894    	  1992: 	move.l gr_x,d1
00:000061B6 243900040898    	  1993: 	move.l gr_y,d2
00:000061BC 2A03            	  1994: 	move.l d3,d5
00:000061BE 2C04            	  1995: 	move.l d4,d6
00:000061C0 9A81            	  1996: 	sub.l d1,d5			; d5 = x1-x0
00:000061C2 6608            	  1997: 	bne.s .notVert
00:000061C4 4CDF03E7        	  1998: 	movem.l (a7)+,d0/d1/d2/d5/d6/d7/a0/a1
00:000061C8 60000090        	  1999: 	bra DrawVertTo
                            	  2000: .notVert:
00:000061CC 6A02            	  2001: 	bpl.s .0001
00:000061CE 4485            	  2002: 	neg.l d5				
                            	  2003: .0001:						; d5 = dx = abs(x1-x0)
00:000061D0 9C82            	  2004: 	sub.l d2,d6			; d6 = y1-y0
00:000061D2 6606            	  2005: 	bne.s .notHoriz
00:000061D4 4CDF03E7        	  2006: 	movem.l (a7)+,d0/d1/d2/d5/d6/d7/a0/a1
00:000061D8 6050            	  2007: 	bra DrawHorizTo
                            	  2008: .notHoriz:
00:000061DA 6B02            	  2009: 	bmi.s .0002
00:000061DC 4486            	  2010: 	neg.l d6
                            	  2011: .0002:						; d6 = dy = -abs(y1-y0)
00:000061DE 7E01            	  2012: 	move.l #1,d7		; d7 = sx (x0 < x1 ? 1 : -1)
00:000061E0 B681            	  2013: 	cmp.l d1,d3
00:000061E2 6202            	  2014: 	bhi.s .0004
00:000061E4 4487            	  2015: 	neg.l d7
                            	  2016: .0004:
00:000061E6 7001            	  2017: 	move.l #1,d0		; d0 = sy (y0 < y1) ? 1 : -1)
00:000061E8 B882            	  2018: 	cmp.l d2,d4
00:000061EA 6202            	  2019: 	bhi.s .0006
00:000061EC 4480            	  2020: 	neg.l d0
                            	  2021: .0006:
00:000061EE 2045            	  2022: 	move.l d5,a0		; a0 = error = dx + dy
00:000061F0 D1C6            	  2023: 	adda.l d6,a0
                            	  2024: .loop:
00:000061F2 6100047C        	  2025: 	bsr CheckForCtrlC
00:000061F6 6100FEB2        	  2026: 	bsr plot				; plot(x0,y0)
00:000061FA 2248            	  2027: 	move.l a0,a1
00:000061FC D3C9            	  2028: 	adda.l a1,a1		; a1 = error *2
00:000061FE BC89            	  2029: 	cmp.l a1,d6			; e2 >= dy?
00:00006200 6E08            	  2030: 	bgt.s .0008
00:00006202 B681            	  2031: 	cmp.l d1,d3			; x0==x1?
00:00006204 6712            	  2032: 	beq.s .brkloop
00:00006206 D1C6            	  2033: 	adda.l d6,a0		; err = err + dy
00:00006208 D287            	  2034: 	add.l d7,d1			; x0 = x0 + sx
                            	  2035: .0008:
00:0000620A BA89            	  2036: 	cmp.l a1,d5			; err2 <= dx?
00:0000620C 6D08            	  2037: 	blt.s .0009
00:0000620E B882            	  2038: 	cmp.l d2,d4			; y0==y1?
00:00006210 6706            	  2039: 	beq.s .brkloop
00:00006212 D1C5            	  2040: 	adda.l d5,a0		; err = err + dx
00:00006214 D480            	  2041: 	add.l d0,d2			; y0 = y0 + sy
                            	  2042: .0009:
00:00006216 60DA            	  2043: 	bra.s .loop
                            	  2044: .brkloop:
00:00006218 23C300040894    	  2045: 	move.l d3,gr_x
00:0000621E 23C400040898    	  2046: 	move.l d4,gr_y
00:00006224 4CDF03E7        	  2047: 	movem.l (a7)+,d0/d1/d2/d5/d6/d7/a0/a1
00:00006228 4E75            	  2048: 	rts
                            	  2049: 
                            	  2050: ; Parameters:
                            	  2051: ;		d3 = x1
                            	  2052: ;		d4 = y1
                            	  2053: 
                            	  2054: DrawHorizTo:
00:0000622A 48E76400        	  2055: 	movem.l d1/d2/d5,-(a7)
00:0000622E 223900040894    	  2056: 	move.l gr_x,d1
00:00006234 243900040898    	  2057: 	move.l gr_y,d2
00:0000623A 7A01            	  2058: 	move.l #1,d5			; assume increment
00:0000623C B681            	  2059: 	cmp.l d1,d3
00:0000623E 6202            	  2060: 	bhi.s .0001
00:00006240 4485            	  2061: 	neg.l d5					; switch to decrement
                            	  2062: .0001:
00:00006242 6100FE66        	  2063: 	bsr plot
00:00006246 B681            	  2064: 	cmp.l d1,d3
00:00006248 6704            	  2065: 	beq.s .0002
00:0000624A D285            	  2066: 	add.l d5,d1
00:0000624C 60F4            	  2067: 	bra.s .0001
                            	  2068: .0002:
00:0000624E 23C100040894    	  2069: 	move.l d1,gr_x
00:00006254 4CDF0026        	  2070: 	movem.l (a7)+,d1/d2/d5
00:00006258 4E75            	  2071: 	rts
                            	  2072: 	
                            	  2073: 	
                            	  2074: ; Parameters:
                            	  2075: ;		d3 = x1
                            	  2076: ;		d4 = y1
                            	  2077: 
                            	  2078: DrawVertTo:
00:0000625A 48E76400        	  2079: 	movem.l d1/d2/d5,-(a7)
00:0000625E 223900040894    	  2080: 	move.l gr_x,d1
00:00006264 243900040898    	  2081: 	move.l gr_y,d2
00:0000626A 7A01            	  2082: 	move.l #1,d5			; assume increment
00:0000626C B882            	  2083: 	cmp.l d2,d4
00:0000626E 6202            	  2084: 	bhi.s .0001
00:00006270 4485            	  2085: 	neg.l d5					; switch to decrement
                            	  2086: .0001:
00:00006272 6100FE36        	  2087: 	bsr plot
00:00006276 B882            	  2088: 	cmp.l d2,d4
00:00006278 6704            	  2089: 	beq.s .0002
00:0000627A D485            	  2090: 	add.l d5,d2
00:0000627C 60F4            	  2091: 	bra.s .0001
                            	  2092: .0002:
00:0000627E 23C200040898    	  2093: 	move.l d2,gr_y
00:00006284 4CDF0026        	  2094: 	movem.l (a7)+,d1/d2/d5
00:00006288 4E75            	  2095: 	rts
                            	  2096: 	
                            	  2097: 	
                            	  2098: ;plotLine(x0, y0, x1, y1)
                            	  2099: ;    dx = abs(x1 - x0)
                            	  2100: ;    sx = x0 < x1 ? 1 : -1
                            	  2101: ;    dy = -abs(y1 - y0)
                            	  2102: ;    sy = y0 < y1 ? 1 : -1
                            	  2103: ;    error = dx + dy
                            	  2104: ;    
                            	  2105: ;    while true
                            	  2106: ;        plot(x0, y0)
                            	  2107: ;        e2 = 2 * error
                            	  2108: ;        if e2 >= dy
                            	  2109: ;            if x0 == x1 break
                            	  2110: ;            error = error + dy
                            	  2111: ;            x0 = x0 + sx
                            	  2112: ;        end if
                            	  2113: ;        if e2 <= dx
                            	  2114: ;            if y0 == y1 break
                            	  2115: ;            error = error + dx
                            	  2116: ;            y0 = y0 + sy
                            	  2117: ;        end if
                            	  2118: ;    end while
                            	  2119:     
                            	  2120: ;------------------------------------------------------------------------------
                            	  2121: ; Cursor positioning / Clear screen
                            	  2122: ; - out of range settings are ignored
                            	  2123: ;
                            	  2124: ; Parameters:
                            	  2125: ;		d1.w cursor position, bits 0 to 7 are row, bits 8 to 15 are column.
                            	  2126: ;	Returns:
                            	  2127: ;		none
                            	  2128: ;------------------------------------------------------------------------------
                            	  2129: 
                            	  2130: Cursor1:
00:0000628A 2F01            	  2131: 	move.l d1,-(a7)
00:0000628C 0C41FF00        	  2132: 	cmpi.w #$FF00,d1
00:00006290 660A            	  2133: 	bne.s .0002
00:00006292 6100F796        	  2134: 	bsr	clear_screen
00:00006296 221F            	  2135: 	move.l (a7)+,d1
00:00006298 6000FAC0        	  2136: 	bra	HomeCursor
                            	  2137: .0002:
00:0000629C B2390004008C    	  2138: 	cmp.b TextRows,d1		; if cursor pos out of range, ignore setting
00:000062A2 6406            	  2139: 	bhs.s	.0003
00:000062A4 13C100040000    	  2140: 	move.b d1,CursorRow
                            	  2141: .0003:
00:000062AA E059            	  2142: 	ror.w	#8,d1
00:000062AC B2390004008D    	  2143: 	cmp.b	TextCols,d1
00:000062B2 6406            	  2144: 	bhs.s	.0001
00:000062B4 13C100040001    	  2145: 	move.b d1,CursorCol
                            	  2146: .0001:
00:000062BA 6100FAB0        	  2147: 	bsr SyncCursor			; update hardware cursor
00:000062BE 221F            	  2148: 	move.l (a7)+,d1
00:000062C0 4E75            	  2149: 	rts
                            	  2150: 
                            	  2151: ;------------------------------------------------------------------------------
                            	  2152: ; Stub routine for unimplemented functionality.
                            	  2153: ;------------------------------------------------------------------------------
                            	  2154: 
                            	  2155: StubRout:
00:000062C2 4E75            	  2156: 	rts
                            	  2157: 
                            	  2158: ;------------------------------------------------------------------------------
                            	  2159: ; Select a specific IO focus.
                            	  2160: ;------------------------------------------------------------------------------
                            	  2161: 
                            	  2162: select_iofocus:
00:000062C4 0C010002        	  2163: 	cmpi.b	#2,d1
00:000062C8 650A            	  2164: 	blo.s		.0001
00:000062CA 0C010005        	  2165: 	cmpi.b	#NCORES+1,d1
00:000062CE 6204            	  2166: 	bhi.s		.0001
00:000062D0 2001            	  2167: 	move.l	d1,d0
00:000062D2 6014            	  2168: 	bra.s		select_focus1
                            	  2169: .0001:
00:000062D4 4E75            	  2170: 	rts
                            	  2171: 
                            	  2172: ;------------------------------------------------------------------------------
                            	  2173: ; Rotate the IO focus, done when ALT-Tab is pressed.
                            	  2174: ;
                            	  2175: ; Modifies:
                            	  2176: ;		d0, IOFocus BIOS variable
                            	  2177: ;		updates the text screen pointer
                            	  2178: ;------------------------------------------------------------------------------
                            	  2179: 
                            	  2180: rotate_iofocus:
00:000062D6 103900100000    	  2181: 	move.b IOFocus,d0					; d0 = focus, we can trash d0
00:000062DC 5200            	  2182: 	add.b	#1,d0								; increment the focus
00:000062DE B03C0005        	  2183: 	cmp.b	#NCORES+1,d0				; limit to 2 to 9
00:000062E2 6304            	  2184: 	bls.s	.0001
00:000062E4 103C0002        	  2185: 	move.b #2,d0
                            	  2186: .0001:
                            	  2187: select_focus1:
00:000062E8 13C000100000    	  2188: 	move.b	d0,IOFocus				; set IO focus
                            	  2189: 	; reset keyboard processor to focus core
                            	  2190: ;	move.l #$3C060500,d0			; core=??,level sensitive,enabled,irq6,inta
                            	  2191: ;	or.b IOFocus,d0
                            	  2192: ;	move.l d0,PLIC+$80+4*30		; set register
                            	  2193: 	; Adjust text screen pointer
00:000062EE 5500            	  2194: 	subi.b #2,d0							; screen is 0 to 7, focus is 2 to 9
00:000062F0 4880            	  2195: 	ext.w	d0									; make into word value
00:000062F2 C0FC0800        	  2196: 	mulu #2048,d0							; * 2048	cells per screen
00:000062F6 E158            	  2197: 	rol.w	#8,d0								; swap byte order
00:000062F8 4840            	  2198: 	swap d0										; get bits 16-31
00:000062FA E158            	  2199: 	rol.w	#8,d0								; swap byte order
00:000062FC 23C0FD080028    	  2200: 	move.l d0,TEXTREG+$28			; update screen address in text controller
00:00006302 6000FA68        	  2201: 	bra	SyncCursor						; set cursor position
                            	  2202: 
                            	  2203: ;==============================================================================
                            	  2204: ; PLIC - platform level interrupt controller
                            	  2205: ;
                            	  2206: ; Register layout:
                            	  2207: ;   bits 0 to 7  = cause code to issue (vector number)
                            	  2208: ;   bits 8 to 11 = irq level to issue
                            	  2209: ;   bit 16 = irq enable
                            	  2210: ;   bit 17 = edge sensitivity
                            	  2211: ;   bit 18 = 0=vpa, 1=inta
                            	  2212: ;		bit 24 to 29 target core
                            	  2213: ;
                            	  2214: ; Note byte order must be reversed for PLIC.
                            	  2215: ;==============================================================================
                            	  2216: 
                            	  2217: init_plic:
00:00006306 41F9FD090000    	  2218: 	lea	PLIC,a0							; a0 points to PLIC
00:0000630C 43E800F4        	  2219: 	lea	$80+4*29(a0),a1			; point to timer registers (29)
00:00006310 22BC0006033F    	  2220: 	move.l #$0006033F,(a1)	; initialize, core=63,edge sensitive,enabled,irq6,vpa
00:00006316 5889            	  2221: 	lea	4(a1),a1						; point to keyboard registers (30)
00:00006318 22BC3C060502    	  2222: 	move.l #$3C060502,(a1)	; core=2,level sensitive,enabled,irq6,inta
00:0000631E 5889            	  2223: 	lea	4(a1),a1						; point to nmi button register (31)
00:00006320 22BC00070302    	  2224: 	move.l #$00070302,(a1)	; initialize, core=2,edge sensitive,enabled,irq7,vpa
00:00006326 43E800C0        	  2225: 	lea	$80+4*16(a0),a1			; a1 points to ACIA register
00:0000632A 22BC3D030502    	  2226: 	move.l #$3D030502,(a1)	; core=2,level sensitive,enabled,irq3,inta	
00:00006330 43E80090        	  2227: 	lea	$80+4*4(a0),a1			; a1 points to io_bitmap irq
00:00006334 22BC3B060702    	  2228: 	move.l #$3B060702,(a1)	; core=2,edge sensitive,enabled,irq6,inta	
00:0000633A 4E75            	  2229: 	rts
                            	  2230: 
                            	  2231: ;==============================================================================
                            	  2232: ; Keyboard stuff
                            	  2233: ;
                            	  2234: ; KeyState2_
                            	  2235: ; 876543210
                            	  2236: ; ||||||||+ = shift
                            	  2237: ; |||||||+- = alt
                            	  2238: ; ||||||+-- = control
                            	  2239: ; |||||+--- = numlock
                            	  2240: ; ||||+---- = capslock
                            	  2241: ; |||+----- = scrolllock
                            	  2242: ; ||+------ =
                            	  2243: ; |+------- = 
                            	  2244: ; +-------- = extended
                            	  2245: ;
                            	  2246: ;==============================================================================
                            	  2247: 
                            	  2248: ;------------------------------------------------------------------------------
                            	  2249: ; Setup the Keyboard device
                            	  2250: ;------------------------------------------------------------------------------
                            	  2251: setup_keybd:
                            	  2252: keybd_init:
00:0000633C 701F            	  2253: 	moveq #31,d0
00:0000633E 41F900040A40    	  2254: 	lea.l keybd_dcb,a0
                            	  2255: .0001:
00:00006344 4298            	  2256: 	clr.l (a0)+
00:00006346 51C8FFFC        	  2257: 	dbra d0,.0001
00:0000634A 23FC204243440004	  2258: 	move.l #$20424344,keybd_dcb+DCB_MAGIC				; 'DCB'
00:00006352 0A40
00:00006354 23FC2044424B0004	  2259: 	move.l #$2044424B,keybd_dcb+DCB_NAME				; 'KBD'
00:0000635C 0A44
00:0000635E 23FC000063CC0004	  2260: 	move.l #keybd_cmdproc,con_dcb+DCB_CMDPROC
00:00006366 0A98
00:00006368 23FC001000200004	  2261: 	move.l #_KeybdBuf,keybd_dcb+DCB_INBUFPTR
00:00006370 0A68
00:00006372 23FC001000800004	  2262: 	move.l #_KeybdOBuf,keybd_dcb+DCB_OUTBUFPTR
00:0000637A 0A6C
00:0000637C 23FC000000200004	  2263: 	move.l #32,keybd_dcb+DCB_INBUFSIZE
00:00006384 0A70
00:00006386 23FC000000200004	  2264: 	move.l #32,keybd_dcb+DCB_OUTBUFSIZE
00:0000638E 0A74
00:00006390 423900040A7B    	  2265: 	clr.b keybd_dcb+DCB_OUTCOLS	; set rows and columns
00:00006396 423900040A7A    	  2266: 	clr.b keybd_dcb+DCB_OUTROWS
00:0000639C 423900040A79    	  2267: 	clr.b keybd_dcb+DCB_INCOLS		; set rows and columns
00:000063A2 423900040A78    	  2268: 	clr.b keybd_dcb+DCB_INROWS
                            	  2269: ;	bsr KeybdInit
00:000063A8 4E75            	  2270: 	rts
                            	  2271: 
                            	  2272: 	align 2
                            	  2273: KBD_CMDTBL:
00:000063AC 0000633C        	  2274: 	dc.l keybd_init
00:000063B0 000063F2        	  2275: 	dc.l keybd_stat
00:000063B4 000063FA        	  2276: 	dc.l keybd_putchar
00:000063B8 0000640A        	  2277: 	dc.l keybd_putbuf
00:000063BC 00006402        	  2278: 	dc.l keybd_getchar
00:000063C0 0000640A        	  2279: 	dc.l keybd_getbuf
00:000063C4 0000640A        	  2280: 	dc.l keybd_set_inpos
00:000063C8 0000640A        	  2281: 	dc.l keybd_set_outpos
                            	  2282: 
                            	  2283: keybd_cmdproc:
00:000063CC 0C060008        	  2284: 	cmpi.b #8,d6
00:000063D0 641C            	  2285: 	bhs.s .0001
00:000063D2 4A06            	  2286: 	tst.b d6
00:000063D4 6B18            	  2287: 	bmi.s .0001
00:000063D6 48E70280        	  2288: 	movem.l d6/a0,-(a7)
00:000063DA E506            	  2289: 	asl.b #2,d6
00:000063DC 4886            	  2290: 	ext.w d6
00:000063DE 41FAFFCC        	  2291: 	lea KBD_CMDTBL,a0
00:000063E2 20706000        	  2292: 	move.l (a0,d6.w),a0
00:000063E6 4E90            	  2293: 	jsr (a0)
00:000063E8 4CDF0140        	  2294: 	movem.l (a7)+,d6/a0
00:000063EC 4E75            	  2295: 	rts
                            	  2296: .0001:
00:000063EE 7002            	  2297: 	moveq #E_Func,d0
00:000063F0 4E75            	  2298: 	rts
                            	  2299: 
                            	  2300: keybd_stat:
00:000063F2 61000196        	  2301: 	bsr _KeybdGetStatus
00:000063F6 7000            	  2302: 	moveq #E_Ok,d0
00:000063F8 4E75            	  2303: 	rts
                            	  2304: 
                            	  2305: keybd_putchar:
00:000063FA 61000500        	  2306: 	bsr KeybdSendByte
00:000063FE 7000            	  2307: 	moveq #E_Ok,d0
00:00006400 4E75            	  2308: 	rts
                            	  2309: 
                            	  2310: keybd_getchar:
00:00006402 61000234        	  2311: 	bsr GetKey
00:00006406 7000            	  2312: 	moveq #E_Ok,d0
00:00006408 4E75            	  2313: 	rts
                            	  2314: 
                            	  2315: keybd_putbuf:
                            	  2316: keybd_getbuf:
                            	  2317: keybd_set_inpos:
                            	  2318: keybd_set_outpos:
00:0000640A 700A            	  2319: 	moveq #E_NotSupported,d0
00:0000640C 4E75            	  2320: 	rts
                            	  2321: 
                            	  2322: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2323: ; Get ID - get the keyboards identifier code.
                            	  2324: ;
                            	  2325: ; Parameters: none
                            	  2326: ; Returns: d = $AB83, $00 on fail
                            	  2327: ; Modifies: d, KeybdID updated
                            	  2328: ; Stack Space: 2 words
                            	  2329: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2330: 
                            	  2331: KeybdGetID:
00:0000640E 323C00F2        	  2332: 	move.w	#$F2,d1
00:00006412 610004E8        	  2333: 	bsr			KeybdSendByte
00:00006416 610001E6        	  2334: 	bsr			KeybdWaitTx
00:0000641A 610001C0        	  2335: 	bsr			KeybdRecvByte
00:0000641E 08010007        	  2336: 	btst		#7,d1
00:00006422 6624            	  2337: 	bne			kgnotKbd
00:00006424 0C0100AB        	  2338: 	cmpi.b	#$AB,d1
00:00006428 661E            	  2339: 	bne			kgnotKbd
00:0000642A 610001B0        	  2340: 	bsr			KeybdRecvByte
00:0000642E 08010007        	  2341: 	btst		#7,d1
00:00006432 6614            	  2342: 	bne			kgnotKbd
00:00006434 0C010083        	  2343: 	cmpi.b	#$83,d1
00:00006438 660E            	  2344: 	bne			kgnotKbd
00:0000643A 223C0000AB83    	  2345: 	move.l	#$AB83,d1
                            	  2346: kgid1:
00:00006440 33C100100018    	  2347: 	move.w	d1,KeybdID
00:00006446 4E75            	  2348: 	rts
                            	  2349: kgnotKbd:
00:00006448 7200            	  2350: 	moveq		#0,d1
00:0000644A 60F4            	  2351: 	bra			kgid1
                            	  2352: 
                            	  2353: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2354: ; Set the LEDs on the keyboard.
                            	  2355: ;
                            	  2356: ; Parameters:
                            	  2357: ;		d1.b = LED state
                            	  2358: ;	Modifies:
                            	  2359: ;		none
                            	  2360: ; Returns:
                            	  2361: ;		none
                            	  2362: ; Stack Space:
                            	  2363: ;		1 long word
                            	  2364: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2365: 
                            	  2366: KeybdSetLED:
00:0000644C 2F01            	  2367: 	move.l	d1,-(a7)
00:0000644E 123C00ED        	  2368: 	move.b	#$ED,d1
00:00006452 610004A8        	  2369: 	bsr			KeybdSendByte
00:00006456 610001A6        	  2370: 	bsr			KeybdWaitTx
00:0000645A 61000180        	  2371: 	bsr			KeybdRecvByte
00:0000645E 4A01            	  2372: 	tst.b		d1
00:00006460 6B12            	  2373: 	bmi			.0001
00:00006462 0C0100FA        	  2374: 	cmpi.b	#$FA,d1
00:00006466 2217            	  2375: 	move.l	(a7),d1
00:00006468 61000492        	  2376: 	bsr			KeybdSendByte
00:0000646C 61000190        	  2377: 	bsr			KeybdWaitTx
00:00006470 6100016A        	  2378: 	bsr			KeybdRecvByte
                            	  2379: .0001:
00:00006474 221F            	  2380: 	move.l	(a7)+,d1
00:00006476 4E75            	  2381: 	rts
                            	  2382: 
                            	  2383: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2384: ; Initialize the keyboard.
                            	  2385: ;
                            	  2386: ; Parameters:
                            	  2387: ;		none
                            	  2388: ;	Modifies:
                            	  2389: ;		none
                            	  2390: ; Returns:
                            	  2391: ;		none
                            	  2392: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2393: 
                            	  2394: _KeybdInit:
                            	  2395: KeybdInit:
                            	  2396: ;	movem.l	d0/d1/d3/a1,-(a7)
00:00006478 42390010000F    	  2397: 	clr.b	_KeyState1		; records key up/down state
00:0000647E 423900100010    	  2398: 	clr.b	_KeyState2		; records shift,ctrl,alt state
00:00006484 4E75            	  2399: 	rts
                            	  2400: 
00:00006486 61000498        	  2401: 	bsr			Wait300ms
00:0000648A 610000FE        	  2402: 	bsr			_KeybdGetStatus	; wait for response from keyboard
00:0000648E 4A01            	  2403: 	tst.b		d1
00:00006490 6A10            	  2404: 	bpl			.0001					; is input buffer full ? no, branch
00:00006492 61000114        	  2405: 	bsr	_KeybdGetScancode
00:00006496 6100012E        	  2406: 	bsr _KeybdClearIRQ
00:0000649A 0C0100AA        	  2407: 	cmpi.b	#$AA,d1				; keyboard Okay
00:0000649E 67000098        	  2408: 	beq			kbdi0005
                            	  2409: .0001:
00:000064A2 760A            	  2410: 	moveq		#10,d3
                            	  2411: kbdi0002:
00:000064A4 6100045E        	  2412: 	bsr			Wait10ms
00:000064A8 4239FD0FFE01    	  2413: 	clr.b		KEYBD+1				; clear receive register (write $00 to status reg)
00:000064AE 6100A1DC        	  2414: 	bsr net_delay
00:000064B2 72FF            	  2415: 	moveq		#-1,d1				; send reset code to keyboard
00:000064B4 13C1FD0FFE01    	  2416: 	move.b	d1,KEYBD+1		; write $FF to status reg to clear TX state
00:000064BA 6100A1D0        	  2417: 	bsr net_delay
00:000064BE 6100043C        	  2418: 	bsr			KeybdSendByte	; now write ($FF) to transmit register for reset
00:000064C2 6100013A        	  2419: 	bsr			KeybdWaitTx		; wait until no longer busy
00:000064C6 4A81            	  2420: 	tst.l		d1
00:000064C8 6B000088        	  2421: 	bmi			kbdiXmitBusy
00:000064CC 6100010E        	  2422: 	bsr			KeybdRecvByte	; look for an ACK ($FA)
00:000064D0 0C0100FA        	  2423: 	cmpi.b	#$FA,d1
00:000064D4 6604            	  2424: 	bne			.0001
00:000064D6 61000104        	  2425: 	bsr			KeybdRecvByte	; look for BAT completion code ($AA)
                            	  2426: .0001:
00:000064DA 0C0100FC        	  2427: 	cmpi.b	#$FC,d1				; reset error ?
00:000064DE 672E            	  2428: 	beq			kbdiTryAgain
00:000064E0 0C0100AA        	  2429: 	cmpi.b	#$AA,d1				; reset complete okay ?
00:000064E4 6628            	  2430: 	bne			kbdiTryAgain
                            	  2431: 
                            	  2432: 	; After a reset, scan code set #2 should be active
                            	  2433: .config:
00:000064E6 323C00F0        	  2434: 	move.w	#$F0,d1			; send scan code select
00:000064EA 13C1FD0FFF00    	  2435: 	move.b	d1,leds
00:000064F0 6100A19A        	  2436: 	bsr net_delay
00:000064F4 61000406        	  2437: 	bsr			KeybdSendByte
00:000064F8 61000104        	  2438: 	bsr			KeybdWaitTx
00:000064FC 4A81            	  2439: 	tst.l		d1
00:000064FE 6B52            	  2440: 	bmi			kbdiXmitBusy
00:00006500 610000DA        	  2441: 	bsr			KeybdRecvByte	; wait for response from keyboard
00:00006504 4A41            	  2442: 	tst.w		d1
00:00006506 6B06            	  2443: 	bmi			kbdiTryAgain
00:00006508 0C0100FA        	  2444: 	cmpi.b	#$FA,d1				; ACK
00:0000650C 670E            	  2445: 	beq			kbdi0004
                            	  2446: kbdiTryAgain:
00:0000650E 51CBFF94        	  2447: 	dbra		d3,kbdi0002
                            	  2448: .keybdErr:
00:00006512 43FA004C        	  2449: 	lea			msgBadKeybd,a1
00:00006516 6100F816        	  2450: 	bsr			DisplayStringCRLF
00:0000651A 6020            	  2451: 	bra			ledxit
                            	  2452: kbdi0004:
00:0000651C 7202            	  2453: 	moveq		#2,d1			; select scan code set #2
00:0000651E 610003DC        	  2454: 	bsr			KeybdSendByte
00:00006522 610000DA        	  2455: 	bsr			KeybdWaitTx
00:00006526 4A81            	  2456: 	tst.l		d1
00:00006528 6B28            	  2457: 	bmi			kbdiXmitBusy
00:0000652A 610000B0        	  2458: 	bsr			KeybdRecvByte	; wait for response from keyboard
00:0000652E 4A41            	  2459: 	tst.w		d1
00:00006530 6BDC            	  2460: 	bmi			kbdiTryAgain
00:00006532 0C0100FA        	  2461: 	cmpi.b	#$FA,d1
00:00006536 66D6            	  2462: 	bne			kbdiTryAgain
                            	  2463: kbdi0005:
00:00006538 6100FED4        	  2464: 	bsr			KeybdGetID
                            	  2465: ledxit:
00:0000653C 7207            	  2466: 	moveq		#$07,d1
00:0000653E 6100FF0C        	  2467: 	bsr			KeybdSetLED
00:00006542 610003DC        	  2468: 	bsr			Wait300ms
00:00006546 7200            	  2469: 	moveq		#$00,d1
00:00006548 6100FF02        	  2470: 	bsr			KeybdSetLED
00:0000654C 4CDF020B        	  2471: 	movem.l	(a7)+,d0/d1/d3/a1
00:00006550 4E75            	  2472: 	rts
                            	  2473: kbdiXmitBusy:
00:00006552 43FA001B        	  2474: 	lea			msgXmitBusy,a1
00:00006556 6100F7D6        	  2475: 	bsr			DisplayStringCRLF
00:0000655A 4CDF020B        	  2476: 	movem.l	(a7)+,d0/d1/d3/a1
00:0000655E 4E75            	  2477: 	rts
                            	  2478: 	
                            	  2479: msgBadKeybd:
00:00006560 4B6579626F617264	  2480: 	dc.b		"Keyboard error",0
00:00006568 206572726F72
00:0000656E 00
                            	  2481: msgXmitBusy:
00:0000656F 4B6579626F617264	  2482: 	dc.b		"Keyboard transmitter stuck",0
00:00006577 207472616E736D69
00:0000657F 7474657220737475
00:00006587 636B
00:00006589 00
                            	  2483: 
                            	  2484: 	even
                            	  2485: _KeybdGetStatus:
00:0000658A 4E7A1FE0        	  2486: 	movec coreno,d1
00:0000658E 0C010002        	  2487: 	cmpi.b #2,d1
00:00006592 660A            	  2488: 	bne .0001
00:00006594 7200            	  2489: 	moveq	#0,d1
00:00006596 1239FD0FFE01    	  2490: 	move.b KEYBD+1,d1
00:0000659C 4E75            	  2491: 	rts
                            	  2492: .0001:
00:0000659E 7200            	  2493: 	moveq #0,d1
00:000065A0 1239FD0FFE03    	  2494: 	move.b KEYBD+3,d1
00:000065A6 4E75            	  2495: 	rts
                            	  2496: 
                            	  2497: ; Get the scancode from the keyboard port
                            	  2498: 
                            	  2499: _KeybdGetScancode:
00:000065A8 4E7A1FE0        	  2500: 	movec coreno,d1
00:000065AC 0C010002        	  2501: 	cmpi.b #2,d1
00:000065B0 660A            	  2502: 	bne .0001
00:000065B2 7200            	  2503: 	moveq		#0,d1
00:000065B4 1239FD0FFE00    	  2504: 	move.b	KEYBD,d1				; get the scan code
00:000065BA 4E75            	  2505: 	rts
                            	  2506: .0001:
00:000065BC 7200            	  2507: 	moveq #0,d1
00:000065BE 1239FD0FFE02    	  2508: 	move.b KEYBD+2,d1
00:000065C4 4E75            	  2509: 	rts
                            	  2510: 
                            	  2511: _KeybdClearIRQ:
00:000065C6 2F01            	  2512: 	move.l d1,-(a7)
00:000065C8 4E7A1FE0        	  2513: 	movec coreno,d1
00:000065CC 0C010002        	  2514: 	cmpi.b #2,d1
00:000065D0 6606            	  2515: 	bne .0001
00:000065D2 4239FD0FFE01    	  2516: 	move.b	#0,KEYBD+1			; clear receive register
                            	  2517: .0001:
00:000065D8 221F            	  2518: 	move.l (a7)+,d1
00:000065DA 4E75            	  2519: 	rts
                            	  2520: 
                            	  2521: ; Recieve a byte from the keyboard, used after a command is sent to the
                            	  2522: ; keyboard in order to wait for a response.
                            	  2523: ;
                            	  2524: KeybdRecvByte:
00:000065DC 2F03            	  2525: 	move.l	d3,-(a7)
00:000065DE 363C0064        	  2526: 	move.w	#100,d3		; wait up to 1s
                            	  2527: .0003:
00:000065E2 61A6            	  2528: 	bsr			_KeybdGetStatus	; wait for response from keyboard
00:000065E4 4A01            	  2529: 	tst.b		d1
00:000065E6 6B0E            	  2530: 	bmi			.0004			; is input buffer full ? yes, branch
00:000065E8 6100031A        	  2531: 	bsr			Wait10ms	; wait a bit
00:000065EC 51CBFFF4        	  2532: 	dbra		d3,.0003	; go back and try again
00:000065F0 261F            	  2533: 	move.l	(a7)+,d3
00:000065F2 72FF            	  2534: 	moveq		#-1,d1		; return -1
00:000065F4 4E75            	  2535: 	rts
                            	  2536: .0004:
00:000065F6 61B0            	  2537: 	bsr	_KeybdGetScancode
00:000065F8 61CC            	  2538: 	bsr _KeybdClearIRQ
00:000065FA 261F            	  2539: 	move.l	(a7)+,d3
00:000065FC 4E75            	  2540: 	rts
                            	  2541: 
                            	  2542: 
                            	  2543: ; Wait until the keyboard transmit is complete
                            	  2544: ; Returns -1 if timedout, 0 if transmit completed
                            	  2545: ;
                            	  2546: KeybdWaitTx:
00:000065FE 48E73000        	  2547: 	movem.l	d2/d3,-(a7)
00:00006602 7664            	  2548: 	moveq		#100,d3		; wait a max of 1s
                            	  2549: .0001:
00:00006604 6184            	  2550: 	bsr	_KeybdGetStatus
00:00006606 08010006        	  2551: 	btst #6,d1				; check for transmit complete bit
00:0000660A 6610            	  2552: 	bne	.0002					; branch if bit set
00:0000660C 610002F6        	  2553: 	bsr	Wait10ms			; delay a little bit
00:00006610 51CBFFF2        	  2554: 	dbra d3,.0001			; go back and try again
00:00006614 4CDF000C        	  2555: 	movem.l	(a7)+,d2/d3
00:00006618 72FF            	  2556: 	moveq	#-1,d1			; return -1
00:0000661A 4E75            	  2557: 	rts
                            	  2558: .0002:
00:0000661C 4CDF000C        	  2559: 	movem.l	(a7)+,d2/d3
00:00006620 7200            	  2560: 	moveq	#0,d1		; return 0
00:00006622 4E75            	  2561: 	rts
                            	  2562: 
                            	  2563: ;------------------------------------------------------------------------------
                            	  2564: ; d1.b 0=echo off, non-zero = echo on
                            	  2565: ;------------------------------------------------------------------------------
                            	  2566: 
                            	  2567: SetKeyboardEcho:
00:00006624 13C10004000C    	  2568: 	move.b	d1,KeybdEcho
00:0000662A 4E75            	  2569: 	rts
                            	  2570: 
                            	  2571: ;------------------------------------------------------------------------------
                            	  2572: ; Get key pending status into d1.b
                            	  2573: ;
                            	  2574: ; Returns:
                            	  2575: ;		d1.b = 1 if a key is available, otherwise zero.
                            	  2576: ;------------------------------------------------------------------------------
                            	  2577: 
                            	  2578: CheckForKey:
00:0000662C 7200            	  2579: 	moveq.l	#0,d1					; clear high order bits
                            	  2580: ;	move.b	KEYBD+1,d1		; get keyboard port status
                            	  2581: ;	smi.b		d1						; set true/false
                            	  2582: ;	andi.b	#1,d1					; return true (1) if key available, 0 otherwise
00:0000662E 4A3900100013    	  2583: 	tst.b	_KeybdCnt
00:00006634 56C1            	  2584: 	sne.b	d1
00:00006636 4E75            	  2585: 	rts
                            	  2586: 
                            	  2587: ;------------------------------------------------------------------------------
                            	  2588: ; GetKey
                            	  2589: ; 	Get a character from the keyboard. 
                            	  2590: ;
                            	  2591: ; Modifies:
                            	  2592: ;		d1
                            	  2593: ; Returns:
                            	  2594: ;		d1 = -1 if no key available or not in focus, otherwise key
                            	  2595: ;------------------------------------------------------------------------------
                            	  2596: 
                            	  2597: GetKey:
00:00006638 2F00            	  2598: 	move.l	d0,-(a7)					; push d0
00:0000663A 123900100000    	  2599: 	move.b	IOFocus,d1				; Check if the core has the IO focus
00:00006640 4E7A0FE0        	  2600: 	movec.l	coreno,d0
00:00006644 B200            	  2601: 	cmp.b	d0,d1
00:00006646 6622            	  2602: 	bne.s	.0004								; go return no key available, if not in focus
00:00006648 6136            	  2603: 	bsr	KeybdGetCharNoWait		; get a character
00:0000664A 4A81            	  2604: 	tst.l	d1									; was a key available?
00:0000664C 6B1C            	  2605: 	bmi.s	.0004
00:0000664E 4A390004000C    	  2606: 	tst.b	KeybdEcho						; is keyboard echo on ?
00:00006654 6710            	  2607: 	beq.s	.0003								; no echo, just return the key
00:00006656 0C01000D        	  2608: 	cmpi.b #CR,d1							; convert CR keystroke into CRLF
00:0000665A 6606            	  2609: 	bne.s	.0005
00:0000665C 6100F408        	  2610: 	bsr	CRLF
00:00006660 6004            	  2611: 	bra.s	.0003
                            	  2612: .0005:
00:00006662 61002126        	  2613: 	bsr	OutputChar
                            	  2614: .0003:
00:00006666 201F            	  2615: 	move.l (a7)+,d0						; pop d0
00:00006668 4E75            	  2616: 	rts												; return key
                            	  2617: ; Return -1 indicating no char was available
                            	  2618: .0004:
00:0000666A 201F            	  2619: 	move.l (a7)+,d0						; pop d0
00:0000666C 72FF            	  2620: 	moveq	#-1,d1							; return no key available
00:0000666E 4E75            	  2621: 	rts
                            	  2622: 
                            	  2623: ;------------------------------------------------------------------------------
                            	  2624: ; Check for the cntrl-C keyboard sequence. Abort running routine and drop
                            	  2625: ; back into the monitor.
                            	  2626: ;------------------------------------------------------------------------------
                            	  2627: 
                            	  2628: CheckForCtrlC:
00:00006670 2F01            	  2629: 	move.l d1,-(a7)
00:00006672 610C            	  2630: 	bsr	KeybdGetCharNoWait
00:00006674 0C010003        	  2631: 	cmpi.b #CTRLC,d1
00:00006678 67000732        	  2632: 	beq	Monitor
00:0000667C 221F            	  2633: 	move.l (a7)+,d1
00:0000667E 4E75            	  2634: 	rts
                            	  2635: 
                            	  2636: ;------------------------------------------------------------------------------
                            	  2637: ;------------------------------------------------------------------------------
                            	  2638: 
                            	  2639: KeybdGetCharNoWait:
00:00006680 42390004000D    	  2640: 	clr.b	KeybdWaitFlag
00:00006686 6008            	  2641: 	bra	KeybdGetChar
                            	  2642: 
                            	  2643: KeybdGetCharWait:
00:00006688 13FC00FF0004000D	  2644: 	move.b #-1,KeybdWaitFlag
                            	  2645: 
                            	  2646: KeybdGetChar:
00:00006690 48E7B080        	  2647: 	movem.l	d0/d2/d3/a0,-(a7)
                            	  2648: .0003:
00:00006694 4E7A0FE0        	  2649: 	movec	coreno,d0
00:00006698 4840            	  2650: 	swap d0
00:0000669A 7203            	  2651: 	moveq	#KEYBD_SEMA,d1
00:0000669C 6100A10A        	  2652: 	bsr	LockSemaphore
00:000066A0 143900100013    	  2653: 	move.b	_KeybdCnt,d2		; get count of buffered scan codes
00:000066A6 673E            	  2654: 	beq.s		.0015						;
00:000066A8 143900100011    	  2655: 	move.b	_KeybdHead,d2		; d2 = buffer head
00:000066AE 4882            	  2656: 	ext.w		d2
00:000066B0 41F900100020    	  2657: 	lea			_KeybdBuf,a0		; a0 = pointer to keyboard buffer
00:000066B6 7200            	  2658: 	clr.l		d1
00:000066B8 12302000        	  2659: 	move.b	(a0,d2.w),d1		; d1 = scan code from buffer
00:000066BC 5202            	  2660: 	addi.b	#1,d2						; increment keyboard head index
00:000066BE 0202001F        	  2661: 	andi.b	#31,d2					; and wrap around at buffer size
00:000066C2 13C200100011    	  2662: 	move.b	d2,_KeybdHead
00:000066C8 533900100013    	  2663: 	subi.b	#1,_KeybdCnt		; decrement count of scan codes in buffer
00:000066CE C342            	  2664: 	exg			d1,d2						; save scancode value in d2
00:000066D0 4E7A0FE0        	  2665: 	movec		coreno,d0
00:000066D4 4840            	  2666: 	swap		d0
00:000066D6 7203            	  2667: 	moveq		#KEYBD_SEMA,d1
00:000066D8 6100A10A        	  2668: 	bsr			UnlockSemaphore
00:000066DC C541            	  2669: 	exg			d2,d1						; restore scancode value
00:000066DE 602A            	  2670: 	bra			.0001						; go process scan code
                            	  2671: .0014:
00:000066E0 6100FEA8        	  2672: 	bsr		_KeybdGetStatus		; check keyboard status for key available
00:000066E4 6B1C            	  2673: 	bmi		.0006							; yes, go process
                            	  2674: .0015:
00:000066E6 4E7A0FE0        	  2675: 	movec		coreno,d0
00:000066EA 4840            	  2676: 	swap		d0
00:000066EC 7203            	  2677: 	moveq		#KEYBD_SEMA,d1
00:000066EE 6100A0F4        	  2678: 	bsr			UnlockSemaphore
00:000066F2 4A390004000D    	  2679: 	tst.b		KeybdWaitFlag			; are we willing to wait for a key ?
00:000066F8 6B9A            	  2680: 	bmi			.0003							; yes, branch back
00:000066FA 4CDF010D        	  2681: 	movem.l	(a7)+,d0/d2/d3/a0
00:000066FE 72FF            	  2682: 	moveq		#-1,d1						; flag no char available
00:00006700 4E75            	  2683: 	rts
                            	  2684: .0006:
00:00006702 6100FEA4        	  2685: 	bsr	_KeybdGetScancode
00:00006706 6100FEBE        	  2686: 	bsr _KeybdClearIRQ
                            	  2687: .0001:
00:0000670A 33FC0001FD0FFF00	  2688: 	move.w	#1,leds
00:00006712 B23C00F0        	  2689: 	cmp.b	#SC_KEYUP,d1
00:00006716 670000C0        	  2690: 	beq		.doKeyup
00:0000671A B23C00E0        	  2691: 	cmp.b	#SC_EXTEND,d1
00:0000671E 670000C4        	  2692: 	beq		.doExtend
00:00006722 B23C0014        	  2693: 	cmp.b	#SC_CTRL,d1
00:00006726 670000C8        	  2694: 	beq		.doCtrl
00:0000672A B23C0012        	  2695: 	cmp.b	#SC_LSHIFT,d1
00:0000672E 6700012A        	  2696: 	beq		.doShift
00:00006732 B23C0059        	  2697: 	cmp.b	#SC_RSHIFT,d1
00:00006736 67000122        	  2698: 	beq		.doShift
00:0000673A B23C0077        	  2699: 	cmp.b	#SC_NUMLOCK,d1
00:0000673E 67000142        	  2700: 	beq		.doNumLock
00:00006742 B23C0058        	  2701: 	cmp.b	#SC_CAPSLOCK,d1
00:00006746 67000148        	  2702: 	beq		.doCapsLock
00:0000674A B23C007E        	  2703: 	cmp.b	#SC_SCROLLLOCK,d1
00:0000674E 6700014E        	  2704: 	beq		.doScrollLock
00:00006752 B23C0011        	  2705: 	cmp.b   #SC_ALT,d1
00:00006756 670000C0        	  2706: 	beq     .doAlt
00:0000675A 14390010000F    	  2707: 	move.b	_KeyState1,d2			; check key up/down
00:00006760 42390010000F    	  2708: 	move.b	#0,_KeyState1			; clear keyup status
00:00006766 4A02            	  2709: 	tst.b	d2
00:00006768 6600FF2A        	  2710: 	bne	    .0003					; ignore key up
00:0000676C B23C000D        	  2711: 	cmp.b   #SC_TAB,d1
00:00006770 670000CE        	  2712: 	beq     .doTab
                            	  2713: .0013:
00:00006774 143900100010    	  2714: 	move.b	_KeyState2,d2
00:0000677A 6A1A            	  2715: 	bpl		.0010					; is it extended code ?
00:0000677C C43C007F        	  2716: 	and.b	#$7F,d2					; clear extended bit
00:00006780 13C200100010    	  2717: 	move.b	d2,_KeyState2
00:00006786 42390010000F    	  2718: 	move.b	#0,_KeyState1			; clear keyup
00:0000678C 41FA04E4        	  2719: 	lea		_keybdExtendedCodes,a0
00:00006790 12301000        	  2720: 	move.b	(a0,d1.w),d1
00:00006794 6034            	  2721: 	bra		.0008
                            	  2722: .0010:
00:00006796 08020002        	  2723: 	btst	#2,d2					; is it CTRL code ?
00:0000679A 670E            	  2724: 	beq		.0009
00:0000679C C27C007F        	  2725: 	and.w	#$7F,d1
00:000067A0 41FA0450        	  2726: 	lea		_keybdControlCodes,a0
00:000067A4 12301000        	  2727: 	move.b	(a0,d1.w),d1
00:000067A8 6020            	  2728: 	bra		.0008
                            	  2729: .0009:
00:000067AA 08020000        	  2730: 	btst	#0,d2					; is it shift down ?
00:000067AE 670A            	  2731: 	beq  	.0007
00:000067B0 41FA0340        	  2732: 	lea		_shiftedScanCodes,a0
00:000067B4 12301000        	  2733: 	move.b	(a0,d1.w),d1
00:000067B8 6010            	  2734: 	bra		.0008
                            	  2735: .0007:
00:000067BA 41FA0236        	  2736: 	lea		_unshiftedScanCodes,a0
00:000067BE 12301000        	  2737: 	move.b	(a0,d1.w),d1
00:000067C2 33FC0202FD0FFF00	  2738: 	move.w	#$0202,leds
                            	  2739: .0008:
00:000067CA 33FC0303FD0FFF00	  2740: 	move.w	#$0303,leds
00:000067D2 4CDF010D        	  2741: 	movem.l	(a7)+,d0/d2/d3/a0
00:000067D6 4E75            	  2742: 	rts
                            	  2743: .doKeyup:
00:000067D8 13FC00FF0010000F	  2744: 	move.b	#-1,_KeyState1
00:000067E0 6000FEB2        	  2745: 	bra		.0003
                            	  2746: .doExtend:
00:000067E4 0039008000100010	  2747: 	or.b	#$80,_KeyState2
00:000067EC 6000FEA6        	  2748: 	bra		.0003
                            	  2749: .doCtrl:
00:000067F0 12390010000F    	  2750: 	move.b	_KeyState1,d1
00:000067F6 42390010000F    	  2751: 	clr.b	_KeyState1
00:000067FC 4A01            	  2752: 	tst.b	d1
00:000067FE 6A0C            	  2753: 	bpl.s	.0004
00:00006800 08B9000200100010	  2754: 	bclr	#2,_KeyState2
00:00006808 6000FE8A        	  2755: 	bra		.0003
                            	  2756: .0004:
00:0000680C 08F9000200100010	  2757: 	bset	#2,_KeyState2
00:00006814 6000FE7E        	  2758: 	bra		.0003
                            	  2759: .doAlt:
00:00006818 12390010000F    	  2760: 	move.b	_KeyState1,d1
00:0000681E 42390010000F    	  2761: 	clr.b	_KeyState1
00:00006824 4A01            	  2762: 	tst.b	d1
00:00006826 6A0C            	  2763: 	bpl		.0011
00:00006828 08B9000100100010	  2764: 	bclr	#1,_KeyState2
00:00006830 6000FE62        	  2765: 	bra		.0003
                            	  2766: .0011:
00:00006834 08F9000100100010	  2767: 	bset	#1,_KeyState2
00:0000683C 6000FE56        	  2768: 	bra		.0003
                            	  2769: .doTab:
00:00006840 2F01            	  2770: 	move.l	d1,-(a7)
00:00006842 123900100010    	  2771:   move.b  _KeyState2,d1
00:00006848 08010001        	  2772:   btst	#1,d1                 ; is ALT down ?
00:0000684C 6706            	  2773:   beq     .0012
                            	  2774: ;    	inc     _iof_switch
00:0000684E 221F            	  2775:   move.l	(a7)+,d1
00:00006850 6000FE42        	  2776:   bra     .0003
                            	  2777: .0012:
00:00006854 221F            	  2778:   move.l	(a7)+,d1
00:00006856 6000FF1C        	  2779:   bra     .0013
                            	  2780: .doShift:
00:0000685A 12390010000F    	  2781: 	move.b	_KeyState1,d1
00:00006860 42390010000F    	  2782: 	clr.b	_KeyState1
00:00006866 4A01            	  2783: 	tst.b	d1
00:00006868 6A0C            	  2784: 	bpl.s	.0005
00:0000686A 08B9000000100010	  2785: 	bclr	#0,_KeyState2
00:00006872 6000FE20        	  2786: 	bra		.0003
                            	  2787: .0005:
00:00006876 08F9000000100010	  2788: 	bset	#0,_KeyState2
00:0000687E 6000FE14        	  2789: 	bra		.0003
                            	  2790: .doNumLock:
00:00006882 0879000400100010	  2791: 	bchg	#4,_KeyState2
00:0000688A 6120            	  2792: 	bsr		KeybdSetLEDStatus
00:0000688C 6000FE06        	  2793: 	bra		.0003
                            	  2794: .doCapsLock:
00:00006890 0879000500100010	  2795: 	bchg	#5,_KeyState2
00:00006898 6112            	  2796: 	bsr		KeybdSetLEDStatus
00:0000689A 6000FDF8        	  2797: 	bra		.0003
                            	  2798: .doScrollLock:
00:0000689E 0879000600100010	  2799: 	bchg	#6,_KeyState2
00:000068A6 6104            	  2800: 	bsr		KeybdSetLEDStatus
00:000068A8 6000FDEA        	  2801: 	bra		.0003
                            	  2802: 
                            	  2803: KeybdSetLEDStatus:
00:000068AC 48E73000        	  2804: 	movem.l	d2/d3,-(a7)
00:000068B0 42390010000E    	  2805: 	clr.b		KeybdLEDs
00:000068B6 0839000400100010	  2806: 	btst		#4,_KeyState2
00:000068BE 6708            	  2807: 	beq.s		.0002
00:000068C0 13FC00020010000E	  2808: 	move.b	#2,KeybdLEDs
                            	  2809: .0002:
00:000068C8 0839000500100010	  2810: 	btst		#5,_KeyState2
00:000068D0 6708            	  2811: 	beq.s		.0003
00:000068D2 08F900020010000E	  2812: 	bset		#2,KeybdLEDs
                            	  2813: .0003:
00:000068DA 0839000600100010	  2814: 	btst		#6,_KeyState2
00:000068E2 6708            	  2815: 	beq.s		.0004
00:000068E4 08F900000010000E	  2816: 	bset		#0,KeybdLEDs
                            	  2817: .0004:
00:000068EC 12390010000E    	  2818: 	move.b	KeybdLEDs,d1
00:000068F2 6100FB58        	  2819: 	bsr			KeybdSetLED
00:000068F6 4CDF000C        	  2820: 	movem.l	(a7)+,d2/d3
00:000068FA 4E75            	  2821: 	rts
                            	  2822: 
                            	  2823: KeybdSendByte:
00:000068FC 13C1FD0FFE00    	  2824: 	move.b d1,KEYBD
00:00006902 4E75            	  2825: 	rts
                            	  2826: 	
                            	  2827: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2828: ; Wait for 10 ms
                            	  2829: ;
                            	  2830: ; Parameters: none
                            	  2831: ; Returns: none
                            	  2832: ; Modifies: none
                            	  2833: ; Stack Space: 2 long words
                            	  2834: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2835: 
                            	  2836: Wait10ms:
00:00006904 48E7C000        	  2837: 	movem.l	d0/d1,-(a7)
00:00006908 4E7A0FF0        	  2838: 	movec	tick,d0
00:0000690C 068000061A80    	  2839: 	addi.l #400000,d0			; 400,000 cycles at 40MHz
                            	  2840: .0001:
00:00006912 4E7A1FF0        	  2841: 	movec	tick,d1
00:00006916 B081            	  2842: 	cmp.l	d1,d0
00:00006918 62F8            	  2843: 	bhi	.0001
00:0000691A 4CDF0003        	  2844: 	movem.l	(a7)+,d0/d1
00:0000691E 4E75            	  2845: 	rts
                            	  2846: 
                            	  2847: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2848: ; Wait for 300 ms
                            	  2849: ;
                            	  2850: ; Parameters: none
                            	  2851: ; Returns: none
                            	  2852: ; Modifies: none
                            	  2853: ; Stack Space: 2 long words
                            	  2854: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  2855: 
                            	  2856: Wait300ms:
00:00006920 48E7C000        	  2857: 	movem.l	d0/d1,-(a7)
00:00006924 4E7A0FF0        	  2858: 	movec		tick,d0
00:00006928 068000B71B00    	  2859: 	addi.l	#12000000,d0			; 12,000,000 cycles at 40MHz
                            	  2860: .0001:
00:0000692E 4E7A1FF0        	  2861: 	movec		tick,d1
00:00006932 B081            	  2862: 	cmp.l		d1,d0
00:00006934 62F8            	  2863: 	bhi			.0001
00:00006936 4CDF0003        	  2864: 	movem.l	(a7)+,d0/d1
00:0000693A 4E75            	  2865: 	rts
                            	  2866: 
                            	  2867: ;--------------------------------------------------------------------------
                            	  2868: ; Keyboard IRQ routine.
                            	  2869: ; - only core 2 processes keyboard interrupts.
                            	  2870: ; - the keyboard buffer is in shared global scratchpad space.
                            	  2871: ;
                            	  2872: ; Returns:
                            	  2873: ; 	d1 = -1 if keyboard routine handled interrupt, otherwise positive.
                            	  2874: ;--------------------------------------------------------------------------
                            	  2875: 
                            	  2876: KeybdIRQ:
00:0000693C 46FC2600        	  2877: 	move.w #$2600,sr					; disable lower interrupts
00:00006940 48E7C080        	  2878: 	movem.l	d0/d1/a0,-(a7)
00:00006944 46B9FD000000    	  2879: 	eori.l #-1,$FD000000
00:0000694A 7200            	  2880: 	moveq	#0,d1								; check if keyboard IRQ
00:0000694C 1239FD0FFE01    	  2881: 	move.b KEYBD+1,d1					; get status reg
00:00006952 4A01            	  2882: 	tst.b	d1
00:00006954 6A000096        	  2883: 	bpl	.0001									; branch if not keyboard
00:00006958 4E7A0FE0        	  2884: 	movec	coreno,d0
00:0000695C 4840            	  2885: 	swap d0
00:0000695E 7203            	  2886: 	moveq	#KEYBD_SEMA,d1
00:00006960 61009E46        	  2887: 	bsr LockSemaphore
00:00006964 1239FD0FFE00    	  2888: 	move.b KEYBD,d1						; get scan code
00:0000696A 4239FD0FFE01    	  2889: 	clr.b KEYBD+1							; clear status register (clears IRQ AND scancode)
00:00006970 0839000100100010	  2890: 	btst #1,_KeyState2				; Is Alt down?
00:00006978 6738            	  2891: 	beq.s	.0003
00:0000697A 0C01000D        	  2892: 	cmpi.b #SC_TAB,d1					; is Alt-Tab?
00:0000697E 6632            	  2893: 	bne.s	.0003
00:00006980 4E7A0FF0        	  2894: 	movec tick,d0
00:00006984 90B90001001C    	  2895: 	sub.l _Keybd_tick,d0
00:0000698A B0BC0000000A    	  2896: 	cmp.l #10,d0							; has it been 10 or more ticks?
                            	  2897: ;	blo.s .0002
00:00006990 4E7A0FF0        	  2898: 	movec tick,d0							; update tick of last ALT-Tab
00:00006994 23C00001001C    	  2899: 	move.l d0,_Keybd_tick
00:0000699A 6100F93A        	  2900: 	bsr	rotate_iofocus
00:0000699E 423900100011    	  2901: 	clr.b	_KeybdHead					; clear keyboard buffer
00:000069A4 423900100012    	  2902: 	clr.b	_KeybdTail
00:000069AA 423900100013    	  2903: 	clr.b	_KeybdCnt
00:000069B0 602E            	  2904: 	bra	.0002									; do not store Alt-Tab
                            	  2905: .0003:
                            	  2906: 	; Insert keyboard scan code into raw keyboard buffer
00:000069B2 0C39002000100013	  2907: 	cmpi.b #32,_KeybdCnt			; see if keyboard buffer full
00:000069BA 6424            	  2908: 	bhs.s	.0002
00:000069BC 103900100012    	  2909: 	move.b _KeybdTail,d0			; keyboard buffer not full, add to tail
00:000069C2 4880            	  2910: 	ext.w	d0
00:000069C4 41F900100020    	  2911: 	lea	_KeybdBuf,a0					; a0 = pointer to buffer
00:000069CA 11810000        	  2912: 	move.b d1,(a0,d0.w)				; put scancode in buffer
00:000069CE 5200            	  2913: 	addi.b #1,d0							; increment tail index
00:000069D0 0200001F        	  2914: 	andi.b #31,d0							; wrap at buffer limit
00:000069D4 13C000100012    	  2915: 	move.b d0,_KeybdTail			; update tail index
00:000069DA 523900100013    	  2916: 	addi.b #1,_KeybdCnt				; increment buffer count
                            	  2917: .0002:
00:000069E0 4E7A0FE0        	  2918: 	movec	coreno,d0
00:000069E4 4840            	  2919: 	swap d0
00:000069E6 7203            	  2920: 	moveq	#KEYBD_SEMA,d1
00:000069E8 61009DFA        	  2921: 	bsr	UnlockSemaphore
                            	  2922: .0001:
00:000069EC 4CDF0103        	  2923: 	movem.l	(a7)+,d0/d1/a0		; return
00:000069F0 4E73            	  2924: 	rte
                            	  2925: 
                            	  2926: ;--------------------------------------------------------------------------
                            	  2927: ; PS2 scan codes to ascii conversion tables.
                            	  2928: ;--------------------------------------------------------------------------
                            	  2929: ;
                            	  2930: _unshiftedScanCodes:
00:000069F2 2E              	  2931: 	dc.b	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
00:000069F3 A9
00:000069F4 2E
00:000069F5 A5
00:000069F6 A3
00:000069F7 A1
00:000069F8 A2
00:000069F9 AC
00:000069FA 2E              	  2932: 	dc.b	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
00:000069FB AA
00:000069FC A8
00:000069FD A6
00:000069FE A4
00:000069FF 09
00:00006A00 60
00:00006A01 2E
00:00006A02 2E              	  2933: 	dc.b	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
00:00006A03 2E
00:00006A04 2E
00:00006A05 2E
00:00006A06 2E
00:00006A07 71
00:00006A08 31
00:00006A09 2E
00:00006A0A 2E              	  2934: 	dc.b	$2e,$2e,$7a,$73,$61,$77,$32,$2e
00:00006A0B 2E
00:00006A0C 7A
00:00006A0D 73
00:00006A0E 61
00:00006A0F 77
00:00006A10 32
00:00006A11 2E
00:00006A12 2E              	  2935: 	dc.b	$2e,$63,$78,$64,$65,$34,$33,$2e
00:00006A13 63
00:00006A14 78
00:00006A15 64
00:00006A16 65
00:00006A17 34
00:00006A18 33
00:00006A19 2E
00:00006A1A 2E              	  2936: 	dc.b	$2e,$20,$76,$66,$74,$72,$35,$2e
00:00006A1B 20
00:00006A1C 76
00:00006A1D 66
00:00006A1E 74
00:00006A1F 72
00:00006A20 35
00:00006A21 2E
00:00006A22 2E              	  2937: 	dc.b	$2e,$6e,$62,$68,$67,$79,$36,$2e
00:00006A23 6E
00:00006A24 62
00:00006A25 68
00:00006A26 67
00:00006A27 79
00:00006A28 36
00:00006A29 2E
00:00006A2A 2E              	  2938: 	dc.b	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
00:00006A2B 2E
00:00006A2C 6D
00:00006A2D 6A
00:00006A2E 75
00:00006A2F 37
00:00006A30 38
00:00006A31 2E
00:00006A32 2E              	  2939: 	dc.b	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
00:00006A33 2C
00:00006A34 6B
00:00006A35 69
00:00006A36 6F
00:00006A37 30
00:00006A38 39
00:00006A39 2E
00:00006A3A 2E              	  2940: 	dc.b	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
00:00006A3B 2E
00:00006A3C 2F
00:00006A3D 6C
00:00006A3E 3B
00:00006A3F 70
00:00006A40 2D
00:00006A41 2E
00:00006A42 2E              	  2941: 	dc.b	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
00:00006A43 2E
00:00006A44 27
00:00006A45 2E
00:00006A46 5B
00:00006A47 3D
00:00006A48 2E
00:00006A49 2E
00:00006A4A AD              	  2942: 	dc.b	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
00:00006A4B 2E
00:00006A4C 0D
00:00006A4D 5D
00:00006A4E 2E
00:00006A4F 5C
00:00006A50 2E
00:00006A51 2E
00:00006A52 2E              	  2943: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:00006A53 2E
00:00006A54 2E
00:00006A55 2E
00:00006A56 2E
00:00006A57 2E
00:00006A58 08
00:00006A59 2E
00:00006A5A 2E              	  2944: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
00:00006A5B 95
00:00006A5C 2E
00:00006A5D 93
00:00006A5E 94
00:00006A5F 2E
00:00006A60 2E
00:00006A61 2E
00:00006A62 98              	  2945: 	dc.b	$98,$7f,$92,$2e,$91,$90,$1b,$af
00:00006A63 7F
00:00006A64 92
00:00006A65 2E
00:00006A66 91
00:00006A67 90
00:00006A68 1B
00:00006A69 AF
00:00006A6A AB              	  2946: 	dc.b	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
00:00006A6B 2E
00:00006A6C 97
00:00006A6D 2E
00:00006A6E 2E
00:00006A6F 96
00:00006A70 AE
00:00006A71 2E
                            	  2947: 
00:00006A72 2E              	  2948: 	dc.b	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
00:00006A73 2E
00:00006A74 2E
00:00006A75 A7
00:00006A76 2E
00:00006A77 2E
00:00006A78 2E
00:00006A79 2E
00:00006A7A 2E              	  2949: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006A7B 2E
00:00006A7C 2E
00:00006A7D 2E
00:00006A7E 2E
00:00006A7F 2E
00:00006A80 2E
00:00006A81 2E
00:00006A82 2E              	  2950: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006A83 2E
00:00006A84 2E
00:00006A85 2E
00:00006A86 2E
00:00006A87 2E
00:00006A88 2E
00:00006A89 2E
00:00006A8A 2E              	  2951: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006A8B 2E
00:00006A8C 2E
00:00006A8D 2E
00:00006A8E 2E
00:00006A8F 2E
00:00006A90 2E
00:00006A91 2E
00:00006A92 2E              	  2952: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006A93 2E
00:00006A94 2E
00:00006A95 2E
00:00006A96 2E
00:00006A97 2E
00:00006A98 2E
00:00006A99 2E
00:00006A9A 2E              	  2953: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006A9B 2E
00:00006A9C 2E
00:00006A9D 2E
00:00006A9E 2E
00:00006A9F 2E
00:00006AA0 2E
00:00006AA1 2E
00:00006AA2 2E              	  2954: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006AA3 2E
00:00006AA4 2E
00:00006AA5 2E
00:00006AA6 2E
00:00006AA7 2E
00:00006AA8 2E
00:00006AA9 2E
00:00006AAA 2E              	  2955: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006AAB 2E
00:00006AAC 2E
00:00006AAD 2E
00:00006AAE 2E
00:00006AAF 2E
00:00006AB0 2E
00:00006AB1 2E
00:00006AB2 2E              	  2956: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006AB3 2E
00:00006AB4 2E
00:00006AB5 2E
00:00006AB6 2E
00:00006AB7 2E
00:00006AB8 2E
00:00006AB9 2E
00:00006ABA 2E              	  2957: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006ABB 2E
00:00006ABC 2E
00:00006ABD 2E
00:00006ABE 2E
00:00006ABF 2E
00:00006AC0 2E
00:00006AC1 2E
00:00006AC2 2E              	  2958: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006AC3 2E
00:00006AC4 2E
00:00006AC5 2E
00:00006AC6 2E
00:00006AC7 2E
00:00006AC8 2E
00:00006AC9 2E
00:00006ACA 2E              	  2959: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006ACB 2E
00:00006ACC 2E
00:00006ACD 2E
00:00006ACE 2E
00:00006ACF 2E
00:00006AD0 2E
00:00006AD1 2E
00:00006AD2 2E              	  2960: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006AD3 2E
00:00006AD4 2E
00:00006AD5 2E
00:00006AD6 2E
00:00006AD7 2E
00:00006AD8 2E
00:00006AD9 2E
00:00006ADA 2E              	  2961: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006ADB 2E
00:00006ADC 2E
00:00006ADD 2E
00:00006ADE 2E
00:00006ADF 2E
00:00006AE0 2E
00:00006AE1 2E
00:00006AE2 2E              	  2962: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006AE3 2E
00:00006AE4 2E
00:00006AE5 2E
00:00006AE6 2E
00:00006AE7 2E
00:00006AE8 2E
00:00006AE9 2E
00:00006AEA 2E              	  2963: 	dc.b	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
00:00006AEB 2E
00:00006AEC FA
00:00006AED 2E
00:00006AEE 2E
00:00006AEF 2E
00:00006AF0 2E
00:00006AF1 2E
                            	  2964: 
                            	  2965: _shiftedScanCodes:
00:00006AF2 2E              	  2966: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006AF3 2E
00:00006AF4 2E
00:00006AF5 2E
00:00006AF6 2E
00:00006AF7 2E
00:00006AF8 2E
00:00006AF9 2E
00:00006AFA 2E              	  2967: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
00:00006AFB 2E
00:00006AFC 2E
00:00006AFD 2E
00:00006AFE 2E
00:00006AFF 09
00:00006B00 7E
00:00006B01 2E
00:00006B02 2E              	  2968: 	dc.b	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
00:00006B03 2E
00:00006B04 2E
00:00006B05 2E
00:00006B06 2E
00:00006B07 51
00:00006B08 21
00:00006B09 2E
00:00006B0A 2E              	  2969: 	dc.b	$2e,$2e,$5a,$53,$41,$57,$40,$2e
00:00006B0B 2E
00:00006B0C 5A
00:00006B0D 53
00:00006B0E 41
00:00006B0F 57
00:00006B10 40
00:00006B11 2E
00:00006B12 2E              	  2970: 	dc.b	$2e,$43,$58,$44,$45,$24,$23,$2e
00:00006B13 43
00:00006B14 58
00:00006B15 44
00:00006B16 45
00:00006B17 24
00:00006B18 23
00:00006B19 2E
00:00006B1A 2E              	  2971: 	dc.b	$2e,$20,$56,$46,$54,$52,$25,$2e
00:00006B1B 20
00:00006B1C 56
00:00006B1D 46
00:00006B1E 54
00:00006B1F 52
00:00006B20 25
00:00006B21 2E
00:00006B22 2E              	  2972: 	dc.b	$2e,$4e,$42,$48,$47,$59,$5e,$2e
00:00006B23 4E
00:00006B24 42
00:00006B25 48
00:00006B26 47
00:00006B27 59
00:00006B28 5E
00:00006B29 2E
00:00006B2A 2E              	  2973: 	dc.b	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
00:00006B2B 2E
00:00006B2C 4D
00:00006B2D 4A
00:00006B2E 55
00:00006B2F 26
00:00006B30 2A
00:00006B31 2E
00:00006B32 2E              	  2974: 	dc.b	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
00:00006B33 3C
00:00006B34 4B
00:00006B35 49
00:00006B36 4F
00:00006B37 29
00:00006B38 28
00:00006B39 2E
00:00006B3A 2E              	  2975: 	dc.b	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
00:00006B3B 3E
00:00006B3C 3F
00:00006B3D 4C
00:00006B3E 3A
00:00006B3F 50
00:00006B40 5F
00:00006B41 2E
00:00006B42 2E              	  2976: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
00:00006B43 2E
00:00006B44 22
00:00006B45 2E
00:00006B46 7B
00:00006B47 2B
00:00006B48 2E
00:00006B49 2E
00:00006B4A 2E              	  2977: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
00:00006B4B 2E
00:00006B4C 0D
00:00006B4D 7D
00:00006B4E 2E
00:00006B4F 7C
00:00006B50 2E
00:00006B51 2E
00:00006B52 2E              	  2978: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:00006B53 2E
00:00006B54 2E
00:00006B55 2E
00:00006B56 2E
00:00006B57 2E
00:00006B58 08
00:00006B59 2E
00:00006B5A 2E              	  2979: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006B5B 2E
00:00006B5C 2E
00:00006B5D 2E
00:00006B5E 2E
00:00006B5F 2E
00:00006B60 2E
00:00006B61 2E
00:00006B62 2E              	  2980: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
00:00006B63 7F
00:00006B64 2E
00:00006B65 2E
00:00006B66 2E
00:00006B67 2E
00:00006B68 1B
00:00006B69 2E
00:00006B6A 2E              	  2981: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006B6B 2E
00:00006B6C 2E
00:00006B6D 2E
00:00006B6E 2E
00:00006B6F 2E
00:00006B70 2E
00:00006B71 2E
                            	  2982: 
00:00006B72 2E              	  2983: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006B73 2E
00:00006B74 2E
00:00006B75 2E
00:00006B76 2E
00:00006B77 2E
00:00006B78 2E
00:00006B79 2E
00:00006B7A 2E              	  2984: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006B7B 2E
00:00006B7C 2E
00:00006B7D 2E
00:00006B7E 2E
00:00006B7F 2E
00:00006B80 2E
00:00006B81 2E
00:00006B82 2E              	  2985: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006B83 2E
00:00006B84 2E
00:00006B85 2E
00:00006B86 2E
00:00006B87 2E
00:00006B88 2E
00:00006B89 2E
00:00006B8A 2E              	  2986: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006B8B 2E
00:00006B8C 2E
00:00006B8D 2E
00:00006B8E 2E
00:00006B8F 2E
00:00006B90 2E
00:00006B91 2E
00:00006B92 2E              	  2987: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006B93 2E
00:00006B94 2E
00:00006B95 2E
00:00006B96 2E
00:00006B97 2E
00:00006B98 2E
00:00006B99 2E
00:00006B9A 2E              	  2988: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006B9B 2E
00:00006B9C 2E
00:00006B9D 2E
00:00006B9E 2E
00:00006B9F 2E
00:00006BA0 2E
00:00006BA1 2E
00:00006BA2 2E              	  2989: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006BA3 2E
00:00006BA4 2E
00:00006BA5 2E
00:00006BA6 2E
00:00006BA7 2E
00:00006BA8 2E
00:00006BA9 2E
00:00006BAA 2E              	  2990: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006BAB 2E
00:00006BAC 2E
00:00006BAD 2E
00:00006BAE 2E
00:00006BAF 2E
00:00006BB0 2E
00:00006BB1 2E
00:00006BB2 2E              	  2991: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006BB3 2E
00:00006BB4 2E
00:00006BB5 2E
00:00006BB6 2E
00:00006BB7 2E
00:00006BB8 2E
00:00006BB9 2E
00:00006BBA 2E              	  2992: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006BBB 2E
00:00006BBC 2E
00:00006BBD 2E
00:00006BBE 2E
00:00006BBF 2E
00:00006BC0 2E
00:00006BC1 2E
00:00006BC2 2E              	  2993: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006BC3 2E
00:00006BC4 2E
00:00006BC5 2E
00:00006BC6 2E
00:00006BC7 2E
00:00006BC8 2E
00:00006BC9 2E
00:00006BCA 2E              	  2994: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006BCB 2E
00:00006BCC 2E
00:00006BCD 2E
00:00006BCE 2E
00:00006BCF 2E
00:00006BD0 2E
00:00006BD1 2E
00:00006BD2 2E              	  2995: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006BD3 2E
00:00006BD4 2E
00:00006BD5 2E
00:00006BD6 2E
00:00006BD7 2E
00:00006BD8 2E
00:00006BD9 2E
00:00006BDA 2E              	  2996: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006BDB 2E
00:00006BDC 2E
00:00006BDD 2E
00:00006BDE 2E
00:00006BDF 2E
00:00006BE0 2E
00:00006BE1 2E
00:00006BE2 2E              	  2997: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006BE3 2E
00:00006BE4 2E
00:00006BE5 2E
00:00006BE6 2E
00:00006BE7 2E
00:00006BE8 2E
00:00006BE9 2E
00:00006BEA 2E              	  2998: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006BEB 2E
00:00006BEC 2E
00:00006BED 2E
00:00006BEE 2E
00:00006BEF 2E
00:00006BF0 2E
00:00006BF1 2E
                            	  2999: 
                            	  3000: ; control
                            	  3001: _keybdControlCodes:
00:00006BF2 2E              	  3002: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006BF3 2E
00:00006BF4 2E
00:00006BF5 2E
00:00006BF6 2E
00:00006BF7 2E
00:00006BF8 2E
00:00006BF9 2E
00:00006BFA 2E              	  3003: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
00:00006BFB 2E
00:00006BFC 2E
00:00006BFD 2E
00:00006BFE 2E
00:00006BFF 09
00:00006C00 7E
00:00006C01 2E
00:00006C02 2E              	  3004: 	dc.b	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
00:00006C03 2E
00:00006C04 2E
00:00006C05 2E
00:00006C06 2E
00:00006C07 11
00:00006C08 21
00:00006C09 2E
00:00006C0A 2E              	  3005: 	dc.b	$2e,$2e,$1a,$13,$01,$17,$40,$2e
00:00006C0B 2E
00:00006C0C 1A
00:00006C0D 13
00:00006C0E 01
00:00006C0F 17
00:00006C10 40
00:00006C11 2E
00:00006C12 2E              	  3006: 	dc.b	$2e,$03,$18,$04,$05,$24,$23,$2e
00:00006C13 03
00:00006C14 18
00:00006C15 04
00:00006C16 05
00:00006C17 24
00:00006C18 23
00:00006C19 2E
00:00006C1A 2E              	  3007: 	dc.b	$2e,$20,$16,$06,$14,$12,$25,$2e
00:00006C1B 20
00:00006C1C 16
00:00006C1D 06
00:00006C1E 14
00:00006C1F 12
00:00006C20 25
00:00006C21 2E
00:00006C22 2E              	  3008: 	dc.b	$2e,$0e,$02,$08,$07,$19,$5e,$2e
00:00006C23 0E
00:00006C24 02
00:00006C25 08
00:00006C26 07
00:00006C27 19
00:00006C28 5E
00:00006C29 2E
00:00006C2A 2E              	  3009: 	dc.b	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
00:00006C2B 2E
00:00006C2C 0D
00:00006C2D 0A
00:00006C2E 15
00:00006C2F 26
00:00006C30 2A
00:00006C31 2E
00:00006C32 2E              	  3010: 	dc.b	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
00:00006C33 3C
00:00006C34 0B
00:00006C35 09
00:00006C36 0F
00:00006C37 29
00:00006C38 28
00:00006C39 2E
00:00006C3A 2E              	  3011: 	dc.b	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
00:00006C3B 3E
00:00006C3C 3F
00:00006C3D 0C
00:00006C3E 3A
00:00006C3F 10
00:00006C40 5F
00:00006C41 2E
00:00006C42 2E              	  3012: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
00:00006C43 2E
00:00006C44 22
00:00006C45 2E
00:00006C46 7B
00:00006C47 2B
00:00006C48 2E
00:00006C49 2E
00:00006C4A 2E              	  3013: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
00:00006C4B 2E
00:00006C4C 0D
00:00006C4D 7D
00:00006C4E 2E
00:00006C4F 7C
00:00006C50 2E
00:00006C51 2E
00:00006C52 2E              	  3014: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:00006C53 2E
00:00006C54 2E
00:00006C55 2E
00:00006C56 2E
00:00006C57 2E
00:00006C58 08
00:00006C59 2E
00:00006C5A 2E              	  3015: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006C5B 2E
00:00006C5C 2E
00:00006C5D 2E
00:00006C5E 2E
00:00006C5F 2E
00:00006C60 2E
00:00006C61 2E
00:00006C62 2E              	  3016: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
00:00006C63 7F
00:00006C64 2E
00:00006C65 2E
00:00006C66 2E
00:00006C67 2E
00:00006C68 1B
00:00006C69 2E
00:00006C6A 2E              	  3017: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006C6B 2E
00:00006C6C 2E
00:00006C6D 2E
00:00006C6E 2E
00:00006C6F 2E
00:00006C70 2E
00:00006C71 2E
                            	  3018: 
                            	  3019: _keybdExtendedCodes:
00:00006C72 2E              	  3020: 	dc.b	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
00:00006C73 2E
00:00006C74 2E
00:00006C75 2E
00:00006C76 A3
00:00006C77 A1
00:00006C78 A2
00:00006C79 2E
00:00006C7A 2E              	  3021: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006C7B 2E
00:00006C7C 2E
00:00006C7D 2E
00:00006C7E 2E
00:00006C7F 2E
00:00006C80 2E
00:00006C81 2E
00:00006C82 2E              	  3022: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006C83 2E
00:00006C84 2E
00:00006C85 2E
00:00006C86 2E
00:00006C87 2E
00:00006C88 2E
00:00006C89 2E
00:00006C8A 2E              	  3023: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006C8B 2E
00:00006C8C 2E
00:00006C8D 2E
00:00006C8E 2E
00:00006C8F 2E
00:00006C90 2E
00:00006C91 2E
00:00006C92 2E              	  3024: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006C93 2E
00:00006C94 2E
00:00006C95 2E
00:00006C96 2E
00:00006C97 2E
00:00006C98 2E
00:00006C99 2E
00:00006C9A 2E              	  3025: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006C9B 2E
00:00006C9C 2E
00:00006C9D 2E
00:00006C9E 2E
00:00006C9F 2E
00:00006CA0 2E
00:00006CA1 2E
00:00006CA2 2E              	  3026: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006CA3 2E
00:00006CA4 2E
00:00006CA5 2E
00:00006CA6 2E
00:00006CA7 2E
00:00006CA8 2E
00:00006CA9 2E
00:00006CAA 2E              	  3027: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006CAB 2E
00:00006CAC 2E
00:00006CAD 2E
00:00006CAE 2E
00:00006CAF 2E
00:00006CB0 2E
00:00006CB1 2E
00:00006CB2 2E              	  3028: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006CB3 2E
00:00006CB4 2E
00:00006CB5 2E
00:00006CB6 2E
00:00006CB7 2E
00:00006CB8 2E
00:00006CB9 2E
00:00006CBA 2E              	  3029: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006CBB 2E
00:00006CBC 2E
00:00006CBD 2E
00:00006CBE 2E
00:00006CBF 2E
00:00006CC0 2E
00:00006CC1 2E
00:00006CC2 2E              	  3030: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006CC3 2E
00:00006CC4 2E
00:00006CC5 2E
00:00006CC6 2E
00:00006CC7 2E
00:00006CC8 2E
00:00006CC9 2E
00:00006CCA 2E              	  3031: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006CCB 2E
00:00006CCC 2E
00:00006CCD 2E
00:00006CCE 2E
00:00006CCF 2E
00:00006CD0 2E
00:00006CD1 2E
00:00006CD2 2E              	  3032: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00006CD3 2E
00:00006CD4 2E
00:00006CD5 2E
00:00006CD6 2E
00:00006CD7 2E
00:00006CD8 2E
00:00006CD9 2E
00:00006CDA 2E              	  3033: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
00:00006CDB 95
00:00006CDC 2E
00:00006CDD 93
00:00006CDE 94
00:00006CDF 2E
00:00006CE0 2E
00:00006CE1 2E
00:00006CE2 98              	  3034: 	dc.b	$98,$99,$92,$2e,$91,$90,$2e,$2e
00:00006CE3 99
00:00006CE4 92
00:00006CE5 2E
00:00006CE6 91
00:00006CE7 90
00:00006CE8 2E
00:00006CE9 2E
00:00006CEA 2E              	  3035: 	dc.b	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
00:00006CEB 2E
00:00006CEC 97
00:00006CED 2E
00:00006CEE 2E
00:00006CEF 96
00:00006CF0 2E
00:00006CF1 2E
                            	  3036: 
                            	  3037: ;==============================================================================
                            	  3038: ;==============================================================================
                            	  3039: ; Monitor
                            	  3040: ;==============================================================================
                            	  3041: ;==============================================================================
                            	  3042: 
                            	  3043: cmdString:
00:00006CF2 BF              	  3044: 	dc.b	'?'+$80						; ? display help
00:00006CF3 41              	  3045: 	dc.b	'A','S'+$80				; AS = asteroids
00:00006CF4 D3
00:00006CF5 CC              	  3046: 	dc.b	'L'+$80						; L load S19 file
00:00006CF6 46              	  3047: 	dc.b	'F','B'+$80				; FB fill with byte
00:00006CF7 C2
00:00006CF8 46              	  3048: 	dc.b	'F','W'+$80				; FW fill with wyde
00:00006CF9 D7
00:00006CFA 46              	  3049: 	dc.b	'F','L'+$80				; FL fill with long wyde
00:00006CFB CC
00:00006CFC 464D54          	  3050: 	dc.b	'FMT','K'+$80			; FMTK run Femtiki OS
00:00006CFF CB
00:00006D00 42              	  3051: 	dc.b	'B','A'+$80				; BA start Tiny Basic
00:00006D01 C1
00:00006D02 42              	  3052: 	dc.b	'B','R'+$80				; BR breakpoint
00:00006D03 D2
00:00006D04 44              	  3053: 	dc.b	'D','I'+$80				; DI disassemble
00:00006D05 C9
00:00006D06 44              	  3054: 	dc.b	'D','R'+$80				; DR dump registers
00:00006D07 D2
00:00006D08 C4              	  3055: 	dc.b	'D'+$80						; D dump memory
00:00006D09 CA              	  3056: 	dc.b	'J'+$80						; J jump to code
00:00006D0A C5              	  3057: 	dc.b	'E'+$80						; : edit memory
00:00006D0B 434C            	  3058: 	dc.b	"CL",'S'+$80			; CLS clear screen
00:00006D0D D3
00:00006D0E 434F52          	  3059: 	dc.b	"COR",'E'+$80			; CORE <n> switch to core
00:00006D11 C5
00:00006D12 5446            	  3060: 	dc.b	"TF",'P'+$80			; TFP test fp
00:00006D14 D0
00:00006D15 5447            	  3061: 	dc.b  "TG",'F'+$80			; TGF test get float
00:00006D17 C6
00:00006D18 545241          	  3062: 	dc.b  "TRA",'M'+$80			; TRAM test RAM
00:00006D1B CD
00:00006D1C 54              	  3063: 	dc.b	'T','R'+$80				; TR test serial receive
00:00006D1D D2
00:00006D1E D4              	  3064: 	dc.b	'T'+$80						; T test CPU
00:00006D1F D3              	  3065: 	dc.b	'S'+$80						; S send serial
00:00006D20 52455345        	  3066: 	dc.b	"RESE",'T'+$80		; RESET <n>
00:00006D24 D4
00:00006D25 434C4F43        	  3067: 	dc.b	"CLOC",'K'+$80		; CLOCK <n>
00:00006D29 CB
00:00006D2A D2              	  3068: 	dc.b	'R'+$80						; R receive serial
00:00006D2B D6              	  3069: 	dc.b	'V'+$80
                            	  3070: 
                            	  3071: 	align	2
                            	  3072: cmdTable:
00:00006D2C 00007024        	  3073: 	dc.l	cmdHelp
00:00006D30 00006EA6        	  3074: 	dc.l	cmdAsteroids
00:00006D34 00007D9C        	  3075: 	dc.l	cmdLoadS19
00:00006D38 000072E0        	  3076: 	dc.l	cmdFillB
00:00006D3C 00007334        	  3077: 	dc.l	cmdFillW
00:00006D40 00007388        	  3078: 	dc.l	cmdFillL
00:00006D44 00006EF2        	  3079: 	dc.l	cmdFMTK
00:00006D48 00006EAE        	  3080: 	dc.l	cmdTinyBasic
00:00006D4C 00006E82        	  3081: 	dc.l	cmdBreakpoint
00:00006D50 0000749A        	  3082: 	dc.l	cmdDisassemble
00:00006D54 000075B4        	  3083: 	dc.l	cmdDumpRegs
00:00006D58 000074EA        	  3084: 	dc.l	cmdDumpMemory
00:00006D5C 0000748A        	  3085: 	dc.l	cmdJump
00:00006D60 00007434        	  3086: 	dc.l	cmdEditMemory
00:00006D64 00006EC2        	  3087: 	dc.l	cmdClearScreen
00:00006D68 00006ECE        	  3088: 	dc.l	cmdCore
00:00006D6C 00006EFA        	  3089: 	dc.l  cmdTestFP
00:00006D70 00006F86        	  3090: 	dc.l	cmdTestGF
00:00006D74 00007CDA        	  3091: 	dc.l  cmdTestRAM
00:00006D78 0000765E        	  3092: 	dc.l	cmdTestSerialReceive
00:00006D7C 00006EB2        	  3093: 	dc.l	cmdTestCPU
00:00006D80 0000727C        	  3094: 	dc.l	cmdSendSerial
00:00006D84 00006FD2        	  3095: 	dc.l	cmdReset
00:00006D88 00006FB4        	  3096: 	dc.l	cmdClock
00:00006D8C 000072AC        	  3097: 	dc.l	cmdReceiveSerial	
00:00006D90 00006E42        	  3098: 	dc.l	cmdVideoMode
00:00006D94 00006DAC        	  3099: 	dc.l	cmdMonitor
                            	  3100: 
                            	  3101: ; Get a word from screen memory and swap byte order
                            	  3102: 
                            	  3103: FromScreen:
00:00006D98 2210            	  3104: 	move.l (a0),d1
00:00006D9A 61001218        	  3105: 	bsr	rbo
                            	  3106: 	if (SCREEN_FORMAT==1)
00:00006D9E 5888            	  3107: 		lea	4(a0),a0	; increment screen pointer
                            	  3108: 	else
                            	  3109: 		lea	8(a0),a0	; increment screen pointer
                            	  3110: 	endif
00:00006DA0 4E75            	  3111: 	rts
                            	  3112: 
                            	  3113: StartMon:
00:00006DA2 427900040202    	  3114: 	clr.w	NumSetBreakpoints
00:00006DA8 610018AA        	  3115: 	bsr	ClearBreakpointList
                            	  3116: cmdMonitor:
                            	  3117: Monitor:
                            	  3118: 	; Reset the stack pointer on each entry into the monitor
00:00006DAC 2E7C00040FFC    	  3119: 	move.l #$40FFC,sp		; reset core's stack
00:00006DB2 46FC2200        	  3120: 	move.w #$2200,sr		; enable level 2 and higher interrupts
00:00006DB6 4E7A0FE0        	  3121: 	movec	coreno,d0
00:00006DBA 4840            	  3122: 	swap d0
00:00006DBC 7201            	  3123: 	moveq	#1,d1
00:00006DBE 61009A24        	  3124: 	bsr	UnlockSemaphore
00:00006DC2 42390004000C    	  3125: 	clr.b KeybdEcho			; turn off keyboard echo
                            	  3126: PromptLn:
00:00006DC8 6100EC9C        	  3127: 	bsr	CRLF
00:00006DCC 123C0024        	  3128: 	move.b #'$',d1
00:00006DD0 610019B8        	  3129: 	bsr OutputChar
                            	  3130: 
                            	  3131: ; Get characters until a CR is keyed
                            	  3132: ;
                            	  3133: Prompt3:
00:00006DD4 6100F862        	  3134: 	bsr	GetKey
00:00006DD8 0C0100FF        	  3135: 	cmpi.b #-1,d1
00:00006DDC 67F6            	  3136: 	beq.s	Prompt3
00:00006DDE 0C01000D        	  3137: 	cmpi.b #CR,d1
00:00006DE2 6706            	  3138: 	beq.s	Prompt1
00:00006DE4 610019A4        	  3139: 	bsr	OutputChar
00:00006DE8 60EA            	  3140: 	bra.s	Prompt3
                            	  3141: 
                            	  3142: ; Process the screen line that the CR was keyed on
                            	  3143: 
                            	  3144: Prompt1:
00:00006DEA 423900040001    	  3145: 	clr.b	CursorCol				; go back to the start of the line
00:00006DF0 6100ECB8        	  3146: 	bsr	CalcScreenLoc			; a0 = screen memory location
                            	  3147: .0001:
00:00006DF4 61A2            	  3148: 	bsr	FromScreen				; grab character off screen
00:00006DF6 0C010024        	  3149: 	cmpi.b #'$',d1				; skip over '$' prompt character
00:00006DFA 67F8            	  3150: 	beq.s	.0001
                            	  3151: 	
                            	  3152: ; Dispatch based on command string
                            	  3153: 
                            	  3154: cmdDispatch:
00:00006DFC 45FAFEF4        	  3155: 	lea	cmdString,a2
00:00006E00 7800            	  3156: 	clr.l	d4							; command counter
                            	  3157: 	if (SCREEN_FORMAT==1)
00:00006E02 5988            	  3158: 		lea	-4(a0),a0				; backup a character
                            	  3159: 	else
                            	  3160: 		lea	-8(a0),a0				; backup a character
                            	  3161: 	endif
00:00006E04 2648            	  3162: 	move.l	a0,a3					; a3 = start of command on screen
                            	  3163: .checkNextCmd:
00:00006E06 6190            	  3164: 	bsr	FromScreen				; d1 = char from input screen
00:00006E08 1A1A            	  3165: 	move.b (a2)+,d5
00:00006E0A BB01            	  3166: 	eor.b	d5,d1						; does it match with command string?
00:00006E0C 67F8            	  3167: 	beq.s	.checkNextCmd		; If it does, keep matching for longest match
00:00006E0E 0C010080        	  3168: 	cmpi.b #$80,d1				; didn't match, was it the end of the command?
00:00006E12 6724            	  3169: 	beq.s	.foundCmd
00:00006E14 4A2AFFFF        	  3170: 	tst.b	-1(a2)					; was end of table hit?
00:00006E18 6712            	  3171: 	beq.s	.endOfTable
00:00006E1A 5844            	  3172: 	addi.w #4,d4					; increment command counter
00:00006E1C 204B            	  3173: 	move.l a3,a0					; reset input pointer
00:00006E1E 4A2AFFFF        	  3174: 	tst.b	-1(a2)					; were we at the end of the command?
00:00006E22 6BE2            	  3175: 	bmi.s	.checkNextCmd		; if were at end continue, otherwise scan for end of cmd
                            	  3176: .scanToEndOfCmd
00:00006E24 4A1A            	  3177: 	tst.b	(a2)+						; scan to end of command
00:00006E26 6704            	  3178: 	beq.s	.endOfTable
00:00006E28 6AFA            	  3179: 	bpl.s	.scanToEndOfCmd
00:00006E2A 6BDA            	  3180: 	bmi.s	.checkNextCmd
                            	  3181: .endOfTable
00:00006E2C 43FA0388        	  3182: 	lea	msgUnknownCmd,a1
00:00006E30 6100EEFC        	  3183: 	bsr	DisplayStringCRLF
00:00006E34 6000FF76        	  3184: 	bra	Monitor
                            	  3185: .foundCmd:
00:00006E38 43FAFEF2        	  3186: 	lea	cmdTable,a1				; a1 = pointer to command address table
00:00006E3C 22714000        	  3187: 	move.l (a1,d4.w),a1		; fetch command routine address from table
00:00006E40 4ED1            	  3188: 	jmp	(a1)							; go execute command
                            	  3189: 
                            	  3190: cmdVideoMode:
00:00006E42 61000590        	  3191: 	bsr ignBlanks
00:00006E46 61000836        	  3192: 	bsr GetHexNumber
00:00006E4A 4A01            	  3193: 	cmpi.b #0,d1
00:00006E4C 660C            	  3194: 	bne.s .0001
00:00006E4E 6100EB6C        	  3195: 	bsr set_text_mode
00:00006E52 6100EBD6        	  3196: 	bsr clear_screen
00:00006E56 6000FF54        	  3197: 	bra Monitor
                            	  3198: .0001:
00:00006E5A 6100EB8A        	  3199: 	bsr set_graphics_mode
00:00006E5E 6100EBC2        	  3200: 	bsr get_screen_address
00:00006E62 42B9FD0FFD04    	  3201: 	move.l #0,RAND+4		; select stream 0
00:00006E68 343C1D4B        	  3202: 	move.w #7499,d2
                            	  3203: .0002:
00:00006E6C 2239FD0FFD00    	  3204: 	move.l RAND,d1
00:00006E72 42B9FD0FFD00    	  3205: 	move.l #0,RAND			; cause new number generation
00:00006E78 20C1            	  3206: 	move.l d1,(a0)+			; random display
00:00006E7A 51CAFFF0        	  3207: 	dbra d2,.0002
00:00006E7E 6000FF2C        	  3208: 	bra Monitor
                            	  3209: 
                            	  3210: cmdBreakpoint:
00:00006E82 61000550        	  3211: 	bsr	ignBlanks
00:00006E86 6100FF10        	  3212: 	bsr	FromScreen
00:00006E8A 0C01002B        	  3213: 	cmpi.b	#'+',d1
00:00006E8E 670016D2        	  3214: 	beq	ArmBreakpoint
00:00006E92 0C01002D        	  3215: 	cmpi.b	#'-',d1
00:00006E96 67001748        	  3216: 	beq	DisarmBreakpoint
00:00006E9A 0C01004C        	  3217: 	cmpi.b	#'L',d1
00:00006E9E 67001794        	  3218: 	beq	ListBreakpoints
00:00006EA2 6000FF08        	  3219: 	bra	Monitor
                            	  3220: 
                            	  3221: cmdAsteroids:
00:00006EA6 487AFF04        	  3222: 	pea Monitor
00:00006EAA 60002896        	  3223: 	jmp asteroids_start
                            	  3224: 
                            	  3225: cmdTinyBasic:
00:00006EAE 6000D542        	  3226: 	bra	CSTART
                            	  3227: 
                            	  3228: cmdTestCPU:
00:00006EB2 610099CE        	  3229: 	bsr	cpu_test
00:00006EB6 43FA1AC9        	  3230: 	lea	msg_test_done,a1
00:00006EBA 6100EE72        	  3231: 	bsr	DisplayStringCRLF
00:00006EBE 6000FEEC        	  3232: 	bra	Monitor
                            	  3233: 
                            	  3234: cmdClearScreen:
00:00006EC2 610010EA        	  3235: 	bsr	ClearScreen
00:00006EC6 6100EE92        	  3236: 	bsr	HomeCursor
00:00006ECA 6000FEE0        	  3237: 	bra	Monitor
                            	  3238: 
                            	  3239: cmdCore:
00:00006ECE 61000504        	  3240: 	bsr			ignBlanks
00:00006ED2 6100FEC4        	  3241: 	bsr			FromScreen
00:00006ED6 0C010032        	  3242: 	cmpi.b	#'2',d1					; check range
00:00006EDA 6500FED0        	  3243: 	blo			Monitor
00:00006EDE 0C010035        	  3244: 	cmpi.b	#'0'+NCORES+1,d1
00:00006EE2 6200FEC8        	  3245: 	bhi			Monitor
00:00006EE6 04010030        	  3246: 	subi.b	#'0',d1					; convert ascii to binary
00:00006EEA 6100F3D8        	  3247: 	bsr			select_iofocus
00:00006EEE 6000FEBC        	  3248: 	bra			Monitor
                            	  3249: 
                            	  3250: cmdFMTK:
00:00006EF2 6100932C        	  3251: 	bsr FemtikiInit
00:00006EF6 6000FEB4        	  3252: 	bra Monitor
                            	  3253: 
                            	  3254: cmdTestFP:
00:00006EFA 7029            	  3255: 	moveq #41,d0						; function #41, get float
00:00006EFC 7208            	  3256: 	moveq #8,d1							; d1 = input stride
00:00006EFE 2248            	  3257: 	move.l a0,a1						; a1 = pointer to input buffer
00:00006F00 4E4F            	  3258: 	trap #15
00:00006F02 2049            	  3259: 	move.l a1,a0
00:00006F04 F2000200        	  3260: 	fmove.x fp0,fp4
00:00006F08 610004CA        	  3261: 	bsr ignBlanks
00:00006F0C 6100FE8A        	  3262: 	bsr FromScreen
00:00006F10 1E01            	  3263: 	move.b d1,d7
00:00006F12 7029            	  3264: 	moveq #41,d0						; function #41, get float
00:00006F14 7208            	  3265: 	move.l #8,d1						; d1 = input stride
00:00006F16 2248            	  3266: 	move.l a0,a1						; a1 = pointer to input buffer
00:00006F18 4E4F            	  3267: 	trap #15
00:00006F1A 2049            	  3268: 	move.l a1,a0
00:00006F1C F2000100        	  3269: 	fmove.x fp0,fp2
00:00006F20 6100EB44        	  3270: 	bsr CRLF
                            	  3271: ;	moveq #39,d0
                            	  3272: ;	moveq #40,d1
                            	  3273: ;	moveq #30,d2
                            	  3274: ;	moveq #'e',d3
                            	  3275: ;	trap #15
                            	  3276: ;	bsr CRLF
00:00006F24 F2396A00000402C0	  3277: 	fmove.x fp4,fpBuf
00:00006F2C F2396900000402D0	  3278: 	fmove.x fp2,fpBuf+16
00:00006F34 0C07002B        	  3279: 	cmpi.b #'+',d7
00:00006F38 6606            	  3280: 	bne .0001
00:00006F3A F2000A22        	  3281: 	fadd fp2,fp4
00:00006F3E 6022            	  3282: 	bra .0002
                            	  3283: .0001
00:00006F40 0C07002D        	  3284: 	cmpi.b #'-',d7
00:00006F44 6606            	  3285: 	bne .0003
00:00006F46 F2000A28        	  3286: 	fsub fp2,fp4
00:00006F4A 6016            	  3287: 	bra .0002
                            	  3288: .0003
00:00006F4C 0C07002A        	  3289: 	cmpi.b #'*',d7
00:00006F50 6606            	  3290: 	bne .0004
00:00006F52 F2000A23        	  3291: 	fmul fp2,fp4
00:00006F56 600A            	  3292: 	bra .0002
                            	  3293: .0004
00:00006F58 0C07002F        	  3294: 	cmpi.b #'/',d7
00:00006F5C 6620            	  3295: 	bne .0005
00:00006F5E F2000A20        	  3296: 	fdiv fp2,fp4
                            	  3297: 	bra .0002
                            	  3298: .0002
00:00006F62 F2396A00000402E0	  3299: 	fmove.x fp4,fpBuf+32
00:00006F6A F2001000        	  3300: 	fmove.x fp4,fp0
00:00006F6E 43F900040520    	  3301: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
00:00006F74 7027            	  3302: 	moveq #39,d0						; function #39 print float
00:00006F76 7228            	  3303: 	moveq #40,d1						; width
00:00006F78 741E            	  3304: 	moveq #30,d2						; precision
00:00006F7A 7665            	  3305: 	moveq #'e',d3
00:00006F7C 4E4F            	  3306: 	trap #15
                            	  3307: .0005
00:00006F7E 6100EAE6        	  3308: 	bsr CRLF
00:00006F82 6000FE28        	  3309: 	bra Monitor
                            	  3310: 
                            	  3311: cmdTestGF:
00:00006F86 6100EADE        	  3312: 	bsr CRLF
00:00006F8A 7029            	  3313: 	moveq #41,d0						; function #41, get float
00:00006F8C 7208            	  3314: 	move.l #8,d1						; d1 = input stride
00:00006F8E 2248            	  3315: 	move.l a0,a1						; a1 = pointer to input buffer
00:00006F90 4E4F            	  3316: 	trap #15
00:00006F92 F2396800000402E0	  3317: 	fmove.x fp0,fpBuf+32
00:00006F9A 43F900040520    	  3318: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
00:00006FA0 7027            	  3319: 	moveq #39,d0
00:00006FA2 7228            	  3320: 	moveq #40,d1
00:00006FA4 741E            	  3321: 	moveq #30,d2
00:00006FA6 7665            	  3322: 	moveq #'e',d3
00:00006FA8 4E4F            	  3323: 	trap #15
00:00006FAA 2049            	  3324: 	move.l a1,a0
00:00006FAC 6100EAB8        	  3325: 	bsr CRLF
00:00006FB0 6000FDFA        	  3326: 	bra Monitor
                            	  3327: 		
                            	  3328: ;-------------------------------------------------------------------------------
                            	  3329: ; CLOCK <n>
                            	  3330: ;    Set the clock register to n which will turn off or on clocks to the CPUs.
                            	  3331: ;-------------------------------------------------------------------------------
                            	  3332: 
                            	  3333: cmdClock:
00:00006FB4 6100041E        	  3334: 	bsr			ignBlanks
00:00006FB8 610006C4        	  3335: 	bsr			GetHexNumber
00:00006FBC 4A00            	  3336: 	tst.b		d0							; was there a number?
00:00006FBE 6700FDEC        	  3337: 	beq			Monitor
00:00006FC2 00400004        	  3338: 	ori.w		#4,d0						; primary core's clock cannot be turned off
00:00006FC6 E159            	  3339: 	rol.w		#8,d1						; switch byte order
00:00006FC8 33C1FD0FFC02    	  3340: 	move.w	d1,RST_REG+2
00:00006FCE 6000FDDC        	  3341: 	bra			Monitor
                            	  3342: 
                            	  3343: ;-------------------------------------------------------------------------------
                            	  3344: ; RESET <n>
                            	  3345: ;    Reset the specified core. Resetting the core automatically turns on the 
                            	  3346: ; core's clock.
                            	  3347: ;-------------------------------------------------------------------------------
                            	  3348: 
                            	  3349: cmdReset:
00:00006FD2 61000400        	  3350: 	bsr			ignBlanks
00:00006FD6 6100FDC0        	  3351: 	bsr			FromScreen
00:00006FDA 0C010032        	  3352: 	cmpi.b	#'2',d1					; check range
00:00006FDE 6500FDCC        	  3353: 	blo			Monitor
00:00006FE2 0C010039        	  3354: 	cmpi.b	#'9',d1
00:00006FE6 6200FDC4        	  3355: 	bhi			Monitor
00:00006FEA 04010030        	  3356: 	subi.b	#'0',d1					; convert ascii to binary
00:00006FEE E349            	  3357: 	lsl.w		#1,d1						; make into index
00:00006FF0 43FA0012        	  3358: 	lea			tblPow2,a1
00:00006FF4 32311000        	  3359: 	move.w	(a1,d1.w),d1
00:00006FF8 E159            	  3360: 	rol.w		#8,d1						; reverse byte order
00:00006FFA 33C1FD0FFC00    	  3361: 	move.w	d1,RST_REG
00:00007000 6000FDAA        	  3362: 	bra			Monitor
                            	  3363: 
                            	  3364: tblPow2:
00:00007004 0001            	  3365: 	dc.w		1
00:00007006 0002            	  3366: 	dc.w		2
00:00007008 0004            	  3367: 	dc.w		4
00:0000700A 0008            	  3368: 	dc.w		8
00:0000700C 0010            	  3369: 	dc.w		16
00:0000700E 0020            	  3370: 	dc.w		32
00:00007010 0040            	  3371: 	dc.w		64
00:00007012 0080            	  3372: 	dc.w		128
00:00007014 0100            	  3373: 	dc.w		256
00:00007016 0200            	  3374: 	dc.w		512
00:00007018 0400            	  3375: 	dc.w		1024
00:0000701A 0800            	  3376: 	dc.w		2048
00:0000701C 1000            	  3377: 	dc.w		4096
00:0000701E 2000            	  3378: 	dc.w		8192
00:00007020 4000            	  3379: 	dc.w		16384
00:00007022 8000            	  3380: 	dc.w		32768
                            	  3381: 	even
                            	  3382: 	
                            	  3383: cmdHelp:
                            	  3384: DisplayHelp:
00:00007024 43FA000A        	  3385: 	lea			HelpMsg,a1
00:00007028 6100ECEE        	  3386: 	bsr			DisplayString
00:0000702C 6000FD7E        	  3387: 	bra			Monitor
                            	  3388: 
                            	  3389: HelpMsg:
00:00007030 3F203D2044697370	  3390: 	dc.b	"? = Display help",LF,CR
00:00007038 6C61792068656C70
00:00007040 0A
00:00007041 0D
00:00007042 434F5245206E203D	  3391: 	dc.b  "CORE n = switch to core n, n = 2 to 9",LF,CR
00:0000704A 2073776974636820
00:00007052 746F20636F726520
00:0000705A 6E2C206E203D2032
00:00007062 20746F2039
00:00007067 0A
00:00007068 0D
00:00007069 5245534554206E20	  3392: 	dc.b  "RESET n = reset core n",LF,CR
00:00007071 3D20726573657420
00:00007079 636F7265206E
00:0000707F 0A
00:00007080 0D
00:00007081 434C53203D20636C	  3393: 	dc.b	"CLS = clear screen",LF,CR
00:00007089 6561722073637265
00:00007091 656E
00:00007093 0A
00:00007094 0D
00:00007095 4542203D20456469	  3394: 	dc.b	"EB = Edit memory bytes, EW, EL",LF,CR
00:0000709D 74206D656D6F7279
00:000070A5 2062797465732C20
00:000070AD 45572C20454C
00:000070B3 0A
00:000070B4 0D
00:000070B5 4642203D2046696C	  3395: 	dc.b	"FB = Fill memory bytes, FW, FL",LF,CR
00:000070BD 6C206D656D6F7279
00:000070C5 2062797465732C20
00:000070CD 46572C20464C
00:000070D3 0A
00:000070D4 0D
00:000070D5 464D544B203D2072	  3396: 	dc.b	"FMTK = run Femtiki OS",LF,CR
00:000070DD 756E2046656D7469
00:000070E5 6B69204F53
00:000070EA 0A
00:000070EB 0D
00:000070EC 4C203D204C6F6164	  3397: 	dc.b	"L = Load S19 file",LF,CR
00:000070F4 205331392066696C
00:000070FC 65
00:000070FD 0A
00:000070FE 0D
00:000070FF 44203D2044756D70	  3398: 	dc.b	"D = Dump memory, DR = dump registers",LF,CR
00:00007107 206D656D6F72792C
00:0000710F 204452203D206475
00:00007117 6D70207265676973
00:0000711F 74657273
00:00007123 0A
00:00007124 0D
00:00007125 4449203D20446973	  3399: 	dc.b	"DI = Disassemble",LF,CR
00:0000712D 617373656D626C65
00:00007135 0A
00:00007136 0D
00:00007137 4241203D20737461	  3400: 	dc.b	"BA = start tiny basic",LF,CR
00:0000713F 72742074696E7920
00:00007147 6261736963
00:0000714C 0A
00:0000714D 0D
00:0000714E 4252203D20736574	  3401: 	dc.b  "BR = set breakpoint",LF,CR
00:00007156 20627265616B706F
00:0000715E 696E74
00:00007161 0A
00:00007162 0D
00:00007163 4A203D204A756D70	  3402: 	dc.b	"J = Jump to code",LF,CR
00:0000716B 20746F20636F6465
00:00007173 0A
00:00007174 0D
00:00007175 53203D2073656E64	  3403: 	dc.b  "S = send to serial port",LF,CR
00:0000717D 20746F2073657269
00:00007185 616C20706F7274
00:0000718C 0A
00:0000718D 0D
00:0000718E 54203D2063707520	  3404: 	dc.b	"T = cpu test program",LF,CR
00:00007196 746573742070726F
00:0000719E 6772616D
00:000071A2 0A
00:000071A3 0D
00:000071A4 5452414D203D2074	  3405: 	dc.b	"TRAM = test RAM",LF,CR,0
00:000071AC 6573742052414D
00:000071B3 0A
00:000071B4 0D
00:000071B5 00
                            	  3406: 
                            	  3407: msgUnknownCmd:
00:000071B6 636F6D6D616E6420	  3408: 	dc.b	"command unknown",0
00:000071BE 756E6B6E6F776E
00:000071C5 00
                            	  3409: 
                            	  3410: msgHello:
00:000071C6 0A              	  3411: 	dc.b	LF,CR,"Hello World!",LF,CR,0
00:000071C7 0D
00:000071C8 48656C6C6F20576F
00:000071D0 726C6421
00:000071D4 0A
00:000071D5 0D
00:000071D6 00
                            	  3412: 	even
                            	  3413: 
                            	  3414: ;------------------------------------------------------------------------------
                            	  3415: ; This routine borrowed from Gordo's Tiny Basic interpreter.
                            	  3416: ; Used to fetch a command line. (Not currently used).
                            	  3417: ;
                            	  3418: ; d0.b	- command prompt
                            	  3419: ;------------------------------------------------------------------------------
                            	  3420: 
                            	  3421: GetCmdLine:
00:000071D8 610015B0        	  3422: 		bsr		OutputChar		; display prompt
00:000071DC 103C0020        	  3423: 		move.b	#' ',d0
00:000071E0 610015A8        	  3424: 		bsr		OutputChar
00:000071E4 41F900040040    	  3425: 		lea		CmdBuf,a0
                            	  3426: .0001:
00:000071EA 6100F44C        	  3427: 		bsr		GetKey
00:000071EE B03C0008        	  3428: 		cmp.b	#CTRLH,d0
00:000071F2 6728            	  3429: 		beq.s	.0003
00:000071F4 B03C0018        	  3430: 		cmp.b	#CTRLX,d0
00:000071F8 6746            	  3431: 		beq.s	.0004
00:000071FA B03C000D        	  3432: 		cmp.b	#CR,d0
00:000071FE 6706            	  3433: 		beq.s	.0002
00:00007200 B03C0020        	  3434: 		cmp.b	#' ',d0
00:00007204 65E4            	  3435: 		bcs.s	.0001
                            	  3436: .0002:
00:00007206 1080            	  3437: 		move.b	d0,(a0)
00:00007208 5088            	  3438: 		lea			8(a0),a0
00:0000720A 6100157E        	  3439: 		bsr		OutputChar
00:0000720E B03C000D        	  3440: 		cmp.b	#CR,d0
00:00007212 675E            	  3441: 		beq		.0007
00:00007214 B1FC0004007F    	  3442: 		cmp.l	#CmdBufEnd-1,a0
00:0000721A 65CE            	  3443: 		bcs.s	.0001
                            	  3444: .0003:
00:0000721C 103C0008        	  3445: 		move.b	#CTRLH,d0
00:00007220 61001568        	  3446: 		bsr		OutputChar
00:00007224 103C0020        	  3447: 		move.b	#' ',d0
00:00007228 61001560        	  3448: 		bsr		OutputChar
00:0000722C B1FC00040040    	  3449: 		cmp.l	#CmdBuf,a0
00:00007232 63B6            	  3450: 		bls.s	.0001
00:00007234 103C0008        	  3451: 		move.b	#CTRLH,d0
00:00007238 61001550        	  3452: 		bsr		OutputChar
00:0000723C 5388            	  3453: 		subq.l	#1,a0
00:0000723E 60AA            	  3454: 		bra.s	.0001
                            	  3455: .0004:
00:00007240 2208            	  3456: 		move.l	a0,d1
00:00007242 92BC00040040    	  3457: 		sub.l	#CmdBuf,d1
00:00007248 671E            	  3458: 		beq.s	.0006
00:0000724A 5341            	  3459: 		subq	#1,d1
                            	  3460: .0005:
00:0000724C 103C0008        	  3461: 		move.b	#CTRLH,d0
00:00007250 61001538        	  3462: 		bsr		OutputChar
00:00007254 103C0020        	  3463: 		move.b	#' ',d0
00:00007258 61001530        	  3464: 		bsr		OutputChar
00:0000725C 103C0008        	  3465: 		move.b	#CTRLH,d0
00:00007260 61001528        	  3466: 		bsr		OutputChar
00:00007264 51C9FFE6        	  3467: 		dbra	d1,.0005
                            	  3468: .0006:
00:00007268 41F900040040    	  3469: 		lea		CmdBuf,a0
00:0000726E 6000FF7A        	  3470: 		bra		.0001
                            	  3471: .0007:
00:00007272 103C000A        	  3472: 		move.b	#LF,d0
00:00007276 61001512        	  3473: 		bsr		OutputChar
00:0000727A 4E75            	  3474: 		rts
                            	  3475: 
                            	  3476: ;------------------------------------------------------------------------------
                            	  3477: ; S <address> <length>
                            	  3478: ; Send data buffer to serial port
                            	  3479: ; S 40000 40
                            	  3480: ;------------------------------------------------------------------------------
                            	  3481: 
                            	  3482: cmdSendSerial:
00:0000727C 61000156        	  3483: 	bsr			ignBlanks
00:00007280 610003FC        	  3484: 	bsr			GetHexNumber
00:00007284 6700FB26        	  3485: 	beq			Monitor
00:00007288 2C01            	  3486: 	move.l	d1,d6					; d6 points to buffer
00:0000728A 61000148        	  3487: 	bsr			ignBlanks
00:0000728E 610003EE        	  3488: 	bsr			GetHexNumber
00:00007292 6602            	  3489: 	bne.s		.0003
00:00007294 7210            	  3490: 	moveq		#16,d1
                            	  3491: .0003:
00:00007296 2246            	  3492: 	move.l	d6,a1					; a1 points to buffer
00:00007298 2401            	  3493: 	move.l	d1,d2					; d2 = count of bytes to send
00:0000729A 6008            	  3494: 	bra.s		.0002					; enter loop at bottom
                            	  3495: .0001:
00:0000729C 1219            	  3496: 	move.b	(a1)+,d1
00:0000729E 303C0022        	  3497: 	move.w	#34,d0				; serial putchar
00:000072A2 4E4F            	  3498: 	trap		#15
                            	  3499: .0002:
00:000072A4 51CAFFF6        	  3500: 	dbra		d2,.0001
00:000072A8 6000FB02        	  3501: 	bra			Monitor
                            	  3502: 		
                            	  3503: ;------------------------------------------------------------------------------
                            	  3504: ; R <address> <length>
                            	  3505: ; Send data buffer to serial port
                            	  3506: ; R 10000 40
                            	  3507: ;------------------------------------------------------------------------------
                            	  3508: 
                            	  3509: cmdReceiveSerial:
00:000072AC 61000126        	  3510: 	bsr			ignBlanks
00:000072B0 610003CC        	  3511: 	bsr			GetHexNumber
00:000072B4 6700FAF6        	  3512: 	beq			Monitor
00:000072B8 2C01            	  3513: 	move.l	d1,d6					; d6 points to buffer
00:000072BA 61000118        	  3514: 	bsr			ignBlanks
00:000072BE 610003BE        	  3515: 	bsr			GetHexNumber
00:000072C2 6602            	  3516: 	bne.s		.0003
00:000072C4 7210            	  3517: 	moveq		#16,d1
                            	  3518: .0003:
00:000072C6 2246            	  3519: 	move.l	d6,a1					; a1 points to buffer
00:000072C8 2401            	  3520: 	move.l	d1,d2					; d2 = count of bytes to send
00:000072CA 600C            	  3521: 	bra.s		.0002					; enter loop at bottom
                            	  3522: .0001:
00:000072CC 303C0024        	  3523: 	move.w	#36,d0				; serial peek char
00:000072D0 4E4F            	  3524: 	trap		#15
00:000072D2 4A81            	  3525: 	tst.l		d1
00:000072D4 6BF6            	  3526: 	bmi.s		.0001
00:000072D6 12C1            	  3527: 	move.b	d1,(a1)+
                            	  3528: .0002:
00:000072D8 51CAFFF2        	  3529: 	dbra		d2,.0001
00:000072DC 6000FACE        	  3530: 	bra			Monitor
                            	  3531: 		
                            	  3532: ;------------------------------------------------------------------------------
                            	  3533: ; Fill memory
                            	  3534: ;
                            	  3535: ; FB = fill bytes		FB 00000010 100 FF	; fill starting at 10 for 256 bytes
                            	  3536: ; FB = fill bytes		FB 00000010 100 R		; fill with random bytes
                            	  3537: ; FW = fill words
                            	  3538: ; FL = fill longs
                            	  3539: ; F = fill bytes
                            	  3540: ;------------------------------------------------------------------------------
                            	  3541: 
                            	  3542: cmdFillB:
00:000072E0 610000F2        	  3543: 	bsr			ignBlanks
00:000072E4 61000398        	  3544: 	bsr			GetHexNumber
00:000072E8 2241            	  3545: 	move.l	d1,a1					; a1 = start
00:000072EA 610000E8        	  3546: 	bsr			ignBlanks
00:000072EE 6100038E        	  3547: 	bsr			GetHexNumber
00:000072F2 2601            	  3548: 	move.l	d1,d3					; d3 = count
00:000072F4 6700FAB6        	  3549: 	beq			Monitor
00:000072F8 610000DA        	  3550: 	bsr			ignBlanks
00:000072FC 610000E8        	  3551: 	bsr PeekScreenChar
00:00007300 0C010052        	  3552: 	cmpi.b #'R',d1
00:00007304 660A            	  3553: 	bne.s .0002
00:00007306 6100FA90        	  3554: 	bsr FromScreen
00:0000730A 1A3C0052        	  3555: 	move.b #'R',d5
00:0000730E 6006            	  3556: 	bra.s .fmem
                            	  3557: .0002:
00:00007310 6100036C        	  3558: 	bsr	GetHexNumber		; fill value
00:00007314 1801            	  3559: 	move.b d1,d4
                            	  3560: .fmem:
00:00007316 3409            	  3561: 	move.w a1,d2
00:00007318 4A42            	  3562: 	tst.w d2
00:0000731A 6604            	  3563: 	bne.s .0001
00:0000731C 6100F352        	  3564: 	bsr	CheckForCtrlC
                            	  3565: .0001:	
00:00007320 0C050052        	  3566: 	cmpi.b #'R',d5
00:00007324 6604            	  3567: 	bne.s .0003
00:00007326 610093F4        	  3568: 	bsr RandGetNum
                            	  3569: .0003:
00:0000732A 12C4            	  3570: 	move.b d4,(a1)+
00:0000732C 5383            	  3571: 	sub.l	#1,d3
00:0000732E 66E6            	  3572: 	bne.s	.fmem
00:00007330 6000FA7A        	  3573: 	bra	Monitor
                            	  3574: 	
                            	  3575: cmdFillW:
00:00007334 6100009E        	  3576: 	bsr			ignBlanks
00:00007338 61000344        	  3577: 	bsr			GetHexNumber
00:0000733C 2241            	  3578: 	move.l	d1,a1					; a1 = start
00:0000733E 61000094        	  3579: 	bsr			ignBlanks
00:00007342 6100033A        	  3580: 	bsr			GetHexNumber
00:00007346 2601            	  3581: 	move.l	d1,d3					; d3 = count
00:00007348 6700FA62        	  3582: 	beq			Monitor
00:0000734C 61000086        	  3583: 	bsr			ignBlanks
00:00007350 61000094        	  3584: 	bsr PeekScreenChar
00:00007354 0C010052        	  3585: 	cmpi.b #'R',d1
00:00007358 660A            	  3586: 	bne.s .0002
00:0000735A 6100FA3C        	  3587: 	bsr FromScreen
00:0000735E 1A3C0052        	  3588: 	move.b #'R',d5
00:00007362 6006            	  3589: 	bra.s .fmem
                            	  3590: .0002:
00:00007364 61000318        	  3591: 	bsr	GetHexNumber			; fill value
00:00007368 3801            	  3592: 	move.w d1,d4
                            	  3593: .fmem:
00:0000736A 3409            	  3594: 	move.w a1,d2
00:0000736C 4A42            	  3595: 	tst.w d2
00:0000736E 6604            	  3596: 	bne.s .0001
00:00007370 6100F2FE        	  3597: 	bsr	CheckForCtrlC
                            	  3598: .0001:	
00:00007374 0C050052        	  3599: 	cmpi.b #'R',d5
00:00007378 6604            	  3600: 	bne.s .0003
00:0000737A 610093A0        	  3601: 	bsr RandGetNum
                            	  3602: .0003:
00:0000737E 32C4            	  3603: 	move.w d4,(a1)+
00:00007380 5383            	  3604: 	sub.l	#1,d3
00:00007382 66E6            	  3605: 	bne.s	.fmem
00:00007384 6000FA26        	  3606: 	bra	Monitor
                            	  3607: 	
                            	  3608: cmdFillL:
00:00007388 614A            	  3609: 	bsr			ignBlanks
00:0000738A 610002F2        	  3610: 	bsr			GetHexNumber
00:0000738E 2241            	  3611: 	move.l	d1,a1					; a1 = start
00:00007390 6142            	  3612: 	bsr			ignBlanks
00:00007392 610002EA        	  3613: 	bsr			GetHexNumber
00:00007396 2601            	  3614: 	move.l	d1,d3					; d3 = count
00:00007398 6700FA12        	  3615: 	beq			Monitor
00:0000739C 6136            	  3616: 	bsr			ignBlanks
00:0000739E 6146            	  3617: 	bsr PeekScreenChar
00:000073A0 0C010052        	  3618: 	cmpi.b #'R',d1
00:000073A4 660A            	  3619: 	bne.s .0002
00:000073A6 6100F9F0        	  3620: 	bsr FromScreen
00:000073AA 1A3C0052        	  3621: 	move.b #'R',d5
00:000073AE 6006            	  3622: 	bra.s .fmem
                            	  3623: .0002:
00:000073B0 610002CC        	  3624: 	bsr			GetHexNumber	; fill value
00:000073B4 2801            	  3625: 	move.l d1,d4
                            	  3626: .fmem:
00:000073B6 3409            	  3627: 	move.w a1,d2
00:000073B8 4A42            	  3628: 	tst.w d2
00:000073BA 6604            	  3629: 	bne.s .0001
00:000073BC 6100F2B2        	  3630: 	bsr	CheckForCtrlC
                            	  3631: .0001:	
00:000073C0 0C050052        	  3632: 	cmpi.b #'R',d5
00:000073C4 6604            	  3633: 	bne.s .0003
00:000073C6 61009354        	  3634: 	bsr RandGetNum
                            	  3635: .0003:
00:000073CA 22C4            	  3636: 	move.l d4,(a1)+
00:000073CC 5383            	  3637: 	sub.l	#1,d3
00:000073CE 66E6            	  3638: 	bne.s	.fmem
00:000073D0 6000F9DA        	  3639: 	bra	Monitor
                            	  3640: 	
                            	  3641: ;------------------------------------------------------------------------------
                            	  3642: ; Modifies:
                            	  3643: ;	a0	- text pointer
                            	  3644: ;------------------------------------------------------------------------------
                            	  3645: 
                            	  3646: ignBlanks:
00:000073D4 2F01            	  3647: 	move.l d1,-(a7)
                            	  3648: .0001:
00:000073D6 6100F9C0        	  3649: 	bsr	FromScreen
00:000073DA 0C010020        	  3650: 	cmpi.b #' ',d1
00:000073DE 67F6            	  3651: 	beq.s .0001
                            	  3652: 	if (SCREEN_FORMAT==1)
00:000073E0 5988            	  3653: 		lea	-4(a0),a0
                            	  3654: 	else
                            	  3655: 		lea	-8(a0),a0
                            	  3656: 	endif
00:000073E2 221F            	  3657: 	move.l (a7)+,d1
00:000073E4 4E75            	  3658: 	rts
                            	  3659: 
                            	  3660: 
                            	  3661: ;------------------------------------------------------------------------------
                            	  3662: ;------------------------------------------------------------------------------
                            	  3663: 
                            	  3664: PeekScreenChar:
00:000073E6 2210            	  3665: 	move.l (a0),d1
00:000073E8 60000BCA        	  3666: 	bra rbo
                            	  3667: 
                            	  3668: ;------------------------------------------------------------------------------
                            	  3669: ; Get the size character
                            	  3670: ; If the size is not recognized, assume a byte size
                            	  3671: ;
                            	  3672: ; Modifies:
                            	  3673: ;		a0	- text pointer
                            	  3674: ;		d1
                            	  3675: ; Returns:
                            	  3676: ;		d4 = size character 'B','W' or 'L'
                            	  3677: ;------------------------------------------------------------------------------
                            	  3678: 
                            	  3679: GetSzChar:
00:000073EC 61E6            	  3680: 	bsr	ignBlanks
00:000073EE 7842            	  3681: 	moveq #'B',d4		; assume byte
00:000073F0 2210            	  3682: 	move.l (a0),d1
00:000073F2 61000BC0        	  3683: 	bsr	rbo
00:000073F6 0C010042        	  3684: 	cmpi.b #'B',d1
00:000073FA 670E            	  3685: 	beq.s .0002
00:000073FC 0C010057        	  3686: 	cmpi.b #'W',d1
00:00007400 6708            	  3687: 	beq.s .0002
00:00007402 0C01004C        	  3688: 	cmpi.b #'L',d1
00:00007406 6702            	  3689: 	beq.s .0002
00:00007408 4E75            	  3690: 	rts
                            	  3691: .0002:
00:0000740A 6100F98C        	  3692: 	bsr FromScreen
00:0000740E 1801            	  3693: 	move.b d1,d4
00:00007410 4E75            	  3694: 	rts
                            	  3695: 
                            	  3696: ;------------------------------------------------------------------------------
                            	  3697: ; Edit memory byte.
                            	  3698: ;    Bytes are built into long words in case the memory is only longword
                            	  3699: ; accessible.
                            	  3700: ;------------------------------------------------------------------------------
                            	  3701: 
                            	  3702: EditMemHelper:
00:00007412 61C0            	  3703: 	bsr ignBlanks
00:00007414 61000268        	  3704: 	bsr GetHexNumber
00:00007418 0C04004C        	  3705: 	cmpi.b #'L',d4
00:0000741C 6604            	  3706: 	bne.s .0001
00:0000741E 2401            	  3707: 	move.l d1,d2
00:00007420 4E75            	  3708: 	rts
                            	  3709: .0001:
00:00007422 0C040057        	  3710: 	cmpi.b #'W',d4
00:00007426 6606            	  3711: 	bne.s .0002
00:00007428 4842            	  3712: 	swap d2
00:0000742A 3401            	  3713: 	move.w d1,d2
00:0000742C 4E75            	  3714: 	rts
                            	  3715: .0002:
00:0000742E E18A            	  3716: 	lsl.l #8,d2
00:00007430 1401            	  3717: 	move.b d1,d2
00:00007432 4E75            	  3718: 	rts
                            	  3719: 	
                            	  3720: cmdEditMemory:
00:00007434 61B6            	  3721: 	bsr GetSzChar
00:00007436 619C            	  3722: 	bsr ignBlanks
00:00007438 61000244        	  3723: 	bsr	GetHexNumber
00:0000743C 2241            	  3724: 	move.l d1,a1
                            	  3725: edtmem1:
00:0000743E 0C04004C        	  3726: 	cmpi.b #'L',d4
00:00007442 6610            	  3727: 	bne.s .0004
00:00007444 7400            	  3728: 	clr.l	d2
00:00007446 61CA            	  3729: 	bsr EditMemHelper
00:00007448 22C2            	  3730: 	move.l d2,(a1)+
00:0000744A 7400            	  3731: 	clr.l	d2
00:0000744C 61C4            	  3732: 	bsr EditMemHelper
00:0000744E 22C2            	  3733: 	move.l d2,(a1)+
00:00007450 6000F95A        	  3734: 	bra Monitor
                            	  3735: .0004:
00:00007454 0C040057        	  3736: 	cmpi.b #'W',d4
00:00007458 6614            	  3737: 	bne.s .0005
00:0000745A 7400            	  3738: 	clr.l	d2
00:0000745C 61B4            	  3739: 	bsr EditMemHelper
00:0000745E 61B2            	  3740: 	bsr EditMemHelper
00:00007460 22C2            	  3741: 	move.l d2,(a1)+
00:00007462 7400            	  3742: 	clr.l	d2
00:00007464 61AC            	  3743: 	bsr EditMemHelper
00:00007466 61AA            	  3744: 	bsr EditMemHelper
00:00007468 22C2            	  3745: 	move.l d2,(a1)+
00:0000746A 6000F940        	  3746: 	bra Monitor
                            	  3747: .0005:
00:0000746E 7400            	  3748: 	clr.l	d2
00:00007470 61A0            	  3749: 	bsr EditMemHelper
00:00007472 619E            	  3750: 	bsr EditMemHelper
00:00007474 619C            	  3751: 	bsr EditMemHelper
00:00007476 619A            	  3752: 	bsr EditMemHelper
00:00007478 22C2            	  3753: 	move.l d2,(a1)+
00:0000747A 7400            	  3754: 	clr.l	d2
00:0000747C 6194            	  3755: 	bsr EditMemHelper
00:0000747E 6192            	  3756: 	bsr EditMemHelper
00:00007480 6190            	  3757: 	bsr EditMemHelper
00:00007482 618E            	  3758: 	bsr EditMemHelper
00:00007484 22C2            	  3759: 	move.l d2,(a1)+
00:00007486 6000F924        	  3760: 	bra Monitor
                            	  3761: 
                            	  3762: ;------------------------------------------------------------------------------
                            	  3763: ; Execute code at the specified address.
                            	  3764: ;------------------------------------------------------------------------------
                            	  3765: 
                            	  3766: cmdJump:
                            	  3767: ExecuteCode:
00:0000748A 6100FF48        	  3768: 	bsr	ignBlanks
00:0000748E 610001EE        	  3769: 	bsr	GetHexNumber
00:00007492 2041            	  3770: 	move.l d1,a0
00:00007494 4E90            	  3771: 	jsr	(a0)
00:00007496 6000F914        	  3772: 	bra Monitor
                            	  3773: 
                            	  3774: ;------------------------------------------------------------------------------
                            	  3775: ; Disassemble code
                            	  3776: ; DI 1000
                            	  3777: ;------------------------------------------------------------------------------
                            	  3778: ;        CALLING SEQUENCE:
                            	  3779: ;   D0,D1,D2 = CODE TO BE DISASSEMBLED
                            	  3780: ;   A4 = VALUE OF PROGRAM COUNTER FOR THE CODE
                            	  3781: ;   A5 = POINTER TO STORE DATA (BUFSIZE = 80 ASSUMED)
                            	  3782: ;        JSR       DCODE68K
                            	  3783: ;
                            	  3784: ;        RETURN:
                            	  3785: ;   A4 = VALUE OF PROGRAM COUNTER FOR NEXT INSTRUCTION
                            	  3786: ;   A5 = POINTER TO LINE AS DISASSEMBLED
                            	  3787: ;   A6 = POINTER TO END OF LINE
                            	  3788: 
                            	  3789: 
                            	  3790: cmdDisassemble:
00:0000749A 6100FF38        	  3791: 	bsr ignBlanks
00:0000749E 610001DE        	  3792: 	bsr GetHexNumber
00:000074A2 6700F908        	  3793: 	beq Monitor
00:000074A6 363C0014        	  3794: 	move.w #20,d3			; number of lines to disassemble
                            	  3795: .0002:
00:000074AA 2F03            	  3796: 	move.l d3,-(a7)
00:000074AC 2041            	  3797: 	move.l d1,a0
00:000074AE 2841            	  3798: 	move.l d1,a4			; a4 = PC of code
00:000074B0 3018            	  3799: 	move.w (a0)+,d0		; d0 to d2 = bytes of instruction to decode
00:000074B2 4840            	  3800: 	swap d0
00:000074B4 3018            	  3801: 	move.w (a0)+,d0
00:000074B6 3218            	  3802: 	move.w (a0)+,d1		; d0 to d2 = bytes of instruction to decode
00:000074B8 4841            	  3803: 	swap d1
00:000074BA 3218            	  3804: 	move.w (a0)+,d1
00:000074BC 3418            	  3805: 	move.w (a0)+,d2		; d0 to d2 = bytes of instruction to decode
00:000074BE 4842            	  3806: 	swap d2
00:000074C0 3418            	  3807: 	move.w (a0)+,d2
00:000074C2 4BF900040800    	  3808: 	lea _dasmbuf,a5		; a5 = pointer to disassembly buffer
00:000074C8 61001DD2        	  3809: 	bsr DCODE68K	
00:000074CC 383C003E        	  3810: 	move.w #62,d4
                            	  3811: .0001:
00:000074D0 121D            	  3812: 	move.b (a5)+,d1
00:000074D2 610012B6        	  3813: 	bsr OutputChar
00:000074D6 51CCFFF8        	  3814: 	dbra d4,.0001
00:000074DA 6100E58A        	  3815: 	bsr CRLF
00:000074DE 220C            	  3816: 	move.l a4,d1
00:000074E0 261F            	  3817: 	move.l (a7)+,d3
00:000074E2 51CBFFC6        	  3818: 	dbra d3,.0002
00:000074E6 6000F8C4        	  3819: 	bra Monitor
                            	  3820: 	
                            	  3821: ;------------------------------------------------------------------------------
                            	  3822: ; Do a memory dump of the requested location.
                            	  3823: ; DB 0800 0850
                            	  3824: ;------------------------------------------------------------------------------
                            	  3825: 
                            	  3826: cmdDumpMemory:
00:000074EA 6100FF00        	  3827: 	bsr GetSzChar
00:000074EE 6100FEE4        	  3828: 	bsr ignBlanks
00:000074F2 6100018A        	  3829: 	bsr	GetHexNumber
00:000074F6 6700F8B4        	  3830: 	beq	Monitor					; was there a number ? no, other garbage, just ignore
00:000074FA 2601            	  3831: 	move.l d1,d3				; save off start of range
00:000074FC 6100FED6        	  3832: 	bsr	ignBlanks
00:00007500 6100017C        	  3833: 	bsr	GetHexNumber
00:00007504 6608            	  3834: 	bne.s	DumpMem1
00:00007506 2203            	  3835: 	move.l d3,d1
00:00007508 068100000040    	  3836: 	addi.l #64,d1				;	no end specified, just dump 64 bytes
                            	  3837: DumpMem1:
00:0000750E 2043            	  3838: 	move.l d3,a0
00:00007510 2241            	  3839: 	move.l d1,a1
00:00007512 6100E552        	  3840: 	bsr	CRLF
                            	  3841: .0001:
00:00007516 B3C8            	  3842: 	cmpa.l a0,a1
00:00007518 6300F892        	  3843: 	bls	Monitor
00:0000751C 6102            	  3844: 	bsr	DisplayMem
00:0000751E 60F6            	  3845: 	bra.s	.0001
                            	  3846: 
                            	  3847: ;------------------------------------------------------------------------------
                            	  3848: ; Display memory dump in a format suitable for edit.
                            	  3849: ;
                            	  3850: ;	EB 12345678 00 11 22 33 44 55 66 77  "........"
                            	  3851: ;
                            	  3852: ; Modifies:
                            	  3853: ;		d1,d2,a0
                            	  3854: ;------------------------------------------------------------------------------
                            	  3855: 	
                            	  3856: DisplayMem:
00:00007520 123C0045        	  3857: 	move.b #'E',d1
00:00007524 61001264        	  3858: 	bsr	OutputChar
00:00007528 1204            	  3859: 	move.b d4,d1
00:0000752A 6100125E        	  3860: 	bsr OutputChar
00:0000752E 6100072C        	  3861: 	bsr DisplaySpace
00:00007532 2208            	  3862: 	move.l a0,d1
00:00007534 6100072E        	  3863: 	bsr	DisplayTetra
00:00007538 7407            	  3864: 	moveq #7,d2						; assume bytes
00:0000753A 0C04004C        	  3865: 	cmpi.b #'L',d4
00:0000753E 6604            	  3866: 	bne.s .0004
00:00007540 7401            	  3867: 	moveq	#1,d2
00:00007542 6008            	  3868: 	bra.s dspmem1
                            	  3869: .0004:
00:00007544 0C040057        	  3870: 	cmpi.b #'W',d4
00:00007548 6602            	  3871: 	bne.s dspmem1
00:0000754A 7403            	  3872: 	moveq #3,d2
                            	  3873: dspmem1:
00:0000754C 123C0020        	  3874: 	move.b #' ',d1
00:00007550 61001238        	  3875: 	bsr	OutputChar
00:00007554 0C04004C        	  3876: 	cmpi.b #'L',d4
00:00007558 6608            	  3877: 	bne.s .0005
00:0000755A 2218            	  3878: 	move.l (a0)+,d1
00:0000755C 61000706        	  3879: 	bsr	DisplayTetra
00:00007560 6014            	  3880: 	bra.s .0006
                            	  3881: .0005:
00:00007562 0C040057        	  3882: 	cmpi.b #'W',d4
00:00007566 6608            	  3883: 	bne.s .0007
00:00007568 3218            	  3884: 	move.w (a0)+,d1
00:0000756A 610006FE        	  3885: 	bsr	DisplayWyde
00:0000756E 6006            	  3886: 	bra.s .0006
                            	  3887: .0007:
00:00007570 1218            	  3888: 	move.b (a0)+,d1
00:00007572 610006FC        	  3889: 	bsr DisplayByte
                            	  3890: .0006:
00:00007576 51CAFFD4        	  3891: 	dbra d2,dspmem1
00:0000757A 610006CE        	  3892: 	bsr	DisplayTwoSpaces
00:0000757E 123C0022        	  3893: 	move.b #34,d1
00:00007582 61001206        	  3894: 	bsr	OutputChar
00:00007586 5188            	  3895: 	lea	-8(a0),a0
00:00007588 7407            	  3896: 	moveq	#7,d2
                            	  3897: .0002:
00:0000758A 1218            	  3898: 	move.b (a0)+,d1
00:0000758C B23C0020        	  3899: 	cmp.b	#' ',d1
00:00007590 6506            	  3900: 	blo.s	.0003
00:00007592 B23C007F        	  3901: 	cmp.b	#127,d1
00:00007596 6304            	  3902: 	bls.s	.0001
                            	  3903: .0003:
00:00007598 123C002E        	  3904: 	move.b #'.',d1
                            	  3905: .0001:
00:0000759C 610011EC        	  3906: 	bsr	OutputChar
00:000075A0 51CAFFE8        	  3907: 	dbra d2,.0002
00:000075A4 123C0022        	  3908: 	move.b #34,d1
00:000075A8 610011E0        	  3909: 	bsr	OutputChar
00:000075AC 6100F0C2        	  3910: 	bsr	CheckForCtrlC
00:000075B0 6000E4B4        	  3911: 	bra	CRLF
                            	  3912: 
                            	  3913: ;------------------------------------------------------------------------------
                            	  3914: ; Dump Registers
                            	  3915: ;    The dump is in a format that allows the register value to be edited.
                            	  3916: ;
                            	  3917: ; RegD0 12345678
                            	  3918: ; RegD1 77777777
                            	  3919: ;	... etc
                            	  3920: ;------------------------------------------------------------------------------
                            	  3921: 
                            	  3922: cmdDumpRegs:
00:000075B4 6100E4B0        	  3923: 	bsr	CRLF
00:000075B8 363C000F        	  3924: 	move.w #15,d3						; number of registers-1
00:000075BC 41FA007A        	  3925: 	lea	msg_reglist,a0			;
00:000075C0 43FA0072        	  3926: 	lea	msg_regs,a1
00:000075C4 45F900040100    	  3927: 	lea	Regsave,a2					; a2 points to register save area
                            	  3928: .0001:
00:000075CA 6100E74C        	  3929: 	bsr			DisplayString
00:000075CE 1218            	  3930: 	move.b	(a0)+,d1
00:000075D0 610011B8        	  3931: 	bsr			OutputChar
00:000075D4 1218            	  3932: 	move.b	(a0)+,d1
00:000075D6 610011B2        	  3933: 	bsr			OutputChar
00:000075DA 61000680        	  3934: 	bsr			DisplaySpace
00:000075DE 221A            	  3935: 	move.l	(a2)+,d1
00:000075E0 61000682        	  3936: 	bsr			DisplayTetra
00:000075E4 6100E480        	  3937: 	bsr			CRLF
00:000075E8 51CBFFE0        	  3938: 	dbra		d3,.0001
00:000075EC 6100E72A        	  3939: 	bsr			DisplayString
00:000075F0 1218            	  3940: 	move.b	(a0)+,d1
00:000075F2 61001196        	  3941: 	bsr			OutputChar
00:000075F6 1218            	  3942: 	move.b	(a0)+,d1
00:000075F8 61001190        	  3943: 	bsr			OutputChar
00:000075FC 6100065E        	  3944: 	bsr			DisplaySpace
00:00007600 223900040144    	  3945: 	move.l	Regsave+$44,d1
00:00007606 6100065C        	  3946: 	bsr			DisplayTetra
00:0000760A 6100E45A        	  3947: 	bsr			CRLF
00:0000760E 6100E708        	  3948: 	bsr			DisplayString
00:00007612 1218            	  3949: 	move.b	(a0)+,d1
00:00007614 61001174        	  3950: 	bsr			OutputChar
00:00007618 1218            	  3951: 	move.b	(a0)+,d1
00:0000761A 6100116E        	  3952: 	bsr			OutputChar
00:0000761E 6100063C        	  3953: 	bsr			DisplaySpace
00:00007622 323900040140    	  3954: 	move.w	Regsave+$40,d1
00:00007628 61000640        	  3955: 	bsr			DisplayWyde
00:0000762C 6100E438        	  3956: 	bsr			CRLF
00:00007630 6000F77A        	  3957: 	bra			Monitor
                            	  3958: 
                            	  3959: msg_regs:
00:00007634 526567          	  3960: 	dc.b	"Reg",0
00:00007637 00
                            	  3961: msg_reglist:
00:00007638 4430443144324433	  3962: 	dc.b	"D0D1D2D3D4D5D6D7A0A1A2A3A4A5A6A7PCSR",0
00:00007640 4434443544364437
00:00007648 4130413141324133
00:00007650 4134413541364137
00:00007658 50435352
00:0000765C 00
                            	  3963: 
                            	  3964: 	align	1
                            	  3965: 
                            	  3966: ;------------------------------------------------------------------------------
                            	  3967: ;------------------------------------------------------------------------------
                            	  3968: 
                            	  3969: cmdTestSerialReceive:
                            	  3970: .0002:
00:0000765E 7024            	  3971: 	moveq		#36,d0				; serial get char from buffer
00:00007660 4E4F            	  3972: 	trap		#15
                            	  3973: ;	bsr			SerialPeekCharDirect
00:00007662 4A41            	  3974: 	tst.w		d1
00:00007664 6B0A            	  3975: 	bmi.s		.0001
00:00007666 0C01001A        	  3976: 	cmpi.b	#CTRLZ,d1
00:0000766A 670A            	  3977: 	beq			.0003
00:0000766C 6100111C        	  3978: 	bsr			OutputChar
                            	  3979: .0001:	
00:00007670 6100EFFE        	  3980: 	bsr			CheckForCtrlC
00:00007674 60E8            	  3981: 	bra			.0002
                            	  3982: .0003:
00:00007676 6100EE00        	  3983: 	bsr			_KeybdInit
00:0000767A 6000F730        	  3984: 	bra			Monitor
                            	  3985: 
                            	  3986: ;------------------------------------------------------------------------------
                            	  3987: ; Get a hexidecimal number. Maximum of eight digits.
                            	  3988: ;
                            	  3989: ; Returns:
                            	  3990: ;		d0 = number of digits
                            	  3991: ;		d1 = value of number
                            	  3992: ;		zf = number of digits == 0
                            	  3993: ;------------------------------------------------------------------------------
                            	  3994: 
                            	  3995: GetHexNumber:
00:0000767E 2F02            	  3996: 	move.l d2,-(a7)
00:00007680 7400            	  3997: 	clr.l	d2
00:00007682 7000            	  3998: 	moveq	#0,d0
                            	  3999: .0002
00:00007684 6100F712        	  4000: 	bsr	FromScreen
00:00007688 61000586        	  4001: 	bsr	AsciiToHexNybble
00:0000768C 0C0100FF        	  4002: 	cmpi.b #$ff,d1
00:00007690 6712            	  4003: 	beq.s	.0001
00:00007692 E98A            	  4004: 	lsl.l	#4,d2
00:00007694 02810000000F    	  4005: 	andi.l #$0f,d1
00:0000769A 8481            	  4006: 	or.l d1,d2
00:0000769C 5240            	  4007: 	addq #1,d0
00:0000769E 0C000008        	  4008: 	cmpi.b #8,d0
00:000076A2 65E0            	  4009: 	blo.s	.0002
                            	  4010: .0001
00:000076A4 2202            	  4011: 	move.l d2,d1
00:000076A6 241F            	  4012: 	move.l (a7)+,d2
00:000076A8 4A00            	  4013: 	tst.b	d0
00:000076AA 4E75            	  4014: 	rts	
                            	  4015: 
                            	  4016: GetDecNumber:
00:000076AC 48E73000        	  4017: 	movem.l d2/d3,-(a7)
00:000076B0 7400            	  4018: 	clr.l d2
00:000076B2 7000            	  4019: 	clr.l d0
                            	  4020: .0002
00:000076B4 6100F6E2        	  4021: 	bsr FromScreen					; grab a character off the screen
00:000076B8 61000556        	  4022: 	bsr	AsciiToHexNybble		; convert to an ascii nybble
00:000076BC 0C0100FF        	  4023: 	cmpi.b #$ff,d1
00:000076C0 6718            	  4024: 	beq.s	.0001
00:000076C2 02810000000F    	  4025: 	andi.l #$0F,d1					; d1 = 0 to 9
00:000076C8 2602            	  4026: 	move.l d2,d3						; d3 = current number
00:000076CA D683            	  4027: 	add.l d3,d3							; d3*2
00:000076CC E78A            	  4028: 	lsl.l #3,d2							; current number * 8
00:000076CE D483            	  4029: 	add.l d3,d2							; current number * 10
00:000076D0 D481            	  4030: 	add.l d1,d2							; add in new digit
00:000076D2 5240            	  4031: 	addq #1,d0							; increment number of digits
00:000076D4 0C000009        	  4032: 	cmpi.b #9,d0						; make sure 9 or fewer
00:000076D8 65DA            	  4033: 	blo .0002
                            	  4034: .0001
00:000076DA 2202            	  4035: 	move.l d2,d1						; return number in d1
00:000076DC 4CDF000C        	  4036: 	movem.l (a7)+,d2/d3
00:000076E0 4A00            	  4037: 	tst.b d0
00:000076E2 4E75            	  4038: 	rts
                            	  4039: 	
                            	  4040: 	include "FloatToString.x68"

Source: "FloatToString.x68"
                            	     1: 	code
                            	     2: ;==============================================================================
                            	     3: ; Decimal-Floating point to string conversion routine.
                            	     4: ;
                            	     5: ; Modifies
                            	     6: ;		_fpWork work area
                            	     7: ; Register Usage:
                            	     8: ; 	fp0 = input decimal-float to convert
                            	     9: ;		fp1 = constant holder, 1.0, 10.0
                            	    10: ;		fp2 = 1.0e<fp0 exponent> value for conversion
                            	    11: ;		fp3 = holds digit value during significand conversion
                            	    12: ; 	a0 = pointer to string buffer, updated to point to NULL at end of string
                            	    13: ;		a1 = pointer to "Nan" or "Inf" message string
                            	    14: ;		d0 = temporary
                            	    15: ;		d1 = digit value during exponent, significand conversion
                            	    16: ; 	d6 = exponent
                            	    17: ;==============================================================================
                            	    18: 	align 4
00:000076F0 25FF0000        	    19: _dfOne	dc.l $25ff0000,$00000000,$00000000
00:000076F4 00000000
00:000076F8 00000000
00:000076FC 2600C000        	    20: _dfTen	dc.l $2600C000,$00000000,$00000000
00:00007700 00000000
00:00007704 00000000
00:00007708 2606DDFA        	    21: _dfMil  dc.l $2606DDFA,$1C000000,$00000000
00:0000770C 1C000000
00:00007710 00000000
                            	    22: 
00:00007714 4E614E          	    23: _msgNan	dc.b "NaN",0
00:00007717 00
00:00007718 496E66          	    24: _msgInf dc.b "Inf",0
00:0000771B 00
                            	    25: 	even
                            	    26: 
                            	    27: ;------------------------------------------------------------------------------
                            	    28: ; Check for the special Nan and infinity values. Output the appropriate string.
                            	    29: ;
                            	    30: ; Modifies
                            	    31: ;		_fpWork area
                            	    32: ;		a0
                            	    33: ; Parameters:
                            	    34: ;		fp0 = dbl
                            	    35: ;------------------------------------------------------------------------------
                            	    36: 
                            	    37: _CheckNan:
00:0000771C 4E52FFF4        	    38: 	link a2,#-12
00:00007720 48D70201        	    39: 	movem.l d0/a1,(sp)
00:00007724 2F79000400980008	    40: 	move.l _canary,8(sp)
00:0000772C F239680000040600	    41: 	fmove.x fp0,_fpWork
00:00007734 103900040600    	    42: 	move.b _fpWork,d0				; get sign+combo
00:0000773A 0200007C        	    43: 	andi.b #$7C,d0					; mask for combo bits
00:0000773E 0C00007C        	    44: 	cmpi.b #$7C,d0					; is it the Nan combo?
00:00007742 6606            	    45: 	bne .notNan
00:00007744 43FAFFCE        	    46: 	lea _msgNan,a1					; output "Nan"
00:00007748 600A            	    47: 	bra .outStr
                            	    48: .notNan
00:0000774A 0C000078        	    49: 	cmpi.b #$78,d0					; is it infinity combo?
00:0000774E 661E            	    50: 	bne .notInf
00:00007750 43FAFFC6        	    51: 	lea _msgInf,a1
                            	    52: .outStr
00:00007754 10D9            	    53: 	move.b (a1)+,(a0)+			; output "Inf"
00:00007756 10D9            	    54: 	move.b (a1)+,(a0)+
00:00007758 10D9            	    55: 	move.b (a1)+,(a0)+
00:0000775A 4210            	    56: 	clr.b (a0)
00:0000775C 4CD70201        	    57: 	movem.l (sp),d0/a1
00:00007760 A2AF00030008    	    58: 	cchk 8(sp)
00:00007766 4E5A            	    59: 	unlk a2
00:00007768 003C0001        	    60: 	ori #1,ccr							; set carry and return
00:0000776C 4E75            	    61: 	rts
                            	    62: .notInf
00:0000776E 4CD70201        	    63: 	movem.l (sp),d0/a1
00:00007772 A2AF00030008    	    64: 	cchk 8(sp)
00:00007778 4E5A            	    65: 	unlk a2
00:0000777A 023C00FE        	    66: 	andi #$FE,ccr						; clear carry and return
00:0000777E 4E75            	    67: 	rts
                            	    68: 
                            	    69: ;------------------------------------------------------------------------------
                            	    70: ; Check for a zero value. Output a single "0" if zero,
                            	    71: ;
                            	    72: ; Modifies:
                            	    73: ;		a0
                            	    74: ; Parameters:
                            	    75: ;		fp0 = dbl
                            	    76: ;------------------------------------------------------------------------------
                            	    77: 
                            	    78: _CheckZero:
00:00007780 F200003A        	    79: 	ftst fp0								; check if number is zero
00:00007784 F28E000E        	    80: 	fbne .0003
00:00007788 10FC0030        	    81: 	move.b #'0',(a0)+				; if zero output "0"
00:0000778C 4210            	    82: 	clr.b (a0)
00:0000778E 003C0004        	    83: 	ori #4,ccr							; set zf
00:00007792 4E75            	    84: 	rts
                            	    85: .0003
00:00007794 023C00FB        	    86: 	andi #$FB,ccr						; clear zf
00:00007798 4E75            	    87: 	rts
                            	    88: 
                            	    89: ;------------------------------------------------------------------------------
                            	    90: ; Check for a negative number. This includes Nans and Infinities. Output a "-"
                            	    91: ; if negative.
                            	    92: ;
                            	    93: ;	Modifies
                            	    94: ;		a0
                            	    95: ; Parameters:
                            	    96: ;		fp0 = dbl
                            	    97: ;------------------------------------------------------------------------------
                            	    98: 
                            	    99: _CheckNegative:
00:0000779A F200003A        	   100: 	ftst fp0								; is number negative?
00:0000779E F293000A        	   101: 	fbge .0002
00:000077A2 10FC002D        	   102: 	move.b #'-',(a0)+				; yes, output '-'
00:000077A6 F200001A        	   103: 	fneg fp0								; make fp0 positive
                            	   104: .0002
00:000077AA 4E75            	   105: 	rts
                            	   106: 
                            	   107: ;------------------------------------------------------------------------------
                            	   108: ; Make the input value larger so that digits may appear before the decimal
                            	   109: ; point.
                            	   110: ;
                            	   111: ; Modifies:
                            	   112: ;		fp0,fp1,d6
                            	   113: ; Parameters:
                            	   114: ;		fp0 = dbl
                            	   115: ;------------------------------------------------------------------------------
                            	   116: 
                            	   117: ;	if (dbl < 1.0) {
                            	   118: ;		while (dbl < 1.0) {
                            	   119: ;			dbl *= 1000000.0;
                            	   120: ;			exp -= 6;  
                            	   121: ;		}
                            	   122: ;	}
                            	   123: 
                            	   124: _MakeBig:
00:000077AC F23C50800001    	   125: 	fmove.w #1,fp1
                            	   126: .0002
00:000077B2 F2000438        	   127: 	fcmp fp1,fp0						; is fp0 > 1?
00:000077B6 F293000E        	   128: 	fbge .0001							; yes, return
00:000077BA F23C402600000006	   129: 	fscale.l #6,fp0					; multiply fp0 by a million
00:000077C2 5D46            	   130: 	subi.w #6,d6						; decrement exponent by six
00:000077C4 60EC            	   131: 	bra .0002								; keep trying until number is > 1
                            	   132: .0001
00:000077C6 4E75            	   133: 	rts
                            	   134: 	
                            	   135: ;------------------------------------------------------------------------------
                            	   136: ;	Create a number dbl2 on the same order of magnitude as dbl, but
                            	   137: ;	less than dbl. The number will be 1.0e<dbl's exponent>
                            	   138: ;
                            	   139: ; Modifies:
                            	   140: ;		d6,fp2
                            	   141: ; Parameters:
                            	   142: ;		fp0 = dbl
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: ;	// The following is similar to using log10() and pow() functions.
                            	   146: ;	// Now dbl is >= 1.0
                            	   147: ;	// Create a number dbl2 on the same order of magnitude as dbl, but
                            	   148: ;	// less than dbl.
                            	   149: ;	dbl2 = 1.0;
                            	   150: ;	dbla = dbl2;
                            	   151: ;	if (dbl > dbl2) {	// dbl > 1.0 ?
                            	   152: ;		while (dbl2 <= dbl) {
                            	   153: ;			dbla = dbl2;
                            	   154: ;			dbl2 *= 10.0;	// increase power of 10
                            	   155: ;			exp++;
                            	   156: ;		}
                            	   157: ;		// The above loop goes one too far, we want the last value less
                            	   158: ;		// than dbl.
                            	   159: ;		dbl2 = dbla;
                            	   160: ;		exp--;
                            	   161: ;	}
                            	   162: 
                            	   163: _LessThanDbl:
00:000077C8 F23C51000001    	   164: 	fmove.w #1,fp2			; setup fp2 = 1
00:000077CE F2000838        	   165: 	fcmp fp2,fp0				; if (dbl > dbl2)
00:000077D2 F295001E        	   166: 	fble .0004
                            	   167: .0006
00:000077D6 F2000138        	   168: 	fcmp fp0,fp2				; while (dbl2 <= dbl)
00:000077DA F292000C        	   169: 	fbgt .0005
00:000077DE F23C51260001    	   170: 	fscale.w #1,fp2			; dbl2 *= 10 (increase exponent by one)
00:000077E4 5246            	   171: 	addi.w #1,d6				; exp++
00:000077E6 60EE            	   172: 	bra .0006
                            	   173: .0005
00:000077E8 F23C4126FFFFFFFF	   174: 	fscale.l #-1,fp2		; dbl2 /= 10 (decrease exponent by one)
00:000077F0 5346            	   175: 	subi.w #1,d6				; exp--;
                            	   176: .0004	
                            	   177: ;	fmove.x fp0,_fpWork	; debugging
                            	   178: ;	fmove.x fp2,_fpWork+12
00:000077F2 4E75            	   179: 	rts
                            	   180: 
                            	   181: ;------------------------------------------------------------------------------
                            	   182: ; Compute the number of digits before the decimal point.
                            	   183: ;
                            	   184: ; Modifies:
                            	   185: ;		d0,d6,_digits_before_decpt
                            	   186: ; Parameters:
                            	   187: ;		d6 = exponent
                            	   188: ;------------------------------------------------------------------------------
                            	   189: 
                            	   190: ; if (exp >= 0 && exp < 6) {
                            	   191: ;   digits_before_decpt = exp+1;
                            	   192: ;		exp = 0;
                            	   193: ;	}
                            	   194: ;	else if (exp >= -7)
                            	   195: ;		digits_before_decpt = 1;
                            	   196: ;	else
                            	   197: ;		digits_before_decpt = -1;
                            	   198: 
                            	   199: _ComputeDigitsBeforeDecpt:
00:000077F4 2F00            	   200: 	move.l d0,-(a7)
00:000077F6 4A46            	   201: 	tst.w d6
00:000077F8 6B16            	   202: 	bmi .0007
00:000077FA 0C460006        	   203: 	cmpi.w #6,d6
00:000077FE 6C10            	   204: 	bge .0007
00:00007800 3006            	   205: 	move.w d6,d0
00:00007802 5240            	   206: 	addi.w #1,d0
00:00007804 33C000040510    	   207: 	move.w d0,_digits_before_decpt	
00:0000780A 4246            	   208: 	clr.w d6
00:0000780C 201F            	   209: 	move.l (a7)+,d0
00:0000780E 4E75            	   210: 	rts
                            	   211: .0007
00:00007810 0C46FFF9        	   212: 	cmpi.w #-7,d6
00:00007814 6D0C            	   213: 	blt .0009
00:00007816 33FC000100040510	   214: 	move.w #1,_digits_before_decpt
00:0000781E 201F            	   215: 	move.l (a7)+,d0
00:00007820 4E75            	   216: 	rts
                            	   217: .0009
00:00007822 33FCFFFF00040510	   218: 	move.w #-1,_digits_before_decpt
00:0000782A 201F            	   219: 	move.l (a7)+,d0
00:0000782C 4E75            	   220: 	rts
                            	   221: 
                            	   222: ;------------------------------------------------------------------------------
                            	   223: ;	Spit out a leading zero before the decimal point for a small number.
                            	   224: ;
                            	   225: ; Modifies:
                            	   226: ;		a0
                            	   227: ; Parameters:
                            	   228: ;		d6 = exponent
                            	   229: ;------------------------------------------------------------------------------
                            	   230: 
                            	   231: ;  if (exp < -7) {
                            	   232: ;		 buf[ndx] = '0';
                            	   233: ;		 ndx++;
                            	   234: ;    buf[ndx] = '.';
                            	   235: ;    ndx++;
                            	   236: ;  }
                            	   237: 
                            	   238: _LeadingZero:
00:0000782E 0C46FFF9        	   239: 	cmpi.w #-7,d6
00:00007832 6C08            	   240: 	bge .0010
00:00007834 10FC0030        	   241: 	move.b #'0',(a0)+
00:00007838 10FC002E        	   242: 	move.b #'.',(a0)+
                            	   243: .0010
00:0000783C 4E75            	   244: 	rts
                            	   245: 
                            	   246: ;------------------------------------------------------------------------------
                            	   247: ; Extract the digits of the significand.
                            	   248: ;
                            	   249: ; Modifies:
                            	   250: ;		_precision variable
                            	   251: ; Register Usage
                            	   252: ;		d0 = counter
                            	   253: ;		d1 = digit
                            	   254: ;		fp0 = dbl
                            	   255: ;		fp2 = dbl2
                            	   256: ;		fp3 = digit as decimal float
                            	   257: ;		fp7 = dbla
                            	   258: ; Parameters:
                            	   259: ;		fp0, fp2
                            	   260: ;------------------------------------------------------------------------------
                            	   261: 
                            	   262: ;	// Now loop processing one digit at a time.
                            	   263: ;  for (nn = 0; nn < 25 && precision > 0; nn++) {
                            	   264: ;    digit = 0;
                            	   265: ;		dbla = dbl;
                            	   266: ;		// dbl is on the same order of magnitude as dbl2 so
                            	   267: ;		// a repeated subtract can be used to find the digit.
                            	   268: ;    while (dbl >= dbl2) {
                            	   269: ;      dbl -= dbl2;
                            	   270: ;      digit++;
                            	   271: ;    }
                            	   272: ;    buf[ndx] = digit + '0';
                            	   273: ;		// Now go back and perform just a single subtract and
                            	   274: ;		// a multiply to find out how much to reduce dbl by.
                            	   275: ;		// This should improve the accuracy
                            	   276: ;		if (digit > 2)
                            	   277: ;			dbl = dbla - dbl2 * digit;
                            	   278: ;    ndx++;
                            	   279: ;    digits_before_decpt--;
                            	   280: ;    if (digits_before_decpt==0) {
                            	   281: ;			buf[ndx] = '.';
                            	   282: ;			ndx++;
                            	   283: ;    }
                            	   284: ;    else if (digits_before_decpt < 0)
                            	   285: ;      precision--;
                            	   286: ;		// Shift the next digit to be tested into position.
                            	   287: ;    dbl *= 10.0;
                            	   288: ;  }
                            	   289: 	
                            	   290: _SpitOutDigits:
00:0000783E 4E52FFE8        	   291: 	link a2,#-24
00:00007842 2F79000400980014	   292: 	move.l _canary,20(sp)
00:0000784A F2176B80        	   293: 	fmove.x fp7,(sp)
00:0000784E 48EF0003000C    	   294: 	movem.l d0/d1,12(sp)
00:00007854 303C0018        	   295: 	move.w #24,d0			; d0 = nn
                            	   296: .0017	
00:00007858 4AB900040514    	   297: 	tst.l _precision
00:0000785E 6F46            	   298: 	ble .0011
00:00007860 7200            	   299: 	moveq #0,d1				; digit = 0
00:00007862 F2000380        	   300: 	fmove fp0,fp7			; dbla = dbl
                            	   301: .0013
00:00007866 F2000838        	   302: 	fcmp fp2,fp0
00:0000786A F294000A        	   303: 	fblt .0012
00:0000786E F2000828        	   304: 	fsub fp2,fp0			; dbl -= dbl2
00:00007872 5201            	   305: 	addi.b #1,d1			; digit++
00:00007874 60F0            	   306: 	bra .0013
                            	   307: .0012
00:00007876 06010030        	   308: 	addi.b #'0',d1		; convert digit to ascii
00:0000787A 10C1            	   309: 	move.b d1,(a0)+		; and store
00:0000787C 04010030        	   310: 	subi.b #'0',d1		; d1 = binary digit again
                            	   311: ;	cmpi.b #2,d1
                            	   312: ;	ble .0014
                            	   313: 
                            	   314: ;	ext.w d1
                            	   315: ;	ext.l d1
                            	   316: ;	fmove.l d1,fp3		; fp3 = digit
                            	   317: ;	fmul fp2,fp3			; fp3 = dbl2 * digit
                            	   318: ;	fmove fp7,fp0
                            	   319: ;	fsub fp3,fp0			; dbl = dbla - dbl2 * digit
                            	   320: .0014
00:00007880 537900040510    	   321: 	subi.w #1,_digits_before_decpt
00:00007886 6604            	   322: 	bne .0015
00:00007888 10FC002E        	   323: 	move.b #'.',(a0)+
                            	   324: .0015
00:0000788C 4A7900040510    	   325: 	tst.w _digits_before_decpt
00:00007892 6C06            	   326: 	bge .0016
00:00007894 53B900040514    	   327: 	subi.l #1,_precision
                            	   328: .0016
00:0000789A F23C4126FFFFFFFF	   329: 	fscale.l #-1,fp2		; dbl *= 10.0
00:000078A2 51C8FFB4        	   330: 	dbra d0,.0017
                            	   331: .0011
00:000078A6 4CEF0003000C    	   332: 	movem.l 12(sp),d0/d1
00:000078AC F2174B80        	   333: 	fmove.x (sp),fp7
00:000078B0 A2AF00030014    	   334: 	cchk 20(sp)
00:000078B6 4E5A            	   335: 	unlk a2
00:000078B8 4E75            	   336: 	rts
                            	   337: 
                            	   338: ;------------------------------------------------------------------------------
                            	   339: ; If the number ends in a decimal point, trim off the point.
                            	   340: ;
                            	   341: ; Registers Modified:
                            	   342: ;		none
                            	   343: ; Parameters:
                            	   344: ;		a0 = pointer to end of number
                            	   345: ; Returns:
                            	   346: ;		a0 = updated to point just past last digit.
                            	   347: ;------------------------------------------------------------------------------
                            	   348: 
                            	   349: _TrimTrailingPoint:
00:000078BA 0C28002EFFFF    	   350: 	cmpi.b #'.',-1(a0)
00:000078C0 6604            	   351: 	bne .0001
00:000078C2 4220            	   352: 	clr.b -(a0)
00:000078C4 4E75            	   353: 	rts
                            	   354: .0001
00:000078C6 0C10002E        	   355: 	cmpi.b #'.',(a0)
00:000078CA 660A            	   356: 	bne .0002
00:000078CC 4A280001        	   357: 	cmpi.b #0,1(a0)
00:000078D0 6604            	   358: 	bne .0002
00:000078D2 4210            	   359: 	clr.b (a0)
00:000078D4 5348            	   360: 	subq #1,a0
                            	   361: .0002
00:000078D6 4E75            	   362: 	rts
                            	   363: 	
                            	   364: ;------------------------------------------------------------------------------
                            	   365: ; If the number ends in .0 get rid of the .0
                            	   366: ;
                            	   367: ; Registers Modified:
                            	   368: ;		none
                            	   369: ; Parameters:
                            	   370: ;		a0 = pointer to last digits of number
                            	   371: ; Returns:
                            	   372: ;		a0 = updated to point just past last digit.
                            	   373: ;------------------------------------------------------------------------------
                            	   374: 
                            	   375: _TrimDotZero:
00:000078D8 4A10            	   376: 	tst.b (a0)
00:000078DA 6616            	   377: 	bne .0004
00:000078DC 0C280030FFFF    	   378: 	cmpi.b #'0',-1(a0)
00:000078E2 660E            	   379: 	bne .0004
00:000078E4 0C28002EFFFE    	   380: 	cmpi.b #'.',-2(a0)
00:000078EA 6606            	   381: 	bne .0004
00:000078EC 4228FFFE        	   382: 	clr.b -2(a0)
00:000078F0 5548            	   383: 	subq #2,a0
                            	   384: .0004
00:000078F2 4E75            	   385: 	rts
                            	   386: 
                            	   387: ;------------------------------------------------------------------------------
                            	   388: ; Trim trailing zeros from the number. Generally there is no need to display
                            	   389: ; trailing zeros.
                            	   390: ; Turns a number like 652.000000000000000000000 into 650.0
                            	   391: ;
                            	   392: ; Registers Modified:
                            	   393: ;		none
                            	   394: ; Parameters:
                            	   395: ;		a0 = pointer to last digits of number
                            	   396: ; Returns:
                            	   397: ;		a0 = updated to point just past last digit.
                            	   398: ;------------------------------------------------------------------------------
                            	   399: 
                            	   400: ;	// Trim trailing zeros from the number
                            	   401: ;  do {
                            	   402: ;      ndx--;
                            	   403: ;  } while(buf[ndx]=='0');
                            	   404: ;  ndx++;
                            	   405: 
                            	   406: _TrimTrailingZeros:
                            	   407: .0018	
00:000078F4 0C200030        	   408: 	cmpi.b #'0',-(a0)		; if the last digit was a zero, backup
00:000078F8 67FA            	   409: 	beq .0018
00:000078FA 5248            	   410: 	addq #1,a0					; now advance by one
00:000078FC 4210            	   411: 	move.b #0,(a0)			; NULL terminate string
00:000078FE 4E75            	   412: 	rts
                            	   413: 
                            	   414: ;------------------------------------------------------------------------------
                            	   415: ; Output 'e+' or 'e-'
                            	   416: ;
                            	   417: ; Registers Modified:
                            	   418: ;		d6.w (if negative)
                            	   419: ; Parameters:
                            	   420: ;		a0 = pointer to last digits of number
                            	   421: ; Returns:
                            	   422: ;		a0 = updated to point just past '+' or '-'.
                            	   423: ;------------------------------------------------------------------------------
                            	   424: 
                            	   425: ;	// Spit out +/-E
                            	   426: ;  buf[ndx] = E;
                            	   427: ;  ndx++;
                            	   428: ;  if (exp < 0) {
                            	   429: ;    buf[ndx]='-';
                            	   430: ;    ndx++;
                            	   431: ;    exp = -exp;
                            	   432: ;  }
                            	   433: ;  else {
                            	   434: ;		buf[ndx]='+';
                            	   435: ;		ndx++;
                            	   436: ;  }
                            	   437: 
                            	   438: _SpitOutE:	
00:00007900 10F90004050C    	   439: 	move.b _E,(a0)+
00:00007906 4A46            	   440: 	tst.w d6
00:00007908 6C08            	   441: 	bge .0021
00:0000790A 10FC002D        	   442: 	move.b #'-',(a0)+
00:0000790E 4446            	   443: 	neg.w d6
00:00007910 6004            	   444: 	bra .0022
                            	   445: .0021
00:00007912 10FC002B        	   446: 	move.b #'+',(a0)+
                            	   447: .0022
00:00007916 4E75            	   448: 	rts
                            	   449: 
                            	   450: ;------------------------------------------------------------------------------
                            	   451: ; Extract a single digit of the exponent. Extract works from the leftmost digit
                            	   452: ; to the rightmost.
                            	   453: ;
                            	   454: ; Register Usage
                            	   455: ;		d2 = history of zeros
                            	   456: ;		d3 = digit
                            	   457: ; Modifies
                            	   458: ;		d2,d6,a0
                            	   459: ; Parameter
                            	   460: ; 	d1.w = power of ten
                            	   461: ;		d6.w = exponent
                            	   462: ;------------------------------------------------------------------------------
                            	   463: 
                            	   464: _ExtExpDigit:
00:00007918 2F03            	   465: 	move.l d3,-(a7)
00:0000791A 48C6            	   466: 	ext.l d6				; make d6 a long
00:0000791C 8CC1            	   467: 	divu d1,d6			; divide by power of ten
00:0000791E 1606            	   468: 	move.b d6,d3		; d3 = quotient (0 to 9)
00:00007920 4846            	   469: 	swap d6					; d6 = remainder, setup for next digit
00:00007922 8403            	   470: 	or.b d3,d2
00:00007924 4A03            	   471: 	tst.b d3
00:00007926 6604            	   472: 	bne .0003
00:00007928 4A02            	   473: 	tst.b d2	
00:0000792A 6706            	   474: 	beq .0004
                            	   475: .0003
00:0000792C 06030030        	   476: 	addi.b #'0',d3	; convert to ascii
00:00007930 10C3            	   477: 	move.b d3,(a0)+
                            	   478: .0004
00:00007932 261F            	   479: 	move.l (a7)+,d3
00:00007934 4E75            	   480: 	rts
                            	   481: 
                            	   482: ;------------------------------------------------------------------------------
                            	   483: ; Extract all the digits of the exponent.
                            	   484: ;
                            	   485: ; Register Usage
                            	   486: ;		d1 = power of 10
                            	   487: ;		d2 = history of zeros
                            	   488: ; Parameters
                            	   489: ;		a0 = pointer to string buffer
                            	   490: ;		d6 = exponent
                            	   491: ;------------------------------------------------------------------------------
                            	   492: 
                            	   493: ;	// If the number is times 10^0 don't output the exponent
                            	   494: ;  if (exp==0) {
                            	   495: ;    buf[ndx]='\0';
                            	   496: ;    goto prt;
                            	   497: ;  }
                            	   498: 
                            	   499: _ExtExpDigits:
00:00007936 2F01            	   500: 	move.l d1,-(a7)
00:00007938 4A46            	   501: 	tst.w d6							; is exponent zero?
00:0000793A 671C            	   502: 	beq .0002
00:0000793C 61C2            	   503: 	bsr _SpitOutE					; exponent is non-zero e+
00:0000793E 4202            	   504: 	clr.b d2							; d2 = history of zeros
00:00007940 323C03E8        	   505: 	move.w #1000,d1
00:00007944 61D2            	   506: 	bsr _ExtExpDigit
00:00007946 323C0064        	   507: 	move.w #100,d1
00:0000794A 61CC            	   508: 	bsr _ExtExpDigit
00:0000794C 323C000A        	   509: 	move.w #10,d1
00:00007950 61C6            	   510: 	bsr _ExtExpDigit
00:00007952 323C0001        	   511: 	move.w #1,d1
00:00007956 61C0            	   512: 	bsr _ExtExpDigit
                            	   513: .0002:
00:00007958 221F            	   514: 	move.l (a7)+,d1
00:0000795A 4210            	   515: 	move.b #0,(a0)				; NULL terminate string
00:0000795C 4E75            	   516: 	rts										; and return
                            	   517: 
                            	   518: ;------------------------------------------------------------------------------
                            	   519: ; Pad the left side of the output string.
                            	   520: ;
                            	   521: ; Modifies:
                            	   522: ;		d0,d1,d2,d3
                            	   523: ;------------------------------------------------------------------------------
                            	   524: 
                            	   525: ;  // pad left
                            	   526: ;  if (width > 0) {
                            	   527: ;    if (ndx < width) {
                            	   528: ;      for (nn = 39; nn >= width-ndx; nn--)
                            	   529: ;        buf[nn] = buf[nn-(width-ndx)];
                            	   530: ;      for (; nn >= 0; nn--)
                            	   531: ;        buf[nn] = ' ';
                            	   532: ;    }
                            	   533: ;  }
                            	   534: 	
                            	   535: _PadLeft:
00:0000795E 48E7F000        	   536: 	movem.l d0/d1/d2/d3,-(a7)
00:00007962 4A3900040508    	   537: 	tst.b _width
00:00007968 6F3E            	   538: 	ble .0041
00:0000796A 2008            	   539: 	move.l a0,d0
00:0000796C 90BC00040520    	   540: 	sub.l #_fpBuf,d0	; d0 = ndx
00:00007972 B03900040508    	   541: 	cmp.b _width,d0
00:00007978 6C2E            	   542: 	bge .0041
00:0000797A 323C0031        	   543: 	move.w #49,d1			; d1 = nn
                            	   544: .0040
00:0000797E 143900040508    	   545: 	move.b _width,d2
00:00007984 4882            	   546: 	ext.w d2
00:00007986 9440            	   547: 	sub.w d0,d2				; d2 = width-ndx
00:00007988 B242            	   548: 	cmp.w d2,d1
00:0000798A 6D0E            	   549: 	blt .0039
00:0000798C 3601            	   550: 	move.w d1,d3			; d3 = nn
00:0000798E 9642            	   551: 	sub.w d2,d3				; d3 = nn-(width-ndx)
00:00007990 11B030001000    	   552: 	move.b (a0,d3.w),(a0,d1.w)
00:00007996 5341            	   553: 	subi.w #1,d1
00:00007998 60E4            	   554: 	bra .0040
                            	   555: .0039
00:0000799A 4A41            	   556: 	tst.w d1
00:0000799C 6B0A            	   557: 	bmi .0041
00:0000799E 11BC00201000    	   558: 	move.b #' ',(a0,d1.w)
00:000079A4 5341            	   559: 	subi.w #1,d1
00:000079A6 60F2            	   560: 	bra .0039
                            	   561: .0041
00:000079A8 4CDF000F        	   562: 	movem.l (a7)+,d0/d1/d2/d3
00:000079AC 4E75            	   563: 	rts
                            	   564: 
                            	   565: ;------------------------------------------------------------------------------
                            	   566: ; Pad the right side of the output string.
                            	   567: ;
                            	   568: ; Parameters:
                            	   569: ;		a0 = pointer to end of string
                            	   570: ; Modifies:
                            	   571: ;		none
                            	   572: ; Returns:
                            	   573: ;		none
                            	   574: ;------------------------------------------------------------------------------
                            	   575: 
                            	   576: ;  // pad right
                            	   577: ;  if (width < 0) {
                            	   578: ;    width = -width;
                            	   579: ;    while (ndx < width) {
                            	   580: ;      buf[ndx]=' ';
                            	   581: ;      ndx++;
                            	   582: ;    }
                            	   583: ;    buf[ndx]='\0';
                            	   584: ;  }
                            	   585: ;  return (ndx);
                            	   586: 
                            	   587: _PadRight:
00:000079AE 2F00            	   588: 	move.l d0,-(a7)
00:000079B0 4A3900040508    	   589: 	tst.b _width
00:000079B6 6A24            	   590: 	bpl .0042
00:000079B8 443900040508    	   591: 	neg.b _width
00:000079BE 2008            	   592: 	move.l a0,d0
00:000079C0 90BC00040520    	   593: 	sub.l #_fpBuf,d0	; d0 = ndx
                            	   594: .0044
00:000079C6 B03900040508    	   595: 	cmp.b _width,d0
00:000079CC 6C0A            	   596: 	bge .0043
00:000079CE 11BC00200000    	   597: 	move.b #' ',(a0,d0.w)
00:000079D4 5240            	   598: 	addi.w #1,d0
00:000079D6 60EE            	   599: 	bra .0044
                            	   600: .0043
00:000079D8 42300000        	   601: 	move.b #0,(a0,d0.w)
                            	   602: .0042
00:000079DC 201F            	   603: 	move.l (a7)+,d0
00:000079DE 4E75            	   604: 	rts
                            	   605: 
                            	   606: ;------------------------------------------------------------------------------
                            	   607: ; Output a string representation of a decimal floating point number to a 
                            	   608: ; buffer.
                            	   609: ;
                            	   610: ; Register Usage
                            	   611: ;		a0 = pointer to string buffer
                            	   612: ;		d6 = exponent
                            	   613: ; Modifies:
                            	   614: ;		a0 = points to end of string
                            	   615: ; Parameters:
                            	   616: ;		fp0 = number to convert
                            	   617: ; Returns:
                            	   618: ;		none
                            	   619: ;------------------------------------------------------------------------------
                            	   620: 
                            	   621: _FloatToString:
00:000079E0 2F06            	   622: 	move.l d6,-(a7)
00:000079E2 6100FDB6        	   623: 	bsr _CheckNegative			; is number negative?
00:000079E6 6100FD98        	   624: 	bsr _CheckZero					; check for zero
00:000079EA 6732            	   625: 	beq .0001								; branch since already output "0"
00:000079EC 6100FD2E        	   626: 	bsr _CheckNan						; check for Nan or infinity
00:000079F0 652C            	   627: 	bcs .0001								; branch if nan/inf string output
                            	   628: 	; Now the fun begins
00:000079F2 7C00            	   629: 	clr.l d6								; exponent = 0
00:000079F4 6100FDB6        	   630: 	bsr _MakeBig
00:000079F8 6100FDCE        	   631: 	bsr _LessThanDbl
00:000079FC 6100FDF6        	   632: 	bsr _ComputeDigitsBeforeDecpt
00:00007A00 6100FE2C        	   633: 	bsr _LeadingZero
00:00007A04 6100FE38        	   634: 	bsr _SpitOutDigits
00:00007A08 6100FEEA        	   635: 	bsr _TrimTrailingZeros
00:00007A0C 6100FEAC        	   636: 	bsr _TrimTrailingPoint
00:00007A10 6100FEC6        	   637: 	bsr _TrimDotZero
00:00007A14 6100FF20        	   638: 	bsr _ExtExpDigits				; extract exponent digits
00:00007A18 6100FF44        	   639: 	bsr _PadLeft						; pad the number to the left or right
00:00007A1C 6190            	   640: 	bsr _PadRight
                            	   641: .0001
00:00007A1E 2C1F            	   642: 	move.l (a7)+,d6
00:00007A20 4E75            	   643: 	rts
                            	   644: 
                            	   645: 

Source: "boot.x68"
                            	  4041: 	include "GetFloat.asm"

Source: "GetFloat.asm"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;
                            	    37: ; Get a floating point number
                            	    38: ;
                            	    39: _GetFloatGetChar:
00:00007A22 1210            	    40: 	move.b (a0),d1
00:00007A24 D1C0            	    41: 	add.l d0,a0
00:00007A26 4E75            	    42: 	rts
                            	    43: _GetFloatIgnBlanks:
                            	    44: .0001
00:00007A28 61F8            	    45: 	bsr _GetFloatGetChar
00:00007A2A 0C010020        	    46: 	cmpi.b #' ',d1
00:00007A2E 67F8            	    47: 	beq .0001
                            	    48: _GetFloatBackupChar:
00:00007A30 91C0            	    49: 	sub.l d0,a0
00:00007A32 4E75            	    50: 	rts
                            	    51: 
                            	    52: ;-------------------------------------------------------------------------------
                            	    53: ; Get fractional part of a number, 25 digits max, into a float register.
                            	    54: ;
                            	    55: ; Register Usage:
                            	    56: ;		d1 = digit from input screen
                            	    57: ;		d4 = digit count
                            	    58: ;		d6 = digit scaling factor
                            	    59: ;		fp1 = digit as float number
                            	    60: ; Returns:
                            	    61: ;		fp0 = fraction
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: _GetFraction:
00:00007A34 4E52FFE4        	    65: 	link a2,#-28
00:00007A38 2F79000400980018	    66: 	move.l _canary,24(sp)
00:00007A40 48D70052        	    67: 	movem.l d1/d4/d6,(sp)
00:00007A44 F22F6880000C    	    68: 	fmove.x fp1,12(sp)
00:00007A4A 7C00            	    69: 	clr.l d6							; d6 = scale factor
00:00007A4C F23C50000000    	    70: 	fmove.w #0,fp0				; fract = 0.0
00:00007A52 7818            	    71: 	moveq #24,d4
                            	    72: .0002
00:00007A54 61CC            	    73: 	bsr _GetFloatGetChar
00:00007A56 0C010030        	    74: 	cmpi.b #'0',d1
00:00007A5A 6520            	    75: 	blo .0001
00:00007A5C 0C010039        	    76: 	cmpi.b #'9',d1				; make sure between 0 and 9
00:00007A60 621A            	    77: 	bhi .0001
00:00007A62 04010030        	    78: 	subi.b #'0',d1
00:00007A66 F23C50260001    	    79: 	fscale.w #1,fp0				; fract * 10.0
00:00007A6C 5246            	    80: 	addq #1,d6						; record scaling
00:00007A6E F2015880        	    81: 	fmove.b d1,fp1				; fp1 = digit
00:00007A72 F2000422        	    82: 	fadd fp1,fp0					; fract += digit
00:00007A76 5245            	    83: 	addq.w #1,d5					; increment number of digits in number
00:00007A78 51CCFFDA        	    84: 	dbra d4,.0002
                            	    85: .0001
00:00007A7C 61B2            	    86: 	bsr _GetFloatBackupChar
00:00007A7E 4446            	    87: 	neg d6
00:00007A80 F2064026        	    88: 	fscale.l d6,fp0				; fract /= scale
00:00007A84 4CD70052        	    89: 	movem.l (sp),d1/d4/d6
00:00007A88 F22F4880000C    	    90: 	fmove.x 12(sp),fp1
00:00007A8E A2AF00030018    	    91: 	cchk 24(sp)
00:00007A94 4E5A            	    92: 	unlk a2
00:00007A96 4E75            	    93: 	rts
                            	    94: 
                            	    95: ;-------------------------------------------------------------------------------
                            	    96: ; Get exponent part of a number, 4 digits max, into a float register.
                            	    97: ;
                            	    98: ; Register Usage:
                            	    99: ;		d1 = digit from input screen
                            	   100: ;		d2 = exponent
                            	   101: ;		d3 = temp, number times 2
                            	   102: ;		d4 = digit counter
                            	   103: ; Parameters:
                            	   104: ;		fp0 = float number
                            	   105: ; Returns:
                            	   106: ;		fp0 = float number with exponent factored in
                            	   107: ;-------------------------------------------------------------------------------
                            	   108: 
                            	   109: _GetExponent:
00:00007A98 4E52FFE0        	   110: 	link a2,#-32
00:00007A9C 2F7900040098001C	   111: 	move.l _canary,28(sp)
00:00007AA4 48D7001E        	   112: 	movem.l d1/d2/d3/d4,(sp)
00:00007AA8 F22F69000010    	   113: 	fmove.x fp2,16(sp)
00:00007AAE 7400            	   114: 	clr.l d2							; d2 = number = 0
00:00007AB0 F23C51000000    	   115: 	fmove.w #0,fp2				; fp2 = exp = 0.0
00:00007AB6 7601            	   116: 	moveq #1,d3						; d3 = exscale = 1
00:00007AB8 6100FF68        	   117: 	bsr _GetFloatGetChar
00:00007ABC 0C01002D        	   118: 	cmpi.b #'-',d1
00:00007AC0 6608            	   119: 	bne .0001
00:00007AC2 4483            	   120: 	neg.l d3							; exscale = -1
                            	   121: .0006
00:00007AC4 6100FF62        	   122: 	bsr _GetFloatIgnBlanks
00:00007AC8 600A            	   123: 	bra .0002
                            	   124: .0001
00:00007ACA 0C01002B        	   125: 	cmpi.b #'+',d1
00:00007ACE 67F4            	   126: 	beq .0006
00:00007AD0 6100FF5E        	   127: 	bsr _GetFloatBackupChar
                            	   128: .0002	
00:00007AD4 7803            	   129: 	moveq #3,d4						; d4 = max 4 digits
                            	   130: .0004
00:00007AD6 6100FF4A        	   131: 	bsr _GetFloatGetChar	; d1 = digit char
00:00007ADA 0C010030        	   132: 	cmpi.b #'0',d1
00:00007ADE 651E            	   133: 	blo .0003
00:00007AE0 0C010039        	   134: 	cmpi.b #'9',d1				; ensure between 0 and 9
00:00007AE4 6218            	   135: 	bhi .0003
00:00007AE6 04010030        	   136: 	subi.b #'0',d1
00:00007AEA D482            	   137: 	add.l d2,d2						; number *2
00:00007AEC 2602            	   138: 	move.l d2,d3
00:00007AEE E58A            	   139: 	lsl.l #2,d2						; number *8
00:00007AF0 D483            	   140: 	add.l d3,d2						; number *10	
00:00007AF2 4881            	   141: 	ext.w d1
00:00007AF4 48C1            	   142: 	ext.l d1
00:00007AF6 D481            	   143: 	add.l d1,d2						; number + digit
00:00007AF8 5245            	   144: 	addq.w #1,d5					; increment number of digits in number
00:00007AFA 51CCFFDA        	   145: 	dbra d4,.0004
                            	   146: .0003
00:00007AFE 6100FF30        	   147: 	bsr _GetFloatBackupChar	; backup a character
00:00007B02 C4C3            	   148: 	mulu d3,d2						; *1 or *-1
00:00007B04 48C2            	   149: 	ext.l d2
00:00007B06 F2024126        	   150: 	fscale.l d2,fp2				; exp * exmul
00:00007B0A F2000823        	   151: 	fmul fp2,fp0					; rval *= exp
00:00007B0E 4CD7001E        	   152: 	movem.l (sp),d1/d2/d3/d4
00:00007B12 F22F49000010    	   153: 	fmove.x 16(sp),fp2
00:00007B18 A2AF0003001C    	   154: 	cchk 28(sp)
00:00007B1E 4E5A            	   155: 	unlk a2
00:00007B20 4E75            	   156: 	rts	
                            	   157: 
                            	   158: ;-------------------------------------------------------------------------------
                            	   159: ; Get an integer number, positive or negative, 25 digits max, into a float
                            	   160: ; register.
                            	   161: ;
                            	   162: ; Register Usage:
                            	   163: ;		d1 = digit from input screen
                            	   164: ;		d2 = digit down counter
                            	   165: ;		d3 = sign of number '+' or '-'
                            	   166: ;		fp1 = digit
                            	   167: ; Modifies:
                            	   168: ;		a0,fp0
                            	   169: ; Returns:
                            	   170: ;		a0 = updated buffer pointer
                            	   171: ;		fp0 = integer number
                            	   172: ;-------------------------------------------------------------------------------
                            	   173: 
                            	   174: _GetInteger:
00:00007B22 4E52FFE4        	   175: 	link a2,#-28
00:00007B26 2F79000400980018	   176: 	move.l _canary,24(sp)
00:00007B2E 48D7000E        	   177: 	movem.l d1/d2/d3,(sp)
00:00007B32 F22F6880000C    	   178: 	fmove.x fp1,12(sp)
00:00007B38 F23C50000000    	   179: 	fmove.w #0,fp0
00:00007B3E 7418            	   180: 	moveq #24,d2					; d2 = digit count (25 max)
00:00007B40 6100FEE6        	   181: 	bsr _GetFloatIgnBlanks
00:00007B44 6100FEDC        	   182: 	bsr _GetFloatGetChar	; get the sign of the number
00:00007B48 0C01002B        	   183: 	cmpi.b #'+',d1
00:00007B4C 670A            	   184: 	beq .0002
                            	   185: .0003
00:00007B4E 0C01002D        	   186: 	cmpi.b #'-',d1
00:00007B52 6608            	   187: 	bne .0004
00:00007B54 1E3C002D        	   188: 	move.b #'-',d7
                            	   189: .0002
00:00007B58 6100FEC8        	   190: 	bsr _GetFloatGetChar
                            	   191: .0004
00:00007B5C 0C010030        	   192: 	cmpi.b #'0',d1				; only characters 0 to 9 valid
00:00007B60 651E            	   193: 	blo .0001
00:00007B62 0C010039        	   194: 	cmpi.b #'9',d1
00:00007B66 6218            	   195: 	bhi .0001
00:00007B68 04010030        	   196: 	subi.b #'0',d1
00:00007B6C F23C50260001    	   197: 	fscale.w #1,fp0				; number *10
00:00007B72 F2015880        	   198: 	fmove.b d1,fp1				; fp1 = digit
00:00007B76 F2000422        	   199: 	fadd fp1,fp0
00:00007B7A 5245            	   200: 	addq.w #1,d5
00:00007B7C 51CAFFDA        	   201: 	dbra d2,.0002
                            	   202: .0001
00:00007B80 6100FEAE        	   203: 	bsr _GetFloatBackupChar
00:00007B84 4CD7000E        	   204: 	movem.l (sp),d1/d2/d3
00:00007B88 F22F4880000C    	   205: 	fmove.x 12(sp),fp1
00:00007B8E A2AF00030018    	   206: 	cchk 24(sp)
00:00007B94 4E5A            	   207: 	unlk a2
00:00007B96 4E75            	   208: 	rts
                            	   209: 		
                            	   210: ;-------------------------------------------------------------------------------
                            	   211: ; Get a floating point number off the input screen.
                            	   212: ;
                            	   213: ; Parameters:
                            	   214: ;		a0 = pointer to buffer containing string
                            	   215: ;		d0 = stride of buffer (increment / decrement amount)
                            	   216: ; Register Usage:
                            	   217: ;		d1 = character from input screen
                            	   218: ;		d5.lo = number of digits in number, d5.hi = number of characters fetched
                            	   219: ; Returns:
                            	   220: ;		fp0 = number
                            	   221: ;		a0 = updated buffer pointer
                            	   222: ;		d0 = length of number >0 if a number
                            	   223: ;-------------------------------------------------------------------------------
                            	   224: 
                            	   225: _GetFloat:
00:00007B98 4E52FFE0        	   226: 	link a2,#-32
00:00007B9C 2F7900040098001C	   227: 	move.l _canary,28(sp)
00:00007BA4 48D702A2        	   228: 	movem.l d1/d5/d7/a1,(sp)
00:00007BA8 F22F69000010    	   229: 	fmove.x fp2,16(sp)
00:00007BAE 7A00            	   230: 	clr.l d5
00:00007BB0 1E3C002B        	   231: 	move.b #'+',d7				; assume a positive number
00:00007BB4 2248            	   232: 	move.l a0,a1					; a1 = copy of pointer to buffer
00:00007BB6 6100FF6A        	   233: 	bsr _GetInteger				; rval = integer
00:00007BBA F2000100        	   234: 	fmove.x fp0,fp2
00:00007BBE 6100FE62        	   235: 	bsr _GetFloatGetChar
00:00007BC2 0C01002E        	   236: 	cmpi.b #'.',d1
00:00007BC6 6706            	   237: 	beq .0004
                            	   238: .0005
00:00007BC8 6100FE66        	   239: 	bsr _GetFloatBackupChar
00:00007BCC 601C            	   240: 	bra .0002
                            	   241: .0004
00:00007BCE 6100FE64        	   242: 	bsr _GetFraction
00:00007BD2 F2000822        	   243: 	fadd fp2,fp0					; rval += fraction
00:00007BD6 6100FE4A        	   244: 	bsr _GetFloatGetChar
00:00007BDA 0C010065        	   245: 	cmpi.b #'e',d1				; accept either 'e' or 'E' indicating exponent
00:00007BDE 6706            	   246: 	beq .0001
00:00007BE0 0C010045        	   247: 	cmpi.b #'E',d1
00:00007BE4 66E2            	   248: 	bne .0005
                            	   249: .0001
00:00007BE6 6100FEB0        	   250: 	bsr _GetExponent			; factor exponent into fp0
                            	   251: .0002
00:00007BEA 0C07002D        	   252: 	cmpi.b #'-',d7				; adjust number for sign
00:00007BEE 6604            	   253: 	bne .0003
00:00007BF0 F200001A        	   254: 	fneg fp0
                            	   255: .0003
00:00007BF4 93C8            	   256: 	suba.l a0,a1					; compute number of characters fetched
00:00007BF6 3009            	   257: 	move.w a1,d0					; move it to d0.hi
00:00007BF8 4840            	   258: 	swap d0
00:00007BFA 3005            	   259: 	move.w d5,d0					; return digit/character count in d0 (non zero for a number)
00:00007BFC 4CD702A2        	   260: 	movem.l (sp),d1/d5/d7/a1
00:00007C00 F22F49000010    	   261: 	fmove.x 16(sp),fp2
00:00007C06 A2AF0003001C    	   262: 	cchk 28(sp)
00:00007C0C 4E5A            	   263: 	unlk a2
00:00007C0E 4E75            	   264: 	rts	
                            	   265: 
                            	   266: 		

Source: "boot.x68"
                            	  4042: 
                            	  4043: ;------------------------------------------------------------------------------
                            	  4044: ; Convert ASCII character in the range '0' to '9', 'a' tr 'f' or 'A' to 'F'
                            	  4045: ; to a hex nybble.
                            	  4046: ;------------------------------------------------------------------------------
                            	  4047: 
                            	  4048: AsciiToHexNybble:
00:00007C10 0C010030        	  4049: 	cmpi.b	#'0',d1
00:00007C14 6530            	  4050: 	blo.s		gthx3
00:00007C16 0C010039        	  4051: 	cmpi.b	#'9',d1
00:00007C1A 6206            	  4052: 	bhi.s		gthx5
00:00007C1C 04010030        	  4053: 	subi.b	#'0',d1
00:00007C20 4E75            	  4054: 	rts
                            	  4055: gthx5:
00:00007C22 0C010041        	  4056: 	cmpi.b	#'A',d1
00:00007C26 651E            	  4057: 	blo.s		gthx3
00:00007C28 0C010046        	  4058: 	cmpi.b	#'F',d1
00:00007C2C 6206            	  4059: 	bhi.s		gthx6
00:00007C2E 060100C9        	  4060: 	addi.b	#10-'A',d1
00:00007C32 4E75            	  4061: 	rts
                            	  4062: gthx6:
00:00007C34 0C010061        	  4063: 	cmpi.b	#'a',d1
00:00007C38 650C            	  4064: 	blo.s		gthx3
00:00007C3A 0C010066        	  4065: 	cmpi.b	#'f',d1
00:00007C3E 6206            	  4066: 	bhi.s		gthx3
00:00007C40 060100A9        	  4067: 	addi.b	#10-'a',d1
00:00007C44 4E75            	  4068: 	rts
                            	  4069: gthx3:
00:00007C46 72FF            	  4070: 	moveq	#-1,d1		; not a hex number
00:00007C48 4E75            	  4071: 	rts
                            	  4072: 
                            	  4073: ;------------------------------------------------------------------------------
                            	  4074: ;------------------------------------------------------------------------------
                            	  4075: 
                            	  4076: DisplayTwoSpaces:
00:00007C4A 2F01            	  4077: 	move.l	d1,-(a7)
00:00007C4C 123C0020        	  4078: 	move.b	#' ',d1
00:00007C50 61000B38        	  4079: 	bsr			OutputChar
                            	  4080: dspspc1:
00:00007C54 61000B34        	  4081: 	bsr			OutputChar
00:00007C58 221F            	  4082: 	move.l	(a7)+,d1
00:00007C5A 4E75            	  4083: 	rts
                            	  4084: 
                            	  4085: DisplaySpace:
00:00007C5C 2F01            	  4086: 	move.l	d1,-(a7)
00:00007C5E 123C0020        	  4087: 	move.b	#' ',d1
00:00007C62 60F0            	  4088: 	bra			dspspc1
                            	  4089: 
                            	  4090: ;------------------------------------------------------------------------------
                            	  4091: ; Display the 32 bit word in D1.L
                            	  4092: ;------------------------------------------------------------------------------
                            	  4093: 
                            	  4094: DisplayTetra:
00:00007C64 4841            	  4095: 	swap	d1
00:00007C66 6102            	  4096: 	bsr		DisplayWyde
00:00007C68 4841            	  4097: 	swap	d1
                            	  4098: 
                            	  4099: ;------------------------------------------------------------------------------
                            	  4100: ; Display the byte in D1.W
                            	  4101: ;------------------------------------------------------------------------------
                            	  4102: 
                            	  4103: DisplayWyde:
00:00007C6A E059            	  4104: 	ror.w		#8,d1
00:00007C6C 6102            	  4105: 	bsr			DisplayByte
00:00007C6E E159            	  4106: 	rol.w		#8,d1
                            	  4107: 
                            	  4108: ;------------------------------------------------------------------------------
                            	  4109: ; Display the byte in D1.B
                            	  4110: ;------------------------------------------------------------------------------
                            	  4111: 
                            	  4112: DisplayByte:
00:00007C70 E819            	  4113: 	ror.b		#4,d1
00:00007C72 6102            	  4114: 	bsr			DisplayNybble
00:00007C74 E919            	  4115: 	rol.b		#4,d1
                            	  4116: 
                            	  4117: ;------------------------------------------------------------------------------
                            	  4118: ; Display nybble in D1.B
                            	  4119: ;------------------------------------------------------------------------------
                            	  4120: 
                            	  4121: DisplayNybble:
00:00007C76 2F01            	  4122: 	move.l	d1,-(a7)
00:00007C78 0201000F        	  4123: 	andi.b	#$F,d1
00:00007C7C 06010030        	  4124: 	addi.b	#'0',d1
00:00007C80 0C010039        	  4125: 	cmpi.b	#'9',d1
00:00007C84 6302            	  4126: 	bls.s		.0001
00:00007C86 5E01            	  4127: 	addi.b	#7,d1
                            	  4128: .0001:
00:00007C88 61000B00        	  4129: 	bsr			OutputChar
00:00007C8C 221F            	  4130: 	move.l	(a7)+,d1
00:00007C8E 4E75            	  4131: 	rts
                            	  4132: 
                            	  4133: ;------------------------------------------------------------------------------
                            	  4134: ; Buffer tetra in d0 to buffer pointed to by a6
                            	  4135: ;------------------------------------------------------------------------------
                            	  4136: 
                            	  4137: BufTetra:
00:00007C90 4840            	  4138: 	swap d0
00:00007C92 6102            	  4139: 	bsr BufWyde
00:00007C94 4840            	  4140: 	swap d0
                            	  4141: 
                            	  4142: BufWyde:
00:00007C96 E058            	  4143: 	ror.w #8,d0
00:00007C98 6102            	  4144: 	bsr BufByte
00:00007C9A E158            	  4145: 	rol.w #8,d0
                            	  4146: 	
                            	  4147: BufByte:
00:00007C9C E818            	  4148: 	ror.b #4,d0
00:00007C9E 6102            	  4149: 	bsr BufNybble
00:00007CA0 E918            	  4150: 	rol.b #4,d0
                            	  4151: 
                            	  4152: BufNybble:
00:00007CA2 2F00            	  4153: 	move.l d0,-(a7)
00:00007CA4 0200000F        	  4154: 	andi.b #$F,d0
00:00007CA8 06000030        	  4155: 	addi.b #'0',d0
00:00007CAC 0C000039        	  4156: 	cmpi.b #'9',d0
00:00007CB0 6302            	  4157: 	bls.s .0001
00:00007CB2 5E00            	  4158: 	addi.b #7,d0
                            	  4159: .0001:
00:00007CB4 1CC0            	  4160: 	move.b d0,(a6)+
00:00007CB6 201F            	  4161: 	move.l (a7)+,d0
00:00007CB8 4E75            	  4162: 	rts
                            	  4163: 
                            	  4164: ;------------------------------------------------------------------------------
                            	  4165: ;------------------------------------------------------------------------------
                            	  4166: ;
                            	  4167: ;DisplayHexNumber:
                            	  4168: ;	move.w	#$A6A6,leds		; diagnostics
                            	  4169: ;	move.l	#VDGREG,a6
                            	  4170: ;	move.w	#7,d2		; number-1 of digits to display
                            	  4171: ;disphnum1:
                            	  4172: ;	move.b	d1,d0		; get digit into d0.b
                            	  4173: ;	andi.w	#$0f,d0
                            	  4174: ;	cmpi.w	#$09,d0
                            	  4175: ;	bls.s	disphnum2
                            	  4176: ;	addi.w	#7,d0
                            	  4177: ;disphnum2:
                            	  4178: ;	addi.w	#$30,d0	; convert to display char
                            	  4179: ;	move.w	d2,d3		; char count into d3
                            	  4180: ;	asl.w	#3,d3		; scale * 8
                            	  4181: ;disphnum3:
                            	  4182: ;	move.w	$42C(a6),d4			; read character queue index into d4
                            	  4183: ;	cmp.w	#28,d4					; allow up 28 entries to be in progress
                            	  4184: ;	bhs.s	disphnum3				; branch if too many chars queued
                            	  4185: ;	ext.w	d0						; zero out high order bits
                            	  4186: ;	move.w	d0,$420(a6)			; set char code
                            	  4187: ;	move.w	#WHITE,$422(a6)		; set fg color
                            	  4188: ;	move.w	#DARK_BLUE,$424(a6)	; set bk color
                            	  4189: ;	move.w	d3,$426(a6)			; set x pos
                            	  4190: ;	move.w	#8,$428(a6)			; set y pos
                            	  4191: ;	move.w	#$0707,$42A(a6)		; set font x,y extent
                            	  4192: ;	move.w	#0,$42E(a6)			; pulse character queue write signal
                            	  4193: ;	ror.l	#4,d1					; rot to next digit
                            	  4194: ;	dbeq	d2,disphnum1
                            	  4195: ;	jmp		(a5)
                            	  4196: 
                            	  4197: 	include "ramtest.x68"

Source: "ramtest.x68"
                            	     1: ;===============================================================================
                            	     2: ;    Perform ram test. (Uses checkerboard testing).
                            	     3: ; 
                            	     4: ;    Local ram, which does not get tested, is used for the stack.
                            	     5: ;===============================================================================
                            	     6: 	code
                            	     7: 	even
                            	     8: DisplayAddr:
00:00007CBA 2208            	     9: 	move.l a0,d1
00:00007CBC E089            	    10: 	lsr.l #8,d1
00:00007CBE E089            	    11: 	lsr.l #8,d1
00:00007CC0 E889            	    12: 	lsr.l #4,d1
00:00007CC2 04410400        	    13: 	subi.w #1024,d1
00:00007CC6 A2C10000        	    14: 	bin2bcd d1
00:00007CCA 619E            	    15: 	bsr	DisplayWyde
00:00007CCC 618E            	    16: 	bsr DisplaySpace
00:00007CCE 123C000D        	    17: 	move.b #CR,d1
00:00007CD2 6000DDE4        	    18: 	bra DisplayChar
00:00007CD6 08000083        	    19: 	btst #$83,d0
                            	    20: 	
                            	    21: cmdTestRAM:
                            	    22: ramtest:
00:00007CDA 33FCA5A5FD0FFF00	    23: 	move.w	#$A5A5,leds		; diagnostics
00:00007CE2 263CAAAAAAAA    	    24:   move.l #$aaaaaaaa,d3
00:00007CE8 283C55555555    	    25:   move.l #$55555555,d4
00:00007CEE 6134            	    26:   bsr ramtest0
                            	    27:   ; switch checkerboard pattern and repeat test.
00:00007CF0 C744            	    28:   exg d3,d4
00:00007CF2 6130            	    29:   bsr ramtest0
                            	    30: 	; Save last ram address in end of memory pointer.
                            	    31: rmtst5:
00:00007CF4 7025            	    32: 	moveq #37,d0					; lock semaphore
00:00007CF6 7206            	    33: 	moveq #MEMORY_SEMA,d1
                            	    34: ;	trap #15
00:00007CF8 207C7FFFFFF8    	    35:   movea.l #$7FFFFFF8,a0
00:00007CFE 23C800100004    	    36:   move.l a0,memend
                            	    37: 	; Create very first memory block.
00:00007D04 207C3FFFFFF4    	    38:   movea.l #$3FFFFFF4,a0
00:00007D0A 23C840000004    	    39:   move.l a0,$40000004		; length of block
00:00007D10 23FC465245454000	    40:   move.l #$46524545,$40000000
00:00007D18 0000
00:00007D1A 7026            	    41: 	moveq #38,d0					; unlock semaphore
00:00007D1C 7206            	    42: 	moveq #MEMORY_SEMA,d1
00:00007D1E 4E4F            	    43: 	trap #15
00:00007D20 6000F08A        	    44: 	bra Monitor
                            	    45: ;  rts
                            	    46: 
                            	    47: ramtest0:
00:00007D24 2003            	    48: 	move.l d3,d0
00:00007D26 207C40000000    	    49:   movea.l #$40000000,a0
                            	    50: ;-----------------------------------------------------------
                            	    51: ;   Write checkerboard pattern to ram then read it back to
                            	    52: ; find the highest usable ram address (maybe). This address
                            	    53: ; must be lower than the start of the rom (0xe00000).
                            	    54: ;-----------------------------------------------------------
                            	    55: ramtest1:
00:00007D2C 20C3            	    56:   move.l d3,(a0)+
00:00007D2E 20C4            	    57:   move.l d4,(a0)+
00:00007D30 2208            	    58:   move.l a0,d1
00:00007D32 4A41            	    59:   tst.w	d1
00:00007D34 6606            	    60:   bne.s rmtst1
00:00007D36 6182            	    61:   bsr DisplayAddr
00:00007D38 6100E936        	    62:   bsr CheckForCtrlC
                            	    63: rmtst1:
00:00007D3C B1FC7FFFFFF8    	    64:   cmpa.l #$7FFFFFF8,a0
00:00007D42 65E8            	    65:   blo.s ramtest1
00:00007D44 6100DD20        	    66:   bsr	CRLF
                            	    67: ;------------------------------------------------------
                            	    68: ;   Save maximum useable address for later comparison.
                            	    69: ;------------------------------------------------------
                            	    70: ramtest6:
00:00007D48 33FCA7A7FD0FFF00	    71: 	move.w	#$A7A7,leds		; diagnostics
00:00007D50 2448            	    72:   movea.l a0,a2
00:00007D52 207C40000000    	    73:   movea.l #$40000000,a0
                            	    74: ;--------------------------------------------
                            	    75: ;   Read back checkerboard pattern from ram.
                            	    76: ;--------------------------------------------
                            	    77: ramtest2
00:00007D58 2A18            	    78:   move.l (a0)+,d5
00:00007D5A 2C18            	    79:   move.l (a0)+,d6
00:00007D5C B1CA            	    80:   cmpa.l a2,a0
00:00007D5E 643A            	    81:   bhs.s	ramtest3
00:00007D60 2208            	    82:   move.l a0,d1
00:00007D62 4A41            	    83:   tst.w	d1
00:00007D64 6608            	    84:   bne.s	rmtst2
00:00007D66 6100FF52        	    85:   bsr	DisplayAddr
00:00007D6A 6100E904        	    86: 	bsr CheckForCtrlC
                            	    87: rmtst2
00:00007D6E BA83            	    88:   cmp.l d3,d5
00:00007D70 6604            	    89:   bne.s rmtst3
00:00007D72 BC84            	    90:   cmp.l d4,d6
00:00007D74 67E2            	    91:   beq.s ramtest2
                            	    92: ;----------------------------------
                            	    93: ; Report error in ram.
                            	    94: ;----------------------------------
                            	    95: rmtst3
00:00007D76 6100DCEE        	    96: 	bsr CRLF
00:00007D7A 7245            	    97: 	moveq	#'E',d1
00:00007D7C 6100DD3A        	    98: 	bsr DisplayChar
00:00007D80 6100FEDA        	    99: 	bsr DisplaySpace
00:00007D84 2208            	   100: 	move.l a0,d1
00:00007D86 6100FEDC        	   101: 	bsr DisplayTetra
00:00007D8A 6100FED0        	   102: 	bsr DisplaySpace
00:00007D8E 2205            	   103: 	move.l d5,d1
00:00007D90 6100FED2        	   104: 	bsr DisplayTetra
00:00007D94 6100E8DA        	   105: 	bsr CheckForCtrlC
00:00007D98 60BE            	   106: 	bra ramtest2
                            	   107: ramtest3
00:00007D9A 4E75            	   108: 	rts
                            	   109: 

Source: "boot.x68"
                            	  4198: 	include "LoadS19.x68"

Source: "LoadS19.x68"
                            	     1: ;==============================================================================
                            	     2: ; Load an S19 format file
                            	     3: ;==============================================================================
                            	     4: 	code
                            	     5: 	even
                            	     6: cmdLoadS19:
00:00007D9C 6100DCC8        	     7: 	bsr			CRLF					; move display to next line
00:00007DA0 6012            	     8: 	bra			ProcessRec
                            	     9: NextRec:
00:00007DA2 610001DC        	    10: 	bsr			sGetChar			; get character from serial port routines
00:00007DA6 0C01000A        	    11: 	cmpi.b	#LF,d1				; look for a line-feed
00:00007DAA 66F6            	    12: 	bne			NextRec
00:00007DAC 123C002E        	    13: 	move.b	#'.',d1				; progress display
00:00007DB0 6100DD06        	    14: 	bsr			DisplayChar
                            	    15: ProcessRec:
00:00007DB4 6100E8BA        	    16: 	bsr			CheckForCtrlC	; check for CTRL-C once per record
00:00007DB8 610001C6        	    17: 	bsr			sGetChar
00:00007DBC 0C01000D        	    18: 	cmpi.b	#CR,d1
00:00007DC0 67F2            	    19: 	beq.s		ProcessRec
00:00007DC2 423900100150    	    20: 	clr.b		S19Checksum		; clear the checksum
00:00007DC8 1801            	    21: 	move.b	d1,d4
00:00007DCA 0C04001A        	    22: 	cmpi.b	#CTRLZ,d4			; CTRL-Z ?
00:00007DCE 6700EFDC        	    23: 	beq			Monitor
00:00007DD2 0C040053        	    24: 	cmpi.b	#'S',d4				; All records must begin with an 'S'
00:00007DD6 66CA            	    25: 	bne.s		NextRec
00:00007DD8 610001A6        	    26: 	bsr			sGetChar
00:00007DDC 1801            	    27: 	move.b	d1,d4
00:00007DDE 0C040030        	    28: 	cmpi.b	#'0',d4				; Record type must be between '0' and '9'
00:00007DE2 65BE            	    29: 	blo.s		NextRec
00:00007DE4 0C040039        	    30: 	cmpi.b	#'9',d4				; d4 = record type
00:00007DE8 62B8            	    31: 	bhi.s		NextRec
00:00007DEA 61000194        	    32: 	bsr			sGetChar			; get byte count for record
00:00007DEE 6100FE20        	    33: 	bsr			AsciiToHexNybble
00:00007DF2 1401            	    34: 	move.b	d1,d2
00:00007DF4 6100018A        	    35: 	bsr			sGetChar
00:00007DF8 6100FE16        	    36: 	bsr			AsciiToHexNybble
00:00007DFC E90A            	    37: 	lsl.b		#4,d2
00:00007DFE 8202            	    38: 	or.b		d2,d1					; d1 = byte count
00:00007E00 1601            	    39: 	move.b	d1,d3					; d3 = byte count
00:00007E02 D73900100150    	    40: 	add.b		d3,S19Checksum
00:00007E08 0C040030        	    41: 	cmpi.b	#'0',d4				; manufacturer ID record, ignore
00:00007E0C 6794            	    42: 	beq			NextRec
00:00007E0E 0C040031        	    43: 	cmpi.b	#'1',d4
00:00007E12 670000A2        	    44: 	beq			ProcessS1
00:00007E16 0C040032        	    45: 	cmpi.b	#'2',d4
00:00007E1A 6700009E        	    46: 	beq			ProcessS2
00:00007E1E 0C040033        	    47: 	cmpi.b	#'3',d4
00:00007E22 6700009A        	    48: 	beq			ProcessS3
00:00007E26 0C040035        	    49: 	cmpi.b	#'5',d4				; record count record, ignore
00:00007E2A 6700FF76        	    50: 	beq			NextRec
00:00007E2E 0C040037        	    51: 	cmpi.b	#'7',d4
00:00007E32 6700008E        	    52: 	beq			ProcessS7
00:00007E36 0C040038        	    53: 	cmpi.b	#'8',d4
00:00007E3A 67000096        	    54: 	beq			ProcessS8
00:00007E3E 0C040039        	    55: 	cmpi.b	#'9',d4
00:00007E42 6700009E        	    56: 	beq			ProcessS9
00:00007E46 6000FF5A        	    57: 	bra			NextRec
                            	    58: 
                            	    59: pcssxa:
00:00007E4A 2209            	    60: 	move.l	a1,d1
00:00007E4C 6100FE16        	    61: 	bsr			DisplayTetra
00:00007E50 123C000D        	    62: 	move.b	#CR,d1
00:00007E54 6100DC62        	    63: 	bsr			DisplayChar
00:00007E58 024300FF        	    64: 	andi.w	#$ff,d3
00:00007E5C 5343            	    65: 	subi.w	#1,d3			; one less for dbra
                            	    66: .0001:
00:00007E5E 7400            	    67: 	clr.l		d2
00:00007E60 6100011E        	    68: 	bsr			sGetChar
00:00007E64 6100FDAA        	    69: 	bsr			AsciiToHexNybble
00:00007E68 E98A            	    70: 	lsl.l		#4,d2
00:00007E6A 8401            	    71: 	or.b		d1,d2
00:00007E6C 61000112        	    72: 	bsr			sGetChar
00:00007E70 6100FD9E        	    73: 	bsr			AsciiToHexNybble
00:00007E74 E98A            	    74: 	lsl.l		#4,d2
00:00007E76 8401            	    75: 	or.b		d1,d2
00:00007E78 D53900100150    	    76: 	add.b		d2,S19Checksum
00:00007E7E 12C2            	    77: 	move.b	d2,(a1)+			; move byte to memory
00:00007E80 51CBFFDC        	    78: 	dbra		d3,.0001
                            	    79: 	; Get the checksum byte
00:00007E84 7400            	    80: 	clr.l		d2
00:00007E86 610000F8        	    81: 	bsr			sGetChar
00:00007E8A 6100FD84        	    82: 	bsr			AsciiToHexNybble
00:00007E8E E98A            	    83: 	lsl.l		#4,d2
00:00007E90 8401            	    84: 	or.b		d1,d2
00:00007E92 610000EC        	    85: 	bsr			sGetChar
00:00007E96 6100FD78        	    86: 	bsr			AsciiToHexNybble
00:00007E9A E98A            	    87: 	lsl.l		#4,d2
00:00007E9C 8401            	    88: 	or.b		d1,d2
00:00007E9E 4602            	    89: 	eor.b		#$FF,d2
00:00007EA0 B43900100150    	    90: 	cmp.b		S19Checksum,d2
00:00007EA6 6700FEFA        	    91: 	beq			NextRec
00:00007EAA 123C0045        	    92: 	move.b	#'E',d1
00:00007EAE 6100DC08        	    93: 	bsr			DisplayChar
00:00007EB2 6000FEEE        	    94: 	bra			NextRec
                            	    95: 
                            	    96: ProcessS1:
00:00007EB6 613A            	    97: 	bsr			S19Get16BitAddress
00:00007EB8 6090            	    98: 	bra			pcssxa
                            	    99: ProcessS2:
00:00007EBA 6144            	   100: 	bsr			S19Get24BitAddress
00:00007EBC 608C            	   101: 	bra			pcssxa
                            	   102: ProcessS3:
00:00007EBE 614C            	   103: 	bsr			S19Get32BitAddress
00:00007EC0 6088            	   104: 	bra			pcssxa
                            	   105: ProcessS7:
00:00007EC2 6148            	   106: 	bsr			S19Get32BitAddress
00:00007EC4 23C900040008    	   107: 	move.l	a1,S19StartAddress
00:00007ECA 6100E5AC        	   108: 	bsr			_KeybdInit
00:00007ECE 6000EEDC        	   109: 	bra			Monitor
                            	   110: ProcessS8:
00:00007ED2 612C            	   111: 	bsr			S19Get24BitAddress
00:00007ED4 23C900040008    	   112: 	move.l	a1,S19StartAddress
00:00007EDA 6100E59C        	   113: 	bsr			_KeybdInit
00:00007EDE 6000EECC        	   114: 	bra			Monitor
                            	   115: ProcessS9:
00:00007EE2 610E            	   116: 	bsr			S19Get16BitAddress
00:00007EE4 23C900040008    	   117: 	move.l	a1,S19StartAddress
00:00007EEA 6100E58C        	   118: 	bsr			_KeybdInit
00:00007EEE 6000EEBC        	   119: 	bra			Monitor
                            	   120: 
                            	   121: S19Get16BitAddress:
00:00007EF2 7400            	   122: 	clr.l		d2
00:00007EF4 6100008A        	   123: 	bsr			sGetChar
00:00007EF8 6100FD16        	   124: 	bsr			AsciiToHexNybble
00:00007EFC 1401            	   125: 	move.b	d1,d2
00:00007EFE 603E            	   126: 	bra			S1932b
                            	   127: 
                            	   128: S19Get24BitAddress:
00:00007F00 7400            	   129: 	clr.l		d2
00:00007F02 617C            	   130: 	bsr			sGetChar
00:00007F04 6100FD0A        	   131: 	bsr			AsciiToHexNybble
00:00007F08 1401            	   132: 	move.b	d1,d2
00:00007F0A 601E            	   133: 	bra			S1932a
                            	   134: 
                            	   135: S19Get32BitAddress:
00:00007F0C 7400            	   136: 	clr.l		d2
00:00007F0E 6170            	   137: 	bsr			sGetChar
00:00007F10 6100FCFE        	   138: 	bsr			AsciiToHexNybble
00:00007F14 1401            	   139: 	move.b	d1,d2
00:00007F16 6168            	   140: 	bsr			sGetChar
00:00007F18 6100FCF6        	   141: 	bsr			AsciiToHexNybble
00:00007F1C E98A            	   142: 	lsl.l		#4,d2
00:00007F1E 8401            	   143: 	or.b		d1,d2
00:00007F20 615E            	   144: 	bsr			sGetChar
00:00007F22 6100FCEC        	   145: 	bsr			AsciiToHexNybble
00:00007F26 E98A            	   146: 	lsl.l		#4,d2
00:00007F28 8401            	   147: 	or.b		d1,d2
                            	   148: S1932a:
00:00007F2A 6154            	   149: 	bsr			sGetChar
00:00007F2C 6100FCE2        	   150: 	bsr			AsciiToHexNybble
00:00007F30 E98A            	   151: 	lsl.l		#4,d2
00:00007F32 8401            	   152: 	or.b		d1,d2
00:00007F34 614A            	   153: 	bsr			sGetChar
00:00007F36 6100FCD8        	   154: 	bsr			AsciiToHexNybble
00:00007F3A E98A            	   155: 	lsl.l		#4,d2
00:00007F3C 8401            	   156: 	or.b		d1,d2
                            	   157: S1932b:
00:00007F3E 6140            	   158: 	bsr			sGetChar
00:00007F40 6100FCCE        	   159: 	bsr			AsciiToHexNybble
00:00007F44 E98A            	   160: 	lsl.l		#4,d2
00:00007F46 8401            	   161: 	or.b		d1,d2
00:00007F48 6136            	   162: 	bsr			sGetChar
00:00007F4A 6100FCC4        	   163: 	bsr			AsciiToHexNybble
00:00007F4E E98A            	   164: 	lsl.l		#4,d2
00:00007F50 8401            	   165: 	or.b		d1,d2
00:00007F52 612C            	   166: 	bsr			sGetChar
00:00007F54 6100FCBA        	   167: 	bsr			AsciiToHexNybble
00:00007F58 E98A            	   168: 	lsl.l		#4,d2
00:00007F5A 8401            	   169: 	or.b		d1,d2
00:00007F5C 7800            	   170: 	clr.l		d4
00:00007F5E 2242            	   171: 	move.l	d2,a1
                            	   172: 	; Add bytes from address value to checksum
00:00007F60 D53900100150    	   173: 	add.b		d2,S19Checksum
00:00007F66 E08A            	   174: 	lsr.l		#8,d2
00:00007F68 D53900100150    	   175: 	add.b		d2,S19Checksum
00:00007F6E E08A            	   176: 	lsr.l		#8,d2
00:00007F70 D53900100150    	   177: 	add.b		d2,S19Checksum
00:00007F76 E08A            	   178: 	lsr.l		#8,d2
00:00007F78 D53900100150    	   179: 	add.b		d2,S19Checksum
00:00007F7E 4E75            	   180: 	rts
                            	   181: 
                            	   182: ;------------------------------------------------------------------------------
                            	   183: ; Get a character from auxillary input. Waiting for a character is limited to
                            	   184: ; 32000 tries. If a character is not available within the limit, then a return
                            	   185: ; to the monitor is done.
                            	   186: ;
                            	   187: ;	Parameters:
                            	   188: ;		none
                            	   189: ; Returns:
                            	   190: ;		d1 = character from receive buffer or -1 if no char available
                            	   191: ;------------------------------------------------------------------------------
                            	   192: 
                            	   193: sGetChar:
00:00007F80 48E7A000        	   194: 	movem.l	d0/d2,-(a7)
00:00007F84 343C7D00        	   195: 	move.w	#32000,d2
                            	   196: .0001:
00:00007F88 7024            	   197: 	moveq		#36,d0				; serial get char from buffer
00:00007F8A 4E4F            	   198: 	trap		#15
00:00007F8C 4A41            	   199: 	tst.w		d1						; was there a char available?
00:00007F8E 6A0C            	   200: 	bpl.s		.0002
00:00007F90 51CAFFF6        	   201: 	dbra		d2,.0001			; no - try again
00:00007F94 4CDF0005        	   202: 	movem.l	(a7)+,d0/d2
                            	   203: .0003:
                            	   204: ;	bsr			_KeybdInit
00:00007F98 6000EE12        	   205: 	bra			Monitor				; ran out of tries
                            	   206: .0002:
00:00007F9C 4CDF0005        	   207: 	movem.l	(a7)+,d0/d2
00:00007FA0 0C01001A        	   208: 	cmpi.b	#CTRLZ,d1			; receive end of file?
00:00007FA4 67F2            	   209: 	beq			.0003
00:00007FA6 4E75            	   210: 	rts
                            	   211: 
                            	   212: 

Source: "boot.x68"
                            	  4199: 	
                            	  4200: AudioInputTest:
00:00007FA8 4E75            	  4201: 	rts
                            	  4202: BouncingBalls:
00:00007FAA 4E75            	  4203: 	rts
                            	  4204: GraphicsDemo:
00:00007FAC 4E75            	  4205: 	rts
                            	  4206: ClearScreen:
00:00007FAE 6000DA7A        	  4207: 	bra		clear_screen
00:00007FB2 4E75            	  4208: 	rts
                            	  4209: 
                            	  4210: ;------------------------------------------------------------------------------
                            	  4211: ; Reverse the order of bytes in d1.
                            	  4212: ;------------------------------------------------------------------------------
                            	  4213: 
                            	  4214: rbo:
00:00007FB4 E159            	  4215: 	rol.w	#8,d1
00:00007FB6 4841            	  4216: 	swap d1
00:00007FB8 E159            	  4217: 	rol.w	#8,d1
00:00007FBA 4E75            	  4218: 	rts
                            	  4219: 
                            	  4220: ;==============================================================================
                            	  4221: ; Serial I/O routines
                            	  4222: ;==============================================================================
                            	  4223: 
                            	  4224: ;------------------------------------------------------------------------------
                            	  4225: ; Setup the console device
                            	  4226: ; stdout = text screen controller
                            	  4227: ;------------------------------------------------------------------------------
                            	  4228: 
                            	  4229: serial_init:
                            	  4230: setup_serial:
00:00007FBC 701F            	  4231: 	moveq #31,d0
00:00007FBE 41F900040B40    	  4232: 	lea.l serial_dcb,a0
                            	  4233: .0001:
00:00007FC4 4298            	  4234: 	clr.l (a0)+
00:00007FC6 51C8FFFC        	  4235: 	dbra d0,.0001
00:00007FCA 23FC204243440004	  4236: 	move.l #$20424344,serial_dcb+DCB_MAGIC				; 'DCB'
00:00007FD2 0B40
00:00007FD4 23FC204F4F430004	  4237: 	move.l #$204F4F43,serial_dcb+DCB_NAME				; 'COM'
00:00007FDC 0B44
00:00007FDE 23FC0000803C0004	  4238: 	move.l #serial_cmdproc,serial_dcb+DCB_CMDPROC
00:00007FE6 0B58
00:00007FE8 23FC001010000004	  4239: 	move.l #SerRcvBuf,serial_dcb+DCB_INBUFPTR
00:00007FF0 0B68
00:00007FF2 23FC001020000004	  4240: 	move.l #SerXmitBuf,serial_dcb+DCB_OUTBUFPTR
00:00007FFA 0B6C
00:00007FFC 23FC000010000004	  4241: 	move.l #4096,serial_dcb+DCB_INBUFSIZE
00:00008004 0B70
00:00008006 61000090        	  4242: 	bsr SerialInit
00:0000800A 4E75            	  4243: 	rts
                            	  4244: 
                            	  4245: 	align 2
                            	  4246: COM_CMDTBL:
00:0000800C 00007FBC        	  4247: 	dc.l serial_init
00:00008010 00008062        	  4248: 	dc.l serial_stat
00:00008014 00008066        	  4249: 	dc.l serial_putchar
00:00008018 00008094        	  4250: 	dc.l serial_putbuf
00:0000801C 0000806E        	  4251: 	dc.l serial_getchar
00:00008020 00008094        	  4252: 	dc.l serial_getbuf
00:00008024 00008094        	  4253: 	dc.l serial_set_inpos
00:00008028 00008094        	  4254: 	dc.l serial_set_outpos
00:0000802C 00008074        	  4255: 	dc.l serial_getchar_direct
00:00008030 0000807C        	  4256: 	dc.l serial_peek_char
00:00008034 00008084        	  4257: 	dc.l serial_peek_char_direct
00:00008038 0000808C        	  4258: 	dc.l serial_putchar_direct
                            	  4259: 
                            	  4260: serial_cmdproc:
00:0000803C 0C06000C        	  4261: 	cmpi.b #12,d6
00:00008040 641C            	  4262: 	bhs.s .0001
00:00008042 4A06            	  4263: 	tst.b d6
00:00008044 6B18            	  4264: 	bmi.s .0001
00:00008046 48E70280        	  4265: 	movem.l d6/a0,-(a7)
00:0000804A E506            	  4266: 	asl.b #2,d6
00:0000804C 4886            	  4267: 	ext.w d6
00:0000804E 41FAFFBC        	  4268: 	lea COM_CMDTBL,a0
00:00008052 20706000        	  4269: 	move.l (a0,d6.w),a0
00:00008056 4E90            	  4270: 	jsr (a0)
00:00008058 4CDF0140        	  4271: 	movem.l (a7)+,d6/a0
00:0000805C 4E75            	  4272: 	rts
                            	  4273: .0001:
00:0000805E 7002            	  4274: 	moveq #E_Func,d0
00:00008060 4E75            	  4275: 	rts
                            	  4276: 
                            	  4277: serial_stat:
00:00008062 7000            	  4278: 	moveq #E_Ok,d0
00:00008064 4E75            	  4279: 	rts
                            	  4280: 
                            	  4281: serial_putchar:
00:00008066 6100013C        	  4282: 	bsr SerialPutChar
00:0000806A 7000            	  4283: 	moveq #E_Ok,d0
00:0000806C 4E75            	  4284: 	rts
                            	  4285: 
                            	  4286: serial_getchar:
00:0000806E 6166            	  4287: 	bsr SerialGetChar
00:00008070 7000            	  4288: 	moveq #E_Ok,d0
00:00008072 4E75            	  4289: 	rts
                            	  4290: 
                            	  4291: serial_getchar_direct:
00:00008074 61000114        	  4292: 	bsr SerialPeekCharDirect
00:00008078 7000            	  4293: 	moveq #E_Ok,d0
00:0000807A 4E75            	  4294: 	rts
                            	  4295: 
                            	  4296: serial_peek_char:
00:0000807C 610000D0        	  4297: 	bsr SerialPeekChar
00:00008080 7000            	  4298: 	moveq #E_Ok,d0
00:00008082 4E75            	  4299: 	rts
                            	  4300: 
                            	  4301: serial_peek_char_direct:
00:00008084 61000104        	  4302: 	bsr SerialPeekCharDirect
00:00008088 7000            	  4303: 	moveq #E_Ok,d0
00:0000808A 4E75            	  4304: 	rts
                            	  4305: 
                            	  4306: serial_putchar_direct:
00:0000808C 6100017A        	  4307: 	bsr SerialPutCharDirect
00:00008090 7000            	  4308: 	moveq #E_Ok,d0
00:00008092 4E75            	  4309: 	rts
                            	  4310: 
                            	  4311: serial_putbuf:
                            	  4312: serial_getbuf:
                            	  4313: serial_set_inpos:
                            	  4314: serial_set_outpos:
00:00008094 700A            	  4315: 	moveq #E_NotSupported,d0
00:00008096 4E75            	  4316: 	rts
                            	  4317: 
                            	  4318: ;------------------------------------------------------------------------------
                            	  4319: ; Initialize the serial port an enhanced 6551 circuit.
                            	  4320: ;
                            	  4321: ; Select internal baud rate clock divider for 9600 baud
                            	  4322: ; Reset fifos, set threshold to 3/4 full on transmit and 3/4 empty on receive
                            	  4323: ; Note that the byte order is swapped.
                            	  4324: ;------------------------------------------------------------------------------
                            	  4325: 
                            	  4326: SerialInit:
00:00008098 427900100162    	  4327: 	clr.w		SerHeadRcv					; clear receive buffer indexes
00:0000809E 427900100160    	  4328: 	clr.w		SerTailRcv
00:000080A4 427900100168    	  4329: 	clr.w		SerHeadXmit					; clear transmit buffer indexes
00:000080AA 427900100166    	  4330: 	clr.w		SerTailXmit
00:000080B0 423900100164    	  4331: 	clr.b		SerRcvXon						; and Xon,Xoff flags
00:000080B6 423900100165    	  4332: 	clr.b		SerRcvXoff
00:000080BC 203C09000000    	  4333: 	move.l	#$09000000,d0				; dtr,rts active, rxint enabled, no parity
00:000080C2 23C0FD060008    	  4334: 	move.l	d0,ACIA+ACIA_CMD
                            	  4335: ;	move.l	#$1E00F700,d0				; fifos enabled
00:000080C8 203C1E000000    	  4336: 	move.l	#$1E000000,d0				; fifos disabled
00:000080CE 23C0FD06000C    	  4337: 	move.l	d0,ACIA+ACIA_CTRL
00:000080D4 4E75            	  4338: 	rts
                            	  4339: ;	move.l	#$0F000000,d0				; transmit a break for a while
                            	  4340: ;	move.l	d0,ACIA+ACIA_CMD
                            	  4341: ;	move.l	#300000,d2					; wait 100 ms
                            	  4342: ;	bra			.0001
                            	  4343: ;.0003:
                            	  4344: ;	swap		d2
                            	  4345: ;.0001:
                            	  4346: ;	nop
                            	  4347: ;	dbra		d2,.0001
                            	  4348: ;.0002:
                            	  4349: ;	swap		d2
                            	  4350: ;	dbra		d2,.0003
                            	  4351: ;	move.l	#$07000000,d0				; clear break
                            	  4352: ;	move.l	d0,ACIA+ACIA_CMD
                            	  4353: ;	rts
                            	  4354: 	
                            	  4355: ;------------------------------------------------------------------------------
                            	  4356: ; SerialGetChar
                            	  4357: ;
                            	  4358: ; Check the serial port buffer to see if there's a char available. If there's
                            	  4359: ; a char available then return it. If the buffer is almost empty then send an
                            	  4360: ; XON.
                            	  4361: ;
                            	  4362: ; Stack Space:
                            	  4363: ;		2 long words
                            	  4364: ; Parameters:
                            	  4365: ;		none
                            	  4366: ; Modifies:
                            	  4367: ;		d0,a0
                            	  4368: ; Returns:
                            	  4369: ;		d1 = character or -1
                            	  4370: ;------------------------------------------------------------------------------
                            	  4371: 
                            	  4372: SerialGetChar:
00:000080D6 2F02            	  4373: 	move.l		d2,-(a7)
00:000080D8 4E7A0FE0        	  4374: 	movec			coreno,d0
00:000080DC 4840            	  4375: 	swap			d0
00:000080DE 7202            	  4376: 	moveq			#SERIAL_SEMA,d1
00:000080E0 610086C6        	  4377: 	bsr				LockSemaphore
00:000080E4 61000146        	  4378: 	bsr				SerialRcvCount			; check number of chars in receive buffer
00:000080E8 0C400008        	  4379: 	cmpi.w		#8,d0								; less than 8?
00:000080EC 621C            	  4380: 	bhi				.sgc2
00:000080EE 4A3900100164    	  4381: 	tst.b			SerRcvXon						; skip sending XON if already sent
00:000080F4 6614            	  4382: 	bne	  		.sgc2            		; XON already sent?
00:000080F6 123C0011        	  4383: 	move.b		#XON,d1							; if <8 send an XON
00:000080FA 423900100165    	  4384: 	clr.b			SerRcvXoff					; clear XOFF status
00:00008100 13C100100164    	  4385: 	move.b		d1,SerRcvXon				; flag so we don't send it multiple times
00:00008106 6100009C        	  4386: 	bsr				SerialPutChar				; send it
                            	  4387: .sgc2:
00:0000810A 323900100162    	  4388: 	move.w		SerHeadRcv,d1				; check if anything is in buffer
00:00008110 B27900100160    	  4389: 	cmp.w			SerTailRcv,d1
00:00008116 6720            	  4390: 	beq				.NoChars						; no?
00:00008118 41F900101000    	  4391: 	lea				SerRcvBuf,a0
00:0000811E 12301000        	  4392: 	move.b		(a0,d1.w),d1				; get byte from buffer
00:00008122 527900100162    	  4393: 	addi.w		#1,SerHeadRcv
00:00008128 02790FFF00100162	  4394: 	andi.w		#$FFF,SerHeadRcv		; 4k wrap around
00:00008130 0281000000FF    	  4395: 	andi.l		#$FF,d1
00:00008136 6002            	  4396: 	bra				.Xit
                            	  4397: .NoChars:
00:00008138 72FF            	  4398: 	moveq			#-1,d1
                            	  4399: .Xit:
00:0000813A C342            	  4400: 	exg				d1,d2
00:0000813C 4E7A0FE0        	  4401: 	movec			coreno,d0
00:00008140 4840            	  4402: 	swap			d0
00:00008142 7202            	  4403: 	moveq			#SERIAL_SEMA,d1
00:00008144 6100869E        	  4404: 	bsr				UnlockSemaphore
00:00008148 C541            	  4405: 	exg				d2,d1
00:0000814A 241F            	  4406: 	move.l		(a7)+,d2
00:0000814C 4E75            	  4407: 	rts
                            	  4408: 
                            	  4409: ;------------------------------------------------------------------------------
                            	  4410: ; SerialPeekChar
                            	  4411: ;
                            	  4412: ; Check the serial port buffer to see if there's a char available. If there's
                            	  4413: ; a char available then return it. But don't update the buffer indexes. No need
                            	  4414: ; to send an XON here.
                            	  4415: ;
                            	  4416: ; Stack Space:
                            	  4417: ;		1 long word
                            	  4418: ; Parameters:
                            	  4419: ;		none
                            	  4420: ; Modifies:
                            	  4421: ;		d0,a0
                            	  4422: ; Returns:
                            	  4423: ;		d1 = character or -1
                            	  4424: ;------------------------------------------------------------------------------
                            	  4425: 
                            	  4426: SerialPeekChar:
00:0000814E 2F02            	  4427: 	move.l d2,-(a7)
00:00008150 4E7A0FE0        	  4428: 	movec	coreno,d0
00:00008154 4840            	  4429: 	swap d0
00:00008156 7202            	  4430: 	moveq	#SERIAL_SEMA,d1
00:00008158 6100864E        	  4431: 	bsr	LockSemaphore
00:0000815C 343900100162    	  4432: 	move.w SerHeadRcv,d2		; check if anything is in buffer
00:00008162 B47900100160    	  4433: 	cmp.w	SerTailRcv,d2
00:00008168 670C            	  4434: 	beq	.NoChars				; no?
00:0000816A 41F900101000    	  4435: 	lea	SerRcvBuf,a0
00:00008170 14302000        	  4436: 	move.b (a0,d2.w),d2		; get byte from buffer
00:00008174 6002            	  4437: 	bra	.Xit
                            	  4438: .NoChars:
00:00008176 74FF            	  4439: 	moveq	#-1,d2
                            	  4440: .Xit:
00:00008178 4E7A0FE0        	  4441: 	movec	coreno,d0
00:0000817C 4840            	  4442: 	swap d0
00:0000817E 7202            	  4443: 	moveq	#SERIAL_SEMA,d1
00:00008180 61008662        	  4444: 	bsr	UnlockSemaphore
00:00008184 2202            	  4445: 	move.l	d2,d1
00:00008186 241F            	  4446: 	move.l (a7)+,d2
00:00008188 4E75            	  4447: 	rts
                            	  4448: 
                            	  4449: ;------------------------------------------------------------------------------
                            	  4450: ; SerialPeekChar
                            	  4451: ;		Get a character directly from the I/O port. This bypasses the input
                            	  4452: ; buffer.
                            	  4453: ;
                            	  4454: ; Stack Space:
                            	  4455: ;		0 words
                            	  4456: ; Parameters:
                            	  4457: ;		none
                            	  4458: ; Modifies:
                            	  4459: ;		d
                            	  4460: ; Returns:
                            	  4461: ;		d1 = character or -1
                            	  4462: ;------------------------------------------------------------------------------
                            	  4463: 
                            	  4464: SerialPeekCharDirect:
00:0000818A 1239FD060004    	  4465: 	move.b	ACIA+ACIA_STAT,d1	; get serial status
00:00008190 08010003        	  4466: 	btst		#3,d1							; look for Rx not empty
00:00008194 670A            	  4467: 	beq.s		.0001
00:00008196 7200            	  4468: 	moveq.l	#0,d1							; clear upper bits of return value
00:00008198 1239FD060000    	  4469: 	move.b	ACIA+ACIA_RX,d1		; get data from ACIA
00:0000819E 4E75            	  4470: 	rts												; return
                            	  4471: .0001:
00:000081A0 72FF            	  4472: 	moveq		#-1,d1
00:000081A2 4E75            	  4473: 	rts
                            	  4474: 
                            	  4475: ;------------------------------------------------------------------------------
                            	  4476: ; SerialPutChar
                            	  4477: ;		If there is a transmit buffer, adds the character to the transmit buffer
                            	  4478: ; if it can, otherwise will wait for a byte to be freed up in the transmit
                            	  4479: ; buffer (blocks).
                            	  4480: ;		If there is no transmit buffer, put a character to the directly to the
                            	  4481: ; serial transmitter. This routine blocks until the transmitter is empty. 
                            	  4482: ;
                            	  4483: ; Stack Space
                            	  4484: ;		4 long words
                            	  4485: ; Parameters:
                            	  4486: ;		d1.b = character to put
                            	  4487: ; Modifies:
                            	  4488: ;		none
                            	  4489: ;------------------------------------------------------------------------------
                            	  4490: 
                            	  4491: SerialPutChar:
                            	  4492: .0004:
00:000081A4 4A7900040B74    	  4493: 	tst.w serial_dcb+DCB_OUTBUFSIZE	; buffered output?
00:000081AA 675C            	  4494: 	beq.s SerialPutCharDirect
00:000081AC 48E7E080        	  4495: 	movem.l d0/d1/d2/a0,-(a7)
00:000081B0 4E7A0FE0        	  4496: 	movec	coreno,d0
00:000081B4 4840            	  4497: 	swap d0
00:000081B6 7202            	  4498: 	moveq	#SERIAL_SEMA,d1
00:000081B8 610085EE        	  4499: 	bsr	LockSemaphore
00:000081BC 303900100166    	  4500: 	move.w SerTailXmit,d0
00:000081C2 3400            	  4501: 	move.w d0,d2
00:000081C4 5240            	  4502: 	addi.w #1,d0
00:000081C6 B07900040B74    	  4503: 	cmp.w serial_dcb+DCB_OUTBUFSIZE,d0
00:000081CC 6502            	  4504: 	blo.s .0002
00:000081CE 4240            	  4505: 	clr.w d0
                            	  4506: .0002:
00:000081D0 B07900100168    	  4507: 	cmp.w SerHeadXmit,d0			; Is Xmit buffer full?
00:000081D6 660E            	  4508: 	bne.s .0003
00:000081D8 4E7A0FE0        	  4509: 	movec	coreno,d0						; buffer full, unlock semaphore and wait
00:000081DC 4840            	  4510: 	swap d0
00:000081DE 7202            	  4511: 	moveq	#SERIAL_SEMA,d1
00:000081E0 61008602        	  4512: 	bsr	UnlockSemaphore
00:000081E4 60BE            	  4513: 	bra.s .0004
                            	  4514: .0003:
00:000081E6 33C000100166    	  4515: 	move.w d0,SerTailXmit			; update tail pointer
00:000081EC 41F900102000    	  4516: 	lea SerXmitBuf,a0
00:000081F2 11812000        	  4517: 	move.b d1,(a0,d2.w)				; store byte in Xmit buffer
00:000081F6 4E7A0FE0        	  4518: 	movec	coreno,d0						; unlock semaphore
00:000081FA 4840            	  4519: 	swap d0
00:000081FC 7202            	  4520: 	moveq	#SERIAL_SEMA,d1
00:000081FE 610085E4        	  4521: 	bsr	UnlockSemaphore
00:00008202 4CDF0107        	  4522: 	movem.l (a7)+,d0/d1/d2/a0
00:00008206 4E75            	  4523: 	rts
                            	  4524: 
                            	  4525: SerialPutCharDirect:
00:00008208 48E7C000        	  4526: 	movem.l	d0/d1,-(a7)							; push d0,d1
                            	  4527: .0001:
00:0000820C 1039FD060004    	  4528: 	move.b ACIA+ACIA_STAT,d0	; wait until the uart indicates tx empty
00:00008212 08000004        	  4529: 	btst #4,d0								; bit #4 of the status reg
00:00008216 67F4            	  4530: 	beq.s	.0001			    			; branch if transmitter is not empty
00:00008218 13C1FD060000    	  4531: 	move.b d1,ACIA+ACIA_TX		; send the byte
00:0000821E 4CDF0003        	  4532: 	movem.l	(a7)+,d0/d1				; pop d0,d1
00:00008222 4E75            	  4533: 	rts
                            	  4534: 	
                            	  4535: ;------------------------------------------------------------------------------
                            	  4536: ; Reverse the order of bytes in d1.
                            	  4537: ;------------------------------------------------------------------------------
                            	  4538: 
                            	  4539: SerialRbo:
00:00008224 E159            	  4540: 	rol.w		#8,d1
00:00008226 4841            	  4541: 	swap		d1
00:00008228 E159            	  4542: 	rol.w		#8,d1
00:0000822A 4E75            	  4543: 	rts
                            	  4544: 
                            	  4545: ;------------------------------------------------------------------------------
                            	  4546: ; Calculate number of character in input buffer
                            	  4547: ;
                            	  4548: ; Returns:
                            	  4549: ;		d0 = number of bytes in buffer.
                            	  4550: ;------------------------------------------------------------------------------
                            	  4551: 
                            	  4552: SerialRcvCount:
00:0000822C 303900100160    	  4553: 	move.w	SerTailRcv,d0
00:00008232 907900100162    	  4554: 	sub.w		SerHeadRcv,d0
00:00008238 6C10            	  4555: 	bge			.0001
00:0000823A 303C1000        	  4556: 	move.w	#$1000,d0
00:0000823E 907900100162    	  4557: 	sub.w		SerHeadRcv,d0
00:00008244 D07900100160    	  4558: 	add.w		SerTailRcv,d0
                            	  4559: .0001:
00:0000824A 4E75            	  4560: 	rts
                            	  4561: 
                            	  4562: ;------------------------------------------------------------------------------
                            	  4563: ; Serial IRQ routine
                            	  4564: ;
                            	  4565: ; Keeps looping as long as it finds characters in the ACIA recieve buffer/fifo.
                            	  4566: ; Received characters are buffered. If the buffer becomes full, new characters
                            	  4567: ; will be lost.
                            	  4568: ;
                            	  4569: ; Parameters:
                            	  4570: ;		none
                            	  4571: ; Modifies:
                            	  4572: ;		none
                            	  4573: ; Returns:
                            	  4574: ;		d1 = -1 if IRQ handled, otherwise zero
                            	  4575: ;------------------------------------------------------------------------------
                            	  4576: 
                            	  4577: SerialIRQ:
00:0000824C 46FC2300        	  4578: 	move.w	#$2300,sr						; disable lower level IRQs
00:00008250 48E7E080        	  4579: 	movem.l	d0/d1/d2/a0,-(a7)
00:00008254 4E7A0FE0        	  4580: 	movec	coreno,d0
00:00008258 4840            	  4581: 	swap d0
00:0000825A 7202            	  4582: 	moveq	#SERIAL_SEMA,d1
00:0000825C 6100854A        	  4583: 	bsr	LockSemaphore
                            	  4584: sirqNxtByte:
00:00008260 1239FD060004    	  4585: 	move.b ACIA+ACIA_STAT,d1		; check the status
00:00008266 08010003        	  4586: 	btst #3,d1									; bit 3 = rx full
00:0000826A 6756            	  4587: 	beq	notRxInt
00:0000826C 1239FD060000    	  4588: 	move.b ACIA+ACIA_RX,d1
                            	  4589: sirq0001:
00:00008272 303900100160    	  4590: 	move.w SerTailRcv,d0				; check if recieve buffer full
00:00008278 5240            	  4591: 	addi.w #1,d0
00:0000827A 02400FFF        	  4592: 	andi.w #$FFF,d0
00:0000827E B07900100162    	  4593: 	cmp.w	SerHeadRcv,d0
00:00008284 673C            	  4594: 	beq	sirqRxFull
00:00008286 33C000100160    	  4595: 	move.w d0,SerTailRcv				; update tail pointer
00:0000828C 5340            	  4596: 	subi.w #1,d0								; backup
00:0000828E 02400FFF        	  4597: 	andi.w #$FFF,d0
00:00008292 41F900101000    	  4598: 	lea	SerRcvBuf,a0						; a0 = buffer address
00:00008298 11810000        	  4599: 	move.b d1,(a0,d0.w)					; store recieved byte in buffer
00:0000829C 4A3900100165    	  4600: 	tst.b	SerRcvXoff						; check if xoff already sent
00:000082A2 66BC            	  4601: 	bne	sirqNxtByte
00:000082A4 6186            	  4602: 	bsr	SerialRcvCount					; if more than 4080 chars in buffer
00:000082A6 0C400FF0        	  4603: 	cmpi.w #4080,d0
00:000082AA 65B4            	  4604: 	blo	sirqNxtByte
00:000082AC 123C0013        	  4605: 	move.b #XOFF,d1							; send an XOFF
00:000082B0 423900100164    	  4606: 	clr.b	SerRcvXon							; clear XON status
00:000082B6 13C100100165    	  4607: 	move.b d1,SerRcvXoff				; set XOFF status
00:000082BC 6100FEE6        	  4608: 	bsr	SerialPutChar						; send XOFF
00:000082C0 609E            	  4609: 	bra	sirqNxtByte     				; check the status for another byte
                            	  4610: sirqRxFull:
                            	  4611: notRxInt:
00:000082C2 08010004        	  4612: 	btst #4,d1									; TX empty?
00:000082C6 6748            	  4613: 	beq.s notTxInt
00:000082C8 4A390010016A    	  4614: 	tst.b SerXmitXoff						; and allowed to send?
00:000082CE 6640            	  4615: 	bne.s sirqXmitOff
00:000082D0 4AB900040B74    	  4616: 	tst.l serial_dcb+DCB_OUTBUFSIZE	; Is there a buffer being transmitted?
00:000082D6 6738            	  4617: 	beq.s notTxInt
00:000082D8 303900100168    	  4618: 	move.w SerHeadXmit,d0
00:000082DE B07900100166    	  4619: 	cmp.w SerTailXmit,d0
00:000082E4 672A            	  4620: 	beq.s sirqTxEmpty
00:000082E6 41F900102000    	  4621: 	lea SerXmitBuf,a0
00:000082EC 12300000        	  4622: 	move.b (a0,d0.w),d1
00:000082F0 13C1FD060000    	  4623: 	move.b d1,ACIA+ACIA_TX			; transmit character
00:000082F6 527900100168    	  4624: 	addi.w #1,SerHeadXmit				; advance head index
00:000082FC 303900040B74    	  4625: 	move.w serial_dcb+DCB_OUTBUFSIZE,d0
00:00008302 B07900100168    	  4626: 	cmp.w SerHeadXmit,d0
00:00008308 6206            	  4627: 	bhi.s sirq0002
00:0000830A 427900100168    	  4628: 	clr.w SerHeadXmit						; wrap around
                            	  4629: sirq0002:
                            	  4630: sirqXmitOff:
                            	  4631: sirqTxEmpty:
                            	  4632: notTxInt:
00:00008310 4E7A0FE0        	  4633: 	movec	coreno,d0
00:00008314 4840            	  4634: 	swap d0
00:00008316 7202            	  4635: 	moveq	#SERIAL_SEMA,d1
00:00008318 610084CA        	  4636: 	bsr	UnlockSemaphore
00:0000831C 4CDF0107        	  4637: 	movem.l	(a7)+,d0/d1/d2/a0
00:00008320 4E73            	  4638: 	rte
                            	  4639: 
                            	  4640: nmeSerial:
00:00008322 53657269616C    	  4641: 	dc.b		"Serial",0
00:00008328 00
                            	  4642: 
                            	  4643: ;===============================================================================
                            	  4644: ; Generic I2C routines
                            	  4645: ;===============================================================================
                            	  4646: 
                            	  4647: 	even
                            	  4648: ; i2c
                            	  4649: i2c_setup:
                            	  4650: ;		lea		I2C,a6				
                            	  4651: ;		move.w	#19,I2C_PREL(a6)	; setup prescale for 400kHz clock
                            	  4652: ;		move.w	#0,I2C_PREH(a6)
                            	  4653: init_i2c:
00:0000832A 4DF9FD069000    	  4654: 	lea	I2C2,a6				
00:00008330 1CBC0013        	  4655: 	move.b #19,I2C_PREL(a6)	; setup prescale for 400kHz clock, 40MHz master
00:00008334 422E0001        	  4656: 	move.b #0,I2C_PREH(a6)
00:00008338 4E75            	  4657: 	rts
                            	  4658: 
                            	  4659: ; Wait for I2C transfer to complete
                            	  4660: ;
                            	  4661: ; Parameters
                            	  4662: ; 	a6 - I2C controller base address
                            	  4663: 
                            	  4664: i2c_wait_tip:
00:0000833A 2F00            	  4665: 	move.l d0,-(a7)
                            	  4666: .0001				
00:0000833C 102E0004        	  4667: 	move.b I2C_STAT(a6),d0		; wait for tip to clear
00:00008340 08000001        	  4668: 	btst #1,d0
00:00008344 66F6            	  4669: 	bne.s	.0001
00:00008346 201F            	  4670: 	move.l (a7)+,d0
00:00008348 4E75            	  4671: 	rts
                            	  4672: 
                            	  4673: ; Parameters
                            	  4674: ;	d0.b - data to transmit
                            	  4675: ;	d1.b - command value
                            	  4676: ;	a6	 - I2C controller base address
                            	  4677: ;
                            	  4678: i2c_wr_cmd:
00:0000834A 1D400003        	  4679: 	move.b d0,I2C_TXR(a6)
00:0000834E 1D410004        	  4680: 	move.b d1,I2C_CMD(a6)
00:00008352 61E6            	  4681: 	bsr	i2c_wait_tip
00:00008354 102E0004        	  4682: 	move.b I2C_STAT(a6),d0
00:00008358 4E75            	  4683: 	rts
                            	  4684: 
                            	  4685: i2c_xmit1:
00:0000835A 2F00            	  4686: 	move.l d0,-(a7)
00:0000835C 1D7C00010002    	  4687: 	move.b #1,I2C_CTRL(a6)		; enable the core
00:00008362 7076            	  4688: 	moveq	#$76,d0				; set slave address = %0111011
00:00008364 323C0090        	  4689: 	move.w #$90,d1				; set STA, WR
00:00008368 61E0            	  4690: 	bsr i2c_wr_cmd
00:0000836A 610C            	  4691: 	bsr	i2c_wait_rx_nack
00:0000836C 201F            	  4692: 	move.l (a7)+,d0
00:0000836E 323C0050        	  4693: 	move.w #$50,d1				; set STO, WR
00:00008372 61D6            	  4694: 	bsr i2c_wr_cmd
00:00008374 61000002        	  4695: 	bsr	i2c_wait_rx_nack
                            	  4696: 
                            	  4697: i2c_wait_rx_nack:
00:00008378 2F00            	  4698: 	move.l d0,-(a7)
                            	  4699: .0001						
00:0000837A 102E0004        	  4700: 	move.b I2C_STAT(a6),d0		; wait for RXack = 0
00:0000837E 08000007        	  4701: 	btst #7,d0
00:00008382 66F6            	  4702: 	bne.s	.0001
00:00008384 201F            	  4703: 	move.l (a7)+,d0
00:00008386 4E75            	  4704: 	rts
                            	  4705: 
                            	  4706: ;===============================================================================
                            	  4707: ; Realtime clock routines
                            	  4708: ;===============================================================================
                            	  4709: 
                            	  4710: rtc_read:
00:00008388 2C7CFD069000    	  4711: 	movea.l	#I2C2,a6
00:0000838E 4BF900100200    	  4712: 	lea	RTCBuf,a5
00:00008394 1D7C00800002    	  4713: 	move.b	#$80,I2C_CTRL(a6)	; enable I2C
00:0000839A 103C00DE        	  4714: 	move.b	#$DE,d0				; read address, write op
00:0000839E 123C0090        	  4715: 	move.b	#$90,d1				; STA + wr bit
00:000083A2 61A6            	  4716: 	bsr	i2c_wr_cmd
00:000083A4 4A00            	  4717: 	tst.b	d0
00:000083A6 6B66            	  4718: 	bmi	.rxerr
00:000083A8 4200            	  4719: 	move.b #$00,d0				; address zero
00:000083AA 123C0010        	  4720: 	move.b #$10,d1				; wr bit
00:000083AE 619A            	  4721: 	bsr	i2c_wr_cmd
00:000083B0 4A00            	  4722: 	tst.b	d0
00:000083B2 6B5A            	  4723: 	bmi	.rxerr
00:000083B4 103C00DF        	  4724: 	move.b #$DF,d0				; read address, read op
00:000083B8 123C0090        	  4725: 	move.b #$90,d1				; STA + wr bit
00:000083BC 618C            	  4726: 	bsr i2c_wr_cmd
00:000083BE 4A00            	  4727: 	tst.b	d0
00:000083C0 6B4C            	  4728: 	bmi	.rxerr
                            	  4729: 		
00:000083C2 343C0020        	  4730: 	move.w #$20,d2
                            	  4731: .0001
00:000083C6 1D7C00200004    	  4732: 	move.b #$20,I2C_CMD(a6)	; rd bit
00:000083CC 6100FF6C        	  4733: 	bsr	i2c_wait_tip
00:000083D0 61A6            	  4734: 	bsr	i2c_wait_rx_nack
00:000083D2 102E0004        	  4735: 	move.b I2C_STAT(a6),d0
00:000083D6 4A00            	  4736: 	tst.b	d0
00:000083D8 6B34            	  4737: 	bmi	.rxerr
00:000083DA 102E0003        	  4738: 	move.b I2C_RXR(a6),d0
00:000083DE 1B802000        	  4739: 	move.b d0,(a5,d2.w)
00:000083E2 5242            	  4740: 	addi.w #1,d2
00:000083E4 0C42005F        	  4741: 	cmpi.w #$5F,d2
00:000083E8 66DC            	  4742: 	bne	.0001
00:000083EA 1D7C00680004    	  4743: 	move.b #$68,I2C_CMD(a6)	; STO, rd bit + nack
00:000083F0 6100FF48        	  4744: 	bsr i2c_wait_tip
00:000083F4 6182            	  4745: 	bsr i2c_wait_rx_nack
00:000083F6 102E0004        	  4746: 	move.b I2C_STAT(a6),d0
00:000083FA 4A00            	  4747: 	tst.b	d0
00:000083FC 6B10            	  4748: 	bmi	.rxerr
00:000083FE 102E0003        	  4749: 	move.b I2C_RXR(a6),d0
00:00008402 1B802000        	  4750: 	move.b d0,(a5,d2.w)
00:00008406 422E0002        	  4751: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
00:0000840A 7000            	  4752: 	moveq	#0,d0
00:0000840C 4E75            	  4753: 	rts
                            	  4754: .rxerr
00:0000840E 422E0002        	  4755: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
00:00008412 4E75            	  4756: 	rts
                            	  4757: 
                            	  4758: rtc_write:
00:00008414 2C7CFD069000    	  4759: 	movea.l	#I2C2,a6
00:0000841A 4BF900100200    	  4760: 	lea	RTCBuf,a5
00:00008420 1D7C00800002    	  4761: 	move.b #$80,I2C_CTRL(a6)	; enable I2C
00:00008426 103C00DE        	  4762: 	move.b #$DE,d0				; read address, write op
00:0000842A 123C0090        	  4763: 	move.b #$90,d1				; STA + wr bit
00:0000842E 6100FF1A        	  4764: 	bsr	i2c_wr_cmd
00:00008432 4A00            	  4765: 	tst.b	d0
00:00008434 6B42            	  4766: 	bmi	.rxerr
00:00008436 4200            	  4767: 	move.b #$00,d0				; address zero
00:00008438 123C0010        	  4768: 	move.b #$10,d1				; wr bit
00:0000843C 6100FF0C        	  4769: 	bsr	i2c_wr_cmd
00:00008440 4A00            	  4770: 	tst.b	d0
00:00008442 6B34            	  4771: 	bmi	.rxerr
00:00008444 343C0020        	  4772: 	move.w #$20,d2
                            	  4773: .0001
00:00008448 10352000        	  4774: 	move.b (a5,d2.w),d0
00:0000844C 123C0010        	  4775: 	move.b #$10,d1
00:00008450 6100FEF8        	  4776: 	bsr	i2c_wr_cmd
00:00008454 4A00            	  4777: 	tst.b	d0
00:00008456 6B20            	  4778: 	bmi	.rxerr
00:00008458 5242            	  4779: 	addi.w #1,d2
00:0000845A 0C42005F        	  4780: 	cmpi.w #$5F,d2
00:0000845E 66E8            	  4781: 	bne.s	.0001
00:00008460 10352000        	  4782: 	move.b (a5,d2.w),d0
00:00008464 123C0050        	  4783: 	move.b #$50,d1				; STO, wr bit
00:00008468 6100FEE0        	  4784: 	bsr	i2c_wr_cmd
00:0000846C 4A00            	  4785: 	tst.b	d0
00:0000846E 6B08            	  4786: 	bmi	.rxerr
00:00008470 422E0002        	  4787: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
00:00008474 7000            	  4788: 	moveq	#0,d0
00:00008476 4E75            	  4789: 	rts
                            	  4790: .rxerr:
00:00008478 422E0002        	  4791: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
00:0000847C 4E75            	  4792: 	rts
                            	  4793: 
                            	  4794: msgRtcReadFail:
00:0000847E 5254432072656164	  4795: 	dc.b	"RTC read/write failed.",$0A,$0D,$00
00:00008486 2F77726974652066
00:0000848E 61696C65642E
00:00008494 0A
00:00008495 0D
00:00008496 00
                            	  4796: 
                            	  4797: msgBusErr:
00:00008497 0A              	  4798: 	dc.b	$0A,$0D,"Bus error at: ",$00
00:00008498 0D
00:00008499 427573206572726F
00:000084A1 722061743A20
00:000084A7 00
                            	  4799: 	even
                            	  4800: 
                            	  4801: ;------------------------------------------------------------------------------
                            	  4802: ;------------------------------------------------------------------------------
                            	  4803: 	even
                            	  4804: 
                            	  4805: bus_err:
00:000084A8 4E71            	  4806: 	nop
00:000084AA 43FAFFEB        	  4807: 	lea.l msgBusErr,a1
00:000084AE 6100D868        	  4808: 	bsr DisplayString
00:000084B2 222F0002        	  4809: 	move.l 2(a7),d1
00:000084B6 6100F7AC        	  4810: 	bsr DisplayTetra
00:000084BA 6100D5AA        	  4811: 	bsr CRLF
00:000084BE 6000E8EC        	  4812: 	bra	Monitor
                            	  4813: 
                            	  4814: trap3:
                            	  4815: 	; First save all registers
00:000084C2 48F9FFFF00040100	  4816: 	movem.l		d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
00:000084CA 33DF00040140    	  4817: 	move.w		(a7)+,Regsave+$40
00:000084D0 23DF00040144    	  4818: 	move.l		(a7)+,Regsave+$44
00:000084D6 2E7C00040FFC    	  4819: 	move.l		#$40FFC,a7			; reset stack pointer
00:000084DC 46FC2500        	  4820: 	move.w		#$2500,sr				; enable interrupts
00:000084E0 303900040202    	  4821: 	move.w		NumSetBreakpoints,d0
00:000084E6 5340            	  4822: 	subi.w		#1,d0
00:000084E8 41F900040220    	  4823: 	lea				Breakpoints,a0
00:000084EE 223900040144    	  4824: 	move.l		Regsave+$44,d1
                            	  4825: .0001:
00:000084F4 B298            	  4826: 	cmp.l			(a0)+,d1
00:000084F6 6708            	  4827: 	beq.s			ProcessBreakpoint
00:000084F8 51C8FFFA        	  4828: 	dbra			d0,.0001
00:000084FC 6000E8AE        	  4829: 	bra				Monitor					; not a breakpoint
                            	  4830: ProcessBreakpoint:
00:00008500 6104            	  4831: 	bsr				DisarmAllBreakpoints
00:00008502 6000F0B0        	  4832: 	bra				cmdDumpRegs
                            	  4833: 
                            	  4834: ;------------------------------------------------------------------------------
                            	  4835: ; DisarmAllBreakpoints, used when entering the monitor.
                            	  4836: ;------------------------------------------------------------------------------
                            	  4837: 
                            	  4838: DisarmAllBreakpoints:
00:00008506 48E780E0        	  4839: 	movem.l	d0/a0/a1/a2,-(a7)			; stack some regs
00:0000850A 303900040202    	  4840: 	move.w	NumSetBreakpoints,d0	; d0 = number of breakpoints that are set
00:00008510 0C400008        	  4841: 	cmpi.w	#numBreakpoints,d0		; check for valid number
00:00008514 641A            	  4842: 	bhs.s		.0001
00:00008516 45F900040220    	  4843: 	lea			Breakpoints,a2				; a2 = pointer to breakpoint address table
00:0000851C 41F900040280    	  4844: 	lea			BreakpointWords,a0		; a0 = pointer to breakpoint instruction word table
00:00008522 6004            	  4845: 	bra.s		.0003									; enter loop at bottom
                            	  4846: .0002:
00:00008524 225A            	  4847: 	move.l	(a2)+,a1							; a1 = address of breakpoint
00:00008526 3298            	  4848: 	move.w	(a0)+,(a1)						; copy instruction word back to code
                            	  4849: .0003:
00:00008528 51C8FFFA        	  4850: 	dbra		d0,.0002
00:0000852C 4CDF0701        	  4851: 	movem.l	(a7)+,d0/a0/a1/a2			; restore regs
                            	  4852: .0001:
00:00008530 4E75            	  4853: 	rts	
                            	  4854: 
                            	  4855: ;------------------------------------------------------------------------------
                            	  4856: ; ArmAllBreakpoints, used when entering the monitor.
                            	  4857: ;------------------------------------------------------------------------------
                            	  4858: 
                            	  4859: ArmAllBreakpoints:
00:00008532 48E780E0        	  4860: 	movem.l		d0/a0/a1/a2,-(a7)			; stack some regs
00:00008536 303900040202    	  4861: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:0000853C 0C400008        	  4862: 	cmpi.w		#numBreakpoints,d0		; is the number valid?
00:00008540 641E            	  4863: 	bhs.s			.0001
00:00008542 45F900040220    	  4864: 	lea				Breakpoints,a2				; a2 = pointer to breakpoint address table
00:00008548 41F900040280    	  4865: 	lea				BreakpointWords,a0		; a0 = pointer to instruction word table
00:0000854E 6008            	  4866: 	bra.s			.0003									; enter loop at bottom
                            	  4867: .0002:
00:00008550 225A            	  4868: 	move.l		(a2)+,a1							; a1 = address of breakpoint
00:00008552 3091            	  4869: 	move.w		(a1),(a0)							; copy instruction word to table
00:00008554 30FC4E43        	  4870: 	move.w		#$4E43,(a0)+					; set instruction = TRAP3
                            	  4871: .0003:
00:00008558 51C8FFF6        	  4872: 	dbra			d0,.0002
00:0000855C 4CDF0701        	  4873: 	movem.l		(a7)+,d0/a0/a1/a2			; restore regs
                            	  4874: .0001:
00:00008560 4E75            	  4875: 	rts	
                            	  4876: 
                            	  4877: ;------------------------------------------------------------------------------
                            	  4878: ;------------------------------------------------------------------------------
                            	  4879: 
                            	  4880: ArmBreakpoint:
00:00008562 48E7E0E0        	  4881: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
00:00008566 303900040202    	  4882: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:0000856C 0C400008        	  4883: 	cmpi.w		#numBreakpoints,d0		; check if too many
00:00008570 645A            	  4884: 	bhs.s			.0001
00:00008572 527900040202    	  4885: 	addi.w		#1,NumSetBreakpoints	; increment number of breakpoints
00:00008578 2400            	  4886: 	move.l		d0,d2
00:0000857A 6100EE58        	  4887: 	bsr				ignBlanks
00:0000857E 6100F0FE        	  4888: 	bsr				GetHexNumber
00:00008582 6748            	  4889: 	beq.s			.0001									; was there an address?
00:00008584 08010000        	  4890: 	btst			#0,d1									; address value must be even
00:00008588 6642            	  4891: 	bne.s			.0001
                            	  4892: 	; See if the breakpoint is in the table already
00:0000858A 43F900040220    	  4893: 	lea				Breakpoints,a1				; a1 points to breakpoint table
00:00008590 343C0007        	  4894: 	move.w		#numBreakpoints-1,d2
                            	  4895: .0002:
00:00008594 B299            	  4896: 	cmp.l			(a1)+,d1
00:00008596 673A            	  4897: 	beq.s			.0003									; breakpoint is in table already
00:00008598 51CAFFFA        	  4898: 	dbra			d2,.0002
                            	  4899: 	; Add breakpoint to table
                            	  4900: 	; Search for empty entry
00:0000859C 43F900040220    	  4901: 	lea				Breakpoints,a1				; a1 = pointer to breakpoint address table
00:000085A2 4242            	  4902: 	clr.w			d2										; d2 = count
                            	  4903: .0006:
00:000085A4 4A91            	  4904: 	tst.l			(a1)									; is the entry empty?
00:000085A6 670C            	  4905: 	beq.s			.0005									; branch if found empty entry
00:000085A8 5889            	  4906: 	lea				4(a1),a1							; point to next entry
00:000085AA 5242            	  4907: 	addi.w		#1,d2									; increment count
00:000085AC 0C420008        	  4908: 	cmpi.w		#numBreakpoints,d2		; safety: check against max number
00:000085B0 65F2            	  4909: 	blo.s			.0006
00:000085B2 6018            	  4910: 	bra.s			.0001									; what? no empty entries found, table corrupt?
                            	  4911: .0005:
00:000085B4 E542            	  4912: 	asl.w			#2,d2									; d2 = long word index
00:000085B6 23812000        	  4913: 	move.l		d1,(a1,d2.w)					; move breakpoint address to table
00:000085BA 2441            	  4914: 	move.l		d1,a2
00:000085BC E24A            	  4915: 	lsr.w			#1,d2									; d2 = word index
                            	  4916: .0004:
00:000085BE 43F900040280    	  4917: 	lea				BreakpointWords,a1
00:000085C4 33922000        	  4918: 	move.w		(a2),(a1,d2.w)				; copy instruction word to table
00:000085C8 34BC4E43        	  4919: 	move.w		#$4E43,(a2)						; replace word with TRAP3
                            	  4920: .0001:
00:000085CC 4CDF0707        	  4921: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
00:000085D0 4E75            	  4922: 	rts
                            	  4923: .0003:
00:000085D2 2469FFFC        	  4924: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
00:000085D6 0C524E43        	  4925: 	cmpi.w		#$4E43,(a2)						; see if breakpoint already armed
00:000085DA 67F0            	  4926: 	beq.s			.0001
00:000085DC D482            	  4927: 	asl.l			#1,d2									; d2 = word index
00:000085DE 60DE            	  4928: 	bra.s			.0004
                            	  4929: 
                            	  4930: 
                            	  4931: ;------------------------------------------------------------------------------
                            	  4932: ;------------------------------------------------------------------------------
                            	  4933: 
                            	  4934: DisarmBreakpoint:
00:000085E0 48E7E0E0        	  4935: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
00:000085E4 303900040202    	  4936: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:000085EA 0C400008        	  4937: 	cmpi.w		#numBreakpoints,d0		; check if too many
00:000085EE 623E            	  4938: 	bhi.s			.0001
00:000085F0 2400            	  4939: 	move.l		d0,d2
00:000085F2 6100EDE0        	  4940: 	bsr				ignBlanks
00:000085F6 6100F086        	  4941: 	bsr				GetHexNumber
00:000085FA 6732            	  4942: 	beq.s			.0001									; was there an address?
00:000085FC 08010000        	  4943: 	btst			#0,d1									; address value must be even
00:00008600 662C            	  4944: 	bne.s			.0001
                            	  4945: 	; See if the breakpoint is in the table already
00:00008602 43F900040220    	  4946: 	lea				Breakpoints,a1				; a1 points to breakpoint table
00:00008608 5342            	  4947: 	subi.w		#1,d2
                            	  4948: .0002:
00:0000860A B299            	  4949: 	cmp.l			(a1)+,d1
00:0000860C 6706            	  4950: 	beq.s			.0003									; breakpoint is in table already
00:0000860E 51CAFFFA        	  4951: 	dbra			d2,.0002
00:00008612 601A            	  4952: 	bra				.0001									; breakpoint was not in table
                            	  4953: .0003:
                            	  4954: 	; Remove breakpoint from table
00:00008614 537900040202    	  4955: 	subi.w		#1,NumSetBreakpoints	; decrement number of breakpoints
00:0000861A 2469FFFC        	  4956: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
00:0000861E 42A9FFFC        	  4957: 	clr.l			-4(a1)								; empty out breakpoint
00:00008622 43F900040280    	  4958: 	lea				BreakpointWords,a1
00:00008628 D482            	  4959: 	asl.l			#1,d2									; d2 = word index
00:0000862A 34B12000        	  4960: 	move.w		(a1,d2.w),(a2)				; copy instruction from table back to code
                            	  4961: .0001:
00:0000862E 4CDF0707        	  4962: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
00:00008632 4E75            	  4963: 	rts
                            	  4964: 
                            	  4965: ;------------------------------------------------------------------------------
                            	  4966: ;------------------------------------------------------------------------------
                            	  4967: 
                            	  4968: ListBreakpoints:
00:00008634 6100D430        	  4969: 	bsr			CRLF
00:00008638 343C0008        	  4970: 	move.w	#numBreakpoints,d2
00:0000863C 43F900040220    	  4971: 	lea			Breakpoints,a1
                            	  4972: .0001:
00:00008642 2219            	  4973: 	move.l	(a1)+,d1
00:00008644 6100F61E        	  4974: 	bsr			DisplayTetra
00:00008648 6100D41C        	  4975: 	bsr			CRLF
00:0000864C 51CAFFF4        	  4976: 	dbra		d2,.0001
00:00008650 6000E75A        	  4977: 	bra			Monitor
                            	  4978: 
                            	  4979: ;------------------------------------------------------------------------------
                            	  4980: ;------------------------------------------------------------------------------
                            	  4981: 
                            	  4982: ClearBreakpointList:
00:00008654 343C0008        	  4983: 	move.w	#numBreakpoints,d2
00:00008658 43F900040220    	  4984: 	lea			Breakpoints,a1
                            	  4985: .0001:
00:0000865E 4299            	  4986: 	clr.l		(a1)+
00:00008660 51CAFFFC        	  4987: 	dbra		d2,.0001
00:00008664 4E75            	  4988: 	rts
                            	  4989: 
                            	  4990: ;------------------------------------------------------------------------------
                            	  4991: ; SendMsg
                            	  4992: ; 00100xy0
                            	  4993: ;
                            	  4994: ; Parameters:
                            	  4995: ;		d1 = target core number
                            	  4996: ;		d2 = argument 1
                            	  4997: ;		d3 = argument 2
                            	  4998: ;		d4 = argument 3
                            	  4999: ;
                            	  5000: ;------------------------------------------------------------------------------
                            	  5001: 
                            	  5002: SendMsg:
00:00008666 48E70440        	  5003: 	movem.l	d5/a1,-(a7)
00:0000866A E149            	  5004: 	lsl.w		#8,d1
00:0000866C 4E7A5FE0        	  5005: 	movec		coreno,d5
00:00008670 E94D            	  5006: 	lsl.w		#4,d5
00:00008672 8245            	  5007: 	or.w		d5,d1
00:00008674 43F900100000    	  5008: 	lea			$00100000,a1
00:0000867A 4AB11000        	  5009: 	tst.l		0(a1,d1.w)
00:0000867E 661C            	  5010: 	bne			.msgFull
00:00008680 4E7A5FE0        	  5011: 	movec		coreno,d5
00:00008684 23851000        	  5012: 	move.l	d5,0(a1,d1.w)
00:00008688 23821004        	  5013: 	move.l	d2,4(a1,d1.w)
00:0000868C 23831008        	  5014: 	move.l	d3,8(a1,d1.w)
00:00008690 2384100C        	  5015: 	move.l	d4,12(a1,d1.w)
00:00008694 4CDF0220        	  5016: 	movem.l	(a7)+,d5/a1
00:00008698 7200            	  5017: 	moveq		#0,d1
00:0000869A 4E75            	  5018: 	rts
                            	  5019: .msgFull:
00:0000869C 4CDF0220        	  5020: 	movem.l	(a7)+,d5/a1
00:000086A0 72FF            	  5021: 	moveq		#-1,d1
00:000086A2 4E75            	  5022: 	rts
                            	  5023: 
                            	  5024: ;------------------------------------------------------------------------------
                            	  5025: ; ReceiveMsg
                            	  5026: ;		Scan the message table for messages and dispatch them.
                            	  5027: ; 00100xy0
                            	  5028: ;
                            	  5029: ; Parameters:
                            	  5030: ;------------------------------------------------------------------------------
                            	  5031: 
                            	  5032: ReceiveMsg:
00:000086A4 48E77F40        	  5033: 	movem.l		d1/d2/d3/d4/d5/d6/d7/a1,-(a7)
00:000086A8 43F900100000    	  5034: 	lea				$00100000,a1
00:000086AE 4E7A5FE0        	  5035: 	movec			coreno,d5
00:000086B2 E14D            	  5036: 	lsl.w			#8,d5
00:000086B4 7C02            	  5037: 	moveq			#2,d6
                            	  5038: .nextCore:
00:000086B6 3E06            	  5039: 	move.w		d6,d7
00:000086B8 E94F            	  5040: 	lsl.w			#4,d7
00:000086BA DE45            	  5041: 	add.w			d5,d7
00:000086BC 4AB17000        	  5042: 	tst.l			0(a1,d7.w)			; Is there a message from core d6?
00:000086C0 6716            	  5043: 	beq.s			.noMsg
00:000086C2 22317000        	  5044: 	move.l		0(a1,d7.w),d1
00:000086C6 24317004        	  5045: 	move.l		4(a1,d7.w),d2
00:000086CA 26317008        	  5046: 	move.l		8(a1,d7.w),d3
00:000086CE 2831700C        	  5047: 	move.l		12(a1,d7.w),d4
00:000086D2 42B17000        	  5048: 	clr.l			0(a1,d7.w)			; indicate message was received
00:000086D6 610E            	  5049: 	bsr				DispatchMsg
                            	  5050: .noMsg:
00:000086D8 5246            	  5051: 	addq			#1,d6
00:000086DA BC7C0009        	  5052: 	cmp.w			#9,d6
00:000086DE 63D6            	  5053: 	bls				.nextCore
00:000086E0 4CDF02FE        	  5054: 	movem.l		(a7)+,d1/d2/d3/d4/d5/d6/d7/a1
00:000086E4 4E75            	  5055: 	rts
                            	  5056: 
                            	  5057: ;------------------------------------------------------------------------------
                            	  5058: ;------------------------------------------------------------------------------
                            	  5059: 
                            	  5060: DispatchMsg:
00:000086E6 4E75            	  5061: 	rts
                            	  5062: 
                            	  5063: ;------------------------------------------------------------------------------
                            	  5064: ; Trap #15, function 39 - convert floating-point to string and display
                            	  5065: ;
                            	  5066: ; Parameters
                            	  5067: ;		a1 = pointer to buffer
                            	  5068: ;		fp0 = number to print
                            	  5069: ;		d1 = width of print field
                            	  5070: ;		d2 = precision
                            	  5071: ;		d3 = 'E' or 'e'
                            	  5072: ;------------------------------------------------------------------------------
                            	  5073: 
                            	  5074: prtflt:
00:000086E8 4E52FFD0        	  5075: 	link a2,#-48
00:000086EC 2F7900040098002C	  5076: 	move.l _canary,44(sp)
00:000086F4 48D7074F        	  5077: 	movem.l d0/d1/d2/d3/d6/a0/a1/a2,(sp)
00:000086F8 F22F68000020    	  5078: 	fmove.x fp0,32(sp)
00:000086FE 2049            	  5079: 	move.l a1,a0						; a0 = pointer to buffer to use
00:00008700 13C100040508    	  5080: 	move.b d1,_width
00:00008706 23C200040514    	  5081: 	move.l d2,_precision
00:0000870C 13C30004050C    	  5082: 	move.b d3,_E
00:00008712 6100F2CC        	  5083: 	bsr _FloatToString
00:00008716 6100D600        	  5084: 	bsr DisplayString
00:0000871A F22F48000020    	  5085: 	fmove.x 32(sp),fp0
00:00008720 4CD7074F        	  5086: 	movem.l (sp),d0/d1/d2/d3/d6/a0/a1/a2
00:00008724 A2AF0003002C    	  5087: 	cchk 44(sp)
00:0000872A 4E5A            	  5088: 	unlk a2
00:0000872C 4E75            	  5089: 	rts
                            	  5090: 
                            	  5091: T15FloatToString:
00:0000872E 4E52FFD4        	  5092: 	link a2,#-44
00:00008732 48D7034F        	  5093: 	movem.l d0/d1/d2/d3/d6/a0/a1,(sp)
00:00008736 F22F6800001C    	  5094: 	fmove.x fp0,28(sp)
00:0000873C 2049            	  5095: 	move.l a1,a0						; a0 = pointer to buffer to use
00:0000873E 13C100040508    	  5096: 	move.b d1,_width
00:00008744 23C200040514    	  5097: 	move.l d2,_precision
00:0000874A 13C30004050C    	  5098: 	move.b d3,_E
00:00008750 6100F28E        	  5099: 	bsr _FloatToString
00:00008754 F22F4800001C    	  5100: 	fmove.x 28(sp),fp0
00:0000875A 4CD7034F        	  5101: 	movem.l (sp),d0/d1/d2/d3/d6/a0/a1
00:0000875E 4E5A            	  5102: 	unlk a2
00:00008760 4E75            	  5103: 	rts
                            	  5104: 
                            	  5105: ;==============================================================================
                            	  5106: ; Parameters:
                            	  5107: ;		d7 = device number
                            	  5108: ;		d6 = function number
                            	  5109: ;		d0 to d5 = arguments
                            	  5110: ;==============================================================================
                            	  5111: 
                            	  5112: io_trap:
00:00008762 0C070002        	  5113: 	cmpi.b #2,d7							; make sure legal device
00:00008766 621E            	  5114: 	bhi.s .0002
00:00008768 4A07            	  5115: 	tst.b d7
00:0000876A 6B1A            	  5116: 	bmi.s .0002
00:0000876C 48E70180        	  5117: 	movem.l d7/a0,-(a7)
00:00008770 CEFC0040        	  5118: 	mulu #DCB_SIZE,d7					; index to DCB
00:00008774 207C00040A00    	  5119: 	move.l #null_dcb,a0
00:0000877A 20707018        	  5120: 	move.l DCB_CMDPROC(a0,d7.w),a0
00:0000877E 4E90            	  5121: 	jsr (a0)
00:00008780 4CDF0180        	  5122: 	movem.l (a7)+,d7/a0
00:00008784 4E73            	  5123: 	rte
                            	  5124: .0002:
00:00008786 7020            	  5125: 	moveq #E_BadDevNum,d0
00:00008788 4E73            	  5126: 	rte
                            	  5127: 
                            	  5128: ;==============================================================================
                            	  5129: ; Output a character to the current output device.
                            	  5130: ;==============================================================================
                            	  5131: 
                            	  5132: OutputChar:
00:0000878A 48E70300        	  5133: 	movem.l d6/d7,-(a7)
00:0000878E 7E00            	  5134: 	clr.l d7
00:00008790 1E39000400A8    	  5135: 	move.b OutputDevice,d7		; d7 = output device
00:00008796 3C3C0002        	  5136: 	move.w #DEV_PUTCHAR,d6		; d6 = function
00:0000879A 4E40            	  5137: 	trap #0
00:0000879C 4CDF00C0        	  5138: 	movem.l (a7)+,d6/d7
00:000087A0 4E75            	  5139: 	rts
                            	  5140: 
00:000087A2 0C390001000400A8	  5141: 	cmpi.b #1,OutputDevice	; stdout
00:000087AA 6604            	  5142: 	bne .0001
00:000087AC 6000D30A        	  5143: 	bra DisplayChar
                            	  5144: .0001:
00:000087B0 0C390002000400A8	  5145: 	cmpi.b #2,OutputDevice
00:000087B8 6604            	  5146: 	bne .0003
00:000087BA 6000F9E8        	  5147: 	bra	SerialPutChar
                            	  5148: .0003:
00:000087BE 4E75            	  5149: 	rts
                            	  5150: 
                            	  5151: ;------------------------------------------------------------------------------
                            	  5152: ;------------------------------------------------------------------------------
                            	  5153: 
                            	  5154: InitIRQ:
00:000087C0 7006            	  5155: 	moveq		#6,d0
00:000087C2 41FAE178        	  5156: 	lea			KeybdIRQ,a0
00:000087C6 610C            	  5157: 	bsr			InstallIRQ
00:000087C8 41FA004E        	  5158: 	lea			TickIRQ,a0
00:000087CC 6106            	  5159: 	bsr			InstallIRQ
00:000087CE 7003            	  5160: 	moveq		#3,d0
00:000087D0 41FAFA7A        	  5161: 	lea			SerialIRQ,a0
                            	  5162: 	; fall through
                            	  5163: 
                            	  5164: ;------------------------------------------------------------------------------
                            	  5165: ; Install an IRQ handler.
                            	  5166: ;
                            	  5167: ; Parameters:
                            	  5168: ;		a0 = pointer to bucket containing vector
                            	  5169: ;		d0 = vector (64 to 255)
                            	  5170: ; Returns:
                            	  5171: ;		d0 = 0 if successfully added, otherwise E_NotAlloc
                            	  5172: ;		nf = 0, zf = 1 if successfully added, otherwise nf = 1, zf = 0
                            	  5173: ;------------------------------------------------------------------------------
                            	  5174: 
                            	  5175: InstallIRQ:
00:000087D4 48E70060        	  5176: 	movem.l a1/a2,-(a7)				; save working register
00:000087D8 4A90            	  5177: 	tst.l (a0)								; link field must be NULL
00:000087DA 6634            	  5178: 	bne.s .0003
00:000087DC 0C400040        	  5179: 	cmpi.w #64,d0							; is vector in range (64 to 255)?
00:000087E0 652E            	  5180: 	blo.s .0003
00:000087E2 0C4000FF        	  5181: 	cmpi.w #255,d0
00:000087E6 6228            	  5182: 	bhi.s .0003
00:000087E8 45F80400        	  5183: 	lea	irq_list_tbl,a2				; a2 points to installed IRQ list
00:000087EC E748            	  5184: 	lsl.w	#3,d0								; multiply by 2 long words
00:000087EE 22720000        	  5185: 	move.l (a2,d0.w),a1				; get first link
00:000087F2 45F20000        	  5186: 	lea (a2,d0.w),a2					; 
                            	  5187: .0002:
00:000087F6 B1C9            	  5188: 	cmpa.l a1,a0							; installed already?
00:000087F8 6716            	  5189: 	beq.s .0003
00:000087FA B2FC0000        	  5190: 	cmpa.l #0,a1							; is link NULL?
00:000087FE 6706            	  5191: 	beq.s .0001
00:00008800 2449            	  5192: 	move.l a1,a2							; save previous link
00:00008802 2251            	  5193: 	move.l (a1),a1						; get next link
00:00008804 60F0            	  5194: 	bra .0002
                            	  5195: .0001:
00:00008806 2488            	  5196: 	move.l a0,(a2)						; set link
00:00008808 225F245F        	  5197: 	movem.l (a7)+,a1/a2
00:0000880C 7000            	  5198: 	moveq #E_Ok,d0
00:0000880E 4E75            	  5199: 	rts
                            	  5200: .0003:
00:00008810 225F245F        	  5201: 	movem.l (a7)+,a1/a2
00:00008814 7009            	  5202: 	moveq #E_NotAlloc,d0			; return failed to add
00:00008816 4E75            	  5203: 	rts
                            	  5204: 
                            	  5205: ;------------------------------------------------------------------------------
                            	  5206: ; TickIRQ
                            	  5207: ; - this IRQ is processed by all cores.
                            	  5208: ; - reset the edge circuit.
                            	  5209: ; - an IRQ live indicator is updated on the text screen for the core
                            	  5210: ;------------------------------------------------------------------------------
                            	  5211: 
                            	  5212: TickIRQ:
00:00008818 46FC2600        	  5213: 	move.w #$2600,sr					; disable lower level IRQs
00:0000881C 48E77080        	  5214: 	movem.l	d1/d2/d3/a0,-(a7)
00:00008820 52B90004009C    	  5215: 	addi.l #1,tickcnt
00:00008826 13FC0001000400A0	  5216: 	move.b #1,IRQFlag					; tick interrupt indicator in local memory
00:0000882E 4E7A1FE0        	  5217: 	movec	coreno,d1						; d1 = core number
00:00008832 2601            	  5218: 	move.l d1,d3
                            	  5219: 	if (SCREEN_FORMAT==1)
00:00008834 E583            	  5220: 		asl.l #2,d3								; 4 bytes per text cell
                            	  5221: 	else
                            	  5222: 		asl.l #3,d3								; 8 bytes per text cell
                            	  5223: 	endif
00:00008836 23FC1D000000FD09	  5224: 	move.l #$1D000000,PLIC+$14	; reset edge sense circuit
00:0000883E 0014
00:00008840 41F9FD0000C8    	  5225: 	lea $FD0000C8,a0					; display field address
00:00008846 24303004        	  5226: 	move.l 4(a0,d3.w),d2			; get char from screen
                            	  5227: ;	rol.l #8,d2								; extract char field
                            	  5228: ;	clr.b d2									; clear char field
                            	  5229: ;	addi.b #'0',d1						; binary to ascii core number
                            	  5230: ;	or.b	d1,d2								; insert core number
                            	  5231: ;	ror.l #8,d2								; reposition to proper place
                            	  5232: ;	addi.w #1,d2							; flashy colors
00:0000884A 5282            	  5233: 	addi.l #$0001,d2
00:0000884C 21823004        	  5234: 	move.l d2,4(a0,d3.w)			; update onscreen IRQ flag
00:00008850 6100FE52        	  5235: 	bsr	ReceiveMsg
00:00008854 4CDF010E        	  5236: 	movem.l	(a7)+,d1/d2/d3/a0
00:00008858 4E73            	  5237: 	rte
                            	  5238: 
                            	  5239: ;------------------------------------------------------------------------------
                            	  5240: ;------------------------------------------------------------------------------
                            	  5241: 
                            	  5242: irq3_rout:
                            	  5243: ;	movem.l	d0/d1/a0/a1,-(a7)
                            	  5244: ;	lea			InstalledIRQ+8*4*3,a0
                            	  5245: ;	bra			irq_rout
                            	  5246: 
                            	  5247: irq6_rout:
                            	  5248: ;	movem.l	d0/d1/a0/a1,-(a7)
                            	  5249: ;	lea			InstalledIRQ+8*4*6,a0
                            	  5250: irq_rout:
00:0000885A 7007            	  5251: 	moveq		#7,d0
                            	  5252: .nextHandler:
00:0000885C 2258            	  5253: 	move.l	(a0)+,a1
00:0000885E 6706            	  5254: 	beq.s		.0003
00:00008860 4E91            	  5255: 	jsr			(a1)
00:00008862 4A81            	  5256: 	tst.l		d1								; was IRQ handled?
00:00008864 6B04            	  5257: 	bmi.s		.0002							; first one to return handled quits loop
                            	  5258: .0003:
00:00008866 51C8FFF4        	  5259: 	dbra		d0,.nextHandler
                            	  5260: .0002:
00:0000886A 4CDF0303        	  5261: 	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  5262: 
                            	  5263: ; Load head of list into an address register, then branch to a generic routine.
                            	  5264: 
                            	  5265: ;	rept 192
                            	  5266: ;	macIRQ_proc_label REPTN
                            	  5267: ;	movem.l a0/a1,-(a7)
                            	  5268: ;	move.l irq_list_tbl+REPTN*4,a1	; get the head of the list
                            	  5269: ;	jmp irq_proc_generic
                            	  5270: ;	endr
                            	  5271: 
                            	  5272: irq_proc_generic:
                            	  5273: .0003:
00:0000886E 20690004        	  5274: 	move.l 4(a1),a0									; a0 = vector
00:00008872 B0FC0000        	  5275: 	cmpa.l #0,a0										; ugh. move to address does not set flags
00:00008876 6706            	  5276: 	beq.s .0001											; valid vector?
00:00008878 4E90            	  5277: 	jsr (a0)												; call the interrupt routine
00:0000887A 4A81            	  5278: 	tst.l d1												; IRQ handled?
00:0000887C 6B08            	  5279: 	bmi.s .0002											
                            	  5280: .0001:
00:0000887E 2251            	  5281: 	move.l (a1),a1
00:00008880 B0FC0000        	  5282: 	cmpa.l #0,a0										; end of list?
00:00008884 66E8            	  5283: 	bne.s .0003
                            	  5284: .0002:
00:00008886 205F225F        	  5285: 	movem.l (a7)+,a0/a1
00:0000888A 4E73            	  5286: 	rte 
                            	  5287: 
                            	  5288: SpuriousIRQ:
00:0000888C 4E73            	  5289: 	rte
                            	  5290: 
                            	  5291: ;	bsr			KeybdIRQ
                            	  5292: ;	tst.l		d1								; handled by KeybdIRQ?
                            	  5293: ;	bmi.s		.0002							; if yes, go return
                            	  5294: ;.0001:
                            	  5295: ;	move.l	#$1D000000,PLIC+$14	; reset edge sense circuit
                            	  5296: ;	move.l	TextScr,a0				; a0 = screen address
                            	  5297: ;	addi.l	#1,40(a0)					; update onscreen IRQ flag
                            	  5298: ;.0002:	
                            	  5299: ;	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  5300: ;	rte
                            	  5301: 
                            	  5302: nmi_rout:
00:0000888E 48E7C080        	  5303: 	movem.l	d0/d1/a0,-(a7)
00:00008892 123C004E        	  5304: 	move.b	#'N',d1
00:00008896 6100FEF2        	  5305: 	bsr			OutputChar
00:0000889A 4CDF0103        	  5306: 	movem.l	(a7)+,d0/d1/a0		; return
00:0000889E 4E73            	  5307: 	rte
                            	  5308: 
                            	  5309: addr_err:
00:000088A0 544F            	  5310: 	addq		#2,sp						; get rid of sr
00:000088A2 221F            	  5311: 	move.l	(sp)+,d1				; pop exception address
00:000088A4 6100F3BE        	  5312: 	bsr			DisplayTetra		; and display it
00:000088A8 43FA00A6        	  5313: 	lea			msgAddrErr,a1	; followed by message
00:000088AC 6100D480        	  5314: 	bsr			DisplayStringCRLF
                            	  5315: .0001:
00:000088B0 60FE            	  5316: 	bra			.0001
00:000088B2 6000E4F8        	  5317: 	bra			Monitor
                            	  5318: 	
                            	  5319: brdisp_trap:
00:000088B6 48F9FFFF00040100	  5320: 	movem.l	d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
00:000088BE 33DF00040140    	  5321: 	move.w	(a7)+,Regsave+$40
00:000088C4 23DF00040144    	  5322: 	move.l	(a7)+,Regsave+$44
00:000088CA 2E7C00040FFC    	  5323: 	move.l	#$40FFC,a7			; reset stack pointer
00:000088D0 46FC2500        	  5324: 	move.w	#$2500,sr				; enable interrupts
00:000088D4 43FA0099        	  5325: 	lea			msg_bad_branch_disp,a1
00:000088D8 6100D43E        	  5326: 	bsr			DisplayString
00:000088DC 6100F37E        	  5327: 	bsr			DisplaySpace
00:000088E0 223900040144    	  5328: 	move.l	Regsave+$44,d1	; exception address
00:000088E6 6100F37C        	  5329: 	bsr			DisplayTetra		; and display it
                            	  5330: ;	move.l	(sp)+,d1				; pop format word 68010 mode only
00:000088EA 6000ECC8        	  5331: 	bra			cmdDumpRegs
                            	  5332: 
                            	  5333: illegal_trap:
00:000088EE 544F            	  5334: 	addq		#2,sp						; get rid of sr
00:000088F0 221F            	  5335: 	move.l	(sp)+,d1				; pop exception address
00:000088F2 6100F370        	  5336: 	bsr			DisplayTetra		; and display it
00:000088F6 43FA0065        	  5337: 	lea			msg_illegal,a1	; followed by message
00:000088FA 6100D41C        	  5338: 	bsr			DisplayString
                            	  5339: .0001:
00:000088FE 60FE            	  5340: 	bra			.0001
00:00008900 6000E4AA        	  5341: 	bra			Monitor
                            	  5342: 	
                            	  5343: io_irq:
00:00008904 544F            	  5344: 	addq #2,sp
00:00008906 221F            	  5345: 	move.l (sp)+,d1
00:00008908 6100F35A        	  5346: 	bsr DisplayTetra
00:0000890C 43FA0083        	  5347: 	lea msg_io_access,a1
00:00008910 6100D406        	  5348: 	bsr DisplayString
00:00008914 6000EC9E        	  5349: 	bra cmdDumpRegs
                            	  5350: 
                            	  5351: ; -----------------------------------------------------------------------------
                            	  5352: ; -----------------------------------------------------------------------------
                            	  5353: 
                            	  5354: msg_start:
00:00008918 46656D74696B6920	  5355: 	dc.b	"Femtiki rf68k Multi-core OS Starting",LF,CR,0
00:00008920 726636386B204D75
00:00008928 6C74692D636F7265
00:00008930 204F532053746172
00:00008938 74696E67
00:0000893C 0A
00:0000893D 0D
00:0000893E 00
                            	  5356: ;	dc.b	"rf68k System Starting",CR,LF,0
                            	  5357: msg_core_start:
00:0000893F 20636F7265207374	  5358: 	dc.b	" core starting",CR,LF,0
00:00008947 617274696E67
00:0000894D 0D
00:0000894E 0A
00:0000894F 00
                            	  5359: msgAddrErr
00:00008950 2061646472657373	  5360: 	dc.b	" address err",0
00:00008958 20657272
00:0000895C 00
                            	  5361: msg_illegal:
00:0000895D 20696C6C6567616C	  5362: 	dc.b	" illegal opcode",CR,LF,0
00:00008965 206F70636F6465
00:0000896C 0D
00:0000896D 0A
00:0000896E 00
                            	  5363: msg_bad_branch_disp:
00:0000896F 206272616E636820	  5364: 	dc.b	" branch selfref: ",0
00:00008977 73656C667265663A
00:0000897F 20
00:00008980 00
                            	  5365: msg_test_done:
00:00008981 2043505520746573	  5366: 	dc.b	" CPU test done.",0
00:00008989 7420646F6E652E
00:00008990 00
                            	  5367: msg_io_access
00:00008991 20756E7065726D69	  5368: 	dc.b " unpermitted access to I/O",0
00:00008999 7474656420616363
00:000089A1 65737320746F2049
00:000089A9 2F4F
00:000089AB 00
                            	  5369: msgChk
00:000089AC 20636865636B2066	  5370: 	dc.b " check failed",0
00:000089B4 61696C6564
00:000089B9 00
                            	  5371: msgStackCanary
00:000089BA 20737461636B2063	  5372: 	dc.b " stack canary overwritten",0
00:000089C2 616E617279206F76
00:000089CA 6572777269747465
00:000089D2 6E
00:000089D3 00
                            	  5373: 
                            	  5374: 	even
                            	  5375: 
                            	  5376: ;-------------------------------------------------------------------------
                            	  5377: ; File HEX2DEC   HEX2DEC convert hex to decimal                   11/02/81
                            	  5378: ;
                            	  5379: ;    CONVERT BINARY TO DECIMAL  REG  D0 PUT IN ( A6) BUFFER AS ASCII
                            	  5380: 
                            	  5381: ; Shift buffer one character to left
                            	  5382: ShiftBuf:
00:000089D4 48E78028        	  5383: 	movem.l d0/a2/a4,-(a7)
00:000089D8 200B            	  5384: 	move.l a3,d0
00:000089DA 06800000003F    	  5385: 	addi.l #BUFSIZE,d0
                            	  5386: .0001:
00:000089E0 18EC0001        	  5387: 	move.b 1(a4),(a4)+
00:000089E4 B08C            	  5388: 	cmp.l a4,d0
00:000089E6 65F8            	  5389: 	blo.s .0001
00:000089E8 4CDF1401        	  5390: 	movem.l (a7)+,d0/a2/a4
00:000089EC 4E75            	  5391: 	rts
                            	  5392: 
                            	  5393: HEX2DEC2:
00:000089EE 48E7C01C        	  5394: 	movem.l d0/d1/a3/a4/a5,-(a7)
00:000089F2 264E            	  5395: 	move.l a6,a3
00:000089F4 284E            	  5396: 	move.l a6,a4
00:000089F6 2200            	  5397: 	move.l d0,d1
00:000089F8 6A0A            	  5398: 	bpl.s .0001
00:000089FA 4480            	  5399: 	neg.l d0										;
00:000089FC 6B32            	  5400: 	bmi.s .0002									; neg and still minus, must be -tve zero
00:000089FE 1CFC002D        	  5401: 	move.b #'-',(a6)+
00:00008A02 284E            	  5402: 	move.l a6,a4
                            	  5403: .0001:
00:00008A04 82FC0064        	  5404: 	divu #100,d1								; scale d1 - chop last 2 decimal digits
00:00008A08 A2C10000        	  5405: 	bin2bcd d1									; convert to BCD
00:00008A0C 6100F282        	  5406: 	bsr BufTetra								; capture in buffer (8 digits)
00:00008A10 2200            	  5407: 	move.l d0,d1
00:00008A12 A2C10000        	  5408: 	bin2bcd d1									; convert to BCD
00:00008A16 6100F284        	  5409: 	bsr BufByte									; capture last 2 digits in buffer
                            	  5410: .0004:
00:00008A1A 0C140030        	  5411: 	cmpi.b #'0',(a4)						; Is there a leading zero?
00:00008A1E 6606            	  5412: 	bne.s .0003									; No, we're done shifting
00:00008A20 61B2            	  5413: 	bsr ShiftBuf								; Shift the buffer over a character
00:00008A22 538E            	  5414: 	subq.l #1,a6								; adjust buffer pos.
00:00008A24 60F4            	  5415: 	bra.s .0004									; go check next character
                            	  5416: .0003:
00:00008A26 4A14            	  5417: 	tst.b (a4)
00:00008A28 6706            	  5418: 	beq.s .0002
00:00008A2A 0C140020        	  5419: 	cmpi.b #' ',(a4)						; is the buffer empty?
00:00008A2E 6606            	  5420: 	bne.s .0005
                            	  5421: .0002:
00:00008A30 18FC0030        	  5422: 	move.b #'0',(a4)+						; ensure at least a '0'
00:00008A34 2C4C            	  5423: 	move.l a4,a6
                            	  5424: .0005:
00:00008A36 4CDF3803        	  5425: 	movem.l (a7)+,d0/d1/a3/a4/a5
00:00008A3A 4E75            	  5426: 	rts
                            	  5427: 
                            	  5428: HEX2DEC: 
00:00008A3C 48E77B00        	  5429: 	movem.l D1-D4/D6-D7,-(A7)   ; SAVE REGISTERS
00:00008A40 2E00            	  5430: 	move.l D0,D7          			; SAVE IT HERE
00:00008A42 6A08            	  5431: 	bpl.s HX2DC
00:00008A44 4487            	  5432: 	neg.l D7              			; CHANGE TO POSITIVE
00:00008A46 6B4E            	  5433: 	bmi.s HX2DC57          			; SPECIAL CASE (-0)
00:00008A48 1CFC002D        	  5434: 	move.b #'-',(A6)+      			; PUT IN NEG SIGN
                            	  5435: HX2DC:  
00:00008A4C 4244            	  5436: 	clr.w D4              			; FOR ZERO SURPRESS
00:00008A4E 7C0A            	  5437: 	moveq #10,D6          			; COUNTER
                            	  5438: HX2DC0:
00:00008A50 7401            	  5439:   moveq #1,D2           			; VALUE TO SUB
00:00008A52 2206            	  5440: 	move.l D6,D1          			; COUNTER
00:00008A54 5381            	  5441: 	subq.l #1,D1           			; ADJUST - FORM POWER OF TEN
00:00008A56 671A            	  5442: 	beq.s HX2DC2           			; IF POWER IS ZERO
                            	  5443: HX2DC1:
00:00008A58 3602            	  5444:   move.w D2,D3          			; D3=LOWER WORD
00:00008A5A C6FC000A        	  5445: 	mulu #10,D3
00:00008A5E 4842            	  5446: 	swap D2              				; D2=UPPER WORD
00:00008A60 C4FC000A        	  5447: 	mulu #10,D2
00:00008A64 4843            	  5448: 	swap D3              				; ADD UPPER TO UPPER
00:00008A66 D443            	  5449: 	add.w D3,D2
00:00008A68 4842            	  5450: 	swap D2              				; PUT UPPER IN UPPER
00:00008A6A 4843            	  5451: 	swap D3              				; PUT LOWER IN LOWER
00:00008A6C 3403            	  5452: 	move.w D3,D2          			; D2=UPPER & LOWER
00:00008A6E 5381            	  5453: 	subq.l #1,D1
00:00008A70 66E6            	  5454: 	bne.s HX2DC1
                            	  5455: HX2DC2:
00:00008A72 7000            	  5456:   clr.l D0              			; HOLDS SUB AMT
                            	  5457: HX2DC22:
00:00008A74 BE82            	  5458: 	cmp.l D2,D7
00:00008A76 6D06            	  5459:   blt.s HX2DC3           			; IF NO MORE SUB POSSIBLE
00:00008A78 5280            	  5460: 	addq.l #1,D0           			; BUMP SUBS
00:00008A7A 9E82            	  5461: 	sub.l D2,D7          				; COUNT DOWN BY POWERS OF TEN
00:00008A7C 60F6            	  5462: 	bra.s HX2DC22          			; DO MORE
                            	  5463: HX2DC3:
00:00008A7E 4A00            	  5464:   tst.b D0              			; ANY VALUE?
00:00008A80 6604            	  5465: 	bne.s HX2DC4
00:00008A82 4A44            	  5466: 	tst.w D4              			; ZERO SURPRESS
00:00008A84 6708            	  5467: 	beq.s HX2DC5
                            	  5468: HX2DC4:
00:00008A86 06000030        	  5469:   addi.b #$30,D0         		; BINARY TO ASCII
00:00008A8A 1CC0            	  5470: 	move.b D0,(A6)+       			; PUT IN BUFFER
00:00008A8C 1800            	  5471: 	move.b D0,D4          			; MARK AS NON ZERO SURPRESS
                            	  5472: HX2DC5:
00:00008A8E 5386            	  5473:   subq.l #1,D6           			; NEXT POWER
00:00008A90 66BE            	  5474: 	bne.s HX2DC0
00:00008A92 4A44            	  5475: 	tst.w D4              			; SEE IF ANYTHING PRINTED
00:00008A94 6604            	  5476: 	bne.s HX2DC6
                            	  5477: HX2DC57:
00:00008A96 1CFC0030        	  5478:  move.b #'0',(A6)+      			; PRINT AT LEST A ZERO
                            	  5479: HX2DC6:
00:00008A9A 4CDF00DE        	  5480: 	movem.l (A7)+,D1-D4/D6-D7 ; RESTORE REGISTERS
00:00008A9E 4E75            	  5481:   rts                      	; END OF ROUTINE
                            	  5482: 
                            	  5483: 
                            	  5484: PNT4HX:
                            	  5485: PNT4HEX:
00:00008AA0 6000F1F4        	  5486: 	bra BufWyde
                            	  5487: PNT6HX:
00:00008AA4 4840            	  5488: 	swap d0
00:00008AA6 6100F1F4        	  5489: 	bsr BufByte
00:00008AAA 4840            	  5490: 	swap d0
00:00008AAC 6000F1E8        	  5491: 	bra BufWyde
                            	  5492: PNT8HX:
00:00008AB0 6000F1DE        	  5493: 	bra BufTetra
                            	  5494: 	
                            	  5495: ; FORMAT RELATIVE ADDRESS  AAAAAA+Rn
                            	  5496: ;        ENTER     D0 = VALUE
                            	  5497: ;                  A6 = STORE POINTER
                            	  5498: ;
                            	  5499: FRELADDR:
00:00008AB4 48E74780        	  5500: 	movem.l D1/D5-D7/A0,-(A7)
00:00008AB8 41F900040880    	  5501: 	lea OFFSET,A0
00:00008ABE 7EFF            	  5502: 	moveq #-1,D7        	; D7 = DIFF. BEST FIT
00:00008AC0 7C00            	  5503: 	clr.l D6            	; D6 = OFFSET POSITION
                            	  5504: FREL10:
00:00008AC2 2200            	  5505:   move.l D0,D1
00:00008AC4 4A90            	  5506: 	tst.l (a0)
00:00008AC6 670C            	  5507: 	beq.s FREL15         	; ZERO OFFSET
00:00008AC8 9290            	  5508: 	sub.l (a0),d1      		; D1 = DIFF.
00:00008ACA 6B08            	  5509: 	bmi.s FREL15         	; NO FIT
00:00008ACC B287            	  5510: 	cmp.l D7,D1
00:00008ACE 6404            	  5511: 	bcc.s FREL15         	; OLD FIT BETTER
00:00008AD0 2E01            	  5512: 	move.l D1,D7        	; D7 = NEW BEST FIT
00:00008AD2 2A06            	  5513: 	move.l D6,D5        	; D5 = POSITION
                            	  5514: FREL15:
00:00008AD4 5888            	  5515:   addq.l #4,A0
00:00008AD6 5286            	  5516: 	addq.l #1,D6
00:00008AD8 0C460008        	  5517: 	cmpi.w #8,D6
00:00008ADC 66E4            	  5518: 	bne.s FREL10         	; MORE OFFSETS TO CHECK
00:00008ADE 4A87            	  5519: 	tst.l D7
00:00008AE0 6B1E            	  5520: 	bmi.s FREL25         	; NO FIT
00:00008AE2 4A46            	  5521: 	tst D6
00:00008AE4 6608            	  5522: 	bne.s FREL20
00:00008AE6 4AB900040880    	  5523: 	tst.l OFFSET
00:00008AEC 6712            	  5524: 	beq.s FREL25         	; R0 = 000000; NO FIT
                            	  5525: FREL20:
00:00008AEE 2007            	  5526:   move.l D7,D0
00:00008AF0 61B2            	  5527: 	bsr	PNT6HX         		; FORMAT OFFSET
00:00008AF2 1CFC002B        	  5528: 	move.b #'+',(A6)+    	; +
00:00008AF6 1CFC0052        	  5529: 	move.b #'R',(A6)+    	; R
00:00008AFA 06050030        	  5530: 	addi.b #'0',D5       	; MAKE ASCII
00:00008AFE 600A            	  5531: 	bra.s FREL30
                            	  5532: FREL25:
00:00008B00 61A2            	  5533:   bsr	PNT6HX         	; FORMAT ADDRESS AS IS
00:00008B02 1A3C0020        	  5534: 	move.b #BLANK,D5
00:00008B06 1CC5            	  5535: 	move.b D5,(A6)+     	; THREE SPACES FOR ALIGNMENT
00:00008B08 1CC5            	  5536: 	move.b D5,(A6)+
                            	  5537: FREL30:
00:00008B0A 1CC5            	  5538:   move.b D5,(A6)+
00:00008B0C 4CDF01E2        	  5539: 	movem.l (A7)+,D1/D5-D7/A0
00:00008B10 4E75            	  5540: 	rts
                            	  5541: 
                            	  5542: 	include "dcode68k.x68"

Source: "dcode68k.x68"
                            	     1: ;-------------------------------------------------------------------------
                            	     2: ; File DCODE68K  68K ONE LINE DISASSEMBLER                        07/28/82
                            	     3: ;
                            	     4: ;        CALLING SEQUENCE:
                            	     5: ;   D0,D1,D2 = CODE TO BE DISASSEMBLED
                            	     6: ;   A4 = VALUE OF PROGRAM COUNTER FOR THE CODE
                            	     7: ;   A5 = POINTER TO STORE DATA (BUFSIZE = 80 ASSUMED)
                            	     8: ;        JSR       DCODE68K
                            	     9: ;
                            	    10: ;        RETURN:
                            	    11: ;   A4 = VALUE OF PROGRAM COUNTER FOR NEXT INSTRUCTION
                            	    12: ;   A5 = POINTER TO LINE AS DISASSEMBLED
                            	    13: ;   A6 = POINTER TO END OF LINE
                            	    14: ;
                            	    15: ; 01234567890123456789012345678901234567890123456789
                            	    16: ; AAAAAA FDATA.DDDDDDDDDDDDDD FOC.... FOP.....
                            	    17: ;
                            	    18: ;FDATA   =       10             DATA FIELD
                            	    19: ;FOC     =       31             OP-CODE FIELD
                            	    20: ;FOP     =       39             OPERAND FIELD
                            	    21: ;
                            	    22: ; CAUSES ORGIN MODULO 4
                            	    23: ; LONG:    macro
                            	    24: ;         .align  2
                            	    25: ;         DS.B    (;-X)&2
                            	    26: ;         endm
                            	    27: LOCVARSZ = 16
                            	    28: BUFSIZE  = 63
                            	    29: FDATA    =       10        ; OFFSET TO DATA
                            	    30: FOL      =       31        ; OFFSET TO LABEL
                            	    31: FOC      =       31        ; OFFSET TO OP-CODE (NO LABEL FIELD)
                            	    32: FOP      =       39        ; OFFSET TO OPERAND (NO LABEL FIELD)
                            	    33: 
                            	    34: 					code
                            	    35: 					even
                            	    36: X:       ;              ; BASE ADDRESS THIS MODULE
                            	    37:                                 ; LONG
                            	    38: 
                            	    39: ;  MOVEM REGISTERS TO EA
                            	    40: ;
                            	    41: ;        01001D001S......
                            	    42: ;        ..........XXXXXX       EFFECTIVE ADDRESS
                            	    43: ;        .........0......       WORD
                            	    44: ;        .........1......       LONG
                            	    45: ;        .....0..........       REGISTER TO MEMORY
                            	    46: ;        .....1..........       MEMORY TO REGISTER
                            	    47: ;
                            	    48: ;
                            	    49: IMOVEMFR:
00:00008B12 610006F8        	    50:          BSR     MOVEMS         ; SIZE
                            	    51: 
00:00008B16 7C38            	    52:          MOVEQ   #$0038,D6
00:00008B18 CC54            	    53:          AND.W   (A4),D6
00:00008B1A 0C460020        	    54:          CMPI.W  #$0020,D6
00:00008B1E 6706            	    55:          BEQ.S   IM7788         ; PREDECREMENT MODE
                            	    56: 
00:00008B20 7C01            	    57:          MOVEQ   #1,D6         ; D6 = INCREMENTER (BIT POSITION)
00:00008B22 7200            	    58:          MOVEQ   #0,D1         ; D1 = BIT POSITION
00:00008B24 6004            	    59:          BRA.S   IM7799
                            	    60: 
00:00008B26 7CFF            	    61: IM7788:  MOVEQ   #-1,D6        ; D6 = DECREMENTER (BIT POSITION)
00:00008B28 720F            	    62:          MOVEQ   #15,D1        ; D1 = BIT POSITION
00:00008B2A 610006F4        	    63: IM7799:  BSR     MOVEMR         ; BUILD MASK WORD
                            	    64: 
00:00008B2E 1CFC002C        	    65:          MOVE.B  #',',(A6)+    ; STORE COMMA
                            	    66: 
00:00008B32 5483            	    67:          ADDQ.L  #2,D3
00:00008B34 3814            	    68:          MOVE.W  (A4),D4
00:00008B36 3E3C01F4        	    69:          MOVE.W  #$1F4,D7     ; CONTROL + PREDECREMENT
00:00008B3A 6100050E        	    70:          BSR     EEA
00:00008B3E 601A            	    71:          BRA.S   CS16           ; COMMON
                            	    72: 
                            	    73:          
                            	    74: 
                            	    75: ; MOVEM  EA  TO REGISTERS
                            	    76: ;
00:00008B40 610006CA        	    77: IMOVEMTR:BSR     MOVEMS         ; SIZE
00:00008B44 5483            	    78:          ADDQ.L  #2,D3
00:00008B46 3E3C07EC        	    79:          MOVE.W  #$7EC,D7     ; CONTROL + POSTINCREMENT
00:00008B4A 610004FE        	    80:          BSR     EEA
                            	    81: 
00:00008B4E 1CFC002C        	    82:          MOVE.B  #',',(A6)+    ; STORE COMMA
                            	    83: 
00:00008B52 7C01            	    84:          MOVEQ   #1,D6         ; D6 = BIT POSITION INCREMENTER
00:00008B54 7200            	    85:          MOVEQ   #0,D1         ; D1 = BIT POSITION
00:00008B56 610006C8        	    86:          BSR     MOVEMR
                            	    87: 
00:00008B5A 606C            	    88: CS16:    BRA.S   CS15           ; COMMON
                            	    89: 
                            	    90:          
                            	    91: ISTOP:
00:00008B5C 302C0002        	    92: 	move.w 2(A4),D0
00:00008B60 1CFC0023        	    93: 	move.b #'#',(A6)+    	; IMMEDIATE
00:00008B64 1CFC0024        	    94: 	move.b #'$',(A6)+    	; HEX
00:00008B68 6100FF36        	    95: 	bsr PNT4HX         		; VALUE
00:00008B6C 600007C6        	    96: 	bra COMMON4
                            	    97: 
                            	    98: IMMED:   ;.align  2              ; ADD  AND  CMP #  EOR  OR  SUB
00:00008B70 6100044E        	    99: 	bsr FORMSIZE
00:00008B74 5483            	   100: 	addq.l #2,D3         	; SIZE = 4
00:00008B76 1CFC0023        	   101: 	move.b #'#',(A6)+    	; IMMEDIATE
00:00008B7A 7000            	   102: 	clr.l D0
00:00008B7C 302C0002        	   103: 	move.w 2(A4),D0     	; D0 = EXTENSION WORD
00:00008B80 3214            	   104: 	move.w (A4),D1
00:00008B82 EC49            	   105: 	lsr.w #6,D1
00:00008B84 02410003        	   106: 	andi.w #3,D1
00:00008B88 6746            	   107: 	beq.s IMMED65        	; .BYTE
00:00008B8A 0C010001        	   108: 	cmpi.b #1,D1
00:00008B8E 6750            	   109: 	beq.s IMMED75        	; .WORD
00:00008B90 5483            	   110: 	addq.l #2,D3         	; .LONG    SIZE = 6
00:00008B92 202C0002        	   111: 	move.l 2(A4),D0     	; D0 = LONG EXTENSION WORD
                            	   112: 
                            	   113: IMMED45:
00:00008B96 6100FEA4        	   114: 	bsr HEX2DEC        		; DECIMAL
00:00008B9A 1CC5            	   115: 	move.b D5,(A6)+     	; COMMA SEPARATOR
00:00008B9C 3014            	   116: 	move (A4),D0
00:00008B9E 0240003F        	   117: 	andi.w #$003F,D0
00:00008BA2 0C40003C        	   118: 	cmpi.w #$003C,D0    	; DESTINATION ADDRESS MODE 111100  "SR"
00:00008BA6 6622            	   119: 	bne.s IMMED55        	; NOT FOUND
00:00008BA8 3014            	   120: 	move.w (A4),D0      	; "SR"  ILLEGAL FOR
00:00008BAA 02404000        	   121: 	andi.w #$4000,D0    	; ADDI   SUBI  CMPI
00:00008BAE 660007AE        	   122: 	bne FERROR         		; 0600   0400  0C00
00:00008BB2 3214            	   123: 	move.w (A4),D1
00:00008BB4 024100C0        	   124: 	andi.w #$00C0,D1
00:00008BB8 0C410080        	   125: 	cmpi.w #$0080,D1
00:00008BBC 670007A0        	   126: 	beq FERROR         		; .LONG NOT ALLOWED
00:00008BC0 1CFC0053        	   127: 	move.b #'S',(A6)+    	; #,SR FOR ANDI, EORI, ORI
00:00008BC4 1CFC0052        	   128: 	move.b #'R',(A6)+
                            	   129: CS15:
00:00008BC8 603C            	   130: 	bra.s CS14           	; COMMON
                            	   131: IMMED55:
00:00008BCA 6100047E        	   132: 	bsr EEA
00:00008BCE 6036            	   133: 	bra.s CS14           	; COMMON
                            	   134: IMMED65:
00:00008BD0 2200            	   135: 	move.l D0,D1        	; D1 = XXXXXXXX........
00:00008BD2 E049            	   136: 	lsr.w #8,D1         	; D1 = 00000000XXXXXXXX
00:00008BD4 670A            	   137: 	beq.s IMMED75
00:00008BD6 2200            	   138: 	move.l D0,D1
00:00008BD8 EE41            	   139: 	asr.w #7,D1
00:00008BDA 5241            	   140: 	addq.w #1,D1         ; CHECK FOR NEGATIVE
00:00008BDC 66000780        	   141: 	bne FERROR
                            	   142: IMMED75:
00:00008BE0 48C0            	   143: 	ext.l D0
00:00008BE2 60B2            	   144: 	bra.s IMMED45
                            	   145: 
                            	   146: ;  BIT   5432109876543210
                            	   147: ;        ....RRRMMM......       ; DESTINATION REGISTER MODE
                            	   148: ;        ..........MMMRRR       ; SOURCE MODE REGISTER
                            	   149: ;        0001............       ; .BYTE
                            	   150: ;        0011............       ; .WORD
                            	   151: ;        0010............       ; .LONG
                            	   152: ;
                            	   153: ; IF BYTE SIZE; DESTINATION ADDRESS DIRECT NOT ALLOWED
                            	   154:    
                            	   155: IMOVE:
00:00008BE4 6000037E        	   156: 	bra IMOVEA1
                            	   157: 
                            	   158: ILINK:
00:00008BE8 6158            	   159: 	bsr.s FORMREGA
00:00008BEA 1CC5            	   160: 	move.b D5,(A6)+     ; COMMA SERARATOR
00:00008BEC 1CFC0023        	   161: 	move.b #'#',(A6)+
00:00008BF0 302C0002        	   162: 	move.w 2(A4),D0
00:00008BF4 48C0            	   163: 	ext.l D0
00:00008BF6 6100FE44        	   164: 	bsr HEX2DEC        	; DECIMAL DISPLACEMENT
00:00008BFA 60000738        	   165: 	bra COMMON4
                            	   166:          
                            	   167:          ; CLR  NEG  NEGX  NOT TST
                            	   168: FORM1:
00:00008BFE 610003C0        	   169: 	bsr FORMSIZE
                            	   170: ;                               ; NBCD TAS
                            	   171: FORM1A:
00:00008C02 61000446        	   172: 	bsr EEA            	; DATA ALTERABLE ONLY
                            	   173: CS14:
00:00008C06 6068            	   174: 	bra.s CS13          ; COMMON
                            	   175:      
                            	   176: 
                            	   177: 				;.align  2              ; EXT  SWAP
                            	   178: FORM3:   
00:00008C08 6148            	   179: 	bsr.s FORMREGD
00:00008C0A 6064            	   180: 	bra.s CS13           	; COMMON
                            	   181:          
                            	   182: 
                            	   183: FORM4:	;   .align  2              ; TRAP
00:00008C0C 1CFC0023        	   184:          MOVE.B  #'#',(A6)+
00:00008C10 3014            	   185:          MOVE.W  (A4),D0
00:00008C12 02800000000F    	   186:          ANDI.L  #$0F,D0
00:00008C18 6100FE22        	   187:          BSR     HEX2DEC        ; DECIMAL
00:00008C1C 6052            	   188:          BRA.S   CS13           ; COMMON
                            	   189: 
                            	   190:          
                            	   191: 
                            	   192: FORM5:	;   .align  2              ; UNLNK
00:00008C1E 6122            	   193:          BSR.S   FORMREGA
00:00008C20 604E            	   194:          BRA.S   CS13           ; COMMON
                            	   195: 
                            	   196: ;  BIT   5432109876543210
                            	   197: ;        ....RRR.........       ; ADDRESS REGISTER
                            	   198: ;        ..........XXXXXX       ; EFFECTIVE ADDRESS
                            	   199: ;
                            	   200:          
                            	   201: 
                            	   202: FORM6A:	;  .align  2              ; LEA
00:00008C22 3E3C07E4        	   203:          MOVE.W  #$7E4,D7     ; CONTROL ADDRESSING
00:00008C26 6150            	   204:          BSR.S   EEA10
                            	   205: 
00:00008C28 1CC5            	   206:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   207: 
00:00008C2A 3814            	   208:          MOVE.W  (A4),D4
00:00008C2C EF5C            	   209:          ROL.W   #7,D4
00:00008C2E 6112            	   210:          BSR.S   FORMREGA
00:00008C30 603E            	   211:          BRA.S   CS13           ; COMMON
                            	   212: 
                            	   213: ;  BIT   5432109876543210
                            	   214: ;        ....DDD.........       ; DATA REGISTER
                            	   215: ;        ..........XXXXXX       ; EFFECTIVE ADDRESS
                            	   216: ;
                            	   217:          
                            	   218: 
                            	   219: FORM6D:  ;.align  2              ; CHK  DIVS  DIVU  MULS  MULU
00:00008C32 3E3C0FFD        	   220:          MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:00008C36 6140            	   221:          BSR.S   EEA10
                            	   222: 
00:00008C38 1CC5            	   223:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   224: 
00:00008C3A 3814            	   225:          MOVE.W  (A4),D4
00:00008C3C EF5C            	   226:          ROL.W   #7,D4
00:00008C3E 6112            	   227:          BSR.S   FORMREGD
00:00008C40 602E            	   228:          BRA.S   CS13           ; COMMON
                            	   229: 
00:00008C42 1CFC0041        	   230: FORMREGA:MOVE.B  #'A',(A6)+    ; FORMAT A@
00:00008C46 02040007        	   231: FORMREG5:ANDI.B  #$07,D4
00:00008C4A 00040030        	   232:          ORI.B   #'0',D4
00:00008C4E 1CC4            	   233:          MOVE.B  D4,(A6)+
00:00008C50 4E75            	   234:          RTS
                            	   235: 
00:00008C52 1CFC0044        	   236: FORMREGD:MOVE.B  #'D',(A6)+    ; FORMAT D@
00:00008C56 60EE            	   237:          BRA.S   FORMREG5
                            	   238: 
                            	   239: ;  BIT   5432109876543210
                            	   240: ;        ....DDD......DDD       ; DATA REGISTERS
                            	   241: ;
                            	   242:         
                            	   243: FORM7: ;  .align  2              ; EXG
00:00008C58 EF5C            	   244: 	rol.w #7,D4
00:00008C5A 61F6            	   245: 	bsr.s FORMREGD
00:00008C5C 1CC5            	   246: 	move.b D5,(A6)+     	; COMMA SEPARATOR
00:00008C5E 3814            	   247: 	move.w (A4),D4
00:00008C60 61F0            	   248: 	bsr.s FORMREGD
00:00008C62 600C            	   249: 	bra.s CS13           	; COMMON
                            	   250: 
                            	   251: ;  BIT   5432109876543210
                            	   252: ;        ....AAA......AAA       ; ADDRESS REGISTERS
                            	   253: ;
                            	   254:          
                            	   255: FORM8:   ;.align  2              ; EXG
00:00008C64 EF5C            	   256:          ROL.W   #7,D4
00:00008C66 61DA            	   257:          BSR.S   FORMREGA
                            	   258: 
                            	   259: FORM815:
00:00008C68 1CFC002C        	   260: 	MOVE.B  #',',(A6)+    ; COMMA SEPARATOR
00:00008C6C 3814            	   261: 	MOVE.W  (A4),D4
00:00008C6E 61D2            	   262: 	BSR.S   FORMREGA
                            	   263: CS13:
00:00008C70 6078            	   264: 	BRA     CS12           ; COMMON
                            	   265: 
                            	   266: ;  BIT   5432109876543210
                            	   267: ;        ....DDD.........       ; DATA REGISTER
                            	   268: ;        .............AAA       ; ADDRESS REGISTER
                            	   269: ;
                            	   270:          
                            	   271: 
                            	   272: FORM9:   ;.align  2              ; EXG
00:00008C72 EF5C            	   273:          ROL.W   #7,D4
00:00008C74 61DC            	   274:          BSR.S   FORMREGD       ; DATA REGISTER
00:00008C76 60F0            	   275:          BRA.S   FORM815
                            	   276: 
00:00008C78 600003D0        	   277: EEA10:   BRA     EEA
                            	   278: 
                            	   279: ;  BIT   5432109876543210
                            	   280: ;        ..........AAAAAA         EFFECTIVE ADDRESS
                            	   281: ;        .......MMM......         OP-MODE
                            	   282: ;        ....RRR.........         D-REGISTER
                            	   283: ;        .......011......         WORD  EA,A@
                            	   284: ;        .......111......         LONG  EA,A@
                            	   285: ;        .......000......         EA,D@ BYTE (ADDRESS REGISTER DIRECT NOT ALLOWED)
                            	   286: ;        .......0........         EA,D@
                            	   287: ;        .......1........         D@,EA
                            	   288: ;        ........00......         BYTE
                            	   289: ;        ........01......         WORD
                            	   290: ;        ........10......         LONG
                            	   291: ;
                            	   292:          
                            	   293: 
                            	   294: ;                               ADD <EA>,A@   CMP <EA>,A@   SUB <EA>,A@
                            	   295: FORM10EX:	;.align  2              ; ADD  CMP  SUB
00:00008C7C 3E3C0FFF        	   296:          MOVE.W  #$FFF,D7     ; ALL MODES ALLOWED
00:00008C80 2004            	   297:          MOVE.L  D4,D0
00:00008C82 024001C0        	   298:          ANDI.W  #$01C0,D0
00:00008C86 6738            	   299:          BEQ.S   FORM103        ; .......000......
00:00008C88 0C4001C0        	   300:          CMPI.W  #$01C0,D0
00:00008C8C 6710            	   301:          BEQ.S   FORM10E3       ; .......111......
00:00008C8E 0C4000C0        	   302:          CMPI.W  #$00C0,D0
00:00008C92 661E            	   303:          BNE.S   FORM10E6
                            	   304: 
00:00008C94 1AFC002E        	   305:          MOVE.B  #'.',(A5)+    ; .......011......       STORE PERIOD
00:00008C98 1AFC0057        	   306:          MOVE.B  #'W',(A5)+
00:00008C9C 6008            	   307:          BRA.S   FORM10E4
                            	   308: 
00:00008C9E 1AFC002E        	   309: FORM10E3:MOVE.B  #'.',(A5)+
00:00008CA2 1AFC004C        	   310:          MOVE.B  #'L',(A5)+
                            	   311: 
00:00008CA6 61D0            	   312: FORM10E4:BSR.S   EEA10
                            	   313: 
00:00008CA8 1CC5            	   314:          MOVE.B  D5,(A6)+     ; STORE COMMA SEPARATOR
                            	   315: 
00:00008CAA 3814            	   316:          MOVE.W  (A4),D4
00:00008CAC EF5C            	   317:          ROL.W   #7,D4
00:00008CAE 6192            	   318:          BSR.S   FORMREGA       ; <EA>,A@
00:00008CB0 6038            	   319:          BRA.S   CS12           ; COMMON
                            	   320: 
00:00008CB2 08140000        	   321: FORM10E6:BTST.B  #0,(A4)
00:00008CB6 661C            	   322:          BNE.S   FORM105        ; .......1........    D@,<EA>
00:00008CB8 600A            	   323:          BRA.S   FORM104        ; .......0........    <EA>,D@
                            	   324: 
                            	   325: ;  BIT   5432109876543210
                            	   326: ;        ..........AAAAAA       EFFECTIVE ADDRESS
                            	   327: ;        .......MMM......       OP-MODE
                            	   328: ;        ....RRR.........       D-REGISTER
                            	   329: ;        .......0........       EA,D@
                            	   330: ;        .......1........       D@,EA
                            	   331: ;        ........00......       BYTE
                            	   332: ;        ........01......       WORD
                            	   333: ;        ........10......       LONG
                            	   334: 
                            	   335:          
                            	   336: 
                            	   337: FORM10:  ;.align  2              ; AND  EOR  OR
00:00008CBA 08140000        	   338:          BTST.B  #0,(A4)
00:00008CBE 6614            	   339:          BNE.S   FORM105
                            	   340: 
00:00008CC0 3E3C0FFD        	   341: FORM103: MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:00008CC4 610002FA        	   342: FORM104: BSR     FORMSIZE
00:00008CC8 61AE            	   343:          BSR.S   EEA10          ; <EA>,D@
                            	   344: 
00:00008CCA 1CC5            	   345:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   346: 
00:00008CCC 1814            	   347:          MOVE.B  (A4),D4
00:00008CCE E20C            	   348:          LSR.B   #1,D4
00:00008CD0 6180            	   349:          BSR     FORMREGD
00:00008CD2 6016            	   350:          BRA.S   CS12           ; COMMON
                            	   351: 
00:00008CD4 610002EA        	   352: FORM105: BSR     FORMSIZE       ; D@,<EA>
00:00008CD8 1814            	   353:          MOVE.B  (A4),D4
00:00008CDA E20C            	   354:          LSR.B   #1,D4
00:00008CDC 6100FF74        	   355:          BSR     FORMREGD
                            	   356: 
00:00008CE0 1CC5            	   357:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   358: 
00:00008CE2 3814            	   359:          MOVE.W  (A4),D4
00:00008CE4 3E3C01FD        	   360:          MOVE.W  #$1FD,D7     ; ALTERABLE MEMORY ADDRESSING
00:00008CE8 618E            	   361:          BSR.S   EEA10
00:00008CEA 6000064A        	   362: CS12:    BRA     COMMON
                            	   363: 
                            	   364:          
                            	   365: 
                            	   366: ;                               PEA     (JMP  JSR)
00:00008CEE 3E3C07E4        	   367: FORM11:  MOVE.W  #$7E4,D7     ; CONTROL ADDERSSING
00:00008CF2 6184            	   368:          BSR     EEA10
00:00008CF4 60F4            	   369:          BRA.S   CS12           ; COMMON
                            	   370: 
                            	   371:          
                            	   372: 
                            	   373: ;                               ; JMP  JSR
00:00008CF6 2004            	   374: FORM11SL:MOVE.L  D4,D0        ; LOOK FOR .S  OR  .L
00:00008CF8 0240003F        	   375:          ANDI.W  #$3F,D0
00:00008CFC 0C400038        	   376:          CMPI.W  #$38,D0
00:00008D00 6608            	   377:          BNE.S   FORM112        ; NOT .S
00:00008D02 1AFC002E        	   378:          MOVE.B  #'.',(A5)+    ; PERIOD
00:00008D06 1AFC0053        	   379:          MOVE.B  #'S',(A5)+    ; S
00:00008D0A 0C400039        	   380: FORM112: CMPI.W  #$39,D0
00:00008D0E 6608            	   381:          BNE.S   FORM114
00:00008D10 1AFC002E        	   382:          MOVE.B  #'.',(A5)+    ; PERIOD
00:00008D14 1AFC004C        	   383:          MOVE.B  #'L',(A5)+    ; L
00:00008D18 60D4            	   384: FORM114: BRA.S   FORM11
                            	   385: 
                            	   386: ;  BIT   5432109876543210
                            	   387: ;        ....XXX.....0...       DATA DESTINATION REGISTER
                            	   388: ;        ....XXX.....1...       ADDRESS REGISTER
                            	   389: ;        ....XXX.00......       BYTE
                            	   390: ;        ........01......       WORD
                            	   391: ;        ........10......       LONG
                            	   392: ;        ............0...       DATA REGISTER TO DATA REGISTER
                            	   393: ;        ............1...       MEMORY TO MEMORY
                            	   394: ;        ............0xXX       DATA SOURCE REGISTER
                            	   395: ;        ............1XXX       ADDRESS SOURCE REGISTER
                            	   396: ;
                            	   397:          
                            	   398: 
                            	   399: FORM12:  ;.align  2              ; ABCD  ADDX  SBCD  SUBX
00:00008D1A 610002A4        	   400:          BSR     FORMSIZE
                            	   401: 
00:00008D1E 08040003        	   402:          BTST    #3,D4
00:00008D22 6610            	   403:          BNE.S   FORM125
                            	   404: 
00:00008D24 6100FF2C        	   405:          BSR     FORMREGD       ; D@,D@;   FORMAT SOURCE
                            	   406: 
00:00008D28 1CC5            	   407:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   408: 
00:00008D2A 1814            	   409:          MOVE.B  (A4),D4
00:00008D2C E20C            	   410:          LSR.B   #1,D4
00:00008D2E 6100FF22        	   411:          BSR     FORMREGD       ; FORMAT DESTINATION
00:00008D32 6046            	   412:          BRA.S   CS11           ; COMMON
                            	   413: 
00:00008D34 1CFC002D        	   414: FORM125: MOVE.B  #'-',(A6)+    ; -
00:00008D38 1CFC0028        	   415:          MOVE.B  #'(',(A6)+    ; (
00:00008D3C 6100FF04        	   416:          BSR     FORMREGA       ; A@    SOURCE
                            	   417: 
00:00008D40 203C282D2C29    	   418:          MOVE.L  #$282d2c29,D0 ; ),-(
00:00008D46 6152            	   419:          BSR.S   SCHR           ; STORE CHARS
                            	   420: 
00:00008D48 1814            	   421:          MOVE.B  (A4),D4
00:00008D4A E20C            	   422:          LSR.B   #1,D4
00:00008D4C 6100FEF4        	   423:          BSR     FORMREGA       ; A@   DESTINATION
00:00008D50 1CFC0029        	   424:          MOVE.B  #')',(A6)+
00:00008D54 6024            	   425:          BRA.S   CS11           ; COMMON
                            	   426: 
                            	   427: ;  BIT   5432109876543210
                            	   428: ;        ....XXX.....1...       ADDRESS REGISTER    DESTINATION
                            	   429: ;        ....XXX.00......       BYTE
                            	   430: ;        ........01......       WORD
                            	   431: ;        ........10......       LONG
                            	   432: ;        ............1...       MEMORY TO MEMORY
                            	   433: ;        ............1XXX       ADDRESS SOURCE REGISTER
                            	   434: ;
                            	   435:          
                            	   436: 
                            	   437: FORM12A: ;.align  2              ; CMPM
00:00008D56 61000268        	   438:          BSR     FORMSIZE
                            	   439: 
00:00008D5A 1CFC0028        	   440:          MOVE.B  #'(',(A6)+    ; (
00:00008D5E 6100FEE2        	   441:          BSR     FORMREGA       ; A@
                            	   442: 
00:00008D62 203C282C2B29    	   443:          MOVE.L  #$282c2b29,D0  ; )+,(
00:00008D68 6130            	   444:          BSR.S   SCHR           ; STORE CHARS
                            	   445: 
00:00008D6A 1814            	   446:          MOVE.B  (A4),D4
00:00008D6C E20C            	   447:          LSR.B   #1,D4
00:00008D6E 6100FED2        	   448:          BSR     FORMREGA       ; A@
00:00008D72 1CFC0029        	   449:          MOVE.B  #')',(A6)+
00:00008D76 1CFC002B        	   450:          MOVE.B  #'+',(A6)+
00:00008D7A 600005BA        	   451: CS11:    BRA     COMMON
                            	   452: 
                            	   453:          
                            	   454: 
00:00008D7E 60000210        	   455: IQUICK:  BRA     IQUICKA        ; ADDQ  SUBQ
                            	   456: 
                            	   457: ;  BIT   5432109876543210
                            	   458: ;        0111...0........       FIXED
                            	   459: ;        ....RRR.........       DATA REGISTER
                            	   460: ;        ........DDDDDDDD       SIGN EXTENDED DATA
                            	   461: ;
                            	   462:          
                            	   463: 
                            	   464: IMOVEQ:  ;.align  2
00:00008D82 1CFC0023        	   465:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	   466: 
00:00008D86 3014            	   467:          MOVE.W  (A4),D0
00:00008D88 4880            	   468:          EXT.W   D0
00:00008D8A 48C0            	   469:          EXT.L   D0
00:00008D8C 6100FCAE        	   470:          BSR     HEX2DEC        ; DECIMAL
                            	   471: 
00:00008D90 1CC5            	   472:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   473: 
00:00008D92 EF5C            	   474:          ROL.W   #7,D4
00:00008D94 6100FEBC        	   475:          BSR     FORMREGD
00:00008D98 60E0            	   476:          BRA.S   CS11           ; COMMON
                            	   477: 
00:00008D9A 1CC0            	   478: SCHR:    MOVE.B  D0,(A6)+     ; OUTPUT STRING
00:00008D9C E088            	   479:          LSR.L   #8,D0
00:00008D9E 66FA            	   480:          BNE.S   SCHR           ; MORE TO OUTPUT
00:00008DA0 4E75            	   481:          RTS
                            	   482: 
                            	   483: ; MOVE FROM SR  (STATUS REGISTER)
                            	   484: ;
                            	   485:          
                            	   486: 
00:00008DA2 203C002C5253    	   487: IMVFSR:  MOVE.L  #$002c5253,D0 ; SR,
                            	   488: 
00:00008DA8 61F0            	   489:          BSR.S   SCHR
00:00008DAA 6100029E        	   490:          BSR     EEA            ; DATA ALTERABLE
00:00008DAE 60CA            	   491:          BRA.S   CS11           ; COMMON
                            	   492: 
                            	   493: ; MOVE FROM USP (USER STACK POINTER)
                            	   494: ;
                            	   495:          
                            	   496: 
00:00008DB0 203C2C505355    	   497: IMVFUSP: MOVE.L  #$2c505355,D0 ; USP,
00:00008DB6 61E2            	   498:          BSR.S   SCHR
00:00008DB8 6100FE88        	   499:          BSR     FORMREGA
00:00008DBC 60BC            	   500:          BRA.S   CS11           ; COMMON
                            	   501: 
                            	   502: ; MOVE TO SR (STATUS REGISTER)
                            	   503: ;
                            	   504:          
                            	   505: 
00:00008DBE 3E3C0FFD        	   506: IMVTSR:  MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:00008DC2 61000286        	   507:          BSR     EEA
00:00008DC6 203C0052532C    	   508:          MOVE.L  #$0052532c,D0 ; ,SR
00:00008DCC 61CC            	   509: IMVT44:  BSR.S   SCHR
00:00008DCE 60AA            	   510:          BRA.S   CS11           ; COMMON
                            	   511: 
                            	   512: ; MOVE TO USP (USER STACK POINTER)
                            	   513: ;
                            	   514:          
                            	   515: 
00:00008DD0 6100FE70        	   516: IMVTUSP: BSR     FORMREGA
00:00008DD4 203C5053552C    	   517:          MOVE.L  #$5053552c,D0 ; ,USP
00:00008DDA 60F0            	   518:          BRA.S   IMVT44
                            	   519: 
                            	   520: ;  MOVE TO CCR (CONDITION CODE REGISTER)
                            	   521: ;
                            	   522:          
                            	   523: 
00:00008DDC 3E3C0FFD        	   524: IMVTCCR: MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:00008DE0 61000268        	   525:          BSR     EEA
00:00008DE4 203C5243432C    	   526:          MOVE.L  #$5243432c,D0 ; ,CCR
00:00008DEA 60E0            	   527:          BRA.S   IMVT44
                            	   528: 
                            	   529: ;  BIT   5432109876543210
                            	   530: ;        0000...1..001...       FIXED
                            	   531: ;        ....XXX.........       DATA REGISTER
                            	   532: ;        ........0.......       MEMORY TO REGISTER
                            	   533: ;        ........1.......       REGISTER TO MEMORY
                            	   534: ;        .........0......       WORD
                            	   535: ;        .........1......       LONG
                            	   536: ;        .............XXX       ADDRESS REGISTER
                            	   537: ;
                            	   538:          
                            	   539: 
                            	   540: IMOVEP:  ;.align  2
00:00008DEC 1AFC002E        	   541:          MOVE.B  #'.',(A5)+    ; D@,#(A@)
00:00008DF0 303C4C57        	   542:          MOVE.W  #$4c57,D0    ; "LW"
00:00008DF4 08040006        	   543:          BTST    #6,D4
00:00008DF8 6702            	   544:          BEQ.S   IMOVEP11       ; USE "W"
00:00008DFA E048            	   545:          LSR.W   #8,D0         ; USE "L"
00:00008DFC 1AC0            	   546: IMOVEP11:MOVE.B  D0,(A5)+     ; LENGTH
                            	   547: 
00:00008DFE 1814            	   548:          MOVE.B  (A4),D4
00:00008E00 E20C            	   549:          LSR.B   #1,D4
                            	   550: 
00:00008E02 082C00070001    	   551:          BTST.B  #7,1(A4)
00:00008E08 670E            	   552:          BEQ.S   IMOVEP35
                            	   553: 
00:00008E0A 6100FE46        	   554:          BSR     FORMREGD       ; D@,$HHHH(A@)
                            	   555: 
00:00008E0E 1CC5            	   556:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   557: 
00:00008E10 3814            	   558:          MOVE.W  (A4),D4
00:00008E12 6112            	   559:          BSR.S   IMOVEP66
00:00008E14 6000051E        	   560: CS20:    BRA     COMMON4
                            	   561: 
00:00008E18 610C            	   562: IMOVEP35:BSR.S   IMOVEP66       ; $HHHH(A@),D@
                            	   563: 
00:00008E1A 1CC5            	   564:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   565: 
00:00008E1C 1814            	   566:          MOVE.B  (A4),D4
00:00008E1E E20C            	   567:          LSR.B   #1,D4
00:00008E20 6100FE30        	   568:          BSR     FORMREGD
00:00008E24 60EE            	   569:          BRA.S   CS20           ; COMMON4
                            	   570: 
00:00008E26 1CFC0024        	   571: IMOVEP66:MOVE.B  #'$',(A6)+    ; FORMAT DISPLACEMENT
00:00008E2A 302C0002        	   572:          MOVE.W  2(A4),D0
00:00008E2E 6100FC70        	   573:          BSR     PNT4HX
                            	   574: 
00:00008E32 1CFC0028        	   575:          MOVE.B  #'(',(A6)+
                            	   576: 
00:00008E36 3814            	   577:          MOVE.W  (A4),D4
00:00008E38 6100FE08        	   578:          BSR     FORMREGA
00:00008E3C 1CFC0029        	   579:          MOVE.B  #')',(A6)+
00:00008E40 4E75            	   580:          RTS
                            	   581: 
                            	   582: SCOMMON:
00:00008E42 600004F2        	   583: 	bra COMMON         ; NOP RESET RTE RTR RTS TRAPV
                            	   584:         
                            	   585: 
00:00008E46 610000E4        	   586: ISCC:    BSR     ICCCC          ; GET REST OF OP-CODE
00:00008E4A 610001FE        	   587:          BSR     EEA            ; DATA ALTERABLE
00:00008E4E 60F2            	   588:          BRA.S   SCOMMON
                            	   589: 
                            	   590:          
                            	   591: 
                            	   592: IDBCC:   ;.align  2              ; DB--
00:00008E50 3814            	   593:          MOVE.W  (A4),D4
00:00008E52 6100FDFE        	   594:          BSR     FORMREGD
                            	   595: 
00:00008E56 1CC5            	   596:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
00:00008E58 1CFC0024        	   597:          MOVE.B  #'$',(A6)+    ; HEX FIELD TO FOLLOW
                            	   598: 
00:00008E5C 610000CE        	   599:          BSR     ICCCC
00:00008E60 602C            	   600:          BRA.S   ICC55
                            	   601: 
                            	   602: ;  BIT   5432109876543210
                            	   603: ;        0110............       FIXED
                            	   604: ;        ....CCCC........       CONDITION
                            	   605: ;        ........DDDDDDD0       DISPLACEMENT
                            	   606: ;        ...............1       ERROR (ODD BOUNDRY DISPLACEMENT)
                            	   607: ;
                            	   608:          
                            	   609: 
                            	   610: ICC:     ;.align  2              ; B--
00:00008E62 610000C8        	   611:          BSR     ICCCC
                            	   612: 
00:00008E66 1CFC0024        	   613: IBSR:    MOVE.B  #'$',(A6)+    ; BSR.S BRA
                            	   614: 
00:00008E6A 4A04            	   615:          TST.B   D4
00:00008E6C 6720            	   616:          BEQ.S   ICC55          ; 16 BIT DISPLACEMENT
                            	   617: 
00:00008E6E 1AFC002E        	   618:          MOVE.B  #'.',(A5)+
00:00008E72 1AFC0053        	   619:          MOVE.B  #'S',(A5)+
00:00008E76 4884            	   620:          EXT.W   D4            ; 8 BIT DISPLACEMENT
                            	   621: 
00:00008E78 48C4            	   622: ICC35:   EXT.L   D4            ; SIGN-EXTENDED DISPLACEMENT
00:00008E7A D8A9FFFC        	   623:          ADD.L   HISPC(A1),D4  ; + PROGRAM COUNTER
00:00008E7E 5484            	   624:          ADDQ.L  #2,D4         ; + TWO
00:00008E80 2004            	   625:          MOVE.L  D4,D0
                            	   626: 
00:00008E82 E284            	   627:          ASR.L   #1,D4
00:00008E84 650004D8        	   628:          BCS     FERROR         ; ODD BOUNDRY DISPLACEMENT
                            	   629: 
00:00008E88 6100FC1A        	   630:          BSR     PNT6HX
00:00008E8C 60B4            	   631:          BRA.S   SCOMMON
                            	   632: 
00:00008E8E 5483            	   633: ICC55:   ADDQ.L  #2,D3         ; SIZE
00:00008E90 382C0002        	   634:          MOVE.W  2(A4),D4
00:00008E94 1AFC002E        	   635:          MOVE.B  #'.',(A5)+
00:00008E98 1AFC004C        	   636:          MOVE.B  #'L',(A5)+    ; .L FOR 16 BIT DISPLACEMENT
00:00008E9C 60DA            	   637:          BRA.S   ICC35
                            	   638: 
                            	   639:          
                            	   640: ;                               ; BCHG  BCLR  BSET  BTST
                            	   641: ISETD:   ;.align  2              ; DYNAMIC BIT
00:00008E9E EF5C            	   642:          ROL.W   #7,D4
00:00008EA0 6100FDB0        	   643:          BSR     FORMREGD       ; DATA REGISTER
                            	   644: 
00:00008EA4 1CC5            	   645: ISETD12: MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   646: 
00:00008EA6 3814            	   647:          MOVE.W  (A4),D4
00:00008EA8 610001A0        	   648:          BSR     EEA            ; DATA ALTERABLE
00:00008EAC 6094            	   649: CS18:    BRA.S   SCOMMON
                            	   650: 
                            	   651:          ;.align   4
                            	   652: 
                            	   653: ;                            BCHG  BCLR  BSET  BTST
                            	   654: ;  1ST WORD     .... .... ..XX XXXX    EA   DATA ALTERABLE ONLY
                            	   655: ;  2ND WORD     0000 0000 000Y YYYY    BIT NUMBER
                            	   656: ;
                            	   657: ISETS:   ;.align  2              ; STATIC BIT
00:00008EAE 5483            	   658:          ADDQ.L  #2,D3         ; SIZE
00:00008EB0 1CFC0023        	   659:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	   660: 
00:00008EB4 7000            	   661:          CLR.L   D0
00:00008EB6 302C0002        	   662:          MOVE.W  2(A4),D0     ; GET BIT POSITION FROM 2ND WORD
00:00008EBA 2200            	   663:          MOVE.L  D0,D1
00:00008EBC EA89            	   664:          LSR.L   #5,D1
00:00008EBE 6600049E        	   665:          BNE     FERROR
00:00008EC2 6100FB78        	   666:          BSR     HEX2DEC        ; DECIMAL
                            	   667: 
00:00008EC6 60DC            	   668:          BRA.S   ISETD12
                            	   669: 
                            	   670: ;   BIT  5432109876543210
                            	   671: ;        ....XXX.........       IMMEDIATE COUNT/REGISTER
                            	   672: ;        .......0........       RIGHT SHIFT
                            	   673: ;        .......1........       LEFT SHIFT
                            	   674: ;        ........00......       BYTE
                            	   675: ;        ........01......       WORD
                            	   676: ;        ........10......       LONG
                            	   677: ;        ....0...11......       WORD (MEMORY)
                            	   678: ;        ....0...11AAAAAA       EFFECTIVE ADDRESS
                            	   679: ;        ..........0.....       SHIFT IMMEDIATE COUNT
                            	   680: ;        ..........1.....       SHIFT COUNT (MODULO 64) IN DATA REGISTER
                            	   681: ;
                            	   682:          ;.align   4
                            	   683: 
                            	   684: ISHIFT:  ;.align   2             ; AS-  LS-  RO-  ROX-
00:00008EC8 303C4C52        	   685:          MOVE.W  #$4c52,D0    ; "LR"
00:00008ECC 08040008        	   686:          BTST    #8,D4         ; DIRECTION BIT
00:00008ED0 6702            	   687:          BEQ.S   ISHIFT13       ; RIGHT
00:00008ED2 E048            	   688:          LSR.W   #8,D0         ; LEFT
00:00008ED4 1AC0            	   689: ISHIFT13:MOVE.B  D0,(A5)+     ; DIRECTION; "L" OR "R"
                            	   690: 
00:00008ED6 3014            	   691:          MOVE.W  (A4),D0
00:00008ED8 024000C0        	   692:          ANDI.W  #$00C0,D0
00:00008EDC 0C4000C0        	   693:          CMPI.W  #$00C0,D0
00:00008EE0 6730            	   694:          BEQ.S   ISHIFTM1       ; MEMORY SHIFT
                            	   695: 
00:00008EE2 610000DC        	   696:          BSR     FORMSIZE
                            	   697: 
00:00008EE6 EF5C            	   698:          ROL.W   #7,D4
00:00008EE8 0804000C        	   699:          BTST    #12,D4        ; I/R BIT
00:00008EEC 6616            	   700:          BNE.S   ISHIFT33       ; COUNT IN REGISTER
                            	   701: 
00:00008EEE 02040007        	   702:          ANDI.B  #$07,D4      ; IMMEDIATE COUNT
00:00008EF2 6604            	   703:          BNE.S   ISHIFT23
00:00008EF4 00040008        	   704:          ORI.B   #$08,D4      ; CHANGE ZERO TO EIGHT
00:00008EF8 00040030        	   705: ISHIFT23:ORI.B   #'0',D4
00:00008EFC 1CFC0023        	   706:          MOVE.B  #'#',(A6)+
00:00008F00 1CC4            	   707:          MOVE.B  D4,(A6)+
00:00008F02 6004            	   708:          BRA.S   ISHIFT44
                            	   709: 
00:00008F04 6100FD4C        	   710: ISHIFT33:BSR     FORMREGD
                            	   711: 
00:00008F08 1CC5            	   712: ISHIFT44:MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   713: 
00:00008F0A 3814            	   714:          MOVE.W  (A4),D4
00:00008F0C 6100FD44        	   715:          BSR     FORMREGD
00:00008F10 609A            	   716: CS17:    BRA.S   CS18           ; COMMON
                            	   717: 
00:00008F12 1AFC002E        	   718: ISHIFTM1:MOVE.B  #'.',(A5)+    ; PERIOD
00:00008F16 1AFC0057        	   719:          MOVE.B  #'W',(A5)+    ; .WORD
                            	   720: 
00:00008F1A 0804000B        	   721:          BTST    #11,D4
00:00008F1E 6600043E        	   722:          BNE     FERROR         ; BIT 11 MUST BE ZERO
                            	   723: 
00:00008F22 3E3C01FC        	   724:          MOVE.W  #$1FC,D7     ; MEMORY ALTERABLE ADDRESSING
00:00008F26 61000122        	   725:          BSR     EEA
00:00008F2A 60E4            	   726:          BRA.S   CS17           ; COMMON
                            	   727: 
00:00008F2C 700F            	   728: ICCCC:   MOVEQ   #$0F,D0      ; APPEND CONDITION CODE
00:00008F2E C014            	   729:          AND.B   (A4),D0      ; D0 = CCC
00:00008F30 E388            	   730:          LSL.L   #1,D0         ; D0 = CCC;2
                            	   731: 
00:00008F32 323B0010        	   732:          MOVE.W  BRTBL(PC,D0.W),D1 ; GET BRANCH MNEMONIC
00:00008F36 1AC1            	   733:          MOVE.B  D1,(A5)+     ; (REVERSED) FROM THE TABLE
00:00008F38 E049            	   734:          LSR.W   #8,D1         ; AND ADD THE NONBLANK PORTION
00:00008F3A 0C010020        	   735:          CMPI.B  #BLANK,D1     ; TO THE BUFFER.
00:00008F3E 6702            	   736:          BEQ.S   ICCCC9
00:00008F40 1AC1            	   737:          MOVE.B  D1,(A5)+
00:00008F42 4E75            	   738: ICCCC9:  RTS
                            	   739: 
00:00008F44 2054            	   740: BRTBL:   dc.b  " T"           ; "T " BRA ACCEPTED
00:00008F46 2046            	   741:          dc.b  " F"           ; "F "
00:00008F48 4948            	   742:          dc.b  "IH"           ; "HI"
00:00008F4A 534C            	   743:          dc.b  "SL"           ; "LS"
00:00008F4C 4343            	   744:          dc.b  "CC"           ; "CC"
00:00008F4E 5343            	   745:          dc.b  "SC"           ; "CS"
00:00008F50 454E            	   746:          dc.b  "EN"           ; "NE"
00:00008F52 5145            	   747:          dc.b  "QE"           ; "EQ"
00:00008F54 4356            	   748:          dc.b  "CV"           ; "VC"
00:00008F56 5356            	   749:          dc.b  "SV"           ; "VS"
00:00008F58 4C50            	   750:          dc.b  "LP"           ; "PL"
00:00008F5A 494D            	   751:          dc.b  "IM"           ; "MI"
00:00008F5C 4547            	   752:          dc.b  "EG"           ; "GE"
00:00008F5E 544C            	   753:          dc.b  "TL"           ; "LT"
00:00008F60 5447            	   754:          dc.b  "TG"           ; "GT"
00:00008F62 454C            	   755:          dc.b  "EL"           ; "LE"
                            	   756: 
                            	   757: ;   BIT  5432109876543210
                            	   758: ;        ....RRRMMM......    DESTINATION REGISTER MODE
                            	   759: ;        ..........MMMRRR    SOURCE MODE REGISTER
                            	   760: ;
                            	   761: ; IF BYTE SIZE; ADDRESS DIRECT NOT ALLOWED AS SOURCE
                            	   762: ;
                            	   763: 					even
                            	   764: IMOVEA1: ;.align  2
00:00008F64 3E3C0FFF        	   765:          MOVE.W  #$FFF,D7     ; ALL MODES
00:00008F68 610000E0        	   766:          BSR     EEA
                            	   767: 
00:00008F6C 1CC5            	   768:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   769: 
00:00008F6E 3814            	   770:          MOVE.W  (A4),D4      ; ....RRRMMM......
00:00008F70 E24C            	   771:          LSR.W   #1,D4         ; .....RRRMMM.....
00:00008F72 EA0C            	   772:          LSR.B   #5,D4         ; .....RRR.....MMM
00:00008F74 E05C            	   773:          ROR.W   #8,D4         ; .....MMM.....RRR
00:00008F76 EB0C            	   774:          LSL.B   #5,D4         ; .....MMMRRR.....
00:00008F78 EA4C            	   775:          LSR.W   #5,D4         ; ..........MMMRRR
                            	   776: 
                            	   777: ; IF .BYTE DESTINATION A@ NOT ALLOWED
00:00008F7A 3E3C01FF        	   778:          MOVE.W  #$1FF,D7     ; DATA ALTERABLE + A@
00:00008F7E 1014            	   779:          MOVE.B  (A4),D0
00:00008F80 0C000001        	   780:          CMPI.B  #$01,D0
00:00008F84 6604            	   781:          BNE.S   IMOVE19        ; NOT BYTE SIZE
                            	   782: 
00:00008F86 3E3C01FD        	   783:          MOVE.W  #$1FD,D7     ; DATA ALTERABLE
                            	   784: IMOVE19:
                            	   785: 
00:00008F8A 610000BE        	   786:          BSR     EEA
00:00008F8E 602C            	   787:          BRA.S   CS19           ; COMMON
                            	   788: 
                            	   789: ;  IF BYTE; ADDRESS REGISTER DIRECT NOT ALLOWED
                            	   790: IQUICKA: ;.align  2              ; ADDQ  SUBQ
00:00008F90 612E            	   791:          BSR.S   FORMSIZE
                            	   792: 
00:00008F92 1CFC0023        	   793:          MOVE.B  #'#',(A6)+
00:00008F96 EF5C            	   794:          ROL.W   #7,D4
00:00008F98 02040007        	   795:          ANDI.B  #7,D4
00:00008F9C 6604            	   796:          BNE.S   IQUICK21
00:00008F9E 00040008        	   797:          ORI.B   #8,D4         ; MAKE ZERO INTO EIGHT
00:00008FA2 00040030        	   798: IQUICK21:ORI.B   #'0',D4       ; MAKE ASCII
00:00008FA6 1CC4            	   799:          MOVE.B  D4,(A6)+
                            	   800: 
00:00008FA8 1CC5            	   801:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   802: 
00:00008FAA 3814            	   803:          MOVE.W  (A4),D4
                            	   804: 
00:00008FAC 3014            	   805:          MOVE.W  (A4),D0
00:00008FAE 024000C0        	   806:          ANDI.W  #$00C0,D0
00:00008FB2 6704            	   807:          BEQ.S   IQUICK31       ; DATA ALTERABLE
00:00008FB4 3E3C01FF        	   808:          MOVE.W  #$1FF,D7     ; ALTERABLE ADDRESSING
00:00008FB8 61000090        	   809: IQUICK31:BSR     EEA
00:00008FBC 60000378        	   810: CS19:    BRA     COMMON
                            	   811: 
                            	   812: ;  BIT   5432109876543210
                            	   813: ;        ........00......       BYTE
                            	   814: ;        ........01......       WORD
                            	   815: ;        ........10......       LONG
                            	   816: ;        ........11......       ERROR
                            	   817: ;
                            	   818: FORMSIZE: ;.align  2
00:00008FC0 3414            	   819:          MOVE.W  (A4),D2
00:00008FC2 1AFC002E        	   820:          MOVE.B  #'.',(A5)+    ; STORE PERIOD
00:00008FC6 EC4A            	   821:          LSR.W   #6,D2
00:00008FC8 02420003        	   822:          ANDI.W  #$03,D2
00:00008FCC 6606            	   823:          BNE.S   FORM91
00:00008FCE 1AFC0042        	   824:          MOVE.B  #'B',(A5)+    ; STORE "B"
00:00008FD2 6016            	   825:          BRA.S   FORM95
                            	   826: 
00:00008FD4 103C0057        	   827: FORM91:  MOVE.B  #'W',D0
00:00008FD8 0C020001        	   828:          CMPI.B  #1,D2
00:00008FDC 670A            	   829:          BEQ.S   FORM93
00:00008FDE 103C004C        	   830:          MOVE.B  #'L',D0
00:00008FE2 0C020002        	   831:          CMPI.B  #2,D2
00:00008FE6 665E            	   832:          BNE.S   FE10           ; FERROR
00:00008FE8 1AC0            	   833: FORM93:  MOVE.B  D0,(A5)+     ; STORE "W" OR "L"
00:00008FEA 4E75            	   834: FORM95:  RTS
                            	   835: 
00:00008FEC 6100FC64        	   836: EA000:   BSR     FORMREGD
00:00008FF0 08070000        	   837:          BTST    #0,D7
00:00008FF4 6750            	   838:          BEQ.S   FE10           ; FERROR
00:00008FF6 4E75            	   839:          RTS
                            	   840: 
00:00008FF8 6100FC48        	   841: EA001:   BSR     FORMREGA
00:00008FFC 08070001        	   842:          BTST    #1,D7
00:00009000 6744            	   843:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:00009002 4E75            	   844:          RTS
                            	   845: 
00:00009004 1CFC0028        	   846: EA010:   MOVE.B  #'(',(A6)+
00:00009008 6100FC38        	   847:          BSR     FORMREGA
00:0000900C 1CFC0029        	   848:          MOVE.B  #')',(A6)+
00:00009010 08070002        	   849:          BTST    #2,D7
00:00009014 6730            	   850:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:00009016 4E75            	   851:          RTS
                            	   852: 
00:00009018 1CFC0028        	   853: EA011:   MOVE.B  #'(',(A6)+
00:0000901C 6100FC24        	   854:          BSR     FORMREGA
00:00009020 1CFC0029        	   855:          MOVE.B  #')',(A6)+
00:00009024 1CFC002B        	   856:          MOVE.B  #'+',(A6)+
00:00009028 08070003        	   857:          BTST    #3,D7
00:0000902C 6718            	   858:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:0000902E 4E75            	   859: EA011RTS:RTS
                            	   860: 
00:00009030 1CFC002D        	   861: EA100:   MOVE.B  #'-',(A6)+
00:00009034 1CFC0028        	   862:          MOVE.B  #'(',(A6)+
00:00009038 6100FC08        	   863:          BSR     FORMREGA
00:0000903C 1CFC0029        	   864:          MOVE.B  #')',(A6)+
00:00009040 08070004        	   865:          BTST    #4,D7
00:00009044 66E8            	   866:          BNE.S   EA011RTS
00:00009046 60000316        	   867: FE10:    BRA     FERROR         ; THIS MODE NOT ALLOWED
                            	   868: 
                            	   869: ;  ENTER       A4 = POINTER TO FIRST WORD
                            	   870: ;              D3 = OFFSET TO EXTENSION
                            	   871: ;              D4 = VALUE TO PROCESS
                            	   872: ;              D7 = MODES ALLOWED MASK
                            	   873: ;
                            	   874: EEA:     ;.align  2
00:0000904A 2004            	   875: 	move.l D4,D0
00:0000904C E648            	   876: 	lsr.w #3,D0
00:0000904E 02400007        	   877: 	andi.w #$7,D0
00:00009052 6798            	   878: 	beq.s EA000
00:00009054 0C000001        	   879: 	cmpi.b #1,D0
00:00009058 679E            	   880: 	beq.s EA001
00:0000905A 0C000002        	   881: 	cmpi.b #2,D0
00:0000905E 67A4            	   882: 	beq.s EA010
00:00009060 0C000003        	   883: 	cmpi.b #3,D0
00:00009064 67B2            	   884: 	beq.s EA011
00:00009066 0C000004        	   885: 	cmpi.b #4,D0
00:0000906A 67C4            	   886: 	beq.s EA100
00:0000906C 0C000005        	   887: 	cmpi.b #5,D0
00:00009070 6760            	   888: 	beq.s EA101
00:00009072 0C000007        	   889: 	cmpi.b #7,D0
00:00009076 6770            	   890: 	beq.s EA111
                            	   891: 
                            	   892: ;    EXTENSION WORD
                            	   893: ;   BIT  5432109876543210
                            	   894: ;        0...............    DATA REGISTER
                            	   895: ;        1...............    ADDRESS REGISTER
                            	   896: ;        .RRR............    REGISTER
                            	   897: ;        ....0...........    SIGN EXTENDED, LOW ORDER INTEGER IN INDEX REG
                            	   898: ;        ....1...........    LONG VALUE IN INDEX REGISTER
                            	   899: ;        .....000........
                            	   900: ;        ........DDDDDDDD    DISPLACEMENT INTEGER
                            	   901: ;
                            	   902: ; EA110            ADDRESS REGISTER INDIRECT WITH INDEX
                            	   903: 
00:00009078 08070006        	   904:          BTST    #6,D7
00:0000907C 67C8            	   905:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
                            	   906: 
00:0000907E 32343000        	   907:          MOVE.W  (A4,D3.W),D1
00:00009082 02410700        	   908:          ANDI.W  #$0700,D1
00:00009086 66BE            	   909:          BNE.S   FE10           ; FERROR  BITS 10-8 MUST BE ZERO
                            	   910: 
00:00009088 30343000        	   911:          MOVE.W  (A4,D3.W),D0  ; D0 = DISPLACEMENT
00:0000908C 4880            	   912:          EXT.W   D0
00:0000908E 48C0            	   913:          EXT.L   D0
00:00009090 6100F9AA        	   914:          BSR     HEX2DEC        ; DECIMAL
00:00009094 1CFC0028        	   915:          MOVE.B  #'(',(A6)+    ; (
                            	   916: 
00:00009098 6100FBA8        	   917:          BSR     FORMREGA       ; XX(A@
                            	   918: 
00:0000909C 1CFC002C        	   919:          MOVE.B  #',',(A6)+    ; XX(A@,
                            	   920: 
00:000090A0 18343000        	   921:          MOVE.B  (A4,D3.W),D4
00:000090A4 E804            	   922:          ASR.B   #4,D4
00:000090A6 6A06            	   923:          BPL.S   EA1105
00:000090A8 6100FB98        	   924:          BSR     FORMREGA
00:000090AC 6004            	   925:          BRA.S   EA1107
                            	   926: 
00:000090AE 6100FBA2        	   927: EA1105:  BSR     FORMREGD
00:000090B2 1CFC002E        	   928: EA1107:  MOVE.B  #'.',(A6)+    ; XX(A@,X@.
                            	   929: 
00:000090B6 38343000        	   930:          MOVE.W  (A4,D3.W),D4 ; D4 = R@
00:000090BA 103C0057        	   931:          MOVE.B  #'W',D0       ; ..........W
00:000090BE 0804000B        	   932:          BTST    #11,D4
00:000090C2 6704            	   933:          BEQ.S   EA1109
00:000090C4 103C004C        	   934:          MOVE.B  #'L',D0       ; ..........L
00:000090C8 1CC0            	   935: EA1109:  MOVE.B  D0,(A6)+
00:000090CA 1CFC0029        	   936:          MOVE.B  #')',(A6)+    ; ...........)
00:000090CE 5483            	   937:          ADDQ.L  #2,D3
00:000090D0 4E75            	   938:          RTS
                            	   939: 
                            	   940: ; ADDRESS REGISTER INDIRECT WITH DISPLACEMENT
                            	   941: ;
                            	   942: EA101:
00:000090D2 08070005        	   943: 	btst #5,D7         	; 101000;   DIS(A@)
00:000090D6 6756            	   944: 	beq.s FE11          ; FERROR;  THIS MODE NOT ALLOWED
00:000090D8 30343000        	   945: 	move.w (A4,D3.W),D0
00:000090DC 48C0            	   946: 	ext.l D0
00:000090DE 6100F95C        	   947: 	bsr HEX2DEC        	; DECIMAL
00:000090E2 5483            	   948: 	addq.l #2,D3        ; SIZE
00:000090E4 6000FF1E        	   949: 	bra EA010
                            	   950: 
                            	   951: ;  111000        ABSOLUTE SHORT
                            	   952: ;  111001        ABSOLUTE LONG
                            	   953: ;  111010        PROGRAM COUNTER WITH DISPLACEMENT
                            	   954: ;  111011        PROGRAM COUNTER WITH INDEX
                            	   955: ;  111100        IMMEDIATE OR STATUS REG
                            	   956: ;
                            	   957: EA111:
00:000090E8 02440007        	   958: 	andi.w #7,D4
00:000090EC 6618            	   959: 	bne.s EA1112
00:000090EE 08070007        	   960: 	btst #7,D7
00:000090F2 673A            	   961: 	beq.s FE11           	; FERROR;  THIS MODE NOT ALLOWED
00:000090F4 30343000        	   962: 	move.w (A4,D3.W),D0 	; 111000;   ABSOLUTE SHORT
00:000090F8 48C0            	   963: 	ext.l D0
00:000090FA 1CFC0024        	   964: 	move.b #'$',(A6)+
00:000090FE 6100F9B0        	   965: 	bsr PNT8HX         		; SIGN EXTENDED VALUE
00:00009102 5483            	   966: 	addq.l #2,D3         	; SIZE + 2
00:00009104 4E75            	   967: 	rts
                            	   968: 
                            	   969: EA1112:
00:00009106 0C040001        	   970: 	cmpi.b #1,D4
00:0000910A 6616            	   971: 	bne.s EA1113
00:0000910C 08070008        	   972: 	btst #8,D7
00:00009110 671C            	   973: 	beq.s FE11          	; FERROR;  THIS MODE NOT ALLOWED
00:00009112 1CFC0024        	   974: 	move.b #'$',(A6)+    	; HEX
00:00009116 20343000        	   975: 	move.l (A4,D3.W),D0  	; 111001;     ABSOLUTE LONG
00:0000911A 6100F994        	   976: 	bsr PNT8HX
                            	   977: 	;-       MOVE.B  #'.',(A6)+    ; FORCE LONG FORMAT
                            	   978: 	;-       MOVE.B  #'L',(A6)+    ; IE   .L
00:0000911E 5883            	   979: 	addq.l #4,D3
00:00009120 4E75            	   980: 	rts
                            	   981: 
                            	   982: EA1113:
00:00009122 0C040002        	   983: 	cmpi.b #2,D4
00:00009126 662C            	   984: 	bne.s EA1114
00:00009128 08070009        	   985: 	btst #9,D7
00:0000912C 6604            	   986: 	bne.s EA1113A
                            	   987: FE11:
00:0000912E 6000022E        	   988: 	bra FERROR         	; THIS MODE NOT ALLOWED
                            	   989: 
                            	   990: EA1113A:
00:00009132 30343000        	   991: 	move.w (A4,D3.W),D0  ; 111010;  PC + DISPLACEMENT  DESTINATION(PC)
00:00009136 48C0            	   992: 	ext.l D0
00:00009138 D0A9FFFC        	   993: 	add.l HISPC(A1),D0
00:0000913C 5480            	   994: 	addq.l #2,D0
00:0000913E 1CFC0024        	   995: 	move.b #'$',(A6)+    ; HEX "$"
00:00009142 6100F96C        	   996: 	bsr PNT8HX         ; DESTINATION
00:00009146 203C29435028    	   997: 	move.l #$29435028,D0  ; (PC)
00:0000914C 6100FC4C        	   998: 	bsr SCHR           ; STORE WORD
00:00009150 5483            	   999: 	addq.l #2,D3         ; SIZE
00:00009152 4E75            	  1000: 	rts
                            	  1001: 
                            	  1002: EA1114:
00:00009154 0C040003        	  1003: 	cmpi.b #3,D4
00:00009158 6664            	  1004: 	bne.s EA1115
                            	  1005: 
                            	  1006: ; PROGRAM COUNTER WITH INDEX    DESTINATION(PC,R@.X)
                            	  1007: ;
                            	  1008: ;        5432109876543210       SECOND WORD
                            	  1009: ;        0...............       DATA REGISTER
                            	  1010: ;        1...............       ADDRESS REGISTER
                            	  1011: ;        .XXX............       REGISTER
                            	  1012: ;        ....0...........       SIGN-EXTENDED, LOW ORDER WORD INTEGER
                            	  1013: ;                               ..IN INDEX REGISTER
                            	  1014: ;        ....1...........       LONG VALUE IN INDEX REGISTER
                            	  1015: ;        .....000........
                            	  1016: ;        ........XXXXXXXX       DISPLACEMENT INTEGER
                            	  1017: ;
00:0000915A 0807000A        	  1018:          BTST    #10,D7
00:0000915E 67CE            	  1019:          BEQ.S   FE11           ; FERROR  THIS MODE NOT ASLLOWED
                            	  1020: 
00:00009160 32343000        	  1021:          MOVE.W  (A4,D3.W),D1
00:00009164 02410700        	  1022:          ANDI.W  #$0700,D1
00:00009168 66C4            	  1023:          BNE.S   FE11           ; FERROR;  BITS 10-8 MUST BE ZERO
                            	  1024: 
00:0000916A 10343001        	  1025:          MOVE.B  1(A4,D3.W),D0 ; 111100;   DESTINATION(PC,R@.X)
00:0000916E 4880            	  1026:          EXT.W   D0
00:00009170 48C0            	  1027:          EXT.L   D0
00:00009172 D0A9FFFC        	  1028:          ADD.L   HISPC(A1),D0
00:00009176 5480            	  1029:          ADDQ.L  #2,D0
00:00009178 1CFC0024        	  1030:          MOVE.B  #'$',(A6)+    ; HEX "$"
00:0000917C 6100F932        	  1031:          BSR     PNT8HX         ; DESTINATION
                            	  1032: 
00:00009180 203C2C435028    	  1033:          MOVE.L  #$2c435028,D0
00:00009186 6100FC12        	  1034:          BSR     SCHR           ; DES(PC,
                            	  1035: 
00:0000918A 38343000        	  1036:          MOVE.W  (A4,D3.W),D4
00:0000918E E95C            	  1037:          ROL.W   #4,D4
00:00009190 08040003        	  1038:          BTST    #3,D4
00:00009194 6706            	  1039:          BEQ.S   EAF25
00:00009196 6100FAAA        	  1040:          BSR     FORMREGA
00:0000919A 6004            	  1041:          BRA.S   EAF27
00:0000919C 6100FAB4        	  1042: EAF25:   BSR     FORMREGD       ; DES(PC,R@
                            	  1043: EAF27:
                            	  1044: 
00:000091A0 1CFC002E        	  1045:          MOVE.B  #'.',(A6)+    ; DES(PC,R@.
                            	  1046: 
00:000091A4 38343000        	  1047:          MOVE.W  (A4,D3.W),D4
00:000091A8 303C4C57        	  1048:          MOVE.W  #$4c57,D0    ; "LW"
00:000091AC 0804000B        	  1049:          BTST    #11,D4
00:000091B0 6702            	  1050:          BEQ.S   EAF35
00:000091B2 E048            	  1051:          LSR.W   #8,D0
00:000091B4 1CC0            	  1052: EAF35:   MOVE.B  D0,(A6)+     ; DES(PC,R@.X
                            	  1053: 
00:000091B6 1CFC0029        	  1054:          MOVE.B  #')',(A6)+    ; DES(PC,R@.X)
00:000091BA 5483            	  1055:          ADDQ.L  #2,D3
00:000091BC 4E75            	  1056:          RTS
                            	  1057: 
                            	  1058: ;   BIT  5432109876543210
                            	  1059: ;        ..........111100       ; FIRST WORD;  #<IMMEDIATE>
                            	  1060: ;
00:000091BE 0C040004        	  1061: EA1115:  CMPI.B  #4,D4
00:000091C2 6600FF6A        	  1062:          BNE     FE11           ; FERROR
                            	  1063: 
00:000091C6 0807000B        	  1064:          BTST    #11,D7
00:000091CA 6700FF62        	  1065:          BEQ     FE11           ; FERROR;  THIS MODE NOT ALLOWED
                            	  1066: 
00:000091CE 1CFC0023        	  1067:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	  1068: 
00:000091D2 122DFFFF        	  1069:          MOVE.B  -1(A5),D1
00:000091D6 0C01004C        	  1070:          CMPI.B  #'L',D1
00:000091DA 6724            	  1071:          BEQ.S   EA11155        ; LONG
                            	  1072: 
00:000091DC 30343000        	  1073:          MOVE.W  (A4,D3.W),D0
                            	  1074: 
00:000091E0 0C010042        	  1075:          CMPI.B  #'B',D1
00:000091E4 6610            	  1076:          BNE.S   EA11153        ; .WORD
                            	  1077: 
                            	  1078: ; BYTE SIZE; DATA ALLOWED
                            	  1079: ;  0000 0000 XXXX XXXX
                            	  1080: ;  1111 1111 1XXX XXXX
00:000091E6 2200            	  1081:          MOVE.L  D0,D1
00:000091E8 E049            	  1082:          LSR.W   #8,D1
00:000091EA 670A            	  1083:          BEQ.S   EA11153
00:000091EC 2200            	  1084:          MOVE.L  D0,D1
00:000091EE EE41            	  1085:          ASR.W   #7,D1
00:000091F0 5241            	  1086:          ADDQ.W  #1,D1
00:000091F2 6600FF3A        	  1087:          BNE     FE11           ; FERROR
                            	  1088: 
00:000091F6 48C0            	  1089: EA11153: EXT.L   D0
00:000091F8 6100F842        	  1090:          BSR     HEX2DEC
00:000091FC 5483            	  1091:          ADDQ.L  #2,D3
00:000091FE 4E75            	  1092:          RTS
                            	  1093: 
00:00009200 20343000        	  1094: EA11155: MOVE.L  (A4,D3.W),D0
00:00009204 6100F836        	  1095:          BSR     HEX2DEC
00:00009208 5883            	  1096:          ADDQ.L  #4,D3         ; SIZE
00:0000920A 4E75            	  1097:          RTS
                            	  1098: 
00:0000920C 1AFC002E        	  1099: MOVEMS:  MOVE.B  #'.',(A5)+    ; PERIOD
00:00009210 303C4C57        	  1100:          MOVE.W  #$4c57,D0    ; "LW"
00:00009214 08040006        	  1101:          BTST    #6,D4
00:00009218 6702            	  1102:          BEQ.S   MOVEMS2
00:0000921A E048            	  1103:          LSR.W   #8,D0
00:0000921C 1AC0            	  1104: MOVEMS2: MOVE.B  D0,(A5)+     ; SIZE
00:0000921E 4E75            	  1105:          RTS
                            	  1106: 
                            	  1107: ; MOVEM - REGISTER EXPANSION
                            	  1108: ;
                            	  1109: MOVEMR:  ;.align  2
00:00009220 342C0002        	  1110:          MOVE.W  2(A4),D2     ; D2 = SECOND WORD
00:00009224 7020            	  1111:          MOVEQ   #$20,D0      ; D0 = SPACE
00:00009226 7E2F            	  1112:          MOVEQ   #$2F,D7      ; D7 = /
00:00009228 538E            	  1113:          SUBQ.L  #1,A6         ; ADJUST STORE POINTER
00:0000922A 7A30            	  1114:          MOVEQ   #$30,D5      ; D5 = REGISTER #
00:0000922C 383C4144        	  1115:          MOVE.W  #$4144,D4    ; "AD" D4 = REG CLASS
                            	  1116: 
00:00009230 0302            	  1117: MOVEMR11:BTST    D1,D2
00:00009232 6730            	  1118:          BEQ.S   MOVEMR77       ; BIT RESET
                            	  1119: 
00:00009234 B016            	  1120:          CMP.B   (A6),D0      ; BIT SET
00:00009236 6612            	  1121:          BNE.S   MOVEMR44       ; NOT SPACE
                            	  1122: 
00:00009238 1D440001        	  1123: MOVEMR33:MOVE.B  D4,1(A6)     ; REG TYPE
00:0000923C 1D450002        	  1124:          MOVE.B  D5,2(A6)     ; REG #
00:00009240 1D7C002D0003    	  1125:          MOVE.B  #'-',3(A6)    ; -
00:00009246 568E            	  1126:          ADDQ.L  #3,A6
00:00009248 602E            	  1127:          BRA.S   MOVEMR88
                            	  1128: 
                            	  1129: MOVEMR44:
00:0000924A 0C16002C        	  1130: 	cmpi.b #',',(A6)
00:0000924E 67E8            	  1131: 	beq.s MOVEMR33      ; COMMA SEPARATOR
00:00009250 BE16            	  1132: 	cmp.b (A6),D7      	; / SEPARATOR
00:00009252 67E4            	  1133: 	beq.s MOVEMR33
00:00009254 1D440001        	  1134: 	move.b D4,1(A6)     ; REG TYPE
00:00009258 1D450002        	  1135: 	move.b D5,2(A6)     ; REG #
00:0000925C 1D7C002D0003    	  1136: 	move.b #'-',3(A6)   ; - SEPARATOR
00:00009262 6014            	  1137: 	bra.s MOVEMR88
                            	  1138: 
                            	  1139: MOVEMR77:
00:00009264 0C16002C        	  1140: 	cmpi.b #',',(A6)
00:00009268 670E            	  1141: 	beq.s MOVEMR88       ; COMMA
00:0000926A B016            	  1142: 	cmp.b (A6),D0
00:0000926C 670A            	  1143: 	beq.s MOVEMR88       ; SPACE
00:0000926E B02E0001        	  1144: 	cmp.b 1(A6),D0
00:00009272 6702            	  1145: 	beq.s MOVEMR79       ; SPACE
00:00009274 568E            	  1146: 	addq.l #3,A6
                            	  1147: MOVEMR79:
00:00009276 1C87            	  1148: 	move.b D7,(A6)      ; / SEPARATOR
                            	  1149: 
                            	  1150: MOVEMR88:
00:00009278 5285            	  1151: 	addq.l #1,D5
00:0000927A D286            	  1152: 	add.l D6,D1        ; D1 = BIT POSITION
00:0000927C 0C050038        	  1153: 	cmpi.b #'8',D5
00:00009280 66AE            	  1154: 	bne.s MOVEMR11
00:00009282 B016            	  1155: 	cmp.b (A6),D0      ; SPACE
00:00009284 670A            	  1156: 	beq.s MOVEMR94
00:00009286 B02E0001        	  1157: 	cmp.b 1(A6),D0     ; SPACE
00:0000928A 6704            	  1158: 	beq.s MOVEMR94
00:0000928C 568E            	  1159: 	addq.l #3,A6
00:0000928E 1C87            	  1160: 	move.b D7,(A6)      ; /   SEPARATOR
                            	  1161: 
                            	  1162: MOVEMR94:
00:00009290 1A3C0030        	  1163: 	move.b #'0',D5       	; RESET REG TO ZERO
00:00009294 E04C            	  1164: 	lsr.w #8,D4         	; CHANGE REG TYPE
00:00009296 6698            	  1165: 	bne.s MOVEMR11       	; MORE
00:00009298 1C80            	  1166: 	move.b D0,(A6)      	; SPACE
00:0000929A 4E75            	  1167: 	rts
                            	  1168: 
                            	  1169: DCODE68K:
00:0000929C 4E51FFF0        	  1170: 	link A1,#-LOCVARSZ 	; CREATE A FRAME FOR THE
00:000092A0 48E91007FFF0    	  1171: 	movem.l D0-D2/A4,DDATA(A1)  ; CODE AND ITS PC.  A4
00:000092A6 49E9FFF0        	  1172: 	lea DDATA(A1),A4 		; POINTS TO THE CODE.
00:000092AA 264D            	  1173: 	move.l A5,A3        ; A3 = START OF OUTPUT BUFFER
00:000092AC 2C4D            	  1174: 	move.l A5,A6
00:000092AE 703F            	  1175: 	moveq #BUFSIZE,D0
                            	  1176: DEC311:
00:000092B0 1CFC0020        	  1177:   move.b #BLANK,(a6)+  ; SPACE FILL BUFFER
00:000092B4 5380            	  1178: 	subq.l #1,D0
00:000092B6 66F8            	  1179: 	bne.s DEC311
00:000092B8 421E            	  1180: 	clr.b (a6)+					; NULL temrinate
00:000092BA 2C4B            	  1181: 	move.l A3,A6        ; FORMAT ADDRESS
00:000092BC 2029FFFC        	  1182: 	move.l HISPC(A1),D0
00:000092C0 6100F7F2        	  1183: 	bsr FRELADDR
                            	  1184: 
                            	  1185: ; CHECK FOR KNOWN ILLEGAL CODES
00:000092C4 3014            	  1186: 	move.w (a4),d0
00:000092C6 4BFA00C0        	  1187: 	lea KI(PC),a5
00:000092CA 2C4D            	  1188: 	move.l a5,a6
00:000092CC 548E            	  1189: 	add.l #KIEND-KI,a6
                            	  1190: DEC404:
00:000092CE B05D            	  1191:   cmp.w (a5)+,d0
00:000092D0 671A            	  1192: 	beq.s FE12           ; FERROR;  ILLEGAL CODE
00:000092D2 BBCE            	  1193: 	cmp.l a6,a5
00:000092D4 66F8            	  1194: 	bne.s DEC404
                            	  1195: 
                            	  1196: ; LOOK FOR MATCH OF OP-CODE
                            	  1197: ;
00:000092D6 4BFA00B2        	  1198: 	lea TBL(PC),A5   		; A5 = POINTER TO DECODE TABLE
00:000092DA 4DFA0366        	  1199: 	lea TBLE(PC),A6  		; A6 = POINTER TO END OF TABLE
                            	  1200: DEC411:
00:000092DE 3014            	  1201: 	move.w (A4),D0      ;  FIRST WORD
00:000092E0 C05D            	  1202: 	and.w (A5)+,D0     	;  MASK
00:000092E2 B05D            	  1203: 	cmp.w (A5)+,D0
00:000092E4 6708            	  1204: 	beq.s DEC425        ; FOUND MATCH
00:000092E6 588D            	  1205: 	addq.l #4,A5        ; UPDATE POINTER
00:000092E8 BBCE            	  1206: 	cmp.l A6,A5
00:000092EA 65F2            	  1207: 	blo.s DEC411        ; MORE TABLE
                            	  1208: FE12:
00:000092EC 6070            	  1209: 	bra.s FERROR        ; ILLEGAL INSTRUCTION
                            	  1210: DEC425:
00:000092EE 7C00            	  1211:   clr.l D6
00:000092F0 3C1D            	  1212: 	move.w (A5)+,D6     ; D6 = (GOTO OFFSET)/4
                            	  1213: ;         LSL.L   #2,D6
00:000092F2 7E00            	  1214: 	clr.l D7
00:000092F4 3E1D            	  1215: 	move.w (A5)+,D7     ; D7 = INDEX TO OP-CODE
                            	  1216: 
                            	  1217: ; MOVE OP-CODE TO BUFFER
                            	  1218: ;
00:000092F6 41FA034A        	  1219: 	lea OPCTBL(PC),A0
                            	  1220: DEC510:
00:000092FA 4A47            	  1221:   tst D7
00:000092FC 6708            	  1222: 	beq.s DEC530         	; AT INDEX
                            	  1223: DEC515:
00:000092FE 4A18            	  1224:   tst.b (A0)+
00:00009300 6AFC            	  1225: 	bpl.s DEC515         	; MOVE THROUGH FIELD
00:00009302 5387            	  1226: 	subq.l #1,D7
00:00009304 60F4            	  1227: 	bra.s DEC510
                            	  1228: DEC530:
00:00009306 701F            	  1229: 	moveq #FOC,D0
00:00009308 4BF30000        	  1230: 	lea.l (A3,D0.W),A5 		; A5 = STORE POINTER  OP-CODE
                            	  1231: DEC535:
00:0000930C 1018            	  1232:   move.b (A0)+,D0
00:0000930E 08800007        	  1233: 	bclr #7,D0
00:00009312 6604            	  1234: 	bne.s DEC537         	; END OF MOVE
00:00009314 1AC0            	  1235: 	move.b D0,(A5)+
00:00009316 60F4            	  1236: 	bra.s DEC535
                            	  1237: DEC537:
00:00009318 1AC0            	  1238:   move.b D0,(A5)+
                            	  1239: 
                            	  1240: ; CALCULATE GOTO AND GO
                            	  1241: ;
00:0000931A 7602            	  1242: 	moveq #2,D3         ; D3= SIZE
00:0000931C 41FAF7F4        	  1243: 	lea X(PC),A0
00:00009320 D1C6            	  1244: 	add.l D6,A0
00:00009322 7027            	  1245: 	moveq #FOP,D0
00:00009324 4DF30000        	  1246: 	lea.l (A3,D0.W),A6 	; A6 = POINTER FOR OPERAND
00:00009328 3814            	  1247: 	move.w (A4),D4      ; D4 = FIRST WORD
00:0000932A 1A3C002C        	  1248: 	move.b #',',D5      ; D5 = CONTAINS ASCII COMMA
00:0000932E 3E3C01FD        	  1249: 	move.w #$1FD,D7     ; D7 = DATA ALTERABLE MODES ALLOWED
00:00009332 4ED0            	  1250: 	jmp (A0)
                            	  1251: 
                            	  1252: ;	 A3 = pointer to beginning of buffer
                            	  1253: ;  A4 = POINTER TO DATA IN FRAME CREATED BY "LINK A1,..."
                            	  1254: ;  A5 = POINTER STORE OP-CODE
                            	  1255: ;  A6 = POINTER STORE OPERAND
                            	  1256: ;  D3 = SIZE = 2 BYTES
                            	  1257: ;  D4 = FIRST WORD
                            	  1258: ;  D7 = ADDRESS MODES ALLOWED ($1FD) DATA ALTERABLE
                            	  1259: 
                            	  1260: COMMON4:
00:00009334 5483            	  1261: 	addq.l #2,D3         	; SIZE = 4
                            	  1262: COMMON:
00:00009336 2C03            	  1263: 	move.l D3,D6        	; D6 = SIZE
00:00009338 1CFC0020        	  1264: 	move.b #BLANK,(A6)+ 	; SPACE AS LAST CHAR
00:0000933C 2A4E            	  1265: 	move.l A6,A5        	; SAVE END OF BUFFER POINTER
00:0000933E 700A            	  1266: 	moveq #FDATA,D0
00:00009340 4DF30000        	  1267: 	lea.l (A3,D0.W),A6
                            	  1268: COMMON35:
00:00009344 301C            	  1269: 	move.w (A4)+,D0     	; GET NEXT WORD OF DATA.
00:00009346 54A9FFFC        	  1270: 	addq.l #2,HISPC(A1)  	; ADJUST PROG COUNTER.
00:0000934A 6100F754        	  1271: 	bsr PNT4HX         		; FORMAT DATA. (A6)+
00:0000934E 5503            	  1272: 	subq.b #2,D3
00:00009350 66F2            	  1273: 	bne.s COMMON35
00:00009352 2C4D            	  1274: 	move.l A5,A6        	; A6 = RESTORE END POINTER
00:00009354 2A4B            	  1275: 	move.l A3,A5        	; A5 =  BEGINNING OF BUFFER
00:00009356 2869FFFC        	  1276: 	move.l HISPC(A1),A4 	; MOVE THE UPDATED PC
00:0000935A 4E59            	  1277: 	unlk A1            		; TO A4 AND UNDO FRAME.
00:0000935C 4E75            	  1278: 	rts
                            	  1279: 
                            	  1280: FERROR:  ;.align  2
                            	  1281: ; ILLEGAL INSTRUCTION
                            	  1282: ;
00:0000935E 701F            	  1283: 	moveq #FOC,D0
00:00009360 4DF30000        	  1284: 	lea.l (A3,D0.W),A6
00:00009364 4BFA0018        	  1285: 	lea MSG111(PC),A5
                            	  1286: FERROR35:
00:00009368 101D            	  1287: 	move.b (A5)+,D0
00:0000936A 0C000004        	  1288: 	cmpi.b #EOT,D0
00:0000936E 6704            	  1289: 	beq.s FERROR39
00:00009370 1CC0            	  1290: 	move.b D0,(A6)+
00:00009372 60F4            	  1291: 	bra.s FERROR35
                            	  1292: FERROR39:
00:00009374 3014            	  1293: 	move.w (A4),D0
00:00009376 6100F728        	  1294: 	bsr PNT4HX
00:0000937A 7602            	  1295: 	moveq #2,D3         ; SIZE
00:0000937C 60B8            	  1296: 	bra.s COMMON
                            	  1297: MSG111:  
00:0000937E 44432E5720202020	  1298: 	dc.b "DC.W    $"
00:00009386 24
00:00009387 04              	  1299: 	dc.b EOT
                            	  1300: 
                            	  1301: KI:
00:00009388 4AFB            	  1302: 	dc.w $4AFB         ; KNOWN ILLEGAL CODES
                            	  1303: KIEND:   
                            	  1304: 	even
                            	  1305: 
                            	  1306: ;  \1   MASK
                            	  1307: ;  \2   OP-CODE PATTERN
                            	  1308: ;  \3   GOTO OFFSET
                            	  1309: ;  \4   INDEX TO OP-CODE
                            	  1310: C68:     macro arg1,arg2,arg3,arg4
                            	  1311:          DC.W    $\1
                            	  1312:          DC.W    $\2
                            	  1313:          DC.W    (\3-X)
                            	  1314:          DC.w    \4
                            	  1315:          endm
                            	  1316: 
                            	  1317: 				 even
                            	  1318: TBL:     ;.align  2
                            	  1319:          C68     FEC0,E6C0,ISHIFT,56           ; RO
00:0000938A FEC0            	     1M          DC.W    $FEC0
00:0000938C E6C0            	     2M          DC.W    $E6C0
00:0000938E 03B6            	     3M          DC.W    (ISHIFT-X)
00:00009390 0038            	     4M          DC.w    56
                            	  1320:          C68     FEC0,E4C0,ISHIFT,57           ; ROX
00:00009392 FEC0            	     1M          DC.W    $FEC0
00:00009394 E4C0            	     2M          DC.W    $E4C0
00:00009396 03B6            	     3M          DC.W    (ISHIFT-X)
00:00009398 0039            	     4M          DC.w    57
                            	  1321:          C68     FEC0,E2C0,ISHIFT,55           ; LS
00:0000939A FEC0            	     1M          DC.W    $FEC0
00:0000939C E2C0            	     2M          DC.W    $E2C0
00:0000939E 03B6            	     3M          DC.W    (ISHIFT-X)
00:000093A0 0037            	     4M          DC.w    55
                            	  1322:          C68     FEC0,E0C0,ISHIFT,54           ; AS
00:000093A2 FEC0            	     1M          DC.W    $FEC0
00:000093A4 E0C0            	     2M          DC.W    $E0C0
00:000093A6 03B6            	     3M          DC.W    (ISHIFT-X)
00:000093A8 0036            	     4M          DC.w    54
                            	  1323:          C68     F018,E018,ISHIFT,56           ; RO
00:000093AA F018            	     1M          DC.W    $F018
00:000093AC E018            	     2M          DC.W    $E018
00:000093AE 03B6            	     3M          DC.W    (ISHIFT-X)
00:000093B0 0038            	     4M          DC.w    56
                            	  1324:          C68     F018,E010,ISHIFT,57           ; ROX
00:000093B2 F018            	     1M          DC.W    $F018
00:000093B4 E010            	     2M          DC.W    $E010
00:000093B6 03B6            	     3M          DC.W    (ISHIFT-X)
00:000093B8 0039            	     4M          DC.w    57
                            	  1325:          C68     F018,E008,ISHIFT,55           ; LS
00:000093BA F018            	     1M          DC.W    $F018
00:000093BC E008            	     2M          DC.W    $E008
00:000093BE 03B6            	     3M          DC.W    (ISHIFT-X)
00:000093C0 0037            	     4M          DC.w    55
                            	  1326:          C68     F018,E000,ISHIFT,54           ; AS
00:000093C2 F018            	     1M          DC.W    $F018
00:000093C4 E000            	     2M          DC.W    $E000
00:000093C6 03B6            	     3M          DC.W    (ISHIFT-X)
00:000093C8 0036            	     4M          DC.w    54
                            	  1327:          C68     F0C0,D0C0,FORM10EX,4          ; ADD       <EA>,A@
00:000093CA F0C0            	     1M          DC.W    $F0C0
00:000093CC D0C0            	     2M          DC.W    $D0C0
00:000093CE 016A            	     3M          DC.W    (FORM10EX-X)
00:000093D0 0004            	     4M          DC.w    4
                            	  1328:          C68     F130,D100,FORM12,53           ; ADDX
00:000093D2 F130            	     1M          DC.W    $F130
00:000093D4 D100            	     2M          DC.W    $D100
00:000093D6 0208            	     3M          DC.W    (FORM12-X)
00:000093D8 0035            	     4M          DC.w    53
                            	  1329:          C68     F000,D000,FORM10EX,4          ; ADD
00:000093DA F000            	     1M          DC.W    $F000
00:000093DC D000            	     2M          DC.W    $D000
00:000093DE 016A            	     3M          DC.W    (FORM10EX-X)
00:000093E0 0004            	     4M          DC.w    4
                            	  1330:          C68     F1F8,C188,FORM9,50            ; EXG
00:000093E2 F1F8            	     1M          DC.W    $F1F8
00:000093E4 C188            	     2M          DC.W    $C188
00:000093E6 0160            	     3M          DC.W    (FORM9-X)
00:000093E8 0032            	     4M          DC.w    50
                            	  1331:          C68     F1F8,C148,FORM8,50            ; EXG
00:000093EA F1F8            	     1M          DC.W    $F1F8
00:000093EC C148            	     2M          DC.W    $C148
00:000093EE 0152            	     3M          DC.W    (FORM8-X)
00:000093F0 0032            	     4M          DC.w    50
                            	  1332:          C68     F1F8,C140,FORM7,50            ; EXG
00:000093F2 F1F8            	     1M          DC.W    $F1F8
00:000093F4 C140            	     2M          DC.W    $C140
00:000093F6 0146            	     3M          DC.W    (FORM7-X)
00:000093F8 0032            	     4M          DC.w    50
                            	  1333:          C68     F1F0,C100,FORM12,49           ; ABCD
00:000093FA F1F0            	     1M          DC.W    $F1F0
00:000093FC C100            	     2M          DC.W    $C100
00:000093FE 0208            	     3M          DC.W    (FORM12-X)
00:00009400 0031            	     4M          DC.w    49
                            	  1334:          C68     F1C0,C1C0,FORM6D,48           ; MULS
00:00009402 F1C0            	     1M          DC.W    $F1C0
00:00009404 C1C0            	     2M          DC.W    $C1C0
00:00009406 0120            	     3M          DC.W    (FORM6D-X)
00:00009408 0030            	     4M          DC.w    48
                            	  1335:          C68     F1C0,C0C0,FORM6D,47           ; MULU
00:0000940A F1C0            	     1M          DC.W    $F1C0
00:0000940C C0C0            	     2M          DC.W    $C0C0
00:0000940E 0120            	     3M          DC.W    (FORM6D-X)
00:00009410 002F            	     4M          DC.w    47
                            	  1336:          C68     F000,C000,FORM10,2            ; AND
00:00009412 F000            	     1M          DC.W    $F000
00:00009414 C000            	     2M          DC.W    $C000
00:00009416 01A8            	     3M          DC.W    (FORM10-X)
00:00009418 0002            	     4M          DC.w    2
                            	  1337:          C68     F0C0,B0C0,FORM10EX,6          ; CMP     <EA>,A@
00:0000941A F0C0            	     1M          DC.W    $F0C0
00:0000941C B0C0            	     2M          DC.W    $B0C0
00:0000941E 016A            	     3M          DC.W    (FORM10EX-X)
00:00009420 0006            	     4M          DC.w    6
                            	  1338:          C68     F138,B108,FORM12A,46          ; CMPM
00:00009422 F138            	     1M          DC.W    $F138
00:00009424 B108            	     2M          DC.W    $B108
00:00009426 0244            	     3M          DC.W    (FORM12A-X)
00:00009428 002E            	     4M          DC.w    46
                            	  1339:          C68     F100,B100,FORM10,5            ; EOR
00:0000942A F100            	     1M          DC.W    $F100
00:0000942C B100            	     2M          DC.W    $B100
00:0000942E 01A8            	     3M          DC.W    (FORM10-X)
00:00009430 0005            	     4M          DC.w    5
                            	  1340:          C68     F000,B000,FORM10EX,6          ; CMP
00:00009432 F000            	     1M          DC.W    $F000
00:00009434 B000            	     2M          DC.W    $B000
00:00009436 016A            	     3M          DC.W    (FORM10EX-X)
00:00009438 0006            	     4M          DC.w    6
                            	  1341:          C68     F0C0,90C0,FORM10EX,44         ; SUB       <EA>,A@
00:0000943A F0C0            	     1M          DC.W    $F0C0
00:0000943C 90C0            	     2M          DC.W    $90C0
00:0000943E 016A            	     3M          DC.W    (FORM10EX-X)
00:00009440 002C            	     4M          DC.w    44
                            	  1342:          C68     F130,9100,FORM12,45           ; SUBX
00:00009442 F130            	     1M          DC.W    $F130
00:00009444 9100            	     2M          DC.W    $9100
00:00009446 0208            	     3M          DC.W    (FORM12-X)
00:00009448 002D            	     4M          DC.w    45
                            	  1343:          C68     F000,9000,FORM10EX,44         ; SUB
00:0000944A F000            	     1M          DC.W    $F000
00:0000944C 9000            	     2M          DC.W    $9000
00:0000944E 016A            	     3M          DC.W    (FORM10EX-X)
00:00009450 002C            	     4M          DC.w    44
                            	  1344:          C68     F1F0,8100,FORM12,43           ; SBCD
00:00009452 F1F0            	     1M          DC.W    $F1F0
00:00009454 8100            	     2M          DC.W    $8100
00:00009456 0208            	     3M          DC.W    (FORM12-X)
00:00009458 002B            	     4M          DC.w    43
                            	  1345:          C68     F1C0,81C0,FORM6D,42           ; DIVS
00:0000945A F1C0            	     1M          DC.W    $F1C0
00:0000945C 81C0            	     2M          DC.W    $81C0
00:0000945E 0120            	     3M          DC.W    (FORM6D-X)
00:00009460 002A            	     4M          DC.w    42
                            	  1346:          C68     F1C0,80C0,FORM6D,41           ; DIVU
00:00009462 F1C0            	     1M          DC.W    $F1C0
00:00009464 80C0            	     2M          DC.W    $80C0
00:00009466 0120            	     3M          DC.W    (FORM6D-X)
00:00009468 0029            	     4M          DC.w    41
                            	  1347:          C68     F000,8000,FORM10,40           ; OR
00:0000946A F000            	     1M          DC.W    $F000
00:0000946C 8000            	     2M          DC.W    $8000
00:0000946E 01A8            	     3M          DC.W    (FORM10-X)
00:00009470 0028            	     4M          DC.w    40
                            	  1348:          C68     F100,7000,IMOVEQ,39           ; MOVEQ
00:00009472 F100            	     1M          DC.W    $F100
00:00009474 7000            	     2M          DC.W    $7000
00:00009476 0270            	     3M          DC.W    (IMOVEQ-X)
00:00009478 0027            	     4M          DC.w    39
                            	  1349:          C68     FF00,6100,IBSR,51             ; BSR
00:0000947A FF00            	     1M          DC.W    $FF00
00:0000947C 6100            	     2M          DC.W    $6100
00:0000947E 0354            	     3M          DC.W    (IBSR-X)
00:00009480 0033            	     4M          DC.w    51
                            	  1350:          C68     FF00,6000,IBSR,65             ; BRA
00:00009482 FF00            	     1M          DC.W    $FF00
00:00009484 6000            	     2M          DC.W    $6000
00:00009486 0354            	     3M          DC.W    (IBSR-X)
00:00009488 0041            	     4M          DC.w    65
                            	  1351:          C68     F000,6000,ICC,38              ; B
00:0000948A F000            	     1M          DC.W    $F000
00:0000948C 6000            	     2M          DC.W    $6000
00:0000948E 0350            	     3M          DC.W    (ICC-X)
00:00009490 0026            	     4M          DC.w    38
                            	  1352:          C68     F0F8,50C8,IDBCC,37            ; DB
00:00009492 F0F8            	     1M          DC.W    $F0F8
00:00009494 50C8            	     2M          DC.W    $50C8
00:00009496 033E            	     3M          DC.W    (IDBCC-X)
00:00009498 0025            	     4M          DC.w    37
                            	  1353:          C68     F0C0,50C0,ISCC,36             ; S
00:0000949A F0C0            	     1M          DC.W    $F0C0
00:0000949C 50C0            	     2M          DC.W    $50C0
00:0000949E 0334            	     3M          DC.W    (ISCC-X)
00:000094A0 0024            	     4M          DC.w    36
                            	  1354:          C68     F100,5100,IQUICK,35           ; SUBQ
00:000094A2 F100            	     1M          DC.W    $F100
00:000094A4 5100            	     2M          DC.W    $5100
00:000094A6 026C            	     3M          DC.W    (IQUICK-X)
00:000094A8 0023            	     4M          DC.w    35
                            	  1355:          C68     F100,5000,IQUICK,34           ; ADDQ
00:000094AA F100            	     1M          DC.W    $F100
00:000094AC 5000            	     2M          DC.W    $5000
00:000094AE 026C            	     3M          DC.W    (IQUICK-X)
00:000094B0 0022            	     4M          DC.w    34
                            	  1356:          C68     F1C0,41C0,FORM6A,33           ; LEA
00:000094B2 F1C0            	     1M          DC.W    $F1C0
00:000094B4 41C0            	     2M          DC.W    $41C0
00:000094B6 0110            	     3M          DC.W    (FORM6A-X)
00:000094B8 0021            	     4M          DC.w    33
                            	  1357:          C68     F1C0,4180,FORM6D,32           ; CHK
00:000094BA F1C0            	     1M          DC.W    $F1C0
00:000094BC 4180            	     2M          DC.W    $4180
00:000094BE 0120            	     3M          DC.W    (FORM6D-X)
00:000094C0 0020            	     4M          DC.w    32
                            	  1358:          C68     FFC0,4EC0,FORM11SL,31         ; JMP
00:000094C2 FFC0            	     1M          DC.W    $FFC0
00:000094C4 4EC0            	     2M          DC.W    $4EC0
00:000094C6 01E4            	     3M          DC.W    (FORM11SL-X)
00:000094C8 001F            	     4M          DC.w    31
                            	  1359:          C68     FFC0,4E80,FORM11SL,30         ; JSR
00:000094CA FFC0            	     1M          DC.W    $FFC0
00:000094CC 4E80            	     2M          DC.W    $4E80
00:000094CE 01E4            	     3M          DC.W    (FORM11SL-X)
00:000094D0 001E            	     4M          DC.w    30
                            	  1360:          C68     FFFF,4E77,SCOMMON,29          ; RTR
00:000094D2 FFFF            	     1M          DC.W    $FFFF
00:000094D4 4E77            	     2M          DC.W    $4E77
00:000094D6 0330            	     3M          DC.W    (SCOMMON-X)
00:000094D8 001D            	     4M          DC.w    29
                            	  1361:          C68     FFFF,4E76,SCOMMON,28          ; TRAPV
00:000094DA FFFF            	     1M          DC.W    $FFFF
00:000094DC 4E76            	     2M          DC.W    $4E76
00:000094DE 0330            	     3M          DC.W    (SCOMMON-X)
00:000094E0 001C            	     4M          DC.w    28
                            	  1362:          C68     FFFF,4E75,SCOMMON,27          ; RTS
00:000094E2 FFFF            	     1M          DC.W    $FFFF
00:000094E4 4E75            	     2M          DC.W    $4E75
00:000094E6 0330            	     3M          DC.W    (SCOMMON-X)
00:000094E8 001B            	     4M          DC.w    27
                            	  1363:          C68     FFFF,4E73,SCOMMON,26          ; RTE
00:000094EA FFFF            	     1M          DC.W    $FFFF
00:000094EC 4E73            	     2M          DC.W    $4E73
00:000094EE 0330            	     3M          DC.W    (SCOMMON-X)
00:000094F0 001A            	     4M          DC.w    26
                            	  1364:          C68     FFFF,4E72,ISTOP,25            ; STOP
00:000094F2 FFFF            	     1M          DC.W    $FFFF
00:000094F4 4E72            	     2M          DC.W    $4E72
00:000094F6 004A            	     3M          DC.W    (ISTOP-X)
00:000094F8 0019            	     4M          DC.w    25
                            	  1365:          C68     FFFF,4E71,SCOMMON,24          ; NOP
00:000094FA FFFF            	     1M          DC.W    $FFFF
00:000094FC 4E71            	     2M          DC.W    $4E71
00:000094FE 0330            	     3M          DC.W    (SCOMMON-X)
00:00009500 0018            	     4M          DC.w    24
                            	  1366:          C68     FFFF,4E70,SCOMMON,23          ; RESET
00:00009502 FFFF            	     1M          DC.W    $FFFF
00:00009504 4E70            	     2M          DC.W    $4E70
00:00009506 0330            	     3M          DC.W    (SCOMMON-X)
00:00009508 0017            	     4M          DC.w    23
                            	  1367:          C68     FFF8,4E68,IMVFUSP,60          ; MOVE FROM USP
00:0000950A FFF8            	     1M          DC.W    $FFF8
00:0000950C 4E68            	     2M          DC.W    $4E68
00:0000950E 029E            	     3M          DC.W    (IMVFUSP-X)
00:00009510 003C            	     4M          DC.w    60
                            	  1368:          C68     FFF8,4E60,IMVTUSP,60          ; MOVE TO USP
00:00009512 FFF8            	     1M          DC.W    $FFF8
00:00009514 4E60            	     2M          DC.W    $4E60
00:00009516 02BE            	     3M          DC.W    (IMVTUSP-X)
00:00009518 003C            	     4M          DC.w    60
                            	  1369:          C68     FFF8,4E58,FORM5,22            ; UNLINK
00:0000951A FFF8            	     1M          DC.W    $FFF8
00:0000951C 4E58            	     2M          DC.W    $4E58
00:0000951E 010C            	     3M          DC.W    (FORM5-X)
00:00009520 0016            	     4M          DC.w    22
                            	  1370:          C68     FFF8,4E50,ILINK,21            ; LINK
00:00009522 FFF8            	     1M          DC.W    $FFF8
00:00009524 4E50            	     2M          DC.W    $4E50
00:00009526 00D6            	     3M          DC.W    (ILINK-X)
00:00009528 0015            	     4M          DC.w    21
                            	  1371:          C68     FFF0,4E40,FORM4,20            ; TRAP
00:0000952A FFF0            	     1M          DC.W    $FFF0
00:0000952C 4E40            	     2M          DC.W    $4E40
00:0000952E 00FA            	     3M          DC.W    (FORM4-X)
00:00009530 0014            	     4M          DC.w    20
                            	  1372:          C68     FF80,4C80,IMOVEMTR,15         ; MOVEM FROM REGISTERS
00:00009532 FF80            	     1M          DC.W    $FF80
00:00009534 4C80            	     2M          DC.W    $4C80
00:00009536 002E            	     3M          DC.W    (IMOVEMTR-X)
00:00009538 000F            	     4M          DC.w    15
                            	  1373:          C68     FFC0,4AC0,FORM1A,19           ; TAS
00:0000953A FFC0            	     1M          DC.W    $FFC0
00:0000953C 4AC0            	     2M          DC.W    $4AC0
00:0000953E 00F0            	     3M          DC.W    (FORM1A-X)
00:00009540 0013            	     4M          DC.w    19
                            	  1374:          C68     FF00,4A00,FORM1,18            ; TST
00:00009542 FF00            	     1M          DC.W    $FF00
00:00009544 4A00            	     2M          DC.W    $4A00
00:00009546 00EC            	     3M          DC.W    (FORM1-X)
00:00009548 0012            	     4M          DC.w    18
                            	  1375:          C68     FFF8,48C0,FORM3,17            ; EXT.L
00:0000954A FFF8            	     1M          DC.W    $FFF8
00:0000954C 48C0            	     2M          DC.W    $48C0
00:0000954E 00F6            	     3M          DC.W    (FORM3-X)
00:00009550 0011            	     4M          DC.w    17
                            	  1376:          C68     FFF8,4880,FORM3,16            ; EXT.W
00:00009552 FFF8            	     1M          DC.W    $FFF8
00:00009554 4880            	     2M          DC.W    $4880
00:00009556 00F6            	     3M          DC.W    (FORM3-X)
00:00009558 0010            	     4M          DC.w    16
                            	  1377:          C68     FF80,4880,IMOVEMFR,15         ; MOVEA TO REGISTERS
00:0000955A FF80            	     1M          DC.W    $FF80
00:0000955C 4880            	     2M          DC.W    $4880
00:0000955E 0000            	     3M          DC.W    (IMOVEMFR-X)
00:00009560 000F            	     4M          DC.w    15
                            	  1378:          C68     FFF8,4840,FORM3,14            ; SWAP
00:00009562 FFF8            	     1M          DC.W    $FFF8
00:00009564 4840            	     2M          DC.W    $4840
00:00009566 00F6            	     3M          DC.W    (FORM3-X)
00:00009568 000E            	     4M          DC.w    14
                            	  1379:          C68     FFC0,4840,FORM11,13           ; PEA
00:0000956A FFC0            	     1M          DC.W    $FFC0
00:0000956C 4840            	     2M          DC.W    $4840
00:0000956E 01DC            	     3M          DC.W    (FORM11-X)
00:00009570 000D            	     4M          DC.w    13
                            	  1380:          C68     FFC0,4800,FORM1A,12           ; NBCD
00:00009572 FFC0            	     1M          DC.W    $FFC0
00:00009574 4800            	     2M          DC.W    $4800
00:00009576 00F0            	     3M          DC.W    (FORM1A-X)
00:00009578 000C            	     4M          DC.w    12
                            	  1381:          C68     FFC0,46C0,IMVTSR,59           ; MOVE TO SR
00:0000957A FFC0            	     1M          DC.W    $FFC0
00:0000957C 46C0            	     2M          DC.W    $46C0
00:0000957E 02AC            	     3M          DC.W    (IMVTSR-X)
00:00009580 003B            	     4M          DC.w    59
                            	  1382:          C68     FF00,4600,FORM1,11            ; NOT
00:00009582 FF00            	     1M          DC.W    $FF00
00:00009584 4600            	     2M          DC.W    $4600
00:00009586 00EC            	     3M          DC.W    (FORM1-X)
00:00009588 000B            	     4M          DC.w    11
                            	  1383:          C68     FFC0,44C0,IMVTCCR,59          ; MOVE TO CCR
00:0000958A FFC0            	     1M          DC.W    $FFC0
00:0000958C 44C0            	     2M          DC.W    $44C0
00:0000958E 02CA            	     3M          DC.W    (IMVTCCR-X)
00:00009590 003B            	     4M          DC.w    59
                            	  1384:          C68     FF00,4400,FORM1,10            ; NEG
00:00009592 FF00            	     1M          DC.W    $FF00
00:00009594 4400            	     2M          DC.W    $4400
00:00009596 00EC            	     3M          DC.W    (FORM1-X)
00:00009598 000A            	     4M          DC.w    10
                            	  1385:          C68     FF00,4200,FORM1,9             ; CLR
00:0000959A FF00            	     1M          DC.W    $FF00
00:0000959C 4200            	     2M          DC.W    $4200
00:0000959E 00EC            	     3M          DC.W    (FORM1-X)
00:000095A0 0009            	     4M          DC.w    9
                            	  1386:          C68     FFC0,40C0,IMVFSR,59           ; MOVE.W  FROM  SR
00:000095A2 FFC0            	     1M          DC.W    $FFC0
00:000095A4 40C0            	     2M          DC.W    $40C0
00:000095A6 0290            	     3M          DC.W    (IMVFSR-X)
00:000095A8 003B            	     4M          DC.w    59
                            	  1387:          C68     FF00,4000,FORM1,8             ; NEGX
00:000095AA FF00            	     1M          DC.W    $FF00
00:000095AC 4000            	     2M          DC.W    $4000
00:000095AE 00EC            	     3M          DC.W    (FORM1-X)
00:000095B0 0008            	     4M          DC.w    8
                            	  1388:          C68     F000,3000,IMOVE,59            ; MOVE.W
00:000095B2 F000            	     1M          DC.W    $F000
00:000095B4 3000            	     2M          DC.W    $3000
00:000095B6 00D2            	     3M          DC.W    (IMOVE-X)
00:000095B8 003B            	     4M          DC.w    59
                            	  1389:          C68     F000,2000,IMOVE,60            ; MOVE.L
00:000095BA F000            	     1M          DC.W    $F000
00:000095BC 2000            	     2M          DC.W    $2000
00:000095BE 00D2            	     3M          DC.W    (IMOVE-X)
00:000095C0 003C            	     4M          DC.w    60
                            	  1390:          C68     F000,1000,IMOVE,58            ; MOVE.B
00:000095C2 F000            	     1M          DC.W    $F000
00:000095C4 1000            	     2M          DC.W    $1000
00:000095C6 00D2            	     3M          DC.W    (IMOVE-X)
00:000095C8 003A            	     4M          DC.w    58
                            	  1391:          C68     FF00,0C00,IMMED,6             ; CMP       #
00:000095CA FF00            	     1M          DC.W    $FF00
00:000095CC 0C00            	     2M          DC.W    $0C00
00:000095CE 005E            	     3M          DC.W    (IMMED-X)
00:000095D0 0006            	     4M          DC.w    6
                            	  1392:          C68     FF00,0A00,IMMED,5             ; EOR       #
00:000095D2 FF00            	     1M          DC.W    $FF00
00:000095D4 0A00            	     2M          DC.W    $0A00
00:000095D6 005E            	     3M          DC.W    (IMMED-X)
00:000095D8 0005            	     4M          DC.w    5
                            	  1393:          C68     FF00,0600,IMMED,4             ; ADD       #
00:000095DA FF00            	     1M          DC.W    $FF00
00:000095DC 0600            	     2M          DC.W    $0600
00:000095DE 005E            	     3M          DC.W    (IMMED-X)
00:000095E0 0004            	     4M          DC.w    4
                            	  1394:          C68     FF00,0400,IMMED,3             ; SUB       #
00:000095E2 FF00            	     1M          DC.W    $FF00
00:000095E4 0400            	     2M          DC.W    $0400
00:000095E6 005E            	     3M          DC.W    (IMMED-X)
00:000095E8 0003            	     4M          DC.w    3
                            	  1395:          C68     FF00,0200,IMMED,2             ; AND       #
00:000095EA FF00            	     1M          DC.W    $FF00
00:000095EC 0200            	     2M          DC.W    $0200
00:000095EE 005E            	     3M          DC.W    (IMMED-X)
00:000095F0 0002            	     4M          DC.w    2
                            	  1396:          C68     FF00,0000,IMMED,1             ; OR        #
00:000095F2 FF00            	     1M          DC.W    $FF00
00:000095F4 0000            	     2M          DC.W    $0000
00:000095F6 005E            	     3M          DC.W    (IMMED-X)
00:000095F8 0001            	     4M          DC.w    1
                            	  1397:          C68     F138,0108,IMOVEP,0            ; MOVEP
00:000095FA F138            	     1M          DC.W    $F138
00:000095FC 0108            	     2M          DC.W    $0108
00:000095FE 02DA            	     3M          DC.W    (IMOVEP-X)
00:00009600 0000            	     4M          DC.w    0
                            	  1398:          C68     FFC0,08C0,ISETS,64            ; BSET
00:00009602 FFC0            	     1M          DC.W    $FFC0
00:00009604 08C0            	     2M          DC.W    $08C0
00:00009606 039C            	     3M          DC.W    (ISETS-X)
00:00009608 0040            	     4M          DC.w    64
                            	  1399:          C68     FFC0,0880,ISETS,63            ; BCLR
00:0000960A FFC0            	     1M          DC.W    $FFC0
00:0000960C 0880            	     2M          DC.W    $0880
00:0000960E 039C            	     3M          DC.W    (ISETS-X)
00:00009610 003F            	     4M          DC.w    63
                            	  1400:          C68     FFC0,0840,ISETS,62            ; BCHG
00:00009612 FFC0            	     1M          DC.W    $FFC0
00:00009614 0840            	     2M          DC.W    $0840
00:00009616 039C            	     3M          DC.W    (ISETS-X)
00:00009618 003E            	     4M          DC.w    62
                            	  1401:          C68     FFC0,0800,ISETS,61            ; BTST
00:0000961A FFC0            	     1M          DC.W    $FFC0
00:0000961C 0800            	     2M          DC.W    $0800
00:0000961E 039C            	     3M          DC.W    (ISETS-X)
00:00009620 003D            	     4M          DC.w    61
                            	  1402:          C68     F1C0,01C0,ISETD,64            ; BSET
00:00009622 F1C0            	     1M          DC.W    $F1C0
00:00009624 01C0            	     2M          DC.W    $01C0
00:00009626 038C            	     3M          DC.W    (ISETD-X)
00:00009628 0040            	     4M          DC.w    64
                            	  1403:          C68     F1C0,0180,ISETD,63            ; BCLR
00:0000962A F1C0            	     1M          DC.W    $F1C0
00:0000962C 0180            	     2M          DC.W    $0180
00:0000962E 038C            	     3M          DC.W    (ISETD-X)
00:00009630 003F            	     4M          DC.w    63
                            	  1404:          C68     F1C0,0140,ISETD,62            ; BCHG
00:00009632 F1C0            	     1M          DC.W    $F1C0
00:00009634 0140            	     2M          DC.W    $0140
00:00009636 038C            	     3M          DC.W    (ISETD-X)
00:00009638 003E            	     4M          DC.w    62
                            	  1405:          C68     F1C0,0100,ISETD,61            ; BTST
00:0000963A F1C0            	     1M          DC.W    $F1C0
00:0000963C 0100            	     2M          DC.W    $0100
00:0000963E 038C            	     3M          DC.W    (ISETD-X)
00:00009640 003D            	     4M          DC.w    61
                            	  1406: TBLE:
                            	  1407:           even
                            	  1408: 
                            	  1409: N68:     macro arg1,arg2
                            	  1410:          dc.b  "\1",\2
                            	  1411:          endm
                            	  1412: 
                            	  1413: 				even
                            	  1414: OPCTBL:  ;.align  2
                            	  1415:          N68     MOVE,$d0    ; 0
00:00009642 4D4F5645        	     1M          dc.b  "MOVE",$d0
00:00009646 D0
                            	  1416:          N68     O,$d2       ; 1
00:00009647 4F              	     1M          dc.b  "O",$d2
00:00009648 D2
                            	  1417:          N68     AN,$c4      ; 2
00:00009649 414E            	     1M          dc.b  "AN",$c4
00:0000964B C4
                            	  1418:          N68     SU,$c2      ; 3
00:0000964C 5355            	     1M          dc.b  "SU",$c2
00:0000964E C2
                            	  1419:          N68     AD,$c4      ; 4
00:0000964F 4144            	     1M          dc.b  "AD",$c4
00:00009651 C4
                            	  1420:          N68     EO,$d2      ; 5
00:00009652 454F            	     1M          dc.b  "EO",$d2
00:00009654 D2
                            	  1421:          N68     CM,$d0      ; 6
00:00009655 434D            	     1M          dc.b  "CM",$d0
00:00009657 D0
                            	  1422:          N68     MOV,$c5     ; 7
00:00009658 4D4F56          	     1M          dc.b  "MOV",$c5
00:0000965B C5
                            	  1423:          N68     NEG,$d8     ; 8
00:0000965C 4E4547          	     1M          dc.b  "NEG",$d8
00:0000965F D8
                            	  1424:          N68     CL,$d2      ; 9
00:00009660 434C            	     1M          dc.b  "CL",$d2
00:00009662 D2
                            	  1425:          N68     NE,$c7      ; 10
00:00009663 4E45            	     1M          dc.b  "NE",$c7
00:00009665 C7
                            	  1426:          N68     NO,$d4      ; 11
00:00009666 4E4F            	     1M          dc.b  "NO",$d4
00:00009668 D4
                            	  1427:          N68     NBC,$c4     ; 12
00:00009669 4E4243          	     1M          dc.b  "NBC",$c4
00:0000966C C4
                            	  1428:          N68     PEA.,$cc    ; 13
00:0000966D 5045412E        	     1M          dc.b  "PEA.",$cc
00:00009671 CC
                            	  1429:          N68     SWAP.,$d7   ; 14
00:00009672 535741502E      	     1M          dc.b  "SWAP.",$d7
00:00009677 D7
                            	  1430:          N68     MOVE,$cd    ; 15
00:00009678 4D4F5645        	     1M          dc.b  "MOVE",$cd
00:0000967C CD
                            	  1431:          N68     EXT.,$d7    ; 16
00:0000967D 4558542E        	     1M          dc.b  "EXT.",$d7
00:00009681 D7
                            	  1432:          N68     EXT.,$cc    ; 17
00:00009682 4558542E        	     1M          dc.b  "EXT.",$cc
00:00009686 CC
                            	  1433:          N68     TS,$d4      ; 18
00:00009687 5453            	     1M          dc.b  "TS",$d4
00:00009689 D4
                            	  1434:          N68     TAS.,$c2    ; 19
00:0000968A 5441532E        	     1M          dc.b  "TAS.",$c2
00:0000968E C2
                            	  1435:          N68     TRA,$d0     ; 20
00:0000968F 545241          	     1M          dc.b  "TRA",$d0
00:00009692 D0
                            	  1436:          N68     LIN,$cb     ; 21
00:00009693 4C494E          	     1M          dc.b  "LIN",$cb
00:00009696 CB
                            	  1437:          N68     UNL,$cb     ; 22
00:00009697 554E4C          	     1M          dc.b  "UNL",$cb
00:0000969A CB
                            	  1438:          N68     RESE,$d4    ; 23
00:0000969B 52455345        	     1M          dc.b  "RESE",$d4
00:0000969F D4
                            	  1439:          N68     NO,$d0      ; 24
00:000096A0 4E4F            	     1M          dc.b  "NO",$d0
00:000096A2 D0
                            	  1440:          N68     STO,$d0     ; 25
00:000096A3 53544F          	     1M          dc.b  "STO",$d0
00:000096A6 D0
                            	  1441:          N68     RT,$c5      ; 26
00:000096A7 5254            	     1M          dc.b  "RT",$c5
00:000096A9 C5
                            	  1442:          N68     RT,$d3      ; 27
00:000096AA 5254            	     1M          dc.b  "RT",$d3
00:000096AC D3
                            	  1443:          N68     TRAP,$d6    ; 28
00:000096AD 54524150        	     1M          dc.b  "TRAP",$d6
00:000096B1 D6
                            	  1444:          N68     RT,$d2      ; 29
00:000096B2 5254            	     1M          dc.b  "RT",$d2
00:000096B4 D2
                            	  1445:          N68     JS,$d2      ; 30
00:000096B5 4A53            	     1M          dc.b  "JS",$d2
00:000096B7 D2
                            	  1446:          N68     JM,$d0      ; 31
00:000096B8 4A4D            	     1M          dc.b  "JM",$d0
00:000096BA D0
                            	  1447:          N68     CHK.,$d7    ; 32
00:000096BB 43484B2E        	     1M          dc.b  "CHK.",$d7
00:000096BF D7
                            	  1448:          N68     LEA.,$cc    ; 33
00:000096C0 4C45412E        	     1M          dc.b  "LEA.",$cc
00:000096C4 CC
                            	  1449:          N68     ADD,$d1     ; 34
00:000096C5 414444          	     1M          dc.b  "ADD",$d1
00:000096C8 D1
                            	  1450:          N68     SUB,$d1     ; 35
00:000096C9 535542          	     1M          dc.b  "SUB",$d1
00:000096CC D1
00:000096CD D3              	  1451:          DC.B    $d3         ; 36
                            	  1452:          N68     D,$c2       ; 37
00:000096CE 44              	     1M          dc.b  "D",$c2
00:000096CF C2
00:000096D0 C2              	  1453:          DC.B    $c2         ; 38
                            	  1454:          N68     MOVEQ.,$cc  ; .....39
00:000096D1 4D4F5645512E    	     1M          dc.b  "MOVEQ.",$cc
00:000096D7 CC
                            	  1455:          N68     O,$d2       ; 40
00:000096D8 4F              	     1M          dc.b  "O",$d2
00:000096D9 D2
                            	  1456:          N68     DIVU.,$d7   ; 41
00:000096DA 444956552E      	     1M          dc.b  "DIVU.",$d7
00:000096DF D7
                            	  1457:          N68     DIVS.,$d7   ; 42
00:000096E0 444956532E      	     1M          dc.b  "DIVS.",$d7
00:000096E5 D7
                            	  1458:          N68     SBC,$c4     ; 43
00:000096E6 534243          	     1M          dc.b  "SBC",$c4
00:000096E9 C4
                            	  1459:          N68     SU,$c2      ; 44
00:000096EA 5355            	     1M          dc.b  "SU",$c2
00:000096EC C2
                            	  1460:          N68     SUB,$d8     ; 45
00:000096ED 535542          	     1M          dc.b  "SUB",$d8
00:000096F0 D8
                            	  1461:          N68     CMP,$cd     ; 46
00:000096F1 434D50          	     1M          dc.b  "CMP",$cd
00:000096F4 CD
                            	  1462:          N68     MULU.,$d7   ; 47
00:000096F5 4D554C552E      	     1M          dc.b  "MULU.",$d7
00:000096FA D7
                            	  1463:          N68     MULS.,$d7   ; 48
00:000096FB 4D554C532E      	     1M          dc.b  "MULS.",$d7
00:00009700 D7
                            	  1464:          N68     ABC,$c4     ; 49
00:00009701 414243          	     1M          dc.b  "ABC",$c4
00:00009704 C4
                            	  1465:          N68     EX,$c7      ; 50
00:00009705 4558            	     1M          dc.b  "EX",$c7
00:00009707 C7
                            	  1466:          N68     BS,$d2      ; .....51
00:00009708 4253            	     1M          dc.b  "BS",$d2
00:0000970A D2
                            	  1467:          N68     NUL,$cc     ; .....52
00:0000970B 4E554C          	     1M          dc.b  "NUL",$cc
00:0000970E CC
                            	  1468:          N68     ADD,$d8     ; 53
00:0000970F 414444          	     1M          dc.b  "ADD",$d8
00:00009712 D8
                            	  1469:          N68     A,$d3       ; 54
00:00009713 41              	     1M          dc.b  "A",$d3
00:00009714 D3
                            	  1470:          N68     L,$d3       ; 55
00:00009715 4C              	     1M          dc.b  "L",$d3
00:00009716 D3
                            	  1471:          N68     R,$cf       ; 56
00:00009717 52              	     1M          dc.b  "R",$cf
00:00009718 CF
                            	  1472:          N68     RO,$d8      ; 57
00:00009719 524F            	     1M          dc.b  "RO",$d8
00:0000971B D8
                            	  1473:          N68     MOVE.,$c2   ; 58
00:0000971C 4D4F56452E      	     1M          dc.b  "MOVE.",$c2
00:00009721 C2
                            	  1474:          N68     MOVE.,$d7   ; 59
00:00009722 4D4F56452E      	     1M          dc.b  "MOVE.",$d7
00:00009727 D7
                            	  1475:          N68     MOVE.,$cc   ; 60
00:00009728 4D4F56452E      	     1M          dc.b  "MOVE.",$cc
00:0000972D CC
                            	  1476:          N68     BTS,$d4     ; 61
00:0000972E 425453          	     1M          dc.b  "BTS",$d4
00:00009731 D4
                            	  1477:          N68     BCH,$c7     ; 62
00:00009732 424348          	     1M          dc.b  "BCH",$c7
00:00009735 C7
                            	  1478:          N68     BCL,$d2     ; 63
00:00009736 42434C          	     1M          dc.b  "BCL",$d2
00:00009739 D2
                            	  1479:          N68     BSE,$d4     ; 64
00:0000973A 425345          	     1M          dc.b  "BSE",$d4
00:0000973D D4
                            	  1480:          N68     BR,$c1      ; 65
00:0000973E 4252            	     1M          dc.b  "BR",$c1
00:00009740 C1
                            	  1481: 
00:00009741 00              	  1482:          DC.B    0         ; PAD BYTE
                            	  1483: 
                            	  1484: 

Source: "boot.x68"
                            	  5543:  	include "games/asteroids/asteroids 1_0.x68"

Source: "games\asteroids\asteroids 1_0.x68"
                            	     1: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	     2: ;														;
                            	     3: ;	ASTEROIDS type game for the EASy68k simulator	2009/05/17	V1.00			;
                            	     4: ;														;
                            	     5: ;	The objective of of the game is to score as many points as possible by		;
                            	     6: ;	destroying asteroids and flying saucers. You control a triangular ship		;
                            	     7: ;	that can rotate, fire shots forward and thrust forward. As the ship moves,	;
                            	     8: ;	momentum is not conserved, the ship eventually comes to a stop when not		;
                            	     9: ;	thrusting. In moments of extreme danger you can send the ship into		;
                            	    10: ;	hyperspace, causing it to disappear and reappear in a random location.		;
                            	    11: ;														;
                            	    12: ;	Each wave starts with the asteroids drifting in random directions onto the	;
                            	    13: ;	screen. Objects wrap around screen edges, an asteroid that drifts off the	;
                            	    14: ;	left edge of the screen reappears at the right and continues moving in the	;
                            	    15: ;	same direction. As you shoot asteroids they break into smaller asteroids	;
                            	    16: ;	that often move faster and are more difficult to hit. The smaller the		;
                            	    17: ;	asteroid the higher the points scored.							;
                            	    18: ;														;
                            	    19: ;	Every so often a flying saucer will appear on one side of the screen and	;
                            	    20: ;	move to the other before disappearing again. Large saucers fire in random	;
                            	    21: ;	directions, while small saucers aim their fire towards the player's ship.	;
                            	    22: ;														;
                            	    23: ;	Once all of the asteroids and flying saucers have been cleared a new set of	;
                            	    24: ;	large asteroids appears. The number of asteroids increases by two each round	;
                            	    25: ;	up to a maximum of eleven. The game continues until all the player lives	;
                            	    26: ;	are lost, a bonus life being awarded for each 10,000 points scored up to a	;
                            	    27: ;	maximum of 255 lives. A maximum of only 18 lives are shown on screen.		;
                            	    28: ;														;
                            	    29: ;	Like the original game the maximum possible score in this game is 99,990	;
                            	    30: ;	points after which it rolls over back to zero.						;
                            	    31: ;														;
                            	    32: ;	Also like the original game some game parameters can be set using the		;
                            	    33: ;	switches in the hardware window. These can be changed at any time during	;
                            	    34: ;	the game.												;
                            	    35: ;														;
                            	    36: ;	Switch	Function										;
                            	    37: ;	------	--------										;
                            	    38: ;	7 - 3		Unused										;
                            	    39: ;	  2		Starting ship count. On = 4, off = 3					;
                            	    40: ;	1 - 0		Language	1	0								;
                            	    41: ;					off	off	English						;
                            	    42: ;					off	on	German						;
                            	    43: ;					on	off	French						;
                            	    44: ;					on	on	Spanish						;
                            	    45: ;														;
                            	    46: ;	Game controls...											;
                            	    47: ;														;
                            	    48: ;	 [1] or [2] for a one or two player game start						;
                            	    49: ;	 [s] to toggle the sound off and on								;
                            	    50: ;														;
                            	    51: ;	 [q] to rotate the ship widdershins								;
                            	    52: ;	 [w] to rotate the ship deocil								;
                            	    53: ;	 [l] to fire the ship thruster								;
                            	    54: ;	 [p] to fire the ship weapon									;
                            	    55: ;	 [SPACE] to jump to hyperspace								;
                            	    56: ;														;
                            	    57: ;	Other keys are:											;
                            	    58: ;														;
                            	    59: ;	 The F2, F3 and F4 keys can be used to select a screen size of 640 x 480,	;
                            	    60: ;	 800 x 600 and 1024 x 768 respectively.							;
                            	    61: ;														;
                            	    62: ;	The game saves the high scores in the file asteroids.hi If this file is		;
                            	    63: ;	not present it will be created after the first high score is entered. If	;
                            	    64: ;	this file is read only new high scores will not be saved. No check is made	;
                            	    65: ;	on the validity of this file, editing the file may cause the game to crash.	;
                            	    66: ;														;
                            	    67: ;	This version for Sim68K 4.6.0 or later							;
                            	    68: ;														;
                            	    69: ;	More 68000 and other projects can be found on my website at ..			;
                            	    70: ;														;
                            	    71: ;	 http://mycorner.no-ip.org/index.html							;
                            	    72: ;														;
                            	    73: ;	mail : leeedavison@googlemail.com								;
                            	    74: ;														;
                            	    75: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    76: 
                            	    77: ; a0 = system calls and volatile
                            	    78: ; a1 = system calls and volatile
                            	    79: ; a2 = volatile
                            	    80: ; a3 = variables base address
                            	    81: ; a4 = vector list pointer
                            	    82: ; a5 = player 1 / current player
                            	    83: ; a6 = player 2 / other player
                            	    84: ; a7 = stack pointer
                            	    85: 
                            	    86: 
                            	    87: ;	ORG	$10000
                            	    88: 	code
                            	    89: 	even
                            	    90: 
                            	    91: asteroids_start:
00:00009742 61001230        	    92: 	bsr	Initialise				; go setup everything
00:00009746 610006DC        	    93: 	bsr reset_game				; clear the scores and set the ship start count
                            	    94: 
                            	    95: ; main loop. this is executed at most once every 16ms, as it waits for the 16ms counter
                            	    96: ; to be incremented from zero since the last loop
                            	    97: 
                            	    98: main_loop:
00:0000974A 705E            	    99: 	moveq	#94,d0					; copy screen buffer to main (page flip)
00:0000974C 4E4F            	   100: 	trap #15
                            	   101: 
00:0000974E 6100C864        	   102: 	jsr clear_bitmap_screen4
                            	   103: ;	move.w #$FF00,d1			; clear screen
                            	   104: ;	moveq #11,d0					; position cursor
                            	   105: ;	trap #15
                            	   106: 
                            	   107: ;	bsr sound_key					; handle the sound key
00:00009752 61001214        	   108: 	bsr s_controls				; go check the screen controls
                            	   109: 
00:00009756 20390004009C    	   110: 	move.l tickcnt,d0
                            	   111: .0001:
00:0000975C B0B90004009C    	   112: 	cmp.l tickcnt,d0
00:00009762 67F8            	   113: 	beq.s .0001
00:00009764 7001            	   114: 	moveq #1,d0
                            	   115: ;wait_16ms
                            	   116: ;	MOVE.b	sixteen_ms(a3),d0		; get the 16ms counter
                            	   117: ;	BEQ.s		wait_16ms			; if not there yet just loop
                            	   118: 
                            	   119: ;	clr.b	sixteen_ms(a3)			; clear the 16ms counter
00:00009766 D16B0059        	   120: 	add.w d0,game_count(a3)		; increment the game counter
00:0000976A D12B0025        	   121: 	add.b d0,time_count(a3)		; increment the timeout counter
                            	   122: 
00:0000976E 49FA13F8        	   123: 	lea vector(pc),a4			; reset the vector RAM pointer
                            	   124: 
00:00009772 6168            	   125: 	bsr game_message			; do "PLAYER x", "GAME OVER" or credit messages
                            	   126: 
00:00009774 61000F2C        	   127: 	bsr check_hiscores		; do the high score checks
00:00009778 610004C4        	   128: 	bsr enter_hiscores		; get the player high score entries
00:0000977C 6A30            	   129: 	bpl.s no_play					; if the high scores are being entered skip the
                            	   130: 												; active play routines
                            	   131: 
00:0000977E 61000C80        	   132: 	bsr high_scores				; display the high score table if the game is
                            	   133: 												; over
00:00009782 652A            	   134: 	bcs.s	no_play					; if the high score table was displayed skip
                            	   135: 												; active play
                            	   136: 
00:00009784 4A2B001C        	   137: 	tst.b px_time(a3)			; test the "PLAYER x" timer
00:00009788 661C            	   138: 	bne.s px_hide					; skip the control checks if the "PLAYER x"
                            	   139: 												; timer is not timed out
                            	   140: 
00:0000978A 4A2B001A        	   141: 	tst.b num_players(a3)	; test the number of players in the game
00:0000978E 6712            	   142: 	beq.s skip_player_cont		; if no players skip the player controls
                            	   143: 
00:00009790 4A2D0027        	   144: 	tst.b p_flag_off(a5)			; test the player flag
00:00009794 6B08            	   145: 	bmi.s skip_player_move		; if the player is exploding skip the player
                            	   146: 														; move controls
                            	   147: 
00:00009796 610003FE        	   148: 	bsr	ship_fire					; handle the fire button			##
00:0000979A 610005F8        	   149: 	bsr	hyperspace				; handle the hyperspace button		##
                            	   150: skip_player_move
00:0000979E 610007F4        	   151: 	bsr ship_move					; handle ship rotation and thrust		##
                            	   152: skip_player_cont
00:000097A2 61000284        	   153: 	bsr do_saucer					; handle the saucer
                            	   154: px_hide
00:000097A6 610006FA        	   155: 	bsr move_items				; move all the objects and add them to the
                            	   156: 												; vector list
00:000097AA 6100014A        	   157: 	bsr check_hits				; check for player/saucer/shot hits
                            	   158: no_play
00:000097AE 61000AC0        	   159: 	bsr static_messages		; add (c), scores and players ships to the
                            	   160: 												; vector list
                            	   161: 
00:000097B2 61000E36        	   162: 	bsr fx_sounds					; do the saucer and thump sounds
                            	   163: 
00:000097B6 38FCB000        	   164: 	move.w #HALT,(a4)+		; add HALT to the vector list
                            	   165: 
00:000097BA 49FA13AC        	   166: 	lea vector(pc),a4			; reset the vector RAM pointer
00:000097BE 6100125E        	   167: 	bsr do_vector					; go do the vector list, draw them
                            	   168: 
00:000097C2 102D007B        	   169: 	move.b new_rocks(a5),d0			; test the generate new rocks flag
00:000097C6 6704            	   170: 	beq.s no_dec_new_rocks			; if counted out skip the decrement
                            	   171: 
00:000097C8 532D007B        	   172: 	subq.b #1,new_rocks(a5)			; else decrement the generate new rocks flag
                            	   173: no_dec_new_rocks
00:000097CC 802D0076        	   174: 	or.b rock_count(a5),d0			; OR the new rocks flag with the rock count
00:000097D0 6600FF78        	   175: 	bne main_loop					; if not counted out or still rocks go do the
                            	   176: 												; main loop
                            	   177: 
00:000097D4 487AFF74        	   178: 	pea main_loop					; return to the main loop
00:000097D8 6000091C        	   179: 	bra make_rocks				; go generate new rocks
                            	   180: 
                            	   181: 
                            	   182: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   183: ;
                            	   184: ; do "PLAYER x", "GAME OVER" or credit messages
                            	   185: 
                            	   186: game_message:
00:000097DC 4A2B001A        	   187: 	tst.b num_players(a3)		; test the number of players in the game
00:000097E0 670E            	   188: 	beq.s do_start_mess			; if no players go do the start message
                            	   189: 
00:000097E2 4A2B001C        	   190: 	tst.b px_time(a3)				; test the "PLAYER x" timer
00:000097E6 677C            	   191: 	beq.s game_over					; if timed out go do "GAME OVER" or thump
                            	   192: 													; sound count
                            	   193: 
00:000097E8 532B001C        	   194: 	subq.b #1,px_time(a3)		; decrement the "PLAYER x" timer
00:000097EC 60001110        	   195: 	bra player_x						; add "PLAYER x" to the vector list and return
                            	   196: 
                            	   197: ; do the push start message
                            	   198: 
                            	   199: do_start_mess:
00:000097F0 7005            	   200: 	moveq #5,d0					; GetKey
00:000097F2 4E4F            	   201: 	trap #15
00:000097F4 4A81            	   202: 	tst.l d1
00:000097F6 6B54            	   203: 	bmi.s push_start_mess
00:000097F8 7001            	   204: 	moveq #1,d0
00:000097FA 0C010031        	   205: 	cmpi.b #'1',d1
00:000097FE 6718            	   206: 	beq.s start_game
00:00009800 0C010032        	   207: 	cmpi.b #'2',d1
00:00009804 6646            	   208: 	bne.s push_start_mess
                            	   209: 
                            	   210: ;	MOVE.l	#'2121',d1			; [2][1][2][1] key
                            	   211: ;	MOVEQ		#19,d0			; check for keypress
                            	   212: ;	TRAP		#15
                            	   213: 
                            	   214: ;	MOVEQ		#1,d0				; default to one player
                            	   215: ;	TST.b		d1				; test the [1] key result
                            	   216: ;	BMI.s		start_game			; if pressed go start a one player game
                            	   217: 
                            	   218: ;	TST.w		d1				; test the [2] key result
                            	   219: 	;BPL.s		push_start_mess		; if not pressed go do the "PUSH START" message
                            	   220: 
                            	   221: 							; else the two player start was pressed
00:00009806 4BEB01F7        	   222: 	lea player_2(a3),a5		; set the pointer to player two's variables
00:0000980A 61000618        	   223: 	bsr reset_game				; clear the score and set the ship start count
00:0000980E 6100098E        	   224: 	bsr player_init				; initialise the player variables
00:00009812 610008E2        	   225: 	bsr make_rocks				; generate new rocks
00:00009816 7002            	   226: 	moveq #2,d0						; set two players in this game
                            	   227: 
                            	   228: ; one or two player game start
                            	   229: 
                            	   230: start_game:
00:00009818 1740001A        	   231: 	move.b d0,num_players(a3)	; save the number of players in the game
                            	   232: 
00:0000981C 422B0018        	   233: 	clr.b player_idx(a3)			; clear the player index
00:00009820 4BEB00F3        	   234: 	lea	player_1(a3),a5				; set the pointer to player one's variables
00:00009824 4DEB01F7        	   235: 	lea player_2(a3),a6				; set the pointer to player two's variables
                            	   236: 
00:00009828 610005FA        	   237: 	bsr reset_game				; clear the scores and set the ship start count
00:0000982C 61000970        	   238: 	bsr player_init				; initialise the player variables
00:00009830 610008C4        	   239: 	bsr make_rocks				; generate new rocks
                            	   240: 
00:00009834 7000            	   241: 	moveq #0,d0						; clear the longword
00:00009836 3B400080        	   242: 	move.w d0,score_off(a5)		; clear player 1's score
00:0000983A 3D400080        	   243: 	move.w d0,score_off(a6)		; clear player 2's score
                            	   244: 
00:0000983E 177C0080001C    	   245: 	move.b #$80,px_time(a3)		; set the "PLAYER x" timer
00:00009844 177C00040024    	   246: 	move.b #$04,thump_time(a3)	; set the thump sound change timer
00:0000984A 4E75            	   247: 	rts
                            	   248: 
                            	   249: ; else do the "PUSH START" message
                            	   250: 
                            	   251: push_start_mess:
00:0000984C 102B0176        	   252: 	move.b p1_high(a3),d0			; get the player 1 highscore flag
00:00009850 C02B027A        	   253: 	and.b p2_high(a3),d0			; and with the player 2 highscore flag
00:00009854 6A0C            	   254: 	bpl.s exit_push_start			; if either player is entering their high score
                            	   255: 														; skip the "PUSH START" message
                            	   256: 
00:00009856 7206            	   257: 	moveq #$06,d1								; message 6 - "PUSH START"
00:00009858 082B0005005A    	   258: 	btst.b #5,game_count+1(a3)	; test a bit in the game counter low byte
00:0000985E 67001030        	   259: 	beq add_message							; if set add message d1 to the display list
                            	   260: 															; and return
                            	   261: exit_push_start
00:00009862 4E75            	   262: 	rts
                            	   263: 
                            	   264: ; do "GAME OVER" or thump sound count
                            	   265: 
                            	   266: game_over:
00:00009864 703F            	   267: 	moveq #$3F,d0							; set the game counter mask
00:00009866 C06B0059        	   268: 	and.w game_count(a3),d0		; mask the game counter
00:0000986A 660C            	   269: 	bne.s nodec_thmpi					; branch if not zero
                            	   270: 
                            	   271: 							; gets here 1/64th of the time
00:0000986C 0C2D0006007C    	   272: 	cmpi.b #6,thmp_sndi(a5)		; compare the thump sound change timer initial
                            	   273: 							; value with the minimum value
00:00009872 6704            	   274: 	beq.s nodec_thmpi					; if there already don't decrement it
                            	   275: 
00:00009874 532D007C        	   276: 	subq.b #1,thmp_sndi(a5)		; else decrement the thump sound change timer
                            	   277: 							; initial value
                            	   278: nodec_thmpi
00:00009878 4A2D0082        	   279: 	tst.b ships_off(a5)			; test the player ship count
00:0000987C 6624            	   280: 	bne.s no_game_over			; if ships left skip game over
                            	   281: 
                            	   282: 							; else this player has no ships left
00:0000987E 102D002B        	   283: 	move.b p_fire_off(a5),d0		; get player fire 1
00:00009882 802D002C        	   284: 	or.b p_fire_off+1(a5),d0		; OR with player fire 2
00:00009886 802D002D        	   285: 	or.b p_fire_off+2(a5),d0		; OR with player fire 3
00:0000988A 802D002E        	   286: 	or.b p_fire_off+3(a5),d0		; OR with player fire 4
00:0000988E 6612            	   287: 	bne.s no_game_over			; if shots still flying skip the game over
                            	   288: 
00:00009890 7207            	   289: 	moveq #7,d1							; else message 7 - "GAME OVER"
00:00009892 61000FFC        	   290: 	bsr add_message					; add message d1 to the display list
                            	   291: 
00:00009896 0C2B0002001A    	   292: 	cmpi.b #$02,num_players(a3)	; compare the number of players with two
00:0000989C 6604            	   293: 	bne.s no_game_over			; if not two player skip which game's over
                            	   294: 
00:0000989E 6100105E        	   295: 	bsr player_x						; add "PLAYER x" to the vector list
                            	   296: no_game_over
00:000098A2 4A2D0027        	   297: 	tst.b p_flag_off(a5)		; test the player flag
00:000098A6 6638            	   298: 	bne.s	exit_game_message		; if alive or exploding just exit
                            	   299: 
00:000098A8 0C2D0080007A    	   300: 	cmpi.b #$80,hide_p_cnt(a5)	; compare with about to die - 1 with the hide
                            	   301: 							; the player count
00:000098AE 6630            	   302: 	bne.s exit_game_message			; if not about to die just exit
                            	   303: 
00:000098B0 1B7C0010007A    	   304: 	move.b #$10,hide_p_cnt(a5)	; set the hide the player count
                            	   305: 
00:000098B6 122B001A        	   306: 	move.b num_players(a3),d1	; get the number of players in the game
                            	   307: 
00:000098BA 102B0175        	   308: 	move.b p1_ships(a3),d0		; get player 1's ship count
00:000098BE 802B0279        	   309: 	or.b p2_ships(a3),d0			; OR with player 2's ship count
00:000098C2 671E            	   310: 	beq.s end_game					; if no ships left go end the game
                            	   311: 
00:000098C4 610006BA        	   312: 	bsr clear_saucer				; clear the saucer and restart the saucer timer
00:000098C8 5301            	   313: 	subq.b #1,d1						; decrement the number of players in the game
00:000098CA 6714            	   314: 	beq.s exit_game_message	; if that was the last player go flag no game
                            	   315: 							; and exit
                            	   316: 
00:000098CC 177C0080001C    	   317: 	move.b #$80,px_time(a3)		; set the "PLAYER x" timer
                            	   318: 
00:000098D2 4A2E0082        	   319: 	tst.b ships_off(a6)			; test the other player's ship count
00:000098D6 6708            	   320: 	beq.s exit_game_message		; if no ships left go flag no game and exit
                            	   321: 
                            	   322: 														; else change to the other player
00:000098D8 0A2B00010018    	   323: 	eori.b #1,player_idx(a3)		; toggle the player index
00:000098DE CB4E            	   324: 	exg a5,a6									; swap the player pointers
                            	   325: exit_game_message
00:000098E0 4E75            	   326: 	rts
                            	   327: 
                            	   328: ; neither player has any ships left so end the game
                            	   329: 
                            	   330: end_game:
00:000098E2 17410019        	   331: 	move.b d1,past_play(a3)		; save the number of players that were in the
                            	   332: 							; game
00:000098E6 177C00FF001A    	   333: 	move.b #$FF,num_players(a3)	; clear the number of players in the game
00:000098EC 4BEB00F3        	   334: 	lea player_1(a3),a5		; set the pointer to player one's variables
00:000098F0 4DEB01F7        	   335: 	lea player_2(a3),a6		; set the pointer to player two's variables
00:000098F4 4E75            	   336: 	rts
                            	   337: 
                            	   338: 
                            	   339: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   340: ;
                            	   341: ; check for player/saucer/shot hits
                            	   342: 
                            	   343: check_hits:
00:000098F6 7C07            	   344: 	moveq #flag_end-p_flag_off-1,d6
                            	   345: 							; set the count/index for player/saucer/shots
                            	   346: pss_check_loop
00:000098F8 4A356027        	   347: 	tst.b p_flag_off(a5,d6.w)	; test if the player/saucer/shot exists
00:000098FC 6E06            	   348: 	bgt.s check_pss			; if the item exists and is not exploding go
                            	   349: 							; test it
                            	   350: 
                            	   351: next_pss
00:000098FE 51CEFFF8        	   352: 	dbf d6,pss_check_loop	; decrement count/index and loop if more to do
                            	   353: 
00:00009902 4E75            	   354: 	rts
                            	   355: 
                            	   356: ; the player/saucer/shot exists and is not exploding
                            	   357: 
                            	   358: check_pss
00:00009904 7E1C            	   359: 	moveq #s_flag_off-flags_off,d7
                            	   360: 							; set the item index to the saucer
00:00009906 0C460004        	   361: 	cmpi.w #p_fire_off-p_flag_off,d6
                            	   362: 							; compare the player/saucer/shot index with the
                            	   363: 							; first player shot
00:0000990A 640A            	   364: 	bcc.s check_all			; if it is a player shot go test it against all
                            	   365: 							; the items
                            	   366: 
00:0000990C 5347            	   367: 	subq.w #1,d7				; else skip the saucer
00:0000990E 4A46            	   368: 	tst.w d6						; test the player/saucer/shot index
00:00009910 6604            	   369: 	bne.s check_all			; if not the player go test against everything
                            	   370: 
                            	   371: 							; else skip the player
                            	   372: check_next_object
00:00009912 5347            	   373: 	subq.w #1,d7				; decrement the item index
00:00009914 6BE8            	   374: 	bmi.s next_pss			; if all done go do next player/saucer/shot
                            	   375: 
                            	   376: check_all
00:00009916 1435700C        	   377: 	MOVE.b	flags_off(a5,d7.w),d2	; get the item flag indexed by d7
00:0000991A 6FF6            	   378: 	BLE.s		check_next_object		; if the item doesn't exist or the item is
                            	   379: 							; exploding go try the next item
                            	   380: 
00:0000991C 3A07            	   381: 	MOVE.w	d7,d5				; copy the item index
00:0000991E DA45            	   382: 	ADD.w		d5,d5				; ; 2 for the item position index
                            	   383: 
00:00009920 3806            	   384: 	MOVE.w	d6,d4				; copy the fire item index
00:00009922 D844            	   385: 	ADD.w		d4,d4				; ; 2 for the fire item position index
                            	   386: 
00:00009924 30355080        	   387: 	MOVE.w	x_pos_off(a5,d5.w),d0	; get item x position
00:00009928 907540B6        	   388: 	SUB.w		p_xpos_off(a5,d4.w),d0	; subtract the player/saucer/shot x position
00:0000992C 6A02            	   389: 	BPL.s		delta_x_pos			; if the delta is positive skip the negate
                            	   390: 
00:0000992E 4440            	   391: 	NEG.w		d0				; else negate the delta
                            	   392: delta_x_pos
00:00009930 0C400151        	   393: 	CMPI.w	#$0151,d0			; compare the range with $0151
00:00009934 64DC            	   394: 	BCC.s		check_next_object		; if it's out of range go try the next item
                            	   395: 
00:00009936 323550C6        	   396: 	MOVE.w	y_pos_off(a5,d5.w),d1	; get item y position
00:0000993A 927540FC        	   397: 	SUB.w		p_ypos_off(a5,d4.w),d1	; subtract the player/saucer/shot y position
00:0000993E 6A02            	   398: 	BPL.s		delta_y_pos			; if the delta is positive skip the negate
                            	   399: 
00:00009940 4441            	   400: 	NEG.w		d1				; else negate the delta
                            	   401: delta_y_pos
00:00009942 0C410151        	   402: 	CMPI.w	#$0151,d1			; compare the range with $0151
00:00009946 64CA            	   403: 	BCC.s		check_next_object		; if it's out of range go try the next item
                            	   404: 
00:00009948 C0C0            	   405: 	MULU.w	d0,d0				; calculate delta x^2
00:0000994A C2C1            	   406: 	MULU.w	d1,d1				; calculate delta y^2
00:0000994C D081            	   407: 	ADD.l		d1,d0				; calculate delta x^2 + delta y^2
00:0000994E E480            	   408: 	ASR.l		#2,d0				; / 4 makes it a word value again
                            	   409: 
00:00009950 02420007        	   410: 	ANDI.w	#$07,d2			; mask the size bits
00:00009954 5302            	   411: 	SUBQ.b	#1,d2				; make $01 to $04 into $00 to $03
00:00009956 D402            	   412: 	ADD.b		d2,d2				; ; 2 bytes per size^2
                            	   413: 
00:00009958 0C460001        	   414: 	CMPI.w	#s_flag_off-p_flag_off,d6
                            	   415: 							; compare the player/saucer/shot index with the
                            	   416: 							; saucer
00:0000995C 6E10            	   417: 	BGT.s		no_add_size			; if shot index just go get the collision size
                            	   418: 
00:0000995E 6B0C            	   419: 	BMI.s		add_p_size			; if player index only add the player offset
                            	   420: 
00:00009960 083500016027    	   421: 	BTST.b	#1,p_flag_off(a5,d6.w)	; else test the saucer size flag
00:00009966 6702            	   422: 	BEQ.s		small_s_size		; if not size $02 only add the small saucer size
                            	   423: 
00:00009968 5042            	   424: 	ADDQ.w	#col_table_l-col_table_s,d2
                            	   425: 							; add the offset to the item + large saucer size
                            	   426: 							; table
                            	   427: small_s_size
00:0000996A 5042            	   428: 	ADDQ.w	#col_table_s-col_table_p,d2
                            	   429: 							; add the offset to the item + small saucer size
                            	   430: 							; table
                            	   431: add_p_size
00:0000996C 5042            	   432: 	ADDQ.w	#col_table_p-col_table,d2
                            	   433: 							; add the offset to the item + player size table
                            	   434: no_add_size
00:0000996E 343B200C        	   435: 	MOVE.w	col_table(pc,d2.w),d2	; get the collision size from the table
                            	   436: 
00:00009972 B440            	   437: 	CMP.w		d0,d2				; compare the distance^2 with the collision size
00:00009974 659C            	   438: 	BCS.s		check_next_object		; if it's out of range go try the next item
                            	   439: 
00:00009976 487AFF86        	   440: 	PEA		next_pss(pc)		; now go try the next fire item, this one died
00:0000997A 6020            	   441: 	BRA.s		handle_collision		; else go handle a collision between items
                            	   442: 
                            	   443: ; table of collision distance squares
                            	   444: 
                            	   445: col_table
00:0000997C 06E4            	   446: 	dc.w	$06E4			; $24^2		small rock, small saucer, player
00:0000997E 1440            	   447: 	dc.w	$1440			; $48^2		medium rock, large saucer
00:00009980 0000            	   448: 	dc.w	$0000			; no size 3 rock
00:00009982 4410            	   449: 	dc.w	$4410			; $84^2		large rock
                            	   450: col_table_p
00:00009984 1000            	   451: 	dc.w	$1000			; ($24 + $1C)^2	small rock  + player
00:00009986 2710            	   452: 	dc.w	$2710			; ($48 + $1C)^2	medium rock + player
00:00009988 0000            	   453: 	dc.w	$0000			; no size 3 rock
00:0000998A 6400            	   454: 	dc.w	$6400			; ($84 + $1C)^2	large rock  + player
                            	   455: col_table_s
00:0000998C 0B64            	   456: 	dc.w	$0B64			; ($24 + $12)^2	small rock  + small saucer
00:0000998E 1FA4            	   457: 	dc.w	$1FA4			; ($48 + $12)^2	medium rock + small saucer
00:00009990 0000            	   458: 	dc.w	$0000			; no size 3 rock
00:00009992 57E4            	   459: 	dc.w	$57E4			; ($84 + $12)^2	large rock  + small saucer
                            	   460: col_table_l
00:00009994 1440            	   461: 	dc.w	$1440			; ($24 + $24)^2	small rock  + large saucer
00:00009996 2D90            	   462: 	dc.w	$2D90			; ($48 + $24)^2	medium rock + large saucer
00:00009998 0000            	   463: 	dc.w	$0000			; no size 3 rock
00:0000999A 6E40            	   464: 	dc.w	$6E40			; ($84 + $24)^2	large rock  + large saucer
                            	   465: 
                            	   466: 
                            	   467: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   468: ;
                            	   469: ; handle collision between items
                            	   470: ;
                            	   471: ; d6 = X = player/saucer/shot index
                            	   472: ; d7 = Y = object index
                            	   473: 
                            	   474: handle_collision
00:0000999C 0C460001        	   475: 	CMPI.w	#s_flag_off-p_flag_off,d6
                            	   476: 							; compare the player/saucer/shot index with the
                            	   477: 							; saucer
00:000099A0 660A            	   478: 	BNE.s		not_saucer			; if not the saucer go find out what it was
                            	   479: 
                            	   480: 							; else the saucer hit something
00:000099A2 0C47001B        	   481: 	CMPI.w	#p_flag_off-flags_off,d7
                            	   482: 							; compare the object with the player index
00:000099A6 6612            	   483: 	BNE.s		not_player			; if not the player go find out what it was
                            	   484: 
                            	   485: 							; else the saucer hit the player so make it that
                            	   486: 							; the player hit the saucer
00:000099A8 7E1C            	   487: 	MOVEQ		#s_flag_off-flags_off,d7
                            	   488: 							; make the object the saucer
00:000099AA 7C00            	   489: 	MOVEQ		#p_flag_off-p_flag_off,d6
                            	   490: 							; make the player/saucer/shot index the player
                            	   491: not_saucer
00:000099AC 4A46            	   492: 	TST.w		d6				; test the player/saucer/shot index
00:000099AE 6622            	   493: 	BNE.s		not_pss_player		; if it's not the player go find out what it was
                            	   494: 
                            	   495: ; the player hit something
                            	   496: 
00:000099B0 1B7C0081007A    	   497: 	MOVE.b	#$81,hide_p_cnt(a5)	; set the hide the player count
00:000099B6 532D0082        	   498: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
                            	   499: 
                            	   500: ; either the player hit the saucer or the player or saucer hit either a rock or a shot
                            	   501: 
                            	   502: not_player
00:000099BA 1BBC00A06027    	   503: 	MOVE.b	#$A0,p_flag_off(a5,d6.w)
                            	   504: 							; set the item is exploding flag
00:000099C0 7000            	   505: 	MOVEQ		#0,d0				; clear the longword
00:000099C2 1B80604A        	   506: 	MOVE.b	d0,p_xvel_off(a5,d6.w)	; clear the player/saucer/shot x velocity
00:000099C6 1B80606D        	   507: 	MOVE.b	d0,p_yvel_off(a5,d6.w)	; clear the player/saucer/shot y velocity
00:000099CA 0C47001B        	   508: 	CMPI.w	#p_flag_off-flags_off,d7
                            	   509: 							; compare the object with the player index
00:000099CE 650E            	   510: 	BCS.s		what_hit_rock		; if less go handle something hitting a rock
                            	   511: 
00:000099D0 6038            	   512: 	BRA.s		what_hit_saucer		; else go handle something hitting the saucer
                            	   513: 
                            	   514: ; else a shot hit something
                            	   515: 
                            	   516: not_pss_player
00:000099D2 42356027        	   517: 	CLR.b		p_flag_off(a5,d6.w)	; clear the shot object
00:000099D6 0C07001B        	   518: 	CMPI.b	#p_flag_off-flags_off,d7
                            	   519: 							; compare the item with the player's index
00:000099DA 6722            	   520: 	BEQ.s		player_shot			; if it's the player go handle a shot hitting
                            	   521: 							; the player
                            	   522: 
00:000099DC 642C            	   523: 	BCC.s		what_hit_saucer		; if it's the saucer go handle a shot hitting
                            	   524: 							; the saucer
                            	   525: 
                            	   526: what_hit_rock
00:000099DE 61000C4C        	   527: 	BSR		hit_a_rock			; handle something hitting a rock
                            	   528: 
                            	   529: ; explode the object
                            	   530: 
                            	   531: explode_object
00:000099E2 7203            	   532: 	MOVEQ		#$03,d1			; set the mask for the two size bits
00:000099E4 C235700C        	   533: 	AND.b		flags_off(a5,d7.w),d1	; and it with the item flag
00:000099E8 5A01            	   534: 	ADDQ.b	#sexpl_snd,d1		; add the small explosion sound to the size
00:000099EA 61002BAC        	   535: 	BSR		play_sample			; go play the sample
                            	   536: 
00:000099EE 1BBC00A0700C    	   537: 	MOVE.b	#$A0,flags_off(a5,d7.w)	; set the item to exploding
00:000099F4 4235702F        	   538: 	CLR.b		x_vel_off(a5,d7.w)	; clear the item x velocity byte
00:000099F8 42357052        	   539: 	CLR.b		y_vel_off(a5,d7.w)	; clear the item y velocity byte
00:000099FC 4E75            	   540: 	RTS
                            	   541: 
                            	   542: ; handle a shot hitting the player
                            	   543: 
                            	   544: player_shot
00:000099FE 532D0082        	   545: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
00:00009A02 1B7C0081007A    	   546: 	MOVE.b	#$81,hide_p_cnt(a5)	; set the hide the player count
00:00009A08 60D8            	   547: 	BRA.s		explode_object		; go explode the player
                            	   548: 
                            	   549: ; handle something hitting the saucer
                            	   550: 
                            	   551: what_hit_saucer
00:00009A0A 1B6D00780077    	   552: 	MOVE.b	i_sauc_tim(a5),sauc_cntdn(a5)
                            	   553: 							; save the small saucer boundary/initial saucer
                            	   554: 							; value to the saucer countdown timer
00:00009A10 4A2B001A        	   555: 	TST.b		num_players(a3)		; test the number of players in the game
00:00009A14 67CC            	   556: 	BEQ.s		explode_object		; if no players skip adding the score
                            	   557: 
00:00009A16 7299            	   558: 	MOVEQ		#$99,d1			; default to 990 points for a small saucer
00:00009A18 082D00000028    	   559: 	BTST.b	#0,s_flag_off(a5)		; test the saucer size bit
00:00009A1E 6602            	   560: 	BNE.s		keep_small			; if it was a small saucer keep the score value
                            	   561: 
00:00009A20 7220            	   562: 	MOVEQ		#$20,d1			; else set 200 points for the large saucer
                            	   563: keep_small
00:00009A22 610009A8        	   564: 	BSR		add_score			; add d1 to the current player's score
00:00009A26 60BA            	   565: 	BRA.s		explode_object		; go explode the saucer
                            	   566: 
                            	   567: 
                            	   568: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   569: ;
                            	   570: ; handle the saucer
                            	   571: 
                            	   572: do_saucer
00:00009A28 70FC            	   573: 	MOVEQ		#-4,d0			; set the timeout counter mask
00:00009A2A C02B0025        	   574: 	AND.b		time_count(a3),d0		; mask the timeout counter
00:00009A2E 670000B0        	   575: 	BEQ		exit_do_saucer		; 3/4 of the time just exit
                            	   576: 
00:00009A32 B12B0025        	   577: 	EOR.b		d0,time_count(a3)		; reset the timeout counter
                            	   578: 
00:00009A36 4A2D0028        	   579: 	TST.b		s_flag_off(a5)		; test the saucer flag
00:00009A3A 6B0000A4        	   580: 	BMI		exit_do_saucer		; if the saucer is exploding just exit
                            	   581: 
00:00009A3E 660000A2        	   582: 	BNE		existing_saucer		; if a saucer exists go handle it
                            	   583: 
                            	   584: ; no saucer exists so possibly generate a new one
                            	   585: 
00:00009A42 4A2B001A        	   586: 	TST.b		num_players(a3)		; test the number of players in the game
00:00009A46 670C            	   587: 	BEQ.s		attract_saucer		; if no players go do the attract mode saucer
                            	   588: 
00:00009A48 4A2D0027        	   589: 	TST.b		p_flag_off(a5)		; test the player flag
00:00009A4C 67000092        	   590: 	BEQ		exit_do_saucer		; if this player doesn't exist just exit
                            	   591: 
00:00009A50 6B00008E        	   592: 	BMI		exit_do_saucer		; if this player is exploding just exit
                            	   593: 
                            	   594: attract_saucer
00:00009A54 4A2D0079        	   595: 	TST.b		r_hit_tim(a5)		; test the rock hit timer
00:00009A58 6704            	   596: 	BEQ.s		rock_hit_out		; if counted out skip the decrement
                            	   597: 
00:00009A5A 532D0079        	   598: 	SUBQ.b	#1,r_hit_tim(a5)		; else decrement the rock hit timer
                            	   599: rock_hit_out
00:00009A5E 532D0077        	   600: 	SUBQ.b	#1,sauc_cntdn(a5)		; decrement the saucer countdown timer
00:00009A62 667C            	   601: 	BNE		exit_do_saucer		; if not there yet just exit
                            	   602: 
00:00009A64 1B7C00120077    	   603: 	MOVE.b	#$12,sauc_cntdn(a5)	; set the first saucer fire count
                            	   604: 
00:00009A6A 4A2D0079        	   605: 	TST.b		r_hit_tim(a5)		; test the rock hit timer
00:00009A6E 670C            	   606: 	BEQ.s		dec_isaucer_time		; if timed out go decrement the initial saucer
                            	   607: 							; timer
                            	   608: 
00:00009A70 102D0076        	   609: 	MOVE.b	rock_count(a5),d0		; get the rock count
00:00009A74 676A            	   610: 	BEQ.s		exit_do_saucer		; if no rocks just exit
                            	   611: 
00:00009A76 B02D007D        	   612: 	CMP.b		min_rocks(a5),d0		; compare the rock count with the minimum rock
                            	   613: 							; count before the saucer initial timer starts
                            	   614: 							; to decrement
00:00009A7A 6364            	   615: 	BLS.s		exit_do_saucer		; if the minimum rock count is >= the rock count
                            	   616: 							; just exit
                            	   617: 
                            	   618: dec_isaucer_time
00:00009A7C 70FA            	   619: 	MOVEQ		#-6,d0			; set to subtract 6
00:00009A7E D02D0078        	   620: 	ADD.b		i_sauc_tim(a5),d0		; subtract it from the small saucer
                            	   621: 							; boundary/initial saucer timer
00:00009A82 0C000020        	   622: 	CMPI.b	#$20,d0			; compare it with the minimum value
00:00009A86 6504            	   623: 	BCS.s		no_save_ist			; if less skip the save
                            	   624: 
00:00009A88 1B400078        	   625: 	MOVE.b	d0,i_sauc_tim(a5)		; save the small saucer boundary/initial saucer
                            	   626: 							; timer
                            	   627: no_save_ist
00:00009A8C 61000F6C        	   628: 	BSR		gen_prng			; generate the next pseudo random number
00:00009A90 302B000A        	   629: 	MOVE.w	PRNlword(a3),d0		; get a pseudo random word
00:00009A94 0C401800        	   630: 	CMPI.w	#$1800,d0			; compare with $1800
00:00009A98 6504            	   631: 	BCS.s		saucer_yok			; if less than $1800 just use it
                            	   632: 
00:00009A9A 024017FF        	   633: 	ANDI.w	#$17FF,d0			; else mask to $17xx
                            	   634: saucer_yok
00:00009A9E 3B40FFFE        	   635: 	MOVE.w	d0,s_ypos_off(a5)		; save the saucer y position
                            	   636: 
00:00009AA2 7000            	   637: 	MOVEQ		#0,d0				; clear the saucer x position
00:00009AA4 7210            	   638: 	MOVEQ		#$10,d1			; set the saucer x velocity to + $10
00:00009AA6 4A6B000C        	   639: 	TST.w		PRNlword+2(a3)		; test a pseudo random word
00:00009AAA 6B06            	   640: 	BMI.s		start_left			; if bit set start on the left
                            	   641: 
                            	   642: 							; else start at the right side and move left
00:00009AAC 303C1FFF        	   643: 	MOVE.w	#$1FFF,d0			; set the saucer x position
00:00009AB0 72F0            	   644: 	MOVEQ		#$F0,d1			; set the saucer x velocity to - $10
                            	   645: start_left
00:00009AB2 1B41004B        	   646: 	MOVE.b	d1,s_xvel_off(a5)		; save the saucer x velocity byte
00:00009AB6 3B40FFB8        	   647: 	MOVE.w	d0,s_xpos_off(a5)		; save the saucer x position
                            	   648: 
00:00009ABA 7202            	   649: 	MOVEQ		#$02,d1			; default to a large saucer
00:00009ABC 4A2D0078        	   650: 	TST.b		i_sauc_tim(a5)		; test the small saucer boundary/initial saucer
                            	   651: 							; timer
00:00009AC0 6B1A            	   652: 	BMI.s		save_saucer			; if > $80 always make a big saucer
                            	   653: 
00:00009AC2 0C2D00300080    	   654: 	CMPI.b	#$30,score_off(a5)	; compare the player's score with 30000 points
00:00009AC8 6410            	   655: 	BCC.s		small_saucer		; if >= 30000 points go make a small saucer
                            	   656: 
00:00009ACA 61000F2E        	   657: 	BSR		gen_prng			; generate the next pseudo random number
00:00009ACE 142D0078        	   658: 	MOVE.b	i_sauc_tim(a5),d2		; get the small saucer boundary/initial saucer
                            	   659: 							; timer
00:00009AD2 E20A            	   660: 	LSR.b		#1,d2				; / 2
00:00009AD4 B42B000C        	   661: 	CMP.b		PRNlword+2(a3),d2		; compare it with the random byte
00:00009AD8 6402            	   662: 	BCC.s		save_saucer			; if the small saucer boundary is > the random
                            	   663: 							; byte go save the large saucer
                            	   664: 
                            	   665: small_saucer
00:00009ADA 7201            	   666: 	MOVEQ		#$01,d1			; else make it a small saucer
                            	   667: save_saucer
00:00009ADC 1B410028        	   668: 	MOVE.b	d1,s_flag_off(a5)		; save the saucer flag
                            	   669: exit_do_saucer
00:00009AE0 4E75            	   670: 	RTS
                            	   671: 
                            	   672: ; there is an existing saucer
                            	   673: 
                            	   674: existing_saucer
00:00009AE2 707E            	   675: 	MOVEQ		#$7E,d0			; set saucer change mask
00:00009AE4 C06B0059        	   676: 	AND.w		game_count(a3),d0		; mask the game counter
00:00009AE8 6610            	   677: 	BNE.s		keep_saucer_dir		; if it was not x000 000x skip the saucer
                            	   678: 							; direction change
                            	   679: 
00:00009AEA 61000F0E        	   680: 	BSR		gen_prng			; generate the next pseudo random number
00:00009AEE 7003            	   681: 	MOVEQ		#3,d0				; set the direction mask
00:00009AF0 C02B000A        	   682: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:00009AF4 1B7B0018006E    	   683: 	MOVE.b	saucer_yvel(pc,d0.w),s_yvel_off(a5)
                            	   684: 							; save the saucer y velocity byte
                            	   685: keep_saucer_dir
00:00009AFA 4A2B001A        	   686: 	TST.b		num_players(a3)		; test the number of players in the game
00:00009AFE 6706            	   687: 	BEQ.s		attract_fire		; if no players just go do the fire countdown
                            	   688: 
00:00009B00 4A2D007A        	   689: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:00009B04 6606            	   690: 	BNE.s		exit_existing_saucer	; if the player is hidden just exit
                            	   691: 
                            	   692: attract_fire
00:00009B06 532D0077        	   693: 	SUBQ.b	#1,sauc_cntdn(a5)		; decrement the saucer countdown timer
00:00009B0A 6706            	   694: 	BEQ.s		fire_saucer			; if counted out go fire
                            	   695: 
                            	   696: exit_existing_saucer
00:00009B0C 4E75            	   697: 	RTS
                            	   698: 
                            	   699: ; saucer y velocity byte
                            	   700: 
                            	   701: saucer_yvel
00:00009B0E F0              	   702: 	dc.b	$F0			; down
00:00009B0F 00              	   703: 	dc.b	$00			; horizontal
00:00009B10 00              	   704: 	dc.b	$00			; horizontal
00:00009B11 10              	   705: 	dc.b	$10			; up
                            	   706: 
                            	   707: 
                            	   708: ; handle the saucer fire
                            	   709: 
                            	   710: fire_saucer
00:00009B12 1B7C000A0077    	   711: 	MOVE.b	#$0A,sauc_cntdn(a5)	; set the time between saucer shots, save the
                            	   712: 							; countdown timer
00:00009B18 7001            	   713: 	MOVEQ		#1,d0				; set the mask for a small saucer
00:00009B1A C02D0028        	   714: 	AND.b		s_flag_off(a5),d0		; mask the saucer flag
00:00009B1E 660A            	   715: 	BNE.s		aim_shot			; if it's a small saucer go aim at the player
                            	   716: 
00:00009B20 61000ED8        	   717: 	BSR		gen_prng			; generate the next pseudo random number
00:00009B24 102B000A        	   718: 	MOVE.b	PRNlword(a3),d0		; get a pseudo random byte
00:00009B28 6056            	   719: 	BRA.s		no_aim_shot			; and go fire wildly in any direction
                            	   720: 
                            	   721: ; aim the shot at the player
                            	   722: 
                            	   723: aim_shot
00:00009B2A 1F2D004B        	   724: 	MOVE.b	s_xvel_off(a5),-(sp)	; copy the saucer x velocity byte
00:00009B2E 301F            	   725: 	MOVE.w	(sp)+,d0			; get the byte as a word
00:00009B30 4200            	   726: 	CLR.b		d0				; clear the low byte
00:00009B32 E240            	   727: 	ASR.w		#1,d0				; / 2
                            	   728: 
00:00009B34 322DFFB6        	   729: 	MOVE.w	p_xpos_off(a5),d1		; get the player x position
00:00009B38 926DFFB8        	   730: 	SUB.w		s_xpos_off(a5),d1		; subtract the saucer x position
00:00009B3C E541            	   731: 	ASL.w		#2,d1				; ; 4 delta x
                            	   732: 
00:00009B3E 9240            	   733: 	SUB.w		d0,d1				; subtract the half saucer x velocity word
                            	   734: 
00:00009B40 1F2D006E        	   735: 	MOVE.b	s_yvel_off(a5),-(sp)	; copy the saucer y velocity byte
00:00009B44 301F            	   736: 	MOVE.w	(sp)+,d0			; get the byte as a word
00:00009B46 4200            	   737: 	CLR.b		d0				; clear the low byte
00:00009B48 E240            	   738: 	ASR.w		#1,d0				; / 2
                            	   739: 
00:00009B4A 342DFFFC        	   740: 	MOVE.w	p_ypos_off(a5),d2		; get the player y position
00:00009B4E 946DFFFE        	   741: 	SUB.w		s_ypos_off(a5),d2		; subtract the saucer y position
00:00009B52 E542            	   742: 	ASL.w		#2,d2				; ; 4 delta x low byte
                            	   743: 
00:00009B54 9440            	   744: 	SUB.w		d0,d2				; subtract the half saucer y velocity word
                            	   745: 
00:00009B56 61000BF0        	   746: 	BSR		get_atn			; calculate the angle given the delta x,y in
                            	   747: 							; d1.w,d2.w
00:00009B5A 1740001F        	   748: 	MOVE.b	d0,s_orient(a3)		; save the saucer shot direction
                            	   749: 
00:00009B5E 61000E9A        	   750: 	BSR		gen_prng			; generate the next pseudo random number
00:00009B62 7200            	   751: 	MOVEQ		#0,d1				; set index to +/- $0F degree units perturbation
00:00009B64 102B000A        	   752: 	MOVE.b	PRNlword(a3),d0		; get a pseudo random byte
00:00009B68 0C2D00350080    	   753: 	CMPI.b	#$35,score_off(a5)	; compare the player's score with 35000
00:00009B6E 6502            	   754: 	BCS.s		wide_shot			; if less than 35000 skip the index change
                            	   755: 
00:00009B70 7201            	   756: 	MOVEQ		#1,d1				; set index to +/- $07 degree units perturbation
                            	   757: wide_shot
00:00009B72 C03B101E        	   758: 	AND.b		shot_mask(pc,d1.w),d0	; mask with the shot AND mask
00:00009B76 6A04            	   759: 	BPL.s		no_shot_or			; if the result is positive skip the bit set
                            	   760: 
00:00009B78 803B101A        	   761: 	OR.b		shot_or(pc,d1.w),d0	; else set the correct bits for a negative
                            	   762: 							; perturbation
                            	   763: no_shot_or
00:00009B7C D02B001F        	   764: 	ADD.b		s_orient(a3),d0		; add the saucer shot direction to the
                            	   765: 							; perturbation
                            	   766: no_aim_shot
00:00009B80 1740001F        	   767: 	MOVE.b	d0,s_orient(a3)		; save the saucer shot direction
                            	   768: 
00:00009B84 7801            	   769: 	MOVEQ		#1,d4				; set the index to the saucer velocity
00:00009B86 7A02            	   770: 	MOVEQ		#2,d5				; set the index to the saucer position
00:00009B88 7CFF            	   771: 	MOVEQ		#-1,d6			; set the minimum shot index - 1
00:00009B8A 7E01            	   772: 	MOVEQ		#1,d7				; set the shot start index
                            	   773: 
00:00009B8C 122B0021        	   774: 	MOVE.b	last_fire(a3),d1		; get the fire last state
00:00009B90 6022            	   775: 	BRA.s		test_fire_loop		; go fire the shot
                            	   776: 
                            	   777: 
                            	   778: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   779: ;
                            	   780: ; these two byte pairs together effect the accuracy of the small saucer's shooting
                            	   781: ; by limiting the range of the random perturbation to the saucer's aim
                            	   782: 
                            	   783: ; shot AND mask, masks the perturbation to either +/- $0F or +/- $07 degree units
                            	   784: 
                            	   785: shot_mask
00:00009B92 8F              	   786: 	dc.b	$8F			; AND mask to +/- $0F degree units
00:00009B93 87              	   787: 	dc.b	$87			; AND mask to +/- $07 degree units
                            	   788: 
                            	   789: ; shot OR byte, sets the needed bits for a negative perturbation result
                            	   790: 
                            	   791: shot_or
00:00009B94 70              	   792: 	dc.b	$70			; OR to set bits after - $0F mask result
00:00009B95 78              	   793: 	dc.b	$78			; OR to set bits after - $07 mask result
                            	   794: 
                            	   795: 
                            	   796: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   797: ;
                            	   798: ; handle the fire button
                            	   799: 
                            	   800: ship_fire:
                            	   801: ;##	TST.b		num_players(a3)		; test the number of players in the game
                            	   802: ;##	BEQ.s		exit_ship_fire		; if no players just exit
                            	   803: 
                            	   804: ;##	TST.b		hide_p_cnt(a5)		; test the hide the player count
                            	   805: ;##	BNE.s		exit_ship_fire		; if the player is hidden just exit
                            	   806: 
                            	   807: ;	MOVEQ		#'P',d1			; [P] key
                            	   808: ;	MOVEQ		#19,d0			; check for keypress
                            	   809: ;	TRAP		#15
                            	   810: 
00:00009B96 7005            	   811: 	moveq #5,d0					; getkey
00:00009B98 4E4F            	   812: 	trap #15
00:00009B9A 0C010050        	   813: 	cmpi.b #'P',d1
00:00009B9E 6620            	   814: 	bne.s save_ship_fire
                            	   815: 
                            	   816: ;	TST.b		d1				; test the result
                            	   817: ;	BEQ.s		save_ship_fire		; if fire not pressed go clear the fire state
                            	   818: 							; and exit
                            	   819: 
00:00009BA0 4A2B0021        	   820: 	tst.b last_fire(a3)		; test the fire last state
00:00009BA4 661E            	   821: 	bne.s exit_ship_fire	; if the fire button is held just exit
                            	   822: 
00:00009BA6 7800            	   823: 	moveq #0,d4					; set the index to the player velocity
00:00009BA8 7A00            	   824: 	moveq #0,d5					; set the index to the player position
00:00009BAA 7C01            	   825: 	moveq #1,d6					; set the minimum shot index - 1
00:00009BAC 7E05            	   826: 	moveq #5,d7					; set the shot start index
                            	   827: 
00:00009BAE 176B001E001F    	   828: 	move.b p_orient(a3),s_orient(a3)
                            	   829: 							; copy the player orientation
                            	   830: 
                            	   831: ; fire the shot, player or saucer
                            	   832: 
                            	   833: test_fire_loop
00:00009BB4 4A357029        	   834: 	tst.b s_fire_off(a5,d7.w)	; test this fire object
00:00009BB8 670C            	   835: 	beq.s fire_shot			; if this shot is free go use it
                            	   836: 
00:00009BBA 5347            	   837: 	subq.w #1,d7				; decrement the shot index
00:00009BBC BC47            	   838: 	cmp.w d7,d6					; compare with minimum - 1 index
00:00009BBE 66F4            	   839: 	bne.s test_fire_loop		; loop if more to do
                            	   840: 
                            	   841: save_ship_fire
00:00009BC0 17410021        	   842: 	move.b d1,last_fire(a3)		; save the fire last state
                            	   843: exit_ship_fire
00:00009BC4 4E75            	   844: 	rts
                            	   845: 
                            	   846: ; player/saucer fired and a shot, indexed by d7, is free
                            	   847: 
                            	   848: fire_shot:
00:00009BC6 3C07            	   849: 	move.w d7,d6				; copy the item index
00:00009BC8 DC46            	   850: 	add.w d6,d6					; 2 for position index
                            	   851: 
00:00009BCA 1BBC00127029    	   852: 	MOVE.b	#$12,s_fire_off(a5,d7.w)
                            	   853: 							; set the fire item flag
                            	   854: 
00:00009BD0 102B001F        	   855: 	MOVE.b	s_orient(a3),d0		; get the player/saucer orientation
00:00009BD4 61000C1A        	   856: 	BSR		cos_d0			; do COS(d0)
                            	   857: 
00:00009BD8 1635404A        	   858: 	MOVE.b	p_xvel_off(a5,d4.w),d3	; get the player/saucer x velocity byte
00:00009BDC 613A            	   859: 	BSR.s		calc_fire_byte		; test the fire velocity and make 3/4 sin/cos
00:00009BDE 1B83704C        	   860: 	MOVE.b	d3,f_xvel_off(a5,d7.w)	; save the shot x velocity byte
                            	   861: 
00:00009BE2 D07550B6        	   862: 	ADD.w		p_xpos_off(a5,d5.w),d0	; add the player/saucer x position
00:00009BE6 3B8060BA        	   863: 	MOVE.w	d0,f_xpos_off(a5,d6.w)	; save the shot x position
                            	   864: 
00:00009BEA 102B001F        	   865: 	MOVE.b	s_orient(a3),d0		; get the player/saucer orientation
00:00009BEE 61000C04        	   866: 	BSR		sin_d0			; do SIN(d0)
                            	   867: 
00:00009BF2 1635406D        	   868: 	MOVE.b	p_yvel_off(a5,d4.w),d3	; get the player/saucer y velocity byte
00:00009BF6 6120            	   869: 	BSR		calc_fire_byte		; test the fire velocity and make 3/4 sin/cos
00:00009BF8 1B83706F        	   870: 	MOVE.b	d3,f_yvel_off(a5,d7.w)	; save the shot y velocity byte
                            	   871: 
00:00009BFC D07550FC        	   872: 	ADD.w		p_ypos_off(a5,d5.w),d0	; add the player/saucer y position
00:00009C00 3B806000        	   873: 	MOVE.w	d0,f_ypos_off(a5,d6.w)	; save the shot y position
                            	   874: 
00:00009C04 17410021        	   875: 	MOVE.b	d1,last_fire(a3)		; save the fire last state
                            	   876: 
00:00009C08 7201            	   877: 	MOVEQ		#pfire_snd,d1		; default to the player fire sound
00:00009C0A 0C470002        	   878: 	CMPI.w	#2,d7				; compare the index with the lowest player fire
00:00009C0E 64002988        	   879: 	BCC		play_sample			; if it was the player go play the sample and
                            	   880: 							; return
                            	   881: 
                            	   882: 							; else it must be the saucer that fired so
00:00009C12 7200            	   883: 	MOVEQ		#sfire_snd,d1		; set the saucer fire sound
00:00009C14 60002982        	   884: 	BRA		play_sample			; play the sample and return
                            	   885: 
                            	   886: 
                            	   887: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   888: ;
                            	   889: ; test the fire velocity and make 3/4 sin/cos
                            	   890: 
                            	   891: calc_fire_byte
00:00009C18 E240            	   892: 	ASR.w		#1,d0				; / 2
                            	   893: 
00:00009C1A 3F00            	   894: 	MOVE.w	d0,-(sp)			; push the word value
00:00009C1C 101F            	   895: 	MOVE.b	(sp)+,d0			; pop it as a byte value
                            	   896: 
00:00009C1E D600            	   897: 	ADD.b		d0,d3				; add it to the COS / 2 value
00:00009C20 6B0A            	   898: 	BMI.s		test_neg_fire		; if negative go test the negative limit
                            	   899: 
00:00009C22 0C030070        	   900: 	CMPI.b	#$70,d3			; else compare it with the positive limit
00:00009C26 650C            	   901: 	BCS.s		fire_ok			; if < the positive limit skip the adjust
                            	   902: 
00:00009C28 766F            	   903: 	MOVEQ		#$6F,d3			; else set the value to the positive limit
00:00009C2A 6008            	   904: 	BRA.s		fire_ok			; go save the shot x velocity
                            	   905: 
                            	   906: test_neg_fire
00:00009C2C 0C030091        	   907: 	CMPI.b	#$91,d3			; compare it with the negative limit
00:00009C30 6402            	   908: 	BCC.s		fire_ok			; if < the negative limit skip the adjust
                            	   909: 
00:00009C32 7691            	   910: 	MOVEQ		#$91,d3			; else set the value to the negative limit
                            	   911: fire_ok
00:00009C34 4880            	   912: 	EXT.w		d0				; make the byte value into a word
                            	   913: 
00:00009C36 3400            	   914: 	MOVE.w	d0,d2				; get the COS / 2 back
00:00009C38 E242            	   915: 	ASR.w		#1,d2				; / 4
00:00009C3A D142            	   916: 	ADDX.w	d2,d0				; make 3 / 4 COS and round up
                            	   917: 
00:00009C3C 4E75            	   918: 	RTS
                            	   919: 
                            	   920: 
                            	   921: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   922: ;
                            	   923: ; get the player high score entries
                            	   924: 
                            	   925: enter_hiscores
00:00009C3E 102D0083        	   926: 	MOVE.b	high_off(a5),d0		; get the player 1 highscore flag
00:00009C42 C02E0083        	   927: 	AND.b		high_off(a6),d0		; and with the player 2 highscore flag
00:00009C46 6B00014A        	   928: 	BMI		exit_enter_hiscores	; if neither player is entering their high
                            	   929: 							; score just exit
                            	   930: 
00:00009C4A 102D0083        	   931: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:00009C4E 6B000088        	   932: 	BMI		next_p_high			; if this player isn't entering their high
                            	   933: 							; score go try the other player
                            	   934: 
                            	   935: 							; get a player high score entry
00:00009C52 0C2B00010019    	   936: 	CMPI.b	#1,past_play(a3)		; compare 1 with the number of players that
                            	   937: 							; were in the game
00:00009C58 6712            	   938: 	BEQ.s		no_playerx			; if it was only 1 player skip the "PLAYER x"
                            	   939: 							; message
                            	   940: 
00:00009C5A 7201            	   941: 	MOVEQ		#1,d1				; message 1 - "PLAYER "
00:00009C5C 61000C32        	   942: 	BSR		add_message			; add message d1 to the display list
                            	   943: 
00:00009C60 7010            	   944: 	MOVEQ		#$10,d0			; set game counter mask
00:00009C62 C06B0059        	   945: 	AND.w		game_count(a3),d0		; mask the game counter
00:00009C66 6604            	   946: 	BNE.s		no_playerx			; if bit set skip the player number write
                            	   947: 
00:00009C68 61000C98        	   948: 	BSR		player_n			; add the player number to the vector list
                            	   949: no_playerx
00:00009C6C 7202            	   950: 	MOVEQ		#2,d1				; message 2 - "YOUR SCORE IS ONE OF THE TE..."
00:00009C6E 61000C20        	   951: 	BSR		add_message			; add message d1 to the display list
00:00009C72 7203            	   952: 	MOVEQ		#3,d1				; message 3 - "PLEASE ENTER YOUR INITIALS"
00:00009C74 61000C1A        	   953: 	BSR		add_message			; add message d1 to the display list
00:00009C78 7204            	   954: 	MOVEQ		#4,d1				; message 4 - "PUSH ROTATE TO SELECT LETTER"
00:00009C7A 61000C14        	   955: 	BSR		add_message			; add message d1 to the display list
00:00009C7E 7205            	   956: 	MOVEQ		#5,d1				; message 5 - "PUSH HYPERSPACE WHEN LETTER..."
00:00009C80 61000C0E        	   957: 	BSR		add_message			; add message d1 to the display list
                            	   958: 
00:00009C84 36BC2000        	   959: 	MOVE.w	#$2000,glob_scale(a3)	; set the global scale
                            	   960: 
00:00009C88 7264            	   961: 	MOVEQ		#$64,d1			; set the x co-ordinate
00:00009C8A 7439            	   962: 	MOVEQ		#$39,d2			; set the y co-ordinate
00:00009C8C 61000CB8        	   963: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	   964: 							; a draw command
                            	   965: 
00:00009C90 323C7000        	   966: 	MOVE.w	#REL7,d1			; make a $7000,$0000 command
00:00009C94 61000CCA        	   967: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	   968: 
00:00009C98 7000            	   969: 	MOVEQ		#0,d0				; clear the longword
00:00009C9A 102D0083        	   970: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:00009C9E 41F3003B        	   971: 	LEA		hinames(a3,d0.w),a0	; point to the high score names
                            	   972: 
00:00009CA2 610001AA        	   973: 	BSR		write_initial		; write a high score initial to the vector list
00:00009CA6 610001A6        	   974: 	BSR		write_initial		; write a high score initial to the vector list
00:00009CAA 610001A2        	   975: 	BSR		write_initial		; write a high score initial to the vector list
                            	   976: 
                            	   977: ;	MOVEQ		#' ',d1			; [SPACE] key
                            	   978: ;	MOVEQ		#19,d0			; check for keypress
                            	   979: ;	TRAP		#15
00:00009CAE 7005            	   980: 	moveq #5,d0
00:00009CB0 4E4F            	   981: 	trap #15
00:00009CB2 4A81            	   982: 	tst.l d1
00:00009CB4 6B6E            	   983: 	bmi.s save_hbutton
00:00009CB6 0C010020        	   984: 	cmpi.b #' ',d1
00:00009CBA 6668            	   985: 	bne.s save_hbutton
                            	   986: 
                            	   987: ;	TST.b		d1				; test the result
                            	   988: ;	BEQ.s		save_hbutton		; if hyperspace not pressed go save the state
                            	   989: 
00:00009CBC 4A2B0022        	   990: 	TST.b		last_hype(a3)		; test the hyperspace last state
00:00009CC0 6662            	   991: 	BNE.s		save_hbutton		; if hyperspace is held go save the state
                            	   992: 
                            	   993: ; the hyperspace button has just been pressed
                            	   994: 
00:00009CC2 522B0020        	   995: 	ADDQ.b	#1,hi_char(a3)		; increment the input character index
00:00009CC6 0C2B00030020    	   996: 	CMPI.b	#3,hi_char(a3)		; compare with end + 1
00:00009CCC 653E            	   997: 	BCS.s		next_hi_char		; if not there yet go and increment to the next
                            	   998: 							; character
                            	   999: 
                            	  1000: 							; else that was the last character
00:00009CCE 17410022        	  1001: 	MOVE.b	d1,last_hype(a3)		; save the hyperspace last state
00:00009CD2 1B7C00FF0083    	  1002: 	MOVE.b	#$FF,high_off(a5)		; clear the player highscore flag
                            	  1003: next_p_high
00:00009CD8 7000            	  1004: 	MOVEQ		#0,d0				; clear the longword
00:00009CDA 17400020        	  1005: 	MOVE.b	d0,hi_char(a3)		; clear the input character index
                            	  1006: 
00:00009CDE 43FA29CA        	  1007: 	LEA		filename(pc),a1		; point to the highscore filename
00:00009CE2 7034            	  1008: 	MOVEQ		#52,d0			; open new file
00:00009CE4 4E4F            	  1009: 	TRAP		#15
                            	  1010: 
00:00009CE6 4A40            	  1011: 	TST.w		d0				; check for errors
00:00009CE8 660A            	  1012: 	BNE.s		close_all			; if error go close all files
                            	  1013: 
00:00009CEA 43EB0027        	  1014: 	LEA		hiscores(a3),a1		; point to the highscore tables
00:00009CEE 7432            	  1015: 	MOVEQ		#50,d2			; set the table length
00:00009CF0 7036            	  1016: 	MOVEQ		#54,d0			; write file
00:00009CF2 4E4F            	  1017: 	TRAP		#15
                            	  1018: 
                            	  1019: close_all
00:00009CF4 7032            	  1020: 	MOVEQ		#50,d0			; close all files
00:00009CF6 4E4F            	  1021: 	TRAP		#15
                            	  1022: 
00:00009CF8 17400018        	  1023: 	MOVE.b	d0,player_idx(a3)		; clear the player index
00:00009CFC 4BEB00F3        	  1024: 	LEA		player_1(a3),a5		; get the pointer to player one's variables
00:00009D00 4DEB01F7        	  1025: 	LEA		player_2(a3),a6		; get the pointer to player two's variables
                            	  1026: 
00:00009D04 177C00F00059    	  1027: 	MOVE.b	#$F0,game_count(a3)	; set the game counter high byte, high score
                            	  1028: 							; entry timeout
00:00009D0A 4E75            	  1029: 	RTS
                            	  1030: 
                            	  1031: ; hyperspace button press accepted and not at initials end
                            	  1032: 
                            	  1033: next_hi_char
00:00009D0C 177C00F40059    	  1034: 	MOVE.b	#$F4,game_count(a3)	; set the game counter high byte, high score
                            	  1035: 							; entry timeout
                            	  1036: 
00:00009D12 7000            	  1037: 	MOVEQ		#0,d0				; clear the longword
00:00009D14 102D0083        	  1038: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:00009D18 D02B0020        	  1039: 	ADD.b		hi_char(a3),d0		; add the input character index
00:00009D1C 41F3003B        	  1040: 	LEA		hinames(a3,d0.w),a0	; point to the high score names
00:00009D20 10BC000B        	  1041: 	MOVE.b	#$0B,(a0)			; set the next character to "A"
                            	  1042: save_hbutton
00:00009D24 17410022        	  1043: 	MOVE.b	d1,last_hype(a3)		; save the hyperspace button last state
                            	  1044: 
00:00009D28 4A2B0059        	  1045: 	TST.b		game_count(a3)		; test the game counter high byte
00:00009D2C 660C            	  1046: 	BNE.s		not_timed_out		; if not timed out just continue
                            	  1047: 
00:00009D2E 70FF            	  1048: 	MOVEQ		#-1,d0			; flag high score done
00:00009D30 1B400083        	  1049: 	MOVE.b	d0,high_off(a5)		; clear the player 1 highscore flag
00:00009D34 1D400083        	  1050: 	MOVE.b	d0,high_off(a6)		; clear the player 2 highscore flag
00:00009D38 609E            	  1051: 	BRA.s		next_p_high			; go save the entry end exit, branch always
                            	  1052: 
                            	  1053: not_timed_out
00:00009D3A 70F8            	  1054: 	MOVEQ		#-8,d0			; set the timeout counter mask
00:00009D3C C02B0025        	  1055: 	AND.b		time_count(a3),d0		; mask the timeout counter
00:00009D40 674E            	  1056: 	BEQ.s		exit_not_done		; just exit 7/8ths of the time
                            	  1057: 
00:00009D42 B12B0025        	  1058: 	EOR.b		d0,time_count(a3)		; reset the timeout counter
                            	  1059: 
00:00009D46 7400            	  1060: 	MOVEQ		#0,d2				; assume no rotate
                            	  1061: ;	MOVE.w	#'WQ',d1			; [WQ] keys
                            	  1062: ;	MOVEQ		#19,d0			; check for keypress
                            	  1063: ;	TRAP		#15
00:00009D48 7005            	  1064: 	moveq #5,d0
00:00009D4A 4E4F            	  1065: 	trap #15
00:00009D4C 0C010051        	  1066: 	cmpi.b #'Q',d1
00:00009D50 6604            	  1067: 	bne.s not_rot_left
00:00009D52 7401            	  1068: 	moveq #1,d2
00:00009D54 6008            	  1069: 	bra.s was_rot_left
                            	  1070: not_rot_left:
00:00009D56 0C010057        	  1071: 	cmpi.b #'W',d1
00:00009D5A 6602            	  1072: 	bne.s not_rot_right2
00:00009D5C 5302            	  1073: 	subq.b #1,d2	
                            	  1074: 
                            	  1075: ;	TST.b		d1				; test the result
                            	  1076: ;	BPL.s		rot_not_left		; if not pressed go test rotate right
                            	  1077: ;
                            	  1078: ;	MOVEQ		#1,d2				; if pressed set the offset to + 1
                            	  1079: rot_not_left
                            	  1080: ;	TST.w		d1				; test the result
                            	  1081: ;	BPL.s		rot_not_right		; if not pressed go add the rotation
                            	  1082: 
                            	  1083: ;	SUBQ.b	#1,d2				; if pressed set the offset to - 1
                            	  1084: not_rot_right2
                            	  1085: was_rot_left:
00:00009D5E 7000            	  1086: 	MOVEQ		#0,d0				; clear the longword
00:00009D60 102D0083        	  1087: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:00009D64 D02B0020        	  1088: 	ADD.b		hi_char(a3),d0		; add the input character index
00:00009D68 D433003B        	  1089: 	ADD.b		hinames(a3,d0.w),d2	; add the character to the offset
00:00009D6C 6B14            	  1090: 	BMI.s		wrap_to_z			; if negative go set "Z"
                            	  1091: 
00:00009D6E 0C02000B        	  1092: 	CMPI.b	#$0B,d2			; compare with "A"
00:00009D72 6410            	  1093: 	BCC.s		check_alpha			; if >= "A" go test for <= "Z"
                            	  1094: 
00:00009D74 0C020001        	  1095: 	CMPI.b	#$01,d2			; compare with "0"
00:00009D78 6704            	  1096: 	BEQ.s		wrap_to_a			; if "0" go set to "A"
                            	  1097: 
                            	  1098: 							; gets here if it was "2" to "9"
00:00009D7A 7400            	  1099: 	MOVEQ		#0,d2				; else set to " "
00:00009D7C 600E            	  1100: 	BRA.s		save_char			; go save the new character
                            	  1101: 
                            	  1102: wrap_to_a
00:00009D7E 740B            	  1103: 	MOVEQ		#$0B,d2			; set to "A"
00:00009D80 600A            	  1104: 	BRA.s		save_char			; go save the new character
                            	  1105: 
                            	  1106: wrap_to_z
00:00009D82 7424            	  1107: 	MOVEQ		#$24,d2			; set to "Z"
                            	  1108: check_alpha
00:00009D84 0C020025        	  1109: 	CMPI.b	#$25,d2			; compare with "Z" + 1
00:00009D88 6502            	  1110: 	BCS.s		save_char			; if less skip the reset
                            	  1111: 
00:00009D8A 7400            	  1112: 	MOVEQ		#0,d2				; else reset it to " "
                            	  1113: save_char
00:00009D8C 1782003B        	  1114: 	MOVE.b	d2,hinames(a3,d0.w)	; save the new character
                            	  1115: exit_not_done
00:00009D90 7000            	  1116: 	MOVEQ		#0,d0				; flag high score not complete
                            	  1117: exit_enter_hiscores
00:00009D92 4E75            	  1118: 	RTS
                            	  1119: 
                            	  1120: 
                            	  1121: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1122: ;
                            	  1123: ; handle the hyperspace button
                            	  1124: 
                            	  1125: hyperspace
                            	  1126: ;##	TST.b		num_players(a3)		; test the number of players in the game
                            	  1127: ;##	BEQ		exit_hyperspace		; if no players just exit
                            	  1128: 
                            	  1129: ;##	TST.b		hide_p_cnt(a5)		; test the hide the player count
                            	  1130: ;##	BNE		exit_hyperspace		; if the player is hidden just exit
                            	  1131: 
00:00009D94 4A2D0027        	  1132: 	TST.b		p_flag_off(a5)		; test the player flag
00:00009D98 6F000088        	  1133: 	BLE		exit_hyperspace		; if no player or player exploding just exit
                            	  1134: 
                            	  1135: ;	MOVEQ		#' ',d1			; [SPACE] key, read the hyperspace button
                            	  1136: ;	MOVEQ		#19,d0			; check for keypress
                            	  1137: ;	TRAP		#15
00:00009D9C 7005            	  1138: 	moveq #5,d0
00:00009D9E 4E4F            	  1139: 	trap #15
00:00009DA0 0C010020        	  1140: 	cmpi.b #' ',d1
00:00009DA4 667C            	  1141: 	bne.s exit_hyperspace
                            	  1142: 
                            	  1143: ;	TST.b		d1				; test the result
                            	  1144: ;	BEQ.s		exit_hyperspace		; if the key is not pressed just exit
                            	  1145: 
00:00009DA6 7000            	  1146: 	MOVEQ		#0,d0				; clear the longword
00:00009DA8 1B400027        	  1147: 	MOVE.b	d0,p_flag_off(a5)		; clear the player flag
00:00009DAC 1B40004A        	  1148: 	MOVE.b	d0,p_xvel_off(a5)		; clear the player x velocity
00:00009DB0 1B40006D        	  1149: 	MOVE.b	d0,p_yvel_off(a5)		; clear the player y velocity
                            	  1150: 
00:00009DB4 1B7C0030007A    	  1151: 	MOVE.b	#$30,hide_p_cnt(a5)	; set the hide the player count
                            	  1152: 
00:00009DBA 61000C3E        	  1153: 	BSR		gen_prng			; generate the next pseudo random number
00:00009DBE 302B000A        	  1154: 	MOVE.w	PRNlword(a3),d0		; get a pseudo random word
00:00009DC2 02401FFF        	  1155: 	ANDI.w	#$1FFF,d0			; mask to $1Fxx
00:00009DC6 0C401E00        	  1156: 	CMPI.w	#$1E00,d0			; compare with $1E00
00:00009DCA 6504            	  1157: 	BCS.s		hype_xok1			; if less than $1E00 just use it
                            	  1158: 
00:00009DCC 02401CFF        	  1159: 	ANDI.w	#$1CFF,d0			; else restrict it to $1Cxx
                            	  1160: hype_xok1
00:00009DD0 0C400400        	  1161: 	CMPI.w	#$0400,d0			; compare it with $0400
00:00009DD4 6404            	  1162: 	BCC.s		hype_xok2			; if >= $0400 go use it
                            	  1163: 
00:00009DD6 00400300        	  1164: 	ORI.w		#$0300,d0			; else make it $03xx
                            	  1165: hype_xok2
00:00009DDA 3B40FFB6        	  1166: 	MOVE.w	d0,p_xpos_off(a5)		; save the player x position
                            	  1167: 
00:00009DDE 61000C1A        	  1168: 	BSR		gen_prng			; generate the next pseudo random number
00:00009DE2 302B000A        	  1169: 	MOVE.w	PRNlword(a3),d0		; get a pseudo random word
00:00009DE6 02401FFF        	  1170: 	ANDI.w	#$1FFF,d0			; mask to $1Fxx
                            	  1171: 
00:00009DEA 3F00            	  1172: 	MOVE.w	d0,-(sp)			; push the word
00:00009DEC 141F            	  1173: 	MOVE.b	(sp)+,d2			; pull the byte for later success/fail check
                            	  1174: 
00:00009DEE 0C401600        	  1175: 	CMPI.w	#$1600,d0			; compare with $1600
00:00009DF2 6504            	  1176: 	BCS.s		hype_yok1			; if less than $1600 just use it
                            	  1177: 
00:00009DF4 024014FF        	  1178: 	ANDI.w	#$14FF,d0			; else restrict it to $14xx
                            	  1179: hype_yok1
00:00009DF8 0C400400        	  1180: 	CMPI.w	#$0400,d0			; compare it with $0400
00:00009DFC 6404            	  1181: 	BCC.s		hype_yok2			; if >= $0400 go use it
                            	  1182: 
00:00009DFE 00400300        	  1183: 	ORI.w		#$0300,d0			; else make it $03xx
                            	  1184: hype_yok2
00:00009E02 3B40FFFC        	  1185: 	MOVE.w	d0,p_ypos_off(a5)		; save the player y position
                            	  1186: 
00:00009E06 7201            	  1187: 	MOVEQ		#1,d1				; default to a successful hyperspace jump
                            	  1188: 
00:00009E08 0C020018        	  1189: 	CMPI.b	#$18,d2			; compare with $18xx
00:00009E0C 6510            	  1190: 	BCS.s		save_hyperspace		; if less than $18xx go save the hyperspace flag
                            	  1191: 
00:00009E0E 02020007        	  1192: 	ANDI.b	#$07,d2			; else mask it
00:00009E12 D402            	  1193: 	ADD.b		d2,d2				; ; 2
00:00009E14 5802            	  1194: 	ADDI.b	#$04,d2			; + 4
00:00009E16 B42D0076        	  1195: 	CMP.b		rock_count(a5),d2		; compare this with the rock count
00:00009E1A 6502            	  1196: 	BCS.s		save_hyperspace		; if < the rock count allow the jump
                            	  1197: 
00:00009E1C 7280            	  1198: 	MOVEQ		#$80,d1			; else flag an unsuccessful hyperspace jump
                            	  1199: save_hyperspace
00:00009E1E 17410026        	  1200: 	MOVE.b	d1,hyper(a3)		; save the hyperspace flag
                            	  1201: exit_hyperspace
00:00009E22 4E75            	  1202: 	RTS
                            	  1203: 
                            	  1204: 
                            	  1205: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1206: ;
                            	  1207: ; clear the items and set the ship start count
                            	  1208: 
                            	  1209: reset_game
00:00009E24 7003            	  1210: 	MOVEQ		#3,d0				; default to a 3 ship game
00:00009E26 206B000E        	  1211: 	MOVEA.l	switch_addr(a3),a0	; point to the switch
00:00009E2A 08100002        	  1212: 	BTST		#2,(a0)			; test the ship start switch
00:00009E2E 6702            	  1213: 	BEQ.s		three_ship_start		; if 0 go start with three ships
                            	  1214: 
00:00009E30 7004            	  1215: 	MOVEQ		#4,d0				; else make it a 4 ship game
                            	  1216: three_ship_start
00:00009E32 1740001B        	  1217: 	MOVE.b	d0,ss_count(a3)		; save the starting ship count
                            	  1218: 
00:00009E36 1B7C00020075    	  1219: 	MOVE.b	#2,i_rk_count(a5)		; set the previous initial rock count
                            	  1220: 
00:00009E3C 7000            	  1221: 	MOVEQ		#0,d0				; clear the longword
00:00009E3E 7E22            	  1222: 	MOVEQ		#flag_end-flags_off-1,d7
                            	  1223: 							; set the count for the number of items
                            	  1224: clear_items_loop
00:00009E40 1B80700C        	  1225: 	MOVE.b	d0,flags_off(a5,d7.w)	; clear an item
00:00009E44 51CFFFFA        	  1226: 	DBF		d7,clear_items_loop	; loop if more to do
                            	  1227: 
00:00009E48 1B400076        	  1228: 	MOVE.b	d0,rock_count(a5)		; clear the rock count
                            	  1229: 
00:00009E4C 4E75            	  1230: 	RTS
                            	  1231: 
                            	  1232: 
                            	  1233: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1234: ;
                            	  1235: ; write a high score initial to the vector list
                            	  1236: 
                            	  1237: write_initial
00:00009E4E 7200            	  1238: 	MOVEQ		#0,d1				; clear the longword
00:00009E50 1218            	  1239: 	MOVE.b	(a0)+,d1			; get a high score initial
00:00009E52 6614            	  1240: 	BNE.s		add_character		; if not [SPACE] just go add it
                            	  1241: 
00:00009E54 102B0176        	  1242: 	MOVE.b	p1_high(a3),d0		; get the player 1 highscore flag
00:00009E58 C02B027A        	  1243: 	AND.b		p2_high(a3),d0		; and with the player 2 highscore flag
00:00009E5C 6B0A            	  1244: 	BMI.s		add_character		; if neither is entering their initials just
                            	  1245: 							; go add the character
                            	  1246: 
                            	  1247: 							; else add a "_" instead of a [SPACE]
00:00009E5E 38FCF872        	  1248: 	MOVE.w	#$F872,(a4)+		; add the underline vector word to the vector
                            	  1249: 							; list
00:00009E62 38FCF801        	  1250: 	MOVE.w	#$F801,(a4)+		; add the step to next character vector word
                            	  1251: 							; to the vector list
00:00009E66 4E75            	  1252: 	RTS
                            	  1253: 
                            	  1254: 
                            	  1255: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1256: ;
                            	  1257: ; add character (d1) to the vector list
                            	  1258: 
                            	  1259: add_character
00:00009E68 2F08            	  1260: 	MOVE.l	a0,-(sp)			; save a0
00:00009E6A D241            	  1261: 	ADD.w		d1,d1				; ; 2 bytes per character (d1) JSRL
00:00009E6C 41FA2316        	  1262: 	LEA		char_set(pc),a0		; point to the character JSRL table
00:00009E70 38F01000        	  1263: 	MOVE.w	(a0,d1.w),(a4)+		; add the JSRL word to the vector list
00:00009E74 205F            	  1264: 	MOVE.l	(sp)+,a0			; restore a0
00:00009E76 4E75            	  1265: 	RTS
                            	  1266: 
                            	  1267: 
                            	  1268: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1269: ;
                            	  1270: ; add d7 ships to the vector list. this is limited to a maximum of eighteen ships for
                            	  1271: ; speed and clarity
                            	  1272: 
                            	  1273: add_ships
00:00009E78 6726            	  1274: 	BEQ.s		exit_add_ships		; if no ships left just exit
                            	  1275: 
00:00009E7A 7012            	  1276: 	MOVEQ		#18,d0			; set the maximum ship count
00:00009E7C B047            	  1277: 	CMP.w		d7,d0				; compare the ship count with the max count
00:00009E7E 6402            	  1278: 	BCC.s		show_ships			; if <= to max go show the ships
                            	  1279: 
00:00009E80 3E00            	  1280: 	MOVE.w	d0,d7				; else set the ship count to the maximum
                            	  1281: show_ships
00:00009E82 9247            	  1282: 	SUB.w		d7,d1				; subtract the ship count twice to move the ..
00:00009E84 9247            	  1283: 	SUB.w		d7,d1				; .. ships further right the more there are
                            	  1284: 
00:00009E86 36BCE000        	  1285: 	MOVE.w	#$E000,glob_scale(a3)	; set the global scale
00:00009E8A 343C00D1        	  1286: 	MOVE.w	#$D1,d2			; set the ships y co-ordinate
00:00009E8E 61000AB6        	  1287: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1288: 							; a draw command
00:00009E92 5347            	  1289: 	SUBQ.w	#1,d7				; adjust for loop type
                            	  1290: add_ships_loop
00:00009E94 43FA20F4        	  1291: 	LEA		play_liv(pc),a1		; set the pointer to ships left
00:00009E98 61000A96        	  1292: 	BSR		add_address			; convert the a1 address and add it to the
                            	  1293: 							; vector list as a vector subroutine call
00:00009E9C 51CFFFF6        	  1294: 	DBF		d7,add_ships_loop		; decrement the ship count and loop if more
                            	  1295: 							; to do
                            	  1296: exit_add_ships
00:00009EA0 4E75            	  1297: 	RTS
                            	  1298: 
                            	  1299: 
                            	  1300: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1301: ;
                            	  1302: ; move all the items and add them to the vector list
                            	  1303: 
                            	  1304: ; d6 = object index
                            	  1305: ; d7 = position index
                            	  1306: 
                            	  1307: move_items
00:00009EA2 7E44            	  1308: 	MOVEQ		#x_pos_end-x_pos_off-2,d7
                            	  1309: 							; set the index to the last object position
00:00009EA4 7C22            	  1310: 	MOVEQ		#flag_end-flags_off-1,d6
                            	  1311: 							; set the count to the last object
                            	  1312: move_next_item
00:00009EA6 1035600C        	  1313: 	MOVE.b	flags_off(a5,d6.w),d0	; get an object flag
00:00009EAA 670000CC        	  1314: 	BEQ		move_next_object		; if no item go do the next one
                            	  1315: 
                            	  1316: ; have an active item
                            	  1317: 
00:00009EAE 6A5C            	  1318: 	BPL.s		move_item			; if the item is not exploding go move the item
                            	  1319: 
                            	  1320: 							; else the item is exploding
00:00009EB0 4400            	  1321: 	NEG.b		d0				; do twos complement [$A0 becones $60]
00:00009EB2 E808            	  1322: 	LSR.b		#4,d0				; shift the high nibble to the low nibble
                            	  1323: 							; [$60 becomes $06]
00:00009EB4 5200            	  1324: 	ADDQ.b	#1,d0				; + 1
00:00009EB6 0C06001B        	  1325: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  1326: 							; compare the index with the player index
00:00009EBA 6606            	  1327: 	BNE.s		skip_play_inc		; if not the player skip setting the player
                            	  1328: 							; increment
                            	  1329: 
                            	  1330: ; set the player explosion increment to 1/2 by only setting it to 1 on alternate loops
                            	  1331: 
00:00009EBC 7001            	  1332: 	MOVEQ		#1,d0				; set game counter mask
00:00009EBE C06B0059        	  1333: 	AND.w		game_count(a3),d0		; mask the game counter
                            	  1334: skip_play_inc
00:00009EC2 D035600C        	  1335: 	ADD.b		flags_off(a5,d6.w),d0	; add the item flag
00:00009EC6 6B2A            	  1336: 	BMI.s		item_exploding		; go handle the item still exploding
                            	  1337: 
00:00009EC8 0C46001B        	  1338: 	CMPI.w	#p_flag_off-flags_off,d6
                            	  1339: 							; compare the index with the player index
00:00009ECC 6716            	  1340: 	BEQ.s		go_reset_play		; if the player go reset the player and do next
                            	  1341: 
00:00009ECE 641A            	  1342: 	BCC.s		go_reset_sauc		; if the saucer go reset the saucer and do next
                            	  1343: 
                            	  1344: 							; else it was a rock so clear it
00:00009ED0 532D0076        	  1345: 	SUBQ.b	#1,rock_count(a5)		; decrement the rock count
00:00009ED4 6606            	  1346: 	BNE.s		no_new_rocks		; skip flag set if rocks still left
                            	  1347: 
00:00009ED6 1B7C007F007B    	  1348: 	MOVE.b	#$7F,new_rocks(a5)	; else set the generate new rocks flag
                            	  1349: no_new_rocks
00:00009EDC 4235600C        	  1350: 	CLR.b		flags_off(a5,d6.w)	; clear the item flag
00:00009EE0 60000096        	  1351: 	BRA		move_next_object		; go check next item
                            	  1352: 
                            	  1353: go_reset_play
00:00009EE4 610002EE        	  1354: 	BSR		player_reset		; reset the player velocity and position
00:00009EE8 60F2            	  1355: 	BRA		no_new_rocks		; go clear the player and do the next item
                            	  1356: 
                            	  1357: ; reset the saucer timer
                            	  1358: 
                            	  1359: go_reset_sauc
00:00009EEA 1B6D00780077    	  1360: 	MOVE.b	i_sauc_tim(a5),sauc_cntdn(a5)
                            	  1361: 							; get the small saucer boundary/initial saucer
                            	  1362: 							; timer and reset the saucer countdown timer
00:00009EF0 60EA            	  1363: 	BRA.s		no_new_rocks		; go clear the saucer and do the next item
                            	  1364: 
                            	  1365: ; the item is still exploding
                            	  1366: 
                            	  1367: item_exploding
00:00009EF2 1B80600C        	  1368: 	MOVE.b	d0,flags_off(a5,d6.w)	; save the incremented item flag
00:00009EF6 1F00            	  1369: 	MOVE.b	d0,-(sp)			; save the byte
00:00009EF8 321F            	  1370: 	MOVE.w	(sp)+,d1			; pull the word
00:00009EFA C27CF000        	  1371: 	AND.w		#$F000,d1			; mask the top nibble as the scale
00:00009EFE D27C1000        	  1372: 	ADD.w		#$1000,d1			; + $10
00:00009F02 0C06001B        	  1373: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  1374: 							; compare the index with the player index
00:00009F06 6602            	  1375: 	BNE.s		no_reset_scale		; if not the player ship skip the scale reset
                            	  1376: 
00:00009F08 7200            	  1377: 	MOVEQ		#$0000,d1			; else it was the player so reset the scale
                            	  1378: no_reset_scale
00:00009F0A 6066            	  1379: 	BRA.s		keep_scale			; go add the object to the vector list and do
                            	  1380: 							; the next item
                            	  1381: 
                            	  1382: ; the item is not exploding so move the item
                            	  1383: 
                            	  1384: move_item
00:00009F0C 1035602F        	  1385: 	MOVE.b	x_vel_off(a5,d6.w),d0	; get the x velocity byte
00:00009F10 4880            	  1386: 	EXT.w		d0				; extend it to a word value
00:00009F12 D0757080        	  1387: 	ADD.w		x_pos_off(a5,d7.w),d0	; add the x position
00:00009F16 6B06            	  1388: 	BMI.s		x_pos_neg			; if negative go mask to $2000
                            	  1389: 
00:00009F18 B07C2000        	  1390: 	CMP.w		#$2000,d0			; compare the object x position with $2000
00:00009F1C 6510            	  1391: 	BCS.s		not_x_max			; if less go do y position
                            	  1392: 
                            	  1393: x_pos_neg
00:00009F1E 02401FFF        	  1394: 	ANDI.w	#$1FFF,d0			; else wrap round the x position
                            	  1395: 
00:00009F22 0C06001C        	  1396: 	CMPI.b	#s_flag_off-flags_off,d6
                            	  1397: 							; compare the index with the saucer index
00:00009F26 6606            	  1398: 	BNE.s		not_x_max			; if not saucer continue
                            	  1399: 
                            	  1400: 							; else the saucer has passed the screen end
00:00009F28 487A004E        	  1401: 	PEA		move_next_object(pc)	; on RTS go check the next item
00:00009F2C 6052            	  1402: 	BRA.s		clear_saucer		; clear the saucer and restart the saucer timer
                            	  1403: 
                            	  1404: not_x_max
00:00009F2E 3B807080        	  1405: 	MOVE.w	d0,x_pos_off(a5,d7.w)	; save the new x position
                            	  1406: 
00:00009F32 10356052        	  1407: 	MOVE.b	y_vel_off(a5,d6.w),d0	; get the y velocity byte
00:00009F36 4880            	  1408: 	EXT.w		d0				; extend it to a word value
00:00009F38 D07570C6        	  1409: 	ADD.w		y_pos_off(a5,d7.w),d0	; add the y position
00:00009F3C 6A06            	  1410: 	BPL.s		y_not_neg			; skip add if not < 0
                            	  1411: 
00:00009F3E D07C1800        	  1412: 	ADD.w		#$1800,d0			; else wrap round the y position
00:00009F42 600A            	  1413: 	BRA.s		not_y_max			; and skip the max check
                            	  1414: 
                            	  1415: y_not_neg
00:00009F44 B07C1800        	  1416: 	CMP.w		#$1800,d0			; compare the object y position with $1800
00:00009F48 6504            	  1417: 	BCS.s		not_y_max			; if less just continue
                            	  1418: 
00:00009F4A 907C1800        	  1419: 	SUB.w		#$1800,d0			; else wrap round the y position
                            	  1420: not_y_max
00:00009F4E 3B8070C6        	  1421: 	MOVE.w	d0,y_pos_off(a5,d7.w)	; save the new y position
                            	  1422: 
00:00009F52 323CE000        	  1423: 	MOVE.w	#$E000,d1			; set the scale to $E000
00:00009F56 0C46001D        	  1424: 	CMPI.w	#s_fire_off-flags_off,d6
                            	  1425: 							; compare the index with the fire objects
00:00009F5A 6416            	  1426: 	BCC.s		keep_scale			; if fire object keep this scale and go add the
                            	  1427: 							; item and do next
                            	  1428: 
00:00009F5C 1035600C        	  1429: 	MOVE.b	flags_off(a5,d6.w),d0	; get the object flag
00:00009F60 08000000        	  1430: 	BTST.l	#0,d0				; test bit 0
00:00009F64 660C            	  1431: 	BNE.s		keep_scale			; if %xx1 keep this scale and go add the item
                            	  1432: 							; and do next
                            	  1433: 
00:00009F66 323CF000        	  1434: 	MOVE.w	#$F000,d1			; set the scale to $F000
00:00009F6A 08000001        	  1435: 	BTST.l	#1,d0				; test bit 0
00:00009F6E 6602            	  1436: 	BNE.s		keep_scale			; if %x10 keep this scale and go add the item
                            	  1437: 							; and do next
                            	  1438: 
00:00009F70 7200            	  1439: 	MOVEQ		#0,d1				; set the scale to $0000
                            	  1440: 
                            	  1441: ; add the item to the vector list and go do the next item
                            	  1442: 
                            	  1443: keep_scale
00:00009F72 3681            	  1444: 	MOVE.w	d1,glob_scale(a3)		; save the global scale
00:00009F74 610003EA        	  1445: 	BSR		add_to_list			; add an object to the vector list
                            	  1446: move_next_object
00:00009F78 5547            	  1447: 	SUBQ.w	#2,d7				; decrement the position index
00:00009F7A 51CEFF2A        	  1448: 	DBF		d6,move_next_item		; decrement the count and loop if more to do
                            	  1449: 
00:00009F7E 4E75            	  1450: 	RTS
                            	  1451: 
                            	  1452: 
                            	  1453: 
                            	  1454: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1455: ;
                            	  1456: ; clear the saucer and restart the saucer timer
                            	  1457: 
                            	  1458: clear_saucer
00:00009F80 1B6D00780077    	  1459: 	MOVE.b	i_sauc_tim(a5),sauc_cntdn(a5)	
                            	  1460: 							; copy the small saucer boundary/initial saucer
                            	  1461: 							; timer to the saucer countdown timer
00:00009F86 422D0028        	  1462: 	CLR.b		s_flag_off(a5)		; clear the saucer flag
00:00009F8A 422D004B        	  1463: 	CLR.b		s_xvel_off(a5)		; clear the saucer x velocity byte
00:00009F8E 422D006E        	  1464: 	CLR.b		s_yvel_off(a5)		; clear the saucer y velocity byte
00:00009F92 4E75            	  1465: 	RTS
                            	  1466: 
                            	  1467: 
                            	  1468: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1469: ;
                            	  1470: ; handle ship rotation and thrust
                            	  1471: 
                            	  1472: ship_move
                            	  1473: ;##	TST.b		num_players(a3)		; test the number of players in the game
                            	  1474: ;##	BEQ.s		exit_ship_move		; if no players just exit
                            	  1475: 
00:00009F94 4A2D0027        	  1476: 	TST.b		p_flag_off(a5)		; test the player flag
00:00009F98 6B4A            	  1477: 	BMI.s		exit_ship_move		; if the player is exploding just exit
                            	  1478: 
00:00009F9A 4A2D007A        	  1479: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:00009F9E 6746            	  1480: 	BEQ.s		rot_and_thrust		; if the player is visible go handle the ship
                            	  1481: 							; rotate and thrust
                            	  1482: 
00:00009FA0 532D007A        	  1483: 	SUBQ.b	#1,hide_p_cnt(a5)		; else decrement the hide the player count
00:00009FA4 663E            	  1484: 	BNE.s		exit_ship_move		; if not timed out just exit
                            	  1485: 
00:00009FA6 4A2B0026        	  1486: 	TST.b		hyper(a3)			; test the hyperspace flag
00:00009FAA 6B1E            	  1487: 	BMI.s		kill_the_player		; if negative go handle an unsuccessful
                            	  1488: 							; hyperspace jump
                            	  1489: 
00:00009FAC 6614            	  1490: 	BNE.s		reveal_player		; else if non zero go handle a successful
                            	  1491: 							; hyperspace jump
                            	  1492: 
                            	  1493: 							; else the player has just become visible
00:00009FAE 61000104        	  1494: 	BSR		check_clear			; check items within $0400 range of the player
00:00009FB2 662C            	  1495: 	BNE.s		clear_hyper			; if there are items within range go clear the
                            	  1496: 							; hyperspace flag and exit
                            	  1497: 
00:00009FB4 4A2D0028        	  1498: 	TST.b		s_flag_off(a5)		; test the saucer flag
00:00009FB8 6708            	  1499: 	BEQ.s		reveal_player		; if there's no saucer go reveal the player
                            	  1500: 
00:00009FBA 1B7C0002007A    	  1501: 	MOVE.b	#$02,hide_p_cnt(a5)	; else set the hide the player count
00:00009FC0 4E75            	  1502: 	RTS
                            	  1503: 
                            	  1504: ; handle a successful hyperspace jump
                            	  1505: 
                            	  1506: reveal_player
00:00009FC2 1B7C00010027    	  1507: 	MOVE.b	#$01,p_flag_off(a5)	; set the player flag
00:00009FC8 6016            	  1508: 	BRA.s		clear_hyper			; go clear the hyperspace flag and return
                            	  1509: 
                            	  1510: ; handle an unsuccessful hyperspace jump
                            	  1511: 
                            	  1512: kill_the_player
00:00009FCA 1B7C00A00027    	  1513: 	MOVE.b	#$A0,p_flag_off(a5)	; flag that the player's ship is exploding
00:00009FD0 532D0082        	  1514: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
00:00009FD4 1B7C0081007A    	  1515: 	MOVE.b	#$81,hide_p_cnt(a5)	; set the hide the player count
                            	  1516: 
00:00009FDA 7206            	  1517: 	MOVEQ		#mexpl_snd,d1		; set the medium explosion sound
00:00009FDC 610025BA        	  1518: 	BSR		play_sample			; go play the sample
                            	  1519: clear_hyper
00:00009FE0 422B0026        	  1520: 	CLR.b		hyper(a3)			; clear the hyperspace flag
                            	  1521: exit_ship_move
00:00009FE4 4E75            	  1522: 	RTS
                            	  1523: 
                            	  1524: ; handle the ship rotate and thrust
                            	  1525: 
                            	  1526: rot_and_thrust
00:00009FE6 7400            	  1527: 	MOVEQ		#0,d2				; assume no rotate
00:00009FE8 223C4C205751    	  1528: 	MOVE.l	#'L WQ',d1			; [L WQ] keys
00:00009FEE 7013            	  1529: 	MOVEQ		#19,d0			; check for keypress
00:00009FF0 4E4F            	  1530: 	TRAP		#15
00:00009FF2 7005            	  1531: 	moveq #5,d0
00:00009FF4 4E4F            	  1532: 	trap #15
00:00009FF6 0C010051        	  1533: 	cmpi.b #'Q',d1
00:00009FFA 6602            	  1534: 	bne.s not_rot_left1
00:00009FFC 7403            	  1535: 	moveq #3,d2
                            	  1536: not_rot_left1:
00:00009FFE 0C010057        	  1537: 	cmpi.b #'W',d1
00:0000A002 6602            	  1538: 	bne.s not_rot_right1
00:0000A004 5702            	  1539: 	subq.b #3,d2
                            	  1540: not_rot_right1:
                            	  1541: 
                            	  1542: ;	TST.b		d1				; test the [Q] result
                            	  1543: ;	BPL.s		not_rot_left		; if not pressed go test rotate right
                            	  1544: 
                            	  1545: ;	MOVEQ		#3,d2				; if pressed set the rotation angle to + 3
                            	  1546: ;not_rot_left
                            	  1547: ;	TST.w		d1				; test the [W] result
                            	  1548: ;	BPL.s		not_rot_right		; if not pressed go add the rotation
                            	  1549: 
                            	  1550: ;	SUBQ.b	#3,d2				; if pressed set the rotation angle to - 3
                            	  1551: ;not_rot_right
00:0000A006 D52B001E        	  1552: 	ADD.b		d2,p_orient(a3)		; add the roataion to the player orientation
                            	  1553: 
00:0000A00A 7001            	  1554: 	MOVEQ		#1,d0				; set game counter mask
00:0000A00C C06B0059        	  1555: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000A010 66D2            	  1556: 	BNE.s		exit_ship_move		; just exit half the time
                            	  1557: 
00:0000A012 0C01004C        	  1558: 	cmpi.b #'L',d1
00:0000A016 664C            	  1559: 	bne.s not_thrust
                            	  1560: ;	TST.l		d1				; test the [L] result
                            	  1561: ;	BPL.s		not_thrust			; if not pressed then go slow the ship
                            	  1562: 
                            	  1563: ; thrust button is pressed so increase the ship velocity
                            	  1564: 
00:0000A018 7202            	  1565: 	MOVEQ		#thrst_snd,d1		; set the thrust sound
00:0000A01A 6100257C        	  1566: 	BSR		play_sample			; play the sample and return
                            	  1567: 
00:0000A01E 102B001E        	  1568: 	MOVE.b	p_orient(a3),d0		; get the player orientation
00:0000A022 610007CC        	  1569: 	BSR		cos_d0			; do COS(d0)
00:0000A026 EE40            	  1570: 	ASR.w		#7,d0				; scale to 1/128th
                            	  1571: 
00:0000A028 1F2D004A        	  1572: 	MOVE.b	p_xvel_off(a5),-(sp)	; get the x velocity high byte
00:0000A02C 321F            	  1573: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000A02E 122D007E        	  1574: 	MOVE.b	p_xvlo_off(a5),d1		; get the x velocity low byte
00:0000A032 D240            	  1575: 	ADD.w		d0,d1				; add the thrust x component
00:0000A034 6164            	  1576: 	BSR.s		check_velocity		; limit check the velocity in d1
00:0000A036 1B41007E        	  1577: 	MOVE.b	d1,p_xvlo_off(a5)		; save the x velocity low byte
00:0000A03A 3F01            	  1578: 	MOVE.w	d1,-(sp)			; save the word
00:0000A03C 1B5F004A        	  1579: 	MOVE.b	(sp)+,p_xvel_off(a5)	; save the x velocity high byte
                            	  1580: 
00:0000A040 102B001E        	  1581: 	MOVE.b	p_orient(a3),d0		; get the player orientation
00:0000A044 610007AE        	  1582: 	BSR		sin_d0			; do SIN(d0)
00:0000A048 EE40            	  1583: 	ASR.w		#7,d0				; scale to 1/128th
                            	  1584: 
00:0000A04A 1F2D006D        	  1585: 	MOVE.b	p_yvel_off(a5),-(sp)	; get the y velocity high byte
00:0000A04E 321F            	  1586: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000A050 122D007F        	  1587: 	MOVE.b	p_yvlo_off(a5),d1		; get the y velocity low byte
00:0000A054 D240            	  1588: 	ADD.w		d0,d1				; add the thrust y component
00:0000A056 6142            	  1589: 	BSR.s		check_velocity		; limit check the velocity in d1
00:0000A058 1B41007F        	  1590: 	MOVE.b	d1,p_yvlo_off(a5)		; save the y velocity low byte
00:0000A05C 3F01            	  1591: 	MOVE.w	d1,-(sp)			; save the word
00:0000A05E 1B5F006D        	  1592: 	MOVE.b	(sp)+,p_yvel_off(a5)	; save the y velocity high byte
                            	  1593: 
00:0000A062 4E75            	  1594: 	RTS
                            	  1595: 
                            	  1596: ; thrust button is not pressed so slow the ship by adding - 128 ; velocity
                            	  1597: 
                            	  1598: not_thrust
00:0000A064 1F2D004A        	  1599: 	MOVE.b	p_xvel_off(a5),-(sp)	; get the x velocity high byte
00:0000A068 321F            	  1600: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000A06A 122D007E        	  1601: 	MOVE.b	p_xvlo_off(a5),d1		; get the x velocity low byte
00:0000A06E 3001            	  1602: 	MOVE.w	d1,d0				; copy the x velocity
00:0000A070 EE40            	  1603: 	ASR.w		#7,d0				; scale to 1/128th
00:0000A072 9240            	  1604: 	SUB.w		d0,d1				; subtract the x drag component
00:0000A074 1B41007E        	  1605: 	MOVE.b	d1,p_xvlo_off(a5)		; save the x velocity low byte
00:0000A078 3F01            	  1606: 	MOVE.w	d1,-(sp)			; save the word
00:0000A07A 1B5F004A        	  1607: 	MOVE.b	(sp)+,p_xvel_off(a5)	; save the x velocity high byte
                            	  1608: 
                            	  1609: ; done the x velocity now do the y
                            	  1610: 
00:0000A07E 1F2D006D        	  1611: 	MOVE.b	p_yvel_off(a5),-(sp)	; get the y velocity high byte
00:0000A082 321F            	  1612: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000A084 122D007F        	  1613: 	MOVE.b	p_yvlo_off(a5),d1		; get the y velocity low byte
00:0000A088 3001            	  1614: 	MOVE.w	d1,d0				; copy the y velocity
00:0000A08A EE40            	  1615: 	ASR.w		#7,d0				; scale to 1/128th
00:0000A08C 9240            	  1616: 	SUB.w		d0,d1				; subtract the y drag component
00:0000A08E 1B41007F        	  1617: 	MOVE.b	d1,p_yvlo_off(a5)		; save the y velocity low byte
00:0000A092 3F01            	  1618: 	MOVE.w	d1,-(sp)			; save the word
00:0000A094 1B5F006D        	  1619: 	MOVE.b	(sp)+,p_yvel_off(a5)	; save the y velocity high byte
                            	  1620: 
00:0000A098 4E75            	  1621: 	RTS
                            	  1622: 
                            	  1623: 
                            	  1624: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1625: ;
                            	  1626: ; limit check the velocity in XA
                            	  1627: 
                            	  1628: check_velocity
00:0000A09A 6B0C            	  1629: 	BMI.s		check_neg_velocity	; if negative go check negative limit
                            	  1630: 
00:0000A09C 0C414000        	  1631: 	CMPI.w	#$4000,d1			; compare velocity with positive limit
00:0000A0A0 6510            	  1632: 	BCS.s		exit_check_velocity	; if less just exit
                            	  1633: 
00:0000A0A2 323C3FFF        	  1634: 	MOVE.w	#$3FFF,d1			; else set the velocity
00:0000A0A6 4E75            	  1635: 	RTS
                            	  1636: 
                            	  1637: ; velocity is negative so check against the negative limit
                            	  1638: 
                            	  1639: check_neg_velocity
00:0000A0A8 0C41C002        	  1640: 	CMPI.w	#$C002,d1			; compare velocity with negative limit
00:0000A0AC 6404            	  1641: 	BCC.s		exit_check_velocity	; if greater or equal just exit
                            	  1642: 
00:0000A0AE 323CC001        	  1643: 	MOVE.w	#$C001,d1			; else set the velocity
                            	  1644: exit_check_velocity
00:0000A0B2 4E75            	  1645: 	RTS
                            	  1646: 
                            	  1647: 
                            	  1648: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1649: ;
                            	  1650: ; check items within $0400 range of the player
                            	  1651: 
                            	  1652: check_clear
00:0000A0B4 7C1C            	  1653: 	MOVEQ		#s_flag_off-flags_off,d6
                            	  1654: 							; set the count/index to the saucer
00:0000A0B6 7E38            	  1655: 	MOVEQ		#s_xpos_off-x_pos_off,d7
                            	  1656: 							; set the index to the saucer position
                            	  1657: check_clear_loop
00:0000A0B8 4A35600C        	  1658: 	TST.b		flags_off(a5,d6.w)	; test the item flag
00:0000A0BC 6F28            	  1659: 	BLE.s		not_closer			; if no item or exploding go do the next item
                            	  1660: 
00:0000A0BE 30357080        	  1661: 	MOVE.w	x_pos_off(a5,d7.w),d0	; get the item x position
00:0000A0C2 906DFFB6        	  1662: 	SUB.w		p_xpos_off(a5),d0		; subtract the player x position
00:0000A0C6 0C400400        	  1663: 	CMPI.w	#$0400,d0			; compare the result with $0400
00:0000A0CA 6506            	  1664: 	BCS.s		check_clear_y		; if closer go check the y distance
                            	  1665: 
00:0000A0CC 0C40FC00        	  1666: 	CMPI.w	#$FC00,d0			; compare the result with -$0400
00:0000A0D0 6514            	  1667: 	BCS.s		not_closer			; if not closer go do the next item
                            	  1668: 
                            	  1669: check_clear_y
00:0000A0D2 303570C6        	  1670: 	MOVE.w	y_pos_off(a5,d7.w),d0	; get the item y position
00:0000A0D6 906DFFFC        	  1671: 	SUB.w		p_ypos_off(a5),d0		; subtract the player y position
00:0000A0DA 0C400400        	  1672: 	CMPI.w	#$0400,d0			; compare the result with $0400
00:0000A0DE 6510            	  1673: 	BCS.s		is_closer			; if closer go flag within distance and
                            	  1674: 							; increment the hide the player count
                            	  1675: 
00:0000A0E0 0C40FC00        	  1676: 	CMPI.w	#$FC00,d0			; compare the result with -$0400
00:0000A0E4 640A            	  1677: 	BCC.s		is_closer			; if closer go flag within distance and
                            	  1678: 							; increment the hide the player count
                            	  1679: 
                            	  1680: not_closer
00:0000A0E6 5547            	  1681: 	SUBQ.w	#2,d7				; decrement the position index
00:0000A0E8 51CEFFCE        	  1682: 	DBF		d6,check_clear_loop	; decrement the count and loop if more to do
                            	  1683: 
00:0000A0EC 7000            	  1684: 	MOVEQ		#0,d0				; return Zb = 1
00:0000A0EE 4E75            	  1685: 	RTS
                            	  1686: 
                            	  1687: is_closer
00:0000A0F0 522D007A        	  1688: 	ADDQ.b	#1,hide_p_cnt(a5)		; increment the hide the player count
                            	  1689: 							; return Zb = 0
00:0000A0F4 4E75            	  1690: 	RTS
                            	  1691: 
                            	  1692: 
                            	  1693: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1694: ;
                            	  1695: ; generate new rocks
                            	  1696: 
                            	  1697: make_rocks
00:0000A0F6 4A2D0028        	  1698: 	TST.b		s_flag_off(a5)		; test the saucer flag
00:0000A0FA 660000A0        	  1699: 	BNE		exit_make_rocks		; if existing saucer just exit
                            	  1700: 
00:0000A0FE 7C34            	  1701: 	MOVEQ		#p_xpos_off-x_pos_off-2,d6
                            	  1702: 							; set the index to the last rock position
00:0000A100 7A1A            	  1703: 	MOVEQ		#p_flag_off-flags_off-1,d5
                            	  1704: 							; set the count/index to the last rock flag
00:0000A102 4A2D007B        	  1705: 	TST.b		new_rocks(a5)		; test the generate new rocks flag
00:0000A106 6600008A        	  1706: 	BNE		clear_rocks			; if not counted out go clear all the rocks
                            	  1707: 
                            	  1708: ; these are used as the new rock initial velocity
                            	  1709: 
00:0000A10A 7000            	  1710: 	MOVEQ		#0,d0				; clear the longword
00:0000A10C 1B40004B        	  1711: 	MOVE.b	d0,s_xvel_off(a5)		; clear the saucer x velocity byte
00:0000A110 1B40006E        	  1712: 	MOVE.b	d0,s_yvel_off(a5)		; clear the saucer y velocity byte
                            	  1713: 
00:0000A114 700A            	  1714: 	MOVEQ		#$0A,d0			; set the max value
00:0000A116 B02D007D        	  1715: 	CMP.b		min_rocks(a5),d0		; compare minimum rock count with $0A
00:0000A11A 6504            	  1716: 	BCS.s		no_inc_min			; if > skip the increment
                            	  1717: 
00:0000A11C 522D007D        	  1718: 	ADDQ.b	#1,min_rocks(a5)		; else decrement the minimum rock count before
                            	  1719: 							; the saucer initial timer starts to decrement
                            	  1720: no_inc_min
00:0000A120 7800            	  1721: 	MOVEQ		#0,d4				; clear the longword
00:0000A122 182D0075        	  1722: 	MOVE.b	i_rk_count(a5),d4		; get the initial rock count
00:0000A126 5404            	  1723: 	ADDQ.b	#2,d4				; + 2
00:0000A128 0C04000B        	  1724: 	CMPI.b	#11,d4			; compare the new rock count with 11 rocks
00:0000A12C 6302            	  1725: 	BLS.s		no_set_max			; if less or equal just use it
                            	  1726: 
00:0000A12E 780B            	  1727: 	MOVEQ		#11,d4			; else set the new rock count to 11
                            	  1728: no_set_max
00:0000A130 1B440076        	  1729: 	MOVE.b	d4,rock_count(a5)		; save the rock count
00:0000A134 1B440075        	  1730: 	MOVE.b	d4,i_rk_count(a5)		; save the initial rock count
                            	  1731: 
00:0000A138 7E1C            	  1732: 	MOVEQ		#s_xvel_off-x_vel_off,d7
                            	  1733: 							; set the index to the saucer for a zero initial
                            	  1734: 							; velocity
                            	  1735: 
00:0000A13A 5344            	  1736: 	SUBQ.w	#1,d4				; adjust for the loop type
                            	  1737: gen_rock_loop
00:0000A13C 610008BC        	  1738: 	BSR		gen_prng			; generate the next pseudo random number
00:0000A140 7018            	  1739: 	MOVEQ		#$18,d0			; set the rock type mask
00:0000A142 C02B000A        	  1740: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000A146 00000004        	  1741: 	ORI.b		#$04,d0			; set the rock size to the largest
00:0000A14A 1B80500C        	  1742: 	MOVE.b	d0,flags_off(a5,d5.w)	; save the rock flag
00:0000A14E 610000C4        	  1743: 	BSR		copy_velocity		; copy the saucer velocity, (d7), plus a random
                            	  1744: 							; delta x,y velocity to the new rock, (d5),
                            	  1745: 							; velocity
                            	  1746: 
00:0000A152 610008A6        	  1747: 	BSR		gen_prng			; generate the next pseudo random number
00:0000A156 7200            	  1748: 	MOVEQ		#0,d1				; clear the other axis position
00:0000A158 303C3FFF        	  1749: 	MOVE.w	#$3FFF,d0			; set the starting position mask
00:0000A15C C06B000A        	  1750: 	AND.w		PRNlword(a3),d0		; mask a pseudo random word
00:0000A160 E248            	  1751: 	LSR.w		#1,d0				; shift a random bit into Cb
00:0000A162 640C            	  1752: 	BCC.s		rock_on_x			; if Cb = 0 go set the rock at a point along
                            	  1753: 							; the x axis
                            	  1754: 
                            	  1755: ; set the rock at a point along the y axis
                            	  1756: 
00:0000A164 0C401800        	  1757: 	CMPI.w	#$1800,d0			; compare the position with the y axis maximum
00:0000A168 6504            	  1758: 	BCS.s		rock_y_ok			; if less just use it
                            	  1759: 
00:0000A16A 024017FF        	  1760: 	ANDI.w	#$17FF,d0			; mask the position to the y axis maximum
                            	  1761: rock_y_ok
00:0000A16E C340            	  1762: 	EXG		d1,d0				; swap y value to d1, zero to d0
                            	  1763: 
                            	  1764: ; set the rock at a point along the x axis
                            	  1765: 
                            	  1766: rock_on_x
00:0000A170 3B806080        	  1767: 	MOVE.w	d0,x_pos_off(a5,d6.w)	; save the rock x position
00:0000A174 3B8160C6        	  1768: 	MOVE.w	d1,y_pos_off(a5,d6.w)	; save the rock y position
00:0000A178 5546            	  1769: 	SUBQ.w	#2,d6				; decrement the rock position index
00:0000A17A 5345            	  1770: 	SUBQ.w	#1,d5				; decrement the rock count/index
00:0000A17C 51CCFFBE        	  1771: 	DBF		d4,gen_rock_loop		; decrement the new rock count and loop if more
                            	  1772: 							; to do
                            	  1773: 
00:0000A180 1B7C007F0077    	  1774: 	MOVE.b	#$7F,sauc_cntdn(a5)	; set the saucer countdown timer
00:0000A186 1B7C0034007C    	  1775: 	MOVE.b	#$34,thmp_sndi(a5)	; reset the thump sound change timer initial
                            	  1776: 							; value
00:0000A18C 177C00080023    	  1777: 	MOVE.b	#beat1_snd,thump_snd(a3)
                            	  1778: 							; reset the thump sound value
                            	  1779: 
                            	  1780: ; now clear all the other rocks
                            	  1781: 
                            	  1782: clear_rocks
00:0000A192 7000            	  1783: 	MOVEQ		#0,d0				; clear the longword
                            	  1784: clear_rocks_loop
00:0000A194 1B80500C        	  1785: 	MOVE.b	d0,flags_off(a5,d5.w)	; clear the rock flag
00:0000A198 51CDFFFA        	  1786: 	DBF		d5,clear_rocks_loop	; decrement the count and loop if more to do
                            	  1787: 
                            	  1788: exit_make_rocks
00:0000A19C 4E75            	  1789: 	RTS
                            	  1790: 
                            	  1791: 
                            	  1792: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1793: ;
                            	  1794: ; initialise the player variables
                            	  1795: 
                            	  1796: player_init
00:0000A19E 1B6B001B0082    	  1797: 	MOVE.b	ss_count(a3),ships_off(a5)
                            	  1798: 							; set the player's starting ship count
00:0000A1A4 1B7C00920078    	  1799: 	MOVE.b	#$92,i_sauc_tim(a5)	; set the small saucer boundary/initial saucer
                            	  1800: 							; timer
00:0000A1AA 1B7C00920077    	  1801: 	MOVE.b	#$92,sauc_cntdn(a5)	; set the saucer countdown timer
00:0000A1B0 1B7C007F007B    	  1802: 	MOVE.b	#$7F,new_rocks(a5)	; set the generate new rocks flag
                            	  1803: 
00:0000A1B6 1B7C0005007D    	  1804: 	MOVE.b	#$05,min_rocks(a5)	; set the minimum rock count before the saucer
                            	  1805: 							; initial timer starts to decrement
00:0000A1BC 1B7C0034007C    	  1806: 	MOVE.b	#$34,thmp_sndi(a5)	; reset the thump sound change timer initial
                            	  1807: 							; value
00:0000A1C2 177C00080023    	  1808: 	MOVE.b	#beat1_snd,thump_snd(a3)	; reset the thump sound value
00:0000A1C8 1B7C00FF0083    	  1809: 	MOVE.b	#$FF,high_off(a5)		; clear the player highscore flag
00:0000A1CE 1B7C0001007A    	  1810: 	MOVE.b	#$01,hide_p_cnt(a5)	; set the hide the player count
                            	  1811: 
                            	  1812: 
                            	  1813: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1814: ;
                            	  1815: ; reset the player velocity and position
                            	  1816: 
                            	  1817: player_reset
00:0000A1D4 3B7C1000FFB6    	  1818: 	MOVE.w	#$1000,p_xpos_off(a5)	; set the player x position
00:0000A1DA 3B7C0C00FFFC    	  1819: 	MOVE.w	#$0C00,p_ypos_off(a5)	; set the player y position
00:0000A1E0 422D004A        	  1820: 	CLR.b		p_xvel_off(a5)		; clear the player x velocity
00:0000A1E4 422D006D        	  1821: 	CLR.b		p_yvel_off(a5)		; clear the player y velocity
00:0000A1E8 4E75            	  1822: 	RTS
                            	  1823: 
                            	  1824: 
                            	  1825: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1826: ;
                            	  1827: ; copy the item parameters from the old rock, (d7), to the new rock, (d5)
                            	  1828: 
                            	  1829: copy_rock
00:0000A1EA 3807            	  1830: 	MOVE.w	d7,d4				; copy the old rock index
00:0000A1EC D844            	  1831: 	ADD.w		d4,d4				; ; 2 for the old rock position index
                            	  1832: 
                            	  1833: copy_rock_2
00:0000A1EE 3605            	  1834: 	MOVE.w	d5,d3				; copy the new rock index
00:0000A1F0 D643            	  1835: 	ADD.w		d3,d3				; ; 2 for the new rock position index
                            	  1836: 
00:0000A1F2 7207            	  1837: 	MOVEQ		#$07,d1			; set the size mask
00:0000A1F4 C235700C        	  1838: 	AND.b		flags_off(a5,d7.w),d1	; mask the old rock size
00:0000A1F8 61000800        	  1839: 	BSR		gen_prng			; generate the next pseudo random number
00:0000A1FC 7018            	  1840: 	MOVEQ		#$18,d0			; set the rock type mask
00:0000A1FE C02B000A        	  1841: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000A202 8001            	  1842: 	OR.b		d1,d0				; OR in the old rock size
00:0000A204 1B80500C        	  1843: 	MOVE.b	d0,flags_off(a5,d5.w)	; save the new rock flag
                            	  1844: 
00:0000A208 3BB540803080    	  1845: 	MOVE.w	x_pos_off(a5,d4.w),x_pos_off(a5,d3.w)
                            	  1846: 							; copy the old rock x position to the new rock
                            	  1847: 							; x position
00:0000A20E 3BB540C630C6    	  1848: 	MOVE.w	y_pos_off(a5,d4.w),y_pos_off(a5,d3.w)
                            	  1849: 							; copy the old rock y position to the new rock
                            	  1850: 							; y position
                            	  1851: 
                            	  1852: 
                            	  1853: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1854: ;
                            	  1855: ; copy the old rock, (d7), velocity plus random delta x,y velocity to the new rock,
                            	  1856: ; (d5), velocity
                            	  1857: 
                            	  1858: copy_velocity
00:0000A214 610007E4        	  1859: 	BSR		gen_prng			; generate the next pseudo random number
00:0000A218 708F            	  1860: 	MOVEQ		#$8F,d0			; mask +/- $00 to $0F
00:0000A21A C02B000A        	  1861: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000A21E 6A04            	  1862: 	BPL.s		x_off_pos			; skip bits set if positive
                            	  1863: 
00:0000A220 00000070        	  1864: 	ORI.b		#$70,d0			; else make $Fx
                            	  1865: x_off_pos
00:0000A224 D035702F        	  1866: 	ADD.b		x_vel_off(a5,d7.w),d0	; add the item (d7) to the delta x velocity
00:0000A228 6120            	  1867: 	BSR.s		limit_velocity		; ensure velocity is within limits
00:0000A22A 1B80502F        	  1868: 	MOVE.b	d0,x_vel_off(a5,d5.w)	; save the rock x velocity
                            	  1869: 
                            	  1870: 
00:0000A22E 610007CA        	  1871: 	BSR		gen_prng			; generate the next pseudo random number
00:0000A232 708F            	  1872: 	MOVEQ		#$8F,d0			; mask +/- $00 to $0F
00:0000A234 C02B000A        	  1873: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000A238 6A04            	  1874: 	BPL.s		y_off_pos			; skip bits set if positive
                            	  1875: 
00:0000A23A 00000070        	  1876: 	ORI.b		#$70,d0			; else make $Fx
                            	  1877: y_off_pos
00:0000A23E D0357052        	  1878: 	ADD.b		y_vel_off(a5,d7.w),d0	; add the item (d5) to the delta y velocity
00:0000A242 6106            	  1879: 	BSR.s		limit_velocity		; ensure velocity is within limits
00:0000A244 1B805052        	  1880: 	MOVE.b	d0,y_vel_off(a5,d5.w)	; save the rock y velocity
                            	  1881: 
00:0000A248 4E75            	  1882: 	RTS
                            	  1883: 
                            	  1884: 
                            	  1885: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1886: ;
                            	  1887: ; ensure velocity is within limits
                            	  1888: 
                            	  1889: limit_velocity
00:0000A24A 6A12            	  1890: 	BPL.s		limit_p_vel			; if positive go test positive limit
                            	  1891: 
00:0000A24C 0C0000E1        	  1892: 	CMPI.b	#$E1,d0			; compare velocity with upper limit
00:0000A250 6402            	  1893: 	BCC.s		neg_upper_ok		; if less skip set
                            	  1894: 
00:0000A252 70E1            	  1895: 	MOVEQ		#$E1,d0			; else set velocity to -$1F
                            	  1896: neg_upper_ok
00:0000A254 0C0000FB        	  1897: 	CMPI.b	#$FB,d0			; compare velocity with lower limit
00:0000A258 6514            	  1898: 	BCS.s		exit_limit_velocity	; if greater just exit
                            	  1899: 
00:0000A25A 70FA            	  1900: 	MOVEQ		#$FA,d0			; else set velocity to -$06
00:0000A25C 4E75            	  1901: 	RTS
                            	  1902: 
                            	  1903: ; test velocity positive limit
                            	  1904: 
                            	  1905: limit_p_vel
00:0000A25E 0C000006        	  1906: 	CMPI.b	#$06,d0			; compare velocity with lower limit
00:0000A262 6402            	  1907: 	BCC.s		pos_lower_ok		; skip set if greater
                            	  1908: 
00:0000A264 7006            	  1909: 	MOVEQ		#$06,d0			; else set velocity to $06
                            	  1910: pos_lower_ok
00:0000A266 0C000020        	  1911: 	CMPI.b	#$20,d0			; compare velocity with upper limit
00:0000A26A 6502            	  1912: 	BCS.s		exit_limit_velocity	; if less just exit
                            	  1913: 
00:0000A26C 701F            	  1914: 	MOVEQ		#$1F,d0			; else set velocity to $1F
                            	  1915: exit_limit_velocity
00:0000A26E 4E75            	  1916: 	RTS
                            	  1917: 
                            	  1918: 
                            	  1919: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1920: ;
                            	  1921: ; add (c), scores and players ships to the vector list
                            	  1922: 
                            	  1923: static_messages
00:0000A270 43FA18F6        	  1924: 	LEA		copy_msg(pc),a1		; set the pointer to the copyright message
00:0000A274 610006BA        	  1925: 	BSR		add_address			; convert the a1 address and add it to the
                            	  1926: 							; vector list as a vector subroutine call
                            	  1927: 
00:0000A278 36BC1000        	  1928: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
00:0000A27C 7219            	  1929: 	MOVEQ		#$19,d1			; set the score x co-ordinate
00:0000A27E 343C00D7        	  1930: 	MOVE.w	#$D7,d2			; set the score y co-ordinate
00:0000A282 610006C2        	  1931: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1932: 							; a draw command
                            	  1933: 
00:0000A286 323C7000        	  1934: 	MOVE.w	#REL7,d1			; make a $7000,$0000 command
00:0000A28A 610006D4        	  1935: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  1936: 
00:0000A28E 0C2B0002001A    	  1937: 	CMPI.b	#$02,num_players(a3)	; compare the number of players in the game
00:0000A294 661E            	  1938: 	BNE.s		skip_play_flash		; if not two players skip flashing the active
                            	  1939: 							; player
                            	  1940: 
00:0000A296 4A2B0018        	  1941: 	TST.b		player_idx(a3)		; test the player index
00:0000A29A 6618            	  1942: 	BNE.s		skip_play_flash		; if player 2 go add the player to the vector
                            	  1943: 							; list
                            	  1944: 
00:0000A29C 102D0027        	  1945: 	MOVE.b	p_flag_off(a5),d0		; get the player flag
00:0000A2A0 802B0026        	  1946: 	OR.b		hyper(a3),d0		; OR with the hyperspace flag
00:0000A2A4 660E            	  1947: 	BNE.s		skip_play_flash		; if playing go add player 1's score to the
                            	  1948: 							; vector list
                            	  1949: 
00:0000A2A6 4A2D007A        	  1950: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:0000A2AA 6B08            	  1951: 	BMI.s		skip_play_flash		; if the player is dieing go display the score
                            	  1952: 
00:0000A2AC 082B0004005A    	  1953: 	BTST.b	#4,game_count+1(a3)	; test a bit in the game counter low byte
00:0000A2B2 6714            	  1954: 	BEQ.s		do_p1_ships			; skip the score display if the flash is off
                            	  1955: 
                            	  1956: ; add the active player to the vector list
                            	  1957: 
                            	  1958: skip_play_flash
00:0000A2B4 43EB0173        	  1959: 	LEA		p1_score(a3),a1		; point to player 1's score
00:0000A2B8 7E02            	  1960: 	MOVEQ		#$02,d7			; set the number byte count
00:0000A2BA 17470016        	  1961: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000A2BE 61000512        	  1962: 	BSR		output_number		; output the number (a1) as a leading zero
                            	  1963: 							; suppressed character string
00:0000A2C2 7200            	  1964: 	MOVEQ		#0,d1				; add player 1's score's trailing "0"
00:0000A2C4 61000650        	  1965: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  1966: 
                            	  1967: do_p1_ships
00:0000A2C8 7229            	  1968: 	MOVEQ		#$29,d1			; set the x co-ordinate for player 1's ships
00:0000A2CA 7E00            	  1969: 	MOVEQ		#0,d7				; clear the longword
00:0000A2CC 1E2B0175        	  1970: 	MOVE.b	p1_ships(a3),d7		; get player 1's ship count
00:0000A2D0 6100FBA6        	  1971: 	BSR		add_ships			; add d7 ships to the vector list
                            	  1972: 
00:0000A2D4 4253            	  1973: 	MOVE.w	#$0000,glob_scale(a3)	; set the global scale
                            	  1974: 
00:0000A2D6 7278            	  1975: 	MOVEQ		#$78,d1			; set the high score x co-ordinate
00:0000A2D8 343C00D7        	  1976: 	MOVE.w	#$D7,d2			; set the high score y co-ordinate
00:0000A2DC 61000668        	  1977: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1978: 							; a draw command
00:0000A2E0 323C5000        	  1979: 	MOVE.w	#REL5,d1			; make a $5000,$0000 command
00:0000A2E4 6100067A        	  1980: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  1981: 
00:0000A2E8 43EB0027        	  1982: 	LEA		hiscores(a3),a1		; point to the highest high score
00:0000A2EC 7E02            	  1983: 	MOVEQ		#$02,d7			; set the number byte count
00:0000A2EE 17470016        	  1984: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000A2F2 610004DE        	  1985: 	BSR		output_number		; output the number (a1) as a leading zero
                            	  1986: 							; suppressed character string
                            	  1987: 
00:0000A2F6 7200            	  1988: 	MOVEQ		#0,d1				; add the high score trailing "0"
00:0000A2F8 6100061C        	  1989: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  1990: 
00:0000A2FC 36BC1000        	  1991: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
                            	  1992: 
00:0000A300 323C00C0        	  1993: 	MOVE.w	#$C0,d1			; set the score x co-ordinate
00:0000A304 343C00D7        	  1994: 	MOVE.w	#$D7,d2			; set the score y co-ordinate
00:0000A308 6100063C        	  1995: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1996: 							; a draw command
00:0000A30C 323C5000        	  1997: 	MOVE.w	#REL5,d1			; make a $5000,$0000 command
00:0000A310 6100064E        	  1998: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  1999: 
00:0000A314 0C2B0001001A    	  2000: 	CMPI.b	#$01,num_players(a3)	; compare the number of players in the game
                            	  2001: 							; with one
00:0000A31A 6742            	  2002: 	BEQ.s		exit_static			; if just one player skip displaying p2 score
                            	  2003: 
00:0000A31C 651E            	  2004: 	BCS.s		do_p2_score			; if no players go add player 2's score to
                            	  2005: 							; the vector list
                            	  2006: 
00:0000A31E 4A2B0018        	  2007: 	TST.b		player_idx(a3)		; test the player index
00:0000A322 6718            	  2008: 	BEQ.s		do_p2_score			; if player 1 go add the player to the vector
                            	  2009: 							; list
                            	  2010: 
00:0000A324 102D0027        	  2011: 	MOVE.b	p_flag_off(a5),d0		; get the player flag
00:0000A328 802B0026        	  2012: 	OR.b		hyper(a3),d0		; OR with the hyperspace flag
00:0000A32C 660E            	  2013: 	BNE.s		do_p2_score			; if playing go add player 2's score to the
                            	  2014: 							; vector list
                            	  2015: 
00:0000A32E 4A2D007A        	  2016: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:0000A332 6B08            	  2017: 	BMI.s		do_p2_score			; if the player is dieing go display the score
                            	  2018: 
00:0000A334 082B0004005A    	  2019: 	BTST.b	#4,game_count+1(a3)	; test a bit in the game counter low byte
00:0000A33A 6714            	  2020: 	BEQ.s		skip_p2_score		; skip the score display if the flash is off
                            	  2021: 
                            	  2022: do_p2_score
00:0000A33C 43EB0277        	  2023: 	LEA		p2_score(a3),a1		; point to player 2's score
00:0000A340 7E02            	  2024: 	MOVEQ		#$02,d7			; set the number byte count
00:0000A342 17470016        	  2025: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000A346 6100048A        	  2026: 	BSR		output_number		; output the number (a1) as a leading zero
                            	  2027: 							; suppressed character string
00:0000A34A 7200            	  2028: 	MOVEQ		#0,d1				; add player 2's score's trailing "0"
00:0000A34C 610005C8        	  2029: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  2030: 
                            	  2031: skip_p2_score
00:0000A350 323C00D0        	  2032: 	MOVE.w	#$D0,d1			; set the x co-ordinate for player 2's ships
00:0000A354 7E00            	  2033: 	MOVEQ		#0,d7				; clear the longword
00:0000A356 1E2B0279        	  2034: 	MOVE.b	p2_ships(a3),d7		; get player 2's ship count
00:0000A35A 6000FB1C        	  2035: 	BRA		add_ships			; add d7 ships to the vector list and return
                            	  2036: 
                            	  2037: exit_static
00:0000A35E 4E75            	  2038: 	RTS
                            	  2039: 
                            	  2040: 
                            	  2041: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2042: ;
                            	  2043: ; add an item to the vector list
                            	  2044: ;
                            	  2045: ; d6 = object flag offset
                            	  2046: ; d7 = position offset
                            	  2047: 
                            	  2048: 							; first add the DRAW to the item's origin
                            	  2049: add_to_list
00:0000A360 303570C6        	  2050: 	MOVE.w	y_pos_off(a5,d7.w),d0	; get the y position
00:0000A364 D07C0400        	  2051: 	ADD.w		#$0400,d0			; add offset so y is centred around 512
00:0000A368 E648            	  2052: 	LSR.w		#3,d0				; / 8
00:0000A36A 0040A000        	  2053: 	ORI.w		#DRAW,d0			; OR in the draw command
00:0000A36E 38C0            	  2054: 	MOVE.w	d0,(a4)+			; add it to the vector list
                            	  2055: 
00:0000A370 30357080        	  2056: 	MOVE.w	x_pos_off(a5,d7.w),d0	; get the x position
00:0000A374 E648            	  2057: 	LSR.w		#3,d0				; / 8
00:0000A376 8041            	  2058: 	OR.w		d1,d0				; OR in the global scale
00:0000A378 38C0            	  2059: 	MOVE.w	d0,(a4)+			; add it to the vector list
                            	  2060: 
00:0000A37A 7200            	  2061: 	MOVEQ		#0,d1				; clear the longword
00:0000A37C 1235600C        	  2062: 	MOVE.b	flags_off(a5,d6.w),d1	; get the object flag
00:0000A380 6A12            	  2063: 	BPL.s		add_item			; if not exploding go add the item to the
                            	  2064: 							; vector list
                            	  2065: 
                            	  2066: 							; else add an exploding item
00:0000A382 0C06001B        	  2067: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  2068: 							; compare the index with the player index
00:0000A386 6700014A        	  2069: 	BEQ		add_play_explode		; if it is the player go add ship pieces to the
                            	  2070: 							; vector list
                            	  2071: 
00:0000A38A 0201000C        	  2072: 	ANDI.b	#$0C,d1			; else mask the rock type
00:0000A38E 43FA1818        	  2073: 	LEA		expl_tab(pc),a1		; point to the explosion JSRL table
00:0000A392 601A            	  2074: 	BRA.s		add_explode			; go add the JSRL word to the vector list and
                            	  2075: 							; return
                            	  2076: 
                            	  2077: ; add item d6 to the vector list
                            	  2078: 
                            	  2079: add_item
00:0000A394 0C06001B        	  2080: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  2081: 							; compare the index with the player index
00:0000A398 670001DE        	  2082: 	BEQ		add_player			; if = go add the player to the vector list
                            	  2083: 
00:0000A39C 0C06001C        	  2084: 	CMPI.b	#s_flag_off-flags_off,d6
                            	  2085: 							; compare the index with the saucer index
00:0000A3A0 6712            	  2086: 	BEQ.s		add_saucer			; if = go add the saucer to the vector list
                            	  2087: 
00:0000A3A2 6416            	  2088: 	BCC.s		add_fire			; if > saucer go add fire to the vector list
                            	  2089: 
                            	  2090: 							; else add a rock to the vector list
00:0000A3A4 02410018        	  2091: 	ANDI.w	#$0018,d1			; mask the rock type
00:0000A3A8 E449            	  2092: 	LSR.w		#2,d1				; >> 3 << 1
00:0000A3AA 43FA18E2        	  2093: 	LEA		rock_tab(pc),a1		; point to the rock JSRL table
                            	  2094: add_explode
00:0000A3AE 38F11000        	  2095: 	MOVE.w	(a1,d1.w),(a4)+		; add the JSRL word to the vector list
00:0000A3B2 4E75            	  2096: 	RTS
                            	  2097: 
                            	  2098: ; add the saucer to the vector list
                            	  2099: 
                            	  2100: add_saucer
00:0000A3B4 38FA194A        	  2101: 	MOVE.w	sauc_jsr(pc),(a4)+	; add the saucer JSRL to the vector list
00:0000A3B8 4E75            	  2102: 	RTS
                            	  2103: 
                            	  2104: ; add fire to the vector list
                            	  2105: 
                            	  2106: add_fire
00:0000A3BA 38FA1E12        	  2107: 	MOVE.w	shot_jsr(pc),(a4)+	; add the shot JSRL to the vector list
                            	  2108: 
00:0000A3BE 7003            	  2109: 	MOVEQ		#3,d0				; set the game counter mask
00:0000A3C0 C06B0059        	  2110: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000A3C4 6604            	  2111: 	BNE.s		no_shot_dec			; skip the shot decrement 3/4 of the time
                            	  2112: 
00:0000A3C6 5335600C        	  2113: 	SUBQ.b	#1,flags_off(a5,d6.w)	; decrement fire item (d7) flag
                            	  2114: no_shot_dec
00:0000A3CA 4E75            	  2115: 	RTS
                            	  2116: 
                            	  2117: 
                            	  2118: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2119: ;
                            	  2120: ; add d1.b to the current player's score
                            	  2121: 
                            	  2122: add_score
00:0000A3CC 44FC0004        	  2123: 	MOVE.w	#4,CCR			; set Zb, clear everything else
00:0000A3D0 142D0081        	  2124: 	MOVE.b	score_off+1(a5),d2	; get the player's score, tens
00:0000A3D4 C501            	  2125: 	ABCD.b	d1,d2				; add the value to the score
00:0000A3D6 6422            	  2126: 	BCC.s		exit_add_score		; if no carry just exit
                            	  2127: 
00:0000A3D8 7200            	  2128: 	MOVEQ		#0,d1				; clear the add high byte
00:0000A3DA 102D0080        	  2129: 	MOVE.b	score_off(a5),d0		; get the player's score, thousands
00:0000A3DE C101            	  2130: 	ABCD.b	d1,d0				; add the value to the score
00:0000A3E0 1B400080        	  2131: 	MOVE.b	d0,score_off(a5)		; save the player's score, thousands
                            	  2132: 
00:0000A3E4 0200000F        	  2133: 	ANDI.b	#$0F,d0			; mask the units of thousands
00:0000A3E8 6610            	  2134: 	BNE.s		exit_add_score		; if the score is not x0000 just exit
                            	  2135: 
00:0000A3EA 720A            	  2136: 	MOVEQ		#extra_snd,d1		; set the bonus ship sound
00:0000A3EC 610021AA        	  2137: 	BSR		play_sample			; go play the sample
                            	  2138: 
00:0000A3F0 522D0082        	  2139: 	ADDQ.b	#1,ships_off(a5)		; increment the player's ship count
00:0000A3F4 6604            	  2140: 	BNE.s		exit_add_score		; exit if not wrappwd
                            	  2141: 
00:0000A3F6 532D0082        	  2142: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
                            	  2143: exit_add_score
00:0000A3FA 1B420081        	  2144: 	MOVE.b	d2,score_off+1(a5)	; save the player's score, tens
00:0000A3FE 4E75            	  2145: 	RTS
                            	  2146: 
                            	  2147: 
                            	  2148: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2149: ;
                            	  2150: ; display the high score table if the game is over
                            	  2151: 
                            	  2152: high_scores
00:0000A400 4A2B001A        	  2153: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000A404 660000A0        	  2154: 	BNE		exit_no_scores		; if playing skip the high scores
                            	  2155: 
00:0000A408 082B00020059    	  2156: 	BTST.b	#2,game_count(a3)		; test a bit in the game counter high byte
00:0000A40E 66000096        	  2157: 	BNE		exit_no_scores		; if not high score time just exit
                            	  2158: 
00:0000A412 45EB0027        	  2159: 	LEA		hiscores(a3),a2		; point to the high score table
                            	  2160: 
00:0000A416 4A52            	  2161: 	TST.w		(a2)				; test the highest high score
00:0000A418 6700008C        	  2162: 	BEQ		exit_no_scores		; if the high score table is empty just exit
                            	  2163: 
00:0000A41C 7200            	  2164: 	MOVEQ		#0,d1				; message 0 - "HIGH SCORES"
00:0000A41E 61000470        	  2165: 	BSR		add_message			; add message d1 to the display list
                            	  2166: 
00:0000A422 36BC1000        	  2167: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
                            	  2168: 
00:0000A426 41EB003B        	  2169: 	LEA		hinames(a3),a0		; point to the high score names
00:0000A42A 7C00            	  2170: 	MOVEQ		#0,d6				; clear the high score index
00:0000A42C 377C00A70012    	  2171: 	MOVE.w	#$00A7,hiscore_y(a3)	; set the score's y co-ordinate
                            	  2172: high_scores_loop
00:0000A432 4A52            	  2173: 	TST.w		(a2)				; test the high score entry
00:0000A434 676A            	  2174: 	BEQ.s		exit_high_scores		; if this score is zero just exit
                            	  2175: 
00:0000A436 725F            	  2176: 	MOVEQ		#$5F,d1			; set the score's x co-ordinate
00:0000A438 342B0012        	  2177: 	MOVE.w	hiscore_y(a3),d2		; get the score's y co-ordinate
00:0000A43C 61000508        	  2178: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  2179: 							; a draw command
                            	  2180: 
00:0000A440 323C4000        	  2181: 	MOVE.w	#REL4,d1			; make a $4000,$0000 command
00:0000A444 6100051A        	  2182: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  2183: 
00:0000A448 43EB0017        	  2184: 	LEA		high_idx(a3),a1		; point to the high score index
00:0000A44C 7E01            	  2185: 	MOVEQ		#$01,d7			; set the number byte count and the increment
00:0000A44E 44FC0004        	  2186: 	MOVE.w	#4,CCR			; set Zb, clear everything else
00:0000A452 CD07            	  2187: 	ABCD.b	d7,d6				; add to the high score index
00:0000A454 1286            	  2188: 	MOVE.b	d6,(a1)			; save the high score decimal index
00:0000A456 17470016        	  2189: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000A45A 61000376        	  2190: 	BSR		output_number		; output a number as a leading zero suppressed
                            	  2191: 							; string
                            	  2192: 
                            	  2193: 							; set the point after the high score number
00:0000A45E 323C4000        	  2194: 	MOVE.w	#REL4,d1			; make a $4000,$xx00 command
00:0000A462 3401            	  2195: 	MOVE.w	d1,d2				; make a $4000,$4000 command, point after entry
                            	  2196: 							; number
00:0000A464 610004FC        	  2197: 	BSR		add_pair			; add (d1)00,(d2)00 to the vector list
                            	  2198: 
00:0000A468 7200            	  2199: 	MOVEQ		#0,d1				; set [SPACE] character
00:0000A46A 6100F9FC        	  2200: 	BSR		add_character		; add character (d1) to the vector list
                            	  2201: 
00:0000A46E 224A            	  2202: 	MOVEA.l	a2,a1				; point to the high score entry
00:0000A470 7E02            	  2203: 	MOVEQ		#$02,d7			; set the number byte count
00:0000A472 177C00FF0016    	  2204: 	MOVE.b	#-1,suppress_0(a3)	; set the flag to suppress leading zeros
00:0000A478 61000358        	  2205: 	BSR		output_number		; output a number as a leading zero suppressed
                            	  2206: 							; string
                            	  2207: 
00:0000A47C 7200            	  2208: 	MOVEQ		#0,d1				; add the final "0"
00:0000A47E 61000496        	  2209: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  2210: 
00:0000A482 7200            	  2211: 	MOVEQ		#0,d1				; set [SPACE] character
00:0000A484 6100F9E2        	  2212: 	BSR		add_character		; add character (d1) to the vector list
                            	  2213: 
00:0000A488 6100F9C4        	  2214: 	BSR		write_initial		; write a high score initial to the vector list
00:0000A48C 6100F9C0        	  2215: 	BSR		write_initial		; write a high score initial to the vector list
00:0000A490 6100F9BC        	  2216: 	BSR		write_initial		; write a high score initial to the vector list
                            	  2217: 
00:0000A494 516B0012        	  2218: 	SUBQ.w	#8,hiscore_y(a3)		; subtract 8 from the score's y co-ordinate
00:0000A498 544A            	  2219: 	ADDQ.w	#2,a2				; increment the high score pointer
                            	  2220: 
00:0000A49A 0C060010        	  2221: 	CMPI.b	#$10,d6			; compare the high score index with 10
00:0000A49E 6592            	  2222: 	BCS.s		high_scores_loop		; loop if more to do
                            	  2223: 
                            	  2224: exit_high_scores
00:0000A4A0 003C0001        	  2225: 	ORI.b		#$01,CCR			; set the carry, flag scores displayed
00:0000A4A4 4E75            	  2226: 	RTS
                            	  2227: 
                            	  2228: exit_no_scores
00:0000A4A6 023C00FE        	  2229: 	ANDI.b	#$FE,CCR			; clear the carry, flag scores not displayed
00:0000A4AA 4E75            	  2230: 	RTS
                            	  2231: 
                            	  2232: 
                            	  2233: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2234: ;
                            	  2235: ; find a free rock item, the index is returned in d5
                            	  2236: 
                            	  2237: find_rock
00:0000A4AC 7A1A            	  2238: 	MOVEQ		#p_flag_off-flags_off-1,d5
                            	  2239: 							; set the count/index to the last rock flag
                            	  2240: 
                            	  2241: ; find a free rock item from d5
                            	  2242: 
                            	  2243: find_next_rock
00:0000A4AE 4A35500C        	  2244: 	TST.b		flags_off(a5,d5.w)	; test the rock flag
00:0000A4B2 6704            	  2245: 	BEQ.s		exit_find_rock		; if free return this index
                            	  2246: 
00:0000A4B4 51CDFFF8        	  2247: 	DBF		d5,find_next_rock		; else loop if more to do
                            	  2248: 
                            	  2249: exit_find_rock
00:0000A4B8 4E75            	  2250: 	RTS
                            	  2251: 
                            	  2252: 
                            	  2253: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2254: ;
                            	  2255: ; wrecked ship piece x,y velocities
                            	  2256: 
                            	  2257: ship_wrk_x
00:0000A4BA FFD8            	  2258: 	dc.w	$FFD8					; x
00:0000A4BC 0032            	  2259: 	dc.w	$0032					; x
00:0000A4BE 0000            	  2260: 	dc.w	$0000					; x
00:0000A4C0 003C            	  2261: 	dc.w	$003C					; x
00:0000A4C2 000A            	  2262: 	dc.w	$000A					; x
00:0000A4C4 FFD8            	  2263: 	dc.w	$FFD8					; x
                            	  2264: 
                            	  2265: ship_wrk_y
00:0000A4C6 001E            	  2266: 	dc.w	$001E					; y
00:0000A4C8 FFEC            	  2267: 	dc.w	$FFEC					; y
00:0000A4CA FFC4            	  2268: 	dc.w	$FFC4					; y
00:0000A4CC 0014            	  2269: 	dc.w	$0014					; y
00:0000A4CE 0046            	  2270: 	dc.w	$0046					; y
00:0000A4D0 FFD8            	  2271: 	dc.w	$FFD8					; y
                            	  2272: 
                            	  2273: 
                            	  2274: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2275: ;
                            	  2276: ; add the player explosion to the vector list
                            	  2277: 
                            	  2278: add_play_explode
00:0000A4D2 48E70300        	  2279: 	MOVEM.l	d6-d7,-(sp)			; save the registers
00:0000A4D6 7200            	  2280: 	MOVEQ		#0,d1				; clear the longword
00:0000A4D8 122D0027        	  2281: 	MOVE.b	p_flag_off(a5),d1		; get the player flag
00:0000A4DC 0C0100A2        	  2282: 	CMPI.b	#$A2,d1			; compare the player flag with $A2
00:0000A4E0 641A            	  2283: 	BCC.s		no_reset_xy			; if >= $A2 skip resetting the explosion
                            	  2284: 							; start point
                            	  2285: 
                            	  2286: 							; else reset the explosion start point
00:0000A4E2 7E0A            	  2287: 	MOVEQ		#$0A,d7			; set the index to the last piece x,y pair
                            	  2288: reset_xy_loop
00:0000A4E4 303B70D4        	  2289: 	MOVE.w	ship_wrk_x(pc,d7.w),d0	; get the x velocity word
00:0000A4E8 E948            	  2290: 	LSL.w		#4,d0				; ; 16
00:0000A4EA 3780705B        	  2291: 	MOVE.w	d0,expl_x_pos(a3,d7.w)	; save the x position word
                            	  2292: 
00:0000A4EE 303B70D6        	  2293: 	MOVE.w	ship_wrk_y(pc,d7.w),d0	; get the y velocity word
00:0000A4F2 E948            	  2294: 	LSL.w		#4,d0				; ; 16
00:0000A4F4 37807067        	  2295: 	MOVE.w	d0,expl_y_pos(a3,d7.w)	; save the y position word
                            	  2296: 
00:0000A4F8 5547            	  2297: 	SUBQ.w	#2,d7				; decrement the index
00:0000A4FA 6AE8            	  2298: 	BPL.s		reset_xy_loop		; loop if more to do
                            	  2299: 
                            	  2300: ; now use the player flag as the start index to the ship pieces. this means there will
                            	  2301: ; be less pieces as the explosion progresses
                            	  2302: 
                            	  2303: no_reset_xy
00:0000A4FC 7070            	  2304: 	MOVEQ		#$70,d0			; set the mask
00:0000A4FE B101            	  2305: 	EOR.b		d0,d1				; toggle the player flag
00:0000A500 C200            	  2306: 	AND.b		d0,d1				; mask the player flag
00:0000A502 E609            	  2307: 	LSR.b		#3,d1				; / 16 ; 2 gives the piece start index
00:0000A504 3E01            	  2308: 	MOVE.w	d1,d7				; copy the index
                            	  2309: 
                            	  2310: 							; the piece draw loop	
                            	  2311: piece_draw_loop
00:0000A506 303B70B2        	  2312: 	MOVE.w	ship_wrk_x(pc,d7.w),d0	; get the x velocity word
00:0000A50A D073705B        	  2313: 	ADD.w		expl_x_pos(a3,d7.w),d0	; add the x position word
00:0000A50E 3780705B        	  2314: 	MOVE.w	d0,expl_x_pos(a3,d7.w)	; save the x position word
                            	  2315: 
00:0000A512 323B70B2        	  2316: 	MOVE.w	ship_wrk_y(pc,d7.w),d1	; get the y velocity word
00:0000A516 D2737067        	  2317: 	ADD.w		expl_y_pos(a3,d7.w),d1	; add the y position word
00:0000A51A 37817067        	  2318: 	MOVE.w	d1,expl_y_pos(a3,d7.w)	; save the y position word
                            	  2319: 
00:0000A51E 244C            	  2320: 	MOVEA.l	a4,a2				; copy the vector pointer
                            	  2321: 
00:0000A520 7400            	  2322: 	MOVEQ		#0,d2				; clear the x sign bit
00:0000A522 4A40            	  2323: 	TST.w		d0				; test the x position word
00:0000A524 6A06            	  2324: 	BPL.s		vec_x_pos			; if positive skip the negate
                            	  2325: 
00:0000A526 4440            	  2326: 	NEG.w		d0				; else negate the x position, make it positive
00:0000A528 343C0400        	  2327: 	MOVE.w	#$0400,d2			; and set the x sign bit
                            	  2328: vec_x_pos
                            	  2329: 
00:0000A52C 7600            	  2330: 	MOVEQ		#0,d3				; clear the y sign bit
00:0000A52E 4A41            	  2331: 	TST.w		d1				; test the y position word
00:0000A530 6A06            	  2332: 	BPL.s		vec_y_pos			; if positive skip the negate
                            	  2333: 
00:0000A532 4441            	  2334: 	NEG.w		d1				; else negate the y position, make it positive
00:0000A534 363C0400        	  2335: 	MOVE.w	#$0400,d3			; and set the y sign bit
                            	  2336: vec_y_pos
00:0000A538 E848            	  2337: 	LSR.w		#4,d0				; shift the x position
00:0000A53A E849            	  2338: 	LSR.w		#4,d1				; shift the y position
                            	  2339: 
00:0000A53C 8042            	  2340: 	OR.w		d2,d0				; OR in the x sign bit
00:0000A53E 00416000        	  2341: 	ORI.w		#$6000,d1			; fix the scale
00:0000A542 8243            	  2342: 	OR.w		d3,d1				; OR in the y sign bit
                            	  2343: 
00:0000A544 38C1            	  2344: 	MOVE.w	d1,(a4)+			; add y position to the vector list
00:0000A546 38C0            	  2345: 	MOVE.w	d0,(a4)+			; add x position to the vector list
                            	  2346: 
                            	  2347: 							; add the piece vector to the list
                            	  2348: 
00:0000A548 303B7022        	  2349: 	MOVE.w	ship_parts(pc,d7.w),d0	; get wrecked ship piece vector word
00:0000A54C 38C0            	  2350: 	MOVE.w	d0,(a4)+			; add the wrecked ship piece vector word to the
                            	  2351: 							; vector list
                            	  2352: 
00:0000A54E 0A400404        	  2353: 	EORI.w	#$0404,d0			; toggle the sign bits
00:0000A552 0240FF0F        	  2354: 	ANDI.w	#$FF0F,d0			; clear the intensity bits
00:0000A556 38C0            	  2355: 	MOVE.w	d0,(a4)+			; add the inverse wrecked ship piece vector word
                            	  2356: 							; to the vector list
                            	  2357: 
                            	  2358: 							; now copy an inverse relative long vector to
                            	  2359: 							; the list
00:0000A558 2012            	  2360: 	MOVE.l	(a2),d0			; get the vector to the piece
00:0000A55A 0A8004000400    	  2361: 	EORI.l	#$04000400,d0		; toggle the sign bits
00:0000A560 28C0            	  2362: 	MOVE.l	d0,(a4)+			; save the inverse vector to the list
                            	  2363: 
00:0000A562 5547            	  2364: 	SUBQ.w	#2,d7				; decrement the index
00:0000A564 6AA0            	  2365: 	BPL		piece_draw_loop		; loop if more to do
                            	  2366: 
00:0000A566 4CDF00C0        	  2367: 	MOVEM.l	(sp)+,d6-d7			; restore the registers
00:0000A56A 4E75            	  2368: 	RTS
                            	  2369: 
                            	  2370: 
                            	  2371: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2372: ;
                            	  2373: ; pieces of wrecked ship
                            	  2374: 
                            	  2375: ship_parts
00:0000A56C FFC6            	  2376: 	dc.w	$FFC6				; x = -2, Y = -3
00:0000A56E FEC1            	  2377: 	dc.w	$FEC1				; x =  1, Y = -2
00:0000A570 F1C3            	  2378: 	dc.w	$F1C3				; x =  3, Y =  1
00:0000A572 F1CD            	  2379: 	dc.w	$F1CD				; x = -1, Y =  1
00:0000A574 F1C7            	  2380: 	dc.w	$F1C7				; x = -3, Y =  1
00:0000A576 FDC1            	  2381: 	dc.w	$FDC1				; x =  1, Y = -1
                            	  2382: 
                            	  2383: 
                            	  2384: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2385: ;
                            	  2386: ; add the player ship to the vector list
                            	  2387: 
                            	  2388: add_player
00:0000A578 7600            	  2389: 	MOVEQ		#0,d3				; clear the x_sign
00:0000A57A 7400            	  2390: 	MOVEQ		#0,d2				; clear the y_sign
00:0000A57C 7800            	  2391: 	MOVEQ		#0,d4				; yx_sign
                            	  2392: 
00:0000A57E 122B001E        	  2393: 	MOVE.b	p_orient(a3),d1		; get the player orientation
00:0000A582 6A0A            	  2394: 	BPL.s		no_pos_reflect		; if positive skip reflection
                            	  2395: 
00:0000A584 343C0400        	  2396: 	MOVE.w	#$0400,d2			; set the y_sign
00:0000A588 3802            	  2397: 	MOVE.w	d2,d4				; set the yx_sign
00:0000A58A 4401            	  2398: 	NEG.b		d1				; make ABS orientation
00:0000A58C 6B06            	  2399: 	BMI.s		third_quad			; if still negative go do the third quad
                            	  2400: 
                            	  2401: no_pos_reflect
00:0000A58E 08010006        	  2402: 	BTST.l	#6,d1				; test the quadrant
00:0000A592 670E            	  2403: 	BEQ.s		first_quad			; skip reflect if in first quadrant
                            	  2404: 
                            	  2405: third_quad
00:0000A594 363C0400        	  2406: 	MOVE.w	#$0400,d3			; set the x_sign
00:0000A598 183C0004        	  2407: 	MOVE.b	#$04,d4			; set the yx_sign
                            	  2408: 
00:0000A59C 4401            	  2409: 	NEG.b		d1				; negate the byte
00:0000A59E D23C0080        	  2410: 	ADD.b		#$80,d1			; reflect the quadrant
                            	  2411: first_quad
00:0000A5A2 E209            	  2412: 	LSR.b		#1,d1				; do quadrant value / 2
00:0000A5A4 C23C003E        	  2413: 	AND.b		#$3E,d1			; mask to word boundary, value is $00 to $20
                            	  2414: 
00:0000A5A8 43FA1774        	  2415: 	LEA		play_tab(pc),a1		; point to the player ship table
00:0000A5AC 32311000        	  2416: 	MOVE.w	(a1,d1.w),d1		; get the offset to the player ship
00:0000A5B0 43F11000        	  2417: 	LEA		(a1,d1.w),a1		; get the pointer to the player ship
00:0000A5B4 6118            	  2418: 	BSR.s		copy_vectors		; copy the vectors from (a1) to the vector list
                            	  2419: 
                            	  2420: ;	MOVEQ		#'L',d1			; set for the thrust button
                            	  2421: ;	MOVEQ		#19,d0			; check for keypress
                            	  2422: ;	TRAP		#15
00:0000A5B6 7005            	  2423: 	moveq #5,d0
00:0000A5B8 4E4F            	  2424: 	trap #15
00:0000A5BA 0C01004C        	  2425: 	cmpi.b #'L',d1
00:0000A5BE 6608            	  2426: 	bne.s no_thrust
                            	  2427: 
                            	  2428: ;	TST.b		d1				; test the result
                            	  2429: ;	BEQ.s		no_thrust			; if not pressed then skip the thrust copy
                            	  2430: 
00:0000A5C0 7003            	  2431: 	MOVEQ		#3,d0				; set the game counter mask
00:0000A5C2 C06B0059        	  2432: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000A5C6 6606            	  2433: 	BNE.s		copy_vectors		; 3/4 of the time go copy the vectors from (a1)
                            	  2434: 							; to the vector list and return
                            	  2435: no_thrust
00:0000A5C8 4E75            	  2436: 	RTS
                            	  2437: 
                            	  2438: 
                            	  2439: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2440: ;
                            	  2441: ; copy the vectors from (a1) to the vector list
                            	  2442: 
                            	  2443: copy_short
00:0000A5CA B940            	  2444: 	EOR.w		d4,d0				; possibly toggle the x and y signs
00:0000A5CC 38C0            	  2445: 	MOVE.w	d0,(a4)+			; copy the word to the vector list
                            	  2446: 
                            	  2447: copy_vectors
00:0000A5CE 3019            	  2448: 	MOVE.w	(a1)+,d0			; get a vector word
00:0000A5D0 B07CF000        	  2449: 	CMP.w		#SHRT,d0			; compare with short form vector
00:0000A5D4 64F4            	  2450: 	BCC.s		copy_short			; if short vector go copy it
                            	  2451: 
00:0000A5D6 B07CA000        	  2452: 	CMP.w		#DRAW,d0			; compare with the DRAW command
00:0000A5DA 640C            	  2453: 	BCC.s		exit_copy_vectors		; if DRAW or greater exit the vector copy
                            	  2454: 
                            	  2455: ; else it is a long vector
                            	  2456: 
00:0000A5DC B540            	  2457: 	EOR.w		d2,d0				; possibly toggle the y sign
00:0000A5DE 38C0            	  2458: 	MOVE.w	d0,(a4)+			; copy the word to the vector list
00:0000A5E0 3019            	  2459: 	MOVE.w	(a1)+,d0			; get the second vector word
00:0000A5E2 B740            	  2460: 	EOR.w		d3,d0				; possibly toggle the x sign
00:0000A5E4 38C0            	  2461: 	MOVE.w	d0,(a4)+			; copy the word to the vector list
00:0000A5E6 60E6            	  2462: 	BRA.s		copy_vectors		; go do the next word
                            	  2463: 
                            	  2464: ; it's a short form vector
                            	  2465: 
                            	  2466: exit_copy_vectors
00:0000A5E8 4E75            	  2467: 	RTS
                            	  2468: 
                            	  2469: 
                            	  2470: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2471: ;
                            	  2472: ; do the game sounds
                            	  2473: 
                            	  2474: fx_sounds
00:0000A5EA 7200            	  2475: 	MOVEQ		#0,d1				; clear the longword
00:0000A5EC 122D0028        	  2476: 	MOVE.b	s_flag_off(a5),d1		; get the saucer flag
00:0000A5F0 6F06            	  2477: 	BLE.s		no_saucer_sound		; if no saucer or the saucer is exploding skip
                            	  2478: 							; the saucer sound
                            	  2479: 
00:0000A5F2 5401            	  2480: 	ADDQ.b	#smsau_snd-1,d1		; add the small saucer sound to the size
00:0000A5F4 61001FA2        	  2481: 	BSR		play_sample			; go play the sample
                            	  2482: no_saucer_sound
00:0000A5F8 4A2D0076        	  2483: 	TST.b		rock_count(a5)		; test the rock count
00:0000A5FC 672C            	  2484: 	BEQ.s		no_thump_sound		; if no rocks skip the thump sound
                            	  2485: 
00:0000A5FE 4A2D0027        	  2486: 	TST.b		p_flag_off(a5)		; test the player flag
00:0000A602 6F26            	  2487: 	BLE.s		no_thump_sound		; if no player or the player is exploding skip
                            	  2488: 							; the thump sound
                            	  2489: 
00:0000A604 4A2B0026        	  2490: 	TST.b		hyper(a3)			; test the hyperspace flag
00:0000A608 6620            	  2491: 	BNE.s		no_thump_sound		; if in hyperspace skip the thump sound
                            	  2492: 
00:0000A60A 532B0024        	  2493: 	SUBQ.b	#1,thump_time(a3)		; decrement the thump sound change timer
00:0000A60E 661A            	  2494: 	BNE.s		no_thump_sound		; skip changing the sound if not timed out
                            	  2495: 
00:0000A610 7004            	  2496: 	MOVEQ		#4,d0				; add the sound on time
00:0000A612 D02D007C        	  2497: 	ADD.b		thmp_sndi(a5),d0		; add the thump sound change timer initial
00:0000A616 17400024        	  2498: 	MOVE.b	d0,thump_time(a3)		; save the thump sound change timer
                            	  2499: 
00:0000A61A 7001            	  2500: 	MOVEQ		#1,d0				; set the bitmap change mask
00:0000A61C 122B0023        	  2501: 	MOVE.b	thump_snd(a3),d1		; get the thump sound value
00:0000A620 B101            	  2502: 	EOR.b		d0,d1				; change the thump sound value
00:0000A622 17410023        	  2503: 	MOVE.b	d1,thump_snd(a3)		; save the thump sound value
00:0000A626 60001F70        	  2504: 	BRA		play_sample			; go play the sample and return
                            	  2505: 
                            	  2506: no_thump_sound
00:0000A62A 4E75            	  2507: 	RTS
                            	  2508: 
                            	  2509: 
                            	  2510: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2511: ;
                            	  2512: ; handle something hitting a rock
                            	  2513: 
                            	  2514: ; d6 = player/saucer/shot object index
                            	  2515: ; d7 = object index
                            	  2516: 
                            	  2517: hit_a_rock
00:0000A62C 1B7C00500079    	  2518: 	MOVE.b	#$50,r_hit_tim(a5)	; set the rock hit timer
00:0000A632 1035700C        	  2519: 	MOVE.b	flags_off(a5,d7.w),d0	; get the rock flag
00:0000A636 7278            	  2520: 	MOVEQ		#$78,d1			; set the mask for the rock type
00:0000A638 C200            	  2521: 	AND.b		d0,d1				; mask the rock type
                            	  2522: 
00:0000A63A 02400007        	  2523: 	ANDI.w	#$07,d0			; mask the rock size
00:0000A63E E248            	  2524: 	LSR.w		#1,d0				; / 2
00:0000A640 3400            	  2525: 	MOVE.w	d0,d2				; copy the size
00:0000A642 6702            	  2526: 	BEQ.s		clear_rock			; if the size is zero then the rock is destroyed
                            	  2527: 							; so go clear the rock flag
                            	  2528: 
00:0000A644 8001            	  2529: 	OR.b		d1,d0				; else OR back the rock type
                            	  2530: clear_rock
00:0000A646 1B80700C        	  2531: 	MOVE.b	d0,flags_off(a5,d7.w)	; save the rock flag
                            	  2532: 
00:0000A64A 4A2B001A        	  2533: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000A64E 6712            	  2534: 	BEQ.s		skip_add			; if no players skip the score add
                            	  2535: 
00:0000A650 4A46            	  2536: 	TST.w		d6				; test the player/saucer/shot index
00:0000A652 6706            	  2537: 	BEQ.s		add_to_score		; if the player hit the rock go add it to the
                            	  2538: 							; player's score
                            	  2539: 
00:0000A654 0C460004        	  2540: 	CMPI.w	#p_fire_off-p_flag_off,d6
                            	  2541: 							; compare the player/saucer/shot index with the
                            	  2542: 							; first of the player's fire
00:0000A658 6508            	  2543: 	BCS.s		skip_add			; if < the player's fire skip adding to the
                            	  2544: 							; player's score
                            	  2545: 
                            	  2546: add_to_score
00:0000A65A 123B2042        	  2547: 	MOVE.b	rock_score(pc,d2.w),d1	; get the score per rock size
00:0000A65E 6100FD6C        	  2548: 	BSR		add_score			; add d1.b to the current player's score
                            	  2549: skip_add
00:0000A662 4A35700C        	  2550: 	TST.b		flags_off(a5,d7.w)	; test the rock flag
00:0000A666 6734            	  2551: 	BEQ.s		exit_hit_a_rock		; if the rock was destroyed just exit
                            	  2552: 
                            	  2553: ; else break the rock into none, one, or two smaller rocks
                            	  2554: 
00:0000A668 6100FE42        	  2555: 	BSR		find_rock			; find a free rock, the index is returned in d5
00:0000A66C 662E            	  2556: 	BNE.s		exit_hit_a_rock		; if there are no free rocks just exit
                            	  2557: 
00:0000A66E 522D0076        	  2558: 	ADDQ.b	#1,rock_count(a5)		; else increment the rock count
                            	  2559: 
00:0000A672 6100FB76        	  2560: 	BSR		copy_rock			; copy the item parameters from the old rock,
                            	  2561: 							; (d7), to the new rock, (d5)
                            	  2562: 
00:0000A676 701F            	  2563: 	MOVEQ		#$1F,d0			; set the mask for the low 5 bits
00:0000A678 C035502F        	  2564: 	AND.b		x_vel_off(a5,d5.w),d0	; get the new rock x velocity byte
00:0000A67C D000            	  2565: 	ADD.b		d0,d0				; ; 2
00:0000A67E B1353081        	  2566: 	EOR.b		d0,x_pos_off+1(a5,d3.w)	; purturb the new rock x position low byte
                            	  2567: 
00:0000A682 6100FE2A        	  2568: 	BSR		find_next_rock		; find a free rock from d5, the index is
                            	  2569: 							; returned in d5
00:0000A686 6614            	  2570: 	BNE.s		exit_hit_a_rock		; if there are no free rocks just exit
                            	  2571: 
00:0000A688 522D0076        	  2572: 	ADDQ.b	#1,rock_count(a5)		; else increment the rock count
                            	  2573: 
00:0000A68C 6100FB60        	  2574: 	BSR		copy_rock_2			; copy the item parameters from the old rock,
                            	  2575: 							; (d7), to the new rock, (d5)
                            	  2576: 
00:0000A690 701F            	  2577: 	MOVEQ		#$1F,d0			; set the mask for the low 5 bits
00:0000A692 C0355052        	  2578: 	AND.b		y_vel_off(a5,d5.w),d0	; get the new rock y velocity byte
00:0000A696 D000            	  2579: 	ADD.b		d0,d0				; ; 2
00:0000A698 B13530C7        	  2580: 	EOR.b		d0,y_pos_off+1(a5,d3.w)	; purturb the new rock y position low byte
                            	  2581: exit_hit_a_rock
00:0000A69C 4E75            	  2582: 	RTS
                            	  2583: 
                            	  2584: 
                            	  2585: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2586: ;
                            	  2587: ; score per rock size
                            	  2588: 
                            	  2589: rock_score
00:0000A69E 10              	  2590: 	dc.b	$10					; 100 points, small rock
00:0000A69F 05              	  2591: 	dc.b	$05					;  50 points, medium rock
00:0000A6A0 02              	  2592: 	dc.b	$02					;  20 points, large rock
00:0000A6A1 00              	  2593: 	dc.b	$00					;   0 points, null pad byte
                            	  2594: 
                            	  2595: 
                            	  2596: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2597: ;
                            	  2598: ; do the high score checks
                            	  2599: 
                            	  2600: check_hiscores
00:0000A6A2 102B001A        	  2601: 	MOVE.b	num_players(a3),d0	; get the number of players in the game
00:0000A6A6 6A5A            	  2602: 	BPL.s		exit_check_hiscores	; if still players just exit
                            	  2603: 
00:0000A6A8 1B400083        	  2604: 	MOVE.b	d0,high_off(a5)		; clear the player 2 highscore flag
00:0000A6AC 1D400083        	  2605: 	MOVE.b	d0,high_off(a6)		; clear the player 1 highscore flag
                            	  2606: 
00:0000A6B0 177C00010018    	  2607: 	MOVE.b	#$01,player_idx(a3)	; set the player index for player two
00:0000A6B6 4BEB01F7        	  2608: 	LEA		player_2(a3),a5		; set the pointer to player two's variables
00:0000A6BA 4DEB00F3        	  2609: 	LEA		player_1(a3),a6		; set the pointer to player one's variables
                            	  2610: check_hi_player
00:0000A6BE 7400            	  2611: 	MOVEQ		#0,d2				; clear the high score index
00:0000A6C0 302D0080        	  2612: 	MOVE.w	score_off(a5),d0		; get the player score
00:0000A6C4 670E            	  2613: 	BEQ.s		check_hi_next		; if zero go try the other player
                            	  2614: 
                            	  2615: check_hi_loop
00:0000A6C6 B0732027        	  2616: 	CMP.w		hiscores(a3,d2.w),d0	; compare the high score with the player score
00:0000A6CA 6238            	  2617: 	BHI.s		insert_hiscore		; if the player score was more go insert the
                            	  2618: 							; score
                            	  2619: 
00:0000A6CC 5442            	  2620: 	ADDQ.w	#2,d2				; increment the high score index
00:0000A6CE 0C420014        	  2621: 	CMPI.w	#20,d2			; compare with max + 2
00:0000A6D2 65F2            	  2622: 	BCS.s		check_hi_loop		; loop if more high scores to do
                            	  2623: 
                            	  2624: 							; else change to the other player
                            	  2625: check_hi_next
00:0000A6D4 CB4E            	  2626: 	EXG		a5,a6				; swap the players
00:0000A6D6 0A2B00010018    	  2627: 	EORI.b	#1,player_idx(a3)		; toggle the player index
00:0000A6DC 67E0            	  2628: 	BEQ.s		check_hi_player		; loop if more players to do
                            	  2629: 
00:0000A6DE 102D0083        	  2630: 	MOVE.b	high_off(a5),d0		; get player 2's highscore flag
00:0000A6E2 6B14            	  2631: 	BMI.s		exit_hi_chk			; if not entering a high score go clear the
                            	  2632: 							; player count and exit
                            	  2633: 
00:0000A6E4 B02E0083        	  2634: 	CMP.b		high_off(a6),d0		; compare with the player 1 highscore flag
00:0000A6E8 650E            	  2635: 	BCS.s		exit_hi_chk			; if player 2's position < player 1's position
                            	  2636: 							; just exit
                            	  2637: 
00:0000A6EA 5600            	  2638: 	ADDQ.b	#3,d0				; else increment player 2's position to the
                            	  2639: 							; next entry
00:0000A6EC 0C00001E        	  2640: 	CMPI.b	#$1E,d0			; compare the result with max + 1
00:0000A6F0 6502            	  2641: 	BCS.s		save_hi_index		; if less go save the new player 1 index
                            	  2642: 
00:0000A6F2 70FF            	  2643: 	MOVEQ		#-1,d0			; else reset player 2's highscore flag
                            	  2644: save_hi_index
00:0000A6F4 1B400083        	  2645: 	MOVE.b	d0,high_off(a5)		; save player 2's highscore flag
                            	  2646: exit_hi_chk
00:0000A6F8 7000            	  2647: 	MOVEQ		#0,d0				; clear the longword
00:0000A6FA 1740001A        	  2648: 	MOVE.b	d0,num_players(a3)	; clear the number of players in the game
00:0000A6FE 17400020        	  2649: 	MOVE.b	d0,hi_char(a3)		; clear the input character index
                            	  2650: exit_check_hiscores
00:0000A702 4E75            	  2651: 	RTS
                            	  2652: 
                            	  2653: ; insert a new high score into the high score table. the index is in d2.w
                            	  2654: 
                            	  2655: insert_hiscore
00:0000A704 7612            	  2656: 	MOVEQ		#18,d3			; index to the last high score
00:0000A706 781B            	  2657: 	MOVEQ		#27,d4			; index to the last high score initials
                            	  2658: insert_loop
00:0000A708 B443            	  2659: 	CMP.w		d3,d2				; compare the current high score with the insert
                            	  2660: 							; point
00:0000A70A 671E            	  2661: 	BEQ.s		exit_insert_loop		; if there exit the loop
                            	  2662: 
00:0000A70C 37B330253027    	  2663: 	MOVE.w	hiscores-2(a3,d3.w),hiscores(a3,d3.w)
                            	  2664: 							; copy the (n-1)th high score to this one
00:0000A712 17B34038403B    	  2665: 	MOVE.b	hinames-3(a3,d4.w),hinames(a3,d4.w)
                            	  2666: 							; copy the (n-1)th high score name first byte
00:0000A718 17B34039403C    	  2667: 	MOVE.b	hinames-2(a3,d4.w),hinames+1(a3,d4.w)
                            	  2668: 							; copy the (n-1)th high score name second byte
00:0000A71E 17B3403A403D    	  2669: 	MOVE.b	hinames-1(a3,d4.w),hinames+2(a3,d4.w)
                            	  2670: 							; copy the (n-1)th high score name third byte
                            	  2671: 
00:0000A724 5543            	  2672: 	SUBQ.w	#2,d3				; decrement the index to the previous score
00:0000A726 5744            	  2673: 	SUBQ.w	#3,d4				; decrement the index to the previous initials
00:0000A728 66DE            	  2674: 	BNE.s		insert_loop			; loop for the next high score
                            	  2675: 
                            	  2676: exit_insert_loop
00:0000A72A 1B440083        	  2677: 	MOVE.b	d4,high_off(a5)		; save the player highscore flag
00:0000A72E 37803027        	  2678: 	MOVE.w	d0,hiscores(a3,d3.w)	; copy the player score to this one
00:0000A732 17BC000B403B    	  2679: 	MOVE.b	#$0B,hinames(a3,d4.w)	; make the high score name first byte "A"
00:0000A738 4233403C        	  2680: 	CLR.b		hinames+1(a3,d4.w)	; make the high score name second byte " "
00:0000A73C 4233403D        	  2681: 	CLR.b		hinames+2(a3,d4.w)	; make the high score name third byte " "
                            	  2682: 
00:0000A740 177C00F00059    	  2683: 	MOVE.b	#$F0,game_count(a3)	; set the game counter high byte, high score
                            	  2684: 							; entry timeout
                            	  2685: 
00:0000A746 608C            	  2686: 	BRA.s		check_hi_next		; loop for the other player
                            	  2687: 
                            	  2688: 
                            	  2689: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2690: ;
                            	  2691: ; calculate the angle given the delta x,y. the delta is calculated by subtracting the
                            	  2692: ; source x,y co-ordinates from the target x,y co-ordinates. the angle is returned in
                            	  2693: ; d0.b with $00 being 3 o'clock
                            	  2694: ;
                            	  2695: ; d1.w = delta x = target x - source x
                            	  2696: ; d2.w = delta y = target y - source y
                            	  2697: 
                            	  2698: get_atn
00:0000A748 4A42            	  2699: 	TST.w		d2				; test the delta y
00:0000A74A 6A08            	  2700: 	BPL.s		atn_semi			; if +ve skip the delta y negate
                            	  2701: 
00:0000A74C 4442            	  2702: 	NEG.w		d2				; else make delta y positive
00:0000A74E 6104            	  2703: 	BSR.s		atn_semi			; get arctan(y/x) for the semicircle
00:0000A750 4400            	  2704: 	NEG.b		d0				; negate the result
00:0000A752 4E75            	  2705: 	RTS
                            	  2706: 
                            	  2707: ; get arctan(y/x) for the semicircle
                            	  2708: 
                            	  2709: atn_semi
00:0000A754 4A41            	  2710: 	TST.w		d1				; test the delta x
00:0000A756 6A0C            	  2711: 	BPL.s		atn_quad			; if +ve skip the delta x negate
                            	  2712: 
00:0000A758 4441            	  2713: 	NEG.w		d1				; else make delta x positive
00:0000A75A 6108            	  2714: 	BSR.s		atn_quad			; get arctan(y/x) or arctan(x/y)
00:0000A75C 0A000080        	  2715: 	EORI.b	#$80,d0			; reflect 180 degrees
00:0000A760 4400            	  2716: 	NEG.b		d0				; negate the result
00:0000A762 4E75            	  2717: 	RTS
                            	  2718: 
                            	  2719: 
                            	  2720: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2721: ;
                            	  2722: ; get arctan(y/x) or arctan(x/y) for one quadrant.
                            	  2723: 
                            	  2724: atn_quad
00:0000A764 B441            	  2725: 	CMP.w		d1,d2				; compare y with x
00:0000A766 650C            	  2726: 	BCS.s		atn_eight			; if x > y get arctan(y/x) from the table
                            	  2727: 							; and return
                            	  2728: 
00:0000A768 C342            	  2729: 	EXG		d1,d2				; else swap x,y
00:0000A76A 6108            	  2730: 	BSR.s		atn_eight			; get arctan(x/y) from the table
00:0000A76C 04000040        	  2731: 	SUBI.b	#$40,d0			; reflect the quadrant
00:0000A770 4400            	  2732: 	NEG.b		d0				; and negate the result
00:0000A772 4E75            	  2733: 	RTS
                            	  2734: 
                            	  2735: 
                            	  2736: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2737: ;
                            	  2738: ; divide d2.w by d1.w, the six bit result in d0.w is then used to index the ATN()
                            	  2739: ; table to get the result for this octant. (is that the right word for one eighth
                            	  2740: ; of a circle?)
                            	  2741: 
                            	  2742: atn_eight
00:0000A774 7000            	  2743: 	MOVEQ		#0,d0				; clear the result
00:0000A776 7E05            	  2744: 	MOVEQ		#6-1,d7			; set the bit count
                            	  2745: loop_atn
00:0000A778 D442            	  2746: 	ADD.w		d2,d2				; shift the dividend
00:0000A77A 3602            	  2747: 	MOVE.w	d2,d3				; copy the dividend
00:0000A77C 9641            	  2748: 	SUB.w		d1,d3				; compare it with the divisor
00:0000A77E 6502            	  2749: 	BCS.s		skip_sub			; if the dividend < the divisor skip the
                            	  2750: 							; subtract
                            	  2751: 
00:0000A780 9441            	  2752: 	SUB.w		d1,d2				; else subtract the divisor
                            	  2753: skip_sub
00:0000A782 D100            	  2754: 	ADDX.b	d0,d0				; shift a bit into the result
00:0000A784 51CFFFF2        	  2755: 	DBF		d7,loop_atn			; loop if more to do
                            	  2756: 
00:0000A788 0200003F        	  2757: 	ANDI.b	#$3F,d0			; mask the result to $0000 to $003F
00:0000A78C 103B0004        	  2758: 	MOVE.b	atn_tab(pc,d0.w),d0	; get the arctan from the table
00:0000A790 4E75            	  2759: 	RTS
                            	  2760: 
                            	  2761: 
                            	  2762: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2763: ;
                            	  2764: ; arctangent table. returns the effective angle of the dx/dy ratio for scaled values
                            	  2765: ; of dx/dy of up to 0.984375 or 63/64ths. this is only 1/8th of a full circle but it
                            	  2766: ; is easy to rotate and reflect these values to cover the other 7/8ths.
                            	  2767: 
                            	  2768: atn_tab
00:0000A792 20              	  2769: 	dc.b	$20,$20,$1F,$1F,$1F,$1E,$1E,$1E,$1D,$1D,$1C,$1C,$1C,$1B,$1B,$1A
00:0000A793 20
00:0000A794 1F
00:0000A795 1F
00:0000A796 1F
00:0000A797 1E
00:0000A798 1E
00:0000A799 1E
00:0000A79A 1D
00:0000A79B 1D
00:0000A79C 1C
00:0000A79D 1C
00:0000A79E 1C
00:0000A79F 1B
00:0000A7A0 1B
00:0000A7A1 1A
00:0000A7A2 1A              	  2770: 	dc.b	$1A,$1A,$19,$19,$18,$18,$17,$17,$17,$16,$16,$15,$15,$14,$14,$13
00:0000A7A3 1A
00:0000A7A4 19
00:0000A7A5 19
00:0000A7A6 18
00:0000A7A7 18
00:0000A7A8 17
00:0000A7A9 17
00:0000A7AA 17
00:0000A7AB 16
00:0000A7AC 16
00:0000A7AD 15
00:0000A7AE 15
00:0000A7AF 14
00:0000A7B0 14
00:0000A7B1 13
00:0000A7B2 13              	  2771: 	dc.b	$13,$12,$12,$11,$11,$10,$0F,$0F,$0E,$0E,$0D,$0D,$0C,$0B,$0B,$0A
00:0000A7B3 12
00:0000A7B4 12
00:0000A7B5 11
00:0000A7B6 11
00:0000A7B7 10
00:0000A7B8 0F
00:0000A7B9 0F
00:0000A7BA 0E
00:0000A7BB 0E
00:0000A7BC 0D
00:0000A7BD 0D
00:0000A7BE 0C
00:0000A7BF 0B
00:0000A7C0 0B
00:0000A7C1 0A
00:0000A7C2 0A              	  2772: 	dc.b	$0A,$09,$08,$08,$07,$07,$06,$05,$05,$04,$03,$03,$02,$02,$01,$00
00:0000A7C3 09
00:0000A7C4 08
00:0000A7C5 08
00:0000A7C6 07
00:0000A7C7 07
00:0000A7C8 06
00:0000A7C9 05
00:0000A7CA 05
00:0000A7CB 04
00:0000A7CC 03
00:0000A7CD 03
00:0000A7CE 02
00:0000A7CF 02
00:0000A7D0 01
00:0000A7D1 00
                            	  2773: 
                            	  2774: 
                            	  2775: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2776: ;
                            	  2777: ; output a number as a leading zero suppressed character string
                            	  2778: ;
                            	  2779: ; a1 = number address
                            	  2780: ; d7 = number byte count
                            	  2781: 
                            	  2782: output_number
00:0000A7D2 5347            	  2783: 	SUBQ.w	#1,d7				; adjust for the loop type
                            	  2784: output_number_loop
00:0000A7D4 1211            	  2785: 	MOVE.b	(a1),d1			; get a byte
00:0000A7D6 E809            	  2786: 	LSR.b		#4,d1				; shift the high nibble to the low nibble
00:0000A7D8 61000130        	  2787: 	BSR		add_sup_hex_chr		; add a leading zero suppressed character
00:0000A7DC 4A47            	  2788: 	TST.w		d7				; test the byte count
00:0000A7DE 6604            	  2789: 	BNE.s		zero_suppress		; if this isn't the last byte skip the zero
                            	  2790: 							; suppress clear
                            	  2791: 
00:0000A7E0 422B0016        	  2792: 	CLR.b		suppress_0(a3)		; clear the zero suppress for the last digit
                            	  2793: zero_suppress
00:0000A7E4 1219            	  2794: 	MOVE.b	(a1)+,d1			; get a byte and increment the pointer
00:0000A7E6 61000122        	  2795: 	BSR		add_sup_hex_chr		; add a leading zero suppressed character
00:0000A7EA 51CFFFE8        	  2796: 	DBF		d7,output_number_loop	; decrement count and loop if more to do
                            	  2797: 
00:0000A7EE 4E75            	  2798: 	RTS
                            	  2799: 
                            	  2800: 
                            	  2801: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2802: ;
                            	  2803: ; get COS(d0) in d0. d0 is an eight bit value representing a full circle with the
                            	  2804: ; value increasing as you turn widdershins
                            	  2805: 
                            	  2806: cos_d0
00:0000A7F0 06000040        	  2807: 	ADDI.b	#$40,d0			; add 1/4 rotation
                            	  2808: 
                            	  2809: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2810: ;
                            	  2811: ; get SIN(d0) in d0. d0 is an eight bit value representing a full circle with the
                            	  2812: ; value increasing as you turn widdershins
                            	  2813: 
                            	  2814: sin_d0
00:0000A7F4 024000FF        	  2815: 	ANDI.w	#$00FF,d0			; mask one full circle
00:0000A7F8 4A00            	  2816: 	TST.b		d0				; test angle sign
00:0000A7FA 6A06            	  2817: 	BPL.s		cossin_d0			; if +ve just get SIN/COS and return
                            	  2818: 
00:0000A7FC 6104            	  2819: 	BSR.s		cossin_d0			; else get SIN/COS
00:0000A7FE 4440            	  2820: 	NEG.w		d0				; now do twos complement
00:0000A800 4E75            	  2821: 	RTS
                            	  2822: 
                            	  2823: ; get d0 from SIN/COS table
                            	  2824: 
                            	  2825: cossin_d0
00:0000A802 D000            	  2826: 	ADD.b		d0,d0				; ; 2 bytes per word value
00:0000A804 6A02            	  2827: 	BPL.s		a_was_less			; branch if the angle < 1/4 circle
                            	  2828: 
00:0000A806 4400            	  2829: 	NEG.b		d0				; wrap $82 to $FE to $7E to $02
                            	  2830: a_was_less
00:0000A808 303B0004        	  2831: 	MOVE.w	sin_cos(pc,d0.w),d0	; get the SIN/COS value
00:0000A80C 4E75            	  2832: 	RTS
                            	  2833: 
                            	  2834: 
                            	  2835: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2836: ;
                            	  2837: ; SIN/COS table, returns values between $0000 and $7FFF. the last value should be
                            	  2838: ; $8000 but that can cause an overflow in the word length calculations and it's
                            	  2839: ; easier to fudge the table a bit. no one will ever notice.
                            	  2840: 
                            	  2841: sin_cos
00:0000A80E 0000            	  2842: 	dc.w	$0000,$0324,$0648,$096B,$0C8C,$0FAB,$12C8,$15E2
00:0000A810 0324
00:0000A812 0648
00:0000A814 096B
00:0000A816 0C8C
00:0000A818 0FAB
00:0000A81A 12C8
00:0000A81C 15E2
00:0000A81E 18F9            	  2843: 	dc.w	$18F9,$1C0C,$1F1A,$2224,$2528,$2827,$2B1F,$2E11
00:0000A820 1C0C
00:0000A822 1F1A
00:0000A824 2224
00:0000A826 2528
00:0000A828 2827
00:0000A82A 2B1F
00:0000A82C 2E11
00:0000A82E 30FC            	  2844: 	dc.w	$30FC,$33DF,$36BA,$398D,$3C57,$3F17,$41CE,$447B
00:0000A830 33DF
00:0000A832 36BA
00:0000A834 398D
00:0000A836 3C57
00:0000A838 3F17
00:0000A83A 41CE
00:0000A83C 447B
00:0000A83E 471D            	  2845: 	dc.w	$471D,$49B4,$4C40,$4EC0,$5134,$539B,$55F6,$5843
00:0000A840 49B4
00:0000A842 4C40
00:0000A844 4EC0
00:0000A846 5134
00:0000A848 539B
00:0000A84A 55F6
00:0000A84C 5843
00:0000A84E 5A82            	  2846: 	dc.w	$5A82,$5CB4,$5ED7,$60EC,$62F2,$64E9,$66CF,$68A7
00:0000A850 5CB4
00:0000A852 5ED7
00:0000A854 60EC
00:0000A856 62F2
00:0000A858 64E9
00:0000A85A 66CF
00:0000A85C 68A7
00:0000A85E 6A6E            	  2847: 	dc.w	$6A6E,$6C24,$6DCA,$6F5F,$70E3,$7255,$73B6,$7505
00:0000A860 6C24
00:0000A862 6DCA
00:0000A864 6F5F
00:0000A866 70E3
00:0000A868 7255
00:0000A86A 73B6
00:0000A86C 7505
00:0000A86E 7642            	  2848: 	dc.w	$7642,$776C,$7885,$798A,$7A7D,$7B5D,$7C2A,$7CE4
00:0000A870 776C
00:0000A872 7885
00:0000A874 798A
00:0000A876 7A7D
00:0000A878 7B5D
00:0000A87A 7C2A
00:0000A87C 7CE4
00:0000A87E 7D8A            	  2849: 	dc.w	$7D8A,$7E1E,$7E9D,$7F0A,$7F62,$7FA7,$7FD9,$7FF6
00:0000A880 7E1E
00:0000A882 7E9D
00:0000A884 7F0A
00:0000A886 7F62
00:0000A888 7FA7
00:0000A88A 7FD9
00:0000A88C 7FF6
00:0000A88E 7FFF            	  2850: 	dc.w	$7FFF
                            	  2851: 
                            	  2852: 
                            	  2853: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2854: ;
                            	  2855: ; add message d1 to the display list
                            	  2856: 
                            	  2857: add_message
00:0000A890 36BC1000        	  2858: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
                            	  2859: 
00:0000A894 D241            	  2860: 	ADD.w		d1,d1				; make into a word index
00:0000A896 3F01            	  2861: 	MOVE.w	d1,-(sp)			; save the index
                            	  2862: 
00:0000A898 D241            	  2863: 	ADD.w		d1,d1				; make into a word pair index
00:0000A89A 41FA1946        	  2864: 	LEA		mess_origin(pc),a0	; point to the mesage co-ordinate table
00:0000A89E 34301002        	  2865: 	MOVE.w	2(a0,d1.w),d2		; get the message y co-ordinate
00:0000A8A2 32301000        	  2866: 	MOVE.w	(a0,d1.w),d1		; get the message x co-ordinate
00:0000A8A6 6100009E        	  2867: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  2868: 							; a draw command
                            	  2869: 
00:0000A8AA 323C7000        	  2870: 	MOVE.w	#REL7,d1			; make a $7000,$0000 command
00:0000A8AE 610000B0        	  2871: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  2872: 
00:0000A8B2 7003            	  2873: 	MOVEQ		#$03,d0			; set the mask for the language bits
00:0000A8B4 206B000E        	  2874: 	MOVEA.l	switch_addr(a3),a0	; point to the switch
00:0000A8B8 C010            	  2875: 	AND.b		(a0),d0			; get and mask the switch bits
00:0000A8BA D040            	  2876: 	ADD.w		d0,d0				; make into a word pointer
                            	  2877: 
00:0000A8BC 41FA1944        	  2878: 	LEA		mess_table(pc),a0		; point to the mesage language table
00:0000A8C0 30300000        	  2879: 	MOVE.w	(a0,d0.w),d0		; get the offset to the messages
00:0000A8C4 41F00000        	  2880: 	LEA		(a0,d0.w),a0		; get the pointer to the messages
                            	  2881: 
00:0000A8C8 321F            	  2882: 	MOVE.w	(sp)+,d1			; restore the message index
                            	  2883: 
00:0000A8CA 32301000        	  2884: 	MOVE.w	(a0,d1.w),d1		; get the offset to the message
00:0000A8CE 41F01000        	  2885: 	LEA		(a0,d1.w),a0		; get the pointer to the message
00:0000A8D2 43FA18B0        	  2886: 	LEA		char_set(pc),a1		; get the pointer to the character JSRL table
00:0000A8D6 7000            	  2887: 	MOVEQ		#0,d0				; clear the longword
                            	  2888: add_char_loop
00:0000A8D8 1018            	  2889: 	MOVE.b	(a0)+,d0			; get the next character
00:0000A8DA 671A            	  2890: 	BEQ.s		exit_add_message		; if null just exit
                            	  2891: 
                            	  2892: ; convert the character and add it to the vector list
                            	  2893: 
00:0000A8DC 903C0020        	  2894: 	SUB.b		#' ',d0			; subtract [SPACE]
00:0000A8E0 670C            	  2895: 	BEQ.s		add_the_char		; if it was [SPACE] go add it
                            	  2896: 
00:0000A8E2 903C000F        	  2897: 	SUB.b		#15,d0			; convert a number
00:0000A8E6 0C00000B        	  2898: 	CMPI.b	#11,d0			; compare with converted "9"+1
00:0000A8EA 6502            	  2899: 	BCS.s		add_the_char		; if it was <="9" go add it
                            	  2900: 
00:0000A8EC 5F00            	  2901: 	SUBQ.b	#7,d0				; else convert "A" to "Z"
                            	  2902: add_the_char
00:0000A8EE D000            	  2903: 	ADD.b		d0,d0				; ; 2
00:0000A8F0 38F10000        	  2904: 	MOVE.w	(a1,d0.w),(a4)+		; copy the JSRL to the vector list
00:0000A8F4 60E2            	  2905: 	BRA.s		add_char_loop		; loop for next
                            	  2906: 
                            	  2907: exit_add_message
00:0000A8F6 4E75            	  2908: 	RTS
                            	  2909: 
                            	  2910: 
                            	  2911: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2912: ;
                            	  2913: ; timer interrupt. the timer interrupt should be triggered every 16ms
                            	  2914: 
                            	  2915: timer_interrupt
00:0000A8F8 522B001D        	  2916: 	ADDQ.b	#1,sixteen_ms(a3)		; increment the 16ms counter
00:0000A8FC 4E73            	  2917: 	RTE
                            	  2918: 
                            	  2919: 
                            	  2920: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2921: ;
                            	  2922: ; add "PLAYER x" to the vector list
                            	  2923: 
                            	  2924: player_x
00:0000A8FE 7201            	  2925: 	MOVEQ		#1,d1				; message 1 - "PLAYER "
00:0000A900 618E            	  2926: 	BSR		add_message			; add message d1 to the display list
                            	  2927: player_n
00:0000A902 7201            	  2928: 	MOVEQ		#1,d1				; make 0,1 into 1,2
00:0000A904 D22B0018        	  2929: 	ADD.b		player_idx(a3),d1		; add the player index
00:0000A908 600C            	  2930: 	BRA.s		add_hex_chr			; write a hex character to the vector list
                            	  2931: 							; and return
                            	  2932: 
                            	  2933: 
                            	  2934: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2935: ;
                            	  2936: ; if suppress_0 <> 0 write a leading zero suppressed hex character to the vector list
                            	  2937: 
                            	  2938: add_sup_hex_chr
00:0000A90A 4A2B0016        	  2939: 	TST.b		suppress_0(a3)		; test the leading zero suppressed flag
00:0000A90E 6706            	  2940: 	BEQ.s		add_hex_chr			; if not suppressed go write a hex character
                            	  2941: 							; to the vector list
                            	  2942: 
                            	  2943: ; if supressed write a [SPACE] instead of a "0"
                            	  2944: 
00:0000A910 700F            	  2945: 	MOVEQ		#$0F,d0			; set the nibble mask
00:0000A912 C240            	  2946: 	AND.w		d0,d1				; mask the low nibble
00:0000A914 670A            	  2947: 	BEQ.s		add_sup_zero		; if it is zero go write a space
                            	  2948: 
                            	  2949: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2950: ;
                            	  2951: ; write a hex character d1 to the vector list
                            	  2952: 
                            	  2953: add_hex_chr
00:0000A916 C27C000F        	  2954: 	AND.w		#$0F,d1			; mask the low nibble
00:0000A91A 5241            	  2955: 	ADDQ.w	#1,d1				; add 1 to pass the [SPACE] character
00:0000A91C 422B0016        	  2956: 	CLR.b		suppress_0(a3)		; clear the leading zero suppressed flag
                            	  2957: add_sup_zero
00:0000A920 D241            	  2958: 	ADD.w		d1,d1				; ; 2, bytes per character
00:0000A922 2F08            	  2959: 	MOVE.l	a0,-(sp)			; save a0
00:0000A924 41FA185E        	  2960: 	LEA		char_set(pc),a0		; point to the character JSRL table
00:0000A928 38F01000        	  2961: 	MOVE.w	(a0,d1.w),(a4)+		; copy the character JSRL to the vector list
00:0000A92C 205F            	  2962: 	MOVE.l	(sp)+,a0			; restore a0
                            	  2963: 
00:0000A92E 4E75            	  2964: 	RTS
                            	  2965: 
                            	  2966: 
                            	  2967: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2968: ;
                            	  2969: ; convert the a1 address and add it to the vector list as a vector subroutine call
                            	  2970: 
                            	  2971: add_address
00:0000A930 41FA0236        	  2972: 	LEA		vector(pc),a0		; point to the vector memory
00:0000A934 93C8            	  2973: 	SUBA.l	a0,a1				; convert the pointer to an offset
00:0000A936 2209            	  2974: 	MOVE.l	a1,d1				; copy the result
00:0000A938 E249            	  2975: 	LSR.w		#1,d1				; / 2
00:0000A93A C27C0FFF        	  2976: 	AND.w		#$0FFF,d1			; mask the address bits
00:0000A93E 0041C000        	  2977: 	ORI.w		#JSRL,d1			; OR with vector subroutine call
00:0000A942 38C1            	  2978: 	MOVE.w	d1,(a4)+			; copy to the vector list
00:0000A944 4E75            	  2979: 	RTS
                            	  2980: 
                            	  2981: 
                            	  2982: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2983: ;
                            	  2984: ; add 4 ; the co-ordinate pair in d1,d2 to the list as a draw command
                            	  2985: 
                            	  2986: add_coords
00:0000A946 7002            	  2987: 	MOVEQ		#2,d0				; set shift count
00:0000A948 E161            	  2988: 	ASL.w		d0,d1				; x co-ordinate ; 4
00:0000A94A E162            	  2989: 	ASL.w		d0,d2				; y co-ordinate ; 4
                            	  2990: 
00:0000A94C 303C0FFC        	  2991: 	MOVE.w	#$0FFC,d0			; set the co-ordinate mask
00:0000A950 C240            	  2992: 	AND.w		d0,d1				; mask the x co-ordinate
00:0000A952 C440            	  2993: 	AND.w		d0,d2				; mask the y co-ordinate
                            	  2994: 
00:0000A954 0042A000        	  2995: 	ORI.w		#DRAW,d2			; OR in the draw command
00:0000A958 8253            	  2996: 	OR.w		glob_scale(a3),d1		; OR in the global scale
                            	  2997: 
00:0000A95A 38C2            	  2998: 	MOVE.w	d2,(a4)+			; save the command/y co-ordinate to the list
00:0000A95C 38C1            	  2999: 	MOVE.w	d1,(a4)+			; save the scale/x co-ordinate to the list
00:0000A95E 4E75            	  3000: 	RTS
                            	  3001: 
                            	  3002: 
                            	  3003: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3004: ;
                            	  3005: ; add (d1)00,0000 to the vector list
                            	  3006: 
                            	  3007: add_single
00:0000A960 7400            	  3008: 	MOVEQ		#0,d2				; clear the second word
                            	  3009: 
                            	  3010: 
                            	  3011: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3012: ;
                            	  3013: ; add (A)00,(X)00 to the vector list
                            	  3014: 
                            	  3015: add_pair
00:0000A962 38C1            	  3016: 	MOVE.w	d1,(a4)+			; save the first word to the vector list
00:0000A964 38C2            	  3017: 	MOVE.w	d2,(a4)+			; save the second word to the vector list
00:0000A966 4E75            	  3018: 	RTS
                            	  3019: 
                            	  3020: 
                            	  3021: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3022: ;
                            	  3023: ; check the [F2], [F3] and [F4] keys. set the screen size to 640 x 480, 800 x 600 or
                            	  3024: ; 1024 x 768 if the corresponding key has been pressed
                            	  3025: 
                            	  3026: s_controls
                            	  3027: ;	MOVE.l	#$71007273,d1		; [F2], [], [F3] and [F4] keys
                            	  3028: ;	MOVEQ		#19,d0			; check for keypress
                            	  3029: ;	TRAP		#15
                            	  3030: 
                            	  3031: ;	MOVEQ		#33,d0			; set/get output window size
                            	  3032: 
                            	  3033: ;	MOVE.l	d1,d2				; copy result
                            	  3034: ;	BEQ.s		notscreen			; skip screen size if no F key
                            	  3035: 
                            	  3036: ;	MOVE.l	#$028001E0,d1		; set 640 x 480
                            	  3037: ;	TST.l		d2				; test result
                            	  3038: ;	BMI.s		setscreen			; if F2 go set window size
                            	  3039: 
                            	  3040: ;	MOVE.l	#$03200258,d1		; set 800 x 600
                            	  3041: ;	TST.w		d2				; test result
                            	  3042: ;	BMI.s		setscreen			; if F3 go set window size
                            	  3043: 
                            	  3044: 							; else was F4 so ..
                            	  3045: ;	MOVE.l	#$04000300,d1		; set 1024 x 768
                            	  3046: setscreen
                            	  3047: ;	CMP.l		scr_x(a3),d1		; compare with current screen size
                            	  3048: ;	BEQ.s		notscreen			; if already set skip setting it now
                            	  3049: 
                            	  3050: ;	TRAP		#15
                            	  3051: 
                            	  3052: notscreen
                            	  3053: ;	MOVEQ		#0,d1				; get the current window size
                            	  3054: ;	TRAP		#15
                            	  3055: 
00:0000A968 223C03200258    	  3056: 	move.l #$03200258,d1		; always 800x600
00:0000A96E 27410006        	  3057: 	move.l d1,scr_x(a3)			; save the screen x and y size
00:0000A972 4E75            	  3058: 	rts
                            	  3059: 
                            	  3060: 
                            	  3061: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3062: ;
                            	  3063: ; setup stuff.
                            	  3064: 
                            	  3065: Initialise:
00:0000A974 7200            	  3066: 	moveq	#0,d1					; turn off echo
00:0000A976 700C            	  3067: 	moveq	#12,d0				; keyboard echo
00:0000A978 4E4F            	  3068: 	trap #15
                            	  3069: 
00:0000A97A 323CFF00        	  3070: 	move.w #$FF00,d1		; clear screen
00:0000A97E 700B            	  3071: 	moveq #11,d0				; position cursor
00:0000A980 4E4F            	  3072: 	trap #15
                            	  3073: 
00:0000A982 7211            	  3074: 	moveq #17,d1				; enable double buffering
00:0000A984 705C            	  3075: 	moveq	#92,d0				; set draw mode
00:0000A986 4E4F            	  3076: 	trap #15
                            	  3077: 
00:0000A988 720A            	  3078: 	moveq #10,d1				; OR mode drawing, this helps on two ways.
                            	  3079: 							; first it emulates a vector display where
                            	  3080: 							; the vectors that cross can bright up the
                            	  3081: 							; intersection and second it means we can
                            	  3082: 							; forget depth sorting of objects
00:0000A98A 705C            	  3083: 	moveq #92,d0				; set draw mode
00:0000A98C 4E4F            	  3084: 	trap #15
                            	  3085: 
00:0000A98E 47FA1D27        	  3086: 	lea	variables(pc),a3	; get the pointer to the variables base
00:0000A992 4BEB00F3        	  3087: 	lea player_1(a3),a5		; get the pointer to player one's variables
00:0000A996 4DEB01F7        	  3088: 	lea player_2(a3),a6		; get the pointer to player two's variables
                            	  3089: 
                            	  3090: 										; clear all the variable space
00:0000A99A 7000            	  3091: 	moveq #0,d0				; clear the longword
00:0000A99C 41EB0012        	  3092: 	lea hiscore_y(a3),a0		; get the start address
00:0000A9A0 43EB027B        	  3093: 	lea p_2_end(a3),a1			; get the end address
                            	  3094: clear_loop
00:0000A9A4 30C0            	  3095: 	move.w d0,(a0)+			; clear the word
00:0000A9A6 B1C9            	  3096: 	cmpa.l a1,a0				; compare the addresses
00:0000A9A8 66FA            	  3097: 	bne.s clear_loop		; if not at end loop
                            	  3098: 
00:0000A9AA 7008            	  3099: 	moveq #8,d0					; get the time in 1/100 ths seconds
00:0000A9AC 4E4F            	  3100: 	trap #15
                            	  3101: 
00:0000A9AE 0A81DEADBEEF    	  3102: 	eori.l	#$DEADBEEF,d1		; EOR with the initial PRNG seed, this must
                            	  3103: 													; result in any value but zero
00:0000A9B4 2741000A        	  3104: 	move.l	d1,PRNlword(a3)		; save the initial PRNG seed
                            	  3105: 
00:0000A9B8 7203            	  3106: 	moveq #3,d1					; get the switches address
00:0000A9BA 7020            	  3107: 	moveq #32,d0				; simulator hardware
00:0000A9BC 4E4F            	  3108: 	trap #15
                            	  3109: 
00:0000A9BE 2741000E        	  3110: 	move.l d1,switch_addr(a3)	; save the switches address
                            	  3111: 
                            	  3112: 	;LEA		timer_interrupt(pc),a0	; get the timer interrupt routine address
                            	  3113: 	;MOVE.l	a0,$64.w			; save the timer interrupt as interrupt 1
                            	  3114: 
                            	  3115: 	;MOVEQ		#6,d1				; set auto IRQ
                            	  3116: 	;MOVEQ		#$81,d2			; enable IRQ 1
                            	  3117: 	;MOVEQ		#16,d3			; set the time in ms
                            	  3118: 	;MOVEQ		#32,d0			; set simulator hardware
                            	  3119: 	;TRAP		#15
                            	  3120: 
                            	  3121: 	;MOVEQ		#5,d1				; enable exceptions
                            	  3122: 	;MOVEQ		#32,d0			; set simulator hardware
                            	  3123: 	;TRAP		#15
                            	  3124: 
00:0000A9C2 49FA01A4        	  3125: 	lea vector(pc),a4			; get the pointer to the vector list RAM
00:0000A9C6 38BCB000        	  3126: 	move.w #HALT,(a4)			; add HALT to the vector list
                            	  3127: 
00:0000A9CA 61001B5F        	  3128: 	bsr sound_init				; initialise the sounds
                            	  3129: 
00:0000A9CE 70FF            	  3130: 	moveq #-1,d0					; flag high score done
00:0000A9D0 17400176        	  3131: 	move.b d0,p1_high(a3)	; save the player 1 highscore flag
00:0000A9D4 1740027A        	  3132: 	move.b d0,p2_high(a3)	; save the player 2 highscore flag
                            	  3133: 
00:0000A9D8 43FA1CD0        	  3134: 	lea filename(pc),a1		; point to the highscore filename
00:0000A9DC 7033            	  3135: 	moveq	#51,d0					; open existing file
00:0000A9DE 4E4F            	  3136: 	trap #15
                            	  3137: 
00:0000A9E0 4A40            	  3138: 	tst.w d0							; check for errors
00:0000A9E2 6706            	  3139: 	beq.s read_hi					; if no error go read the file
                            	  3140: 
00:0000A9E4 0C400003        	  3141: 	cmpi.w #3,d0					; compare with read only
00:0000A9E8 660A            	  3142: 	bne.s	close_all_2			; if not read only go close all files
                            	  3143: 
                            	  3144: read_hi
00:0000A9EA 43EB0027        	  3145: 	lea hiscores(a3),a1		; point to the highscore tables
00:0000A9EE 7432            	  3146: 	moveq	#50,d2					; set the table length
00:0000A9F0 7035            	  3147: 	moveq	#53,d0					; read file
00:0000A9F2 4E4F            	  3148: 	trap #15
                            	  3149: 
                            	  3150: close_all_2
00:0000A9F4 7032            	  3151: 	moveq #50,d0					; close all files
00:0000A9F6 4E4F            	  3152: 	trap #15
                            	  3153: 
00:0000A9F8 4E75            	  3154: 	rts
                            	  3155: 
                            	  3156: 
                            	  3157: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3158: ;
                            	  3159: ; This is the code that generates the pseudo random sequence. A seed word located in
                            	  3160: ; PRNlword(a3) is loaded into a register before being operated on to generate the
                            	  3161: ; next number in the sequence. This number is then saved as the seed for the next
                            	  3162: ; time it's called.
                            	  3163: ;
                            	  3164: ; This code is adapted from the 32 bit version of RND(n) used in EhBASIC68. Taking
                            	  3165: ; the 19th next number is slower but helps to hide the shift and add nature of this
                            	  3166: ; generator as can be seen from analysing the output.
                            	  3167: 
                            	  3168: gen_prng:
00:0000A9FA 4E75            	  3169: 	rts
00:0000A9FC 48E7E000        	  3170: 	MOVEM.l	d0-d2,-(sp)			; save d0, d1 and d2
00:0000AA00 202B000A        	  3171: 	MOVE.l	PRNlword(a3),d0		; get current seed longword
00:0000AA04 72AF            	  3172: 	MOVEQ		#$AF-$100,d1		; set the EOR value
00:0000AA06 7412            	  3173: 	MOVEQ		#18,d2			; do this 19 times
                            	  3174: Ninc0
00:0000AA08 D080            	  3175: 	ADD.l		d0,d0				; shift left 1 bit
00:0000AA0A 6402            	  3176: 	BCC.s		Ninc1				; if bit not set skip feedback
                            	  3177: 
00:0000AA0C B300            	  3178: 	EOR.b		d1,d0				; do Galois LFSR feedback
                            	  3179: Ninc1
00:0000AA0E 51CAFFF8        	  3180: 	DBF		d2,Ninc0			; loop
                            	  3181: 
00:0000AA12 2740000A        	  3182: 	MOVE.l	d0,PRNlword(a3)		; save back to seed longword
00:0000AA16 4CDF0007        	  3183: 	MOVEM.l	(sp)+,d0-d2			; restore d0, d1 and d2
                            	  3184: 
00:0000AA1A 4E75            	  3185: 	RTS
                            	  3186: 
                            	  3187: 
                            	  3188: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3189: ;
                            	  3190: ; vector generator subroutines. this code emulates the atari digital vector generator
                            	  3191: ; and truns the vector draw list into lines on the screen
                            	  3192: 
                            	  3193: ; vector subroutine return code. if a vector subroutine is called the address for this
                            	  3194: ; code is pushed on the stack
                            	  3195: 
                            	  3196: op_rtsvec
00:0000AA1C 285F            	  3197: 	MOVE.l	(sp)+,a4			; restore the vector pointer
                            	  3198: 
                            	  3199: ; evaluate the next vector command. the command is pointed to by (a4) and execution
                            	  3200: ; will continue until an RTSL or HALT command is encountered. this is a subset of the
                            	  3201: ; battlezone DVG command set
                            	  3202: 
                            	  3203: do_vector
00:0000AA1E 381C            	  3204: 	MOVE.w	(a4)+,d4			; get the vector opcode
00:0000AA20 3004            	  3205: 	MOVE.w	d4,d0				; copy it
00:0000AA22 ED58            	  3206: 	ROL.w		#6,d0				; shift opcode bits to b5-b2
00:0000AA24 0240003C        	  3207: 	ANDI.w	#$003C,d0			; mask the opcode bits
00:0000AA28 4EFB0076        	  3208: 	JMP		vector_base(pc,d0.w)	; go do the vector opcode
                            	  3209: 
                            	  3210: ; call vector subroutine, push the vector pointer and then the vector subroutine
                            	  3211: ; address as the return address then do jump to vector address
                            	  3212: 
                            	  3213: op_call
00:0000AA2C 2F0C            	  3214: 	MOVE.l	a4,-(sp)			; save the vector pointer
00:0000AA2E 487AFFEC        	  3215: 	PEA		op_rtsvec(pc)		; push vector return code as return address
                            	  3216: 
                            	  3217: ; jump to vector, the address is a thirteen bit address
                            	  3218: 
                            	  3219: op_jump
00:0000AA32 C87C0FFF        	  3220: 	AND.w		#$0FFF,d4			; mask the address
00:0000AA36 D844            	  3221: 	ADD.w		d4,d4				; make it a word address
00:0000AA38 49FA012E        	  3222: 	LEA		vector(pc),a4		; reset the vector RAM pointer
00:0000AA3C 49F44000        	  3223: 	LEA		(a4,d4.w),a4		; calculate the new address
00:0000AA40 60DC            	  3224: 	BRA.s		do_vector			; go do the next vector
                            	  3225: 
                            	  3226: ; relative vector routine. co-ordinates are ten bit with sign numbers
                            	  3227: 
                            	  3228: op_vctr
00:0000AA42 3E3C07FF        	  3229: 	MOVE.w	#$07FF,d7			; set the co-ordinate and sign bits mask
00:0000AA46 720A            	  3230: 	MOVEQ		#10,d1			; set the sign bit number
                            	  3231: 
00:0000AA48 C847            	  3232: 	AND.w		d7,d4				; mask the y co-ordinate and sign
00:0000AA4A 0384            	  3233: 	BCLR.l	d1,d4				; test and clear the sign bit
00:0000AA4C 6702            	  3234: 	BEQ.s		no_neg_y11			; if positive skip the negate
                            	  3235: 
00:0000AA4E 4444            	  3236: 	NEG.w		d4				; else negate the y co-ordinate
                            	  3237: no_neg_y11
                            	  3238: 
00:0000AA50 361C            	  3239: 	MOVE.w	(a4)+,d3			; get the second word
00:0000AA52 3403            	  3240: 	MOVE.w	d3,d2				; copy the intensity
                            	  3241: 
00:0000AA54 C647            	  3242: 	AND.w		d7,d3				; mask the x co-ordinate and sign
00:0000AA56 0383            	  3243: 	BCLR.l	d1,d3				; test and clear the sign bit
00:0000AA58 6702            	  3244: 	BEQ.s		no_neg_x11			; if positive skip the negate
                            	  3245: 
00:0000AA5A 4443            	  3246: 	NEG.w		d3				; else negate the x co-ordinate
                            	  3247: no_neg_x11
                            	  3248: 
00:0000AA5C E440            	  3249: 	ASR.w		#2,d0				; make the scale count from the masked JMP
00:0000AA5E 4440            	  3250: 	NEG.w		d0				; make negative
00:0000AA60 D07C0009        	  3251: 	ADD.w		#9,d0				; make 9 - scale
                            	  3252: 
00:0000AA64 E063            	  3253: 	ASR.w		d0,d3				; scale the x co-ordinate
00:0000AA66 E064            	  3254: 	ASR.w		d0,d4				; scale the y co-ordinate
                            	  3255: 
00:0000AA68 600000A2        	  3256: 	BRA		end_vector			; go do the end of the vector draw
                            	  3257: 
                            	  3258: ; set scale and position the beam
                            	  3259: 
                            	  3260: op_abs
00:0000AA6C 3E3C07FF        	  3261: 	MOVE.w	#$07FF,d7			; set the co-ordinate and sign bits mask
00:0000AA70 720A            	  3262: 	MOVEQ		#10,d1			; set the sign bit number
                            	  3263: 
00:0000AA72 C847            	  3264: 	AND.w		d7,d4				; mask the y co-ordinate and sign
00:0000AA74 0384            	  3265: 	BCLR.l	d1,d4				; test and clear the sign bit
00:0000AA76 6702            	  3266: 	BEQ.s		no_neg_y10			; if positive skip the negate
                            	  3267: 
00:0000AA78 4444            	  3268: 	NEG.w		d4				; else negate the y co-ordinate
                            	  3269: no_neg_y10
                            	  3270: 
00:0000AA7A 361C            	  3271: 	MOVE.w	(a4)+,d3			; get the second word
00:0000AA7C 3403            	  3272: 	MOVE.w	d3,d2				; copy the scale
                            	  3273: 
00:0000AA7E C647            	  3274: 	AND.w		d7,d3				; mask the x co-ordinate and sign
00:0000AA80 0383            	  3275: 	BCLR.l	d1,d3				; test and clear the sign bit
00:0000AA82 6702            	  3276: 	BEQ.s		no_neg_x10			; if positive skip the negate
                            	  3277: 
00:0000AA84 4443            	  3278: 	NEG.w		d3				; else negate the x co-ordinate
                            	  3279: no_neg_x10
                            	  3280: 
                            	  3281: ; now convert the scale so it is b15 = direction flag and the rest is the shift count
                            	  3282: 
00:0000AA86 E95A            	  3283: 	ROL.w		#4,d2				; move the scale bits to bits 3 to 0
00:0000AA88 0242000F        	  3284: 	ANDI.w	#$000F,d2			; mask the scale bits
00:0000AA8C 08820003        	  3285: 	BCLR.l	#3,d2				; clear the top bit
00:0000AA90 6706            	  3286: 	BEQ.s		not_right			; ship right shift adjust
                            	  3287: 
00:0000AA92 4442            	  3288: 	NEG.w		d2				; make negative
00:0000AA94 D47C8008        	  3289: 	ADD.w		#$8008,d2			; add offset and flag right shift
                            	  3290: not_right
00:0000AA98 3682            	  3291: 	MOVE.w	d2,(a3)			; save the global scal, offset is zero	##
                            	  3292: ;##	MOVE.w	d2,vector_s(a3)		; save the global scale
                            	  3293: 
00:0000AA9A 7056            	  3294: 	MOVEQ		#86,d0			; set move to x,y
00:0000AA9C 6000009E        	  3295: 	BRA		vector_move			; go do the move
                            	  3296: 
                            	  3297: vector_base
00:0000AAA0 4E75            	  3298: 	RTS						; treat $0xxx as HALT, quit processing vectors
00:0000AAA2 4E71            	  3299: 	NOP						; filler
00:0000AAA4 6000FF9C        	  3300: 	BRA.w		op_vctr			; scale 1 relative long vector
00:0000AAA8 6000FF98        	  3301: 	BRA.w		op_vctr			; scale 2 relative long vector
00:0000AAAC 6000FF94        	  3302: 	BRA.w		op_vctr			; scale 3 relative long vector
00:0000AAB0 6000FF90        	  3303: 	BRA.w		op_vctr			; scale 4 relative long vector
00:0000AAB4 6000FF8C        	  3304: 	BRA.w		op_vctr			; scale 5 relative long vector
00:0000AAB8 6000FF88        	  3305: 	BRA.w		op_vctr			; scale 6 relative long vector
00:0000AABC 6000FF84        	  3306: 	BRA.w		op_vctr			; scale 7 relative long vector
00:0000AAC0 6000FF80        	  3307: 	BRA.w		op_vctr			; scale 8 relative long vector
00:0000AAC4 6000FF7C        	  3308: 	BRA.w		op_vctr			; scale 9 relative long vector
00:0000AAC8 6000FFA2        	  3309: 	BRA.w		op_abs			; set scale and position beam
00:0000AACC 4E75            	  3310: 	RTS						; do HALT, quit processing vectors
00:0000AACE 4E71            	  3311: 	NOP						; filler
00:0000AAD0 6000FF5A        	  3312: 	BRA.w		op_call			; call vector subroutine
00:0000AAD4 4E75            	  3313: 	RTS						; return from vector subroutine
00:0000AAD6 4E71            	  3314: 	NOP						; filler
00:0000AAD8 6000FF58        	  3315: 	BRA.w		op_jump			; do vector jump
                            	  3316: ;##	BRA.w		op_short			; draw relative short vector
                            	  3317: 
                            	  3318: ; do relative short vector
                            	  3319: 
                            	  3320: op_short
00:0000AADC 3E04            	  3321: 	MOVE.w	d4,d7				; copy the opcode
00:0000AADE 02470808        	  3322: 	ANDI.w	#$0808,d7			; mask the scale bits	0000 x000 0000 y000
00:0000AAE2 E94F            	  3323: 	LSL.w		#4,d7				; shift bits to b8,b0	x000 0000 y000 0000
00:0000AAE4 E31F            	  3324: 	ROL.b		#1,d7				; shift bits together	x000 0000 0000 000y
00:0000AAE6 E35F            	  3325: 	ROL.w		#1,d7				; shift bits to b1,b0	0000 0000 0000 00yx
00:0000AAE8 5247            	  3326: 	ADDQ.w	#1,d7				; make 1 to 4
                            	  3327: 
00:0000AAEA 1F04            	  3328: 	MOVE.b	d4,-(sp)			; push the intensity byte
00:0000AAEC 341F            	  3329: 	MOVE.w	(sp)+,d2			; pull the word, intensity now in high byte
                            	  3330: 
00:0000AAEE 7007            	  3331: 	MOVEQ		#7,d0				; set the co-ordinate and sign bits mask
00:0000AAF0 7202            	  3332: 	MOVEQ		#2,d1				; set the sign bit number
                            	  3333: 
00:0000AAF2 3604            	  3334: 	MOVE.w	d4,d3				; copy the opcode for the x co-ordinate
                            	  3335: 
00:0000AAF4 3F04            	  3336: 	MOVE.w	d4,-(sp)			; push the opcode
00:0000AAF6 181F            	  3337: 	MOVE.b	(sp)+,d4			; pull the y co-ordinate byte
                            	  3338: 
00:0000AAF8 C840            	  3339: 	AND.w		d0,d4				; mask the y co-ordinate and sign bits
00:0000AAFA 0384            	  3340: 	BCLR.l	d1,d4				; test and clear the sign bit
00:0000AAFC 6702            	  3341: 	BEQ.s		no_neg_y2			; if positive just exit
                            	  3342: 
00:0000AAFE 4444            	  3343: 	NEG.w		d4				; else negate the y co-ordinate
                            	  3344: no_neg_y2
                            	  3345: 
00:0000AB00 C640            	  3346: 	AND.w		d0,d3				; mask the x co-ordinate and sign bits
00:0000AB02 0383            	  3347: 	BCLR.l	d1,d3				; test and clear the sign bit
00:0000AB04 6702            	  3348: 	BEQ.s		no_neg_x2			; if positive just exit
                            	  3349: 
00:0000AB06 4443            	  3350: 	NEG.w		d3				; else negate the x co-ordinate
                            	  3351: no_neg_x2
                            	  3352: 
00:0000AB08 EF63            	  3353: 	ASL.w		d7,d3				; scale the x magnitude
00:0000AB0A EF64            	  3354: 	ASL.w		d7,d4				; scale the y magnitude
                            	  3355: 
                            	  3356: end_vector
00:0000AB0C 3E13            	  3357: 	MOVE.w	(a3),d7			; get the global scale, offset is zero	##
                            	  3358: ;##	MOVE.w	vector_s(a3),d7		; get the global scale
00:0000AB0E 6A06            	  3359: 	BPL.s		shift_left			; if positive go shift left
                            	  3360: 
                            	  3361: 							; else shift right
00:0000AB10 EE63            	  3362: 	ASR.w		d7,d3				; scale the x co-ordinate
00:0000AB12 EE64            	  3363: 	ASR.w		d7,d4				; scale the y co-ordinate
00:0000AB14 6004            	  3364: 	BRA.s		last_vector			; continue
                            	  3365: 
                            	  3366: shift_left
00:0000AB16 EF63            	  3367: 	ASL.w		d7,d3				; scale the x co-ordinate
00:0000AB18 EF64            	  3368: 	ASL.w		d7,d4				; scale the y co-ordinate
                            	  3369: last_vector
00:0000AB1A D66B0002        	  3370: 	ADD.w		local_x(a3),d3		; add x the co-ordinate to vector x
00:0000AB1E D86B0004        	  3371: 	ADD.w		local_y(a3),d4		; add y the co-ordinate to vector y
                            	  3372: 
00:0000AB22 7056            	  3373: 	MOVEQ		#86,d0			; set move to x,y
                            	  3374: 
00:0000AB24 C47CF000        	  3375: 	AND.w		#$F000,d2			; d2 is intensity
00:0000AB28 6712            	  3376: 	BEQ.s		vector_move			; if zero intensity just do move
                            	  3377: 
00:0000AB2A 7200            	  3378: 	MOVEQ		#0,d1				; clear the longword
00:0000AB2C 3F02            	  3379: 	MOVE.w	d2,-(sp)			; copy the intensity
00:0000AB2E 141F            	  3380: 	MOVE.b	(sp)+,d2			; to the low byte byte
00:0000AB30 1202            	  3381: 	MOVE.b	d2,d1				; copy the intensity byte
00:0000AB32 4841            	  3382: 	SWAP		d1				; move to the high word
00:0000AB34 3202            	  3383: 	MOVE.w	d2,d1				; get the other word
                            	  3384: 
00:0000AB36 7050            	  3385: 	MOVEQ		#80,d0			; set pen colour
00:0000AB38 4E4F            	  3386: 	TRAP		#15
                            	  3387: 
00:0000AB3A 7055            	  3388: 	MOVEQ		#85,d0			; set draw to x,y
                            	  3389: vector_move
00:0000AB3C 3404            	  3390: 	MOVE.w	d4,d2				; copy the y co-ordinate
00:0000AB3E 3203            	  3391: 	MOVE.w	d3,d1				; copy the x co-ordinate
                            	  3392: ;##	BRA.s		display_vector		; display the vector
                            	  3393: 
                            	  3394: 
                            	  3395: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3396: ;
                            	  3397: ; display vector and do next. takes the vector, scales the x and y to the current
                            	  3398: ; screen size - does axis inversion if needed - and then displays it. set up the
                            	  3399: ; graphics function in d0, x co-ordinate in d1.w and y co-ordinate in d2.w
                            	  3400: 
                            	  3401: ;##display_vector
00:0000AB40 37410002        	  3402: 	MOVE.w	d1,local_x(a3)		; save as new local x co-ordinate
00:0000AB44 37420004        	  3403: 	MOVE.w	d2,local_y(a3)		; save as new local y co-ordinate
                            	  3404: 
00:0000AB48 760A            	  3405: 	MOVEQ		#10,d3			; set the shift count for / 1024
                            	  3406: 
00:0000AB4A C3EB0006        	  3407: 	MULS.w	scr_x(a3),d1		; x ; screen x
00:0000AB4E E6A1            	  3408: 	ASR.l		d3,d1				; / 1024
                            	  3409: 
00:0000AB50 947C0080        	  3410: 	SUB.w		#128,d2			; subtract offset to centre vertically
00:0000AB54 C5EB0006        	  3411: 	MULS.w	scr_x(a3),d2		; y ; screen x
00:0000AB58 E6A2            	  3412: 	ASR.l		d3,d2				; / 1024
00:0000AB5A 4442            	  3413: 	NEG.w		d2				; y = 0 is top of screen remember
00:0000AB5C D46B0008        	  3414: 	ADD.w		scr_y(a3),d2		; + screen y
00:0000AB60 5342            	  3415: 	SUBQ.w	#1,d2				; - 1
                            	  3416: 
00:0000AB62 4E4F            	  3417: 	TRAP		#15				; do move or draw
                            	  3418: 
00:0000AB64 6000FEB8        	  3419: 	BRA		do_vector			; go do the next vector opcode
                            	  3420: 
                            	  3421: 
                            	  3422: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3423: ;
                            	  3424: ; vector commands
                            	  3425: 
                            	  3426: REL1		EQU $1000				; draw relative
                            	  3427: REL2		EQU $2000				; draw relative
                            	  3428: REL3		EQU $3000				; draw relative
                            	  3429: REL4		EQU $4000				; draw relative
                            	  3430: REL5		EQU $5000				; draw relative
                            	  3431: REL6		EQU $6000				; draw relative
                            	  3432: REL7		EQU $7000				; draw relative
                            	  3433: REL8		EQU $8000				; draw relative
                            	  3434: REL9		EQU $9000				; draw relative
                            	  3435: DRAW		EQU $A000				; draw absolute
                            	  3436: HALT		EQU $B000				; halt
                            	  3437: JSRL		EQU $C000				; vector subroutine call
                            	  3438: RTSL		EQU $D000				; return from vector subroutine
                            	  3439: JMPL		EQU $E000				; vector jump
                            	  3440: SHRT		EQU $F000				; relative short vector
                            	  3441: 
                            	  3442: 
                            	  3443: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3444: ;
                            	  3445: ; vector list RAM
                            	  3446: 
                            	  3447: vector
00:0000AB68 00              	  3448: 	ds.b	$1000					; 4k of space
00:0000AB69 *
                            	  3449: 
                            	  3450: 
                            	  3451: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3452: ;
                            	  3453: ; vector ROM
                            	  3454: 
                            	  3455: ; copyright symbol followed by JSR's to write "2009 LEE DAVISO", followed by a JMP to
                            	  3456: ; char_n, which is the routine for "N"
                            	  3457: 
                            	  3458: copy_msg
00:0000BB68 A088            	  3459: 	dc.w	$A088,$019A,$7000,$0000,$F573,$F173,$F178,$F177
00:0000BB6A 019A
00:0000BB6C 7000
00:0000BB6E 0000
00:0000BB70 F573
00:0000BB72 F173
00:0000BB74 F178
00:0000BB76 F177
00:0000BB78 F577            	  3460: 	dc.w	$F577,$F578,$3180,$0200,$F875,$FD70,$F871,$FD02
00:0000BB7A F578
00:0000BB7C 3180
00:0000BB7E 0200
00:0000BB80 F875
00:0000BB82 FD70
00:0000BB84 F871
00:0000BB86 FD02
00:0000BB88 CAD6            	  3461: 	dc.w	JSRL+(char_2-vector)>>1		; 2
00:0000BB8A CA81            	  3462: 	dc.w	JSRL+(char_o0-vector)>>1	; 0
00:0000BB8C CA81            	  3463: 	dc.w	JSRL+(char_o0-vector)>>1	; 0
00:0000BB8E CB07            	  3464: 	dc.w	JSRL+(char_9-vector)>>1		; 9
00:0000BB90 CAD0            	  3465: 	dc.w	JSRL+(char_spc-vector)>>1	; [SPACE]
00:0000BB92 CA71            	  3466: 	dc.w	JSRL+(char_l-vector)>>1		; L
00:0000BB94 CA3F            	  3467: 	dc.w	JSRL+(char_e-vector)>>1		; E
00:0000BB96 CA3F            	  3468: 	dc.w	JSRL+(char_e-vector)>>1		; E
00:0000BB98 CAD0            	  3469: 	dc.w	JSRL+(char_spc-vector)>>1	; [SPACE]
00:0000BB9A CA37            	  3470: 	dc.w	JSRL+(char_d-vector)>>1		; D
00:0000BB9C CA1C            	  3471: 	dc.w	JSRL+(char_a-vector)>>1		; A
00:0000BB9E CAB2            	  3472: 	dc.w	JSRL+(char_v-vector)>>1		; V
00:0000BBA0 CA5E            	  3473: 	dc.w	JSRL+(char_i-vector)>>1		; I
00:0000BBA2 CA9F            	  3474: 	dc.w	JSRL+(char_s-vector)>>1		; S
00:0000BBA4 CA81            	  3475: 	dc.w	JSRL+(char_o0-vector)>>1	; O
00:0000BBA6 EA7C            	  3476: 	dc.w	JMPL+(char_n-vector)>>1		; N
                            	  3477: 
                            	  3478: ; table for the various saucer and rock explosions
                            	  3479: 
                            	  3480: expl_tab
00:0000BBA8 C874            	  3481: 	dc.w	JSRL+(expl_0-vector)>>1		; explosion 0
00:0000BBAA C859            	  3482: 	dc.w	JSRL+(expl_1-vector)>>1		; explosion 1
00:0000BBAC C83A            	  3483: 	dc.w	JSRL+(expl_2-vector)>>1		; explosion 2
00:0000BBAE C824            	  3484: 	dc.w	JSRL+(expl_3-vector)>>1		; explosion 3
                            	  3485: 
                            	  3486: ; explosion 3
                            	  3487: 
                            	  3488: expl_3
00:0000BBB0 F80D            	  3489: 	dc.w	$F80D,$F8F8,$FD0D,$F8F8,$FD09,$F8F8,$F10B,$F8F8
00:0000BBB2 F8F8
00:0000BBB4 FD0D
00:0000BBB6 F8F8
00:0000BBB8 FD09
00:0000BBBA F8F8
00:0000BBBC F10B
00:0000BBBE F8F8
00:0000BBC0 F50A            	  3490: 	dc.w	$F50A,$F8F8,$F908,$F8F8,$F309,$F8F8,$F30D,$F8F8
00:0000BBC2 F8F8
00:0000BBC4 F908
00:0000BBC6 F8F8
00:0000BBC8 F309
00:0000BBCA F8F8
00:0000BBCC F30D
00:0000BBCE F8F8
00:0000BBD0 5480            	  3491: 	dc.w	$5480,$0600,$F8F8,$F10F,$F8F8,RTSL
00:0000BBD2 0600
00:0000BBD4 F8F8
00:0000BBD6 F10F
00:0000BBD8 F8F8
00:0000BBDA D000
                            	  3492: 
                            	  3493: ; explosion 2
                            	  3494: 
                            	  3495: expl_2
00:0000BBDC 3000            	  3496: 	dc.w	$3000,$0780,$F8F8,$3780,$0780,$F8F8,$3780,$0380
00:0000BBDE 0780
00:0000BBE0 F8F8
00:0000BBE2 3780
00:0000BBE4 0780
00:0000BBE6 F8F8
00:0000BBE8 3780
00:0000BBEA 0380
00:0000BBEC F8F8            	  3497: 	dc.w	$F8F8,$40E0,$02A0,$F8F8,$35C0,$0380,$F8F8,$3380
00:0000BBEE 40E0
00:0000BBF0 02A0
00:0000BBF2 F8F8
00:0000BBF4 35C0
00:0000BBF6 0380
00:0000BBF8 F8F8
00:0000BBFA 3380
00:0000BBFC 0000            	  3498: 	dc.w	$0000,$F8F8,$42A0,$00E0,$F8F8,$42A0,$04E0,$F8F8
00:0000BBFE F8F8
00:0000BC00 42A0
00:0000BC02 00E0
00:0000BC04 F8F8
00:0000BC06 42A0
00:0000BC08 04E0
00:0000BC0A F8F8
00:0000BC0C 44E0            	  3499: 	dc.w	$44E0,$0780,$F8F8,$40E0,$06A0,$F8F8,RTSL
00:0000BC0E 0780
00:0000BC10 F8F8
00:0000BC12 40E0
00:0000BC14 06A0
00:0000BC16 F8F8
00:0000BC18 D000
                            	  3500: 
                            	  3501: ; explosion 1
                            	  3502: 
                            	  3503: expl_1
00:0000BC1A F807            	  3504: 	dc.w	$F807,$F8F8,$FF07,$F8F8,$FF03,$F8F8,$40C0,$0240
00:0000BC1C F8F8
00:0000BC1E FF07
00:0000BC20 F8F8
00:0000BC22 FF03
00:0000BC24 F8F8
00:0000BC26 40C0
00:0000BC28 0240
00:0000BC2A F8F8            	  3505: 	dc.w	$F8F8,$3580,$0300,$F8F8,$FB00,$F8F8,$4240,$00C0
00:0000BC2C 3580
00:0000BC2E 0300
00:0000BC30 F8F8
00:0000BC32 FB00
00:0000BC34 F8F8
00:0000BC36 4240
00:0000BC38 00C0
00:0000BC3A F8F8            	  3506: 	dc.w	$F8F8,$4240,$04C0,$F8F8,$44C0,$0700,$F8F8,$40C0
00:0000BC3C 4240
00:0000BC3E 04C0
00:0000BC40 F8F8
00:0000BC42 44C0
00:0000BC44 0700
00:0000BC46 F8F8
00:0000BC48 40C0
00:0000BC4A 0640            	  3507: 	dc.w	$0640,$F8F8,RTSL
00:0000BC4C F8F8
00:0000BC4E D000
                            	  3508: 
                            	  3509: ; explosion 0
                            	  3510: 
                            	  3511: expl_0
00:0000BC50 3000            	  3512: 	dc.w	$3000,$0680,$F8F8,$3680,$0680,$F8F8,$3680,$0280
00:0000BC52 0680
00:0000BC54 F8F8
00:0000BC56 3680
00:0000BC58 0680
00:0000BC5A F8F8
00:0000BC5C 3680
00:0000BC5E 0280
00:0000BC60 F8F8            	  3513: 	dc.w	$F8F8,$3140,$03C0,$F8F8,$3540,$0280,$F8F8,$3280
00:0000BC62 3140
00:0000BC64 03C0
00:0000BC66 F8F8
00:0000BC68 3540
00:0000BC6A 0280
00:0000BC6C F8F8
00:0000BC6E 3280
00:0000BC70 0000            	  3514: 	dc.w	$0000,$F8F8,$33C0,$0140,$F8F8,$33C0,$0540,$F8F8
00:0000BC72 F8F8
00:0000BC74 33C0
00:0000BC76 0140
00:0000BC78 F8F8
00:0000BC7A 33C0
00:0000BC7C 0540
00:0000BC7E F8F8
00:0000BC80 44A0            	  3515: 	dc.w	$44A0,$0680,$F8F8,$3140,$07C0,$F8F8,RTSL
00:0000BC82 0680
00:0000BC84 F8F8
00:0000BC86 3140
00:0000BC88 07C0
00:0000BC8A F8F8
00:0000BC8C D000
                            	  3516: 
                            	  3517: ; table for rocks
                            	  3518: 
                            	  3519: rock_tab
00:0000BC8E C897            	  3520: 	dc.w	JSRL+(rock_0-vector)>>1		; top notch rock
00:0000BC90 C8A3            	  3521: 	dc.w	JSRL+(rock_1-vector)>>1		; "X" rock
00:0000BC92 C8B1            	  3522: 	dc.w	JSRL+(rock_2-vector)>>1		; bottom and left notch rock
00:0000BC94 C8BE            	  3523: 	dc.w	JSRL+(rock_3-vector)>>1		; left and right notch rock
                            	  3524: 
                            	  3525: ; top notch rock
                            	  3526: 
                            	  3527: rock_0
00:0000BC96 F908            	  3528: 	dc.w	$F908,$F979,$FD79,$F67D,$F679,$F68F,$F08F,$F97D
00:0000BC98 F979
00:0000BC9A FD79
00:0000BC9C F67D
00:0000BC9E F679
00:0000BCA0 F68F
00:0000BCA2 F08F
00:0000BCA4 F97D
00:0000BCA6 FA78            	  3529: 	dc.w	$FA78,$F979,$FD79,RTSL
00:0000BCA8 F979
00:0000BCAA FD79
00:0000BCAC D000
                            	  3530: 
                            	  3531: ; "X" rock
                            	  3532: 
                            	  3533: rock_1
00:0000BCAE F10A            	  3534: 	dc.w	$F10A,$F17A,$F97D,$F57E,$F17E,$FD7D,$F679,$F67D
00:0000BCB0 F17A
00:0000BCB2 F97D
00:0000BCB4 F57E
00:0000BCB6 F17E
00:0000BCB8 FD7D
00:0000BCBA F679
00:0000BCBC F67D
00:0000BCBE FD79            	  3535: 	dc.w	$FD79,$F179,$F58B,$F38A,$F97D,RTSL
00:0000BCC0 F179
00:0000BCC2 F58B
00:0000BCC4 F38A
00:0000BCC6 F97D
00:0000BCC8 D000
                            	  3536: 
                            	  3537: ; bottom and left notch rock
                            	  3538: 
                            	  3539: rock_2
00:0000BCCA F80D            	  3540: 	dc.w	$F80D,$F57E,$F77A,$F37A,$F778,$F879,$F37A,$F978
00:0000BCCC F57E
00:0000BCCE F77A
00:0000BCD0 F37A
00:0000BCD2 F778
00:0000BCD4 F879
00:0000BCD6 F37A
00:0000BCD8 F978
00:0000BCDA F37E            	  3541: 	dc.w	$F37E,$F07F,$F77F,$F57A,RTSL
00:0000BCDC F07F
00:0000BCDE F77F
00:0000BCE0 F57A
00:0000BCE2 D000
                            	  3542: 
                            	  3543: ; left and right notch rock
                            	  3544: 
                            	  3545: rock_3
00:0000BCE4 F009            	  3546: 	dc.w	$F009,$F17B,$F168,$F27F,$F07F,$F669,$F07F,$F778
00:0000BCE6 F17B
00:0000BCE8 F168
00:0000BCEA F27F
00:0000BCEC F07F
00:0000BCEE F669
00:0000BCF0 F07F
00:0000BCF2 F778
00:0000BCF4 F77A            	  3547: 	dc.w	$F77A,$F17B,$F569,$F969,$F27F,RTSL
00:0000BCF6 F17B
00:0000BCF8 F569
00:0000BCFA F969
00:0000BCFC F27F
00:0000BCFE D000
                            	  3548: 
                            	  3549: ; indirect saucer table
                            	  3550: 
                            	  3551: sauc_jsr
00:0000BD00 C8CD            	  3552: 	dc.w	JSRL+(sauc_vec-vector)>>1	; saucer
                            	  3553: 
                            	  3554: ; saucer
                            	  3555: 
                            	  3556: sauc_vec
00:0000BD02 F10E            	  3557: 	dc.w	$F10E,$F8CA,$F60B,$6000,$D680,$F6DB,$F8CA,$F2DB
00:0000BD04 F8CA
00:0000BD06 F60B
00:0000BD08 6000
00:0000BD0A D680
00:0000BD0C F6DB
00:0000BD0E F8CA
00:0000BD10 F2DB
00:0000BD12 F2DF            	  3558: 	dc.w	$F2DF,$F2CD,$F8CD,$F6CD,$F6DF,RTSL
00:0000BD14 F2CD
00:0000BD16 F8CD
00:0000BD18 F6CD
00:0000BD1A F6DF
00:0000BD1C D000
                            	  3559: 
                            	  3560: ; player ship address table
                            	  3561: 
                            	  3562: play_tab
00:0000BD1E 0022            	  3563: 	dc.w	play_00-play_tab
00:0000BD20 003A            	  3564: 	dc.w	play_01-play_tab
00:0000BD22 005E            	  3565: 	dc.w	play_02-play_tab
00:0000BD24 0082            	  3566: 	dc.w	play_03-play_tab
00:0000BD26 00A6            	  3567: 	dc.w	play_04-play_tab
00:0000BD28 00C8            	  3568: 	dc.w	play_05-play_tab
00:0000BD2A 00EC            	  3569: 	dc.w	play_06-play_tab
00:0000BD2C 0110            	  3570: 	dc.w	play_07-play_tab
00:0000BD2E 0134            	  3571: 	dc.w	play_08-play_tab
00:0000BD30 0158            	  3572: 	dc.w	play_09-play_tab
00:0000BD32 017C            	  3573: 	dc.w	play_0A-play_tab
00:0000BD34 01A0            	  3574: 	dc.w	play_0B-play_tab
00:0000BD36 01C4            	  3575: 	dc.w	play_0C-play_tab
00:0000BD38 01E8            	  3576: 	dc.w	play_0D-play_tab
00:0000BD3A 020C            	  3577: 	dc.w	play_0E-play_tab
00:0000BD3C 0230            	  3578: 	dc.w	play_0F-play_tab
00:0000BD3E 0254            	  3579: 	dc.w	play_10-play_tab
                            	  3580: 
                            	  3581: ; ship and thrust outlines. each ship outline is followed by its thrust outline which
                            	  3582: ; is only copied if the thrust button is pressed
                            	  3583: 
                            	  3584: play_00
00:0000BD40 F60F            	  3585: 	dc.w	$F60F,$FAC8,$F9BD,$6500,$C300,$6500,$C700,$F9B9
00:0000BD42 FAC8
00:0000BD44 F9BD
00:0000BD46 6500
00:0000BD48 C300
00:0000BD4A 6500
00:0000BD4C C700
00:0000BD4E F9B9
00:0000BD50 D000            	  3586: 	dc.w	RTSL
00:0000BD52 F9CE            	  3587: 	dc.w	$F9CE,$F9CA,RTSL
00:0000BD54 F9CA
00:0000BD56 D000
                            	  3588: play_01
00:0000BD58 4640            	  3589: 	dc.w	$4640,$06C0,$5200,$C430,$41C0,$C620,$64B0,$C318
00:0000BD5A 06C0
00:0000BD5C 5200
00:0000BD5E C430
00:0000BD60 41C0
00:0000BD62 C620
00:0000BD64 64B0
00:0000BD66 C318
00:0000BD68 6548            	  3590: 	dc.w	$6548,$C6E0,$4220,$C1C0,RTSL
00:0000BD6A C6E0
00:0000BD6C 4220
00:0000BD6E C1C0
00:0000BD70 D000
00:0000BD72 50D0            	  3591: 	dc.w	$50D0,$C610,$4260,$C3C0,RTSL
00:0000BD74 C610
00:0000BD76 4260
00:0000BD78 C3C0
00:0000BD7A D000
                            	  3592: play_02
00:0000BD7C 4680            	  3593: 	dc.w	$4680,$0680,$43E0,$C4C0,$41A0,$C660,$6468,$C320
00:0000BD7E 0680
00:0000BD80 43E0
00:0000BD82 C4C0
00:0000BD84 41A0
00:0000BD86 C660
00:0000BD88 6468
00:0000BD8A C320
00:0000BD8C 6590            	  3594: 	dc.w	$6590,$C6C0,$4260,$C1A0,RTSL
00:0000BD8E C6C0
00:0000BD90 4260
00:0000BD92 C1A0
00:0000BD94 D000
00:0000BD96 5090            	  3595: 	dc.w	$5090,$C630,$42C0,$C380,RTSL
00:0000BD98 C630
00:0000BD9A 42C0
00:0000BD9C C380
00:0000BD9E D000
                            	  3596: play_03
00:0000BDA0 46C0            	  3597: 	dc.w	$46C0,$0640,$43E0,$C520,$4160,$C680,$6418,$C328
00:0000BDA2 0640
00:0000BDA4 43E0
00:0000BDA6 C520
00:0000BDA8 4160
00:0000BDAA C680
00:0000BDAC 6418
00:0000BDAE C328
00:0000BDB0 65D0            	  3598: 	dc.w	$65D0,$C698,$4280,$C160,RTSL
00:0000BDB2 C698
00:0000BDB4 4280
00:0000BDB6 C160
00:0000BDB8 D000
00:0000BDBA 5060            	  3599: 	dc.w	$5060,$C630,$4320,$C340,RTSL
00:0000BDBC C630
00:0000BDBE 4320
00:0000BDC0 C340
00:0000BDC2 D000
                            	  3600: play_04
00:0000BDC4 F70E            	  3601: 	dc.w	$F70E,$43C0,$C580,$4120,$C6A0,$6038,$C328,$6610
00:0000BDC6 43C0
00:0000BDC8 C580
00:0000BDCA 4120
00:0000BDCC C6A0
00:0000BDCE 6038
00:0000BDD0 C328
00:0000BDD2 6610
00:0000BDD4 C660            	  3602: 	dc.w	$C660,$42A0,$C120,RTSL
00:0000BDD6 42A0
00:0000BDD8 C120
00:0000BDDA D000
00:0000BDDC 5030            	  3603: 	dc.w	$5030,$C640,$4360,$C2E0,RTSL
00:0000BDDE C640
00:0000BDE0 4360
00:0000BDE2 C2E0
00:0000BDE4 D000
                            	  3604: play_05
00:0000BDE6 4720            	  3605: 	dc.w	$4720,$05C0,$4380,$C5E0,$40E0,$C6C0,$6088,$C320
00:0000BDE8 05C0
00:0000BDEA 4380
00:0000BDEC C5E0
00:0000BDEE 40E0
00:0000BDF0 C6C0
00:0000BDF2 6088
00:0000BDF4 C320
00:0000BDF6 6648            	  3606: 	dc.w	$6648,$C630,$42C0,$C0E0,RTSL
00:0000BDF8 C630
00:0000BDFA 42C0
00:0000BDFC C0E0
00:0000BDFE D000
00:0000BE00 5410            	  3607: 	dc.w	$5410,$C640,$43A0,$C2A0,RTSL
00:0000BE02 C640
00:0000BE04 43A0
00:0000BE06 C2A0
00:0000BE08 D000
                            	  3608: play_06
00:0000BE0A 4760            	  3609: 	dc.w	$4760,$0560,$4360,$C640,$4080,$C6C0,$60D8,$C310
00:0000BE0C 0560
00:0000BE0E 4360
00:0000BE10 C640
00:0000BE12 4080
00:0000BE14 C6C0
00:0000BE16 60D8
00:0000BE18 C310
00:0000BE1A 6680            	  3610: 	dc.w	$6680,$C5F0,$42C0,$C080,RTSL
00:0000BE1C C5F0
00:0000BE1E 42C0
00:0000BE20 C080
00:0000BE22 D000
00:0000BE24 5440            	  3611: 	dc.w	$5440,$C630,$43E0,$C240,RTSL
00:0000BE26 C630
00:0000BE28 43E0
00:0000BE2A C240
00:0000BE2C D000
                            	  3612: play_07
00:0000BE2E 4780            	  3613: 	dc.w	$4780,$0500,$4320,$C680,$4040,$C6E0,$6120,$C2F8
00:0000BE30 0500
00:0000BE32 4320
00:0000BE34 C680
00:0000BE36 4040
00:0000BE38 C6E0
00:0000BE3A 6120
00:0000BE3C C2F8
00:0000BE3E 66B0            	  3614: 	dc.w	$66B0,$C5B0,$42E0,$C040,RTSL
00:0000BE40 C5B0
00:0000BE42 42E0
00:0000BE44 C040
00:0000BE46 D000
00:0000BE48 5480            	  3615: 	dc.w	$5480,$C630,$5210,$C0F0,RTSL
00:0000BE4A C630
00:0000BE4C 5210
00:0000BE4E C0F0
00:0000BE50 D000
                            	  3616: play_08
00:0000BE52 4780            	  3617: 	dc.w	$4780,$04C0,$42E0,$C6E0,$4000,$C6E0,$6168,$C2D8
00:0000BE54 04C0
00:0000BE56 42E0
00:0000BE58 C6E0
00:0000BE5A 4000
00:0000BE5C C6E0
00:0000BE5E 6168
00:0000BE60 C2D8
00:0000BE62 66D8            	  3618: 	dc.w	$66D8,$C568,$42E0,$C000,RTSL
00:0000BE64 C568
00:0000BE66 42E0
00:0000BE68 C000
00:0000BE6A D000
00:0000BE6C 54B0            	  3619: 	dc.w	$54B0,$C620,$5220,$C0B0,RTSL
00:0000BE6E C620
00:0000BE70 5220
00:0000BE72 C0B0
00:0000BE74 D000
                            	  3620: play_09
00:0000BE76 47A0            	  3621: 	dc.w	$47A0,$0460,$4280,$C720,$4440,$C6E0,$61B0,$C2B0
00:0000BE78 0460
00:0000BE7A 4280
00:0000BE7C C720
00:0000BE7E 4440
00:0000BE80 C6E0
00:0000BE82 61B0
00:0000BE84 C2B0
00:0000BE86 66F8            	  3622: 	dc.w	$66F8,$C520,$42E0,$C440,RTSL
00:0000BE88 C520
00:0000BE8A 42E0
00:0000BE8C C440
00:0000BE8E D000
00:0000BE90 54F0            	  3623: 	dc.w	$54F0,$C610,$5230,$C080,RTSL
00:0000BE92 C610
00:0000BE94 5230
00:0000BE96 C080
00:0000BE98 D000
                            	  3624: play_0A
00:0000BE9A 47A0            	  3625: 	dc.w	$47A0,$0000,$4240,$C760,$4480,$C6C0,$61F0,$C280
00:0000BE9C 0000
00:0000BE9E 4240
00:0000BEA0 C760
00:0000BEA2 4480
00:0000BEA4 C6C0
00:0000BEA6 61F0
00:0000BEA8 C280
00:0000BEAA 6710            	  3626: 	dc.w	$6710,$C4D8,$42C0,$C480,RTSL
00:0000BEAC C4D8
00:0000BEAE 42C0
00:0000BEB0 C480
00:0000BEB2 D000
00:0000BEB4 4640            	  3627: 	dc.w	$4640,$C7E0,$5230,$C040,RTSL
00:0000BEB6 C7E0
00:0000BEB8 5230
00:0000BEBA C040
00:0000BEBC D000
                            	  3628: play_0B
00:0000BEBE 47A0            	  3629: 	dc.w	$47A0,$0060,$41E0,$C780,$44E0,$C6C0,$6230,$C248
00:0000BEC0 0060
00:0000BEC2 41E0
00:0000BEC4 C780
00:0000BEC6 44E0
00:0000BEC8 C6C0
00:0000BECA 6230
00:0000BECC C248
00:0000BECE 6720            	  3630: 	dc.w	$6720,$C488,$42C0,$C4E0,RTSL
00:0000BED0 C488
00:0000BED2 42C0
00:0000BED4 C4E0
00:0000BED6 D000
00:0000BED8 46A0            	  3631: 	dc.w	$46A0,$C7A0,$5240,$C010,RTSL
00:0000BEDA C7A0
00:0000BEDC 5240
00:0000BEDE C010
00:0000BEE0 D000
                            	  3632: play_0C
00:0000BEE2 4780            	  3633: 	dc.w	$4780,$00C0,$4180,$C7C0,$4520,$C6A0,$6260,$C210
00:0000BEE4 00C0
00:0000BEE6 4180
00:0000BEE8 C7C0
00:0000BEEA 4520
00:0000BEEC C6A0
00:0000BEEE 6260
00:0000BEF0 C210
00:0000BEF2 6728            	  3634: 	dc.w	$6728,$C438,$42A0,$C520,RTSL
00:0000BEF4 C438
00:0000BEF6 42A0
00:0000BEF8 C520
00:0000BEFA D000
00:0000BEFC 46E0            	  3635: 	dc.w	$46E0,$C760,$5240,$C430,RTSL
00:0000BEFE C760
00:0000BF00 5240
00:0000BF02 C430
00:0000BF04 D000
                            	  3636: play_0D
00:0000BF06 4780            	  3637: 	dc.w	$4780,$0100,$4120,$C7E0,$4560,$C680,$6298,$C1D0
00:0000BF08 0100
00:0000BF0A 4120
00:0000BF0C C7E0
00:0000BF0E 4560
00:0000BF10 C680
00:0000BF12 6298
00:0000BF14 C1D0
00:0000BF16 6728            	  3638: 	dc.w	$6728,$C018,$4280,$C560,RTSL
00:0000BF18 C018
00:0000BF1A 4280
00:0000BF1C C560
00:0000BF1E D000
00:0000BF20 4740            	  3639: 	dc.w	$4740,$C720,$5230,$C460,RTSL
00:0000BF22 C720
00:0000BF24 5230
00:0000BF26 C460
00:0000BF28 D000
                            	  3640: play_0E
00:0000BF2A 4760            	  3641: 	dc.w	$4760,$0160,$40C0,$C7E0,$45A0,$C660,$62C0,$C190
00:0000BF2C 0160
00:0000BF2E 40C0
00:0000BF30 C7E0
00:0000BF32 45A0
00:0000BF34 C660
00:0000BF36 62C0
00:0000BF38 C190
00:0000BF3A 6720            	  3642: 	dc.w	$6720,$C068,$4260,$C5A0,RTSL
00:0000BF3C C068
00:0000BF3E 4260
00:0000BF40 C5A0
00:0000BF42 D000
00:0000BF44 4780            	  3643: 	dc.w	$4780,$C6C0,$5230,$C490,RTSL
00:0000BF46 C6C0
00:0000BF48 5230
00:0000BF4A C490
00:0000BF4C D000
                            	  3644: play_0F
00:0000BF4E 4720            	  3645: 	dc.w	$4720,$01C0,$5030,$C600,$45C0,$C620,$62E0,$C148
00:0000BF50 01C0
00:0000BF52 5030
00:0000BF54 C600
00:0000BF56 45C0
00:0000BF58 C620
00:0000BF5A 62E0
00:0000BF5C C148
00:0000BF5E 6718            	  3646: 	dc.w	$6718,$C0B0,$4220,$C5C0,RTSL
00:0000BF60 C0B0
00:0000BF62 4220
00:0000BF64 C5C0
00:0000BF66 D000
00:0000BF68 47C0            	  3647: 	dc.w	$47C0,$C660,$5210,$C4D0,RTSL
00:0000BF6A C660
00:0000BF6C 5210
00:0000BF6E C4D0
00:0000BF70 D000
                            	  3648: play_10
00:0000BF72 F70A            	  3649: 	dc.w	$F70A,$F8CE,$FDCD,$6300,$C100,$6700,$C100,$F9CD
00:0000BF74 F8CE
00:0000BF76 FDCD
00:0000BF78 6300
00:0000BF7A C100
00:0000BF7C 6700
00:0000BF7E C100
00:0000BF80 F9CD
00:0000BF82 D000            	  3650: 	dc.w	RTSL
00:0000BF84 FECD            	  3651: 	dc.w	$FECD,$FACD,RTSL
00:0000BF86 FACD
00:0000BF88 D000
                            	  3652: 
                            	  3653: ; ship outline for player lives
                            	  3654: 
                            	  3655: play_liv
00:0000BF8A F70E            	  3656: 	dc.w	$F70E,$F87A,$FD79,$6300,$7500,$6700,$7500,$F979
00:0000BF8C F87A
00:0000BF8E FD79
00:0000BF90 6300
00:0000BF92 7500
00:0000BF94 6700
00:0000BF96 7500
00:0000BF98 F979
00:0000BF9A 60C0            	  3657: 	dc.w	$60C0,$0280,$D09F
00:0000BF9C 0280
00:0000BF9E D09F
                            	  3658: 
                            	  3659: ; character set
                            	  3660: 
                            	  3661: char_a						; A
00:0000BFA0 FA70            	  3662: 	dc.w	$FA70,$F272,$F672,$FE70
00:0000BFA2 F272
00:0000BFA4 F672
00:0000BFA6 FE70
00:0000BFA8 F906            	  3663: 	dc.w	$F906,$F872,$F602,RTSL
00:0000BFAA F872
00:0000BFAC F602
00:0000BFAE D000
                            	  3664: char_b						; B
00:0000BFB0 FB70            	  3665: 	dc.w	$FB70,$F073,$F571,$F570
00:0000BFB2 F073
00:0000BFB4 F571
00:0000BFB6 F570
00:0000BFB8 F575            	  3666: 	dc.w	$F575,$F077,$F003,$F571
00:0000BFBA F077
00:0000BFBC F003
00:0000BFBE F571
00:0000BFC0 F570            	  3667: 	dc.w	$F570,$F575,$F077,$F803,RTSL
00:0000BFC2 F575
00:0000BFC4 F077
00:0000BFC6 F803
00:0000BFC8 D000
                            	  3668: char_c						; C
00:0000BFCA FB70            	  3669: 	dc.w	$FB70,$F872,$FF06,$F872
00:0000BFCC F872
00:0000BFCE FF06
00:0000BFD0 F872
00:0000BFD2 F002            	  3670: 	dc.w	$F002,RTSL
00:0000BFD4 D000
                            	  3671: char_d						; D
00:0000BFD6 FB70            	  3672: 	dc.w	$FB70,$F072,$F672,$F670
00:0000BFD8 F072
00:0000BFDA F672
00:0000BFDC F670
00:0000BFDE F676            	  3673: 	dc.w	$F676,$F076,$F803,RTSL
00:0000BFE0 F076
00:0000BFE2 F803
00:0000BFE4 D000
                            	  3674: char_e						; E
00:0000BFE6 FB70            	  3675: 	dc.w	$FB70,$F872,$F705,$F077
00:0000BFE8 F872
00:0000BFEA F705
00:0000BFEC F077
00:0000BFEE F700            	  3676: 	dc.w	$F700,$F872,$F002,RTSL
00:0000BFF0 F872
00:0000BFF2 F002
00:0000BFF4 D000
                            	  3677: char_f						; F
00:0000BFF6 FB70            	  3678: 	dc.w	$FB70,$F872,$F705,$F077
00:0000BFF8 F872
00:0000BFFA F705
00:0000BFFC F077
00:0000BFFE F700            	  3679: 	dc.w	$F700,$F803,RTSL
00:0000C000 F803
00:0000C002 D000
                            	  3680: char_g						; G
00:0000C004 FB70            	  3681: 	dc.w	$FB70,$F872,$F670,$F606
00:0000C006 F872
00:0000C008 F670
00:0000C00A F606
00:0000C00C F072            	  3682: 	dc.w	$F072,$F670,$F876,$F803
00:0000C00E F670
00:0000C010 F876
00:0000C012 F803
00:0000C014 D000            	  3683: 	dc.w	RTSL
                            	  3684: char_h						; H
00:0000C016 FB70            	  3685: 	dc.w	$FB70,$F700,$F872,$F300
00:0000C018 F700
00:0000C01A F872
00:0000C01C F300
00:0000C01E FF70            	  3686: 	dc.w	$FF70,$F002,RTSL
00:0000C020 F002
00:0000C022 D000
                            	  3687: char_i						; I
00:0000C024 F872            	  3688: 	dc.w	$F872,$F006,$FB70,$F002
00:0000C026 F006
00:0000C028 FB70
00:0000C02A F002
00:0000C02C F876            	  3689: 	dc.w	$F876,$FF03,RTSL
00:0000C02E FF03
00:0000C030 D000
                            	  3690: char_j						; J
00:0000C032 F200            	  3691: 	dc.w	$F200,$F672,$F072,$FB70
00:0000C034 F672
00:0000C036 F072
00:0000C038 FB70
00:0000C03A FF01            	  3692: 	dc.w	$FF01,RTSL
00:0000C03C D000
                            	  3693: char_k						; K
00:0000C03E FB70            	  3694: 	dc.w	$FB70,$F003,$F777,$F773
00:0000C040 F003
00:0000C042 F777
00:0000C044 F773
00:0000C046 F003            	  3695: 	dc.w	$F003,RTSL
00:0000C048 D000
                            	  3696: char_l						; L
00:0000C04A FB00            	  3697: 	dc.w	$FB00,$FF70,$F872,$F002,RTSL
00:0000C04C FF70
00:0000C04E F872
00:0000C050 F002
00:0000C052 D000
                            	  3698: char_m						; M
00:0000C054 FB70            	  3699: 	dc.w	$FB70,$F672,$F272,$FF70
00:0000C056 F672
00:0000C058 F272
00:0000C05A FF70
00:0000C05C F002            	  3700: 	dc.w	$F002,RTSL
00:0000C05E D000
                            	  3701: char_n						; N
00:0000C060 FB70            	  3702: 	dc.w	$FB70,$FF72,$FB70,$FF01,RTSL
00:0000C062 FF72
00:0000C064 FB70
00:0000C066 FF01
00:0000C068 D000
                            	  3703: char_o0						; O,0
00:0000C06A FB70            	  3704: 	dc.w	$FB70,$F872,$FF70,$F876
00:0000C06C F872
00:0000C06E FF70
00:0000C070 F876
00:0000C072 F803            	  3705: 	dc.w	$F803,RTSL
00:0000C074 D000
                            	  3706: char_p						; P
00:0000C076 FB70            	  3707: 	dc.w	$FB70,$F872,$F770,$F876
00:0000C078 F872
00:0000C07A F770
00:0000C07C F876
00:0000C07E F703            	  3708: 	dc.w	$F703,$F003,RTSL
00:0000C080 F003
00:0000C082 D000
                            	  3709: char_q						; Q
00:0000C084 FB70            	  3710: 	dc.w	$FB70,$F872,$FE70,$F676
00:0000C086 F872
00:0000C088 FE70
00:0000C08A F676
00:0000C08C F076            	  3711: 	dc.w	$F076,$F202,$F672,$F002
00:0000C08E F202
00:0000C090 F672
00:0000C092 F002
00:0000C094 D000            	  3712: 	dc.w	RTSL
                            	  3713: char_r						; R
00:0000C096 FB70            	  3714: 	dc.w	$FB70,$F872,$F770,$F876
00:0000C098 F872
00:0000C09A F770
00:0000C09C F876
00:0000C09E F001            	  3715: 	dc.w	$F001,$F773,$F002,RTSL
00:0000C0A0 F773
00:0000C0A2 F002
00:0000C0A4 D000
                            	  3716: char_s						; S
00:0000C0A6 F872            	  3717: 	dc.w	$F872,$F370,$F876,$F370
00:0000C0A8 F370
00:0000C0AA F876
00:0000C0AC F370
00:0000C0AE F872            	  3718: 	dc.w	$F872,$FF01,RTSL
00:0000C0B0 FF01
00:0000C0B2 D000
                            	  3719: char_t						; T
00:0000C0B4 F002            	  3720: 	dc.w	$F002,$FB70,$F006,$F872
00:0000C0B6 FB70
00:0000C0B8 F006
00:0000C0BA F872
00:0000C0BC FF01            	  3721: 	dc.w	$FF01,RTSL
00:0000C0BE D000
                            	  3722: char_u						; U
00:0000C0C0 FB00            	  3723: 	dc.w	$FB00,$FF70,$F872,$FB70
00:0000C0C2 FF70
00:0000C0C4 F872
00:0000C0C6 FB70
00:0000C0C8 FF01            	  3724: 	dc.w	$FF01,RTSL
00:0000C0CA D000
                            	  3725: char_v						; V
00:0000C0CC FB00            	  3726: 	dc.w	$FB00,$FF71,$FB71,$FF01,RTSL
00:0000C0CE FF71
00:0000C0D0 FB71
00:0000C0D2 FF01
00:0000C0D4 D000
                            	  3727: char_w						; W
00:0000C0D6 FB00            	  3728: 	dc.w	$FB00,$FF70,$F272,$F672
00:0000C0D8 FF70
00:0000C0DA F272
00:0000C0DC F672
00:0000C0DE FB70            	  3729: 	dc.w	$FB70,$FF01,RTSL
00:0000C0E0 FF01
00:0000C0E2 D000
                            	  3730: char_x						; X
00:0000C0E4 FB72            	  3731: 	dc.w	$FB72,$F806,$FF72,$F002,RTSL
00:0000C0E6 F806
00:0000C0E8 FF72
00:0000C0EA F002
00:0000C0EC D000
                            	  3732: char_y						; Y
00:0000C0EE F002            	  3733: 	dc.w	$F002,$FA70,$F276,$F802
00:0000C0F0 FA70
00:0000C0F2 F276
00:0000C0F4 F802
00:0000C0F6 F676            	  3734: 	dc.w	$F676,$FE02,RTSL
00:0000C0F8 FE02
00:0000C0FA D000
                            	  3735: char_z						; Z
00:0000C0FC FB00            	  3736: 	dc.w	$FB00,$F872,$FF76,$F872
00:0000C0FE F872
00:0000C100 FF76
00:0000C102 F872
00:0000C104 F002            	  3737: 	dc.w	$F002,RTSL
00:0000C106 D000
                            	  3738: char_spc						; [SPACE]
00:0000C108 F803            	  3739: 	dc.w	$F803,RTSL
00:0000C10A D000
                            	  3740: char_1						; 1
00:0000C10C F002            	  3741: 	dc.w	$F002,$FB70,$FF02,RTSL
00:0000C10E FB70
00:0000C110 FF02
00:0000C112 D000
                            	  3742: char_2						; 2
00:0000C114 FB00            	  3743: 	dc.w	$FB00,$F872,$F770,$F876
00:0000C116 F872
00:0000C118 F770
00:0000C11A F876
00:0000C11C F770            	  3744: 	dc.w	$F770,$F872,$F002,RTSL
00:0000C11E F872
00:0000C120 F002
00:0000C122 D000
                            	  3745: char_3						; 3
00:0000C124 F872            	  3746: 	dc.w	$F872,$FB70,$F876,$F700
00:0000C126 FB70
00:0000C128 F876
00:0000C12A F700
00:0000C12C F872            	  3747: 	dc.w	$F872,$F702,RTSL
00:0000C12E F702
00:0000C130 D000
                            	  3748: char_4						; 4
00:0000C132 FB00            	  3749: 	dc.w	$FB00,$F770,$F872,$F300
00:0000C134 F770
00:0000C136 F872
00:0000C138 F300
00:0000C13A FF70            	  3750: 	dc.w	$FF70,$F002,RTSL
00:0000C13C F002
00:0000C13E D000
                            	  3751: char_5						; 6
00:0000C140 F872            	  3752: 	dc.w	$F872,$F370,$F876,$F370
00:0000C142 F370
00:0000C144 F876
00:0000C146 F370
00:0000C148 F872            	  3753: 	dc.w	$F872,$FF01,RTSL
00:0000C14A FF01
00:0000C14C D000
                            	  3754: char_6						; 6
00:0000C14E F300            	  3755: 	dc.w	$F300,$F872,$F770,$F876
00:0000C150 F872
00:0000C152 F770
00:0000C154 F876
00:0000C156 FB70            	  3756: 	dc.w	$FB70,$FF03,RTSL
00:0000C158 FF03
00:0000C15A D000
                            	  3757: char_7						; 7
00:0000C15C FB00            	  3758: 	dc.w	$FB00,$F872,$FF70,$F002,RTSL
00:0000C15E F872
00:0000C160 FF70
00:0000C162 F002
00:0000C164 D000
                            	  3759: char_8						; 8
00:0000C166 F872            	  3760: 	dc.w	$F872,$FB70,$F876,$FF70
00:0000C168 FB70
00:0000C16A F876
00:0000C16C FF70
00:0000C16E F300            	  3761: 	dc.w	$F300,$F872,$F702,RTSL
00:0000C170 F872
00:0000C172 F702
00:0000C174 D000
                            	  3762: char_9						; 9
00:0000C176 F802            	  3763: 	dc.w	$F802,$FB70,$F876,$F770
00:0000C178 FB70
00:0000C17A F876
00:0000C17C F770
00:0000C17E F872            	  3764: 	dc.w	$F872,$F702,RTSL
00:0000C180 F702
00:0000C182 D000
                            	  3765: 
                            	  3766: ; indirect table for character set
                            	  3767: 
                            	  3768: char_set
00:0000C184 CAD0            	  3769: 	dc.w	JSRL+(char_spc-vector)>>1	; [SPACE]
00:0000C186 CA81            	  3770: 	dc.w	JSRL+(char_o0-vector)>>1	; 0 also O
00:0000C188 CAD2            	  3771: 	dc.w	JSRL+(char_1-vector)>>1		; 1
00:0000C18A CAD6            	  3772: 	dc.w	JSRL+(char_2-vector)>>1		; 2
00:0000C18C CADE            	  3773: 	dc.w	JSRL+(char_3-vector)>>1		; 3
00:0000C18E CAE5            	  3774: 	dc.w	JSRL+(char_4-vector)>>1		; 4
00:0000C190 CAEC            	  3775: 	dc.w	JSRL+(char_5-vector)>>1		; 5
00:0000C192 CAF3            	  3776: 	dc.w	JSRL+(char_6-vector)>>1		; 6
00:0000C194 CAFA            	  3777: 	dc.w	JSRL+(char_7-vector)>>1		; 7
00:0000C196 CAFF            	  3778: 	dc.w	JSRL+(char_8-vector)>>1		; 8
00:0000C198 CB07            	  3779: 	dc.w	JSRL+(char_9-vector)>>1		; 9
00:0000C19A CA1C            	  3780: 	dc.w	JSRL+(char_a-vector)>>1		; A
00:0000C19C CA24            	  3781: 	dc.w	JSRL+(char_b-vector)>>1		; B
00:0000C19E CA31            	  3782: 	dc.w	JSRL+(char_c-vector)>>1		; C
00:0000C1A0 CA37            	  3783: 	dc.w	JSRL+(char_d-vector)>>1		; D
00:0000C1A2 CA3F            	  3784: 	dc.w	JSRL+(char_e-vector)>>1		; E
00:0000C1A4 CA47            	  3785: 	dc.w	JSRL+(char_f-vector)>>1		; F
00:0000C1A6 CA4E            	  3786: 	dc.w	JSRL+(char_g-vector)>>1		; G
00:0000C1A8 CA57            	  3787: 	dc.w	JSRL+(char_h-vector)>>1		; H
00:0000C1AA CA5E            	  3788: 	dc.w	JSRL+(char_i-vector)>>1		; I
00:0000C1AC CA65            	  3789: 	dc.w	JSRL+(char_j-vector)>>1		; J
00:0000C1AE CA6B            	  3790: 	dc.w	JSRL+(char_k-vector)>>1		; K
00:0000C1B0 CA71            	  3791: 	dc.w	JSRL+(char_l-vector)>>1		; L
00:0000C1B2 CA76            	  3792: 	dc.w	JSRL+(char_m-vector)>>1		; M
00:0000C1B4 CA7C            	  3793: 	dc.w	JSRL+(char_n-vector)>>1		; N
00:0000C1B6 CA81            	  3794: 	dc.w	JSRL+(char_o0-vector)>>1	; O also 0
00:0000C1B8 CA87            	  3795: 	dc.w	JSRL+(char_p-vector)>>1		; P
00:0000C1BA CA8E            	  3796: 	dc.w	JSRL+(char_q-vector)>>1		; Q
00:0000C1BC CA97            	  3797: 	dc.w	JSRL+(char_r-vector)>>1		; R
00:0000C1BE CA9F            	  3798: 	dc.w	JSRL+(char_s-vector)>>1		; S
00:0000C1C0 CAA6            	  3799: 	dc.w	JSRL+(char_t-vector)>>1		; T
00:0000C1C2 CAAC            	  3800: 	dc.w	JSRL+(char_u-vector)>>1		; U
00:0000C1C4 CAB2            	  3801: 	dc.w	JSRL+(char_v-vector)>>1		; V
00:0000C1C6 CAB7            	  3802: 	dc.w	JSRL+(char_w-vector)>>1		; W
00:0000C1C8 CABE            	  3803: 	dc.w	JSRL+(char_x-vector)>>1		; X
00:0000C1CA CAC3            	  3804: 	dc.w	JSRL+(char_y-vector)>>1		; Y
00:0000C1CC CACA            	  3805: 	dc.w	JSRL+(char_z-vector)>>1		; Z
                            	  3806: 
                            	  3807: ; indirect shot table
                            	  3808: 
                            	  3809: shot_jsr
00:0000C1CE CB34            	  3810: 	dc.w	JSRL+(shot_vec-vector)>>1	; shot
                            	  3811: 
                            	  3812: ; shot vector object, a small cross of intensity $F
                            	  3813: 
                            	  3814: shot_vec
00:0000C1D0 7420            	  3815: 	dc.w	$7420,$0000
00:0000C1D2 0000
00:0000C1D4 7040            	  3816: 	dc.w	$7040,$F000
00:0000C1D6 F000
00:0000C1D8 7420            	  3817: 	dc.w	$7420,$0420
00:0000C1DA 0420
00:0000C1DC 7000            	  3818: 	dc.w	$7000,$F040
00:0000C1DE F040
00:0000C1E0 D000            	  3819: 	dc.w	RTSL
                            	  3820: 
                            	  3821: 
                            	  3822: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3823: ;
                            	  3824: ; canned messages
                            	  3825: 
                            	  3826: ; x,y co-ordinates for the message origins
                            	  3827: 
                            	  3828: mess_origin
00:0000C1E2 0064            	  3829: 	dc.w	$0064,$00B6				; message 0 x,y
00:0000C1E4 00B6
00:0000C1E6 0064            	  3830: 	dc.w	$0064,$00B6				; message 1 x,y
00:0000C1E8 00B6
00:0000C1EA 000C            	  3831: 	dc.w	$000C,$00AA				; message 2 x,y
00:0000C1EC 00AA
00:0000C1EE 000C            	  3832: 	dc.w	$000C,$00A2				; message 3 x,y
00:0000C1F0 00A2
00:0000C1F2 000C            	  3833: 	dc.w	$000C,$009A				; message 4 x,y
00:0000C1F4 009A
00:0000C1F6 000C            	  3834: 	dc.w	$000C,$0092				; message 5 x,y
00:0000C1F8 0092
00:0000C1FA 0064            	  3835: 	dc.w	$0064,$00C6				; message 6 x,y
00:0000C1FC 00C6
00:0000C1FE 0064            	  3836: 	dc.w	$0064,$009D				; message 7 x,y
00:0000C200 009D
                            	  3837: 
                            	  3838: ; message tables
                            	  3839: 
                            	  3840: mess_table
00:0000C202 0008            	  3841: 	dc.w	e_messages-mess_table		; english
00:0000C204 00C2            	  3842: 	dc.w	d_messages-mess_table		; german
00:0000C206 019E            	  3843: 	dc.w	f_messages-mess_table		; french
00:0000C208 026C            	  3844: 	dc.w	s_messages-mess_table		; spanish
                            	  3845: 
                            	  3846: ; message offset table
                            	  3847: 
                            	  3848: e_messages
00:0000C20A 0010            	  3849: 	dc.w	e_mess_0-e_messages		; message 0
00:0000C20C 001C            	  3850: 	dc.w	e_mess_1-e_messages		; message 1
00:0000C20E 0024            	  3851: 	dc.w	e_mess_2-e_messages		; message 2
00:0000C210 0046            	  3852: 	dc.w	e_mess_3-e_messages		; message 3
00:0000C212 0061            	  3853: 	dc.w	e_mess_4-e_messages		; message 4
00:0000C214 007E            	  3854: 	dc.w	e_mess_5-e_messages		; message 5
00:0000C216 00A5            	  3855: 	dc.w	e_mess_6-e_messages		; message 6
00:0000C218 00B0            	  3856: 	dc.w	e_mess_7-e_messages		; message 7
                            	  3857: 
                            	  3858: e_mess_0
00:0000C21A 484947482053434F	  3859: 	dc.b	'HIGH SCORES',$00
00:0000C222 524553
00:0000C225 00
                            	  3860: e_mess_1
00:0000C226 504C4159455220  	  3861: 	dc.b	'PLAYER ',$00
00:0000C22D 00
                            	  3862: e_mess_2
00:0000C22E 594F55522053434F	  3863: 	dc.b	'YOUR SCORE IS ONE OF THE TEN BEST',$00
00:0000C236 5245204953204F4E
00:0000C23E 45204F4620544845
00:0000C246 2054454E20424553
00:0000C24E 54
00:0000C24F 00
                            	  3864: e_mess_3
00:0000C250 504C454153452045	  3865: 	dc.b	'PLEASE ENTER YOUR INITIALS',$00
00:0000C258 4E54455220594F55
00:0000C260 5220494E49544941
00:0000C268 4C53
00:0000C26A 00
                            	  3866: e_mess_4
00:0000C26B 5055534820524F54	  3867: 	dc.b	'PUSH ROTATE TO SELECT LETTER',$00
00:0000C273 41544520544F2053
00:0000C27B 454C454354204C45
00:0000C283 54544552
00:0000C287 00
                            	  3868: e_mess_5
00:0000C288 5055534820485950	  3869: 	dc.b	'PUSH HYPERSPACE WHEN LETTER IS CORRECT',$00
00:0000C290 4552535041434520
00:0000C298 5748454E204C4554
00:0000C2A0 5445522049532043
00:0000C2A8 4F5252454354
00:0000C2AE 00
                            	  3870: e_mess_6
00:0000C2AF 5055534820535441	  3871: 	dc.b	'PUSH START',$00
00:0000C2B7 5254
00:0000C2B9 00
                            	  3872: e_mess_7
00:0000C2BA 47414D45204F5645	  3873: 	dc.b	'GAME OVER',$00
00:0000C2C2 52
00:0000C2C3 00
                            	  3874: 
                            	  3875: 	ds.w	0					; ensure even
                            	  3876: 
                            	  3877: ; german message offset table
                            	  3878: 
                            	  3879: d_messages
00:0000C2C4 0010            	  3880: 	dc.w	d_mess_0-d_messages		; message 0
00:0000C2C6 0020            	  3881: 	dc.w	d_mess_1-d_messages		; message 1
00:0000C2C8 0029            	  3882: 	dc.w	d_mess_2-d_messages		; message 2
00:0000C2CA 0050            	  3883: 	dc.w	d_mess_3-d_messages		; message 3
00:0000C2CC 0073            	  3884: 	dc.w	d_mess_4-d_messages		; message 4
00:0000C2CE 0096            	  3885: 	dc.w	d_mess_5-d_messages		; message 5
00:0000C2D0 00BC            	  3886: 	dc.w	d_mess_6-d_messages		; message 6
00:0000C2D2 00D2            	  3887: 	dc.w	d_mess_7-d_messages		; message 7
                            	  3888: 
                            	  3889: d_mess_0
00:0000C2D4 484F454348535445	  3890: 	dc.b	'HOECHSTERGEBNIS',$00
00:0000C2DC 524745424E4953
00:0000C2E3 00
                            	  3891: d_mess_1
00:0000C2E4 535049454C455220	  3892: 	dc.b	'SPIELER ',$00
00:0000C2EC 00
                            	  3893: d_mess_2
00:0000C2ED 4948522045524745	  3894: 	dc.b	'IHR ERGEBNIS IST EINES DER ZEHN BESTEN',$00
00:0000C2F5 424E495320495354
00:0000C2FD 2045494E45532044
00:0000C305 4552205A45484E20
00:0000C30D 42455354454E
00:0000C313 00
                            	  3895: d_mess_3
00:0000C314 4249545445204745	  3896: 	dc.b	'BITTE GEBEN SIE IHRE INITIALEN EIN',$00
00:0000C31C 42454E2053494520
00:0000C324 4948524520494E49
00:0000C32C 5449414C454E2045
00:0000C334 494E
00:0000C336 00
                            	  3897: d_mess_4
00:0000C337 5A55522042554348	  3898: 	dc.b	'ZUR BUCHSTABENWAHL ROTATE DRUECKEN',$00
00:0000C33F 53544142454E5741
00:0000C347 484C20524F544154
00:0000C34F 452044525545434B
00:0000C357 454E
00:0000C359 00
                            	  3899: d_mess_5
00:0000C35A 57454E4E20425543	  3900: 	dc.b	'WENN BUCHSTABE OK HYPERSPACE DRUECKEN',$00
00:0000C362 485354414245204F
00:0000C36A 4B20485950455253
00:0000C372 5041434520445255
00:0000C37A 45434B454E
00:0000C37F 00
                            	  3901: d_mess_6
00:0000C380 53544152544B4E4F	  3902: 	dc.b	'STARTKNOEPFE DRUECKEN',$00
00:0000C388 4550464520445255
00:0000C390 45434B454E
00:0000C395 00
                            	  3903: d_mess_7
00:0000C396 535049454C454E44	  3904: 	dc.b	'SPIELENDE',$00
00:0000C39E 45
00:0000C39F 00
                            	  3905: 
                            	  3906: 	ds.w	0					; ensure even
                            	  3907: 
                            	  3908: ; french message offset table
                            	  3909: 
                            	  3910: f_messages
00:0000C3A0 0010            	  3911: 	dc.w	f_mess_0-f_messages		; message 0
00:0000C3A2 001F            	  3912: 	dc.w	f_mess_1-f_messages		; message 1
00:0000C3A4 0026            	  3913: 	dc.w	f_mess_2-f_messages		; message 2
00:0000C3A6 004A            	  3914: 	dc.w	f_mess_3-f_messages		; message 3
00:0000C3A8 0063            	  3915: 	dc.w	f_mess_4-f_messages		; message 4
00:0000C3AA 0085            	  3916: 	dc.w	f_mess_5-f_messages		; message 5
00:0000C3AC 00AE            	  3917: 	dc.w	f_mess_6-f_messages		; message 6
00:0000C3AE 00C0            	  3918: 	dc.w	f_mess_7-f_messages		; message 7
                            	  3919: 
                            	  3920: f_mess_0
00:0000C3B0 4D45494C4C455552	  3921: 	dc.b	'MEILLEUR SCORE',$00
00:0000C3B8 2053434F5245
00:0000C3BE 00
                            	  3922: f_mess_1
00:0000C3BF 4A4F55455220    	  3923: 	dc.b	'JOUER ',$00
00:0000C3C5 00
                            	  3924: f_mess_2
00:0000C3C6 564F545245205343	  3925: 	dc.b	'VOTRE SCORE EST UN DES 10 MEILLEURS',$00
00:0000C3CE 4F52452045535420
00:0000C3D6 554E204445532031
00:0000C3DE 30204D45494C4C45
00:0000C3E6 555253
00:0000C3E9 00
                            	  3926: f_mess_3
00:0000C3EA 53565020454E5452	  3927: 	dc.b	'SVP ENTREZ VOS INITIALES',$00
00:0000C3F2 455A20564F532049
00:0000C3FA 4E495449414C4553
00:0000C402 00
                            	  3928: f_mess_4
00:0000C403 504F555353455A20	  3929: 	dc.b	'POUSSEZ ROTATE POUR VOS INITIALES',$00
00:0000C40B 524F544154452050
00:0000C413 4F555220564F5320
00:0000C41B 494E495449414C45
00:0000C423 53
00:0000C424 00
                            	  3930: f_mess_5
00:0000C425 504F555353455A20	  3931: 	dc.b	'POUSSEZ HYPERSPACE QUAND LETTRE CORRECTE',$00
00:0000C42D 4859504552535041
00:0000C435 4345205155414E44
00:0000C43D 204C455454524520
00:0000C445 434F525245435445
00:0000C44D 00
                            	  3932: f_mess_6
00:0000C44E 4150505559455220	  3933: 	dc.b	'APPUYER SUR START',$00
00:0000C456 5355522053544152
00:0000C45E 54
00:0000C45F 00
                            	  3934: f_mess_7
00:0000C460 46494E2044452050	  3935: 	dc.b	'FIN DE PARTIE',$00
00:0000C468 4152544945
00:0000C46D 00
                            	  3936: 
                            	  3937: 	ds.w	0					; ensure even
                            	  3938: 
                            	  3939: ; spanish message offset table
                            	  3940: 
                            	  3941: s_messages
00:0000C46E 0010            	  3942: 	dc.w	s_mess_0-s_messages		; message 0
00:0000C470 0018            	  3943: 	dc.w	s_mess_1-s_messages		; message 1
00:0000C472 0021            	  3944: 	dc.w	s_mess_2-s_messages		; message 2
00:0000C474 0048            	  3945: 	dc.w	s_mess_3-s_messages		; message 3
00:0000C476 0066            	  3946: 	dc.w	s_mess_4-s_messages		; message 4
00:0000C478 008E            	  3947: 	dc.w	s_mess_5-s_messages		; message 5
00:0000C47A 00A0            	  3948: 	dc.w	s_mess_6-s_messages		; message 6
00:0000C47C 00AD            	  3949: 	dc.w	s_mess_7-s_messages		; message 7
                            	  3950: 
                            	  3951: s_mess_0
00:0000C47E 5245434F524453  	  3952: 	dc.b	'RECORDS',$00
00:0000C485 00
                            	  3953: s_mess_1
00:0000C486 4A554741444F5220	  3954: 	dc.b	'JUGADOR ',$00
00:0000C48E 00
                            	  3955: s_mess_2
00:0000C48F 53552050554E5441	  3956: 	dc.b	'SU PUNTAJE ESTA ENTRE LOS DIEZ MEJORES',$00
00:0000C497 4A45204553544120
00:0000C49F 454E545245204C4F
00:0000C4A7 53204449455A204D
00:0000C4AF 454A4F524553
00:0000C4B5 00
                            	  3957: s_mess_3
00:0000C4B6 504F52204641564F	  3958: 	dc.b	'POR FAVOR ENTRE SUS INICIALES',$00
00:0000C4BE 5220454E54524520
00:0000C4C6 53555320494E4943
00:0000C4CE 49414C4553
00:0000C4D3 00
                            	  3959: s_mess_4
00:0000C4D4 4F5052494D412052	  3960: 	dc.b	'OPRIMA ROTATE PARA SELECCIONAR LA LETRA',$00
00:0000C4DC 4F54415445205041
00:0000C4E4 52412053454C4543
00:0000C4EC 43494F4E4152204C
00:0000C4F4 41204C45545241
00:0000C4FB 00
                            	  3961: s_mess_5
00:0000C4FC 4F5052494D412048	  3962: 	dc.b	'OPRIMA HYPERSPACE',$00
00:0000C504 5950455253504143
00:0000C50C 45
00:0000C50D 00
                            	  3963: s_mess_6
00:0000C50E 50554C5341522053	  3964: 	dc.b	'PULSAR START',$00
00:0000C516 54415254
00:0000C51A 00
                            	  3965: s_mess_7
00:0000C51B 4A5545474F205445	  3966: 	dc.b	'JUEGO TERMINADO',$00
00:0000C523 524D494E41444F
00:0000C52A 00
                            	  3967: 
                            	  3968: 	ds.w	0					; ensure even
                            	  3969: 
                            	  3970: 
                            	  3971: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3972: ;
                            	  3973: ; include files
                            	  3974: 
                            	  3975: 	INCLUDE	"games/asteroids/sounds.x68"

Source: "games\asteroids\sounds.x68"
                            	     1: *************************************************************************************
                            	     2: *														*
                            	     3: *	Sound routines V1.00. This is an include file for asteroids 1_0.x68		*
                            	     4: *														*
                            	     5: *	load the sounds, play an indexed sample. Uses the DirextX sound play and	*
                            	     6: *	requires EASy68K 3.7.10 beta or later.							*
                            	     7: *														*
                            	     8: *************************************************************************************
                            	     9: 
                            	    10: sfire_snd	EQU  0
                            	    11: pfire_snd	EQU  1
                            	    12: thrst_snd	EQU  2
                            	    13: smsau_snd	EQU  3
                            	    14: lgsau_snd	EQU  4
                            	    15: sexpl_snd	EQU  5
                            	    16: mexpl_snd	EQU  sexpl_snd+1
                            	    17: lexpl_snd	EQU  sexpl_snd+2
                            	    18: beat1_snd	EQU  8				* beat_2 must be beat_1 XOR 1
                            	    19: beat2_snd	EQU  9				* see above
                            	    20: extra_snd	EQU 10
                            	    21: 
                            	    22: 
                            	    23: *************************************************************************************
                            	    24: *
                            	    25: * initialise the sounds routine
                            	    26: 
                            	    27: sound_init
00:0000C52C 422B0014        	    28: 	MOVE.b	#0,s_key(a3)		* clear the last [S] key status
00:0000C530 177C00FF0015    	    29: 	MOVE.b	#-1,play_sound(a3)	* set the sound flag
                            	    30: 
00:0000C536 43FA0098        	    31: 	LEA		beat1_sound(pc),a1	* point to the background beat sound file name
00:0000C53A 7208            	    32: 	MOVEQ		#beat1_snd,d1		* index 10
00:0000C53C 614E            	    33: 	BSR.s		load_sound			* load the sound into directx memory
                            	    34: 
00:0000C53E 43FA00A2        	    35: 	LEA		beat2_sound(pc),a1	* point to the background beat sound file name
00:0000C542 7209            	    36: 	MOVEQ		#beat2_snd,d1		* index 9
00:0000C544 6146            	    37: 	BSR.s		load_sound			* load the sound into directx memory
                            	    38: 
00:0000C546 43FA00AC        	    39: 	LEA		lexpl_sound(pc),a1	* point to the large explosion sound file name
00:0000C54A 7207            	    40: 	MOVEQ		#lexpl_snd,d1		* index 8
00:0000C54C 613E            	    41: 	BSR.s		load_sound			* load the sound into directx memory
                            	    42: 
00:0000C54E 43FA00B9        	    43: 	LEA		mexpl_sound(pc),a1	* point to the medium explosion sound file name
00:0000C552 7206            	    44: 	MOVEQ		#mexpl_snd,d1		* index 7
00:0000C554 6136            	    45: 	BSR.s		load_sound			* load the sound into directx memory
                            	    46: 
00:0000C556 43FA00C6        	    47: 	LEA		sexpl_sound(pc),a1	* point to the small explosion sound file name
00:0000C55A 7205            	    48: 	MOVEQ		#sexpl_snd,d1		* index 6
00:0000C55C 612E            	    49: 	BSR.s		load_sound			* load the sound into directx memory
                            	    50: 
00:0000C55E 43FA00D3        	    51: 	LEA		extra_sound(pc),a1	* point to the extra life sound file name
00:0000C562 720A            	    52: 	MOVEQ		#extra_snd,d1		* index 5
00:0000C564 6126            	    53: 	BSR.s		load_sound			* load the sound into directx memory
                            	    54: 
00:0000C566 43FA00E1        	    55: 	LEA		lgsau_sound(pc),a1	* point to the large saucer sound file name
00:0000C56A 7204            	    56: 	MOVEQ		#lgsau_snd,d1		* index 4
00:0000C56C 6124            	    57: 	BSR.s		load_old_sound		* load the sound into sound memory
                            	    58: 
00:0000C56E 43FA00EE        	    59: 	LEA		smsau_sound(pc),a1	* point to the small saucer sound file name
00:0000C572 7203            	    60: 	MOVEQ		#smsau_snd,d1		* index 3
00:0000C574 611C            	    61: 	BSR.s		load_old_sound		* load the sound into directx memory
                            	    62: 
00:0000C576 43FA00FB        	    63: 	LEA		thrst_sound(pc),a1	* point to the ship thrust sound file name
00:0000C57A 7202            	    64: 	MOVEQ		#thrst_snd,d1		* index 2
00:0000C57C 610E            	    65: 	BSR.s		load_sound			* load the sound into directx memory
                            	    66: 
00:0000C57E 43FA0106        	    67: 	LEA		pfire_sound(pc),a1	* point to the player fire sound file name
00:0000C582 7201            	    68: 	MOVEQ		#pfire_snd,d1		* index 1
00:0000C584 6106            	    69: 	BSR.s		load_sound			* load the sound into directx memory
                            	    70: 
00:0000C586 43FA0110        	    71: 	LEA		sfire_sound(pc),a1	* point to the saucer fire sound file name
00:0000C58A 7200            	    72: 	MOVEQ		#sfire_snd,d1		* index 0
                            	    73: 
                            	    74: 
                            	    75: *************************************************************************************
                            	    76: *
                            	    77: * load the sound into directx memory
                            	    78: 
                            	    79: load_sound
00:0000C58C 704A            	    80: 	MOVEQ		#74,d0			* load the sound into directx memory
00:0000C58E 4E4F            	    81: 	TRAP		#15
                            	    82: 
00:0000C590 4E75            	    83: 	RTS
                            	    84: 
                            	    85: 
                            	    86: *************************************************************************************
                            	    87: *
                            	    88: * load the sound into sound memory
                            	    89: 
                            	    90: load_old_sound
00:0000C592 7047            	    91: 	MOVEQ		#71,d0			* load the sound into sound memory
00:0000C594 4E4F            	    92: 	TRAP		#15
                            	    93: 
00:0000C596 4E75            	    94: 	RTS
                            	    95: 
                            	    96: 
                            	    97: *************************************************************************************
                            	    98: *
                            	    99: * play a sound sample
                            	   100: 
                            	   101: play_sample
00:0000C598 4A2B001A        	   102: 	TST.b		num_players(a3)		* test the number of players in the game
00:0000C59C 6718            	   103: 	BEQ.s		exit_play_sample		* if no players left just exit
                            	   104: 
00:0000C59E 4A2B0015        	   105: 	TST.b		play_sound(a3)		* test the sound flag
00:0000C5A2 6712            	   106: 	BEQ.s		exit_play_sample		* if the sound is off just exit
                            	   107: 
00:0000C5A4 7048            	   108: 	MOVEQ		#72,d0			* play a sound from sound memory
00:0000C5A6 0C410003        	   109: 	CMPI.w	#smsau_snd,d1		* is it the small saucer sound
00:0000C5AA 6708            	   110: 	BEQ.s		old_sound_play		* if so go play it with the old player
                            	   111: 
00:0000C5AC 0C410004        	   112: 	CMPI.w	#lgsau_snd,d1		* is it the large saucer sound
00:0000C5B0 6702            	   113: 	BEQ.s		old_sound_play		* if so go play it with the old player
                            	   114: 
00:0000C5B2 704B            	   115: 	MOVEQ		#75,d0			* play a sound from directx memory
                            	   116: old_sound_play
00:0000C5B4 4E4F            	   117: 	TRAP		#15
                            	   118: 
                            	   119: exit_play_sample
00:0000C5B6 4E75            	   120: 	RTS
                            	   121: 
                            	   122: 
                            	   123: *************************************************************************************
                            	   124: *
                            	   125: * test the sound key
                            	   126: 
                            	   127: sound_key
00:0000C5B8 7253            	   128: 	MOVEQ		#$53,d1			* [][][][S] key
00:0000C5BA 7013            	   129: 	MOVEQ		#19,d0			* check for keypress
00:0000C5BC 4E4F            	   130: 	TRAP		#15
                            	   131: 
00:0000C5BE 102B0014        	   132: 	MOVE.b	s_key(a3),d0		* get the last key(s) state
00:0000C5C2 B300            	   133: 	EOR.b		d1,d0				* compare the result with the last key(s) state,
                            	   134: 							* each byte is now $FF if a key has changed or
                            	   135: 							* $00 if a key has not changed
00:0000C5C4 C001            	   136: 	AND.b		d1,d0				* make each byte $FF if key just pressed or
                            	   137: 							* $00 if key not just pressed
00:0000C5C6 B12B0015        	   138: 	EOR.b		d0,play_sound(a3)		* if key just pressed toggle the sound flag
00:0000C5CA 17410014        	   139: 	MOVE.b	d1,s_key(a3)		* save the last [S] key status
00:0000C5CE 4E75            	   140: 	RTS
                            	   141: 
                            	   142: 
                            	   143: *************************************************************************************
                            	   144: *
                            	   145: * sound file names
                            	   146: 
                            	   147: beat1_sound
00:0000C5D0 73616D706C65735C	   148: 	dc.b	'samples\beat1.wav',$00		* background beat sound
00:0000C5D8 62656174312E7761
00:0000C5E0 76
00:0000C5E1 00
                            	   149: 
                            	   150: beat2_sound
00:0000C5E2 73616D706C65735C	   151: 	dc.b	'samples\beat2.wav',$00		* background beat sound
00:0000C5EA 62656174322E7761
00:0000C5F2 76
00:0000C5F3 00
                            	   152: 
                            	   153: lexpl_sound
00:0000C5F4 73616D706C65735C	   154: 	dc.b	'samples\lexplode.wav',$00	* large explosion sound
00:0000C5FC 6C6578706C6F6465
00:0000C604 2E776176
00:0000C608 00
                            	   155: 
                            	   156: mexpl_sound
00:0000C609 73616D706C65735C	   157: 	dc.b	'samples\mexplode.wav',$00	* medium explosion sound
00:0000C611 6D6578706C6F6465
00:0000C619 2E776176
00:0000C61D 00
                            	   158: 
                            	   159: sexpl_sound
00:0000C61E 73616D706C65735C	   160: 	dc.b	'samples\sexplode.wav',$00	* small explosion sound
00:0000C626 736578706C6F6465
00:0000C62E 2E776176
00:0000C632 00
                            	   161: 
                            	   162: extra_sound
00:0000C633 73616D706C65735C	   163: 	dc.b	'samples\extraship.wav',$00	* extra life sound
00:0000C63B 6578747261736869
00:0000C643 702E776176
00:0000C648 00
                            	   164: 
                            	   165: lgsau_sound
00:0000C649 73616D706C65735C	   166: 	dc.b	'samples\lgsaucer.wav',$00	* large saucer sound
00:0000C651 6C67736175636572
00:0000C659 2E776176
00:0000C65D 00
                            	   167: 
                            	   168: smsau_sound
00:0000C65E 73616D706C65735C	   169: 	dc.b	'samples\smsaucer.wav',$00	* small saucer sound
00:0000C666 736D736175636572
00:0000C66E 2E776176
00:0000C672 00
                            	   170: 
                            	   171: thrst_sound
00:0000C673 73616D706C65735C	   172: 	dc.b	'samples\thrust.wav',$00	* ship thrust sound
00:0000C67B 7468727573742E77
00:0000C683 6176
00:0000C685 00
                            	   173: 
                            	   174: pfire_sound
00:0000C686 73616D706C65735C	   175: 	dc.b	'samples\pfire.wav',$00		* player fire sound
00:0000C68E 70666972652E7761
00:0000C696 76
00:0000C697 00
                            	   176: 
                            	   177: sfire_sound
00:0000C698 73616D706C65735C	   178: 	dc.b	'samples\sfire.wav',$00		* saucer fire sound
00:0000C6A0 73666972652E7761
00:0000C6A8 76
00:0000C6A9 00
                            	   179: 
                            	   180: 	ds.w	0					* ensure even
                            	   181: 
                            	   182: 
                            	   183: *************************************************************************************
                            	   184: 
                            	   185: 

Source: "games\asteroids\asteroids 1_0.x68"
                            	  3976: 							; sound routines
                            	  3977: 
                            	  3978: 
                            	  3979: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3980: ;
                            	  3981: ; high score table filename
                            	  3982: 
                            	  3983: filename
00:0000C6AA 61737465726F6964	  3984: 	dc.b		'asteroids.hi',0		; highscore filename
00:0000C6B2 732E6869
00:0000C6B6 00
                            	  3985: 	ds.w		0				; ensure even
                            	  3986: 
                            	  3987: 
                            	  3988: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3989: ;
                            	  3990: ; variables
                            	  3991: 
                            	  3992: variables
                            	  3993: 
                            	  3994: 	OFFSET	0				; going to use relative addressing
                            	  3995: 
                            	  3996: vector_s
                            	  3997: ;##	ds.w	1				; vector scale
02:00000000 0000            	  3998: glob_scale	ds.w	1				; global scale
                            	  3999: 
                            	  4000: 
02:00000002 0000            	  4001: local_x	ds.w	1				; local screen x co-ordinate offset
02:00000004 0000            	  4002: local_y	ds.w	1				; local screen y co-ordinate offset
                            	  4003: 
02:00000006 0000            	  4004: scr_x		ds.w	1				; screen x size
02:00000008 0000            	  4005: scr_y		ds.w	1				; screen y size
                            	  4006: 
02:0000000A 00000000        	  4007: PRNlword	ds.l	1				; PRNG seed long word
                            	  4008: 
02:0000000E 00000000        	  4009: switch_addr	ds.l	1				; hardware switch address
                            	  4010: 
02:00000012 0000            	  4011: hiscore_y	ds.w	1				; high score y co-ordinate
                            	  4012: 
                            	  4013: 
02:00000014 00              	  4014: s_key		ds.b	1				; last [s] key status
02:00000015 00              	  4015: play_sound	ds.b	1				; sound flag
                            	  4016: 
02:00000016 00              	  4017: suppress_0	ds.b	1				; leading zero suppress flag
                            	  4018: 							; 0 = don't suppress
                            	  4019: 
02:00000017 00              	  4020: high_idx	ds.b	1				; high score index, single byte, 1 to 10 in BCD
                            	  4021: 
02:00000018 00              	  4022: player_idx	ds.b	1				; player index
                            	  4023: 							; 0 = player 1
                            	  4024: 							; 1 = player 2
                            	  4025: 
02:00000019 00              	  4026: past_play	ds.b	1				; number of players that were in the game
                            	  4027: 
02:0000001A 00              	  4028: num_players	ds.b	1				; number of players in the game
                            	  4029: 							; $00 - game over
                            	  4030: 							; $01 - 1 player game
                            	  4031: 							; $02 - 2 player game
                            	  4032: 							; $FF - game over, high score not checked
                            	  4033: 
02:0000001B 00              	  4034: ss_count	ds.b	1				; starting ship count
                            	  4035: 
02:0000001C 00              	  4036: px_time	ds.b	1				; "PLAYER x" timer. while this is non zero
                            	  4037: 							; "PLAYER x" will be displayed. this is used at
                            	  4038: 							; the beginning of any game and at the beginning
                            	  4039: 							; of each turn in a two player game
                            	  4040: 
02:0000001D 00              	  4041: sixteen_ms	ds.b	1				; 16ms counter, incremented every 16ms by the
                            	  4042: 							; timer interrupt and cleared by the main
                            	  4043: 							; program loop
                            	  4044: 
02:0000001E 00              	  4045: p_orient	ds.b	1				; player orientation, this is shared by both
                            	  4046: 							; players as it is in the arcade machine
                            	  4047: 							;
                            	  4048: 							; $00 = right
                            	  4049: 							; $40 = up
                            	  4050: 							; $80 = left
                            	  4051: 							; $C0 = down
                            	  4052: 							;
                            	  4053: 							; this is $00 = right then anticlockwise each
                            	  4054: 							; positive step being 1.40625 degrees so that
                            	  4055: 							; by the time you get back to $00 one full
                            	  4056: 							; rotation has been done
                            	  4057: 
02:0000001F 00              	  4058: s_orient	ds.b	1				; shot direction, see above
                            	  4059: 
02:00000020 00              	  4060: hi_char	ds.b	1				; high score input character index
                            	  4061: 
02:00000021 00              	  4062: last_fire	ds.b	1				; fire key last state register
02:00000022 00              	  4063: last_hype	ds.b	1				; hyperspace key last state register
                            	  4064: 
02:00000023 00              	  4065: thump_snd	ds.b	1				; thump sound value
02:00000024 00              	  4066: thump_time	ds.b	1				; thump sound change timer
02:00000025 00              	  4067: time_count	ds.b	1				; game counter byte
                            	  4068: 
02:00000026 00              	  4069: hyper		ds.b	1				; hyperspace flag
                            	  4070: 							; $00 = no jump
                            	  4071: 							; $01 = jump successful
                            	  4072: 							; $80 = jump unsuccessful
                            	  4073: 							; $xx = 
                            	  4074: 
                            	  4075: 		ds.w	0
                            	  4076: 
02:00000027 0000            	  4077: hiscores	ds.w	10				; high score table, each score is a BCD word
02:00000029 *
02:0000003B 00              	  4078: hinames	ds.b	3*10				; high score initials table
02:0000003C *
                            	  4079: 
02:00000059 0000            	  4080: game_count	ds.w	1				; game counter word
                            	  4081: 
02:0000005B 0000            	  4082: expl_x_pos	ds.w	6				; player ship explosion pieces x positions
02:0000005D *
                            	  4083: 
02:00000067 0000            	  4084: expl_y_pos	ds.w	6				; player ship explosion pieces y positions
02:00000069 *
                            	  4085: 
                            	  4086: 
                            	  4087: ; player 1 variables
                            	  4088: 
                            	  4089: player_1	EQU	*+$80				; player one variables base
                            	  4090: 
                            	  4091: x_pos_off	EQU	*-player_1			; offset to the x position base
02:00000073 0000            	  4092: 		ds.w	$1B				; item x position base address
02:00000075 *
                            	  4093: 
                            	  4094: p_xpos_off	EQU	*-player_1			; offset to the player x position
02:000000A9 0000            	  4095: 		ds.w	1				; player x position
                            	  4096: 
                            	  4097: s_xpos_off	EQU	*-player_1			; offset to the saucer x position
02:000000AB 0000            	  4098: 		ds.w	1				; saucer x position
                            	  4099: 
                            	  4100: f_xpos_off	EQU	*-player_1			; offset to the player x position
02:000000AD 0000            	  4101: 		ds.w	6				; fire objects x position
02:000000AF *
                            	  4102: x_pos_end	EQU	*-player_1			; offset to the flags end
                            	  4103: 
                            	  4104: y_pos_off	EQU	*-player_1			; offset to the y position base
02:000000B9 0000            	  4105: 		ds.w	$1B				; item y position base address
02:000000BB *
                            	  4106: 
                            	  4107: p_ypos_off	EQU	*-player_1			; offset to the player y position
02:000000EF 0000            	  4108: 		ds.w	1				; player y position
                            	  4109: s_ypos_off	EQU	*-player_1			; offset to the saucer y position
02:000000F1 0000            	  4110: 		ds.w	1				; saucer y position
                            	  4111: 
                            	  4112: f_ypos_off	EQU	*-player_1			; offset to the player y position
02:000000F3 0000            	  4113: 		ds.w	6				; fire objects y position
02:000000F5 *
                            	  4114: 
                            	  4115: 							; items $xx00 to $xx1A are rocks
                            	  4116: 							; $00 = no item
                            	  4117: 							; $0x = item exists
                            	  4118: 							; $Ax = item exploding
                            	  4119: 
                            	  4120: flags_off	EQU	*-player_1			; offset to the flags base
02:000000FF 00              	  4121: 		ds.b	$1B				; space for the rock flags
02:00000100 *
                            	  4122: 
                            	  4123: p_flag_off	EQU	*-player_1			; offset to the player flag
02:0000011A 00              	  4124: 		ds.b	1				; player flag
                            	  4125: 
                            	  4126: s_flag_off	EQU	*-player_1			; offset to the saucer flag
02:0000011B 00              	  4127: 		ds.b	1				; saucer flag
                            	  4128: 							; $00 = no saucer
                            	  4129: 							; $01 = small saucer
                            	  4130: 							; $02 = large saucer
                            	  4131: 							; $8x = saucer exploding
                            	  4132: 
                            	  4133: s_fire_off	EQU	*-player_1			; offset to the saucer fire flags
02:0000011C 00              	  4134: 		ds.b	2				; saucer fire objects
02:0000011D *
                            	  4135: 
                            	  4136: p_fire_off	EQU	*-player_1			; offset to the player fire flags
02:0000011E 00              	  4137: 		ds.b	4				; player fire objects
02:0000011F *
                            	  4138: flag_end	EQU	*-player_1			; offset to the flags end
                            	  4139: 
                            	  4140: x_vel_off	EQU	*-player_1			; offset to the x velocity base
02:00000122 00              	  4141: 		ds.b	$1B				; item x velocity base address
02:00000123 *
                            	  4142: 
                            	  4143: p_xvel_off	EQU	*-player_1			; offset to the player x velocity
02:0000013D 00              	  4144: 		ds.b	1				; player x velocity
                            	  4145: 
                            	  4146: s_xvel_off	EQU	*-player_1			; offset to the saucer x velocity
02:0000013E 00              	  4147: 		ds.b	1				; saucer x velocity
                            	  4148: 
                            	  4149: f_xvel_off	EQU	*-player_1			; offset to the fire objects x velocity
02:0000013F 00              	  4150: 		ds.b	6				; fire objects x velocity
02:00000140 *
                            	  4151: 
                            	  4152: y_vel_off	EQU	*-player_1			; offset to the x velocity base
02:00000145 00              	  4153: 		ds.b	$1B				; item y velocity base address
02:00000146 *
                            	  4154: 
                            	  4155: p_yvel_off	EQU	*-player_1			; offset to the player y velocity
02:00000160 00              	  4156: 		ds.b	1				; player y velocity
                            	  4157: 
                            	  4158: s_yvel_off	EQU	*-player_1			; offset to the saucer y velocity
02:00000161 00              	  4159: 		ds.b	1				; saucer y velocity
                            	  4160: 
                            	  4161: f_yvel_off	EQU	*-player_1			; offset to the fire objects y velocity
02:00000162 00              	  4162: 		ds.b	6				; fire objects y velocity
02:00000163 *
                            	  4163: 
                            	  4164: 
                            	  4165: i_rk_count	EQU	*-player_1			; offset to the initial rock count
02:00000168 00              	  4166: 		ds.b	1				; initial rock count
                            	  4167: rock_count	EQU	*-player_1			; offset to the rock count
02:00000169 00              	  4168: 		ds.b	1				; rock count
                            	  4169: 
                            	  4170: sauc_cntdn	EQU	*-player_1			; offset to the saucer countdown timer
02:0000016A 00              	  4171: 		ds.b	1				; saucer countdown timer
                            	  4172: 
                            	  4173: i_sauc_tim	EQU	*-player_1			; offset to the initial saucer timer
02:0000016B 00              	  4174: 		ds.b	1				; small saucer boundary/initial saucer timer
                            	  4175: 
                            	  4176: r_hit_tim	EQU	*-player_1			; offset to the rock hit timer
02:0000016C 00              	  4177: 		ds.b	1				; rock hit timer. if this times out because the
                            	  4178: 							; player hasn't shot a rock for a while then
                            	  4179: 							; the saucer timer initial value is decremented
                            	  4180: 							; so that the saucers come faster if the player
                            	  4181: 							; is just ignoring the last rock
                            	  4182: 
                            	  4183: hide_p_cnt	EQU	*-player_1			; offset to the hide the player count
02:0000016D 00              	  4184: 		ds.b	1				; hide the player count. when this count is non
                            	  4185: 							; zero the player is not displayed and the
                            	  4186: 							; thump sound does not sound. this count is set
                            	  4187: 							; to various lengths after certain events have
                            	  4188: 							; occured
                            	  4189: 							;
                            	  4190: 							; $0x player hidden, will appear
                            	  4191: 							; $8x player hidden, gonna die
                            	  4192: 
                            	  4193: new_rocks	EQU	*-player_1			; offset to the new rocks flag
02:0000016E 00              	  4194: 		ds.b	1				; generate new rocks flag
                            	  4195: 							; 0 = generate new rocks
                            	  4196: thmp_sndi	EQU	*-player_1			; offset to the thump sound change initial value
02:0000016F 00              	  4197: 		ds.b	1				; thump sound change timer initial value
                            	  4198: 
                            	  4199: min_rocks	EQU	*-player_1			; offset to the minimum rock count
02:00000170 00              	  4200: 		ds.b	1				; minimum rock count before the saucer initial
                            	  4201: 							; timer starts to decrement
                            	  4202: 
                            	  4203: p_xvlo_off	EQU	*-player_1			; offset to the player y velocity low byte
02:00000171 00              	  4204: 		ds.b	1				; player x velocity low byte
                            	  4205: p_yvlo_off	EQU	*-player_1			; offset to the player y velocity low byte
02:00000172 00              	  4206: 		ds.b	1				; player y velocity low byte
                            	  4207: 
                            	  4208: 		ds.w	0				; ensure even
                            	  4209: 
                            	  4210: score_off	EQU	*-player_1			; offset to the score word
02:00000173 0000            	  4211: p1_score	ds.w	1				; player score
                            	  4212: 
                            	  4213: ships_off	EQU	*-player_1			; offset to the ship count
02:00000175 00              	  4214: p1_ships	ds.b	1				; player 1 ship count
                            	  4215: 
                            	  4216: high_off	EQU	*-player_1			; offset to the player entering hiscore flag
02:00000176 00              	  4217: p1_high	ds.b	1				; player 1 highscore flag
                            	  4218: 							; $0x - entering high score, also index
                            	  4219: 							; $8x - done
                            	  4220: 
                            	  4221: 
                            	  4222: 		ds.w	0				; ensure even
                            	  4223: 
                            	  4224: ; player 2 variables
                            	  4225: 
                            	  4226: 
                            	  4227: player_2	EQU	*+$80				; player two variables base
02:00000177 00              	  4228: 		ds.b	score_off+$80		; space for the player two variables
02:00000178 *
                            	  4229: 
02:00000277 0000            	  4230: p2_score	ds.w	1				; player 2 score
                            	  4231: 
02:00000279 00              	  4232: p2_ships	ds.b	1				; player 2 ship count
                            	  4233: 
02:0000027A 00              	  4234: p2_high	ds.b	1				; player 2 highscore flag
                            	  4235: 							; $0x - entering high score, also index
                            	  4236: 							; $8x - done
                            	  4237: 
                            	  4238: 		ds.w	0				; ensure even
                            	  4239: 
                            	  4240: p_2_end
                            	  4241: 
                            	  4242: 
                            	  4243: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  4244: 
                            	  4245: 
                            	  4246: 	END	start
                            	  4247: 
                            	  4248: 
                            	  4249: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  4250: 

Source: "boot.x68"
                            	  5544: 


Symbols by name:
ABCD_INNER1                     00:00002BFE
ABCD_INNER2                     00:00002C6C
ABCD_NO_C1                      00:00002C1A
ABCD_NO_C2                      00:00002C22
ABCD_NO_C3                      00:00002C88
ABCD_NO_C4                      00:00002C90
ABCD_OUTER1                     00:00002BFC
ABCD_OUTER2                     00:00002C6A
ABS                             00:000052E0
ACIA                             E:FD060000
ACIA_CMD                         E:00000008
ACIA_CTRL                        E:0000000C
ACIA_RX                          E:00000000
ACIA_STAT                        E:00000004
ACIA_TX                          E:00000000
ADDA_OUTER1                     00:0000376C
ADDQ_LOOP1                      00:00002F86
ADDQ_LOOP2                      00:00002FC4
ADDQ_LOOP3                      00:00002FFA
ADDX_LOOP3                      00:00003892
ADDX_LOOP4                      00:000038AE
ADDX_LOOP5                      00:000038CA
ADDX_OUTER1                     00:000037FE
ADD_OUTER1                      00:00003592
ADD_OUTER2                      00:00003606
AHOW                            00:00005558
ALL_DONE                        00:00000960
AND_OUTER1                      00:000032B0
AND_OUTER2                      00:00003324
ASORRY                          00:00005550
AUXIN                           00:0000587C
AUXOUT                          00:00005868
AWHAT                           00:00005510
AXIRET                          00:0000589A
AllocateString                  00:00004FF8
ArmAllBreakpoints               00:00008532
ArmBreakpoint                   00:00008562
AsciiToHexNybble                00:00007C10
AudioInputTest                  00:00007FA8
BCC1                            00:00002EA4
BCC10                           00:00002EF6
BCC11                           00:00002EFE
BCC12                           00:00002F08
BCC13                           00:00002F10
BCC14                           00:00002F1A
BCC2                            00:00002EAE
BCC3                            00:00002EB6
BCC4                            00:00002EC0
BCC5                            00:00002EC8
BCC6                            00:00002ED2
BCC7                            00:00002EDA
BCC8                            00:00002EE4
BCC9                            00:00002EEC
BLANK                            E:00000020
BRTBL                           00:00008F44
BSR_CLOSE1                      00:00001A34
BSR_CLOSE2                      00:00001A6A
BSR_FAR1                        00:00000962
BSR_FAR2                        00:00002E94
BUFFER                          00:0000596C
BUFLEN                           E:00000050
BUFSIZE                          E:0000003F
BYEBYE                          00:0000589C
BlankLastLine                   00:00005CBA
BouncingBalls                   00:00007FAA
BreakpointWords                  E:00040280
Breakpoints                      E:00040220
BufByte                         00:00007C9C
BufNybble                       00:00007CA2
BufTetra                        00:00007C90
BufWyde                         00:00007C96
CALL                            00:00004C9E
CHKIO                           00:0000580E
CHKRET                          00:0000581E
CHR                             00:0000548A
CLMSG                           00:00005904
CLS                             00:0000582C
CMPA_OUTER1                     00:00003486
CMPM_LOOP1                      00:00003514
CMPM_LOOP2                      00:0000352E
CMPM_LOOP3                      00:00003548
CMP_OUTER1                      00:00003410
COMMON                          00:00009336
COMMON35                        00:00009344
COMMON4                         00:00009334
COM_CMDTBL                      00:0000800C
CON_CMDTBL                      00:00000608
CORENO                          00:00005308
CR                               E:0000000D
CRLF                            00:00005A66
CS11                            00:00008D7A
CS12                            00:00008CEA
CS13                            00:00008C70
CS14                            00:00008C06
CS15                            00:00008BC8
CS16                            00:00008B5A
CS17                            00:00008F10
CS18                            00:00008EAC
CS19                            00:00008FBC
CS20                            00:00008E14
CSTART                          00:000043F2
CTRLC                            E:00000003
CTRLH                            E:00000008
CTRLS                            E:00000013
CTRLX                            E:00000018
CTRLZ                            E:0000001A
CURRNT                          00:00005914
CalcScreenLoc                   00:00005AAA
CallOS                          00:00000240
CheckForCtrlC                   00:00006670
CheckForKey                     00:0000662C
CheckNumeric                    00:00004D68
ClearBreakpointList             00:00008654
ClearScreen                     00:00007FAE
ClearStringArea                 00:0000451C
ClearStringStack                00:0000453C
CmdBuf                           E:00040040
CmdBufEnd                        E:00040080
ConcatString                    00:00004E74
Cursor1                         00:0000628A
CursorCol                        E:00040001
CursorRow                        E:00040000
DBCC_LOOP1                      00:00002F24
DBCC_LOOP2                      00:00002F32
DCB_CMDPROC                      E:00000018
DCB_INBUFPTR                     E:00000028
DCB_INBUFSIZE                    E:00000030
DCB_INCOLS                       E:00000039
DCB_INROWS                       E:00000038
DCB_MAGIC                        E:00000000
DCB_NAME                         E:00000004
DCB_OUTBUFPTR                    E:0000002C
DCB_OUTBUFSIZE                   E:00000034
DCB_OUTCOLS                      E:0000003B
DCB_OUTROWS                      E:0000003A
DCB_SIZE                         E:00000040
DCODE68K                        00:0000929C
DDATA                            E:FFFFFFF0
DEC311                          00:000092B0
DEC404                          00:000092CE
DEC411                          00:000092DE
DEC425                          00:000092EE
DEC510                          00:000092FA
DEC515                          00:000092FE
DEC530                          00:00009306
DEC535                          00:0000930C
DEC537                          00:00009318
DEFLT                           00:00004B2E
DEV_PUTCHAR                      E:00000002
DIRECT                          00:000046F8
DIRFLG                          00:00005968
DIV1                            00:00005224
DIV2                            00:0000522A
DIV3                            00:00005230
DIV32                           00:00005212
DIV4                            00:0000523E
DIVRT                           00:0000524C
DIVS_OUTER1                     00:00003170
DIVU_OUTER1                     00:0000311E
DOMID                           00:000053B8
DOQUO                           00:000057EC
DOQUO1                          00:000057F4
DRAW                             E:0000A000
DT_NUMERIC                       E:00000001
DT_STRING                        E:00000002
Delay3s                         00:00000842
Delay3s2                        00:00000866
DisarmAllBreakpoints            00:00008506
DisarmBreakpoint                00:000085E0
DispatchMsg                     00:000086E6
DisplayAddr                     00:00007CBA
DisplayByte                     00:00007C70
DisplayChar                     00:00005AB8
DisplayHelp                     00:00007024
DisplayMem                      00:00007520
DisplayNybble                   00:00007C76
DisplaySpace                    00:00007C5C
DisplayString                   00:00005D18
DisplayStringCRLF               00:00005D2E
DisplayStringLimited            00:00005D34
DisplayStringLimitedCRLF        00:00005D54
DisplayTetra                    00:00007C64
DisplayTwoSpaces                00:00007C4A
DisplayWyde                     00:00007C6A
DrawHorizTo                     00:0000622A
DrawToXY                        00:000061AC
DrawVertTo                      00:0000625A
DumpMem1                        00:0000750E
EA000                           00:00008FEC
EA001                           00:00008FF8
EA010                           00:00009004
EA011                           00:00009018
EA011RTS                        00:0000902E
EA100                           00:00009030
EA101                           00:000090D2
EA1105                          00:000090AE
EA1107                          00:000090B2
EA1109                          00:000090C8
EA111                           00:000090E8
EA1112                          00:00009106
EA1113                          00:00009122
EA1113A                         00:00009132
EA1114                          00:00009154
EA1115                          00:000091BE
EA11153                         00:000091F6
EA11155                         00:00009200
EAF25                           00:0000919C
EAF27                           00:000091A0
EAF35                           00:000091B4
EEA                             00:0000904A
EEA10                           00:00008C78
ENDCHK                          00:000054FC
ENDCHK1                         00:0000550C
ENDMEM                          00:000043EE
EOR_OUTER2                      00:0000339A
EOT                              E:00000004
ERROR                           00:00005514
ETYPE                           00:0000555E
EX1                             00:00004732
EXCEPTION_6                     00:0000096A
EXCEPTION_7                     00:00000972
EXEC                            00:00004708
EXGO                            00:0000473E
EXLP                            00:00004710
EXMAT                           00:00004738
EXNGO                           00:0000471A
EXP4RT                          00:00004F68
EXPR                            00:00004D14
EXPR2                           00:00004E04
EXPR3                           00:00004EE2
EXPR4                           00:00004F4C
EXPR_AND                        00:00004D3A
EXPR_OR                         00:00004D14
EXPR_REL                        00:00004D7A
E_BadDevNum                      E:00000020
E_Func                           E:00000002
E_NotAlloc                       E:00000009
E_NotSupported                   E:0000000A
E_Ok                             E:00000000
EditMemHelper                   00:00007412
ExecuteCode                     00:0000748A
FDATA                            E:0000000A
FE10                            00:00009046
FE11                            00:0000912E
FE12                            00:000092EC
FERROR                          00:0000935E
FERROR35                        00:00009368
FERROR39                        00:00009374
FI1                             00:000054EE
FI2                             00:000054FA
FIN                             00:000054E2
FINISH                          00:00004916
FMTK_SEMA                        E:00000008
FNDLN                           00:00005602
FNDLNP                          00:00005610
FNDNXT                          00:00005628
FNDRET                          00:00005626
FNDSKP                          00:0000562A
FOC                              E:0000001F
FOP                              E:00000027
FOR                             00:00004984
FORM1                           00:00008BFE
FORM10                          00:00008CBA
FORM103                         00:00008CC0
FORM104                         00:00008CC4
FORM105                         00:00008CD4
FORM10E3                        00:00008C9E
FORM10E4                        00:00008CA6
FORM10E6                        00:00008CB2
FORM10EX                        00:00008C7C
FORM11                          00:00008CEE
FORM112                         00:00008D0A
FORM114                         00:00008D18
FORM11SL                        00:00008CF6
FORM12                          00:00008D1A
FORM125                         00:00008D34
FORM12A                         00:00008D56
FORM1A                          00:00008C02
FORM3                           00:00008C08
FORM4                           00:00008C0C
FORM5                           00:00008C1E
FORM6A                          00:00008C22
FORM6D                          00:00008C32
FORM7                           00:00008C58
FORM8                           00:00008C64
FORM815                         00:00008C68
FORM9                           00:00008C72
FORM91                          00:00008FD4
FORM93                          00:00008FE8
FORM95                          00:00008FEA
FORMREG5                        00:00008C46
FORMREGA                        00:00008C42
FORMREGD                        00:00008C52
FORMSIZE                        00:00008FC0
FR1                             00:0000499E
FR2                             00:000049B6
FR3                             00:000049BC
FR4                             00:000049C2
FR5                             00:000049CA
FR6                             00:000049DC
FR7                             00:000049E8
FR8                             00:00004A00
FRAMEBUF                         E:FD200000
FREL10                          00:00008AC2
FREL15                          00:00008AD4
FREL20                          00:00008AEE
FREL25                          00:00008B00
FREL30                          00:00008B0A
FRELADDR                        00:00008AB4
FemtikiInit                     00:00000220
FemtikiInitIRQ                  00:00000230
FemtikiTimerIRQ                 00:0000030E
ForceUnlockSemaphore            00:000007CA
FreeTCB                          E:0010030C
FromScreen                      00:00006D98
GBYTE                           00:00004B86
GBYTE1                          00:00004B8A
GBYTE2                          00:00004B98
GETLN                           00:00005564
GL1                             00:00005574
GL2                             00:00005592
GL3                             00:000055A6
GL4                             00:000055CA
GL5                             00:000055D6
GL6                             00:000055F2
GL7                             00:000055FA
GOAUXI                          00:000043E2
GOAUXO                          00:000043DE
GOBYE                           00:000043E6
GOIN                            00:000043DA
GOOUT                           00:000043D6
GOSUB                           00:0000491E
GOTO                            00:00004820
GOWARM                          00:000043D2
GRBufferToScreen                00:00005F8A
GarbageCollectStrings           00:00005056
GetCmdLine                      00:000071D8
GetDecNumber                    00:000076AC
GetHexNumber                    00:0000767E
GetKey                          00:00006638
GetRunningTCBPointer            00:000002AA
GetSzChar                       00:000073EC
GetTick                         00:00005F58
GlobalReadLong                  00:00000682
GlobalWriteLong                 00:00000688
GraphicsDemo                    00:00007FAC
HALT                             E:0000B000
HAS_MMU                          E:00000000
HEX2DEC                         00:00008A3C
HEX2DEC2                        00:000089EE
HISPC                            E:FFFFFFFC
HOWMSG                          00:000058D5
HX2DC                           00:00008A4C
HX2DC0                          00:00008A50
HX2DC1                          00:00008A58
HX2DC2                          00:00008A72
HX2DC22                         00:00008A74
HX2DC3                          00:00008A7E
HX2DC4                          00:00008A86
HX2DC5                          00:00008A8E
HX2DC57                         00:00008A96
HX2DC6                          00:00008A9A
HelpMsg                         00:00007030
HomeCursor                      00:00005D5A
I2C2                             E:FD069000
I2C_CMD                          E:00000004
I2C_CTRL                         E:00000002
I2C_PREH                         E:00000001
I2C_PREL                         E:00000000
I2C_RXR                          E:00000003
I2C_STAT                         E:00000004
I2C_TXR                          E:00000003
IBSR                            00:00008E66
ICC                             00:00008E62
ICC35                           00:00008E78
ICC55                           00:00008E8E
ICCCC                           00:00008F2C
ICCCC9                          00:00008F42
IDBCC                           00:00008E50
IF                              00:00004A70
IF1                             00:00004A74
IF2                             00:00004A7A
IGNBLK                          00:000057BA
ILINK                           00:00008BE8
IM7788                          00:00008B26
IM7799                          00:00008B2A
IMMED                           00:00008B70
IMMED45                         00:00008B96
IMMED55                         00:00008BCA
IMMED65                         00:00008BD0
IMMED75                         00:00008BE0
IMOVE                           00:00008BE4
IMOVE19                         00:00008F8A
IMOVEA1                         00:00008F64
IMOVEMFR                        00:00008B12
IMOVEMTR                        00:00008B40
IMOVEP                          00:00008DEC
IMOVEP11                        00:00008DFC
IMOVEP35                        00:00008E18
IMOVEP66                        00:00008E26
IMOVEQ                          00:00008D82
IMVFSR                          00:00008DA2
IMVFUSP                         00:00008DB0
IMVT44                          00:00008DCC
IMVTCCR                         00:00008DDC
IMVTSR                          00:00008DBE
IMVTUSP                         00:00008DD0
INC                             00:00005848
INC1                            00:00005854
INCOM                           00:00004750
INCON                           00:00004742
INITMSG                         00:000058AA
INPERR                          00:00004A8A
INPPTR                          00:0000590C
INPUT                           00:00004A98
INT                             00:00005474
INT_EXPR                        00:00004D02
IOCOM                           00:0000475E
IOCON                           00:00004774
IOFocus                          E:00100000
IP2                             00:00004ACA
IP3                             00:00004AE4
IP4                             00:00004B1E
IP5                             00:00004B2A
IP6                             00:00004AC6
IP7                             00:00004ABC
IQUICK                          00:00008D7E
IQUICK21                        00:00008FA2
IQUICK31                        00:00008FB8
IQUICKA                         00:00008F90
IRQFlag                          E:000400A0
IRQROUT                         00:00005948
IRQ_trampolines                 01:00000100
ISCC                            00:00008E46
ISETD                           00:00008E9E
ISETD12                         00:00008EA4
ISETS                           00:00008EAE
ISHIFT                          00:00008EC8
ISHIFT13                        00:00008ED4
ISHIFT23                        00:00008EF8
ISHIFT33                        00:00008F04
ISHIFT44                        00:00008F08
ISHIFTM1                        00:00008F12
ISTOP                           00:00008B5C
IncCursorPos                    00:00005C1E
IncCursorRow                    00:00005C3E
InitIOPBitmap                   00:00000690
InitIRQ                         00:000087C0
InitRand                        00:000006DC
InitSemaphores                  00:00000782
Initialise                      00:0000A974
InputDevice                      E:000400A4
InstallIRQ                      00:000087D4
JMPL                             E:0000E000
JSRL                             E:0000C000
KBD_CMDTBL                      00:000063AC
KEYBD                            E:FD0FFE00
KEYBD_SEMA                       E:00000003
KI                              00:00009388
KIEND                           00:0000938A
KeybdEcho                        E:0004000C
KeybdGetChar                    00:00006690
KeybdGetCharNoWait              00:00006680
KeybdGetCharWait                00:00006688
KeybdGetID                      00:0000640E
KeybdID                          E:00100018
KeybdIRQ                        00:0000693C
KeybdInit                       00:00006478
KeybdLEDs                        E:0010000E
KeybdRecvByte                   00:000065DC
KeybdSendByte                   00:000068FC
KeybdSetLED                     00:0000644C
KeybdSetLEDStatus               00:000068AC
KeybdWaitFlag                    E:0004000D
KeybdWaitTx                     00:000065FE
LEA1                            00:00002440
LEFT                            00:0000541A
LEN                             00:0000544E
LET                             00:00004B36
LF                               E:0000000A
LIST                            00:00004868
LOAD                            00:00004B46
LOCVARSZ                         E:00000010
LOD1                            00:00004B52
LOD2                            00:00004B6C
LODEND                          00:00004B7C
LOPINC                          00:00005928
LOPLMT                          00:00005934
LOPLN                           00:00005940
LOPPT                           00:00005944
LOPVAR                          00:00005924
LS1                             00:00004874
LS2                             00:00004888
LS3                             00:0000488E
LSTROM                          00:00005908
LT1                             00:00004B42
LastStr                         00:00005958
ListBreakpoints                 00:00008634
LockSemaphore                   00:000007A8
LockSysSemaphore                00:00000396
LorR1                           00:0000534C
LorRArgs                        00:00005314
MAX_TID                          E:00000FFF
MEMORY_SEMA                      E:00000006
MID                             00:00005350
MID1                            00:00005416
MID2                            00:00005398
MID4                            00:000053E4
MID5                            00:000053B0
MMU                              E:FDC00000
MOVE1                           00:000020AE
MOVE2                           00:00002032
MOVE3                           00:0000212E
MOVE4                           00:00002288
MOVEMR                          00:00009220
MOVEMR11                        00:00009230
MOVEMR33                        00:00009238
MOVEMR44                        00:0000924A
MOVEMR77                        00:00009264
MOVEMR79                        00:00009276
MOVEMR88                        00:00009278
MOVEMR94                        00:00009290
MOVEMS                          00:0000920C
MOVEMS2                         00:0000921C
MSG111                          00:0000937E
MULS_OUTER1                     00:00003A66
MULU_OUTER1                     00:00003A1A
MVDOWN                          00:0000564C
MVRET                           00:00005640
MVUP                            00:00005638
MVUPW                           00:00005642
Monitor                         00:00006DAC
MoveToXY                        00:0000619E
NBCD_LOOP                       00:00002DE4
NBCD_LOOP1                      00:00002E2A
NBCD_NO_C                       00:00002DF0
NBCD_NO_C1                      00:00002E3E
NBCD_NO_Z                       00:00002DF4
NBCD_NO_Z1                      00:00002E42
NCORES                           E:00000004
NEW                             00:0000478A
NEXT                            00:00004A04
NOSTRING                        00:000058EC
NR_TCB                           E:00001000
NUM_EXPR                        00:00004CF4
NX0                             00:00004A0E
NX1                             00:00004A4E
NX2                             00:00004A66
NX3                             00:00004A20
NextRec                         00:00007DA2
NextString                      00:00005092
Ninc0                           00:0000AA08
Ninc1                           00:0000AA0E
NumSetBreakpoints                E:00040202
OFFSET                           E:00040880
OKMSG                           00:000058CE
ONIRQ                           00:00004834
ONIRQ1                          00:0000484E
OPCTBL                          00:00009642
OR_OUTER1                       00:000031C6
OR_OUTER2                       00:0000323A
OSCallTable                     00:0000023E
OUTC                            00:00005838
OUTCOM                          00:00004768
OUTCON                          00:0000477E
OUTPTR                          00:00005910
OutputChar                      00:0000878A
OutputDevice                     E:000400A8
PARN                            00:00004FE2
PBYTE                           00:00004C04
PBYTE1                          00:00004C06
PBYTE2                          00:00004C1A
PEEK                            00:0000524E
PKER                            00:00004C9A
PLIC                             E:FD090000
PNT4HEX                         00:00008AA0
PNT4HX                          00:00008AA0
PNT6HX                          00:00008AA4
PNT8HX                          00:00008AB0
POKE                            00:00004C24
POPA                            00:00005654
PR0                             00:000048B2
PR1                             00:000048C0
PR2                             00:000048A4
PR3                             00:000048CE
PR6                             00:000048DA
PR8                             00:000048E0
PR9                             00:000048FC
PRINT                           00:00004894
PRMESG                          00:00005820
PRMRET                          00:0000582A
PRNlword                         S:0000000A
PRTLN                           00:00005738
PRTNUM                          00:000056EE
PRTRET                          00:000056E0
PRTSTG                          00:000056C6
PRTSTR2                         00:000056E8
PRTSTR2a                        00:000056E2
PS1                             00:000056C8
PUSHA                           00:00005690
PeekScreenChar                  00:000073E6
PointsIntoStringArea            00:000050EE
ProcessBreakpoint               00:00008500
ProcessRec                      00:00007DB4
ProcessS1                       00:00007EB6
ProcessS2                       00:00007EBA
ProcessS3                       00:00007EBE
ProcessS7                       00:00007EC2
ProcessS8                       00:00007ED2
ProcessS9                       00:00007EE2
Prompt1                         00:00006DEA
Prompt3                         00:00006DD4
PromptLn                        00:00006DC8
QHOW                            00:00005556
QSORRY                          00:0000554E
QWHAT                           00:0000550E
QueueCycle                       E:0010031C
RAND                             E:FD0FFD00
RAND_MW                          E:FD0FFD0C
RAND_MZ                          E:FD0FFD08
RAND_NUM                         E:FD0FFD00
RAND_SEMA                        E:00000004
RAND_STRM                        E:FD0FFD04
RANPNT                          00:00005908
REL4                             E:00004000
REL5                             E:00005000
REL7                             E:00007000
REM                             00:00004A6E
RETURN                          00:00004958
RIGHT                           00:00005426
RND                             00:000052B6
ROXx_FLAGS                      00:00003D2E
ROXx_LOOP1                      00:00003D44
ROXx_LOOP2                      00:00003D64
ROXx_LOOP3                      00:00003D84
ROXx_LOOP4                      00:00003DA4
ROXx_LOOP5                      00:00003DC4
ROXx_LOOP6                      00:00003DE6
ROx_FLAGS                       00:00003AF8
ROx_LOOP1                       00:00003B0E
ROx_LOOP2                       00:00003B2E
ROx_LOOP3                       00:00003B4E
ROx_LOOP4                       00:00003B6E
ROx_LOOP5                       00:00003B8E
ROx_LOOP6                       00:00003BB0
RST_REG                          E:FD0FFC00
RTCBuf                           E:00100200
RTR_DONE                        00:00002E86
RTSL                             E:0000D000
RUN                             00:000047A6
RUN1                            00:000047FA
RUNNXL                          00:000047BA
RUNSML                          00:00004810
RUNTSL                          00:00004806
RandGetNum                      00:0000071C
RandInit                        00:000006DC
RandWait                        00:0000076C
ReceiveMsg                      00:000086A4
Regsave                          E:00040100
RunningTCB                       E:00100224
S1932a                          00:00007F2A
S1932b                          00:00007F3E
S19Checksum                      E:00100150
S19Get16BitAddress              00:00007EF2
S19Get24BitAddress              00:00007F00
S19Get32BitAddress              00:00007F0C
S19StartAddress                  E:00040008
SAVE                            00:00004BA6
SAVE1                           00:00004BAE
SAVE2                           00:00004BD2
SAVEND                          00:00004BE0
SBCD_INNER1                     00:00002CF6
SBCD_INNER2                     00:00002D64
SBCD_NO_C1                      00:00002D12
SBCD_NO_C2                      00:00002D1A
SBCD_NO_C3                      00:00002D80
SBCD_NO_C4                      00:00002D88
SBCD_OUTER1                     00:00002CF4
SBCD_OUTER2                     00:00002D62
SCHR                            00:00008D9A
SCOMMON                         00:00008E42
SCREEN_FORMAT                    E:00000001
SCREEN_SEMA                      E:00000005
SC_ALT                           E:00000011
SC_CAPSLOCK                      E:00000058
SC_CTRL                          E:00000014
SC_EXTEND                        E:000000E0
SC_KEYUP                         E:000000F0
SC_LSHIFT                        E:00000012
SC_NUMLOCK                       E:00000077
SC_RSHIFT                        E:00000059
SC_SCROLLLOCK                    E:0000007E
SC_TAB                           E:0000000D
SERIAL_SEMA                      E:00000002
SETVAL                          00:000054C2
SHIFTS2_FLAGS                   00:000041A6
SHIFTS2_LOOP1                   00:000041BC
SHIFTS2_LOOP2                   00:000041D8
SHIFTS2_LOOP3                   00:000041F4
SHIFTS2_LOOP4                   00:00004210
SHIFTS2_LOOP5                   00:0000422C
SHIFTS2_LOOP6                   00:0000424A
SHIFTS_FLAGS                    00:00003F64
SHIFTS_LOOP1                    00:00003F7A
SHIFTS_LOOP2                    00:00003F9A
SHIFTS_LOOP3                    00:00003FBA
SHIFTS_LOOP4                    00:00003FDA
SHIFTS_LOOP5                    00:00003FFA
SHIFTS_LOOP6                    00:0000401C
SHRT                             E:0000F000
SIV1                            00:000050C6
SIZE                            00:000052EC
SRYMSG                          00:000058FE
ST3                             00:00004490
ST4                             00:000044E2
START                           00:000043D0
STKFP                           00:00005918
STKGOS                          00:0000591C
STKINP                          00:00005920
STKLMT                          00:00005964
STOP                            00:0000479E
STRAREASIZE                      E:00000800
STRSTK                          00:0000594C
SUBA_OUTER1                     00:000037B8
SUBQ_LOOP1                      00:00003044
SUBQ_LOOP2                      00:0000307E
SUBQ_LOOP3                      00:000030B4
SUBX_LOOP3                      00:000039A2
SUBX_LOOP4                      00:000039BE
SUBX_LOOP5                      00:000039DA
SUBX_OUTER1                     00:0000390E
SUB_OUTER1                      00:0000367C
SUB_OUTER2                      00:000036F0
SV1                             00:000054E0
ScrollUp                        00:00005C72
SelectThreadToRun               00:000002C2
SendMsg                         00:00008666
SerHeadRcv                       E:00100162
SerHeadXmit                      E:00100168
SerRcvBuf                        E:00101000
SerRcvXoff                       E:00100165
SerRcvXon                        E:00100164
SerTailRcv                       E:00100160
SerTailXmit                      E:00100166
SerXmitBuf                       E:00102000
SerXmitXoff                      E:0010016A
SerialGetChar                   00:000080D6
SerialIRQ                       00:0000824C
SerialInit                      00:00008098
SerialPeekChar                  00:0000814E
SerialPeekCharDirect            00:0000818A
SerialPutChar                   00:000081A4
SerialPutCharDirect             00:00008208
SerialRbo                       00:00008224
SerialRcvCount                  00:0000822C
SetDrawMode                     00:00005F60
SetKeyboardEcho                 00:00006624
SetPenColor                     00:00005F82
ShiftBuf                        00:000089D4
SimHardware                     00:00005F48
SpuriousIRQ                     00:0000888C
StartMon                        00:00006DA2
StartQ                          00:00000172
StrArea                         00:00005954
StrSp                           00:00005950
StringInVar                     00:000050A8
StringOnStack                   00:00005112
StubRout                        00:000062C2
SyncCursor                      00:00005D6C
T15Abort                        00:0000081A
T15DispatchTable                00:00005DB8
T15FloatToString                00:0000872E
T15GetFloat                     00:0000080C
T15LockSemaphore                00:00000800
T15UnlockSemaphore              00:00000806
TAB1                            00:00004550
TAB10                           00:00004605
TAB10_1                         00:000046E8
TAB11                           00:00004608
TAB11_1                         00:000046F0
TAB1_1                          00:00004610
TAB2                            00:0000457F
TAB2_1                          00:00004640
TAB4                            00:000045BC
TAB4_1                          00:00004680
TAB5                            00:000045EE
TAB5_1                          00:000046B4
TAB6                            00:000045F1
TAB6_1                          00:000046BC
TAB8                            00:000045F6
TAB8_1                          00:000046C4
TAB9                            00:00004601
TAB9_1                          00:000046E0
TBL                             00:0000938A
TBLE                            00:00009642
TC1                             00:00005768
TCBAffineChose                  00:000000A0
TCBAffinity                      E:00000084
TCBAffinityBase                  E:00000082
TCBAlloc                        00:0000006E
TCBEndTick                       E:00000070
TCBFree                         00:00000092
TCBHandleToPointer              00:00000028
TCBIAlloc                       00:00000050
TCBIFree                        00:0000007C
TCBInit                         00:00000000
TCBInsertIntoReadyQueue         00:000000D8
TCBNext                          E:0000007C
TCBPC                            E:00000050
TCBPointerToHandle              00:00000040
TCBPopReadyQueue                00:0000017A
TCBPrev                          E:00000080
TCBPriority                      E:00000055
TCBRegs                          E:00000004
TCBRemoveFromReadyQueue         00:00000150
TCBSR                            E:0000004C
TCBSSP                           E:00000048
TCBStartTick                     E:0000006C
TCBStatus                        E:00000054
TCBTicks                         E:00000074
TCBUSP                           E:00000044
TCB_SIZE                         E:00000100
TEXTREG                          E:FD080000
TICK                            00:000052FC
TOUPB1                          00:000057CA
TOUPBRT                         00:000057EA
TOUPBUF                         00:000057C4
TOUPPER                         00:000057FC
TOUPRET                         00:0000580C
TRAP15                          00:00005DA0
TSTC                            00:00005756
TSTNUM                          00:0000576E
TSTV                            00:00005190
TSTVRT                          00:00005210
TS_PREEMPT                       E:00000020
TS_RUNNING                       E:00000080
TV1                             00:000051D8
TV2                             00:00005208
TXT                             00:000059BC
TXTBGN                          00:000043EA
TXTUNF                          00:0000595C
TYPMSG                          00:000058E4
TestBitmap                      00:00006020
TextCols                         E:0004008D
TextCurpos                       E:00040002
TextPos                          E:00040002
TextRows                         E:0004008C
TextScr                          E:00040004
TickIRQ                         00:00008818
TimerStack                       E:00040BFC
USP1                            00:0000516E
UnlockSemaphore                 00:000007E4
UnlockSysSemaphore              00:000003A6
UpdateIRQLive                   00:000002EC
UpdateStringPointers            00:00005142
UpdateTextPos                   00:00005A80
VARBGN                          00:00005960
WAITIRQ                         00:00004858
WHTMSG                          00:000058DC
WSTART                          00:0000445C
Wait10ms                        00:00006904
Wait300ms                       00:00006920
X                               00:00008B12
XOFF                             E:00000013
XON                              E:00000011
XP11                            00:00004D8E
XP12                            00:00004D9A
XP13                            00:00004DA6
XP14                            00:00004DB2
XP15                            00:00004DBE
XP15RT                          00:00004DCA
XP16                            00:00004DCC
XP17                            00:00004DEA
XP18                            00:00004DF0
XP21                            00:00004E12
XP22                            00:00004E18
XP23                            00:00004E1C
XP24                            00:00004E2A
XP25                            00:00004E58
XP26                            00:00004E5E
XP27                            00:00004E72
XP30                            00:00004EE8
XP31                            00:00004EF4
XP34                            00:00004F0A
XP35                            00:00004F24
XP36                            00:00004EE4
XP40                            00:00004F58
XP41                            00:00004F6A
XP42                            00:00004FF2
XP43                            00:00004FF4
XP44                            00:00004FD6
XP45                            00:00004F84
XPRT0                           00:00004DDA
XPRT1                           00:00004DE2
XPSTNG                          00:00004F7A
XP_AND                          00:00004D4C
XP_ANDX                         00:00004D62
XP_MOD                          00:00004F2A
XP_OR                           00:00004D24
XP_ORX                          00:00004D62
XP_POP                          00:00004CC8
XP_POP1                         00:00004CDE
XP_PUSH                         00:00004CB2
_CheckNan                       00:0000771C
_CheckNegative                  00:0000779A
_CheckZero                      00:00007780
_ComputeDigitsBeforeDecpt       00:000077F4
_E                               E:0004050C
_ExtExpDigit                    00:00007918
_ExtExpDigits                   00:00007936
_FloatToString                  00:000079E0
_GetExponent                    00:00007A98
_GetFloat                       00:00007B98
_GetFloatBackupChar             00:00007A30
_GetFloatGetChar                00:00007A22
_GetFloatIgnBlanks              00:00007A28
_GetFraction                    00:00007A34
_GetInteger                     00:00007B22
_GetRand                        00:0000074A
_KeyState1                       E:0010000F
_KeyState2                       E:00100010
_KeybdBuf                        E:00100020
_KeybdClearIRQ                  00:000065C6
_KeybdCnt                        E:00100013
_KeybdGetScancode               00:000065A8
_KeybdGetStatus                 00:0000658A
_KeybdHead                       E:00100011
_KeybdInit                      00:00006478
_KeybdOBuf                       E:00100080
_KeybdTail                       E:00100012
_Keybd_tick                      E:0001001C
_LeadingZero                    00:0000782E
_LessThanDbl                    00:000077C8
_MakeBig                        00:000077AC
_PadLeft                        00:0000795E
_PadRight                       00:000079AE
_SpitOutDigits                  00:0000783E
_SpitOutE                       00:00007900
_TrimDotZero                    00:000078D8
_TrimTrailingPoint              00:000078BA
_TrimTrailingZeros              00:000078F4
_canary                          E:00040098
_dasmbuf                         E:00040800
_dfMil                          00:00007708
_dfOne                          00:000076F0
_dfTen                          00:000076FC
_digits_before_decpt             E:00040510
_fpBuf                           E:00040520
_fpTextIncr                      E:00040094
_fpWork                          E:00040600
_keybdControlCodes              00:00006BF2
_keybdExtendedCodes             00:00006C72
_msgInf                         00:00007718
_msgNan                         00:00007714
_precision                       E:00040514
_shiftedScanCodes               00:00006AF2
_unshiftedScanCodes             00:000069F2
_width                           E:00040508
a_was_less                      00:0000A808
add_address                     00:0000A930
add_char_loop                   00:0000A8D8
add_character                   00:00009E68
add_coords                      00:0000A946
add_explode                     00:0000A3AE
add_fire                        00:0000A3BA
add_hex_chr                     00:0000A916
add_item                        00:0000A394
add_message                     00:0000A890
add_p_size                      00:0000996C
add_pair                        00:0000A962
add_play_explode                00:0000A4D2
add_player                      00:0000A578
add_saucer                      00:0000A3B4
add_score                       00:0000A3CC
add_ships                       00:00009E78
add_ships_loop                  00:00009E94
add_single                      00:0000A960
add_sup_hex_chr                 00:0000A90A
add_sup_zero                    00:0000A920
add_the_char                    00:0000A8EE
add_to_list                     00:0000A360
add_to_score                    00:0000A65A
addr_err                        00:000088A0
aim_shot                        00:00009B2A
asteroids_start                 00:00009742
atn_eight                       00:0000A774
atn_quad                        00:0000A764
atn_semi                        00:0000A754
atn_tab                         00:0000A792
attract_fire                    00:00009B06
attract_saucer                  00:00009A54
beat1_snd                        E:00000008
beat1_sound                     00:0000C5D0
beat2_snd                        E:00000009
beat2_sound                     00:0000C5E2
bkColor                          E:00040088
brdisp_trap                     00:000088B6
bus_err                         00:000084A8
calc_fire_byte                  00:00009C18
char_1                          00:0000C10C
char_2                          00:0000C114
char_3                          00:0000C124
char_4                          00:0000C132
char_5                          00:0000C140
char_6                          00:0000C14E
char_7                          00:0000C15C
char_8                          00:0000C166
char_9                          00:0000C176
char_a                          00:0000BFA0
char_b                          00:0000BFB0
char_c                          00:0000BFCA
char_d                          00:0000BFD6
char_e                          00:0000BFE6
char_f                          00:0000BFF6
char_g                          00:0000C004
char_h                          00:0000C016
char_i                          00:0000C024
char_j                          00:0000C032
char_k                          00:0000C03E
char_l                          00:0000C04A
char_m                          00:0000C054
char_n                          00:0000C060
char_o0                         00:0000C06A
char_p                          00:0000C076
char_q                          00:0000C084
char_r                          00:0000C096
char_s                          00:0000C0A6
char_set                        00:0000C184
char_spc                        00:0000C108
char_t                          00:0000C0B4
char_u                          00:0000C0C0
char_v                          00:0000C0CC
char_w                          00:0000C0D6
char_x                          00:0000C0E4
char_y                          00:0000C0EE
char_z                          00:0000C0FC
check_all                       00:00009916
check_alpha                     00:00009D84
check_clear                     00:0000A0B4
check_clear_loop                00:0000A0B8
check_clear_y                   00:0000A0D2
check_hi_loop                   00:0000A6C6
check_hi_next                   00:0000A6D4
check_hi_player                 00:0000A6BE
check_hiscores                  00:0000A6A2
check_hits                      00:000098F6
check_neg_velocity              00:0000A0A8
check_next_object               00:00009912
check_pss                       00:00009904
check_velocity                  00:0000A09A
chk_exception                   00:0000082C
clear_bitmap_screen4            00:00005FB4
clear_hyper                     00:00009FE0
clear_items_loop                00:00009E40
clear_loop                      00:0000A9A4
clear_rock                      00:0000A646
clear_rocks                     00:0000A192
clear_rocks_loop                00:0000A194
clear_saucer                    00:00009F80
clear_screen                    00:00005A2A
close_all                       00:00009CF4
close_all_2                     00:0000A9F4
cmdAsteroids                    00:00006EA6
cmdBreakpoint                   00:00006E82
cmdClearScreen                  00:00006EC2
cmdClock                        00:00006FB4
cmdCore                         00:00006ECE
cmdDisassemble                  00:0000749A
cmdDispatch                     00:00006DFC
cmdDumpMemory                   00:000074EA
cmdDumpRegs                     00:000075B4
cmdEditMemory                   00:00007434
cmdFMTK                         00:00006EF2
cmdFillB                        00:000072E0
cmdFillL                        00:00007388
cmdFillW                        00:00007334
cmdHelp                         00:00007024
cmdJump                         00:0000748A
cmdLoadS19                      00:00007D9C
cmdMonitor                      00:00006DAC
cmdReceiveSerial                00:000072AC
cmdReset                        00:00006FD2
cmdSendSerial                   00:0000727C
cmdString                       00:00006CF2
cmdTable                        00:00006D2C
cmdTestCPU                      00:00006EB2
cmdTestFP                       00:00006EFA
cmdTestGF                       00:00006F86
cmdTestRAM                      00:00007CDA
cmdTestSerialReceive            00:0000765E
cmdTinyBasic                    00:00006EAE
cmdVideoMode                    00:00006E42
col_table                       00:0000997C
col_table_l                     00:00009994
col_table_p                     00:00009984
col_table_s                     00:0000998C
con_dcb                          E:00040A80
console_cmdproc                 00:00000628
console_getbuf                  00:00000662
console_getchar                 00:0000065A
console_init                    00:0000058A
console_putbuf                  00:00000662
console_putchar                 00:00000652
console_set_inpos               00:00000662
console_set_outpos              00:00000662
console_stat                    00:0000064E
copy_msg                        00:0000BB68
copy_rock                       00:0000A1EA
copy_rock_2                     00:0000A1EE
copy_short                      00:0000A5CA
copy_vectors                    00:0000A5CE
copy_velocity                   00:0000A214
cos_d0                          00:0000A7F0
cossin_d0                       00:0000A802
cpu_test                        00:00000882
d_mess_0                        00:0000C2D4
d_mess_1                        00:0000C2E4
d_mess_2                        00:0000C2ED
d_mess_3                        00:0000C314
d_mess_4                        00:0000C337
d_mess_5                        00:0000C35A
d_mess_6                        00:0000C380
d_mess_7                        00:0000C396
d_messages                      00:0000C2C4
dccr                            00:00005AE0
dclf                            00:00005BA4
dcx10                           00:00005B48
dcx11                           00:00005B6A
dcx12                           00:00005B60
dcx14                           00:00005AD6
dcx16                           00:00005BA8
dcx4                            00:00005BAC
dcx6                            00:00005AFE
dcx7                            00:00005ADA
dcx8                            00:00005B14
dcx9                            00:00005B2A
dec_isaucer_time                00:00009A7C
delta_x_pos                     00:00009930
delta_y_pos                     00:00009942
dly3s1                          00:00000852
dly3s2                          00:00000850
doBackspace                     00:00005BB6
doCtrlX                         00:00005BFA
doDelete                        00:00005BC4
do_nothing                      00:00000554
do_p1_ships                     00:0000A2C8
do_p2_score                     00:0000A33C
do_saucer                       00:00009A28
do_start_mess                   00:000097F0
do_vector                       00:0000AA1E
dspj1                           00:00005D1C
dspmem1                         00:0000754C
dspspc1                         00:00007C54
dsret                           00:00005D28
e_mess_0                        00:0000C21A
e_mess_1                        00:0000C226
e_mess_2                        00:0000C22E
e_mess_3                        00:0000C250
e_mess_4                        00:0000C26B
e_mess_5                        00:0000C288
e_mess_6                        00:0000C2AF
e_mess_7                        00:0000C2BA
e_messages                      00:0000C20A
edtmem1                         00:0000743E
end_game                        00:000098E2
end_vector                      00:0000AB0C
enter_hiscores                  00:00009C3E
existing_saucer                 00:00009AE2
exit_add_message                00:0000A8F6
exit_add_score                  00:0000A3FA
exit_add_ships                  00:00009EA0
exit_check_hiscores             00:0000A702
exit_check_velocity             00:0000A0B2
exit_copy_vectors               00:0000A5E8
exit_do_saucer                  00:00009AE0
exit_enter_hiscores             00:00009D92
exit_existing_saucer            00:00009B0C
exit_find_rock                  00:0000A4B8
exit_game_message               00:000098E0
exit_hi_chk                     00:0000A6F8
exit_high_scores                00:0000A4A0
exit_hit_a_rock                 00:0000A69C
exit_hyperspace                 00:00009E22
exit_insert_loop                00:0000A72A
exit_limit_velocity             00:0000A26E
exit_make_rocks                 00:0000A19C
exit_no_scores                  00:0000A4A6
exit_not_done                   00:00009D90
exit_play_sample                00:0000C5B6
exit_push_start                 00:00009862
exit_ship_fire                  00:00009BC4
exit_ship_move                  00:00009FE4
exit_static                     00:0000A35E
expl_0                          00:0000BC50
expl_1                          00:0000BC1A
expl_2                          00:0000BBDC
expl_3                          00:0000BBB0
expl_tab                        00:0000BBA8
expl_x_pos                       S:0000005B
expl_y_pos                       S:00000067
explode_object                  00:000099E2
extra_snd                        E:0000000A
extra_sound                     00:0000C633
f_mess_0                        00:0000C3B0
f_mess_1                        00:0000C3BF
f_mess_2                        00:0000C3C6
f_mess_3                        00:0000C3EA
f_mess_4                        00:0000C403
f_mess_5                        00:0000C425
f_mess_6                        00:0000C44E
f_mess_7                        00:0000C460
f_messages                      00:0000C3A0
f_xpos_off                       E:FFFFFFBA
f_xvel_off                       E:0000004C
f_ypos_off                       E:00000000
f_yvel_off                       E:0000006F
fgColor                          E:00040084
filename                        00:0000C6AA
find_next_rock                  00:0000A4AE
find_rock                       00:0000A4AC
fire_ok                         00:00009C34
fire_saucer                     00:00009B12
fire_shot                       00:00009BC6
first_quad                      00:0000A5A2
flag_end                         E:0000002F
flags_off                        E:0000000C
fpBuf                            E:000402C0
fx_sounds                       00:0000A5EA
game_count                       S:00000059
game_message                    00:000097DC
game_over                       00:00009864
gen_prng                        00:0000A9FA
gen_rock_loop                   00:0000A13C
get_atn                         00:0000A748
get_screen_address              00:00005A22
get_screen_color                00:00005A10
glob_scale                       S:00000000
go_reset_play                   00:00009EE4
go_reset_sauc                   00:00009EEA
gr_bitmap_buffer                 E:000408B0
gr_bitmap_screen                 E:000408A4
gr_double_buffer                 E:000408AC
gr_height                        E:000408A0
gr_raster_op                     E:000408A8
gr_width                         E:0004089C
gr_x                             E:00040894
gr_y                             E:00040898
gthx3                           00:00007C46
gthx5                           00:00007C22
gthx6                           00:00007C34
handle_collision                00:0000999C
hi_char                          S:00000020
hide_p_cnt                       E:0000007A
high_idx                         S:00000017
high_off                         E:00000083
high_scores                     00:0000A400
high_scores_loop                00:0000A432
hinames                          S:0000003B
hiscore_y                        S:00000012
hiscores                         S:00000027
hit_a_rock                      00:0000A62C
hype_xok1                       00:00009DD0
hype_xok2                       00:00009DDA
hype_yok1                       00:00009DF8
hype_yok2                       00:00009E02
hyper                            S:00000026
hyperspace                      00:00009D94
i2c_setup                       00:0000832A
i2c_wait_rx_nack                00:00008378
i2c_wait_tip                    00:0000833A
i2c_wr_cmd                      00:0000834A
i2c_xmit1                       00:0000835A
i_rk_count                       E:00000075
i_sauc_tim                       E:00000078
icc1                            00:00005C70
ignBlanks                       00:000073D4
illegal_trap                    00:000088EE
init_framebuf                   00:00000666
init_i2c                        00:0000832A
init_plic                       00:00006306
insert_hiscore                  00:0000A704
insert_loop                     00:0000A708
io_irq                          00:00008904
io_trap                         00:00008762
irq3_rout                       00:0000885A
irq6_rout                       00:0000885A
irq_list_tbl                     A:00000400
irq_proc_generic                00:0000886E
irq_rout                        00:0000885A
is_closer                       00:0000A0F0
item_exploding                  00:00009EF2
kbdi0002                        00:000064A4
kbdi0004                        00:0000651C
kbdi0005                        00:00006538
kbdiTryAgain                    00:0000650E
kbdiXmitBusy                    00:00006552
keep_saucer_dir                 00:00009AFA
keep_scale                      00:00009F72
keep_small                      00:00009A22
keybd_cmdproc                   00:000063CC
keybd_dcb                        E:00040A40
keybd_getbuf                    00:0000640A
keybd_getchar                   00:00006402
keybd_init                      00:0000633C
keybd_putbuf                    00:0000640A
keybd_putchar                   00:000063FA
keybd_set_inpos                 00:0000640A
keybd_set_outpos                00:0000640A
keybd_stat                      00:000063F2
kgid1                           00:00006440
kgnotKbd                        00:00006448
kill_the_player                 00:00009FCA
last_fire                        S:00000021
last_hype                        S:00000022
last_vector                     00:0000AB1A
leds                             E:FD0FFF00
ledxit                          00:0000653C
lexpl_snd                        E:00000007
lexpl_sound                     00:0000C5F4
lgsau_snd                        E:00000004
lgsau_sound                     00:0000C649
limit_p_vel                     00:0000A25E
limit_velocity                  00:0000A24A
load_old_sound                  00:0000C592
load_sound                      00:0000C58C
local_x                          S:00000002
local_y                          S:00000004
loop1                           00:00000520
loop2                           00:0000051E
loop3                           00:00005A54
loop_atn                        00:0000A778
main_loop                       00:0000974A
make_rocks                      00:0000A0F6
memend                           E:00100004
mess_origin                     00:0000C1E2
mess_table                      00:0000C202
mexpl_snd                        E:00000006
mexpl_sound                     00:0000C609
min_rocks                        E:0000007D
move_item                       00:00009F0C
move_items                      00:00009EA2
move_next_item                  00:00009EA6
move_next_object                00:00009F78
msgAddrErr                      00:00008950
msgBadKeybd                     00:00006560
msgBusErr                       00:00008497
msgChk                          00:000089AC
msgHello                        00:000071C6
msgRtcReadFail                  00:0000847E
msgStackCanary                  00:000089BA
msgUnknownCmd                   00:000071B6
msgXmitBusy                     00:0000656F
msg_bad_branch_disp             00:0000896F
msg_core_start                  00:0000893F
msg_illegal                     00:0000895D
msg_io_access                   00:00008991
msg_reglist                     00:00007638
msg_regs                        00:00007634
msg_start                       00:00008918
msg_test_done                   00:00008981
nd1                             00:0000068C
nd2                             00:0000068C
nd3                             00:0000068C
nd4                             00:0000068C
neg_upper_ok                    00:0000A254
net_delay                       00:0000068C
new_rocks                        E:0000007B
next_hi_char                    00:00009D0C
next_p_high                     00:00009CD8
next_pss                        00:000098FE
nmeSerial                       00:00008322
nmi_rout                        00:0000888E
no_add_size                     00:0000996E
no_aim_shot                     00:00009B80
no_dec_new_rocks                00:000097CC
no_game_over                    00:000098A2
no_inc_min                      00:0000A120
no_neg_x10                      00:0000AA86
no_neg_x11                      00:0000AA5C
no_neg_x2                       00:0000AB08
no_neg_y10                      00:0000AA7A
no_neg_y11                      00:0000AA50
no_neg_y2                       00:0000AB00
no_new_rocks                    00:00009EDC
no_play                         00:000097AE
no_playerx                      00:00009C6C
no_pos_reflect                  00:0000A58E
no_reset_scale                  00:00009F0A
no_reset_xy                     00:0000A4FC
no_saucer_sound                 00:0000A5F8
no_save_ist                     00:00009A8C
no_set_max                      00:0000A130
no_shot_dec                     00:0000A3CA
no_shot_or                      00:00009B7C
no_thrust                       00:0000A5C8
no_thump_sound                  00:0000A62A
nodec_thmpi                     00:00009878
notRxInt                        00:000082C2
notTxInt                        00:00008310
not_closer                      00:0000A0E6
not_player                      00:000099BA
not_pss_player                  00:000099D2
not_right                       00:0000AA98
not_rot_left                    00:00009D56
not_rot_left1                   00:00009FFE
not_rot_right1                  00:0000A006
not_rot_right2                  00:00009D5E
not_saucer                      00:000099AC
not_thrust                      00:0000A064
not_timed_out                   00:00009D3A
not_x_max                       00:00009F2E
not_y_max                       00:00009F4E
notscreen                       00:0000A968
null_cmdproc                    00:00000588
null_dcb                         E:00040A00
null_init                       00:0000055A
null_ret                        00:00000586
numBreakpoints                   E:00000008
num_players                      S:0000001A
old_sound_play                  00:0000C5B4
op_ABCD                         00:00002BDC
op_ADD                          00:00003572
op_ADDA                         00:00003746
op_ADDQ                         00:00002F72
op_ADDX                         00:000037DE
op_ADD_I                        00:00001C5A
op_AND                          00:00003290
op_ANDI_TO_CCR                  00:00000A0A
op_ANDI_TO_SR                   00:00000A30
op_BCC                          00:00002E9C
op_BCHG                         00:00000E00
op_BCLR                         00:00001168
op_BOOL_I                       00:0000188A
op_BSET                         00:000014B6
op_BSR                          00:00001A3C
op_BTST                         00:00000A56
op_BTST0                        00:00000BE0
op_BTST1                        00:00000BEC
op_BTST10                       00:00000C34
op_BTST11                       00:00000C3C
op_BTST12                       00:00000C42
op_BTST2                        00:00000BF4
op_BTST20                       00:00000D9A
op_BTST21                       00:00000DA4
op_BTST22                       00:00000DAA
op_BTST23                       00:00000DB0
op_BTST24                       00:00000DB6
op_BTST25                       00:00000DBC
op_BTST26                       00:00000DC2
op_BTST27                       00:00000DC8
op_BTST28                       00:00000DCE
op_BTST29                       00:00000DD4
op_BTST3                        00:00000BFC
op_BTST30                       00:00000DDA
op_BTST31                       00:00000DE0
op_BTST32                       00:00000DE4
op_BTST4                        00:00000C04
op_BTST5                        00:00000C0C
op_BTST6                        00:00000C14
op_BTST7                        00:00000C1C
op_BTST8                        00:00000C24
op_BTST9                        00:00000C2C
op_CHK                          00:000024E6
op_CMP                          00:000033F0
op_CMPA                         00:00003466
op_CMPM                         00:000034CC
op_CMP_I                        00:00001A72
op_DBCC                         00:00002F1C
op_DIVS                         00:00003154
op_DIVU                         00:00003102
op_EOR                          00:0000337A
op_EORI_TO_CCR                  00:000009BE
op_EORI_TO_SR                   00:000009E4
op_EXG                          00:00003A96
op_EXT                          00:00002366
op_LEAPEA                       00:000023A8
op_LINKS                        00:000024B8
op_MOVE                         00:00001F66
op_MOVEM                        00:000028BE
op_MOVEP                        00:000017FE
op_MOVEQ                        00:000030E6
op_MOVE_USP                     00:000024D6
op_MOVE_xxx_FLAGS               00:00002172
op_MULS                         00:00003A4A
op_MULU                         00:000039FE
op_NBCD                         00:00002DCC
op_NEGS                         00:00002530
op_OR                           00:000031A6
op_ORI_TO_CCR                   00:0000097A
op_ORI_TO_SR                    00:0000099C
op_ROXx                         00:00003D3A
op_ROx                          00:00003B04
op_RTR                          00:00002E7A
op_SBCD                         00:00002CD4
op_SCC                          00:00002F42
op_SHIFTS                       00:00003F70
op_SHIFTS2                      00:000041B2
op_SUB                          00:0000365C
op_SUBA                         00:00003792
op_SUBQ                         00:0000302C
op_SUBX                         00:000038EE
op_SUB_I                        00:00001DE0
op_SWAP                         00:00002392
op_TAS                          00:00002454
op_TRAPV                        00:00002E5E
op_TST                          00:0000247A
op_abs                          00:0000AA6C
op_call                         00:0000AA2C
op_jump                         00:0000AA32
op_rtsvec                       00:0000AA1C
op_short                        00:0000AADC
op_vctr                         00:0000AA42
output_number                   00:0000A7D2
output_number_loop              00:0000A7D4
p1_high                          S:00000176
p1_score                         S:00000173
p1_ships                         S:00000175
p2_high                          S:0000027A
p2_score                         S:00000277
p2_ships                         S:00000279
p_2_end                          S:0000027B
p_fire_off                       E:0000002B
p_flag_off                       E:00000027
p_orient                         S:0000001E
p_xpos_off                       E:FFFFFFB6
p_xvel_off                       E:0000004A
p_xvlo_off                       E:0000007E
p_ypos_off                       E:FFFFFFFC
p_yvel_off                       E:0000006D
p_yvlo_off                       E:0000007F
past_play                        S:00000019
pcssxa                          00:00007E4A
pen_color                        E:00040890
pfire_snd                        E:00000001
pfire_sound                     00:0000C686
piece_draw_loop                 00:0000A506
play_00                         00:0000BD40
play_01                         00:0000BD58
play_02                         00:0000BD7C
play_03                         00:0000BDA0
play_04                         00:0000BDC4
play_05                         00:0000BDE6
play_06                         00:0000BE0A
play_07                         00:0000BE2E
play_08                         00:0000BE52
play_09                         00:0000BE76
play_0A                         00:0000BE9A
play_0B                         00:0000BEBE
play_0C                         00:0000BEE2
play_0D                         00:0000BF06
play_0E                         00:0000BF2A
play_0F                         00:0000BF4E
play_10                         00:0000BF72
play_liv                        00:0000BF8A
play_sample                     00:0000C598
play_sound                       S:00000015
play_tab                        00:0000BD1E
player_1                         E:000000F3
player_2                         E:000001F7
player_idx                       S:00000018
player_init                     00:0000A19E
player_n                        00:0000A902
player_reset                    00:0000A1D4
player_shot                     00:000099FE
player_x                        00:0000A8FE
plot                            00:000060AA
plot_and                        00:00006166
plot_black                      00:00006188
plot_copy                       00:0000617A
plot_or                         00:0000613C
plot_sw                         00:00006118
plot_white                      00:00006192
plot_xor                        00:00006150
plottbl                         00:000060DC
pos_lower_ok                    00:0000A266
prtflt                          00:000086E8
pss_check_loop                  00:000098F8
push_start_mess                 00:0000984C
px_hide                         00:000097A6
px_time                          S:0000001C
r_hit_tim                        E:00000079
ramtest                         00:00007CDA
ramtest0                        00:00007D24
ramtest1                        00:00007D2C
ramtest2                        00:00007D58
ramtest3                        00:00007D9A
ramtest6                        00:00007D48
rbo                             00:00007FB4
read_hi                         00:0000A9EA
readyQ                           E:00100320
reset_game                      00:00009E24
reset_xy_loop                   00:0000A4E4
reveal_player                   00:00009FC2
rmtst1                          00:00007D3C
rmtst2                          00:00007D6E
rmtst3                          00:00007D76
rmtst5                          00:00007CF4
rock_0                          00:0000BC96
rock_1                          00:0000BCAE
rock_2                          00:0000BCCA
rock_3                          00:0000BCE4
rock_count                       E:00000076
rock_hit_out                    00:00009A5E
rock_on_x                       00:0000A170
rock_score                      00:0000A69E
rock_tab                        00:0000BC8E
rock_y_ok                       00:0000A16E
rot_and_thrust                  00:00009FE6
rot_not_left                    00:00009D5E
rotate_iofocus                  00:000062D6
rtc_read                        00:00008388
rtc_write                       00:00008414
sGetChar                        00:00007F80
s_controls                      00:0000A968
s_fire_off                       E:00000029
s_flag_off                       E:00000028
s_key                            S:00000014
s_mess_0                        00:0000C47E
s_mess_1                        00:0000C486
s_mess_2                        00:0000C48F
s_mess_3                        00:0000C4B6
s_mess_4                        00:0000C4D4
s_mess_5                        00:0000C4FC
s_mess_6                        00:0000C50E
s_mess_7                        00:0000C51B
s_messages                      00:0000C46E
s_orient                         S:0000001F
s_xpos_off                       E:FFFFFFB8
s_xvel_off                       E:0000004B
s_ypos_off                       E:FFFFFFFE
s_yvel_off                       E:0000006E
sauc_cntdn                       E:00000077
sauc_jsr                        00:0000BD00
sauc_vec                        00:0000BD02
saucer_yok                      00:00009A9E
saucer_yvel                     00:00009B0E
save_char                       00:00009D8C
save_hbutton                    00:00009D24
save_hi_index                   00:0000A6F4
save_hyperspace                 00:00009E1E
save_saucer                     00:00009ADC
save_ship_fire                  00:00009BC0
score_off                        E:00000080
scr_x                            S:00000006
scr_y                            S:00000008
select_focus1                   00:000062E8
select_iofocus                  00:000062C4
semamem                          E:FD050000
serial_cmdproc                  00:0000803C
serial_dcb                       E:00040B40
serial_getbuf                   00:00008094
serial_getchar                  00:0000806E
serial_getchar_direct           00:00008074
serial_init                     00:00007FBC
serial_peek_char                00:0000807C
serial_peek_char_direct         00:00008084
serial_putbuf                   00:00008094
serial_putchar                  00:00008066
serial_putchar_direct           00:0000808C
serial_set_inpos                00:00008094
serial_set_outpos               00:00008094
serial_stat                     00:00008062
set_graphics_mode               00:000059E6
set_text_mode                   00:000059BC
setscreen                       00:0000A968
setup_console                   00:0000058A
setup_keybd                     00:0000633C
setup_null                      00:0000055A
setup_serial                    00:00007FBC
sexpl_snd                        E:00000005
sexpl_sound                     00:0000C61E
sfire_snd                        E:00000000
sfire_sound                     00:0000C698
shift_left                      00:0000AB16
ship_fire                       00:00009B96
ship_move                       00:00009F94
ship_parts                      00:0000A56C
ship_wrk_x                      00:0000A4BA
ship_wrk_y                      00:0000A4C6
ships_off                        E:00000082
shot_jsr                        00:0000C1CE
shot_mask                       00:00009B92
shot_or                         00:00009B94
shot_vec                        00:0000C1D0
show_ships                      00:00009E82
sin_cos                         00:0000A80E
sin_d0                          00:0000A7F4
sirq0001                        00:00008272
sirq0002                        00:00008310
sirqNxtByte                     00:00008260
sirqRxFull                      00:000082C2
sirqTxEmpty                     00:00008310
sirqXmitOff                     00:00008310
sixteen_ms                       S:0000001D
skip_add                        00:0000A662
skip_p2_score                   00:0000A350
skip_play_flash                 00:0000A2B4
skip_play_inc                   00:00009EC2
skip_player_cont                00:000097A2
skip_player_move                00:0000979E
skip_sub                        00:0000A782
small_s_size                    00:0000996A
small_saucer                    00:00009ADA
smsau_snd                        E:00000003
smsau_sound                     00:0000C65E
sound_init                      00:0000C52B
sound_key                       00:0000C5B8
ss_count                         S:0000001B
start                           00:000003B8
start_game                      00:00009818
start_left                      00:00009AB2
start_other                     00:00000532
static_messages                 00:0000A270
suppress_0                       S:00000016
switch_addr                      S:0000000E
sys_switches                     E:000408B8
tblPow2                         00:00007004
tcbs                             E:20010000
test_fire_loop                  00:00009BB4
test_neg_fire                   00:00009C2C
third_quad                      00:0000A594
thmp_sndi                        E:0000007C
three_ship_start                00:00009E32
thrst_snd                        E:00000002
thrst_sound                     00:0000C673
thump_snd                        S:00000023
thump_time                       S:00000024
tickcnt                          E:0004009C
time_count                       S:00000025
timer_interrupt                 00:0000A8F8
trap3                           00:000084C2
variables                       00:0000C6B7
vec_x_pos                       00:0000A52C
vec_y_pos                       00:0000A538
vector                          00:0000AB68
vector_base                     00:0000AAA0
vector_move                     00:0000AB3C
was_rot_left                    00:00009D5E
what_hit_rock                   00:000099DE
what_hit_saucer                 00:00009A0A
wide_shot                       00:00009B72
wrap_to_a                       00:00009D7E
wrap_to_z                       00:00009D82
write_initial                   00:00009E4E
x_off_pos                       00:0000A224
x_pos_end                        E:FFFFFFC6
x_pos_neg                       00:00009F1E
x_pos_off                        E:FFFFFF80
x_vel_off                        E:0000002F
y_not_neg                       00:00009F44
y_off_pos                       00:0000A23E
y_pos_off                        E:FFFFFFC6
y_vel_off                        E:00000052
zero_suppress                   00:0000A7E4

Symbols by value:
FD050000 semamem
FD060000 ACIA
FD069000 I2C2
FD080000 TEXTREG
FD090000 PLIC
FD0FFC00 RST_REG
FD0FFD00 RAND_NUM
FD0FFD00 RAND
FD0FFD04 RAND_STRM
FD0FFD08 RAND_MZ
FD0FFD0C RAND_MW
FD0FFE00 KEYBD
FD0FFF00 leds
FD200000 FRAMEBUF
FDC00000 MMU
FFFFFF80 x_pos_off
FFFFFFB6 p_xpos_off
FFFFFFB8 s_xpos_off
FFFFFFBA f_xpos_off
FFFFFFC6 y_pos_off
FFFFFFC6 x_pos_end
FFFFFFF0 DDATA
FFFFFFFC HISPC
FFFFFFFC p_ypos_off
FFFFFFFE s_ypos_off
00000000 HAS_MMU
00000000 glob_scale
00000000 E_Ok
00000000 DCB_MAGIC
00000000 ACIA_TX
00000000 TCBInit
00000000 ACIA_RX
00000000 f_ypos_off
00000000 sfire_snd
00000000 I2C_PREL
00000001 DT_NUMERIC
00000001 SCREEN_FORMAT
00000001 pfire_snd
00000001 I2C_PREH
00000002 SERIAL_SEMA
00000002 I2C_CTRL
00000002 DT_STRING
00000002 local_x
00000002 E_Func
00000002 thrst_snd
00000002 DEV_PUTCHAR
00000003 I2C_RXR
00000003 smsau_snd
00000003 KEYBD_SEMA
00000003 CTRLC
00000003 I2C_TXR
00000004 RAND_SEMA
00000004 NCORES
00000004 local_y
00000004 I2C_CMD
00000004 EOT
00000004 DCB_NAME
00000004 lgsau_snd
00000004 TCBRegs
00000004 I2C_STAT
00000004 ACIA_STAT
00000005 sexpl_snd
00000005 SCREEN_SEMA
00000006 MEMORY_SEMA
00000006 mexpl_snd
00000006 scr_x
00000007 lexpl_snd
00000008 CTRLH
00000008 beat1_snd
00000008 ACIA_CMD
00000008 FMTK_SEMA
00000008 numBreakpoints
00000008 scr_y
00000009 E_NotAlloc
00000009 beat2_snd
0000000A FDATA
0000000A PRNlword
0000000A LF
0000000A E_NotSupported
0000000A extra_snd
0000000C ACIA_CTRL
0000000C flags_off
0000000D CR
0000000D SC_TAB
0000000E switch_addr
00000010 LOCVARSZ
00000011 XON
00000011 SC_ALT
00000012 SC_LSHIFT
00000012 hiscore_y
00000013 XOFF
00000013 CTRLS
00000014 s_key
00000014 SC_CTRL
00000015 play_sound
00000016 suppress_0
00000017 high_idx
00000018 DCB_CMDPROC
00000018 player_idx
00000018 CTRLX
00000019 past_play
0000001A CTRLZ
0000001A num_players
0000001B ss_count
0000001C px_time
0000001D sixteen_ms
0000001E p_orient
0000001F FOC
0000001F s_orient
00000020 E_BadDevNum
00000020 TS_PREEMPT
00000020 BLANK
00000020 hi_char
00000021 last_fire
00000022 last_hype
00000023 thump_snd
00000024 thump_time
00000025 time_count
00000026 hyper
00000027 FOP
00000027 hiscores
00000027 p_flag_off
00000028 TCBHandleToPointer
00000028 s_flag_off
00000028 DCB_INBUFPTR
00000029 s_fire_off
0000002B p_fire_off
0000002C DCB_OUTBUFPTR
0000002F x_vel_off
0000002F flag_end
00000030 DCB_INBUFSIZE
00000034 DCB_OUTBUFSIZE
00000038 DCB_INROWS
00000039 DCB_INCOLS
0000003A DCB_OUTROWS
0000003B hinames
0000003B DCB_OUTCOLS
0000003F BUFSIZE
00000040 TCBPointerToHandle
00000040 DCB_SIZE
00000044 TCBUSP
00000048 TCBSSP
0000004A p_xvel_off
0000004B s_xvel_off
0000004C TCBSR
0000004C f_xvel_off
00000050 TCBPC
00000050 TCBIAlloc
00000050 BUFLEN
00000052 y_vel_off
00000054 TCBStatus
00000055 TCBPriority
00000058 SC_CAPSLOCK
00000059 SC_RSHIFT
00000059 game_count
0000005B expl_x_pos
00000067 expl_y_pos
0000006C TCBStartTick
0000006D p_yvel_off
0000006E s_yvel_off
0000006E TCBAlloc
0000006F f_yvel_off
00000070 TCBEndTick
00000074 TCBTicks
00000075 i_rk_count
00000076 rock_count
00000077 SC_NUMLOCK
00000077 sauc_cntdn
00000078 i_sauc_tim
00000079 r_hit_tim
0000007A hide_p_cnt
0000007B new_rocks
0000007C TCBIFree
0000007C TCBNext
0000007C thmp_sndi
0000007D min_rocks
0000007E SC_SCROLLLOCK
0000007E p_xvlo_off
0000007F p_yvlo_off
00000080 TS_RUNNING
00000080 score_off
00000080 TCBPrev
00000082 ships_off
00000082 TCBAffinityBase
00000083 high_off
00000084 TCBAffinity
00000092 TCBFree
000000A0 TCBAffineChose
000000D8 TCBInsertIntoReadyQueue
000000E0 SC_EXTEND
000000F0 SC_KEYUP
000000F3 player_1
00000100 IRQ_trampolines
00000100 TCB_SIZE
00000150 TCBRemoveFromReadyQueue
00000172 StartQ
00000173 p1_score
00000175 p1_ships
00000176 p1_high
0000017A TCBPopReadyQueue
000001F7 player_2
00000220 FemtikiInit
00000230 FemtikiInitIRQ
0000023E OSCallTable
00000240 CallOS
00000277 p2_score
00000279 p2_ships
0000027A p2_high
0000027B p_2_end
000002AA GetRunningTCBPointer
000002C2 SelectThreadToRun
000002EC UpdateIRQLive
0000030E FemtikiTimerIRQ
00000396 LockSysSemaphore
000003A6 UnlockSysSemaphore
000003B8 start
00000400 irq_list_tbl
0000051E loop2
00000520 loop1
00000532 start_other
00000554 do_nothing
0000055A setup_null
0000055A null_init
00000586 null_ret
00000588 null_cmdproc
0000058A console_init
0000058A setup_console
00000608 CON_CMDTBL
00000628 console_cmdproc
0000064E console_stat
00000652 console_putchar
0000065A console_getchar
00000662 console_getbuf
00000662 console_set_outpos
00000662 console_putbuf
00000662 console_set_inpos
00000666 init_framebuf
00000682 GlobalReadLong
00000688 GlobalWriteLong
0000068C nd1
0000068C net_delay
0000068C nd2
0000068C nd3
0000068C nd4
00000690 InitIOPBitmap
000006DC RandInit
000006DC InitRand
0000071C RandGetNum
0000074A _GetRand
0000076C RandWait
00000782 InitSemaphores
000007A8 LockSemaphore
000007CA ForceUnlockSemaphore
000007E4 UnlockSemaphore
00000800 STRAREASIZE
00000800 T15LockSemaphore
00000806 T15UnlockSemaphore
0000080C T15GetFloat
0000081A T15Abort
0000082C chk_exception
00000842 Delay3s
00000850 dly3s2
00000852 dly3s1
00000866 Delay3s2
00000882 cpu_test
00000960 ALL_DONE
00000962 BSR_FAR1
0000096A EXCEPTION_6
00000972 EXCEPTION_7
0000097A op_ORI_TO_CCR
0000099C op_ORI_TO_SR
000009BE op_EORI_TO_CCR
000009E4 op_EORI_TO_SR
00000A0A op_ANDI_TO_CCR
00000A30 op_ANDI_TO_SR
00000A56 op_BTST
00000BE0 op_BTST0
00000BEC op_BTST1
00000BF4 op_BTST2
00000BFC op_BTST3
00000C04 op_BTST4
00000C0C op_BTST5
00000C14 op_BTST6
00000C1C op_BTST7
00000C24 op_BTST8
00000C2C op_BTST9
00000C34 op_BTST10
00000C3C op_BTST11
00000C42 op_BTST12
00000D9A op_BTST20
00000DA4 op_BTST21
00000DAA op_BTST22
00000DB0 op_BTST23
00000DB6 op_BTST24
00000DBC op_BTST25
00000DC2 op_BTST26
00000DC8 op_BTST27
00000DCE op_BTST28
00000DD4 op_BTST29
00000DDA op_BTST30
00000DE0 op_BTST31
00000DE4 op_BTST32
00000E00 op_BCHG
00000FFF MAX_TID
00001000 NR_TCB
00001168 op_BCLR
000014B6 op_BSET
000017FE op_MOVEP
0000188A op_BOOL_I
00001A34 BSR_CLOSE1
00001A3C op_BSR
00001A6A BSR_CLOSE2
00001A72 op_CMP_I
00001C5A op_ADD_I
00001DE0 op_SUB_I
00001F66 op_MOVE
00002032 MOVE2
000020AE MOVE1
0000212E MOVE3
00002172 op_MOVE_xxx_FLAGS
00002288 MOVE4
00002366 op_EXT
00002392 op_SWAP
000023A8 op_LEAPEA
00002440 LEA1
00002454 op_TAS
0000247A op_TST
000024B8 op_LINKS
000024D6 op_MOVE_USP
000024E6 op_CHK
00002530 op_NEGS
000028BE op_MOVEM
00002BDC op_ABCD
00002BFC ABCD_OUTER1
00002BFE ABCD_INNER1
00002C1A ABCD_NO_C1
00002C22 ABCD_NO_C2
00002C6A ABCD_OUTER2
00002C6C ABCD_INNER2
00002C88 ABCD_NO_C3
00002C90 ABCD_NO_C4
00002CD4 op_SBCD
00002CF4 SBCD_OUTER1
00002CF6 SBCD_INNER1
00002D12 SBCD_NO_C1
00002D1A SBCD_NO_C2
00002D62 SBCD_OUTER2
00002D64 SBCD_INNER2
00002D80 SBCD_NO_C3
00002D88 SBCD_NO_C4
00002DCC op_NBCD
00002DE4 NBCD_LOOP
00002DF0 NBCD_NO_C
00002DF4 NBCD_NO_Z
00002E2A NBCD_LOOP1
00002E3E NBCD_NO_C1
00002E42 NBCD_NO_Z1
00002E5E op_TRAPV
00002E7A op_RTR
00002E86 RTR_DONE
00002E94 BSR_FAR2
00002E9C op_BCC
00002EA4 BCC1
00002EAE BCC2
00002EB6 BCC3
00002EC0 BCC4
00002EC8 BCC5
00002ED2 BCC6
00002EDA BCC7
00002EE4 BCC8
00002EEC BCC9
00002EF6 BCC10
00002EFE BCC11
00002F08 BCC12
00002F10 BCC13
00002F1A BCC14
00002F1C op_DBCC
00002F24 DBCC_LOOP1
00002F32 DBCC_LOOP2
00002F42 op_SCC
00002F72 op_ADDQ
00002F86 ADDQ_LOOP1
00002FC4 ADDQ_LOOP2
00002FFA ADDQ_LOOP3
0000302C op_SUBQ
00003044 SUBQ_LOOP1
0000307E SUBQ_LOOP2
000030B4 SUBQ_LOOP3
000030E6 op_MOVEQ
00003102 op_DIVU
0000311E DIVU_OUTER1
00003154 op_DIVS
00003170 DIVS_OUTER1
000031A6 op_OR
000031C6 OR_OUTER1
0000323A OR_OUTER2
00003290 op_AND
000032B0 AND_OUTER1
00003324 AND_OUTER2
0000337A op_EOR
0000339A EOR_OUTER2
000033F0 op_CMP
00003410 CMP_OUTER1
00003466 op_CMPA
00003486 CMPA_OUTER1
000034CC op_CMPM
00003514 CMPM_LOOP1
0000352E CMPM_LOOP2
00003548 CMPM_LOOP3
00003572 op_ADD
00003592 ADD_OUTER1
00003606 ADD_OUTER2
0000365C op_SUB
0000367C SUB_OUTER1
000036F0 SUB_OUTER2
00003746 op_ADDA
0000376C ADDA_OUTER1
00003792 op_SUBA
000037B8 SUBA_OUTER1
000037DE op_ADDX
000037FE ADDX_OUTER1
00003892 ADDX_LOOP3
000038AE ADDX_LOOP4
000038CA ADDX_LOOP5
000038EE op_SUBX
0000390E SUBX_OUTER1
000039A2 SUBX_LOOP3
000039BE SUBX_LOOP4
000039DA SUBX_LOOP5
000039FE op_MULU
00003A1A MULU_OUTER1
00003A4A op_MULS
00003A66 MULS_OUTER1
00003A96 op_EXG
00003AF8 ROx_FLAGS
00003B04 op_ROx
00003B0E ROx_LOOP1
00003B2E ROx_LOOP2
00003B4E ROx_LOOP3
00003B6E ROx_LOOP4
00003B8E ROx_LOOP5
00003BB0 ROx_LOOP6
00003D2E ROXx_FLAGS
00003D3A op_ROXx
00003D44 ROXx_LOOP1
00003D64 ROXx_LOOP2
00003D84 ROXx_LOOP3
00003DA4 ROXx_LOOP4
00003DC4 ROXx_LOOP5
00003DE6 ROXx_LOOP6
00003F64 SHIFTS_FLAGS
00003F70 op_SHIFTS
00003F7A SHIFTS_LOOP1
00003F9A SHIFTS_LOOP2
00003FBA SHIFTS_LOOP3
00003FDA SHIFTS_LOOP4
00003FFA SHIFTS_LOOP5
00004000 REL4
0000401C SHIFTS_LOOP6
000041A6 SHIFTS2_FLAGS
000041B2 op_SHIFTS2
000041BC SHIFTS2_LOOP1
000041D8 SHIFTS2_LOOP2
000041F4 SHIFTS2_LOOP3
00004210 SHIFTS2_LOOP4
0000422C SHIFTS2_LOOP5
0000424A SHIFTS2_LOOP6
000043D0 START
000043D2 GOWARM
000043D6 GOOUT
000043DA GOIN
000043DE GOAUXO
000043E2 GOAUXI
000043E6 GOBYE
000043EA TXTBGN
000043EE ENDMEM
000043F2 CSTART
0000445C WSTART
00004490 ST3
000044E2 ST4
0000451C ClearStringArea
0000453C ClearStringStack
00004550 TAB1
0000457F TAB2
000045BC TAB4
000045EE TAB5
000045F1 TAB6
000045F6 TAB8
00004601 TAB9
00004605 TAB10
00004608 TAB11
00004610 TAB1_1
00004640 TAB2_1
00004680 TAB4_1
000046B4 TAB5_1
000046BC TAB6_1
000046C4 TAB8_1
000046E0 TAB9_1
000046E8 TAB10_1
000046F0 TAB11_1
000046F8 DIRECT
00004708 EXEC
00004710 EXLP
0000471A EXNGO
00004732 EX1
00004738 EXMAT
0000473E EXGO
00004742 INCON
00004750 INCOM
0000475E IOCOM
00004768 OUTCOM
00004774 IOCON
0000477E OUTCON
0000478A NEW
0000479E STOP
000047A6 RUN
000047BA RUNNXL
000047FA RUN1
00004806 RUNTSL
00004810 RUNSML
00004820 GOTO
00004834 ONIRQ
0000484E ONIRQ1
00004858 WAITIRQ
00004868 LIST
00004874 LS1
00004888 LS2
0000488E LS3
00004894 PRINT
000048A4 PR2
000048B2 PR0
000048C0 PR1
000048CE PR3
000048DA PR6
000048E0 PR8
000048FC PR9
00004916 FINISH
0000491E GOSUB
00004958 RETURN
00004984 FOR
0000499E FR1
000049B6 FR2
000049BC FR3
000049C2 FR4
000049CA FR5
000049DC FR6
000049E8 FR7
00004A00 FR8
00004A04 NEXT
00004A0E NX0
00004A20 NX3
00004A4E NX1
00004A66 NX2
00004A6E REM
00004A70 IF
00004A74 IF1
00004A7A IF2
00004A8A INPERR
00004A98 INPUT
00004ABC IP7
00004AC6 IP6
00004ACA IP2
00004AE4 IP3
00004B1E IP4
00004B2A IP5
00004B2E DEFLT
00004B36 LET
00004B42 LT1
00004B46 LOAD
00004B52 LOD1
00004B6C LOD2
00004B7C LODEND
00004B86 GBYTE
00004B8A GBYTE1
00004B98 GBYTE2
00004BA6 SAVE
00004BAE SAVE1
00004BD2 SAVE2
00004BE0 SAVEND
00004C04 PBYTE
00004C06 PBYTE1
00004C1A PBYTE2
00004C24 POKE
00004C9A PKER
00004C9E CALL
00004CB2 XP_PUSH
00004CC8 XP_POP
00004CDE XP_POP1
00004CF4 NUM_EXPR
00004D02 INT_EXPR
00004D14 EXPR_OR
00004D14 EXPR
00004D24 XP_OR
00004D3A EXPR_AND
00004D4C XP_AND
00004D62 XP_ORX
00004D62 XP_ANDX
00004D68 CheckNumeric
00004D7A EXPR_REL
00004D8E XP11
00004D9A XP12
00004DA6 XP13
00004DB2 XP14
00004DBE XP15
00004DCA XP15RT
00004DCC XP16
00004DDA XPRT0
00004DE2 XPRT1
00004DEA XP17
00004DF0 XP18
00004E04 EXPR2
00004E12 XP21
00004E18 XP22
00004E1C XP23
00004E2A XP24
00004E58 XP25
00004E5E XP26
00004E72 XP27
00004E74 ConcatString
00004EE2 EXPR3
00004EE4 XP36
00004EE8 XP30
00004EF4 XP31
00004F0A XP34
00004F24 XP35
00004F2A XP_MOD
00004F4C EXPR4
00004F58 XP40
00004F68 EXP4RT
00004F6A XP41
00004F7A XPSTNG
00004F84 XP45
00004FD6 XP44
00004FE2 PARN
00004FF2 XP42
00004FF4 XP43
00004FF8 AllocateString
00005000 REL5
00005056 GarbageCollectStrings
00005092 NextString
000050A8 StringInVar
000050C6 SIV1
000050EE PointsIntoStringArea
00005112 StringOnStack
00005142 UpdateStringPointers
0000516E USP1
00005190 TSTV
000051D8 TV1
00005208 TV2
00005210 TSTVRT
00005212 DIV32
00005224 DIV1
0000522A DIV2
00005230 DIV3
0000523E DIV4
0000524C DIVRT
0000524E PEEK
000052B6 RND
000052E0 ABS
000052EC SIZE
000052FC TICK
00005308 CORENO
00005314 LorRArgs
0000534C LorR1
00005350 MID
00005398 MID2
000053B0 MID5
000053B8 DOMID
000053E4 MID4
00005416 MID1
0000541A LEFT
00005426 RIGHT
0000544E LEN
00005474 INT
0000548A CHR
000054C2 SETVAL
000054E0 SV1
000054E2 FIN
000054EE FI1
000054FA FI2
000054FC ENDCHK
0000550C ENDCHK1
0000550E QWHAT
00005510 AWHAT
00005514 ERROR
0000554E QSORRY
00005550 ASORRY
00005556 QHOW
00005558 AHOW
0000555E ETYPE
00005564 GETLN
00005574 GL1
00005592 GL2
000055A6 GL3
000055CA GL4
000055D6 GL5
000055F2 GL6
000055FA GL7
00005602 FNDLN
00005610 FNDLNP
00005626 FNDRET
00005628 FNDNXT
0000562A FNDSKP
00005638 MVUP
00005640 MVRET
00005642 MVUPW
0000564C MVDOWN
00005654 POPA
00005690 PUSHA
000056C6 PRTSTG
000056C8 PS1
000056E0 PRTRET
000056E2 PRTSTR2a
000056E8 PRTSTR2
000056EE PRTNUM
00005738 PRTLN
00005756 TSTC
00005768 TC1
0000576E TSTNUM
000057BA IGNBLK
000057C4 TOUPBUF
000057CA TOUPB1
000057EA TOUPBRT
000057EC DOQUO
000057F4 DOQUO1
000057FC TOUPPER
0000580C TOUPRET
0000580E CHKIO
0000581E CHKRET
00005820 PRMESG
0000582A PRMRET
0000582C CLS
00005838 OUTC
00005848 INC
00005854 INC1
00005868 AUXOUT
0000587C AUXIN
0000589A AXIRET
0000589C BYEBYE
000058AA INITMSG
000058CE OKMSG
000058D5 HOWMSG
000058DC WHTMSG
000058E4 TYPMSG
000058EC NOSTRING
000058FE SRYMSG
00005904 CLMSG
00005908 RANPNT
00005908 LSTROM
0000590C INPPTR
00005910 OUTPTR
00005914 CURRNT
00005918 STKFP
0000591C STKGOS
00005920 STKINP
00005924 LOPVAR
00005928 LOPINC
00005934 LOPLMT
00005940 LOPLN
00005944 LOPPT
00005948 IRQROUT
0000594C STRSTK
00005950 StrSp
00005954 StrArea
00005958 LastStr
0000595C TXTUNF
00005960 VARBGN
00005964 STKLMT
00005968 DIRFLG
0000596C BUFFER
000059BC TXT
000059BC set_text_mode
000059E6 set_graphics_mode
00005A10 get_screen_color
00005A22 get_screen_address
00005A2A clear_screen
00005A54 loop3
00005A66 CRLF
00005A80 UpdateTextPos
00005AAA CalcScreenLoc
00005AB8 DisplayChar
00005AD6 dcx14
00005ADA dcx7
00005AE0 dccr
00005AFE dcx6
00005B14 dcx8
00005B2A dcx9
00005B48 dcx10
00005B60 dcx12
00005B6A dcx11
00005BA4 dclf
00005BA8 dcx16
00005BAC dcx4
00005BB6 doBackspace
00005BC4 doDelete
00005BFA doCtrlX
00005C1E IncCursorPos
00005C3E IncCursorRow
00005C70 icc1
00005C72 ScrollUp
00005CBA BlankLastLine
00005D18 DisplayString
00005D1C dspj1
00005D28 dsret
00005D2E DisplayStringCRLF
00005D34 DisplayStringLimited
00005D54 DisplayStringLimitedCRLF
00005D5A HomeCursor
00005D6C SyncCursor
00005DA0 TRAP15
00005DB8 T15DispatchTable
00005F48 SimHardware
00005F58 GetTick
00005F60 SetDrawMode
00005F82 SetPenColor
00005F8A GRBufferToScreen
00005FB4 clear_bitmap_screen4
00006020 TestBitmap
000060AA plot
000060DC plottbl
00006118 plot_sw
0000613C plot_or
00006150 plot_xor
00006166 plot_and
0000617A plot_copy
00006188 plot_black
00006192 plot_white
0000619E MoveToXY
000061AC DrawToXY
0000622A DrawHorizTo
0000625A DrawVertTo
0000628A Cursor1
000062C2 StubRout
000062C4 select_iofocus
000062D6 rotate_iofocus
000062E8 select_focus1
00006306 init_plic
0000633C keybd_init
0000633C setup_keybd
000063AC KBD_CMDTBL
000063CC keybd_cmdproc
000063F2 keybd_stat
000063FA keybd_putchar
00006402 keybd_getchar
0000640A keybd_set_inpos
0000640A keybd_getbuf
0000640A keybd_set_outpos
0000640A keybd_putbuf
0000640E KeybdGetID
00006440 kgid1
00006448 kgnotKbd
0000644C KeybdSetLED
00006478 KeybdInit
00006478 _KeybdInit
000064A4 kbdi0002
0000650E kbdiTryAgain
0000651C kbdi0004
00006538 kbdi0005
0000653C ledxit
00006552 kbdiXmitBusy
00006560 msgBadKeybd
0000656F msgXmitBusy
0000658A _KeybdGetStatus
000065A8 _KeybdGetScancode
000065C6 _KeybdClearIRQ
000065DC KeybdRecvByte
000065FE KeybdWaitTx
00006624 SetKeyboardEcho
0000662C CheckForKey
00006638 GetKey
00006670 CheckForCtrlC
00006680 KeybdGetCharNoWait
00006688 KeybdGetCharWait
00006690 KeybdGetChar
000068AC KeybdSetLEDStatus
000068FC KeybdSendByte
00006904 Wait10ms
00006920 Wait300ms
0000693C KeybdIRQ
000069F2 _unshiftedScanCodes
00006AF2 _shiftedScanCodes
00006BF2 _keybdControlCodes
00006C72 _keybdExtendedCodes
00006CF2 cmdString
00006D2C cmdTable
00006D98 FromScreen
00006DA2 StartMon
00006DAC Monitor
00006DAC cmdMonitor
00006DC8 PromptLn
00006DD4 Prompt3
00006DEA Prompt1
00006DFC cmdDispatch
00006E42 cmdVideoMode
00006E82 cmdBreakpoint
00006EA6 cmdAsteroids
00006EAE cmdTinyBasic
00006EB2 cmdTestCPU
00006EC2 cmdClearScreen
00006ECE cmdCore
00006EF2 cmdFMTK
00006EFA cmdTestFP
00006F86 cmdTestGF
00006FB4 cmdClock
00006FD2 cmdReset
00007000 REL7
00007004 tblPow2
00007024 cmdHelp
00007024 DisplayHelp
00007030 HelpMsg
000071B6 msgUnknownCmd
000071C6 msgHello
000071D8 GetCmdLine
0000727C cmdSendSerial
000072AC cmdReceiveSerial
000072E0 cmdFillB
00007334 cmdFillW
00007388 cmdFillL
000073D4 ignBlanks
000073E6 PeekScreenChar
000073EC GetSzChar
00007412 EditMemHelper
00007434 cmdEditMemory
0000743E edtmem1
0000748A ExecuteCode
0000748A cmdJump
0000749A cmdDisassemble
000074EA cmdDumpMemory
0000750E DumpMem1
00007520 DisplayMem
0000754C dspmem1
000075B4 cmdDumpRegs
00007634 msg_regs
00007638 msg_reglist
0000765E cmdTestSerialReceive
0000767E GetHexNumber
000076AC GetDecNumber
000076F0 _dfOne
000076FC _dfTen
00007708 _dfMil
00007714 _msgNan
00007718 _msgInf
0000771C _CheckNan
00007780 _CheckZero
0000779A _CheckNegative
000077AC _MakeBig
000077C8 _LessThanDbl
000077F4 _ComputeDigitsBeforeDecpt
0000782E _LeadingZero
0000783E _SpitOutDigits
000078BA _TrimTrailingPoint
000078D8 _TrimDotZero
000078F4 _TrimTrailingZeros
00007900 _SpitOutE
00007918 _ExtExpDigit
00007936 _ExtExpDigits
0000795E _PadLeft
000079AE _PadRight
000079E0 _FloatToString
00007A22 _GetFloatGetChar
00007A28 _GetFloatIgnBlanks
00007A30 _GetFloatBackupChar
00007A34 _GetFraction
00007A98 _GetExponent
00007B22 _GetInteger
00007B98 _GetFloat
00007C10 AsciiToHexNybble
00007C22 gthx5
00007C34 gthx6
00007C46 gthx3
00007C4A DisplayTwoSpaces
00007C54 dspspc1
00007C5C DisplaySpace
00007C64 DisplayTetra
00007C6A DisplayWyde
00007C70 DisplayByte
00007C76 DisplayNybble
00007C90 BufTetra
00007C96 BufWyde
00007C9C BufByte
00007CA2 BufNybble
00007CBA DisplayAddr
00007CDA ramtest
00007CDA cmdTestRAM
00007CF4 rmtst5
00007D24 ramtest0
00007D2C ramtest1
00007D3C rmtst1
00007D48 ramtest6
00007D58 ramtest2
00007D6E rmtst2
00007D76 rmtst3
00007D9A ramtest3
00007D9C cmdLoadS19
00007DA2 NextRec
00007DB4 ProcessRec
00007E4A pcssxa
00007EB6 ProcessS1
00007EBA ProcessS2
00007EBE ProcessS3
00007EC2 ProcessS7
00007ED2 ProcessS8
00007EE2 ProcessS9
00007EF2 S19Get16BitAddress
00007F00 S19Get24BitAddress
00007F0C S19Get32BitAddress
00007F2A S1932a
00007F3E S1932b
00007F80 sGetChar
00007FA8 AudioInputTest
00007FAA BouncingBalls
00007FAC GraphicsDemo
00007FAE ClearScreen
00007FB4 rbo
00007FBC setup_serial
00007FBC serial_init
0000800C COM_CMDTBL
0000803C serial_cmdproc
00008062 serial_stat
00008066 serial_putchar
0000806E serial_getchar
00008074 serial_getchar_direct
0000807C serial_peek_char
00008084 serial_peek_char_direct
0000808C serial_putchar_direct
00008094 serial_set_inpos
00008094 serial_putbuf
00008094 serial_getbuf
00008094 serial_set_outpos
00008098 SerialInit
000080D6 SerialGetChar
0000814E SerialPeekChar
0000818A SerialPeekCharDirect
000081A4 SerialPutChar
00008208 SerialPutCharDirect
00008224 SerialRbo
0000822C SerialRcvCount
0000824C SerialIRQ
00008260 sirqNxtByte
00008272 sirq0001
000082C2 sirqRxFull
000082C2 notRxInt
00008310 sirqTxEmpty
00008310 notTxInt
00008310 sirqXmitOff
00008310 sirq0002
00008322 nmeSerial
0000832A i2c_setup
0000832A init_i2c
0000833A i2c_wait_tip
0000834A i2c_wr_cmd
0000835A i2c_xmit1
00008378 i2c_wait_rx_nack
00008388 rtc_read
00008414 rtc_write
0000847E msgRtcReadFail
00008497 msgBusErr
000084A8 bus_err
000084C2 trap3
00008500 ProcessBreakpoint
00008506 DisarmAllBreakpoints
00008532 ArmAllBreakpoints
00008562 ArmBreakpoint
000085E0 DisarmBreakpoint
00008634 ListBreakpoints
00008654 ClearBreakpointList
00008666 SendMsg
000086A4 ReceiveMsg
000086E6 DispatchMsg
000086E8 prtflt
0000872E T15FloatToString
00008762 io_trap
0000878A OutputChar
000087C0 InitIRQ
000087D4 InstallIRQ
00008818 TickIRQ
0000885A irq6_rout
0000885A irq3_rout
0000885A irq_rout
0000886E irq_proc_generic
0000888C SpuriousIRQ
0000888E nmi_rout
000088A0 addr_err
000088B6 brdisp_trap
000088EE illegal_trap
00008904 io_irq
00008918 msg_start
0000893F msg_core_start
00008950 msgAddrErr
0000895D msg_illegal
0000896F msg_bad_branch_disp
00008981 msg_test_done
00008991 msg_io_access
000089AC msgChk
000089BA msgStackCanary
000089D4 ShiftBuf
000089EE HEX2DEC2
00008A3C HEX2DEC
00008A4C HX2DC
00008A50 HX2DC0
00008A58 HX2DC1
00008A72 HX2DC2
00008A74 HX2DC22
00008A7E HX2DC3
00008A86 HX2DC4
00008A8E HX2DC5
00008A96 HX2DC57
00008A9A HX2DC6
00008AA0 PNT4HEX
00008AA0 PNT4HX
00008AA4 PNT6HX
00008AB0 PNT8HX
00008AB4 FRELADDR
00008AC2 FREL10
00008AD4 FREL15
00008AEE FREL20
00008B00 FREL25
00008B0A FREL30
00008B12 X
00008B12 IMOVEMFR
00008B26 IM7788
00008B2A IM7799
00008B40 IMOVEMTR
00008B5A CS16
00008B5C ISTOP
00008B70 IMMED
00008B96 IMMED45
00008BC8 CS15
00008BCA IMMED55
00008BD0 IMMED65
00008BE0 IMMED75
00008BE4 IMOVE
00008BE8 ILINK
00008BFE FORM1
00008C02 FORM1A
00008C06 CS14
00008C08 FORM3
00008C0C FORM4
00008C1E FORM5
00008C22 FORM6A
00008C32 FORM6D
00008C42 FORMREGA
00008C46 FORMREG5
00008C52 FORMREGD
00008C58 FORM7
00008C64 FORM8
00008C68 FORM815
00008C70 CS13
00008C72 FORM9
00008C78 EEA10
00008C7C FORM10EX
00008C9E FORM10E3
00008CA6 FORM10E4
00008CB2 FORM10E6
00008CBA FORM10
00008CC0 FORM103
00008CC4 FORM104
00008CD4 FORM105
00008CEA CS12
00008CEE FORM11
00008CF6 FORM11SL
00008D0A FORM112
00008D18 FORM114
00008D1A FORM12
00008D34 FORM125
00008D56 FORM12A
00008D7A CS11
00008D7E IQUICK
00008D82 IMOVEQ
00008D9A SCHR
00008DA2 IMVFSR
00008DB0 IMVFUSP
00008DBE IMVTSR
00008DCC IMVT44
00008DD0 IMVTUSP
00008DDC IMVTCCR
00008DEC IMOVEP
00008DFC IMOVEP11
00008E14 CS20
00008E18 IMOVEP35
00008E26 IMOVEP66
00008E42 SCOMMON
00008E46 ISCC
00008E50 IDBCC
00008E62 ICC
00008E66 IBSR
00008E78 ICC35
00008E8E ICC55
00008E9E ISETD
00008EA4 ISETD12
00008EAC CS18
00008EAE ISETS
00008EC8 ISHIFT
00008ED4 ISHIFT13
00008EF8 ISHIFT23
00008F04 ISHIFT33
00008F08 ISHIFT44
00008F10 CS17
00008F12 ISHIFTM1
00008F2C ICCCC
00008F42 ICCCC9
00008F44 BRTBL
00008F64 IMOVEA1
00008F8A IMOVE19
00008F90 IQUICKA
00008FA2 IQUICK21
00008FB8 IQUICK31
00008FBC CS19
00008FC0 FORMSIZE
00008FD4 FORM91
00008FE8 FORM93
00008FEA FORM95
00008FEC EA000
00008FF8 EA001
00009004 EA010
00009018 EA011
0000902E EA011RTS
00009030 EA100
00009046 FE10
0000904A EEA
000090AE EA1105
000090B2 EA1107
000090C8 EA1109
000090D2 EA101
000090E8 EA111
00009106 EA1112
00009122 EA1113
0000912E FE11
00009132 EA1113A
00009154 EA1114
0000919C EAF25
000091A0 EAF27
000091B4 EAF35
000091BE EA1115
000091F6 EA11153
00009200 EA11155
0000920C MOVEMS
0000921C MOVEMS2
00009220 MOVEMR
00009230 MOVEMR11
00009238 MOVEMR33
0000924A MOVEMR44
00009264 MOVEMR77
00009276 MOVEMR79
00009278 MOVEMR88
00009290 MOVEMR94
0000929C DCODE68K
000092B0 DEC311
000092CE DEC404
000092DE DEC411
000092EC FE12
000092EE DEC425
000092FA DEC510
000092FE DEC515
00009306 DEC530
0000930C DEC535
00009318 DEC537
00009334 COMMON4
00009336 COMMON
00009344 COMMON35
0000935E FERROR
00009368 FERROR35
00009374 FERROR39
0000937E MSG111
00009388 KI
0000938A TBL
0000938A KIEND
00009642 OPCTBL
00009642 TBLE
00009742 asteroids_start
0000974A main_loop
0000979E skip_player_move
000097A2 skip_player_cont
000097A6 px_hide
000097AE no_play
000097CC no_dec_new_rocks
000097DC game_message
000097F0 do_start_mess
00009818 start_game
0000984C push_start_mess
00009862 exit_push_start
00009864 game_over
00009878 nodec_thmpi
000098A2 no_game_over
000098E0 exit_game_message
000098E2 end_game
000098F6 check_hits
000098F8 pss_check_loop
000098FE next_pss
00009904 check_pss
00009912 check_next_object
00009916 check_all
00009930 delta_x_pos
00009942 delta_y_pos
0000996A small_s_size
0000996C add_p_size
0000996E no_add_size
0000997C col_table
00009984 col_table_p
0000998C col_table_s
00009994 col_table_l
0000999C handle_collision
000099AC not_saucer
000099BA not_player
000099D2 not_pss_player
000099DE what_hit_rock
000099E2 explode_object
000099FE player_shot
00009A0A what_hit_saucer
00009A22 keep_small
00009A28 do_saucer
00009A54 attract_saucer
00009A5E rock_hit_out
00009A7C dec_isaucer_time
00009A8C no_save_ist
00009A9E saucer_yok
00009AB2 start_left
00009ADA small_saucer
00009ADC save_saucer
00009AE0 exit_do_saucer
00009AE2 existing_saucer
00009AFA keep_saucer_dir
00009B06 attract_fire
00009B0C exit_existing_saucer
00009B0E saucer_yvel
00009B12 fire_saucer
00009B2A aim_shot
00009B72 wide_shot
00009B7C no_shot_or
00009B80 no_aim_shot
00009B92 shot_mask
00009B94 shot_or
00009B96 ship_fire
00009BB4 test_fire_loop
00009BC0 save_ship_fire
00009BC4 exit_ship_fire
00009BC6 fire_shot
00009C18 calc_fire_byte
00009C2C test_neg_fire
00009C34 fire_ok
00009C3E enter_hiscores
00009C6C no_playerx
00009CD8 next_p_high
00009CF4 close_all
00009D0C next_hi_char
00009D24 save_hbutton
00009D3A not_timed_out
00009D56 not_rot_left
00009D5E not_rot_right2
00009D5E rot_not_left
00009D5E was_rot_left
00009D7E wrap_to_a
00009D82 wrap_to_z
00009D84 check_alpha
00009D8C save_char
00009D90 exit_not_done
00009D92 exit_enter_hiscores
00009D94 hyperspace
00009DD0 hype_xok1
00009DDA hype_xok2
00009DF8 hype_yok1
00009E02 hype_yok2
00009E1E save_hyperspace
00009E22 exit_hyperspace
00009E24 reset_game
00009E32 three_ship_start
00009E40 clear_items_loop
00009E4E write_initial
00009E68 add_character
00009E78 add_ships
00009E82 show_ships
00009E94 add_ships_loop
00009EA0 exit_add_ships
00009EA2 move_items
00009EA6 move_next_item
00009EC2 skip_play_inc
00009EDC no_new_rocks
00009EE4 go_reset_play
00009EEA go_reset_sauc
00009EF2 item_exploding
00009F0A no_reset_scale
00009F0C move_item
00009F1E x_pos_neg
00009F2E not_x_max
00009F44 y_not_neg
00009F4E not_y_max
00009F72 keep_scale
00009F78 move_next_object
00009F80 clear_saucer
00009F94 ship_move
00009FC2 reveal_player
00009FCA kill_the_player
00009FE0 clear_hyper
00009FE4 exit_ship_move
00009FE6 rot_and_thrust
00009FFE not_rot_left1
0000A000 DRAW
0000A006 not_rot_right1
0000A064 not_thrust
0000A09A check_velocity
0000A0A8 check_neg_velocity
0000A0B2 exit_check_velocity
0000A0B4 check_clear
0000A0B8 check_clear_loop
0000A0D2 check_clear_y
0000A0E6 not_closer
0000A0F0 is_closer
0000A0F6 make_rocks
0000A120 no_inc_min
0000A130 no_set_max
0000A13C gen_rock_loop
0000A16E rock_y_ok
0000A170 rock_on_x
0000A192 clear_rocks
0000A194 clear_rocks_loop
0000A19C exit_make_rocks
0000A19E player_init
0000A1D4 player_reset
0000A1EA copy_rock
0000A1EE copy_rock_2
0000A214 copy_velocity
0000A224 x_off_pos
0000A23E y_off_pos
0000A24A limit_velocity
0000A254 neg_upper_ok
0000A25E limit_p_vel
0000A266 pos_lower_ok
0000A26E exit_limit_velocity
0000A270 static_messages
0000A2B4 skip_play_flash
0000A2C8 do_p1_ships
0000A33C do_p2_score
0000A350 skip_p2_score
0000A35E exit_static
0000A360 add_to_list
0000A394 add_item
0000A3AE add_explode
0000A3B4 add_saucer
0000A3BA add_fire
0000A3CA no_shot_dec
0000A3CC add_score
0000A3FA exit_add_score
0000A400 high_scores
0000A432 high_scores_loop
0000A4A0 exit_high_scores
0000A4A6 exit_no_scores
0000A4AC find_rock
0000A4AE find_next_rock
0000A4B8 exit_find_rock
0000A4BA ship_wrk_x
0000A4C6 ship_wrk_y
0000A4D2 add_play_explode
0000A4E4 reset_xy_loop
0000A4FC no_reset_xy
0000A506 piece_draw_loop
0000A52C vec_x_pos
0000A538 vec_y_pos
0000A56C ship_parts
0000A578 add_player
0000A58E no_pos_reflect
0000A594 third_quad
0000A5A2 first_quad
0000A5C8 no_thrust
0000A5CA copy_short
0000A5CE copy_vectors
0000A5E8 exit_copy_vectors
0000A5EA fx_sounds
0000A5F8 no_saucer_sound
0000A62A no_thump_sound
0000A62C hit_a_rock
0000A646 clear_rock
0000A65A add_to_score
0000A662 skip_add
0000A69C exit_hit_a_rock
0000A69E rock_score
0000A6A2 check_hiscores
0000A6BE check_hi_player
0000A6C6 check_hi_loop
0000A6D4 check_hi_next
0000A6F4 save_hi_index
0000A6F8 exit_hi_chk
0000A702 exit_check_hiscores
0000A704 insert_hiscore
0000A708 insert_loop
0000A72A exit_insert_loop
0000A748 get_atn
0000A754 atn_semi
0000A764 atn_quad
0000A774 atn_eight
0000A778 loop_atn
0000A782 skip_sub
0000A792 atn_tab
0000A7D2 output_number
0000A7D4 output_number_loop
0000A7E4 zero_suppress
0000A7F0 cos_d0
0000A7F4 sin_d0
0000A802 cossin_d0
0000A808 a_was_less
0000A80E sin_cos
0000A890 add_message
0000A8D8 add_char_loop
0000A8EE add_the_char
0000A8F6 exit_add_message
0000A8F8 timer_interrupt
0000A8FE player_x
0000A902 player_n
0000A90A add_sup_hex_chr
0000A916 add_hex_chr
0000A920 add_sup_zero
0000A930 add_address
0000A946 add_coords
0000A960 add_single
0000A962 add_pair
0000A968 notscreen
0000A968 s_controls
0000A968 setscreen
0000A974 Initialise
0000A9A4 clear_loop
0000A9EA read_hi
0000A9F4 close_all_2
0000A9FA gen_prng
0000AA08 Ninc0
0000AA0E Ninc1
0000AA1C op_rtsvec
0000AA1E do_vector
0000AA2C op_call
0000AA32 op_jump
0000AA42 op_vctr
0000AA50 no_neg_y11
0000AA5C no_neg_x11
0000AA6C op_abs
0000AA7A no_neg_y10
0000AA86 no_neg_x10
0000AA98 not_right
0000AAA0 vector_base
0000AADC op_short
0000AB00 no_neg_y2
0000AB08 no_neg_x2
0000AB0C end_vector
0000AB16 shift_left
0000AB1A last_vector
0000AB3C vector_move
0000AB68 vector
0000B000 HALT
0000BB68 copy_msg
0000BBA8 expl_tab
0000BBB0 expl_3
0000BBDC expl_2
0000BC1A expl_1
0000BC50 expl_0
0000BC8E rock_tab
0000BC96 rock_0
0000BCAE rock_1
0000BCCA rock_2
0000BCE4 rock_3
0000BD00 sauc_jsr
0000BD02 sauc_vec
0000BD1E play_tab
0000BD40 play_00
0000BD58 play_01
0000BD7C play_02
0000BDA0 play_03
0000BDC4 play_04
0000BDE6 play_05
0000BE0A play_06
0000BE2E play_07
0000BE52 play_08
0000BE76 play_09
0000BE9A play_0A
0000BEBE play_0B
0000BEE2 play_0C
0000BF06 play_0D
0000BF2A play_0E
0000BF4E play_0F
0000BF72 play_10
0000BF8A play_liv
0000BFA0 char_a
0000BFB0 char_b
0000BFCA char_c
0000BFD6 char_d
0000BFE6 char_e
0000BFF6 char_f
0000C000 JSRL
0000C004 char_g
0000C016 char_h
0000C024 char_i
0000C032 char_j
0000C03E char_k
0000C04A char_l
0000C054 char_m
0000C060 char_n
0000C06A char_o0
0000C076 char_p
0000C084 char_q
0000C096 char_r
0000C0A6 char_s
0000C0B4 char_t
0000C0C0 char_u
0000C0CC char_v
0000C0D6 char_w
0000C0E4 char_x
0000C0EE char_y
0000C0FC char_z
0000C108 char_spc
0000C10C char_1
0000C114 char_2
0000C124 char_3
0000C132 char_4
0000C140 char_5
0000C14E char_6
0000C15C char_7
0000C166 char_8
0000C176 char_9
0000C184 char_set
0000C1CE shot_jsr
0000C1D0 shot_vec
0000C1E2 mess_origin
0000C202 mess_table
0000C20A e_messages
0000C21A e_mess_0
0000C226 e_mess_1
0000C22E e_mess_2
0000C250 e_mess_3
0000C26B e_mess_4
0000C288 e_mess_5
0000C2AF e_mess_6
0000C2BA e_mess_7
0000C2C4 d_messages
0000C2D4 d_mess_0
0000C2E4 d_mess_1
0000C2ED d_mess_2
0000C314 d_mess_3
0000C337 d_mess_4
0000C35A d_mess_5
0000C380 d_mess_6
0000C396 d_mess_7
0000C3A0 f_messages
0000C3B0 f_mess_0
0000C3BF f_mess_1
0000C3C6 f_mess_2
0000C3EA f_mess_3
0000C403 f_mess_4
0000C425 f_mess_5
0000C44E f_mess_6
0000C460 f_mess_7
0000C46E s_messages
0000C47E s_mess_0
0000C486 s_mess_1
0000C48F s_mess_2
0000C4B6 s_mess_3
0000C4D4 s_mess_4
0000C4FC s_mess_5
0000C50E s_mess_6
0000C51B s_mess_7
0000C52B sound_init
0000C58C load_sound
0000C592 load_old_sound
0000C598 play_sample
0000C5B4 old_sound_play
0000C5B6 exit_play_sample
0000C5B8 sound_key
0000C5D0 beat1_sound
0000C5E2 beat2_sound
0000C5F4 lexpl_sound
0000C609 mexpl_sound
0000C61E sexpl_sound
0000C633 extra_sound
0000C649 lgsau_sound
0000C65E smsau_sound
0000C673 thrst_sound
0000C686 pfire_sound
0000C698 sfire_sound
0000C6AA filename
0000C6B7 variables
0000D000 RTSL
0000E000 JMPL
0000F000 SHRT
0001001C _Keybd_tick
00040000 CursorRow
00040001 CursorCol
00040002 TextCurpos
00040002 TextPos
00040004 TextScr
00040008 S19StartAddress
0004000C KeybdEcho
0004000D KeybdWaitFlag
00040040 CmdBuf
00040080 CmdBufEnd
00040084 fgColor
00040088 bkColor
0004008C TextRows
0004008D TextCols
00040094 _fpTextIncr
00040098 _canary
0004009C tickcnt
000400A0 IRQFlag
000400A4 InputDevice
000400A8 OutputDevice
00040100 Regsave
00040202 NumSetBreakpoints
00040220 Breakpoints
00040280 BreakpointWords
000402C0 fpBuf
00040508 _width
0004050C _E
00040510 _digits_before_decpt
00040514 _precision
00040520 _fpBuf
00040600 _fpWork
00040800 _dasmbuf
00040880 OFFSET
00040890 pen_color
00040894 gr_x
00040898 gr_y
0004089C gr_width
000408A0 gr_height
000408A4 gr_bitmap_screen
000408A8 gr_raster_op
000408AC gr_double_buffer
000408B0 gr_bitmap_buffer
000408B8 sys_switches
00040A00 null_dcb
00040A40 keybd_dcb
00040A80 con_dcb
00040B40 serial_dcb
00040BFC TimerStack
00100000 IOFocus
00100004 memend
0010000E KeybdLEDs
0010000F _KeyState1
00100010 _KeyState2
00100011 _KeybdHead
00100012 _KeybdTail
00100013 _KeybdCnt
00100018 KeybdID
00100020 _KeybdBuf
00100080 _KeybdOBuf
00100150 S19Checksum
00100160 SerTailRcv
00100162 SerHeadRcv
00100164 SerRcvXon
00100165 SerRcvXoff
00100166 SerTailXmit
00100168 SerHeadXmit
0010016A SerXmitXoff
00100200 RTCBuf
00100224 RunningTCB
0010030C FreeTCB
0010031C QueueCycle
00100320 readyQ
00101000 SerRcvBuf
00102000 SerXmitBuf
20010000 tcbs

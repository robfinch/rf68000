Sections:
00: "CODE" (0-DA7D)
01: "DATA" (0-700)


Source: "boot.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022-2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;-------------------------------------------------------------------------------
                            	    37: ;
                            	    38: ; system memory map
                            	    39: ;
                            	    40: ;
                            	    41: ; 00000000 +----------------+      <+
                            	    42: ;          | startup sp,pc  | 8 B   |
                            	    43: ; 00000008 +----------------+       |
                            	    44: ;					 |    vectors     | pair shared+
                            	    45: ; 00000400 +----------------+       |
                            	    46: ;					 |   bios mem     |       |
                            	    47: ; 00001000 +----------------+       |
                            	    48: ;					 |   bios code    |       |
                            	    49: ; 00020000 +----------------+      <+
                            	    50: ;					 |    unused      |
                            	    51: ; 00040000 +----------------+
                            	    52: ;					 |   local ram    |
                            	    53: ; 00048000 +----------------+
                            	    54: ;					 |    unused      |
                            	    55: ; 00100000 +----------------+
                            	    56: ;					 |   global ram   |
                            	    57: ; 00101000 +----------------+
                            	    58: ;					 | serial rcvbuf  |
                            	    59: ; 00102000 +----------------+
                            	    60: ;          | serial xmitbuf |
                            	    61: ; 00103000 +----------------+
                            	    62: ;					 |    unused      |
                            	    63: ; 40000000 +----------------+
                            	    64: ;          |                |
                            	    65: ;          |                |
                            	    66: ;          |                |
                            	    67: ;          :  dram memory   : 1GB MB
                            	    68: ;          |                |
                            	    69: ;          |                |
                            	    70: ;          |                |
                            	    71: ; 80000000 +----------------+
                            	    72: ;          |                |
                            	    73: ;          |                |
                            	    74: ;          |                |
                            	    75: ;          :  dram memory   : 1GB MB
                            	    76: ;          |     mirror     |
                            	    77: ;          |                |
                            	    78: ;          |                |
                            	    79: ; C0000000 +----------------+
                            	    80: ;          |                |
                            	    81: ;          :     unused     :
                            	    82: ;          |                |
                            	    83: ; FD000000 +----------------+
                            	    84: ;          |                |
                            	    85: ;          :    I/O area    : 1.0 M
                            	    86: ;          |                |
                            	    87: ; FFE00000 +----------------+
                            	    88: ;          |                |
                            	    89: ;          :     unused     :
                            	    90: ;          |                |
                            	    91: ; FFFFFFFF +----------------+
                            	    92: ;
                            	    93: ;-------------------------------------------------------------------------------
                            	    94: ;
                            	    95: HAS_MMU equ 0
                            	    96: NCORES equ 4
                            	    97: TEXTCOL equ 48
                            	    98: TEXTROW	equ	32
                            	    99: VIDEO_X equ 800
                            	   100: VIDEO_Y equ 600
                            	   101: 
                            	   102: CTRLC	EQU		$03
                            	   103: CTRLH	EQU		$08
                            	   104: CTRLS	EQU		$13
                            	   105: CTRLX	EQU		$18
                            	   106: CTRLZ	EQU		$1A
                            	   107: LF		EQU		$0A
                            	   108: CR		EQU		$0D
                            	   109: XON		EQU		$11
                            	   110: XOFF	EQU		$13
                            	   111: EOT		EQU		$04
                            	   112: BLANK EQU		$20
                            	   113: 
                            	   114: SC_F12  EQU    $07
                            	   115: SC_C    EQU    $21
                            	   116: SC_T    EQU    $2C
                            	   117: SC_Z    EQU    $1A
                            	   118: SC_KEYUP	EQU		$F0
                            	   119: SC_EXTEND   EQU		$E0
                            	   120: SC_CTRL		EQU		$14
                            	   121: SC_RSHIFT	EQU		$59
                            	   122: SC_NUMLOCK	EQU		$77
                            	   123: SC_SCROLLLOCK	EQU	$7E
                            	   124: SC_CAPSLOCK		EQU	$58
                            	   125: SC_ALT		EQU		$11
                            	   126: SC_LSHIFT	EQU		$12
                            	   127: SC_DEL		EQU		$71		; extend
                            	   128: SC_LCTRL	EQU		$58
                            	   129: SC_TAB      EQU		$0D
                            	   130: 
                            	   131: 	include "..\Femtiki\device.x68"

Source: "..\Femtiki\device.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: DEV_INIT equ 0
                            	    38: DEV_STAT equ 1
                            	    39: DEV_PUTCHAR equ 2
                            	    40: DEV_PUTBUF equ 3
                            	    41: DEV_GETCHAR equ 4
                            	    42: DEV_GETBUF equ 5
                            	    43: DEV_SET_INPOS equ 6
                            	    44: DEV_SET_OUTPOS equ 7
                            	    45: DEV_GETCHAR_DIRECT equ 8
                            	    46: DEV_PEEKCHAR equ 9
                            	    47: DEV_PEEKCHAR_DIRECT equ 10
                            	    48: DEV_PUTCHAR_DIRECT equ 11
                            	    49: DEV_CLEAR equ 12
                            	    50: DEV_SWAPBUF equ 13
                            	    51: DEV_SETBUF1 equ 14
                            	    52: DEV_SETBUF2 equ 15
                            	    53: DEV_GETBUF1 equ 16
                            	    54: DEV_GETBUF2 equ 17
                            	    55: DEV_WRITEAT equ 18
                            	    56: DEV_SETUNIT equ 19
                            	    57: DEV_GET_DIMEN equ 20
                            	    58: DEV_GET_COLOR equ 21
                            	    59: DEV_GET_INPOS equ 22
                            	    60: DEV_GET_OUTPOS equ 23
                            	    61: DEV_GET_OUTPTR equ 24
                            	    62: DEV_SET_COLOR equ 25
                            	    63: DEV_SET_COLOR123 equ 26
                            	    64: DEV_PLOT_POINT equ 27
                            	    65: DEV_DRAW_LINE equ 28
                            	    66: DEV_DRAW_TRIANGLE equ 29
                            	    67: DEV_DRAW_RECTANGLE equ 30
                            	    68: DEV_DRAW_CURVE equ 31
                            	    69: DEV_SET_DIMEN equ 32
                            	    70: DEV_SET_COLOR_DEPTH equ 33
                            	    71: DEV_SET_DESTBUF equ 34
                            	    72: DEV_SET_DISPBUF equ 35
                            	    73: 
                            	    74: 
                            	    75: DCB_MAGIC equ	0			; 'DCB'
                            	    76: DCB_NAME	equ 4			; 15 chars+NULL
                            	    77: DCB_CMDPROC	equ 24	; 8 byte pointer to command processor
                            	    78: DCB_OUTPOSX equ 32
                            	    79: DCB_OUTPOSY equ 36
                            	    80: DCB_OUTPOSZ equ 40
                            	    81: DCB_INPOSX equ 44
                            	    82: DCB_INPOSY equ 48
                            	    83: DCB_INPOSZ equ 52
                            	    84: DCB_INBUFPTR equ 56
                            	    85: DCB_OUTBUFPTR equ 60
                            	    86: DCB_INBUFSIZE equ 64
                            	    87: DCB_OUTBUFSIZE equ 68
                            	    88: DCB_INDIMX equ 72
                            	    89: DCB_INDIMY equ 76
                            	    90: DCB_INDIMZ equ 80
                            	    91: DCB_OUTDIMX equ 84
                            	    92: DCB_OUTDIMY equ 88
                            	    93: DCB_OUTDIMZ equ 92
                            	    94: DCB_BKCOLOR equ 96
                            	    95: DCB_FGCOLOR equ 100
                            	    96: DCB_OPCODE equ 104
                            	    97: DCB_LASTERC equ 108
                            	    98: DCB_INBUFPTR2 equ 112
                            	    99: DCB_OUTBUFPTR2 equ 116
                            	   100: DCB_INBUFSIZE2 equ 120
                            	   101: DCB_OUTBUFSIZE2 equ 124
                            	   102: DCB_UNIT equ 128
                            	   103: DCB_SIZE equ 132
                            	   104: 
                            	   105: ;Standard Devices are:
                            	   106: 
                            	   107: ;#		Device					Standard name
                            	   108: 
                            	   109: ;0		NULL device 			NUL		(OS built-in)
                            	   110: ;1		Keyboard (sequential)	KBD		(OS built-in, ReadOnly)
                            	   111: ;2		Video (sequential)		VID		(OS built-in, WriteOnly)
                            	   112: ;3		Printer (parallel 1)	LPT		(OS built-in)
                            	   113: ;4		Printer (parallel 2)	LPT2	(OS built-in)
                            	   114: ;5		RS-232 1				COM1	(OS built-in)
                            	   115: ;6		RS-232 2				COM2	(OS built-in)
                            	   116: ;7		RS-232 3				COM3	(OS built-in)
                            	   117: ;8		RS-232 4				COM4	(OS built-in)
                            	   118: ;9
                            	   119: ;10		Floppy					FD0 	(OS built-in)
                            	   120: ;11		Floppy					FD1 	(OS built-in)
                            	   121: ;12		Hard disk				HD0 	(OS built-in)
                            	   122: ;13		Hard disk				HD1 	(OS built-in)
                            	   123: ;14
                            	   124: ;15
                            	   125: ;16
                            	   126: ;17
                            	   127: ;18
                            	   128: ;19
                            	   129: ;20
                            	   130: ;21
                            	   131: ;22
                            	   132: ;23
                            	   133: 

Source: "boot.x68"
                            	   132: 	include "..\Femtiki\FemtikiTop.x68"

Source: "..\Femtiki\FemtikiTop.x68"
                            	     1: 	include "..\Femtiki\const.x68"

Source: "..\Femtiki\const.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: TS_NONE			EQU		0
                            	    38: TS_READY		EQU		1
                            	    39: TS_DEAD			EQU		2
                            	    40: TS_MSGRDY		EQU		4
                            	    41: TS_WAITMSG	EQU		8
                            	    42: TS_TIMEOUT	EQU		16
                            	    43: TS_PREEMPT	EQU		32
                            	    44: TS_RUNNING	EQU		128
                            	    45: 
                            	    46: ; error codes
                            	    47: E_Ok		EQU		$00
                            	    48: E_Arg		EQU		$01
                            	    49: E_Func  EQU    $02
                            	    50: E_BadMbx	EQU		$04
                            	    51: E_QueFull	EQU		$05
                            	    52: E_NoThread	EQU		$06
                            	    53: E_NotAlloc	EQU		$09
                            	    54: E_NotSupported EQU $0A
                            	    55: E_NoMsg		EQU		$0b
                            	    56: E_Timeout	EQU		$10
                            	    57: E_BadAlarm	EQU		$11
                            	    58: E_NotOwner	EQU		$12
                            	    59: E_QueStrategy EQU		$13
                            	    60: E_DCBInUse	EQU		$19
                            	    61: ; Device driver errors
                            	    62: E_BadDevNum	EQU		$20
                            	    63: E_NoDev		EQU		$21
                            	    64: E_BadDevOp	EQU		$22
                            	    65: E_ReadError	EQU		$23
                            	    66: E_WriteError EQU		$24
                            	    67: E_BadBlockNum	EQU	$25
                            	    68: E_TooManyBlocks	EQU	$26
                            	    69: 
                            	    70: ; resource errors
                            	    71: E_NoMoreMbx	EQU		$40
                            	    72: E_NoMoreMsgBlks	EQU	$41
                            	    73: E_NoMoreAlarmBlks	EQU $44
                            	    74: E_NoMoreTCBs	EQU	$45
                            	    75: E_NoMem		EQU 12
                            	    76: 
                            	    77: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     2: 	include "..\Femtiki\config.x68"

Source: "..\Femtiki\config.x68"
                            	     1: MAX_TID		EQU		4095
                            	     2: NR_TCB		EQU		4096
                            	     3: NTASK     EQU   4096    ; number of threads allowed
                            	     4: LOG_TCBSZ	EQU		8
                            	     5: LOG_PGSZ	EQU		10
                            	     6: LOG_ACBSZ EQU   12
                            	     7: OSPAGES		EQU		16			; pages of memory dedicated to OS
                            	     8: PAGESZ    EQU   16384  	; size of a page of memory
                            	     9: MEMSZ     EQU   32768   ; pages
                            	    10: MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                            	    11: NR_MSG		EQU		21842		; number of messages available
                            	    12: NR_MBX		EQU		9792
                            	    13: 
                            	    14: 
                            	    15: 
                            	    16: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     3: 	include "..\Femtiki\types.x68"

Source: "..\Femtiki\types.x68"
                            	     1: ; Thread Control Block
                            	     2: TCBMagic    EQU		$0000
                            	     3: TCBRegs  		EQU   $0004		; register set storage area
                            	     4: TCBUSP			EQU		$0044
                            	     5: TCBSSP			EQU		$0048
                            	     6: TCBSR				EQU		$004C
                            	     7: TCBPC				EQU		$0050
                            	     8: TCBStatus		EQU		$0054
                            	     9: TCBPriority	EQU		$0055
                            	    10: TCBWaitMbx	EQU		$0056
                            	    11: TCBHasFocus EQU   $005A
                            	    12: TCBStackBot	EQU		$005C
                            	    13: TCBMsgD1		EQU		$0060
                            	    14: TCBMsgD2		EQU		$0064
                            	    15: TCBMsgD3		EQU		$0068
                            	    16: TCBStartTick	EQU	$006C
                            	    17: TCBEndTick	EQU		$0070
                            	    18: TCBTicks		EQU		$0074
                            	    19: TCBException	EQU	$0078
                            	    20: TCBNext			EQU		$007C
                            	    21: TCBPrev			EQU		$0080
                            	    22: TCBAffinityBase	EQU	$0082
                            	    23: TCBAffinity	EQU		$0084
                            	    24: TCBTimeout	EQU		$0088
                            	    25: TCBtid      EQU   $008C
                            	    26: TCBmid      EQU   $0090
                            	    27: TCBappid    EQU   $0094
                            	    28: TCBOpMode   EQU   $0098
                            	    29: TCBMbxNext  EQU   $009C
                            	    30: TCBMbxPrev  EQU   $00A0
                            	    31: TCBThreadNum  EQU   $00A4
                            	    32: TCBAcbNext	EQU		$00A8
                            	    33: TCBAcbPrev	EQU		$00AC
                            	    34: TCBhMailboxes	EQU		$00B0
                            	    35: TCBName			EQU		$00C0
                            	    36: TCB_SIZE		EQU		$0100
                            	    37: 
                            	    38: MBX_MAGIC		equ		0
                            	    39: MBX_OWNER		equ		4		; tid of owning task
                            	    40: MBX_LINK    equ   8
                            	    41: MBX_TQHEAD  equ   12   ; link field for free list shared with task queue head
                            	    42: MBX_TQTAIL  equ   16
                            	    43: MBX_MQHEAD	equ		20
                            	    44: MBX_MQTAIL	equ		24
                            	    45: MBX_SIZE		equ		32
                            	    46: 
                            	    47: MSG_MAGIC   equ   0
                            	    48: MSG_LINK	  equ		4
                            	    49: MSG_RETADR  equ   8
                            	    50: MSG_TGTADR  equ   12
                            	    51: MSG_TYPE    equ   16
                            	    52: MSG_D1		  equ		20
                            	    53: MSG_D2		  equ		24
                            	    54: MSG_D3		  equ		28
                            	    55: MSG_SIZE	  equ		32
                            	    56: 
                            	    57: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     4: 
                            	     5: 	include "..\Femtiki\source\kernel\Femtiki_vars.x68"

Source: "..\Femtiki\source\kernel\Femtiki_vars.x68"
                            	     1: 
                            	     2: PAMShareCounts	EQU	$20000000	; one byte for each physical page of memory
                            	     3: tcbs						EQU	$20010000	; 4095*256 = 1MB
                            	     4: tcbs_end				EQU	$20020000
                            	     5: messages				EQU	$20020000	; 32*8192 (680*16=21760 messages)
                            	     6: messages_end		EQU	$20060000
                            	     7: mailboxes				EQU	$20060000
                            	     8: mailboxes_end		EQU	$20078000	;	12*8192 (816*12=9792 mailboxes)
                            	     9: acbs						EQU	$20080000	; 32*2*8192 =512kB
                            	    10: acbs_end				EQU	$20100000
                            	    11: 
                            	    12: 
                            	    13: sys_stacks			EQU	$DF0000
                            	    14: 
                            	    15: FemtikiVars			EQU	$00100200
                            	    16: PAMLastAllocate2	EQU		$00100218
                            	    17: RunningAID		EQU		$00100220
                            	    18: RunningTCB			EQU		$00100224
                            	    19: ACBPtrs				EQU		$00100228
                            	    20: MidStackBottoms	EQU		$00100264
                            	    21: FemtikiInited	EQU		$00100284
                            	    22: missed_ticks	EQU		$00100288
                            	    23: IOFocusList		EQU		$0010028C
                            	    24: IOFocusID			EQU		$001002AC
                            	    25: iof_switch		EQU		$001002AD
                            	    26: nMessage			EQU		$001002AE
                            	    27: nMailbox			EQU		$001002B0
                            	    28: hKeybdMbx			EQU		$001002BA
                            	    29: hFocusSwitchMbx		EQU		$001002BC
                            	    30: BIOS_RespMbx	EQU		$001002BE
                            	    31: hasUltraHighPriorityTasks	EQU		$001002C0
                            	    32: im_save				EQU		$001002C2
                            	    33: sp_tmp				EQU		$001002C4
                            	    34: startQNdx			EQU		$001002C6
                            	    35: NPAGES				EQU		$001002D8
                            	    36: syspages			EQU		$001002DA
                            	    37: mmu_FreeMaps	EQU		$001002E0
                            	    38: mmu_entries		EQU		$00100300
                            	    39: freelist			EQU		$00100302
                            	    40: hSearchMap		EQU		$00100304
                            	    41: OSActive			EQU		$00100305
                            	    42: FreeACB				EQU		$00100308
                            	    43: FreeTCB				EQU		$0010030C
                            	    44: FreeMSG				EQU		$00100310
                            	    45: FreeMBX				EQU		$00100314
                            	    46: TimeoutList		EQU		$00100318
                            	    47: QueueCycle    EQU   $0010031C
                            	    48: readyQ				EQU		$00100320		; 32 bytes per queue per core, 2 cores for now
                            	    49: readyQEnd			EQU		$00100360
                            	    50: FemtikiVars_end	EQU	$00100400
                            	    51: 
                            	    52: ;gc_stack		rmb		512
                            	    53: ;gc_pc				fcdw		0
                            	    54: ;gc_omapno		fcw			0
                            	    55: ;gc_mapno		fcw			0
                            	    56: ;gc_dl				fcw			0
                            	    57: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     6: 	code
                            	     7: 	even
                            	     8: 	include "..\Femtiki\source\kernel\tcb.x68"

Source: "..\Femtiki\source\kernel\tcb.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;------------------------------------------------------------------------------
                            	    38: ; Initialize variables related to TCBs.
                            	    39: ;------------------------------------------------------------------------------
                            	    40: 
                            	    41: TCBInit:
00:00000000 41F920010000    	    42: 	lea tcbs,a0
00:00000006 4E7B8013        	    43: 	movec a0,tcba
00:0000000A 700F            	    44: 	moveq #2*8-1,d0		; 2 cores, 32 bytes (8 lwords) per queue
00:0000000C 72FF            	    45: 	moveq #-1,d1			; value to set
00:0000000E 41F900100320    	    46: 	lea readyQ,a0			; clear out ready queue
                            	    47: .0001
00:00000014 20C1            	    48: 	move.l d1,(a0)+
00:00000016 51C8FFFC        	    49: 	dbra d0,.0001
00:0000001A 203C0003FFFF    	    50: 	move.l #TCB_SIZE*NR_TCB/4-1,d0
                            	    51: .clearTCBs
00:00000020 4298            	    52: 	clr.l (a0)+
00:00000022 51C8FFFC        	    53: 	dbra d0,.clearTCBs
00:00000026 4E75            	    54: 	rts
                            	    55: 
                            	    56: ;------------------------------------------------------------------------------
                            	    57: ; Convert a TCB handle into a pointer.
                            	    58: ;
                            	    59: ; Parameters:
                            	    60: ;		d0 = TCB handle
                            	    61: ; Returns:
                            	    62: ;		a0 = pointer to TCB
                            	    63: ;------------------------------------------------------------------------------
                            	    64: 
                            	    65: TCBHandleToPointer:
00:00000028 2F01            	    66: 	move.l d1,-(a7)
00:0000002A 028000000FFF    	    67: 	andi.l #MAX_TID,d0		; limit to # threads
00:00000030 4E7A1013        	    68: 	movec tcba,d1
00:00000034 E188            	    69: 	lsl.l #8,d0
00:00000036 D280            	    70: 	add.l d0,d1
00:00000038 2041            	    71: 	move.l d1,a0
00:0000003A E088            	    72: 	lsr.l #8,d0						; restore d0
00:0000003C 221F            	    73: 	move.l (a7)+,d1
00:0000003E 4E75            	    74: 	rts
                            	    75: 
                            	    76: ;------------------------------------------------------------------------------
                            	    77: ; Convert a TCB pointer into a handle.
                            	    78: ;
                            	    79: ; Parameters:
                            	    80: ;		a0 = TCB pointer
                            	    81: ; Returns:
                            	    82: ;		d0 = TCB handle
                            	    83: ;------------------------------------------------------------------------------
                            	    84: 
                            	    85: TCBPointerToHandle:
00:00000040 2F01            	    86: 	move.l d1,-(a7)				; save d1
00:00000042 4E7A1013        	    87: 	movec tcba,d1
00:00000046 91C1            	    88: 	sub.l d1,a0
00:00000048 2008            	    89: 	move.l a0,d0
00:0000004A E088            	    90: 	lsr.l #8,d0
00:0000004C 221F            	    91: 	move.l (a7)+,d1				; restore d1
00:0000004E 4E75            	    92: 	rts
                            	    93: 
                            	    94: ;------------------------------------------------------------------------------
                            	    95: ; Internal TCB allocation function.
                            	    96: ;
                            	    97: ; Parameters:
                            	    98: ;		none
                            	    99: ; Returns:
                            	   100: ;		d0 = handle for allocated TCB, NULL if none available
                            	   101: ;------------------------------------------------------------------------------
                            	   102: 
                            	   103: TCBIAlloc:
00:00000050 30390010030C    	   104: 	move.w FreeTCB,d0				; d1 = Free handle
00:00000056 6714            	   105: 	beq .0001
00:00000058 2F08            	   106: 	move.l a0,-(sp)
00:0000005A 61CC            	   107: 	bsr TCBHandleToPointer	; convert to pointer
00:0000005C 3228007C        	   108: 	move.w TCBNext(a0),d1		; d1 = next on free list
00:00000060 33C10010030C    	   109: 	move.w d1,FreeTCB				; update head of free list
00:00000066 61D8            	   110: 	bsr TCBPointerToHandle	; convert pointer to handle
00:00000068 205F            	   111: 	move.l (sp)+,a0
00:0000006A 4E75            	   112: 	rts
                            	   113: 	; Here there was no free TCB available. Return a NULL
                            	   114: .0001
00:0000006C 4E75            	   115: 	rts
                            	   116: 	
                            	   117: ;------------------------------------------------------------------------------
                            	   118: ; TCB allocation function. Locks the system semaphore during allocation.
                            	   119: ;
                            	   120: ; Parameters:
                            	   121: ;		none
                            	   122: ; Returns:
                            	   123: ;		d0 = handle for allocated TCB, NULL if none available
                            	   124: ;		d1 = E_Ok
                            	   125: ;------------------------------------------------------------------------------
                            	   126: 
                            	   127: TCBAlloc:
00:0000006E 61000326        	   128: 	bsr LockSysSemaphore
00:00000072 61DC            	   129: 	bsr	TCBIAlloc
00:00000074 61000330        	   130: 	bsr UnlockSysSemaphore
00:00000078 7200            	   131: 	moveq #E_Ok,d1
00:0000007A 4E75            	   132: 	rts
                            	   133: 	
                            	   134: ;------------------------------------------------------------------------------
                            	   135: ; Internal TCB free function.
                            	   136: ;
                            	   137: ; Modifies:
                            	   138: ;		none
                            	   139: ; Parameters:
                            	   140: ;		d0 = handle to TCB
                            	   141: ; Returns:
                            	   142: ;		d0 = handle to TCB
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: TCBIFree:
00:0000007C 2F08            	   146: 	move.l a0,-(sp)
00:0000007E 61A8            	   147: 	bsr TCBHandleToPointer
00:00000080 31790010030C007C	   148: 	move.w FreeTCB,TCBNext(a0)
00:00000088 33C00010030C    	   149: 	move.w d0,FreeTCB
00:0000008E 205F            	   150: 	move.l (sp)+,a0
00:00000090 4E75            	   151: 	rts
                            	   152: 
                            	   153: ;------------------------------------------------------------------------------
                            	   154: ; TCB free function. Locks the system sempaphore while freeing.
                            	   155: ;
                            	   156: ; Modifies:
                            	   157: ;		none
                            	   158: ; Parameters:
                            	   159: ;		d0 = handle to TCB
                            	   160: ; Returns:
                            	   161: ;		d0 = handle to TCB
                            	   162: ;		d1 = E_Ok
                            	   163: ;------------------------------------------------------------------------------
                            	   164: 
                            	   165: TCBFree:
00:00000092 61000302        	   166: 	bsr LockSysSemaphore
00:00000096 61E4            	   167: 	bsr TCBIFree
00:00000098 6100030C        	   168: 	bsr UnlockSysSemaphore
00:0000009C 7200            	   169: 	moveq #E_Ok,d1
00:0000009E 4E75            	   170: 	rts
                            	   171: 
                            	   172: ;------------------------------------------------------------------------------
                            	   173: ; Given an affinity, chose the core number to run on.
                            	   174: ;
                            	   175: ; Parameters:
                            	   176: ;		a0 = pointer to TCB
                            	   177: ;	Returns:
                            	   178: ;		d0 = core number to run on
                            	   179: ;------------------------------------------------------------------------------
                            	   180: 
                            	   181: TCBAffineChose:
00:000000A0 48E75000        	   182: 	movem.l d1/d3,-(sp)
00:000000A4 363C001F        	   183: 	move.w #31,d3										; limit number of bit selects to 32
00:000000A8 12280082        	   184: 	move.b TCBAffinityBase(a0),d1		; d1 = starting bit
00:000000AC 20280084        	   185: 	move.l TCBAffinity(a0),d0				; d0 = affinity mask
                            	   186: .0002
00:000000B0 0300            	   187: 	btst.l d1,d0										; is bit d1 set?
00:000000B2 6610            	   188: 	bne .0001												; if set, exit loop
00:000000B4 5241            	   189: 	addq #1,d1
00:000000B6 51CBFFF8        	   190: 	dbra d3,.0002
                            	   191: 	; no bits set? How?
00:000000BA 117C00020082    	   192: 	move.b #2,TCBAffinityBase(a0)
00:000000C0 7000            	   193: 	moveq #0,d0											; just return core #2 (0)
00:000000C2 4E75            	   194: 	rts
                            	   195: .0001
00:000000C4 1001            	   196: 	move.b d1,d0
00:000000C6 5500            	   197: 	subi.b #2,d0										; cores start at #2
00:000000C8 4880            	   198: 	ext.w d0
00:000000CA 48C0            	   199: 	ext.l d0
00:000000CC 5241            	   200: 	addq #1,d1											; increment bit selection for next time
00:000000CE 11410082        	   201: 	move.b d1,TCBAffinityBase(a0)		; and store in TCB
00:000000D2 4CDF000A        	   202: 	movem.l (sp)+,d1/d3
00:000000D6 4E75            	   203: 	rts
                            	   204: 
                            	   205: ;------------------------------------------------------------------------------
                            	   206: ; Insert thread into ready queue. The thread is added at the tail of the 
                            	   207: ; queue. The queue is a doubly linked list.
                            	   208: ;
                            	   209: ; Stack Space:
                            	   210: ;		8 lwords
                            	   211: ; Modifies:
                            	   212: ;		none
                            	   213: ; Parameters:
                            	   214: ;		d0 = thread id to insert
                            	   215: ; Returns:
                            	   216: ;		d0 = TCB handle
                            	   217: ; ----------------------------------------------------------------------------
                            	   218: 
                            	   219: TCBInsertIntoReadyQueue:
00:000000D8 48E770F0        	   220: 	movem.l d1-d3/a0-a3,-(sp)
00:000000DC 2400            	   221: 	move.l d0,d2											; d2 = thread to insert
00:000000DE 6100FF48        	   222: 	bsr TCBHandleToPointer
00:000000E2 2648            	   223: 	move.l a0,a3											; a3 = TCB pointer of thread to insert
00:000000E4 610002B0        	   224: 	bsr LockSysSemaphore
00:000000E8 002800800054    	   225: 	ori.b #TS_RUNNING,TCBStatus(a0)
00:000000EE 61B0            	   226: 	bsr TCBAffineChose								; Chose which cores queue to use
00:000000F0 EB88            	   227: 	lsl.l #5,d0												; 32 bytes per readyQ head/tail per core
00:000000F2 7200            	   228: 	clr.l d1
00:000000F4 12280055        	   229: 	move.b TCBPriority(a0),d1					; d1 = priority
00:000000F8 028100000007    	   230: 	andi.l #7,d1
00:000000FE E589            	   231: 	lsl.l #2,d1												; 4 bytes per priority level
00:00000100 D280            	   232: 	add.l d0,d1												; add in base queue
00:00000102 D2BC00100320    	   233: 	add.l #readyQ,d1									; add in start of ready queues
00:00000108 2241            	   234: 	move.l d1,a1
00:0000010A 30290004        	   235: 	move.w 4(a1),d0										; d0 = tail entry
00:0000010E 3600            	   236: 	move.w d0,d3											; d3 = tail entry
00:00000110 4A40            	   237: 	tst.w d0
00:00000112 6D20            	   238: 	blt .qempty
00:00000114 6100FF12        	   239: 	bsr TCBHandleToPointer						; a0 = pointer to tail
00:00000118 2448            	   240: 	move.l a0,a2
00:0000011A 2038007C        	   241: 	move.l TCBNext,d0
00:0000011E 6100FF08        	   242: 	bsr TCBHandleToPointer						; a0 = tail->next
00:00000122 21420080        	   243: 	move.l d2,TCBPrev(a0)							; tail->next->prev = new entry
00:00000126 2542007C        	   244: 	move.l d2,TCBNext(a2)							; tail->next = new entry
00:0000012A 2740007C        	   245: 	move.l d0,TCBNext(a3)							; new entry->next = tail->next
00:0000012E 27430080        	   246: 	move.l d3,TCBPrev(a3)							; new entry->prev = tail
00:00000132 6012            	   247: 	bra .0002
                            	   248: .qempty
00:00000134 4A51            	   249: 	tst.w (a1)												; check if there is a list head
00:00000136 6C0E            	   250: 	bge .0002													; head with no tail -> list corrupt
00:00000138 33420004        	   251: 	move.w d2,4(a1)										; head and tail equal new entry
00:0000013C 3282            	   252: 	move.w d2,(a1)
00:0000013E 3742007C        	   253: 	move.w d2,TCBNext(a3)							; next and prev of new entry point to self
00:00000142 37420080        	   254: 	move.w d2,TCBPrev(a3)
                            	   255: 	; Head but no tail, list corrupt?
                            	   256: .0002
00:00000146 6100025E        	   257: 	bsr UnlockSysSemaphore
00:0000014A 4CDF0F0E        	   258: 	movem.l (sp)+,d1-d3/a0-a3
00:0000014E 4E75            	   259: 	rts
                            	   260: 
                            	   261: ;------------------------------------------------------------------------------
                            	   262: ; Remove a thread from the ready queue. Actual removal is not done here, it
                            	   263: ; is done the next time the thread is selected to run. Just mark the thread as
                            	   264: ; not running.
                            	   265: ;
                            	   266: ; Parameters:
                            	   267: ;		d0 = thread id to remove
                            	   268: ; Returns:
                            	   269: ;		none
                            	   270: ; -----------------------------------------------------------------------------
                            	   271: 
                            	   272: TCBRemoveFromReadyQueue:
00:00000150 4A40            	   273: 	cmpi.w #0,d0
00:00000152 6D1C            	   274: 	blt .0001
00:00000154 028000000FFF    	   275: 	andi.l #MAX_TID,d0									; limit to # of threads
00:0000015A 2F08            	   276: 	move.l a0,-(sp)
00:0000015C 6100FECA        	   277: 	bsr	TCBHandleToPointer
00:00000160 61000234        	   278: 	bsr LockSysSemaphore
00:00000164 0228007F0054    	   279: 	andi.b #TS_RUNNING^$FF,TCBStatus(a0)
00:0000016A 6100023A        	   280: 	bsr UnlockSysSemaphore
00:0000016E 205F            	   281: 	move.l (sp)+,a0
                            	   282: .0001
00:00000170 4E75            	   283: 	rts
                            	   284: 	
                            	   285: ; ----------------------------------------------------------------------------
                            	   286: ; Register Usage
                            	   287: ;		d0 = temporary
                            	   288: ;		d1 = index into list of queues
                            	   289: ;		d2 = index to queue set
                            	   290: ;		d4 = queue counter, goes from 7 down to 0
                            	   291: ;		d5 = temporary
                            	   292: ;		d6 = next on list
                            	   293: ;		a0 = temporary pointer to TCB
                            	   294: ;		a1 = pointer to queue
                            	   295: ;		a2 = pointer to old head of list
                            	   296: ;		a3 = pointer to TCB at head of queue
                            	   297: ; Modifies:
                            	   298: ;		none
                            	   299: ; Parameters:
                            	   300: ;		none
                            	   301: ; Returns:
                            	   302: ;		a0 = pointer to TCB, NULL if none on list
                            	   303: ;		d0 = TCB handle
                            	   304: ; ----------------------------------------------------------------------------
                            	   305: 
                            	   306: StartQ
00:00000172 01              	   307: 	dc.b 1,2,3,4,1,5,6,7
00:00000173 02
00:00000174 03
00:00000175 04
00:00000176 01
00:00000177 05
00:00000178 06
00:00000179 07
                            	   308: 
                            	   309: 	even
                            	   310: TCBPopReadyQueue:
00:0000017A 48E77E70        	   311: 	movem.l	d1-d6/a1-a3,-(a7)
00:0000017E 4E7A2FE0        	   312: 	movec coreno,d2					; select the queue set based on the core number
00:00000182 5502            	   313: 	subi.b #2,d2						; cores start at #2
00:00000184 EB8A            	   314: 	lsl.l #5,d2							; d2 = index to queue set, 32 bytes per queue set
00:00000186 7807            	   315: 	moveq #7,d4							; d4 = queue count
00:00000188 6100020C        	   316: 	bsr LockSysSemaphore
                            	   317: 	; One in four tries pick a different priority to start searching from. 
00:0000018C 12390010031C    	   318: 	move.b QueueCycle,d1		; increment Queue cycle counter
00:00000192 5201            	   319: 	addi.b #1,d1
00:00000194 02010007        	   320: 	andi.b #7,d1
00:00000198 13C10010031C    	   321: 	move.b d1,QueueCycle
00:0000019E 6612            	   322: 	bne	.0001
00:000001A0 43FAFFD0        	   323: 	lea StartQ,a1
00:000001A4 4881            	   324: 	ext.w d1
00:000001A6 12311000        	   325: 	move.b (a1,d1.w),d1
00:000001AA 02410007        	   326: 	andi.w #7,d1						; limit to number of queues
00:000001AE E549            	   327: 	lsl.w #2,d1							; make into lword index
00:000001B0 6002            	   328: 	bra .0002
                            	   329: .0001
00:000001B2 7200            	   330: 	moveq #0,d1							; start at Queue #0
                            	   331: .0002
00:000001B4 43F900100320    	   332: 	lea readyQ,a1						; a1 = pointer to list of ready queues
00:000001BA D3C2            	   333: 	add.l d2,a1							; a1 = pointer to queue set
00:000001BC 36311000        	   334: 	move.w (a1,d1.w),d3			; d3 = old head of list
00:000001C0 6D4E            	   335: 	blt .nextQ							; anything on list?, if not go next queue
00:000001C2 3003            	   336: 	move.w d3,d0						; d0 = old head of list
00:000001C4 6100FE62        	   337: 	bsr TCBHandleToPointer
00:000001C8 2448            	   338: 	move.l a0,a2						; a2 = pointer to old head of list
00:000001CA 3A2A007C        	   339: 	move.w TCBNext(a2),d5		; remove head of list from list
00:000001CE BA80            	   340: 	cmp.l d0,d5							; removing last TCB?
00:000001D0 6736            	   341: 	beq .removeLast
00:000001D2 3C05            	   342: 	move.w d5,d6						; d6 = next on list
00:000001D4 3005            	   343: 	move.w d5,d0						; d0 = next on list
00:000001D6 6100FE50        	   344: 	bsr TCBHandleToPointer	; a0 = pointer to next TCB on list
00:000001DA 3A2A0080        	   345: 	move.w TCBPrev(a2),d5		; d5 = previous TCB from head
00:000001DE 31450080        	   346: 	move.w d5,TCBPrev(a0)		; next->prev = head->prev
00:000001E2 3005            	   347: 	move.w d5,d0
00:000001E4 6100FE42        	   348: 	bsr TCBHandleToPointer	; a0 = pointer to previous TCB from head
00:000001E8 3146007C        	   349: 	move.w d6,TCBNext(a0)		; head->prev->next = next
                            	   350: .0003
00:000001EC 33861000        	   351: 	move.w d6,(a1,d1.w)			; reset head of list to next
00:000001F0 3543007C        	   352: 	move.w d3,TCBNext(a2)		; point links back to self
00:000001F4 35430080        	   353: 	move.w d3,TCBPrev(a2)
00:000001F8 3003            	   354: 	move.w d3,d0						; return handle in d0
00:000001FA 48C0            	   355: 	ext.l d0
00:000001FC 204A            	   356: 	move.l a2,a0						; return pointer in a0
                            	   357: .0004
00:000001FE 610001A6        	   358: 	bsr UnlockSysSemaphore
00:00000202 4CDF0E7E        	   359: 	movem.l	(a7)+,d1-d6/a1-a3
00:00000206 4E75            	   360: 	rts
                            	   361: .removeLast
00:00000208 7CFF            	   362: 	moveq #-1,d6						; set head to negative when removing last
00:0000020A 33861002        	   363: 	move.w d6,2(a1,d1.w)		; tail = negative
00:0000020E 60DC            	   364: 	bra .0003
                            	   365: .nextQ
00:00000210 5841            	   366: 	addi.w #4,d1						; increment queue number by lword
00:00000212 0241001C        	   367: 	andi.w #$1C,d1					; limit to number of queues
00:00000216 51CCFF9C        	   368: 	dbra d4,.0002						; go back and check the next queue
00:0000021A 70FF            	   369: 	moveq #-1,d0						; return handle < 0 if nothing in any queue
00:0000021C 91C8            	   370: 	suba.l a0,a0						; and NULL pointer
00:0000021E 60DE            	   371: 	bra	.0004								; return NULL pointer if nothing in any queue
                            	   372: 
                            	   373: ;------------------------------------------------------------------------------
                            	   374: ; Remove a thread from the timeout list.
                            	   375: ; Called when a mailbox is freed and a thread is waiting at the
                            	   376: ; mailbox.
                            	   377: ;
                            	   378: ; Parameters:
                            	   379: ;		B = task id to remove
                            	   380: ; Modifies:
                            	   381: ;		none
                            	   382: ; Returns:
                            	   383: ;		none
                            	   384: ;------------------------------------------------------------------------------
                            	   385: 	if 0
                            	   386: RemoveFromTimeoutList:
                            	   387: 	pshs	d,w,x,y,u
                            	   388: 	cmpb	TimeoutList			; head of list?
                            	   389: 	beq		0001f
                            	   390: 	lbsr	TCBHandleToPointer
                            	   391: 	tfr		d,x
                            	   392: 	ldb		TCBNext,x
                            	   393: 	clra
                            	   394: 	tfr		d,u
                            	   395: 	ldf		TCBPrev,x
                            	   396: 	lbsr	TCBHandleToPointer
                            	   397: 	tfr		d,y
                            	   398: 	stf		TCBPrev,y
                            	   399: 	tfr		f,b
                            	   400: 	clra
                            	   401: 	lbsr	TCBHandleToPointer
                            	   402: 	tfr		d,y
                            	   403: 	tfr		u,d
                            	   404: 	stb		TCBNext,y
                            	   405: 	bra		0002f
                            	   406: 	; Removing from head of timeout list
                            	   407: 0001:
                            	   408: 	lbsr	TCBHandleToPointer
                            	   409: 	tfr		d,x
                            	   410: 	ldb		TCBNext,x
                            	   411: 	stb		TimeoutList		; set new head of list
                            	   412: 	clra
                            	   413: 	lbsr	TCBHandleToPointer
                            	   414: 	tfr		d,y
                            	   415: 	clrb
                            	   416: 	stb		TCBPrev,y			; next->prev = NULL
                            	   417: 0002:
                            	   418: 	clrd
                            	   419: 	std		TCBNext,x			; next = NULL
                            	   420: 	std		TCBPrev,x			; prev = NULL
                            	   421: 	puls	d,w,x,y,u,pc
                            	   422: 	
                            	   423: ;// ----------------------------------------------------------------------------
                            	   424: ;// Pop the top entry from the timeout list.
                            	   425: ;// ----------------------------------------------------------------------------
                            	   426: ;
                            	   427: ;hTCB PopTimeoutList()
                            	   428: ;{
                            	   429: ;    TCB *p;
                            	   430: ;    hTCB h;
                            	   431: ;
                            	   432: ;    h = TimeoutList;
                            	   433: ;    if (TimeoutList > 0 && TimeoutList < NR_TCB) {
                            	   434: ;        TimeoutList = tcbs[TimeoutList].next;
                            	   435: ;        if (TimeoutList >= 0 && TimeoutList < NR_TCB) {
                            	   436: ;            tcbs[TimeoutList].prev = h->prev;
                            	   437: ;            h->prev->next = TimeoutList;
                            	   438: ;        }
                            	   439: ;    }
                            	   440: ;    return h;
                            	   441: ;}
                            	   442: ;
                            	   443: ; Returns:
                            	   444: ;		B = task at top of list
                            	   445: ;
                            	   446: 
                            	   447: PopTimeoutList:
                            	   448: 	pshs	w,x,y
                            	   449: 	ldb		TimeoutList
                            	   450: 	pshs	b
                            	   451: 	beq		0001f
                            	   452: 	cmpb	#NR_TCB
                            	   453: 	bhs		0001f
                            	   454: 	bsr		TCBHandleToPointer
                            	   455: 	tfr		d,x
                            	   456: 	ldb		TCBNext,x
                            	   457: 	tfr		b,f
                            	   458: 	lde		TCBPrev,x
                            	   459: 	stb		TimeoutList
                            	   460: 	beq		0001f
                            	   461: 	cmpb	#NR_TCB
                            	   462: 	bhs		0001f
                            	   463: 	bsr		TCBHandleToPointer
                            	   464: 	tfr		d,y
                            	   465: 	ste		TCBPrev,y
                            	   466: 	tfr		e,b
                            	   467: 	bsr		TCBHandleToPointer
                            	   468: 	tfr		d,y
                            	   469: 	stf		TCBNext,y
                            	   470: 	clr		TCBPrev,x
                            	   471: 	clr		TCBNext,x
                            	   472: 0001:
                            	   473: 	puls	b
                            	   474: 	puls	x,y,w,pc
                            	   475: 
                            	   476: ; ----------------------------------------------------------------------------
                            	   477: ; ----------------------------------------------------------------------------
                            	   478: DispTwoSpace:
                            	   479: 	bsr	DispSpace
                            	   480: DispSpace:
                            	   481: 	ldb		#' '
                            	   482: 	swi
                            	   483: 	fcb		MF_OUTCH
                            	   484: 	rts
                            	   485: 
                            	   486: DumpTCBs:
                            	   487: 	swi
                            	   488: 	fcb		MF_CRLF
                            	   489: 	ldb		#1
                            	   490: 0002:
                            	   491: 	lbsr	TCBHandleToPointer
                            	   492: 	tfr		d,x
                            	   493: 	ldb		TCBtid,x
                            	   494: 	swi
                            	   495: 	fcb		MF_DisplayByteAsHex
                            	   496: 	bsr		DispSpace
                            	   497: 	ldb		TCBStatus,x
                            	   498: 	swi
                            	   499: 	fcb		MF_DisplayByteAsHex
                            	   500: 	bsr		DispTwoSpace
                            	   501: 	swi
                            	   502: 	fcb		MF_CRLF
                            	   503: 	ldb		TCBNext,x
                            	   504: 	beq		0001f
                            	   505: 	bra		0002b
                            	   506: 0001:
                            	   507: 	rts
                            	   508: 	
                            	   509: fcb	"TID Stat"
                            	   510: 	endif
                            	   511: 
                            	   512: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     9: 	include "..\Femtiki\source\kernel\Femtiki.x68"

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     1: 	code
                            	     2: 	even
                            	     3: ;------------------------------------------------------------------------------
                            	     4: ; Initialize the Femtiki OS.
                            	     5: ;------------------------------------------------------------------------------
                            	     6: 
                            	     7: FemtikiInit:
00:00000220 7000            	     8: 	moveq #0,d0
00:00000222 4E7B0012        	     9: 	movec d0,tr
00:00000226 6100FDD8        	    10: 	bsr TCBInit
00:0000022A 42390010031C    	    11: 	clr.b QueueCycle
                            	    12: FemtikiInitIRQ:
00:00000230 43FA00DC        	    13: 	lea FemtikiTimerIRQ,a1						; Set timer IRQ vector to Femtiki
00:00000234 4E7A8801        	    14: 	movec vbr,a0
00:00000238 21490078        	    15: 	move.l a1,30*4(a0)								; vector #30
00:0000023C 4E75            	    16: 	rts
                            	    17: 
                            	    18: ;------------------------------------------------------------------------------
                            	    19: ; Operating system call dispatcher.
                            	    20: ; On entry, the task state has been saved including the system stack pointer,
                            	    21: ; in the task control block.
                            	    22: ;------------------------------------------------------------------------------
                            	    23: 
                            	    24: OSCallTable
00:0000023E 0000            	    25: 	dc.w		0
                            	    26: 
                            	    27: 	even
                            	    28: CallOS:
00:00000240 2F08            	    29: 	move.l	a0,-(a7)
00:00000242 207900100224    	    30: 	move.l	RunningTCB,a0
00:00000248 48E8FFFF0004    	    31: 	movem.l d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,TCBRegs(a0)
00:0000024E 225F            	    32: 	move.l	(a7)+,a1
00:00000250 21490020        	    33: 	move.l	a1,32(a0)
00:00000254 4E7A9800        	    34: 	movec		usp,a1
00:00000258 21490044        	    35: 	move.l	a1,TCBUSP(a0)
00:0000025C 301F            	    36: 	move.w	(a7)+,d0					; pop the status register
00:0000025E 3140004C        	    37: 	move.w	d0,TCBSR(a0)			; save in TCB
00:00000262 225F            	    38: 	move.l	(a7)+,a1					; pop the program counter
00:00000264 5489            	    39: 	lea	2(a1),a1							; increment past inline callno argument
00:00000266 21490050        	    40: 	move.l	a1,TCBPC(a0)			; save PC in TCB
00:0000026A 214F0048        	    41: 	move.l	a7,TCBSSP(a0)			; finally save SSP
00:0000026E 3029FFFE        	    42: 	move.w	-2(a1),d0					; d0 = call number
00:00000272 E548            	    43: 	lsl.w		#2,d0							; make into table index
00:00000274 43FAFFC8        	    44: 	lea			OSCallTable,a1
00:00000278 22710000        	    45: 	move.l	(a1,d0.w),a1
00:0000027C 4E91            	    46: 	jsr			(a1)							; call the OS function
                            	    47: 	; Restore the thread context and return
00:0000027E 207900100224    	    48: 	move.l	RunningTCB,a0
00:00000284 2E780048        	    49: 	move.l	TCBSSP,a7
00:00000288 2F280050        	    50: 	move.l	TCBPC(a0),-(a7)		; setup the PC and the SR on the stack
00:0000028C 3F28004C        	    51: 	move.w	TCBSR(a0),-(a7)		; prep for RTE
00:00000290 20380044        	    52: 	move.l	TCBUSP,d0					; restore user stack pointer
00:00000294 4E7B0800        	    53: 	movec		d0,usp
00:00000298 4CE800FF0004    	    54: 	movem.l	TCBRegs(a0),d0/d1/d2/d3/d4/d5/d6/d7
00:0000029E 4CE87E00002C    	    55: 	movem.l TCBRegs+40(a0),a1/a2/a3/a4/a5/a6
00:000002A4 20680024        	    56: 	move.l	TCBRegs+32(a0),a0
00:000002A8 4E73            	    57: 	rte
                            	    58: 
                            	    59: ;------------------------------------------------------------------------------
                            	    60: ; Get a pointer to the currently running TCB.
                            	    61: ;
                            	    62: ; Returns:
                            	    63: ;		a0 = pointer to running TCB
                            	    64: ;------------------------------------------------------------------------------
                            	    65: 
                            	    66: GetRunningTCBPointer:
00:000002AA 48E7C000        	    67: 	movem.l d0/d1,-(a7)
00:000002AE 4E7A0012        	    68: 	movec tr,d0
00:000002B2 6100FD74        	    69: 	bsr TCBHandleToPointer
00:000002B6 028000000FFF    	    70: 	andi.l #MAX_TID,d0		; limit to # threads
00:000002BC 4CDF0003        	    71: 	movem.l (a7)+,d0/d1
00:000002C0 4E75            	    72: 	rts
                            	    73: 
                            	    74: ; ----------------------------------------------------------------------------
                            	    75: ; Select a thread to run. Relatively easy. All that needs to be done is to
                            	    76: ; keep popping the queue until a valid running task is found. There should
                            	    77: ; always be at least one thread in the queue.
                            	    78: ;
                            	    79: ; Modifies:
                            	    80: ;		none
                            	    81: ; Returns:
                            	    82: ;		d0 = handle of the next thread to run
                            	    83: ; ----------------------------------------------------------------------------
                            	    84: 
                            	    85: SelectThreadToRun:
                            	    86: .0001										; keep popping tasks from the readyQ until a valid one
00:000002C2 6100FEB6        	    87: 	bsr	TCBPopReadyQueue	; is found.
00:000002C6 4A40            	    88: 	tst.w d0
00:000002C8 6B0C            	    89: 	bmi	.0002
00:000002CA 0C2800800054    	    90: 	cmpi.b #TS_RUNNING,TCBStatus(a0)	; ensure the thread is to be running
00:000002D0 66F0            	    91: 	bne	.0001													; if not, go get the next thread
00:000002D2 6000FE04        	    92: 	bra	TCBInsertIntoReadyQueue				; insert thread back into queue
                            	    93: 	; Nothing in queues? There is supposed to be. Add the OS task to the queue.
                            	    94: .0002
00:000002D6 4E7A8013        	    95: 	movec tcba,a0
00:000002DA 117C00800054    	    96: 	move.b #TS_RUNNING,TCBStatus(a0)	; flag as RUNNING
00:000002E0 117C00040055    	    97: 	move.b #4,TCBPriority(a0)					; OS has normal priority
00:000002E6 7000            	    98: 	moveq #0,d0												; fast pointer to handle
00:000002E8 6000FDEE        	    99: 	bra TCBInsertIntoReadyQueue
                            	   100: 
                            	   101: ; ----------------------------------------------------------------------------
                            	   102: ; Update the IRQ live indicator on screen.
                            	   103: ; ----------------------------------------------------------------------------
                            	   104: 
                            	   105: UpdateIRQLive:
00:000002EC 227900040004    	   106: 	move.l TextScr,a1					; a1 = screen address
00:000002F2 2411            	   107: 	move.l (a1),d2
00:000002F4 E15A            	   108: 	rol.w	#8,d2								; reverse byte order of d2
00:000002F6 4842            	   109: 	swap d2
00:000002F8 E15A            	   110: 	rol.w	#8,d2
00:000002FA 06010030        	   111: 	addi.b #'0',d1						; binary to ascii core number
00:000002FE D202            	   112: 	add.b	d2,d1
00:00000300 E159            	   113: 	rol.w	#8,d1								; put bytes back in order
00:00000302 4841            	   114: 	swap d1
00:00000304 E159            	   115: 	rol.w	#8,d1
00:00000306 23410004        	   116: 	move.l d1,4(a1)						; update onscreen IRQ flag
00:0000030A 5291            	   117: 	addi.l #1,(a1)						; flashy colors
00:0000030C 4E75            	   118: 	rts
                            	   119: 
                            	   120: ; ----------------------------------------------------------------------------
                            	   121: ; Femtiki IRQ service routine. This is where a thread switch can occur so,
                            	   122: ; the thread context is saved and restored.
                            	   123: ; ----------------------------------------------------------------------------
                            	   124: 
                            	   125: FemtikiTimerIRQ:
00:0000030E 46FC2600        	   126: 	move.w #$2600,sr							; disable lower level IRQs
00:00000312 2F00            	   127: 	move.l d0,-(a7)
00:00000314 2F08            	   128: 	move.l a0,-(a7)
00:00000316 6192            	   129: 	bsr GetRunningTCBPointer			; a0 = pointer to running TCB
00:00000318 48E8FFFF0004    	   130: 	movem.l #$FFFF,TCBRegs(a0)		; save all registers
00:0000031E 201F            	   131: 	move.l (a7)+,d0
00:00000320 21400020        	   132: 	move.l d0,32(a0)							; save original a0 value
00:00000324 201F            	   133: 	move.l (a7)+,d0
00:00000326 2080            	   134: 	move.l d0,(a0)								; save original d0 value
00:00000328 4E7A0800        	   135: 	movec usp,d0									; save user stack pointer
00:0000032C 21400044        	   136: 	move.l d0,TCBUSP(a0)
00:00000330 2E7C00041BFC    	   137: 	move.l #TimerStack,a7					; reset stack pointer
00:00000336 4E7A1FE0        	   138: 	movec	coreno,d1								; d1 = core number
00:0000033A 0C010002        	   139: 	cmpi.b #2,d1
00:0000033E 6612            	   140: 	bne.s	.0002
00:00000340 23FC1D000000FD09	   141: 	move.l #$1D000000,PLIC+$14		; reset edge sense circuit
00:00000348 0014
00:0000034A 13FC0001000400A0	   142: 	move.b #1,IRQFlag							; set IRQ flag for TinyBasic shell
                            	   143: .0002
00:00000352 6198            	   144: 	bsr UpdateIRQLive							; Update IRQ live indicator
                            	   145: ;	bsr ReceiveMsg								; Check for RPC
00:00000354 4E7A0FF0        	   146: 	movec tick,d0									; Update time accounting
00:00000358 21400070        	   147: 	move.l d0,TCBEndTick(a0)			; compute number of ticks thread was running
00:0000035C 90A8006C        	   148: 	sub.l	TCBStartTick(a0),d0
00:00000360 D1A80074        	   149: 	add.l	d0,TCBTicks(a0)					; add to cumulative ticks
00:00000364 117C00200054    	   150: 	move.b #TS_PREEMPT,TCBStatus(a0)	; set thread status to PREEMPT
00:0000036A 6100FF56        	   151: 	bsr	SelectThreadToRun					; d0 = TCB handle
00:0000036E 4E7B0012        	   152: 	movec d0,tr										; set running thread number in tr
00:00000372 6100FF36        	   153: 	bsr GetRunningTCBPointer			; a0 = pointer to TCB
00:00000376 117C00800054    	   154: 	move.b #TS_RUNNING,TCBStatus(a0)	; set thread status to RUNNING
00:0000037C 4E7A0FF0        	   155: 	movec	tick,d0
00:00000380 2140006C        	   156: 	move.l d0,TCBStartTick(a0)		; record starting tick
00:00000384 20280044        	   157: 	move.l TCBUSP(a0),d0					; restore user stack pointer
00:00000388 4E7B0800        	   158: 	movec d0,usp
00:0000038C 4CE8FFFF0004    	   159: 	movem.l TCBRegs(a0),#$FFFF		; restore all registers
00:00000392 504F            	   160: 	addq #8,sp										; "pop" d0/a0, saved stack pointer is off by 8
00:00000394 4E73            	   161: 	rte														; and return
                            	   162: 
                            	   163: 	include "..\Femtiki\source\kernel\Semaphore.x68"

Source: "..\Femtiki\source\kernel\Semaphore.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;-------------------------------------------------------------------------------
                            	    38: ; Lock the system semaphore. Call the BIOS.
                            	    39: ;
                            	    40: ; Parameters:
                            	    41: ;		none
                            	    42: ; Returns:
                            	    43: ;		none
                            	    44: ;-------------------------------------------------------------------------------
                            	    45: 
                            	    46: LockSysSemaphore:
00:00000396 48E7C000        	    47: 	movem.l d0/d1,-(sp)
00:0000039A 7025            	    48: 	moveq #37,d0				; lock semaphore
00:0000039C 7208            	    49: 	moveq #FMTK_SEMA,d1
00:0000039E 4E4F            	    50: 	trap #15
00:000003A0 4CDF0003        	    51: 	movem.l (sp)+,d0/d1
00:000003A4 4E75            	    52: 	rts
                            	    53: 
                            	    54: 
                            	    55: ;-------------------------------------------------------------------------------
                            	    56: ; Unlock the system semaphore.
                            	    57: ;
                            	    58: ; Parameters:
                            	    59: ;		none
                            	    60: ; Returns:
                            	    61: ;		none
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: UnlockSysSemaphore:
00:000003A6 48E7C000        	    65: 	movem.l d0/d1,-(sp)
00:000003AA 7026            	    66: 	moveq #38,d0				; unlock semaphore
00:000003AC 7208            	    67: 	moveq #FMTK_SEMA,d1
00:000003AE 4E4F            	    68: 	trap #15
00:000003B0 4CDF0003        	    69: 	movem.l (sp)+,d0/d1
00:000003B4 4E75            	    70: 	rts
                            	    71: 
                            	    72: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	   164: 
                            	   165: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	    10: 

Source: "boot.x68"
                            	   133: 
                            	   134: DDATA EQU $FFFFFFF0     ; DS.L    3
                            	   135: HISPC EQU $FFFFFFFC     ; DS.L    1
                            	   136: SCREEN_FORMAT = 1
                            	   137: 
                            	   138: 	if HAS_MMU
                            	   139: TEXTREG		EQU	$1E3FF00	; virtual addresses
                            	   140: txtscreen	EQU	$1E00000
                            	   141: semamem		EQU	$1E50000
                            	   142: ACIA			EQU	$1E60000
                            	   143: ACIA_RX		EQU	0
                            	   144: ACIA_TX		EQU	0
                            	   145: ACIA_STAT	EQU	4
                            	   146: ACIA_CMD	EQU	8
                            	   147: ACIA_CTRL	EQU	12
                            	   148: I2C2 			equ $01E69000
                            	   149: I2C_PREL 	equ 0
                            	   150: I2C_PREH 	equ 1
                            	   151: I2C_CTRL 	equ 2
                            	   152: I2C_RXR 	equ 3
                            	   153: I2C_TXR 	equ 3
                            	   154: I2C_CMD 	equ 4
                            	   155: I2C_STAT 	equ 4
                            	   156: PLIC			EQU	$1E90000
                            	   157: MMU				EQU $FDC00000	; physical address
                            	   158: leds			EQU	$1EFFF00	; virtual addresses
                            	   159: keybd			EQU	$1EFFE00
                            	   160: KEYBD			EQU	$1EFFE00
                            	   161: RAND			EQU	$1EFFD00
                            	   162: RAND_NUM	EQU	$1EFFD00
                            	   163: RAND_STRM	EQU	$1EFFD04
                            	   164: RAND_MZ		EQU $1EFFD08
                            	   165: RAND_MW		EQU	$1EFFD0C
                            	   166: RST_REG		EQU	$1EFFC00
                            	   167: IO_BITMAP	EQU $1F00000
                            	   168: 	else
                            	   169: TEXTREG		EQU	$FD080000
                            	   170: txtscreen	EQU	$FD000000
                            	   171: semamem		EQU	$FD050000
                            	   172: ACIA			EQU	$FD060000
                            	   173: ACIA_RX		EQU	0
                            	   174: ACIA_TX		EQU	0
                            	   175: ACIA_STAT	EQU	4
                            	   176: ACIA_CMD	EQU	8
                            	   177: ACIA_CTRL	EQU	12
                            	   178: I2C2 			equ $FD069000
                            	   179: I2C_PREL 	equ 0
                            	   180: I2C_PREH 	equ 1
                            	   181: I2C_CTRL 	equ 2
                            	   182: I2C_RXR 	equ 3
                            	   183: I2C_TXR 	equ 3
                            	   184: I2C_CMD 	equ 4
                            	   185: I2C_STAT 	equ 4
                            	   186: PLIC			EQU	$FD090000
                            	   187: MMU				EQU $FDC00000	; physical address
                            	   188: leds			EQU	$FD0FFF00	; virtual addresses
                            	   189: keybd			EQU	$FD0FFE00
                            	   190: KEYBD			EQU	$FD0FFE00
                            	   191: RAND			EQU	$FD0FFD00
                            	   192: RAND_NUM	EQU	$FD0FFD00
                            	   193: RAND_STRM	EQU	$FD0FFD04
                            	   194: RAND_MZ		EQU $FD0FFD08
                            	   195: RAND_MW		EQU	$FD0FFD0C
                            	   196: RST_REG		EQU	$FD0FFC00
                            	   197: IO_BITMAP	EQU $FD100000
                            	   198: FRAMEBUF	EQU	$FD200000
                            	   199: GFXACCEL	EQU	$FD300000
                            	   200: 	endif
                            	   201: 
                            	   202: SERIAL_SEMA	EQU	2
                            	   203: KEYBD_SEMA	EQU	3
                            	   204: RAND_SEMA		EQU	4
                            	   205: SCREEN_SEMA	EQU	5
                            	   206: MEMORY_SEMA EQU 6
                            	   207: TCB_SEMA 		EQU	7
                            	   208: FMTK_SEMA		EQU	8
                            	   209: 
                            	   210: macIRQ_proc	macro arg1
                            	   211: 	dc.l IRQ_proc\1
                            	   212: endm
                            	   213: 
                            	   214: macIRQ_proc_label	macro arg1
                            	   215: IRQ_proc\1:
                            	   216: endm
                            	   217: 
                            	   218: 	data
                            	   219: 	; 0
01:00000000 00040FFC        	   220: 	dc.l		$00040FFC
01:00000004 000003B8        	   221: 	dc.l		start
01:00000008 000098AA        	   222: 	dc.l		bus_err
01:0000000C 00009C88        	   223: 	dc.l		addr_err
01:00000010 00009CD6        	   224: 	dc.l		illegal_trap		* ILLEGAL instruction
01:00000014 00000000        	   225: 	dc.l		0
01:00000018 00002600        	   226: 	dc.l		chk_exception		; CHK
01:0000001C 00002744        	   227: 	dc.l		EXCEPTION_7			* TRAPV
01:00000020 00000000        	   228: 	dc.l		0
01:00000024 00000000        	   229: 	dc.l		0
                            	   230: 	
                            	   231: 	; 10
01:00000028 00000000        	   232: 	dc.l		0
01:0000002C 00000000        	   233: 	dc.l		0
01:00000030 00000000        	   234: 	dc.l		0
01:00000034 00000000        	   235: 	dc.l		0
01:00000038 00000000        	   236: 	dc.l		0
01:0000003C 00000000        	   237: 	dc.l		0
01:00000040 00000000        	   238: 	dc.l		0
01:00000044 00000000        	   239: 	dc.l		0
01:00000048 00000000        	   240: 	dc.l		0
01:0000004C 00000000        	   241: 	dc.l		0
                            	   242: 	
                            	   243: 	; 20
01:00000050 00000000        	   244: 	dc.l		0
01:00000054 00000000        	   245: 	dc.l		0
01:00000058 00000000        	   246: 	dc.l		0
01:0000005C 00000000        	   247: 	dc.l		0
01:00000060 00009C74        	   248: 	dc.l		SpuriousIRQ
01:00000064 00000000        	   249: 	dc.l		0
01:00000068 00000000        	   250: 	dc.l		0
01:0000006C 00009C42        	   251: 	dc.l		irq3_rout
01:00000070 00000000        	   252: 	dc.l		0
01:00000074 00000000        	   253: 	dc.l		0
                            	   254: 	
                            	   255: 	; 30
01:00000078 00009C00        	   256: 	dc.l		TickIRQ						; IRQ 30 - timer / keyboard
01:0000007C 00009C76        	   257: 	dc.l		nmi_rout
01:00000080 00009B64        	   258: 	dc.l		io_trap						; TRAP zero
01:00000084 00000000        	   259: 	dc.l		0
01:00000088 00000000        	   260: 	dc.l		0
01:0000008C 000098C4        	   261: 	dc.l		trap3							; breakpoint
01:00000090 00000000        	   262: 	dc.l		0
01:00000094 00000000        	   263: 	dc.l		0
01:00000098 00000000        	   264: 	dc.l		0
01:0000009C 00000000        	   265: 	dc.l		0
                            	   266: 
                            	   267: 	; 40
01:000000A0 00000000        	   268: 	dc.l		0
01:000000A4 00000000        	   269: 	dc.l		0
01:000000A8 00000000        	   270: 	dc.l		0
01:000000AC 00000000        	   271: 	dc.l		0
01:000000B0 00000000        	   272: 	dc.l		0
01:000000B4 00000000        	   273: 	dc.l		0
01:000000B8 00000000        	   274: 	dc.l		0
01:000000BC 00007B22        	   275: 	dc.l		TRAP15
01:000000C0 00000000        	   276: 	dc.l		0
01:000000C4 00000000        	   277: 	dc.l		0
                            	   278: 
                            	   279: 	; 50	
01:000000C8 00000000        	   280: 	dc.l		0
01:000000CC 00000000        	   281: 	dc.l		0
01:000000D0 00000000        	   282: 	dc.l		0
01:000000D4 00000000        	   283: 	dc.l		0
01:000000D8 00000000        	   284: 	dc.l		0
01:000000DC 00000000        	   285: 	dc.l		0
01:000000E0 00000000        	   286: 	dc.l		0
01:000000E4 00000000        	   287: 	dc.l		0
01:000000E8 00000000        	   288: 	dc.l		0
01:000000EC 00009CEC        	   289: 	dc.l		io_irq
                            	   290: 
                            	   291: 	; 60
01:000000F0 00000B7A        	   292: 	dc.l		KeybdIRQ
01:000000F4 000017E4        	   293: 	dc.l		SerialIRQ
01:000000F8 00000000        	   294: 	dc.l		0
01:000000FC 00009C9E        	   295: 	dc.l		brdisp_trap
                            	   296: 	
                            	   297: 	; 64
                            	   298: 
                            	   299: IRQ_trampolines:
                            	   300: ;	rept 192
                            	   301: ;	macIRQ_proc REPTN
                            	   302: ;	endr
                            	   303: 
                            	   304: 	org			$400
                            	   305: 
                            	   306: irq_list_tbl:
                            	   307: 	rept 192
                            	   308: 	dc.l 0
                            	   309: 	dc.l 0
                            	   310: 	endr
01:00000400 00000000        	     1R 	dc.l 0
01:00000404 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000408 00000000        	     1R 	dc.l 0
01:0000040C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000410 00000000        	     1R 	dc.l 0
01:00000414 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000418 00000000        	     1R 	dc.l 0
01:0000041C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000420 00000000        	     1R 	dc.l 0
01:00000424 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000428 00000000        	     1R 	dc.l 0
01:0000042C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000430 00000000        	     1R 	dc.l 0
01:00000434 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000438 00000000        	     1R 	dc.l 0
01:0000043C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000440 00000000        	     1R 	dc.l 0
01:00000444 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000448 00000000        	     1R 	dc.l 0
01:0000044C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000450 00000000        	     1R 	dc.l 0
01:00000454 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000458 00000000        	     1R 	dc.l 0
01:0000045C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000460 00000000        	     1R 	dc.l 0
01:00000464 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000468 00000000        	     1R 	dc.l 0
01:0000046C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000470 00000000        	     1R 	dc.l 0
01:00000474 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000478 00000000        	     1R 	dc.l 0
01:0000047C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000480 00000000        	     1R 	dc.l 0
01:00000484 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000488 00000000        	     1R 	dc.l 0
01:0000048C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000490 00000000        	     1R 	dc.l 0
01:00000494 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000498 00000000        	     1R 	dc.l 0
01:0000049C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004A0 00000000        	     1R 	dc.l 0
01:000004A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004A8 00000000        	     1R 	dc.l 0
01:000004AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004B0 00000000        	     1R 	dc.l 0
01:000004B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004B8 00000000        	     1R 	dc.l 0
01:000004BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004C0 00000000        	     1R 	dc.l 0
01:000004C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004C8 00000000        	     1R 	dc.l 0
01:000004CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004D0 00000000        	     1R 	dc.l 0
01:000004D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004D8 00000000        	     1R 	dc.l 0
01:000004DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004E0 00000000        	     1R 	dc.l 0
01:000004E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004E8 00000000        	     1R 	dc.l 0
01:000004EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004F0 00000000        	     1R 	dc.l 0
01:000004F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004F8 00000000        	     1R 	dc.l 0
01:000004FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000500 00000000        	     1R 	dc.l 0
01:00000504 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000508 00000000        	     1R 	dc.l 0
01:0000050C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000510 00000000        	     1R 	dc.l 0
01:00000514 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000518 00000000        	     1R 	dc.l 0
01:0000051C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000520 00000000        	     1R 	dc.l 0
01:00000524 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000528 00000000        	     1R 	dc.l 0
01:0000052C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000530 00000000        	     1R 	dc.l 0
01:00000534 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000538 00000000        	     1R 	dc.l 0
01:0000053C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000540 00000000        	     1R 	dc.l 0
01:00000544 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000548 00000000        	     1R 	dc.l 0
01:0000054C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000550 00000000        	     1R 	dc.l 0
01:00000554 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000558 00000000        	     1R 	dc.l 0
01:0000055C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000560 00000000        	     1R 	dc.l 0
01:00000564 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000568 00000000        	     1R 	dc.l 0
01:0000056C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000570 00000000        	     1R 	dc.l 0
01:00000574 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000578 00000000        	     1R 	dc.l 0
01:0000057C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000580 00000000        	     1R 	dc.l 0
01:00000584 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000588 00000000        	     1R 	dc.l 0
01:0000058C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000590 00000000        	     1R 	dc.l 0
01:00000594 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000598 00000000        	     1R 	dc.l 0
01:0000059C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005A0 00000000        	     1R 	dc.l 0
01:000005A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005A8 00000000        	     1R 	dc.l 0
01:000005AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005B0 00000000        	     1R 	dc.l 0
01:000005B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005B8 00000000        	     1R 	dc.l 0
01:000005BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005C0 00000000        	     1R 	dc.l 0
01:000005C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005C8 00000000        	     1R 	dc.l 0
01:000005CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005D0 00000000        	     1R 	dc.l 0
01:000005D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005D8 00000000        	     1R 	dc.l 0
01:000005DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005E0 00000000        	     1R 	dc.l 0
01:000005E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005E8 00000000        	     1R 	dc.l 0
01:000005EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005F0 00000000        	     1R 	dc.l 0
01:000005F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005F8 00000000        	     1R 	dc.l 0
01:000005FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000600 00000000        	     1R 	dc.l 0
01:00000604 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000608 00000000        	     1R 	dc.l 0
01:0000060C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000610 00000000        	     1R 	dc.l 0
01:00000614 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000618 00000000        	     1R 	dc.l 0
01:0000061C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000620 00000000        	     1R 	dc.l 0
01:00000624 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000628 00000000        	     1R 	dc.l 0
01:0000062C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000630 00000000        	     1R 	dc.l 0
01:00000634 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000638 00000000        	     1R 	dc.l 0
01:0000063C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000640 00000000        	     1R 	dc.l 0
01:00000644 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000648 00000000        	     1R 	dc.l 0
01:0000064C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000650 00000000        	     1R 	dc.l 0
01:00000654 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000658 00000000        	     1R 	dc.l 0
01:0000065C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000660 00000000        	     1R 	dc.l 0
01:00000664 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000668 00000000        	     1R 	dc.l 0
01:0000066C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000670 00000000        	     1R 	dc.l 0
01:00000674 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000678 00000000        	     1R 	dc.l 0
01:0000067C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000680 00000000        	     1R 	dc.l 0
01:00000684 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000688 00000000        	     1R 	dc.l 0
01:0000068C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000690 00000000        	     1R 	dc.l 0
01:00000694 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000698 00000000        	     1R 	dc.l 0
01:0000069C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006A0 00000000        	     1R 	dc.l 0
01:000006A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006A8 00000000        	     1R 	dc.l 0
01:000006AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006B0 00000000        	     1R 	dc.l 0
01:000006B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006B8 00000000        	     1R 	dc.l 0
01:000006BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006C0 00000000        	     1R 	dc.l 0
01:000006C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006C8 00000000        	     1R 	dc.l 0
01:000006CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006D0 00000000        	     1R 	dc.l 0
01:000006D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006D8 00000000        	     1R 	dc.l 0
01:000006DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006E0 00000000        	     1R 	dc.l 0
01:000006E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006E8 00000000        	     1R 	dc.l 0
01:000006EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006F0 00000000        	     1R 	dc.l 0
01:000006F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006F8 00000000        	     1R 	dc.l 0
01:000006FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000700 00000000        	     1R 	dc.l 0
01:00000704 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000708 00000000        	     1R 	dc.l 0
01:0000070C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000710 00000000        	     1R 	dc.l 0
01:00000714 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000718 00000000        	     1R 	dc.l 0
01:0000071C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000720 00000000        	     1R 	dc.l 0
01:00000724 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000728 00000000        	     1R 	dc.l 0
01:0000072C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000730 00000000        	     1R 	dc.l 0
01:00000734 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000738 00000000        	     1R 	dc.l 0
01:0000073C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000740 00000000        	     1R 	dc.l 0
01:00000744 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000748 00000000        	     1R 	dc.l 0
01:0000074C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000750 00000000        	     1R 	dc.l 0
01:00000754 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000758 00000000        	     1R 	dc.l 0
01:0000075C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000760 00000000        	     1R 	dc.l 0
01:00000764 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000768 00000000        	     1R 	dc.l 0
01:0000076C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000770 00000000        	     1R 	dc.l 0
01:00000774 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000778 00000000        	     1R 	dc.l 0
01:0000077C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000780 00000000        	     1R 	dc.l 0
01:00000784 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000788 00000000        	     1R 	dc.l 0
01:0000078C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000790 00000000        	     1R 	dc.l 0
01:00000794 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000798 00000000        	     1R 	dc.l 0
01:0000079C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007A0 00000000        	     1R 	dc.l 0
01:000007A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007A8 00000000        	     1R 	dc.l 0
01:000007AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007B0 00000000        	     1R 	dc.l 0
01:000007B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007B8 00000000        	     1R 	dc.l 0
01:000007BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007C0 00000000        	     1R 	dc.l 0
01:000007C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007C8 00000000        	     1R 	dc.l 0
01:000007CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007D0 00000000        	     1R 	dc.l 0
01:000007D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007D8 00000000        	     1R 	dc.l 0
01:000007DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007E0 00000000        	     1R 	dc.l 0
01:000007E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007E8 00000000        	     1R 	dc.l 0
01:000007EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007F0 00000000        	     1R 	dc.l 0
01:000007F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007F8 00000000        	     1R 	dc.l 0
01:000007FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000800 00000000        	     1R 	dc.l 0
01:00000804 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000808 00000000        	     1R 	dc.l 0
01:0000080C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000810 00000000        	     1R 	dc.l 0
01:00000814 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000818 00000000        	     1R 	dc.l 0
01:0000081C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000820 00000000        	     1R 	dc.l 0
01:00000824 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000828 00000000        	     1R 	dc.l 0
01:0000082C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000830 00000000        	     1R 	dc.l 0
01:00000834 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000838 00000000        	     1R 	dc.l 0
01:0000083C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000840 00000000        	     1R 	dc.l 0
01:00000844 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000848 00000000        	     1R 	dc.l 0
01:0000084C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000850 00000000        	     1R 	dc.l 0
01:00000854 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000858 00000000        	     1R 	dc.l 0
01:0000085C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000860 00000000        	     1R 	dc.l 0
01:00000864 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000868 00000000        	     1R 	dc.l 0
01:0000086C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000870 00000000        	     1R 	dc.l 0
01:00000874 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000878 00000000        	     1R 	dc.l 0
01:0000087C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000880 00000000        	     1R 	dc.l 0
01:00000884 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000888 00000000        	     1R 	dc.l 0
01:0000088C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000890 00000000        	     1R 	dc.l 0
01:00000894 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000898 00000000        	     1R 	dc.l 0
01:0000089C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008A0 00000000        	     1R 	dc.l 0
01:000008A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008A8 00000000        	     1R 	dc.l 0
01:000008AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008B0 00000000        	     1R 	dc.l 0
01:000008B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008B8 00000000        	     1R 	dc.l 0
01:000008BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008C0 00000000        	     1R 	dc.l 0
01:000008C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008C8 00000000        	     1R 	dc.l 0
01:000008CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008D0 00000000        	     1R 	dc.l 0
01:000008D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008D8 00000000        	     1R 	dc.l 0
01:000008DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008E0 00000000        	     1R 	dc.l 0
01:000008E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008E8 00000000        	     1R 	dc.l 0
01:000008EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008F0 00000000        	     1R 	dc.l 0
01:000008F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008F8 00000000        	     1R 	dc.l 0
01:000008FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000900 00000000        	     1R 	dc.l 0
01:00000904 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000908 00000000        	     1R 	dc.l 0
01:0000090C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000910 00000000        	     1R 	dc.l 0
01:00000914 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000918 00000000        	     1R 	dc.l 0
01:0000091C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000920 00000000        	     1R 	dc.l 0
01:00000924 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000928 00000000        	     1R 	dc.l 0
01:0000092C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000930 00000000        	     1R 	dc.l 0
01:00000934 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000938 00000000        	     1R 	dc.l 0
01:0000093C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000940 00000000        	     1R 	dc.l 0
01:00000944 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000948 00000000        	     1R 	dc.l 0
01:0000094C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000950 00000000        	     1R 	dc.l 0
01:00000954 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000958 00000000        	     1R 	dc.l 0
01:0000095C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000960 00000000        	     1R 	dc.l 0
01:00000964 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000968 00000000        	     1R 	dc.l 0
01:0000096C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000970 00000000        	     1R 	dc.l 0
01:00000974 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000978 00000000        	     1R 	dc.l 0
01:0000097C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000980 00000000        	     1R 	dc.l 0
01:00000984 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000988 00000000        	     1R 	dc.l 0
01:0000098C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000990 00000000        	     1R 	dc.l 0
01:00000994 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000998 00000000        	     1R 	dc.l 0
01:0000099C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009A0 00000000        	     1R 	dc.l 0
01:000009A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009A8 00000000        	     1R 	dc.l 0
01:000009AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009B0 00000000        	     1R 	dc.l 0
01:000009B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009B8 00000000        	     1R 	dc.l 0
01:000009BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009C0 00000000        	     1R 	dc.l 0
01:000009C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009C8 00000000        	     1R 	dc.l 0
01:000009CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009D0 00000000        	     1R 	dc.l 0
01:000009D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009D8 00000000        	     1R 	dc.l 0
01:000009DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009E0 00000000        	     1R 	dc.l 0
01:000009E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009E8 00000000        	     1R 	dc.l 0
01:000009EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009F0 00000000        	     1R 	dc.l 0
01:000009F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009F8 00000000        	     1R 	dc.l 0
01:000009FC 00000000        	     2R 	dc.l 0
                            	     3R 	
                            	   311: 
                            	   312: 	org			$A00
                            	   313: 
                            	   314: ;-------------------------------------------------------------------------------
                            	   315: ;-------------------------------------------------------------------------------
                            	   316: 
                            	   317: ; BIOS variables which must be local (not shared) to each core
                            	   318: 
                            	   319: CursorRow	equ		$40000
                            	   320: CursorCol	equ		$40001
                            	   321: TextPos		equ		$40002
                            	   322: TextCurpos	equ	$40002
                            	   323: TextScr			equ	$40004
                            	   324: S19StartAddress	equ	$40008
                            	   325: KeybdEcho		equ	$4000C
                            	   326: KeybdWaitFlag	equ	$4000D
                            	   327: CmdBuf			equ $40040
                            	   328: CmdBufEnd		equ	$40080
                            	   329: fgColor			equ	$40084
                            	   330: bkColor			equ	$40088
                            	   331: TextRows		equ	$4008C
                            	   332: TextCols		equ	$4008D
                            	   333: _fpTextIncr	equ $40094
                            	   334: _canary			equ $40098
                            	   335: tickcnt			equ $4009C
                            	   336: IRQFlag			equ $400A0
                            	   337: InputDevice	equ $400A4
                            	   338: OutputDevice	equ $400A8
                            	   339: Regsave			equ	$40100
                            	   340: numBreakpoints	equ		8
                            	   341: BreakpointFlag	equ		$40200
                            	   342: NumSetBreakpoints	equ	$40202	; to $40203
                            	   343: Breakpoints			equ		$40220	; to $40240
                            	   344: BreakpointWords	equ		$40280	; to $402A0
                            	   345: fpBuf       equ $402C0
                            	   346: ;RunningTCB  equ $40300
                            	   347: _exp equ $40500
                            	   348: _digit equ $40504
                            	   349: _width equ $40508
                            	   350: _E equ $4050C
                            	   351: _digits_before_decpt equ $40510
                            	   352: _precision equ $40514
                            	   353: _fpBuf equ $40520	; to $40560
                            	   354: _fpWork equ $40600
                            	   355: _dasmbuf	equ	$40800
                            	   356: OFFSET equ $40880
                            	   357: pen_color equ $40890
                            	   358: gr_x equ $40894
                            	   359: gr_y equ $40898
                            	   360: gr_width equ $4089C
                            	   361: gr_height equ $408A0
                            	   362: gr_bitmap_screen equ $408A4
                            	   363: gr_raster_op equ $408A8
                            	   364: gr_double_buffer equ $408AC
                            	   365: gr_bitmap_buffer equ $408B0
                            	   366: sys_switches equ $408B8
                            	   367: gfxaccel_ctrl equ $408C0
                            	   368: m_z equ $408D0
                            	   369: m_w equ $408D4
                            	   370: next_m_z equ $408D8
                            	   371: next_m_w equ $408DC
                            	   372: EightPixels equ $40100000	; to $40200020
                            	   373: 
                            	   374: null_dcb equ $0040A00		; 0
                            	   375: keybd_dcb equ null_dcb+DCB_SIZE	; 1
                            	   376: textvid_dcb equ keybd_dcb+DCB_SIZE	; 2
                            	   377: err_dcb equ textvid_dcb+DCB_SIZE		; 3
                            	   378: serial_dcb equ err_dcb+DCB_SIZE*2		; 5
                            	   379: framebuf_dcb equ serial_dcb+DCB_SIZE	; 6
                            	   380: gfxaccel_dcb equ framebuf_dcb+DCB_SIZE	; 7
                            	   381: 
                            	   382: TimerStack	equ	$41BFC
                            	   383: 
                            	   384: ; Keyboard buffer is in shared memory
                            	   385: IOFocus			EQU	$00100000
                            	   386: memend			equ $00100004
                            	   387: KeybdLEDs		equ	$0010000E
                            	   388: _KeyState1	equ	$0010000F
                            	   389: _KeyState2	equ	$00100010
                            	   390: _KeybdHead	equ	$00100011
                            	   391: _KeybdTail	equ	$00100012
                            	   392: _KeybdCnt		equ	$00100013
                            	   393: KeybdID			equ	$00100018
                            	   394: _Keybd_tick	equ $0001001C
                            	   395: _KeybdBuf		equ	$00100020
                            	   396: _KeybdOBuf	equ	$00100080
                            	   397: S19Checksum	equ	$00100150
                            	   398: SerTailRcv	equ	$00100160
                            	   399: SerHeadRcv	equ	$00100162
                            	   400: SerRcvXon		equ	$00100164
                            	   401: SerRcvXoff	equ	$00100165
                            	   402: SerTailXmit	equ	$00100166
                            	   403: SerHeadXmit	equ	$00100168
                            	   404: SerXmitXoff	equ	$0010016A
                            	   405: SerRcvBuf		equ	$00101000
                            	   406: SerXmitBuf	equ	$00102000
                            	   407: RTCBuf			equ $00100200	; to $0010023F
                            	   408: 
                            	   409: 	code
                            	   410: 	align		2
                            	   411: start:
                            	   412: ;	fadd (a0)+,fp2
00:000003B8 13FC0001FD0FFF00	   413: 	move.b #1,leds
00:000003C0 46FC2700        	   414: 	move.w #$2700,sr					; enable level 6 and higher interrupts
00:000003C4 7000            	   415: 	moveq #0,d0								; set address space zero
00:000003C6 4E7B0003        	   416: 	movec d0,asid
                            	   417: 	; Setup circuit select signals
00:000003CA 203CFDC00000    	   418: 	move.l #MMU,d0
00:000003D0 4E7B0014        	   419: 	movec d0,mmus
                            	   420: 	if HAS_MMU
                            	   421: 		move.l #$01F00000,d0			; set virtual address for iop bitmap
                            	   422: 		movec d0,iops
                            	   423: 		move.l #$01E00000,d0			; set virtual address for io block
                            	   424: 		movec d0,ios
                            	   425: 	else
00:000003D4 203CFD100000    	   426: 		move.l #$FD100000,d0			; set virtual address for iop bitmap
00:000003DA 4E7B0016        	   427: 		movec d0,iops
00:000003DE 203CFD000000    	   428: 		move.l #$FD000000,d0			; set virtual address for io block
00:000003E4 4E7B0015        	   429: 		movec d0,ios
                            	   430: 	endif
                            	   431: ;	move.l $4000000C,d0
00:000003E8 13FC0002FD0FFF00	   432: 	move.b #2,leds
00:000003F0 4E7A0FE0        	   433: 	movec coreno,d0							; set initial value of thread register
00:000003F4 4840            	   434: 	swap d0											; coreno in high eight bits
00:000003F6 E188            	   435: 	lsl.l #8,d0
00:000003F8 4E7B0012        	   436: 	movec d0,tr
                            	   437: 	; Prepare local variable storage
00:000003FC 303C03FF        	   438: 	move.w #1023,d0						; 1024 longs to clear
00:00000400 41F900040000    	   439: 	lea	$40000,a0							; non shared local memory address
                            	   440: .0111:
00:00000406 4298            	   441: 	clr.l	(a0)+								; clear the memory area
00:00000408 51C8FFFC        	   442: 	dbra d0,.0111
00:0000040C 13FC0005FD0FFF00	   443: 	move.b #5,leds
00:00000414 13FC0001000400A4	   444: 	move.b #1,InputDevice			; select keyboard input
00:0000041C 13FC0002000400A8	   445: 	move.b #2,OutputDevice		; select text screen output
00:00000424 61000B92        	   446: 	bsr setup_textvid
00:00000428 13FC0003FD0FFF00	   447: 	move.b #3,leds
00:00000430 610000EE        	   448: 	bsr setup_null
00:00000434 13FC0004FD0FFF00	   449: 	move.b #4,leds
00:0000043C 6100012A        	   450: 	bsr setup_keybd
00:00000440 13FC0006FD0FFF00	   451: 	move.b #6,leds
00:00000448 6100112A        	   452: 	bsr setup_serial
00:0000044C 13FC0007FD0FFF00	   453: 	move.b #7,leds
00:00000454 4E7A0FE0        	   454: 	movec.l	coreno,d0					; get core number
00:00000458 0C000002        	   455: 	cmpi.b #2,d0
00:0000045C 66000096        	   456: 	bne	start_other
00:00000460 61001516        	   457: 	bsr setup_framebuf
00:00000464 13FC0008FD0FFF00	   458: 	move.b #8,leds
00:0000046C 61001A32        	   459: 	bsr setup_gfxaccel
00:00000470 13FC0009FD0FFF00	   460: 	move.b #9,leds
00:00000478 42B9000408B8    	   461: 	clr.l sys_switches
00:0000047E 4E7A0FE0        	   462: 	movec.l	coreno,d0					; get core number
00:00000482 13C000100000    	   463: 	move.b d0,IOFocus					; Set the IO focus in global memory
                            	   464: 	if HAS_MMU
                            	   465: 		bsr InitMMU							; Can't access anything till this is done'
                            	   466: 	endif
00:00000488 61001F52        	   467: 	bsr	InitIOPBitmap					; not going to get far without this
00:0000048C 610020CA        	   468: 	bsr	InitSemaphores
00:00000490 61001F96        	   469: 	bsr	InitRand
00:00000494 61001FFC        	   470: 	bsr RandGetNum
00:00000498 0281FFFFFF00    	   471: 	andi.l #$FFFFFF00,d1
00:0000049E 23C100040098    	   472: 	move.l d1,_canary
00:000004A4 4E7B1020        	   473: 	movec d1,canary
                            	   474: ;	bsr	Delay3s						; give devices time to reset
                            	   475: ;	moveq #2,d7					; device 2
                            	   476: ;	moveq #DEV_CLEAR,d6	; clear
                            	   477: ;	trap #0
                            	   478: ;	bsr	textvid_clear
                            	   479: 
00:000004A8 6100020A        	   480: 	bsr	_KeybdInit
                            	   481: ;	bsr	InitIRQ
00:000004AC 61001182        	   482: 	bsr	SerialInit
                            	   483: ;	bsr init_i2c
                            	   484: ;	bsr rtc_read
                            	   485: 
                            	   486: 	; Write startup message to screen
                            	   487: 
00:000004B0 43F900009D00    	   488: 	lea	msg_start,a1
00:000004B6 6100762C        	   489: 	bsr	DisplayString
                            	   490: ;	bsr	FemtikiInit
00:000004BA 4E7A0FE0        	   491: 	movec	coreno,d0
00:000004BE 4840            	   492: 	swap d0
00:000004C0 7201            	   493: 	moveq	#1,d1
00:000004C2 610020F6        	   494: 	bsr	UnlockSemaphore	; allow another cpu access
00:000004C6 7200            	   495: 	moveq	#0,d1
00:000004C8 610020F0        	   496: 	bsr	UnlockSemaphore	; allow other cpus to proceed
00:000004CC 33FCA4A4FD0FFF00	   497: 	move.w #$A4A4,leds			; diagnostics
00:000004D4 61007B40        	   498: 	bsr	init_plic				; initialize platform level interrupt controller
00:000004D8 60007C54        	   499: 	bra	StartMon
00:000004DC 61002176        	   500: 	bsr	cpu_test
                            	   501: ;	lea	brdisp_trap,a0	; set brdisp trap vector
                            	   502: ;	move.l	a0,64*4
                            	   503: 
                            	   504: loop2:
00:000004E0 70FF            	   505: 	move.l	#-1,d0
                            	   506: loop1:
00:000004E2 2200            	   507: 	move.l	d0,d1
00:000004E4 E089            	   508: 	lsr.l		#8,d1
00:000004E6 E089            	   509: 	lsr.l		#8,d1
00:000004E8 13C1FD0FFF00    	   510: 	move.b	d1,leds
00:000004EE 51C8FFF2        	   511: 	dbra		d0,loop1
00:000004F2 60EC            	   512: 	bra			loop2
                            	   513: 
                            	   514: start_other:
00:000004F4 61002142        	   515: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:000004F8 6100213E        	   516: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:000004FC 6100213A        	   517: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:00000500 7E02            	   518: 	move.l #2,d7
00:00000502 7C0C            	   519: 	move.l #DEV_CLEAR,d6
00:00000504 4E40            	   520: 	trap #0
00:00000506 4E7A1FE0        	   521: 	movec		coreno,d1
00:0000050A 4EB9000093D0    	   522: 	bsr			DisplayByte
00:00000510 43F900009D27    	   523: 	lea			msg_core_start,a1
00:00000516 610075CC        	   524: 	bsr			DisplayString
                            	   525: ;	bsr			FemtikiInitIRQ
                            	   526: do_nothing:	
00:0000051A 60007C12        	   527: 	bra			StartMon
00:0000051E 60FA            	   528: 	bra			do_nothing
                            	   529: 
                            	   530: ;------------------------------------------------------------------------------
                            	   531: ; Initialize the MMU to allow thread #0 access to IO
                            	   532: ;------------------------------------------------------------------------------
                            	   533: 	if HAS_MMU
                            	   534: 	align 2
                            	   535: mmu_adrtbl:	; virtual address[24:16], physical address[31:16] bytes reversed!
                            	   536: 	dc.l	$0010,$10000300	; global scratch pad
                            	   537: 	dc.l	$01E0,$00FD0300	
                            	   538: 	dc.l	$01E1,$01FD0300
                            	   539: 	dc.l	$01E2,$02FD0300
                            	   540: 	dc.l  $01E3,$03FD0300
                            	   541: 	dc.l	$01E5,$05FD0300
                            	   542: 	dc.l	$01E6,$06FD0300
                            	   543: 	dc.l	$01E9,$09FD0300
                            	   544: 	dc.l	$01EF,$0FFD0300
                            	   545: 	dc.l	$01F0,$10FD0300
                            	   546: 	dc.l  $01FF,$FFFF0300	; all ones output for IRQ ack needed
                            	   547: 
                            	   548: 	even
                            	   549: InitMMU:
                            	   550: 	lea MMU+8,a0				; first 128kB is local RAM
                            	   551: 	move.l #$32000,d2		; map all pages to DRAM
                            	   552: 	move.l #510,d0			; then override for IO later
                            	   553: .0002
                            	   554: 	move.l d2,d1
                            	   555: 	bsr rbo
                            	   556: 	move.l d1,(a0)+
                            	   557: 	addi.w #1,d2				; increment DRAM page number
                            	   558: 	dbra d0,.0002
                            	   559: 	lea MMU,a0					; now program IO access
                            	   560: 	lea mmu_adrtbl,a1
                            	   561: 	moveq #10,d0
                            	   562: .0001
                            	   563: 	move.l (a1)+,d2
                            	   564: 	lsl.l #2,d2
                            	   565: 	move.l (a1)+,(a0,d2.w)
                            	   566: 	dbra d0,.0001
                            	   567: 	rts	
                            	   568: 	endif
                            	   569: 
                            	   570: ;------------------------------------------------------------------------------
                            	   571: ; Device drivers
                            	   572: ;------------------------------------------------------------------------------
                            	   573: 
                            	   574: 	include "null.x68"

Source: "null.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;------------------------------------------------------------------------------
                            	    38: ;------------------------------------------------------------------------------
                            	    39: ; Setup the NULL device
                            	    40: ;------------------------------------------------------------------------------
                            	    41: ;------------------------------------------------------------------------------
                            	    42: 
                            	    43: setup_null:
                            	    44: null_init:
00:00000520 48E780C0        	    45: 	movem.l d0/a0/a1,-(a7)
00:00000524 7020            	    46: 	moveq #32,d0
00:00000526 41F900040A00    	    47: 	lea.l null_dcb,a0
                            	    48: .0001:
00:0000052C 4298            	    49: 	clr.l (a0)+
00:0000052E 51C8FFFC        	    50: 	dbra d0,.0001
00:00000532 23FC444342200004	    51: 	move.l #$44434220,null_dcb+DCB_MAGIC				; 'DCB'
00:0000053A 0A00
00:0000053C 23FC4E554C4C0004	    52: 	move.l #$4E554C4C,null_dcb+DCB_NAME					; 'NULL'
00:00000544 0A04
00:00000546 23FC000005640004	    53: 	move.l #null_cmdproc,null_dcb+DCB_CMDPROC
00:0000054E 0A18
00:00000550 43F900040A00    	    54: 	lea.l null_dcb+DCB_MAGIC,a1
00:00000556 6100758C        	    55: 	jsr DisplayString
00:0000055A 6100756E        	    56: 	jsr CRLF
00:0000055E 4CDF0301        	    57: 	movem.l (a7)+,d0/a0/a1
                            	    58: null_ret:
00:00000562 4E75            	    59: 	rts
                            	    60: 
                            	    61: null_cmdproc:
00:00000564 7000            	    62: 	moveq #E_Ok,d0
00:00000566 4E75            	    63: 	rts
                            	    64: 
                            	    65: 

Source: "boot.x68"
                            	   575: 	include "keybd.x68"

Source: "keybd.x68"
                            	     1: ;==============================================================================
                            	     2: ; Keyboard stuff
                            	     3: ;
                            	     4: ; KeyState2_
                            	     5: ; 876543210
                            	     6: ; ||||||||+ = shift
                            	     7: ; |||||||+- = alt
                            	     8: ; ||||||+-- = control
                            	     9: ; |||||+--- = numlock
                            	    10: ; ||||+---- = capslock
                            	    11: ; |||+----- = scrolllock
                            	    12: ; ||+------ =
                            	    13: ; |+------- = 
                            	    14: ; +-------- = extended
                            	    15: ;
                            	    16: ;==============================================================================
                            	    17: 
                            	    18: ;------------------------------------------------------------------------------
                            	    19: ; Setup the Keyboard device
                            	    20: ;------------------------------------------------------------------------------
                            	    21: setup_keybd:
                            	    22: keybd_init:
00:00000568 48E780C0        	    23: 	movem.l d0/a0/a1,-(a7)
00:0000056C 7020            	    24: 	moveq #32,d0
00:0000056E 41F900040A84    	    25: 	lea.l keybd_dcb,a0
                            	    26: .0001:
00:00000574 4298            	    27: 	clr.l (a0)+
00:00000576 51C8FFFC        	    28: 	dbra d0,.0001
00:0000057A 23FC444342200004	    29: 	move.l #$44434220,keybd_dcb+DCB_MAGIC				; 'DCB '
00:00000582 0A84
00:00000584 23FC4B4244000004	    30: 	move.l #$4B424400,keybd_dcb+DCB_NAME				; 'KBD'
00:0000058C 0A88
00:0000058E 23FC0000060C0004	    31: 	move.l #keybd_cmdproc,keybd_dcb+DCB_CMDPROC
00:00000596 0A9C
00:00000598 23FC001000200004	    32: 	move.l #_KeybdBuf,keybd_dcb+DCB_INBUFPTR
00:000005A0 0ABC
00:000005A2 23FC001000800004	    33: 	move.l #_KeybdOBuf,keybd_dcb+DCB_OUTBUFPTR
00:000005AA 0AC0
00:000005AC 23FC000000200004	    34: 	move.l #32,keybd_dcb+DCB_INBUFSIZE
00:000005B4 0AC4
00:000005B6 23FC000000200004	    35: 	move.l #32,keybd_dcb+DCB_OUTBUFSIZE
00:000005BE 0AC8
00:000005C0 423900040AD8    	    36: 	clr.b keybd_dcb+DCB_OUTDIMX	; set rows and columns
00:000005C6 423900040ADC    	    37: 	clr.b keybd_dcb+DCB_OUTDIMY
00:000005CC 423900040ACC    	    38: 	clr.b keybd_dcb+DCB_INDIMX		; set rows and columns
00:000005D2 423900040AD0    	    39: 	clr.b keybd_dcb+DCB_INDIMY
                            	    40: ;	bsr KeybdInit
00:000005D8 43F900040A84    	    41: 	lea.l keybd_dcb+DCB_MAGIC,a1
00:000005DE 61007504        	    42: 	jsr DisplayString
00:000005E2 610074E6        	    43: 	jsr CRLF
00:000005E6 4CDF0301        	    44: 	movem.l (a7)+,d0/a0/a1
00:000005EA 4E75            	    45: 	rts
                            	    46: 
                            	    47: 	align 2
                            	    48: KBD_CMDTBL:
00:000005EC 00000568        	    49: 	dc.l keybd_init				; 0
00:000005F0 0000062E        	    50: 	dc.l keybd_stat
00:000005F4 00000636        	    51: 	dc.l keybd_putchar
00:000005F8 00000646        	    52: 	dc.l keybd_putbuf
00:000005FC 0000063E        	    53: 	dc.l keybd_getchar
00:00000600 00000646        	    54: 	dc.l keybd_getbuf
00:00000604 00000646        	    55: 	dc.l keybd_set_inpos
00:00000608 00000646        	    56: 	dc.l keybd_set_outpos
                            	    57: 
                            	    58: keybd_cmdproc:
00:0000060C 0C060008        	    59: 	cmpi.b #8,d6
00:00000610 6418            	    60: 	bhs.s .0001
00:00000612 48E70280        	    61: 	movem.l d6/a0,-(a7)
00:00000616 E506            	    62: 	asl.b #2,d6
00:00000618 4886            	    63: 	ext.w d6
00:0000061A 41FAFFD0        	    64: 	lea KBD_CMDTBL,a0
00:0000061E 20706000        	    65: 	move.l (a0,d6.w),a0
00:00000622 4E90            	    66: 	jsr (a0)
00:00000624 4CDF0140        	    67: 	movem.l (a7)+,d6/a0
00:00000628 4E75            	    68: 	rts
                            	    69: .0001:
00:0000062A 7002            	    70: 	moveq #E_Func,d0
00:0000062C 4E75            	    71: 	rts
                            	    72: 
                            	    73: keybd_stat:
00:0000062E 61000196        	    74: 	bsr _KeybdGetStatus
00:00000632 7000            	    75: 	moveq #E_Ok,d0
00:00000634 4E75            	    76: 	rts
                            	    77: 
                            	    78: keybd_putchar:
00:00000636 61000502        	    79: 	bsr KeybdSendByte
00:0000063A 7000            	    80: 	moveq #E_Ok,d0
00:0000063C 4E75            	    81: 	rts
                            	    82: 
                            	    83: keybd_getchar:
00:0000063E 61000234        	    84: 	bsr GetKey
00:00000642 7000            	    85: 	moveq #E_Ok,d0
00:00000644 4E75            	    86: 	rts
                            	    87: 
                            	    88: keybd_putbuf:
                            	    89: keybd_getbuf:
                            	    90: keybd_set_inpos:
                            	    91: keybd_set_outpos:
00:00000646 700A            	    92: 	moveq #E_NotSupported,d0
00:00000648 4E75            	    93: 	rts
                            	    94: 
                            	    95: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	    96: ; Get ID - get the keyboards identifier code.
                            	    97: ;
                            	    98: ; Parameters: none
                            	    99: ; Returns: d = $AB83, $00 on fail
                            	   100: ; Modifies: d, KeybdID updated
                            	   101: ; Stack Space: 2 words
                            	   102: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   103: 
                            	   104: KeybdGetID:
00:0000064A 323C00F2        	   105: 	move.w	#$F2,d1
00:0000064E 610004EA        	   106: 	bsr			KeybdSendByte
00:00000652 610001E6        	   107: 	bsr			KeybdWaitTx
00:00000656 610001C0        	   108: 	bsr			KeybdRecvByte
00:0000065A 08010007        	   109: 	btst		#7,d1
00:0000065E 6624            	   110: 	bne			kgnotKbd
00:00000660 0C0100AB        	   111: 	cmpi.b	#$AB,d1
00:00000664 661E            	   112: 	bne			kgnotKbd
00:00000666 610001B0        	   113: 	bsr			KeybdRecvByte
00:0000066A 08010007        	   114: 	btst		#7,d1
00:0000066E 6614            	   115: 	bne			kgnotKbd
00:00000670 0C010083        	   116: 	cmpi.b	#$83,d1
00:00000674 660E            	   117: 	bne			kgnotKbd
00:00000676 223C0000AB83    	   118: 	move.l	#$AB83,d1
                            	   119: kgid1:
00:0000067C 33C100100018    	   120: 	move.w	d1,KeybdID
00:00000682 4E75            	   121: 	rts
                            	   122: kgnotKbd:
00:00000684 7200            	   123: 	moveq		#0,d1
00:00000686 60F4            	   124: 	bra			kgid1
                            	   125: 
                            	   126: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   127: ; Set the LEDs on the keyboard.
                            	   128: ;
                            	   129: ; Parameters:
                            	   130: ;		d1.b = LED state
                            	   131: ;	Modifies:
                            	   132: ;		none
                            	   133: ; Returns:
                            	   134: ;		none
                            	   135: ; Stack Space:
                            	   136: ;		1 long word
                            	   137: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   138: 
                            	   139: KeybdSetLED:
00:00000688 2F01            	   140: 	move.l	d1,-(a7)
00:0000068A 123C00ED        	   141: 	move.b	#$ED,d1
00:0000068E 610004AA        	   142: 	bsr			KeybdSendByte
00:00000692 610001A6        	   143: 	bsr			KeybdWaitTx
00:00000696 61000180        	   144: 	bsr			KeybdRecvByte
00:0000069A 4A01            	   145: 	tst.b		d1
00:0000069C 6B12            	   146: 	bmi			.0001
00:0000069E 0C0100FA        	   147: 	cmpi.b	#$FA,d1
00:000006A2 2217            	   148: 	move.l	(a7),d1
00:000006A4 61000494        	   149: 	bsr			KeybdSendByte
00:000006A8 61000190        	   150: 	bsr			KeybdWaitTx
00:000006AC 6100016A        	   151: 	bsr			KeybdRecvByte
                            	   152: .0001:
00:000006B0 221F            	   153: 	move.l	(a7)+,d1
00:000006B2 4E75            	   154: 	rts
                            	   155: 
                            	   156: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   157: ; Initialize the keyboard.
                            	   158: ;
                            	   159: ; Parameters:
                            	   160: ;		none
                            	   161: ;	Modifies:
                            	   162: ;		none
                            	   163: ; Returns:
                            	   164: ;		none
                            	   165: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   166: 
                            	   167: _KeybdInit:
                            	   168: KeybdInit:
                            	   169: ;	movem.l	d0/d1/d3/a1,-(a7)
00:000006B4 42390010000F    	   170: 	clr.b	_KeyState1		; records key up/down state
00:000006BA 423900100010    	   171: 	clr.b	_KeyState2		; records shift,ctrl,alt state
00:000006C0 4E75            	   172: 	rts
                            	   173: 
00:000006C2 6100049A        	   174: 	bsr			Wait300ms
00:000006C6 610000FE        	   175: 	bsr			_KeybdGetStatus	; wait for response from keyboard
00:000006CA 4A01            	   176: 	tst.b		d1
00:000006CC 6A10            	   177: 	bpl			.0001					; is input buffer full ? no, branch
00:000006CE 61000114        	   178: 	bsr	_KeybdGetScancode
00:000006D2 6100012E        	   179: 	bsr _KeybdClearIRQ
00:000006D6 0C0100AA        	   180: 	cmpi.b	#$AA,d1				; keyboard Okay
00:000006DA 67000098        	   181: 	beq			kbdi0005
                            	   182: .0001:
00:000006DE 760A            	   183: 	moveq		#10,d3
                            	   184: kbdi0002:
00:000006E0 61000460        	   185: 	bsr			Wait10ms
00:000006E4 4239FD0FFE01    	   186: 	clr.b		KEYBD+1				; clear receive register (write $00 to status reg)
00:000006EA 61001CEC        	   187: 	bsr net_delay
00:000006EE 72FF            	   188: 	moveq		#-1,d1				; send reset code to keyboard
00:000006F0 13C1FD0FFE01    	   189: 	move.b	d1,KEYBD+1		; write $FF to status reg to clear TX state
00:000006F6 61001CE0        	   190: 	bsr net_delay
00:000006FA 6100043E        	   191: 	bsr			KeybdSendByte	; now write ($FF) to transmit register for reset
00:000006FE 6100013A        	   192: 	bsr			KeybdWaitTx		; wait until no longer busy
00:00000702 4A81            	   193: 	tst.l		d1
00:00000704 6B000088        	   194: 	bmi			kbdiXmitBusy
00:00000708 6100010E        	   195: 	bsr			KeybdRecvByte	; look for an ACK ($FA)
00:0000070C 0C0100FA        	   196: 	cmpi.b	#$FA,d1
00:00000710 6604            	   197: 	bne			.0001
00:00000712 61000104        	   198: 	bsr			KeybdRecvByte	; look for BAT completion code ($AA)
                            	   199: .0001:
00:00000716 0C0100FC        	   200: 	cmpi.b	#$FC,d1				; reset error ?
00:0000071A 672E            	   201: 	beq			kbdiTryAgain
00:0000071C 0C0100AA        	   202: 	cmpi.b	#$AA,d1				; reset complete okay ?
00:00000720 6628            	   203: 	bne			kbdiTryAgain
                            	   204: 
                            	   205: 	; After a reset, scan code set #2 should be active
                            	   206: .config:
00:00000722 323C00F0        	   207: 	move.w	#$F0,d1			; send scan code select
00:00000726 13C1FD0FFF00    	   208: 	move.b	d1,leds
00:0000072C 61001CAA        	   209: 	bsr net_delay
00:00000730 61000408        	   210: 	bsr			KeybdSendByte
00:00000734 61000104        	   211: 	bsr			KeybdWaitTx
00:00000738 4A81            	   212: 	tst.l		d1
00:0000073A 6B52            	   213: 	bmi			kbdiXmitBusy
00:0000073C 610000DA        	   214: 	bsr			KeybdRecvByte	; wait for response from keyboard
00:00000740 4A41            	   215: 	tst.w		d1
00:00000742 6B06            	   216: 	bmi			kbdiTryAgain
00:00000744 0C0100FA        	   217: 	cmpi.b	#$FA,d1				; ACK
00:00000748 670E            	   218: 	beq			kbdi0004
                            	   219: kbdiTryAgain:
00:0000074A 51CBFF94        	   220: 	dbra		d3,kbdi0002
                            	   221: .keybdErr:
00:0000074E 43FA004C        	   222: 	lea			msgBadKeybd,a1
00:00000752 610073A6        	   223: 	bsr			DisplayStringCRLF
00:00000756 6020            	   224: 	bra			ledxit
                            	   225: kbdi0004:
00:00000758 7202            	   226: 	moveq		#2,d1			; select scan code set #2
00:0000075A 610003DE        	   227: 	bsr			KeybdSendByte
00:0000075E 610000DA        	   228: 	bsr			KeybdWaitTx
00:00000762 4A81            	   229: 	tst.l		d1
00:00000764 6B28            	   230: 	bmi			kbdiXmitBusy
00:00000766 610000B0        	   231: 	bsr			KeybdRecvByte	; wait for response from keyboard
00:0000076A 4A41            	   232: 	tst.w		d1
00:0000076C 6BDC            	   233: 	bmi			kbdiTryAgain
00:0000076E 0C0100FA        	   234: 	cmpi.b	#$FA,d1
00:00000772 66D6            	   235: 	bne			kbdiTryAgain
                            	   236: kbdi0005:
00:00000774 6100FED4        	   237: 	bsr			KeybdGetID
                            	   238: ledxit:
00:00000778 7207            	   239: 	moveq		#$07,d1
00:0000077A 6100FF0C        	   240: 	bsr			KeybdSetLED
00:0000077E 610003DE        	   241: 	bsr			Wait300ms
00:00000782 7200            	   242: 	moveq		#$00,d1
00:00000784 6100FF02        	   243: 	bsr			KeybdSetLED
00:00000788 4CDF020B        	   244: 	movem.l	(a7)+,d0/d1/d3/a1
00:0000078C 4E75            	   245: 	rts
                            	   246: kbdiXmitBusy:
00:0000078E 43FA001B        	   247: 	lea			msgXmitBusy,a1
00:00000792 61007366        	   248: 	bsr			DisplayStringCRLF
00:00000796 4CDF020B        	   249: 	movem.l	(a7)+,d0/d1/d3/a1
00:0000079A 4E75            	   250: 	rts
                            	   251: 	
                            	   252: msgBadKeybd:
00:0000079C 4B6579626F617264	   253: 	dc.b		"Keyboard error",0
00:000007A4 206572726F72
00:000007AA 00
                            	   254: msgXmitBusy:
00:000007AB 4B6579626F617264	   255: 	dc.b		"Keyboard transmitter stuck",0
00:000007B3 207472616E736D69
00:000007BB 7474657220737475
00:000007C3 636B
00:000007C5 00
                            	   256: 
                            	   257: 	even
                            	   258: _KeybdGetStatus:
00:000007C6 4E7A1FE0        	   259: 	movec coreno,d1
00:000007CA 0C010002        	   260: 	cmpi.b #2,d1
00:000007CE 660A            	   261: 	bne .0001
00:000007D0 7200            	   262: 	moveq	#0,d1
00:000007D2 1239FD0FFE01    	   263: 	move.b KEYBD+1,d1
00:000007D8 4E75            	   264: 	rts
                            	   265: .0001:
00:000007DA 7200            	   266: 	moveq #0,d1
00:000007DC 1239FD0FFE03    	   267: 	move.b KEYBD+3,d1
00:000007E2 4E75            	   268: 	rts
                            	   269: 
                            	   270: ; Get the scancode from the keyboard port
                            	   271: 
                            	   272: _KeybdGetScancode:
00:000007E4 4E7A1FE0        	   273: 	movec coreno,d1
00:000007E8 0C010002        	   274: 	cmpi.b #2,d1
00:000007EC 660A            	   275: 	bne .0001
00:000007EE 7200            	   276: 	moveq		#0,d1
00:000007F0 1239FD0FFE00    	   277: 	move.b	KEYBD,d1				; get the scan code
00:000007F6 4E75            	   278: 	rts
                            	   279: .0001:
00:000007F8 7200            	   280: 	moveq #0,d1
00:000007FA 1239FD0FFE02    	   281: 	move.b KEYBD+2,d1
00:00000800 4E75            	   282: 	rts
                            	   283: 
                            	   284: _KeybdClearIRQ:
00:00000802 2F01            	   285: 	move.l d1,-(a7)
00:00000804 4E7A1FE0        	   286: 	movec coreno,d1
00:00000808 0C010002        	   287: 	cmpi.b #2,d1
00:0000080C 6606            	   288: 	bne .0001
00:0000080E 4239FD0FFE01    	   289: 	move.b	#0,KEYBD+1			; clear receive register
                            	   290: .0001:
00:00000814 221F            	   291: 	move.l (a7)+,d1
00:00000816 4E75            	   292: 	rts
                            	   293: 
                            	   294: ; Recieve a byte from the keyboard, used after a command is sent to the
                            	   295: ; keyboard in order to wait for a response.
                            	   296: ;
                            	   297: KeybdRecvByte:
00:00000818 2F03            	   298: 	move.l	d3,-(a7)
00:0000081A 363C0064        	   299: 	move.w	#100,d3		; wait up to 1s
                            	   300: .0003:
00:0000081E 61A6            	   301: 	bsr			_KeybdGetStatus	; wait for response from keyboard
00:00000820 4A01            	   302: 	tst.b		d1
00:00000822 6B0E            	   303: 	bmi			.0004			; is input buffer full ? yes, branch
00:00000824 6100031C        	   304: 	bsr			Wait10ms	; wait a bit
00:00000828 51CBFFF4        	   305: 	dbra		d3,.0003	; go back and try again
00:0000082C 261F            	   306: 	move.l	(a7)+,d3
00:0000082E 72FF            	   307: 	moveq		#-1,d1		; return -1
00:00000830 4E75            	   308: 	rts
                            	   309: .0004:
00:00000832 61B0            	   310: 	bsr	_KeybdGetScancode
00:00000834 61CC            	   311: 	bsr _KeybdClearIRQ
00:00000836 261F            	   312: 	move.l	(a7)+,d3
00:00000838 4E75            	   313: 	rts
                            	   314: 
                            	   315: 
                            	   316: ; Wait until the keyboard transmit is complete
                            	   317: ; Returns -1 if timedout, 0 if transmit completed
                            	   318: ;
                            	   319: KeybdWaitTx:
00:0000083A 48E73000        	   320: 	movem.l	d2/d3,-(a7)
00:0000083E 7664            	   321: 	moveq		#100,d3		; wait a max of 1s
                            	   322: .0001:
00:00000840 6184            	   323: 	bsr	_KeybdGetStatus
00:00000842 08010006        	   324: 	btst #6,d1				; check for transmit complete bit
00:00000846 6610            	   325: 	bne	.0002					; branch if bit set
00:00000848 610002F8        	   326: 	bsr	Wait10ms			; delay a little bit
00:0000084C 51CBFFF2        	   327: 	dbra d3,.0001			; go back and try again
00:00000850 4CDF000C        	   328: 	movem.l	(a7)+,d2/d3
00:00000854 72FF            	   329: 	moveq	#-1,d1			; return -1
00:00000856 4E75            	   330: 	rts
                            	   331: .0002:
00:00000858 4CDF000C        	   332: 	movem.l	(a7)+,d2/d3
00:0000085C 7200            	   333: 	moveq	#0,d1		; return 0
00:0000085E 4E75            	   334: 	rts
                            	   335: 
                            	   336: ;------------------------------------------------------------------------------
                            	   337: ; d1.b 0=echo off, non-zero = echo on
                            	   338: ;------------------------------------------------------------------------------
                            	   339: 
                            	   340: SetKeyboardEcho:
00:00000860 13C10004000C    	   341: 	move.b	d1,KeybdEcho
00:00000866 4E75            	   342: 	rts
                            	   343: 
                            	   344: ;------------------------------------------------------------------------------
                            	   345: ; Get key pending status into d1.b
                            	   346: ;
                            	   347: ; Returns:
                            	   348: ;		d1.b = 1 if a key is available, otherwise zero.
                            	   349: ;------------------------------------------------------------------------------
                            	   350: 
                            	   351: CheckForKey:
00:00000868 7200            	   352: 	moveq.l	#0,d1					; clear high order bits
                            	   353: ;	move.b	KEYBD+1,d1		; get keyboard port status
                            	   354: ;	smi.b		d1						; set true/false
                            	   355: ;	andi.b	#1,d1					; return true (1) if key available, 0 otherwise
00:0000086A 4A3900100013    	   356: 	tst.b	_KeybdCnt
00:00000870 56C1            	   357: 	sne.b	d1
00:00000872 4E75            	   358: 	rts
                            	   359: 
                            	   360: ;------------------------------------------------------------------------------
                            	   361: ; GetKey
                            	   362: ; 	Get a character from the keyboard. 
                            	   363: ;
                            	   364: ; Modifies:
                            	   365: ;		d1
                            	   366: ; Returns:
                            	   367: ;		d1 = -1 if no key available or not in focus, otherwise key
                            	   368: ;------------------------------------------------------------------------------
                            	   369: 
                            	   370: GetKey:
00:00000874 2F00            	   371: 	move.l	d0,-(a7)					; push d0
00:00000876 123900100000    	   372: 	move.b	IOFocus,d1				; Check if the core has the IO focus
00:0000087C 4E7A0FE0        	   373: 	movec.l	coreno,d0
00:00000880 B200            	   374: 	cmp.b	d0,d1
00:00000882 6624            	   375: 	bne.s	.0004								; go return no key available, if not in focus
00:00000884 6138            	   376: 	bsr	KeybdGetCharNoWait		; get a character
00:00000886 4A81            	   377: 	tst.l	d1									; was a key available?
00:00000888 6B1E            	   378: 	bmi.s	.0004
00:0000088A 4A390004000C    	   379: 	tst.b	KeybdEcho						; is keyboard echo on ?
00:00000890 6712            	   380: 	beq.s	.0003								; no echo, just return the key
00:00000892 0C01000D        	   381: 	cmpi.b #CR,d1							; convert CR keystroke into CRLF
00:00000896 6606            	   382: 	bne.s	.0005
00:00000898 61007230        	   383: 	bsr	CRLF
00:0000089C 6006            	   384: 	bra.s	.0003
                            	   385: .0005:
00:0000089E 4EB900009B8A    	   386: 	bsr	OutputChar
                            	   387: .0003:
00:000008A4 201F            	   388: 	move.l (a7)+,d0						; pop d0
00:000008A6 4E75            	   389: 	rts												; return key
                            	   390: ; Return -1 indicating no char was available
                            	   391: .0004:
00:000008A8 201F            	   392: 	move.l (a7)+,d0						; pop d0
00:000008AA 72FF            	   393: 	moveq	#-1,d1							; return no key available
00:000008AC 4E75            	   394: 	rts
                            	   395: 
                            	   396: ;------------------------------------------------------------------------------
                            	   397: ; Check for the cntrl-C keyboard sequence. Abort running routine and drop
                            	   398: ; back into the monitor.
                            	   399: ;------------------------------------------------------------------------------
                            	   400: 
                            	   401: CheckForCtrlC:
00:000008AE 2F01            	   402: 	move.l d1,-(a7)
00:000008B0 610C            	   403: 	bsr	KeybdGetCharNoWait
00:000008B2 0C010003        	   404: 	cmpi.b #CTRLC,d1
00:000008B6 67007880        	   405: 	beq	Monitor
00:000008BA 221F            	   406: 	move.l (a7)+,d1
00:000008BC 4E75            	   407: 	rts
                            	   408: 
                            	   409: ;------------------------------------------------------------------------------
                            	   410: ;------------------------------------------------------------------------------
                            	   411: 
                            	   412: KeybdGetCharNoWait:
00:000008BE 42390004000D    	   413: 	clr.b	KeybdWaitFlag
00:000008C4 6008            	   414: 	bra	KeybdGetChar
                            	   415: 
                            	   416: KeybdGetCharWait:
00:000008C6 13FC00FF0004000D	   417: 	move.b #-1,KeybdWaitFlag
                            	   418: 
                            	   419: KeybdGetChar:
00:000008CE 48E7B080        	   420: 	movem.l	d0/d2/d3/a0,-(a7)
                            	   421: .0003:
00:000008D2 4E7A0FE0        	   422: 	movec	coreno,d0
00:000008D6 4840            	   423: 	swap d0
00:000008D8 7203            	   424: 	moveq	#KEYBD_SEMA,d1
00:000008DA 61001CA2        	   425: 	bsr	LockSemaphore
00:000008DE 143900100013    	   426: 	move.b	_KeybdCnt,d2		; get count of buffered scan codes
00:000008E4 673E            	   427: 	beq.s		.0015						;
00:000008E6 143900100011    	   428: 	move.b	_KeybdHead,d2		; d2 = buffer head
00:000008EC 4882            	   429: 	ext.w		d2
00:000008EE 41F900100020    	   430: 	lea			_KeybdBuf,a0		; a0 = pointer to keyboard buffer
00:000008F4 7200            	   431: 	clr.l		d1
00:000008F6 12302000        	   432: 	move.b	(a0,d2.w),d1		; d1 = scan code from buffer
00:000008FA 5202            	   433: 	addi.b	#1,d2						; increment keyboard head index
00:000008FC 0202001F        	   434: 	andi.b	#31,d2					; and wrap around at buffer size
00:00000900 13C200100011    	   435: 	move.b	d2,_KeybdHead
00:00000906 533900100013    	   436: 	subi.b	#1,_KeybdCnt		; decrement count of scan codes in buffer
00:0000090C C342            	   437: 	exg			d1,d2						; save scancode value in d2
00:0000090E 4E7A0FE0        	   438: 	movec		coreno,d0
00:00000912 4840            	   439: 	swap		d0
00:00000914 7203            	   440: 	moveq		#KEYBD_SEMA,d1
00:00000916 61001CA2        	   441: 	bsr			UnlockSemaphore
00:0000091A C541            	   442: 	exg			d2,d1						; restore scancode value
00:0000091C 602A            	   443: 	bra			.0001						; go process scan code
                            	   444: .0014:
00:0000091E 6100FEA6        	   445: 	bsr		_KeybdGetStatus		; check keyboard status for key available
00:00000922 6B1C            	   446: 	bmi		.0006							; yes, go process
                            	   447: .0015:
00:00000924 4E7A0FE0        	   448: 	movec		coreno,d0
00:00000928 4840            	   449: 	swap		d0
00:0000092A 7203            	   450: 	moveq		#KEYBD_SEMA,d1
00:0000092C 61001C8C        	   451: 	bsr			UnlockSemaphore
00:00000930 4A390004000D    	   452: 	tst.b		KeybdWaitFlag			; are we willing to wait for a key ?
00:00000936 6B9A            	   453: 	bmi			.0003							; yes, branch back
00:00000938 4CDF010D        	   454: 	movem.l	(a7)+,d0/d2/d3/a0
00:0000093C 72FF            	   455: 	moveq		#-1,d1						; flag no char available
00:0000093E 4E75            	   456: 	rts
                            	   457: .0006:
00:00000940 6100FEA2        	   458: 	bsr	_KeybdGetScancode
00:00000944 6100FEBC        	   459: 	bsr _KeybdClearIRQ
                            	   460: .0001:
00:00000948 33FC0001FD0FFF00	   461: 	move.w	#1,leds
00:00000950 B23C00F0        	   462: 	cmp.b	#SC_KEYUP,d1
00:00000954 670000C0        	   463: 	beq		.doKeyup
00:00000958 B23C00E0        	   464: 	cmp.b	#SC_EXTEND,d1
00:0000095C 670000C4        	   465: 	beq		.doExtend
00:00000960 B23C0014        	   466: 	cmp.b	#SC_CTRL,d1
00:00000964 670000C8        	   467: 	beq		.doCtrl
00:00000968 B23C0012        	   468: 	cmp.b	#SC_LSHIFT,d1
00:0000096C 6700012A        	   469: 	beq		.doShift
00:00000970 B23C0059        	   470: 	cmp.b	#SC_RSHIFT,d1
00:00000974 67000122        	   471: 	beq		.doShift
00:00000978 B23C0077        	   472: 	cmp.b	#SC_NUMLOCK,d1
00:0000097C 67000142        	   473: 	beq		.doNumLock
00:00000980 B23C0058        	   474: 	cmp.b	#SC_CAPSLOCK,d1
00:00000984 67000148        	   475: 	beq		.doCapsLock
00:00000988 B23C007E        	   476: 	cmp.b	#SC_SCROLLLOCK,d1
00:0000098C 6700014E        	   477: 	beq		.doScrollLock
00:00000990 B23C0011        	   478: 	cmp.b   #SC_ALT,d1
00:00000994 670000C0        	   479: 	beq     .doAlt
00:00000998 14390010000F    	   480: 	move.b	_KeyState1,d2			; check key up/down
00:0000099E 42390010000F    	   481: 	move.b	#0,_KeyState1			; clear keyup status
00:000009A4 4A02            	   482: 	tst.b	d2
00:000009A6 6600FF2A        	   483: 	bne	    .0003					; ignore key up
00:000009AA B23C000D        	   484: 	cmp.b   #SC_TAB,d1
00:000009AE 670000CE        	   485: 	beq     .doTab
                            	   486: .0013:
00:000009B2 143900100010    	   487: 	move.b	_KeyState2,d2
00:000009B8 6A1A            	   488: 	bpl		.0010					; is it extended code ?
00:000009BA C43C007F        	   489: 	and.b	#$7F,d2					; clear extended bit
00:000009BE 13C200100010    	   490: 	move.b	d2,_KeyState2
00:000009C4 42390010000F    	   491: 	move.b	#0,_KeyState1			; clear keyup
00:000009CA 41FA04E4        	   492: 	lea		_keybdExtendedCodes,a0
00:000009CE 12301000        	   493: 	move.b	(a0,d1.w),d1
00:000009D2 6034            	   494: 	bra		.0008
                            	   495: .0010:
00:000009D4 08020002        	   496: 	btst	#2,d2					; is it CTRL code ?
00:000009D8 670E            	   497: 	beq		.0009
00:000009DA C27C007F        	   498: 	and.w	#$7F,d1
00:000009DE 41FA0450        	   499: 	lea		_keybdControlCodes,a0
00:000009E2 12301000        	   500: 	move.b	(a0,d1.w),d1
00:000009E6 6020            	   501: 	bra		.0008
                            	   502: .0009:
00:000009E8 08020000        	   503: 	btst	#0,d2					; is it shift down ?
00:000009EC 670A            	   504: 	beq  	.0007
00:000009EE 41FA0340        	   505: 	lea		_shiftedScanCodes,a0
00:000009F2 12301000        	   506: 	move.b	(a0,d1.w),d1
00:000009F6 6010            	   507: 	bra		.0008
                            	   508: .0007:
00:000009F8 41FA0236        	   509: 	lea		_unshiftedScanCodes,a0
00:000009FC 12301000        	   510: 	move.b	(a0,d1.w),d1
00:00000A00 33FC0202FD0FFF00	   511: 	move.w	#$0202,leds
                            	   512: .0008:
00:00000A08 33FC0303FD0FFF00	   513: 	move.w	#$0303,leds
00:00000A10 4CDF010D        	   514: 	movem.l	(a7)+,d0/d2/d3/a0
00:00000A14 4E75            	   515: 	rts
                            	   516: .doKeyup:
00:00000A16 13FC00FF0010000F	   517: 	move.b	#-1,_KeyState1
00:00000A1E 6000FEB2        	   518: 	bra		.0003
                            	   519: .doExtend:
00:00000A22 0039008000100010	   520: 	or.b	#$80,_KeyState2
00:00000A2A 6000FEA6        	   521: 	bra		.0003
                            	   522: .doCtrl:
00:00000A2E 12390010000F    	   523: 	move.b	_KeyState1,d1
00:00000A34 42390010000F    	   524: 	clr.b	_KeyState1
00:00000A3A 4A01            	   525: 	tst.b	d1
00:00000A3C 6A0C            	   526: 	bpl.s	.0004
00:00000A3E 08B9000200100010	   527: 	bclr	#2,_KeyState2
00:00000A46 6000FE8A        	   528: 	bra		.0003
                            	   529: .0004:
00:00000A4A 08F9000200100010	   530: 	bset	#2,_KeyState2
00:00000A52 6000FE7E        	   531: 	bra		.0003
                            	   532: .doAlt:
00:00000A56 12390010000F    	   533: 	move.b	_KeyState1,d1
00:00000A5C 42390010000F    	   534: 	clr.b	_KeyState1
00:00000A62 4A01            	   535: 	tst.b	d1
00:00000A64 6A0C            	   536: 	bpl		.0011
00:00000A66 08B9000100100010	   537: 	bclr	#1,_KeyState2
00:00000A6E 6000FE62        	   538: 	bra		.0003
                            	   539: .0011:
00:00000A72 08F9000100100010	   540: 	bset	#1,_KeyState2
00:00000A7A 6000FE56        	   541: 	bra		.0003
                            	   542: .doTab:
00:00000A7E 2F01            	   543: 	move.l	d1,-(a7)
00:00000A80 123900100010    	   544:   move.b  _KeyState2,d1
00:00000A86 08010001        	   545:   btst	#1,d1                 ; is ALT down ?
00:00000A8A 6706            	   546:   beq     .0012
                            	   547: ;    	inc     _iof_switch
00:00000A8C 221F            	   548:   move.l	(a7)+,d1
00:00000A8E 6000FE42        	   549:   bra     .0003
                            	   550: .0012:
00:00000A92 221F            	   551:   move.l	(a7)+,d1
00:00000A94 6000FF1C        	   552:   bra     .0013
                            	   553: .doShift:
00:00000A98 12390010000F    	   554: 	move.b	_KeyState1,d1
00:00000A9E 42390010000F    	   555: 	clr.b	_KeyState1
00:00000AA4 4A01            	   556: 	tst.b	d1
00:00000AA6 6A0C            	   557: 	bpl.s	.0005
00:00000AA8 08B9000000100010	   558: 	bclr	#0,_KeyState2
00:00000AB0 6000FE20        	   559: 	bra		.0003
                            	   560: .0005:
00:00000AB4 08F9000000100010	   561: 	bset	#0,_KeyState2
00:00000ABC 6000FE14        	   562: 	bra		.0003
                            	   563: .doNumLock:
00:00000AC0 0879000400100010	   564: 	bchg	#4,_KeyState2
00:00000AC8 6120            	   565: 	bsr		KeybdSetLEDStatus
00:00000ACA 6000FE06        	   566: 	bra		.0003
                            	   567: .doCapsLock:
00:00000ACE 0879000500100010	   568: 	bchg	#5,_KeyState2
00:00000AD6 6112            	   569: 	bsr		KeybdSetLEDStatus
00:00000AD8 6000FDF8        	   570: 	bra		.0003
                            	   571: .doScrollLock:
00:00000ADC 0879000600100010	   572: 	bchg	#6,_KeyState2
00:00000AE4 6104            	   573: 	bsr		KeybdSetLEDStatus
00:00000AE6 6000FDEA        	   574: 	bra		.0003
                            	   575: 
                            	   576: KeybdSetLEDStatus:
00:00000AEA 48E73000        	   577: 	movem.l	d2/d3,-(a7)
00:00000AEE 42390010000E    	   578: 	clr.b		KeybdLEDs
00:00000AF4 0839000400100010	   579: 	btst		#4,_KeyState2
00:00000AFC 6708            	   580: 	beq.s		.0002
00:00000AFE 13FC00020010000E	   581: 	move.b	#2,KeybdLEDs
                            	   582: .0002:
00:00000B06 0839000500100010	   583: 	btst		#5,_KeyState2
00:00000B0E 6708            	   584: 	beq.s		.0003
00:00000B10 08F900020010000E	   585: 	bset		#2,KeybdLEDs
                            	   586: .0003:
00:00000B18 0839000600100010	   587: 	btst		#6,_KeyState2
00:00000B20 6708            	   588: 	beq.s		.0004
00:00000B22 08F900000010000E	   589: 	bset		#0,KeybdLEDs
                            	   590: .0004:
00:00000B2A 12390010000E    	   591: 	move.b	KeybdLEDs,d1
00:00000B30 6100FB56        	   592: 	bsr			KeybdSetLED
00:00000B34 4CDF000C        	   593: 	movem.l	(a7)+,d2/d3
00:00000B38 4E75            	   594: 	rts
                            	   595: 
                            	   596: KeybdSendByte:
00:00000B3A 13C1FD0FFE00    	   597: 	move.b d1,KEYBD
00:00000B40 4E75            	   598: 	rts
                            	   599: 	
                            	   600: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   601: ; Wait for 10 ms
                            	   602: ;
                            	   603: ; Parameters: none
                            	   604: ; Returns: none
                            	   605: ; Modifies: none
                            	   606: ; Stack Space: 2 long words
                            	   607: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   608: 
                            	   609: Wait10ms:
00:00000B42 48E7C000        	   610: 	movem.l	d0/d1,-(a7)
00:00000B46 4E7A0FF0        	   611: 	movec	tick,d0
00:00000B4A 068000061A80    	   612: 	addi.l #400000,d0			; 400,000 cycles at 40MHz
                            	   613: .0001:
00:00000B50 4E7A1FF0        	   614: 	movec	tick,d1
00:00000B54 B081            	   615: 	cmp.l	d1,d0
00:00000B56 62F8            	   616: 	bhi	.0001
00:00000B58 4CDF0003        	   617: 	movem.l	(a7)+,d0/d1
00:00000B5C 4E75            	   618: 	rts
                            	   619: 
                            	   620: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   621: ; Wait for 300 ms
                            	   622: ;
                            	   623: ; Parameters: none
                            	   624: ; Returns: none
                            	   625: ; Modifies: none
                            	   626: ; Stack Space: 2 long words
                            	   627: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   628: 
                            	   629: Wait300ms:
00:00000B5E 48E7C000        	   630: 	movem.l	d0/d1,-(a7)
00:00000B62 4E7A0FF0        	   631: 	movec		tick,d0
00:00000B66 068000B71B00    	   632: 	addi.l	#12000000,d0			; 12,000,000 cycles at 40MHz
                            	   633: .0001:
00:00000B6C 4E7A1FF0        	   634: 	movec		tick,d1
00:00000B70 B081            	   635: 	cmp.l		d1,d0
00:00000B72 62F8            	   636: 	bhi			.0001
00:00000B74 4CDF0003        	   637: 	movem.l	(a7)+,d0/d1
00:00000B78 4E75            	   638: 	rts
                            	   639: 
                            	   640: ;--------------------------------------------------------------------------
                            	   641: ; Keyboard IRQ routine.
                            	   642: ; - only core 2 processes keyboard interrupts.
                            	   643: ; - the keyboard buffer is in shared global scratchpad space.
                            	   644: ;
                            	   645: ; Returns:
                            	   646: ; 	d1 = -1 if keyboard routine handled interrupt, otherwise positive.
                            	   647: ;--------------------------------------------------------------------------
                            	   648: 
                            	   649: KeybdIRQ:
00:00000B7A 46FC2600        	   650: 	move.w #$2600,sr					; disable lower interrupts
00:00000B7E 48E7C080        	   651: 	movem.l	d0/d1/a0,-(a7)
00:00000B82 46B9FD000000    	   652: 	eori.l #-1,$FD000000
00:00000B88 7200            	   653: 	moveq	#0,d1								; check if keyboard IRQ
00:00000B8A 1239FD0FFE01    	   654: 	move.b KEYBD+1,d1					; get status reg
00:00000B90 4A01            	   655: 	tst.b	d1
00:00000B92 6A000096        	   656: 	bpl	.0001									; branch if not keyboard
00:00000B96 4E7A0FE0        	   657: 	movec	coreno,d0
00:00000B9A 4840            	   658: 	swap d0
00:00000B9C 7203            	   659: 	moveq	#KEYBD_SEMA,d1
00:00000B9E 610019DE        	   660: 	bsr LockSemaphore
00:00000BA2 1239FD0FFE00    	   661: 	move.b KEYBD,d1						; get scan code
00:00000BA8 4239FD0FFE01    	   662: 	clr.b KEYBD+1							; clear status register (clears IRQ AND scancode)
00:00000BAE 0839000100100010	   663: 	btst #1,_KeyState2				; Is Alt down?
00:00000BB6 6738            	   664: 	beq.s	.0003
00:00000BB8 0C01000D        	   665: 	cmpi.b #SC_TAB,d1					; is Alt-Tab?
00:00000BBC 6632            	   666: 	bne.s	.0003
00:00000BBE 4E7A0FF0        	   667: 	movec tick,d0
00:00000BC2 90B90001001C    	   668: 	sub.l _Keybd_tick,d0
00:00000BC8 B0BC0000000A    	   669: 	cmp.l #10,d0							; has it been 10 or more ticks?
                            	   670: ;	blo.s .0002
00:00000BCE 4E7A0FF0        	   671: 	movec tick,d0							; update tick of last ALT-Tab
00:00000BD2 23C00001001C    	   672: 	move.l d0,_Keybd_tick
00:00000BD8 6100740C        	   673: 	bsr	rotate_iofocus
00:00000BDC 423900100011    	   674: 	clr.b	_KeybdHead					; clear keyboard buffer
00:00000BE2 423900100012    	   675: 	clr.b	_KeybdTail
00:00000BE8 423900100013    	   676: 	clr.b	_KeybdCnt
00:00000BEE 602E            	   677: 	bra	.0002									; do not store Alt-Tab
                            	   678: .0003:
                            	   679: 	; Insert keyboard scan code into raw keyboard buffer
00:00000BF0 0C39002000100013	   680: 	cmpi.b #32,_KeybdCnt			; see if keyboard buffer full
00:00000BF8 6424            	   681: 	bhs.s	.0002
00:00000BFA 103900100012    	   682: 	move.b _KeybdTail,d0			; keyboard buffer not full, add to tail
00:00000C00 4880            	   683: 	ext.w	d0
00:00000C02 41F900100020    	   684: 	lea	_KeybdBuf,a0					; a0 = pointer to buffer
00:00000C08 11810000        	   685: 	move.b d1,(a0,d0.w)				; put scancode in buffer
00:00000C0C 5200            	   686: 	addi.b #1,d0							; increment tail index
00:00000C0E 0200001F        	   687: 	andi.b #31,d0							; wrap at buffer limit
00:00000C12 13C000100012    	   688: 	move.b d0,_KeybdTail			; update tail index
00:00000C18 523900100013    	   689: 	addi.b #1,_KeybdCnt				; increment buffer count
                            	   690: .0002:
00:00000C1E 4E7A0FE0        	   691: 	movec	coreno,d0
00:00000C22 4840            	   692: 	swap d0
00:00000C24 7203            	   693: 	moveq	#KEYBD_SEMA,d1
00:00000C26 61001992        	   694: 	bsr	UnlockSemaphore
                            	   695: .0001:
00:00000C2A 4CDF0103        	   696: 	movem.l	(a7)+,d0/d1/a0		; return
00:00000C2E 4E73            	   697: 	rte
                            	   698: 
                            	   699: ;--------------------------------------------------------------------------
                            	   700: ; PS2 scan codes to ascii conversion tables.
                            	   701: ;--------------------------------------------------------------------------
                            	   702: ;
                            	   703: _unshiftedScanCodes:
00:00000C30 2E              	   704: 	dc.b	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
00:00000C31 A9
00:00000C32 2E
00:00000C33 A5
00:00000C34 A3
00:00000C35 A1
00:00000C36 A2
00:00000C37 AC
00:00000C38 2E              	   705: 	dc.b	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
00:00000C39 AA
00:00000C3A A8
00:00000C3B A6
00:00000C3C A4
00:00000C3D 09
00:00000C3E 60
00:00000C3F 2E
00:00000C40 2E              	   706: 	dc.b	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
00:00000C41 2E
00:00000C42 2E
00:00000C43 2E
00:00000C44 2E
00:00000C45 71
00:00000C46 31
00:00000C47 2E
00:00000C48 2E              	   707: 	dc.b	$2e,$2e,$7a,$73,$61,$77,$32,$2e
00:00000C49 2E
00:00000C4A 7A
00:00000C4B 73
00:00000C4C 61
00:00000C4D 77
00:00000C4E 32
00:00000C4F 2E
00:00000C50 2E              	   708: 	dc.b	$2e,$63,$78,$64,$65,$34,$33,$2e
00:00000C51 63
00:00000C52 78
00:00000C53 64
00:00000C54 65
00:00000C55 34
00:00000C56 33
00:00000C57 2E
00:00000C58 2E              	   709: 	dc.b	$2e,$20,$76,$66,$74,$72,$35,$2e
00:00000C59 20
00:00000C5A 76
00:00000C5B 66
00:00000C5C 74
00:00000C5D 72
00:00000C5E 35
00:00000C5F 2E
00:00000C60 2E              	   710: 	dc.b	$2e,$6e,$62,$68,$67,$79,$36,$2e
00:00000C61 6E
00:00000C62 62
00:00000C63 68
00:00000C64 67
00:00000C65 79
00:00000C66 36
00:00000C67 2E
00:00000C68 2E              	   711: 	dc.b	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
00:00000C69 2E
00:00000C6A 6D
00:00000C6B 6A
00:00000C6C 75
00:00000C6D 37
00:00000C6E 38
00:00000C6F 2E
00:00000C70 2E              	   712: 	dc.b	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
00:00000C71 2C
00:00000C72 6B
00:00000C73 69
00:00000C74 6F
00:00000C75 30
00:00000C76 39
00:00000C77 2E
00:00000C78 2E              	   713: 	dc.b	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
00:00000C79 2E
00:00000C7A 2F
00:00000C7B 6C
00:00000C7C 3B
00:00000C7D 70
00:00000C7E 2D
00:00000C7F 2E
00:00000C80 2E              	   714: 	dc.b	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
00:00000C81 2E
00:00000C82 27
00:00000C83 2E
00:00000C84 5B
00:00000C85 3D
00:00000C86 2E
00:00000C87 2E
00:00000C88 AD              	   715: 	dc.b	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
00:00000C89 2E
00:00000C8A 0D
00:00000C8B 5D
00:00000C8C 2E
00:00000C8D 5C
00:00000C8E 2E
00:00000C8F 2E
00:00000C90 2E              	   716: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:00000C91 2E
00:00000C92 2E
00:00000C93 2E
00:00000C94 2E
00:00000C95 2E
00:00000C96 08
00:00000C97 2E
00:00000C98 2E              	   717: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
00:00000C99 95
00:00000C9A 2E
00:00000C9B 93
00:00000C9C 94
00:00000C9D 2E
00:00000C9E 2E
00:00000C9F 2E
00:00000CA0 98              	   718: 	dc.b	$98,$7f,$92,$2e,$91,$90,$1b,$af
00:00000CA1 7F
00:00000CA2 92
00:00000CA3 2E
00:00000CA4 91
00:00000CA5 90
00:00000CA6 1B
00:00000CA7 AF
00:00000CA8 AB              	   719: 	dc.b	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
00:00000CA9 2E
00:00000CAA 97
00:00000CAB 2E
00:00000CAC 2E
00:00000CAD 96
00:00000CAE AE
00:00000CAF 2E
                            	   720: 
00:00000CB0 2E              	   721: 	dc.b	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
00:00000CB1 2E
00:00000CB2 2E
00:00000CB3 A7
00:00000CB4 2E
00:00000CB5 2E
00:00000CB6 2E
00:00000CB7 2E
00:00000CB8 2E              	   722: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CB9 2E
00:00000CBA 2E
00:00000CBB 2E
00:00000CBC 2E
00:00000CBD 2E
00:00000CBE 2E
00:00000CBF 2E
00:00000CC0 2E              	   723: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CC1 2E
00:00000CC2 2E
00:00000CC3 2E
00:00000CC4 2E
00:00000CC5 2E
00:00000CC6 2E
00:00000CC7 2E
00:00000CC8 2E              	   724: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CC9 2E
00:00000CCA 2E
00:00000CCB 2E
00:00000CCC 2E
00:00000CCD 2E
00:00000CCE 2E
00:00000CCF 2E
00:00000CD0 2E              	   725: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CD1 2E
00:00000CD2 2E
00:00000CD3 2E
00:00000CD4 2E
00:00000CD5 2E
00:00000CD6 2E
00:00000CD7 2E
00:00000CD8 2E              	   726: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CD9 2E
00:00000CDA 2E
00:00000CDB 2E
00:00000CDC 2E
00:00000CDD 2E
00:00000CDE 2E
00:00000CDF 2E
00:00000CE0 2E              	   727: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CE1 2E
00:00000CE2 2E
00:00000CE3 2E
00:00000CE4 2E
00:00000CE5 2E
00:00000CE6 2E
00:00000CE7 2E
00:00000CE8 2E              	   728: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CE9 2E
00:00000CEA 2E
00:00000CEB 2E
00:00000CEC 2E
00:00000CED 2E
00:00000CEE 2E
00:00000CEF 2E
00:00000CF0 2E              	   729: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CF1 2E
00:00000CF2 2E
00:00000CF3 2E
00:00000CF4 2E
00:00000CF5 2E
00:00000CF6 2E
00:00000CF7 2E
00:00000CF8 2E              	   730: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CF9 2E
00:00000CFA 2E
00:00000CFB 2E
00:00000CFC 2E
00:00000CFD 2E
00:00000CFE 2E
00:00000CFF 2E
00:00000D00 2E              	   731: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D01 2E
00:00000D02 2E
00:00000D03 2E
00:00000D04 2E
00:00000D05 2E
00:00000D06 2E
00:00000D07 2E
00:00000D08 2E              	   732: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D09 2E
00:00000D0A 2E
00:00000D0B 2E
00:00000D0C 2E
00:00000D0D 2E
00:00000D0E 2E
00:00000D0F 2E
00:00000D10 2E              	   733: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D11 2E
00:00000D12 2E
00:00000D13 2E
00:00000D14 2E
00:00000D15 2E
00:00000D16 2E
00:00000D17 2E
00:00000D18 2E              	   734: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D19 2E
00:00000D1A 2E
00:00000D1B 2E
00:00000D1C 2E
00:00000D1D 2E
00:00000D1E 2E
00:00000D1F 2E
00:00000D20 2E              	   735: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D21 2E
00:00000D22 2E
00:00000D23 2E
00:00000D24 2E
00:00000D25 2E
00:00000D26 2E
00:00000D27 2E
00:00000D28 2E              	   736: 	dc.b	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
00:00000D29 2E
00:00000D2A FA
00:00000D2B 2E
00:00000D2C 2E
00:00000D2D 2E
00:00000D2E 2E
00:00000D2F 2E
                            	   737: 
                            	   738: _shiftedScanCodes:
00:00000D30 2E              	   739: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D31 2E
00:00000D32 2E
00:00000D33 2E
00:00000D34 2E
00:00000D35 2E
00:00000D36 2E
00:00000D37 2E
00:00000D38 2E              	   740: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
00:00000D39 2E
00:00000D3A 2E
00:00000D3B 2E
00:00000D3C 2E
00:00000D3D 09
00:00000D3E 7E
00:00000D3F 2E
00:00000D40 2E              	   741: 	dc.b	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
00:00000D41 2E
00:00000D42 2E
00:00000D43 2E
00:00000D44 2E
00:00000D45 51
00:00000D46 21
00:00000D47 2E
00:00000D48 2E              	   742: 	dc.b	$2e,$2e,$5a,$53,$41,$57,$40,$2e
00:00000D49 2E
00:00000D4A 5A
00:00000D4B 53
00:00000D4C 41
00:00000D4D 57
00:00000D4E 40
00:00000D4F 2E
00:00000D50 2E              	   743: 	dc.b	$2e,$43,$58,$44,$45,$24,$23,$2e
00:00000D51 43
00:00000D52 58
00:00000D53 44
00:00000D54 45
00:00000D55 24
00:00000D56 23
00:00000D57 2E
00:00000D58 2E              	   744: 	dc.b	$2e,$20,$56,$46,$54,$52,$25,$2e
00:00000D59 20
00:00000D5A 56
00:00000D5B 46
00:00000D5C 54
00:00000D5D 52
00:00000D5E 25
00:00000D5F 2E
00:00000D60 2E              	   745: 	dc.b	$2e,$4e,$42,$48,$47,$59,$5e,$2e
00:00000D61 4E
00:00000D62 42
00:00000D63 48
00:00000D64 47
00:00000D65 59
00:00000D66 5E
00:00000D67 2E
00:00000D68 2E              	   746: 	dc.b	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
00:00000D69 2E
00:00000D6A 4D
00:00000D6B 4A
00:00000D6C 55
00:00000D6D 26
00:00000D6E 2A
00:00000D6F 2E
00:00000D70 2E              	   747: 	dc.b	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
00:00000D71 3C
00:00000D72 4B
00:00000D73 49
00:00000D74 4F
00:00000D75 29
00:00000D76 28
00:00000D77 2E
00:00000D78 2E              	   748: 	dc.b	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
00:00000D79 3E
00:00000D7A 3F
00:00000D7B 4C
00:00000D7C 3A
00:00000D7D 50
00:00000D7E 5F
00:00000D7F 2E
00:00000D80 2E              	   749: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
00:00000D81 2E
00:00000D82 22
00:00000D83 2E
00:00000D84 7B
00:00000D85 2B
00:00000D86 2E
00:00000D87 2E
00:00000D88 2E              	   750: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
00:00000D89 2E
00:00000D8A 0D
00:00000D8B 7D
00:00000D8C 2E
00:00000D8D 7C
00:00000D8E 2E
00:00000D8F 2E
00:00000D90 2E              	   751: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:00000D91 2E
00:00000D92 2E
00:00000D93 2E
00:00000D94 2E
00:00000D95 2E
00:00000D96 08
00:00000D97 2E
00:00000D98 2E              	   752: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D99 2E
00:00000D9A 2E
00:00000D9B 2E
00:00000D9C 2E
00:00000D9D 2E
00:00000D9E 2E
00:00000D9F 2E
00:00000DA0 2E              	   753: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
00:00000DA1 7F
00:00000DA2 2E
00:00000DA3 2E
00:00000DA4 2E
00:00000DA5 2E
00:00000DA6 1B
00:00000DA7 2E
00:00000DA8 2E              	   754: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DA9 2E
00:00000DAA 2E
00:00000DAB 2E
00:00000DAC 2E
00:00000DAD 2E
00:00000DAE 2E
00:00000DAF 2E
                            	   755: 
00:00000DB0 2E              	   756: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DB1 2E
00:00000DB2 2E
00:00000DB3 2E
00:00000DB4 2E
00:00000DB5 2E
00:00000DB6 2E
00:00000DB7 2E
00:00000DB8 2E              	   757: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DB9 2E
00:00000DBA 2E
00:00000DBB 2E
00:00000DBC 2E
00:00000DBD 2E
00:00000DBE 2E
00:00000DBF 2E
00:00000DC0 2E              	   758: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DC1 2E
00:00000DC2 2E
00:00000DC3 2E
00:00000DC4 2E
00:00000DC5 2E
00:00000DC6 2E
00:00000DC7 2E
00:00000DC8 2E              	   759: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DC9 2E
00:00000DCA 2E
00:00000DCB 2E
00:00000DCC 2E
00:00000DCD 2E
00:00000DCE 2E
00:00000DCF 2E
00:00000DD0 2E              	   760: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DD1 2E
00:00000DD2 2E
00:00000DD3 2E
00:00000DD4 2E
00:00000DD5 2E
00:00000DD6 2E
00:00000DD7 2E
00:00000DD8 2E              	   761: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DD9 2E
00:00000DDA 2E
00:00000DDB 2E
00:00000DDC 2E
00:00000DDD 2E
00:00000DDE 2E
00:00000DDF 2E
00:00000DE0 2E              	   762: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DE1 2E
00:00000DE2 2E
00:00000DE3 2E
00:00000DE4 2E
00:00000DE5 2E
00:00000DE6 2E
00:00000DE7 2E
00:00000DE8 2E              	   763: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DE9 2E
00:00000DEA 2E
00:00000DEB 2E
00:00000DEC 2E
00:00000DED 2E
00:00000DEE 2E
00:00000DEF 2E
00:00000DF0 2E              	   764: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DF1 2E
00:00000DF2 2E
00:00000DF3 2E
00:00000DF4 2E
00:00000DF5 2E
00:00000DF6 2E
00:00000DF7 2E
00:00000DF8 2E              	   765: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DF9 2E
00:00000DFA 2E
00:00000DFB 2E
00:00000DFC 2E
00:00000DFD 2E
00:00000DFE 2E
00:00000DFF 2E
00:00000E00 2E              	   766: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E01 2E
00:00000E02 2E
00:00000E03 2E
00:00000E04 2E
00:00000E05 2E
00:00000E06 2E
00:00000E07 2E
00:00000E08 2E              	   767: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E09 2E
00:00000E0A 2E
00:00000E0B 2E
00:00000E0C 2E
00:00000E0D 2E
00:00000E0E 2E
00:00000E0F 2E
00:00000E10 2E              	   768: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E11 2E
00:00000E12 2E
00:00000E13 2E
00:00000E14 2E
00:00000E15 2E
00:00000E16 2E
00:00000E17 2E
00:00000E18 2E              	   769: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E19 2E
00:00000E1A 2E
00:00000E1B 2E
00:00000E1C 2E
00:00000E1D 2E
00:00000E1E 2E
00:00000E1F 2E
00:00000E20 2E              	   770: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E21 2E
00:00000E22 2E
00:00000E23 2E
00:00000E24 2E
00:00000E25 2E
00:00000E26 2E
00:00000E27 2E
00:00000E28 2E              	   771: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E29 2E
00:00000E2A 2E
00:00000E2B 2E
00:00000E2C 2E
00:00000E2D 2E
00:00000E2E 2E
00:00000E2F 2E
                            	   772: 
                            	   773: ; control
                            	   774: _keybdControlCodes:
00:00000E30 2E              	   775: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E31 2E
00:00000E32 2E
00:00000E33 2E
00:00000E34 2E
00:00000E35 2E
00:00000E36 2E
00:00000E37 2E
00:00000E38 2E              	   776: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
00:00000E39 2E
00:00000E3A 2E
00:00000E3B 2E
00:00000E3C 2E
00:00000E3D 09
00:00000E3E 7E
00:00000E3F 2E
00:00000E40 2E              	   777: 	dc.b	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
00:00000E41 2E
00:00000E42 2E
00:00000E43 2E
00:00000E44 2E
00:00000E45 11
00:00000E46 21
00:00000E47 2E
00:00000E48 2E              	   778: 	dc.b	$2e,$2e,$1a,$13,$01,$17,$40,$2e
00:00000E49 2E
00:00000E4A 1A
00:00000E4B 13
00:00000E4C 01
00:00000E4D 17
00:00000E4E 40
00:00000E4F 2E
00:00000E50 2E              	   779: 	dc.b	$2e,$03,$18,$04,$05,$24,$23,$2e
00:00000E51 03
00:00000E52 18
00:00000E53 04
00:00000E54 05
00:00000E55 24
00:00000E56 23
00:00000E57 2E
00:00000E58 2E              	   780: 	dc.b	$2e,$20,$16,$06,$14,$12,$25,$2e
00:00000E59 20
00:00000E5A 16
00:00000E5B 06
00:00000E5C 14
00:00000E5D 12
00:00000E5E 25
00:00000E5F 2E
00:00000E60 2E              	   781: 	dc.b	$2e,$0e,$02,$08,$07,$19,$5e,$2e
00:00000E61 0E
00:00000E62 02
00:00000E63 08
00:00000E64 07
00:00000E65 19
00:00000E66 5E
00:00000E67 2E
00:00000E68 2E              	   782: 	dc.b	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
00:00000E69 2E
00:00000E6A 0D
00:00000E6B 0A
00:00000E6C 15
00:00000E6D 26
00:00000E6E 2A
00:00000E6F 2E
00:00000E70 2E              	   783: 	dc.b	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
00:00000E71 3C
00:00000E72 0B
00:00000E73 09
00:00000E74 0F
00:00000E75 29
00:00000E76 28
00:00000E77 2E
00:00000E78 2E              	   784: 	dc.b	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
00:00000E79 3E
00:00000E7A 3F
00:00000E7B 0C
00:00000E7C 3A
00:00000E7D 10
00:00000E7E 5F
00:00000E7F 2E
00:00000E80 2E              	   785: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
00:00000E81 2E
00:00000E82 22
00:00000E83 2E
00:00000E84 7B
00:00000E85 2B
00:00000E86 2E
00:00000E87 2E
00:00000E88 2E              	   786: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
00:00000E89 2E
00:00000E8A 0D
00:00000E8B 7D
00:00000E8C 2E
00:00000E8D 7C
00:00000E8E 2E
00:00000E8F 2E
00:00000E90 2E              	   787: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:00000E91 2E
00:00000E92 2E
00:00000E93 2E
00:00000E94 2E
00:00000E95 2E
00:00000E96 08
00:00000E97 2E
00:00000E98 2E              	   788: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E99 2E
00:00000E9A 2E
00:00000E9B 2E
00:00000E9C 2E
00:00000E9D 2E
00:00000E9E 2E
00:00000E9F 2E
00:00000EA0 2E              	   789: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
00:00000EA1 7F
00:00000EA2 2E
00:00000EA3 2E
00:00000EA4 2E
00:00000EA5 2E
00:00000EA6 1B
00:00000EA7 2E
00:00000EA8 2E              	   790: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EA9 2E
00:00000EAA 2E
00:00000EAB 2E
00:00000EAC 2E
00:00000EAD 2E
00:00000EAE 2E
00:00000EAF 2E
                            	   791: 
                            	   792: _keybdExtendedCodes:
00:00000EB0 2E              	   793: 	dc.b	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
00:00000EB1 2E
00:00000EB2 2E
00:00000EB3 2E
00:00000EB4 A3
00:00000EB5 A1
00:00000EB6 A2
00:00000EB7 2E
00:00000EB8 2E              	   794: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EB9 2E
00:00000EBA 2E
00:00000EBB 2E
00:00000EBC 2E
00:00000EBD 2E
00:00000EBE 2E
00:00000EBF 2E
00:00000EC0 2E              	   795: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EC1 2E
00:00000EC2 2E
00:00000EC3 2E
00:00000EC4 2E
00:00000EC5 2E
00:00000EC6 2E
00:00000EC7 2E
00:00000EC8 2E              	   796: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EC9 2E
00:00000ECA 2E
00:00000ECB 2E
00:00000ECC 2E
00:00000ECD 2E
00:00000ECE 2E
00:00000ECF 2E
00:00000ED0 2E              	   797: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000ED1 2E
00:00000ED2 2E
00:00000ED3 2E
00:00000ED4 2E
00:00000ED5 2E
00:00000ED6 2E
00:00000ED7 2E
00:00000ED8 2E              	   798: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000ED9 2E
00:00000EDA 2E
00:00000EDB 2E
00:00000EDC 2E
00:00000EDD 2E
00:00000EDE 2E
00:00000EDF 2E
00:00000EE0 2E              	   799: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EE1 2E
00:00000EE2 2E
00:00000EE3 2E
00:00000EE4 2E
00:00000EE5 2E
00:00000EE6 2E
00:00000EE7 2E
00:00000EE8 2E              	   800: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EE9 2E
00:00000EEA 2E
00:00000EEB 2E
00:00000EEC 2E
00:00000EED 2E
00:00000EEE 2E
00:00000EEF 2E
00:00000EF0 2E              	   801: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EF1 2E
00:00000EF2 2E
00:00000EF3 2E
00:00000EF4 2E
00:00000EF5 2E
00:00000EF6 2E
00:00000EF7 2E
00:00000EF8 2E              	   802: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EF9 2E
00:00000EFA 2E
00:00000EFB 2E
00:00000EFC 2E
00:00000EFD 2E
00:00000EFE 2E
00:00000EFF 2E
00:00000F00 2E              	   803: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000F01 2E
00:00000F02 2E
00:00000F03 2E
00:00000F04 2E
00:00000F05 2E
00:00000F06 2E
00:00000F07 2E
00:00000F08 2E              	   804: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000F09 2E
00:00000F0A 2E
00:00000F0B 2E
00:00000F0C 2E
00:00000F0D 2E
00:00000F0E 2E
00:00000F0F 2E
00:00000F10 2E              	   805: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000F11 2E
00:00000F12 2E
00:00000F13 2E
00:00000F14 2E
00:00000F15 2E
00:00000F16 2E
00:00000F17 2E
00:00000F18 2E              	   806: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
00:00000F19 95
00:00000F1A 2E
00:00000F1B 93
00:00000F1C 94
00:00000F1D 2E
00:00000F1E 2E
00:00000F1F 2E
00:00000F20 98              	   807: 	dc.b	$98,$99,$92,$2e,$91,$90,$2e,$2e
00:00000F21 99
00:00000F22 92
00:00000F23 2E
00:00000F24 91
00:00000F25 90
00:00000F26 2E
00:00000F27 2E
00:00000F28 2E              	   808: 	dc.b	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
00:00000F29 2E
00:00000F2A 97
00:00000F2B 2E
00:00000F2C 2E
00:00000F2D 96
00:00000F2E 2E
00:00000F2F 2E
                            	   809: 
                            	   810: 

Source: "boot.x68"
                            	   576: 	include "textvid.x68"

Source: "textvid.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;------------------------------------------------------------------------------
                            	    38: ;------------------------------------------------------------------------------
                            	    39: ; Setup the text video device
                            	    40: ; stdout = text screen controller
                            	    41: ;------------------------------------------------------------------------------
                            	    42: ;------------------------------------------------------------------------------
                            	    43: 
                            	    44: TBLE macro arg1
                            	    45: 	dc.l (\1)
                            	    46: endm
                            	    47: 
                            	    48: 	code
                            	    49: 	even
                            	    50: 
                            	    51: 	align 2
                            	    52: TEXTVID_CMDTBL:
                            	    53: 	TBLE textvid_init					; 0
00:00000F30 00001010        	     1M 	dc.l (textvid_init)
                            	    54: 	TBLE textvid_stat
00:00000F34 000010B8        	     1M 	dc.l (textvid_stat)
                            	    55: 	TBLE textvid_putchar
00:00000F38 00001262        	     1M 	dc.l (textvid_putchar)
                            	    56: 	TBLE textvid_putbuf
00:00000F3C 000010C4        	     1M 	dc.l (textvid_putbuf)
                            	    57: 	TBLE textvid_getchar
00:00000F40 000010BC        	     1M 	dc.l (textvid_getchar)
                            	    58: 	TBLE textvid_getbuf
00:00000F44 000010C4        	     1M 	dc.l (textvid_getbuf)
                            	    59: 	TBLE textvid_set_inpos
00:00000F48 000010DE        	     1M 	dc.l (textvid_set_inpos)
                            	    60: 	TBLE textvid_set_outpos
00:00000F4C 000010F4        	     1M 	dc.l (textvid_set_outpos)
                            	    61: 	TBLE textvid_stub
00:00000F50 000010C4        	     1M 	dc.l (textvid_stub)
                            	    62: 	TBLE textvid_stub
00:00000F54 000010C4        	     1M 	dc.l (textvid_stub)
                            	    63: 	TBLE textvid_stub				; 10
00:00000F58 000010C4        	     1M 	dc.l (textvid_stub)
                            	    64: 	TBLE textvid_stub
00:00000F5C 000010C4        	     1M 	dc.l (textvid_stub)
                            	    65: 	TBLE textvid_clear
00:00000F60 000011A0        	     1M 	dc.l (textvid_clear)
                            	    66: 	TBLE textvid_stub
00:00000F64 000010C4        	     1M 	dc.l (textvid_stub)
                            	    67: 	TBLE textvid_stub
00:00000F68 000010C4        	     1M 	dc.l (textvid_stub)
                            	    68: 	TBLE textvid_stub
00:00000F6C 000010C4        	     1M 	dc.l (textvid_stub)
                            	    69: 	TBLE textvid_getbuf1
00:00000F70 00001156        	     1M 	dc.l (textvid_getbuf1)
                            	    70: 	TBLE textvid_stub
00:00000F74 000010C4        	     1M 	dc.l (textvid_stub)
                            	    71: 	TBLE textvid_stub
00:00000F78 000010C4        	     1M 	dc.l (textvid_stub)
                            	    72: 	TBLE textvid_set_unit
00:00000F7C 00001166        	     1M 	dc.l (textvid_set_unit)
                            	    73: 	TBLE textvid_get_dimen	; 20
00:00000F80 00001170        	     1M 	dc.l (textvid_get_dimen)
                            	    74: 	TBLE textvid_get_color
00:00000F84 00001146        	     1M 	dc.l (textvid_get_color)
                            	    75: 	TBLE textvid_get_inpos
00:00000F88 000010C8        	     1M 	dc.l (textvid_get_inpos)
                            	    76: 	TBLE textvid_get_outpos
00:00000F8C 0000110A        	     1M 	dc.l (textvid_get_outpos)
                            	    77: 	TBLE textvid_get_outptr
00:00000F90 00001120        	     1M 	dc.l (textvid_get_outptr)
                            	    78: 
                            	    79: 	code
                            	    80: 	even
                            	    81: textvid_cmdproc:
00:00000F94 0C060019        	    82: 	cmpi.b #25,d6
00:00000F98 641A            	    83: 	bhs.s .0001
00:00000F9A 48E70280        	    84: 	movem.l d6/a0,-(a7)
00:00000F9E 4886            	    85: 	ext.w d6
00:00000FA0 48C6            	    86: 	ext.l d6
00:00000FA2 E54E            	    87: 	lsl.w #2,d6
00:00000FA4 41FAFF8A        	    88: 	lea TEXTVID_CMDTBL,a0
00:00000FA8 20706000        	    89: 	move.l (a0,d6.w),a0
00:00000FAC 4E90            	    90: 	jsr (a0)
00:00000FAE 4CDF0140        	    91: 	movem.l (a7)+,d6/a0
00:00000FB2 4E75            	    92: 	rts
                            	    93: .0001:
00:00000FB4 7002            	    94: 	moveq #E_Func,d0
00:00000FB6 4E75            	    95: 	rts
                            	    96: 
                            	    97: setup_textvid:
00:00000FB8 48E780C0        	    98: 	movem.l d0/a0/a1,-(a7)
00:00000FBC 7020            	    99: 	moveq #32,d0
00:00000FBE 41F900040B08    	   100: 	lea.l textvid_dcb,a0
                            	   101: .0001:
00:00000FC4 4298            	   102: 	clr.l (a0)+
00:00000FC6 51C8FFFC        	   103: 	dbra d0,.0001
00:00000FCA 23FC444342200004	   104: 	move.l #$44434220,textvid_dcb+DCB_MAGIC				; 'DCB '
00:00000FD2 0B08
00:00000FD4 23FC544558540004	   105: 	move.l #$54455854,textvid_dcb+DCB_NAME				; 'TEXTVID'
00:00000FDC 0B0C
00:00000FDE 23FC564944000004	   106: 	move.l #$56494400,textvid_dcb+DCB_NAME+4			;
00:00000FE6 0B10
00:00000FE8 23FC00000F940004	   107: 	move.l #textvid_cmdproc,textvid_dcb+DCB_CMDPROC
00:00000FF0 0B20
00:00000FF2 611C            	   108: 	bsr textvid_init
00:00000FF4 6100161E        	   109: 	jsr Delay3s
00:00000FF8 610001A6        	   110: 	bsr textvid_clear
00:00000FFC 43F900040B08    	   111: 	lea.l textvid_dcb+DCB_MAGIC,a1
00:00001002 61006AE0        	   112: 	jsr DisplayString
00:00001006 61006AC2        	   113: 	jsr CRLF
00:0000100A 4CDF0301        	   114: 	movem.l (a7)+,d0/a0/a1
00:0000100E 4E75            	   115: 	rts
                            	   116: 
                            	   117: textvid_init:
00:00001010 2F00            	   118: 	move.l d0,-(a7)
                            	   119: 	if (SCREEN_FORMAT==1)
00:00001012 23FC000000FF0004	   120: 		move.l #$0000ff,fgColor		; set foreground / background color (white)
00:0000101A 0084
00:0000101C 23FC000000020004	   121: 		move.l #$000002,bkColor		; medium blue
00:00001024 0088
00:00001026 23FC000000FF0004	   122: 		move.l #$0000ff,textvid_dcb+DCB_FGCOLOR
00:0000102E 0B6C
00:00001030 23FC000000020004	   123: 		move.l #$000002,textvid_dcb+DCB_BKCOLOR		; medium blue
00:00001038 0B68
                            	   124: 	else
                            	   125: 		move.l #$1fffff,fgColor		; set foreground / background color (white)
                            	   126: 		move.l #$00003f,bkColor		; medium blue
                            	   127: 		move.l #$1fffff,textvid_dcb+DCB_FGCOLOR		; set foreground / background color (white)
                            	   128: 		move.l #$00003f,textvid_dcb+DCB_BKCOLOR		; medium blue
                            	   129: 	endif
00:0000103A 4E7A0FE0        	   130: 	movec.l	coreno,d0					; get core number (2 to 9)
00:0000103E 5500            	   131: 	subi.b #2,d0							; adjust (0 to 7)
                            	   132: 	if (SCREEN_FORMAT==1)
00:00001040 C0FC2000        	   133: 		mulu #8192,d0						; compute screen location
                            	   134: 	else
                            	   135: 		mulu #16384,d0						; compute screen location
                            	   136: 	endif
                            	   137: 	if HAS_MMU
                            	   138: 		addi.l #$01E00000,d0
                            	   139: 	else
00:00001044 0680FD000000    	   140: 		addi.l #$FD000000,d0
                            	   141: 	endif
00:0000104A 23C000040B40    	   142: 	move.l d0,textvid_dcb+DCB_INBUFPTR
00:00001050 23C000040B44    	   143: 	move.l d0,textvid_dcb+DCB_OUTBUFPTR
00:00001056 23C000040004    	   144: 	move.l d0,TextScr
                            	   145: 	if (SCREEN_FORMAT==1)
00:0000105C 23FC000020000004	   146: 		move.l #8192,textvid_dcb+DCB_INBUFSIZE
00:00001064 0B48
00:00001066 23FC000020000004	   147: 		move.l #8192,textvid_dcb+DCB_OUTBUFSIZE
00:0000106E 0B4C
                            	   148: 	else
                            	   149: 		move.l #16384,textvid_dcb+DCB_INBUFSIZE
                            	   150: 		move.l #16384,textvid_dcb+DCB_OUTBUFSIZE
                            	   151: 	endif
00:00001070 23FC000000300004	   152: 	move.l #TEXTCOL,textvid_dcb+DCB_OUTDIMX	; set rows and columns
00:00001078 0B5C
00:0000107A 23FC000000200004	   153: 	move.l #TEXTROW,textvid_dcb+DCB_OUTDIMY
00:00001082 0B60
00:00001084 23FC000000300004	   154: 	move.l #TEXTCOL,textvid_dcb+DCB_INDIMX		; set rows and columns
00:0000108C 0B50
00:0000108E 23FC000000200004	   155: 	move.l #TEXTROW,textvid_dcb+DCB_INDIMY
00:00001096 0B54
00:00001098 13FC00300004008D	   156: 	move.b #TEXTCOL,TextCols				; set rows and columns
00:000010A0 13FC00200004008C	   157: 	move.b #TEXTROW,TextRows
00:000010A8 42B900040B28    	   158: 	clr.l textvid_dcb+DCB_OUTPOSX
00:000010AE 42B900040B2C    	   159: 	clr.l textvid_dcb+DCB_OUTPOSY
00:000010B4 201F            	   160: 	move.l (a7)+,d0
00:000010B6 4E75            	   161: 	rts
                            	   162: 
                            	   163: textvid_stat:
00:000010B8 7000            	   164: 	moveq #E_Ok,d0
00:000010BA 4E75            	   165: 	rts
                            	   166: 
                            	   167: textvid_getchar:
00:000010BC 61007066        	   168: 	bsr FromScreen
00:000010C0 7000            	   169: 	moveq #E_Ok,d0
00:000010C2 4E75            	   170: 	rts
                            	   171: 
                            	   172: textvid_putbuf:
                            	   173: textvid_getbuf:
                            	   174: textvid_stub:
00:000010C4 700A            	   175: 	moveq #E_NotSupported,d0
00:000010C6 4E75            	   176: 	rts
                            	   177: 
                            	   178: textvid_get_inpos:
00:000010C8 223900040B34    	   179: 	move.l textvid_dcb+DCB_INPOSX,d1
00:000010CE 243900040B38    	   180: 	move.l textvid_dcb+DCB_INPOSY,d2
00:000010D4 263900040B3C    	   181: 	move.l textvid_dcb+DCB_INPOSZ,d3
00:000010DA 7000            	   182: 	move.l #E_Ok,d0
00:000010DC 4E75            	   183: 	rts
                            	   184: 
                            	   185: textvid_set_inpos:
00:000010DE 23C100040B34    	   186: 	move.l d1,textvid_dcb+DCB_INPOSX
00:000010E4 23C200040B38    	   187: 	move.l d2,textvid_dcb+DCB_INPOSY
00:000010EA 23C300040B3C    	   188: 	move.l d3,textvid_dcb+DCB_INPOSZ
00:000010F0 7000            	   189: 	move.l #E_Ok,d0
00:000010F2 4E75            	   190: 	rts
                            	   191: 
                            	   192: textvid_set_outpos:
00:000010F4 23C100040B28    	   193: 	move.l d1,textvid_dcb+DCB_OUTPOSX
00:000010FA 23C200040B2C    	   194: 	move.l d2,textvid_dcb+DCB_OUTPOSY
00:00001100 23C300040B30    	   195: 	move.l d3,textvid_dcb+DCB_OUTPOSZ
00:00001106 7000            	   196: 	move.l #E_Ok,d0
00:00001108 4E75            	   197: 	rts
                            	   198: 
                            	   199: textvid_get_outpos:
00:0000110A 223900040B28    	   200: 	move.l textvid_dcb+DCB_OUTPOSX,d1
00:00001110 243900040B2C    	   201: 	move.l textvid_dcb+DCB_OUTPOSY,d2
00:00001116 263900040B30    	   202: 	move.l textvid_dcb+DCB_OUTPOSZ,d3
00:0000111C 7000            	   203: 	move.l #E_Ok,d0
00:0000111E 4E75            	   204: 	rts
                            	   205: 
                            	   206: textvid_get_outptr:
00:00001120 2F02            	   207: 	move.l d2,-(a7)
00:00001122 223900040B28    	   208: 	move.l textvid_dcb+DCB_OUTPOSX,d1
00:00001128 203900040B2C    	   209: 	move.l textvid_dcb+DCB_OUTPOSY,d0
00:0000112E 243900040B5C    	   210: 	move.l textvid_dcb+DCB_OUTDIMX,d2
00:00001134 C0C2            	   211: 	mulu d2,d0
00:00001136 D280            	   212: 	add.l d0,d1
                            	   213: 	if (SCREEN_FORMAT==1)
00:00001138 E589            	   214: 		lsl.l #2,d1
                            	   215: 	else
                            	   216: 		lsl.l #3,d1
                            	   217: 	endif
00:0000113A D2B900040B44    	   218: 	add.l textvid_dcb+DCB_OUTBUFPTR,d1
00:00001140 241F            	   219: 	move.l (a7)+,d2
00:00001142 7000            	   220: 	move.l #E_Ok,d0
00:00001144 4E75            	   221: 	rts
                            	   222: 
                            	   223: textvid_get_color:
00:00001146 223900040B6C    	   224: 	move.l textvid_dcb+DCB_FGCOLOR,d1
00:0000114C 243900040B68    	   225: 	move.l textvid_dcb+DCB_BKCOLOR,d2
00:00001152 7000            	   226: 	move.l #E_Ok,d0
00:00001154 4E75            	   227: 	rts
                            	   228: 
                            	   229: textvid_getbuf1:
00:00001156 223900040B44    	   230: 	move.l textvid_dcb+DCB_OUTBUFPTR,d1
00:0000115C 243900040B4C    	   231: 	move.l textvid_dcb+DCB_OUTBUFSIZE,d2
00:00001162 7000            	   232: 	move.l #E_Ok,d0
00:00001164 4E75            	   233: 	rts
                            	   234: 
                            	   235: textvid_set_unit:
00:00001166 23C100040B88    	   236: 	move.l d1,textvid_dcb+DCB_UNIT
00:0000116C 7000            	   237: 	move.l #E_Ok,d0
00:0000116E 4E75            	   238: 	rts
                            	   239: 
                            	   240: textvid_get_dimen:
00:00001170 4A00            	   241: 	cmpi.b #0,d0
00:00001172 6616            	   242: 	bne.s .0001
00:00001174 223900040B5C    	   243: 	move.l textvid_dcb+DCB_OUTDIMX,d1
00:0000117A 243900040B60    	   244: 	move.l textvid_dcb+DCB_OUTDIMY,d2
00:00001180 263900040B64    	   245: 	move.l textvid_dcb+DCB_OUTDIMZ,d3
00:00001186 7000            	   246: 	move.l #E_Ok,d0
00:00001188 4E75            	   247: 	rts
                            	   248: .0001:
00:0000118A 223900040B50    	   249: 	move.l textvid_dcb+DCB_INDIMX,d1
00:00001190 243900040B54    	   250: 	move.l textvid_dcb+DCB_INDIMY,d2
00:00001196 263900040B58    	   251: 	move.l textvid_dcb+DCB_INDIMZ,d3
00:0000119C 7000            	   252: 	move.l #E_Ok,d0
00:0000119E 4E75            	   253: 	rts
                            	   254: 
                            	   255: ; -----------------------------------------------------------------------------
                            	   256: ; -----------------------------------------------------------------------------
                            	   257: 
                            	   258: textvid_clear:
00:000011A0 23FCFFFFFFFFFD0F	   259: 	move.l #$FFFFFFFF,leds
00:000011A8 FF00
00:000011AA 48E77880        	   260: 	movem.l	d1/d2/d3/d4/a0,-(a7)
00:000011AE 4E7A0FE0        	   261: 	movec	coreno,d0
00:000011B2 4840            	   262: 	swap d0	
                            	   263: ;	moveq		#SCREEN_SEMA,d1
                            	   264: ;	bsr			LockSemaphore
00:000011B4 223900040B44    	   265: 	move.l textvid_dcb+DCB_OUTBUFPTR,d1
00:000011BA 243900040B4C    	   266: 	move.l textvid_dcb+DCB_OUTBUFSIZE,d2
00:000011C0 23FCFEFEFEFEFD0F	   267: 	move.l #$FEFEFEFE,leds
00:000011C8 FF00
00:000011CA 2041            	   268: 	move.l d1,a0								; a0 = pointer to screen area
00:000011CC 2802            	   269: 	move.l d2,d4
                            	   270: 	if (SCREEN_FORMAT==1)
00:000011CE E48C            	   271: 		lsr.l #2,d4									; number of cells to clear
                            	   272: 	else
                            	   273: 		lsr.l #3,d4									; number of cells to clear
                            	   274: 	endif
00:000011D0 223900040B6C    	   275: 	move.l textvid_dcb+DCB_FGCOLOR,d1
00:000011D6 243900040B68    	   276: 	move.l textvid_dcb+DCB_BKCOLOR,d2
00:000011DC 23FCFDFDFDFDFD0F	   277: 	move.l #$FDFDFDFD,leds
00:000011E4 FF00
                            	   278: ;	bsr	get_screen_color				; get the color bits
                            	   279: 	if (SCREEN_FORMAT==1)
00:000011E6 48C1            	   280: 		ext.l d1
00:000011E8 E189            	   281: 		lsl.l #8,d1
00:000011EA 48C2            	   282: 		ext.l d2									; clear high order bits
00:000011EC 8481            	   283: 		or.l d1,d2								; forground color in bits 24 to 31
00:000011EE 4842            	   284: 		swap d2										; color in bits 16 to 23
00:000011F0 00420020        	   285: 		ori.w #32,d2							; insert character to display (space)
00:000011F4 E15A            	   286: 		rol.w #8,d2								; reverse byte order
00:000011F6 4842            	   287: 		swap d2
00:000011F8 E15A            	   288: 		rol.w #8,d2
                            	   289: loop3:
00:000011FA 20C2            	   290: 		move.l d2,(a0)+						; copy to cell
                            	   291: 	else
                            	   292: 		lsl.l #5,d1								; high order background color bits go in bits 0 to 4
                            	   293: 		move.l d2,d3
                            	   294: 		swap d3
                            	   295: 		andi.l #$1f,d3
                            	   296: 		or.l d3,d1
                            	   297: 		; we want bkcolor in bits 16 to 32
                            	   298: 		; char in bits 0 to 15
                            	   299: 		swap d2										; color in bits 16 to 32
                            	   300: 		move.w #32,d2							; load space character
                            	   301: 		rol.w	#8,d2								; swap endian, text controller expects little endian
                            	   302: 		swap d2
                            	   303: 		rol.w	#8,d2
                            	   304: 		rol.w	#8,d0								; swap endian
                            	   305: 		swap d0
                            	   306: 		rol.w	#8,d0
                            	   307: loop3:
                            	   308: 		move.l d2,(a0)+						; copy char plus bkcolor to cell
                            	   309: 		move.l d1,(a0)+						; copy fgcolor to cell
                            	   310: 	endif
00:000011FC 51CCFFFC        	   311: 	dbra d4,loop3
00:00001200 4E7A0FE0        	   312: 	movec coreno,d0
00:00001204 4840            	   313: 	swap d0	
                            	   314: ;	moveq #SCREEN_SEMA,d1
                            	   315: ;	bsr UnlockSemaphore
00:00001206 23FCFCFCFCFCFD0F	   316: 	move.l #$FCFCFCFC,leds
00:0000120E FF00
00:00001210 4CDF011E        	   317: 	movem.l (a7)+,d1/d2/d3/d4/a0
00:00001214 7000            	   318: 	move.l #E_Ok,d0
00:00001216 4E75            	   319: 	rts
                            	   320: 
                            	   321: ; -----------------------------------------------------------------------------
                            	   322: ; Gets the screen color in d0 and d1. Setup already to be able to insert
                            	   323: ; character code.
                            	   324: ; -----------------------------------------------------------------------------
                            	   325: 
                            	   326: get_screen_color:
00:00001218 2F02            	   327: 	move.l d2,-(a7)
00:0000121A 223900040B6C    	   328: 	move.l textvid_dcb+DCB_FGCOLOR,d1
00:00001220 243900040B68    	   329: 	move.l textvid_dcb+DCB_BKCOLOR,d2
                            	   330: 	if (SCREEN_FORMAT==1)
00:00001226 E189            	   331: 		lsl.l #8,d1							; foreground color in bits 8 to 15
00:00001228 024200FF        	   332: 		andi.w #$ff,d2
00:0000122C 8242            	   333: 		or.w d2,d1							; background color in bits 0 to 7
00:0000122E 4841            	   334: 		swap d1									; foreground color in bits 24 to 31, bk in 16 to 23
00:00001230 4241            	   335: 		move.w #0,d1						; clear character
00:00001232 2001            	   336: 		move.l d1,d0
                            	   337: 	else
                            	   338: 		asl.l	#5,d1							; shift into position
                            	   339: 		ori.l	#$40000000,d1			; set priority
                            	   340: 		move.l d2,d0
                            	   341: 		lsr.l	#8,d2
                            	   342: 		lsr.l	#8,d2
                            	   343: 		andi.l #31,d2						; mask off extra bits
                            	   344: 		or.l d2,d1							; set background color bits in upper long word
                            	   345: 		asl.l	#8,d0							; shift into position for display ram
                            	   346: 		asl.l	#8,d0
                            	   347: 	endif
00:00001234 241F            	   348: 	move.l (a7)+,d2
00:00001236 4E75            	   349: 	rts
                            	   350: 
                            	   351: ;------------------------------------------------------------------------------
                            	   352: ; Calculate screen memory location from CursorRow,CursorCol.
                            	   353: ; Destroys d0,d2,a0
                            	   354: ;------------------------------------------------------------------------------
                            	   355: 
                            	   356: CalcScreenLoc:
00:00001238 48E7C400        	   357: 	movem.l d0/d1/d5,-(a7)
00:0000123C 203900040B28    	   358: 	move.l textvid_dcb+DCB_OUTPOSX,d0
00:00001242 2A3900040B2C    	   359: 	move.l textvid_dcb+DCB_OUTPOSY,d5
00:00001248 223900040B5C    	   360: 	move.l textvid_dcb+DCB_OUTDIMX,d1
00:0000124E CAC1            	   361: 	mulu d1,d5							; y * num cols
00:00001250 D085            	   362: 	add.l d5,d0							; plus x
                            	   363: 	if (SCREEN_FORMAT==1)
00:00001252 E580            	   364: 		asl.l #2,d0							; 4 bytes per char
                            	   365: 	else
                            	   366: 		asl.l	#3,d0							; 8 bytes per char
                            	   367: 	endif
00:00001254 207900040B44    	   368: 	move.l textvid_dcb+DCB_OUTBUFPTR,a0
00:0000125A D1C0            	   369: 	add.l	d0,a0								; a0 = screen location
00:0000125C 4CDF0023        	   370: 	movem.l (a7)+,d0/d1/d5
00:00001260 4E75            	   371: 	rts
                            	   372: 
                            	   373: ;------------------------------------------------------------------------------
                            	   374: ; Display a character on the screen
                            	   375: ; Parameters:
                            	   376: ; 	d1.b = char to display
                            	   377: ;------------------------------------------------------------------------------
                            	   378: 
                            	   379: textvid_putchar:
00:00001262 48E77000        	   380: 	movem.l	d1/d2/d3,-(a7)
00:00001266 4E7A2FE0        	   381: 	movec	coreno,d2
00:0000126A 0C020002        	   382: 	cmpi.b #2,d2
                            	   383: ;	bne.s		.0001
                            	   384: ;	bsr			SerialPutChar
                            	   385: .0001:
00:0000126E 0281000000FF    	   386: 	andi.l #$ff,d1				; zero out upper bytes of d1
00:00001274 0C01000D        	   387: 	cmpi.b #13,d1				; carriage return ?
00:00001278 6612            	   388: 	bne.s	dccr
00:0000127A 42B900040B28    	   389: 	clr.l	textvid_dcb+DCB_OUTPOSX	; just set cursor column to zero on a CR
                            	   390: dcx14:
00:00001280 6100024E        	   391: 	bsr	SyncCursor				; set position in text controller
                            	   392: dcx7:
00:00001284 4CDF000E        	   393: 	movem.l	(a7)+,d1/d2/d3
00:00001288 7000            	   394: 	moveq #E_Ok,d0
00:0000128A 4E75            	   395: 	rts
                            	   396: dccr:
00:0000128C 0C010091        	   397: 	cmpi.b #$91,d1			; cursor right ?
00:00001290 6618            	   398: 	bne.s dcx6
00:00001292 243900040B5C    	   399: 	move.l textvid_dcb+DCB_OUTDIMX,d2
00:00001298 5382            	   400: 	subq.l #1,d2
00:0000129A 94B900040B28    	   401: 	sub.l	textvid_dcb+DCB_OUTPOSX,d2
00:000012A0 67E2            	   402: 	beq.s	dcx7
00:000012A2 52B900040B28    	   403: 	addq.l #1,textvid_dcb+DCB_OUTPOSX
00:000012A8 60D6            	   404: 	bra.s dcx14
                            	   405: dcx6:
00:000012AA 0C010090        	   406: 	cmpi.b #$90,d1			; cursor up ?
00:000012AE 6610            	   407: 	bne.s	dcx8
00:000012B0 4AB900040B2C    	   408: 	tst.l textvid_dcb+DCB_OUTPOSY
00:000012B6 67CC            	   409: 	beq.s	dcx7
00:000012B8 53B900040B2C    	   410: 	subq.l #1,textvid_dcb+DCB_OUTPOSY
00:000012BE 60C0            	   411: 	bra.s	dcx14
                            	   412: dcx8:
00:000012C0 0C010093        	   413: 	cmpi.b #$93,d1			; cursor left?
00:000012C4 6610            	   414: 	bne.s	dcx9
00:000012C6 4AB900040B28    	   415: 	tst.l textvid_dcb+DCB_OUTPOSX
00:000012CC 67B6            	   416: 	beq.s	dcx7
00:000012CE 53B900040B28    	   417: 	subq.l #1,textvid_dcb+DCB_OUTPOSX
00:000012D4 60AA            	   418: 	bra.s	dcx14
                            	   419: dcx9:
00:000012D6 0C010092        	   420: 	cmpi.b #$92,d1			; cursor down ?
00:000012DA 6618            	   421: 	bne.s	dcx10
00:000012DC 243900040B60    	   422: 	move.l textvid_dcb+DCB_OUTDIMY,d2
00:000012E2 5382            	   423: 	subq.l #1,d2
00:000012E4 B4B900040B2C    	   424: 	cmp.l	textvid_dcb+DCB_OUTPOSY,d2
00:000012EA 6798            	   425: 	beq.s	dcx7
00:000012EC 52B900040B2C    	   426: 	addq.l #1,textvid_dcb+DCB_OUTPOSY
00:000012F2 608C            	   427: 	bra.s	dcx14
                            	   428: dcx10:
00:000012F4 0C010094        	   429: 	cmpi.b #$94,d1			; cursor home ?
00:000012F8 661C            	   430: 	bne.s	dcx11
00:000012FA 4AB900040B28    	   431: 	tst.l	textvid_dcb+DCB_OUTPOSX
00:00001300 670A            	   432: 	beq.s	dcx12
00:00001302 42B900040B28    	   433: 	clr.l	textvid_dcb+DCB_OUTPOSX
00:00001308 6000FF76        	   434: 	bra	dcx14
                            	   435: dcx12:
00:0000130C 42B900040B2C    	   436: 	clr.l	textvid_dcb+DCB_OUTPOSY
00:00001312 6000FF6C        	   437: 	bra	dcx14
                            	   438: dcx11:
00:00001316 48E70080        	   439: 	movem.l	a0,-(a7)
00:0000131A 0C010099        	   440: 	cmpi.b #$99,d1				; delete ?
00:0000131E 6760            	   441: 	beq.s	doDelete
00:00001320 0C010008        	   442: 	cmpi.b #CTRLH,d1			; backspace ?
00:00001324 674C            	   443: 	beq.s doBackspace
00:00001326 0C010018        	   444: 	cmpi.b #CTRLX,d1			; delete line ?
00:0000132A 6700008A        	   445: 	beq	doCtrlX
00:0000132E 0C01000A        	   446: 	cmpi.b #10,d1					; linefeed ?
00:00001332 672C            	   447: 	beq.s dclf
                            	   448: 
                            	   449: 	; regular char
00:00001334 23FCFFFFFFFFFD0F	   450: 	move.l #$FFFFFFFF,leds
00:0000133C FF00
00:0000133E 6100FEF8        	   451: 	bsr	CalcScreenLoc			; a0 = screen location
00:00001342 23FCFFFFFFFEFD0F	   452: 	move.l #$FFFFFFFE,leds
00:0000134A FF00
00:0000134C 2401            	   453: 	move.l d1,d2					; d2 = char
00:0000134E 6100FEC8        	   454: 	bsr get_screen_color	; d0,d1 = color
00:00001352 8082            	   455: 	or.l d2,d0						; d0 = char + color
00:00001354 E158            	   456: 	rol.w	#8,d0						; swap bytes - text controller expects little endian data
00:00001356 4840            	   457: 	swap d0								; swap halfs
00:00001358 E158            	   458: 	rol.w	#8,d0						; swap remaining bytes
                            	   459: 	if (SCREEN_FORMAT==1)
00:0000135A 20C0            	   460: 		move.l d0,(a0)+
                            	   461: 	else
                            	   462: 		move.l d0,(a0)+
                            	   463: 		rol.w	#8,d1					; swap bytes
                            	   464: 		swap d1							; swap halfs
                            	   465: 		rol.w	#8,d1					; swap remaining bytes
                            	   466: 		move.l d1,(a0)
                            	   467: 	endif
00:0000135C 617C            	   468: 	bsr	IncCursorPos
00:0000135E 6004            	   469: 	bra	dcx16
                            	   470: dclf:
00:00001360 61000092        	   471: 	bsr IncCursorRow
                            	   472: dcx16:
00:00001364 6100016A        	   473: 	bsr	SyncCursor
                            	   474: dcx4:
00:00001368 205F            	   475: 	movem.l	(a7)+,a0			; get back a0
00:0000136A 4CDF000E        	   476: 	movem.l	(a7)+,d1/d2/d3
00:0000136E 7000            	   477: 	moveq #E_Ok,d0
00:00001370 4E75            	   478: 	rts
                            	   479: 
                            	   480: 	;---------------------------
                            	   481: 	; CTRL-H: backspace
                            	   482: 	;---------------------------
                            	   483: doBackspace:
00:00001372 4AB900040B28    	   484: 	tst.l	textvid_dcb+DCB_OUTPOSX		; if already at start of line
00:00001378 67EE            	   485: 	beq.s dcx4						; nothing to do
00:0000137A 53B900040B28    	   486: 	subq.l #1,textvid_dcb+DCB_OUTPOSX		; decrement column
                            	   487: 
                            	   488: 	;---------------------------
                            	   489: 	; Delete key
                            	   490: 	;---------------------------
                            	   491: doDelete:
00:00001380 48E7C080        	   492: 	movem.l	d0/d1/a0,-(a7)	; save off screen location
00:00001384 6100FEB2        	   493: 	bsr	CalcScreenLoc				; a0 = screen location
00:00001388 203900040B28    	   494: 	move.l textvid_dcb+DCB_OUTPOSX,d0
                            	   495: .0001:
                            	   496: 	if (SCREEN_FORMAT==1)
00:0000138E 20A80004        	   497: 		move.l 4(a0),(a0)				; pull remaining characters on line over 1
00:00001392 5888            	   498: 		adda.l #4,a0
                            	   499: 	else
                            	   500: 		move.l 8(a0),(a0)				; pull remaining characters on line over 1
                            	   501: 		move.l 12(a0),4(a0)
                            	   502: 		adda.l #8,a0
                            	   503: 	endif
00:00001394 5280            	   504: 	addq.l #1,d0
00:00001396 B0B900040B5C    	   505: 	cmp.l	textvid_dcb+DCB_OUTDIMX,d0
00:0000139C 65F0            	   506: 	blo.s	.0001
00:0000139E 6100FE78        	   507: 	bsr	get_screen_color
                            	   508: 	if (SCREEN_FORMAT==1)
00:000013A2 303C0020        	   509: 		move.w #' ',d0
00:000013A6 E158            	   510: 		rol.w	#8,d0
00:000013A8 4840            	   511: 		swap d0
00:000013AA E158            	   512: 		rol.w	#8,d0
00:000013AC 2140FFFC        	   513: 		move.l d0,-4(a0)
                            	   514: 	else
                            	   515: 		move.w #' ',d0					; terminate line with a space
                            	   516: 		rol.w	#8,d0
                            	   517: 		swap d0
                            	   518: 		rol.w	#8,d0
                            	   519: 		move.l d0,-8(a0)
                            	   520: 	endif
00:000013B0 4CDF0103        	   521: 	movem.l	(a7)+,d0/d1/a0
00:000013B4 60AE            	   522: 	bra.s		dcx16				; finished
                            	   523: 
                            	   524: 	;---------------------------
                            	   525: 	; CTRL-X: erase line
                            	   526: 	;---------------------------
                            	   527: doCtrlX:
00:000013B6 42B900040B28    	   528: 	clr.l	textvid_dcb+DCB_OUTPOSX			; Reset cursor to start of line
00:000013BC 203900040B5C    	   529: 	move.l textvid_dcb+DCB_OUTDIMX,d0	; and display TextCols number of spaces
00:000013C2 4880            	   530: 	ext.w	d0
00:000013C4 48C0            	   531: 	ext.l	d0
00:000013C6 123C0020        	   532: 	move.b #' ',d1			; d1 = space char
                            	   533: .0001:
                            	   534: 	; textvid_putchar is called recursively here
                            	   535: 	; It's safe to do because we know it won't recurse again due to the
                            	   536: 	; fact we know the character being displayed is a space char
00:000013CA 6100FE96        	   537: 	bsr	textvid_putchar
00:000013CE 5340            	   538: 	subq #1,d0
00:000013D0 66F8            	   539: 	bne.s	.0001
00:000013D2 42B900040B28    	   540: 	clr.l	textvid_dcb+DCB_OUTPOSX			; now really go back to start of line
00:000013D8 608A            	   541: 	bra	dcx16						; we're done
                            	   542: 
                            	   543: ;------------------------------------------------------------------------------
                            	   544: ; Increment the cursor position, scroll the screen if needed.
                            	   545: ;------------------------------------------------------------------------------
                            	   546: 
                            	   547: IncCursorPos:
00:000013DA 52B900040B28    	   548: 	addq.l #1,textvid_dcb+DCB_OUTPOSX
00:000013E0 203900040B5C    	   549: 	move.l textvid_dcb+DCB_OUTDIMX,d0
00:000013E6 B0B900040B28    	   550: 	cmp.l	textvid_dcb+DCB_OUTPOSX,d0
00:000013EC 642E            	   551: 	bhs.s	icc1
00:000013EE 42B900040B28    	   552: 	clr.l textvid_dcb+DCB_OUTPOSX
                            	   553: IncCursorRow:
00:000013F4 52B900040B2C    	   554: 	addq.l #1,textvid_dcb+DCB_OUTPOSY
00:000013FA 203900040B60    	   555: 	move.l textvid_dcb+DCB_OUTDIMY,d0
00:00001400 B0B900040B2C    	   556: 	cmp.l textvid_dcb+DCB_OUTPOSY,d0
00:00001406 6214            	   557: 	bhi.s	icc1
00:00001408 203900040B60    	   558: 	move.l textvid_dcb+DCB_OUTDIMY,d0
00:0000140E 23C000040B2C    	   559: 	move.l d0,textvid_dcb+DCB_OUTPOSY		; in case CursorRow is way over
00:00001414 53B900040B2C    	   560: 	subq.l #1,textvid_dcb+DCB_OUTPOSY
00:0000141A 6102            	   561: 	bsr	ScrollUp
                            	   562: icc1:
00:0000141C 4E75            	   563: 	rts
                            	   564: 
                            	   565: ;------------------------------------------------------------------------------
                            	   566: ; Scroll screen up.
                            	   567: ;------------------------------------------------------------------------------
                            	   568: 
                            	   569: ScrollUp:
00:0000141E 48E7C084        	   570: 	movem.l	d0/d1/a0/a5,-(a7)		; save off some regs
00:00001422 4E7A0FE0        	   571: 	movec	coreno,d0
00:00001426 4840            	   572: 	swap d0	
00:00001428 7205            	   573: 	moveq	#SCREEN_SEMA,d1
00:0000142A 61001152        	   574: 	bsr	LockSemaphore
00:0000142E 207900040B44    	   575: 	move.l textvid_dcb+DCB_OUTBUFPTR,a0
00:00001434 2A48            	   576: 	move.l a0,a5								; a5 = pointer to text screen
                            	   577: .0003:								
00:00001436 203900040B5C    	   578: 	move.l textvid_dcb+DCB_OUTDIMX,d0					; d0 = columns
00:0000143C 223900040B60    	   579: 	move.l textvid_dcb+DCB_OUTDIMY,d1					; d1 = rows
                            	   580: 	if (SCREEN_FORMAT==1)
00:00001442 E580            	   581: 		asl.l	#2,d0								; make into cell index
                            	   582: 	else
                            	   583: 		asl.l	#3,d0								; make into cell index
                            	   584: 	endif
00:00001444 41F50800        	   585: 	lea	0(a5,d0.l),a0						; a0 = pointer to second row of text screen
                            	   586: 	if (SCREEN_FORMAT==1)
00:00001448 E488            	   587: 		lsr.l	#2,d0								; get back d0
                            	   588: 	else
                            	   589: 		lsr.l	#3,d0								; get back d0
                            	   590: 	endif
00:0000144A 5381            	   591: 	subq.l #1,d1									; number of rows-1
00:0000144C C0C1            	   592: 	mulu d1,d0									; d0 = count of characters to move
                            	   593: 	if (SCREEN_FORMAT==1)
                            	   594: 	else
                            	   595: 		add.l d0,d0									; d0*2 2 longs per char
                            	   596: 	endif
                            	   597: .0001:
00:0000144E 2AD8            	   598: 	move.l (a0)+,(a5)+
00:00001450 51C8FFFC        	   599: 	dbra d0,.0001
00:00001454 4E7A0FE0        	   600: 	movec coreno,d0
00:00001458 4840            	   601: 	swap d0	
00:0000145A 7205            	   602: 	moveq #SCREEN_SEMA,d1
00:0000145C 6100115C        	   603: 	bsr UnlockSemaphore
00:00001460 4CDF2103        	   604: 	movem.l (a7)+,d0/d1/a0/a5
                            	   605: 	; Fall through into blanking out last line
                            	   606: 
                            	   607: ;------------------------------------------------------------------------------
                            	   608: ; Blank out the last line on the screen.
                            	   609: ;------------------------------------------------------------------------------
                            	   610: 
                            	   611: BlankLastLine:
00:00001464 48E7E080        	   612: 	movem.l	d0/d1/d2/a0,-(a7)
00:00001468 4E7A0FE0        	   613: 	movec	coreno,d0
00:0000146C 4840            	   614: 	swap d0	
00:0000146E 7205            	   615: 	moveq	#SCREEN_SEMA,d1
00:00001470 6100110C        	   616: 	bsr	LockSemaphore
00:00001474 207900040B44    	   617: 	move.l textvid_dcb+DCB_OUTBUFPTR,a0
00:0000147A 203900040B5C    	   618: 	move.l textvid_dcb+DCB_OUTDIMX,d0					; d0 = columns
00:00001480 223900040B60    	   619: 	move.l textvid_dcb+DCB_OUTDIMY,d1					; d1 = rows
00:00001486 5341            	   620: 	subq #1,d1									; last row = #rows-1
00:00001488 C0C1            	   621: 	mulu d1,d0									; d0 = index of last line
                            	   622: 	if (SCREEN_FORMAT==1)
00:0000148A E588            	   623: 		lsl.l	#2,d0								; *4 bytes per char
                            	   624: 	else
                            	   625: 		lsl.l	#3,d0								; *8 bytes per char
                            	   626: 	endif
00:0000148C 41F00800        	   627: 	lea	(a0,d0.l),a0						; point a0 to last row
00:00001490 243900040B5C    	   628: 	move.l textvid_dcb+DCB_OUTDIMX,d2					; number of text cells to clear
00:00001496 5382            	   629: 	subq.l #1,d2								; count must be one less than desired
00:00001498 6100FD7E        	   630: 	bsr	get_screen_color				; d0,d1 = screen color
                            	   631: 	if (SCREEN_FORMAT==1)
00:0000149C 303C0020        	   632: 		move.w #32,d0
                            	   633: 	else
                            	   634: 		move.w #32,d0								; set the character for display in low 16 bits
                            	   635: 	endif
00:000014A0 E158            	   636: 	rol.w	#8,d0
00:000014A2 4840            	   637: 	swap d0
00:000014A4 E158            	   638: 	rol.w	#8,d0
                            	   639: .0001:
                            	   640: 	if (SCREEN_FORMAT==1)
00:000014A6 20C0            	   641: 		move.l d0,(a0)+
                            	   642: 	else
                            	   643: 		move.l d0,(a0)+
                            	   644: 		bsr rbo
                            	   645: 		move.l d1,(a0)+
                            	   646: 	endif
00:000014A8 51CAFFFC        	   647: 	dbra d2,.0001
00:000014AC 4E7A0FE0        	   648: 	movec	coreno,d0
00:000014B0 4840            	   649: 	swap d0	
00:000014B2 7205            	   650: 	moveq #SCREEN_SEMA,d1
00:000014B4 61001104        	   651: 	bsr UnlockSemaphore
00:000014B8 4CDF0107        	   652: 	movem.l	(a7)+,d0/d1/d2/a0
00:000014BC 4E75            	   653: 	rts
                            	   654: 
                            	   655: ;------------------------------------------------------------------------------
                            	   656: ; Set cursor position to top left of screen.
                            	   657: ;
                            	   658: ; Parameters:
                            	   659: ;		<none>
                            	   660: ; Returns:
                            	   661: ;		<none>
                            	   662: ; Registers Affected:
                            	   663: ;		<none>
                            	   664: ;------------------------------------------------------------------------------
                            	   665: 
                            	   666: HomeCursor:
00:000014BE 42B900040B28    	   667: 	clr.l textvid_dcb+DCB_OUTPOSX
00:000014C4 42B900040B2C    	   668: 	clr.l textvid_dcb+DCB_OUTPOSY
00:000014CA 42B900040B30    	   669: 	clr.l textvid_dcb+DCB_OUTPOSZ
                            	   670: 	; fall through
                            	   671: 
                            	   672: ;------------------------------------------------------------------------------
                            	   673: ; SyncCursor:
                            	   674: ;
                            	   675: ; Sync the hardware cursor's position to the text cursor position but only for
                            	   676: ; the core with the IO focus.
                            	   677: ;
                            	   678: ; Parameters:
                            	   679: ;		<none>
                            	   680: ; Returns:
                            	   681: ;		<none>
                            	   682: ; Registers Affected:
                            	   683: ;		<none>
                            	   684: ;------------------------------------------------------------------------------
                            	   685: 
                            	   686: SyncCursor:
00:000014D0 23FCFFFFFFFDFD0F	   687: 	move.l #$FFFFFFFD,leds
00:000014D8 FF00
00:000014DA 48E7E000        	   688: 	movem.l	d0/d1/d2,-(a7)
00:000014DE 4E7A0FE0        	   689: 	movec	coreno,d0
00:000014E2 B03900100000    	   690: 	cmp.b	IOFocus,d0
00:000014E8 6622            	   691: 	bne.s .0001
00:000014EA 203900040B28    	   692: 	move.l textvid_dcb+DCB_OUTPOSX,d0
00:000014F0 223900040B2C    	   693: 	move.l textvid_dcb+DCB_OUTPOSY,d1
00:000014F6 243900040B5C    	   694: 	move.l textvid_dcb+DCB_OUTDIMX,d2
00:000014FC C4C1            	   695: 	mulu d1,d2
00:000014FE D480            	   696: 	add.l d0,d2
00:00001500 E15A            	   697: 	rol.w	#8,d2					; swap byte order
00:00001502 4842            	   698: 	swap d2
00:00001504 E15A            	   699: 	rol.w #8,d2
00:00001506 23C2FD080024    	   700: 	move.l d2,TEXTREG+$24
                            	   701: .0001:	
00:0000150C 4CDF0007        	   702: 	movem.l	(a7)+,d0/d1/d2
00:00001510 4E75            	   703: 	rts
                            	   704: 
                            	   705: 

Source: "boot.x68"
                            	   577: 	include "err.x68"

Source: "err.x68"
                            	     1: ;------------------------------------------------------------------------------
                            	     2: ;------------------------------------------------------------------------------
                            	     3: ; Setup the err device
                            	     4: ;------------------------------------------------------------------------------
                            	     5: ;------------------------------------------------------------------------------
                            	     6: 
                            	     7: setup_err:
                            	     8: err_init:
00:00001512 7020            	     9: 	moveq #32,d0
00:00001514 41F900040B8C    	    10: 	lea.l err_dcb,a0
                            	    11: .0001:
00:0000151A 4298            	    12: 	clr.l (a0)+
00:0000151C 51C8FFFC        	    13: 	dbra d0,.0001
00:00001520 23FC204243440004	    14: 	move.l #$20424344,err_dcb+DCB_MAGIC				; 'DCB'
00:00001528 0B8C
00:0000152A 23FC4C4C554E0004	    15: 	move.l #$4C4C554E,err_dcb+DCB_NAME					; 'err'
00:00001532 0B90
00:00001534 23FC000015400004	    16: 	move.l #err_cmdproc,err_dcb+DCB_CMDPROC
00:0000153C 0BA4
                            	    17: err_ret:
00:0000153E 4E75            	    18: 	rts
                            	    19: 
                            	    20: err_cmdproc:
00:00001540 7000            	    21: 	moveq #E_Ok,d0
00:00001542 4E75            	    22: 	rts
                            	    23: 
                            	    24: 

Source: "boot.x68"
                            	   578: 	include "serial.x68"

Source: "serial.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;==============================================================================
                            	    38: ; Serial I/O routines
                            	    39: ;==============================================================================
                            	    40: 
                            	    41: 	code
                            	    42: 	align 2
                            	    43: COM_CMDTBL:
00:00001544 00001574        	    44: 	dc.l serial_init
00:00001548 000015FA        	    45: 	dc.l serial_stat
00:0000154C 000015FE        	    46: 	dc.l serial_putchar
00:00001550 0000162C        	    47: 	dc.l serial_putbuf
00:00001554 00001606        	    48: 	dc.l serial_getchar
00:00001558 0000162C        	    49: 	dc.l serial_getbuf
00:0000155C 0000162C        	    50: 	dc.l serial_set_inpos
00:00001560 0000162C        	    51: 	dc.l serial_set_outpos
00:00001564 0000160C        	    52: 	dc.l serial_getchar_direct
00:00001568 00001614        	    53: 	dc.l serial_peek_char
00:0000156C 0000161C        	    54: 	dc.l serial_peek_char_direct
00:00001570 00001624        	    55: 	dc.l serial_putchar_direct
                            	    56: 
                            	    57: ;------------------------------------------------------------------------------
                            	    58: ; Setup the console device
                            	    59: ; stdout = text screen controller
                            	    60: ;------------------------------------------------------------------------------
                            	    61: 	even
                            	    62: 
                            	    63: serial_init:
                            	    64: setup_serial:
00:00001574 48E780C0        	    65: 	movem.l d0/a0/a1,-(a7)
00:00001578 701F            	    66: 	moveq #31,d0
00:0000157A 41F900040C94    	    67: 	lea.l serial_dcb,a0
                            	    68: .0001:
00:00001580 4298            	    69: 	clr.l (a0)+
00:00001582 51C8FFFC        	    70: 	dbra d0,.0001
00:00001586 23FC444342200004	    71: 	move.l #$44434220,serial_dcb+DCB_MAGIC			; 'DCB'
00:0000158E 0C94
00:00001590 23FC434F4D000004	    72: 	move.l #$434F4D00,serial_dcb+DCB_NAME				; 'COM'
00:00001598 0C98
00:0000159A 23FC000015D80004	    73: 	move.l #serial_cmdproc,serial_dcb+DCB_CMDPROC
00:000015A2 0CAC
00:000015A4 23FC001010000004	    74: 	move.l #SerRcvBuf,serial_dcb+DCB_INBUFPTR
00:000015AC 0CCC
00:000015AE 23FC001020000004	    75: 	move.l #SerXmitBuf,serial_dcb+DCB_OUTBUFPTR
00:000015B6 0CD0
00:000015B8 23FC000010000004	    76: 	move.l #4096,serial_dcb+DCB_INBUFSIZE
00:000015C0 0CD4
00:000015C2 616C            	    77: 	bsr SerialInit
00:000015C4 43F900040C94    	    78: 	lea.l serial_dcb,a1
00:000015CA 61006518        	    79: 	jsr DisplayString
00:000015CE 610064FA        	    80: 	jsr CRLF
00:000015D2 4CDF0301        	    81: 	movem.l (a7)+,d0/a0/a1
00:000015D6 4E75            	    82: 	rts
                            	    83: 
                            	    84: serial_cmdproc:
00:000015D8 0C06000C        	    85: 	cmpi.b #12,d6
00:000015DC 6418            	    86: 	bhs.s .0001
00:000015DE 48E70280        	    87: 	movem.l d6/a0,-(a7)
00:000015E2 4886            	    88: 	ext.w d6
00:000015E4 E54E            	    89: 	lsl.w #2,d6
00:000015E6 41FAFF5C        	    90: 	lea COM_CMDTBL,a0
00:000015EA 20706000        	    91: 	move.l (a0,d6.w),a0
00:000015EE 4E90            	    92: 	jsr (a0)
00:000015F0 4CDF0140        	    93: 	movem.l (a7)+,d6/a0
00:000015F4 4E75            	    94: 	rts
                            	    95: .0001:
00:000015F6 7002            	    96: 	moveq #E_Func,d0
00:000015F8 4E75            	    97: 	rts
                            	    98: 
                            	    99: serial_stat:
00:000015FA 7000            	   100: 	moveq #E_Ok,d0
00:000015FC 4E75            	   101: 	rts
                            	   102: 
                            	   103: serial_putchar:
00:000015FE 6100013C        	   104: 	bsr SerialPutChar
00:00001602 7000            	   105: 	moveq #E_Ok,d0
00:00001604 4E75            	   106: 	rts
                            	   107: 
                            	   108: serial_getchar:
00:00001606 6166            	   109: 	bsr SerialGetChar
00:00001608 7000            	   110: 	moveq #E_Ok,d0
00:0000160A 4E75            	   111: 	rts
                            	   112: 
                            	   113: serial_getchar_direct:
00:0000160C 61000114        	   114: 	bsr SerialPeekCharDirect
00:00001610 7000            	   115: 	moveq #E_Ok,d0
00:00001612 4E75            	   116: 	rts
                            	   117: 
                            	   118: serial_peek_char:
00:00001614 610000D0        	   119: 	bsr SerialPeekChar
00:00001618 7000            	   120: 	moveq #E_Ok,d0
00:0000161A 4E75            	   121: 	rts
                            	   122: 
                            	   123: serial_peek_char_direct:
00:0000161C 61000104        	   124: 	bsr SerialPeekCharDirect
00:00001620 7000            	   125: 	moveq #E_Ok,d0
00:00001622 4E75            	   126: 	rts
                            	   127: 
                            	   128: serial_putchar_direct:
00:00001624 6100017A        	   129: 	bsr SerialPutCharDirect
00:00001628 7000            	   130: 	moveq #E_Ok,d0
00:0000162A 4E75            	   131: 	rts
                            	   132: 
                            	   133: serial_putbuf:
                            	   134: serial_getbuf:
                            	   135: serial_set_inpos:
                            	   136: serial_set_outpos:
00:0000162C 700A            	   137: 	moveq #E_NotSupported,d0
00:0000162E 4E75            	   138: 	rts
                            	   139: 
                            	   140: ;------------------------------------------------------------------------------
                            	   141: ; Initialize the serial port an enhanced 6551 circuit.
                            	   142: ;
                            	   143: ; Select internal baud rate clock divider for 9600 baud
                            	   144: ; Reset fifos, set threshold to 3/4 full on transmit and 3/4 empty on receive
                            	   145: ; Note that the byte order is swapped.
                            	   146: ;------------------------------------------------------------------------------
                            	   147: 
                            	   148: SerialInit:
00:00001630 427900100162    	   149: 	clr.w		SerHeadRcv					; clear receive buffer indexes
00:00001636 427900100160    	   150: 	clr.w		SerTailRcv
00:0000163C 427900100168    	   151: 	clr.w		SerHeadXmit					; clear transmit buffer indexes
00:00001642 427900100166    	   152: 	clr.w		SerTailXmit
00:00001648 423900100164    	   153: 	clr.b		SerRcvXon						; and Xon,Xoff flags
00:0000164E 423900100165    	   154: 	clr.b		SerRcvXoff
00:00001654 203C09000000    	   155: 	move.l	#$09000000,d0				; dtr,rts active, rxint enabled, no parity
00:0000165A 23C0FD060008    	   156: 	move.l	d0,ACIA+ACIA_CMD
                            	   157: ;	move.l	#$1E00F700,d0				; fifos enabled
00:00001660 203C1E000000    	   158: 	move.l	#$1E000000,d0				; fifos disabled
00:00001666 23C0FD06000C    	   159: 	move.l	d0,ACIA+ACIA_CTRL
00:0000166C 4E75            	   160: 	rts
                            	   161: ;	move.l	#$0F000000,d0				; transmit a break for a while
                            	   162: ;	move.l	d0,ACIA+ACIA_CMD
                            	   163: ;	move.l	#300000,d2					; wait 100 ms
                            	   164: ;	bra			.0001
                            	   165: ;.0003:
                            	   166: ;	swap		d2
                            	   167: ;.0001:
                            	   168: ;	nop
                            	   169: ;	dbra		d2,.0001
                            	   170: ;.0002:
                            	   171: ;	swap		d2
                            	   172: ;	dbra		d2,.0003
                            	   173: ;	move.l	#$07000000,d0				; clear break
                            	   174: ;	move.l	d0,ACIA+ACIA_CMD
                            	   175: ;	rts
                            	   176: 	
                            	   177: ;------------------------------------------------------------------------------
                            	   178: ; SerialGetChar
                            	   179: ;
                            	   180: ; Check the serial port buffer to see if there's a char available. If there's
                            	   181: ; a char available then return it. If the buffer is almost empty then send an
                            	   182: ; XON.
                            	   183: ;
                            	   184: ; Stack Space:
                            	   185: ;		2 long words
                            	   186: ; Parameters:
                            	   187: ;		none
                            	   188: ; Modifies:
                            	   189: ;		d0,a0
                            	   190: ; Returns:
                            	   191: ;		d1 = character or -1
                            	   192: ;------------------------------------------------------------------------------
                            	   193: 
                            	   194: SerialGetChar:
00:0000166E 2F02            	   195: 	move.l		d2,-(a7)
00:00001670 4E7A0FE0        	   196: 	movec			coreno,d0
00:00001674 4840            	   197: 	swap			d0
00:00001676 7202            	   198: 	moveq			#SERIAL_SEMA,d1
00:00001678 61000F04        	   199: 	bsr				LockSemaphore
00:0000167C 61000146        	   200: 	bsr				SerialRcvCount			; check number of chars in receive buffer
00:00001680 0C400008        	   201: 	cmpi.w		#8,d0								; less than 8?
00:00001684 621C            	   202: 	bhi				.sgc2
00:00001686 4A3900100164    	   203: 	tst.b			SerRcvXon						; skip sending XON if already sent
00:0000168C 6614            	   204: 	bne	  		.sgc2            		; XON already sent?
00:0000168E 123C0011        	   205: 	move.b		#XON,d1							; if <8 send an XON
00:00001692 423900100165    	   206: 	clr.b			SerRcvXoff					; clear XOFF status
00:00001698 13C100100164    	   207: 	move.b		d1,SerRcvXon				; flag so we don't send it multiple times
00:0000169E 6100009C        	   208: 	bsr				SerialPutChar				; send it
                            	   209: .sgc2:
00:000016A2 323900100162    	   210: 	move.w		SerHeadRcv,d1				; check if anything is in buffer
00:000016A8 B27900100160    	   211: 	cmp.w			SerTailRcv,d1
00:000016AE 6720            	   212: 	beq				.NoChars						; no?
00:000016B0 41F900101000    	   213: 	lea				SerRcvBuf,a0
00:000016B6 12301000        	   214: 	move.b		(a0,d1.w),d1				; get byte from buffer
00:000016BA 527900100162    	   215: 	addi.w		#1,SerHeadRcv
00:000016C0 02790FFF00100162	   216: 	andi.w		#$FFF,SerHeadRcv		; 4k wrap around
00:000016C8 0281000000FF    	   217: 	andi.l		#$FF,d1
00:000016CE 6002            	   218: 	bra				.Xit
                            	   219: .NoChars:
00:000016D0 72FF            	   220: 	moveq			#-1,d1
                            	   221: .Xit:
00:000016D2 C342            	   222: 	exg				d1,d2
00:000016D4 4E7A0FE0        	   223: 	movec			coreno,d0
00:000016D8 4840            	   224: 	swap			d0
00:000016DA 7202            	   225: 	moveq			#SERIAL_SEMA,d1
00:000016DC 61000EDC        	   226: 	bsr				UnlockSemaphore
00:000016E0 C541            	   227: 	exg				d2,d1
00:000016E2 241F            	   228: 	move.l		(a7)+,d2
00:000016E4 4E75            	   229: 	rts
                            	   230: 
                            	   231: ;------------------------------------------------------------------------------
                            	   232: ; SerialPeekChar
                            	   233: ;
                            	   234: ; Check the serial port buffer to see if there's a char available. If there's
                            	   235: ; a char available then return it. But don't update the buffer indexes. No need
                            	   236: ; to send an XON here.
                            	   237: ;
                            	   238: ; Stack Space:
                            	   239: ;		1 long word
                            	   240: ; Parameters:
                            	   241: ;		none
                            	   242: ; Modifies:
                            	   243: ;		d0,a0
                            	   244: ; Returns:
                            	   245: ;		d1 = character or -1
                            	   246: ;------------------------------------------------------------------------------
                            	   247: 
                            	   248: SerialPeekChar:
00:000016E6 2F02            	   249: 	move.l d2,-(a7)
00:000016E8 4E7A0FE0        	   250: 	movec	coreno,d0
00:000016EC 4840            	   251: 	swap d0
00:000016EE 7202            	   252: 	moveq	#SERIAL_SEMA,d1
00:000016F0 61000E8C        	   253: 	bsr	LockSemaphore
00:000016F4 343900100162    	   254: 	move.w SerHeadRcv,d2		; check if anything is in buffer
00:000016FA B47900100160    	   255: 	cmp.w	SerTailRcv,d2
00:00001700 670C            	   256: 	beq	.NoChars				; no?
00:00001702 41F900101000    	   257: 	lea	SerRcvBuf,a0
00:00001708 14302000        	   258: 	move.b (a0,d2.w),d2		; get byte from buffer
00:0000170C 6002            	   259: 	bra	.Xit
                            	   260: .NoChars:
00:0000170E 74FF            	   261: 	moveq	#-1,d2
                            	   262: .Xit:
00:00001710 4E7A0FE0        	   263: 	movec	coreno,d0
00:00001714 4840            	   264: 	swap d0
00:00001716 7202            	   265: 	moveq	#SERIAL_SEMA,d1
00:00001718 61000EA0        	   266: 	bsr	UnlockSemaphore
00:0000171C 2202            	   267: 	move.l	d2,d1
00:0000171E 241F            	   268: 	move.l (a7)+,d2
00:00001720 4E75            	   269: 	rts
                            	   270: 
                            	   271: ;------------------------------------------------------------------------------
                            	   272: ; SerialPeekChar
                            	   273: ;		Get a character directly from the I/O port. This bypasses the input
                            	   274: ; buffer.
                            	   275: ;
                            	   276: ; Stack Space:
                            	   277: ;		0 words
                            	   278: ; Parameters:
                            	   279: ;		none
                            	   280: ; Modifies:
                            	   281: ;		d
                            	   282: ; Returns:
                            	   283: ;		d1 = character or -1
                            	   284: ;------------------------------------------------------------------------------
                            	   285: 
                            	   286: SerialPeekCharDirect:
00:00001722 1239FD060004    	   287: 	move.b	ACIA+ACIA_STAT,d1	; get serial status
00:00001728 08010003        	   288: 	btst		#3,d1							; look for Rx not empty
00:0000172C 670A            	   289: 	beq.s		.0001
00:0000172E 7200            	   290: 	moveq.l	#0,d1							; clear upper bits of return value
00:00001730 1239FD060000    	   291: 	move.b	ACIA+ACIA_RX,d1		; get data from ACIA
00:00001736 4E75            	   292: 	rts												; return
                            	   293: .0001:
00:00001738 72FF            	   294: 	moveq		#-1,d1
00:0000173A 4E75            	   295: 	rts
                            	   296: 
                            	   297: ;------------------------------------------------------------------------------
                            	   298: ; SerialPutChar
                            	   299: ;		If there is a transmit buffer, adds the character to the transmit buffer
                            	   300: ; if it can, otherwise will wait for a byte to be freed up in the transmit
                            	   301: ; buffer (blocks).
                            	   302: ;		If there is no transmit buffer, put a character to the directly to the
                            	   303: ; serial transmitter. This routine blocks until the transmitter is empty. 
                            	   304: ;
                            	   305: ; Stack Space
                            	   306: ;		4 long words
                            	   307: ; Parameters:
                            	   308: ;		d1.b = character to put
                            	   309: ; Modifies:
                            	   310: ;		none
                            	   311: ;------------------------------------------------------------------------------
                            	   312: 
                            	   313: SerialPutChar:
                            	   314: .0004:
00:0000173C 4A7900040CD8    	   315: 	tst.w serial_dcb+DCB_OUTBUFSIZE	; buffered output?
00:00001742 675C            	   316: 	beq.s SerialPutCharDirect
00:00001744 48E7E080        	   317: 	movem.l d0/d1/d2/a0,-(a7)
00:00001748 4E7A0FE0        	   318: 	movec	coreno,d0
00:0000174C 4840            	   319: 	swap d0
00:0000174E 7202            	   320: 	moveq	#SERIAL_SEMA,d1
00:00001750 61000E2C        	   321: 	bsr	LockSemaphore
00:00001754 303900100166    	   322: 	move.w SerTailXmit,d0
00:0000175A 3400            	   323: 	move.w d0,d2
00:0000175C 5240            	   324: 	addi.w #1,d0
00:0000175E B07900040CD8    	   325: 	cmp.w serial_dcb+DCB_OUTBUFSIZE,d0
00:00001764 6502            	   326: 	blo.s .0002
00:00001766 4240            	   327: 	clr.w d0
                            	   328: .0002:
00:00001768 B07900100168    	   329: 	cmp.w SerHeadXmit,d0			; Is Xmit buffer full?
00:0000176E 660E            	   330: 	bne.s .0003
00:00001770 4E7A0FE0        	   331: 	movec	coreno,d0						; buffer full, unlock semaphore and wait
00:00001774 4840            	   332: 	swap d0
00:00001776 7202            	   333: 	moveq	#SERIAL_SEMA,d1
00:00001778 61000E40        	   334: 	bsr	UnlockSemaphore
00:0000177C 60BE            	   335: 	bra.s .0004
                            	   336: .0003:
00:0000177E 33C000100166    	   337: 	move.w d0,SerTailXmit			; update tail pointer
00:00001784 41F900102000    	   338: 	lea SerXmitBuf,a0
00:0000178A 11812000        	   339: 	move.b d1,(a0,d2.w)				; store byte in Xmit buffer
00:0000178E 4E7A0FE0        	   340: 	movec	coreno,d0						; unlock semaphore
00:00001792 4840            	   341: 	swap d0
00:00001794 7202            	   342: 	moveq	#SERIAL_SEMA,d1
00:00001796 61000E22        	   343: 	bsr	UnlockSemaphore
00:0000179A 4CDF0107        	   344: 	movem.l (a7)+,d0/d1/d2/a0
00:0000179E 4E75            	   345: 	rts
                            	   346: 
                            	   347: SerialPutCharDirect:
00:000017A0 48E7C000        	   348: 	movem.l	d0/d1,-(a7)							; push d0,d1
                            	   349: .0001:
00:000017A4 1039FD060004    	   350: 	move.b ACIA+ACIA_STAT,d0	; wait until the uart indicates tx empty
00:000017AA 08000004        	   351: 	btst #4,d0								; bit #4 of the status reg
00:000017AE 67F4            	   352: 	beq.s	.0001			    			; branch if transmitter is not empty
00:000017B0 13C1FD060000    	   353: 	move.b d1,ACIA+ACIA_TX		; send the byte
00:000017B6 4CDF0003        	   354: 	movem.l	(a7)+,d0/d1				; pop d0,d1
00:000017BA 4E75            	   355: 	rts
                            	   356: 	
                            	   357: ;------------------------------------------------------------------------------
                            	   358: ; Reverse the order of bytes in d1.
                            	   359: ;------------------------------------------------------------------------------
                            	   360: 
                            	   361: SerialRbo:
00:000017BC E159            	   362: 	rol.w		#8,d1
00:000017BE 4841            	   363: 	swap		d1
00:000017C0 E159            	   364: 	rol.w		#8,d1
00:000017C2 4E75            	   365: 	rts
                            	   366: 
                            	   367: ;------------------------------------------------------------------------------
                            	   368: ; Calculate number of character in input buffer
                            	   369: ;
                            	   370: ; Returns:
                            	   371: ;		d0 = number of bytes in buffer.
                            	   372: ;------------------------------------------------------------------------------
                            	   373: 
                            	   374: SerialRcvCount:
00:000017C4 303900100160    	   375: 	move.w	SerTailRcv,d0
00:000017CA 907900100162    	   376: 	sub.w		SerHeadRcv,d0
00:000017D0 6C10            	   377: 	bge			.0001
00:000017D2 303C1000        	   378: 	move.w	#$1000,d0
00:000017D6 907900100162    	   379: 	sub.w		SerHeadRcv,d0
00:000017DC D07900100160    	   380: 	add.w		SerTailRcv,d0
                            	   381: .0001:
00:000017E2 4E75            	   382: 	rts
                            	   383: 
                            	   384: ;------------------------------------------------------------------------------
                            	   385: ; Serial IRQ routine
                            	   386: ;
                            	   387: ; Keeps looping as long as it finds characters in the ACIA recieve buffer/fifo.
                            	   388: ; Received characters are buffered. If the buffer becomes full, new characters
                            	   389: ; will be lost.
                            	   390: ;
                            	   391: ; Parameters:
                            	   392: ;		none
                            	   393: ; Modifies:
                            	   394: ;		none
                            	   395: ; Returns:
                            	   396: ;		d1 = -1 if IRQ handled, otherwise zero
                            	   397: ;------------------------------------------------------------------------------
                            	   398: 
                            	   399: SerialIRQ:
00:000017E4 46FC2300        	   400: 	move.w	#$2300,sr						; disable lower level IRQs
00:000017E8 48E7E080        	   401: 	movem.l	d0/d1/d2/a0,-(a7)
00:000017EC 4E7A0FE0        	   402: 	movec	coreno,d0
00:000017F0 4840            	   403: 	swap d0
00:000017F2 7202            	   404: 	moveq	#SERIAL_SEMA,d1
00:000017F4 61000D88        	   405: 	bsr	LockSemaphore
                            	   406: sirqNxtByte:
00:000017F8 1239FD060004    	   407: 	move.b ACIA+ACIA_STAT,d1		; check the status
00:000017FE 08010003        	   408: 	btst #3,d1									; bit 3 = rx full
00:00001802 6756            	   409: 	beq	notRxInt
00:00001804 1239FD060000    	   410: 	move.b ACIA+ACIA_RX,d1
                            	   411: sirq0001:
00:0000180A 303900100160    	   412: 	move.w SerTailRcv,d0				; check if recieve buffer full
00:00001810 5240            	   413: 	addi.w #1,d0
00:00001812 02400FFF        	   414: 	andi.w #$FFF,d0
00:00001816 B07900100162    	   415: 	cmp.w	SerHeadRcv,d0
00:0000181C 673C            	   416: 	beq	sirqRxFull
00:0000181E 33C000100160    	   417: 	move.w d0,SerTailRcv				; update tail pointer
00:00001824 5340            	   418: 	subi.w #1,d0								; backup
00:00001826 02400FFF        	   419: 	andi.w #$FFF,d0
00:0000182A 41F900101000    	   420: 	lea	SerRcvBuf,a0						; a0 = buffer address
00:00001830 11810000        	   421: 	move.b d1,(a0,d0.w)					; store recieved byte in buffer
00:00001834 4A3900100165    	   422: 	tst.b	SerRcvXoff						; check if xoff already sent
00:0000183A 66BC            	   423: 	bne	sirqNxtByte
00:0000183C 6186            	   424: 	bsr	SerialRcvCount					; if more than 4080 chars in buffer
00:0000183E 0C400FF0        	   425: 	cmpi.w #4080,d0
00:00001842 65B4            	   426: 	blo	sirqNxtByte
00:00001844 123C0013        	   427: 	move.b #XOFF,d1							; send an XOFF
00:00001848 423900100164    	   428: 	clr.b	SerRcvXon							; clear XON status
00:0000184E 13C100100165    	   429: 	move.b d1,SerRcvXoff				; set XOFF status
00:00001854 6100FEE6        	   430: 	bsr	SerialPutChar						; send XOFF
00:00001858 609E            	   431: 	bra	sirqNxtByte     				; check the status for another byte
                            	   432: sirqRxFull:
                            	   433: notRxInt:
00:0000185A 08010004        	   434: 	btst #4,d1									; TX empty?
00:0000185E 6748            	   435: 	beq.s notTxInt
00:00001860 4A390010016A    	   436: 	tst.b SerXmitXoff						; and allowed to send?
00:00001866 6640            	   437: 	bne.s sirqXmitOff
00:00001868 4AB900040CD8    	   438: 	tst.l serial_dcb+DCB_OUTBUFSIZE	; Is there a buffer being transmitted?
00:0000186E 6738            	   439: 	beq.s notTxInt
00:00001870 303900100168    	   440: 	move.w SerHeadXmit,d0
00:00001876 B07900100166    	   441: 	cmp.w SerTailXmit,d0
00:0000187C 672A            	   442: 	beq.s sirqTxEmpty
00:0000187E 41F900102000    	   443: 	lea SerXmitBuf,a0
00:00001884 12300000        	   444: 	move.b (a0,d0.w),d1
00:00001888 13C1FD060000    	   445: 	move.b d1,ACIA+ACIA_TX			; transmit character
00:0000188E 527900100168    	   446: 	addi.w #1,SerHeadXmit				; advance head index
00:00001894 303900040CD8    	   447: 	move.w serial_dcb+DCB_OUTBUFSIZE,d0
00:0000189A B07900100168    	   448: 	cmp.w SerHeadXmit,d0
00:000018A0 6206            	   449: 	bhi.s sirq0002
00:000018A2 427900100168    	   450: 	clr.w SerHeadXmit						; wrap around
                            	   451: sirq0002:
                            	   452: sirqXmitOff:
                            	   453: sirqTxEmpty:
                            	   454: notTxInt:
00:000018A8 4E7A0FE0        	   455: 	movec	coreno,d0
00:000018AC 4840            	   456: 	swap d0
00:000018AE 7202            	   457: 	moveq	#SERIAL_SEMA,d1
00:000018B0 61000D08        	   458: 	bsr	UnlockSemaphore
00:000018B4 4CDF0107        	   459: 	movem.l	(a7)+,d0/d1/d2/a0
00:000018B8 4E73            	   460: 	rte
                            	   461: 
                            	   462: nmeSerial:
00:000018BA 53657269616C    	   463: 	dc.b		"Serial",0
00:000018C0 00
                            	   464: 
                            	   465: 

Source: "boot.x68"
                            	   579: 	include "framebuf.x68"

Source: "framebuf.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: FRAMEBUF_CTRL equ 0
                            	    38: FRAMEBUF_PAGE1_ADDR equ 2*8
                            	    39: FRAMEBUF_PAGE2_ADDR equ 3*8
                            	    40: FRAMEBUF_BMPSIZE_X equ 13*8
                            	    41: FRAMEBUF_BMPSIZE_Y equ 13*8+4
                            	    42: FRAMEBUF_WINDOW_DIMEN	equ	15*8
                            	    43: FRAMEBUF_COLOR_COMP	equ 19*8
                            	    44: FRAMEBUF_PRGB equ 20*8
                            	    45: FRAMEBUF_COLOR equ 21*8
                            	    46: FRAMEBUF_PPS equ 22*8
                            	    47: 
                            	    48: ;------------------------------------------------------------------------------
                            	    49: ;------------------------------------------------------------------------------
                            	    50: ; Video frame buffer
                            	    51: ;------------------------------------------------------------------------------
                            	    52: ;------------------------------------------------------------------------------
                            	    53: 	code
                            	    54: 	even
                            	    55: 	align 2
                            	    56: FRAMEBUF_CMDTBL:
00:000018C4 000019E6        	    57: 	dc.l framebuf_init				; 0
00:000018C8 00001A90        	    58: 	dc.l framebuf_stat
00:000018CC 00001A90        	    59: 	dc.l framebuf_putchar
00:000018D0 00001B4C        	    60: 	dc.l framebuf_putbuf
00:000018D4 00001A90        	    61: 	dc.l framebuf_getchar
00:000018D8 00001B4C        	    62: 	dc.l framebuf_getbuf
00:000018DC 00001A92        	    63: 	dc.l framebuf_set_inpos
00:000018E0 00001AA0        	    64: 	dc.l framebuf_set_outpos
00:000018E4 00001B4C        	    65: 	dc.l framebuf_stub
00:000018E8 00001B4C        	    66: 	dc.l framebuf_stub
00:000018EC 00001B4C        	    67: 	dc.l framebuf_stub				; 10
00:000018F0 00001B4C        	    68: 	dc.l framebuf_stub
00:000018F4 00001D4C        	    69: 	dc.l framebuf_clear
00:000018F8 00001ADA        	    70: 	dc.l framebuf_swapbuf
00:000018FC 00001ABE        	    71: 	dc.l framebuf_setbuf1
00:00001900 00001ACC        	    72: 	dc.l framebuf_setbuf2
00:00001904 00001AAE        	    73: 	dc.l framebuf_getbuf1
00:00001908 00001AB6        	    74: 	dc.l framebuf_getbuf2
00:0000190C 00001C1E        	    75: 	dc.l framebuf_writeat
00:00001910 00001B42        	    76: 	dc.l framebuf_set_unit
00:00001914 00001B72        	    77: 	dc.l framebuf_get_dimen	; 20
00:00001918 00001B62        	    78: 	dc.l framebuf_get_color
00:0000191C 00001B4C        	    79: 	dc.l framebuf_stub
00:00001920 00001B4C        	    80: 	dc.l framebuf_stub
00:00001924 00001B4C        	    81: 	dc.l framebuf_stub
00:00001928 00001B4C        	    82: 	dc.l framebuf_stub
00:0000192C 00001B4C        	    83: 	dc.l framebuf_stub
00:00001930 00001B4C        	    84: 	dc.l framebuf_stub
00:00001934 00001B4C        	    85: 	dc.l framebuf_stub
00:00001938 00001B4C        	    86: 	dc.l framebuf_stub
00:0000193C 00001B4C        	    87: 	dc.l framebuf_stub			; 30
00:00001940 00001B4C        	    88: 	dc.l framebuf_stub
00:00001944 00001BA2        	    89: 	dc.l framebuf_set_dimen
00:00001948 00001B50        	    90: 	dc.l framebuf_set_color_depth
00:0000194C 00001A90        	    91: 	dc.l framebuf_set_destbuf
00:00001950 00001B38        	    92: 	dc.l framebuf_set_dispbuf
                            	    93: 
                            	    94: 	code
                            	    95: 	even
                            	    96: framebuf_cmdproc:
00:00001954 0C060024        	    97: 	cmpi.b #36,d6
00:00001958 641A            	    98: 	bhs.s .0001
00:0000195A 48E70280        	    99: 	movem.l d6/a0,-(a7)
00:0000195E 4886            	   100: 	ext.w d6
00:00001960 48C6            	   101: 	ext.l d6
00:00001962 E54E            	   102: 	lsl.w #2,d6
00:00001964 41FAFF5E        	   103: 	lea.l FRAMEBUF_CMDTBL,a0
00:00001968 20706000        	   104: 	move.l (a0,d6.w),a0
00:0000196C 4E90            	   105: 	jsr (a0)
00:0000196E 4CDF0140        	   106: 	movem.l (a7)+,d6/a0
00:00001972 4E75            	   107: 	rts
                            	   108: .0001:
00:00001974 7002            	   109: 	moveq #E_Func,d0
00:00001976 4E75            	   110: 	rts
                            	   111: 
                            	   112: setup_framebuf:
00:00001978 48E780C0        	   113: 	movem.l d0/a0/a1,-(a7)
00:0000197C 7020            	   114: 	moveq #32,d0
00:0000197E 41F900040D18    	   115: 	lea.l framebuf_dcb,a0
                            	   116: .0001:
00:00001984 4298            	   117: 	clr.l (a0)+
00:00001986 51C8FFFC        	   118: 	dbra d0,.0001
00:0000198A 23FC444342200004	   119: 	move.l #$44434220,framebuf_dcb+DCB_MAGIC			; 'DCB '
00:00001992 0D18
00:00001994 23FC4652414D0004	   120: 	move.l #$4652414D,framebuf_dcb+DCB_NAME				; 'FRAMEBUF'
00:0000199C 0D1C
00:0000199E 23FC425546000004	   121: 	move.l #$42554600,framebuf_dcb+DCB_NAME+4
00:000019A6 0D20
00:000019A8 23FC000019540004	   122: 	move.l #framebuf_cmdproc,framebuf_dcb+DCB_CMDPROC
00:000019B0 0D30
00:000019B2 7000            	   123: 	move.l #$00000000,d0
00:000019B4 23C000040D50    	   124: 	move.l d0,framebuf_dcb+DCB_INBUFPTR
00:000019BA 23C000040D54    	   125: 	move.l d0,framebuf_dcb+DCB_OUTBUFPTR
00:000019C0 23FC004000000004	   126: 	move.l #$00400000,framebuf_dcb+DCB_INBUFSIZE
00:000019C8 0D58
00:000019CA 23FC004000000004	   127: 	move.l #$00400000,framebuf_dcb+DCB_OUTBUFSIZE
00:000019D2 0D5C
00:000019D4 43F900040D18    	   128: 	lea.l framebuf_dcb+DCB_MAGIC,a1
00:000019DA 61006108        	   129: 	jsr DisplayString
00:000019DE 610060EA        	   130: 	jsr CRLF
00:000019E2 4CDF0301        	   131: 	movem.l (a7)+,d0/a0/a1
                            	   132: 	; fall through
                            	   133: 
                            	   134: framebuf_init:
00:000019E6 13FC0001FD200000	   135: 	move.b #1,FRAMEBUF+0		; turn on frame buffer
00:000019EE 23FC88880000FD20	   136: 	move.l #$88880000,FRAMEBUF+FRAMEBUF_COLOR_COMP	; 8-8-8-8 color
00:000019F6 0098
00:000019F8 13FC0011FD200002	   137: 	move.b #$11,FRAMEBUF+2	; hres 1:1 vres 1:1
00:00001A00 23FC3100000FFD20	   138: 	move.l #$3100000F,FRAMEBUF+4		; burst length, burst interval
00:00001A08 0004
00:00001A0A 23FCFFFFFF000004	   139: 	move.l #$ffffff00,framebuf_dcb+DCB_FGCOLOR	; white
00:00001A12 0D7C
00:00001A14 23FC0F0000000004	   140: 	move.l #$0f000000,framebuf_dcb+DCB_BKCOLOR	; medium blue
00:00001A1C 0D78
00:00001A1E 42B900040D38    	   141: 	clr.l framebuf_dcb+DCB_OUTPOSX
00:00001A24 42B900040D3C    	   142: 	clr.l framebuf_dcb+DCB_OUTPOSY
00:00001A2A 42B900040D44    	   143: 	clr.l framebuf_dcb+DCB_INPOSX
00:00001A30 42B900040D48    	   144: 	clr.l framebuf_dcb+DCB_INPOSY
00:00001A36 13FC000100040D80	   145: 	move.b #1,framebuf_dcb+DCB_OPCODE	; raster op = copy
00:00001A3E 33FC032000040D6C	   146: 	move.w #800,framebuf_dcb+DCB_OUTDIMX		; set rows and columns
00:00001A46 33FC025800040D70	   147: 	move.w #600,framebuf_dcb+DCB_OUTDIMY
00:00001A4E 33FC032000040D60	   148: 	move.w #800,framebuf_dcb+DCB_INDIMX			; set rows and columns
00:00001A56 33FC025800040D64	   149: 	move.w #600,framebuf_dcb+DCB_INDIMY
00:00001A5E 42B900040D50    	   150: 	move.l #$00000000,framebuf_dcb+DCB_INBUFPTR
00:00001A64 23FC004000000004	   151: 	move.l #$00400000,framebuf_dcb+DCB_INBUFPTR2
00:00001A6C 0D88
00:00001A6E 42B900040D54    	   152: 	move.l #$00000000,framebuf_dcb+DCB_OUTBUFPTR
00:00001A74 23FC004000000004	   153: 	move.l #$00400000,framebuf_dcb+DCB_OUTBUFPTR2
00:00001A7C 0D8C
00:00001A7E 42B9FD200010    	   154: 	move.l #$00000000,FRAMEBUF+FRAMEBUF_PAGE1_ADDR	; base addr 1
00:00001A84 23FC00004000FD20	   155: 	move.l #$00004000,FRAMEBUF+FRAMEBUF_PAGE2_ADDR	; base addr 2
00:00001A8C 0018
00:00001A8E 4E75            	   156: 	rts
                            	   157: 
                            	   158: framebuf_stat:
                            	   159: framebuf_putchar:
                            	   160: framebuf_getchar:
                            	   161: framebuf_set_destbuf:
00:00001A90 4E75            	   162: 	rts
                            	   163: 
                            	   164: framebuf_set_inpos:
00:00001A92 23C100040D44    	   165: 	move.l d1,framebuf_dcb+DCB_INPOSX
00:00001A98 23C200040D48    	   166: 	move.l d2,framebuf_dcb+DCB_INPOSY
00:00001A9E 4E75            	   167: 	rts
                            	   168: framebuf_set_outpos:
00:00001AA0 23C100040D38    	   169: 	move.l d1,framebuf_dcb+DCB_OUTPOSX
00:00001AA6 23C200040D3C    	   170: 	move.l d2,framebuf_dcb+DCB_OUTPOSY
00:00001AAC 4E75            	   171: 	rts
                            	   172: 
                            	   173: framebuf_getbuf1:
00:00001AAE 223900040D54    	   174: 	move.l framebuf_dcb+DCB_OUTBUFPTR,d1
00:00001AB4 4E75            	   175: 	rts
                            	   176: framebuf_getbuf2:
00:00001AB6 223900040D8C    	   177: 	move.l framebuf_dcb+DCB_OUTBUFPTR2,d1
00:00001ABC 4E75            	   178: 	rts
                            	   179: framebuf_setbuf1:
00:00001ABE 23C100040D54    	   180: 	move.l d1,framebuf_dcb+DCB_OUTBUFPTR
00:00001AC4 23C200040D5C    	   181: 	move.l d2,framebuf_dcb+DCB_OUTBUFSIZE
00:00001ACA 4E75            	   182: 	rts
                            	   183: framebuf_setbuf2:
00:00001ACC 23C100040D8C    	   184: 	move.l d1,framebuf_dcb+DCB_OUTBUFPTR2
00:00001AD2 23C200040D94    	   185: 	move.l d2,framebuf_dcb+DCB_OUTBUFSIZE2
00:00001AD8 4E75            	   186: 	rts
                            	   187: 
                            	   188: framebuf_swapbuf:
00:00001ADA 48E76000        	   189: 	movem.l d1/d2,-(a7)
00:00001ADE 1239FD200003    	   190: 	move.b FRAMEBUF+3,d1
00:00001AE4 0A010001        	   191: 	eor.b #1,d1
00:00001AE8 13C1FD200003    	   192: 	move.b d1,FRAMEBUF+3					; page flip
00:00001AEE 243900040D54    	   193: 	move.l framebuf_dcb+DCB_OUTBUFPTR,d2
00:00001AF4 203900040D8C    	   194: 	move.l framebuf_dcb+DCB_OUTBUFPTR2,d0
00:00001AFA 23C200040D8C    	   195: 	move.l d2,framebuf_dcb+DCB_OUTBUFPTR2
00:00001B00 23C000040D54    	   196: 	move.l d0,framebuf_dcb+DCB_OUTBUFPTR
00:00001B06 90BC40000000    	   197: 	sub.l #$40000000,d0
00:00001B0C 2200            	   198: 	move.l d0,d1
00:00001B0E 61007C14        	   199: 	bsr rbo
00:00001B12 23C1FD300010    	   200: 	move.l d1,GFXACCEL+16
00:00001B18 243900040D50    	   201: 	move.l framebuf_dcb+DCB_INBUFPTR,d2
00:00001B1E 203900040D88    	   202: 	move.l framebuf_dcb+DCB_INBUFPTR2,d0
00:00001B24 23C200040D88    	   203: 	move.l d2,framebuf_dcb+DCB_INBUFPTR2
00:00001B2A 23C000040D50    	   204: 	move.l d0,framebuf_dcb+DCB_INBUFPTR
00:00001B30 4CDF0006        	   205: 	movem.l (a7)+,d1/d2
00:00001B34 7000            	   206: 	move.l #E_Ok,d0
00:00001B36 4E75            	   207: 	rts
                            	   208: 
                            	   209: framebuf_set_dispbuf:
00:00001B38 13C1FD200003    	   210: 	move.b d1,FRAMEBUF+3					; set display page
00:00001B3E 7000            	   211: 	move.l #E_Ok,d0
00:00001B40 4E75            	   212: 	rts
                            	   213: 
                            	   214: framebuf_set_unit:
00:00001B42 23C100040D98    	   215: 	move.l d1,framebuf_dcb+DCB_UNIT
00:00001B48 7000            	   216: 	move.l #E_Ok,d0
00:00001B4A 4E75            	   217: 	rts
                            	   218: 
                            	   219: framebuf_getbuf:
                            	   220: framebuf_putbuf:
                            	   221: framebuf_stub:
00:00001B4C 700A            	   222: 	moveq #E_NotSupported,d0
00:00001B4E 4E75            	   223: 	rts
                            	   224: 
                            	   225: framebuf_set_color_depth:
00:00001B50 2001            	   226: 	move.l d1,d0
00:00001B52 61007BD0        	   227: 	bsr rbo
00:00001B56 23C1FD200098    	   228: 	move.l d1,FRAMEBUF+FRAMEBUF_COLOR_COMP
00:00001B5C 2200            	   229: 	move.l d0,d1
00:00001B5E 7000            	   230: 	move.l #E_Ok,d0
00:00001B60 4E75            	   231: 	rts
                            	   232: 	
                            	   233: framebuf_get_color:
00:00001B62 223900040D7C    	   234: 	move.l framebuf_dcb+DCB_FGCOLOR,d1
00:00001B68 243900040D78    	   235: 	move.l framebuf_dcb+DCB_BKCOLOR,d2
00:00001B6E 7000            	   236: 	move.l #E_Ok,d0
00:00001B70 4E75            	   237: 	rts
                            	   238: 
                            	   239: framebuf_get_dimen:
00:00001B72 4A00            	   240: 	cmpi.b #0,d0
00:00001B74 6616            	   241: 	bne.s .0001
00:00001B76 223900040D6C    	   242: 	move.l framebuf_dcb+DCB_OUTDIMX,d1
00:00001B7C 243900040D70    	   243: 	move.l framebuf_dcb+DCB_OUTDIMY,d2
00:00001B82 263900040D74    	   244: 	move.l framebuf_dcb+DCB_OUTDIMZ,d3
00:00001B88 7000            	   245: 	move.l #E_Ok,d0
00:00001B8A 4E75            	   246: 	rts
                            	   247: .0001:
00:00001B8C 223900040D60    	   248: 	move.l framebuf_dcb+DCB_INDIMX,d1
00:00001B92 243900040D64    	   249: 	move.l framebuf_dcb+DCB_INDIMY,d2
00:00001B98 263900040D68    	   250: 	move.l framebuf_dcb+DCB_INDIMZ,d3
00:00001B9E 7000            	   251: 	move.l #E_Ok,d0
00:00001BA0 4E75            	   252: 	rts
                            	   253: 
                            	   254: framebuf_set_dimen:
00:00001BA2 4A00            	   255: 	cmpi.b #0,d0
00:00001BA4 6638            	   256: 	bne.s .0001
00:00001BA6 48E76000        	   257: 	movem.l d1/d2,-(a7)
00:00001BAA 23C100040D6C    	   258: 	move.l d1,framebuf_dcb+DCB_OUTDIMX
00:00001BB0 23C200040D70    	   259: 	move.l d2,framebuf_dcb+DCB_OUTDIMY
00:00001BB6 23C300040D74    	   260: 	move.l d3,framebuf_dcb+DCB_OUTDIMZ
00:00001BBC 2001            	   261: 	move.l d1,d0
00:00001BBE 61007B64        	   262: 	bsr rbo
00:00001BC2 23C1FD200068    	   263: 	move.l d1,FRAMEBUF+FRAMEBUF_BMPSIZE_X
00:00001BC8 2202            	   264: 	move.l d2,d1
00:00001BCA 61007B58        	   265: 	bsr rbo
00:00001BCE 23C1FD20006C    	   266: 	move.l d1,FRAMEBUF+FRAMEBUF_BMPSIZE_Y
00:00001BD4 2200            	   267: 	move.l d0,d1
00:00001BD6 4CDF0006        	   268: 	movem.l (a7)+,d1/d2
00:00001BDA 7000            	   269: 	move.l #E_Ok,d0
00:00001BDC 4E75            	   270: 	rts
                            	   271: .0001:
00:00001BDE 0C000001        	   272: 	cmpi.b #1,d0
00:00001BE2 6616            	   273: 	bne.s .0002
00:00001BE4 23C100040D60    	   274: 	move.l d1,framebuf_dcb+DCB_INDIMX
00:00001BEA 23C200040D64    	   275: 	move.l d2,framebuf_dcb+DCB_INDIMY
00:00001BF0 23C300040D68    	   276: 	move.l d3,framebuf_dcb+DCB_INDIMZ
00:00001BF6 7000            	   277: 	move.l #E_Ok,d0
00:00001BF8 4E75            	   278: 	rts
                            	   279: .0002:
00:00001BFA 0C000002        	   280: 	cmpi.b #2,d0		; set window dimensions
00:00001BFE 661A            	   281: 	bne.s .0003
00:00001C00 48E76000        	   282: 	movem.l d1/d2,-(a7)
00:00001C04 48C2            	   283: 	ext.l d2
00:00001C06 4842            	   284: 	swap d2
00:00001C08 48C1            	   285: 	ext.l d1
00:00001C0A 8282            	   286: 	or.l d2,d1
00:00001C0C 61007B16        	   287: 	bsr rbo
00:00001C10 23C1FD200078    	   288: 	move.l d1,FRAMEBUF+FRAMEBUF_WINDOW_DIMEN
00:00001C16 4CDF0006        	   289: 	movem.l (a7)+,d1/d2
                            	   290: .0003:
00:00001C1A 7000            	   291: 	move.l #E_Ok,d0
00:00001C1C 4E75            	   292: 	rts
                            	   293: 
                            	   294: 
                            	   295: ;---------------------------------------------------------------------
                            	   296: ; The following uses point plot hardware built into the frame buffer.
                            	   297: ; It is assumed that previous commands have finished already.
                            	   298: ; It may take a few dozen clocks for a command to complete. As long
                            	   299: ; as this routine is not called to fast in succession it should be
                            	   300: ; okay.
                            	   301: ;---------------------------------------------------------------------
                            	   302: 
                            	   303: framebuf_writeat:
                            	   304: plot:
00:00001C1E 6070            	   305: 	bra plot_sw
00:00001C20 48E76080        	   306: 	movem.l d1/d2/a0,-(a7)
00:00001C24 207CFD200000    	   307: 	move.l #FRAMEBUF,a0
                            	   308: .0001:
                            	   309: ;	tst.b 40(a0)				; wait for any previous command to finish
                            	   310: ;	bne.s .0001										; Then set:
00:00001C2A E159            	   311: 	rol.w #8,d1										; reverse byte order
00:00001C2C 31410020        	   312: 	move.w d1,32(a0)							; pixel x co-ord
00:00001C30 E15A            	   313: 	rol.w #8,d2										; reverse byte order
00:00001C32 31420022        	   314: 	move.w d2,34(a0)							; pixel y co-ord
00:00001C36 317900040D7C002C	   315: 	move.w framebuf_dcb+DCB_FGCOLOR,44(a0)	; pixel color
00:00001C3E 117900040D800029	   316: 	move.b framebuf_dcb+DCB_OPCODE,41(a0)	; set raster operation
00:00001C46 117C00020028    	   317: 	move.b #2,40(a0)							; point plot command
00:00001C4C 4CDF0106        	   318: 	movem.l (a7)+,d1/d2/a0
00:00001C50 4E75            	   319: 	rts
                            	   320: 
                            	   321: ;-------------------------------------------
                            	   322: ; In case of lacking hardware plot
                            	   323: ;-------------------------------------------
                            	   324: 	align 2
                            	   325: plottbl:
00:00001C54 00001D02        	   326: 	dc.l plot_black
00:00001C58 00001CF4        	   327: 	dc.l plot_copy
00:00001C5C 00001CF4        	   328: 	dc.l plot_copy
00:00001C60 00001CE0        	   329: 	dc.l plot_and
00:00001C64 00001CB6        	   330: 	dc.l plot_or
00:00001C68 00001CCA        	   331: 	dc.l plot_xor
00:00001C6C 00001CF4        	   332: 	dc.l plot_copy
00:00001C70 00001CF4        	   333: 	dc.l plot_copy
00:00001C74 00001CF4        	   334: 	dc.l plot_copy
00:00001C78 00001CF4        	   335: 	dc.l plot_copy
00:00001C7C 00001CF4        	   336: 	dc.l plot_copy
00:00001C80 00001CF4        	   337: 	dc.l plot_copy
00:00001C84 00001CF4        	   338: 	dc.l plot_copy
00:00001C88 00001CF4        	   339: 	dc.l plot_copy
00:00001C8C 00001D0C        	   340: 	dc.l plot_white
                            	   341: 
                            	   342: plot_sw:
00:00001C90 48E778C0        	   343: 	movem.l d1/d2/d3/d4/a0/a1,-(a7)
00:00001C94 C4F900040D6C    	   344: 	mulu framebuf_dcb+DCB_OUTDIMX,d2	; multiply y by screen width
                            	   345: ;	move.l d1,d3
                            	   346: ;	andi.l #30,d3
                            	   347: ;	moveq #30,d4
                            	   348: ;	sub.l d4,d3
                            	   349: ;	andi.l #$FFFFFFE0,d1
                            	   350: ;	or.l d3,d1
00:00001C9A 48C1            	   351: 	ext.l d1											; clear high-order word of x
00:00001C9C D481            	   352: 	add.l d1,d2										; add in x co-ord
00:00001C9E D482            	   353: 	add.l d2,d2										; *2 for 16 BPP
00:00001CA0 207900040D8C    	   354: 	move.l framebuf_dcb+DCB_OUTBUFPTR2,a0		; where the draw occurs
00:00001CA6 163900040D80    	   355: 	move.b framebuf_dcb+DCB_OPCODE,d3				; raster operation
00:00001CAC 4883            	   356: 	ext.w d3
00:00001CAE E54B            	   357: 	lsl.w #2,d3
00:00001CB0 227B30A2        	   358: 	move.l plottbl(pc,d3.w),a1
00:00001CB4 4ED1            	   359: 	jmp (a1)
                            	   360: plot_or:
00:00001CB6 38302800        	   361: 	move.w (a0,d2.l),d4	
00:00001CBA 887900040D7C    	   362: 	or.w framebuf_dcb+DCB_FGCOLOR,d4
00:00001CC0 31842800        	   363: 	move.w d4,(a0,d2.l)
00:00001CC4 4CDF031E        	   364: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001CC8 4E75            	   365: 	rts
                            	   366: plot_xor:
00:00001CCA 38302800        	   367: 	move.w (a0,d2.l),d4
00:00001CCE 363900040D7C    	   368: 	move.w framebuf_dcb+DCB_FGCOLOR,d3	
00:00001CD4 B744            	   369: 	eor.w d3,d4
00:00001CD6 31842800        	   370: 	move.w d4,(a0,d2.l)
00:00001CDA 4CDF031E        	   371: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001CDE 4E75            	   372: 	rts
                            	   373: plot_and:
00:00001CE0 38302800        	   374: 	move.w (a0,d2.l),d4	
00:00001CE4 C87900040D7C    	   375: 	and.w framebuf_dcb+DCB_FGCOLOR,d4
00:00001CEA 31842800        	   376: 	move.w d4,(a0,d2.l)
00:00001CEE 4CDF031E        	   377: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001CF2 4E75            	   378: 	rts
                            	   379: plot_copy:
00:00001CF4 31B900040D7C2800	   380: 	move.w framebuf_dcb+DCB_FGCOLOR,(a0,d2.l)
00:00001CFC 4CDF031E        	   381: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001D00 4E75            	   382: 	rts
                            	   383: plot_black:
00:00001D02 42702800        	   384: 	clr.w (a0,d2.l)
00:00001D06 4CDF031E        	   385: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001D0A 4E75            	   386: 	rts
                            	   387: plot_white:
00:00001D0C 31BCFF7F2800    	   388: 	move.w #$FF7F,(a0,d2.l)
00:00001D12 4CDF031E        	   389: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001D16 4E75            	   390: 	rts
                            	   391: 
                            	   392: 
                            	   393: clear_graphics_screen:
                            	   394: ;	move.l #0,d1
                            	   395: ;	bsr gfxaccel_set_color
                            	   396: ;	move.l #0,d1
                            	   397: ;	move.l #0,d2
                            	   398: ;	move.l #1920<<16,d3
                            	   399: ;	move.l #1080<<16,d4
                            	   400: ;	bsr gfxaccel_draw_rectangle
00:00001D18 2A3C00075300    	   401: 	move.l #VIDEO_X*VIDEO_Y,d5		; compute number of strips to write
00:00001D1E E68D            	   402: 	lsr.l #3,d5						; 8 pixels per strip
                            	   403: ;	move.l framebuf_dcb+DCB_OUTBUFPTR,a4
00:00001D20 287C40000000    	   404: 	move.l #$40000000,a4
00:00001D26 42B97FFFFFF8    	   405: 	move.l #0,$7FFFFFF8		; burst length of zero
00:00001D2C 6002            	   406: 	bra.s .0001
                            	   407: .0002:
00:00001D2E 4845            	   408: 	swap d5
                            	   409: .0001:
00:00001D30 220C            	   410: 	move.l a4,d1
00:00001D32 610079F0        	   411: 	bsr rbo
00:00001D36 23C17FFFFFF4    	   412: 	move.l d1,$7FFFFFF4		; target address
00:00001D3C 42B97FFFFFFC    	   413: 	move.l #0,$7FFFFFFC		; value to write
00:00001D42 49EC0020        	   414: 	lea.l 32(a4),a4
00:00001D46 51CDFFE8        	   415: 	dbra d5,.0001
                            	   416: ;	swap d5
                            	   417: ;	dbra d5,.0002
00:00001D4A 4E75            	   418: 	rts
                            	   419: 
                            	   420: 
                            	   421: ; Clears the page opposite to the display page
                            	   422: 
                            	   423: framebuf_clear:
00:00001D4C F2276800        	   424: 	fmove.x fp0,-(a7)
00:00001D50 F2276880        	   425: 	fmove.x fp1,-(a7)
00:00001D54 48E76880        	   426: 	movem.l d1/d2/d4/a0,-(a7)
00:00001D58 1239FD200003    	   427: 	move.b FRAMEBUF+3,d1		; get displayed page
00:00001D5E 0C010001        	   428: 	cmpi.b #1,d1
00:00001D62 6608            	   429: 	bne.s .0001
00:00001D64 207900040D54    	   430: 	move.l framebuf_dcb+DCB_OUTBUFPTR,a0		; where the draw occurs
00:00001D6A 6006            	   431: 	bra.s .0002
                            	   432: .0001
00:00001D6C 207900040D8C    	   433: 	move.l framebuf_dcb+DCB_OUTBUFPTR2,a0		; where the draw occurs
                            	   434: .0002
00:00001D72 223900040D6C    	   435: 	move.l framebuf_dcb+DCB_OUTDIMX,d1
00:00001D78 243900040D70    	   436: 	move.l framebuf_dcb+DCB_OUTDIMY,d2
00:00001D7E C4C1            	   437: 	mulu d1,d2							; d2 = X dimen * Y dimen = number of pixels
00:00001D80 2239FD2000B0    	   438: 	move.l FRAMEBUF+FRAMEBUF_PPS,d1
00:00001D86 6100799C        	   439: 	bsr rbo
00:00001D8A 024103FF        	   440: 	andi.w #$3ff,d1					; extract pixels per strip
00:00001D8E 48C1            	   441: 	ext.l d1
00:00001D90 2801            	   442: 	move.l d1,d4						; d4.w = pixels per strip
00:00001D92 D484            	   443: 	add.l d4,d2							; round number of pixels on screen up a strip
00:00001D94 F2024000        	   444: 	fmove.l d2,fp0					; number might be too big for divu
00:00001D98 F2044080        	   445: 	fmove.l d4,fp1					; so use float divider
00:00001D9C F2000420        	   446: 	fdiv fp1,fp0						; fp0 = screen size / pixels per strip
00:00001DA0 F2006000        	   447: 	fmove.l fp0,d0					; d0 = number of strips to set
00:00001DA4 223900040D7C    	   448: 	move.l framebuf_dcb+DCB_FGCOLOR,d1
00:00001DAA 61007978        	   449: 	bsr rbo
00:00001DAE 2801            	   450: 	move.l d1,d4
00:00001DB0 42B97FFFFFF8    	   451: 	move.l #0,$7FFFFFF8			; set burst length zero
00:00001DB6 6002            	   452: 	bra.s .loop
                            	   453: .loop2:
00:00001DB8 4840            	   454: 	swap d0
                            	   455: .loop:
00:00001DBA 2208            	   456: 	move.l a0,d1
00:00001DBC 61007966        	   457: 	bsr rbo
00:00001DC0 23C17FFFFFF4    	   458: 	move.l d1,$7FFFFFF4			; set destination address
00:00001DC6 23C47FFFFFFC    	   459: 	move.l d4,$7FFFFFFC			; write value (color) to use and trigger write op
00:00001DCC 41E80020        	   460: 	lea 32(a0),a0						; advance pointer
00:00001DD0 51C8FFE8        	   461: 	dbra d0,.loop
00:00001DD4 4840            	   462: 	swap d0
00:00001DD6 51C8FFE0        	   463: 	dbra d0,.loop2
00:00001DDA 4CDF0116        	   464: 	movem.l (a7)+,d1/d2/d4/a0
00:00001DDE F21F4880        	   465: 	fmove.x (a7)+,fp1
00:00001DE2 F21F4800        	   466: 	fmove.x (a7)+,fp0
00:00001DE6 7000            	   467: 	move.l #E_Ok,d0
00:00001DE8 4E75            	   468: 	rts
                            	   469: 
                            	   470: ; The following code using bursts of 1k pixels did not work (hardware).
                            	   471: ;
                            	   472: ;clear_bitmap_screen2:
                            	   473: ;	move.l gr_bitmap_screen,a0
                            	   474: ;clear_bitmap_screen3:
                            	   475: ;	movem.l d0/d2/a0,-(a7)
                            	   476: ;	move.l #$3F3F3F3F,$BFFFFFF4	; 32x64 byte burst
                            	   477: ;	move.w pen_color,d0
                            	   478: ;	swap d0
                            	   479: ;	move.w pen_color,d0
                            	   480: ;	move.w gr_width,d2		; calc. number of pixels on screen
                            	   481: ;	mulu gr_height,d2
                            	   482: ;	add.l #1023,d2				; rounding up
                            	   483: ;	lsr.l #8,d2						; divide by 1024 pixel update
                            	   484: ;	lsr.l #2,d2
                            	   485: ;.0001:
                            	   486: ;	move.l a0,$BFFFFFF8		; write update address
                            	   487: ;	add.l #2048,a0				; update pointer
                            	   488: ;	move.l d0,$BFFFFFFC		; trigger burst write of 2048 bytes
                            	   489: ;	dbra d2,.0001
                            	   490: ;	movem.l (a7)+,d0/d2/a0
                            	   491: ;	rts
                            	   492: 
                            	   493: ; More conventional but slow way of clearing the screen.
                            	   494: ;
                            	   495: ;clear_bitmap_screen:
                            	   496: ;	move.l gr_bitmap_screen,a0
                            	   497: ;clear_bitmap_screen1:
                            	   498: ;	movem.l d0/d2/a0,-(a7)
                            	   499: ;	move.w pen_color,d0
                            	   500: ;	swap d0
                            	   501: ;	move.w pen_color,d0
                            	   502: ;	move.w gr_width,d2		; calc. number of pixels on screen
                            	   503: ;	mulu gr_height,d2			; 800x600 = 480000
                            	   504: ;	bra.s .0001
                            	   505: ;.0002:
                            	   506: ;	swap d2
                            	   507: ;.0001:
                            	   508: ;	move.l d0,(a0)+
                            	   509: ;	dbra d2,.0001
                            	   510: ;	swap d2
                            	   511: ;	dbra d2,.0002
                            	   512: ;	movem.l (a7)+,d0/d2/a0
                            	   513: ;	rts
                            	   514: 
                            	   515: 

Source: "boot.x68"
                            	   580: 	include "gfxaccel.x68"

Source: "gfxaccel.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: GFX_CTRL		equ	$00
                            	    38: GFX_STATUS	equ $04
                            	    39: GFX_TARGET_BASE		equ $10
                            	    40: GFX_TARGET_SIZE_X	equ $14
                            	    41: GFX_TARGET_SIZE_Y equ $18
                            	    42: GFX_DEST_PIXEL_X  equ $38
                            	    43: GFX_DEST_PIXEL_Y  equ $3c
                            	    44: GFX_DEST_PIXEL_Z  equ $40
                            	    45: GFX_CLIP_PIXEL0_X	equ $74
                            	    46: GFX_CLIP_PIXEL0_Y	equ $78
                            	    47: GFX_CLIP_PIXEL1_X	equ $7C
                            	    48: GFX_CLIP_PIXEL1_Y	equ $80
                            	    49: GFX_COLOR0	equ $84
                            	    50: GFX_COLOR1	equ $88
                            	    51: GFX_COLOR2	equ $8C
                            	    52: GFX_TARGET_X0	equ $B0
                            	    53: GFX_TARGET_Y0 equ $B4
                            	    54: GFX_TARGET_X1	equ $B8
                            	    55: GFX_TARGET_Y1	equ $BC
                            	    56: GFX_COLOR_COMP equ $D0
                            	    57: GFX_PPS equ $D4
                            	    58: 
                            	    59: ;------------------------------------------------------------------------------
                            	    60: ;------------------------------------------------------------------------------
                            	    61: ; Graphics accelerator
                            	    62: ;------------------------------------------------------------------------------
                            	    63: ;------------------------------------------------------------------------------
                            	    64: 	align 2
                            	    65: GFXACCEL_CMDTBL:
00:00001DEC 00001F20        	    66: 	dc.l gfxaccel_init				; 0
00:00001DF0 00001F82        	    67: 	dc.l gfxaccel_stat
00:00001DF4 00001F90        	    68: 	dc.l gfxaccel_putchar
00:00001DF8 00001F90        	    69: 	dc.l gfxaccel_putbuf
00:00001DFC 00001F90        	    70: 	dc.l gfxaccel_getchar
00:00001E00 00001F90        	    71: 	dc.l gfxaccel_getbuf
00:00001E04 00001F90        	    72: 	dc.l gfxaccel_set_inpos
00:00001E08 00001F90        	    73: 	dc.l gfxaccel_set_outpos
00:00001E0C 00001F90        	    74: 	dc.l gfxaccel_stub
00:00001E10 00001F90        	    75: 	dc.l gfxaccel_stub
00:00001E14 00001F90        	    76: 	dc.l gfxaccel_stub				; 10
00:00001E18 00001F90        	    77: 	dc.l gfxaccel_stub
00:00001E1C 00001FF4        	    78: 	dc.l gfxaccel_clear
00:00001E20 00001F90        	    79: 	dc.l gfxaccel_swapbuf
00:00001E24 00001F90        	    80: 	dc.l gfxaccel_setbuf1
00:00001E28 00001F90        	    81: 	dc.l gfxaccel_setbuf2
00:00001E2C 00001F90        	    82: 	dc.l gfxaccel_getbuf1
00:00001E30 00001F90        	    83: 	dc.l gfxaccel_getbuf2
00:00001E34 00001F90        	    84: 	dc.l gfxaccel_writeat
00:00001E38 00001F90        	    85: 	dc.l gfxaccel_set_unit
00:00001E3C 00001F90        	    86: 	dc.l gfxaccel_get_dimen	; 20
00:00001E40 0000209A        	    87: 	dc.l gfxaccel_get_color
00:00001E44 00001F90        	    88: 	dc.l gfxaccel_get_inpos
00:00001E48 00001F90        	    89: 	dc.l gfxaccel_get_outpos
00:00001E4C 00001F90        	    90: 	dc.l gfxaccel_get_outptr
00:00001E50 000020A8        	    91: 	dc.l gfxaccel_set_color
00:00001E54 000020C8        	    92: 	dc.l gfxaccel_set_color123
00:00001E58 00002170        	    93: 	dc.l gfxaccel_plot_point
00:00001E5C 000021C2        	    94: 	dc.l gfxaccel_draw_line
00:00001E60 00002292        	    95: 	dc.l gfxaccel_draw_triangle
00:00001E64 0000222A        	    96: 	dc.l gfxaccel_draw_rectangle	;30
00:00001E68 0000231A        	    97: 	dc.l gfxaccel_draw_curve
00:00001E6C 00001F94        	    98: 	dc.l gfxaccel_set_dimen
00:00001E70 00002088        	    99: 	dc.l gfxaccel_set_color_depth
00:00001E74 00001FC8        	   100: 	dc.l gfxaccel_set_destbuf
00:00001E78 00001F90        	   101: 	dc.l gfxaccel_set_dispbuf
                            	   102: 
                            	   103: 	code
                            	   104: 	even
                            	   105: 
                            	   106: gfxaccel_cmdproc:
00:00001E7C 0C060024        	   107: 	cmpi.b #36,d6
00:00001E80 641A            	   108: 	bhs.s .0001
00:00001E82 48E70280        	   109: 	movem.l d6/a0,-(a7)
00:00001E86 4886            	   110: 	ext.w d6
00:00001E88 48C6            	   111: 	ext.l d6
00:00001E8A E54E            	   112: 	lsl.w #2,d6
00:00001E8C 41FAFF5E        	   113: 	lea.l GFXACCEL_CMDTBL,a0
00:00001E90 20706000        	   114: 	move.l (a0,d6.w),a0
00:00001E94 4E90            	   115: 	jsr (a0)
00:00001E96 4CDF0140        	   116: 	movem.l (a7)+,d6/a0
00:00001E9A 4E75            	   117: 	rts
                            	   118: .0001:
00:00001E9C 7002            	   119: 	moveq #E_Func,d0
00:00001E9E 4E75            	   120: 	rts
                            	   121: 
                            	   122: setup_gfxaccel:
00:00001EA0 48E780C0        	   123: 	movem.l d0/a0/a1,-(a7)
00:00001EA4 7020            	   124: 	moveq #32,d0
00:00001EA6 41F900040D9C    	   125: 	lea.l gfxaccel_dcb,a0
                            	   126: .0001:
00:00001EAC 4298            	   127: 	clr.l (a0)+
00:00001EAE 51C8FFFC        	   128: 	dbra d0,.0001
00:00001EB2 23FC444342200004	   129: 	move.l #$44434220,gfxaccel_dcb+DCB_MAGIC			; 'DCB'
00:00001EBA 0D9C
00:00001EBC 23FC474658410004	   130: 	move.l #$47465841,gfxaccel_dcb+DCB_NAME				; 'GFXACCEL'
00:00001EC4 0DA0
00:00001EC6 23FC4343454C0004	   131: 	move.l #$4343454C,gfxaccel_dcb+DCB_NAME+4
00:00001ECE 0DA4
00:00001ED0 23FC00001E7C0004	   132: 	move.l #gfxaccel_cmdproc,gfxaccel_dcb+DCB_CMDPROC
00:00001ED8 0DB4
00:00001EDA 7000            	   133: 	move.l #$00000000,d0
00:00001EDC 23C000040DD4    	   134: 	move.l d0,gfxaccel_dcb+DCB_INBUFPTR
00:00001EE2 23C000040DD8    	   135: 	move.l d0,gfxaccel_dcb+DCB_OUTBUFPTR
00:00001EE8 D0BC00400000    	   136: 	add.l #$400000,d0
00:00001EEE 23C000040E0C    	   137: 	move.l d0,gfxaccel_dcb+DCB_INBUFPTR2
00:00001EF4 23C000040E10    	   138: 	move.l d0,gfxaccel_dcb+DCB_OUTBUFPTR2
00:00001EFA 23FC004000000004	   139: 	move.l #$00400000,gfxaccel_dcb+DCB_INBUFSIZE
00:00001F02 0DDC
00:00001F04 23FC004000000004	   140: 	move.l #$00400000,gfxaccel_dcb+DCB_OUTBUFSIZE
00:00001F0C 0DE0
00:00001F0E 43F900040D9C    	   141: 	lea.l gfxaccel_dcb+DCB_MAGIC,a1
00:00001F14 61005BCE        	   142: 	jsr DisplayString
00:00001F18 61005BB0        	   143: 	jsr CRLF
00:00001F1C 4CDF0301        	   144: 	movem.l (a7)+,d0/a0/a1
                            	   145: 
                            	   146: gfxaccel_init:
00:00001F20 2F01            	   147: 	move.l d1,-(a7)
00:00001F22 720A            	   148: 	moveq #10,d1
00:00001F24 6100047A        	   149: 	bsr gfxaccel_wait
00:00001F28 7200            	   150: 	move.l #0,d1
00:00001F2A 23C1000408C0    	   151: 	move.l d1,gfxaccel_ctrl
00:00001F30 610077F2        	   152: 	bsr rbo
00:00001F34 23C1FD300000    	   153: 	move.l d1,GFXACCEL+GFX_CTRL
00:00001F3A 7200            	   154: 	move.l #$00000000,d1
00:00001F3C 610077E6        	   155: 	bsr rbo
00:00001F40 23C1FD300010    	   156: 	move.l d1,GFXACCEL+GFX_TARGET_BASE	; base draw address
00:00001F46 223C00000320    	   157: 	move.l #800,d1
00:00001F4C 610077D6        	   158: 	bsr rbo
00:00001F50 23C1FD300014    	   159: 	move.l d1,GFXACCEL+GFX_TARGET_SIZE_X	; render target x dimension
00:00001F56 23C1FD3000B8    	   160: 	move.l d1,GFXACCEL+GFX_TARGET_X1
00:00001F5C 223C00000258    	   161: 	move.l #600,d1
00:00001F62 610077C0        	   162: 	bsr rbo
00:00001F66 23C1FD300018    	   163: 	move.l d1,GFXACCEL+GFX_TARGET_SIZE_Y	; render target y dimension
00:00001F6C 23C1FD3000BC    	   164: 	move.l d1,GFXACCEL+GFX_TARGET_Y1
00:00001F72 42B9FD3000B0    	   165: 	move.l #0,GFXACCEL+GFX_TARGET_X0
00:00001F78 42B9FD3000B4    	   166: 	move.l #0,GFXACCEL+GFX_TARGET_Y0
00:00001F7E 221F            	   167: 	move.l (a7)+,d1
00:00001F80 4E75            	   168: 	rts
                            	   169: 
                            	   170: gfxaccel_stat:
00:00001F82 2239FD300004    	   171: 	move.l GFXACCEL+GFX_STATUS,d1
00:00001F88 6100779A        	   172: 	bsr rbo
00:00001F8C 7000            	   173: 	moveq #E_Ok,d0
00:00001F8E 4E75            	   174: 	rts
                            	   175: 
                            	   176: gfxaccel_putchar:
                            	   177: gfxaccel_getchar:
                            	   178: gfxaccel_putbuf:
                            	   179: gfxaccel_getbuf:
                            	   180: gfxaccel_set_inpos:
                            	   181: gfxaccel_set_outpos:
                            	   182: gfxaccel_stub:
                            	   183: gfxaccel_swapbuf:
                            	   184: gfxaccel_setbuf1:
                            	   185: gfxaccel_setbuf2:
                            	   186: gfxaccel_getbuf1:
                            	   187: gfxaccel_getbuf2:
                            	   188: gfxaccel_writeat:
                            	   189: gfxaccel_set_unit:
                            	   190: gfxaccel_get_dimen:
                            	   191: gfxaccel_get_inpos:
                            	   192: gfxaccel_get_outpos:
                            	   193: gfxaccel_get_outptr:
                            	   194: gfxaccel_set_dispbuf:
00:00001F90 700A            	   195: 	move.l #E_NotSupported,d0
00:00001F92 4E75            	   196: 	rts
                            	   197: 
                            	   198: gfxaccel_set_dimen:
00:00001F94 2F01            	   199: 	move.l d1,-(a7)
00:00001F96 2001            	   200: 	move.l d1,d0
00:00001F98 7206            	   201: 	moveq #6,d1
00:00001F9A 61000404        	   202: 	bsr gfxaccel_wait					; wait for an open slot
00:00001F9E 2200            	   203: 	move.l d0,d1
00:00001FA0 61007782        	   204: 	bsr rbo
00:00001FA4 23C1FD300014    	   205: 	move.l d1,GFXACCEL+GFX_TARGET_SIZE_X	; render target x dimension
00:00001FAA 23C1FD3000B8    	   206: 	move.l d1,GFXACCEL+GFX_TARGET_X1
00:00001FB0 2202            	   207: 	move.l d2,d1
00:00001FB2 61007770        	   208: 	bsr rbo
00:00001FB6 23C1FD300018    	   209: 	move.l d1,GFXACCEL+GFX_TARGET_SIZE_Y	; render target y dimension
00:00001FBC 23C1FD3000BC    	   210: 	move.l d1,GFXACCEL+GFX_TARGET_Y1
00:00001FC2 221F            	   211: 	move.l (a7)+,d1
00:00001FC4 7000            	   212: 	moveq #E_Ok,d0
00:00001FC6 4E75            	   213: 	rts
                            	   214: 
                            	   215: gfxaccel_set_destbuf:
00:00001FC8 2001            	   216: 	move.l d1,d0
00:00001FCA 7203            	   217: 	moveq #3,d1
00:00001FCC 610003D2        	   218: 	bsr gfxaccel_wait					; wait for an open slot
00:00001FD0 0C000001        	   219: 	cmpi.b #1,d0
00:00001FD4 6608            	   220: 	bne.s .0001
00:00001FD6 223900040E10    	   221: 	move.l gfxaccel_dcb+DCB_OUTBUFPTR2,d1
00:00001FDC 6006            	   222: 	bra.s .0002
                            	   223: .0001:
00:00001FDE 223900040DD8    	   224: 	move.l gfxaccel_dcb+DCB_OUTBUFPTR,d1
                            	   225: .0002:
00:00001FE4 6100773E        	   226: 	bsr rbo
00:00001FE8 23C1FD300010    	   227: 	move.l d1,GFXACCEL+GFX_TARGET_BASE
00:00001FEE 2200            	   228: 	move.l d0,d1
00:00001FF0 7000            	   229: 	move.l #E_Ok,d0
00:00001FF2 4E75            	   230: 	rts
                            	   231: 
                            	   232: ; Clears destination buffer
                            	   233: 
                            	   234: gfxaccel_clear:
00:00001FF4 F2276800        	   235: 	fmove.x fp0,-(a7)
00:00001FF8 F2276880        	   236: 	fmove.x fp1,-(a7)
00:00001FFC 48E76880        	   237: 	movem.l d1/d2/d4/a0,-(a7)
00:00002000 2239FD300014    	   238: 	move.l GFXACCEL+GFX_TARGET_SIZE_X,d1
00:00002006 6100771C        	   239: 	bsr rbo
00:0000200A 2401            	   240: 	move.l d1,d2
00:0000200C 2239FD300018    	   241: 	move.l GFXACCEL+GFX_TARGET_SIZE_Y,d1
00:00002012 61007710        	   242: 	bsr rbo
00:00002016 C4C1            	   243: 	mulu d1,d2							; d2 = X dimen * Y dimen = number of pixels
00:00002018 2239FD3000D4    	   244: 	move.l GFXACCEL+GFX_PPS,d1	; d1 = pixels per strip reg
00:0000201E 61007704        	   245: 	bsr rbo
00:00002022 024103FF        	   246: 	andi.w #$3ff,d1					; extract pixels per strip
00:00002026 48C1            	   247: 	ext.l d1
00:00002028 2801            	   248: 	move.l d1,d4						; d4.w = pixels per strip
00:0000202A D484            	   249: 	add.l d4,d2							; round number of pixels on screen up a strip
00:0000202C F2024000        	   250: 	fmove.l d2,fp0					; number might be too big for divu
00:00002030 F2044080        	   251: 	fmove.l d4,fp1					; so use float divider
00:00002034 F2000420        	   252: 	fdiv fp1,fp0						; fp0 = screen size / pixels per strip
00:00002038 F2006000        	   253: 	fmove.l fp0,d0					; d0 = number of strips to set
00:0000203C 2839FD300084    	   254: 	move.l GFXACCEL+GFX_COLOR0,d4
00:00002042 2239FD300010    	   255: 	move.l GFXACCEL+GFX_TARGET_BASE,d1
00:00002048 610076DA        	   256: 	bsr rbo
00:0000204C 2041            	   257: 	move.l d1,a0
00:0000204E 42B97FFFFFF8    	   258: 	move.l #0,$7FFFFFF8			; set burst length zero
00:00002054 6002            	   259: 	bra.s .loop
                            	   260: .loop2:
00:00002056 4840            	   261: 	swap d0
                            	   262: .loop:
00:00002058 2208            	   263: 	move.l a0,d1
00:0000205A 610076C8        	   264: 	bsr rbo
00:0000205E 23C17FFFFFF4    	   265: 	move.l d1,$7FFFFFF4			; set destination address
00:00002064 23C47FFFFFFC    	   266: 	move.l d4,$7FFFFFFC			; write value (color) to use and trigger write op
00:0000206A 41E80020        	   267: 	lea 32(a0),a0						; advance pointer
00:0000206E 51C8FFE8        	   268: 	dbra d0,.loop
00:00002072 4840            	   269: 	swap d0
00:00002074 51C8FFE0        	   270: 	dbra d0,.loop2
00:00002078 4CDF0116        	   271: 	movem.l (a7)+,d1/d2/d4/a0
00:0000207C F21F4880        	   272: 	fmove.x (a7)+,fp1
00:00002080 F21F4800        	   273: 	fmove.x (a7)+,fp0
00:00002084 7000            	   274: 	move.l #E_Ok,d0
00:00002086 4E75            	   275: 	rts
                            	   276: 
                            	   277: 
                            	   278: gfxaccel_set_color_depth:
00:00002088 2200            	   279: 	move.l d0,d1
00:0000208A 61007698        	   280: 	bsr rbo
00:0000208E 23C1FD3000D0    	   281: 	move.l d1,GFXACCEL+GFX_COLOR_COMP
00:00002094 2200            	   282: 	move.l d0,d1
00:00002096 7000            	   283: 	moveq #E_Ok,d0
00:00002098 4E75            	   284: 	rts
                            	   285: 	
                            	   286: gfxaccel_get_color:
00:0000209A 2239FD300084    	   287: 	move.l GFXACCEL+GFX_COLOR0,d1
00:000020A0 61007682        	   288: 	bsr rbo
00:000020A4 7000            	   289: 	moveq #E_Ok,d0
00:000020A6 4E75            	   290: 	rts
                            	   291: 
                            	   292: gfxaccel_set_color:
00:000020A8 48E75000        	   293: 	movem.l d1/d3,-(a7)
00:000020AC 2601            	   294: 	move.l d1,d3
00:000020AE 7203            	   295: 	moveq #3,d1
00:000020B0 610002EE        	   296: 	bsr gfxaccel_wait					; wait for an open slot
00:000020B4 2203            	   297: 	move.l d3,d1
00:000020B6 6100766C        	   298: 	bsr rbo
00:000020BA 23C1FD300084    	   299: 	move.l d1,GFXACCEL+GFX_COLOR0
00:000020C0 4CDF000A        	   300: 	movem.l (a7)+,d1/d3
00:000020C4 7000            	   301: 	moveq #E_Ok,d0
00:000020C6 4E75            	   302: 	rts
                            	   303: 
                            	   304: gfxaccel_set_color123:
00:000020C8 48E74800        	   305: 	movem.l d1/d4,-(a7)
00:000020CC 2801            	   306: 	move.l d1,d4
00:000020CE 7205            	   307: 	moveq #5,d1
00:000020D0 610002CE        	   308: 	bsr gfxaccel_wait					; wait for an open slot
00:000020D4 2204            	   309: 	move.l d4,d1
00:000020D6 6100764C        	   310: 	bsr rbo
00:000020DA 23C1FD300084    	   311: 	move.l d1,GFXACCEL+GFX_COLOR0
00:000020E0 2202            	   312: 	move.l d2,d1
00:000020E2 61007640        	   313: 	bsr rbo
00:000020E6 23C1FD300088    	   314: 	move.l d1,GFXACCEL+GFX_COLOR1
00:000020EC 2203            	   315: 	move.l d3,d1
00:000020EE 61007634        	   316: 	bsr rbo
00:000020F2 23C1FD30008C    	   317: 	move.l d1,GFXACCEL+GFX_COLOR2
00:000020F8 4CDF0012        	   318: 	movem.l (a7)+,d1/d4
00:000020FC 7000            	   319: 	moveq #E_Ok,d0
00:000020FE 4E75            	   320: 	rts
                            	   321: 
                            	   322: gfxaccel_clip_rect:
00:00002100 48E74400        	   323: 	movem.l d1/d5,-(a7)
00:00002104 2A01            	   324: 	move.l d1,d5
00:00002106 7206            	   325: 	moveq #6,d1
00:00002108 61000296        	   326: 	bsr gfxaccel_wait					; wait for an open slot
00:0000210C 2205            	   327: 	move.l d5,d1
00:0000210E 61007614        	   328: 	bsr rbo
00:00002112 23C1FD300074    	   329: 	move.l d1,GFXACCEL+GFX_CLIP_PIXEL0_X
00:00002118 2202            	   330: 	move.l d2,d1
00:0000211A 61007608        	   331: 	bsr rbo
00:0000211E 23C1FD300078    	   332: 	move.l d1,GFXACCEL+GFX_CLIP_PIXEL0_Y
00:00002124 2203            	   333: 	move.l d3,d1
00:00002126 610075FC        	   334: 	bsr rbo
00:0000212A 23C1FD30007C    	   335: 	move.l d1,GFXACCEL+GFX_CLIP_PIXEL1_X
00:00002130 2204            	   336: 	move.l d4,d1
00:00002132 610075F0        	   337: 	bsr rbo
00:00002136 23C1FD300080    	   338: 	move.l d1,GFXACCEL+GFX_CLIP_PIXEL1_Y
00:0000213C 4CDF0022        	   339: 	movem.l (a7)+,d1/d5
00:00002140 7000            	   340: 	moveq #E_Ok,d0
00:00002142 4E75            	   341: 	rts
                            	   342: 
                            	   343: ; Parameters:
                            	   344: ;		d2.b = active point to set
                            	   345: ;
                            	   346: gfxaccel_set_active_point:
00:00002144 4882            	   347: 	ext.w d2
00:00002146 48C2            	   348: 	ext.l d2
00:00002148 4842            	   349: 	swap d2													; point number in bits 16,17
00:0000214A 2239000408C0    	   350: 	move.l gfxaccel_ctrl,d1
00:00002150 0281FFF8FFFF    	   351: 	andi.l #$FFF8FFFF,d1						; clear point number bits
00:00002156 8282            	   352: 	or.l d2,d1											; set the point number bits
00:00002158 008100040000    	   353: 	ori.l #$00040000,d1							; set active point
00:0000215E 23C1000408C0    	   354: 	move.l d1,gfxaccel_ctrl
00:00002164 610075BE        	   355: 	bsr rbo
00:00002168 23C1FD300000    	   356: 	move.l d1,GFXACCEL+GFX_CTRL
00:0000216E 4E75            	   357: 	rts
                            	   358: 
                            	   359: ; Graphics accelerator expects that co-ordinates are in 16.16 format.
                            	   360: ; 
                            	   361: gfxaccel_plot_point:
00:00002170 48E74400        	   362: 	movem.l d1/d5,-(a7)
00:00002174 2A01            	   363: 	move.l d1,d5
00:00002176 7206            	   364: 	moveq #6,d1
00:00002178 61000226        	   365: 	bsr gfxaccel_wait								; wait for an open slot
00:0000217C 2205            	   366: 	move.l d5,d1
00:0000217E 610075A4        	   367: 	bsr rbo
00:00002182 23C1FD300038    	   368: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:00002188 2202            	   369: 	move.l d2,d1
00:0000218A 61007598        	   370: 	bsr rbo
00:0000218E 23C1FD30003C    	   371: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:00002194 2203            	   372: 	move.l d3,d1
00:00002196 6100758C        	   373: 	bsr rbo
00:0000219A 23C1FD300040    	   374: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Z
00:000021A0 4242            	   375: 	move.w #0,d2										; point 0
00:000021A2 61A0            	   376: 	bsr gfxaccel_set_active_point
00:000021A4 2239000408C0    	   377: 	move.l gfxaccel_ctrl,d1
00:000021AA 008100000080    	   378: 	ori.l #$00000080,d1							; point write, bit will clear automatically
00:000021B0 61007572        	   379: 	bsr rbo
00:000021B4 23C1FD300000    	   380: 	move.l d1,GFXACCEL+GFX_CTRL
00:000021BA 4CDF0022        	   381: 	movem.l (a7)+,d1/d5
00:000021BE 7000            	   382: 	moveq #E_Ok,d0
00:000021C0 4E75            	   383: 	rts
                            	   384: 
                            	   385: gfxaccel_draw_line:
00:000021C2 48E76400        	   386: 	movem.l d1/d2/d5,-(a7)
00:000021C6 2A01            	   387: 	move.l d1,d5
00:000021C8 7209            	   388: 	moveq #9,d1
00:000021CA 610001D4        	   389: 	bsr gfxaccel_wait								; wait for an open slot
00:000021CE 2205            	   390: 	move.l d5,d1
00:000021D0 61007552        	   391: 	bsr rbo
00:000021D4 23C1FD300038    	   392: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:000021DA 2202            	   393: 	move.l d2,d1
00:000021DC 61007546        	   394: 	bsr rbo
00:000021E0 23C1FD30003C    	   395: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:000021E6 4242            	   396: 	move.w #0,d2										; point 0
00:000021E8 6100FF5A        	   397: 	bsr gfxaccel_set_active_point
00:000021EC 2203            	   398: 	move.l d3,d1
00:000021EE 61007534        	   399: 	bsr rbo
00:000021F2 23C1FD300038    	   400: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:000021F8 2204            	   401: 	move.l d4,d1
00:000021FA 61007528        	   402: 	bsr rbo
00:000021FE 23C1FD30003C    	   403: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:00002204 343C0001        	   404: 	move.w #1,d2										; point 1
00:00002208 6100FF3A        	   405: 	bsr gfxaccel_set_active_point
00:0000220C 2239000408C0    	   406: 	move.l gfxaccel_ctrl,d1					; get the control reg
00:00002212 008100000200    	   407: 	ori.l #$00000200,d1							; trigger draw line
00:00002218 6100750A        	   408: 	bsr rbo
00:0000221C 23C1FD300000    	   409: 	move.l d1,GFXACCEL+GFX_CTRL
00:00002222 4CDF0026        	   410: 	movem.l (a7)+,d1/d2/d5
00:00002226 7000            	   411: 	moveq #E_Ok,d0
00:00002228 4E75            	   412: 	rts
                            	   413: 
                            	   414: ; Draw a rectangle in the currently selected color
                            	   415: ;
                            	   416: ; Parameters:
                            	   417: ;		d1 	- x0 pos
                            	   418: ;		d2	- y0 pos
                            	   419: ;		d3	- x1 pos
                            	   420: ;		d4	- y1 pos
                            	   421: 
                            	   422: gfxaccel_draw_rectangle:
00:0000222A 48E76400        	   423: 	movem.l d1/d2/d5,-(a7)
00:0000222E 2A01            	   424: 	move.l d1,d5
00:00002230 7209            	   425: 	moveq #9,d1
00:00002232 6100016C        	   426: 	bsr gfxaccel_wait								; wait for an open slot
00:00002236 2205            	   427: 	move.l d5,d1
00:00002238 610074EA        	   428: 	bsr rbo
00:0000223C 23C1FD300038    	   429: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:00002242 2202            	   430: 	move.l d2,d1
00:00002244 610074DE        	   431: 	bsr rbo
00:00002248 23C1FD30003C    	   432: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:0000224E 4242            	   433: 	move.w #0,d2										; point 0
00:00002250 6100FEF2        	   434: 	bsr gfxaccel_set_active_point
00:00002254 2203            	   435: 	move.l d3,d1
00:00002256 610074CC        	   436: 	bsr rbo
00:0000225A 23C1FD300038    	   437: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:00002260 2204            	   438: 	move.l d4,d1
00:00002262 610074C0        	   439: 	bsr rbo
00:00002266 23C1FD30003C    	   440: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:0000226C 343C0001        	   441: 	move.w #1,d2										; point 1
00:00002270 6100FED2        	   442: 	bsr gfxaccel_set_active_point
00:00002274 2239000408C0    	   443: 	move.l gfxaccel_ctrl,d1					; get the control reg
00:0000227A 008100000100    	   444: 	ori.l #$00000100,d1							; trigger draw rectangle
00:00002280 610074A2        	   445: 	bsr rbo
00:00002284 23C1FD300000    	   446: 	move.l d1,GFXACCEL+GFX_CTRL
00:0000228A 4CDF0026        	   447: 	movem.l (a7)+,d1/d2/d5
00:0000228E 7000            	   448: 	moveq #E_Ok,d0
00:00002290 4E75            	   449: 	rts
                            	   450: 
                            	   451: ; Draw a triangle in the currently selected color
                            	   452: ;
                            	   453: ; Parameters:
                            	   454: ;		d1 	- x0 pos
                            	   455: ;		d2	- y0 pos
                            	   456: ;		d3	- x1 pos
                            	   457: ;		d4	- y1 pos
                            	   458: ;	  d5	- x2 pos
                            	   459: ;		d0	- y2 pos
                            	   460: 
                            	   461: gfxaccel_draw_triangle:
00:00002292 48E76100        	   462: 	movem.l d1/d2/d7,-(a7)
00:00002296 2E01            	   463: 	move.l d1,d7
00:00002298 720C            	   464: 	moveq #12,d1
00:0000229A 61000104        	   465: 	bsr gfxaccel_wait								; wait for an open slot
00:0000229E 2207            	   466: 	move.l d7,d1
00:000022A0 61007482        	   467: 	bsr rbo
00:000022A4 23C1FD300038    	   468: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:000022AA 2202            	   469: 	move.l d2,d1
00:000022AC 61007476        	   470: 	bsr rbo
00:000022B0 23C1FD30003C    	   471: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:000022B6 4242            	   472: 	move.w #0,d2										; point 0
00:000022B8 6100FE8A        	   473: 	bsr gfxaccel_set_active_point
00:000022BC 2203            	   474: 	move.l d3,d1
00:000022BE 61007464        	   475: 	bsr rbo
00:000022C2 23C1FD300038    	   476: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:000022C8 2204            	   477: 	move.l d4,d1
00:000022CA 61007458        	   478: 	bsr rbo
00:000022CE 23C1FD30003C    	   479: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:000022D4 343C0001        	   480: 	move.w #1,d2										; point 1
00:000022D8 6100FE6A        	   481: 	bsr gfxaccel_set_active_point
00:000022DC 2205            	   482: 	move.l d5,d1
00:000022DE 61007444        	   483: 	bsr rbo
00:000022E2 23C1FD300038    	   484: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:000022E8 2200            	   485: 	move.l d0,d1
00:000022EA 61007438        	   486: 	bsr rbo
00:000022EE 23C1FD30003C    	   487: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:000022F4 343C0002        	   488: 	move.w #2,d2										; point 2
00:000022F8 6100FE4A        	   489: 	bsr gfxaccel_set_active_point
00:000022FC 2239000408C0    	   490: 	move.l gfxaccel_ctrl,d1					; get the control reg
00:00002302 008100000400    	   491: 	ori.l #$00000400,d1							; trigger draw triangle
00:00002308 6100741A        	   492: 	bsr rbo
00:0000230C 23C1FD300000    	   493: 	move.l d1,GFXACCEL+GFX_CTRL
00:00002312 4CDF0086        	   494: 	movem.l (a7)+,d1/d2/d7
00:00002316 7000            	   495: 	moveq #E_Ok,d0
00:00002318 4E75            	   496: 	rts
                            	   497: 
                            	   498: gfxaccel_draw_curve:
00:0000231A 48E76100        	   499: 	movem.l d1/d2/d7,-(a7)
00:0000231E 2E01            	   500: 	move.l d1,d7
00:00002320 720C            	   501: 	moveq #12,d1
00:00002322 617C            	   502: 	bsr gfxaccel_wait								; wait for an open slot
00:00002324 2207            	   503: 	move.l d7,d1
00:00002326 610073FC        	   504: 	bsr rbo
00:0000232A 23C1FD300038    	   505: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:00002330 2202            	   506: 	move.l d2,d1
00:00002332 610073F0        	   507: 	bsr rbo
00:00002336 23C1FD30003C    	   508: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:0000233C 4242            	   509: 	move.w #0,d2										; point 0
00:0000233E 6100FE04        	   510: 	bsr gfxaccel_set_active_point
00:00002342 2203            	   511: 	move.l d3,d1
00:00002344 610073DE        	   512: 	bsr rbo
00:00002348 23C1FD300038    	   513: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:0000234E 2204            	   514: 	move.l d4,d1
00:00002350 610073D2        	   515: 	bsr rbo
00:00002354 23C1FD30003C    	   516: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:0000235A 343C0001        	   517: 	move.w #1,d2										; point 1
00:0000235E 6100FDE4        	   518: 	bsr gfxaccel_set_active_point
00:00002362 2205            	   519: 	move.l d5,d1
00:00002364 610073BE        	   520: 	bsr rbo
00:00002368 23C1FD300038    	   521: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:0000236E 2206            	   522: 	move.l d6,d1
00:00002370 610073B2        	   523: 	bsr rbo
00:00002374 23C1FD30003C    	   524: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:0000237A 343C0002        	   525: 	move.w #2,d2										; point 2
00:0000237E 6100FDC4        	   526: 	bsr gfxaccel_set_active_point
00:00002382 2239000408C0    	   527: 	move.l gfxaccel_ctrl,d1					; get the control reg
00:00002388 008100001C00    	   528: 	ori.l #$00001C00,d1							; trigger draw curve+triangle+interp
00:0000238E 61007394        	   529: 	bsr rbo
00:00002392 23C1FD300000    	   530: 	move.l d1,GFXACCEL+GFX_CTRL
00:00002398 4CDF0086        	   531: 	movem.l (a7)+,d1/d2/d7
00:0000239C 7000            	   532: 	moveq #E_Ok,d0
00:0000239E 4E75            	   533: 	rts
                            	   534: 
                            	   535: ; Waits until the specified number of queue slots are available.
                            	   536: ;
                            	   537: ; Parameters:
                            	   538: ;		d1 = number of queue slots required
                            	   539: 
                            	   540: gfxaccel_wait:
00:000023A0 48E77000        	   541: 	movem.l d1/d2/d3,-(a7)
00:000023A4 2401            	   542: 	move.l d1,d2
00:000023A6 2601            	   543: 	move.l d1,d3
                            	   544: .0001:
00:000023A8 2239FD300004    	   545: 	move.l GFXACCEL+GFX_STATUS,d1
00:000023AE 61007374        	   546: 	bsr rbo
00:000023B2 08010000        	   547: 	btst.l #0,d1			; first check busy bit
00:000023B6 66F0            	   548: 	bne.s .0001
00:000023B8 4841            	   549: 	swap d1
00:000023BA 48C1            	   550: 	ext.l d1
00:000023BC 2403            	   551: 	move.l d3,d2
00:000023BE D481            	   552: 	add.l d1,d2
00:000023C0 0C82000007F8    	   553: 	cmpi.l #2040,d2
00:000023C6 62E0            	   554: 	bhi.s .0001
00:000023C8 4CDF000E        	   555: 	movem.l (a7)+,d1/d2/d3
00:000023CC 4E75            	   556: 	rts
                            	   557: 

Source: "boot.x68"
                            	   581: 
                            	   582: ;------------------------------------------------------------------------------
                            	   583: ;------------------------------------------------------------------------------
                            	   584: ;------------------------------------------------------------------------------
                            	   585: 
                            	   586: GlobalReadLong:
00:000023CE 2210            	   587: 		move.l (a0),d1
00:000023D0 4E75            	   588: 		rts
00:000023D2 6004            	   589: 		bra nd1
                            	   590: GlobalWriteLong:
00:000023D4 2081            	   591: 		move.l d1,(a0)
00:000023D6 4E75            	   592: 		rts
                            	   593: net_delay:
                            	   594: 		bra nd1
                            	   595: nd1	bra nd2
                            	   596: nd2 bra nd3
                            	   597: nd3 bra nd4
00:000023D8 4E71            	   598: nd4	nop
00:000023DA 4E75            	   599: 		rts
                            	   600: 	
                            	   601: 
                            	   602: ;------------------------------------------------------------------------------
                            	   603: ; The IO bitmap needs to be initialized to allow access to IO.
                            	   604: ;------------------------------------------------------------------------------
                            	   605: 
                            	   606: InitIOPBitmap:
00:000023DC 7600            	   607: 	moveq #0,d3				; d3 = asid value
00:000023DE 303C003F        	   608: 	move.w #63,d0			; 64 bitmaps to setup
00:000023E2 4E7A8016        	   609: 	movec iops,a0			; a0 = IOP bitmap address
00:000023E6 2248            	   610: 	movea.l a0,a1			; a1 = table address
                            	   611: .0004
00:000023E8 4A03            	   612: 	tst.b d3
00:000023EA 57C1            	   613: 	seq d1						; set entire bitmap for asid 0, otherwise clear entire bitmap
00:000023EC 4881            	   614: 	ext.w	d1					; make into a long value
00:000023EE 48C1            	   615: 	ext.l d1
00:000023F0 383C007F        	   616: 	move.w #127,d4
                            	   617: .0001
00:000023F4 22C1            	   618: 	move.l d1,(a1)+		; set or clear entire table
00:000023F6 51CCFFFC        	   619: 	dbra d4,.0001
00:000023FA 72FF            	   620: 	moveq #-1,d1
00:000023FC 214100A0        	   621: 	move.l d1,160(a0)	; all io address spaces have access to semaphores
00:00002400 214100A4        	   622: 	move.l d1,164(a0)
00:00002404 214100A8        	   623: 	move.l d1,168(a0)
00:00002408 214100AC        	   624: 	move.l d1,172(a0)
00:0000240C 214101FC        	   625: 	move.l d1,508(a0)	; all io address spaces access random # generator
00:00002410 4840            	   626: 	swap d0
00:00002412 303C001F        	   627: 	move.w #31,d0			; 32 long words for the screen area per bitmap
                            	   628: .0003
00:00002416 20C1            	   629: 	move.l d1,(a0)+		; all cores have access to a screen
00:00002418 51C8FFFC        	   630: 	dbra d0,.0003
00:0000241C 4840            	   631: 	swap d0
00:0000241E 5203            	   632: 	addi.b #1,d3			; do next address space
00:00002420 2049            	   633: 	movea.l a1,a0			; a0 points to area for next address space
00:00002422 51C8FFC4        	   634: 	dbra d0,.0004
00:00002426 4E75            	   635: 	rts	
                            	   636: 	
                            	   637: ;------------------------------------------------------------------------------
                            	   638: ; RandInit
                            	   639: ; 	Initialize random number generator.
                            	   640: ;
                            	   641: ; Modifies:
                            	   642: ;		none
                            	   643: ; Parameters:
                            	   644: ;		none
                            	   645: ;	Returns:
                            	   646: ;		none
                            	   647: ;------------------------------------------------------------------------------
                            	   648: 
                            	   649: InitRand:
                            	   650: RandInit:
00:00002428 23FC123456780004	   651: 	move.l #$12345678,m_z		; initialize to some value
00:00002430 08D0
00:00002432 23FC987654320004	   652: 	move.l #$98765432,m_w
00:0000243A 08D4
00:0000243C 23FC828354380004	   653: 	move.l #$82835438,next_m_z
00:00002444 08D8
00:00002446 23FC087237460004	   654: 	move.l #$08723746,next_m_w
00:0000244E 08DC
00:00002450 48E7C000        	   655: 	movem.l	d0/d1,-(a7)
00:00002454 7025            	   656: 	moveq #37,d0								; lock semaphore
00:00002456 7204            	   657: 	moveq	#RAND_SEMA,d1
00:00002458 4E4F            	   658: 	trap #15
00:0000245A 4E7A0FE0        	   659: 	movec coreno,d0							; d0 = core number
00:0000245E 5580            	   660: 	sub.l #2,d0									; make 0 to 9
00:00002460 ED88            	   661: 	lsl.l	#6,d0									; allow 64 streams per core
00:00002462 23C0FD0FFD04    	   662: 	move.l d0,RAND_STRM					; select the stream
00:00002468 23FC12345678FD0F	   663: 	move.l #$12345678,RAND_MZ		; initialize to some value
00:00002470 FD08
00:00002472 23FC98765432FD0F	   664: 	move.l #$98765432,RAND_MW
00:0000247A FD0C
00:0000247C 23FC2E5BF271FD0F	   665: 	move.l #777777777,RAND_NUM	; generate first number
00:00002484 FD00
00:00002486 7026            	   666: 	moveq #38,d0								; unlock semaphore
00:00002488 7204            	   667: 	moveq	#RAND_SEMA,d1
00:0000248A 4E4F            	   668: 	trap #15
00:0000248C 4CDF0003        	   669: 	movem.l	(a7)+,d0/d1
00:00002490 4E75            	   670: 	rts
                            	   671: 
                            	   672: ;------------------------------------------------------------------------------
                            	   673: ; Returns
                            	   674: ;		d1 = random integer
                            	   675: ;------------------------------------------------------------------------------
                            	   676: 
                            	   677: RandGetNum:
00:00002492 48E7A000        	   678: 	movem.l	d0/d2,-(a7)
00:00002496 7204            	   679: 	moveq #RAND_SEMA,d1
00:00002498 6100013C        	   680: 	bsr T15LockSemaphore
00:0000249C 4E7A0FE0        	   681: 	movec	coreno,d0
00:000024A0 5580            	   682: 	sub.l #2,d0									; make 0 to 9
00:000024A2 ED88            	   683: 	lsl.l	#6,d0
00:000024A4 23C0FD0FFD04    	   684: 	move.l d0,RAND_STRM					; select the stream
00:000024AA 2439FD0FFD00    	   685: 	move.l RAND_NUM,d2					; d2 = random number
00:000024B0 23C2FD0FFD00    	   686: 	move.l d2,RAND_NUM		 		  ; generate next number
00:000024B6 61000124        	   687: 	bsr T15UnlockSemaphore
00:000024BA 2202            	   688: 	move.l d2,d1
00:000024BC 4CDF0005        	   689: 	movem.l	(a7)+,d0/d2
00:000024C0 4E75            	   690: 	rts
                            	   691: 
                            	   692: prng:
00:000024C2 2F02            	   693: 	move.l d2,-(a7)
00:000024C4 2239000408D0    	   694: 	move.l m_z,d1
00:000024CA 2401            	   695: 	move.l d1,d2
00:000024CC C2FC1B39        	   696: 	mulu #6969,d1
00:000024D0 4842            	   697: 	swap d2
00:000024D2 48C2            	   698: 	ext.l d2
00:000024D4 D481            	   699: 	add.l d1,d2
00:000024D6 23C2000408D8    	   700: 	move.l d2,next_m_z
                            	   701: 
00:000024DC 2239000408D4    	   702: 	move.l m_w,d1
00:000024E2 2401            	   703: 	move.l d1,d2
00:000024E4 C2FC4650        	   704: 	mulu #18000,d1
00:000024E8 4842            	   705: 	swap d2
00:000024EA 48C2            	   706: 	ext.l d2
00:000024EC D481            	   707: 	add.l d1,d2
00:000024EE 23C2000408DC    	   708: 	move.l d2,next_m_w
                            	   709: 	
00:000024F4 2239000408D0    	   710: 	move.l m_z,d1
00:000024FA 4841            	   711: 	swap d1
00:000024FC 4241            	   712: 	clr.w d1
00:000024FE D2B9000408D4    	   713: 	add.l m_w,d1
00:00002504 23F9000408D80004	   714: 	move.l next_m_z,m_z
00:0000250C 08D0
00:0000250E 23F9000408DC0004	   715: 	move.l next_m_w,m_w
00:00002516 08D4
00:00002518 241F            	   716: 	move.l (a7)+,d2
00:0000251A 4E75            	   717: 	rts
                            	   718: 	
                            	   719: ;------------------------------------------------------------------------------
                            	   720: ; Modifies:
                            	   721: ;		none
                            	   722: ; Returns
                            	   723: ;		fp0 = random float between 0 and 1.
                            	   724: ;------------------------------------------------------------------------------
                            	   725: 
                            	   726: _GetRand:
00:0000251C 2F01            	   727: 	move.l d1,-(sp)
00:0000251E F2276880        	   728: 	fmove.x fp1,-(sp)
00:00002522 6100FF6E        	   729: 	bsr RandGetNum
00:00002526 E289            	   730: 	lsr.l #1,d1									; make number between 0 and 2^31
00:00002528 F2014000        	   731: 	fmove.l d1,fp0
00:0000252C F23C40807FFFFFFF	   732: 	fmove.l #$7FFFFFFF,fp1			; divide by 2^31
00:00002534 F2000420        	   733: 	fdiv fp1,fp0
00:00002538 F21F4880        	   734: 	fmove.x (sp)+,fp1
00:0000253C 221F            	   735: 	move.l (sp)+,d1
00:0000253E 4E75            	   736: 	rts
                            	   737: 
                            	   738: ;------------------------------------------------------------------------------
                            	   739: ; RandWait
                            	   740: ;    Wait some random number of clock cycles before returning.
                            	   741: ;------------------------------------------------------------------------------
                            	   742: 
                            	   743: RandWait:
00:00002540 48E7C000        	   744: 	movem.l	d0/d1,-(a7)
00:00002544 6100FF4C        	   745: 	bsr			RandGetNum
00:00002548 0241000F        	   746: 	andi.w	#15,d1
                            	   747: .0001:
00:0000254C 4E71            	   748: 	nop
00:0000254E 51C9FFFC        	   749: 	dbra		d1,.0001
00:00002552 4CDF0003        	   750: 	movem.l	(a7)+,d0/d1
00:00002556 4E75            	   751: 	rts
                            	   752: 
                            	   753: ;------------------------------------------------------------------------------
                            	   754: ; Initialize semaphores
                            	   755: ; - all semaphores are set to unlocked except the first one, which is locked
                            	   756: ; for core #2.
                            	   757: ;
                            	   758: ; Parameters:
                            	   759: ;		<none>
                            	   760: ; Modifies:
                            	   761: ;		<none>
                            	   762: ; Returns:
                            	   763: ;		<none>
                            	   764: ;------------------------------------------------------------------------------
                            	   765: 
                            	   766: InitSemaphores:
00:00002558 48E74080        	   767: 	movem.l	d1/a0,-(a7)
00:0000255C 41F9FD050000    	   768: 	lea			semamem,a0
00:00002562 217C000200002000	   769: 	move.l	#$20000,$2000(a0)	; lock the first semaphore for core #2, thread #0
00:0000256A 323C00FE        	   770: 	move.w	#254,d1
                            	   771: .0001:
00:0000256E 5888            	   772: 	lea			4(a0),a0
00:00002570 42A82000        	   773: 	clr.l		$2000(a0)					; write zeros to unlock
00:00002574 51C9FFF8        	   774: 	dbra		d1,.0001
00:00002578 4CDF0102        	   775: 	movem.l	(a7)+,d1/a0
00:0000257C 4E75            	   776: 	rts
                            	   777: 
                            	   778: ; -----------------------------------------------------------------------------
                            	   779: ; Parameters:
                            	   780: ;		d1 semaphore number
                            	   781: ;
                            	   782: ; Side Effects:
                            	   783: ;		increments semaphore, saturates at 255
                            	   784: ;
                            	   785: ; Returns:	
                            	   786: ; 	z flag set if semaphore was zero
                            	   787: ; -----------------------------------------------------------------------------
                            	   788: 
                            	   789: ;IncrementSemaphore:
                            	   790: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   791: ;	lea			semamem,a0			; point to semaphore memory
                            	   792: ;	ext.w		d1							; make d1 word value
                            	   793: ;	asl.w		#4,d1						; align to memory
                            	   794: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   795: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   796: ;	rts
                            	   797: 	
                            	   798: ; -----------------------------------------------------------------------------
                            	   799: ; Parameters:
                            	   800: ;		d1 semaphore number
                            	   801: ;
                            	   802: ; Side Effects:
                            	   803: ;		decrements semaphore, saturates at zero
                            	   804: ;
                            	   805: ; Returns:	
                            	   806: ; 	z flag set if semaphore was zero
                            	   807: ; -----------------------------------------------------------------------------
                            	   808: 
                            	   809: ;DecrementSemaphore:
                            	   810: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   811: ;	lea			semamem,a0			; point to semaphore memory
                            	   812: ;	andi.w	#255,d1					; make d1 word value
                            	   813: ;	asl.w		#4,d1						; align to memory
                            	   814: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   815: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   816: ;	rts
                            	   817: 
                            	   818: ; -----------------------------------------------------------------------------
                            	   819: ; Lock a semaphore
                            	   820: ;
                            	   821: ; Parameters:
                            	   822: ;		d0 = key
                            	   823: ;		d1 = semaphore number
                            	   824: ; -----------------------------------------------------------------------------
                            	   825: 
                            	   826: LockSemaphore:
00:0000257E 4E75            	   827: 	rts
00:00002580 48E74080        	   828: 	movem.l	d1/a0,-(a7)			; save registers
00:00002584 41F9FD050000    	   829: 	lea			semamem,a0			; point to semaphore memory lock area
00:0000258A 024100FF        	   830: 	andi.w	#255,d1					; make d1 word value
00:0000258E E549            	   831: 	lsl.w		#2,d1						; align to memory
                            	   832: .0001
00:00002590 21801000        	   833: 	move.l	d0,(a0,d1.w)		; try and write the semaphore
00:00002594 B0B01000        	   834: 	cmp.l		(a0,d1.w),d0		; did it lock?
00:00002598 66F6            	   835: 	bne.s		.0001						; no, try again
00:0000259A 4CDF0102        	   836: 	movem.l	(a7)+,a0/d1			; restore regs
00:0000259E 4E75            	   837: 	rts
                            	   838: 	
                            	   839: ; -----------------------------------------------------------------------------
                            	   840: ; Unlocks a semaphore even if not the owner.
                            	   841: ;
                            	   842: ; Parameters:
                            	   843: ;		d1 semaphore number
                            	   844: ; -----------------------------------------------------------------------------
                            	   845: 
                            	   846: ForceUnlockSemaphore:
00:000025A0 48E74080        	   847: 	movem.l	d1/a0,-(a7)				; save registers
00:000025A4 41F9FD053000    	   848: 	lea			semamem+$3000,a0	; point to semaphore memory read/write area
00:000025AA 024100FF        	   849: 	andi.w	#255,d1						; make d1 word value
00:000025AE E549            	   850: 	lsl.w		#2,d1							; align to memory
00:000025B0 42B01000        	   851: 	clr.l		(a0,d1.w)					; write zero to unlock
00:000025B4 4CDF0102        	   852: 	movem.l	(a7)+,a0/d1				; restore regs
00:000025B8 4E75            	   853: 	rts
                            	   854: 
                            	   855: ; -----------------------------------------------------------------------------
                            	   856: ; Unlocks a semaphore. Must be the owner to have effect.
                            	   857: ; Three cases:
                            	   858: ;	1) the owner, the semaphore will be reset to zero
                            	   859: ;	2) not the owner, the write will be ignored
                            	   860: ; 3) already unlocked, the write will be ignored
                            	   861: ;
                            	   862: ; Parameters:
                            	   863: ;		d0 = key
                            	   864: ;		d1 = semaphore number
                            	   865: ; -----------------------------------------------------------------------------
                            	   866: 
                            	   867: UnlockSemaphore:
00:000025BA 60E4            	   868: 	bra ForceUnlockSemaphore
00:000025BC 48E74080        	   869: 	movem.l	d1/a0,-(a7)				; save registers
00:000025C0 41F9FD051000    	   870: 	lea			semamem+$1000,a0	; point to semaphore memory unlock area
00:000025C6 024100FF        	   871: 	andi.w	#255,d1						; make d1 word value
00:000025CA E549            	   872: 	lsl.w		#2,d1							; align to memory
00:000025CC 21801000        	   873: 	move.l	d0,(a0,d1.w)			; write matching value to unlock
00:000025D0 4CDF0102        	   874: 	movem.l	(a7)+,a0/d1				; restore regs
00:000025D4 4E75            	   875: 	rts
                            	   876: 
                            	   877: ; -----------------------------------------------------------------------------
                            	   878: ; Parameters:
                            	   879: ;		d1 = semaphore to lock / unlock
                            	   880: ; -----------------------------------------------------------------------------
                            	   881: 
                            	   882: T15LockSemaphore:	
00:000025D6 4E7A0012        	   883: 	movec tr,d0
00:000025DA 60A2            	   884: 	bra LockSemaphore
                            	   885: 
                            	   886: T15UnlockSemaphore:
00:000025DC 4E7A0012        	   887: 	movec tr,d0
00:000025E0 60D8            	   888: 	bra UnlockSemaphore
                            	   889: 
                            	   890: T15GetFloat:
00:000025E2 2049            	   891: 	move.l a1,a0
00:000025E4 2001            	   892: 	move.l d1,d0
00:000025E6 61006D10        	   893: 	bsr _GetFloat
00:000025EA 2248            	   894: 	move.l a0,a1
00:000025EC 2200            	   895: 	move.l d0,d1
00:000025EE 4E75            	   896: 	rts
                            	   897: 
                            	   898: T15Abort:
00:000025F0 61006DDE        	   899: 	bsr DisplayByte
00:000025F4 43FA77AC        	   900: 	lea msgStackCanary,a1
00:000025F8 61005500        	   901: 	bsr DisplayStringCRLF
00:000025FC 60005B3A        	   902: 	bra Monitor
                            	   903: 
                            	   904: chk_exception:
00:00002600 222F0002        	   905: 	move.l 2(sp),d1
00:00002604 61006DBE        	   906: 	bsr DisplayTetra
00:00002608 43FA778A        	   907: 	lea msgChk,a1
00:0000260C 610054EC        	   908: 	bsr DisplayStringCRLF
00:00002610 60005B26        	   909: 	bra Monitor
                            	   910: 
                            	   911: ; -----------------------------------------------------------------------------
                            	   912: ; Delay for a few seconds to allow some I/O reset operations to take place.
                            	   913: ; -----------------------------------------------------------------------------
                            	   914: 
                            	   915: Delay3s:
00:00002614 203C002DC6C0    	   916: 	move.l	#3000000,d0		; this should take a few seconds to loop
00:0000261A 41F9FD0FFF00    	   917: 	lea			leds,a0				; a0 = address of LED output register
00:00002620 6002            	   918: 	bra			dly3s1				; branch to the loop
                            	   919: dly3s2:	
00:00002622 4840            	   920: 	swap		d0						; loop is larger than 16-bits
                            	   921: dly3s1:
00:00002624 2200            	   922: 	move.l	d0,d1					; the counter cycles fast, so use upper bits for display
00:00002626 E199            	   923: 	rol.l		#8,d1					; could use swap here, but lets test rol
00:00002628 E199            	   924: 	rol.l		#8,d1
00:0000262A 1081            	   925: 	move.b	d1,(a0)				; set the LEDs
00:0000262C 51C8FFF6        	   926: 	dbra		d0,dly3s1			; decrement and branch back
00:00002630 4840            	   927: 	swap		d0
00:00002632 51C8FFEE        	   928: 	dbra		d0,dly3s2
00:00002636 4E75            	   929: 	rts
                            	   930: 
                            	   931: Delay3s2:
00:00002638 4E7A0FE0        	   932: 	movec		coreno,d0			; vary delay by core to stagger startup
00:0000263C E188            	   933: 	lsl.l		#8,d0
00:0000263E 0680002DC6C0    	   934: 	addi.l	#3000000,d0		; this should take a few seconds to loop
00:00002644 6002            	   935: 	bra			.0001					; branch to the loop
                            	   936: .0002	
00:00002646 4840            	   937: 	swap		d0						; loop is larger than 16-bits
                            	   938: .0001
00:00002648 51C8FFFE        	   939: 	dbra		d0,.0001			; decrement and branch back
00:0000264C 4840            	   940: 	swap		d0
00:0000264E 51C8FFF6        	   941: 	dbra		d0,.0002
00:00002652 4E75            	   942: 	rts
                            	   943: 
                            	   944: 	include "cputest.x68"

Source: "cputest.x68"
                            	     1: ;; @name cputest.s Tests 68000 cpu
                            	     2: ;
                            	     3: ; Based on https://github.com/MicroCoreLabs/Projects/blob/master/MCL68/MC68000_Test_Code/MC68000_test_all_opcodes.X68
                            	     4: ;
                            	     5: ; Converted into a CD-i system ROM image by CD-i Fan:
                            	     6: ; - comment lines must start in first column
                            	     7: ; - replaced org instructions by suitable rept
                            	     8: ; - copy vectors to low memory at startup
                            	     9: ; - replaced jsr/jmp by bsr/bra for position independence
                            	    10: ; - replaced move.l by moveq whenever possible
                            	    11: ; - converted branches to short form whenever possible (e.g. beq => beq.s)
                            	    12: ; - added immediate suffix to opcodes where required (e.g. and => andi)
                            	    13: ; The last three modifications are required to make the test work;
                            	    14: ; apparently the original assembler was somewhat smarter then
                            	    15: ; the Microware OS-9 assembler and did this automatically.
                            	    16: ;
                            	    17: ; In some cases the opcodes of the test are used as test data!
                            	    18: ;
                            	    19: ; Original file header follows.
                            	    20: ;
                            	    21: ;  File Name   :  MCL68 Opcode Tests
                            	    22: ;  Used on     :
                            	    23: ;  Author      :  Ted Fried, MicroCore Labs
                            	    24: ;  Creation    :  7/14/2020
                            	    25: ;
                            	    26: ;   Description:
                            	    27: ;   ============
                            	    28: ;
                            	    29: ;  Program to test all of the Motorola 68000's opcodes.
                            	    30: ;
                            	    31: ;  If failures are detected, the code will immediately loop on itself.
                            	    32: ;  All addressing modes, data sizes, and opcode combinations are tested.
                            	    33: ;
                            	    34: ;  This code was developed using the Easy68K simulator where all tests passed!
                            	    35: ;
                            	    36: ;------------------------------------------------------------------------
                            	    37: ;
                            	    38: ; Modification History:
                            	    39: ; =====================
                            	    40: ;
                            	    41: ; Revision 1 7/14/2020
                            	    42: ; Initial revision
                            	    43: ;
                            	    44: ;
                            	    45: ;------------------------------------------------------------------------
                            	    46: ;
                            	    47: ; Copyright (c) 2020 Ted Fried
                            	    48: ;
                            	    49: ; Permission is hereby granted, free of charge, to any person obtaining a copy
                            	    50: ; of this software and associated documentation files (the "Software"), to deal
                            	    51: ; in the Software without restriction, including without limitation the rights
                            	    52: ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                            	    53: ; copies of the Software, and to permit persons to whom the Software is
                            	    54: ; furnished to do so, subject to the following conditions:
                            	    55: ;
                            	    56: ; The above copyright notice and this permission notice shall be included in all
                            	    57: ; copies or substantial portions of the Software.
                            	    58: ;
                            	    59: ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            	    60: ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            	    61: ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            	    62: ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            	    63: ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                            	    64: ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                            	    65: ; SOFTWARE.
                            	    66: 
                            	    67: ; Modified for rf68000 project (c) 2022 Robert Finch
                            	    68: 
                            	    69: ;	data
                            	    70: ;	dc.l		$0001FFFC						; top of local ram area
                            	    71: ;	dc.l		start
                            	    72: 
                            	    73: ;    org $1000												; code starts at $400 in local ram
                            	    74: *start:
                            	    75: ;	move.l	$FFFFFFE0,d0		; get core number
                            	    76: ;	cmpi.b	#2,d0
                            	    77: ;	bne			do_nothing
                            	    78: 
                            	    79: ;	lea			EXCEPTION_6,a0	; check exception vector
                            	    80: ;	move.l	a0,6*4
                            	    81: ;	lea			EXCEPTION_7,a0	; TRAPV exception vector
                            	    82: ;	move.l	a0,7*4
                            	    83: 
                            	    84: cpu_test:
00:00002654 610000F6        	    85: 	bsr	op_ORI_TO_CCR
00:00002658 61000114        	    86: 	bsr	op_ORI_TO_SR
00:0000265C 61000132        	    87: 	bsr	op_EORI_TO_CCR
00:00002660 61000154        	    88: 	bsr	op_EORI_TO_SR
00:00002664 61000176        	    89: 	bsr	op_ANDI_TO_CCR
00:00002668 61000198        	    90: 	bsr	op_ANDI_TO_SR
00:0000266C 610001BA        	    91: 	bsr	op_BTST
00:00002670 61000560        	    92: 	bsr	op_BCHG
00:00002674 610008C4        	    93: 	bsr	op_BCLR
00:00002678 61000C0E        	    94: 	bsr	op_BSET
00:0000267C 61000F52        	    95: 	bsr op_MOVEP
00:00002680 61000FDA        	    96: 	bsr op_BOOL_I
00:00002684 610011BE        	    97: 	bsr op_CMP_I
00:00002688 610013A2        	    98: 	bsr op_ADD_I
00:0000268C 61001524        	    99: 	bsr op_SUB_I
00:00002690 610016A6        	   100: 	bsr op_MOVE
00:00002694 610018AE        	   101: 	bsr op_MOVE_xxx_FLAGS
00:00002698 61001A9E        	   102: 	bsr op_EXT
00:0000269C 61001AC6        	   103: 	bsr op_SWAP
00:000026A0 61001AD8        	   104: 	bsr op_LEAPEA
00:000026A4 61001B80        	   105: 	bsr op_TAS
00:000026A8 61001BA2        	   106: 	bsr op_TST
00:000026AC 61001BDC        	   107: 	bsr op_LINKS
00:000026B0 61001BF6        	   108: 	bsr op_MOVE_USP
00:000026B4 61001C02        	   109: 	bsr op_CHK
00:000026B8 61001C48        	   110: 	bsr op_NEGS
00:000026BC 61001FD2        	   111: 	bsr op_MOVEM
                            	   112: ;	bsr op_ABCD
                            	   113: ;	bsr op_SBCD
                            	   114: ;	bsr op_NBCD
00:000026C0 6100256E        	   115: 	bsr op_TRAPV
00:000026C4 61002586        	   116: 	bsr op_RTR
00:000026C8 61001144        	   117: 	bsr op_BSR
00:000026CC 610025A0        	   118: 	bsr op_BCC
00:000026D0 6100261C        	   119: 	bsr op_DBCC
00:000026D4 6100263E        	   120: 	bsr op_SCC
00:000026D8 6100266A        	   121: 	bsr op_ADDQ
00:000026DC 61002720        	   122: 	bsr op_SUBQ
00:000026E0 610027D6        	   123: 	bsr op_MOVEQ
                            	   124: ;	bsr op_DIVU
                            	   125: ;	bsr op_DIVS
00:000026E4 61002892        	   126: 	bsr op_OR
00:000026E8 61002978        	   127: 	bsr op_AND
00:000026EC 61002A5E        	   128: 	bsr op_EOR
00:000026F0 61002AD0        	   129: 	bsr op_CMP
00:000026F4 61002B42        	   130: 	bsr op_CMPA
00:000026F8 61002BA4        	   131: 	bsr op_CMPM
00:000026FC 61002C46        	   132: 	bsr op_ADD
00:00002700 61002D2C        	   133: 	bsr op_SUB
00:00002704 61002E12        	   134: 	bsr op_ADDA
00:00002708 61002E5A        	   135: 	bsr op_SUBA
00:0000270C 61002EA2        	   136: 	bsr op_ADDX	
00:00002710 61002FAE        	   137: 	bsr op_SUBX
00:00002714 610030BA        	   138: 	bsr op_MULU
00:00002718 61003102        	   139: 	bsr op_MULS
00:0000271C 6100314A        	   140: 	bsr op_EXG
00:00002720 610031B4        	   141: 	bsr op_ROx
00:00002724 610033E6        	   142: 	bsr op_ROXx
00:00002728 61003618        	   143: 	bsr op_SHIFTS
00:0000272C 61003856        	   144: 	bsr op_SHIFTS2
                            	   145: 
00:00002730 4E75            	   146: 	rts
                            	   147: 	bra ALL_DONE
                            	   148: 
                            	   149: * Loop here when all tests pass
                            	   150: *
                            	   151: 
00:00002732 60FE            	   152: ALL_DONE: bra.s ALL_DONE
                            	   153: 
00:00002734 263C33333333    	   154: BSR_FAR1:       move.l #$33333333,d3
00:0000273A 4E75            	   155:                 rts
                            	   156: 
                            	   157: ;	moveq		#-1,d0
                            	   158: ;	move.l	d0,$FD0FFF00
                            	   159: ;do_nothing:
                            	   160: ;	bra			*		
                            	   161: 
                            	   162: 
                            	   163: ;' Exception Vector = 6   CHK Instruction
                            	   164: ;
                            	   165: ;	align	4
                            	   166: EXCEPTION_6:
00:0000273C 2C3CEEEE0006    	   167: 	move.l #$EEEE0006,d6      * Set d6 to the exception vector
00:00002742 4E73            	   168: 	rte
                            	   169: 
                            	   170: ; Exception Vector = 7   TRAPV Instruction
                            	   171: ;
                            	   172: ;	align	4
                            	   173: EXCEPTION_7:
00:00002744 203C12345678    	   174: 	move.l #$12345678,d0      * Set d6 to the exception vector
00:0000274A 4E73            	   175: 	rte
                            	   176: 
                            	   177: ;-----------------------------------------------------------
                            	   178: ;-----------------------------------------------------------
                            	   179: ; OPCODE : ORI_TO_CCR
                            	   180: ;-----------------------------------------------------------
                            	   181: ;-----------------------------------------------------------
                            	   182: op_ORI_TO_CCR:
                            	   183: 
00:0000274C 003C00FF        	   184:     ori.b #$FF,CCR
00:00002750 6AFE            	   185:     bpl.s *                   ; branch if Z clear
00:00002752 66FE            	   186:     bne.s *                   ; branch if N clear
00:00002754 68FE            	   187:     bvc.s *                   ; branch if V clear
00:00002756 64FE            	   188:     bcc.s *                   ; branch if C clear
                            	   189: 
00:00002758 44FC0000        	   190:     move #$00,CCR
00:0000275C 003C0000        	   191:     ori.b #$00,CCR
00:00002760 67FE            	   192:     beq.s *                   ; branch if Z set
00:00002762 6BFE            	   193:     bmi.s *                   ; branch if N set
00:00002764 69FE            	   194:     bvs.s *                   ; branch if V set
00:00002766 65FE            	   195:     bcs.s *                   ; branch if C set
                            	   196: 
00:00002768 46FC2700        	   197:     move.w #$2700,SR          ; Put flags back to initial value
                            	   198: 
00:0000276C 4E75            	   199:     rts
                            	   200: 
                            	   201: ;-----------------------------------------------------------
                            	   202: ;-----------------------------------------------------------
                            	   203: ; OPCODE : ORI_TO_SR
                            	   204: ;-----------------------------------------------------------
                            	   205: ;-----------------------------------------------------------
                            	   206: 
                            	   207: op_ORI_TO_SR:
                            	   208: 
00:0000276E 007C2FFF        	   209:     ori.w #$2FFF,SR
00:00002772 6AFE            	   210:     bpl.s *                   * branch if Z clear
00:00002774 66FE            	   211:     bne.s *                   * branch if N clear
00:00002776 68FE            	   212:     bvc.s *                   * branch if V clear
00:00002778 64FE            	   213:     bcc.s *                   * branch if C clear
                            	   214: 
00:0000277A 46FC2000        	   215:     move.w #$2000,SR
00:0000277E 007C0000        	   216:     ori.w #$0000,SR
00:00002782 67FE            	   217:     beq.s *                   * branch if Z set
00:00002784 6BFE            	   218:     bmi.s *                   * branch if N set
00:00002786 69FE            	   219:     bvs.s *                   * branch if V set
00:00002788 65FE            	   220:     bcs.s *                   * branch if C set
                            	   221: 
00:0000278A 46FC2700        	   222:     move.w #$2700,sr         * Put flags back to initial value
                            	   223: 
00:0000278E 4E75            	   224:     rts
                            	   225: ; 
                            	   226: ;-----------------------------------------------------------
                            	   227: ;-----------------------------------------------------------
                            	   228: ; OPCODE : EORI_TO_CCR
                            	   229: ;-----------------------------------------------------------
                            	   230: ;-----------------------------------------------------------
                            	   231: op_EORI_TO_CCR:
                            	   232: 
00:00002790 44FC0000        	   233:     move #$00,CCR
00:00002794 0A3C00FF        	   234:     eori.b #$FF,CCR
00:00002798 6AFE            	   235:     bpl.s *                   ; branch if Z clear
00:0000279A 66FE            	   236:     bne.s *                   ; branch if N clear
00:0000279C 68FE            	   237:     bvc.s *                   ; branch if V clear
00:0000279E 64FE            	   238:     bcc.s *                   ; branch if C clear
                            	   239: 
00:000027A0 44FC0000        	   240:     move #$00,CCR
00:000027A4 0A3C0000        	   241:     eori.b #$00,CCR
00:000027A8 67FE            	   242:     beq.s *                   ; branch if Z set
00:000027AA 6BFE            	   243:     bmi.s *                   ; branch if N set
00:000027AC 69FE            	   244:     bvs.s *                   ; branch if V set
00:000027AE 65FE            	   245:     bcs.s *                   ; branch if C set
                            	   246: 
00:000027B0 46FC2700        	   247:     move.w #$2700,sr           ; Put flags back to initial value
                            	   248: 
00:000027B4 4E75            	   249:     rts
                            	   250: 
                            	   251: 
                            	   252: 
                            	   253: *-----------------------------------------------------------
                            	   254: *-----------------------------------------------------------
                            	   255: * OPCODE : EORI_TO_SR
                            	   256: *-----------------------------------------------------------
                            	   257: *-----------------------------------------------------------
                            	   258: op_EORI_TO_SR:
                            	   259: 
00:000027B6 46FC2000        	   260:     move.w #$2000,SR
00:000027BA 0A7C0FFF        	   261:     eori.w #$0FFF,SR
00:000027BE 6AFE            	   262:     bpl.s *                   * branch if Z clear
00:000027C0 66FE            	   263:     bne.s *                   * branch if N clear
00:000027C2 68FE            	   264:     bvc.s *                   * branch if V clear
00:000027C4 64FE            	   265:     bcc.s *                   * branch if C clear
                            	   266: 
00:000027C6 46FC2000        	   267:     move.w #$2000,SR
00:000027CA 0A7C0000        	   268:     eori.w #$0000,SR
00:000027CE 67FE            	   269:     beq.s *                   * branch if Z set
00:000027D0 6BFE            	   270:     bmi.s *                   * branch if N set
00:000027D2 69FE            	   271:     bvs.s *                   * branch if V set
00:000027D4 65FE            	   272:     bcs.s *                   * branch if C set
                            	   273: 
00:000027D6 46FC2700        	   274:     move.w #$2700,sr          * Put flags back to initial value
                            	   275: 
00:000027DA 4E75            	   276:     rts
                            	   277: 
                            	   278: 
                            	   279: 
                            	   280: *-----------------------------------------------------------
                            	   281: *-----------------------------------------------------------
                            	   282: * OPCODE : ANDI_TO_CCR
                            	   283: *-----------------------------------------------------------
                            	   284: *-----------------------------------------------------------
                            	   285: op_ANDI_TO_CCR:
                            	   286: 
00:000027DC 44FC00FF        	   287:     move #$FF,CCR
00:000027E0 023C00FF        	   288:     andi.b #$FF,CCR
00:000027E4 6AFE            	   289:     bpl.s *                   * branch if Z clear
00:000027E6 66FE            	   290:     bne.s *                   * branch if N clear
00:000027E8 68FE            	   291:     bvc.s *                   * branch if V clear
00:000027EA 64FE            	   292:     bcc.s *                   * branch if C clear
                            	   293: 
00:000027EC 44FC00FF        	   294:     move #$FF,CCR
00:000027F0 023C0000        	   295:     andi.b #$00,CCR
00:000027F4 67FE            	   296:     beq.s *                   * branch if Z set
00:000027F6 6BFE            	   297:     bmi.s *                   * branch if N set
00:000027F8 69FE            	   298:     bvs.s *                   * branch if V set
00:000027FA 65FE            	   299:     bcs.s *                   * branch if C set
                            	   300: 
00:000027FC 46FC2700        	   301:     move #$2700,SR           * Put flags back to initial value
                            	   302: 
00:00002800 4E75            	   303:     rts
                            	   304: 
                            	   305: 
                            	   306: 
                            	   307: *-----------------------------------------------------------
                            	   308: *-----------------------------------------------------------
                            	   309: * OPCODE : ANDI_TO_SR
                            	   310: *-----------------------------------------------------------
                            	   311: *-----------------------------------------------------------
                            	   312: op_ANDI_TO_SR:
00:00002802 46FC20FF        	   313:     move.w #$20FF,SR
00:00002806 027CFFFF        	   314:     andi.w #$FFFF,SR
00:0000280A 6AFE            	   315:     bpl.s *                   * branch if Z clear
00:0000280C 66FE            	   316:     bne.s *                   * branch if N clear
00:0000280E 68FE            	   317:     bvc.s *                   * branch if V clear
00:00002810 64FE            	   318:     bcc.s *                   * branch if C clear
                            	   319: 
00:00002812 46FC20FF        	   320:     move.w #$20FF,SR
00:00002816 027CFF00        	   321:     andi.w #$FF00,SR
00:0000281A 67FE            	   322:     beq.s *                   * branch if Z set
00:0000281C 6BFE            	   323:     bmi.s *                   * branch if N set
00:0000281E 69FE            	   324:     bvs.s *                   * branch if V set
00:00002820 65FE            	   325:     bcs.s *                   * branch if C set
                            	   326: 
00:00002822 46FC2700        	   327:     move.w #$2700,sr           * Put flags back to initial value
                            	   328: 
00:00002826 4E75            	   329:     rts
                            	   330: 
                            	   331: 
                            	   332: *-----------------------------------------------------------
                            	   333: *-----------------------------------------------------------
                            	   334: * OPCODE : BTST
                            	   335: *-----------------------------------------------------------
                            	   336: *-----------------------------------------------------------
                            	   337: op_BTST:
                            	   338: 
                            	   339: *  Bit Number.s Static
                            	   340: 
                            	   341: *             EA = Dn  - LONG only
00:00002828 203C80000001    	   342:             move.l #$80000001,d0      * populate test data
00:0000282E 08000000        	   343:             btst.l #0,d0
00:00002832 67FE            	   344:             beq.s *               * branch if Z set
00:00002834 08000001        	   345:             btst.l #1,d0              *
00:00002838 66FE            	   346:             bne.s *               * branch if Z clear
00:0000283A 0800001F        	   347:             btst.l #31,d0             *
00:0000283E 67FE            	   348:             beq.s *               * branch if Z set
                            	   349: 
                            	   350: 
                            	   351: *             EA = (An)  - BYTE only
00:00002840 307C0100        	   352:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002844 10BC0081        	   353:             move.b #$81,(a0)          * populate test data
00:00002848 1210            	   354:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:0000284A 08100000        	   355:             btst.b #0,(a0)
00:0000284E 67FE            	   356:             beq.s *               * branch if Z set
00:00002850 08100001        	   357:             btst.b #1,(a0)            *
00:00002854 66FE            	   358:             bne.s *               * branch if Z clear
00:00002856 08100007        	   359:             btst.b #7,(a0)            *
00:0000285A 67FE            	   360:             beq.s *               * branch if Z set
                            	   361: 
                            	   362: 
                            	   363: *             EA = (An)+  - BYTE only
00:0000285C 307C0100        	   364:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002860 10FC0001        	   365:             move.b #$01,(a0)+         * populate test data
00:00002864 10FC00FC        	   366:             move.b #$FC,(a0)+         * populate test data
00:00002868 10FC0080        	   367:             move.b #$80,(a0)+         * populate test data
00:0000286C 307C0100        	   368:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002870 08180000        	   369:             btst.b #0,(a0)+
00:00002874 67FE            	   370:             beq.s *               * branch if Z set
00:00002876 08180001        	   371:             btst.b #1,(a0)+           *
00:0000287A 66FE            	   372:             bne.s *               * branch if Z clear
00:0000287C 08180007        	   373:             btst.b #7,(a0)+           *
00:00002880 67FE            	   374:             beq.s *               * branch if Z set
                            	   375: 
                            	   376: 
                            	   377: *             EA = -(An)  - BYTE only
00:00002882 307C0100        	   378:             move.l #$00000100,a0      * point to memory to address
00:00002886 10FC0080        	   379:             move.b #$80,(a0)+         * populate test data
00:0000288A 10FC00FC        	   380:             move.b #$FC,(a0)+         * populate test data
00:0000288E 10FC0001        	   381:             move.b #$01,(a0)+         * populate test data
00:00002892 307C0103        	   382:             move.l #$00000103,a0      * point to memory to address
00:00002896 08200000        	   383:             btst.b #0,-(a0)
00:0000289A 67FE            	   384:             beq.s *               * branch if Z set
00:0000289C 08200001        	   385:             btst.b #1,-(a0)           *
00:000028A0 66FE            	   386:             bne.s *               * branch if Z clear
00:000028A2 08200007        	   387:             btst.b #7,-(a0)           *
00:000028A6 67FE            	   388:             beq.s *               * branch if Z set
                            	   389: 
                            	   390: 
                            	   391: *             EA = n(An)  - BYTE only
00:000028A8 307C0100        	   392:             move.l #$00000100,a0      * point to memory to address
00:000028AC 10FC0001        	   393:             move.b #$01,(a0)+         * populate test data
00:000028B0 10FC00FC        	   394:             move.b #$FC,(a0)+         * populate test data
00:000028B4 10FC0080        	   395:             move.b #$80,(a0)+         * populate test data
00:000028B8 307C0100        	   396:             move.l #$00000100,a0      * point to memory to address
00:000028BC 08100000        	   397:             btst.b #0,0(a0)
00:000028C0 67FE            	   398:             beq.s *               * branch if Z set
00:000028C2 082800010001    	   399:             btst.b #1,1(a0)           *
00:000028C8 66FE            	   400:             bne.s *               * branch if Z clear
00:000028CA 082800070002    	   401:             btst.b #7,2(a0)           *
00:000028D0 67FE            	   402:             beq.s *               * branch if Z set
                            	   403: 
                            	   404: 
                            	   405: *             EA = n(An,R.W)  - BYTE only
00:000028D2 307C0100        	   406:             move.l #$00000100,a0      * point to memory to address
00:000028D6 93C9            	   407:             move.l #$00000000,a1      * point to memory to address
00:000028D8 347C0001        	   408:             move.l #$00000001,a2      * point to memory to address
00:000028DC 7000            	   409:             moveq  #$00000000,d0      * point to memory to address
00:000028DE 7201            	   410:             moveq  #$00000001,d1      * point to memory to address
00:000028E0 083000000000    	   411:             btst.b #0,0(a0,d0.w)
00:000028E6 67FE            	   412:             beq.s *               * branch if Z set
00:000028E8 083000011000    	   413:             btst.b #1,0(a0,d1.w)      *
00:000028EE 66FE            	   414:             bne.s *               * branch if Z clear
00:000028F0 083000071001    	   415:             btst.b #7,1(a0,d1.w)      *
00:000028F6 67FE            	   416:             beq.s *               * branch if Z set
                            	   417: *             EA = n(An,R.L)  - BYTE only
00:000028F8 083000000800    	   418:             btst.b #0,0(a0,d0.l)
00:000028FE 67FE            	   419:             beq.s *               * branch if Z set
00:00002900 083000011800    	   420:             btst.b #1,0(a0,d1.l)      *
00:00002906 66FE            	   421:             bne.s *               * branch if Z clear
00:00002908 083000071801    	   422:             btst.b #7,1(a0,d1.l)      *
00:0000290E 67FE            	   423:             beq.s *               * branch if Z set
                            	   424: *             EA = n(An,A.W)  - BYTE only
00:00002910 083000009000    	   425:             btst.b #0,0(a0,a1.w)
00:00002916 67FE            	   426:             beq.s *               * branch if Z set
00:00002918 08300001A000    	   427:             btst.b #1,0(a0,a2.w)      *
00:0000291E 66FE            	   428:             bne.s *               * branch if Z clear
00:00002920 08300007A001    	   429:             btst.b #7,1(a0,a2.w)      *
00:00002926 67FE            	   430:             beq.s *               * branch if Z set
                            	   431: *             EA = n(An,A.L)  - BYTE only
00:00002928 083000009800    	   432:             btst.b #0,0(a0,a1.l)
00:0000292E 67FE            	   433:             beq.s *               * branch if Z set
00:00002930 08300001A800    	   434:             btst.b #1,0(a0,a2.l)      *
00:00002936 66FE            	   435:             bne.s *               * branch if Z clear
00:00002938 08300007A801    	   436:             btst.b #7,1(a0,a2.l)      *
00:0000293E 67FE            	   437:             beq.s *               * branch if Z set
                            	   438: 
                            	   439: 
                            	   440: *             EA = x.W  - BYTE only
00:00002940 083800000100    	   441:             btst.b #0,$0100
00:00002946 67FE            	   442:             beq.s *               * branch if Z set
00:00002948 083800010101    	   443:             btst.b #1,$0101           *
00:0000294E 66FE            	   444:             bne.s *               * branch if Z clear
00:00002950 083800070102    	   445:             btst.b #7,$0102           *
00:00002956 67FE            	   446:             beq.s *               * branch if Z set
                            	   447: 
                            	   448: 
                            	   449: *             EA = x.L  - BYTE only
00:00002958 207C0000F100    	   450:             move.l #$F100,a0      * point to memory to address 0x100
00:0000295E 10FC0001        	   451:             move.b #$01,(a0)+         * populate test data
00:00002962 10FC00FC        	   452:             move.b #$FC,(a0)+         * populate test data
00:00002966 10FC0080        	   453:             move.b #$80,(a0)+         * populate test data
00:0000296A 083900000000F100	   454:             btst.b #0,$F100
00:00002972 67FE            	   455:             beq.s *               * branch if Z set
00:00002974 083900010000F101	   456:             btst.b #1,$F101       *
00:0000297C 66FE            	   457:             bne.s *               * branch if Z clear
00:0000297E 083900070000F102	   458:             btst.b #7,$F102       *
00:00002986 67FE            	   459:             beq.s *               * branch if Z set
                            	   460: 
                            	   461: 
                            	   462: *             EA = x(PC)  - BYTE only
00:00002988 4BFAFE9E        	   463:             lea op_BTST(pc),a5
00:0000298C 083A0000FE98    	   464:             btst.b #0,op_BTST(pc)
00:00002992 66FE            	   465:             bne.s *               * branch if Z clear
00:00002994 083A0003001A    	   466:             btst.b #3,op_BTST0(pc)     *
00:0000299A 67FE            	   467:             beq.s *               * branch if Z set
00:0000299C 083A00060074    	   468:             btst.b #6,op_BTST12(pc)    *
00:000029A2 67FE            	   469:             beq.s *               * branch if Z set
                            	   470: 
                            	   471: 
                            	   472: *             EA = n(PC,R.W)  - BYTE only
00:000029A4 307C0100        	   473:             move.l #$00000100,a0      * point to memory to address
00:000029A8 93C9            	   474:             move.l #$00000000,a1      * point to memory to address
00:000029AA 347C0001        	   475:             move.l #$00000001,a2      * point to memory to address
00:000029AE 7000            	   476:             moveq  #$00000000,d0      * point to memory to address
00:000029B0 7201            	   477:             moveq  #$00000001,d1      * point to memory to address
                            	   478: 
00:000029B2 083B000000FC    	   479: op_BTST0:   btst.b #0,op_BTST0(pc,d0.w)
00:000029B8 66FE            	   480:             bne.s *               * branch if Z clear
                            	   481: 
00:000029BA 4BFB1002        	   482:             lea op_BTST1(pc,d1.w),a5
00:000029BE 083B000110FC    	   483: op_BTST1:   btst.b #1,op_BTST1(pc,d1.w)      *
00:000029C4 67FE            	   484:             beq.s *               * branch if Z set
00:000029C6 083B000710FC    	   485: op_BTST2:   btst.b #7,op_BTST2(pc,d1.w)      *
00:000029CC 66FE            	   486:             bne.s *               * branch if Z clear
                            	   487: *             EA = n(PC,R.L)  - BYTE only
00:000029CE 083B000008FC    	   488: op_BTST3:   btst.b #0,op_BTST3(pc,d0.l)
00:000029D4 66FE            	   489:             bne.s *               * branch if Z clear
00:000029D6 083B000118FC    	   490: op_BTST4:   btst.b #1,op_BTST4(pc,d1.l)      *
00:000029DC 67FE            	   491:             beq.s *               * branch if Z set
00:000029DE 083B000718FC    	   492: op_BTST5:   btst.b #7,op_BTST5(pc,d1.l)      *
00:000029E4 66FE            	   493:             bne.s *               * branch if Z clear
                            	   494: *             EA = n(PC,A.W)  - BYTE only
00:000029E6 083B000090FC    	   495: op_BTST6    btst.b #0,op_BTST6(pc,a1.w)
00:000029EC 66FE            	   496:             bne.s *               * branch if Z clear
00:000029EE 083B0001A0FC    	   497: op_BTST7:   btst.b #1,op_BTST7(pc,a2.w)      *
00:000029F4 67FE            	   498:             beq.s *               * branch if Z set
00:000029F6 083B0007A0FC    	   499: op_BTST8:   btst.b #7,op_BTST8(pc,a2.w)      *
00:000029FC 66FE            	   500:             bne.s *               * branch if Z clear
                            	   501: *             EA = n(PC,A.L)  - BYTE only
00:000029FE 083B000098FC    	   502: op_BTST9:   btst.b #0,op_BTST9(pc,a1.l)
00:00002A04 66FE            	   503:             bne.s *               * branch if Z clear
00:00002A06 083B0001A8FC    	   504: op_BTST10:  btst.b #1,op_BTST10(pc,a2.l)      *
00:00002A0C 67FE            	   505:             beq.s *               * branch if Z set
00:00002A0E 083B0007A8FC    	   506: op_BTST11:  btst.b #7,op_BTST11(pc,a2.l)      *
00:00002A14 66FE            	   507: op_BTST12:  bne.s *               * branch if Z clear
                            	   508: 
                            	   509: 
                            	   510: 
                            	   511: * Bit Number.s Dynamic
                            	   512: 
                            	   513: *             EA = Dn  - LONG only
00:00002A16 203C80000001    	   514:             move.l #$80000001,d0      * populate test data
00:00002A1C 7A00            	   515:             move.l #0,d5              * populate bit.s number to test
00:00002A1E 7C01            	   516:             move.l #1,d6              * populate bit.s number to test
00:00002A20 7E1F            	   517:             move.l #31,d7              * populate bit.s number to test
                            	   518: 
00:00002A22 0B00            	   519:             btst.l d5,d0
00:00002A24 67FE            	   520:             beq.s *               * branch if Z set
00:00002A26 0D00            	   521:             btst.l d6,d0              *
00:00002A28 66FE            	   522:             bne.s *               * branch if Z clear
00:00002A2A 0F00            	   523:             btst.l d7,d0             *
00:00002A2C 67FE            	   524:             beq.s *               * branch if Z set
                            	   525: 
                            	   526: 
                            	   527: *             EA = (An)  - BYTE only
00:00002A2E 7A00            	   528:             move.l #0,d5              * populate bit.s number to test
00:00002A30 7C01            	   529:             move.l #1,d6              * populate bit.s number to test
00:00002A32 7E07            	   530:             move.l #7,d7              * populate bit.s number to test
00:00002A34 307C0100        	   531:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002A38 10BC0081        	   532:             move.b #$81,(a0)          * populate test data
00:00002A3C 1210            	   533:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00002A3E 0B10            	   534:             btst.b d5,(a0)
00:00002A40 67FE            	   535:             beq.s *               * branch if Z set
00:00002A42 0D10            	   536:             btst.b d6,(a0)            *
00:00002A44 66FE            	   537:             bne.s *               * branch if Z clear
00:00002A46 0F10            	   538:             btst.b d7,(a0)            *
00:00002A48 67FE            	   539:             beq.s *               * branch if Z set
                            	   540: 
                            	   541: * ---
                            	   542: 
                            	   543: 
                            	   544: *             EA = (An)+  - BYTE only
00:00002A4A 307C0100        	   545:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002A4E 10FC0001        	   546:             move.b #$01,(a0)+         * populate test data
00:00002A52 10FC00FC        	   547:             move.b #$FC,(a0)+         * populate test data
00:00002A56 10FC0080        	   548:             move.b #$80,(a0)+         * populate test data
00:00002A5A 307C0100        	   549:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002A5E 0B18            	   550:             btst.b d5,(a0)+
00:00002A60 67FE            	   551:             beq.s *               * branch if Z set
00:00002A62 0D18            	   552:             btst.b d6,(a0)+           *
00:00002A64 66FE            	   553:             bne.s *               * branch if Z clear
00:00002A66 0F18            	   554:             btst.b d7,(a0)+           *
00:00002A68 67FE            	   555:             beq.s *               * branch if Z set
                            	   556: 
                            	   557: 
                            	   558: *             EA = -(An)  - BYTE only
00:00002A6A 307C0100        	   559:             move.l #$00000100,a0      * point to memory to address
00:00002A6E 10FC0080        	   560:             move.b #$80,(a0)+         * populate test data
00:00002A72 10FC00FC        	   561:             move.b #$FC,(a0)+         * populate test data
00:00002A76 10FC0001        	   562:             move.b #$01,(a0)+         * populate test data
00:00002A7A 307C0103        	   563:             move.l #$00000103,a0      * point to memory to address
00:00002A7E 0B20            	   564:             btst.b d5,-(a0)
00:00002A80 67FE            	   565:             beq.s *               * branch if Z set
00:00002A82 0D20            	   566:             btst.b d6,-(a0)           *
00:00002A84 66FE            	   567:             bne.s *               * branch if Z clear
00:00002A86 0F20            	   568:             btst.b d7,-(a0)           *
00:00002A88 67FE            	   569:             beq.s *               * branch if Z set
                            	   570: 
                            	   571: 
                            	   572: *             EA = n(An)  - BYTE only
00:00002A8A 307C0100        	   573:             move.l #$00000100,a0      * point to memory to address
00:00002A8E 10FC0001        	   574:             move.b #$01,(a0)+         * populate test data
00:00002A92 10FC00FC        	   575:             move.b #$FC,(a0)+         * populate test data
00:00002A96 10FC0080        	   576:             move.b #$80,(a0)+         * populate test data
00:00002A9A 307C0100        	   577:             move.l #$00000100,a0      * point to memory to address
00:00002A9E 0B10            	   578:             btst.b d5,0(a0)
00:00002AA0 67FE            	   579:             beq.s *               * branch if Z set
00:00002AA2 0D280001        	   580:             btst.b d6,1(a0)           *
00:00002AA6 66FE            	   581:             bne.s *               * branch if Z clear
00:00002AA8 0F280002        	   582:             btst.b d7,2(a0)           *
00:00002AAC 67FE            	   583:             beq.s *               * branch if Z set
                            	   584: 
                            	   585: 
                            	   586: *             EA = n(An,R.W)  - BYTE only
00:00002AAE 307C0100        	   587:             move.l #$00000100,a0      * point to memory to address
00:00002AB2 93C9            	   588:             move.l #$00000000,a1      * point to memory to address
00:00002AB4 347C0001        	   589:             move.l #$00000001,a2      * point to memory to address
00:00002AB8 7000            	   590:             moveq  #$00000000,d0      * point to memory to address
00:00002ABA 7201            	   591:             moveq  #$00000001,d1      * point to memory to address
00:00002ABC 0B300000        	   592:             btst.b d5,0(a0,d0.w)
00:00002AC0 67FE            	   593:             beq.s *               * branch if Z set
00:00002AC2 0D301000        	   594:             btst.b d6,0(a0,d1.w)      *
00:00002AC6 66FE            	   595:             bne.s *               * branch if Z clear
00:00002AC8 0F301001        	   596:             btst.b d7,1(a0,d1.w)      *
00:00002ACC 67FE            	   597:             beq.s *               * branch if Z set
                            	   598: *             EA = n(An,R.L)  - BYTE only
00:00002ACE 0B300800        	   599:             btst.b d5,0(a0,d0.l)
00:00002AD2 67FE            	   600:             beq.s *               * branch if Z set
00:00002AD4 0D301800        	   601:             btst.b d6,0(a0,d1.l)      *
00:00002AD8 66FE            	   602:             bne.s *               * branch if Z clear
00:00002ADA 0F301801        	   603:             btst.b d7,1(a0,d1.l)      *
00:00002ADE 67FE            	   604:             beq.s *               * branch if Z set
                            	   605: *             EA = n(An,A.W)  - BYTE only
00:00002AE0 0B309000        	   606:             btst.b d5,0(a0,a1.w)
00:00002AE4 67FE            	   607:             beq.s *               * branch if Z set
00:00002AE6 0D30A000        	   608:             btst.b d6,0(a0,a2.w)      *
00:00002AEA 66FE            	   609:             bne.s *               * branch if Z clear
00:00002AEC 0F30A001        	   610:             btst.b d7,1(a0,a2.w)      *
00:00002AF0 67FE            	   611:             beq.s *               * branch if Z set
                            	   612: *             EA = n(An,A.L)  - BYTE only
00:00002AF2 0B309800        	   613:             btst.b d5,0(a0,a1.l)
00:00002AF6 67FE            	   614:             beq.s *               * branch if Z set
00:00002AF8 0D30A800        	   615:             btst.b d6,0(a0,a2.l)      *
00:00002AFC 66FE            	   616:             bne.s *               * branch if Z clear
00:00002AFE 0F30A801        	   617:             btst.b d7,1(a0,a2.l)      *
00:00002B02 67FE            	   618:             beq.s *               * branch if Z set
                            	   619: 
                            	   620: 
                            	   621: *             EA = x.W  - BYTE only
00:00002B04 0B380100        	   622:             btst.b d5,$0100
00:00002B08 67FE            	   623:             beq.s *               * branch if Z set
00:00002B0A 0D380101        	   624:             btst.b d6,$0101           *
00:00002B0E 66FE            	   625:             bne.s *               * branch if Z clear
00:00002B10 0F380102        	   626:             btst.b d7,$0102           *
00:00002B14 67FE            	   627:             beq.s *               * branch if Z set
                            	   628: 
                            	   629: 
                            	   630: *             EA = x.L  - BYTE only
00:00002B16 207C0000F100    	   631:             move.l #$F100,a0      * point to memory to address 0x100
00:00002B1C 10FC0001        	   632:             move.b #$01,(a0)+         * populate test data
00:00002B20 10FC00FC        	   633:             move.b #$FC,(a0)+         * populate test data
00:00002B24 10FC0080        	   634:             move.b #$80,(a0)+         * populate test data
00:00002B28 0B390000F100    	   635:             btst.b d5,$F100
00:00002B2E 67FE            	   636:             beq.s *               * branch if Z set
00:00002B30 0D390000F101    	   637:             btst.b d6,$F101       *
00:00002B36 66FE            	   638:             bne.s *               * branch if Z clear
00:00002B38 0F390000F102    	   639:             btst.b d7,$F102       *
00:00002B3E 67FE            	   640:             beq.s *               * branch if Z set
                            	   641: 
                            	   642: 
                            	   643: *             EA = x(PC)  - BYTE only
00:00002B40 7C03            	   644:             move.l #3,d6              * populate bit.s number to test
00:00002B42 7E06            	   645:             move.l #6,d7              * populate bit.s number to test
00:00002B44 4BFAFCE2        	   646:             lea op_BTST(pc),a5
00:00002B48 0B3AFCDE        	   647:             btst.b d5,op_BTST(pc)
00:00002B4C 66FE            	   648:             bne.s *               * branch if Z clear
00:00002B4E 0D3AFE62        	   649:             btst.b d6,op_BTST0(pc)     *
00:00002B52 67FE            	   650:             beq.s *               * branch if Z set
00:00002B54 0F3AFEBE        	   651:             btst.b d7,op_BTST12(pc)    *
00:00002B58 67FE            	   652:             beq.s *               * branch if Z set
                            	   653: 
                            	   654: 
                            	   655: *             EA = n(PC,R.W)  - BYTE only
00:00002B5A 307C0100        	   656:             move.l #$00000100,a0      * point to memory to address
00:00002B5E 93C9            	   657:             move.l #$00000000,a1      * point to memory to address
00:00002B60 347C0001        	   658:             move.l #$00000001,a2      * point to memory to address
00:00002B64 7000            	   659:             moveq  #$00000000,d0      * point to memory to address
00:00002B66 7201            	   660:             moveq  #$00000001,d1      * point to memory to address
00:00002B68 7C01            	   661:             move.l #1,d6              * populate bit.s number to test
00:00002B6A 7E07            	   662:             move.l #7,d7              * populate bit.s number to test
                            	   663: 
00:00002B6C 0B3B00FE        	   664: op_BTST20:  btst.b d5,op_BTST20(pc,d0.w)
00:00002B70 67FE            	   665:             beq.s *               * branch if Z set
00:00002B72 4BFB1002        	   666:             lea op_BTST21(pc,d1.w),a5
00:00002B76 0D3B10FE        	   667: op_BTST21:  btst.b d6,op_BTST21(pc,d1.w)      *
00:00002B7A 67FE            	   668:             beq.s *               * branch if Z set
00:00002B7C 0F3B10FE        	   669: op_BTST22:  btst.b d7,op_BTST22(pc,d1.w)      *
00:00002B80 66FE            	   670:             bne.s *               * branch if Z clear
                            	   671: *             EA = n(PC,R.L)  - BYTE only
00:00002B82 0B3B08FE        	   672: op_BTST23:  btst.b d5,op_BTST23(pc,d0.l)
00:00002B86 67FE            	   673:             beq.s *               * branch if Z set
00:00002B88 0D3B18FE        	   674: op_BTST24: btst.b d6,op_BTST24(pc,d1.l)      *
00:00002B8C 67FE            	   675:             beq.s *               * branch if Z set
00:00002B8E 0F3B18FE        	   676: op_BTST25  btst.b d7,op_BTST25(pc,d1.l)      *
00:00002B92 66FE            	   677:             bne.s *               * branch if Z clear
                            	   678: *             EA = n(PC,A.W)  - BYTE only
00:00002B94 0B3B90FE        	   679: op_BTST26   btst.b d5,op_BTST26(pc,a1.w)
00:00002B98 67FE            	   680:             beq.s *               * branch if Z set
00:00002B9A 0D3BA0FE        	   681: op_BTST27:  btst.b d6,op_BTST27(pc,a2.w)      *
00:00002B9E 67FE            	   682:             beq.s *               * branch if Z set
00:00002BA0 0F3BA0FE        	   683: op_BTST28:  btst.b d7,op_BTST28(pc,a2.w)      *
00:00002BA4 66FE            	   684:             bne.s *               * branch if Z clear
                            	   685: *             EA = n(PC,A.L)  - BYTE only
00:00002BA6 0B3B98FE        	   686: op_BTST29:  btst.b d5,op_BTST29(pc,a1.l)
00:00002BAA 67FE            	   687:             beq.s *               * branch if Z set
00:00002BAC 0D3BA8FE        	   688: op_BTST30:  btst.b d6,op_BTST30(pc,a2.l)      *
00:00002BB0 67FE            	   689:             beq.s *               * branch if Z set
00:00002BB2 0F3BA8FE        	   690: op_BTST31:  btst.b d7,op_BTST31(pc,a2.l)      *
00:00002BB6 66FE            	   691: op_BTST32:  bne.s *               * branch if Z clear
                            	   692: 
                            	   693: *             EA = #x  - BYTE only
                            	   694: 
00:00002BB8 7A00            	   695:             move.l #0,d5              * populate bit.s number to test
00:00002BBA 7C03            	   696:             move.l #3,d6              * populate bit.s number to test
00:00002BBC 7E07            	   697:             move.l #7,d7              * populate bit.s number to test
                            	   698: 
00:00002BBE 0B3C0088        	   699:             btst.b d5,#$88
00:00002BC2 66FE            	   700:             bne.s *               * branch if Z clear
00:00002BC4 0D3C0088        	   701:             btst.b d6,#$88
00:00002BC8 67FE            	   702:             beq.s *               * branch if Z set
00:00002BCA 0F3C0088        	   703:             btst.b d7,#$88
00:00002BCE 67FE            	   704:             beq.s *               * branch if Z set
                            	   705: 
                            	   706: 
00:00002BD0 4E75            	   707:     rts
                            	   708: 
                            	   709: *-----------------------------------------------------------
                            	   710: *-----------------------------------------------------------
                            	   711: * OPCODE : BCHG
                            	   712: *-----------------------------------------------------------
                            	   713: *-----------------------------------------------------------
                            	   714: op_BCHG:
                            	   715: 
                            	   716: 
                            	   717: *  Bit Number.s Static
                            	   718: 
                            	   719: *             EA = Dn  - LONG only
00:00002BD2 203C80000001    	   720:             move.l #$80000001,d0      * populate test data
00:00002BD8 08400000        	   721:             bchg.l #0,d0
00:00002BDC 67FE            	   722:             beq.s *               * branch if Z set
00:00002BDE 08400001        	   723:             bchg.l #1,d0              *
00:00002BE2 66FE            	   724:             bne.s *               * branch if Z clear
00:00002BE4 0840001F        	   725:             bchg.l #31,d0             *
00:00002BE8 67FE            	   726:             beq.s *               * branch if Z set
00:00002BEA 0C8000000002    	   727:             cmpi.l #$00000002,d0
00:00002BF0 66FE            	   728:             bne.s *               * branch if Z clear
                            	   729: 
                            	   730: 
                            	   731: *             EA = (An)  - BYTE only
00:00002BF2 307C0100        	   732:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002BF6 10BC0081        	   733:             move.b #$81,(a0)          * populate test data
00:00002BFA 1210            	   734:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00002BFC 08500000        	   735:             bchg.b #0,(a0)
00:00002C00 67FE            	   736:             beq.s *               * branch if Z set
00:00002C02 08500001        	   737:             bchg.b #1,(a0)            *
00:00002C06 66FE            	   738:             bne.s *               * branch if Z clear
00:00002C08 08500007        	   739:             bchg.b #7,(a0)            *
00:00002C0C 67FE            	   740:             beq.s *               * branch if Z set
00:00002C0E 0C100002        	   741:             cmpi.b #$02,(a0)
00:00002C12 66FE            	   742:             bne.s *               * branch if Z clear
                            	   743: 
                            	   744: *             EA = (An)+  - BYTE only
00:00002C14 307C0100        	   745:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002C18 10FC0001        	   746:             move.b #$01,(a0)+         * populate test data
00:00002C1C 10FC00FC        	   747:             move.b #$FC,(a0)+         * populate test data
00:00002C20 10FC0080        	   748:             move.b #$80,(a0)+         * populate test data
00:00002C24 307C0100        	   749:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002C28 08580000        	   750:             bchg.b #0,(a0)+
00:00002C2C 67FE            	   751:             beq.s *               * branch if Z set
00:00002C2E 08580001        	   752:             bchg.b #1,(a0)+           *
00:00002C32 66FE            	   753:             bne.s *               * branch if Z clear
00:00002C34 08580007        	   754:             bchg.b #7,(a0)+           *
00:00002C38 67FE            	   755:             beq.s *               * branch if Z set
00:00002C3A 307C0100        	   756:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002C3E 4A18            	   757:             cmpi.b #$00,(a0)+
00:00002C40 66FE            	   758:             bne.s *               * branch if Z clear
00:00002C42 0C1800FE        	   759:             cmpi.b #$FE,(a0)+
00:00002C46 66FE            	   760:             bne.s *               * branch if Z clear
00:00002C48 4A18            	   761:             cmpi.b #$00,(a0)+
00:00002C4A 66FE            	   762:             bne.s *               * branch if Z clear
                            	   763: 
                            	   764: *             EA = -(An)  - BYTE only
00:00002C4C 307C0100        	   765:             move.l #$00000100,a0      * point to memory to address
00:00002C50 10FC0080        	   766:             move.b #$80,(a0)+         * populate test data
00:00002C54 10FC00FC        	   767:             move.b #$FC,(a0)+         * populate test data
00:00002C58 10FC0001        	   768:             move.b #$01,(a0)+         * populate test data
00:00002C5C 307C0103        	   769:             move.l #$00000103,a0      * point to memory to address
00:00002C60 08600000        	   770:             bchg.b #0,-(a0)
00:00002C64 67FE            	   771:             beq.s *               * branch if Z set
00:00002C66 08600001        	   772:             bchg.b #1,-(a0)           *
00:00002C6A 66FE            	   773:             bne.s *               * branch if Z clear
00:00002C6C 08600007        	   774:             bchg.b #7,-(a0)           *
00:00002C70 67FE            	   775:             beq.s *               * branch if Z set
00:00002C72 307C0103        	   776:             move.l #$00000103,a0      * point to memory to address 0x100
00:00002C76 4A20            	   777:             cmpi.b #$00,-(a0)
00:00002C78 66FE            	   778:             bne.s *               * branch if Z clear
00:00002C7A 0C2000FE        	   779:             cmpi.b #$FE,-(a0)
00:00002C7E 66FE            	   780:             bne.s *               * branch if Z clear
00:00002C80 4A20            	   781:             cmpi.b #$00,-(a0)
00:00002C82 66FE            	   782:             bne.s *               * branch if Z clear
                            	   783: 
                            	   784: 
                            	   785: *             EA = n(An)  - BYTE only
00:00002C84 307C0100        	   786:             move.l #$00000100,a0      * point to memory to address
00:00002C88 10FC0001        	   787:             move.b #$01,(a0)+         * populate test data
00:00002C8C 10FC00FC        	   788:             move.b #$FC,(a0)+         * populate test data
00:00002C90 10FC0080        	   789:             move.b #$80,(a0)+         * populate test data
00:00002C94 307C0100        	   790:             move.l #$00000100,a0      * point to memory to address
00:00002C98 08500000        	   791:             bchg.b #0,0(a0)
00:00002C9C 67FE            	   792:             beq.s *               * branch if Z set
00:00002C9E 086800010001    	   793:             bchg.b #1,1(a0)           *
00:00002CA4 66FE            	   794:             bne.s *               * branch if Z clear
00:00002CA6 086800070002    	   795:             bchg.b #7,2(a0)           *
00:00002CAC 67FE            	   796:             beq.s *               * branch if Z set
00:00002CAE 307C0100        	   797:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002CB2 4A18            	   798:             cmpi.b #$00,(a0)+
00:00002CB4 66FE            	   799:             bne.s *               * branch if Z clear
00:00002CB6 0C1800FE        	   800:             cmpi.b #$FE,(a0)+
00:00002CBA 66FE            	   801:             bne.s *               * branch if Z clear
00:00002CBC 4A18            	   802:             cmpi.b #$00,(a0)+
00:00002CBE 66FE            	   803:             bne.s *               * branch if Z clear
                            	   804: 
                            	   805: 
                            	   806: *             EA = n(An,D.W)  - BYTE only
00:00002CC0 307C0100        	   807:             move.l #$00000100,a0      * point to memory to address
00:00002CC4 93C9            	   808:             move.l #$00000000,a1      * point to memory to address
00:00002CC6 347C0001        	   809:             move.l #$00000001,a2      * point to memory to address
00:00002CCA 7000            	   810:             moveq  #$00000000,d0      * point to memory to address
00:00002CCC 7201            	   811:             moveq  #$00000001,d1      * point to memory to address
00:00002CCE 087000000000    	   812:             bchg.b #0,0(a0,d0.w)
00:00002CD4 66FE            	   813:             bne.s *               * branch if Z clear
00:00002CD6 087000011000    	   814:             bchg.b #1,0(a0,d1.w)      *
00:00002CDC 67FE            	   815:             beq.s *               * branch if Z set
00:00002CDE 087000071001    	   816:             bchg.b #7,1(a0,d1.w)      *
00:00002CE4 66FE            	   817:             bne.s *               * branch if Z clear
                            	   818: *             EA = n(An,D.L)  - BYTE only
00:00002CE6 087000000800    	   819:             bchg.b #0,0(a0,d0.l)
00:00002CEC 67FE            	   820:             beq.s *               * branch if Z set
00:00002CEE 087000011800    	   821:             bchg.b #1,0(a0,d1.l)      *
00:00002CF4 66FE            	   822:             bne.s *               * branch if Z clear
00:00002CF6 087000071801    	   823:             bchg.b #7,1(a0,d1.l)      *
00:00002CFC 67FE            	   824:             beq.s *               * branch if Z set
                            	   825: *             EA = n(An,A.W)  - BYTE only
00:00002CFE 087000009000    	   826:             bchg.b #0,0(a0,a1.w)
00:00002D04 66FE            	   827:             bne.s *               * branch if Z clear
00:00002D06 08700001A000    	   828:             bchg.b #1,0(a0,a2.w)      *
00:00002D0C 67FE            	   829:             beq.s *               * branch if Z set
00:00002D0E 08700007A001    	   830:             bchg.b #7,1(a0,a2.w)      *
00:00002D14 66FE            	   831:             bne.s *               * branch if Z clear
                            	   832: *             EA = n(An,A.L)  - BYTE only
00:00002D16 087000009800    	   833:             bchg.b #0,0(a0,a1.l)
00:00002D1C 67FE            	   834:             beq.s *               * branch if Z set
00:00002D1E 08700001A800    	   835:             bchg.b #1,0(a0,a2.l)      *
00:00002D24 66FE            	   836:             bne.s *               * branch if Z clear
00:00002D26 08700007A801    	   837:             bchg.b #7,1(a0,a2.l)      *
00:00002D2C 67FE            	   838:             beq.s *               * branch if Z set
00:00002D2E 307C0100        	   839:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002D32 4A18            	   840:             cmpi.b #$00,(a0)+
00:00002D34 66FE            	   841:             bne.s *               * branch if Z clear
00:00002D36 0C1800FE        	   842:             cmpi.b #$FE,(a0)+
00:00002D3A 66FE            	   843:             bne.s *               * branch if Z clear
00:00002D3C 4A18            	   844:             cmpi.b #$00,(a0)+
00:00002D3E 66FE            	   845:             bne.s *               * branch if Z clear
                            	   846: 
                            	   847: 
                            	   848: *             EA = x.W  - BYTE only
00:00002D40 087800000100    	   849:             bchg.b #0,$0100
00:00002D46 66FE            	   850:             bne.s *               * branch if Z clear
00:00002D48 087800010101    	   851:             bchg.b #1,$0101           *
00:00002D4E 67FE            	   852:             beq.s *               * branch if Z set
00:00002D50 087800070102    	   853:             bchg.b #7,$0102           *
00:00002D56 66FE            	   854:             bne.s *               * branch if Z clear
00:00002D58 307C0100        	   855:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002D5C 0C180001        	   856:             cmpi.b #$01,(a0)+
00:00002D60 66FE            	   857:             bne.s *               * branch if Z clear
00:00002D62 0C1800FC        	   858:             cmpi.b #$FC,(a0)+
00:00002D66 66FE            	   859:             bne.s *               * branch if Z clear
00:00002D68 0C180080        	   860:             cmpi.b #$80,(a0)+
00:00002D6C 66FE            	   861:             bne.s *               * branch if Z clear
                            	   862: 
                            	   863: *             EA = x.L  - BYTE only
00:00002D6E 207C0000F100    	   864:             move.l #$F100,a0      * point to memory to address 0x100
00:00002D74 10FC0001        	   865:             move.b #$01,(a0)+         * populate test data
00:00002D78 10FC00FC        	   866:             move.b #$FC,(a0)+         * populate test data
00:00002D7C 10FC0080        	   867:             move.b #$80,(a0)+         * populate test data
00:00002D80 087900000000F100	   868:             bchg.b #0,$F100
00:00002D88 67FE            	   869:             beq.s *               * branch if Z set
00:00002D8A 087900010000F101	   870:             bchg.b #1,$F101       *
00:00002D92 66FE            	   871:             bne.s *               * branch if Z clear
00:00002D94 087900070000F102	   872:             bchg.b #7,$F102       *
00:00002D9C 67FE            	   873:             beq.s *               * branch if Z set
00:00002D9E 307C0100        	   874:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002DA2 0C180001        	   875:             cmpi.b #$01,(a0)+
00:00002DA6 66FE            	   876:             bne.s *               * branch if Z clear
00:00002DA8 0C1800FC        	   877:             cmpi.b #$FC,(a0)+
00:00002DAC 66FE            	   878:             bne.s *               * branch if Z clear
00:00002DAE 0C180080        	   879:             cmpi.b #$80,(a0)+
00:00002DB2 66FE            	   880:             bne.s *               * branch if Z clear
                            	   881: 
                            	   882: 
                            	   883: * Bit Number.s Dynamic
                            	   884: 
                            	   885: *             EA = Dn  - LONG only
00:00002DB4 203C80000001    	   886:             move.l #$80000001,d0      * populate test data
00:00002DBA 7A00            	   887:             move.l #0,d5              * populate bit.s number to test
00:00002DBC 7C01            	   888:             move.l #1,d6              * populate bit.s number to test
00:00002DBE 7E1F            	   889:             move.l #31,d7              * populate bit.s number to test
                            	   890: 
00:00002DC0 0B40            	   891:             bchg.l d5,d0
00:00002DC2 67FE            	   892:             beq.s *               * branch if Z set
00:00002DC4 0D40            	   893:             bchg.l d6,d0              *
00:00002DC6 66FE            	   894:             bne.s *               * branch if Z clear
00:00002DC8 0F40            	   895:             bchg.l d7,d0             *
00:00002DCA 67FE            	   896:             beq.s *               * branch if Z set
00:00002DCC 0C8000000002    	   897:             cmpi.l #$00000002,d0
00:00002DD2 66FE            	   898:             bne.s *               * branch if Z clear
                            	   899: 
                            	   900: 
                            	   901: *             EA = (An)  - BYTE only
00:00002DD4 7A00            	   902:             move.l #0,d5              * populate bit.s number to test
00:00002DD6 7C01            	   903:             move.l #1,d6              * populate bit.s number to test
00:00002DD8 7E07            	   904:             move.l #7,d7              * populate bit.s number to test
00:00002DDA 307C0100        	   905:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002DDE 10BC0081        	   906:             move.b #$81,(a0)          * populate test data
00:00002DE2 1210            	   907:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00002DE4 0B50            	   908:             bchg.b d5,(a0)
00:00002DE6 67FE            	   909:             beq.s *               * branch if Z set
00:00002DE8 0D50            	   910:             bchg.b d6,(a0)            *
00:00002DEA 66FE            	   911:             bne.s *               * branch if Z clear
00:00002DEC 0F50            	   912:             bchg.b d7,(a0)            *
00:00002DEE 67FE            	   913:             beq.s *               * branch if Z set
00:00002DF0 0C100002        	   914:             cmpi.b #$02,(a0)
00:00002DF4 66FE            	   915:             bne.s *               * branch if Z clear
                            	   916: 
                            	   917: 
                            	   918: *             EA = (An)+  - BYTE only
00:00002DF6 307C0100        	   919:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002DFA 10FC0001        	   920:             move.b #$01,(a0)+         * populate test data
00:00002DFE 10FC00FC        	   921:             move.b #$FC,(a0)+         * populate test data
00:00002E02 10FC0080        	   922:             move.b #$80,(a0)+         * populate test data
00:00002E06 307C0100        	   923:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002E0A 0B58            	   924:             bchg.b d5,(a0)+
00:00002E0C 67FE            	   925:             beq.s *               * branch if Z set
00:00002E0E 0D58            	   926:             bchg.b d6,(a0)+           *
00:00002E10 66FE            	   927:             bne.s *               * branch if Z clear
00:00002E12 0F58            	   928:             bchg.b d7,(a0)+           *
00:00002E14 67FE            	   929:             beq.s *               * branch if Z set
00:00002E16 307C0100        	   930:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002E1A 4A18            	   931:             cmpi.b #$00,(a0)+
00:00002E1C 66FE            	   932:             bne.s *               * branch if Z clear
00:00002E1E 0C1800FE        	   933:             cmpi.b #$FE,(a0)+
00:00002E22 66FE            	   934:             bne.s *               * branch if Z clear
00:00002E24 4A18            	   935:             cmpi.b #$00,(a0)+
00:00002E26 66FE            	   936:             bne.s *               * branch if Z clear
                            	   937: 
                            	   938: *             EA = -(An)  - BYTE only
00:00002E28 307C0100        	   939:             move.l #$00000100,a0      * point to memory to address
00:00002E2C 10FC0080        	   940:             move.b #$80,(a0)+         * populate test data
00:00002E30 10FC00FC        	   941:             move.b #$FC,(a0)+         * populate test data
00:00002E34 10FC0001        	   942:             move.b #$01,(a0)+         * populate test data
00:00002E38 307C0103        	   943:             move.l #$00000103,a0      * point to memory to address
00:00002E3C 0B60            	   944:             bchg.b d5,-(a0)
00:00002E3E 67FE            	   945:             beq.s *               * branch if Z set
00:00002E40 0D60            	   946:             bchg.b d6,-(a0)           *
00:00002E42 66FE            	   947:             bne.s *               * branch if Z clear
00:00002E44 0F60            	   948:             bchg.b d7,-(a0)           *
00:00002E46 67FE            	   949:             beq.s *               * branch if Z set
00:00002E48 307C0103        	   950:             move.l #$00000103,a0      * point to memory to address 0x100
00:00002E4C 4A20            	   951:             cmpi.b #$00,-(a0)
00:00002E4E 66FE            	   952:             bne.s *               * branch if Z clear
00:00002E50 0C2000FE        	   953:             cmpi.b #$FE,-(a0)
00:00002E54 66FE            	   954:             bne.s *               * branch if Z clear
00:00002E56 4A20            	   955:             cmpi.b #$00,-(a0)
00:00002E58 66FE            	   956:             bne.s *               * branch if Z clear
                            	   957: 
                            	   958: *             EA = n(An)  - BYTE only
00:00002E5A 307C0100        	   959:             move.l #$00000100,a0      * point to memory to address
00:00002E5E 10FC0001        	   960:             move.b #$01,(a0)+         * populate test data
00:00002E62 10FC00FC        	   961:             move.b #$FC,(a0)+         * populate test data
00:00002E66 10FC0080        	   962:             move.b #$80,(a0)+         * populate test data
00:00002E6A 307C0100        	   963:             move.l #$00000100,a0      * point to memory to address
00:00002E6E 0B50            	   964:             bchg.b d5,0(a0)
00:00002E70 67FE            	   965:             beq.s *               * branch if Z set
00:00002E72 0D680001        	   966:             bchg.b d6,1(a0)           *
00:00002E76 66FE            	   967:             bne.s *               * branch if Z clear
00:00002E78 0F680002        	   968:             bchg.b d7,2(a0)           *
00:00002E7C 67FE            	   969:             beq.s *               * branch if Z set
00:00002E7E 307C0100        	   970:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002E82 4A18            	   971:             cmpi.b #$00,(a0)+
00:00002E84 66FE            	   972:             bne.s *               * branch if Z clear
00:00002E86 0C1800FE        	   973:             cmpi.b #$FE,(a0)+
00:00002E8A 66FE            	   974:             bne.s *               * branch if Z clear
00:00002E8C 4A18            	   975:             cmpi.b #$00,(a0)+
00:00002E8E 66FE            	   976:             bne.s *               * branch if Z clear
                            	   977: 
                            	   978: *             EA = n(An,R.W)  - BYTE only
00:00002E90 307C0100        	   979:             move.l #$00000100,a0      * point to memory to address
00:00002E94 93C9            	   980:             move.l #$00000000,a1      * point to memory to address
00:00002E96 347C0001        	   981:             move.l #$00000001,a2      * point to memory to address
00:00002E9A 7000            	   982:             moveq  #$00000000,d0      * point to memory to address
00:00002E9C 7201            	   983:             moveq  #$00000001,d1      * point to memory to address
00:00002E9E 0B700000        	   984:             bchg.b d5,0(a0,d0.w)
00:00002EA2 66FE            	   985:             bne.s *               * branch if Z clear
00:00002EA4 0D701000        	   986:             bchg.b d6,0(a0,d1.w)      *
00:00002EA8 67FE            	   987:             beq.s *               * branch if Z set
00:00002EAA 0F701001        	   988:             bchg.b d7,1(a0,d1.w)      *
00:00002EAE 66FE            	   989:             bne.s *               * branch if Z clear
                            	   990: *             EA = n(An,R.L)  - BYTE only
00:00002EB0 0B700800        	   991:             bchg.b d5,0(a0,d0.l)
00:00002EB4 67FE            	   992:             beq.s *               * branch if Z set
00:00002EB6 0D701800        	   993:             bchg.b d6,0(a0,d1.l)      *
00:00002EBA 66FE            	   994:             bne.s *               * branch if Z clear
00:00002EBC 0F701801        	   995:             bchg.b d7,1(a0,d1.l)      *
00:00002EC0 67FE            	   996:             beq.s *               * branch if Z set
                            	   997: *             EA = n(An,A.W)  - BYTE only
00:00002EC2 0B709000        	   998:             bchg.b d5,0(a0,a1.w)
00:00002EC6 66FE            	   999:             bne.s *               * branch if Z clear
00:00002EC8 0D70A000        	  1000:             bchg.b d6,0(a0,a2.w)      *
00:00002ECC 67FE            	  1001:             beq.s *               * branch if Z set
00:00002ECE 0F70A001        	  1002:             bchg.b d7,1(a0,a2.w)      *
00:00002ED2 66FE            	  1003:             bne.s *               * branch if Z clear
                            	  1004: *             EA = n(An,A.L)  - BYTE only
00:00002ED4 0B709800        	  1005:             bchg.b d5,0(a0,a1.l)
00:00002ED8 67FE            	  1006:             beq.s *               * branch if Z set
00:00002EDA 0D70A800        	  1007:             bchg.b d6,0(a0,a2.l)      *
00:00002EDE 66FE            	  1008:             bne.s *               * branch if Z clear
00:00002EE0 0F70A801        	  1009:             bchg.b d7,1(a0,a2.l)      *
00:00002EE4 67FE            	  1010:             beq.s *               * branch if Z set
00:00002EE6 4A18            	  1011:             cmpi.b #$00,(a0)+
00:00002EE8 66FE            	  1012:             bne.s *               * branch if Z clear
                            	  1013: 
                            	  1014: *             EA = x.W  - BYTE only
00:00002EEA 0B780100        	  1015:             bchg.b d5,$0100
00:00002EEE 66FE            	  1016:             bne.s *               * branch if Z clear
00:00002EF0 0D780101        	  1017:             bchg.b d6,$0101           *
00:00002EF4 67FE            	  1018:             beq.s *               * branch if Z set
00:00002EF6 0F780102        	  1019:             bchg.b d7,$0102           *
00:00002EFA 66FE            	  1020:             bne.s *               * branch if Z clear
00:00002EFC 0C1800FC        	  1021:             cmpi.b #$FC,(a0)+
00:00002F00 66FE            	  1022:             bne.s *               * branch if Z clear
                            	  1023: 
                            	  1024: *             EA = x.L  - BYTE only
00:00002F02 207C0000F100    	  1025:             move.l #$F100,a0      * point to memory to address 0x100
00:00002F08 10FC0001        	  1026:             move.b #$01,(a0)+         * populate test data
00:00002F0C 10FC00FC        	  1027:             move.b #$FC,(a0)+         * populate test data
00:00002F10 10FC0080        	  1028:             move.b #$80,(a0)+         * populate test data
00:00002F14 0B790000F100    	  1029:             bchg.b d5,$F100
00:00002F1A 67FE            	  1030:             beq.s *               * branch if Z set
00:00002F1C 0D790000F101    	  1031:             bchg.b d6,$F101       *
00:00002F22 66FE            	  1032:             bne.s *               * branch if Z clear
00:00002F24 0F790000F102    	  1033:             bchg.b d7,$F102       *
00:00002F2A 67FE            	  1034:             beq.s *               * branch if Z set
00:00002F2C 207C0000F101    	  1035:             move.l #$F101,a0      * point to memory to address 0x100
00:00002F32 0C1000FE        	  1036:             cmpi.b #$FE,(a0)
00:00002F36 66FE            	  1037:             bne.s *               * branch if Z clear
                            	  1038: 
                            	  1039: 
00:00002F38 4E75            	  1040:     rts
                            	  1041: 
                            	  1042: *-----------------------------------------------------------
                            	  1043: *-----------------------------------------------------------
                            	  1044: * OPCODE : BCLR
                            	  1045: *-----------------------------------------------------------
                            	  1046: *-----------------------------------------------------------
                            	  1047: op_BCLR:
                            	  1048: 
                            	  1049: 
                            	  1050: *  Bit Number.s Static
                            	  1051: 
                            	  1052: *             EA = Dn  - LONG only
00:00002F3A 203CFF0000FF    	  1053:             move.l #$FF0000FF,d0      * populate test data
00:00002F40 08800000        	  1054:             bclr.l #0,d0
00:00002F44 67FE            	  1055:             beq.s *               * branch if Z set
00:00002F46 08800001        	  1056:             bclr.l #1,d0              *
00:00002F4A 67FE            	  1057:             beq.s *               * branch if Z set
00:00002F4C 0880000F        	  1058:             bclr.l #15,d0             *
00:00002F50 66FE            	  1059:             bne.s *               * branch if Z clear
00:00002F52 0880001F        	  1060:             bclr.l #31,d0             *
00:00002F56 67FE            	  1061:             beq.s *               * branch if Z set
00:00002F58 0C807F0000FC    	  1062:             cmpi.l #$7F0000FC,d0
00:00002F5E 66FE            	  1063:             bne.s *               * branch if Z clear
                            	  1064: 
                            	  1065: 
                            	  1066: *             EA = (An)  - BYTE only
00:00002F60 307C0100        	  1067:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002F64 10BC000F        	  1068:             move.b #$0F,(a0)          * populate test data
00:00002F68 08900000        	  1069:             bclr.b #0,(a0)
00:00002F6C 67FE            	  1070:             beq.s *               * branch if Z set
00:00002F6E 08900007        	  1071:             bclr.b #7,(a0)            *
00:00002F72 66FE            	  1072:             bne.s *               * branch if Z clear
00:00002F74 0C10000E        	  1073:             cmpi.b #$0E,(a0)
00:00002F78 66FE            	  1074:             bne.s *               * branch if Z clear
                            	  1075: 
                            	  1076: *             EA = (An)+  - BYTE only
00:00002F7A 307C0100        	  1077:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002F7E 10FC0001        	  1078:             move.b #$01,(a0)+         * populate test data
00:00002F82 4218            	  1079:             move.b #$00,(a0)+         * populate test data
00:00002F84 307C0100        	  1080:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002F88 08980000        	  1081:             bclr.b #0,(a0)+
00:00002F8C 67FE            	  1082:             beq.s *               * branch if Z set
00:00002F8E 08980001        	  1083:             bclr.b #1,(a0)+           *
00:00002F92 66FE            	  1084:             bne.s *               * branch if Z clear
00:00002F94 307C0100        	  1085:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002F98 4A18            	  1086:             cmpi.b #$00,(a0)+
00:00002F9A 66FE            	  1087:             bne.s *               * branch if Z clear
00:00002F9C 4A18            	  1088:             cmpi.b #$00,(a0)+
00:00002F9E 66FE            	  1089:             bne.s *               * branch if Z clear
                            	  1090: 
                            	  1091: 
                            	  1092: *             EA = -(An)  - BYTE only
00:00002FA0 307C0100        	  1093:             move.l #$00000100,a0      * point to memory to address
00:00002FA4 10FC0001        	  1094:             move.b #$01,(a0)+         * populate test data
00:00002FA8 10FC0080        	  1095:             move.b #$80,(a0)+         * populate test data
00:00002FAC 08A00007        	  1096:             bclr.b #7,-(a0)
00:00002FB0 67FE            	  1097:             beq.s *               * branch if Z set
00:00002FB2 08A00000        	  1098:             bclr.b #0,-(a0)           *
00:00002FB6 67FE            	  1099:             beq.s *               * branch if Z set
00:00002FB8 307C0102        	  1100:             move.l #$00000102,a0      * point to memory to address 0x100
00:00002FBC 4A20            	  1101:             cmpi.b #$00,-(a0)
00:00002FBE 66FE            	  1102:             bne.s *               * branch if Z clear
00:00002FC0 4A20            	  1103:             cmpi.b #$00,-(a0)
00:00002FC2 66FE            	  1104:             bne.s *               * branch if Z clear
                            	  1105: 
                            	  1106: 
                            	  1107: *             EA = n(An)  - BYTE only
00:00002FC4 307C0100        	  1108:             move.l #$00000100,a0      * point to memory to address
00:00002FC8 10FC00FF        	  1109:             move.b #$FF,(a0)+         * populate test data
00:00002FCC 10FC00FF        	  1110:             move.b #$FF,(a0)+         * populate test data
00:00002FD0 307C0100        	  1111:             move.l #$00000100,a0      * point to memory to address
00:00002FD4 08900000        	  1112:             bclr.b #0,0(a0)
00:00002FD8 67FE            	  1113:             beq.s *               * branch if Z set
00:00002FDA 08A800040001    	  1114:             bclr.b #4,1(a0)           *
00:00002FE0 67FE            	  1115:             beq.s *               * branch if Z set
00:00002FE2 307C0100        	  1116:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002FE6 0C1800FE        	  1117:             cmpi.b #$FE,(a0)+
00:00002FEA 66FE            	  1118:             bne.s *               * branch if Z clear
00:00002FEC 0C1800EF        	  1119:             cmpi.b #$EF,(a0)+
00:00002FF0 66FE            	  1120:             bne.s *               * branch if Z clear
                            	  1121: 
                            	  1122: 
                            	  1123: *             EA = n(An,D.W)  - BYTE only
00:00002FF2 307C0100        	  1124:             move.l #$00000100,a0      * point to memory to address
00:00002FF6 93C9            	  1125:             move.l #$00000000,a1      * point to memory to address
00:00002FF8 347C0001        	  1126:             move.l #$00000001,a2      * point to memory to address
00:00002FFC 7000            	  1127:             moveq  #$00000000,d0      * point to memory to address
00:00002FFE 7201            	  1128:             moveq  #$00000001,d1      * point to memory to address
00:00003000 10FC00FF        	  1129:             move.b #$FF,(a0)+         * populate test data
00:00003004 10FC00FF        	  1130:             move.b #$FF,(a0)+         * populate test data
00:00003008 307C0100        	  1131:             move.l #$00000100,a0      * point to memory to address
00:0000300C 08B000000000    	  1132:             bclr.b #0,0(a0,d0.w)
00:00003012 67FE            	  1133:             beq.s *               * branch if Z set
00:00003014 08B000011000    	  1134:             bclr.b #1,0(a0,d1.w)      *
00:0000301A 67FE            	  1135:             beq.s *               * branch if Z set
00:0000301C 08B000021001    	  1136:             bclr.b #2,1(a0,d1.w)      *
00:00003022 66FE            	  1137:             bne.s *               * branch if Z clear
                            	  1138: *             EA = n(An,D.L)  - BYTE only
00:00003024 08B000030800    	  1139:             bclr.b #3,0(a0,d0.l)
00:0000302A 67FE            	  1140:             beq.s *               * branch if Z set
00:0000302C 08B000041800    	  1141:             bclr.b #4,0(a0,d1.l)      *
00:00003032 67FE            	  1142:             beq.s *               * branch if Z set
00:00003034 08B000051801    	  1143:             bclr.b #5,1(a0,d1.l)      *
00:0000303A 66FE            	  1144:             bne.s *               * branch if Z clear
                            	  1145: *             EA = n(An,A.W)  - BYTE only
00:0000303C 08B000069000    	  1146:             bclr.b #6,0(a0,a1.w)
00:00003042 67FE            	  1147:             beq.s *               * branch if Z set
00:00003044 08B00001A000    	  1148:             bclr.b #1,0(a0,a2.w)      *
00:0000304A 66FE            	  1149:             bne.s *               * branch if Z clear
00:0000304C 08B00007A001    	  1150:             bclr.b #7,1(a0,a2.w)      *
00:00003052 67FE            	  1151:             beq.s *               * branch if Z set
                            	  1152: *             EA = n(An,A.L)  - BYTE only
00:00003054 08B000009800    	  1153:             bclr.b #0,0(a0,a1.l)
00:0000305A 66FE            	  1154:             bne.s *               * branch if Z clear
00:0000305C 08B00000A800    	  1155:             bclr.b #0,0(a0,a2.l)      *
00:00003062 67FE            	  1156:             beq.s *               * branch if Z set
00:00003064 08B00001A801    	  1157:             bclr.b #1,1(a0,a2.l)      *
00:0000306A 66FE            	  1158:             bne.s *               * branch if Z clear
00:0000306C 307C0100        	  1159:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003070 0C1800B6        	  1160:             cmpi.b #$B6,(a0)+
00:00003074 66FE            	  1161:             bne.s *               * branch if Z clear
00:00003076 0C1800EC        	  1162:             cmpi.b #$EC,(a0)+
00:0000307A 66FE            	  1163:             bne.s *               * branch if Z clear
00:0000307C 0C180059        	  1164:             cmpi.b #$59,(a0)+
00:00003080 67FE            	  1165:             beq.s *               * branch if Z set
                            	  1166: 
                            	  1167: 
                            	  1168: *             EA = x.W  - BYTE only
00:00003082 307C0100        	  1169:             move.l #$00000100,a0      * point to memory to address
00:00003086 10FC00FF        	  1170:             move.b #$FF,(a0)+         * populate test data
00:0000308A 08B800000100    	  1171:             bclr.b #0,$0100
00:00003090 67FE            	  1172:             beq.s *               * branch if Z set
00:00003092 08B800010100    	  1173:             bclr.b #1,$0100           *
00:00003098 67FE            	  1174:             beq.s *               * branch if Z set
00:0000309A 307C0100        	  1175:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000309E 0C1800FC        	  1176:             cmpi.b #$FC,(a0)+
00:000030A2 66FE            	  1177:             bne.s *               * branch if Z clear
                            	  1178: 
                            	  1179: 
                            	  1180: *             EA = x.L  - BYTE only
00:000030A4 207C0000F100    	  1181:             move.l #$F100,a0      * point to memory to address 0x100
00:000030AA 10BC00FF        	  1182:             move.b #$FF,(a0)          * populate test data
00:000030AE 08B900000000F100	  1183:             bclr.b #0,$F100
00:000030B6 67FE            	  1184:             beq.s *               * branch if Z set
00:000030B8 08B900010000F100	  1185:             bclr.b #1,$F100       *
00:000030C0 67FE            	  1186:             beq.s *               * branch if Z set
00:000030C2 08B900020000F100	  1187:             bclr.b #2,$F100       *
00:000030CA 67FE            	  1188:             beq.s *               * branch if Z set
00:000030CC 207C0000F100    	  1189:             move.l #$F100,a0      * point to memory to address 0x100
00:000030D2 0C1800F8        	  1190:             cmpi.b #$F8,(a0)+
00:000030D6 66FE            	  1191:             bne.s *               * branch if Z clear
                            	  1192: 
                            	  1193: 
                            	  1194: * Bit Number.s Dynamic
                            	  1195: 
                            	  1196: *             EA = Dn  - LONG only
00:000030D8 203CFF00FF00    	  1197:             move.l #$FF00FF00,d0      * populate test data
00:000030DE 7A00            	  1198:             move.l #0,d5              * populate bit.s number to test
00:000030E0 7C01            	  1199:             move.l #1,d6              * populate bit.s number to test
00:000030E2 7E1F            	  1200:             move.l #31,d7              * populate bit.s number to test
                            	  1201: 
00:000030E4 0B80            	  1202:             bclr.l d5,d0
00:000030E6 66FE            	  1203:             bne.s *               * branch if Z clear
00:000030E8 0D80            	  1204:             bclr.l d6,d0              *
00:000030EA 66FE            	  1205:             bne.s *               * branch if Z clear
00:000030EC 0F80            	  1206:             bclr.l d7,d0             *
00:000030EE 67FE            	  1207:             beq.s *               * branch if Z set
00:000030F0 0C807F00FF00    	  1208:             cmpi.l #$7F00FF00,d0
00:000030F6 66FE            	  1209:             bne.s *               * branch if Z clear
                            	  1210: 
                            	  1211: 
                            	  1212: *             EA = (An)  - BYTE only
00:000030F8 7A00            	  1213:             move.l #0,d5              * populate bit.s number to test
00:000030FA 7C01            	  1214:             move.l #1,d6              * populate bit.s number to test
00:000030FC 7E07            	  1215:             move.l #7,d7              * populate bit.s number to test
00:000030FE 307C0100        	  1216:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003102 10BC0081        	  1217:             move.b #$81,(a0)          * populate test data
00:00003106 0B90            	  1218:             bclr.b d5,(a0)
00:00003108 67FE            	  1219:             beq.s *               * branch if Z set
00:0000310A 0D90            	  1220:             bclr.b d6,(a0)            *
00:0000310C 66FE            	  1221:             bne.s *               * branch if Z clear
00:0000310E 0F90            	  1222:             bclr.b d7,(a0)            *
00:00003110 67FE            	  1223:             beq.s *               * branch if Z set
00:00003112 4A10            	  1224:             cmpi.b #$00,(a0)
00:00003114 66FE            	  1225:             bne.s *               * branch if Z clear
                            	  1226: 
                            	  1227: 
                            	  1228: *             EA = (An)+  - BYTE only
00:00003116 307C0100        	  1229:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000311A 10FC0001        	  1230:             move.b #$01,(a0)+         * populate test data
00:0000311E 10FC00FC        	  1231:             move.b #$FC,(a0)+         * populate test data
00:00003122 10FC0080        	  1232:             move.b #$80,(a0)+         * populate test data
00:00003126 307C0100        	  1233:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000312A 0B98            	  1234:             bclr.b d5,(a0)+
00:0000312C 67FE            	  1235:             beq.s *               * branch if Z set
00:0000312E 0D98            	  1236:             bclr.b d6,(a0)+           *
00:00003130 66FE            	  1237:             bne.s *               * branch if Z clear
00:00003132 0F98            	  1238:             bclr.b d7,(a0)+           *
00:00003134 67FE            	  1239:             beq.s *               * branch if Z set
00:00003136 307C0100        	  1240:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000313A 4A18            	  1241:             cmpi.b #$00,(a0)+
00:0000313C 66FE            	  1242:             bne.s *               * branch if Z clear
00:0000313E 0C1800FC        	  1243:             cmpi.b #$FC,(a0)+
00:00003142 66FE            	  1244:             bne.s *               * branch if Z clear
00:00003144 4A18            	  1245:             cmpi.b #$00,(a0)+
00:00003146 66FE            	  1246:             bne.s *               * branch if Z clear
                            	  1247: 
                            	  1248: *             EA = -(An)  - BYTE only
00:00003148 307C0100        	  1249:             move.l #$00000100,a0      * point to memory to address
00:0000314C 10FC0080        	  1250:             move.b #$80,(a0)+         * populate test data
00:00003150 10FC00FC        	  1251:             move.b #$FC,(a0)+         * populate test data
00:00003154 10FC0001        	  1252:             move.b #$01,(a0)+         * populate test data
00:00003158 307C0103        	  1253:             move.l #$00000103,a0      * point to memory to address
00:0000315C 0BA0            	  1254:             bclr.b d5,-(a0)
00:0000315E 67FE            	  1255:             beq.s *               * branch if Z set
00:00003160 0DA0            	  1256:             bclr.b d6,-(a0)           *
00:00003162 66FE            	  1257:             bne.s *               * branch if Z clear
00:00003164 0FA0            	  1258:             bclr.b d7,-(a0)           *
00:00003166 67FE            	  1259:             beq.s *               * branch if Z set
00:00003168 307C0103        	  1260:             move.l #$00000103,a0      * point to memory to address 0x100
00:0000316C 4A20            	  1261:             cmpi.b #$00,-(a0)
00:0000316E 66FE            	  1262:             bne.s *               * branch if Z clear
00:00003170 0C2000FC        	  1263:             cmpi.b #$FC,-(a0)
00:00003174 66FE            	  1264:             bne.s *               * branch if Z clear
00:00003176 4A20            	  1265:             cmpi.b #$00,-(a0)
00:00003178 66FE            	  1266:             bne.s *               * branch if Z clear
                            	  1267: 
                            	  1268: *             EA = n(An)  - BYTE only
00:0000317A 307C0100        	  1269:             move.l #$00000100,a0      * point to memory to address
00:0000317E 10FC0001        	  1270:             move.b #$01,(a0)+         * populate test data
00:00003182 10FC00FC        	  1271:             move.b #$FC,(a0)+         * populate test data
00:00003186 10FC0080        	  1272:             move.b #$80,(a0)+         * populate test data
00:0000318A 307C0100        	  1273:             move.l #$00000100,a0      * point to memory to address
00:0000318E 0B90            	  1274:             bclr.b d5,0(a0)
00:00003190 67FE            	  1275:             beq.s *               * branch if Z set
00:00003192 0DA80001        	  1276:             bclr.b d6,1(a0)           *
00:00003196 66FE            	  1277:             bne.s *               * branch if Z clear
00:00003198 0FA80002        	  1278:             bclr.b d7,2(a0)           *
00:0000319C 67FE            	  1279:             beq.s *               * branch if Z set
00:0000319E 307C0100        	  1280:             move.l #$00000100,a0      * point to memory to address 0x100
00:000031A2 4A18            	  1281:             cmpi.b #$00,(a0)+
00:000031A4 66FE            	  1282:             bne.s *               * branch if Z clear
00:000031A6 0C1800FC        	  1283:             cmpi.b #$FC,(a0)+
00:000031AA 66FE            	  1284:             bne.s *               * branch if Z clear
00:000031AC 4A18            	  1285:             cmpi.b #$00,(a0)+
00:000031AE 66FE            	  1286:             bne.s *               * branch if Z clear
                            	  1287: 
                            	  1288: *             EA = n(An,R.W)  - BYTE only
00:000031B0 307C0100        	  1289:             move.l #$00000100,a0      * point to memory to address
00:000031B4 10FC00FF        	  1290:             move.b #$FF,(a0)+         * populate test data
00:000031B8 10FC00FF        	  1291:             move.b #$FF,(a0)+         * populate test data
00:000031BC 10FC00FF        	  1292:             move.b #$FF,(a0)+         * populate test data
00:000031C0 307C0103        	  1293:             move.l #$00000103,a0      * point to memory to address
00:000031C4 307C0100        	  1294:             move.l #$00000100,a0      * point to memory to address
00:000031C8 93C9            	  1295:             move.l #$00000000,a1      * point to memory to address
00:000031CA 347C0001        	  1296:             move.l #$00000001,a2      * point to memory to address
00:000031CE 7000            	  1297:             moveq  #$00000000,d0      * point to memory to address
00:000031D0 7201            	  1298:             moveq  #$00000001,d1      * point to memory to address
00:000031D2 0BB00000        	  1299:             bclr.b d5,0(a0,d0.w)
00:000031D6 67FE            	  1300:             beq.s *               * branch if Z set
00:000031D8 0DB01000        	  1301:             bclr.b d6,0(a0,d1.w)      *
00:000031DC 67FE            	  1302:             beq.s *               * branch if Z set
00:000031DE 0FB01001        	  1303:             bclr.b d7,1(a0,d1.w)      *
00:000031E2 67FE            	  1304:             beq.s *               * branch if Z set
                            	  1305: *             EA = n(An,R.L)  - BYTE only
00:000031E4 0BB00800        	  1306:             bclr.b d5,0(a0,d0.l)
00:000031E8 66FE            	  1307:             bne.s *               * branch if Z clear
00:000031EA 0DB01800        	  1308:             bclr.b d6,0(a0,d1.l)      *
00:000031EE 66FE            	  1309:             bne.s *               * branch if Z clear
00:000031F0 0FB01801        	  1310:             bclr.b d7,1(a0,d1.l)      *
00:000031F4 66FE            	  1311:             bne.s *               * branch if Z clear
                            	  1312: *             EA = n(An,A.W)  - BYTE only
00:000031F6 0BB09000        	  1313:             bclr.b d5,0(a0,a1.w)
00:000031FA 66FE            	  1314:             bne.s *               * branch if Z clear
00:000031FC 0DB0A000        	  1315:             bclr.b d6,0(a0,a2.w)      *
00:00003200 66FE            	  1316:             bne.s *               * branch if Z clear
00:00003202 0FB0A001        	  1317:             bclr.b d7,1(a0,a2.w)      *
00:00003206 66FE            	  1318:             bne.s *               * branch if Z clear
                            	  1319: *             EA = n(An,A.L)  - BYTE only
00:00003208 0BB09800        	  1320:             bclr.b d5,0(a0,a1.l)
00:0000320C 66FE            	  1321:             bne.s *               * branch if Z clear
00:0000320E 0DB0A800        	  1322:             bclr.b d6,0(a0,a2.l)      *
00:00003212 66FE            	  1323:             bne.s *               * branch if Z clear
00:00003214 0FB0A801        	  1324:             bclr.b d7,1(a0,a2.l)      *
00:00003218 66FE            	  1325:             bne.s *               * branch if Z clear
00:0000321A 307C0100        	  1326:             move.l #$00000100,a0      * point to memory to address
00:0000321E 0C1000FE        	  1327:             cmpi.b #$FE,(a0)
00:00003222 66FE            	  1328:             bne.s *               * branch if Z clear
                            	  1329: 
                            	  1330: *             EA = x.W  - BYTE only
00:00003224 307C0100        	  1331:             move.l #$00000100,a0      * point to memory to address
00:00003228 10FC00FF        	  1332:             move.b #$FF,(a0)+         * populate test data
00:0000322C 10FC00FF        	  1333:             move.b #$FF,(a0)+         * populate test data
00:00003230 10FC00FF        	  1334:             move.b #$FF,(a0)+         * populate test data
00:00003234 0BB80100        	  1335:             bclr.b d5,$0100
00:00003238 67FE            	  1336:             beq.s *               * branch if Z set
00:0000323A 0DB80101        	  1337:             bclr.b d6,$0101           *
00:0000323E 67FE            	  1338:             beq.s *               * branch if Z set
00:00003240 0FB80102        	  1339:             bclr.b d7,$0102           *
00:00003244 67FE            	  1340:             beq.s *               * branch if Z set
00:00003246 307C0100        	  1341:             move.l #$00000100,a0      * point to memory to address
00:0000324A 0C1800FE        	  1342:             cmpi.b #$FE,(a0)+
00:0000324E 66FE            	  1343:             bne.s *               * branch if Z clear
                            	  1344: 
                            	  1345: *             EA = x.L  - BYTE only
00:00003250 207C0000F100    	  1346:             move.l #$F100,a0      * point to memory to address 0x100
00:00003256 10FC0001        	  1347:             move.b #$01,(a0)+         * populate test data
00:0000325A 10FC00FC        	  1348:             move.b #$FC,(a0)+         * populate test data
00:0000325E 10FC0080        	  1349:             move.b #$80,(a0)+         * populate test data
00:00003262 0BB90000F100    	  1350:             bclr.b d5,$F100
00:00003268 67FE            	  1351:             beq.s *               * branch if Z set
00:0000326A 0DB90000F101    	  1352:             bclr.b d6,$F101       *
00:00003270 66FE            	  1353:             bne.s *               * branch if Z clear
00:00003272 0FB90000F102    	  1354:             bclr.b d7,$F102       *
00:00003278 67FE            	  1355:             beq.s *               * branch if Z set
00:0000327A 207C0000F101    	  1356:             move.l #$F101,a0      * point to memory to address 0x100
00:00003280 0C1000FC        	  1357:             cmpi.b #$FC,(a0)
00:00003284 66FE            	  1358:             bne.s *               * branch if Z clear
                            	  1359: 
                            	  1360: 
                            	  1361: 
00:00003286 4E75            	  1362:     rts
                            	  1363: 
                            	  1364: *-----------------------------------------------------------
                            	  1365: *-----------------------------------------------------------
                            	  1366: * OPCODE : BSET
                            	  1367: *-----------------------------------------------------------
                            	  1368: *-----------------------------------------------------------
                            	  1369: op_BSET:
                            	  1370: 
                            	  1371: 
                            	  1372: *  Bit Number.s Static
                            	  1373: 
                            	  1374: *             EA = Dn  - LONG only
00:00003288 7000            	  1375:             moveq  #$00000000,d0      * populate test data
00:0000328A 08C00000        	  1376:             bset.l #0,d0
00:0000328E 66FE            	  1377:             bne.s *               * branch if Z clear
00:00003290 08C00001        	  1378:             bset.l #1,d0              *
00:00003294 66FE            	  1379:             bne.s *               * branch if Z clear
00:00003296 08C0000F        	  1380:             bset.l #15,d0             *
00:0000329A 66FE            	  1381:             bne.s *               * branch if Z clear
00:0000329C 08C0001F        	  1382:             bset.l #31,d0             *
00:000032A0 66FE            	  1383:             bne.s *               * branch if Z clear
00:000032A2 0C8080008003    	  1384:             cmpi.l #$80008003,d0
00:000032A8 66FE            	  1385:             bne.s *               * branch if Z clear
                            	  1386: 
                            	  1387: 
                            	  1388: *             EA = (An)  - BYTE only
00:000032AA 307C0100        	  1389:             move.l #$00000100,a0      * point to memory to address 0x100
00:000032AE 4210            	  1390:             move.b #$00,(a0)          * populate test data
00:000032B0 08D00000        	  1391:             bset.b #0,(a0)
00:000032B4 66FE            	  1392:             bne.s *               * branch if Z clear
00:000032B6 08D00007        	  1393:             bset.b #7,(a0)            *
00:000032BA 66FE            	  1394:             bne.s *               * branch if Z clear
00:000032BC 0C100081        	  1395:             cmpi.b #$81,(a0)
00:000032C0 66FE            	  1396:             bne.s *               * branch if Z clear
                            	  1397: 
                            	  1398: *             EA = (An)+  - BYTE only
00:000032C2 307C0100        	  1399:             move.l #$00000100,a0      * point to memory to address 0x100
00:000032C6 4218            	  1400:             move.b #$00,(a0)+         * populate test data
00:000032C8 4218            	  1401:             move.b #$00,(a0)+         * populate test data
00:000032CA 307C0100        	  1402:             move.l #$00000100,a0      * point to memory to address 0x100
00:000032CE 08D80000        	  1403:             bset.b #0,(a0)+
00:000032D2 66FE            	  1404:             bne.s *               * branch if Z clear
00:000032D4 08D80001        	  1405:             bset.b #1,(a0)+           *
00:000032D8 66FE            	  1406:             bne.s *               * branch if Z clear
00:000032DA 307C0100        	  1407:             move.l #$00000100,a0      * point to memory to address 0x100
00:000032DE 0C180001        	  1408:             cmpi.b #$01,(a0)+
00:000032E2 66FE            	  1409:             bne.s *               * branch if Z clear
00:000032E4 0C180002        	  1410:             cmpi.b #$02,(a0)+
00:000032E8 66FE            	  1411:             bne.s *               * branch if Z clear
                            	  1412: 
                            	  1413: 
                            	  1414: *             EA = -(An)  - BYTE only
00:000032EA 307C0100        	  1415:             move.l #$00000100,a0      * point to memory to address
00:000032EE 4218            	  1416:             move.b #$00,(a0)+         * populate test data
00:000032F0 4218            	  1417:             move.b #$00,(a0)+         * populate test data
00:000032F2 08E00007        	  1418:             bset.b #7,-(a0)
00:000032F6 66FE            	  1419:             bne.s *               * branch if Z clear
00:000032F8 08E00000        	  1420:             bset.b #0,-(a0)           *
00:000032FC 66FE            	  1421:             bne.s *               * branch if Z clear
00:000032FE 307C0102        	  1422:             move.l #$00000102,a0      * point to memory to address 0x100
00:00003302 0C200080        	  1423:             cmpi.b #$80,-(a0)
00:00003306 66FE            	  1424:             bne.s *               * branch if Z clear
00:00003308 0C200001        	  1425:             cmpi.b #$01,-(a0)
00:0000330C 66FE            	  1426:             bne.s *               * branch if Z clear
                            	  1427: 
                            	  1428: 
                            	  1429: *             EA = n(An)  - BYTE only
00:0000330E 307C0100        	  1430:             move.l #$00000100,a0      * point to memory to address
00:00003312 4218            	  1431:             move.b #$00,(a0)+         * populate test data
00:00003314 4218            	  1432:             move.b #$00,(a0)+         * populate test data
00:00003316 307C0100        	  1433:             move.l #$00000100,a0      * point to memory to address
00:0000331A 08D00000        	  1434:             bset.b #0,0(a0)
00:0000331E 66FE            	  1435:             bne.s *               * branch if Z clear
00:00003320 08E800040001    	  1436:             bset.b #4,1(a0)           *
00:00003326 66FE            	  1437:             bne.s *               * branch if Z clear
00:00003328 307C0100        	  1438:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000332C 0C180001        	  1439:             cmpi.b #$01,(a0)+
00:00003330 66FE            	  1440:             bne.s *               * branch if Z clear
00:00003332 0C180010        	  1441:             cmpi.b #$10,(a0)+
00:00003336 66FE            	  1442:             bne.s *               * branch if Z clear
                            	  1443: 
                            	  1444: 
                            	  1445: *             EA = n(An,D.W)  - BYTE only
00:00003338 307C0100        	  1446:             move.l #$00000100,a0      * point to memory to address
00:0000333C 93C9            	  1447:             move.l #$00000000,a1      * point to memory to address
00:0000333E 347C0004        	  1448:             move.l #$00000004,a2      * point to memory to address
00:00003342 7000            	  1449:             moveq  #$00000000,d0      * point to memory to address
00:00003344 7201            	  1450:             moveq  #$00000001,d1      * point to memory to address
00:00003346 4218            	  1451:             move.b #$00,(a0)+         * populate test data
00:00003348 4218            	  1452:             move.b #$00,(a0)+         * populate test data
00:0000334A 4218            	  1453:             move.b #$00,(a0)+         * populate test data
00:0000334C 4218            	  1454:             move.b #$00,(a0)+         * populate test data
00:0000334E 4218            	  1455:             move.b #$00,(a0)+         * populate test data
00:00003350 4218            	  1456:             move.b #$00,(a0)+         * populate test data
00:00003352 4218            	  1457:             move.b #$00,(a0)+         * populate test data
00:00003354 4218            	  1458:             move.b #$00,(a0)+         * populate test data
00:00003356 4218            	  1459:             move.b #$00,(a0)+         * populate test data
00:00003358 4218            	  1460:             move.b #$00,(a0)+         * populate test data
00:0000335A 307C0100        	  1461:             move.l #$00000100,a0      * point to memory to address
00:0000335E 08F000000000    	  1462:             bset.b #0,0(a0,d0.w)
00:00003364 66FE            	  1463:             bne.s *               * branch if Z clear
00:00003366 08F000011000    	  1464:             bset.b #1,0(a0,d1.w)      *
00:0000336C 66FE            	  1465:             bne.s *               * branch if Z clear
00:0000336E 08F000021001    	  1466:             bset.b #2,1(a0,d1.w)      *
00:00003374 66FE            	  1467:             bne.s *               * branch if Z clear
                            	  1468: *             EA = n(An,D.L)  - BYTE only
00:00003376 08F000030802    	  1469:             bset.b #3,2(a0,d0.l)
00:0000337C 66FE            	  1470:             bne.s *               * branch if Z clear
00:0000337E 08F000041800    	  1471:             bset.b #4,0(a0,d1.l)      *
00:00003384 66FE            	  1472:             bne.s *               * branch if Z clear
00:00003386 08F000051801    	  1473:             bset.b #5,1(a0,d1.l)      *
00:0000338C 66FE            	  1474:             bne.s *               * branch if Z clear
                            	  1475: *             EA = n(An,A.W)  - BYTE only
00:0000338E 08F000069000    	  1476:             bset.b #6,0(a0,a1.w)
00:00003394 66FE            	  1477:             bne.s *               * branch if Z clear
00:00003396 08F00001A000    	  1478:             bset.b #1,0(a0,a2.w)      *
00:0000339C 66FE            	  1479:             bne.s *               * branch if Z clear
00:0000339E 08F00007A001    	  1480:             bset.b #7,1(a0,a2.w)      *
00:000033A4 66FE            	  1481:             bne.s *               * branch if Z clear
                            	  1482: *             EA = n(An,A.L)  - BYTE only
00:000033A6 08F00000A802    	  1483:             bset.b #0,2(a0,a2.l)
00:000033AC 66FE            	  1484:             bne.s *               * branch if Z clear
00:000033AE 08F00000A803    	  1485:             bset.b #0,3(a0,a2.l)      *
00:000033B4 66FE            	  1486:             bne.s *               * branch if Z clear
00:000033B6 08F00001A804    	  1487:             bset.b #1,4(a0,a2.l)      *
00:000033BC 66FE            	  1488:             bne.s *               * branch if Z clear
00:000033BE 307C0100        	  1489:             move.l #$00000100,a0      * point to memory to address 0x100
00:000033C2 0C9841122C00    	  1490:             cmpi.l #$41122C00,(a0)+
00:000033C8 66FE            	  1491:             bne.s *               * branch if Z clear
00:000033CA 0C9802800101    	  1492:             cmpi.l #$02800101,(a0)+
00:000033D0 66FE            	  1493:             bne.s *
                            	  1494: 
                            	  1495: 
                            	  1496: 
                            	  1497: *             EA = x.W  - BYTE only
00:000033D2 307C0100        	  1498:             move.l #$00000100,a0      * point to memory to address
00:000033D6 4218            	  1499:             move.b #$00,(a0)+         * populate test data
00:000033D8 08F800000100    	  1500:             bset.b #0,$0100
00:000033DE 66FE            	  1501:             bne.s *               * branch if Z clear
00:000033E0 08F800010100    	  1502:             bset.b #1,$0100           *
00:000033E6 66FE            	  1503:             bne.s *               * branch if Z clear
00:000033E8 307C0100        	  1504:             move.l #$00000100,a0      * point to memory to address 0x100
00:000033EC 0C180003        	  1505:             cmpi.b #$03,(a0)+
00:000033F0 66FE            	  1506:             bne.s *
                            	  1507: 
                            	  1508: 
                            	  1509: *             EA = x.L  - BYTE only
00:000033F2 207C0000F100    	  1510:             move.l #$F100,a0      * point to memory to address 0x100
00:000033F8 4210            	  1511:             move.b #$00,(a0)          * populate test data
00:000033FA 08F900000000F100	  1512:             bset.b #0,$F100
00:00003402 66FE            	  1513:             bne.s *               * branch if Z clear
00:00003404 08F900010000F100	  1514:             bset.b #1,$F100       *
00:0000340C 66FE            	  1515:             bne.s *               * branch if Z clear
00:0000340E 08F900020000F100	  1516:             bset.b #2,$F100       *
00:00003416 66FE            	  1517:             bne.s *               * branch if Z clear
00:00003418 207C0000F100    	  1518:             move.l #$F100,a0      * point to memory to address 0x100
00:0000341E 0C180007        	  1519:             cmpi.b #$07,(a0)+
00:00003422 66FE            	  1520:             bne.s *
                            	  1521: 
                            	  1522: 
                            	  1523: * Bit Number.s Dynamic
                            	  1524: 
                            	  1525: *             EA = Dn  - LONG only
00:00003424 7000            	  1526:             moveq  #$00000000,d0      * populate test data
00:00003426 7A00            	  1527:             move.l #0,d5              * populate bit.s number to test
00:00003428 7C01            	  1528:             move.l #1,d6              * populate bit.s number to test
00:0000342A 7E1F            	  1529:             move.l #31,d7              * populate bit.s number to test
                            	  1530: 
00:0000342C 0BC0            	  1531:             bset.l d5,d0
00:0000342E 66FE            	  1532:             bne.s *               * branch if Z clear
00:00003430 0DC0            	  1533:             bset.l d6,d0              *
00:00003432 66FE            	  1534:             bne.s *               * branch if Z clear
00:00003434 0FC0            	  1535:             bset.l d7,d0             *
00:00003436 66FE            	  1536:             bne.s *               * branch if Z clear
00:00003438 0C8080000003    	  1537:             cmpi.l #$80000003,d0
00:0000343E 66FE            	  1538:             bne.s *               * branch if Z clear
                            	  1539: 
                            	  1540: 
                            	  1541: *             EA = (An)  - BYTE only
00:00003440 7A00            	  1542:             move.l #0,d5              * populate bit.s number to test
00:00003442 7C01            	  1543:             move.l #1,d6              * populate bit.s number to test
00:00003444 7E07            	  1544:             move.l #7,d7              * populate bit.s number to test
00:00003446 307C0100        	  1545:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000344A 4210            	  1546:             move.b #$00,(a0)          * populate test data
00:0000344C 0BD0            	  1547:             bset.b d5,(a0)
00:0000344E 66FE            	  1548:             bne.s *               * branch if Z clear
00:00003450 0DD0            	  1549:             bset.b d6,(a0)            *
00:00003452 66FE            	  1550:             bne.s *               * branch if Z clear
00:00003454 0FD0            	  1551:             bset.b d7,(a0)            *
00:00003456 66FE            	  1552:             bne.s *               * branch if Z clear
00:00003458 0C100083        	  1553:             cmpi.b #$83,(a0)
00:0000345C 66FE            	  1554:             bne.s *               * branch if Z clear
                            	  1555: 
                            	  1556: 
                            	  1557: *             EA = (An)+  - BYTE only
00:0000345E 307C0100        	  1558:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003462 4218            	  1559:             move.b #$00,(a0)+         * populate test data
00:00003464 4218            	  1560:             move.b #$00,(a0)+         * populate test data
00:00003466 4218            	  1561:             move.b #$00,(a0)+         * populate test data
00:00003468 307C0100        	  1562:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000346C 0BD8            	  1563:             bset.b d5,(a0)+
00:0000346E 66FE            	  1564:             bne.s *               * branch if Z clear
00:00003470 0DD8            	  1565:             bset.b d6,(a0)+           *
00:00003472 66FE            	  1566:             bne.s *               * branch if Z clear
00:00003474 0FD8            	  1567:             bset.b d7,(a0)+           *
00:00003476 66FE            	  1568:             bne.s *               * branch if Z clear
00:00003478 307C0100        	  1569:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000347C 0C180001        	  1570:             cmpi.b #$01,(a0)+
00:00003480 66FE            	  1571:             bne.s *               * branch if Z clear
00:00003482 0C180002        	  1572:             cmpi.b #$02,(a0)+
00:00003486 66FE            	  1573:             bne.s *               * branch if Z clear
00:00003488 0C180080        	  1574:             cmpi.b #$80,(a0)+
00:0000348C 66FE            	  1575:             bne.s *               * branch if Z clear
                            	  1576: 
                            	  1577: *             EA = -(An)  - BYTE only
00:0000348E 307C0100        	  1578:             move.l #$00000100,a0      * point to memory to address
00:00003492 4218            	  1579:             move.b #$00,(a0)+         * populate test data
00:00003494 4218            	  1580:             move.b #$00,(a0)+         * populate test data
00:00003496 4218            	  1581:             move.b #$00,(a0)+         * populate test data
00:00003498 307C0103        	  1582:             move.l #$00000103,a0      * point to memory to address
00:0000349C 0BE0            	  1583:             bset.b d5,-(a0)
00:0000349E 66FE            	  1584:             bne.s *               * branch if Z clear
00:000034A0 0DE0            	  1585:             bset.b d6,-(a0)           *
00:000034A2 66FE            	  1586:             bne.s *               * branch if Z clear
00:000034A4 0FE0            	  1587:             bset.b d7,-(a0)           *
00:000034A6 66FE            	  1588:             bne.s *               * branch if Z clear
00:000034A8 307C0103        	  1589:             move.l #$00000103,a0      * point to memory to address 0x100
00:000034AC 0C200001        	  1590:             cmpi.b #$01,-(a0)
00:000034B0 66FE            	  1591:             bne.s *               * branch if Z clear
00:000034B2 0C200002        	  1592:             cmpi.b #$02,-(a0)
00:000034B6 66FE            	  1593:             bne.s *               * branch if Z clear
00:000034B8 0C200080        	  1594:             cmpi.b #$80,-(a0)
00:000034BC 66FE            	  1595:             bne.s *               * branch if Z clear
                            	  1596: 
                            	  1597: *             EA = n(An)  - BYTE only
00:000034BE 307C0100        	  1598:             move.l #$00000100,a0      * point to memory to address
00:000034C2 4218            	  1599:             move.b #$00,(a0)+         * populate test data
00:000034C4 4218            	  1600:             move.b #$00,(a0)+         * populate test data
00:000034C6 4218            	  1601:             move.b #$00,(a0)+         * populate test data
00:000034C8 307C0100        	  1602:             move.l #$00000100,a0      * point to memory to address
00:000034CC 0BD0            	  1603:             bset.b d5,0(a0)
00:000034CE 66FE            	  1604:             bne.s *               * branch if Z clear
00:000034D0 0DE80001        	  1605:             bset.b d6,1(a0)           *
00:000034D4 66FE            	  1606:             bne.s *               * branch if Z clear
00:000034D6 0FE80002        	  1607:             bset.b d7,2(a0)           *
00:000034DA 66FE            	  1608:             bne.s *               * branch if Z clear
00:000034DC 307C0100        	  1609:             move.l #$00000100,a0      * point to memory to address 0x100
00:000034E0 0C180001        	  1610:             cmpi.b #$01,(a0)+
00:000034E4 66FE            	  1611:             bne.s *               * branch if Z clear
00:000034E6 0C180002        	  1612:             cmpi.b #$02,(a0)+
00:000034EA 66FE            	  1613:             bne.s *               * branch if Z clear
00:000034EC 0C180080        	  1614:             cmpi.b #$80,(a0)+
00:000034F0 66FE            	  1615:             bne.s *               * branch if Z clear
                            	  1616: 
                            	  1617: *             EA = n(An,R.W)  - BYTE only
00:000034F2 307C0100        	  1618:             move.l #$00000100,a0      * point to memory to address
00:000034F6 4218            	  1619:             move.b #$00,(a0)+         * populate test data
00:000034F8 4218            	  1620:             move.b #$00,(a0)+         * populate test data
00:000034FA 4218            	  1621:             move.b #$00,(a0)+         * populate test data
00:000034FC 4218            	  1622:             move.b #$00,(a0)+         * populate test data
00:000034FE 4218            	  1623:             move.b #$00,(a0)+         * populate test data
00:00003500 4218            	  1624:             move.b #$00,(a0)+         * populate test data
00:00003502 4218            	  1625:             move.b #$00,(a0)+         * populate test data
00:00003504 4218            	  1626:             move.b #$00,(a0)+         * populate test data
00:00003506 4218            	  1627:             move.b #$00,(a0)+         * populate test data
00:00003508 4218            	  1628:             move.b #$00,(a0)+         * populate test data
00:0000350A 4218            	  1629:             move.b #$00,(a0)+         * populate test data
00:0000350C 4218            	  1630:             move.b #$00,(a0)+         * populate test data
00:0000350E 307C0100        	  1631:             move.l #$00000100,a0      * point to memory to address
00:00003512 93C9            	  1632:             move.l #$00000000,a1      * point to memory to address
00:00003514 347C0001        	  1633:             move.l #$00000001,a2      * point to memory to address
00:00003518 7000            	  1634:             moveq  #$00000000,d0      * point to memory to address
00:0000351A 7201            	  1635:             moveq  #$00000001,d1      * point to memory to address
00:0000351C 0BF00000        	  1636:             bset.b d5,0(a0,d0.w)
00:00003520 66FE            	  1637:             bne.s *               * branch if Z clear
00:00003522 0DF01000        	  1638:             bset.b d6,0(a0,d1.w)      *
00:00003526 66FE            	  1639:             bne.s *               * branch if Z clear
00:00003528 0FF01001        	  1640:             bset.b d7,1(a0,d1.w)      *
00:0000352C 66FE            	  1641:             bne.s *               * branch if Z clear
                            	  1642: *             EA = n(An,R.L)  - BYTE only
00:0000352E 0BF00802        	  1643:             bset.b d5,2(a0,d0.l)
00:00003532 66FE            	  1644:             bne.s *               * branch if Z clear
00:00003534 0DF01803        	  1645:             bset.b d6,3(a0,d1.l)      *
00:00003538 66FE            	  1646:             bne.s *               * branch if Z clear
00:0000353A 0FF01804        	  1647:             bset.b d7,4(a0,d1.l)      *
00:0000353E 66FE            	  1648:             bne.s *               * branch if Z clear
                            	  1649: *             EA = n(An,A.W)  - BYTE only
00:00003540 0BF09005        	  1650:             bset.b d5,5(a0,a1.w)
00:00003544 66FE            	  1651:             bne.s *               * branch if Z clear
00:00003546 0DF0A006        	  1652:             bset.b d6,6(a0,a2.w)      *
00:0000354A 66FE            	  1653:             bne.s *               * branch if Z clear
00:0000354C 0FF0A007        	  1654:             bset.b d7,7(a0,a2.w)      *
00:00003550 66FE            	  1655:             bne.s *               * branch if Z clear
                            	  1656: *             EA = n(An,A.L)  - BYTE only
00:00003552 0BF09808        	  1657:             bset.b d5,8(a0,a1.l)
00:00003556 66FE            	  1658:             bne.s *               * branch if Z clear
00:00003558 0DF0A809        	  1659:             bset.b d6,9(a0,a2.l)      *
00:0000355C 66FE            	  1660:             bne.s *               * branch if Z clear
00:0000355E 0FF0A80A        	  1661:             bset.b d7,10(a0,a2.l)      *
00:00003562 66FE            	  1662:             bne.s *               * branch if Z clear
00:00003564 307C0100        	  1663:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003568 0C9801028100    	  1664:             cmpi.l #$01028100,(a0)+
00:0000356E 66FE            	  1665:             bne.s *               * branch if Z clear
00:00003570 0C9802810002    	  1666:             cmpi.l #$02810002,(a0)+
00:00003576 66FE            	  1667:             bne.s *
                            	  1668: 
                            	  1669: 
                            	  1670: *             EA = x.W  - BYTE only
00:00003578 307C0100        	  1671:             move.l #$00000100,a0      * point to memory to address
00:0000357C 4218            	  1672:             move.b #$00,(a0)+         * populate test data
00:0000357E 4218            	  1673:             move.b #$00,(a0)+         * populate test data
00:00003580 4218            	  1674:             move.b #$00,(a0)+         * populate test data
00:00003582 0BF80100        	  1675:             bset.b d5,$0100
00:00003586 66FE            	  1676:             bne.s *               * branch if Z clear
00:00003588 0DF80100        	  1677:             bset.b d6,$0100           *
00:0000358C 66FE            	  1678:             bne.s *               * branch if Z clear
00:0000358E 0FF80100        	  1679:             bset.b d7,$0100           *
00:00003592 66FE            	  1680:             bne.s *               * branch if Z clear
00:00003594 307C0100        	  1681:             move.l #$00000100,a0      * point to memory to address
00:00003598 0C180083        	  1682:             cmpi.b #$83,(a0)+
00:0000359C 66FE            	  1683:             bne.s *               * branch if Z clear
                            	  1684: 
                            	  1685: *             EA = x.L  - BYTE only
00:0000359E 207C0000F100    	  1686:             move.l #$F100,a0      * point to memory to address 0x100
00:000035A4 4218            	  1687:             move.b #$00,(a0)+         * populate test data
00:000035A6 4218            	  1688:             move.b #$00,(a0)+         * populate test data
00:000035A8 4218            	  1689:             move.b #$00,(a0)+         * populate test data
00:000035AA 0BF90000F100    	  1690:             bset.b d5,$F100
00:000035B0 66FE            	  1691:             bne.s *               * branch if Z clear
00:000035B2 0DF90000F100    	  1692:             bset.b d6,$F100       *
00:000035B8 66FE            	  1693:             bne.s *               * branch if Z clear
00:000035BA 0FF90000F100    	  1694:             bset.b d7,$F100       *
00:000035C0 66FE            	  1695:             bne.s *               * branch if Z clear
00:000035C2 207C0000F100    	  1696:             move.l #$F100,a0      * point to memory to address 0x100
00:000035C8 0C100083        	  1697:             cmpi.b #$83,(a0)
00:000035CC 66FE            	  1698:             bne.s *               * branch if Z clear
                            	  1699: 
                            	  1700: 
00:000035CE 4E75            	  1701:     rts
                            	  1702: 
                            	  1703: *-----------------------------------------------------------
                            	  1704: *-----------------------------------------------------------
                            	  1705: * OPCODE : MOVEP
                            	  1706: *-----------------------------------------------------------
                            	  1707: *-----------------------------------------------------------
                            	  1708: op_MOVEP:
                            	  1709: 
                            	  1710: * Dn --> x(An)
00:000035D0 307C0100        	  1711:             move.l #$00000100,a0
00:000035D4 203C12345678    	  1712:             move.l #$12345678,d0
00:000035DA 223CAABBCCDD    	  1713:             move.l #$AABBCCDD,d1
00:000035E0 4290            	  1714:             move.l #0,(a0)
00:000035E2 42A80004        	  1715:             move.l #0,4(a0)
                            	  1716: 
00:000035E6 01880000        	  1717:             movep.w d0,0(a0)      * even offset
00:000035EA 03880001        	  1718:             movep.w d1,1(a0)      * odd offset
                            	  1719: 
00:000035EE 01C80004        	  1720:             movep.l d0,4(a0)      * even offset
00:000035F2 03C80005        	  1721:             movep.l d1,5(a0)      * odd offset
                            	  1722: 
00:000035F6 0C9056CC78DD    	  1723:             cmpi.l #$56CC78DD,(a0)
00:000035FC 66FE            	  1724:             bne.s *
00:000035FE 0CA812AA34BB0004	  1725:             cmpi.l #$12AA34BB,4(a0)
00:00003606 66FE            	  1726:             bne.s *
00:00003608 0CA856CC78DD0008	  1727:             cmpi.l #$56CC78DD,8(a0)
00:00003610 66FE            	  1728:             bne.s *
                            	  1729: 
                            	  1730: 
                            	  1731: * x(An)--> Dn
00:00003612 203C5A5A5A5A    	  1732:             move.l #$5a5a5a5a,d0
00:00003618 223C5A5A5A5A    	  1733:             move.l #$5a5a5a5a,d1
00:0000361E 243C5A5A5A5A    	  1734:             move.l #$5a5a5a5a,d2
00:00003624 263C5A5A5A5A    	  1735:             move.l #$5a5a5a5a,d3
                            	  1736: 
00:0000362A 01080000        	  1737:             movep.w 0(a0),d0      * even offset
00:0000362E 03080001        	  1738:             movep.w 1(a0),d1      * odd offset
                            	  1739: 
00:00003632 05480004        	  1740:             movep.l 4(a0),d2      * even offset
00:00003636 07480005        	  1741:             movep.l 5(a0),d3      * odd offset
                            	  1742: 
00:0000363A 0C805A5A5678    	  1743:             cmpi.l #$5a5a5678,d0
00:00003640 66FE            	  1744:             bne.s *
00:00003642 0C815A5ACCDD    	  1745:             cmpi.l #$5a5aCCDD,d1
00:00003648 66FE            	  1746:             bne.s *
00:0000364A 0C8212345678    	  1747:             cmpi.l #$12345678,d2
00:00003650 66FE            	  1748:             bne.s *
00:00003652 0C83AABBCCDD    	  1749:             cmpi.l #$AABBCCDD,d3
00:00003658 66FE            	  1750:             bne.s *
                            	  1751: 
00:0000365A 4E75            	  1752:             rts
                            	  1753: 
                            	  1754: 
                            	  1755: 
                            	  1756: *-----------------------------------------------------------
                            	  1757: *-----------------------------------------------------------
                            	  1758: * OPCODE : BOOL_I
                            	  1759: *-----------------------------------------------------------
                            	  1760: *-----------------------------------------------------------
                            	  1761: op_BOOL_I:
                            	  1762: 
                            	  1763: *     Dn -- BYTE
00:0000365C 203C12345678    	  1764:             move.l #$12345678,d0
00:00003662 44FC000F        	  1765:             move.w #$000F,CCR          * pre-set Flags
00:00003666 000000FF        	  1766:             ori.b  #$FF,d0
00:0000366A 0A00005A        	  1767:             eori.b #$5A,d0
00:0000366E 020000F0        	  1768:             andi.b #$F0,d0
00:00003672 69FE            	  1769:             bvs.s *                       * Check V,C are cleared
00:00003674 65FE            	  1770:             bcs.s *
00:00003676 6AFE            	  1771:             bpl.s *                       * Verify if N flag is set
00:00003678 4200            	  1772:             andi.b #$00,d0
00:0000367A 6BFE            	  1773:             bmi.s *                       * Verify if N flag is cleared
00:0000367C 66FE            	  1774:             bne.s *                       * Verify if Z flag is set
                            	  1775: 
                            	  1776: *     Dn -- WORD
00:0000367E 223C12345678    	  1777:             move.l #$12345678,d1
00:00003684 44FC000F        	  1778:             move.w #$000F,CCR          * pre-set Flags
00:00003688 0041FFFF        	  1779:             ori.w  #$FFFF,d1
00:0000368C 0A415A5A        	  1780:             eori.w #$5A5A,d1
00:00003690 0241F0F0        	  1781:             andi.w #$F0F0,d1
00:00003694 69FE            	  1782:             bvs.s *                       * Check V,C are cleared
00:00003696 65FE            	  1783:             bcs.s *
00:00003698 6AFE            	  1784:             bpl.s *                       * Verify if N flag is set
00:0000369A 4241            	  1785:             andi.w #$0000,d1
00:0000369C 6BFE            	  1786:             bmi.s *                       * Verify if N flag is cleared
00:0000369E 66FE            	  1787:             bne.s *                       * Verify if Z flag is set
                            	  1788: 
                            	  1789: *     Dn -- LONG
00:000036A0 243C12345678    	  1790:             move.l #$12345678,d2
00:000036A6 44FC000F        	  1791:             move.w #$000F,CCR          * pre-set Flags
00:000036AA 0082FFFFFFFF    	  1792:             ori.l  #$FFFFFFFF,d2
00:000036B0 0A825A5A5A5A    	  1793:             eori.l #$5A5A5A5A,d2
00:000036B6 0282F0F0F0F0    	  1794:             andi.l #$F0F0F0F0,d2
00:000036BC 69FE            	  1795:             bvs.s *                       * Check V,C are cleared
00:000036BE 65FE            	  1796:             bcs.s *
00:000036C0 6AFE            	  1797:             bpl.s *                       * Verify if N flag is set
00:000036C2 4282            	  1798:             andi.l #$00000000,d2
00:000036C4 6BFE            	  1799:             bmi.s *                       * Verify if N flag is cleared
00:000036C6 66FE            	  1800:             bne.s *                       * Verify if Z flag is set
                            	  1801: 
                            	  1802: 
                            	  1803: *     (An) -- BYTE
00:000036C8 307C0100        	  1804:             move.l #$00000100,a0
00:000036CC 20BC12345678    	  1805:             move.l #$12345678,(a0)
00:000036D2 44FC000F        	  1806:             move.w #$000F,CCR          * pre-set Flags
00:000036D6 001000FF        	  1807:             ori.b  #$FF,(a0)
00:000036DA 0A10005A        	  1808:             eori.b #$5A,(a0)
00:000036DE 021000F0        	  1809:             andi.b #$F0,(a0)
00:000036E2 69FE            	  1810:             bvs.s *                       * Check V,C are cleared
00:000036E4 65FE            	  1811:             bcs.s *
00:000036E6 6AFE            	  1812:             bpl.s *                       * Verify if N flag is set
00:000036E8 4210            	  1813:             andi.b #$00,(a0)
00:000036EA 6BFE            	  1814:             bmi.s *                       * Verify if N flag is cleared
00:000036EC 66FE            	  1815:             bne.s *                       * Verify if Z flag is set
00:000036EE 4A10            	  1816:             cmpi.b #$00,(a0)
00:000036F0 66FE            	  1817:             bne.s *                       * Verify if Z flag is set
                            	  1818: 
                            	  1819: *     (An) -- WORD
00:000036F2 20BC12345678    	  1820:             move.l #$12345678,(a0)
00:000036F8 44FC000F        	  1821:             move.w #$000F,CCR          * pre-set Flags
00:000036FC 0050FFFF        	  1822:             ori.w  #$FFFF,(a0)
00:00003700 0A505A5A        	  1823:             eori.w #$5A5A,(a0)
00:00003704 0250F0F0        	  1824:             andi.w #$F0F0,(a0)
00:00003708 69FE            	  1825:             bvs.s *                       * Check V,C are cleared
00:0000370A 65FE            	  1826:             bcs.s *
00:0000370C 6AFE            	  1827:             bpl.s *                       * Verify if N flag is set
00:0000370E 4250            	  1828:             andi.w #$0000,(a0)
00:00003710 6BFE            	  1829:             bmi.s *                       * Verify if N flag is cleared
00:00003712 66FE            	  1830:             bne.s *                       * Verify if Z flag is set
00:00003714 4A50            	  1831:             cmpi.w #$00,(a0)
00:00003716 66FE            	  1832:             bne.s *                       * Verify if Z flag is set
                            	  1833: 
                            	  1834: *     (An) -- LONG
00:00003718 20BC12345678    	  1835:             move.l #$12345678,(a0)
00:0000371E 44FC000F        	  1836:             move.w #$000F,CCR          * pre-set Flags
00:00003722 0090FFFFFFFF    	  1837:             ori.l  #$FFFFFFFF,(a0)
00:00003728 0A905A5A5A5A    	  1838:             eori.l #$5A5A5A5A,(a0)
00:0000372E 0290F0F0F0F0    	  1839:             andi.l #$F0F0F0F0,(a0)
00:00003734 69FE            	  1840:             bvs.s *                       * Check V,C are cleared
00:00003736 65FE            	  1841:             bcs.s *
00:00003738 6AFE            	  1842:             bpl.s *                       * Verify if N flag is set
00:0000373A 4290            	  1843:             andi.l #$00000000,(a0)
00:0000373C 6BFE            	  1844:             bmi.s *                       * Verify if N flag is cleared
00:0000373E 66FE            	  1845:             bne.s *                       * Verify if Z flag is set
00:00003740 4A90            	  1846:             cmpi.l #$00,(a0)
00:00003742 66FE            	  1847:             bne.s *                       * Verify if Z flag is set
                            	  1848: 
                            	  1849: 
                            	  1850: 
                            	  1851: *     (An)+ -- BYTE
00:00003744 307C0100        	  1852:             move.l #$00000100,a0
00:00003748 20BC00A5FF88    	  1853:             move.l #$00A5FF88,(a0)
00:0000374E 44FC000F        	  1854:             move.w #$000F,CCR          * pre-set Flags
                            	  1855: 
00:00003752 001800F5        	  1856:             ori.b  #$F5,(a0)+
00:00003756 6AFE            	  1857:             bpl.s *                       * Verify if N flag is set
00:00003758 67FE            	  1858:             beq.s *                       * Verify if Z flag is cleared
                            	  1859: 
00:0000375A 4618            	  1860:             eori.b #$FF,(a0)+
00:0000375C 6BFE            	  1861:             bmi.s *                       * Verify if N flag is cleared
00:0000375E 67FE            	  1862:             beq.s *                       * Verify if Z flag is cleared
                            	  1863: 
00:00003760 021800AA        	  1864:             andi.b #$AA,(a0)+
00:00003764 6AFE            	  1865:             bpl.s *                       * Verify if N flag is set
00:00003766 67FE            	  1866:             beq.s *                       * Verify if Z flag is cleared
                            	  1867: 
00:00003768 307C0100        	  1868:             move.l #$00000100,a0
00:0000376C 0C90F55AAA88    	  1869:             cmpi.l #$F55AAA88,(a0)
00:00003772 66FE            	  1870:             bne.s *                       * Verify if Z flag is set
                            	  1871: 
                            	  1872: 
                            	  1873: *     (An)+ -- WORD
00:00003774 307C0100        	  1874:             move.l #$00000100,a0
00:00003778 327C0104        	  1875:             move.l #$00000104,a1
00:0000377C 20BC00005A5A    	  1876:             move.l #$00005a5a,(a0)
00:00003782 22BC12345678    	  1877:             move.l #$12345678,(a1)
00:00003788 44FC000F        	  1878:             move.w #$000F,CCR          * pre-set Flags
                            	  1879: 
00:0000378C 00585678        	  1880:             ori.w  #$5678,(a0)+
00:00003790 6BFE            	  1881:             bmi.s *                       * Verify if N flag is cleared
00:00003792 67FE            	  1882:             beq.s *                       * Verify if Z flag is cleared
                            	  1883: 
00:00003794 4658            	  1884:             eori.w #$FFFF,(a0)+
00:00003796 6AFE            	  1885:             bpl.s *                       * Verify if N flag is set
00:00003798 67FE            	  1886:             beq.s *                       * Verify if Z flag is cleared
                            	  1887: 
00:0000379A 0258A55A        	  1888:             andi.w #$A55A,(a0)+
00:0000379E 6BFE            	  1889:             bmi.s *                       * Verify if N flag is cleared
00:000037A0 67FE            	  1890:             beq.s *                       * Verify if Z flag is cleared
                            	  1891: 
00:000037A2 307C0100        	  1892:             move.l #$00000100,a0
00:000037A6 0C905678A5A5    	  1893:             cmpi.l #$5678a5a5,(a0)
00:000037AC 307C0104        	  1894:             move.l #$00000104,a0
00:000037B0 0C9000105678    	  1895:             cmpi.l #$00105678,(a0)
00:000037B6 66FE            	  1896:             bne.s *                       * Verify if Z flag is set
                            	  1897: 
                            	  1898: *     (An)+ -- LONG
00:000037B8 307C0100        	  1899:             move.l #$00000100,a0
00:000037BC 4298            	  1900:             move.l #$00000000,(a0)+
00:000037BE 20FC5A5A5A5A    	  1901:             move.l #$5a5a5a5a,(a0)+
00:000037C4 20FCFFFFFFFF    	  1902:             move.l #$FFFFFFFF,(a0)+
00:000037CA 307C0100        	  1903:             move.l #$00000100,a0
00:000037CE 44FC000F        	  1904:             move.w #$000F,CCR          * pre-set Flags
                            	  1905: 
00:000037D2 009812345678    	  1906:             ori.l  #$12345678,(a0)+
00:000037D8 6BFE            	  1907:             bmi.s *                       * Verify if N flag is cleared
00:000037DA 67FE            	  1908:             beq.s *                       * Verify if Z flag is cleared
                            	  1909: 
00:000037DC 4698            	  1910:             eori.l #$FFFFFFFF,(a0)+
00:000037DE 6AFE            	  1911:             bpl.s *                       * Verify if N flag is set
00:000037E0 67FE            	  1912:             beq.s *                       * Verify if Z flag is cleared
                            	  1913: 
00:000037E2 0298A5A5A55A    	  1914:             andi.l #$A5A5A55A,(a0)+
00:000037E8 6AFE            	  1915:             bpl.s *                       * Verify if N flag is set
00:000037EA 67FE            	  1916:             beq.s *                       * Verify if Z flag is cleared
                            	  1917: 
00:000037EC 307C0100        	  1918:             move.l #$00000100,a0
00:000037F0 0C9812345678    	  1919:             cmpi.l #$12345678,(a0)+
00:000037F6 0C98A5A5A5A5    	  1920:             cmpi.l #$a5a5a5a5,(a0)+
00:000037FC 0C98A5A5A55A    	  1921:             cmpi.l #$a5a5a55a,(a0)+
00:00003802 66FE            	  1922:             bne.s *                       * Verify if Z flag is set
                            	  1923: 
00:00003804 4E75            	  1924:             rts
                            	  1925: 
                            	  1926: 
                            	  1927: *-----------------------------------------------------------
                            	  1928: *-----------------------------------------------------------
                            	  1929: * OPCODE : BSR
                            	  1930: *-----------------------------------------------------------
                            	  1931: *-----------------------------------------------------------
                            	  1932: 
                            	  1933: 
00:00003806 223C11111111    	  1934: BSR_CLOSE1:     move.l #$11111111,d1
00:0000380C 4E75            	  1935:                 rts
                            	  1936: 
                            	  1937: 
                            	  1938: 
00:0000380E 61F6            	  1939: op_BSR:         bsr BSR_CLOSE1        * Negative 8-bit.s displacement
00:00003810 612A            	  1940:                 bsr BSR_CLOSE2        * Positive 8-bit.s displacement
00:00003812 6100EF20        	  1941:                 bsr.w BSR_FAR1          * Negative 16-bit.s displacement
00:00003816 6100144E        	  1942:                 bsr.w BSR_FAR2          * Positive 16-bit.s displacement
                            	  1943: 
00:0000381A 0C8111111111    	  1944:                 cmpi.l #$11111111,d1
00:00003820 66FE            	  1945:                 bne.s *
00:00003822 0C8222222222    	  1946:                 cmpi.l #$22222222,d2
00:00003828 66FE            	  1947:                 bne.s *
00:0000382A 0C8333333333    	  1948:                 cmpi.l #$33333333,d3
00:00003830 66FE            	  1949:                 bne.s *
00:00003832 0C8444444444    	  1950:                 cmpi.l #$44444444,d4
00:00003838 66FE            	  1951:                 bne.s *
                            	  1952: 
00:0000383A 4E75            	  1953:                 rts
                            	  1954: 
                            	  1955: 
00:0000383C 243C22222222    	  1956: BSR_CLOSE2:     move.l #$22222222,d2
00:00003842 4E75            	  1957:                 rts
                            	  1958: 
                            	  1959: *-----------------------------------------------------------
                            	  1960: *-----------------------------------------------------------
                            	  1961: * OPCODE : op_CMP_I
                            	  1962: *-----------------------------------------------------------
                            	  1963: *-----------------------------------------------------------
                            	  1964: op_CMP_I:
                            	  1965: 
00:00003844 307C0100        	  1966:             move.l #$00000100,a0
00:00003848 20BC00000100    	  1967:             move.l #$00000100,(a0)
                            	  1968: 
                            	  1969: *     REGISTER - BYTE
00:0000384E 7080            	  1970:             move.l #$FFFFFF80,d0
00:00003850 0C000080        	  1971:             cmpi.b #$80,d0
00:00003854 66FE            	  1972:             bne.s *                       * Check Z Flag  beq/bne
00:00003856 6BFE            	  1973:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003858 65FE            	  1974:             bcs.s *                       * Check C Flag  bcc/bcs
00:0000385A 69FE            	  1975:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1976: 
00:0000385C 223CFFFFF000    	  1977:             move.l #$FFFFF000,d1
00:00003862 4A01            	  1978:             cmpi.b #$00,d1
00:00003864 66FE            	  1979:             bne.s *                       * Check Z Flag  beq/bne
00:00003866 6BFE            	  1980:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003868 65FE            	  1981:             bcs.s *                       * Check C Flag  bcc/bcs
00:0000386A 69FE            	  1982:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1983: 
00:0000386C 7481D442        	  1984:             move.l #$FFFFFF02,d2
00:00003870 0C0200FF        	  1985:             cmpi.b #$FF,d2
00:00003874 67FE            	  1986:             beq.s *                       * Check Z Flag  beq/bne
00:00003876 6BFE            	  1987:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003878 64FE            	  1988:             bcc.s *                       * Check C Flag  bcc/bcs
00:0000387A 69FE            	  1989:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1990: 
00:0000387C 263CFFFFFF7F    	  1991:             move.l #$FFFFFF7F,d3
00:00003882 0C0300FF        	  1992:             cmpi.b #$FF,d3
00:00003886 67FE            	  1993:             beq.s *                       * Check Z Flag  beq/bne
00:00003888 6AFE            	  1994:             bpl.s *                       * Check N Flag  bmi/bpl
00:0000388A 64FE            	  1995:             bcc.s *                       * Check C Flag  bcc/bcs
00:0000388C 68FE            	  1996:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  1997: 
                            	  1998: 
                            	  1999: *     REGISTER - WORD
00:0000388E 203CFFFF8000    	  2000:             move.l #$FFFF8000,d0
00:00003894 0C408000        	  2001:             cmpi.w #$8000,d0
00:00003898 66FE            	  2002:             bne.s *                       * Check Z Flag  beq/bne
00:0000389A 6BFE            	  2003:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000389C 65FE            	  2004:             bcs.s *                       * Check C Flag  bcc/bcs
00:0000389E 69FE            	  2005:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2006: 
00:000038A0 223CFFF00000    	  2007:             move.l #$FFF00000,d1
00:000038A6 4A41            	  2008:             cmpi.w #$0000,d1
00:000038A8 66FE            	  2009:             bne.s *                       * Check Z Flag  beq/bne
00:000038AA 6BFE            	  2010:             bmi.s *                       * Check N Flag  bmi/bpl
00:000038AC 65FE            	  2011:             bcs.s *                       * Check C Flag  bcc/bcs
00:000038AE 69FE            	  2012:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2013: 
00:000038B0 243CFFFF0002    	  2014:             move.l #$FFFF0002,d2
00:000038B6 0C42FFFF        	  2015:             cmpi.w #$FFFF,d2
00:000038BA 67FE            	  2016:             beq.s *                       * Check Z Flag  beq/bne
00:000038BC 6BFE            	  2017:             bmi.s *                       * Check N Flag  bmi/bpl
00:000038BE 64FE            	  2018:             bcc.s *                       * Check C Flag  bcc/bcs
00:000038C0 69FE            	  2019:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2020: 
00:000038C2 263CFFFF7FFF    	  2021:             move.l #$FFFF7FFF,d3
00:000038C8 0C43FFFF        	  2022:             cmpi.w #$FFFF,d3
00:000038CC 67FE            	  2023:             beq.s *                       * Check Z Flag  beq/bne
00:000038CE 6AFE            	  2024:             bpl.s *                       * Check N Flag  bmi/bpl
00:000038D0 64FE            	  2025:             bcc.s *                       * Check C Flag  bcc/bcs
00:000038D2 68FE            	  2026:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2027: 
                            	  2028: *     REGISTER - LONG
00:000038D4 203C80000000    	  2029:             move.l #$80000000,d0
00:000038DA 0C8080000000    	  2030:             cmpi.l #$80000000,d0
00:000038E0 66FE            	  2031:             bne.s *                       * Check Z Flag  beq/bne
00:000038E2 6BFE            	  2032:             bmi.s *                       * Check N Flag  bmi/bpl
00:000038E4 65FE            	  2033:             bcs.s *                       * Check C Flag  bcc/bcs
00:000038E6 69FE            	  2034:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2035: 
00:000038E8 7200            	  2036:             moveq  #$00000000,d1
00:000038EA 4A81            	  2037:             cmpi.l #$00000000,d1
00:000038EC 66FE            	  2038:             bne.s *                       * Check Z Flag  beq/bne
00:000038EE 6BFE            	  2039:             bmi.s *                       * Check N Flag  bmi/bpl
00:000038F0 65FE            	  2040:             bcs.s *                       * Check C Flag  bcc/bcs
00:000038F2 69FE            	  2041:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2042: 
00:000038F4 7402            	  2043:             moveq  #$00000002,d2
00:000038F6 0C82FFFFFFFF    	  2044:             cmpi.l #$FFFFFFFF,d2
00:000038FC 67FE            	  2045:             beq.s *                       * Check Z Flag  beq/bne
00:000038FE 6BFE            	  2046:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003900 64FE            	  2047:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003902 69FE            	  2048:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2049: 
00:00003904 263C7FFFFFFF    	  2050:             move.l #$7FFFFFFF,d3
00:0000390A 0C83FFFFFFFF    	  2051:             cmpi.l #$FFFFFFFF,d3
00:00003910 67FE            	  2052:             beq.s *                       * Check Z Flag  beq/bne
00:00003912 6AFE            	  2053:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003914 64FE            	  2054:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003916 68FE            	  2055:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2056: 
                            	  2057: 
                            	  2058: 
                            	  2059: 
                            	  2060: *     EA=x(An,Dn) - BYTE
00:00003918 307C0100        	  2061:             move.l #$00000100,a0
00:0000391C 7E04            	  2062:             moveq  #$00000004,d7
                            	  2063: 
00:0000391E 21BCFFFFFF80700C	  2064:             move.l #$FFFFFF80,12(a0,d7)
00:00003926 21BCFFFFFF80700C	  2065:             move.l #$FFFFFF80,12(a0,d7)
00:0000392E 0C300080700F    	  2066:             cmpi.b #$80,15(a0,d7)
00:00003934 66FE            	  2067:             bne.s *                       * Check Z Flag  beq/bne
00:00003936 6BFE            	  2068:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003938 65FE            	  2069:             bcs.s *                       * Check C Flag  bcc/bcs
00:0000393A 69FE            	  2070:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2071: 
00:0000393C 21BCFFFFF000700C	  2072:             move.l #$FFFFF000,12(a0,d7)
00:00003944 4A30700F        	  2073:             cmpi.b #$00,15(a0,d7)
00:00003948 66FE            	  2074:             bne.s *                       * Check Z Flag  beq/bne
00:0000394A 6BFE            	  2075:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000394C 65FE            	  2076:             bcs.s *                       * Check C Flag  bcc/bcs
00:0000394E 69FE            	  2077:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2078: 
00:00003950 21BCFFFFFF02700C	  2079:             move.l #$FFFFFF02,12(a0,d7)
00:00003958 0C3000FF700F    	  2080:             cmpi.b #$FF,15(a0,d7)
00:0000395E 67FE            	  2081:             beq.s *                       * Check Z Flag  beq/bne
00:00003960 6BFE            	  2082:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003962 64FE            	  2083:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003964 69FE            	  2084:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2085: 
00:00003966 21BCFFFFFF7F700C	  2086:             move.l #$FFFFFF7F,12(a0,d7)
00:0000396E 0C3000FF700F    	  2087:             cmpi.b #$FF,15(a0,d7)
00:00003974 67FE            	  2088:             beq.s *                       * Check Z Flag  beq/bne
00:00003976 6AFE            	  2089:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003978 64FE            	  2090:             bcc.s *                       * Check C Flag  bcc/bcs
00:0000397A 68FE            	  2091:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2092: 
                            	  2093: 
                            	  2094: *     EA=x(An,Dn) - WORD
00:0000397C 21BCFFFF8000700C	  2095:             move.l #$FFFF8000,12(a0,d7)
00:00003984 0C708000700E    	  2096:             cmpi.w #$8000,14(a0,d7)
00:0000398A 66FE            	  2097:             bne.s *                       * Check Z Flag  beq/bne
00:0000398C 6BFE            	  2098:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000398E 65FE            	  2099:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003990 69FE            	  2100:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2101: 
00:00003992 21BCFFF00000700C	  2102:             move.l #$FFF00000,12(a0,d7)
00:0000399A 4A70700E        	  2103:             cmpi.w #$0000,14(a0,d7)
00:0000399E 66FE            	  2104:             bne.s *                       * Check Z Flag  beq/bne
00:000039A0 6BFE            	  2105:             bmi.s *                       * Check N Flag  bmi/bpl
00:000039A2 65FE            	  2106:             bcs.s *                       * Check C Flag  bcc/bcs
00:000039A4 69FE            	  2107:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2108: 
00:000039A6 21BCFFFF0002700C	  2109:             move.l #$FFFF0002,12(a0,d7)
00:000039AE 0C70FFFF700E    	  2110:             cmpi.w #$FFFF,14(a0,d7)
00:000039B4 67FE            	  2111:             beq.s *                       * Check Z Flag  beq/bne
00:000039B6 6BFE            	  2112:             bmi.s *                       * Check N Flag  bmi/bpl
00:000039B8 64FE            	  2113:             bcc.s *                       * Check C Flag  bcc/bcs
00:000039BA 69FE            	  2114:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2115: 
00:000039BC 21BCFFFF7FFF700C	  2116:             move.l #$FFFF7FFF,12(a0,d7)
00:000039C4 0C70FFFF700E    	  2117:             cmpi.w #$FFFF,14(a0,d7)
00:000039CA 67FE            	  2118:             beq.s *                       * Check Z Flag  beq/bne
00:000039CC 6AFE            	  2119:             bpl.s *                       * Check N Flag  bmi/bpl
00:000039CE 64FE            	  2120:             bcc.s *                       * Check C Flag  bcc/bcs
00:000039D0 68FE            	  2121:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2122: 
                            	  2123: *     EA=x(An,Dn) - LONG
00:000039D2 21BC80000000700C	  2124:             move.l #$80000000,12(a0,d7)
00:000039DA 0CB080000000700C	  2125:             cmpi.l #$80000000,12(a0,d7)
00:000039E2 66FE            	  2126:             bne.s *                       * Check Z Flag  beq/bne
00:000039E4 6BFE            	  2127:             bmi.s *                       * Check N Flag  bmi/bpl
00:000039E6 65FE            	  2128:             bcs.s *                       * Check C Flag  bcc/bcs
00:000039E8 69FE            	  2129:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2130: 
00:000039EA 42B0700C        	  2131:             move.l #$00000000,12(a0,d7)
00:000039EE 4AB0700C        	  2132:             cmpi.l #$00000000,12(a0,d7)
00:000039F2 66FE            	  2133:             bne.s *                       * Check Z Flag  beq/bne
00:000039F4 6BFE            	  2134:             bmi.s *                       * Check N Flag  bmi/bpl
00:000039F6 65FE            	  2135:             bcs.s *                       * Check C Flag  bcc/bcs
00:000039F8 69FE            	  2136:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2137: 
00:000039FA 21BC00000002700C	  2138:             move.l #$00000002,12(a0,d7)
00:00003A02 0CB0FFFFFFFF700C	  2139:             cmpi.l #$FFFFFFFF,12(a0,d7)
00:00003A0A 67FE            	  2140:             beq.s *                       * Check Z Flag  beq/bne
00:00003A0C 6BFE            	  2141:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A0E 64FE            	  2142:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003A10 69FE            	  2143:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2144: 
00:00003A12 21BC7FFFFFFF700C	  2145:             move.l #$7FFFFFFF,12(a0,d7)
00:00003A1A 0CB0FFFFFFFF700C	  2146:             cmpi.l #$FFFFFFFF,12(a0,d7)
00:00003A22 67FE            	  2147:             beq.s *                       * Check Z Flag  beq/bne
00:00003A24 6AFE            	  2148:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003A26 64FE            	  2149:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003A28 68FE            	  2150:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2151: 
                            	  2152: 
                            	  2153: 
                            	  2154: 
00:00003A2A 4E75            	  2155:             rts
                            	  2156: 
                            	  2157: 
                            	  2158: 
                            	  2159: *-----------------------------------------------------------
                            	  2160: *-----------------------------------------------------------
                            	  2161: * OPCODE : ADD_I
                            	  2162: *-----------------------------------------------------------
                            	  2163: *-----------------------------------------------------------
                            	  2164: op_ADD_I:
                            	  2165: 
                            	  2166: *     EA = Dn  - Byte
00:00003A2C 203C12345678    	  2167:             move.l #$12345678,d0      * populate test data
00:00003A32 06000000        	  2168:             addi.b #0,d0
00:00003A36 67FE            	  2169:             beq.s *                       * Check Z Flag  beq/bne
00:00003A38 6BFE            	  2170:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A3A 65FE            	  2171:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003A3C 69FE            	  2172:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003A3E 06000010        	  2173:             addi.b #$10,d0
00:00003A42 67FE            	  2174:             beq.s *                       * Check Z Flag  beq/bne
00:00003A44 6AFE            	  2175:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003A46 65FE            	  2176:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003A48 68FE            	  2177:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003A4A 060000A5        	  2178:             addi.b #$A5,d0
00:00003A4E 67FE            	  2179:             beq.s *                       * Check Z Flag  beq/bne
00:00003A50 6BFE            	  2180:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A52 64FE            	  2181:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003A54 68FE            	  2182:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003A56 0C00002D        	  2183:             cmpi.b #$2D,d0
00:00003A5A 66FE            	  2184:             bne.s *                       * Check Z Flag  beq/bne
                            	  2185: 
                            	  2186: *     EA = Dn  - WORD
00:00003A5C 203C12345678    	  2187:             move.l #$12345678,d0      * populate test data
00:00003A62 06400000        	  2188:             addi.w #0,d0
00:00003A66 67FE            	  2189:             beq.s *                       * Check Z Flag  beq/bne
00:00003A68 6BFE            	  2190:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A6A 65FE            	  2191:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003A6C 69FE            	  2192:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003A6E 06407000        	  2193:             addi.w #$7000,d0
00:00003A72 67FE            	  2194:             beq.s *                       * Check Z Flag  beq/bne
00:00003A74 6AFE            	  2195:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003A76 65FE            	  2196:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003A78 68FE            	  2197:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003A7A 0640A55A        	  2198:             addi.w #$A55A,d0
00:00003A7E 67FE            	  2199:             beq.s *                       * Check Z Flag  beq/bne
00:00003A80 6BFE            	  2200:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A82 64FE            	  2201:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003A84 68FE            	  2202:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003A86 0C406BD2        	  2203:             cmpi.w #$6BD2,d0
00:00003A8A 66FE            	  2204:             bne.s *                       * Check Z Flag  beq/bne
                            	  2205: 
                            	  2206: *     EA = Dn  - LONG
00:00003A8C 203C12345678    	  2207:             move.l #$12345678,d0      * populate test data
00:00003A92 068000000000    	  2208:             addi.l #0,d0
00:00003A98 67FE            	  2209:             beq.s *                       * Check Z Flag  beq/bne
00:00003A9A 6BFE            	  2210:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A9C 65FE            	  2211:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003A9E 69FE            	  2212:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003AA0 0680F0000000    	  2213:             addi.l #$F0000000,d0
00:00003AA6 67FE            	  2214:             beq.s *                       * Check Z Flag  beq/bne
00:00003AA8 6BFE            	  2215:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003AAA 64FE            	  2216:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003AAC 69FE            	  2217:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003AAE 0680855AA55A    	  2218:             addi.l #$855AA55A,d0
00:00003AB4 67FE            	  2219:             beq.s *                       * Check Z Flag  beq/bne
00:00003AB6 6AFE            	  2220:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003AB8 65FE            	  2221:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003ABA 69FE            	  2222:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003ABC 0680A0000000    	  2223:             addi.l #$A0000000,d0
00:00003AC2 68FE            	  2224:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003AC4 0C80278EFBD2    	  2225:             cmpi.l #$278EFBD2,d0
00:00003ACA 66FE            	  2226:             bne.s *                       * Check Z Flag  beq/bne
                            	  2227: 
                            	  2228: 
                            	  2229: 
                            	  2230: *     EA = x.L  - Byte
00:00003ACC 207C0000F100    	  2231:             move.l #$F100,a0      * populate test data
00:00003AD2 20BC12345678    	  2232:             move.l #$12345678,(a0)     * populate test data
00:00003AD8 063900000000F103	  2233:             addi.b #0,$F103
00:00003AE0 67FE            	  2234:             beq.s *                       * Check Z Flag  beq/bne
00:00003AE2 6BFE            	  2235:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003AE4 65FE            	  2236:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003AE6 69FE            	  2237:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003AE8 063900100000F103	  2238:             addi.b #$10,$F103
00:00003AF0 67FE            	  2239:             beq.s *                       * Check Z Flag  beq/bne
00:00003AF2 6AFE            	  2240:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003AF4 65FE            	  2241:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003AF6 68FE            	  2242:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003AF8 063900A50000F103	  2243:             addi.b #$A5,$F103
00:00003B00 67FE            	  2244:             beq.s *                       * Check Z Flag  beq/bne
00:00003B02 6BFE            	  2245:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003B04 64FE            	  2246:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003B06 68FE            	  2247:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003B08 0C39002D0000F103	  2248:             cmpi.b #$2D,$F103
00:00003B10 66FE            	  2249:             bne.s *                       * Check Z Flag  beq/bne
                            	  2250: 
                            	  2251: *     EA = x.L- WORD
00:00003B12 207C0000F100    	  2252:             move.l #$F100,a0      * populate test data
00:00003B18 20BC12345678    	  2253:             move.l #$12345678,(a0)     * populate test data
00:00003B1E 067900000000F100	  2254:             addi.w #0,$F100
00:00003B26 67FE            	  2255:             beq.s *                       * Check Z Flag  beq/bne
00:00003B28 6BFE            	  2256:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003B2A 65FE            	  2257:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003B2C 69FE            	  2258:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003B2E 067970000000F100	  2259:             addi.w #$7000,$F100
00:00003B36 67FE            	  2260:             beq.s *                       * Check Z Flag  beq/bne
00:00003B38 6AFE            	  2261:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003B3A 65FE            	  2262:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003B3C 68FE            	  2263:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003B3E 0679A55A0000F100	  2264:             addi.w #$A55A,$F100
00:00003B46 67FE            	  2265:             beq.s *                       * Check Z Flag  beq/bne
00:00003B48 6BFE            	  2266:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003B4A 64FE            	  2267:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003B4C 68FE            	  2268:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003B4E 0C79278E0000F100	  2269:             cmpi.w #$278E,$F100
00:00003B56 66FE            	  2270:             bne.s *                       * Check Z Flag  beq/bne
                            	  2271: 
                            	  2272: *     EA = x.L- LONG
00:00003B58 23FC123456780000	  2273:             move.l #$12345678,$F100  * populate test data
00:00003B60 F100
00:00003B62 06B9000000000000	  2274:             addi.l #0,$F100
00:00003B6A F100
00:00003B6C 67FE            	  2275:             beq.s *                       * Check Z Flag  beq/bne
00:00003B6E 6BFE            	  2276:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003B70 65FE            	  2277:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003B72 69FE            	  2278:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003B74 06B9F00000000000	  2279:             addi.l #$F0000000,$F100
00:00003B7C F100
00:00003B7E 67FE            	  2280:             beq.s *                       * Check Z Flag  beq/bne
00:00003B80 6BFE            	  2281:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003B82 64FE            	  2282:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003B84 69FE            	  2283:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003B86 06B9855AA55A0000	  2284:             addi.l #$855AA55A,$F100
00:00003B8E F100
00:00003B90 67FE            	  2285:             beq.s *                       * Check Z Flag  beq/bne
00:00003B92 6AFE            	  2286:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003B94 65FE            	  2287:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003B96 69FE            	  2288:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003B98 06B9A00000000000	  2289:             addi.l #$A0000000,$F100
00:00003BA0 F100
00:00003BA2 68FE            	  2290:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003BA4 0CB9278EFBD20000	  2291:             cmpi.l #$278EFBD2,$F100
00:00003BAC F100
00:00003BAE 66FE            	  2292:             bne.s *                       * Check Z Flag  beq/bne
                            	  2293: 
00:00003BB0 4E75            	  2294:             rts
                            	  2295: 
                            	  2296: 
                            	  2297: *-----------------------------------------------------------
                            	  2298: *-----------------------------------------------------------
                            	  2299: * OPCODE : SUB_I
                            	  2300: *-----------------------------------------------------------
                            	  2301: *-----------------------------------------------------------
                            	  2302: op_SUB_I:
                            	  2303: 
                            	  2304: *     EA = Dn  - Byte
00:00003BB2 203C12345678    	  2305:             move.l #$12345678,d0      * populate test data
00:00003BB8 04000000        	  2306:             subi.b #0,d0
00:00003BBC 67FE            	  2307:             beq.s *                       * Check Z Flag  beq/bne
00:00003BBE 6BFE            	  2308:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003BC0 65FE            	  2309:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003BC2 69FE            	  2310:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003BC4 04000010        	  2311:             subi.b #$10,d0
00:00003BC8 67FE            	  2312:             beq.s *                       * Check Z Flag  beq/bne
00:00003BCA 6BFE            	  2313:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003BCC 65FE            	  2314:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003BCE 69FE            	  2315:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003BD0 040000A5        	  2316:             subi.b #$A5,d0
00:00003BD4 67FE            	  2317:             beq.s *                       * Check Z Flag  beq/bne
00:00003BD6 6AFE            	  2318:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003BD8 64FE            	  2319:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003BDA 68FE            	  2320:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003BDC 0C0000C3        	  2321:             cmpi.b #$C3,d0
00:00003BE0 66FE            	  2322:             bne.s *                       * Check Z Flag  beq/bne
                            	  2323: 
                            	  2324: *     EA = Dn  - WORD
00:00003BE2 203C12345678    	  2325:             move.l #$12345678,d0      * populate test data
00:00003BE8 04400000        	  2326:             subi.w #0,d0
00:00003BEC 67FE            	  2327:             beq.s *                       * Check Z Flag  beq/bne
00:00003BEE 6BFE            	  2328:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003BF0 65FE            	  2329:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003BF2 69FE            	  2330:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003BF4 04407000        	  2331:             subi.w #$7000,d0
00:00003BF8 67FE            	  2332:             beq.s *                       * Check Z Flag  beq/bne
00:00003BFA 6AFE            	  2333:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003BFC 64FE            	  2334:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003BFE 69FE            	  2335:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003C00 0440A55A        	  2336:             subi.w #$A55A,d0
00:00003C04 67FE            	  2337:             beq.s *                       * Check Z Flag  beq/bne
00:00003C06 6BFE            	  2338:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003C08 65FE            	  2339:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003C0A 69FE            	  2340:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003C0C 0C40411E        	  2341:             cmpi.w #$411E,d0
00:00003C10 66FE            	  2342:             bne.s *                       * Check Z Flag  beq/bne
                            	  2343: 
                            	  2344: *     EA = Dn  - LONG
00:00003C12 203C12345678    	  2345:             move.l #$12345678,d0      * populate test data
00:00003C18 048000000000    	  2346:             subi.l #0,d0
00:00003C1E 67FE            	  2347:             beq.s *                       * Check Z Flag  beq/bne
00:00003C20 6BFE            	  2348:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003C22 65FE            	  2349:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003C24 69FE            	  2350:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003C26 0480F0000000    	  2351:             subi.l #$F0000000,d0
00:00003C2C 67FE            	  2352:             beq.s *                       * Check Z Flag  beq/bne
00:00003C2E 6BFE            	  2353:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003C30 64FE            	  2354:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003C32 69FE            	  2355:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003C34 0480855AA55A    	  2356:             subi.l #$855AA55A,d0
00:00003C3A 67FE            	  2357:             beq.s *                       * Check Z Flag  beq/bne
00:00003C3C 6AFE            	  2358:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003C3E 64FE            	  2359:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003C40 68FE            	  2360:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003C42 0480A0000000    	  2361:             subi.l #$A0000000,d0
00:00003C48 69FE            	  2362:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003C4A 0C80FCD9B11E    	  2363:             cmpi.l #$FCD9B11E,d0
00:00003C50 66FE            	  2364:             bne.s *                       * Check Z Flag  beq/bne
                            	  2365: 
                            	  2366: 
                            	  2367: 
                            	  2368: *     EA = x.L  - Byte
00:00003C52 207C0000F100    	  2369:             move.l #$F100,a0      * populate test data
00:00003C58 20BC12345678    	  2370:             move.l #$12345678,(a0)     * populate test data
00:00003C5E 043900000000F103	  2371:             subi.b #0,$F103
00:00003C66 67FE            	  2372:             beq.s *                       * Check Z Flag  beq/bne
00:00003C68 6BFE            	  2373:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003C6A 65FE            	  2374:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003C6C 69FE            	  2375:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003C6E 043900100000F103	  2376:             subi.b #$10,$F103
00:00003C76 67FE            	  2377:             beq.s *                       * Check Z Flag  beq/bne
00:00003C78 6BFE            	  2378:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003C7A 65FE            	  2379:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003C7C 69FE            	  2380:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003C7E 043900A50000F103	  2381:             subi.b #$A5,$F103
00:00003C86 67FE            	  2382:             beq.s *                       * Check Z Flag  beq/bne
00:00003C88 6AFE            	  2383:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003C8A 64FE            	  2384:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003C8C 68FE            	  2385:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003C8E 0C3900C30000F103	  2386:             cmpi.b #$C3,$F103
00:00003C96 66FE            	  2387:             bne.s *                       * Check Z Flag  beq/bne
                            	  2388: 
                            	  2389: *     EA = x.L- WORD
00:00003C98 207C0000F100    	  2390:             move.l #$F100,a0      * populate test data
00:00003C9E 20BC12345678    	  2391:             move.l #$12345678,(a0)     * populate test data
00:00003CA4 047900000000F100	  2392:             subi.w #0,$F100
00:00003CAC 67FE            	  2393:             beq.s *                       * Check Z Flag  beq/bne
00:00003CAE 6BFE            	  2394:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003CB0 65FE            	  2395:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003CB2 69FE            	  2396:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003CB4 047970000000F100	  2397:             subi.w #$7000,$F100
00:00003CBC 67FE            	  2398:             beq.s *                       * Check Z Flag  beq/bne
00:00003CBE 6AFE            	  2399:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003CC0 64FE            	  2400:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003CC2 69FE            	  2401:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003CC4 0479A55A0000F100	  2402:             subi.w #$A55A,$F100
00:00003CCC 67FE            	  2403:             beq.s *                       * Check Z Flag  beq/bne
00:00003CCE 6AFE            	  2404:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003CD0 64FE            	  2405:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003CD2 69FE            	  2406:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003CD4 0C79FCDA0000F100	  2407:             cmpi.w #$FCDA,$F100
00:00003CDC 66FE            	  2408:             bne.s *                       * Check Z Flag  beq/bne
                            	  2409: 
                            	  2410: *     EA = x.L- LONG
00:00003CDE 23FC123456780000	  2411:             move.l #$12345678,$F100  * populate test data
00:00003CE6 F100
00:00003CE8 04B9000000000000	  2412:             subi.l #0,$F100
00:00003CF0 F100
00:00003CF2 67FE            	  2413:             beq.s *                       * Check Z Flag  beq/bne
00:00003CF4 6BFE            	  2414:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003CF6 65FE            	  2415:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003CF8 69FE            	  2416:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003CFA 04B9F00000000000	  2417:             subi.l #$F0000000,$F100
00:00003D02 F100
00:00003D04 67FE            	  2418:             beq.s *                       * Check Z Flag  beq/bne
00:00003D06 6BFE            	  2419:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003D08 64FE            	  2420:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003D0A 69FE            	  2421:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003D0C 04B9855AA55A0000	  2422:             subi.l #$855AA55A,$F100
00:00003D14 F100
00:00003D16 67FE            	  2423:             beq.s *                       * Check Z Flag  beq/bne
00:00003D18 6AFE            	  2424:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003D1A 64FE            	  2425:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003D1C 68FE            	  2426:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003D1E 04B9A00000000000	  2427:             subi.l #$A0000000,$F100
00:00003D26 F100
00:00003D28 69FE            	  2428:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003D2A 0CB9FCD9B11E0000	  2429:             cmpi.l #$FCD9B11E,$F100
00:00003D32 F100
00:00003D34 66FE            	  2430:             bne.s *                       * Check Z Flag  beq/bne
                            	  2431: 
00:00003D36 4E75            	  2432:             rts
                            	  2433: 
                            	  2434: 
                            	  2435: 
                            	  2436: *-----------------------------------------------------------
                            	  2437: *-----------------------------------------------------------
                            	  2438: * OPCODE : MOVE
                            	  2439: *-----------------------------------------------------------
                            	  2440: *-----------------------------------------------------------
                            	  2441: op_MOVE:
00:00003D38 203C11223344    	  2442:             move.l #$11223344,d0
00:00003D3E 223C55667788    	  2443:             move.l #$55667788,d1
00:00003D44 243C8899AABB    	  2444:             move.l #$8899aabb,d2
00:00003D4A 263CCCDDEEFF    	  2445:             move.l #$ccddeeff,d3
00:00003D50 7800            	  2446:             moveq  #$00000000,d4
00:00003D52 7A00            	  2447:             moveq  #$00000000,d5
00:00003D54 7C00            	  2448:             moveq  #$00000000,d6
00:00003D56 7E00            	  2449:             moveq  #$00000000,d7
00:00003D58 207C44332211    	  2450:             move.l #$44332211,a0
00:00003D5E 227C88776655    	  2451:             move.l #$88776655,a1
00:00003D64 247CBBAA9988    	  2452:             move.l #$bbaa9988,a2
00:00003D6A 267CFFEEDDCC    	  2453:             move.l #$ffeeddcc,a3
                            	  2454: 
00:00003D70 1800            	  2455:             move.b d0,d4              * BYTE - DATA REGISTER
00:00003D72 67FE            	  2456:             beq.s *                       * Check Z Flag  beq/bne
00:00003D74 6BFE            	  2457:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003D76 0C8400000044    	  2458:             cmpi.l #$00000044,d4
00:00003D7C 66FE            	  2459:             bne.s *                       * Check Z Flag  beq/bne
                            	  2460: 
00:00003D7E 3A01            	  2461:             move.w d1,d5              * WORD - DATA REGISTER
00:00003D80 67FE            	  2462:             beq.s *                       * Check Z Flag  beq/bne
00:00003D82 6BFE            	  2463:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003D84 0C8500007788    	  2464:             cmpi.l #$00007788,d5
00:00003D8A 66FE            	  2465:             bne.s *                       * Check Z Flag  beq/bne
                            	  2466: 
00:00003D8C 2C02            	  2467:             move.l d2,d6              * LONG - DATA REGISTER
00:00003D8E 67FE            	  2468:             beq.s *                       * Check Z Flag  beq/bne
00:00003D90 6AFE            	  2469:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003D92 0C868899AABB    	  2470:             cmpi.l #$8899aabb,d6
00:00003D98 66FE            	  2471:             bne.s *                       * Check Z Flag  beq/bne
                            	  2472: 
00:00003D9A 3A09            	  2473:             move.w a1,d5              * WORD - ADDRESS REGISTER
00:00003D9C 67FE            	  2474:             beq.s *                       * Check Z Flag  beq/bne
00:00003D9E 6BFE            	  2475:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003DA0 0C8500006655    	  2476:             cmpi.l #$00006655,d5
00:00003DA6 66FE            	  2477:             bne.s *                       * Check Z Flag  beq/bne
                            	  2478: 
00:00003DA8 2C0A            	  2479:             move.l a2,d6              * LONG - ADDRESS REGISTER
00:00003DAA 67FE            	  2480:             beq.s *                       * Check Z Flag  beq/bne
00:00003DAC 6AFE            	  2481:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003DAE 0C86BBAA9988    	  2482:             cmpi.l #$bbaa9988,d6
00:00003DB4 66FE            	  2483:             bne.s *                       * Check Z Flag  beq/bne
                            	  2484: 
                            	  2485: 
00:00003DB6 3842            	  2486:             movea.w d2,a4             * WORD - ADDRESS REGISTER as SOURCE ## MOVEA
00:00003DB8 B9C2            	  2487:             cmpa.l d2,a4
00:00003DBA 67FE            	  2488:             beq.s *                       * Check Z Flag  beq/bne ## comopare fails because A4 was sign extended
                            	  2489: 
00:00003DBC 2A41            	  2490:             movea.l d1,a5             * LONG - ADDRESS REGISTER as SOURCE ## MOVEA
00:00003DBE BBC1            	  2491:             cmpa.l d1,a5
00:00003DC0 66FE            	  2492:             bne.s *                       * Check Z Flag  beq/bne
                            	  2493: 
                            	  2494: 
                            	  2495: 
                            	  2496: *   Too mamy EA combinations to test,so we focus on a few of the more complicted EA's
                            	  2497: 
00:00003DC2 203C11223344    	  2498:             move.l #$11223344,d0
00:00003DC8 223C00010100    	  2499:             move.l #$00010100,d1
00:00003DCE 243C8899AABB    	  2500:             move.l #$8899aabb,d2
00:00003DD4 7601            	  2501:             moveq  #$00000001,d3
00:00003DD6 7800            	  2502:             moveq  #$00000000,d4
00:00003DD8 7A00            	  2503:             moveq  #$00000000,d5
00:00003DDA 7C00            	  2504:             moveq  #$00000000,d6
00:00003DDC 7E00            	  2505:             moveq  #$00000000,d7
00:00003DDE 91C8            	  2506:             move.l #$00000000,a0
00:00003DE0 227C00010100    	  2507:             move.l #$00010100,a1
                            	  2508: 
                            	  2509: *     x(An,AL) --> x.L
00:00003DE6 11BC005A9804    	  2510:             move.b #$5A,4(a0,a1.l)    * BYTE
00:00003DEC 47F09804        	  2511:             lea 4(a0,a1.l),a3
00:00003DF0 13F0980400010105	  2512:             move.b 4(a0,a1.l),$00010105
00:00003DF8 67FE            	  2513:             beq.s *                       * Check Z Flag  beq/bne
00:00003DFA 6BFE            	  2514:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003DFC 0C30005A9805    	  2515:             cmpi.b #$5A,5(a0,a1.l)
00:00003E02 66FE            	  2516:             bne.s *                       * Check Z Flag  beq/bne
                            	  2517: 
                            	  2518: *     x.L --> n(An,Dw)
00:00003E04 11B9000101051007	  2519: MOVE2:      move.b  $00010105,7(a0,d1.w)    * BYTE
00:00003E0C 67FE            	  2520:             beq.s *                       * Check Z Flag  beq/bne
00:00003E0E 6BFE            	  2521:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003E10 0C30005A1007    	  2522:             cmpi.b #$5A,7(a0,d1.w)
00:00003E16 66FE            	  2523:             bne.s *                       * Check Z Flag  beq/bne
                            	  2524: 
                            	  2525: *     x(PC,Ds) --> x.w
00:00003E18 11FB30660100    	  2526:             move.b  MOVE1(pc,d3.w),$0100 * BYTE
00:00003E1E 67FE            	  2527:             beq.s *                       * Check Z Flag  beq/bne
00:00003E20 6AFE            	  2528:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003E22 0C3900B900003E05	  2529:             cmpi.b #$B9,1+MOVE2
00:00003E2A 66FE            	  2530:             bne.s *                       * Check Z Flag  beq/bne
                            	  2531: 
                            	  2532: *     #x -->    n(An,AL)
00:00003E2C 11BC00781007    	  2533:             move.b  #$78,7(a0,d1.w)    * BYTE
00:00003E32 67FE            	  2534:             beq.s *                       * Check Z Flag  beq/bne
00:00003E34 6BFE            	  2535:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003E36 0C3000781007    	  2536:             cmpi.b #$78,7(a0,d1.w)
00:00003E3C 66FE            	  2537:             bne.s *                       * Check Z Flag  beq/bne
                            	  2538: 
00:00003E3E 203C11223344    	  2539:             move.l #$11223344,d0
00:00003E44 223C00010100    	  2540:             move.l #$00010100,d1
00:00003E4A 243C8899AABB    	  2541:             move.l #$8899aabb,d2
00:00003E50 7602            	  2542:             moveq  #$00000002,d3
00:00003E52 7800            	  2543:             moveq  #$00000000,d4
00:00003E54 7A00            	  2544:             moveq  #$00000000,d5
00:00003E56 7C00            	  2545:             moveq  #$00000000,d6
00:00003E58 7E00            	  2546:             moveq  #$00000000,d7
00:00003E5A 91C8            	  2547:             move.l #$00000000,a0
00:00003E5C 227C00010100    	  2548:             move.l #$00010100,a1
                            	  2549: 
                            	  2550: *     x(An,AL) --> x.L
00:00003E62 31BC5A5A9804    	  2551:             move.w #$5A5A,4(a0,a1.l)    * WORD
00:00003E68 49F09804        	  2552:             lea 4(a0,a1.l),a4
00:00003E6C 33F0980400010104	  2553:             move.w 4(a0,a1.l),$00010104
00:00003E74 67FE            	  2554:             beq.s *                       * Check Z Flag  beq/bne
00:00003E76 6BFE            	  2555:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003E78 0C705A5A9804    	  2556:             cmpi.w #$5A5A,4(a0,a1.l)
00:00003E7E 66FE            	  2557:             bne.s *                       * Check Z Flag  beq/bne
                            	  2558: 
                            	  2559: *     x.L --> n(An,Dw)
00:00003E80 31B9000101041006	  2560: MOVE1:      move.w  $00010104,6(a0,d1.w)    * WORD
00:00003E88 67FE            	  2561:             beq.s *                       * Check Z Flag  beq/bne
00:00003E8A 6BFE            	  2562:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003E8C 0C705A5A1006    	  2563:             cmpi.w #$5A5A,6(a0,d1.w)
00:00003E92 66FE            	  2564:             bne.s *                       * Check Z Flag  beq/bne
                            	  2565: 
                            	  2566: *     x(PC,Ds) --> x.w
00:00003E94 31FB30EA0100    	  2567:             move.w  MOVE1(pc,d3),$0100 * WORD
00:00003E9A 67FE            	  2568:             beq.s *                       * Check Z Flag  beq/bne
00:00003E9C 6BFE            	  2569:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003E9E 0C7967FE00003E88	  2570:             cmpi.w #$67FE,8+MOVE1
00:00003EA6 66FE            	  2571:             bne.s *                       * Check Z Flag  beq/bne
                            	  2572: 
                            	  2573: *     #x -->    n(An,AL)
00:00003EA8 31BC78781006    	  2574:             move.w  #$7878,6(a0,d1.w)    * WORD
00:00003EAE 67FE            	  2575:             beq.s *                       * Check Z Flag  beq/bne
00:00003EB0 6BFE            	  2576:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003EB2 0C7078781006    	  2577:             cmpi.w #$7878,6(a0,d1.w)
00:00003EB8 66FE            	  2578:             bne.s *                       * Check Z Flag  beq/bne
                            	  2579: 
                            	  2580: * ---
                            	  2581: 
00:00003EBA 203C11223344    	  2582:             move.l #$11223344,d0
00:00003EC0 223C00010100    	  2583:             move.l #$00010100,d1
00:00003EC6 243C8899AABB    	  2584:             move.l #$8899aabb,d2
00:00003ECC 7602            	  2585:             moveq  #$00000002,d3
00:00003ECE 7800            	  2586:             moveq  #$00000000,d4
00:00003ED0 7A00            	  2587:             moveq  #$00000000,d5
00:00003ED2 7C00            	  2588:             moveq  #$00000000,d6
00:00003ED4 7E00            	  2589:             moveq  #$00000000,d7
00:00003ED6 91C8            	  2590:             move.l #$00000000,a0
00:00003ED8 227C00010100    	  2591:             move.l #$00010100,a1
                            	  2592: 
                            	  2593: *     x(An,AL) --> x.L
00:00003EDE 21BC5A5A12349804	  2594:             move.l #$5A5A1234,4(a0,a1.l)    * LONG
00:00003EE6 49F09804        	  2595:             lea 4(a0,a1.l),a4
00:00003EEA 23F0980400010104	  2596:             move.l 4(a0,a1.l),$00010104
00:00003EF2 67FE            	  2597:             beq.s *                       * Check Z Flag  beq/bne
00:00003EF4 6BFE            	  2598:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003EF6 0CB05A5A12349804	  2599:             cmpi.l #$5A5A1234,4(a0,a1.l)
00:00003EFE 66FE            	  2600:             bne.s *                       * Check Z Flag  beq/bne
                            	  2601: 
                            	  2602: *     x.L --> n(An,Dw)
00:00003F00 21B9000101041006	  2603: MOVE3:      move.l  $00010104,6(a0,d1.w)    * LONG
00:00003F08 67FE            	  2604:             beq.s *                       * Check Z Flag  beq/bne
00:00003F0A 6BFE            	  2605:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003F0C 0CB05A5A12341006	  2606:             cmpi.l #$5A5A1234,6(a0,d1.w)
00:00003F14 66FE            	  2607:             bne.s *                       * Check Z Flag  beq/bne
                            	  2608: 
                            	  2609: *     x(PC,Ds) --> x.w
00:00003F16 21FB30E80100    	  2610:             move.l  MOVE3(pc,d3),$0100 * LONG
00:00003F1C 67FE            	  2611:             beq.s *                       * Check Z Flag  beq/bne
00:00003F1E 6BFE            	  2612:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003F20 0CB967FE6BFE0000	  2613:             cmpi.l #$67FE6BFE,8+MOVE3
00:00003F28 3F08
00:00003F2A 66FE            	  2614:             bne.s *                       * Check Z Flag  beq/bne
                            	  2615: 
                            	  2616: *     #x -->    n(An,AL)
00:00003F2C 21BC787823231006	  2617:             move.l  #$78782323,6(a0,d1.w)    * LONG
00:00003F34 67FE            	  2618:             beq.s *                       * Check Z Flag  beq/bne
00:00003F36 6BFE            	  2619:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003F38 0CB0787823231006	  2620:             cmpi.l #$78782323,6(a0,d1.w)
00:00003F40 66FE            	  2621:             bne.s *                       * Check Z Flag  beq/bne
                            	  2622: 
                            	  2623: 
00:00003F42 4E75            	  2624:          rts
                            	  2625: 
                            	  2626: 
                            	  2627: *-----------------------------------------------------------
                            	  2628: *-----------------------------------------------------------
                            	  2629: * OPCODE : MOVE_xxx_FLAGS
                            	  2630: *-----------------------------------------------------------
                            	  2631: *-----------------------------------------------------------
                            	  2632: op_MOVE_xxx_FLAGS:
                            	  2633: 
                            	  2634: *     Move_To_SR
                            	  2635: 
                            	  2636: *     Dn
                            	  2637: 
00:00003F44 303C2FFF        	  2638:             move.w #$2FFF,d0
00:00003F48 46C0            	  2639:             move.w d0,SR
00:00003F4A 6AFE            	  2640:             bpl.s *           * branch if Z clear
00:00003F4C 66FE            	  2641:             bne.s *           * branch if N clear
00:00003F4E 68FE            	  2642:             bvc.s *           * branch if V clear
00:00003F50 64FE            	  2643:             bcc.s *           * branch if C clear
00:00003F52 303C2F00        	  2644:             move.w #$2F00,d0
00:00003F56 44C0            	  2645:             move d0,CCR
00:00003F58 67FE            	  2646:             beq.s *           * branch if Z set
00:00003F5A 6BFE            	  2647:             bmi.s *           * branch if N set
00:00003F5C 69FE            	  2648:             bvs.s *           * branch if V set
00:00003F5E 65FE            	  2649:             bcs.s *           * branch if C set
                            	  2650: 
00:00003F60 303C2000        	  2651:             move.w #$2000,d0
00:00003F64 46C0            	  2652:             move.w d0,SR
00:00003F66 67FE            	  2653:             beq.s *           * branch if Z set
00:00003F68 6BFE            	  2654:             bmi.s *           * branch if N set
00:00003F6A 69FE            	  2655:             bvs.s *           * branch if V set
00:00003F6C 65FE            	  2656:             bcs.s *           * branch if C set
                            	  2657: 
                            	  2658: *     (An)
00:00003F6E 307C0100        	  2659:             move.l #$00000100,a0
00:00003F72 30BC2FFF        	  2660:             move.w #$2FFF,(a0)
00:00003F76 46D0            	  2661:             move.w (a0),SR
00:00003F78 6AFE            	  2662:             bpl.s *           * branch if Z clear
00:00003F7A 66FE            	  2663:             bne.s *           * branch if N clear
00:00003F7C 68FE            	  2664:             bvc.s *           * branch if V clear
00:00003F7E 64FE            	  2665:             bcc.s *           * branch if C clear
                            	  2666: 
00:00003F80 30BC2000        	  2667:             move.w #$2000,(a0)
00:00003F84 46D0            	  2668:             move.w (a0),SR
00:00003F86 67FE            	  2669:             beq.s *           * branch if Z set
00:00003F88 6BFE            	  2670:             bmi.s *           * branch if N set
00:00003F8A 69FE            	  2671:             bvs.s *           * branch if V set
00:00003F8C 65FE            	  2672:             bcs.s *           * branch if C set
                            	  2673: 
                            	  2674: *     (An)+
00:00003F8E 307C0100        	  2675:             move.l #$00000100,a0
00:00003F92 30BC2FFF        	  2676:             move.w #$2FFF,(a0)
00:00003F96 46D8            	  2677:             move.w (a0)+,SR
00:00003F98 6AFE            	  2678:             bpl.s *           * branch if Z clear
00:00003F9A 66FE            	  2679:             bne.s *           * branch if N clear
00:00003F9C 68FE            	  2680:             bvc.s *           * branch if V clear
00:00003F9E 64FE            	  2681:             bcc.s *           * branch if C clear
                            	  2682: 
00:00003FA0 30BC2000        	  2683:             move.w #$2000,(a0)
00:00003FA4 46D8            	  2684:             move.w (a0)+,SR
00:00003FA6 67FE            	  2685:             beq.s *           * branch if Z set
00:00003FA8 6BFE            	  2686:             bmi.s *           * branch if N set
00:00003FAA 69FE            	  2687:             bvs.s *           * branch if V set
00:00003FAC 65FE            	  2688:             bcs.s *           * branch if C set
                            	  2689: 
                            	  2690: *     -(An)
00:00003FAE 307C0102        	  2691:             move.l #$00000102,a0
00:00003FB2 30BC2FFF        	  2692:             move.w #$2FFF,(a0)
00:00003FB6 46D8            	  2693:             move.w (a0)+,SR
00:00003FB8 6AFE            	  2694:             bpl.s *           * branch if Z clear
00:00003FBA 66FE            	  2695:             bne.s *           * branch if N clear
00:00003FBC 68FE            	  2696:             bvc.s *           * branch if V clear
00:00003FBE 64FE            	  2697:             bcc.s *           * branch if C clear
                            	  2698: 
00:00003FC0 30BC2000        	  2699:             move.w #$2000,(a0)
00:00003FC4 46D8            	  2700:             move.w (a0)+,SR
00:00003FC6 67FE            	  2701:             beq.s *           * branch if Z set
00:00003FC8 6BFE            	  2702:             bmi.s *           * branch if N set
00:00003FCA 69FE            	  2703:             bvs.s *           * branch if V set
00:00003FCC 65FE            	  2704:             bcs.s *           * branch if C set
                            	  2705: 
                            	  2706: *     n(An)
00:00003FCE 307C0102        	  2707:             move.l #$00000102,a0
00:00003FD2 317C2FFF0002    	  2708:             move.w #$2FFF,2(a0)
00:00003FD8 46E80002        	  2709:             move.w 2(a0),SR
00:00003FDC 6AFE            	  2710:             bpl.s *           * branch if Z clear
00:00003FDE 66FE            	  2711:             bne.s *           * branch if N clear
00:00003FE0 68FE            	  2712:             bvc.s *           * branch if V clear
00:00003FE2 64FE            	  2713:             bcc.s *           * branch if C clear
                            	  2714: 
00:00003FE4 317C20000002    	  2715:             move.w #$2000,2(a0)
00:00003FEA 46E80002        	  2716:             move.w 2(a0),SR
00:00003FEE 67FE            	  2717:             beq.s *           * branch if Z set
00:00003FF0 6BFE            	  2718:             bmi.s *           * branch if N set
00:00003FF2 69FE            	  2719:             bvs.s *           * branch if V set
00:00003FF4 65FE            	  2720:             bcs.s *           * branch if C set
                            	  2721: 
                            	  2722: *     n(An,Rn.l)
00:00003FF6 307C0100        	  2723:             move.l #$00000100,a0
00:00003FFA 7002            	  2724:             moveq  #$00000002,d0
00:00003FFC 31BC2FFF0802    	  2725:             move.w #$2FFF,2(a0,d0.l)
00:00004002 46F00802        	  2726:             move.w 2(a0,d0.l),SR
00:00004006 6AFE            	  2727:             bpl.s *           * branch if Z clear
00:00004008 66FE            	  2728:             bne.s *           * branch if N clear
00:0000400A 68FE            	  2729:             bvc.s *           * branch if V clear
00:0000400C 64FE            	  2730:             bcc.s *           * branch if C clear
                            	  2731: 
00:0000400E 31BC20000802    	  2732:             move.w #$2000,2(a0,d0.l)
00:00004014 46F00802        	  2733:             move.w 2(a0,d0.l),SR
00:00004018 67FE            	  2734:             beq.s *           * branch if Z set
00:0000401A 6BFE            	  2735:             bmi.s *           * branch if N set
00:0000401C 69FE            	  2736:             bvs.s *           * branch if V set
00:0000401E 65FE            	  2737:             bcs.s *           * branch if C set
                            	  2738: 
                            	  2739: *     x.W
00:00004020 31FC2FFF0100    	  2740:             move.w #$2FFF,$0100
00:00004026 46F80100        	  2741:             move.w $0100,SR
00:0000402A 6AFE            	  2742:             bpl.s *           * branch if Z clear
00:0000402C 66FE            	  2743:             bne.s *           * branch if N clear
00:0000402E 68FE            	  2744:             bvc.s *           * branch if V clear
00:00004030 64FE            	  2745:             bcc.s *           * branch if C clear
                            	  2746: 
00:00004032 31FC20000100    	  2747:             move.w #$2000,$0100
00:00004038 46F80100        	  2748:             move.w $0100,SR
00:0000403C 67FE            	  2749:             beq.s *           * branch if Z set
00:0000403E 6BFE            	  2750:             bmi.s *           * branch if N set
00:00004040 69FE            	  2751:             bvs.s *           * branch if V set
00:00004042 65FE            	  2752:             bcs.s *           * branch if C set
                            	  2753: 
                            	  2754: *     x.L
00:00004044 33FC2FFF00010100	  2755:             move.w #$2FFF,$00010100
00:0000404C 46F900010100    	  2756:             move.w $00010100,SR
00:00004052 6AFE            	  2757:             bpl.s *           * branch if Z clear
00:00004054 66FE            	  2758:             bne.s *           * branch if N clear
00:00004056 68FE            	  2759:             bvc.s *           * branch if V clear
00:00004058 64FE            	  2760:             bcc.s *           * branch if C clear
                            	  2761: 
00:0000405A 33FC200000010100	  2762: MOVE4:      move.w #$2000,$00010100
00:00004062 46F900010100    	  2763:             move.w $00010100,SR
00:00004068 67FE            	  2764:             beq.s *           * branch if Z set
00:0000406A 6BFE            	  2765:             bmi.s *           * branch if N set
00:0000406C 69FE            	  2766:             bvs.s *           * branch if V set
00:0000406E 65FE            	  2767:             bcs.s *           * branch if C set
                            	  2768: 
                            	  2769: *     x(PC)
00:00004070 46FAFFEA        	  2770:             move.w MOVE4+2(pc),SR
00:00004074 67FE            	  2771:             beq.s *           * branch if Z set
00:00004076 6BFE            	  2772:             bmi.s *           * branch if N set
00:00004078 69FE            	  2773:             bvs.s *           * branch if V set
00:0000407A 65FE            	  2774:             bcs.s *           * branch if C set
                            	  2775: 
                            	  2776: *     x(PC,d0.l)
00:0000407C 7000            	  2777:             moveq  #$00000000,d0
00:0000407E 46FB08DC        	  2778:             move.w MOVE4+2(pc,d0.l),SR
00:00004082 67FE            	  2779:             beq.s *           * branch if Z set
00:00004084 6BFE            	  2780:             bmi.s *           * branch if N set
00:00004086 69FE            	  2781:             bvs.s *           * branch if V set
00:00004088 65FE            	  2782:             bcs.s *           * branch if C set
00:0000408A 44FB08D0        	  2783:             move MOVE4+2(pc,d0.l),CCR
00:0000408E 67FE            	  2784:             beq.s *           * branch if Z set
00:00004090 6BFE            	  2785:             bmi.s *           * branch if N set
00:00004092 69FE            	  2786:             bvs.s *           * branch if V set
00:00004094 65FE            	  2787:             bcs.s *           * branch if C set
                            	  2788: 
                            	  2789: *     #x
00:00004096 46FC2FFF        	  2790:             move.w #$2FFF,SR
00:0000409A 66FE            	  2791:             bne.s *           * branch if Z clear
00:0000409C 6AFE            	  2792:             bpl.s *           * branch if N clear
00:0000409E 68FE            	  2793:             bvc.s *           * branch if V clear
00:000040A0 64FE            	  2794:             bcc.s *           * branch if C clear
                            	  2795: 
                            	  2796: 
                            	  2797: 
                            	  2798: *  MOVE_From_SR
                            	  2799: 
                            	  2800: 
                            	  2801: 
                            	  2802: *     Dn
00:000040A2 46FC275A        	  2803:             move.w #$275A,SR          * Initial value
00:000040A6 40C0            	  2804:             move.w SR,d0
00:000040A8 0C40271A        	  2805:             cmpi.w #$271A,d0
                            	  2806: * The following fails because sr bits are implemented and non-zero so later code works.           
                            	  2807: *            bne.s *                   * branch if Z set
                            	  2808: 
                            	  2809: *     (An)
00:000040AC 307C0100        	  2810:             move.l #$00000100,a0
00:000040B0 46FC275A        	  2811:             move.w #$275A,SR          * Initial value
00:000040B4 40D0            	  2812:             move.w SR,(a0)
00:000040B6 0C50275A        	  2813:             cmpi.w #$275A,(a0)
00:000040BA 66FE            	  2814:             bne.s *                   * branch if Z set
                            	  2815: 
                            	  2816: *     (An)+
00:000040BC 307C0100        	  2817:             move.l #$00000100,a0
00:000040C0 46FC257A        	  2818:             move.w #$257A,SR          * Initial value
00:000040C4 40D8            	  2819:             move.w SR,(a0)+
00:000040C6 307C0100        	  2820:             move.l #$00000100,a0
00:000040CA 0C58257A        	  2821:             cmpi.w #$257A,(a0)+
00:000040CE 66FE            	  2822:             bne.s *                   * branch if Z set
                            	  2823: 
                            	  2824: *     -(An)
00:000040D0 307C0102        	  2825:             move.l #$00000102,a0
00:000040D4 46FC2766        	  2826:             move.w #$2766,SR          * Initial value
00:000040D8 40E0            	  2827:             move.w SR,-(a0)
00:000040DA 307C0100        	  2828:             move.l #$00000100,a0
00:000040DE 0C502766        	  2829:             cmpi.w #$2766,(a0)
00:000040E2 66FE            	  2830:             bne.s *                   * branch if Z set
                            	  2831: 
                            	  2832: *     x(An)
00:000040E4 307C0102        	  2833:             move.l #$00000102,a0
00:000040E8 46FC2733        	  2834:             move.w #$2733,SR          * Initial value
00:000040EC 40E80004        	  2835:             move.w SR,4(a0)
00:000040F0 0C6827330004    	  2836:             cmpi.w #$2733,4(a0)
00:000040F6 66FE            	  2837:             bne.s *                   * branch if Z set
                            	  2838: 
                            	  2839: *     x(An,rn)
00:000040F8 307C0102        	  2840:             move.l #$00000102,a0
00:000040FC 7004            	  2841:             moveq  #$00000004,d0
00:000040FE 46FC275A        	  2842:             move.w #$275a,SR          * Initial value
00:00004102 40F00804        	  2843:             move.w SR,4(a0,d0.l)
00:00004106 0C70275A0804    	  2844:             cmpi.w #$275a,4(a0,d0.l)
00:0000410C 66FE            	  2845:             bne.s *                   * branch if Z set
                            	  2846: 
                            	  2847: *     x.W
00:0000410E 46FC2777        	  2848:             move.w #$2777,SR          * Initial value
00:00004112 40F80102        	  2849:             move.w SR,$0102
00:00004116 0C7827770102    	  2850:             cmpi.w #$2777,$0102
00:0000411C 66FE            	  2851:             bne.s *                   * branch if Z set
                            	  2852: 
                            	  2853: *     x.L
00:0000411E 46FC2777        	  2854:             move.w #$2777,SR          * Initial value
00:00004122 40F900010102    	  2855:             move.w SR,$10102
00:00004128 0C79277700010102	  2856:             cmpi.w #$2777,$10102
00:00004130 66FE            	  2857:             bne.s *                   * branch if Z set
                            	  2858: 
                            	  2859: 
                            	  2860: 
00:00004132 46FC2700        	  2861:             move.w #$2700,SR          * Put flags back to initial value
                            	  2862: 
00:00004136 4E75            	  2863:             rts
                            	  2864: 
                            	  2865: 
                            	  2866: *-----------------------------------------------------------
                            	  2867: *-----------------------------------------------------------
                            	  2868: * OPCODE : EXT
                            	  2869: *-----------------------------------------------------------
                            	  2870: *-----------------------------------------------------------
                            	  2871: op_EXT:
                            	  2872: 
00:00004138 707F            	  2873:             move.l #$0000007F,d0
00:0000413A 223C00008FFF    	  2874:             move.l #$00008FFF,d1
00:00004140 7400            	  2875:             moveq  #$00000000,d2
                            	  2876: 
00:00004142 4880            	  2877:             ext.w d0
00:00004144 6BFE            	  2878:             bmi.s *                   * Check N Flag  bmi/bpl
00:00004146 67FE            	  2879:             beq.s *                   * Check Z Flag  beq/bne
00:00004148 0C800000007F    	  2880:             cmpi.l #$0000007F,d0
00:0000414E 66FE            	  2881:             bne.s *                   * branch if Z set
                            	  2882: 
00:00004150 48C1            	  2883:             ext.l d1
00:00004152 6AFE            	  2884:             bpl.s *                   * Check N Flag  bmi/bpl
00:00004154 67FE            	  2885:             beq.s *                   * Check Z Flag  beq/bne
00:00004156 0C81FFFF8FFF    	  2886:             cmpi.l #$FFFF8FFF,d1
00:0000415C 66FE            	  2887:             bne.s *                   * branch if Z set
                            	  2888: 
00:0000415E 48C2            	  2889:             ext.l d2
00:00004160 66FE            	  2890:             bne.s *                   * Check Z Flag  beq/bne
                            	  2891: 
                            	  2892: 
                            	  2893: 
00:00004162 4E75            	  2894:             rts
                            	  2895: 
                            	  2896: 
                            	  2897: *-----------------------------------------------------------
                            	  2898: *-----------------------------------------------------------
                            	  2899: * OPCODE : SWAP
                            	  2900: *-----------------------------------------------------------
                            	  2901: *-----------------------------------------------------------
                            	  2902: op_SWAP:
                            	  2903: 
00:00004164 203C12345678    	  2904:             move.l #$12345678,d0
                            	  2905: 
00:0000416A 4840            	  2906:             swap d0
00:0000416C 6BFE            	  2907:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000416E 67FE            	  2908:             beq.s *                   * Check Z Flag  beq/bne
00:00004170 0C8056781234    	  2909:             cmpi.l #$56781234,d0
00:00004176 66FE            	  2910:             bne.s *                   * branch if Z set
                            	  2911: 
                            	  2912: 
                            	  2913: 
00:00004178 4E75            	  2914:             rts
                            	  2915: 
                            	  2916: 
                            	  2917: *-----------------------------------------------------------
                            	  2918: *-----------------------------------------------------------
                            	  2919: * OPCODE : LEA_PEA
                            	  2920: *-----------------------------------------------------------
                            	  2921: *-----------------------------------------------------------
                            	  2922: op_LEAPEA:
                            	  2923: 
00:0000417A 207C00345678    	  2924:             move.l #$00345678,a0
00:00004180 7800            	  2925:             moveq  #$00000000,d4
                            	  2926: 
                            	  2927: *     (An)
00:00004182 4DD0            	  2928:             lea (a0),a6
00:00004184 200E            	  2929:             move.l a6,d0
00:00004186 0C8000345678    	  2930:             cmpi.l #$00345678,d0
00:0000418C 66FE            	  2931:             bne.s *                   * branch if Z set
00:0000418E 4850            	  2932:             pea (a0)
00:00004190 0C9700345678    	  2933:             cmpi.l #$00345678,(a7)
00:00004196 66FE            	  2934:             bne.s *                   * branch if Z set
                            	  2935:             * This was without a specifier which the assembler defaulted to .w
00:00004198 588F            	  2936:             addq.l #4,a7            * Restore Stack Pointer
                            	  2937: 
                            	  2938: *     x(An)
00:0000419A 4DE80004        	  2939:             lea 4(a0),a6
00:0000419E 200E            	  2940:             move.l a6,d0
00:000041A0 0C800034567C    	  2941:             cmpi.l #$0034567C,d0
00:000041A6 66FE            	  2942:             bne.s *                   * branch if Z set
00:000041A8 48680004        	  2943:             pea 4(a0)
00:000041AC 0C970034567C    	  2944:             cmpi.l #$0034567C,(a7)
00:000041B2 66FE            	  2945:             bne.s *                   * branch if Z set
                            	  2946:             * This was without a specifier which the assembler defaulted to .w
00:000041B4 588F            	  2947:             addq.l #4,a7            * Restore Stack Pointer
                            	  2948: 
                            	  2949: *     x(An,Dn.l)
00:000041B6 4DF04004        	  2950:             lea 4(a0,d4),a6
00:000041BA 200E            	  2951:             move.l a6,d0
00:000041BC 0C800034567C    	  2952:             cmpi.l #$0034567C,d0
00:000041C2 66FE            	  2953:             bne.s *                   * branch if Z set
00:000041C4 48704804        	  2954:             pea 4(a0,d4.l)
00:000041C8 0C970034567C    	  2955:             cmpi.l #$0034567C,(a7)
00:000041CE 66FE            	  2956:             bne.s *                   * branch if Z set
                            	  2957:             * This was without a specifier which the assembler defaulted to .w
00:000041D0 588F            	  2958:             addq.l #4,a7            * Restore Stack Pointer
                            	  2959: 
                            	  2960: *     x.W
00:000041D2 4DF81234        	  2961:             lea $1234,a6
00:000041D6 200E            	  2962:             move.l a6,d0
00:000041D8 0C401234        	  2963:             cmpi.w #$1234,d0
00:000041DC 66FE            	  2964:             bne.s *                   * branch if Z set
00:000041DE 48781234        	  2965:             pea $1234
00:000041E2 0C9700001234    	  2966:             cmpi.l #$00001234,(a7)
00:000041E8 66FE            	  2967:             bne.s *                   * branch if Z set
                            	  2968:             * This was without a specifier which the assembler defaulted to .w
00:000041EA 588F            	  2969:             addq.l #4,a7            * Restore Stack Pointer
                            	  2970: 
                            	  2971: *     x.L
00:000041EC 4DF900345678    	  2972:             lea $00345678,a6
00:000041F2 200E            	  2973:             move.l a6,d0
00:000041F4 B08E            	  2974:             cmp.l a6,d0
00:000041F6 66FE            	  2975:             bne.s *                   * branch if Z set
00:000041F8 487900345678    	  2976:             pea $00345678
00:000041FE 0C9700345678    	  2977:             cmpi.l #$00345678,(a7)
00:00004204 66FE            	  2978:             bne.s *                   * branch if Z set
                            	  2979:             * This was without a specifier which the assembler defaulted to .w
00:00004206 588F            	  2980:             addq.l #4,a7            * Restore Stack Pointer
                            	  2981: 
                            	  2982: *     x(PC)
00:00004208 4DFA0008        	  2983:             lea LEA1(pc),a6
00:0000420C 200E            	  2984:             move.l a6,d0
00:0000420E B08E            	  2985:             cmp.l a6,d0
00:00004210 66FE            	  2986:             bne.s *                   * branch if Z set
00:00004212 487AFFFE        	  2987: LEA1:       pea LEA1(pc)
00:00004216 0C970000241E    	  2988:             cmpi.l #$0000241E,(a7)
00:0000421C 67FE            	  2989:             beq.s *                   * branch if Z clear
                            	  2990:             * This was without a specifier which the assembler defaulted to .w
00:0000421E 588F            	  2991:             addq.l #4,a7              * Restore Stack Pointer
                            	  2992: 
                            	  2993: 
                            	  2994: 
                            	  2995: 
00:00004220 46FC2700        	  2996:             move.w #$2700,sr          * Put flags back to initial value
                            	  2997: 
00:00004224 4E75            	  2998:             rts
                            	  2999:  	
                            	  3000: 
                            	  3001: 
                            	  3002: *-----------------------------------------------------------
                            	  3003: *-----------------------------------------------------------
                            	  3004: * OPCODE : LEA_TAS
                            	  3005: *-----------------------------------------------------------
                            	  3006: *-----------------------------------------------------------
                            	  3007: op_TAS:
                            	  3008: 
                            	  3009: *     Test just one addressing mode
                            	  3010: 
00:00004226 307C0100        	  3011:             move.l #$00000100,a0
                            	  3012: 
                            	  3013: *     (An)
00:0000422A 4210            	  3014:             move.b #$00,(a0)
00:0000422C 6BFE            	  3015:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000422E 66FE            	  3016:             bne.s *                   * Check Z Flag  beq/bne
00:00004230 4AD0            	  3017:             tas (a0)
00:00004232 0C100080        	  3018:             cmpi.b #$80,(a0)
00:00004236 66FE            	  3019:             bne.s *                   * branch if Z set
00:00004238 10BC00F5        	  3020:             move.b #$F5,(a0)
00:0000423C 4AD0            	  3021:             tas (a0)
00:0000423E 6AFE            	  3022:             bpl.s *                   * Check N Flag  bmi/bpl
00:00004240 67FE            	  3023:             beq.s *                   * Check Z Flag  beq/bne
00:00004242 4AD0            	  3024:             tas (a0)
00:00004244 0C1000F5        	  3025:             cmpi.b #$F5,(a0)
00:00004248 66FE            	  3026:             bne.s *                   * branch if Z set
                            	  3027: 
00:0000424A 4E75            	  3028:             rts
                            	  3029: 
                            	  3030: 
                            	  3031: *-----------------------------------------------------------
                            	  3032: *-----------------------------------------------------------
                            	  3033: * OPCODE : LEA_TST
                            	  3034: *-----------------------------------------------------------
                            	  3035: *-----------------------------------------------------------
                            	  3036: op_TST:
                            	  3037: 
                            	  3038: *     Test just one addressing mode
                            	  3039: 
00:0000424C 307C0100        	  3040:             move.l #$00000100,a0
                            	  3041: 
                            	  3042: *     (An) - BYTE
00:00004250 4210            	  3043:             move.b #$00,(a0)
00:00004252 4A10            	  3044:             tst.b (a0)
00:00004254 6BFE            	  3045:             bmi.s *                   * Check N Flag  bmi/bpl
00:00004256 66FE            	  3046:             bne.s *                   * Check Z Flag  beq/bne
00:00004258 10BC00F5        	  3047:             move.b #$F5,(a0)
00:0000425C 4A10            	  3048:             tst.b (a0)
00:0000425E 6AFE            	  3049:             bpl.s *                   * Check N Flag  bmi/bpl
00:00004260 67FE            	  3050:             beq.s *                   * Check Z Flag  beq/bne
                            	  3051: 
                            	  3052: *     (An) - WORD
00:00004262 4250            	  3053:             move.w #$0000,(a0)
00:00004264 4A50            	  3054:             tst.w (a0)
00:00004266 6BFE            	  3055:             bmi.s *                   * Check N Flag  bmi/bpl
00:00004268 66FE            	  3056:             bne.s *                   * Check Z Flag  beq/bne
00:0000426A 30BCF567        	  3057:             move.w #$F567,(a0)
00:0000426E 4A50            	  3058:             tst.w (a0)
00:00004270 6AFE            	  3059:             bpl.s *                   * Check N Flag  bmi/bpl
00:00004272 67FE            	  3060:             beq.s *                   * Check Z Flag  beq/bne
                            	  3061: 
                            	  3062: *     (An) - LONG
00:00004274 4290            	  3063:             move.l #$00000000,(a0)
00:00004276 4A90            	  3064:             tst.l (a0)
00:00004278 6BFE            	  3065:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000427A 66FE            	  3066:             bne.s *                   * Check Z Flag  beq/bne
00:0000427C 20BCF56789AB    	  3067:             move.l #$F56789ab,(a0)
00:00004282 4A90            	  3068:             tst.l (a0)
00:00004284 6AFE            	  3069:             bpl.s *                   * Check N Flag  bmi/bpl
00:00004286 67FE            	  3070:             beq.s *                   * Check Z Flag  beq/bne
                            	  3071: 
                            	  3072: 
00:00004288 4E75            	  3073:             rts
                            	  3074: 
                            	  3075: 
                            	  3076: *-----------------------------------------------------------
                            	  3077: *-----------------------------------------------------------
                            	  3078: * OPCODE : LINKS
                            	  3079: *-----------------------------------------------------------
                            	  3080: *-----------------------------------------------------------
                            	  3081: op_LINKS:
                            	  3082: 
00:0000428A 207C11223344    	  3083:             move.l #$11223344,a0
00:00004290 203C11223344    	  3084:             move.l #$11223344,d0
00:00004296 4E500000        	  3085:             link a0,#$0
00:0000429A 0C9711223344    	  3086:             cmpi.l #$11223344,(a7)
                            	  3087: 
00:000042A0 4E58            	  3088:             unlk a0
00:000042A2 B1C0            	  3089:             cmp.l d0,a0
00:000042A4 66FE            	  3090:             bne.s *                   * branch if Z set
                            	  3091: 
00:000042A6 4E75            	  3092:             rts
                            	  3093: 
                            	  3094: *-----------------------------------------------------------
                            	  3095: *-----------------------------------------------------------
                            	  3096: * OPCODE : MOVE_USP
                            	  3097: *-----------------------------------------------------------
                            	  3098: *-----------------------------------------------------------
                            	  3099: op_MOVE_USP:
                            	  3100: 
00:000042A8 207C11223344    	  3101:             move.l #$11223344,a0
00:000042AE 4E60            	  3102:             move a0,USP
00:000042B0 4E69            	  3103:             move USP,a1
00:000042B2 B3C8            	  3104:             cmp.l a0,a1
00:000042B4 66FE            	  3105:             bne.s *                   * branch if Z set
                            	  3106: 
00:000042B6 4E75            	  3107:             rts
                            	  3108: 
                            	  3109: 
                            	  3110: *-----------------------------------------------------------
                            	  3111: *-----------------------------------------------------------
                            	  3112: * OPCODE : CHK
                            	  3113: *-----------------------------------------------------------
                            	  3114: *-----------------------------------------------------------
                            	  3115: 
                            	  3116: op_CHK:
                            	  3117: 
00:000042B8 20780018        	  3118: 	move.l 6*4,a0							; get check vector
00:000042BC 21FC0000273C0018	  3119: 	move.l #EXCEPTION_6,6*4		; set vector
00:000042C4 303C1122        	  3120: 	move.w #$1122,d0
00:000042C8 323C1122        	  3121: 	move.w #$1122,d1
00:000042CC 4380            	  3122: 	chk d0,d1
                            	  3123: 
00:000042CE 4E71            	  3124: 	nop
00:000042D0 4E71            	  3125: 	nop
                            	  3126: 
00:000042D2 323C1122        	  3127: 	move.w #$1122,d1
00:000042D6 43BC1122        	  3128: 	chk #$1122,d1
                            	  3129: 
00:000042DA 323C1122        	  3130: 	move.w #$1122,d1
00:000042DE 43BC007A        	  3131: 	chk #00122,d1
00:000042E2 BCBCEEEE0006    	  3132: 	cmp.l #$EEEE0006,d6
00:000042E8 66FE            	  3133: 	bne.s *                   ; branch if Z set
                            	  3134: 
00:000042EA 303C1122        	  3135: 	move.w #$1122,d0
00:000042EE 323C8000        	  3136: 	move.w #$8000,d1
00:000042F2 4380            	  3137: 	chk d0,d1
00:000042F4 BCBCEEEE0006    	  3138: 	cmp.l #$EEEE0006,d6
00:000042FA 66FE            	  3139: 	bne.s *                   ; branch if Z set
                            	  3140: 
00:000042FC 21C80018        	  3141: 	move.l a0,6*4							; restore old vector
00:00004300 4E75            	  3142: 	rts
                            	  3143: 
                            	  3144: 
                            	  3145: *-----------------------------------------------------------
                            	  3146: *-----------------------------------------------------------
                            	  3147: * OPCODE : NEGS
                            	  3148: *-----------------------------------------------------------
                            	  3149: *-----------------------------------------------------------
                            	  3150: op_NEGS:
                            	  3151: 
                            	  3152: *     NOT - BYTE
00:00004302 307C0100        	  3153:             move.l #$00000100,a0
00:00004306 7000            	  3154:             moveq  #$00000000,d0
00:00004308 4600            	  3155:             not.b d0
00:0000430A 6AFE            	  3156:             bpl.s *                   * Check N Flag  bmi/bpl
00:0000430C 67FE            	  3157:             beq.s *                   * Check Z Flag  beq/bne
00:0000430E 4600            	  3158:             not.b d0
00:00004310 6BFE            	  3159:             bmi.s *                   * Check N Flag  bmi/bpl
00:00004312 66FE            	  3160:             bne.s *                   * Check Z Flag  beq/bne
00:00004314 4A00            	  3161:             cmpi.b #$00,d0
00:00004316 66FE            	  3162:             bne.s *                   * Check Z Flag  beq/bne
00:00004318 10BC0080        	  3163:             move.b #$80,(a0)
00:0000431C 4610            	  3164:             not.b (a0)
00:0000431E 6BFE            	  3165:             bmi.s *                   * Check N Flag  bmi/bpl
00:00004320 67FE            	  3166:             beq.s *                   * Check Z Flag  beq/bne
00:00004322 4610            	  3167:             not.b (a0)
00:00004324 6AFE            	  3168:             bpl.s *                   * Check N Flag  bmi/bpl
00:00004326 67FE            	  3169:             beq.s *                   * Check Z Flag  beq/bne
00:00004328 0C100080        	  3170:             cmpi.b #$80,(a0)
00:0000432C 66FE            	  3171:             bne.s *                   * Check Z Flag  beq/bne
                            	  3172: 
                            	  3173: *     NOT - WORD
00:0000432E 307C0100        	  3174:             move.l #$00000100,a0
00:00004332 7000            	  3175:             moveq  #$00000000,d0
00:00004334 4640            	  3176:             not.w d0
00:00004336 6AFE            	  3177:             bpl.s *                   * Check N Flag  bmi/bpl
00:00004338 67FE            	  3178:             beq.s *                   * Check Z Flag  beq/bne
00:0000433A 4640            	  3179:             not.w d0
00:0000433C 6BFE            	  3180:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000433E 66FE            	  3181:             bne.s *                   * Check Z Flag  beq/bne
00:00004340 4A40            	  3182:             cmpi.w #$0000,d0
00:00004342 66FE            	  3183:             bne.s *                   * Check Z Flag  beq/bne
00:00004344 30BC5A5A        	  3184:             move.w #$5a5a,(a0)
00:00004348 4650            	  3185:             not.w (a0)
00:0000434A 6AFE            	  3186:             bpl.s *                   * Check N Flag  bmi/bpl
00:0000434C 67FE            	  3187:             beq.s *                   * Check Z Flag  beq/bne
00:0000434E 4650            	  3188:             not.w (a0)
00:00004350 6BFE            	  3189:             bmi.s *                   * Check N Flag  bmi/bpl
00:00004352 67FE            	  3190:             beq.s *                   * Check Z Flag  beq/bne
00:00004354 0C505A5A        	  3191:             cmpi.w #$5a5a,(a0)
00:00004358 66FE            	  3192:             bne.s *                   * Check Z Flag  beq/bne
                            	  3193: 
                            	  3194: *     NOT - LONG
00:0000435A 307C0100        	  3195:             move.l #$00000100,a0
00:0000435E 7000            	  3196:             moveq  #$00000000,d0
00:00004360 4680            	  3197:             not.l d0
00:00004362 6AFE            	  3198:             bpl.s *                   * Check N Flag  bmi/bpl
00:00004364 67FE            	  3199:             beq.s *                   * Check Z Flag  beq/bne
00:00004366 4680            	  3200:             not.l d0
00:00004368 6BFE            	  3201:             bmi.s *                   * Check N Flag  bmi/bpl
00:0000436A 66FE            	  3202:             bne.s *                   * Check Z Flag  beq/bne
00:0000436C 4A80            	  3203:             cmpi.l #$00000000,d0
00:0000436E 66FE            	  3204:             bne.s *                   * Check Z Flag  beq/bne
00:00004370 20BC5A5A1234    	  3205:             move.l #$5a5a1234,(a0)
00:00004376 4690            	  3206:             not.l (a0)
00:00004378 6AFE            	  3207:             bpl.s *                   * Check N Flag  bmi/bpl
00:0000437A 67FE            	  3208:             beq.s *                   * Check Z Flag  beq/bne
00:0000437C 4690            	  3209:             not.l (a0)
00:0000437E 6BFE            	  3210:             bmi.s *                   * Check N Flag  bmi/bpl
00:00004380 67FE            	  3211:             beq.s *                   * Check Z Flag  beq/bne
00:00004382 0C905A5A1234    	  3212:             cmpi.l #$5a5a1234,(a0)
00:00004388 66FE            	  3213:             bne.s *                   * Check Z Flag  beq/bne
                            	  3214: 
                            	  3215: * -----
                            	  3216: 
                            	  3217: *     NEG - BYTE
00:0000438A 307C0100        	  3218:             move.l #$00000100,a0
00:0000438E 7000            	  3219:             moveq  #$00000000,d0
00:00004390 7240D241        	  3220:             move.l #$00000080,d1
00:00004394 4400            	  3221:             neg.b d0
00:00004396 6BFE            	  3222:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004398 66FE            	  3223:             bne.s *                   * Check Z Flag  beq/bne 1
00:0000439A 65FE            	  3224:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:0000439C 69FE            	  3225:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000439E 4401            	  3226:             neg.b d1
00:000043A0 6AFE            	  3227:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000043A2 67FE            	  3228:             beq.s *                   * Check Z Flag  beq/bne 0
00:000043A4 64FE            	  3229:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000043A6 68FE            	  3230:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:000043A8 0C010080        	  3231:             cmpi.b #$80,d1
00:000043AC 66FE            	  3232:             bne.s *                   * Check Z Flag  beq/bne
00:000043AE 10BC007F        	  3233:             move.b #$7F,(a0)
00:000043B2 4410            	  3234:             neg.b (a0)
00:000043B4 6AFE            	  3235:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000043B6 67FE            	  3236:             beq.s *                   * Check Z Flag  beq/bne 0
00:000043B8 64FE            	  3237:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000043BA 69FE            	  3238:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000043BC 10BC00F5        	  3239:             move.b #$F5,(a0)
00:000043C0 4410            	  3240:             neg.b (a0)
00:000043C2 6BFE            	  3241:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000043C4 67FE            	  3242:             beq.s *                   * Check Z Flag  beq/bne 0
00:000043C6 64FE            	  3243:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000043C8 69FE            	  3244:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000043CA 0C10000B        	  3245:             cmpi.b #$0B,(a0)
00:000043CE 66FE            	  3246:             bne.s *                   * Check Z Flag  beq/bne
                            	  3247: 
                            	  3248: * -----
                            	  3249: 
                            	  3250: *     NEG - WORD
00:000043D0 307C0100        	  3251:             move.l #$00000100,a0
00:000043D4 7000            	  3252:             moveq  #$00000000,d0
00:000043D6 223C00008000    	  3253:             move.l #$00008000,d1
00:000043DC 4440            	  3254:             neg.w d0
00:000043DE 6BFE            	  3255:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000043E0 66FE            	  3256:             bne.s *                   * Check Z Flag  beq/bne 1
00:000043E2 65FE            	  3257:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:000043E4 69FE            	  3258:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000043E6 4441            	  3259:             neg.w d1
00:000043E8 6AFE            	  3260:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000043EA 67FE            	  3261:             beq.s *                   * Check Z Flag  beq/bne 0
00:000043EC 64FE            	  3262:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000043EE 68FE            	  3263:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:000043F0 0C418000        	  3264:             cmpi.w #$8000,d1
00:000043F4 66FE            	  3265:             bne.s *                   * Check Z Flag  beq/bne
00:000043F6 30BC7FFF        	  3266:             move.w #$7FFF,(a0)
00:000043FA 4450            	  3267:             neg.w (a0)
00:000043FC 6AFE            	  3268:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000043FE 67FE            	  3269:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004400 64FE            	  3270:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004402 69FE            	  3271:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004404 30BCF578        	  3272:             move.w #$F578,(a0)
00:00004408 4450            	  3273:             neg.w (a0)
00:0000440A 6BFE            	  3274:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:0000440C 67FE            	  3275:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000440E 64FE            	  3276:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004410 69FE            	  3277:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004412 0C500A88        	  3278:             cmpi.w #$0A88,(a0)
00:00004416 66FE            	  3279:             bne.s *                   * Check Z Flag  beq/bne
                            	  3280: 
                            	  3281: * -----
                            	  3282: 
                            	  3283: *     NEG - LONG
00:00004418 307C0100        	  3284:             move.l #$00000100,a0
00:0000441C 7000            	  3285:             moveq  #$00000000,d0
00:0000441E 223C80000000    	  3286:             move.l #$80000000,d1
00:00004424 4480            	  3287:             neg.l d0
00:00004426 6BFE            	  3288:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004428 66FE            	  3289:             bne.s *                   * Check Z Flag  beq/bne 1
00:0000442A 65FE            	  3290:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:0000442C 69FE            	  3291:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000442E 4481            	  3292:             neg.l d1
00:00004430 6AFE            	  3293:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004432 67FE            	  3294:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004434 64FE            	  3295:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004436 68FE            	  3296:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:00004438 0C8180000000    	  3297:             cmpi.l #$80000000,d1
00:0000443E 66FE            	  3298:             bne.s *                   * Check Z Flag  beq/bne
00:00004440 20BC7FFFFFFF    	  3299:             move.l #$7FFFFFFF,(a0)
00:00004446 4490            	  3300:             neg.l (a0)
00:00004448 6AFE            	  3301:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:0000444A 67FE            	  3302:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000444C 64FE            	  3303:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000444E 69FE            	  3304:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004450 20BCF5781234    	  3305:             move.l #$F5781234,(a0)
00:00004456 4490            	  3306:             neg.l (a0)
00:00004458 6BFE            	  3307:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:0000445A 67FE            	  3308:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000445C 64FE            	  3309:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000445E 69FE            	  3310:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004460 0C900A87EDCC    	  3311:             cmpi.l #$0A87EDCC,(a0)
00:00004466 66FE            	  3312:             bne.s *                   * Check Z Flag  beq/bne
                            	  3313: 
                            	  3314: 
                            	  3315: * -----
                            	  3316: 
                            	  3317: *     NEGX - BYTE
00:00004468 307C0100        	  3318:             move.l #$00000100,a0
00:0000446C 7000            	  3319:             moveq  #$00000000,d0
00:0000446E 7240D241        	  3320:             move.l #$00000080,d1
00:00004472 003C0010        	  3321:             ori.b #$10,CCR        * Set X Flag
00:00004476 4000            	  3322:             negx.b d0
00:00004478 6AFE            	  3323:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:0000447A 67FE            	  3324:             beq.s *                   * Check Z Flag  beq/bne 1
00:0000447C 64FE            	  3325:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:0000447E 69FE            	  3326:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004480 023C00EF        	  3327:             andi.b #$EF,CCR       * Clear X Flag
00:00004484 4000            	  3328:             negx.b d0
00:00004486 6BFE            	  3329:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004488 67FE            	  3330:             beq.s *                   * Check Z Flag  beq/bne 1
00:0000448A 64FE            	  3331:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:0000448C 69FE            	  3332:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000448E 003C0010        	  3333:             ori.b #$10,CCR        * Set X Flag
00:00004492 4001            	  3334:             negx.b d1
00:00004494 6BFE            	  3335:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:00004496 67FE            	  3336:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004498 64FE            	  3337:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000449A 69FE            	  3338:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:0000449C 0C01007F        	  3339:             cmpi.b #$7F,d1
00:000044A0 66FE            	  3340:             bne.s *                   * Check Z Flag  beq/bne
00:000044A2 023C00EF        	  3341:             andi.b #$EF,CCR       * Clear X Flag
00:000044A6 4001            	  3342:             negx.b d1
00:000044A8 6AFE            	  3343:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000044AA 67FE            	  3344:             beq.s *                   * Check Z Flag  beq/bne 0
00:000044AC 64FE            	  3345:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000044AE 69FE            	  3346:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:000044B0 0C010081        	  3347:             cmpi.b #$81,d1
00:000044B4 66FE            	  3348:             bne.s *                   * Check Z Flag  beq/bne
00:000044B6 10BC007F        	  3349:             move.b #$7F,(a0)
00:000044BA 003C0010        	  3350:             ori.b #$10,CCR        * Set X Flag
00:000044BE 4010            	  3351:             negx.b (a0)
00:000044C0 6AFE            	  3352:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000044C2 67FE            	  3353:             beq.s *                   * Check Z Flag  beq/bne 0
00:000044C4 64FE            	  3354:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3355:             * I think overflow should happen here.
                            	  3356: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:000044C6 10BC007F        	  3357:             move.b #$7F,(a0)
00:000044CA 023C00EF        	  3358:             andi.b #$EF,CCR       * Clear X Flag
00:000044CE 4010            	  3359:             negx.b (a0)
00:000044D0 6AFE            	  3360:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000044D2 67FE            	  3361:             beq.s *                   * Check Z Flag  beq/bne 0
00:000044D4 64FE            	  3362:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000044D6 69FE            	  3363:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000044D8 10BC00F5        	  3364:             move.b #$F5,(a0)
00:000044DC 003C0010        	  3365:             ori.b #$10,CCR        * Set X Flag
00:000044E0 4010            	  3366:             negx.b (a0)
00:000044E2 6BFE            	  3367:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000044E4 67FE            	  3368:             beq.s *                   * Check Z Flag  beq/bne 0
00:000044E6 64FE            	  3369:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000044E8 69FE            	  3370:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000044EA 0C10000A        	  3371:             cmpi.b #$0A,(a0)
00:000044EE 66FE            	  3372:             bne.s *                   * Check Z Flag  beq/bne
00:000044F0 023C00EF        	  3373:             andi.b #$EF,CCR       * Clear X Flag
00:000044F4 4010            	  3374:             negx.b (a0)
00:000044F6 6AFE            	  3375:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:000044F8 67FE            	  3376:             beq.s *                   * Check Z Flag  beq/bne 0
00:000044FA 64FE            	  3377:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000044FC 69FE            	  3378:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000044FE 0C1000F6        	  3379:             cmpi.b #$F6,(a0)
00:00004502 66FE            	  3380:             bne.s *                   * Check Z Flag  beq/bne
                            	  3381: 
                            	  3382: 
                            	  3383: 
                            	  3384: * -----
                            	  3385: 
                            	  3386: *     NEGX - WORD
00:00004504 307C0100        	  3387:             move.l #$00000100,a0
00:00004508 7000            	  3388:             moveq  #$00000000,d0
00:0000450A 223C00008000    	  3389:             move.l #$00008000,d1
00:00004510 003C0010        	  3390:             ori.b #$10,CCR        * Set X Flag
00:00004514 4040            	  3391:             negx.w d0
00:00004516 6AFE            	  3392:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:00004518 67FE            	  3393:             beq.s *                   * Check Z Flag  beq/bne 1
00:0000451A 64FE            	  3394:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:0000451C 69FE            	  3395:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000451E 023C00EF        	  3396:             andi.b #$EF,CCR       * Clear X Flag
00:00004522 4040            	  3397:             negx.w d0
00:00004524 6BFE            	  3398:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004526 67FE            	  3399:             beq.s *                   * Check Z Flag  beq/bne 1
00:00004528 64FE            	  3400:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:0000452A 69FE            	  3401:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000452C 003C0010        	  3402:             ori.b #$10,CCR        * Set X Flag
00:00004530 4041            	  3403:             negx.w d1
00:00004532 6BFE            	  3404:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:00004534 67FE            	  3405:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004536 64FE            	  3406:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004538 69FE            	  3407:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:0000453A 0C417FFF        	  3408:             cmpi.w #$7FFF,d1
00:0000453E 66FE            	  3409:             bne.s *                   * Check Z Flag  beq/bne
00:00004540 023C00EF        	  3410:             andi.b #$EF,CCR       * Clear X Flag
00:00004544 4041            	  3411:             negx.w d1
00:00004546 6AFE            	  3412:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004548 67FE            	  3413:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000454A 64FE            	  3414:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000454C 69FE            	  3415:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:0000454E 0C418001        	  3416:             cmpi.w #$8001,d1
00:00004552 66FE            	  3417:             bne.s *                   * Check Z Flag  beq/bne
00:00004554 30BC7FFF        	  3418:             move.w #$7FFF,(a0)
00:00004558 003C0010        	  3419:             ori.b #$10,CCR        * Set X Flag
00:0000455C 4050            	  3420:             negx.w (a0)
00:0000455E 6AFE            	  3421:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004560 67FE            	  3422:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004562 64FE            	  3423:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3424: ***            
                            	  3425: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004564 30BCF567        	  3426:             move.w #$F567,(a0)
00:00004568 023C00EF        	  3427:             andi.b #$EF,CCR       * Clear X Flag
00:0000456C 4050            	  3428:             negx.w (a0)
00:0000456E 6BFE            	  3429:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:00004570 67FE            	  3430:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004572 64FE            	  3431:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004574 69FE            	  3432:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004576 30BCF567        	  3433:             move.w #$F567,(a0)
00:0000457A 003C0010        	  3434:             ori.b #$10,CCR        * Set X Flag
00:0000457E 4050            	  3435:             negx.w (a0)
00:00004580 6BFE            	  3436:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004582 67FE            	  3437:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004584 64FE            	  3438:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004586 69FE            	  3439:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004588 0C500A98        	  3440:             cmpi.w #$0A98,(a0)
00:0000458C 66FE            	  3441:             bne.s *                   * Check Z Flag  beq/bne
00:0000458E 023C00EF        	  3442:             andi.b #$EF,CCR       * Clear X Flag
00:00004592 4050            	  3443:             negx.w (a0)
00:00004594 6AFE            	  3444:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:00004596 67FE            	  3445:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004598 64FE            	  3446:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000459A 69FE            	  3447:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000459C 0C50F568        	  3448:             cmpi.w #$F568,(a0)
00:000045A0 66FE            	  3449:             bne.s *                   * Check Z Flag  beq/bne
                            	  3450: 
                            	  3451: 
                            	  3452: * -----
                            	  3453: 
                            	  3454: *     NEGX - LONG
00:000045A2 307C0100        	  3455:             move.l #$00000100,a0
00:000045A6 7000            	  3456:             moveq  #$00000000,d0
00:000045A8 223C80000000    	  3457:             move.l #$80000000,d1
00:000045AE 003C0010        	  3458:             ori.b #$10,CCR        * Set X Flag
00:000045B2 4080            	  3459:             negx.l d0
00:000045B4 6AFE            	  3460:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:000045B6 67FE            	  3461:             beq.s *                   * Check Z Flag  beq/bne 1
00:000045B8 64FE            	  3462:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:000045BA 69FE            	  3463:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000045BC 023C00EF        	  3464:             andi.b #$EF,CCR       * Clear X Flag
00:000045C0 4080            	  3465:             negx.l d0
00:000045C2 6BFE            	  3466:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000045C4 67FE            	  3467:             beq.s *                   * Check Z Flag  beq/bne 1
00:000045C6 64FE            	  3468:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:000045C8 69FE            	  3469:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000045CA 003C0010        	  3470:             ori.b #$10,CCR        * Set X Flag
00:000045CE 4081            	  3471:             negx.l d1
00:000045D0 6BFE            	  3472:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:000045D2 67FE            	  3473:             beq.s *                   * Check Z Flag  beq/bne 0
00:000045D4 64FE            	  3474:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000045D6 69FE            	  3475:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:000045D8 0C817FFFFFFF    	  3476:             cmpi.l #$7FFFFFFF,d1
00:000045DE 66FE            	  3477:             bne.s *                   * Check Z Flag  beq/bne
00:000045E0 023C00EF        	  3478:             andi.b #$EF,CCR       * Clear X Flag
00:000045E4 4081            	  3479:             negx.l d1
00:000045E6 6AFE            	  3480:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000045E8 67FE            	  3481:             beq.s *                   * Check Z Flag  beq/bne 0
00:000045EA 64FE            	  3482:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3483: ****            
                            	  3484: *            bvs.s *                   * Check V Flag  bvc/bvs 0
00:000045EC 0C8180000001    	  3485:             cmpi.l #$80000001,d1
00:000045F2 66FE            	  3486:             bne.s *                   * Check Z Flag  beq/bne
00:000045F4 20BC00007FFF    	  3487:             move.l #$7FFF,(a0)
00:000045FA 003C0010        	  3488:             ori.b #$10,CCR        * Set X Flag
00:000045FE 4090            	  3489:             negx.l (a0)
00:00004600 6AFE            	  3490:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004602 67FE            	  3491:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004604 64FE            	  3492:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3493: ****            
                            	  3494: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004606 20BCF5671234    	  3495:             move.l #$F5671234,(a0)
00:0000460C 023C00EF        	  3496:             andi.b #$EF,CCR       * Clear X Flag
00:00004610 4090            	  3497:             negx.l (a0)
00:00004612 6BFE            	  3498:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:00004614 67FE            	  3499:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004616 64FE            	  3500:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004618 69FE            	  3501:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000461A 20BCF5675678    	  3502:             move.l #$F5675678,(a0)
00:00004620 003C0010        	  3503:             ori.b #$10,CCR        * Set X Flag
00:00004624 4090            	  3504:             negx.l (a0)
00:00004626 6BFE            	  3505:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004628 67FE            	  3506:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000462A 64FE            	  3507:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000462C 69FE            	  3508:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000462E 0C900A98A987    	  3509:             cmpi.l #$0A98A987,(a0)
00:00004634 66FE            	  3510:             bne.s *                   * Check Z Flag  beq/bne
00:00004636 023C00EF        	  3511:             andi.b #$EF,CCR       * Clear X Flag
00:0000463A 4090            	  3512:             negx.l (a0)
00:0000463C 6AFE            	  3513:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:0000463E 67FE            	  3514:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004640 64FE            	  3515:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004642 69FE            	  3516:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004644 0C90F5675679    	  3517:             cmpi.l #$F5675679,(a0)
00:0000464A 66FE            	  3518:             bne.s *                   * Check Z Flag  beq/bne
                            	  3519: 
                            	  3520: 
                            	  3521: * -----
                            	  3522: 
                            	  3523: *     CLR - BYTE
00:0000464C 307C0100        	  3524:             move.l #$00000100,a0
00:00004650 203C12345678    	  3525:             move.l #$12345678,d0
00:00004656 223C12345678    	  3526:             move.l #$12345678,d1
00:0000465C 243C12345678    	  3527:             move.l #$12345678,d2
00:00004662 283C12345600    	  3528:             move.l #$12345600,d4
00:00004668 2A3C12340000    	  3529:             move.l #$12340000,d5
00:0000466E 7C00            	  3530:             moveq  #$00000000,d6
                            	  3531: 
00:00004670 4200            	  3532:             clr.b d0
00:00004672 66FE            	  3533:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004674 6BFE            	  3534:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004676 B880            	  3535:             cmp.l d0,d4
00:00004678 66FE            	  3536:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3537: 
00:0000467A 4241            	  3538:             clr.w d1
00:0000467C 66FE            	  3539:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000467E 6BFE            	  3540:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004680 BA81            	  3541:             cmp.l d1,d5
00:00004682 66FE            	  3542:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3543: 
00:00004684 7400            	  3544:             clr.l d2
00:00004686 66FE            	  3545:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004688 6BFE            	  3546:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:0000468A BC82            	  3547:             cmp.l d2,d6
00:0000468C 66FE            	  3548:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3549: 
00:0000468E 4E75            	  3550:             rts
                            	  3551: 
                            	  3552: 
                            	  3553: 
                            	  3554: *-----------------------------------------------------------
                            	  3555: *-----------------------------------------------------------
                            	  3556: * OPCODE : MOVEM
                            	  3557: *-----------------------------------------------------------
                            	  3558: *-----------------------------------------------------------
                            	  3559: op_MOVEM:
                            	  3560: 
                            	  3561: *     WORD  Registers --> Memory
00:00004690 203C0000D0D0    	  3562:             move.l #$0000d0d0,d0
00:00004696 223C0000D1D1    	  3563:             move.l #$0000d1d1,d1
00:0000469C 243C0000D2D2    	  3564:             move.l #$0000d2d2,d2
00:000046A2 263C0000D3D3    	  3565:             move.l #$0000d3d3,d3
00:000046A8 283C0000D4D4    	  3566:             move.l #$0000d4d4,d4
00:000046AE 2A3C0000D5D5    	  3567:             move.l #$0000d5d5,d5
00:000046B4 2C3C0000D6D6    	  3568:             move.l #$0000d6d6,d6
00:000046BA 2E3C0000D7D7    	  3569:             move.l #$0000d7d7,d7
00:000046C0 307C0A0A        	  3570:             move.l #$00000a0a,a0
00:000046C4 327C1A1A        	  3571:             move.l #$00001a1a,a1
00:000046C8 347C2A2A        	  3572:             move.l #$00002a2a,a2
00:000046CC 367C3A3A        	  3573:             move.l #$00003a3a,a3
00:000046D0 387C4A4A        	  3574:             move.l #$00004a4a,a4
00:000046D4 3A7C5A5A        	  3575:             move.l #$00005a5a,a5
00:000046D8 3C7C6A6A        	  3576:             move.l #$00006a6a,a6
                            	  3577: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3578: 
00:000046DC 48B8FFFF0100    	  3579:             movem.w D0-D7/A0-A7,$00000100
                            	  3580: 
00:000046E2 307C0100        	  3581:             move.l #$00000100,a0
                            	  3582: 
00:000046E6 B058            	  3583:             cmp.w (a0)+,d0
00:000046E8 66FE            	  3584:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046EA B258            	  3585:             cmp.w (a0)+,d1
00:000046EC 66FE            	  3586:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046EE B458            	  3587:             cmp.w (a0)+,d2
00:000046F0 66FE            	  3588:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046F2 B658            	  3589:             cmp.w (a0)+,d3
00:000046F4 66FE            	  3590:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046F6 B858            	  3591:             cmp.w (a0)+,d4
00:000046F8 66FE            	  3592:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046FA BA58            	  3593:             cmp.w (a0)+,d5
00:000046FC 66FE            	  3594:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046FE BC58            	  3595:             cmp.w (a0)+,d6
00:00004700 66FE            	  3596:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004702 BE58            	  3597:             cmp.w (a0)+,d7
00:00004704 66FE            	  3598:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3599: 
00:00004706 0C580A0A        	  3600:             cmpi.w #$0A0A,(a0)+    * Because we are using a0 as a pointer
00:0000470A 66FE            	  3601:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3602: 
00:0000470C B2D8            	  3603:             cmp.w (a0)+,a1
00:0000470E 66FE            	  3604:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004710 B4D8            	  3605:             cmp.w (a0)+,a2
00:00004712 66FE            	  3606:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004714 B6D8            	  3607:             cmp.w (a0)+,a3
00:00004716 66FE            	  3608:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004718 B8D8            	  3609:             cmp.w (a0)+,a4
00:0000471A 66FE            	  3610:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000471C BAD8            	  3611:             cmp.w (a0)+,a5
00:0000471E 66FE            	  3612:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004720 BCD8            	  3613:             cmp.w (a0)+,a6
00:00004722 66FE            	  3614:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3615: 
                            	  3616: 
                            	  3617: 
                            	  3618: 
                            	  3619: *     LONG  Registers --> Memory
00:00004724 203CD0D0D0D0    	  3620:             move.l #$d0d0d0d0,d0
00:0000472A 223CD1D1D1D1    	  3621:             move.l #$d1d1d1d1,d1
00:00004730 243CD2D2D2D2    	  3622:             move.l #$d2d2d2d2,d2
00:00004736 263CD3D3D3D3    	  3623:             move.l #$d3d3d3d3,d3
00:0000473C 283CD4D4D4D4    	  3624:             move.l #$d4d4d4d4,d4
00:00004742 2A3CD5D5D5D5    	  3625:             move.l #$d5d5d5d5,d5
00:00004748 2C3CD6D6D6D6    	  3626:             move.l #$d6d6d6d6,d6
00:0000474E 2E3CD7D7D7D7    	  3627:             move.l #$d7d7d7d7,d7
00:00004754 207C0A0A0A0A    	  3628:             move.l #$0a0a0a0a,a0
00:0000475A 227C1A1A1A1A    	  3629:             move.l #$1a1a1a1a,a1
00:00004760 247C2A2A2A2A    	  3630:             move.l #$2a2a2a2a,a2
00:00004766 267C3A3A3A3A    	  3631:             move.l #$3a3a3a3a,a3
00:0000476C 287C4A4A4A4A    	  3632:             move.l #$4a4a4a4a,a4
00:00004772 2A7C5A5A5A5A    	  3633:             move.l #$5a5a5a5a,a5
00:00004778 2C7C6A6A6A6A    	  3634:             move.l #$6a6a6a6a,a6
                            	  3635: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3636: 
                            	  3637: 
00:0000477E 48F8FFFF0120    	  3638:             movem.l D0-D7/A0-A7,$00000120
                            	  3639: 
00:00004784 307C0120        	  3640:             move.l #$00000120,a0
                            	  3641: 
00:00004788 B098            	  3642:             cmp.l (a0)+,d0
00:0000478A 66FE            	  3643:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000478C B298            	  3644:             cmp.l (a0)+,d1
00:0000478E 66FE            	  3645:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004790 B498            	  3646:             cmp.l (a0)+,d2
00:00004792 66FE            	  3647:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004794 B698            	  3648:             cmp.l (a0)+,d3
00:00004796 66FE            	  3649:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004798 B898            	  3650:             cmp.l (a0)+,d4
00:0000479A 66FE            	  3651:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000479C BA98            	  3652:             cmp.l (a0)+,d5
00:0000479E 66FE            	  3653:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047A0 BC98            	  3654:             cmp.l (a0)+,d6
00:000047A2 66FE            	  3655:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047A4 BE98            	  3656:             cmp.l (a0)+,d7
00:000047A6 66FE            	  3657:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3658: 
00:000047A8 0C980A0A0A0A    	  3659:             cmpi.l #$0A0A0A0A,(a0)+    * Because we are using a0 as a pointer
00:000047AE 66FE            	  3660:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3661: 
00:000047B0 B3D8            	  3662:             cmp.l (a0)+,a1
00:000047B2 66FE            	  3663:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047B4 B5D8            	  3664:             cmp.l (a0)+,a2
00:000047B6 66FE            	  3665:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047B8 B7D8            	  3666:             cmp.l (a0)+,a3
00:000047BA 66FE            	  3667:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047BC B9D8            	  3668:             cmp.l (a0)+,a4
00:000047BE 66FE            	  3669:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047C0 BBD8            	  3670:             cmp.l (a0)+,a5
00:000047C2 66FE            	  3671:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047C4 BDD8            	  3672:             cmp.l (a0)+,a6
00:000047C6 66FE            	  3673:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3674: *      ----
                            	  3675: 
                            	  3676: 
                            	  3677: *     WORD  Registers --> Memory  -(An) EA Mode
00:000047C8 203C0000D0D0    	  3678:             move.l #$0000d0d0,d0
00:000047CE 223C0000D1D1    	  3679:             move.l #$0000d1d1,d1
00:000047D4 243C0000D2D2    	  3680:             move.l #$0000d2d2,d2
00:000047DA 263C0000D3D3    	  3681:             move.l #$0000d3d3,d3
00:000047E0 283C0000D4D4    	  3682:             move.l #$0000d4d4,d4
00:000047E6 2A3C0000D5D5    	  3683:             move.l #$0000d5d5,d5
00:000047EC 2C3C0000D6D6    	  3684:             move.l #$0000d6d6,d6
00:000047F2 2E3C0000D7D7    	  3685:             move.l #$0000d7d7,d7
00:000047F8 307C0A0A        	  3686:             move.l #$00000a0a,a0
00:000047FC 327C1A1A        	  3687:             move.l #$00001a1a,a1
00:00004800 347C2A2A        	  3688:             move.l #$00002a2a,a2
00:00004804 367C3A3A        	  3689:             move.l #$00003a3a,a3
00:00004808 387C4A4A        	  3690:             move.l #$00004a4a,a4
00:0000480C 3A7C5A5A        	  3691:             move.l #$00005a5a,a5
00:00004810 3C7C6A6A        	  3692:             move.l #$00006a6a,a6
                            	  3693: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3694: 
00:00004814 307C01A0        	  3695:             move.l #$000001A0,a0
00:00004818 48A0FFFF        	  3696:             movem.w D0-D7/A0-A7,-(a0)
                            	  3697: 
00:0000481C 307C019E        	  3698:             move.l #$0000019E,a0
                            	  3699: 
00:00004820 BCE0            	  3700:             cmp.w -(a0),a6
00:00004822 66FE            	  3701:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004824 BAE0            	  3702:             cmp.w -(a0),a5
00:00004826 66FE            	  3703:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004828 B8E0            	  3704:             cmp.w -(a0),a4
00:0000482A 66FE            	  3705:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000482C B6E0            	  3706:             cmp.w -(a0),a3
00:0000482E 66FE            	  3707:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004830 B4E0            	  3708:             cmp.w -(a0),a2
00:00004832 66FE            	  3709:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004834 B2E0            	  3710:             cmp.w -(a0),a1
00:00004836 66FE            	  3711:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004838 B0E0            	  3712:             cmp.w -(a0),a0
                            	  3713: *            bne.s *                   * Check Z Flag  beq/bne 0
00:0000483A BE60            	  3714:             cmp.w -(a0),d7
00:0000483C 66FE            	  3715:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000483E BC60            	  3716:             cmp.w -(a0),d6
00:00004840 66FE            	  3717:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004842 BA60            	  3718:             cmp.w -(a0),d5
00:00004844 66FE            	  3719:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004846 B860            	  3720:             cmp.w -(a0),d4
00:00004848 66FE            	  3721:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000484A B660            	  3722:             cmp.w -(a0),d3
00:0000484C 66FE            	  3723:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000484E B460            	  3724:             cmp.w -(a0),d2
00:00004850 66FE            	  3725:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004852 B260            	  3726:             cmp.w -(a0),d1
00:00004854 66FE            	  3727:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004856 B060            	  3728:             cmp.w -(a0),d0
00:00004858 66FE            	  3729:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3730: 
                            	  3731: 
                            	  3732: 
                            	  3733: 
                            	  3734: *     LONG  Registers --> Memory   -(An) EA Mode
00:0000485A 203CD0D0D0D0    	  3735:             move.l #$d0d0d0d0,d0
00:00004860 223CD1D1D1D1    	  3736:             move.l #$d1d1d1d1,d1
00:00004866 243CD2D2D2D2    	  3737:             move.l #$d2d2d2d2,d2
00:0000486C 263CD3D3D3D3    	  3738:             move.l #$d3d3d3d3,d3
00:00004872 283CD4D4D4D4    	  3739:             move.l #$d4d4d4d4,d4
00:00004878 2A3CD5D5D5D5    	  3740:             move.l #$d5d5d5d5,d5
00:0000487E 2C3CD6D6D6D6    	  3741:             move.l #$d6d6d6d6,d6
00:00004884 2E3CD7D7D7D7    	  3742:             move.l #$d7d7d7d7,d7
00:0000488A 207C0A0A0A0A    	  3743:             move.l #$0a0a0a0a,a0
00:00004890 227C1A1A1A1A    	  3744:             move.l #$1a1a1a1a,a1
00:00004896 247C2A2A2A2A    	  3745:             move.l #$2a2a2a2a,a2
00:0000489C 267C3A3A3A3A    	  3746:             move.l #$3a3a3a3a,a3
00:000048A2 287C4A4A4A4A    	  3747:             move.l #$4a4a4a4a,a4
00:000048A8 2A7C5A5A5A5A    	  3748:             move.l #$5a5a5a5a,a5
00:000048AE 2C7C6A6A6A6A    	  3749:             move.l #$6a6a6a6a,a6
                            	  3750: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3751: 
                            	  3752: 
00:000048B4 307C01A0        	  3753:             move.l #$000001A0,a0
00:000048B8 48E0FFFF        	  3754:             movem.l D0-D7/A0-A7,-(a0)
                            	  3755: 
00:000048BC 307C019C        	  3756:             move.l #$0000019C,a0
                            	  3757: 
00:000048C0 BDE0            	  3758:             cmp.l -(a0),a6
00:000048C2 66FE            	  3759:             bne.s *                   * Check Z Flag  beq/bne 0
00:000048C4 BBE0            	  3760:             cmp.l -(a0),a5
00:000048C6 66FE            	  3761:             bne.s *                   * Check Z Flag  beq/bne 0
00:000048C8 B9E0            	  3762:             cmp.l -(a0),a4
00:000048CA 66FE            	  3763:             bne.s *                   * Check Z Flag  beq/bne 0
00:000048CC B7E0            	  3764:             cmp.l -(a0),a3
00:000048CE 66FE            	  3765:             bne.s *                   * Check Z Flag  beq/bne 0
00:000048D0 B5E0            	  3766:             cmp.l -(a0),a2
00:000048D2 66FE            	  3767:             bne.s *                   * Check Z Flag  beq/bne 0
00:000048D4 B3E0            	  3768:             cmp.l -(a0),a1
00:000048D6 66FE            	  3769:             bne.s *                   * Check Z Flag  beq/bne 0
00:000048D8 B1E0            	  3770:             cmp.l -(a0),a0
                            	  3771: *            bne.s *                   * Check Z Flag  beq/bne 0
00:000048DA BEA0            	  3772:             cmp.l -(a0),d7
00:000048DC 66FE            	  3773:             bne.s *                   * Check Z Flag  beq/bne 0
00:000048DE BCA0            	  3774:             cmp.l -(a0),d6
00:000048E0 66FE            	  3775:             bne.s *                   * Check Z Flag  beq/bne 0
00:000048E2 BAA0            	  3776:             cmp.l -(a0),d5
00:000048E4 66FE            	  3777:             bne.s *                   * Check Z Flag  beq/bne 0
00:000048E6 B8A0            	  3778:             cmp.l -(a0),d4
00:000048E8 66FE            	  3779:             bne.s *                   * Check Z Flag  beq/bne 0
00:000048EA B6A0            	  3780:             cmp.l -(a0),d3
00:000048EC 66FE            	  3781:             bne.s *                   * Check Z Flag  beq/bne 0
00:000048EE B4A0            	  3782:             cmp.l -(a0),d2
00:000048F0 66FE            	  3783:             bne.s *                   * Check Z Flag  beq/bne 0
00:000048F2 B2A0            	  3784:             cmp.l -(a0),d1
00:000048F4 66FE            	  3785:             bne.s *                   * Check Z Flag  beq/bne 0
00:000048F6 B0A0            	  3786:             cmp.l -(a0),d0
00:000048F8 66FE            	  3787:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3788: 
                            	  3789: 
                            	  3790: 
                            	  3791: *     ----
                            	  3792: 
                            	  3793: *     WORD - Memory --> Registers
00:000048FA 7000            	  3794:             moveq  #$00000000,d0
00:000048FC 7200            	  3795:             moveq  #$00000000,d1
00:000048FE 7400            	  3796:             moveq  #$00000000,d2
00:00004900 7600            	  3797:             moveq  #$00000000,d3
00:00004902 7800            	  3798:             moveq  #$00000000,d4
00:00004904 7A00            	  3799:             moveq  #$00000000,d5
00:00004906 7C00            	  3800:             moveq  #$00000000,d6
00:00004908 7E00            	  3801:             moveq  #$00000000,d7
00:0000490A 91C8            	  3802:             move.l #$00000000,a0
00:0000490C 93C9            	  3803:             move.l #$00000000,a1
00:0000490E 95CA            	  3804:             move.l #$00000000,a2
00:00004910 97CB            	  3805:             move.l #$00000000,a3
00:00004912 99CC            	  3806:             move.l #$00000000,a4
00:00004914 9BCD            	  3807:             move.l #$00000000,a5
00:00004916 9DCE            	  3808:             move.l #$00000000,a6
                            	  3809: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3810: 
00:00004918 4CB82A550100    	  3811:             movem.w $00000100,D0/D2/D4/D6/A1/A3/A5
                            	  3812: 
00:0000491E B0BCFFFFD0D0    	  3813:             cmp.l #$FFFFD0D0,d0
00:00004924 66FE            	  3814:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004926 B4BCFFFFD1D1    	  3815:             cmp.l #$FFFFD1D1,d2
00:0000492C 66FE            	  3816:             bne.s *                  * Check Z Flag  beq/bne 0
00:0000492E B8BCFFFFD2D2    	  3817:             cmp.l #$FFFFD2D2,d4
00:00004934 66FE            	  3818:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004936 BCBCFFFFD3D3    	  3819:             cmp.l #$FFFFD3D3,d6
00:0000493C 66FE            	  3820:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000493E B2FCD4D4        	  3821:             cmp.l #$FFFFD4D4,a1
00:00004942 66FE            	  3822:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004944 B6FCD5D5        	  3823:             cmp.l #$FFFFD5D5,a3
00:00004948 66FE            	  3824:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000494A BAFCD6D6        	  3825:             cmp.l #$FFFFD6D6,a5
00:0000494E 66FE            	  3826:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3827: 
                            	  3828: 
                            	  3829: *     LONG - Memory --> Registers
00:00004950 7000            	  3830:             moveq  #$00000000,d0
00:00004952 7200            	  3831:             moveq  #$00000000,d1
00:00004954 7400            	  3832:             moveq  #$00000000,d2
00:00004956 7600            	  3833:             moveq  #$00000000,d3
00:00004958 7800            	  3834:             moveq  #$00000000,d4
00:0000495A 7A00            	  3835:             moveq  #$00000000,d5
00:0000495C 7C00            	  3836:             moveq  #$00000000,d6
00:0000495E 7E00            	  3837:             moveq  #$00000000,d7
00:00004960 91C8            	  3838:             move.l #$00000000,a0
00:00004962 93C9            	  3839:             move.l #$00000000,a1
00:00004964 95CA            	  3840:             move.l #$00000000,a2
00:00004966 97CB            	  3841:             move.l #$00000000,a3
00:00004968 99CC            	  3842:             move.l #$00000000,a4
00:0000496A 9BCD            	  3843:             move.l #$00000000,a5
00:0000496C 9DCE            	  3844:             move.l #$00000000,a6
                            	  3845: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3846: 
00:0000496E 4CF82A550120    	  3847:             movem.l $00000120,D0/D2/D4/D6/A1/A3/A5
                            	  3848: 
00:00004974 B0BCD0D0D0D0    	  3849:             cmp.l #$D0D0D0D0,d0
00:0000497A 66FE            	  3850:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000497C B4BCD1D1D1D1    	  3851:             cmp.l #$D1D1D1D1,d2
00:00004982 66FE            	  3852:             bne.s *                  * Check Z Flag  beq/bne 0
00:00004984 B8BCD2D2D2D2    	  3853:             cmp.l #$D2D2D2D2,d4
00:0000498A 66FE            	  3854:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000498C BCBCD3D3D3D3    	  3855:             cmp.l #$D3D3D3D3,d6
00:00004992 66FE            	  3856:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004994 B3FCD4D4D4D4    	  3857:             cmp.l #$D4D4D4D4,a1
00:0000499A 66FE            	  3858:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000499C B7FCD5D5D5D5    	  3859:             cmp.l #$D5D5D5D5,a3
00:000049A2 66FE            	  3860:             bne.s *                   * Check Z Flag  beq/bne 0
00:000049A4 BBFCD6D6D6D6    	  3861:             cmp.l #$D6D6D6D6,a5
00:000049AA 66FE            	  3862:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3863: 
00:000049AC 4E75            	  3864:             rts
                            	  3865: 
                            	  3866: 
                            	  3867: *-----------------------------------------------------------
                            	  3868: *-----------------------------------------------------------
                            	  3869: * OPCODE : ABCD
                            	  3870: *-----------------------------------------------------------
                            	  3871: *-----------------------------------------------------------
                            	  3872: op_ABCD:
                            	  3873: 
                            	  3874: *     Test with X Flag CLEARED
00:000049AE 307C0110        	  3875:                 move.l #$00000110,a0 * Address pointer-X
00:000049B2 327C0120        	  3876:                 move.l #$00000120,a1 * Address pointer-Y
00:000049B6 7000            	  3877:                 moveq  #$00000000,d0 * BCD byte-X
00:000049B8 7200            	  3878:                 moveq  #$00000000,d1 * BCD byte-Y
00:000049BA 7400            	  3879:                 moveq  #$00000000,d2
00:000049BC 7600            	  3880:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:000049BE 7800            	  3881:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:000049C0 7A00            	  3882:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:000049C2 2C3C00000099    	  3883:                 move.l #$00000099,d6 * Inner loop counter
00:000049C8 2E3C00000099    	  3884:                 move.l #$00000099,d7 * Outer loop counter
                            	  3885: 
00:000049CE 2007            	  3886: ABCD_OUTER1:    move.l d7,d0
00:000049D0 2206            	  3887: ABCD_INNER1:    move.l d6,d1
00:000049D2 023C00EF        	  3888:                 andi.b #$EF,CCR     * Clear X Flag
00:000049D6 307C0110        	  3889:                 move.l #$00000110,a0 * Address pointer-X
00:000049DA 327C0120        	  3890:                 move.l #$00000120,a1 * Address pointer-Y
00:000049DE 1140FFFF        	  3891:                 move.b d0,-1(a0)
00:000049E2 1341FFFF        	  3892:                 move.b d1,-1(a1)
                            	  3893: 
00:000049E6 C300            	  3894:                 abcd d0,d1
00:000049E8 6402            	  3895:                 bcc.s ABCD_NO_C1          * Check C Flag  bcc/bcs 0
00:000049EA 5284            	  3896:                 add.l #1,d4
00:000049EC DA81            	  3897: ABCD_NO_C1:     add.l d1,d5
                            	  3898: 
00:000049EE C308            	  3899:                 abcd -(a0),-(a1)
00:000049F0 6402            	  3900:                 bcc.s ABCD_NO_C2          * Check C Flag  bcc/bcs 0
00:000049F2 5284            	  3901:                 add.l #1,d4
00:000049F4 D611            	  3902: ABCD_NO_C2:     add.b (a1),d3
                            	  3903: 
                            	  3904: 
00:000049F6 51CEFFD8        	  3905:                 dbf d6,ABCD_INNER1
00:000049FA 2C3C00000099    	  3906:                 move.l #$00000099,d6
00:00004A00 51CFFFCC        	  3907:                 dbf d7,ABCD_OUTER1
00:00004A04 0C8400005AFC    	  3908:                 cmpi.l #$00005AFC,d4  * Check the cumulative results
00:00004A0A 66FE            	  3909:                 bne.s *
00:00004A0C 0C85001C9A34    	  3910:                 cmpi.l #$001C9A34,d5
00:00004A12 66FE            	  3911:                 bne.s *
00:00004A14 0C8300000034    	  3912:                 cmpi.l #$00000034,d3
00:00004A1A 66FE            	  3913:                 bne.s *
                            	  3914: 
                            	  3915: *     Test with X Flag SET
00:00004A1C 307C0110        	  3916:                 move.l #$00000110,a0 * Address pointer-X
00:00004A20 327C0120        	  3917:                 move.l #$00000120,a1 * Address pointer-Y
00:00004A24 7000            	  3918:                 moveq  #$00000000,d0 * BCD byte-X
00:00004A26 7200            	  3919:                 moveq  #$00000000,d1 * BCD byte-Y
00:00004A28 7400            	  3920:                 moveq  #$00000000,d2
00:00004A2A 7600            	  3921:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00004A2C 7800            	  3922:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00004A2E 7A00            	  3923:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00004A30 2C3C00000099    	  3924:                 move.l #$00000099,d6 * Inner loop counter
00:00004A36 2E3C00000099    	  3925:                 move.l #$00000099,d7 * Outer loop counter
                            	  3926: 
00:00004A3C 2007            	  3927: ABCD_OUTER2:    move.l d7,d0
00:00004A3E 2206            	  3928: ABCD_INNER2:    move.l d6,d1
00:00004A40 003C0010        	  3929:                 ori.b #$10,CCR      * Set X Flag
00:00004A44 307C0110        	  3930:                 move.l #$00000110,a0 * Address pointer-X
00:00004A48 327C0120        	  3931:                 move.l #$00000120,a1 * Address pointer-Y
00:00004A4C 1140FFFF        	  3932:                 move.b d0,-1(a0)
00:00004A50 1341FFFF        	  3933:                 move.b d1,-1(a1)
                            	  3934: 
00:00004A54 C300            	  3935:                 abcd d0,d1
00:00004A56 6402            	  3936:                 bcc.s ABCD_NO_C3          * Check C Flag  bcc/bcs 0
00:00004A58 5284            	  3937:                 add.l #1,d4
00:00004A5A DA81            	  3938: ABCD_NO_C3:     add.l d1,d5
                            	  3939: 
00:00004A5C C308            	  3940:                 abcd -(a0),-(a1)
00:00004A5E 6402            	  3941:                 bcc.s ABCD_NO_C4          * Check C Flag  bcc/bcs 0
00:00004A60 5284            	  3942:                 add.l #1,d4
00:00004A62 D611            	  3943: ABCD_NO_C4:     add.b (a1),d3
                            	  3944: 
                            	  3945: 
00:00004A64 51CEFFD8        	  3946:                 dbf d6,ABCD_INNER2
00:00004A68 2C3C00000099    	  3947:                 move.l #$00000099,d6
00:00004A6E 51CFFFCC        	  3948:                 dbf d7,ABCD_OUTER2
00:00004A72 0C8400005B60    	  3949:                 cmpi.l #$00005B60,d4  * Check the cumulative results
00:00004A78 66FE            	  3950:                 bne.s *
00:00004A7A 0C85001CCFC8    	  3951:                 cmpi.l #$001CCFC8,d5
00:00004A80 66FE            	  3952:                 bne.s *
00:00004A82 0C8300000034    	  3953:                 cmpi.l #$00000034,d3
00:00004A88 66FE            	  3954:                 bne.s *
                            	  3955: 
                            	  3956: *             Quick check of Z Flag
00:00004A8A 4200            	  3957:                 move.b #$00,d0
00:00004A8C 4201            	  3958:                 move.b #$00,d1
00:00004A8E 44FC0000        	  3959:                 move #$00,CCR              * Set Z flag to 0
00:00004A92 C101            	  3960:                 abcd d1,d0                  * Should NOT set Z Flag to 1
00:00004A94 67FE            	  3961:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3962: 
00:00004A96 103C0001        	  3963:                 move.b #$01,d0
00:00004A9A 4201            	  3964:                 move.b #$00,d1
00:00004A9C 44FC0004        	  3965:                 move #$04,CCR              * Set Z flag to 0
00:00004AA0 C101            	  3966:                 abcd d1,d0                  * Should NOT set Z Flag to 1
00:00004AA2 67FE            	  3967:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3968: 
00:00004AA4 4E75            	  3969:                 rts
                            	  3970: 
                            	  3971: *-----------------------------------------------------------
                            	  3972: *-----------------------------------------------------------
                            	  3973: * OPCODE : SBCD
                            	  3974: *-----------------------------------------------------------
                            	  3975: *-----------------------------------------------------------
                            	  3976: op_SBCD:
                            	  3977: 
                            	  3978: *     Test with X Flag CLEARED
00:00004AA6 307C0110        	  3979:                 move.l #$00000110,a0 * Address pointer-X
00:00004AAA 327C0120        	  3980:                 move.l #$00000120,a1 * Address pointer-Y
00:00004AAE 7000            	  3981:                 moveq  #$00000000,d0 * BCD byte-X
00:00004AB0 7200            	  3982:                 moveq  #$00000000,d1 * BCD byte-Y
00:00004AB2 7400            	  3983:                 moveq  #$00000000,d2
00:00004AB4 7600            	  3984:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00004AB6 7800            	  3985:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00004AB8 7A00            	  3986:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00004ABA 2C3C00000099    	  3987:                 move.l #$00000099,d6 * Inner loop counter
00:00004AC0 2E3C00000099    	  3988:                 move.l #$00000099,d7 * Outer loop counter
                            	  3989: 
00:00004AC6 2007            	  3990: SBCD_OUTER1:    move.l d7,d0
00:00004AC8 2206            	  3991: SBCD_INNER1:    move.l d6,d1
00:00004ACA 023C00EF        	  3992:                 andi.b #$EF,CCR     * Clear X Flag
00:00004ACE 307C0110        	  3993:                 move.l #$00000110,a0 * Address pointer-X
00:00004AD2 327C0120        	  3994:                 move.l #$00000120,a1 * Address pointer-Y
00:00004AD6 1140FFFF        	  3995:                 move.b d0,-1(a0)
00:00004ADA 1341FFFF        	  3996:                 move.b d1,-1(a1)
                            	  3997: 
00:00004ADE 8300            	  3998:                 sbcd d0,d1
00:00004AE0 6402            	  3999:                 bcc.s SBCD_NO_C1          * Check C Flag  bcc/bcs 0
00:00004AE2 5284            	  4000:                 add.l #1,d4
00:00004AE4 DA81            	  4001: SBCD_NO_C1:     add.l d1,d5
                            	  4002: 
00:00004AE6 8308            	  4003:                 sbcd -(a0),-(a1)
00:00004AE8 6402            	  4004:                 bcc.s SBCD_NO_C2          * Check C Flag  bcc/bcs 0
00:00004AEA 5284            	  4005:                 add.l #1,d4
00:00004AEC D611            	  4006: SBCD_NO_C2:     add.b (a1),d3
                            	  4007: 
                            	  4008: 
00:00004AEE 51CEFFD8        	  4009:                 dbf d6,SBCD_INNER1
00:00004AF2 2C3C00000099    	  4010:                 move.l #$00000099,d6
00:00004AF8 51CFFFCC        	  4011:                 dbf d7,SBCD_OUTER1
00:00004AFC 0C8400005C0A    	  4012:                 cmpi.l #$00005C0A,d4  * Check the cumulative results
00:00004B02 66FE            	  4013:                 bne.s *
00:00004B04 0C85001C459E    	  4014:                 cmpi.l #$001C459E,d5
00:00004B0A 66FE            	  4015:                 bne.s *
00:00004B0C 0C830000009E    	  4016:                 cmpi.l #$0000009E,d3
00:00004B12 66FE            	  4017:                 bne.s *
                            	  4018: 
                            	  4019: *     Test with X Flag SET
00:00004B14 307C0110        	  4020:                 move.l #$00000110,a0 * Address pointer-X
00:00004B18 327C0120        	  4021:                 move.l #$00000120,a1 * Address pointer-Y
00:00004B1C 7000            	  4022:                 moveq  #$00000000,d0 * BCD byte-X
00:00004B1E 7200            	  4023:                 moveq  #$00000000,d1 * BCD byte-Y
00:00004B20 7400            	  4024:                 moveq  #$00000000,d2
00:00004B22 7600            	  4025:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00004B24 7800            	  4026:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00004B26 7A00            	  4027:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00004B28 2C3C00000099    	  4028:                 move.l #$00000099,d6 * Inner loop counter
00:00004B2E 2E3C00000099    	  4029:                 move.l #$00000099,d7 * Outer loop counter
                            	  4030: 
00:00004B34 2007            	  4031: SBCD_OUTER2:    move.l d7,d0
00:00004B36 2206            	  4032: SBCD_INNER2:    move.l d6,d1
00:00004B38 003C0010        	  4033:                 ori.b #$10,CCR      * Set X Flag
00:00004B3C 307C0110        	  4034:                 move.l #$00000110,a0 * Address pointer-X
00:00004B40 327C0120        	  4035:                 move.l #$00000120,a1 * Address pointer-Y
00:00004B44 1140FFFF        	  4036:                 move.b d0,-1(a0)
00:00004B48 1341FFFF        	  4037:                 move.b d1,-1(a1)
                            	  4038: 
00:00004B4C 8300            	  4039:                 sbcd d0,d1
00:00004B4E 6402            	  4040:                 bcc.s SBCD_NO_C3          * Check C Flag  bcc/bcs 0
00:00004B50 5284            	  4041:                 add.l #1,d4
00:00004B52 DA81            	  4042: SBCD_NO_C3:     add.l d1,d5
                            	  4043: 
00:00004B54 8308            	  4044:                 sbcd -(a0),-(a1)
00:00004B56 6402            	  4045:                 bcc.s SBCD_NO_C4          * Check C Flag  bcc/bcs 0
00:00004B58 5284            	  4046:                 add.l #1,d4
00:00004B5A D611            	  4047: SBCD_NO_C4:     add.b (a1),d3
                            	  4048: 
00:00004B5C 51CEFFD8        	  4049:                 dbf d6,SBCD_INNER2
00:00004B60 2C3C00000099    	  4050:                 move.l #$00000099,d6
00:00004B66 51CFFFCC        	  4051:                 dbf d7,SBCD_OUTER2
00:00004B6A 0C8400005CA4    	  4052:                 cmpi.l #$00005CA4,d4  * Check the cumulative results
00:00004B70 66FE            	  4053:                 bne.s *
00:00004B72 0C85001C5C66    	  4054:                 cmpi.l #$001C5C66,d5
00:00004B78 66FE            	  4055:                 bne.s *
00:00004B7A 0C830000009E    	  4056:                 cmpi.l #$0000009E,d3
00:00004B80 66FE            	  4057:                 bne.s *
                            	  4058: 
                            	  4059: 
                            	  4060: *             Quick check of Z Flag
00:00004B82 4200            	  4061:                 move.b #$00,d0
00:00004B84 4201            	  4062:                 move.b #$00,d1
00:00004B86 44FC0000        	  4063:                 move #$00,CCR              * Set Z flag to 0
00:00004B8A 8101            	  4064:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
00:00004B8C 67FE            	  4065:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4066: 
00:00004B8E 103C0001        	  4067:                 move.b #$01,d0
00:00004B92 4201            	  4068:                 move.b #$00,d1
00:00004B94 44FC0004        	  4069:                 move #$04,CCR              * Set Z flag to 0
00:00004B98 8101            	  4070:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
00:00004B9A 67FE            	  4071:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4072: 
00:00004B9C 4E75            	  4073:                 rts
                            	  4074: 
                            	  4075: *-----------------------------------------------------------
                            	  4076: *-----------------------------------------------------------
                            	  4077: * OPCODE : NBCD
                            	  4078: *-----------------------------------------------------------
                            	  4079: *-----------------------------------------------------------
                            	  4080: op_NBCD:
                            	  4081: 
                            	  4082: *        NBCD to a  Register
                            	  4083: 
00:00004B9E 7000            	  4084:                 moveq  #$00000000,d0 * BCD byte
00:00004BA0 7200            	  4085:                 moveq  #$00000000,d1
00:00004BA2 7400            	  4086:                 moveq  #$00000000,d2
00:00004BA4 7600            	  4087:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
00:00004BA6 7800            	  4088:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00004BA8 7A00            	  4089:                 moveq  #$00000000,d5 * Cumulative BCD results
00:00004BAA 2C3C00000099    	  4090:                 move.l #$00000099,d6
00:00004BB0 2E3C00000099    	  4091:                 move.l #$00000099,d7 * Loop counter
                            	  4092: 
00:00004BB6 2007            	  4093: NBCD_LOOP:      move.l d7,d0
00:00004BB8 44FC0004        	  4094:                 move #$04,CCR        * Set Z flag to 0
                            	  4095: 
00:00004BBC 4800            	  4096:                 nbcd d0
                            	  4097: 
00:00004BBE 6402            	  4098:                 bcc.s NBCD_NO_C         * Check C Flag
00:00004BC0 5284            	  4099:                 add.l #1,d4
00:00004BC2 6602            	  4100: NBCD_NO_C:      bne.s NBCD_NO_Z         * Check Z Flag
00:00004BC4 5283            	  4101:                 add.l #1,d3
00:00004BC6 DA80            	  4102: NBCD_NO_Z:      add.l d0,d5         * Add results into d5
                            	  4103: 
00:00004BC8 51CFFFEC        	  4104:                 dbf d7,NBCD_LOOP
                            	  4105: 
00:00004BCC 0C8300000001    	  4106:                 cmpi.l #$00000001,d3  * Check the cumulative results
00:00004BD2 66FE            	  4107:                 bne.s *
00:00004BD4 0C8400000099    	  4108:                 cmpi.l #$00000099,d4
00:00004BDA 66FE            	  4109:                 bne.s *
00:00004BDC 0C8500002E3B    	  4110:                 cmpi.l #$00002E3B,d5
00:00004BE2 66FE            	  4111:                 bne.s *
                            	  4112: 
                            	  4113: 
                            	  4114: *        NBCD to a memory location
                            	  4115: 
00:00004BE4 7000            	  4116:                 moveq  #$00000000,d0 * BCD byte
00:00004BE6 7200            	  4117:                 moveq  #$00000000,d1
00:00004BE8 7400            	  4118:                 moveq  #$00000000,d2
00:00004BEA 7600            	  4119:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
00:00004BEC 7800            	  4120:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00004BEE 7A00            	  4121:                 moveq  #$00000000,d5 * Cumulative BCD results
00:00004BF0 2C3C00000099    	  4122:                 move.l #$00000099,d6
00:00004BF6 2E3C00000099    	  4123:                 move.l #$00000099,d7 * Loop counter
                            	  4124: 
00:00004BFC 11C70100        	  4125: NBCD_LOOP1:     move.b d7,$00000100
00:00004C00 44FC0004        	  4126:                 move #$04,CCR        * Set Z flag to 0
                            	  4127: 
00:00004C04 48380100        	  4128:                 nbcd $00000100
00:00004C08 10380100        	  4129:                 move.b $00000100,d0
                            	  4130: 
00:00004C0C 6402            	  4131:                 bcc.s NBCD_NO_C1        * Check C Flag
00:00004C0E 5284            	  4132:                 add.l #1,d4
00:00004C10 6602            	  4133: NBCD_NO_C1:     bne.s NBCD_NO_Z1        * Check Z Flag
00:00004C12 5283            	  4134:                 add.l #1,d3
00:00004C14 DA80            	  4135: NBCD_NO_Z1:     add.l d0,d5         * Add results into d5
                            	  4136: 
00:00004C16 51CFFFE4        	  4137:                 dbf d7,NBCD_LOOP1
                            	  4138: 
00:00004C1A 0C8300000001    	  4139:                 cmpi.l #$00000001,d3  * Check the cumulative results
00:00004C20 66FE            	  4140:                 bne.s *
00:00004C22 4A84            	  4141:                 cmpi.l #$00000000,d4
00:00004C24 66FE            	  4142:                 bne.s *
00:00004C26 0C8500002E3B    	  4143:                 cmpi.l #$00002E3B,d5
00:00004C2C 66FE            	  4144:                 bne.s *
                            	  4145: 
                            	  4146: 
00:00004C2E 4E75            	  4147:                 rts
                            	  4148: 
                            	  4149: 
                            	  4150: 
                            	  4151: *-----------------------------------------------------------
                            	  4152: *-----------------------------------------------------------
                            	  4153: * OPCODE : TRAPV
                            	  4154: *-----------------------------------------------------------
                            	  4155: *-----------------------------------------------------------
                            	  4156: op_TRAPV:
                            	  4157: 
                            	  4158: *     TRAPV will set d0 to 12345678 if V flag is set
                            	  4159: 
00:00004C30 7000            	  4160:                 moveq  #$00000000,d0 * Clear d0
                            	  4161: 
00:00004C32 44FC0000        	  4162:                 move #$00,CCR        * Clear V flag
00:00004C36 4E76            	  4163:                 trapv
00:00004C38 4A80            	  4164:                 cmpi.l #$00000000,d0  * Check of d0 was updated (should not be_)
00:00004C3A 66FE            	  4165:                 bne.s *
                            	  4166: 
00:00004C3C 44FC0002        	  4167:                 move #$02,CCR        * Set V flag
00:00004C40 4E76            	  4168:                 trapv
00:00004C42 0C8012345678    	  4169:                 cmpi.l #$12345678,d0  * Check of d0 was updated (should not be_)
00:00004C48 66FE            	  4170:                 bne.s *
                            	  4171: 
                            	  4172: 
00:00004C4A 4E75            	  4173:                 rts
                            	  4174: 
                            	  4175: 
                            	  4176: 
                            	  4177: *-----------------------------------------------------------
                            	  4178: *-----------------------------------------------------------
                            	  4179: * OPCODE : RTR
                            	  4180: *-----------------------------------------------------------
                            	  4181: *-----------------------------------------------------------
                            	  4182: 
                            	  4183: op_RTR:
                            	  4184: 
                            	  4185: *     Leventhal claims only 5 LSB's are popped from the stack to the CCR
                            	  4186: 
00:00004C4C 41FA000A        	  4187:                 lea 		RTR_DONE,a0
00:00004C50 2F08            	  4188:                 move.l 	a0,-(a7)     * push destination PC to the stack
00:00004C52 3F3CFF15        	  4189:                 move.w 	#$FF15,-(a7)       * push flags=0xFFFF to the stack
00:00004C56 4E77            	  4190:                 rtr
                            	  4191: 
00:00004C58 40C0            	  4192: RTR_DONE:       move.w SR,d0
00:00004C5A 0240001F        	  4193:                 andi.w #$1F,d0
00:00004C5E 0C400015        	  4194:                 cmpi.w #$15,d0
00:00004C62 66FE            	  4195:                 bne.s *
                            	  4196: 
00:00004C64 4E75            	  4197:                 rts
                            	  4198: 
                            	  4199: 
00:00004C66 283C44444444    	  4200: BSR_FAR2:       move.l #$44444444,d4
00:00004C6C 4E75            	  4201:                 rts
                            	  4202: 
                            	  4203: 
                            	  4204: *-----------------------------------------------------------
                            	  4205: *-----------------------------------------------------------
                            	  4206: * OPCODE : BCC
                            	  4207: *-----------------------------------------------------------
                            	  4208: *-----------------------------------------------------------
                            	  4209: 
00:00004C6E 44FC0000        	  4210: op_BCC:         move #$00,CCR
00:00004C72 6202            	  4211:                 bhi.s BCC1            * Higher Than         C=0 AND Z=0
00:00004C74 60FE            	  4212:                 bra.s *
                            	  4213: 
00:00004C76 44FC0001        	  4214: BCC1:           move #$01,CCR
00:00004C7A 63000004        	  4215:                 bls.w BCC2            * Lower or Same       C=1 OR Z=1
00:00004C7E 60FE            	  4216:                 bra.s *
                            	  4217: 
00:00004C80 44FC0000        	  4218: BCC2:           move #$00,CCR
00:00004C84 6402            	  4219:                 bcc.s BCC3            * Carry Clear         C=0
00:00004C86 60FE            	  4220:                 bra.s *
                            	  4221: 
00:00004C88 44FC0001        	  4222: BCC3:           move #$01,CCR
00:00004C8C 65000004        	  4223:                 bcs.w BCC4            * Carry Set           C=1
00:00004C90 60FE            	  4224:                 bra.s *
                            	  4225: 
00:00004C92 44FC0000        	  4226: BCC4:           move #$00,CCR
00:00004C96 6602            	  4227:                 bne.s BCC5            * Not Equal           Z=0
00:00004C98 60FE            	  4228:                 bra.s *
                            	  4229: 
00:00004C9A 44FC0004        	  4230: BCC5:           move #$04,CCR
00:00004C9E 67000004        	  4231:                 beq.w BCC6            * Equal               Z=1
00:00004CA2 60FE            	  4232:                 bra.s *
                            	  4233: 
00:00004CA4 44FC0000        	  4234: BCC6:           move #$00,CCR
00:00004CA8 6802            	  4235:                 bvc.s BCC7            * V Clear             V=0
00:00004CAA 60FE            	  4236:                 bra.s *
                            	  4237: 
00:00004CAC 44FC0002        	  4238: BCC7:           move #$02,CCR
00:00004CB0 69000004        	  4239:                 bvs.w BCC8            * V Set               V=1
00:00004CB4 60FE            	  4240:                 bra.s *
                            	  4241: 
00:00004CB6 44FC0000        	  4242: BCC8:           move #$00,CCR
00:00004CBA 6A02            	  4243:                 bpl.s BCC9            * Plus                N=0
00:00004CBC 60FE            	  4244:                 bra.s *
                            	  4245: 
00:00004CBE 44FC0008        	  4246: BCC9:           move #$08,CCR
00:00004CC2 6B000004        	  4247:                 bmi.w BCC10           * Minus               N=1
00:00004CC6 60FE            	  4248:                 bra.s *
                            	  4249: 
00:00004CC8 44FC0000        	  4250: BCC10:          move #$00,CCR
00:00004CCC 6C02            	  4251:                 bge.s BCC11           * Greater or Equal    N=V
00:00004CCE 60FE            	  4252:                 bra.s *
                            	  4253: 
00:00004CD0 44FC0002        	  4254: BCC11:          move #$02,CCR
00:00004CD4 6D000004        	  4255:                 blt.w BCC12           * Less Than           N!=V
00:00004CD8 60FE            	  4256:                 bra.s *
                            	  4257: 
00:00004CDA 44FC000A        	  4258: BCC12:          move #$0A,CCR
00:00004CDE 6E02            	  4259:                 bgt.s BCC13           * Greater Than        N=V  AND Z=0
00:00004CE0 60FE            	  4260:                 bra.s *
                            	  4261: 
00:00004CE2 44FC0006        	  4262: BCC13:          move #$06,CCR
00:00004CE6 6F000004        	  4263:                 ble.w BCC14           * Less Than or Equal  N!=V AND Z=1
00:00004CEA 60FE            	  4264:                 bra.s *
                            	  4265: 
                            	  4266: 
00:00004CEC 4E75            	  4267: BCC14:          rts
                            	  4268: 
                            	  4269: 
                            	  4270: *-----------------------------------------------------------
                            	  4271: *-----------------------------------------------------------
                            	  4272: * OPCODE : DBCC
                            	  4273: *-----------------------------------------------------------
                            	  4274: *-----------------------------------------------------------
                            	  4275: 
00:00004CEE 7003            	  4276: op_DBCC:        moveq  #$00000003,d0    * Loop counter
00:00004CF0 7200            	  4277:                 moveq  #$00000000,d1    * Accumulator
00:00004CF2 44FC0000        	  4278:                 move #$00,CCR
                            	  4279: 
00:00004CF6 5201            	  4280: DBCC_LOOP1:     addi.b #$1,d1
00:00004CF8 51C8FFFC        	  4281:                 dbf d0,DBCC_LOOP1
                            	  4282: 
00:00004CFC 0C8100000004    	  4283:                 cmpi.l #$00000004,d1  * Check Accumulator results
00:00004D02 66FE            	  4284:                 bne.s *
                            	  4285: 
00:00004D04 5201            	  4286: DBCC_LOOP2:     addi.b #$1,d1
00:00004D06 54C8FFFC        	  4287:                 dbcc d0,DBCC_LOOP2    * Dont loop
                            	  4288: 
00:00004D0A 0C8100000005    	  4289:                 cmpi.l #$00000005,d1  * Check Accumulator results
00:00004D10 66FE            	  4290:                 bne.s *
                            	  4291: 
00:00004D12 4E75            	  4292:                 rts
                            	  4293: 
                            	  4294: 
                            	  4295: *-----------------------------------------------------------
                            	  4296: *-----------------------------------------------------------
                            	  4297: * OPCODE : SCC
                            	  4298: *-----------------------------------------------------------
                            	  4299: *-----------------------------------------------------------
                            	  4300: 
00:00004D14 44FC0001        	  4301: op_SCC:         move #$01,CCR
00:00004D18 54F900010000    	  4302:                 scc $00010000                   * Clear the EA byte
00:00004D1E 4A3900010000    	  4303:                 cmpi.b #$00,$00010000
00:00004D24 66FE            	  4304:                 bne.s *
                            	  4305: 
00:00004D26 44FC0000        	  4306:                 move #$00,CCR
00:00004D2A 54F900010000    	  4307:                 scc $00010000                   * Set the EA byte to 0xFF
00:00004D30 0C3900FF00010000	  4308:                 cmpi.b #$FF,$00010000
00:00004D38 66FE            	  4309:                 bne.s *
                            	  4310: 
00:00004D3A 54C0            	  4311: 								scc d0													* Test setting a data register
00:00004D3C 0C0000FF        	  4312: 								cmpi.b #$FF,d0
00:00004D40 66FE            	  4313: 								bne.s *
00:00004D42 4E75            	  4314:                 rts
                            	  4315: 
                            	  4316: 
                            	  4317: 
                            	  4318: *-----------------------------------------------------------
                            	  4319: *-----------------------------------------------------------
                            	  4320: * OPCODE : ADDQ
                            	  4321: *-----------------------------------------------------------
                            	  4322: *-----------------------------------------------------------
                            	  4323: 
                            	  4324: op_ADDQ:
                            	  4325: 
                            	  4326: *     BYTE
00:00004D44 203C000000FF    	  4327:                 move.l #$000000FF,d0    * Loop counter
00:00004D4A 7200            	  4328:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004D4C 7400            	  4329:                 moveq  #$00000000,d2    * Data results accumulator
00:00004D4E 7600            	  4330:                 moveq  #$00000000,d3
00:00004D50 7800            	  4331:                 moveq  #$00000000,d4
00:00004D52 7A00            	  4332:                 moveq  #$00000000,d5
00:00004D54 7C00            	  4333:                 moveq  #$00000000,d6
00:00004D56 7E00            	  4334:                 moveq  #$00000000,d7
                            	  4335: 
00:00004D58 5605            	  4336: ADDQ_LOOP1:     addq.b #3,d5
00:00004D5A 40C6            	  4337:                 move.w SR,d6
00:00004D5C 02860000001F    	  4338:                 andi.l #$1F,d6        * Isolate flags
00:00004D62 D286            	  4339:                 add.l d6,d1           * Copy flag results into accumulator
00:00004D64 D485            	  4340:                 add.l d5,d2           * Copy data results into data accumulator
00:00004D66 51C8FFF0        	  4341:                 dbf d0,ADDQ_LOOP1
                            	  4342: 
00:00004D6A 0C810000043D    	  4343:                 cmpi.l #$0000043D,d1
00:00004D70 66FE            	  4344:                 bne.s *
00:00004D72 0C8200007F80    	  4345:                 cmpi.l #$00007F80,d2
00:00004D78 66FE            	  4346:                 bne.s *
                            	  4347: 
                            	  4348: 
                            	  4349: *     WORD
00:00004D7A 203C000000FF    	  4350:                 move.l #$000000FF,d0    * Loop counter
00:00004D80 7200            	  4351:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004D82 7400            	  4352:                 moveq  #$00000000,d2    * Data results accumulator
00:00004D84 7600            	  4353:                 moveq  #$00000000,d3
00:00004D86 7800            	  4354:                 moveq  #$00000000,d4
00:00004D88 2A3C0000FFF0    	  4355:                 move.l #$0000FFF0,d5
00:00004D8E 7C00            	  4356:                 moveq  #$00000000,d6
00:00004D90 7E00            	  4357:                 moveq  #$00000000,d7
00:00004D92 307C0100        	  4358:                 move.l #$00000100,a0
                            	  4359: 
00:00004D96 5A45            	  4360: ADDQ_LOOP2:     addq.w #5,d5
00:00004D98 40C6            	  4361:                 move.w SR,d6
00:00004D9A 02860000001F    	  4362:                 andi.l #$1F,d6        * Isolate flags
00:00004DA0 D286            	  4363:                 add.l d6,d1           * Copy flag results into accumulator
00:00004DA2 D485            	  4364:                 add.l d5,d2           * Copy data results into data accumulator
00:00004DA4 51C8FFF0        	  4365:                 dbf d0,ADDQ_LOOP2
                            	  4366: 
00:00004DA8 0C8100000029    	  4367:                 cmpi.l #$00000029,d1
00:00004DAE 66FE            	  4368:                 bne.s *
00:00004DB0 0C8200057280    	  4369:                 cmpi.l #$00057280,d2
00:00004DB6 66FE            	  4370:                 bne.s *
                            	  4371: 
                            	  4372: 
                            	  4373: *     LONG
00:00004DB8 203C000000FF    	  4374:                 move.l #$000000FF,d0    * Loop counter
00:00004DBE 7200            	  4375:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004DC0 7400            	  4376:                 moveq  #$00000000,d2    * Data results accumulator
00:00004DC2 7600            	  4377:                 moveq  #$00000000,d3
00:00004DC4 7800            	  4378:                 moveq  #$00000000,d4
00:00004DC6 7AF0            	  4379:                 move.l #$FFFFFFF0,d5
00:00004DC8 7C00            	  4380:                 moveq  #$00000000,d6
00:00004DCA 7E00            	  4381:                 moveq  #$00000000,d7
                            	  4382: 
00:00004DCC 5285            	  4383: ADDQ_LOOP3:     addq.l #1,d5
00:00004DCE 40C6            	  4384:                 move.w SR,d6
00:00004DD0 02860000001F    	  4385:                 andi.l #$1F,d6        * Isolate flags
00:00004DD6 D286            	  4386:                 add.l d6,d1           * Copy flag results into accumulator
00:00004DD8 D485            	  4387:                 add.l d5,d2           * Copy data results into data accumulator
00:00004DDA 51C8FFF0        	  4388:                 dbf d0,ADDQ_LOOP3
                            	  4389: 
00:00004DDE 0C810000008D    	  4390:                 cmpi.l #$0000008D,d1
00:00004DE4 66FE            	  4391:                 bne.s *
00:00004DE6 0C8200007080    	  4392:                 cmpi.l #$00007080,d2
00:00004DEC 66FE            	  4393:                 bne.s *
                            	  4394: 
                            	  4395: *     Check that Flags are not updated for Address registers
00:00004DEE 207C0000FFFF    	  4396:                 move.l #$0000FFFF,a0
00:00004DF4 44FC0000        	  4397:                 move #$00,CCR         * Clear flags
00:00004DF8 5E48            	  4398:                 addq.w #$7,a0
00:00004DFA 65FE            	  4399:                 bcs.s *
                            	  4400: 
00:00004DFC 4E75            	  4401:                 rts
                            	  4402: 
                            	  4403: 
                            	  4404: 
                            	  4405: *-----------------------------------------------------------
                            	  4406: *-----------------------------------------------------------
                            	  4407: * OPCODE : SUBQ
                            	  4408: *-----------------------------------------------------------
                            	  4409: *-----------------------------------------------------------
                            	  4410: 
                            	  4411: op_SUBQ:
                            	  4412: 
                            	  4413: *     BYTE
00:00004DFE 203C000000FF    	  4414:                 move.l #$000000FF,d0    * Loop counter
00:00004E04 7200            	  4415:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004E06 243C00001234    	  4416:                 move.l #$00001234,d2    * Data results accumulator
00:00004E0C 7600            	  4417:                 moveq  #$00000000,d3
00:00004E0E 7800            	  4418:                 moveq  #$00000000,d4
00:00004E10 7A12            	  4419:                 moveq  #$00000012,d5
00:00004E12 7C00            	  4420:                 moveq  #$00000000,d6
00:00004E14 7E00            	  4421:                 moveq  #$00000000,d7
                            	  4422: 
00:00004E16 5305            	  4423: SUBQ_LOOP1:     subq.b #1,d5
00:00004E18 40C6            	  4424:                 move.w SR,d6
00:00004E1A 02860000001F    	  4425:                 andi.l #$1F,d6        * Isolate flags
00:00004E20 D286            	  4426:                 add.l d6,d1           * Copy flag results into accumulator
00:00004E22 D485            	  4427:                 add.l d5,d2           * Copy data results into data accumulator
00:00004E24 51C8FFF0        	  4428:                 dbf d0,SUBQ_LOOP1
                            	  4429: 
00:00004E28 0C8100000417    	  4430:                 cmpi.l #$00000417,d1
00:00004E2E 66FE            	  4431:                 bne.s *
00:00004E30 0C82000091B4    	  4432:                 cmpi.l #$000091B4,d2
00:00004E36 66FE            	  4433:                 bne.s *
                            	  4434: 
                            	  4435: 
                            	  4436: *     WORD
00:00004E38 203C000000FF    	  4437:                 move.l #$000000FF,d0    * Loop counter
00:00004E3E 7200            	  4438:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004E40 7400            	  4439:                 moveq  #$00000000,d2    * Data results accumulator
00:00004E42 7600            	  4440:                 moveq  #$00000000,d3
00:00004E44 7800            	  4441:                 moveq  #$00000000,d4
00:00004E46 7A02            	  4442:                 moveq  #$00000002,d5
00:00004E48 7C00            	  4443:                 moveq  #$00000000,d6
00:00004E4A 7E00            	  4444:                 moveq  #$00000000,d7
00:00004E4C 307C0100        	  4445:                 move.l #$00000100,a0
                            	  4446: 
00:00004E50 5B45            	  4447: SUBQ_LOOP2:     subq.w #5,d5
00:00004E52 40C6            	  4448:                 move.w SR,d6
00:00004E54 02860000001F    	  4449:                 andi.l #$1F,d6        * Isolate flags
00:00004E5A D286            	  4450:                 add.l d6,d1           * Copy flag results into accumulator
00:00004E5C D485            	  4451:                 add.l d5,d2           * Copy data results into data accumulator
00:00004E5E 51C8FFF0        	  4452:                 dbf d0,SUBQ_LOOP2
                            	  4453: 
00:00004E62 0C8100000811    	  4454:                 cmpi.l #$00000811,d1
00:00004E68 66FE            	  4455:                 bne.s *
00:00004E6A 0C8200FD7F80    	  4456:                 cmpi.l #$00FD7F80,d2
00:00004E70 66FE            	  4457:                 bne.s *
                            	  4458: 
                            	  4459: 
                            	  4460: *     LONG
00:00004E72 203C000000FF    	  4461:                 move.l #$000000FF,d0    * Loop counter
00:00004E78 7200            	  4462:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004E7A 7400            	  4463:                 moveq  #$00000000,d2    * Data results accumulator
00:00004E7C 7600            	  4464:                 moveq  #$00000000,d3
00:00004E7E 7800            	  4465:                 moveq  #$00000000,d4
00:00004E80 7A07            	  4466:                 moveq  #$00000007,d5
00:00004E82 7C00            	  4467:                 moveq  #$00000000,d6
00:00004E84 7E00            	  4468:                 moveq  #$00000000,d7
                            	  4469: 
00:00004E86 5385            	  4470: SUBQ_LOOP3:     subq.l #1,d5
00:00004E88 40C6            	  4471:                 move.w SR,d6
00:00004E8A 02860000001F    	  4472:                 andi.l #$1F,d6        * Isolate flags
00:00004E90 D286            	  4473:                 add.l d6,d1           * Copy flag results into accumulator
00:00004E92 D485            	  4474:                 add.l d5,d2           * Copy data results into data accumulator
00:00004E94 51C8FFF0        	  4475:                 dbf d0,SUBQ_LOOP3
                            	  4476: 
00:00004E98 0C81000007DD    	  4477:                 cmpi.l #$000007DD,d1
00:00004E9E 66FE            	  4478:                 bne.s *
00:00004EA0 0C82FFFF8680    	  4479:                 cmpi.l #$FFFF8680,d2
00:00004EA6 66FE            	  4480:                 bne.s *
                            	  4481: 
                            	  4482: *     Check that Flags are not updated for Address registers
00:00004EA8 207C0001FFFF    	  4483:                 move.l #$0001FFFF,a0
00:00004EAE 44FC0000        	  4484:                 move #$00,CCR         * Clear flags
00:00004EB2 5F48            	  4485:                 subq.w #$7,a0
00:00004EB4 65FE            	  4486:                 bcs.s *
                            	  4487: 
00:00004EB6 4E75            	  4488:                 rts
                            	  4489: 
                            	  4490: 
                            	  4491: 
                            	  4492: 
                            	  4493: *-----------------------------------------------------------
                            	  4494: *-----------------------------------------------------------
                            	  4495: * OPCODE : MOVEQ
                            	  4496: *-----------------------------------------------------------
                            	  4497: *-----------------------------------------------------------
                            	  4498: 
                            	  4499: op_MOVEQ:
00:00004EB8 7000            	  4500:                 moveq  #$00000000,d0
00:00004EBA 7000            	  4501:                 moveq #$0,d0
00:00004EBC 66FE            	  4502:                 bne.s *
00:00004EBE 4A80            	  4503:                 cmpi.l #$00000000,d0
00:00004EC0 66FE            	  4504:                 bne.s *
                            	  4505: 
00:00004EC2 7000            	  4506:                 moveq  #$00000000,d0
00:00004EC4 7080            	  4507:                 moveq #-128,d0
00:00004EC6 67FE            	  4508:                 beq.s *
00:00004EC8 6AFE            	  4509:                 bpl.s *
00:00004ECA 0C80FFFFFF80    	  4510:                 cmpi.l #$FFFFFF80,d0
00:00004ED0 66FE            	  4511:                 bne.s *
                            	  4512: 
                            	  4513: 
00:00004ED2 4E75            	  4514:                 rts
                            	  4515: 
                            	  4516: 
                            	  4517: *-----------------------------------------------------------
                            	  4518: *-----------------------------------------------------------
                            	  4519: * OPCODE : DIVU
                            	  4520: *-----------------------------------------------------------
                            	  4521: *-----------------------------------------------------------
                            	  4522: 
                            	  4523: op_DIVU:
                            	  4524: 
00:00004ED4 203CA5A5A5A5    	  4525:                 move.l #$a5a5a5a5,d0        * Initial Numerator
00:00004EDA 223C00005A5A    	  4526:                 move.l #$00005a5a,d1        * Initial Divisor
00:00004EE0 243CA5A5A5A5    	  4527:                 move.l #$a5a5a5a5,d2
00:00004EE6 7600            	  4528:                 moveq  #$00000000,d3
00:00004EE8 7800            	  4529:                 moveq  #$00000000,d4        * Cumulative data results
00:00004EEA 7A00            	  4530:                 moveq  #$00000000,d5       * Cumulative flag results
00:00004EEC 7C0E            	  4531:                 move.l #$0000000E,d6       * Inner loop counter
00:00004EEE 7E1E            	  4532:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4533: 
                            	  4534: 
00:00004EF0 80C1            	  4535: DIVU_OUTER1:    divu d1,d0               * !! Easy68K C not always cleared
00:00004EF2 40C3            	  4536:                 move.w SR,d3
00:00004EF4 02830000000C    	  4537:                 andi.l #$0C,d3            * Isolate flags
00:00004EFA DA83            	  4538:                 add.l d3,d5               * Copy flag results into accumulator
00:00004EFC D880            	  4539:                 add.l d0,d4               * Copy data results into data accumulator
00:00004EFE E289            	  4540:                 lsr.l #$1,d1
                            	  4541: 
00:00004F00 51CEFFEE        	  4542:                 dbf d6,DIVU_OUTER1
00:00004F04 E28A            	  4543:                 lsr.l #$1,d2
00:00004F06 2002            	  4544:                 move.l d2,d0
00:00004F08 223C00005A5A    	  4545:                 move.l #$00005a5a,d1       * Initial Divisor
00:00004F0E 7C0E            	  4546:                 move.l #$0000000E,d6       * Inner loop counter
00:00004F10 51CFFFDE        	  4547:                 dbf d7,DIVU_OUTER1
                            	  4548: 
00:00004F14 0C8492FEDB89    	  4549:                 cmpi.l #$92FEDB89,d4      * Check the data results
00:00004F1A 66FE            	  4550:                 bne.s *
                            	  4551: 
00:00004F1C 0C8500000110    	  4552:                 cmpi.l #$00000110,d5      * Check the Flag results
00:00004F22 66FE            	  4553:                 bne.s *
                            	  4554: 
                            	  4555: 
00:00004F24 4E75            	  4556:                 rts
                            	  4557: 
                            	  4558: 
                            	  4559: 
                            	  4560: *-----------------------------------------------------------
                            	  4561: *-----------------------------------------------------------
                            	  4562: * OPCODE : DIVS
                            	  4563: *-----------------------------------------------------------
                            	  4564: *-----------------------------------------------------------
                            	  4565: 
                            	  4566: op_DIVS:
                            	  4567: 
00:00004F26 203CA5A5A5A5    	  4568: 	move.l #$a5a5a5a5,d0        * Initial Numerator
00:00004F2C 223C00005A5A    	  4569: 	move.l #$00005a5a,d1        * Initial Divisor
00:00004F32 243CA5A5A5A5    	  4570: 	move.l #$a5a5a5a5,d2
00:00004F38 7600            	  4571: 	moveq  #$00000000,d3
00:00004F3A 7800            	  4572: 	moveq  #$00000000,d4        * Cumulative data results
00:00004F3C 7A00            	  4573: 	moveq  #$00000000,d5       * Cumulative flag results
00:00004F3E 7C0E            	  4574: 	move.l #$0000000E,d6       * Inner loop counter
00:00004F40 7E1E            	  4575: 	move.l #$0000001E,d7       * Outer loop counter
                            	  4576: 
                            	  4577: DIVS_OUTER1:
00:00004F42 81C1            	  4578: 	divs d1,d0               * !! Easy68K C not always cleared
00:00004F44 40C3            	  4579: 	move.w SR,d3
00:00004F46 02830000000C    	  4580: 	andi.l #$0C,d3            * Isolate flags
00:00004F4C DA83            	  4581: 	add.l d3,d5               * Copy flag results into accumulator
00:00004F4E D880            	  4582: 	add.l d0,d4               * Copy data results into data accumulator
00:00004F50 E289            	  4583: 	lsr.l #$1,d1
                            	  4584: 
00:00004F52 51CEFFEE        	  4585: 	dbf d6,DIVS_OUTER1
00:00004F56 E28A            	  4586: 	lsr.l #$1,d2
00:00004F58 2002            	  4587: 	move.l d2,d0
00:00004F5A 223C00005A5A    	  4588: 	move.l #$00005a5a,d1       * Initial Divisor
00:00004F60 7C0E            	  4589: 	move.l #$0000000E,d6       * Inner loop counter
00:00004F62 51CFFFDE        	  4590: 	dbf d7,DIVS_OUTER1
                            	  4591: 
00:00004F66 0C844EC5D057    	  4592: 	cmpi.l #$4EC5D057,d4      * Check the data results
00:00004F6C 66FE            	  4593: 	bne.s *
                            	  4594: 
00:00004F6E 0C8500000038    	  4595: 	cmpi.l #$00000038,d5      * Check the Flag results
00:00004F74 66FE            	  4596: 	bne.s *
00:00004F76 4E75            	  4597: 	rts
                            	  4598: 
                            	  4599: 
                            	  4600: *-----------------------------------------------------------
                            	  4601: *-----------------------------------------------------------
                            	  4602: * OPCODE : OR
                            	  4603: *-----------------------------------------------------------
                            	  4604: *-----------------------------------------------------------
                            	  4605: 
                            	  4606: op_OR:
                            	  4607: 
                            	  4608: *  * <EA> to Register
                            	  4609: 
00:00004F78 203CA5A5A5A5    	  4610:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00004F7E 223C8167E123    	  4611:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00004F84 243CA5A5A5A5    	  4612:                 move.l #$a5a5a5a5,d2
00:00004F8A 7600            	  4613:                 moveq  #$00000000,d3
00:00004F8C 7800            	  4614:                 moveq  #$00000000,d4       * Cumulative data results
00:00004F8E 7A00            	  4615:                 moveq  #$00000000,d5       * Cumulative flag results
00:00004F90 7C1E            	  4616:                 move.l #$0000001E,d6       * Inner loop counter
00:00004F92 7E1E            	  4617:                 move.l #$0000001E,d7       * Outer loop counter
00:00004F94 307C0100        	  4618:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4619: 
                            	  4620: 
                            	  4621: OR_OUTER1:
                            	  4622: 
                            	  4623: *     BYTE
00:00004F98 2081            	  4624:                 move.l d1,(a0)
00:00004F9A 8010            	  4625:                 or.b (a0),d0
00:00004F9C 40C3            	  4626:                 move.w SR,d3
00:00004F9E 02830000000C    	  4627:                 andi.l #$0C,d3            * Isolate flags
00:00004FA4 DA83            	  4628:                 add.l d3,d5               * Copy flag results into accumulator
00:00004FA6 D880            	  4629:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4630: 
                            	  4631: *     WORD
00:00004FA8 2081            	  4632:                 move.l d1,(a0)
00:00004FAA 8050            	  4633:                 or.w (a0),d0
00:00004FAC 40C3            	  4634:                 move.w SR,d3
00:00004FAE 02830000000C    	  4635:                 andi.l #$0C,d3            * Isolate flags
00:00004FB4 DA83            	  4636:                 add.l d3,d5               * Copy flag results into accumulator
00:00004FB6 D880            	  4637:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4638: 
                            	  4639: *     LONG
00:00004FB8 2081            	  4640:                 move.l d1,(a0)
00:00004FBA 8090            	  4641:                 or.l (a0),d0
00:00004FBC 40C3            	  4642:                 move.w SR,d3
00:00004FBE 02830000000F    	  4643:                 andi.l #$0F,d3            * Isolate flags
00:00004FC4 DA83            	  4644:                 add.l d3,d5               * Copy flag results into accumulator
00:00004FC6 D880            	  4645:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4646: 
                            	  4647: 
00:00004FC8 E289            	  4648:                 lsr.l #$1,d1
00:00004FCA 51CEFFCC        	  4649:                 dbf d6,OR_OUTER1
00:00004FCE E28A            	  4650:                 lsr.l #$1,d2
00:00004FD0 223C8167E123    	  4651:                 move.l #$8167E123,d1       * Initial Data-Y
00:00004FD6 7C1E            	  4652:                 move.l #$0000001E,d6       * Inner loop counter
00:00004FD8 51CFFFBE        	  4653:                 dbf d7,OR_OUTER1
                            	  4654: 
00:00004FDC 0C8476EAC803    	  4655:                 cmpi.l #$76EAC803,d4      * Check the data results
00:00004FE2 66FE            	  4656:                 bne.s *
00:00004FE4 0C8500005A18    	  4657:                 cmpi.l #$00005A18,d5      * Check the Flag results
00:00004FEA 66FE            	  4658:                 bne.s *
                            	  4659: 
                            	  4660: 
                            	  4661: *  * Register to <EA>
                            	  4662: 
00:00004FEC 203C86738374    	  4663:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:00004FF2 223CFC55F2FE    	  4664:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:00004FF8 243C86738374    	  4665:                 move.l #$86738374,d2
00:00004FFE 7600            	  4666:                 moveq  #$00000000,d3
00:00005000 7800            	  4667:                 moveq  #$00000000,d4       * Cumulative data results
00:00005002 7A00            	  4668:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005004 7C1E            	  4669:                 move.l #$0000001E,d6       * Inner loop counter
00:00005006 7E1D            	  4670:                 move.l #$0000001D,d7       * Outer loop counter
00:00005008 307C0100        	  4671:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4672: 
                            	  4673: 
                            	  4674: OR_OUTER2:
                            	  4675: 
                            	  4676: *     BYTE
00:0000500C 2080            	  4677:                 move.l d0,(a0)
00:0000500E 8310            	  4678:                 or.b d1,(a0)
00:00005010 40C3            	  4679:                 move.w SR,d3
00:00005012 02830000000C    	  4680:                 andi.l #$0C,d3            * Isolate flags
00:00005018 DA83            	  4681:                 add.l d3,d5               * Copy flag results into accumulator
00:0000501A D890            	  4682:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4683: 
                            	  4684: *     WORD
00:0000501C 2080            	  4685:                 move.l d0,(a0)
00:0000501E 8350            	  4686:                 or.w d1,(a0)
00:00005020 40C3            	  4687:                 move.w SR,d3
00:00005022 02830000000C    	  4688:                 andi.l #$0C,d3            * Isolate flags
00:00005028 DA83            	  4689:                 add.l d3,d5               * Copy flag results into accumulator
00:0000502A D890            	  4690:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4691: 
                            	  4692: *     LONG
00:0000502C 2080            	  4693:                 move.l d0,(a0)
00:0000502E 8390            	  4694:                 or.l d1,(a0)
00:00005030 40C3            	  4695:                 move.w SR,d3
00:00005032 02830000000F    	  4696:                 andi.l #$0F,d3            * Isolate flags
00:00005038 DA83            	  4697:                 add.l d3,d5               * Copy flag results into accumulator
00:0000503A D890            	  4698:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4699: 
                            	  4700: 
00:0000503C E289            	  4701:                 lsr.l #$1,d1
00:0000503E 51CEFFCC        	  4702:                 dbf d6,OR_OUTER2
00:00005042 E28A            	  4703:                 lsr.l #$1,d2
00:00005044 223C8167E123    	  4704:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000504A 7C1E            	  4705:                 move.l #$0000001E,d6       * Inner loop counter
00:0000504C 51CFFFBE        	  4706:                 dbf d7,OR_OUTER2
                            	  4707: 
00:00005050 0C84FA82B9E4    	  4708:                 cmpi.l #$FA82B9E4,d4      * Check the data results
00:00005056 66FE            	  4709:                 bne.s *
00:00005058 0C8500005730    	  4710:                 cmpi.l #$00005730,d5      * Check the Flag results
00:0000505E 66FE            	  4711:                 bne.s *
                            	  4712: 
                            	  4713: 
00:00005060 4E75            	  4714:                 rts
                            	  4715: 
                            	  4716: 
                            	  4717: 
                            	  4718: *-----------------------------------------------------------
                            	  4719: *-----------------------------------------------------------
                            	  4720: * OPCODE : AND
                            	  4721: *-----------------------------------------------------------
                            	  4722: *-----------------------------------------------------------
                            	  4723: 
                            	  4724: op_AND:
                            	  4725: 
                            	  4726: *  * <EA> to Register
                            	  4727: 
00:00005062 203CA5A5A5A5    	  4728:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00005068 223C8167E123    	  4729:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:0000506E 243CA5A5A5A5    	  4730:                 move.l #$a5a5a5a5,d2
00:00005074 7600            	  4731:                 moveq  #$00000000,d3
00:00005076 7800            	  4732:                 moveq  #$00000000,d4       * Cumulative data results
00:00005078 7A00            	  4733:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000507A 7C1E            	  4734:                 move.l #$0000001E,d6       * Inner loop counter
00:0000507C 7E1E            	  4735:                 move.l #$0000001E,d7       * Outer loop counter
00:0000507E 307C0100        	  4736:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4737: 
                            	  4738: 
                            	  4739: AND_OUTER1:
                            	  4740: 
                            	  4741: *     BYTE
00:00005082 2081            	  4742:                 move.l d1,(a0)
00:00005084 C010            	  4743:                 and.b (a0),d0
00:00005086 40C3            	  4744:                 move.w sr,d3
00:00005088 02830000000C    	  4745:                 andi.l #$0C,d3            * Isolate flags
00:0000508E DA83            	  4746:                 add.l d3,d5               * Copy flag results into accumulator
00:00005090 D880            	  4747:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4748: 
                            	  4749: *     WORD
00:00005092 2081            	  4750:                 move.l d1,(a0)
00:00005094 C050            	  4751:                 and.w (a0),d0
00:00005096 40C3            	  4752:                 move.w sr,d3
00:00005098 02830000000C    	  4753:                 andi.l #$0C,d3            * Isolate flags
00:0000509E DA83            	  4754:                 add.l d3,d5               * Copy flag results into accumulator
00:000050A0 D880            	  4755:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4756: 
                            	  4757: *     LONG
00:000050A2 2081            	  4758:                 move.l d1,(a0)
00:000050A4 C090            	  4759:                 and.l (a0),d0
00:000050A6 40C3            	  4760:                 move.w sr,d3
00:000050A8 02830000000F    	  4761:                 andi.l #$0F,d3            * Isolate flags
00:000050AE DA83            	  4762:                 add.l d3,d5               * Copy flag results into accumulator
00:000050B0 D880            	  4763:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4764: 
                            	  4765: 
00:000050B2 E289            	  4766:                 lsr.l #$1,d1
00:000050B4 51CEFFCC        	  4767:                 dbf d6,AND_OUTER1
00:000050B8 E28A            	  4768:                 lsr.l #$1,d2
00:000050BA 223C8167E123    	  4769:                 move.l #$8167E123,d1       * Initial Data-Y
00:000050C0 7C1E            	  4770:                 move.l #$0000001E,d6       * Inner loop counter
00:000050C2 51CFFFBE        	  4771:                 dbf d7,AND_OUTER1
                            	  4772: 
00:000050C6 0C84CF212883    	  4773:                 cmpi.l #$CF212883,d4      * Check the data results
00:000050CC 66FE            	  4774:                 bne.s *
00:000050CE 0C8500002D10    	  4775:                 cmpi.l #$00002D10,d5      * Check the Flag results
00:000050D4 66FE            	  4776:                 bne.s *
                            	  4777: 
                            	  4778: 
                            	  4779: *  * Register to <EA>
                            	  4780: 
00:000050D6 203C86738374    	  4781:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:000050DC 223CFC55F2FE    	  4782:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:000050E2 243C86738374    	  4783:                 move.l #$86738374,d2
00:000050E8 7600            	  4784:                 moveq  #$00000000,d3
00:000050EA 7800            	  4785:                 moveq  #$00000000,d4       * Cumulative data results
00:000050EC 7A00            	  4786:                 moveq  #$00000000,d5       * Cumulative flag results
00:000050EE 7C1E            	  4787:                 move.l #$0000001E,d6       * Inner loop counter
00:000050F0 7E1D            	  4788:                 move.l #$0000001D,d7       * Outer loop counter
00:000050F2 307C0100        	  4789:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4790: 
                            	  4791: 
                            	  4792: AND_OUTER2:
                            	  4793: 
                            	  4794: *     BYTE
00:000050F6 2080            	  4795:                 move.l d0,(a0)
00:000050F8 C310            	  4796:                 and.b d1,(a0)
00:000050FA 40C3            	  4797:                 move.w sr,d3
00:000050FC 02830000000C    	  4798:                 andi.l #$0C,d3            * Isolate flags
00:00005102 DA83            	  4799:                 add.l d3,d5               * Copy flag results into accumulator
00:00005104 D890            	  4800:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4801: 
                            	  4802: *     WORD
00:00005106 2080            	  4803:                 move.l d0,(a0)
00:00005108 C350            	  4804:                 and.w d1,(a0)
00:0000510A 40C3            	  4805:                 move.w sr,d3
00:0000510C 02830000000C    	  4806:                 andi.l #$0C,d3            * Isolate flags
00:00005112 DA83            	  4807:                 add.l d3,d5               * Copy flag results into accumulator
00:00005114 D890            	  4808:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4809: 
                            	  4810: *     LONG
00:00005116 2080            	  4811:                 move.l d0,(a0)
00:00005118 C390            	  4812:                 and.l d1,(a0)
00:0000511A 40C3            	  4813:                 move.w sr,d3
00:0000511C 02830000000F    	  4814:                 andi.l #$0F,d3            * Isolate flags
00:00005122 DA83            	  4815:                 add.l d3,d5               * Copy flag results into accumulator
00:00005124 D890            	  4816:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4817: 
                            	  4818: 
00:00005126 E289            	  4819:                 lsr.l #$1,d1
00:00005128 51CEFFCC        	  4820:                 dbf d6,AND_OUTER2
00:0000512C E28A            	  4821:                 lsr.l #$1,d2
00:0000512E 223C8167E123    	  4822:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005134 7C1E            	  4823:                 move.l #$0000001E,d6       * Inner loop counter
00:00005136 51CFFFBE        	  4824:                 dbf d7,AND_OUTER2
                            	  4825: 
00:0000513A 0C844A3DE544    	  4826:                 cmpi.l #$4A3DE544,d4      * Check the data results
00:00005140 66FE            	  4827:                 bne.s *
00:00005142 0C85000018E8    	  4828:                 cmpi.l #$000018E8,d5      * Check the Flag results
00:00005148 66FE            	  4829:                 bne.s *
                            	  4830: 
                            	  4831: 
00:0000514A 4E75            	  4832:                 rts
                            	  4833: 
                            	  4834: 
                            	  4835: 
                            	  4836: *-----------------------------------------------------------
                            	  4837: *-----------------------------------------------------------
                            	  4838: * OPCODE : EOR
                            	  4839: *-----------------------------------------------------------
                            	  4840: *-----------------------------------------------------------
                            	  4841: 
                            	  4842: op_EOR:
                            	  4843: 
                            	  4844: *  * Register to <EA>
                            	  4845: 
00:0000514C 203C86738374    	  4846:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:00005152 223CFC55F2FE    	  4847:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:00005158 243C86738374    	  4848:                 move.l #$86738374,d2
00:0000515E 7600            	  4849:                 moveq  #$00000000,d3
00:00005160 7800            	  4850:                 moveq  #$00000000,d4       * Cumulative data results
00:00005162 7A00            	  4851:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005164 7C1E            	  4852:                 move.l #$0000001E,d6       * Inner loop counter
00:00005166 7E1D            	  4853:                 move.l #$0000001D,d7       * Outer loop counter
00:00005168 307C0100        	  4854:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4855: 
                            	  4856: 
                            	  4857: EOR_OUTER2:
                            	  4858: 
                            	  4859: *     BYTE
00:0000516C 2080            	  4860:                 move.l d0,(a0)
00:0000516E B310            	  4861:                 eor.b d1,(a0)
00:00005170 40C3            	  4862:                 move.w sr,d3
00:00005172 02830000000C    	  4863:                 andi.l #$0C,d3            * Isolate flags
00:00005178 DA83            	  4864:                 add.l d3,d5               * Copy flag results into accumulator
00:0000517A D890            	  4865:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4866: 
                            	  4867: *     WORD
00:0000517C 2080            	  4868:                 move.l d0,(a0)
00:0000517E B350            	  4869:                 eor.w d1,(a0)
00:00005180 40C3            	  4870:                 move.w sr,d3
00:00005182 02830000000C    	  4871:                 andi.l #$0C,d3            * Isolate flags
00:00005188 DA83            	  4872:                 add.l d3,d5               * Copy flag results into accumulator
00:0000518A D890            	  4873:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4874: 
                            	  4875: *     LONG
00:0000518C 2080            	  4876:                 move.l d0,(a0)
00:0000518E B390            	  4877:                 eor.l d1,(a0)
00:00005190 40C3            	  4878:                 move.w sr,d3
00:00005192 02830000000F    	  4879:                 andi.l #$0F,d3            * Isolate flags
00:00005198 DA83            	  4880:                 add.l d3,d5               * Copy flag results into accumulator
00:0000519A D890            	  4881:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4882: 
                            	  4883: 
00:0000519C E289            	  4884:                 lsr.l #$1,d1
00:0000519E 51CEFFCC        	  4885:                 dbf d6,EOR_OUTER2
00:000051A2 E28A            	  4886:                 lsr.l #$1,d2
00:000051A4 223C8167E123    	  4887:                 move.l #$8167E123,d1       * Initial Data-Y
00:000051AA 7C1E            	  4888:                 move.l #$0000001E,d6       * Inner loop counter
00:000051AC 51CFFFBE        	  4889:                 dbf d7,EOR_OUTER2
                            	  4890: 
00:000051B0 0C8455C5EB70    	  4891:                 cmpi.l #$55C5EB70,d4      * Check the data results
00:000051B6 66FE            	  4892:                 bne.s *
00:000051B8 0C8500004430    	  4893:                 cmpi.l #$00004430,d5      * Check the Flag results
00:000051BE 66FE            	  4894:                 bne.s *
                            	  4895: 
                            	  4896: 
00:000051C0 4E75            	  4897:                 rts
                            	  4898: 
                            	  4899: 
                            	  4900: *-----------------------------------------------------------
                            	  4901: *-----------------------------------------------------------
                            	  4902: * OPCODE : CMP
                            	  4903: *-----------------------------------------------------------
                            	  4904: *-----------------------------------------------------------
                            	  4905: 
                            	  4906: op_CMP:
                            	  4907: 
                            	  4908: 
                            	  4909: *  * <EA> to Register
                            	  4910: 
00:000051C2 203CA5A5A5A5    	  4911:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000051C8 223C8167E123    	  4912:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:000051CE 243CA5A5A5A5    	  4913:                 move.l #$a5a5a5a5,d2
00:000051D4 7600            	  4914:                 moveq  #$00000000,d3
00:000051D6 7800            	  4915:                 moveq  #$00000000,d4       * Cumulative data results
00:000051D8 7A00            	  4916:                 moveq  #$00000000,d5       * Cumulative flag results
00:000051DA 7C1E            	  4917:                 move.l #$0000001E,d6       * Inner loop counter
00:000051DC 7E1E            	  4918:                 move.l #$0000001E,d7       * Outer loop counter
00:000051DE 307C0100        	  4919:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4920: 
                            	  4921: 
                            	  4922: CMP_OUTER1:
                            	  4923: 
                            	  4924: *     BYTE
00:000051E2 2081            	  4925:                 move.l d1,(a0)
00:000051E4 B010            	  4926:                 cmp.b (a0),d0
00:000051E6 40C3            	  4927:                 move.w sr,d3
00:000051E8 02830000000F    	  4928:                 andi.l #$0F,d3            * Isolate flags
00:000051EE DA83            	  4929:                 add.l d3,d5               * Copy flag results into accumulator
00:000051F0 D880            	  4930:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4931: 
                            	  4932: *     WORD
00:000051F2 2081            	  4933:                 move.l d1,(a0)
00:000051F4 B050            	  4934:                 cmp.w (a0),d0
00:000051F6 40C3            	  4935:                 move.w sr,d3
00:000051F8 02830000000F    	  4936:                 andi.l #$0F,d3            * Isolate flags
00:000051FE DA83            	  4937:                 add.l d3,d5               * Copy flag results into accumulator
00:00005200 D880            	  4938:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4939: 
                            	  4940: *     LONG
00:00005202 2081            	  4941:                 move.l d1,(a0)
00:00005204 B090            	  4942:                 cmp.l (a0),d0
00:00005206 40C3            	  4943:                 move.w sr,d3
00:00005208 02830000000F    	  4944:                 andi.l #$0F,d3            * Isolate flags
00:0000520E DA83            	  4945:                 add.l d3,d5               * Copy flag results into accumulator
00:00005210 D880            	  4946:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4947: 
                            	  4948: 
00:00005212 E289            	  4949:                 lsr.l #$1,d1
00:00005214 51CEFFCC        	  4950:                 dbf d6,CMP_OUTER1
00:00005218 E28A            	  4951:                 lsr.l #$1,d2
00:0000521A 223C8167E123    	  4952:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005220 7C1E            	  4953:                 move.l #$0000001E,d6       * Inner loop counter
00:00005222 51CFFFBE        	  4954:                 dbf d7,CMP_OUTER1
                            	  4955: 
00:00005226 0C847878712F    	  4956:                 cmpi.l #$7878712F,d4      * Check the data results
00:0000522C 66FE            	  4957:                 bne.s *
00:0000522E 0C8500005502    	  4958:                 cmpi.l #$00005502,d5      * Check the Flag results
00:00005234 66FE            	  4959:                 bne.s *
                            	  4960: 
                            	  4961: 
                            	  4962: 
00:00005236 4E75            	  4963:                 rts
                            	  4964: 
                            	  4965: 
                            	  4966: *-----------------------------------------------------------
                            	  4967: *-----------------------------------------------------------
                            	  4968: * OPCODE : CMPA
                            	  4969: *-----------------------------------------------------------
                            	  4970: *-----------------------------------------------------------
                            	  4971: 
                            	  4972: op_CMPA:
                            	  4973: 
                            	  4974: 
                            	  4975: *  * <EA> to Register
                            	  4976: 
00:00005238 207CA5A5A5A5    	  4977:                 move.l #$a5a5a5a5,a0       * Initial Data-X  Inner loop
00:0000523E 223C8167E123    	  4978:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00005244 243CA5A5A5A5    	  4979:                 move.l #$a5a5a5a5,d2
00:0000524A 7600            	  4980:                 moveq  #$00000000,d3
00:0000524C 7800            	  4981:                 moveq  #$00000000,d4       * Cumulative data results
00:0000524E 7A00            	  4982:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005250 7C1E            	  4983:                 move.l #$0000001E,d6       * Inner loop counter
00:00005252 7E1E            	  4984:                 move.l #$0000001E,d7       * Outer loop counter
00:00005254 327C0100        	  4985:                 move.l #$00000100,a1       * Address for memory EA operations
                            	  4986: 
                            	  4987: 
                            	  4988: CMPA_OUTER1:
                            	  4989: 
                            	  4990: 
                            	  4991: *     WORD
00:00005258 2281            	  4992:                 move.l d1,(a1)
00:0000525A B0D1            	  4993:                 cmpa.w (a1),a0
00:0000525C 40C3            	  4994:                 move.w sr,d3
00:0000525E 02830000000F    	  4995:                 andi.l #$0F,d3            * Isolate flags
00:00005264 DA83            	  4996:                 add.l d3,d5               * Copy flag results into accumulator
00:00005266 D888            	  4997:                 add.l a0,d4               * Copy data results into data accumulator
                            	  4998: 
                            	  4999: *     LONG
00:00005268 2281            	  5000:                 move.l d1,(a1)
00:0000526A B1D1            	  5001:                 cmpa.l (a1),a0
00:0000526C 40C3            	  5002:                 move.w sr,d3
00:0000526E 02830000000F    	  5003:                 andi.l #$0F,d3            * Isolate flags
00:00005274 DA83            	  5004:                 add.l d3,d5               * Copy flag results into accumulator
00:00005276 D888            	  5005:                 add.l a0,d4               * Copy data results into data accumulator
                            	  5006: 
                            	  5007: 
00:00005278 E289            	  5008:                 lsr.l #$1,d1
00:0000527A 51CEFFDC        	  5009:                 dbf d6,CMPA_OUTER1
00:0000527E E28A            	  5010:                 lsr.l #$1,d2
00:00005280 223C8167E123    	  5011:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005286 7C1E            	  5012:                 move.l #$0000001E,d6       * Inner loop counter
00:00005288 51CFFFCE        	  5013:                 dbf d7,CMPA_OUTER1
                            	  5014: 
00:0000528C 0C84A5A5A0CA    	  5015:                 cmpi.l #$a5a5a0ca,d4      * Check the data results
00:00005292 66FE            	  5016:                 bne.s *
00:00005294 0C8500003A7D    	  5017:                 cmpi.l #$00003A7D,d5      * Check the Flag results
00:0000529A 66FE            	  5018:                 bne.s *
                            	  5019: 
                            	  5020: 
00:0000529C 4E75            	  5021:                 rts
                            	  5022: 
                            	  5023: 
                            	  5024: 
                            	  5025: *-----------------------------------------------------------
                            	  5026: *-----------------------------------------------------------
                            	  5027: * OPCODE : CMPM
                            	  5028: *-----------------------------------------------------------
                            	  5029: *-----------------------------------------------------------
                            	  5030: 
                            	  5031: op_CMPM:
                            	  5032: 
00:0000529E 307C0100        	  5033:                 move.l #$00000100,a0       * Address for Data-X
00:000052A2 327C0200        	  5034:                 move.l #$00000200,a1       * Address for Data-Y
00:000052A6 7000            	  5035:                 moveq  #$00000000,d0
00:000052A8 7200            	  5036:                 moveq  #$00000000,d1
00:000052AA 7400            	  5037:                 moveq  #$00000000,d2
                            	  5038: 
00:000052AC 20FC11FF5580    	  5039:                 move.l #$11FF5580,(a0)+   * Populate test data
00:000052B2 20FC1111FFFF    	  5040:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:000052B8 20FC33333333    	  5041:                 move.l #$33333333,(a0)+   * Populate test data
00:000052BE 20FC44444444    	  5042:                 move.l #$44444444,(a0)+   * Populate test data
                            	  5043: 
00:000052C4 22FC80FF337F    	  5044:                 move.l #$80FF337F,(a1)+   * Populate test data
00:000052CA 22FCFFFF1111    	  5045:                 move.l #$FFFF1111,(a1)+   * Populate test data
00:000052D0 22FC33333333    	  5046:                 move.l #$33333333,(a1)+   * Populate test data
00:000052D6 22FC44444444    	  5047:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5048: 
00:000052DC 307C0100        	  5049:                 move.l #$00000100,a0       * Address for Data-X
00:000052E0 327C0200        	  5050:                 move.l #$00000200,a1       * Address for Data-Y
00:000052E4 7C0F            	  5051:                 move.l #$0000000F,d6       * Loop counter
                            	  5052: 
00:000052E6 B308            	  5053: CMPM_LOOP1:     cmpm.b (a0)+,(a1)+
00:000052E8 40C3            	  5054:                 move.w sr,d3
00:000052EA 02830000000F    	  5055:                 andi.l #$0F,d3            * Isolate flags
00:000052F0 D083            	  5056:                 add.l d3,d0               * Copy flag results into accumulator
00:000052F2 51CEFFF2        	  5057:                 dbf d6,CMPM_LOOP1
                            	  5058: 
                            	  5059: 
00:000052F6 307C0100        	  5060:                 move.l #$00000100,a0       * Address for Data-X
00:000052FA 327C0200        	  5061:                 move.l #$00000200,a1       * Address for Data-Y
00:000052FE 7C07            	  5062:                 moveq  #$00000007,d6       * Loop counter
                            	  5063: 
00:00005300 B348            	  5064: CMPM_LOOP2:     cmpm.w (a0)+,(a1)+
00:00005302 40C3            	  5065:                 move.w sr,d3
00:00005304 02830000000F    	  5066:                 andi.l #$0F,d3            * Isolate flags
00:0000530A D283            	  5067:                 add.l d3,d1               * Copy flag results into accumulator
00:0000530C 51CEFFF2        	  5068:                 dbf d6,CMPM_LOOP2
                            	  5069: 
                            	  5070: 
00:00005310 307C0100        	  5071:                 move.l #$00000100,a0       * Address for Data-X
00:00005314 327C0200        	  5072:                 move.l #$00000200,a1       * Address for Data-Y
00:00005318 7C03            	  5073:                 moveq  #$00000003,d6       * Loop counter
                            	  5074: 
00:0000531A B388            	  5075: CMPM_LOOP3:     cmpm.l (a0)+,(a1)+
00:0000531C 40C3            	  5076:                 move.w sr,d3
00:0000531E 02830000000F    	  5077:                 andi.l #$0F,d3            * Isolate flags
00:00005324 D483            	  5078:                 add.l d3,d2               * Copy flag results into accumulator
00:00005326 51CEFFF2        	  5079:                 dbf d6,CMPM_LOOP3
                            	  5080: 
                            	  5081: 
00:0000532A 0C800000004C    	  5082:                 cmpi.l #$0000004C,d0      * Check the data results
00:00005330 66FE            	  5083:                 bne.s *
00:00005332 0C8100000024    	  5084:                 cmpi.l #$00000024,d1
00:00005338 66FE            	  5085:                 bne.s *
00:0000533A 0C8200000012    	  5086:                 cmpi.l #$00000012,d2
00:00005340 66FE            	  5087:                 bne.s *
                            	  5088: 
00:00005342 4E75            	  5089:                 rts
                            	  5090: 
                            	  5091: 
                            	  5092: *-----------------------------------------------------------
                            	  5093: *-----------------------------------------------------------
                            	  5094: * OPCODE : ADD
                            	  5095: *-----------------------------------------------------------
                            	  5096: *-----------------------------------------------------------
                            	  5097: 
                            	  5098: op_ADD:
                            	  5099: 
                            	  5100: 
                            	  5101: *  * <EA> to Register
00:00005344 203CA5A5A5A5    	  5102:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:0000534A 223C8167E123    	  5103:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00005350 243CA5A5A5A5    	  5104:                 move.l #$a5a5a5a5,d2
00:00005356 7600            	  5105:                 moveq  #$00000000,d3
00:00005358 7800            	  5106:                 moveq  #$00000000,d4       * Cumulative data results
00:0000535A 7A00            	  5107:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000535C 7C1E            	  5108:                 move.l #$0000001E,d6       * Inner loop counter
00:0000535E 7E1E            	  5109:                 move.l #$0000001E,d7       * Outer loop counter
00:00005360 307C0100        	  5110:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5111: 
                            	  5112: 
                            	  5113: ADD_OUTER1:
                            	  5114: 
                            	  5115: *     BYTE
00:00005364 2081            	  5116:                 move.l d1,(a0)
00:00005366 D010            	  5117:                 add.b (a0),d0
00:00005368 40C3            	  5118:                 move.w sr,d3
00:0000536A 02830000001F    	  5119:                 andi.l #$1F,d3            * Isolate flags
00:00005370 DA83            	  5120:                 add.l d3,d5               * Copy flag results into accumulator
00:00005372 D880            	  5121:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5122: 
                            	  5123: *     WORD
00:00005374 2081            	  5124:                 move.l d1,(a0)
00:00005376 D050            	  5125:                 add.w (a0),d0
00:00005378 40C3            	  5126:                 move.w sr,d3
00:0000537A 02830000000C    	  5127:                 andi.l #$0C,d3            * Isolate flags
00:00005380 DA83            	  5128:                 add.l d3,d5               * Copy flag results into accumulator
00:00005382 D880            	  5129:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5130: 
                            	  5131: *     LONG
00:00005384 2081            	  5132:                 move.l d1,(a0)
00:00005386 D090            	  5133:                 add.l (a0),d0
00:00005388 40C3            	  5134:                 move.w sr,d3
00:0000538A 02830000000F    	  5135:                 andi.l #$0F,d3            * Isolate flags
00:00005390 DA83            	  5136:                 add.l d3,d5               * Copy flag results into accumulator
00:00005392 D880            	  5137:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5138: 
                            	  5139: 
00:00005394 E299            	  5140:                 ror.l #$1,d1
00:00005396 51CEFFCC        	  5141:                 dbf d6,ADD_OUTER1
00:0000539A E29A            	  5142:                 ror.l #$1,d2
00:0000539C 223C8167E123    	  5143:                 move.l #$8167E123,d1       * Initial Data-Y
00:000053A2 7C1E            	  5144:                 move.l #$0000001E,d6       * Inner loop counter
00:000053A4 51CFFFBE        	  5145:                 dbf d7,ADD_OUTER1
                            	  5146: 
00:000053A8 0C8423ED428F    	  5147:                 cmpi.l #$23ED428F,d4      * Check the data results
00:000053AE 66FE            	  5148:                 bne.s *
00:000053B0 0C8500004C96    	  5149:                 cmpi.l #$00004C96,d5      * Check the Flag results
00:000053B6 66FE            	  5150:                 bne.s *
                            	  5151: 
                            	  5152: 
                            	  5153: *  * Register to <EA>
00:000053B8 203C86738374    	  5154:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:000053BE 223CFC55F2FE    	  5155:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:000053C4 243C86738374    	  5156:                 move.l #$86738374,d2
00:000053CA 7600            	  5157:                 moveq  #$00000000,d3
00:000053CC 7800            	  5158:                 moveq  #$00000000,d4       * Cumulative data results
00:000053CE 7A00            	  5159:                 moveq  #$00000000,d5       * Cumulative flag results
00:000053D0 7C1E            	  5160:                 move.l #$0000001E,d6       * Inner loop counter
00:000053D2 7E1D            	  5161:                 move.l #$0000001D,d7       * Outer loop counter
00:000053D4 307C0100        	  5162:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5163: 
                            	  5164: 
                            	  5165: ADD_OUTER2:
                            	  5166: 
                            	  5167: *     BYTE
00:000053D8 2080            	  5168:                 move.l d0,(a0)
00:000053DA D310            	  5169:                 add.b d1,(a0)
00:000053DC 40C3            	  5170:                 move.w sr,d3
00:000053DE 02830000000C    	  5171:                 andi.l #$0C,d3            * Isolate flags
00:000053E4 DA83            	  5172:                 add.l d3,d5               * Copy flag results into accumulator
00:000053E6 D890            	  5173:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5174: 
                            	  5175: *     WORD
00:000053E8 2080            	  5176:                 move.l d0,(a0)
00:000053EA D350            	  5177:                 add.w d1,(a0)
00:000053EC 40C3            	  5178:                 move.w sr,d3
00:000053EE 02830000001F    	  5179:                 andi.l #$1F,d3            * Isolate flags
00:000053F4 DA83            	  5180:                 add.l d3,d5               * Copy flag results into accumulator
00:000053F6 D890            	  5181:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5182: 
                            	  5183: *     LONG
00:000053F8 2080            	  5184:                 move.l d0,(a0)
00:000053FA D390            	  5185:                 add.l d1,(a0)
00:000053FC 40C3            	  5186:                 move.w sr,d3
00:000053FE 02830000000F    	  5187:                 andi.l #$0F,d3            * Isolate flags
00:00005404 DA83            	  5188:                 add.l d3,d5               * Copy flag results into accumulator
00:00005406 D890            	  5189:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5190: 
                            	  5191: 
00:00005408 E299            	  5192:                 ror.l #$1,d1
00:0000540A 51CEFFCC        	  5193:                 dbf d6,ADD_OUTER2
00:0000540E E29A            	  5194:                 ror.l #$1,d2
00:00005410 223C8167E123    	  5195:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005416 7C1E            	  5196:                 move.l #$0000001E,d6       * Inner loop counter
00:00005418 51CFFFBE        	  5197:                 dbf d7,ADD_OUTER2
                            	  5198: 
00:0000541C 0C846701B884    	  5199:                 cmpi.l #$6701B884,d4      * Check the data results
00:00005422 66FE            	  5200:                 bne.s *
00:00005424 0C8500005467    	  5201:                 cmpi.l #$00005467,d5      * Check the Flag results
00:0000542A 66FE            	  5202:                 bne.s *
                            	  5203: 
00:0000542C 4E75            	  5204:                 rts
                            	  5205: 
                            	  5206: *-----------------------------------------------------------
                            	  5207: *-----------------------------------------------------------
                            	  5208: * OPCODE : SUB
                            	  5209: *-----------------------------------------------------------
                            	  5210: *-----------------------------------------------------------
                            	  5211: 
                            	  5212: op_SUB:
                            	  5213: 
                            	  5214: *  * <EA> to Register
00:0000542E 203CA5A5A5A5    	  5215:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00005434 223C8167E123    	  5216:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:0000543A 243CA5A5A5A5    	  5217:                 move.l #$a5a5a5a5,d2
00:00005440 7600            	  5218:                 moveq  #$00000000,d3
00:00005442 7800            	  5219:                 moveq  #$00000000,d4       * Cumulative data results
00:00005444 7A00            	  5220:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005446 7C1E            	  5221:                 move.l #$0000001E,d6       * Inner loop counter
00:00005448 7E1E            	  5222:                 move.l #$0000001E,d7       * Outer loop counter
00:0000544A 307C0100        	  5223:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5224: 
                            	  5225: 
                            	  5226: SUB_OUTER1:
                            	  5227: 
                            	  5228: *     BYTE
00:0000544E 2081            	  5229:                 move.l d1,(a0)
00:00005450 9010            	  5230:                 sub.b (a0),d0
00:00005452 40C3            	  5231:                 move.w sr,d3
00:00005454 02830000001F    	  5232:                 andi.l #$1F,d3            * Isolate flags
00:0000545A DA83            	  5233:                 add.l d3,d5               * Copy flag results into accumulator
00:0000545C D880            	  5234:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5235: 
                            	  5236: *     WORD
00:0000545E 2081            	  5237:                 move.l d1,(a0)
00:00005460 9050            	  5238:                 sub.w (a0),d0
00:00005462 40C3            	  5239:                 move.w sr,d3
00:00005464 02830000000C    	  5240:                 andi.l #$0C,d3            * Isolate flags
00:0000546A DA83            	  5241:                 add.l d3,d5               * Copy flag results into accumulator
00:0000546C D880            	  5242:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5243: 
                            	  5244: *     LONG
00:0000546E 2081            	  5245:                 move.l d1,(a0)
00:00005470 9090            	  5246:                 sub.l (a0),d0
00:00005472 40C3            	  5247:                 move.w sr,d3
00:00005474 02830000000F    	  5248:                 andi.l #$0F,d3            * Isolate flags
00:0000547A DA83            	  5249:                 add.l d3,d5               * Copy flag results into accumulator
00:0000547C D880            	  5250:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5251: 
                            	  5252: 
00:0000547E E299            	  5253:                 ror.l #$1,d1
00:00005480 51CEFFCC        	  5254:                 dbf d6,SUB_OUTER1
00:00005484 E29A            	  5255:                 ror.l #$1,d2
00:00005486 223C8167E123    	  5256:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000548C 7C1E            	  5257:                 move.l #$0000001E,d6       * Inner loop counter
00:0000548E 51CFFFBE        	  5258:                 dbf d7,SUB_OUTER1
                            	  5259: 
00:00005492 0C841A8D14CF    	  5260:                 cmpi.l #$1A8D14CF,d4      * Check the data results
00:00005498 66FE            	  5261:                 bne.s *
00:0000549A 0C8500004FC4    	  5262:                 cmpi.l #$00004FC4,d5      * Check the Flag results
00:000054A0 66FE            	  5263:                 bne.s *
                            	  5264: 
                            	  5265: 
                            	  5266: *  * Register to <EA>
00:000054A2 203C86738374    	  5267:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:000054A8 223CFC55F2FE    	  5268:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:000054AE 243C86738374    	  5269:                 move.l #$86738374,d2
00:000054B4 7600            	  5270:                 moveq  #$00000000,d3
00:000054B6 7800            	  5271:                 moveq  #$00000000,d4       * Cumulative data results
00:000054B8 7A00            	  5272:                 moveq  #$00000000,d5       * Cumulative flag results
00:000054BA 7C1E            	  5273:                 move.l #$0000001E,d6       * Inner loop counter
00:000054BC 7E1D            	  5274:                 move.l #$0000001D,d7       * Outer loop counter
00:000054BE 307C0100        	  5275:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5276: 
                            	  5277: 
                            	  5278: SUB_OUTER2:
                            	  5279: 
                            	  5280: *     BYTE
00:000054C2 2080            	  5281:                 move.l d0,(a0)
00:000054C4 9310            	  5282:                 sub.b d1,(a0)
00:000054C6 40C3            	  5283:                 move.w sr,d3
00:000054C8 02830000000C    	  5284:                 andi.l #$0C,d3            * Isolate flags
00:000054CE DA83            	  5285:                 add.l d3,d5               * Copy flag results into accumulator
00:000054D0 D890            	  5286:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5287: 
                            	  5288: *     WORD
00:000054D2 2080            	  5289:                 move.l d0,(a0)
00:000054D4 9350            	  5290:                 sub.w d1,(a0)
00:000054D6 40C3            	  5291:                 move.w sr,d3
00:000054D8 02830000001F    	  5292:                 andi.l #$1F,d3            * Isolate flags
00:000054DE DA83            	  5293:                 add.l d3,d5               * Copy flag results into accumulator
00:000054E0 D890            	  5294:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5295: 
                            	  5296: *     LONG
00:000054E2 2080            	  5297:                 move.l d0,(a0)
00:000054E4 9390            	  5298:                 sub.l d1,(a0)
00:000054E6 40C3            	  5299:                 move.w sr,d3
00:000054E8 02830000000F    	  5300:                 andi.l #$0F,d3            * Isolate flags
00:000054EE DA83            	  5301:                 add.l d3,d5               * Copy flag results into accumulator
00:000054F0 D890            	  5302:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5303: 
                            	  5304: 
00:000054F2 E299            	  5305:                 ror.l #$1,d1
00:000054F4 51CEFFCC        	  5306:                 dbf d6,SUB_OUTER2
00:000054F8 E29A            	  5307:                 ror.l #$1,d2
00:000054FA 223C8167E123    	  5308:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005500 7C1E            	  5309:                 move.l #$0000001E,d6       * Inner loop counter
00:00005502 51CFFFBE        	  5310:                 dbf d7,SUB_OUTER2
                            	  5311: 
00:00005506 0C8436D38BEC    	  5312:                 cmpi.l #$36D38BEC,d4      * Check the data results
00:0000550C 66FE            	  5313:                 bne.s *
00:0000550E 0C85000045A5    	  5314:                 cmpi.l #$000045A5,d5      * Check the Flag results
00:00005514 66FE            	  5315:                 bne.s *
                            	  5316: 
                            	  5317: 
                            	  5318: 
                            	  5319: 
00:00005516 4E75            	  5320:                 rts
                            	  5321: 
                            	  5322: 
                            	  5323: 
                            	  5324: *-----------------------------------------------------------
                            	  5325: *-----------------------------------------------------------
                            	  5326: * OPCODE : ADDA
                            	  5327: *-----------------------------------------------------------
                            	  5328: *-----------------------------------------------------------
                            	  5329: 
                            	  5330: op_ADDA:
                            	  5331: 
                            	  5332: *  * <EA> to Register
00:00005518 203CA5A5A5A5    	  5333:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:0000551E 223C8167E123    	  5334:                 move.l #$8167E123,d1
00:00005524 243CA5A5A5A5    	  5335:                 move.l #$a5a5a5a5,d2
00:0000552A 7600            	  5336:                 moveq  #$00000000,d3
00:0000552C 7800            	  5337:                 moveq  #$00000000,d4       * Cumulative data results
00:0000552E 7A00            	  5338:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005530 7C1E            	  5339:                 move.l #$0000001E,d6       * Inner loop counter
00:00005532 7E1E            	  5340:                 move.l #$0000001E,d7       * Outer loop counter
00:00005534 307C0100        	  5341:                 move.l #$00000100,a0       * Address for memory EA operations
00:00005538 227C8167E123    	  5342:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5343: 
                            	  5344: ADDA_OUTER1:
                            	  5345: 
                            	  5346: *     WORD
                            	  5347: *                move.l d1,(a0)       * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5348: *                adda.w (a0),a1
                            	  5349: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5350: 
                            	  5351: *     LONG
00:0000553E 2081            	  5352:                 move.l d1,(a0)
00:00005540 D3D0            	  5353:                 adda.l (a0),a1
00:00005542 D889            	  5354:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5355: 
00:00005544 E299            	  5356:                 ror.l #$1,d1
00:00005546 51CEFFF6        	  5357:                 dbf d6,ADDA_OUTER1
00:0000554A E299            	  5358:                 ror.l #$1,d1
00:0000554C 2241            	  5359:                 move.l d1,a1
00:0000554E 223C8167E123    	  5360:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005554 7C1E            	  5361:                 move.l #$0000001E,d6       * Inner loop counter
00:00005556 51CFFFE6        	  5362:                 dbf d7,ADDA_OUTER1
                            	  5363: 
00:0000555A 0C84AC04DB4C    	  5364:                 cmpi.l #$AC04DB4C,d4      * Check the data results
00:00005560 66FE            	  5365:                 bne.s *
                            	  5366: 
                            	  5367: 
00:00005562 4E75            	  5368:                 rts
                            	  5369: 
                            	  5370: 
                            	  5371: *-----------------------------------------------------------
                            	  5372: *-----------------------------------------------------------
                            	  5373: * OPCODE : SUBA
                            	  5374: *-----------------------------------------------------------
                            	  5375: *-----------------------------------------------------------
                            	  5376: 
                            	  5377: op_SUBA:
                            	  5378: 
                            	  5379: *  * <EA> to Register
00:00005564 203CA5A5A5A5    	  5380:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:0000556A 223C8167E123    	  5381:                 move.l #$8167E123,d1
00:00005570 243CA5A5A5A5    	  5382:                 move.l #$a5a5a5a5,d2
00:00005576 7600            	  5383:                 moveq  #$00000000,d3
00:00005578 7800            	  5384:                 moveq  #$00000000,d4       * Cumulative data results
00:0000557A 7A00            	  5385:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000557C 7C1E            	  5386:                 move.l #$0000001E,d6       * Inner loop counter
00:0000557E 7E1E            	  5387:                 move.l #$0000001E,d7       * Outer loop counter
00:00005580 307C0100        	  5388:                 move.l #$00000100,a0       * Address for memory EA operations
00:00005584 227C8167E123    	  5389:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5390: 
                            	  5391: SUBA_OUTER1:
                            	  5392: 
                            	  5393: *     WORD
                            	  5394: *                move.l d1,(a0) * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5395: *                suba.w (a0),a1
                            	  5396: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5397: 
                            	  5398: *     LONG
00:0000558A 2081            	  5399:                 move.l d1,(a0)
00:0000558C 93D0            	  5400:                 suba.l (a0),a1
00:0000558E D889            	  5401:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5402: 
00:00005590 E299            	  5403:                 ror.l #$1,d1
00:00005592 51CEFFF6        	  5404:                 dbf d6,SUBA_OUTER1
00:00005596 E299            	  5405:                 ror.l #$1,d1
00:00005598 2241            	  5406:                 move.l d1,a1
00:0000559A 223C8167E123    	  5407:                 move.l #$8167E123,d1       * Initial Data-Y
00:000055A0 7C1E            	  5408:                 move.l #$0000001E,d6       * Inner loop counter
00:000055A2 51CFFFE6        	  5409:                 dbf d7,SUBA_OUTER1
                            	  5410: 
00:000055A6 0C84E1E36D7A    	  5411:                 cmpi.l #$E1E36D7A,d4      * Check the data results
00:000055AC 66FE            	  5412:                 bne.s *
                            	  5413: 
                            	  5414: 
00:000055AE 4E75            	  5415:                 rts
                            	  5416: 
                            	  5417: 
                            	  5418: 
                            	  5419: *-----------------------------------------------------------
                            	  5420: *-----------------------------------------------------------
                            	  5421: * OPCODE : ADDX
                            	  5422: *-----------------------------------------------------------
                            	  5423: *-----------------------------------------------------------
                            	  5424: 
                            	  5425: op_ADDX:
                            	  5426: 
                            	  5427: 
                            	  5428: *  * Register to Register
00:000055B0 203CA5A5A5A5    	  5429:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000055B6 223C8167E123    	  5430:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:000055BC 243CA5A5A5A5    	  5431:                 move.l #$a5a5a5a5,d2
00:000055C2 7600            	  5432:                 moveq  #$00000000,d3
00:000055C4 7800            	  5433:                 moveq  #$00000000,d4       * Cumulative data results
00:000055C6 7A00            	  5434:                 moveq  #$00000000,d5       * Cumulative flag results
00:000055C8 7C1E            	  5435:                 move.l #$0000001E,d6       * Inner loop counter
00:000055CA 7E1E            	  5436:                 move.l #$0000001E,d7       * Outer loop counter
00:000055CC 307C0100        	  5437:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5438: 
                            	  5439: 
                            	  5440: ADDX_OUTER1:
                            	  5441: 
                            	  5442: *     BYTE
00:000055D0 2002            	  5443:                 move.l d2,d0
00:000055D2 D101            	  5444:                 addx.b d1,d0
00:000055D4 40C3            	  5445:                 move.w sr,d3
00:000055D6 02830000001F    	  5446:                 andi.l #$1F,d3            * Isolate flags
00:000055DC DA83            	  5447:                 add.l d3,d5               * Copy flag results into accumulator
00:000055DE D880            	  5448:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5449: 
                            	  5450: *     WORD
00:000055E0 2002            	  5451:                 move.l d2,d0
00:000055E2 D141            	  5452:                 addx.w d1,d0
00:000055E4 40C3            	  5453:                 move.w sr,d3
00:000055E6 02830000001F    	  5454:                 andi.l #$1F,d3            * Isolate flags
00:000055EC DA83            	  5455:                 add.l d3,d5               * Copy flag results into accumulator
00:000055EE D880            	  5456:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5457: 
                            	  5458: *     LONG
00:000055F0 2002            	  5459:                 move.l d2,d0
00:000055F2 D181            	  5460:                 addx.l d1,d0
00:000055F4 40C3            	  5461:                 move.w sr,d3
00:000055F6 02830000001F    	  5462:                 andi.l #$1F,d3            * Isolate flags
00:000055FC DA83            	  5463:                 add.l d3,d5               * Copy flag results into accumulator
00:000055FE D880            	  5464:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5465: 
00:00005600 E299            	  5466:                 ror.l #$1,d1
00:00005602 51CEFFCC        	  5467:                 dbf d6,ADDX_OUTER1
00:00005606 E29A            	  5468:                 ror.l #$1,d2
00:00005608 223C8167E123    	  5469:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000560E 7C1E            	  5470:                 move.l #$0000001E,d6       * Inner loop counter
00:00005610 51CFFFBE        	  5471:                 dbf d7,ADDX_OUTER1
                            	  5472: 
00:00005614 0C844E96A4D9    	  5473:                 cmpi.l #$4E96A4D9,d4      * Check the data results
00:0000561A 66FE            	  5474:                 bne.s *
00:0000561C 0C85000085CD    	  5475:                 cmpi.l #$000085CD,d5      * Check the Flag results
00:00005622 66FE            	  5476:                 bne.s *
                            	  5477: 
                            	  5478: 
                            	  5479: 
                            	  5480: *     -(An),-(An)
                            	  5481: 
00:00005624 7000            	  5482:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
00:00005626 7200            	  5483:                 moveq  #$00000000,d1
00:00005628 7400            	  5484:                 moveq  #$00000000,d2
00:0000562A 307C0100        	  5485:                 move.l #$00000100,a0       * Address for Data-X
00:0000562E 327C0200        	  5486:                 move.l #$00000200,a1       * Address for Data-Y
00:00005632 20FC11FF5580    	  5487:                 move.l #$11FF5580,(a0)+   * Populate test data
00:00005638 20FC1111FFFF    	  5488:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:0000563E 20FC33333333    	  5489:                 move.l #$33333333,(a0)+   * Populate test data
00:00005644 20FC44444444    	  5490:                 move.l #$44444444,(a0)+   * Populate test data
00:0000564A 22FC80FF337F    	  5491:                 move.l #$80FF337F,(a1)+   * Populate test data
00:00005650 22FCFFFF1111    	  5492:                 move.l #$FFFF1111,(a1)+   * Populate test data
00:00005656 22FC33333333    	  5493:                 move.l #$33333333,(a1)+   * Populate test data
00:0000565C 22FC44444444    	  5494:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5495: 
                            	  5496: 
00:00005662 7C0F            	  5497:                 move.l #$0000000F,d6       * Loop counter
                            	  5498: 
00:00005664 D308            	  5499: ADDX_LOOP3:     addx.b -(a0),-(a1)
00:00005666 40C3            	  5500:                 move.w sr,d3
00:00005668 02830000000F    	  5501:                 andi.l #$0F,d3            * Isolate flags
00:0000566E D083            	  5502:                 add.l d3,d0               * Copy flag results into accumulator
00:00005670 D211            	  5503:                 add.b (a1),d1
00:00005672 51CEFFF0        	  5504:                 dbf d6,ADDX_LOOP3
                            	  5505: 
                            	  5506: 
00:00005676 307C0110        	  5507:                 move.l #$00000110,a0       * Address for Data-X
00:0000567A 327C0210        	  5508:                 move.l #$00000210,a1       * Address for Data-Y
00:0000567E 7C07            	  5509:                 moveq  #$00000007,d6       * Loop counter
                            	  5510: 
00:00005680 D348            	  5511: ADDX_LOOP4:     addx.w -(a0),-(a1)
00:00005682 40C3            	  5512:                 move.w sr,d3
00:00005684 02830000000F    	  5513:                 andi.l #$0F,d3            * Isolate flags
00:0000568A D083            	  5514:                 add.l d3,d0               * Copy flag results into accumulator
00:0000568C D251            	  5515:                 add.w (a1),d1
00:0000568E 51CEFFF0        	  5516:                 dbf d6,ADDX_LOOP4
                            	  5517: 
                            	  5518: 
00:00005692 307C0110        	  5519:                 move.l #$00000110,a0       * Address for Data-X
00:00005696 327C0210        	  5520:                 move.l #$00000210,a1       * Address for Data-Y
00:0000569A 7C03            	  5521:                 moveq  #$00000003,d6       * Loop counter
                            	  5522: 
00:0000569C D388            	  5523: ADDX_LOOP5:     addx.l -(a0),-(a1)
00:0000569E 40C3            	  5524:                 move.w sr,d3
00:000056A0 02830000000F    	  5525:                 andi.l #$0F,d3            * Isolate flags
00:000056A6 D083            	  5526:                 add.l d3,d0               * Copy flag results into accumulator
00:000056A8 D291            	  5527:                 add.l (a1),d1
00:000056AA 51CEFFF0        	  5528:                 dbf d6,ADDX_LOOP5
                            	  5529: 
                            	  5530: 
00:000056AE 0C8000000095    	  5531:                 cmpi.l #$00000095,d0      * Check the flag results
00:000056B4 66FE            	  5532:                 bne.s *
00:000056B6 0C81C812A682    	  5533:                 cmpi.l #$C812A682,d1      * Check the data results
00:000056BC 66FE            	  5534:                 bne.s *
                            	  5535: 
00:000056BE 4E75            	  5536:                 rts
                            	  5537: 
                            	  5538: 
                            	  5539: 
                            	  5540: 
                            	  5541: *-----------------------------------------------------------
                            	  5542: *-----------------------------------------------------------
                            	  5543: * OPCODE : SUBX
                            	  5544: *-----------------------------------------------------------
                            	  5545: *-----------------------------------------------------------
                            	  5546: 
                            	  5547: op_SUBX:
                            	  5548: 
                            	  5549: 
                            	  5550: *  * Register to Register
00:000056C0 203CA5A5A5A5    	  5551:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000056C6 223C8167E123    	  5552:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:000056CC 243CA5A5A5A5    	  5553:                 move.l #$a5a5a5a5,d2
00:000056D2 7600            	  5554:                 moveq  #$00000000,d3
00:000056D4 7800            	  5555:                 moveq  #$00000000,d4       * Cumulative data results
00:000056D6 7A00            	  5556:                 moveq  #$00000000,d5       * Cumulative flag results
00:000056D8 7C1E            	  5557:                 move.l #$0000001E,d6       * Inner loop counter
00:000056DA 7E1E            	  5558:                 move.l #$0000001E,d7       * Outer loop counter
00:000056DC 307C0100        	  5559:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5560: 
                            	  5561: 
                            	  5562: SUBX_OUTER1:
                            	  5563: 
                            	  5564: *     BYTE
00:000056E0 2002            	  5565:                 move.l d2,d0
00:000056E2 9101            	  5566:                 subx.b d1,d0
00:000056E4 40C3            	  5567:                 move.w sr,d3
00:000056E6 02830000001F    	  5568:                 andi.l #$1F,d3            * Isolate flags
00:000056EC DA83            	  5569:                 add.l d3,d5               * Copy flag results into accumulator
00:000056EE D880            	  5570:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5571: 
                            	  5572: *     WORD
00:000056F0 2002            	  5573:                 move.l d2,d0
00:000056F2 9141            	  5574:                 subx.w d1,d0
00:000056F4 40C3            	  5575:                 move.w sr,d3
00:000056F6 02830000001F    	  5576:                 andi.l #$1F,d3            * Isolate flags
00:000056FC DA83            	  5577:                 add.l d3,d5               * Copy flag results into accumulator
00:000056FE D880            	  5578:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5579: 
                            	  5580: *     LONG
00:00005700 2002            	  5581:                 move.l d2,d0
00:00005702 9181            	  5582:                 subx.l d1,d0
00:00005704 40C3            	  5583:                 move.w sr,d3
00:00005706 02830000001F    	  5584:                 andi.l #$1F,d3            * Isolate flags
00:0000570C DA83            	  5585:                 add.l d3,d5               * Copy flag results into accumulator
00:0000570E D880            	  5586:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5587: 
00:00005710 E299            	  5588:                 ror.l #$1,d1
00:00005712 51CEFFCC        	  5589:                 dbf d6,SUBX_OUTER1
00:00005716 E29A            	  5590:                 ror.l #$1,d2
00:00005718 223C8167E123    	  5591:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000571E 7C1E            	  5592:                 move.l #$0000001E,d6       * Inner loop counter
00:00005720 51CFFFBE        	  5593:                 dbf d7,SUBX_OUTER1
                            	  5594: 
00:00005724 0C84FCAA913E    	  5595:                 cmpi.l #$FCAA913E,d4      * Check the data results
00:0000572A 66FE            	  5596:                 bne.s *
00:0000572C 0C8500007E89    	  5597:                 cmpi.l #$00007E89,d5      * Check the Flag results
00:00005732 66FE            	  5598:                 bne.s *
                            	  5599: 
                            	  5600: 
                            	  5601: 
                            	  5602: *     -(An),-(An)
                            	  5603: 
00:00005734 7000            	  5604:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
00:00005736 7200            	  5605:                 moveq  #$00000000,d1
00:00005738 7400            	  5606:                 moveq  #$00000000,d2
00:0000573A 307C0100        	  5607:                 move.l #$00000100,a0       * Address for Data-X
00:0000573E 327C0200        	  5608:                 move.l #$00000200,a1       * Address for Data-Y
00:00005742 20FC11FF5580    	  5609:                 move.l #$11FF5580,(a0)+   * Populate test data
00:00005748 20FC1111FFFF    	  5610:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:0000574E 20FC80FF337F    	  5611:                 move.l #$80FF337F,(a0)+   * Populate test data
00:00005754 20FC44444444    	  5612:                 move.l #$44444444,(a0)+   * Populate test data
00:0000575A 22FC80FF337F    	  5613:                 move.l #$80FF337F,(a1)+   * Populate test data
00:00005760 22FC1111FFFF    	  5614:                 move.l #$1111FFFF,(a1)+   * Populate test data
00:00005766 22FC33333333    	  5615:                 move.l #$33333333,(a1)+   * Populate test data
00:0000576C 22FC5580EECC    	  5616:                 move.l #$5580EECC,(a1)+   * Populate test data
                            	  5617: 
                            	  5618: 
00:00005772 7C0F            	  5619:                 move.l #$0000000F,d6       * Loop counter
                            	  5620: 
00:00005774 9308            	  5621: SUBX_LOOP3:     subx.b -(a0),-(a1)
00:00005776 40C3            	  5622:                 move.w sr,d3
00:00005778 02830000000F    	  5623:                 andi.l #$0F,d3            * Isolate flags
00:0000577E D083            	  5624:                 add.l d3,d0               * Copy flag results into accumulator
00:00005780 D211            	  5625:                 add.b (a1),d1
00:00005782 51CEFFF0        	  5626:                 dbf d6,SUBX_LOOP3
                            	  5627: 
                            	  5628: 
00:00005786 307C0110        	  5629:                 move.l #$00000110,a0       * Address for Data-X
00:0000578A 327C0210        	  5630:                 move.l #$00000210,a1       * Address for Data-Y
00:0000578E 7C07            	  5631:                 moveq  #$00000007,d6       * Loop counter
                            	  5632: 
00:00005790 9348            	  5633: SUBX_LOOP4:     subx.w -(a0),-(a1)
00:00005792 40C3            	  5634:                 move.w sr,d3
00:00005794 02830000000F    	  5635:                 andi.l #$0F,d3            * Isolate flags
00:0000579A D083            	  5636:                 add.l d3,d0               * Copy flag results into accumulator
00:0000579C D251            	  5637:                 add.w (a1),d1
00:0000579E 51CEFFF0        	  5638:                 dbf d6,SUBX_LOOP4
                            	  5639: 
                            	  5640: 
00:000057A2 307C0110        	  5641:                 move.l #$00000110,a0       * Address for Data-X
00:000057A6 327C0210        	  5642:                 move.l #$00000210,a1       * Address for Data-Y
00:000057AA 7C03            	  5643:                 moveq  #$00000003,d6       * Loop counter
                            	  5644: 
00:000057AC 9388            	  5645: SUBX_LOOP5:     subx.l -(a0),-(a1)
00:000057AE 40C3            	  5646:                 move.w sr,d3
00:000057B0 02830000000F    	  5647:                 andi.l #$0F,d3            * Isolate flags
00:000057B6 D083            	  5648:                 add.l d3,d0               * Copy flag results into accumulator
00:000057B8 D291            	  5649:                 add.l (a1),d1
00:000057BA 51CEFFF0        	  5650:                 dbf d6,SUBX_LOOP5
                            	  5651: 
                            	  5652: 
00:000057BE 0C80000000B1    	  5653:                 cmpi.l #$000000B1,d0      * Check the flag results
00:000057C4 66FE            	  5654:                 bne.s *
00:000057C6 0C8162C6F417    	  5655:                 cmpi.l #$62C6F417,d1      * Check the data results
00:000057CC 66FE            	  5656:                 bne.s *
                            	  5657: 
00:000057CE 4E75            	  5658:                 rts
                            	  5659: 
                            	  5660: 
                            	  5661: *-----------------------------------------------------------
                            	  5662: *-----------------------------------------------------------
                            	  5663: * OPCODE : MULU
                            	  5664: *-----------------------------------------------------------
                            	  5665: *-----------------------------------------------------------
                            	  5666: 
                            	  5667: op_MULU:
                            	  5668: 
00:000057D0 203CFE805501    	  5669:                 move.l #$FE805501,d0        * Initial
00:000057D6 223C5697EDB6    	  5670:                 move.l #$5697EDB6,d1        * Initial Y
00:000057DC 243CFE805501    	  5671:                 move.l #$FE805501,d2
00:000057E2 7600            	  5672:                 moveq  #$00000000,d3
00:000057E4 7800            	  5673:                 moveq  #$00000000,d4        * Cumulative data results
00:000057E6 7A00            	  5674:                 moveq  #$00000000,d5       * Cumulative flag results
00:000057E8 7C0E            	  5675:                 move.l #$0000000E,d6       * Inner loop counter
00:000057EA 7E0E            	  5676:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5677: 
                            	  5678: 
00:000057EC C0C1            	  5679: MULU_OUTER1:    mulu d1,d0
00:000057EE 40C3            	  5680:                 move.w sr,d3
00:000057F0 02830000000C    	  5681:                 andi.l #$0C,d3            * Isolate flags
00:000057F6 DA83            	  5682:                 add.l d3,d5               * Copy flag results into accumulator
00:000057F8 D880            	  5683:                 add.l d0,d4               * Copy data results into data accumulator
00:000057FA E299            	  5684:                 ror.l #$1,d1
                            	  5685: 
00:000057FC 51CEFFEE        	  5686:                 dbf d6,MULU_OUTER1
00:00005800 E29A            	  5687:                 ror.l #$1,d2
00:00005802 2002            	  5688:                 move.l d2,d0
00:00005804 7C0E            	  5689:                 move.l #$0000000E,d6       * Inner loop counter
00:00005806 51CFFFE4        	  5690:                 dbf d7,MULU_OUTER1
                            	  5691: 
00:0000580A 0C8476FB988C    	  5692:                 cmpi.l #$76FB988C,d4      * Check the data results
00:00005810 66FE            	  5693:                 bne.s *
                            	  5694: 
00:00005812 0C8500000170    	  5695:                 cmpi.l #$00000170,d5      * Check the Flag results
00:00005818 66FE            	  5696:                 bne.s *
                            	  5697: 
                            	  5698: 
00:0000581A 4E75            	  5699:                 rts
                            	  5700: 
                            	  5701: 
                            	  5702: *-----------------------------------------------------------
                            	  5703: *-----------------------------------------------------------
                            	  5704: * OPCODE : MULS
                            	  5705: *-----------------------------------------------------------
                            	  5706: *-----------------------------------------------------------
                            	  5707: 
                            	  5708: op_MULS:
                            	  5709: 
00:0000581C 203CFE805501    	  5710:                 move.l #$FE805501,d0        * Initial
00:00005822 223C5697EDB6    	  5711:                 move.l #$5697EDB6,d1        * Initial Y
00:00005828 243CFE805501    	  5712:                 move.l #$FE805501,d2
00:0000582E 7600            	  5713:                 moveq  #$00000000,d3
00:00005830 7800            	  5714:                 moveq  #$00000000,d4        * Cumulative data results
00:00005832 7A00            	  5715:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005834 7C0E            	  5716:                 move.l #$0000000E,d6       * Inner loop counter
00:00005836 7E0E            	  5717:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5718: 
                            	  5719: 
00:00005838 C1C1            	  5720: MULS_OUTER1:    muls d1,d0
00:0000583A 40C3            	  5721:                 move.w sr,d3
00:0000583C 02830000000C    	  5722:                 andi.l #$0C,d3            * Isolate flags
00:00005842 DA83            	  5723:                 add.l d3,d5               * Copy flag results into accumulator
00:00005844 D880            	  5724:                 add.l d0,d4               * Copy data results into data accumulator
00:00005846 E299            	  5725:                 ror.l #$1,d1
                            	  5726: 
00:00005848 51CEFFEE        	  5727:                 dbf d6,MULS_OUTER1
00:0000584C E29A            	  5728:                 ror.l #$1,d2
00:0000584E 2002            	  5729:                 move.l d2,d0
00:00005850 7C0E            	  5730:                 move.l #$0000000E,d6       * Inner loop counter
00:00005852 51CFFFE4        	  5731:                 dbf d7,MULS_OUTER1
                            	  5732: 
00:00005856 0C84D4E2988C    	  5733:                 cmpi.l #$D4E2988C,d4      * Check the data results
00:0000585C 66FE            	  5734:                 bne.s *
                            	  5735: 
00:0000585E 0C85000003E0    	  5736:                 cmpi.l #$000003E0,d5      * Check the Flag results
00:00005864 66FE            	  5737:                 bne.s *
                            	  5738: 
                            	  5739: 
00:00005866 4E75            	  5740:                 rts
                            	  5741: 
                            	  5742: 
                            	  5743: 
                            	  5744: *-----------------------------------------------------------
                            	  5745: *-----------------------------------------------------------
                            	  5746: * OPCODE : EXG
                            	  5747: *-----------------------------------------------------------
                            	  5748: *-----------------------------------------------------------
                            	  5749: 
                            	  5750: op_EXG:
00:00005868 223CD1D1D1D1    	  5751:                 move.l #$d1d1d1d1,d1
00:0000586E 243CD2D2D2D2    	  5752:                 move.l #$d2d2d2d2,d2
00:00005874 263CD3D3D3D3    	  5753:                 move.l #$d3d3d3d3,d3
00:0000587A 227CA1A1A1A1    	  5754:                 move.l #$a1a1a1a1,a1
00:00005880 247CA2A2A2A2    	  5755:                 move.l #$a2a2a2a2,a2
00:00005886 267CA3A3A3A3    	  5756:                 move.l #$a3a3a3a3,a3
                            	  5757: 
00:0000588C C342            	  5758:                 exg d1,d2
00:0000588E C34A            	  5759:                 exg a1,a2
00:00005890 C78B            	  5760:                 exg d3,a3
                            	  5761: 
00:00005892 0C81D2D2D2D2    	  5762:                 cmpi.l #$d2d2d2d2,d1      * Check the results
00:00005898 66FE            	  5763:                 bne.s *
00:0000589A 0C82D1D1D1D1    	  5764:                 cmpi.l #$d1d1d1d1,d2
00:000058A0 66FE            	  5765:                 bne.s *
00:000058A2 0C83A3A3A3A3    	  5766:                 cmpi.l #$a3a3a3a3,d3
00:000058A8 66FE            	  5767:                 bne.s *
                            	  5768: 
00:000058AA 2209            	  5769:                 move.l a1,d1
00:000058AC 240A            	  5770:                 move.l a2,d2
00:000058AE 260B            	  5771:                 move.l a3,d3
                            	  5772: 
00:000058B0 0C81A2A2A2A2    	  5773:                 cmpi.l #$a2a2a2a2,d1
00:000058B6 66FE            	  5774:                 bne.s *
00:000058B8 0C82A1A1A1A1    	  5775:                 cmpi.l #$a1a1a1a1,d2
00:000058BE 66FE            	  5776:                 bne.s *
00:000058C0 0C83D3D3D3D3    	  5777:                 cmpi.l #$d3d3d3d3,d3
00:000058C6 66FE            	  5778:                 bne.s *
                            	  5779: 
00:000058C8 4E75            	  5780:                 rts
                            	  5781: 
                            	  5782: 
                            	  5783: *-----------------------------------------------------------
                            	  5784: *-----------------------------------------------------------
                            	  5785: * OPCODE : ROx
                            	  5786: *-----------------------------------------------------------
                            	  5787: *-----------------------------------------------------------
                            	  5788: 
                            	  5789: *     Subroutine to check and accumulate the flags
00:000058CA 40C3            	  5790: ROx_FLAGS:      move.w sr,d3
00:000058CC 02830000000F    	  5791:                 andi.l #$0F,d3            * Isolate flags
00:000058D2 DA83            	  5792:                 add.l d3,d5               * Copy flag results into accumulator
00:000058D4 4E75            	  5793:                 rts
                            	  5794: 
                            	  5795: op_ROx:
                            	  5796: 
                            	  5797: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  5798: 
                            	  5799: *        BYTE LEFT
00:000058D6 203C80018FF1    	  5800:                 move.l #$80018FF1,d0
00:000058DC 7A00            	  5801:                 moveq  #$00000000,d5
00:000058DE 7C11            	  5802:                 moveq  #$00000011,d6
                            	  5803: ROx_LOOP1:
00:000058E0 ED38            	  5804:                 rol.b d6,d0
00:000058E2 61E6            	  5805:                 bsr ROx_FLAGS
00:000058E4 51CEFFFA        	  5806:                 dbf d6,ROx_LOOP1
00:000058E8 0C8080018FE3    	  5807:                 cmpi.l #$80018FE3,d0
00:000058EE 66FE            	  5808:                 bne.s *
00:000058F0 0C850000006B    	  5809:                 cmpi.l #$0000006B,d5
00:000058F6 66FE            	  5810:                 bne.s *
                            	  5811: 
                            	  5812: *        BYTE RIGHT
00:000058F8 203C80018FF1    	  5813:                 move.l #$80018FF1,d0
00:000058FE 7C12            	  5814:                 moveq  #$00000012,d6
                            	  5815: ROx_LOOP2:
00:00005900 EC38            	  5816:                 ror.b d6,d0
00:00005902 61C6            	  5817:                 bsr ROx_FLAGS
00:00005904 51CEFFFA        	  5818:                 dbf d6,ROx_LOOP2
00:00005908 0C8080018F3E    	  5819:                 cmpi.l #$80018F3E,d0
00:0000590E 66FE            	  5820:                 bne.s *
00:00005910 0C85000000C5    	  5821:                 cmpi.l #$000000C5,d5
00:00005916 66FE            	  5822:                 bne.s *
                            	  5823: 
                            	  5824: 
                            	  5825: *        WORD LEFT
00:00005918 203C80018FF1    	  5826:                 move.l #$80018FF1,d0
00:0000591E 7C13            	  5827:                 moveq  #$00000013,d6
                            	  5828: ROx_LOOP3:
00:00005920 ED78            	  5829:                 rol.w d6,d0
00:00005922 61A6            	  5830:                 bsr ROx_FLAGS
00:00005924 51CEFFFA        	  5831:                 dbf d6,ROx_LOOP3
00:00005928 0C80800163FC    	  5832:                 cmpi.l #$800163FC,d0
00:0000592E 66FE            	  5833:                 bne.s *
00:00005930 0C8500000131    	  5834:                 cmpi.l #$00000131,d5
00:00005936 66FE            	  5835:                 bne.s *
                            	  5836: 
                            	  5837: *        WORD RIGHT
00:00005938 203C80018FF1    	  5838:                 move.l #$80018FF1,d0
00:0000593E 7C1E            	  5839:                 move.l #$0000001E,d6
                            	  5840: ROx_LOOP4:
00:00005940 EC78            	  5841:                 ror.w d6,d0
00:00005942 6186            	  5842:                 bsr ROx_FLAGS
00:00005944 51CEFFFA        	  5843:                 dbf d6,ROx_LOOP4
00:00005948 0C808001C7F8    	  5844:                 cmpi.l #$8001C7F8,d0
00:0000594E 66FE            	  5845:                 bne.s *
00:00005950 0C85000001DB    	  5846:                 cmpi.l #$000001DB,d5
00:00005956 66FE            	  5847:                 bne.s *
                            	  5848: 
                            	  5849: 
                            	  5850: *        LONG LEFT
00:00005958 203C80018FF1    	  5851:                 move.l #$80018FF1,d0
00:0000595E 7C15            	  5852:                 moveq  #$00000015,d6
                            	  5853: ROx_LOOP5:
00:00005960 EDB8            	  5854:                 rol.l d6,d0
00:00005962 6100FF66        	  5855:                 bsr ROx_FLAGS
00:00005966 51CEFFF8        	  5856:                 dbf d6,ROx_LOOP5
00:0000596A 0C8000C7F8C0    	  5857:                 cmpi.l #$00C7F8C0,d0
00:00005970 66FE            	  5858:                 bne.s *
00:00005972 0C850000021A    	  5859:                 cmpi.l #$0000021A,d5
00:00005978 66FE            	  5860:                 bne.s *
                            	  5861: 
                            	  5862: *        LONG RIGHT
00:0000597A 203C80018FF1    	  5863:                 move.l #$80018FF1,d0
00:00005980 7C16            	  5864:                 moveq  #$00000016,d6
                            	  5865: ROx_LOOP6:
00:00005982 ECB8            	  5866:                 ror.l d6,d0
00:00005984 6100FF44        	  5867:                 bsr ROx_FLAGS
00:00005988 51CEFFF8        	  5868:                 dbf d6,ROx_LOOP6
00:0000598C 0C80000C7F8C    	  5869:                 cmpi.l #$000C7F8C,d0
00:00005992 66FE            	  5870:                 bne.s *
00:00005994 0C8500000250    	  5871:                 cmpi.l #$00000250,d5
00:0000599A 66FE            	  5872:                 bne.s *
                            	  5873: 
                            	  5874: 
                            	  5875: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  5876: 
00:0000599C 203C80018FF1    	  5877:                 move.l #$80018FF1,d0
00:000059A2 7A00            	  5878:                 moveq  #$00000000,d5
                            	  5879: 
                            	  5880: *        BYTE LEFT
00:000059A4 E318            	  5881:                 rol.b #1,d0
00:000059A6 6100FF22        	  5882:                 bsr ROx_FLAGS
00:000059AA EB18            	  5883:                 rol.b #5,d0
00:000059AC 6100FF1C        	  5884:                 bsr ROx_FLAGS
00:000059B0 EF18            	  5885:                 rol.b #7,d0
00:000059B2 6100FF16        	  5886:                 bsr ROx_FLAGS
00:000059B6 E118            	  5887:                 rol.b #8,d0
00:000059B8 6100FF10        	  5888:                 bsr ROx_FLAGS
00:000059BC 0C8080018F3E    	  5889:                 cmpi.l #$80018F3E,d0
00:000059C2 66FE            	  5890:                 bne.s *
00:000059C4 0C8500000009    	  5891:                 cmpi.l #$00000009,d5
00:000059CA 66FE            	  5892:                 bne.s *
                            	  5893: 
                            	  5894: *        BYTE RIGHT
00:000059CC E218            	  5895:                 ror.b #1,d0
00:000059CE 6100FEFA        	  5896:                 bsr ROx_FLAGS
00:000059D2 EA18            	  5897:                 ror.b #5,d0
00:000059D4 6100FEF4        	  5898:                 bsr ROx_FLAGS
00:000059D8 EE18            	  5899:                 ror.b #7,d0
00:000059DA 6100FEEE        	  5900:                 bsr ROx_FLAGS
00:000059DE E018            	  5901:                 ror.b #8,d0
00:000059E0 6100FEE8        	  5902:                 bsr ROx_FLAGS
00:000059E4 0C8080018FF1    	  5903:                 cmpi.l #$80018FF1,d0
00:000059EA 66FE            	  5904:                 bne.s *
00:000059EC 0C8500000024    	  5905:                 cmpi.l #$00000024,d5
00:000059F2 66FE            	  5906:                 bne.s *
                            	  5907: 
                            	  5908: *        WORD LEFT
00:000059F4 E358            	  5909:                 rol.w #1,d0
00:000059F6 6100FED2        	  5910:                 bsr ROx_FLAGS
00:000059FA EB58            	  5911:                 rol.w #5,d0
00:000059FC 6100FECC        	  5912:                 bsr ROx_FLAGS
00:00005A00 EF58            	  5913:                 rol.w #7,d0
00:00005A02 6100FEC6        	  5914:                 bsr ROx_FLAGS
00:00005A06 E158            	  5915:                 rol.w #8,d0
00:00005A08 6100FEC0        	  5916:                 bsr ROx_FLAGS
00:00005A0C 0C808001FE31    	  5917:                 cmpi.l #$8001FE31,d0
00:00005A12 66FE            	  5918:                 bne.s *
00:00005A14 0C8500000037    	  5919:                 cmpi.l #$00000037,d5
00:00005A1A 66FE            	  5920:                 bne.s *
                            	  5921: 
                            	  5922: *        WORD RIGHT
00:00005A1C E258            	  5923:                 ror.w #1,d0
00:00005A1E 6100FEAA        	  5924:                 bsr ROx_FLAGS
00:00005A22 EA58            	  5925:                 ror.w #5,d0
00:00005A24 6100FEA4        	  5926:                 bsr ROx_FLAGS
00:00005A28 EE58            	  5927:                 ror.w #7,d0
00:00005A2A 6100FE9E        	  5928:                 bsr ROx_FLAGS
00:00005A2E E058            	  5929:                 ror.w #8,d0
00:00005A30 6100FE98        	  5930:                 bsr ROx_FLAGS
00:00005A34 0C8080018FF1    	  5931:                 cmpi.l #$80018FF1,d0
00:00005A3A 66FE            	  5932:                 bne.s *
00:00005A3C 0C850000005B    	  5933:                 cmpi.l #$0000005B,d5
00:00005A42 66FE            	  5934:                 bne.s *
                            	  5935: 
                            	  5936: *        LONG LEFT
00:00005A44 E398            	  5937:                 rol.l #1,d0
00:00005A46 6100FE82        	  5938:                 bsr ROx_FLAGS
00:00005A4A EB98            	  5939:                 rol.l #5,d0
00:00005A4C 6100FE7C        	  5940:                 bsr ROx_FLAGS
00:00005A50 EF98            	  5941:                 rol.l #7,d0
00:00005A52 6100FE76        	  5942:                 bsr ROx_FLAGS
00:00005A56 E198            	  5943:                 rol.l #8,d0
00:00005A58 6100FE70        	  5944:                 bsr ROx_FLAGS
00:00005A5C 0C80FE300031    	  5945:                 cmpi.l #$FE300031,d0
00:00005A62 66FE            	  5946:                 bne.s *
00:00005A64 0C8500000065    	  5947:                 cmpi.l #$00000065,d5
00:00005A6A 66FE            	  5948:                 bne.s *
                            	  5949: 
                            	  5950: *        LONG RIGHT
00:00005A6C E298            	  5951:                 ror.l #1,d0
00:00005A6E 6100FE5A        	  5952:                 bsr ROx_FLAGS
00:00005A72 EA98            	  5953:                 ror.l #5,d0
00:00005A74 6100FE54        	  5954:                 bsr ROx_FLAGS
00:00005A78 EE98            	  5955:                 ror.l #7,d0
00:00005A7A 6100FE4E        	  5956:                 bsr ROx_FLAGS
00:00005A7E E098            	  5957:                 ror.l #8,d0
00:00005A80 6100FE48        	  5958:                 bsr ROx_FLAGS
00:00005A84 0C8080018FF1    	  5959:                 cmpi.l #$80018FF1,d0
00:00005A8A 66FE            	  5960:                 bne.s *
00:00005A8C 0C8500000080    	  5961:                 cmpi.l #$00000080,d5
00:00005A92 66FE            	  5962:                 bne.s *
                            	  5963: 
                            	  5964: 
                            	  5965: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  5966: 
00:00005A94 7A00            	  5967:                 moveq  #$00000000,d5
00:00005A96 307C0100        	  5968:                 move.l #$00000100,a0
00:00005A9A 30BC8FF1        	  5969:                 move.w #$8FF1,(a0)
                            	  5970: 
                            	  5971: *        WORD LEFT
00:00005A9E E7D0            	  5972:                 rol (a0)
00:00005AA0 6100FE28        	  5973:                 bsr ROx_FLAGS
00:00005AA4 E7D0            	  5974:                 rol (a0)
00:00005AA6 6100FE22        	  5975:                 bsr ROx_FLAGS
00:00005AAA E7D0            	  5976:                 rol (a0)
00:00005AAC 6100FE1C        	  5977:                 bsr ROx_FLAGS
00:00005AB0 E7D0            	  5978:                 rol (a0)
00:00005AB2 6100FE16        	  5979:                 bsr ROx_FLAGS
00:00005AB6 3010            	  5980:                 move.w (a0),d0
00:00005AB8 0C808001FF18    	  5981:                 cmpi.l #$8001FF18,d0
00:00005ABE 66FE            	  5982:                 bne.s *
00:00005AC0 0C8500000009    	  5983:                 cmpi.l #$00000009,d5
00:00005AC6 66FE            	  5984:                 bne.s *
                            	  5985: 
                            	  5986: *        WORD RIGHT
00:00005AC8 E6D0            	  5987:                 ror (a0)
00:00005ACA 6100FDFE        	  5988:                 bsr ROx_FLAGS
00:00005ACE E6D0            	  5989:                 ror (a0)
00:00005AD0 6100FDF8        	  5990:                 bsr ROx_FLAGS
00:00005AD4 E6D0            	  5991:                 ror (a0)
00:00005AD6 6100FDF2        	  5992:                 bsr ROx_FLAGS
00:00005ADA E6D0            	  5993:                 ror (a0)
00:00005ADC 6100FDEC        	  5994:                 bsr ROx_FLAGS
00:00005AE0 E6D0            	  5995:                 ror (a0)
00:00005AE2 6100FDE6        	  5996:                 bsr ROx_FLAGS
00:00005AE6 E6D0            	  5997:                 ror (a0)
00:00005AE8 6100FDE0        	  5998:                 bsr ROx_FLAGS
00:00005AEC 3010            	  5999:                 move.w (a0),d0
00:00005AEE 0C80800163FC    	  6000:                 cmpi.l #$800163FC,d0
00:00005AF4 66FE            	  6001:                 bne.s *
00:00005AF6 0C850000001B    	  6002:                 cmpi.l #$0000001B,d5
00:00005AFC 66FE            	  6003:                 bne.s *
                            	  6004: 
00:00005AFE 4E75            	  6005:                 rts
                            	  6006: 
                            	  6007: 
                            	  6008: 
                            	  6009: *-----------------------------------------------------------
                            	  6010: *-----------------------------------------------------------
                            	  6011: * OPCODE : ROXx
                            	  6012: *-----------------------------------------------------------
                            	  6013: *-----------------------------------------------------------
                            	  6014: 
                            	  6015: *     Subroutine to check and accumulate the flags
00:00005B00 40C3            	  6016: ROXx_FLAGS:     move.w sr,d3
00:00005B02 02830000000F    	  6017:                 andi.l #$0F,d3            * Isolate flags
00:00005B08 DA83            	  6018:                 add.l d3,d5               * Copy flag results into accumulator
00:00005B0A 4E75            	  6019:                 rts
                            	  6020: 
                            	  6021: op_ROXx:
                            	  6022: 
                            	  6023: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6024: 
                            	  6025: *        BYTE LEFT
00:00005B0C 203C80018FF1    	  6026:                 move.l #$80018FF1,d0
00:00005B12 7A00            	  6027:                 moveq  #$00000000,d5
00:00005B14 7C11            	  6028:                 moveq  #$00000011,d6
                            	  6029: ROXx_LOOP1:
00:00005B16 ED30            	  6030:                 roxl.b d6,d0
00:00005B18 61E6            	  6031:                 bsr ROXx_FLAGS
00:00005B1A 51CEFFFA        	  6032:                 dbf d6,ROXx_LOOP1
00:00005B1E 0C8080018FD0    	  6033:                 cmpi.l #$80018FD0,d0
00:00005B24 66FE            	  6034:                 bne.s *
00:00005B26 0C8500000042    	  6035:                 cmpi.l #$00000042,d5
00:00005B2C 66FE            	  6036:                 bne.s *
                            	  6037: 
                            	  6038: *        BYTE RIGHT
00:00005B2E 203C80018FF1    	  6039:                 move.l #$80018FF1,d0
00:00005B34 7C12            	  6040:                 moveq  #$00000012,d6
                            	  6041: ROXx_LOOP2:
00:00005B36 EC30            	  6042:                 roxr.b d6,d0
00:00005B38 61C6            	  6043:                 bsr ROXx_FLAGS
00:00005B3A 51CEFFFA        	  6044:                 dbf d6,ROXx_LOOP2
00:00005B3E 0C8080018F51    	  6045:                 cmpi.l #$80018F51,d0
00:00005B44 66FE            	  6046:                 bne.s *
00:00005B46 0C850000009C    	  6047:                 cmpi.l #$0000009C,d5
00:00005B4C 66FE            	  6048:                 bne.s *
                            	  6049: 
                            	  6050: 
                            	  6051: *        WORD LEFT
00:00005B4E 203C80018FF1    	  6052:                 move.l #$80018FF1,d0
00:00005B54 7C13            	  6053:                 moveq  #$00000013,d6
                            	  6054: ROXx_LOOP3:
00:00005B56 ED70            	  6055:                 roxl.w d6,d0
00:00005B58 61A6            	  6056:                 bsr ROXx_FLAGS
00:00005B5A 51CEFFFA        	  6057:                 dbf d6,ROXx_LOOP3
00:00005B5E 0C8080013980    	  6058:                 cmpi.l #$80013980,d0
00:00005B64 66FE            	  6059:                 bne.s *
00:00005B66 0C85000000C9    	  6060:                 cmpi.l #$000000C9,d5
00:00005B6C 66FE            	  6061:                 bne.s *
                            	  6062: 
                            	  6063: *        WORD RIGHT
00:00005B6E 203C80018FF1    	  6064:                 move.l #$80018FF1,d0
00:00005B74 7C1E            	  6065:                 move.l #$0000001E,d6
                            	  6066: ROXx_LOOP4:
00:00005B76 EC70            	  6067:                 roxr.w d6,d0
00:00005B78 6186            	  6068:                 bsr ROXx_FLAGS
00:00005B7A 51CEFFFA        	  6069:                 dbf d6,ROXx_LOOP4
00:00005B7E 0C8080010A1D    	  6070:                 cmpi.l #$80010A1D,d0
00:00005B84 66FE            	  6071:                 bne.s *
00:00005B86 0C850000014D    	  6072:                 cmpi.l #$0000014D,d5
00:00005B8C 66FE            	  6073:                 bne.s *
                            	  6074: 
                            	  6075: 
                            	  6076: *        LONG LEFT
00:00005B8E 203C80018FF1    	  6077:                 move.l #$80018FF1,d0
00:00005B94 7C15            	  6078:                 moveq  #$00000015,d6
                            	  6079: ROXx_LOOP5:
00:00005B96 EDB0            	  6080:                 roxl.l d6,d0
00:00005B98 6100FF66        	  6081:                 bsr ROXx_FLAGS
00:00005B9C 51CEFFF8        	  6082:                 dbf d6,ROXx_LOOP5
00:00005BA0 0C80800185D0    	  6083:                 cmpi.l #$800185D0,d0
00:00005BA6 66FE            	  6084:                 bne.s *
00:00005BA8 0C85000001A1    	  6085:                 cmpi.l #$000001A1,d5
00:00005BAE 66FE            	  6086:                 bne.s *
                            	  6087: 
                            	  6088: *        LONG RIGHT
00:00005BB0 203C80018FF1    	  6089:                 move.l #$80018FF1,d0
00:00005BB6 7C16            	  6090:                 moveq  #$00000016,d6
                            	  6091: ROXx_LOOP6:
00:00005BB8 ECB0            	  6092:                 roxr.l d6,d0
00:00005BBA 6100FF44        	  6093:                 bsr ROXx_FLAGS
00:00005BBE 51CEFFF8        	  6094:                 dbf d6,ROXx_LOOP6
00:00005BC2 0C80082D8200    	  6095:                 cmpi.l #$082D8200,d0
00:00005BC8 66FE            	  6096:                 bne.s *
00:00005BCA 0C85000001DE    	  6097:                 cmpi.l #$000001DE,d5
00:00005BD0 66FE            	  6098:                 bne.s *
                            	  6099: 
                            	  6100: 
                            	  6101: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6102: 
00:00005BD2 203C80018FF1    	  6103:                 move.l #$80018FF1,d0
00:00005BD8 7A00            	  6104:                 moveq  #$00000000,d5
                            	  6105: 
                            	  6106: *        BYTE LEFT
00:00005BDA E310            	  6107:                 roxl.b #1,d0
00:00005BDC 6100FF22        	  6108:                 bsr ROXx_FLAGS
00:00005BE0 EB10            	  6109:                 roxl.b #5,d0
00:00005BE2 6100FF1C        	  6110:                 bsr ROXx_FLAGS
00:00005BE6 EF10            	  6111:                 roxl.b #7,d0
00:00005BE8 6100FF16        	  6112:                 bsr ROXx_FLAGS
00:00005BEC E110            	  6113:                 roxl.b #8,d0
00:00005BEE 6100FF10        	  6114:                 bsr ROXx_FLAGS
00:00005BF2 0C8080018F09    	  6115:                 cmpi.l #$80018F09,d0
00:00005BF8 66FE            	  6116:                 bne.s *
00:00005BFA 0C850000000B    	  6117:                 cmpi.l #$0000000B,d5
00:00005C00 66FE            	  6118:                 bne.s *
                            	  6119: 
                            	  6120: *        BYTE RIGHT
00:00005C02 E210            	  6121:                 roxr.b #1,d0
00:00005C04 6100FEFA        	  6122:                 bsr ROXx_FLAGS
00:00005C08 EA10            	  6123:                 roxr.b #5,d0
00:00005C0A 6100FEF4        	  6124:                 bsr ROXx_FLAGS
00:00005C0E EE10            	  6125:                 roxr.b #7,d0
00:00005C10 6100FEEE        	  6126:                 bsr ROXx_FLAGS
00:00005C14 E010            	  6127:                 roxr.b #8,d0
00:00005C16 6100FEE8        	  6128:                 bsr ROXx_FLAGS
00:00005C1A 0C8080018F00    	  6129:                 cmpi.l #$80018F00,d0
00:00005C20 66FE            	  6130:                 bne.s *
00:00005C22 0C8500000015    	  6131:                 cmpi.l #$00000015,d5
00:00005C28 66FE            	  6132:                 bne.s *
                            	  6133: 
                            	  6134: *        WORD LEFT
00:00005C2A E350            	  6135:                 roxl.w #1,d0
00:00005C2C 6100FED2        	  6136:                 bsr ROXx_FLAGS
00:00005C30 EB50            	  6137:                 roxl.w #5,d0
00:00005C32 6100FECC        	  6138:                 bsr ROXx_FLAGS
00:00005C36 EF50            	  6139:                 roxl.w #7,d0
00:00005C38 6100FEC6        	  6140:                 bsr ROXx_FLAGS
00:00005C3C E150            	  6141:                 roxl.w #8,d0
00:00005C3E 6100FEC0        	  6142:                 bsr ROXx_FLAGS
00:00005C42 0C808001B000    	  6143:                 cmpi.l #$8001B000,d0
00:00005C48 66FE            	  6144:                 bne.s *
00:00005C4A 0C8500000027    	  6145:                 cmpi.l #$00000027,d5
00:00005C50 66FE            	  6146:                 bne.s *
                            	  6147: 
                            	  6148: *        WORD RIGHT
00:00005C52 E250            	  6149:                 roxr.w #1,d0
00:00005C54 6100FEAA        	  6150:                 bsr ROXx_FLAGS
00:00005C58 EA50            	  6151:                 roxr.w #5,d0
00:00005C5A 6100FEA4        	  6152:                 bsr ROXx_FLAGS
00:00005C5E EE50            	  6153:                 roxr.w #7,d0
00:00005C60 6100FE9E        	  6154:                 bsr ROXx_FLAGS
00:00005C64 E050            	  6155:                 roxr.w #8,d0
00:00005C66 6100FE98        	  6156:                 bsr ROXx_FLAGS
00:00005C6A 0C8080010A00    	  6157:                 cmpi.l #$80010A00,d0
00:00005C70 66FE            	  6158:                 bne.s *
00:00005C72 0C8500000028    	  6159:                 cmpi.l #$00000028,d5
00:00005C78 66FE            	  6160:                 bne.s *
                            	  6161: 
                            	  6162: *        LONG LEFT
00:00005C7A E390            	  6163:                 roxl.l #1,d0
00:00005C7C 6100FE82        	  6164:                 bsr ROXx_FLAGS
00:00005C80 EB90            	  6165:                 roxl.l #5,d0
00:00005C82 6100FE7C        	  6166:                 bsr ROXx_FLAGS
00:00005C86 EF90            	  6167:                 roxl.l #7,d0
00:00005C88 6100FE76        	  6168:                 bsr ROXx_FLAGS
00:00005C8C E190            	  6169:                 roxl.l #8,d0
00:00005C8E 6100FE70        	  6170:                 bsr ROXx_FLAGS
00:00005C92 0C8040000010    	  6171:                 cmpi.l #$40000010,d0
00:00005C98 66FE            	  6172:                 bne.s *
00:00005C9A 0C850000002A    	  6173:                 cmpi.l #$0000002A,d5
00:00005CA0 66FE            	  6174:                 bne.s *
                            	  6175: 
                            	  6176: *        LONG RIGHT
00:00005CA2 E290            	  6177:                 roxr.l #1,d0
00:00005CA4 6100FE5A        	  6178:                 bsr ROXx_FLAGS
00:00005CA8 EA90            	  6179:                 roxr.l #5,d0
00:00005CAA 6100FE54        	  6180:                 bsr ROXx_FLAGS
00:00005CAE EE90            	  6181:                 roxr.l #7,d0
00:00005CB0 6100FE4E        	  6182:                 bsr ROXx_FLAGS
00:00005CB4 E090            	  6183:                 roxr.l #8,d0
00:00005CB6 6100FE48        	  6184:                 bsr ROXx_FLAGS
00:00005CBA 0C8000010200    	  6185:                 cmpi.l #$00010200,d0
00:00005CC0 66FE            	  6186:                 bne.s *
00:00005CC2 0C8500000032    	  6187:                 cmpi.l #$00000032,d5
00:00005CC8 66FE            	  6188:                 bne.s *
                            	  6189: 
                            	  6190: 
                            	  6191: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6192: 
00:00005CCA 7A00            	  6193:                 moveq  #$00000000,d5
00:00005CCC 307C0100        	  6194:                 move.l #$00000100,a0
00:00005CD0 30BC8FF1        	  6195:                 move.w #$8FF1,(a0)
                            	  6196: 
                            	  6197: *        WORD LEFT
00:00005CD4 E5D0            	  6198:                 roxl (a0)
00:00005CD6 6100FE28        	  6199:                 bsr ROXx_FLAGS
00:00005CDA E5D0            	  6200:                 roxl (a0)
00:00005CDC 6100FE22        	  6201:                 bsr ROXx_FLAGS
00:00005CE0 E5D0            	  6202:                 roxl (a0)
00:00005CE2 6100FE1C        	  6203:                 bsr ROXx_FLAGS
00:00005CE6 E5D0            	  6204:                 roxl (a0)
00:00005CE8 6100FE16        	  6205:                 bsr ROXx_FLAGS
00:00005CEC 3010            	  6206:                 move.w (a0),d0
00:00005CEE 0C800001FF10    	  6207:                 cmpi.l #$0001FF10,d0
00:00005CF4 66FE            	  6208:                 bne.s *
00:00005CF6 0C8500000009    	  6209:                 cmpi.l #$00000009,d5
00:00005CFC 66FE            	  6210:                 bne.s *
                            	  6211: 
                            	  6212: *        WORD RIGHT
00:00005CFE E4D0            	  6213:                 roxr (a0)
00:00005D00 6100FDFE        	  6214:                 bsr ROXx_FLAGS
00:00005D04 E4D0            	  6215:                 roxr (a0)
00:00005D06 6100FDF8        	  6216:                 bsr ROXx_FLAGS
00:00005D0A E4D0            	  6217:                 roxr (a0)
00:00005D0C 6100FDF2        	  6218:                 bsr ROXx_FLAGS
00:00005D10 E4D0            	  6219:                 roxr (a0)
00:00005D12 6100FDEC        	  6220:                 bsr ROXx_FLAGS
00:00005D16 E4D0            	  6221:                 roxr (a0)
00:00005D18 6100FDE6        	  6222:                 bsr ROXx_FLAGS
00:00005D1C E4D0            	  6223:                 roxr (a0)
00:00005D1E 6100FDE0        	  6224:                 bsr ROXx_FLAGS
00:00005D22 3010            	  6225:                 move.w (a0),d0
00:00005D24 0C80000103FC    	  6226:                 cmpi.l #$000103FC,d0
00:00005D2A 66FE            	  6227:                 bne.s *
00:00005D2C 0C850000000A    	  6228:                 cmpi.l #$0000000A,d5
00:00005D32 66FE            	  6229:                 bne.s *
                            	  6230: 
00:00005D34 4E75            	  6231:                 rts
                            	  6232: 
                            	  6233: 
                            	  6234: 
                            	  6235: 
                            	  6236: *-----------------------------------------------------------
                            	  6237: *-----------------------------------------------------------
                            	  6238: * OPCODE : SHIFTS
                            	  6239: *-----------------------------------------------------------
                            	  6240: *-----------------------------------------------------------
                            	  6241: 
                            	  6242: *     Subroutine to check and accumulate the flags
00:00005D36 40C3            	  6243: SHIFTS_FLAGS:   move.w sr,d3
00:00005D38 02830000000F    	  6244:                 andi.l #$0F,d3            * Isolate flags
00:00005D3E DA83            	  6245:                 add.l d3,d5               * Copy flag results into accumulator
00:00005D40 4E75            	  6246:                 rts
                            	  6247: 
                            	  6248: op_SHIFTS:
                            	  6249: 
                            	  6250: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6251: 
                            	  6252: *        BYTE LEFT
00:00005D42 203C80018F81    	  6253:                 move.l #$80018F81,d0
00:00005D48 7A00            	  6254:                 moveq  #$00000000,d5
00:00005D4A 7C02            	  6255:                 moveq  #$00000002,d6
                            	  6256: SHIFTS_LOOP1:
00:00005D4C ED20            	  6257:                 asl.b d6,d0
00:00005D4E 61E6            	  6258:                 bsr SHIFTS_FLAGS
00:00005D50 51CEFFFA        	  6259:                 dbf d6,SHIFTS_LOOP1
00:00005D54 0C8080018F08    	  6260:                 cmpi.l #$80018F08,d0
00:00005D5A 66FE            	  6261:                 bne.s *
00:00005D5C 0C8500000002    	  6262:                 cmpi.l #$00000002,d5
00:00005D62 66FE            	  6263:                 bne.s *
                            	  6264: 
                            	  6265: *        BYTE RIGHT
00:00005D64 203C80018F81    	  6266:                 move.l #$80018F81,d0
00:00005D6A 7C02            	  6267:                 moveq  #$00000002,d6
                            	  6268: SHIFTS_LOOP2:
00:00005D6C EC20            	  6269:                 asr.b d6,d0
00:00005D6E 61C6            	  6270:                 bsr SHIFTS_FLAGS
00:00005D70 51CEFFFA        	  6271:                 dbf d6,SHIFTS_LOOP2
00:00005D74 0C8080018FF0    	  6272:                 cmpi.l #$80018FF0,d0
00:00005D7A 66FE            	  6273:                 bne.s *
00:00005D7C 0C850000001A    	  6274:                 cmpi.l #$0000001A,d5
00:00005D82 66FE            	  6275:                 bne.s *
                            	  6276: 
                            	  6277: 
                            	  6278: *        WORD LEFT
00:00005D84 203C80018FF1    	  6279:                 move.l #$80018FF1,d0
00:00005D8A 7C02            	  6280:                 moveq  #$00000002,d6
                            	  6281: SHIFTS_LOOP3:
00:00005D8C ED60            	  6282:                 asl.w d6,d0
00:00005D8E 61A6            	  6283:                 bsr SHIFTS_FLAGS
00:00005D90 51CEFFFA        	  6284:                 dbf d6,SHIFTS_LOOP3
00:00005D94 0C8080017F88    	  6285:                 cmpi.l #$80017F88,d0
00:00005D9A 66FE            	  6286:                 bne.s *
00:00005D9C 0C850000001C    	  6287:                 cmpi.l #$0000001C,d5
00:00005DA2 66FE            	  6288:                 bne.s *
                            	  6289: 
                            	  6290: *        WORD RIGHT
00:00005DA4 203C80018FF1    	  6291:                 move.l #$80018FF1,d0
00:00005DAA 7C02            	  6292:                 moveq  #$00000002,d6
                            	  6293: SHIFTS_LOOP4:
00:00005DAC EC60            	  6294:                 asr.w d6,d0
00:00005DAE 6186            	  6295:                 bsr SHIFTS_FLAGS
00:00005DB0 51CEFFFA        	  6296:                 dbf d6,SHIFTS_LOOP4
00:00005DB4 0C808001F1FE    	  6297:                 cmpi.l #$8001F1FE,d0
00:00005DBA 66FE            	  6298:                 bne.s *
00:00005DBC 0C8500000034    	  6299:                 cmpi.l #$00000034,d5
00:00005DC2 66FE            	  6300:                 bne.s *
                            	  6301: 
                            	  6302: 
                            	  6303: *        LONG LEFT
00:00005DC4 203C80018FF1    	  6304:                 move.l #$80018FF1,d0
00:00005DCA 7C02            	  6305:                 moveq  #$00000002,d6
                            	  6306: SHIFTS_LOOP5:
00:00005DCC EDA0            	  6307:                 asl.l d6,d0
00:00005DCE 6100FF66        	  6308:                 bsr SHIFTS_FLAGS
00:00005DD2 51CEFFF8        	  6309:                 dbf d6,SHIFTS_LOOP5
00:00005DD6 0C80000C7F88    	  6310:                 cmpi.l #$000C7F88,d0
00:00005DDC 66FE            	  6311:                 bne.s *
00:00005DDE 0C8500000036    	  6312:                 cmpi.l #$00000036,d5
00:00005DE4 66FE            	  6313:                 bne.s *
                            	  6314: 
                            	  6315: *        LONG RIGHT
00:00005DE6 203C80018FF1    	  6316:                 move.l #$80018FF1,d0
00:00005DEC 7C02            	  6317:                 moveq  #$00000002,d6
                            	  6318: SHIFTS_LOOP6:
00:00005DEE ECA0            	  6319:                 asr.l d6,d0
00:00005DF0 6100FF44        	  6320:                 bsr SHIFTS_FLAGS
00:00005DF4 51CEFFF8        	  6321:                 dbf d6,SHIFTS_LOOP6
00:00005DF8 0C80F00031FE    	  6322:                 cmpi.l #$F00031FE,d0
00:00005DFE 66FE            	  6323:                 bne.s *
00:00005E00 0C850000004E    	  6324:                 cmpi.l #$0000004E,d5
00:00005E06 66FE            	  6325:                 bne.s *
                            	  6326: 
                            	  6327: 
                            	  6328: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6329: 
00:00005E08 203C80018FF1    	  6330:                 move.l #$80018FF1,d0
00:00005E0E 7A00            	  6331:                 moveq  #$00000000,d5
                            	  6332: 
                            	  6333: *        BYTE LEFT
00:00005E10 D000            	  6334:                 asl.b #1,d0
00:00005E12 6100FF22        	  6335:                 bsr SHIFTS_FLAGS
00:00005E16 E500            	  6336:                 asl.b #2,d0
00:00005E18 6100FF1C        	  6337:                 bsr SHIFTS_FLAGS
00:00005E1C D000            	  6338:                 asl.b #1,d0
00:00005E1E 6100FF16        	  6339:                 bsr SHIFTS_FLAGS
00:00005E22 E700            	  6340:                 asl.b #3,d0
00:00005E24 6100FF10        	  6341:                 bsr SHIFTS_FLAGS
00:00005E28 0C8080018F80    	  6342:                 cmpi.l #$80018F80,d0
00:00005E2E 66FE            	  6343:                 bne.s *
00:00005E30 0C850000001F    	  6344:                 cmpi.l #$0000001F,d5
00:00005E36 66FE            	  6345:                 bne.s *
                            	  6346: 
                            	  6347: *        BYTE RIGHT
00:00005E38 E200            	  6348:                 asr.b #1,d0
00:00005E3A 6100FEFA        	  6349:                 bsr SHIFTS_FLAGS
00:00005E3E E400            	  6350:                 asr.b #2,d0
00:00005E40 6100FEF4        	  6351:                 bsr SHIFTS_FLAGS
00:00005E44 E600            	  6352:                 asr.b #3,d0
00:00005E46 6100FEEE        	  6353:                 bsr SHIFTS_FLAGS
00:00005E4A E200            	  6354:                 asr.b #1,d0
00:00005E4C 6100FEE8        	  6355:                 bsr SHIFTS_FLAGS
00:00005E50 0C8080018FFF    	  6356:                 cmpi.l #$80018FFF,d0
00:00005E56 66FE            	  6357:                 bne.s *
00:00005E58 0C850000003F    	  6358:                 cmpi.l #$0000003F,d5
00:00005E5E 66FE            	  6359:                 bne.s *
                            	  6360: 
                            	  6361: *        WORD LEFT
00:00005E60 D040            	  6362:                 asl.w #1,d0
00:00005E62 6100FED2        	  6363:                 bsr SHIFTS_FLAGS
00:00005E66 E540            	  6364:                 asl.w #2,d0
00:00005E68 6100FECC        	  6365:                 bsr SHIFTS_FLAGS
00:00005E6C E740            	  6366:                 asl.w #3,d0
00:00005E6E 6100FEC6        	  6367:                 bsr SHIFTS_FLAGS
00:00005E72 EB40            	  6368:                 asl.w #5,d0
00:00005E74 6100FEC0        	  6369:                 bsr SHIFTS_FLAGS
00:00005E78 0C808001F800    	  6370:                 cmpi.l #$8001F800,d0
00:00005E7E 66FE            	  6371:                 bne.s *
00:00005E80 0C8500000056    	  6372:                 cmpi.l #$00000056,d5
00:00005E86 66FE            	  6373:                 bne.s *
                            	  6374: 
                            	  6375: *        WORD RIGHT
00:00005E88 EA40            	  6376:                 asr.w #5,d0
00:00005E8A 6100FEAA        	  6377:                 bsr SHIFTS_FLAGS
00:00005E8E E240            	  6378:                 asr.w #1,d0
00:00005E90 6100FEA4        	  6379:                 bsr SHIFTS_FLAGS
00:00005E94 E440            	  6380:                 asr.w #2,d0
00:00005E96 6100FE9E        	  6381:                 bsr SHIFTS_FLAGS
00:00005E9A E840            	  6382:                 asr.w #4,d0
00:00005E9C 6100FE98        	  6383:                 bsr SHIFTS_FLAGS
00:00005EA0 0C808001FFFF    	  6384:                 cmpi.l #$8001FFFF,d0
00:00005EA6 66FE            	  6385:                 bne.s *
00:00005EA8 0C8500000077    	  6386:                 cmpi.l #$00000077,d5
00:00005EAE 66FE            	  6387:                 bne.s *
                            	  6388: 
                            	  6389: *        LONG LEFT
00:00005EB0 203C80018FF1    	  6390:                 move.l #$80018FF1,d0
00:00005EB6 D080            	  6391:                 asl.l #1,d0
00:00005EB8 6100FE7C        	  6392:                 bsr SHIFTS_FLAGS
00:00005EBC E580            	  6393:                 asl.l #2,d0
00:00005EBE 6100FE76        	  6394:                 bsr SHIFTS_FLAGS
00:00005EC2 EF80            	  6395:                 asl.l #7,d0
00:00005EC4 6100FE70        	  6396:                 bsr SHIFTS_FLAGS
00:00005EC8 E980            	  6397:                 asl.l #4,d0
00:00005ECA 6100FE6A        	  6398:                 bsr SHIFTS_FLAGS
00:00005ECE 0C8063FC4000    	  6399:                 cmpi.l #$63FC4000,d0
00:00005ED4 66FE            	  6400:                 bne.s *
00:00005ED6 0C850000007A    	  6401:                 cmpi.l #$0000007A,d5
00:00005EDC 66FE            	  6402:                 bne.s *
                            	  6403: 
                            	  6404: *        LONG RIGHT
00:00005EDE 203C80018FF1    	  6405:                 move.l #$80018FF1,d0
00:00005EE4 E280            	  6406:                 asr.l #1,d0
00:00005EE6 6100FE4E        	  6407:                 bsr SHIFTS_FLAGS
00:00005EEA EA80            	  6408:                 asr.l #5,d0
00:00005EEC 6100FE48        	  6409:                 bsr SHIFTS_FLAGS
00:00005EF0 EE80            	  6410:                 asr.l #7,d0
00:00005EF2 6100FE42        	  6411:                 bsr SHIFTS_FLAGS
00:00005EF6 E080            	  6412:                 asr.l #8,d0
00:00005EF8 6100FE3C        	  6413:                 bsr SHIFTS_FLAGS
00:00005EFC 0C80FFFFFC00    	  6414:                 cmpi.l #$FFFFFC00,d0
00:00005F02 66FE            	  6415:                 bne.s *
00:00005F04 0C850000009C    	  6416:                 cmpi.l #$0000009C,d5
00:00005F0A 66FE            	  6417:                 bne.s *
                            	  6418: 
                            	  6419: 
                            	  6420: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6421: 
00:00005F0C 7A00            	  6422:                 moveq  #$00000000,d5
00:00005F0E 307C0100        	  6423:                 move.l #$00000100,a0
00:00005F12 30BC8FF1        	  6424:                 move.w #$8FF1,(a0)
                            	  6425: 
                            	  6426: *        WORD LEFT
00:00005F16 E1D0            	  6427:                 asl  (a0)
00:00005F18 6100FE1C        	  6428:                 bsr SHIFTS_FLAGS
00:00005F1C E1D0            	  6429:                 asl  (a0)
00:00005F1E 6100FE16        	  6430:                 bsr SHIFTS_FLAGS
00:00005F22 E1D0            	  6431:                 asl  (a0)
00:00005F24 6100FE10        	  6432:                 bsr SHIFTS_FLAGS
00:00005F28 E1D0            	  6433:                 asl  (a0)
00:00005F2A 6100FE0A        	  6434:                 bsr SHIFTS_FLAGS
00:00005F2E 3010            	  6435:                 move.w (a0),d0
00:00005F30 0C80FFFFFF10    	  6436:                 cmpi.l #$FFFFFF10,d0
00:00005F36 66FE            	  6437:                 bne.s *
00:00005F38 0C850000000D    	  6438:                 cmpi.l #$0000000D,d5
00:00005F3E 66FE            	  6439:                 bne.s *
                            	  6440: 
                            	  6441: *        WORD RIGHT
00:00005F40 E0D0            	  6442:                 asr (a0)
00:00005F42 6100FDF2        	  6443:                 bsr SHIFTS_FLAGS
00:00005F46 E0D0            	  6444:                 asr (a0)
00:00005F48 6100FDEC        	  6445:                 bsr SHIFTS_FLAGS
00:00005F4C E0D0            	  6446:                 asr (a0)
00:00005F4E 6100FDE6        	  6447:                 bsr SHIFTS_FLAGS
00:00005F52 E0D0            	  6448:                 asr (a0)
00:00005F54 6100FDE0        	  6449:                 bsr SHIFTS_FLAGS
00:00005F58 E0D0            	  6450:                 asr (a0)
00:00005F5A 6100FDDA        	  6451:                 bsr SHIFTS_FLAGS
00:00005F5E E0D0            	  6452:                 asr (a0)
00:00005F60 6100FDD4        	  6453:                 bsr SHIFTS_FLAGS
00:00005F64 3010            	  6454:                 move.w (a0),d0
00:00005F66 0C80FFFFFFFC    	  6455:                 cmpi.l #$FFFFFFFC,d0
00:00005F6C 66FE            	  6456:                 bne.s *
00:00005F6E 0C850000003E    	  6457:                 cmpi.l #$0000003E,d5
00:00005F74 66FE            	  6458:                 bne.s *
                            	  6459: 
00:00005F76 4E75            	  6460:                 rts
                            	  6461: 
                            	  6462: 
                            	  6463: 
                            	  6464: *-----------------------------------------------------------
                            	  6465: *-----------------------------------------------------------
                            	  6466: * OPCODE : SHIFTS2
                            	  6467: *-----------------------------------------------------------
                            	  6468: *-----------------------------------------------------------
                            	  6469: 
                            	  6470: *     Subroutine to check and accumulate the flags
00:00005F78 40C3            	  6471: SHIFTS2_FLAGS:  move.w sr,d3
00:00005F7A 02830000000F    	  6472:                 andi.l #$0F,d3            * Isolate flags
00:00005F80 DA83            	  6473:                 add.l d3,d5               * Copy flag results into accumulator
00:00005F82 4E75            	  6474:                 rts
                            	  6475: 
                            	  6476: op_SHIFTS2:
                            	  6477: 
                            	  6478: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6479: 
                            	  6480: *        BYTE LEFT
00:00005F84 203C80018F81    	  6481:                 move.l #$80018F81,d0
00:00005F8A 7A00            	  6482:                 moveq  #$00000000,d5
00:00005F8C 7C02            	  6483:                 moveq  #$00000002,d6
                            	  6484: SHIFTS2_LOOP1:
00:00005F8E ED28            	  6485:                 lsl.b d6,d0
00:00005F90 61E6            	  6486:                 bsr SHIFTS2_FLAGS
00:00005F92 51CEFFFA        	  6487:                 dbf d6,SHIFTS2_LOOP1
00:00005F96 0C8080018F08    	  6488:                 cmpi.l #$80018F08,d0
00:00005F9C 66FE            	  6489:                 bne.s *
00:00005F9E 4A85            	  6490:                 cmpi.l #$00000000,d5
00:00005FA0 66FE            	  6491:                 bne.s *
                            	  6492: 
                            	  6493: *        BYTE RIGHT
00:00005FA2 203C80018F81    	  6494:                 move.l #$80018F81,d0
00:00005FA8 7C02            	  6495:                 moveq  #$00000002,d6
                            	  6496: SHIFTS2_LOOP2:
00:00005FAA EC28            	  6497:                 lsr.b d6,d0
00:00005FAC 61CA            	  6498:                 bsr SHIFTS2_FLAGS
00:00005FAE 51CEFFFA        	  6499:                 dbf d6,SHIFTS2_LOOP2
00:00005FB2 0C8080018F10    	  6500:                 cmpi.l #$80018F10,d0
00:00005FB8 66FE            	  6501:                 bne.s *
00:00005FBA 4A85            	  6502:                 cmpi.l #$00000000,d5
00:00005FBC 66FE            	  6503:                 bne.s *
                            	  6504: 
                            	  6505: 
                            	  6506: *        WORD LEFT
00:00005FBE 203C80018FF1    	  6507:                 move.l #$80018FF1,d0
00:00005FC4 7C02            	  6508:                 moveq  #$00000002,d6
                            	  6509: SHIFTS2_LOOP3:
00:00005FC6 ED68            	  6510:                 lsl.w d6,d0
00:00005FC8 61AE            	  6511:                 bsr SHIFTS2_FLAGS
00:00005FCA 51CEFFFA        	  6512:                 dbf d6,SHIFTS2_LOOP3
00:00005FCE 0C8080017F88    	  6513:                 cmpi.l #$80017F88,d0
00:00005FD4 66FE            	  6514:                 bne.s *
00:00005FD6 4A85            	  6515:                 cmpi.l #$00000000,d5
00:00005FD8 66FE            	  6516:                 bne.s *
                            	  6517: 
                            	  6518: *        WORD RIGHT
00:00005FDA 203C80018FF1    	  6519:                 move.l #$80018FF1,d0
00:00005FE0 7C02            	  6520:                 moveq  #$00000002,d6
                            	  6521: SHIFTS2_LOOP4:
00:00005FE2 EC68            	  6522:                 lsr.w d6,d0
00:00005FE4 6192            	  6523:                 bsr SHIFTS2_FLAGS
00:00005FE6 51CEFFFA        	  6524:                 dbf d6,SHIFTS2_LOOP4
00:00005FEA 0C80800111FE    	  6525:                 cmpi.l #$800111FE,d0
00:00005FF0 66FE            	  6526:                 bne.s *
00:00005FF2 4A85            	  6527:                 cmpi.l #$00000000,d5
00:00005FF4 66FE            	  6528:                 bne.s *
                            	  6529: 
                            	  6530: 
                            	  6531: *        LONG LEFT
00:00005FF6 203C80018FF1    	  6532:                 move.l #$80018FF1,d0
00:00005FFC 7C02            	  6533:                 moveq  #$00000002,d6
                            	  6534: SHIFTS2_LOOP5:
00:00005FFE EDA8            	  6535:                 lsl.l d6,d0
00:00006000 6100FF76        	  6536:                 bsr SHIFTS2_FLAGS
00:00006004 51CEFFF8        	  6537:                 dbf d6,SHIFTS2_LOOP5
00:00006008 0C80000C7F88    	  6538:                 cmpi.l #$000C7F88,d0
00:0000600E 66FE            	  6539:                 bne.s *
00:00006010 4A85            	  6540:                 cmpi.l #$00000000,d5
00:00006012 66FE            	  6541:                 bne.s *
                            	  6542: 
                            	  6543: *        LONG RIGHT
00:00006014 203C80018FF1    	  6544:                 move.l #$80018FF1,d0
00:0000601A 7C02            	  6545:                 moveq  #$00000002,d6
                            	  6546: SHIFTS2_LOOP6:
00:0000601C ECA8            	  6547:                 lsr.l d6,d0
00:0000601E 6100FF58        	  6548:                 bsr SHIFTS2_FLAGS
00:00006022 51CEFFF8        	  6549:                 dbf d6,SHIFTS2_LOOP6
00:00006026 0C80100031FE    	  6550:                 cmpi.l #$100031FE,d0
00:0000602C 66FE            	  6551:                 bne.s *
00:0000602E 4A85            	  6552:                 cmpi.l #$00000000,d5
00:00006030 66FE            	  6553:                 bne.s *
                            	  6554: 
                            	  6555: 
                            	  6556: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6557: 
00:00006032 203C80018FF1    	  6558:                 move.l #$80018FF1,d0
00:00006038 7A00            	  6559:                 moveq  #$00000000,d5
                            	  6560: 
                            	  6561: *        BYTE LEFT
00:0000603A E308            	  6562:                 lsl.b #1,d0
00:0000603C 6100FF3A        	  6563:                 bsr SHIFTS2_FLAGS
00:00006040 E508            	  6564:                 lsl.b #2,d0
00:00006042 6100FF34        	  6565:                 bsr SHIFTS2_FLAGS
00:00006046 E308            	  6566:                 lsl.b #1,d0
00:00006048 6100FF2E        	  6567:                 bsr SHIFTS2_FLAGS
00:0000604C E708            	  6568:                 lsl.b #3,d0
00:0000604E 6100FF28        	  6569:                 bsr SHIFTS2_FLAGS
00:00006052 0C8080018F80    	  6570:                 cmpi.l #$80018F80,d0
00:00006058 66FE            	  6571:                 bne.s *
00:0000605A 0C850000001B    	  6572:                 cmpi.l #$0000001B,d5
00:00006060 66FE            	  6573:                 bne.s *
                            	  6574: 
                            	  6575: *        BYTE RIGHT
00:00006062 E208            	  6576:                 lsr.b #1,d0
00:00006064 6100FF12        	  6577:                 bsr SHIFTS2_FLAGS
00:00006068 E408            	  6578:                 lsr.b #2,d0
00:0000606A 6100FF0C        	  6579:                 bsr SHIFTS2_FLAGS
00:0000606E E608            	  6580:                 lsr.b #3,d0
00:00006070 6100FF06        	  6581:                 bsr SHIFTS2_FLAGS
00:00006074 E208            	  6582:                 lsr.b #1,d0
00:00006076 6100FF00        	  6583:                 bsr SHIFTS2_FLAGS
00:0000607A 0C8080018F01    	  6584:                 cmpi.l #$80018F01,d0
00:00006080 66FE            	  6585:                 bne.s *
00:00006082 0C850000001B    	  6586:                 cmpi.l #$0000001B,d5
00:00006088 66FE            	  6587:                 bne.s *
                            	  6588: 
                            	  6589: *        WORD LEFT
00:0000608A E348            	  6590:                 lsl.w #1,d0
00:0000608C 6100FEEA        	  6591:                 bsr SHIFTS2_FLAGS
00:00006090 E548            	  6592:                 lsl.w #2,d0
00:00006092 6100FEE4        	  6593:                 bsr SHIFTS2_FLAGS
00:00006096 E748            	  6594:                 lsl.w #3,d0
00:00006098 6100FEDE        	  6595:                 bsr SHIFTS2_FLAGS
00:0000609C EB48            	  6596:                 lsl.w #5,d0
00:0000609E 6100FED8        	  6597:                 bsr SHIFTS2_FLAGS
00:000060A2 0C8080010800    	  6598:                 cmpi.l #$80010800,d0
00:000060A8 66FE            	  6599:                 bne.s *
00:000060AA 0C8500000025    	  6600:                 cmpi.l #$00000025,d5
00:000060B0 66FE            	  6601:                 bne.s *
                            	  6602: 
                            	  6603: *        WORD RIGHT
00:000060B2 EA48            	  6604:                 lsr.w #5,d0
00:000060B4 6100FEC2        	  6605:                 bsr SHIFTS2_FLAGS
00:000060B8 E248            	  6606:                 lsr.w #1,d0
00:000060BA 6100FEBC        	  6607:                 bsr SHIFTS2_FLAGS
00:000060BE E448            	  6608:                 lsr.w #2,d0
00:000060C0 6100FEB6        	  6609:                 bsr SHIFTS2_FLAGS
00:000060C4 E848            	  6610:                 lsr.w #4,d0
00:000060C6 6100FEB0        	  6611:                 bsr SHIFTS2_FLAGS
00:000060CA 0C8080010000    	  6612:                 cmpi.l #$80010000,d0
00:000060D0 66FE            	  6613:                 bne.s *
00:000060D2 0C850000002A    	  6614:                 cmpi.l #$0000002A,d5
00:000060D8 66FE            	  6615:                 bne.s *
                            	  6616: 
                            	  6617: *        LONG LEFT
00:000060DA 203C80018FF1    	  6618:                 move.l #$80018FF1,d0
00:000060E0 E388            	  6619:                 lsl.l #1,d0
00:000060E2 6100FE94        	  6620:                 bsr SHIFTS2_FLAGS
00:000060E6 E588            	  6621:                 lsl.l #2,d0
00:000060E8 6100FE8E        	  6622:                 bsr SHIFTS2_FLAGS
00:000060EC EF88            	  6623:                 lsl.l #7,d0
00:000060EE 6100FE88        	  6624:                 bsr SHIFTS2_FLAGS
00:000060F2 E988            	  6625:                 lsl.l #4,d0
00:000060F4 6100FE82        	  6626:                 bsr SHIFTS2_FLAGS
00:000060F8 0C8063FC4000    	  6627:                 cmpi.l #$63FC4000,d0
00:000060FE 66FE            	  6628:                 bne.s *
00:00006100 0C850000002B    	  6629:                 cmpi.l #$0000002B,d5
00:00006106 66FE            	  6630:                 bne.s *
                            	  6631: 
                            	  6632: *        LONG RIGHT
00:00006108 203C80018FF1    	  6633:                 move.l #$80018FF1,d0
00:0000610E E288            	  6634:                 lsr.l #1,d0
00:00006110 6100FE66        	  6635:                 bsr SHIFTS2_FLAGS
00:00006114 EA88            	  6636:                 lsr.l #5,d0
00:00006116 6100FE60        	  6637:                 bsr SHIFTS2_FLAGS
00:0000611A EE88            	  6638:                 lsr.l #7,d0
00:0000611C 6100FE5A        	  6639:                 bsr SHIFTS2_FLAGS
00:00006120 E088            	  6640:                 lsr.l #8,d0
00:00006122 6100FE54        	  6641:                 bsr SHIFTS2_FLAGS
00:00006126 0C8000000400    	  6642:                 cmpi.l #$00000400,d0
00:0000612C 66FE            	  6643:                 bne.s *
00:0000612E 0C850000002D    	  6644:                 cmpi.l #$0000002D,d5
00:00006134 66FE            	  6645:                 bne.s *
                            	  6646: 
                            	  6647: 
                            	  6648: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6649: 
00:00006136 7A00            	  6650:                 moveq  #$00000000,d5
00:00006138 307C0100        	  6651:                 move.l #$00000100,a0
00:0000613C 30BC8FF1        	  6652:                 move.w #$8FF1,(a0)
                            	  6653: 
                            	  6654: *        WORD LEFT
00:00006140 E3D0            	  6655:                 lsl  (a0)
00:00006142 6100FE34        	  6656:                 bsr SHIFTS2_FLAGS
00:00006146 E3D0            	  6657:                 lsl  (a0)
00:00006148 6100FE2E        	  6658:                 bsr SHIFTS2_FLAGS
00:0000614C E3D0            	  6659:                 lsl  (a0)
00:0000614E 6100FE28        	  6660:                 bsr SHIFTS2_FLAGS
00:00006152 E3D0            	  6661:                 lsl  (a0)
00:00006154 6100FE22        	  6662:                 bsr SHIFTS2_FLAGS
00:00006158 3010            	  6663:                 move.w (a0),d0
00:0000615A 0C800000FF10    	  6664:                 cmpi.l #$0000FF10,d0
00:00006160 66FE            	  6665:                 bne.s *
00:00006162 0C8500000009    	  6666:                 cmpi.l #$00000009,d5
00:00006168 66FE            	  6667:                 bne.s *
                            	  6668: 
                            	  6669: *        WORD RIGHT
00:0000616A E2D0            	  6670:                 lsr (a0)
00:0000616C 6100FE0A        	  6671:                 bsr SHIFTS2_FLAGS
00:00006170 E2D0            	  6672:                 lsr (a0)
00:00006172 6100FE04        	  6673:                 bsr SHIFTS2_FLAGS
00:00006176 E2D0            	  6674:                 lsr (a0)
00:00006178 6100FDFE        	  6675:                 bsr SHIFTS2_FLAGS
00:0000617C E2D0            	  6676:                 lsr (a0)
00:0000617E 6100FDF8        	  6677:                 bsr SHIFTS2_FLAGS
00:00006182 E2D0            	  6678:                 lsr (a0)
00:00006184 6100FDF2        	  6679:                 bsr SHIFTS2_FLAGS
00:00006188 E2D0            	  6680:                 lsr (a0)
00:0000618A 6100FDEC        	  6681:                 bsr SHIFTS2_FLAGS
00:0000618E 3010            	  6682:                 move.w (a0),d0
00:00006190 0C80000003FC    	  6683:                 cmpi.l #$000003FC,d0
00:00006196 66FE            	  6684:                 bne.s *
00:00006198 0C850000000A    	  6685:                 cmpi.l #$0000000A,d5
00:0000619E 66FE            	  6686:                 bne.s *
                            	  6687: 
00:000061A0 4E75            	  6688:                 rts
                            	  6689: 
                            	  6690: ;-----------------------------------------------------------
                            	  6691: ;-----------------------------------------------------------
                            	  6692: ; OPCODE : BSR / RTS
                            	  6693: ;-----------------------------------------------------------
                            	  6694: ;-----------------------------------------------------------
                            	  6695: 
                            	  6696: ;t3_bsr:
                            	  6697: ;	moveq	#3,d3
                            	  6698: ;	rts
                            	  6699: 
                            	  6700: ;t1_bsr:
                            	  6701: ;	moveq	#1,d1
                            	  6702: ;	rts
                            	  6703: 
                            	  6704: ;op_bsr:
                            	  6705: ;	bsr			t1_bsr
                            	  6706: ;	bsr			t2_bsr
                            	  6707: ;	bsr.w		t3_bsr
                            	  6708: ;	bsr.w		t4_bsr
                            	  6709: ;	cmpi.l	#1,d1
                            	  6710: ;	bne			*
                            	  6711: ;	cmpi.l	#2,d2
                            	  6712: ;	bne			*
                            	  6713: ;	cmpi.l	#3,d3
                            	  6714: ;	bne			*
                            	  6715: ;	cmpi.l	#4,d4
                            	  6716: ;	bne			*
                            	  6717: ;	rts
                            	  6718: 
                            	  6719: ;t2_bsr:
                            	  6720: ;	moveq	#2,d2
                            	  6721: ;	rts
                            	  6722: 	
                            	  6723: ;t4_bsr:
                            	  6724: ;	moveq	#4,d4
                            	  6725: ;	rts
                            	  6726: *    END
                            	  6727:     
                            	  6728: 

Source: "boot.x68"
                            	   945: 	include "TinyBasicFlt.x68"

Source: "TinyBasicFlt.x68"
                            	     1: ;*****************************************************************
                            	     2: ;								 *
                            	     3: ;		Tiny Float BASIC for the Motorola MC68000		 *
                            	     4: ;								 *
                            	     5: ; Derived from Palo Alto Tiny BASIC as published in the May 1976 *
                            	     6: ; issue of Dr. Dobb's Journal.  Adapted to the 68000 by:         *
                            	     7: ;	Gordon Brandly						 *
                            	     8: ;								 *
                            	     9: ;*****************************************************************
                            	    10: ;    Copyright (C) 1984 by Gordon Brandly. This program may be	 *
                            	    11: ;    freely distributed for personal use only. All commercial	 *
                            	    12: ;		       rights are reserved.			 *
                            	    13: ;*****************************************************************
                            	    14: ; Modified (c) 2022 for the rf68000. Robert Finch
                            	    15: ; Numerics changed to floating-point
                            	    16: ; added string handling
                            	    17: ; added graphics commands
                            	    18: ;*****************************************************************
                            	    19: 
                            	    20: ; Vers. 1.0  1984/7/17	- Original version by Gordon Brandly
                            	    21: ;	1.1  1984/12/9	- Addition of '$' print term by Marvin Lipford
                            	    22: ;	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                            	    23: ; 
                            	    24: ;	OPT	FRS,BRS 	forward ref.'s & branches default to short
                            	    25: 
                            	    26: ;CR	EQU	$0D		ASCII equates
                            	    27: ;LF	EQU	$0A
                            	    28: ;TAB	EQU	$09
                            	    29: ;CTRLC	EQU	$03
                            	    30: ;CTRLH	EQU	$08
                            	    31: ;CTRLS	EQU	$13
                            	    32: ;CTRLX	EQU	$18
                            	    33: 
                            	    34: DT_NONE equ 0
                            	    35: DT_NUMERIC equ 1
                            	    36: DT_STRING equ 2		; string descriptor
                            	    37: DT_TEXTPTR equ 3	; pointer into program text
                            	    38: 
                            	    39: BUFLEN	EQU	80		length of keyboard input buffer
                            	    40: STRAREASIZE	EQU	2048	; size of string area
                            	    41: 	CODE
                            	    42: *	ORG	$10000		first free address using Tutor
                            	    43: *
                            	    44: * Standard jump table. You can change these addresses if you are
                            	    45: * customizing this interpreter for a different environment.
                            	    46: *
00:000061A2 6020            	    47: START	BRA	CSTART		Cold Start entry point
00:000061A4 6000008A        	    48: GOWARM	BRA	WSTART		Warm Start entry point
00:000061A8 60001736        	    49: GOOUT	BRA OUTC		Jump to character-out routine
00:000061AC 60001742        	    50: GOIN	BRA INC		Jump to character-in routine
00:000061B0 6000175E        	    51: GOAUXO	BRA	AUXOUT		Jump to auxiliary-out routine
00:000061B4 6000176E        	    52: GOAUXI	BRA	AUXIN		Jump to auxiliary-in routine
00:000061B8 6000178A        	    53: GOBYE	BRA	BYEBYE		Jump to monitor, DOS, etc.
                            	    54: *
                            	    55: * Modifiable system constants:
                            	    56: *
00:000061BC 00041000        	    57: TXTBGN	DC.L	$41000		beginning of program memory
00:000061C0 00047FF0        	    58: ENDMEM	DC.L	$47FF0		end of available memory
                            	    59: *
                            	    60: * The main interpreter starts here:
                            	    61: *
                            	    62: CSTART
00:000061C4 2E7AFFFA        	    63: 	MOVE.L ENDMEM,SP	initialize stack pointer
00:000061C8 23FC000078FC0000	    64: 	move.l #INC1,INPPTR
00:000061D0 79B4
00:000061D2 13FC0001000400A4	    65: 	move.b #1,InputDevice			; keyboard
00:000061DA 13FC0002000400A8	    66: 	move.b #2,OutputDevice		; text video
00:000061E2 23FC000000010004	    67: 	move.l #1,_fpTextIncr
00:000061EA 0094
00:000061EC 4DFA1764        	    68: 	LEA	INITMSG,A6	tell who we are
00:000061F0 610016D6        	    69: 	BSR	PRMESG
00:000061F4 23FAFFC600007A04	    70: 	MOVE.L TXTBGN,TXTUNF	init. end-of-program pointer
00:000061FC 203AFFC2        	    71: 	MOVE.L ENDMEM,D0	get address of end of memory
00:00006200 23FAFFBE000079C0	    72: 	move.l ENDMEM,STKFP
00:00006208 90BC00001000    	    73: 	SUB.L	#4096,D0	reserve 4K for the stack
00:0000620E 23C0000079F4    	    74: 	MOVE.L D0,STRSTK
00:00006214 D0BC00000020    	    75: 	ADD.L #32,D0
00:0000621A 23C000007A0C    	    76: 	MOVE.L D0,STKLMT
00:00006220 90BC00000200    	    77: 	SUB.L	#512,D0 	reserve variable area (32 16 byte floats)
00:00006226 23C000007A08    	    78: 	MOVE.L D0,VARBGN
00:0000622C 610000C2        	    79: 	bsr ClearStringArea
                            	    80: WSTART
00:00006230 7000            	    81: 	CLR.L	D0		initialize internal variables
00:00006232 23FC000000010004	    82: 	move.l #1,_fpTextIncr
00:0000623A 0094
00:0000623C 42B9000079F0    	    83: 	clr.l IRQROUT
00:00006242 23C0000079CC    	    84: 	MOVE.L	D0,LOPVAR
00:00006248 23C0000079C4    	    85: 	MOVE.L	D0,STKGOS
00:0000624E 23C0000079BC    	    86: 	MOVE.L	D0,CURRNT	; current line number pointer = 0
00:00006254 2E7AFF6A        	    87: 	MOVE.L ENDMEM,SP	; init S.P. again, just in case
00:00006258 610000B6        	    88: 	bsr ClearStringStack
00:0000625C 4DFA1718        	    89: 	LEA	OKMSG,A6			; display "OK"
00:00006260 61001666        	    90: 	bsr	PRMESG
                            	    91: ST3
00:00006264 103C003E        	    92: 	MOVE.B	#'>',D0         Prompt with a '>' and
00:00006268 610013A2        	    93: 	bsr	GETLN		read a line.
00:0000626C 610015FE        	    94: 	bsr	TOUPBUF 	convert to upper case
00:00006270 2848            	    95: 	MOVE.L	A0,A4		save pointer to end of line
00:00006272 41FA17A0        	    96: 	LEA	BUFFER,A0	point to the beginning of line
00:00006276 6100159E        	    97: 	bsr	TSTNUM		is there a number there?
00:0000627A 610015E6        	    98: 	bsr	IGNBLK		skip trailing blanks
00:0000627E F2016080        	    99: 	FMOVE.L FP1,D1
00:00006282 4A82            	   100: 	TST.L D2			; does line no. exist? (or nonzero?)
00:00006284 670002A2        	   101: 	BEQ	DIRECT		; if not, it's a direct statement
00:00006288 B2BC0000FFFF    	   102: 	CMP.L	#$FFFF,D1	see if line no. is <= 16 bits
00:0000628E 6400136E        	   103: 	BCC	QHOW		if not, we've overflowed
00:00006292 1101            	   104: 	MOVE.B	D1,-(A0)	store the binary line no.
00:00006294 E059            	   105: 	ROR	#8,D1		(Kludge to store a word on a
00:00006296 1101            	   106: 	MOVE.B	D1,-(A0)	possible byte boundary)
00:00006298 E159            	   107: 	ROL	#8,D1
00:0000629A 6100140E        	   108: 	bsr	FNDLN		find this line in save area
00:0000629E 2A49            	   109: 	MOVE.L	A1,A5		save possible line pointer
00:000062A0 6614            	   110: 	BNE	ST4		if not found, insert
00:000062A2 6100142C        	   111: 	bsr	FNDNXT		find the next line (into A1)
00:000062A6 244D            	   112: 	MOVE.L	A5,A2		pointer to line to be deleted
00:000062A8 267A175A        	   113: 	MOVE.L	TXTUNF,A3	points to top of save area
00:000062AC 61001432        	   114: 	bsr	MVUP		move up to delete
00:000062B0 23CA00007A04    	   115: 	MOVE.L	A2,TXTUNF	update the end pointer
                            	   116: ST4
00:000062B6 200C            	   117: 	MOVE.L	A4,D0		calculate the length of new line
00:000062B8 9088            	   118: 	SUB.L	A0,D0
00:000062BA B0BC00000003    	   119: 	CMP.L	#3,D0		is it just a line no. & CR?
00:000062C0 6FA2            	   120: 	BLE	ST3		if so, it was just a delete
00:000062C2 267A1740        	   121: 	MOVE.L TXTUNF,A3	compute new end
00:000062C6 2C4B            	   122: 	MOVE.L A3,A6
00:000062C8 D7C0            	   123: 	ADD.L	D0,A3
00:000062CA 203A1730        	   124: 	MOVE.L StrArea,D0	see if there's enough room
00:000062CE B08B            	   125: 	CMP.L	A3,D0
00:000062D0 63001324        	   126: 	BLS	QSORRY		if not, say so
00:000062D4 23CB00007A04    	   127: 	MOVE.L	A3,TXTUNF	if so, store new end position
00:000062DA 224E            	   128: 	MOVE.L	A6,A1		points to old unfilled area
00:000062DC 244D            	   129: 	MOVE.L	A5,A2		points to beginning of move area
00:000062DE 61001414        	   130: 	bsr	MVDOWN		move things out of the way
00:000062E2 2248            	   131: 	MOVE.L	A0,A1		set up to do the insertion
00:000062E4 244D            	   132: 	MOVE.L	A5,A2
00:000062E6 264C            	   133: 	MOVE.L	A4,A3
00:000062E8 610013F6        	   134: 	bsr	MVUP		do it
00:000062EC 6000FF76        	   135: 	BRA	ST3		go back and get another line
                            	   136: 
                            	   137: ClearStringArea:
00:000062F0 203A1716        	   138: 	move.l VARBGN,d0
00:000062F4 90BC00000800    	   139: 	SUB.L #STRAREASIZE,D0
00:000062FA 23C0000079FC    	   140: 	MOVE.L D0,StrArea
00:00006300 23C000007A00    	   141: 	MOVE.L D0,LastStr
00:00006306 207A16F4        	   142: 	move.l StrArea,a0
00:0000630A 4298            	   143: 	clr.l (a0)+
00:0000630C 4298            	   144: 	clr.l (a0)+
00:0000630E 4E75            	   145: 	rts
                            	   146: 
                            	   147: ClearStringStack:
00:00006310 7007            	   148: 	moveq #7,d0
00:00006312 227A16E0        	   149: 	move.l STRSTK,a1
                            	   150: .0001
00:00006316 4299            	   151: 	clr.l (a1)+				; clear the string stack
00:00006318 51C8FFFC        	   152: 	dbra d0,.0001
00:0000631C 23C9000079F8    	   153: 	move.l a1,StrSp		; set string stack stack pointer
00:00006322 4E75            	   154: 	rts
                            	   155: 
                            	   156: 	even
                            	   157: 
                            	   158: ;******************************************************************
                            	   159: ;
                            	   160: ; *** Tables *** DIRECT *** EXEC ***
                            	   161: ;
                            	   162: ; This section of the code tests a string against a table. When
                            	   163: ; a match is found, control is transferred to the section of
                            	   164: ; code according to the table.
                            	   165: ;
                            	   166: ; At 'EXEC', A0 should point to the string, A1 should point to
                            	   167: ; the character table, and A2 should point to the execution
                            	   168: ; table. At 'DIRECT', A0 should point to the string, A1 and
                            	   169: ; A2 will be set up to point to TAB1 and TAB1_1, which are
                            	   170: ; the tables of all direct and statement commands.
                            	   171: ;
                            	   172: ; A '.' in the string will terminate the test and the partial
                            	   173: ; match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                            	   174: ; 'PRIN.', or 'PRINT' will all match 'PRINT'.
                            	   175: ;
                            	   176: ; There are two tables: the character table and the execution
                            	   177: ; table. The character table consists of any number of text items.
                            	   178: ; Each item is a string of characters with the last character's
                            	   179: ; high bit set to one. The execution table holds a 16-bit
                            	   180: ; execution addresses that correspond to each entry in the
                            	   181: ; character table.
                            	   182: ;
                            	   183: ; The end of the character table is a 0 byte which corresponds
                            	   184: ; to the default routine in the execution table, which is
                            	   185: ; executed if none of the other table items are matched.
                            	   186: ;
                            	   187: ; Character-matching tables:
                            	   188: 
                            	   189: TAB1
00:00006324 3C434F          	   190: 	DC.B	'<CO',('M'+$80)
00:00006327 CD
00:00006328 3C434F          	   191: 	DC.B	'<CO',('N'+$80)
00:0000632B CE
00:0000632C 3E434F          	   192: 	DC.B	'>CO',('M'+$80)
00:0000632F CD
00:00006330 3E434F          	   193: 	DC.B	'>CO',('N'+$80)
00:00006333 CE
00:00006334 3C3E434F        	   194: 	DC.B	'<>CO',('M'+$80)
00:00006338 CD
00:00006339 3C3E434F        	   195: 	DC.B	'<>CO',('N'+$80)
00:0000633D CE
00:0000633E 4C4953          	   196: 	DC.B	'LIS',('T'+$80)         Direct commands
00:00006341 D4
00:00006342 4C4F41          	   197: 	DC.B	'LOA',('D'+$80)
00:00006345 C4
00:00006346 4E45            	   198: 	DC.B	'NE',('W'+$80)
00:00006348 D7
00:00006349 5255            	   199: 	DC.B	'RU',('N'+$80)
00:0000634B CE
00:0000634C 534156          	   200: 	DC.B	'SAV',('E'+$80)
00:0000634F C5
00:00006350 434C            	   201: 	DC.B 	'CL',('S'+$80)
00:00006352 D3
                            	   202: TAB2
00:00006353 4E4558          	   203: 	DC.B	'NEX',('T'+$80)         Direct / statement
00:00006356 D4
00:00006357 4C45            	   204: 	DC.B	'LE',('T'+$80)
00:00006359 D4
00:0000635A 49              	   205: 	DC.B	'I',('F'+$80)
00:0000635B C6
00:0000635C 474F54          	   206: 	DC.B	'GOT',('O'+$80)
00:0000635F CF
00:00006360 474F5355        	   207: 	DC.B	'GOSU',('B'+$80)
00:00006364 C2
00:00006365 5245545552      	   208: 	DC.B	'RETUR',('N'+$80)
00:0000636A CE
00:0000636B 5245            	   209: 	DC.B	'RE',('M'+$80)
00:0000636D CD
00:0000636E 464F            	   210: 	DC.B	'FO',('R'+$80)
00:00006370 D2
00:00006371 494E5055        	   211: 	DC.B	'INPU',('T'+$80)
00:00006375 D4
00:00006376 5052494E        	   212: 	DC.B	'PRIN',('T'+$80)
00:0000637A D4
00:0000637B 504F4B          	   213: 	DC.B	'POK',('E'+$80)
00:0000637E C5
00:0000637F 53544F          	   214: 	DC.B	'STO',('P'+$80)
00:00006382 D0
00:00006383 4259            	   215: 	DC.B	'BY',('E'+$80)
00:00006385 C5
00:00006386 43414C          	   216: 	DC.B	'CAL',('L'+$80)
00:00006389 CC
00:0000638A 4F4E4952        	   217: 	DC.B	'ONIR',('Q'+$80)
00:0000638E D1
                            	   218: ; graphics commands	
00:0000638F 504F494E        	   219: 	DC.B	'POIN',('T'+$80)
00:00006393 D4
00:00006394 4C494E          	   220: 	DC.B	'LIN',('E'+$80)
00:00006397 C5
00:00006398 524543          	   221: 	DC.B	'REC',('T'+$80)
00:0000639B D4
00:0000639C 5452            	   222: 	DC.B	'TR',('I'+$80)
00:0000639E C9
00:0000639F 43555256        	   223: 	DC.B	'CURV',('E'+$80)
00:000063A3 C5
00:000063A4 434F4C4F        	   224: 	DC.B	'COLO',('R'+$80)
00:000063A8 D2
00:000063A9 445241574255    	   225: 	DC.B	'DRAWBU',('F'+$80)
00:000063AF C6
00:000063B0 444953504255    	   226: 	DC.B	'DISPBU',('F'+$80)
00:000063B6 C6
00:000063B7 544558          	   227: 	DC.B	'TEX',('T'+$80)
00:000063BA D4
00:000063BB 00              	   228: 	DC.B	0
                            	   229: TAB4
00:000063BC 504545          	   230: 	DC.B	'PEE',('K'+$80)         Functions
00:000063BF CB
00:000063C0 524E            	   231: 	DC.B	'RN',('D'+$80)
00:000063C2 C4
00:000063C3 4142            	   232: 	DC.B	'AB',('S'+$80)
00:000063C5 D3
00:000063C6 53495A          	   233: 	DC.B	'SIZ',('E'+$80)
00:000063C9 C5
00:000063CA 544943          	   234: 	DC.B	'TIC',('K'+$80)
00:000063CD CB
00:000063CE 434F52454E      	   235: 	DC.B	'COREN',('O'+$80)
00:000063D3 CF
00:000063D4 4C454654        	   236: 	DC.B	'LEFT',('$'+$80)
00:000063D8 A4
00:000063D9 5249474854      	   237: 	DC.B	'RIGHT',('$'+$80)
00:000063DE A4
00:000063DF 4D4944          	   238: 	DC.B	'MID',('$'+$80)
00:000063E2 A4
00:000063E3 4C45            	   239: 	DC.B	'LE',('N'+$80)
00:000063E5 CE
00:000063E6 494E            	   240: 	DC.B	'IN',('T'+$80)
00:000063E8 D4
00:000063E9 434852          	   241: 	DC.B	'CHR',('$'+$80)
00:000063EC A4
00:000063ED 00              	   242: 	DC.B	0
                            	   243: TAB5
00:000063EE 54              	   244: 	DC.B	'T',('O'+$80)           "TO" in "FOR"
00:000063EF CF
00:000063F0 00              	   245: 	DC.B	0
                            	   246: TAB6
00:000063F1 535445          	   247: 	DC.B	'STE',('P'+$80)         "STEP" in "FOR"
00:000063F4 D0
00:000063F5 00              	   248: 	DC.B	0
                            	   249: TAB8
00:000063F6 3E              	   250: 	DC.B	'>',('='+$80)           Relational operators
00:000063F7 BD
00:000063F8 3C              	   251: 	DC.B	'<',('>'+$80)
00:000063F9 BE
00:000063FA BE              	   252: 	DC.B	('>'+$80)
00:000063FB BD              	   253: 	DC.B	('='+$80)
00:000063FC 3C              	   254: 	DC.B	'<',('='+$80)
00:000063FD BD
00:000063FE BC              	   255: 	DC.B	('<'+$80)
00:000063FF 00              	   256: 	DC.B	0
00:00006400 00              	   257: 	DC.B	0	<- for aligning on a word boundary
                            	   258: TAB9
00:00006401 414E            	   259: 	DC.B	'AN',('D'+$80)
00:00006403 C4
00:00006404 00              	   260: 	DC.B	0
                            	   261: TAB10
00:00006405 4F              	   262: 	DC.B	'O',('R'+$80)
00:00006406 D2
00:00006407 00              	   263: 	DC.B	0
                            	   264: TAB11
00:00006408 4D4F            	   265: 	DC.B	'MO',('D'+$80)
00:0000640A C4
00:0000640B 00              	   266: 	DC.B	0
00:0000640C 00              	   267: 	DC.B	0
                            	   268: TAB12
00:0000640D 44455054        	   269: 	DC.B	'DEPT',('H'+$80)
00:00006411 C8
00:00006412 00              	   270: 	DC.B	0
00:00006413 00              	   271: 	DC.B	0
                            	   272: 
                            	   273: ; Execution address tables:
                            	   274: 	align 2
                            	   275: TAB1_1	
00:00006414 00006580        	   276: 	DC.L	INCOM
00:00006418 00006572        	   277: 	DC.L	INCON
00:0000641C 00006598        	   278: 	DC.L	OUTCOM
00:00006420 000065AE        	   279: 	DC.L	OUTCON
00:00006424 0000658E        	   280: 	DC.L	IOCOM
00:00006428 000065A4        	   281: 	DC.L	IOCON
00:0000642C 00006698        	   282: 	DC.L	LIST			Direct commands
00:00006430 00006976        	   283: 	DC.L	LOAD
00:00006434 000065BA        	   284: 	DC.L	NEW
00:00006438 000065D6        	   285: 	DC.L	RUN
00:0000643C 000069D6        	   286: 	DC.L	SAVE
00:00006440 000078D4        	   287: 	DC.L	CLS
                            	   288: TAB2_1
00:00006444 00006834        	   289: 	DC.L	NEXT			Direct / statement
00:00006448 00006966        	   290: 	DC.L	LET
00:0000644C 000068A0        	   291: 	DC.L	IF
00:00006450 00006650        	   292: 	DC.L	GOTO
00:00006454 0000674E        	   293: 	DC.L	GOSUB
00:00006458 00006788        	   294: 	DC.L	RETURN
00:0000645C 0000689E        	   295: 	DC.L	REM
00:00006460 000067B4        	   296: 	DC.L	FOR
00:00006464 000068C8        	   297: 	DC.L	INPUT
00:00006468 000066C4        	   298: 	DC.L	PRINT
00:0000646C 00006A54        	   299: 	DC.L	POKE
00:00006470 000065CE        	   300: 	DC.L	STOP
00:00006474 000061B8        	   301: 	DC.L	GOBYE
00:00006478 00006ACE        	   302: 	DC.L	CALL
00:0000647C 00006664        	   303: 	DC.L	ONIRQ
00:00006480 00006BC0        	   304: 	DC.L	POINT
00:00006484 00006BE6        	   305: 	DC.L	LINE
00:00006488 00006C38        	   306: 	DC.L	RECT
00:0000648C 00006C7E        	   307: 	DC.L	TRIANGLE
00:00006490 00006CFE        	   308: 	DC.L	CURVE
00:00006494 00006B38        	   309: 	DC.L	COLOR
00:00006498 00006B18        	   310: 	DC.L	DRAWBUF
00:0000649C 00006B28        	   311: 	DC.L	DISPBUF
00:000064A0 00006AE4        	   312: 	DC.L	TEXT
00:000064A4 0000695E        	   313: 	DC.L	DEFLT
                            	   314: TAB4_1
00:000064A8 000072F6        	   315: 	DC.L	PEEK			; Functions
00:000064AC 0000735E        	   316: 	DC.L	RND
00:000064B0 00007388        	   317: 	DC.L	ABS
00:000064B4 00007394        	   318: 	DC.L	SIZE
00:000064B8 000073A4        	   319: 	DC.L	TICK
00:000064BC 000073B0        	   320: 	DC.L	CORENO
00:000064C0 000074C2        	   321: 	DC.L	LEFT
00:000064C4 000074CE        	   322: 	DC.L	RIGHT
00:000064C8 000073F8        	   323: 	DC.L	MID
00:000064CC 000074F6        	   324: 	DC.L	LEN
00:000064D0 0000751C        	   325: 	DC.L	INT
00:000064D4 00007532        	   326: 	DC.L  CHR
00:000064D8 00007000        	   327: 	DC.L	XP40
                            	   328: TAB5_1
00:000064DC 000067CE        	   329: 	DC.L	FR1			; "TO" in "FOR"
00:000064E0 000075B6        	   330: 	DC.L	QWHAT
                            	   331: TAB6_1
00:000064E4 000067E6        	   332: 	DC.L	FR2			; "STEP" in "FOR"
00:000064E8 000067EC        	   333: 	DC.L	FR3
                            	   334: TAB8_1
00:000064EC 00006E36        	   335: 	DC.L	XP11	>=		Relational operators
00:000064F0 00006E42        	   336: 	DC.L	XP12	<>
00:000064F4 00006E4E        	   337: 	DC.L	XP13	>
00:000064F8 00006E66        	   338: 	DC.L	XP15	=
00:000064FC 00006E5A        	   339: 	DC.L	XP14	<=
00:00006500 00006E74        	   340: 	DC.L	XP16	<
00:00006504 00006E92        	   341: 	DC.L	XP17
                            	   342: TAB9_1
00:00006508 00006DF4        	   343: 	DC.L	XP_AND
00:0000650C 00006E0A        	   344: 	DC.L	XP_ANDX
                            	   345: TAB10_1
00:00006510 00006DCC        	   346: 	DC.L	XP_OR
00:00006514 00006E0A        	   347: 	DC.L	XP_ORX
                            	   348: TAB11_1
00:00006518 00006FD2        	   349: 	DC.L	XP_MOD
00:0000651C 00006F9C        	   350: 	DC.L	XP31
                            	   351: 	even
                            	   352: TAB12_1
00:00006520 00006B4C        	   353: 	DC.L	COLOR1
00:00006524 00006B44        	   354: 	DC.L	COLOR2
                            	   355: 	
                            	   356: DIRECT
00:00006528 33FC000100007A10	   357: 	move.w #1,DIRFLG
00:00006530 43FAFDF2        	   358: 	LEA	TAB1,A1
00:00006534 45FAFEDE        	   359: 	LEA	TAB1_1,A2
                            	   360: EXEC
00:00006538 61001328        	   361: 	bsr	IGNBLK				; ignore leading blanks
00:0000653C 2648            	   362: 	MOVE.L A0,A3			; save the pointer
00:0000653E 4202            	   363: 	CLR.B	D2					; clear match flag
                            	   364: EXLP
00:00006540 1018            	   365: 	MOVE.B (A0)+,D0	 	; get the program character
00:00006542 1211            	   366: 	MOVE.B (A1),D1 		; get the table character
00:00006544 6604            	   367: 	BNE	EXNGO					; If end of table,
00:00006546 204B            	   368: 	MOVE.L A3,A0			; restore the text pointer and...
00:00006548 6024            	   369: 	BRA	EXGO					; execute the default.
                            	   370: EXNGO
00:0000654A 1600            	   371: 	MOVE.B D0,D3		 	; Else check for period...
00:0000654C C602            	   372: 	AND.B	D2,D3				; and a match.
00:0000654E B63C002E        	   373: 	CMP.B	#'.',D3
00:00006552 671A            	   374: 	BEQ	EXGO					; if so, execute
00:00006554 C23C007F        	   375: 	AND.B	#$7F,D1 		; ignore the table's high bit
00:00006558 B200            	   376: 	CMP.B	D0,D1				; is there a match?
00:0000655A 670C            	   377: 	BEQ	EXMAT
00:0000655C 588A            	   378: 	ADDQ.L #4,A2			; if not, try the next entry
00:0000655E 204B            	   379: 	MOVE.L A3,A0			; reset the program pointer
00:00006560 4202            	   380: 	CLR.B	D2					; sorry, no match
                            	   381: EX1
00:00006562 4A19            	   382: 	TST.B	(A1)+				; get to the end of the entry
00:00006564 6AFC            	   383: 	BPL	EX1
00:00006566 60D8            	   384: 	BRA	EXLP					; back for more matching
                            	   385: EXMAT
00:00006568 74FF            	   386: 	MOVEQ	#-1,D2			; we've got a match so far
00:0000656A 4A19            	   387: 	TST.B	(A1)+				; end of table entry?
00:0000656C 6AD2            	   388: 	BPL	EXLP					; if not, go back for more
                            	   389: EXGO
00:0000656E 2652            	   390: 	MOVE.L (A2),A3		; execute the appropriate routine
00:00006570 4ED3            	   391: 	JMP	(A3)
                            	   392: 
                            	   393: *******************************************************************
                            	   394: * Console redirection
                            	   395: * <COM will redirect input to the COM port
                            	   396: * >COM will redirect output to the COM port
                            	   397: * <CON will redirect input to the console
                            	   398: * >CON will redirect output to the console
                            	   399: * <>COM will redirect input and output to the COM port
                            	   400: * <>CON will redirect input and output to the console
                            	   401: *******************************************************************
                            	   402: INCON
00:00006572 23FC000078FC0000	   403: 	move.l	#INC1,INPPTR
00:0000657A 79B4
00:0000657C 600001C8        	   404: 	bra			FINISH
                            	   405: INCOM
00:00006580 23FC000079240000	   406: 	move.l	#AUXIN,INPPTR
00:00006588 79B4
00:0000658A 600001BA        	   407: 	bra			FINISH
                            	   408: IOCOM
00:0000658E 23FC000079240000	   409: 	move.l	#AUXIN,INPPTR
00:00006596 79B4
                            	   410: OUTCOM
00:00006598 13FC0002000400A8	   411: 	move.b #2,OutputDevice
00:000065A0 600001A4        	   412: 	bra	FINISH
                            	   413: IOCON
00:000065A4 23FC000078FC0000	   414: 	move.l	#INC1,INPPTR
00:000065AC 79B4
                            	   415: OUTCON
00:000065AE 13FC0001000400A8	   416: 	move.b #1,OutputDevice
00:000065B6 6000018E        	   417: 	bra	FINISH
                            	   418: 
                            	   419: *******************************************************************
                            	   420: *
                            	   421: * What follows is the code to execute direct and statement
                            	   422: * commands. Control is transferred to these points via the command
                            	   423: * table lookup code of 'DIRECT' and 'EXEC' in the last section.
                            	   424: * After the command is executed, control is transferred to other
                            	   425: * sections as follows:
                            	   426: *
                            	   427: * For 'LIST', 'NEW', and 'STOP': go back to the warm start point.
                            	   428: * For 'RUN': go execute the first stored line if any; else go
                            	   429: * back to the warm start point.
                            	   430: * For 'GOTO' and 'GOSUB': go execute the target line.
                            	   431: * For 'RETURN' and 'NEXT'; go back to saved return line.
                            	   432: * For all others: if 'CURRNT' is 0, go to warm start; else go
                            	   433: * execute next command. (This is done in 'FINISH'.)
                            	   434: *
                            	   435: *******************************************************************
                            	   436: *
                            	   437: * *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                            	   438: *
                            	   439: * 'NEW<CR>' sets TXTUNF to point to TXTBGN
                            	   440: *
                            	   441: * 'STOP<CR>' goes back to WSTART
                            	   442: *
                            	   443: * 'RUN<CR>' finds the first stored line, stores its address
                            	   444: * in CURRNT, and starts executing it. Note that only those
                            	   445: * commands in TAB2 are legal for a stored program.
                            	   446: *
                            	   447: * There are 3 more entries in 'RUN':
                            	   448: * 'RUNNXL' finds next line, stores it's address and executes it.
                            	   449: * 'RUNTSL' stores the address of this line and executes it.
                            	   450: * 'RUNSML' continues the execution on same line.
                            	   451: *
                            	   452: * 'GOTO expr<CR>' evaluates the expression, finds the target
                            	   453: * line, and jumps to 'RUNTSL' to do it.
                            	   454: *
                            	   455: NEW:
00:000065BA 61000FE8        	   456: 	bsr	ENDCHK
00:000065BE 23FAFBFC00007A04	   457: 	MOVE.L TXTBGN,TXTUNF	set the end pointer
00:000065C6 6100FD28        	   458: 	bsr ClearStringArea
00:000065CA 6100FD44        	   459: 	bsr ClearStringStack
                            	   460: 
                            	   461: STOP:
00:000065CE 61000FD4        	   462: 	bsr	ENDCHK
00:000065D2 6000FC5C        	   463: 	BRA	WSTART
                            	   464: 
                            	   465: RUN:
00:000065D6 427900007A10    	   466: 	clr.w DIRFLG
00:000065DC 61000FC6        	   467: 	bsr	ENDCHK
00:000065E0 207AFBDA        	   468: 	MOVE.L	TXTBGN,A0	set pointer to beginning
00:000065E4 23C8000079BC    	   469: 	MOVE.L	A0,CURRNT
                            	   470: 
                            	   471: RUNNXL:
00:000065EA 4AB9000079BC    	   472: 	TST.L	CURRNT		; executing a program?
00:000065F0 6700FC3E        	   473: 	beq	WSTART			; if not, we've finished a direct stat.
00:000065F4 4AB9000079F0    	   474: 	tst.l	IRQROUT		; are we handling IRQ's ?
00:000065FA 672E            	   475: 	beq	RUN1
00:000065FC 4A39000400A0    	   476: 	tst.b IRQFlag		; was there an IRQ ?
00:00006602 6726            	   477: 	beq	RUN1
00:00006604 4239000400A0    	   478: 	clr.b IRQFlag
                            	   479: 
                            	   480: 	; same code as GOSUB	
                            	   481: ;	sub.l #128,sp		; allocate storage for local variables
                            	   482: ;	move.l STKFP,-(sp)
                            	   483: ;	move.l sp,STKFP
00:0000660A 6100112C        	   484: 	bsr	PUSHA				; save the current 'FOR' parameters
00:0000660E 2F08            	   485: 	MOVE.L A0,-(SP)	; save text pointer
00:00006610 2F3A13AA        	   486: 	MOVE.L CURRNT,-(SP)	found it, save old 'CURRNT'...
00:00006614 2F3A13AE        	   487: 	MOVE.L STKGOS,-(SP)	and 'STKGOS'
00:00006618 42B9000079CC    	   488: 	CLR.L	LOPVAR		; load new values
00:0000661E 23CF000079C4    	   489: 	MOVE.L SP,STKGOS
                            	   490: 
00:00006624 227A13CA        	   491: 	move.l IRQROUT,a1
00:00006628 600C            	   492: 	bra	RUNTSL
                            	   493: RUN1
00:0000662A 7200            	   494: 	CLR.L	D1			; else find the next line number
00:0000662C 2248            	   495: 	MOVE.L A0,A1
00:0000662E 61001088        	   496: 	bsr	FNDLNP
00:00006632 6500FBFC        	   497: 	BCS	WSTART		; if we've fallen off the end, stop
                            	   498: 
                            	   499: RUNTSL
00:00006636 23C9000079BC    	   500: 	MOVE.L	A1,CURRNT	set CURRNT to point to the line no.
00:0000663C 2049            	   501: 	MOVE.L	A1,A0		set the text pointer to
00:0000663E 5488            	   502: 	ADDQ.L	#2,A0		the start of the line text
                            	   503: 
                            	   504: RUNSML
00:00006640 61001274        	   505: 	bsr	CHKIO		see if a control-C was pressed
00:00006644 43FAFD0D        	   506: 	LEA	TAB2,A1 	find command in TAB2
00:00006648 45FAFDFA        	   507: 	LEA	TAB2_1,A2
00:0000664C 6000FEEA        	   508: 	BRA	EXEC		and execute it
                            	   509: 
                            	   510: GOTO:	
00:00006650 61000758        	   511: 	bsr	INT_EXPR	; evaluate the following expression
00:00006654 61000F4E        	   512: 	bsr	ENDCHK		; must find end of line
00:00006658 2200            	   513: 	move.l d0,d1
00:0000665A 6100104E        	   514: 	bsr	FNDLN			; find the target line
00:0000665E 66000F9E        	   515: 	bne	QHOW			; no such line no.
00:00006662 60D2            	   516: 	bra	RUNTSL		; go do it
                            	   517: 
                            	   518: ;******************************************************************
                            	   519: ; ONIRQ <line number>
                            	   520: ; ONIRQ sets up an interrupt handler which acts like a specialized
                            	   521: ; subroutine call. ONIRQ is coded like a GOTO that never executes.
                            	   522: ;******************************************************************
                            	   523: 
                            	   524: ONIRQ:
00:00006664 61000744        	   525: 	bsr	INT_EXPR		; evaluate the following expression
00:00006668 61000F3A        	   526: 	bsr ENDCHK			; must find end of line
00:0000666C 2200            	   527: 	move.l d0,d1
00:0000666E 6100103A        	   528: 	bsr FNDLN				; find the target line
00:00006672 660A            	   529: 	bne	ONIRQ1
00:00006674 42B9000079F0    	   530: 	clr.l IRQROUT
00:0000667A 600000CA        	   531: 	bra	FINISH
                            	   532: ONIRQ1:
00:0000667E 23C9000079F0    	   533: 	move.l a1,IRQROUT
00:00006684 600000C0        	   534: 	jmp	FINISH
                            	   535: 
                            	   536: 
                            	   537: WAITIRQ:
00:00006688 6100122C        	   538: 	jsr	CHKIO				; see if a control-C was pressed
00:0000668C 4A39000400A0    	   539: 	tst.b IRQFlag
00:00006692 67F4            	   540: 	beq	WAITIRQ
00:00006694 600000B0        	   541: 	jmp	FINISH
                            	   542: 
                            	   543: *******************************************************************
                            	   544: *
                            	   545: * *** LIST *** PRINT ***
                            	   546: *
                            	   547: * LIST has two forms:
                            	   548: * 'LIST<CR>' lists all saved lines
                            	   549: * 'LIST #<CR>' starts listing at the line #
                            	   550: * Control-S pauses the listing, control-C stops it.
                            	   551: *
                            	   552: * PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                            	   553: * where '....' is a list of expressions, formats, back-arrows,
                            	   554: * and strings.	These items a separated by commas.
                            	   555: *
                            	   556: * A format is a pound sign followed by a number.  It controls
                            	   557: * the number of spaces the value of an expression is going to
                            	   558: * be printed in.  It stays effective for the rest of the print
                            	   559: * command unless changed by another format.  If no format is
                            	   560: * specified, 11 positions will be used.
                            	   561: *
                            	   562: * A string is quoted in a pair of single- or double-quotes.
                            	   563: *
                            	   564: * An underline (back-arrow) means generate a <CR> without a <LF>
                            	   565: *
                            	   566: * A <CR LF> is generated after the entire list has been printed
                            	   567: * or if the list is empty.  If the list ends with a semicolon,
                            	   568: * however, no <CR LF> is generated.
                            	   569: *
                            	   570: 
                            	   571: LIST:	
00:00006698 6100117C        	   572: 	bsr	TSTNUM		see if there's a line no.
00:0000669C 61000F06        	   573: 	bsr	ENDCHK		if not, we get a zero
00:000066A0 61001008        	   574: 	bsr	FNDLN		find this or next line
                            	   575: LS1
00:000066A4 650000A0        	   576: 	BCS	FINISH		warm start if we passed the end
00:000066A8 61001136        	   577: 	bsr	PRTLN		print the line
00:000066AC 61001208        	   578: 	bsr	CHKIO		check for listing halt request
00:000066B0 670C            	   579: 	BEQ	LS3
00:000066B2 B03C0013        	   580: 	CMP.B	#CTRLS,D0	pause the listing?
00:000066B6 6606            	   581: 	BNE	LS3
                            	   582: LS2
00:000066B8 610011FC        	   583: 	bsr	CHKIO		if so, wait for another keypress
00:000066BC 67FA            	   584: 	BEQ	LS2
                            	   585: LS3
00:000066BE 61000FF8        	   586: 	bsr	FNDLNP		find the next line
00:000066C2 60E0            	   587: 	BRA	LS1
                            	   588: 
                            	   589: PRINT:	
00:000066C4 780B            	   590: 	MOVE.L #11,D4		D4 = number of print spaces
00:000066C6 61001136        	   591: 	bsr	TSTC		if null list and ":"
00:000066CA 3A              	   592: 	DC.B	':',PR2-*
00:000066CB 09
00:000066CC 610013FC        	   593: 	bsr	CRLF		give CR-LF and continue
00:000066D0 6000FF6E        	   594: 	BRA	RUNSML		execution on the same line
                            	   595: PR2	
00:000066D4 61001128        	   596: 	bsr	TSTC		if null list and <CR>
00:000066D8 0D              	   597: 	DC.B	CR,PR0-*
00:000066D9 09
00:000066DA 610013EE        	   598: 	bsr	CRLF		also give CR-LF and
00:000066DE 6000FF0A        	   599: 	BRA	RUNNXL		execute the next line
                            	   600: PR0
00:000066E2 6100111A        	   601: 	bsr	TSTC				; else is it a format?
00:000066E6 23              	   602: 	dc.b '#',PR1-*
00:000066E7 09
00:000066E8 610006C0        	   603: 	bsr	INT_EXPR		; yes, evaluate expression
00:000066EC 2800            	   604: 	move.l d0,d4		; and save it as print width
00:000066EE 600E            	   605: 	bra	PR3					; look for more to print
                            	   606: PR1
00:000066F0 6100110C        	   607: 	bsr	TSTC				; is character expression? (MRL)
00:000066F4 24              	   608: 	dc.b '$',PR8-*
00:000066F5 1B
00:000066F6 610006B2        	   609: 	bsr	INT_EXPR		; yep. Evaluate expression (MRL)
00:000066FA 6100FAAC        	   610: 	bsr	GOOUT				; print low byte (MRL)
                            	   611: 	bra	PR3					; look for more. (MRL)
                            	   612: PR3
00:000066FE 610010FE        	   613: 	bsr	TSTC						; if ",", go find next
00:00006702 2C              	   614: 	dc.b ',',PR6-*
00:00006703 07
00:00006704 61000E84        	   615: 	bsr	FIN							; in the list.
00:00006708 60D8            	   616: 	BRA	PR0
                            	   617: PR6
00:0000670A 610013BE        	   618: 	bsr	CRLF						; list ends here
00:0000670E 6036            	   619: 	BRA	FINISH
                            	   620: PR8
00:00006710 2F04            	   621: 	move.l d4,-(SP)			; save the width value
00:00006712 610006A8        	   622: 	bsr	EXPR						; evaluate the expression
00:00006716 281F            	   623: 	move.l (sp)+,d4			; restore the width
00:00006718 0C8000000002    	   624: 	cmpi.l #DT_STRING,d0	; is it a string?
00:0000671E 670C            	   625: 	beq PR9
00:00006720 F2000080        	   626: 	fmove fp0,fp1
00:00006724 7823            	   627: 	move.l #35,d4
00:00006726 6100106E        	   628: 	bsr	PRTNUM					; print its value
00:0000672A 60D2            	   629: 	bra	PR3							; more to print?
                            	   630: 	; Print a string
                            	   631: PR9
00:0000672C F239680000040600	   632: 	fmove.x fp0,_fpWork
00:00006734 323900040600    	   633: 	move.w _fpWork,d1
00:0000673A 227900040604    	   634: 	move.l _fpWork+4,a1
00:00006740 6100104E        	   635: 	bsr PRTSTR2
00:00006744 60B8            	   636: 	bra PR3
                            	   637: 
                            	   638: FINISH:
00:00006746 61000E42        	   639: 	bsr	FIN			; Check end of command
00:0000674A 60000E6A        	   640: 	BRA	QWHAT		; print "What?" if wrong
                            	   641: 
                            	   642: ;******************************************************************
                            	   643: ;
                            	   644: ; *** GOSUB *** & RETURN ***
                            	   645: ;
                            	   646: ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                            	   647: ; except that the current text pointer, stack pointer, etc. are
                            	   648: ; saved so that execution can be continued after the subroutine
                            	   649: ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                            	   650: ; recursive), the save area must be stacked.  The stack pointer
                            	   651: ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                            	   652: ; If we are in the main routine, 'STKGOS' is zero (this was done
                            	   653: ; in the initialization section of the interpreter), but we still
                            	   654: ; save it as a flag for no further 'RETURN's.
                            	   655: ;
                            	   656: ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                            	   657: ; returns the execution to the command after the most recent
                            	   658: ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                            	   659: ; a 'GOSUB' and is thus an error.
                            	   660: 
                            	   661: GOSUB:
00:0000674E 4FEFFF80        	   662: 	sub.l #128,sp		; allocate storage for local variables
00:00006752 2F3A126C        	   663: 	move.l STKFP,-(sp)
00:00006756 23CF000079C0    	   664: 	move.l sp,STKFP
00:0000675C 61000FDA        	   665: 	bsr	PUSHA				; save the current 'FOR' parameters
00:00006760 61000648        	   666: 	bsr	INT_EXPR		; get line number
00:00006764 2F08            	   667: 	MOVE.L	A0,-(SP)	save text pointer
00:00006766 2200            	   668: 	move.l	d0,d1
00:00006768 61000F40        	   669: 	bsr	FNDLN		find the target line
00:0000676C 66000E92        	   670: 	BNE	AHOW		if not there, say "How?"
00:00006770 2F3A124A        	   671: 	MOVE.L	CURRNT,-(SP)	found it, save old 'CURRNT'...
00:00006774 2F3A124E        	   672: 	MOVE.L	STKGOS,-(SP)	and 'STKGOS'
00:00006778 42B9000079CC    	   673: 	CLR.L	LOPVAR		load new values
00:0000677E 23CF000079C4    	   674: 	MOVE.L	SP,STKGOS
00:00006784 6000FEB0        	   675: 	BRA	RUNTSL
                            	   676: 
                            	   677: RETURN:
00:00006788 61000E1A        	   678: 	bsr	ENDCHK					; there should be just a <CR>
00:0000678C 223A1236        	   679: 	MOVE.L	STKGOS,D1		; get old stack pointer
00:00006790 67000E24        	   680: 	BEQ	QWHAT						; if zero, it doesn't exist
00:00006794 2E41            	   681: 	MOVE.L	D1,SP				; else restore it
00:00006796 23DF000079C4    	   682: 	MOVE.L	(SP)+,STKGOS	; and the old 'STKGOS'
00:0000679C 23DF000079BC    	   683: 	MOVE.L	(SP)+,CURRNT	; and the old 'CURRNT'
00:000067A2 205F            	   684: 	MOVE.L	(SP)+,A0		; and the old text pointer
00:000067A4 61000F56        	   685: 	bsr	POPA						; and the old 'FOR' parameters
                            	   686: ;	move.l STKFP,sp
00:000067A8 23DF000079C0    	   687: 	move.l (sp)+,STKFP
00:000067AE 4FEF0080        	   688: 	add.l #128,sp				; remove local variable storage
00:000067B2 6092            	   689: 	BRA	FINISH					; and we are back home
                            	   690: 
                            	   691: ;******************************************************************
                            	   692: ;
                            	   693: ; *** FOR *** & NEXT ***
                            	   694: ;
                            	   695: ; 'FOR' has two forms:
                            	   696: ; 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                            	   697: ; The second form means the same thing as the first form with a
                            	   698: ; STEP of positive 1.  The interpreter will find the variable 'var'
                            	   699: ; and set its value to the current value of 'exp1'.  It also
                            	   700: ; evaluates 'exp2' and 'exp1' and saves all these together with
                            	   701: ; the text pointer, etc. in the 'FOR' save area, which consisits of
                            	   702: ; 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                            	   703: ; already something in the save area (indicated by a non-zero
                            	   704: ; 'LOPVAR'), then the old save area is saved on the stack before
                            	   705: ; the new values are stored.  The interpreter will then dig in the
                            	   706: ; stack and find out if this same variable was used in another
                            	   707: ; currently active 'FOR' loop.  If that is the case, then the old
                            	   708: ; 'FOR' loop is deactivated. (i.e. purged from the stack)
                            	   709: ;
                            	   710: ; 'NEXT var' serves as the logical (not necessarily physical) end
                            	   711: ; of the 'FOR' loop.  The control variable 'var' is checked with
                            	   712: ; the 'LOPVAR'.  If they are not the same, the interpreter digs in
                            	   713: ; the stack to find the right one and purges all those that didn't
                            	   714: ; match.  Either way, it then adds the 'STEP' to that variable and
                            	   715: ; checks the result with against the limit value.  If it is within
                            	   716: ; the limit, control loops back to the command following the
                            	   717: ; 'FOR'.  If it's outside the limit, the save area is purged and
                            	   718: ; execution continues.
                            	   719: 
                            	   720: FOR:
00:000067B4 61000F82        	   721: 	bsr	PUSHA			; save the old 'FOR' save area
00:000067B8 61000DB0        	   722: 	bsr	SETVAL		; set the control variable
00:000067BC 23CE000079CC    	   723: 	move.l a6,LOPVAR		; save its address
00:000067C2 43FAFC2A        	   724: 	LEA	TAB5,A1 	; use 'EXEC' to test for 'TO'
00:000067C6 45FAFD14        	   725: 	LEA	TAB5_1,A2
00:000067CA 6000FD6C        	   726: 	BRA	EXEC
                            	   727: FR1	
00:000067CE 610005CC        	   728: 	bsr	NUM_EXPR		; evaluate the limit
00:000067D2 F2396800000079DC	   729: 	FMOVE.X	FP0,LOPLMT	; save that
00:000067DA 43FAFC15        	   730: 	LEA	TAB6,A1 		; use 'EXEC' to look for the
00:000067DE 45FAFD04        	   731: 	LEA	TAB6_1,A2		; word 'STEP'
00:000067E2 6000FD54        	   732: 	BRA	EXEC
                            	   733: FR2
00:000067E6 610005B4        	   734: 	bsr	NUM_EXPR		found it, get the step value
00:000067EA 6006            	   735: 	BRA	FR4
                            	   736: FR3
00:000067EC F23C58000001    	   737: 	FMOVE.B #1,FP0	; not found, step defaults to 1
                            	   738: FR4
00:000067F2 F2396800000079D0	   739: 	FMOVE.X	FP0,LOPINC	save that too
                            	   740: FR5	
00:000067FA 23FA11C0000079E8	   741: 	MOVE.L	CURRNT,LOPLN	save address of current line number
00:00006802 23C8000079EC    	   742: 	MOVE.L	A0,LOPPT	and text pointer
00:00006808 2C4F            	   743: 	MOVE.L	SP,A6		dig into the stack to find 'LOPVAR'
00:0000680A 600C            	   744: 	BRA	FR7
                            	   745: FR6
00:0000680C 4DEE0024        	   746: 	lea 36(a6),a6			; look at next stack frame
00:00006810 BDFAF9AE        	   747: 	cmp.l ENDMEM,a6		; safety check
00:00006814 64000DA0        	   748: 	bhs QWHAT
                            	   749: FR7
00:00006818 2016            	   750: 	MOVE.L	(A6),D0 	; is it zero?
00:0000681A 6714            	   751: 	BEQ	FR8						; if so, we're done
00:0000681C B0BA11AE        	   752: 	CMP.L	LOPVAR,D0		; same as current LOPVAR?
00:00006820 66EA            	   753: 	BNE	FR6						; nope, look some more
00:00006822 244F            	   754: 	MOVE.L	SP,A2			; Else remove 9 long words from...
00:00006824 224E            	   755: 	MOVE.L	A6,A1			; inside the stack.
00:00006826 47E90024        	   756: 	lea	36(a1),a3
00:0000682A 61000EC8        	   757: 	bsr	MVDOWN
00:0000682E 2E4B            	   758: 	MOVE.L	A3,SP		set the SP 9 long words up
                            	   759: FR8
00:00006830 6000FF14        	   760: 	BRA	FINISH		and continue execution
                            	   761: 
                            	   762: NEXT	
00:00006834 61000A02        	   763: 	bsr	TSTV						; get address of variable
00:00006838 65000D7C        	   764: 	bcs	QWHAT						; if no variable, say "What?"
00:0000683C 2240            	   765: 	move.l d0,a1				; save variable's address
                            	   766: NX0
00:0000683E 203A118C        	   767: 	move.l LOPVAR,D0		; If 'LOPVAR' is zero, we never...
00:00006842 67000D72        	   768: 	beq	QWHAT						; had a FOR loop, so say "What?"
00:00006846 B3C0            	   769: 	cmp.l	d0,a1					; else we check them
00:00006848 6706            	   770: 	beq	NX3							; OK, they agree
00:0000684A 61000EB0        	   771: 	bsr	POPA						; nope, let's see the next frame
00:0000684E 60EE            	   772: 	bra	NX0
                            	   773: NX3	
00:00006850 F22948000004    	   774: 	fmove.x	4(a1),fp0		; get control variable's value
00:00006856 F23A48221176    	   775: 	fadd.x LOPINC,fp0		; add in loop increment
                            	   776: ;	BVS	QHOW		say "How?" for 32-bit overflow
00:0000685C F22968000004    	   777: 	fmove.x	fp0,4(a1)		; save control variable's new value
00:00006862 F23A48801176    	   778: 	fmove.x	LOPLMT,fp1	; get loop's limit value
00:00006868 F23A503A1164    	   779: 	ftst LOPINC
00:0000686E F293000E        	   780: 	FBGE NX1				; branch if loop increment is positive
00:00006872 F2276800        	   781: 	FMOVE.X FP0,-(a7)	; exchange FP0,FP1
00:00006876 F2000400        	   782: 	FMOVE.X FP1,FP0
00:0000687A F21F4880        	   783: 	FMOVE.X (a7)+,FP1
                            	   784: NX1	
00:0000687E F20000B8        	   785: 	FCMP FP0,FP1		;	test against limit
00:00006882 F2940012        	   786: 	FBLT NX2				; branch if outside limit
00:00006886 23FA1160000079BC	   787: 	MOVE.L LOPLN,CURRNT	Within limit, go back to the...
00:0000688E 207A115C        	   788: 	MOVE.L LOPPT,A0	saved 'CURRNT' and text pointer.
00:00006892 6000FEB2        	   789: 	BRA	FINISH
                            	   790: NX2
00:00006896 61000E64        	   791: 	bsr	POPA		purge this loop
00:0000689A 6000FEAA        	   792: 	BRA	FINISH
                            	   793: 
                            	   794: *******************************************************************
                            	   795: *
                            	   796: * *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                            	   797: *
                            	   798: * 'REM' can be followed by anything and is ignored by the
                            	   799: * interpreter.
                            	   800: *
                            	   801: * 'IF' is followed by an expression, as a condition and one or
                            	   802: * more commands (including other 'IF's) separated by colons.
                            	   803: * Note that the word 'THEN' is not used.  The interpreter evaluates
                            	   804: * the expression.  If it is non-zero, execution continues.  If it
                            	   805: * is zero, the commands that follow are ignored and execution
                            	   806: * continues on the next line.
                            	   807: *
                            	   808: * 'INPUT' is like the 'PRINT' command, and is followed by a list
                            	   809: * of items.  If the item is a string in single or double quotes,
                            	   810: * or is an underline (back arrow), it has the same effect as in
                            	   811: * 'PRINT'.  If an item is a variable, this variable name is
                            	   812: * printed out followed by a colon, then the interpreter waits for
                            	   813: * an expression to be typed in.  The variable is then set to the
                            	   814: * value of this expression.  If the variable is preceeded by a
                            	   815: * string (again in single or double quotes), the string will be
                            	   816: * displayed followed by a colon.  The interpreter the waits for an
                            	   817: * expression to be entered and sets the variable equal to the
                            	   818: * expression's value.  If the input expression is invalid, the
                            	   819: * interpreter will print "What?", "How?", or "Sorry" and reprint
                            	   820: * the prompt and redo the input.  The execution will not terminate
                            	   821: * unless you press control-C.  This is handled in 'INPERR'.
                            	   822: *
                            	   823: * 'LET' is followed by a list of items separated by commas.
                            	   824: * Each item consists of a variable, an equals sign, and an
                            	   825: * expression.  The interpreter evaluates the expression and sets
                            	   826: * the variable to that value.  The interpreter will also handle
                            	   827: * 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                            	   828: 
                            	   829: REM
00:0000689E 600A            	   830: 	BRA	IF2		skip the rest of the line
                            	   831: 
                            	   832: IF
00:000068A0 61000508        	   833: 	bsr	INT_EXPR		evaluate the expression
                            	   834: IF1
00:000068A4 4A80            	   835: 	TST.L	d0		is it zero?
00:000068A6 6600FD98        	   836: 	BNE	RUNSML		if not, continue
                            	   837: IF2
00:000068AA 2248            	   838: 	MOVE.L	A0,A1
00:000068AC 7200            	   839: 	CLR.L	D1
00:000068AE 61000E22        	   840: 	bsr	FNDSKP		if so, skip the rest of the line
00:000068B2 6400FD82        	   841: 	BCC	RUNTSL		and run the next line
00:000068B6 6000F978        	   842: 	BRA	WSTART		if no next line, do a warm start
                            	   843: 
00:000068BA 2E7A110C        	   844: INPERR	MOVE.L	STKINP,SP	restore the old stack pointer
00:000068BE 23DF000079BC    	   845: 	MOVE.L	(SP)+,CURRNT	and old 'CURRNT'
00:000068C4 588F            	   846: 	ADDQ.L	#4,SP
00:000068C6 205F            	   847: 	MOVE.L	(SP)+,A0	and old text pointer
                            	   848: 
                            	   849: INPUT	
00:000068C8 2F08            	   850: 	MOVE.L	A0,-(SP)	save in case of error
00:000068CA 610004F0        	   851: 	bsr EXPR
00:000068CE 0C000002        	   852: 	cmpi.b #DT_STRING,d0
00:000068D2 6622            	   853: 	bne IP6
00:000068D4 F239680000040600	   854: 	fmove.x fp0,_fpWork
00:000068DC 323900040600    	   855: 	move.w _fpWork,d1
00:000068E2 227900040604    	   856: 	move.l _fpWork+4,a1
00:000068E8 61000EA6        	   857: 	bsr PRTSTR2
                            	   858: ;	bsr	QTSTG		is next item a string?
                            	   859: ;	BRA.S	IP2		nope
                            	   860: IP7
00:000068EC 6100094A        	   861: 	bsr	TSTV		yes, but is it followed by a variable?
00:000068F0 655C            	   862: 	BCS	IP4		if not, branch
00:000068F2 2440            	   863: 	MOVE.L	D0,A2		put away the variable's address
00:000068F4 601E            	   864: 	BRA	IP3		if so, input to variable
                            	   865: IP6
00:000068F6 2057            	   866: 	move.l (sp),a0	; restore text pointer
00:000068F8 60F2            	   867: 	bra IP7
                            	   868: IP2
00:000068FA 2F08            	   869: 	MOVE.L	A0,-(SP)	save for 'PRTSTG'
00:000068FC 6100093A        	   870: 	bsr	TSTV		must be a variable now
00:00006900 65000CB4        	   871: 	BCS	QWHAT		"What?" it isn't?
00:00006904 2440            	   872: 	MOVE.L	D0,A2		put away the variable's address
00:00006906 1410            	   873: 	MOVE.B	(A0),D2 	get ready for 'PRTSTG'
00:00006908 4200            	   874: 	CLR.B	D0
00:0000690A 1080            	   875: 	MOVE.B	D0,(A0)
00:0000690C 225F            	   876: 	MOVE.L	(SP)+,A1
00:0000690E 61000E5E        	   877: 	bsr	PRTSTG		print string as prompt
00:00006912 1082            	   878: 	MOVE.B	D2,(A0) 	restore text
                            	   879: IP3
00:00006914 2F08            	   880: 	MOVE.L	A0,-(SP)	save in case of error
00:00006916 2F3A10A4        	   881: 	MOVE.L	CURRNT,-(SP)	also save 'CURRNT'
00:0000691A 23FCFFFFFFFF0000	   882: 	MOVE.L	#-1,CURRNT	flag that we are in INPUT
00:00006922 79BC
00:00006924 23CF000079C8    	   883: 	MOVE.L	SP,STKINP	save the stack pointer too
00:0000692A 2F0A            	   884: 	MOVE.L	A2,-(SP)	save the variable address
00:0000692C 103C003A        	   885: 	MOVE.B	#':',D0         print a colon first
00:00006930 61000CDA        	   886: 	bsr	GETLN		then get an input line
00:00006934 41FA10DE        	   887: 	LEA	BUFFER,A0	point to the buffer
00:00006938 61000482        	   888: 	bsr	EXPR		evaluate the input
00:0000693C 245F            	   889: 	MOVE.L	(SP)+,A2	restore the variable address
00:0000693E 2480            	   890: 	move.l d0,(a2)			; save data type
00:00006940 F22A68000004    	   891: 	FMOVE.X	FP0,4(A2) 	; save value in variable
00:00006946 23DF000079BC    	   892: 	MOVE.L	(SP)+,CURRNT	restore old 'CURRNT'
00:0000694C 205F            	   893: 	MOVE.L	(SP)+,A0	and the old text pointer
                            	   894: IP4
00:0000694E 588F            	   895: 	ADDQ.L	#4,SP		clean up the stack
00:00006950 61000EAC        	   896: 	bsr	TSTC		is the next thing a comma?
00:00006954 2C              	   897: 	DC.B	',',IP5-*
00:00006955 05
00:00006956 6000FF70        	   898: 	BRA	INPUT		yes, more items
                            	   899: IP5
00:0000695A 6000FDEA        	   900: 	BRA	FINISH
                            	   901: 
                            	   902: DEFLT
00:0000695E 0C10000D        	   903: 	CMP.B	#CR,(A0)	; empty line is OK
00:00006962 6700FDE2        	   904: 	BEQ	FINISH			; else it is 'LET'
                            	   905: 
                            	   906: LET
00:00006966 61000C02        	   907: 	bsr	SETVAL		 	; do the assignment
00:0000696A 61000E92        	   908: 	bsr	TSTC				; check for more 'LET' items
00:0000696E 2C              	   909: 	DC.B	',',LT1-*
00:0000696F 03
00:00006970 60F4            	   910: 	BRA	LET
                            	   911: LT1
00:00006972 6000FDD2        	   912: 	BRA	FINISH			; until we are finished.
                            	   913: 
                            	   914: 
                            	   915: *******************************************************************
                            	   916: *
                            	   917: * *** LOAD *** & SAVE ***
                            	   918: *
                            	   919: * These two commands transfer a program to/from an auxiliary
                            	   920: * device such as a cassette, another computer, etc.  The program
                            	   921: * is converted to an easily-stored format: each line starts with
                            	   922: * a colon, the line no. as 4 hex digits, and the rest of the line.
                            	   923: * At the end, a line starting with an '@' sign is sent.  This
                            	   924: * format can be read back with a minimum of processing time by
                            	   925: * the 68000.
                            	   926: *
                            	   927: LOAD	
00:00006976 207AF844        	   928: 	MOVE.L TXTBGN,A0	set pointer to start of prog. area
00:0000697A 103C000D        	   929: 	MOVE.B #CR,D0		For a CP/M host, tell it we're ready...
00:0000697E 6100F830        	   930: 	BSR	GOAUXO		by sending a CR to finish PIP command.
                            	   931: LOD1	
00:00006982 6100F830        	   932: 	BSR	GOAUXI		look for start of line
00:00006986 67FA            	   933: 	BEQ	LOD1
00:00006988 B03C0040        	   934: 	CMP.B	#'@',D0         end of program?
00:0000698C 671E            	   935: 	BEQ	LODEND
00:0000698E B03C003A        	   936: 	CMP.B	#':',D0         if not, is it start of line?
00:00006992 66EE            	   937: 	BNE	LOD1		if not, wait for it
00:00006994 6120            	   938: 	BSR	GBYTE		get first byte of line no.
00:00006996 10C1            	   939: 	MOVE.B	D1,(A0)+	store it
00:00006998 611C            	   940: 	BSR	GBYTE		get 2nd bye of line no.
00:0000699A 10C1            	   941: 	MOVE.B	D1,(A0)+	store that, too
                            	   942: LOD2
00:0000699C 6100F816        	   943: 	BSR	GOAUXI		get another text char.
00:000069A0 67FA            	   944: 	BEQ	LOD2
00:000069A2 10C0            	   945: 	MOVE.B	D0,(A0)+	store it
00:000069A4 B03C000D        	   946: 	CMP.B	#CR,D0		is it the end of the line?
00:000069A8 66F2            	   947: 	BNE	LOD2		if not, go back for more
00:000069AA 60D6            	   948: 	BRA	LOD1		if so, start a new line
                            	   949: LODEND
00:000069AC 23C800007A04    	   950: 	MOVE.L	A0,TXTUNF	set end-of program pointer
00:000069B2 6000F87C        	   951: 	BRA	WSTART		back to direct mode
                            	   952: 
                            	   953: GBYTE
00:000069B6 7401            	   954: 	MOVEQ	#1,D2		get two hex characters from auxiliary
00:000069B8 7200            	   955: 	CLR.L	D1		and store them as a byte in D1
                            	   956: GBYTE1	
00:000069BA 6100F7F8        	   957: 	BSR	GOAUXI		get a char.
00:000069BE 67FA            	   958: 	BEQ	GBYTE1
00:000069C0 B03C0041        	   959: 	CMP.B	#'A',D0
00:000069C4 6502            	   960: 	BCS	GBYTE2
00:000069C6 5F00            	   961: 	SUBQ.B	#7,D0		if greater than 9, adjust
                            	   962: GBYTE2
00:000069C8 C03C000F        	   963: 	AND.B	#$F,D0		strip ASCII
00:000069CC E909            	   964: 	LSL.B	#4,D1		put nybble into the result
00:000069CE 8200            	   965: 	OR.B	D0,D1
00:000069D0 51CAFFE8        	   966: 	DBRA	D2,GBYTE1	get another char.
00:000069D4 4E75            	   967: 	RTS
                            	   968: 
                            	   969: SAVE
00:000069D6 207AF7E4        	   970: 	MOVE.L	TXTBGN,A0	set pointer to start of prog. area
00:000069DA 227A1028        	   971: 	MOVE.L	TXTUNF,A1	set pointer to end of prog. area
                            	   972: SAVE1	
00:000069DE 103C000D        	   973: 	MOVE.B	#CR,D0		send out a CR & LF (CP/M likes this)
00:000069E2 6100F7CC        	   974: 	BSR	GOAUXO
00:000069E6 103C000A        	   975: 	MOVE.B	#LF,D0
00:000069EA 6100F7C4        	   976: 	BSR	GOAUXO
00:000069EE B3C8            	   977: 	CMP.L	A0,A1		are we finished?
00:000069F0 631E            	   978: 	BLS	SAVEND
00:000069F2 103C003A        	   979: 	MOVE.B	#':',D0         if not, start a line
00:000069F6 6100F7B8        	   980: 	BSR	GOAUXO
00:000069FA 1218            	   981: 	MOVE.B	(A0)+,D1	send first half of line no.
00:000069FC 6136            	   982: 	BSR	PBYTE
00:000069FE 1218            	   983: 	MOVE.B	(A0)+,D1	and send 2nd half
00:00006A00 6132            	   984: 	BSR	PBYTE
                            	   985: SAVE2
00:00006A02 1018            	   986: 	MOVE.B	(A0)+,D0	get a text char.
00:00006A04 B03C000D        	   987: 	CMP.B	#CR,D0		is it the end of the line?
00:00006A08 67D4            	   988: 	BEQ	SAVE1		if so, send CR & LF and start new line
00:00006A0A 6100F7A4        	   989: 	BSR	GOAUXO		send it out
00:00006A0E 60F2            	   990: 	BRA	SAVE2		go back for more text
                            	   991: SAVEND
00:00006A10 103C0040        	   992: 	MOVE.B	#'@',D0         send end-of-program indicator
00:00006A14 6100F79A        	   993: 	BSR	GOAUXO
00:00006A18 103C000D        	   994: 	MOVE.B	#CR,D0		followed by a CR & LF
00:00006A1C 6100F792        	   995: 	BSR	GOAUXO
00:00006A20 103C000A        	   996: 	MOVE.B	#LF,D0
00:00006A24 6100F78A        	   997: 	BSR	GOAUXO
00:00006A28 103C001A        	   998: 	MOVE.B	#$1A,D0 	and a control-Z to end the CP/M file
00:00006A2C 6100F782        	   999: 	BSR	GOAUXO
00:00006A30 6000F7FE        	  1000: 	BRA	WSTART		then go do a warm start
                            	  1001: 
00:00006A34 7401            	  1002: PBYTE	MOVEQ	#1,D2		send two hex characters from D1's low byte
00:00006A36 E919            	  1003: PBYTE1	ROL.B	#4,D1		get the next nybble
00:00006A38 1001            	  1004: 	MOVE.B	D1,D0
00:00006A3A C03C000F        	  1005: 	AND.B	#$F,D0		strip off garbage
00:00006A3E D03C0030        	  1006: 	ADD.B	#'0',D0         make it into ASCII
00:00006A42 B03C0039        	  1007: 	CMP.B	#'9',D0
00:00006A46 6302            	  1008: 	BLS	PBYTE2
00:00006A48 5E00            	  1009: 	ADDQ.B	#7,D0		adjust if greater than 9
00:00006A4A 6100F764        	  1010: PBYTE2	BSR	GOAUXO		send it out
00:00006A4E 51CAFFE6        	  1011: 	DBRA	D2,PBYTE1	then send the next nybble
00:00006A52 4E75            	  1012: 	RTS
                            	  1013: 
                            	  1014: *******************************************************************
                            	  1015: *
                            	  1016: * *** POKE *** & CALL ***
                            	  1017: *
                            	  1018: * 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                            	  1019: * address specified by 'expr1'.
                            	  1020: *
                            	  1021: * 'CALL expr' jumps to the machine language subroutine whose
                            	  1022: * starting address is specified by 'expr'.  The subroutine can use
                            	  1023: * all registers but must leave the stack the way it found it.
                            	  1024: * The subroutine returns to the interpreter by executing an RTS.
                            	  1025: *
                            	  1026: POKE
00:00006A54 1E3C0042        	  1027: 	move.b #'B',d7
00:00006A58 1210            	  1028: 	move.b (a0),d1
00:00006A5A 0C01002E        	  1029: 	cmpi.b #'.',d1
00:00006A5E 6620            	  1030: 	bne .0001
00:00006A60 5248            	  1031: 	addq #1,a0
00:00006A62 1210            	  1032: 	move.b (a0),d1
00:00006A64 0C010042        	  1033: 	cmpi.b #'B',d1
00:00006A68 6712            	  1034: 	beq .0002
00:00006A6A 0C010057        	  1035: 	cmpi.b #'W',d1
00:00006A6E 670C            	  1036: 	beq .0002
00:00006A70 0C01004C        	  1037: 	cmpi.b #'L',d1
00:00006A74 6706            	  1038: 	beq .0002
00:00006A76 0C010046        	  1039: 	cmpi.b #'F',d1
00:00006A7A 664E            	  1040: 	bne	PKER
                            	  1041: .0002
00:00006A7C 5248            	  1042: 	addq #1,a0
00:00006A7E 1E01            	  1043: 	move.b d1,d7
                            	  1044: .0001
00:00006A80 61000328        	  1045: 	BSR	INT_EXPR		get the memory address
00:00006A84 61000D78        	  1046: 	bsr	TSTC		it must be followed by a comma
00:00006A88 2C              	  1047: 	DC.B	',',PKER-*
00:00006A89 41
00:00006A8A 2F00            	  1048: 	move.l d0,-(sp)		; save the address
00:00006A8C 6100030E        	  1049: 	BSR	NUM_EXPR			; get the value to be POKE'd
00:00006A90 225F            	  1050: 	move.l	(sp)+,a1	; get the address back
00:00006A92 0C070042        	  1051: 	CMPI.B #'B',D7
00:00006A96 6608            	  1052: 	BNE .0003
00:00006A98 F2117800        	  1053: 	FMOVE.B	FP0,(A1) 	store the byte in memory
00:00006A9C 6000FCA8        	  1054: 	BRA	FINISH
                            	  1055: .0003
00:00006AA0 0C070057        	  1056: 	CMPI.B #'W',d7
00:00006AA4 6608            	  1057: 	BNE .0004
00:00006AA6 F2117000        	  1058: 	FMOVE.W FP0,(A1)
00:00006AAA 6000FC9A        	  1059: 	BRA FINISH
                            	  1060: .0004
00:00006AAE 0C07004C        	  1061: 	CMPI.B #'L',D7
00:00006AB2 6608            	  1062: 	BNE .0005
00:00006AB4 F2116000        	  1063: 	FMOVE.L FP0,(A1)
00:00006AB8 6000FC8C        	  1064: 	BRA FINISH
                            	  1065: .0005
00:00006ABC 0C070046        	  1066: 	CMPI.B #'F',D7
00:00006AC0 6608            	  1067: 	BNE .0006
00:00006AC2 F2116800        	  1068: 	FMOVE.X FP0,(A1)
00:00006AC6 6000FC7E        	  1069: 	BRA FINISH
                            	  1070: .0006
                            	  1071: PKER
00:00006ACA 60000AEA        	  1072: 	BRA	QWHAT		if no comma, say "What?"
                            	  1073: 
                            	  1074: CALL	
00:00006ACE 610002DA        	  1075: 	BSR	INT_EXPR		; get the subroutine's address
00:00006AD2 4A80            	  1076: 	TST.l d0				; make sure we got a valid address
00:00006AD4 67000B28        	  1077: 	BEQ QHOW				; if not, say "How?"
00:00006AD8 2F08            	  1078: 	MOVE.L A0,-(SP)	; save the text pointer
00:00006ADA 2240            	  1079: 	MOVE.L D0,A1
00:00006ADC 4E91            	  1080: 	JSR	(A1)				; jump to the subroutine
00:00006ADE 205F            	  1081: 	MOVE.L (SP)+,A0	; restore the text pointer
00:00006AE0 6000FC64        	  1082: 	BRA	FINISH
                            	  1083: 
                            	  1084: ;******************************************************************
                            	  1085: ; Graphics commands:
                            	  1086: ;		DRAWBUF - which buffer to draw to (0 or 1)
                            	  1087: ;		DISPBUF - which buffer to display (0 or 1)
                            	  1088: ;		POINT - plot point
                            	  1089: ;		LINE	- draw line
                            	  1090: ;		RECT	- draw rectangle
                            	  1091: ;		TRI		- draw triangle
                            	  1092: ;		CURVE	- draw curve
                            	  1093: ;
                            	  1094: ; points are seperated with a ':' as in:
                            	  1095: ;		LINE x1,y1:x2,y2
                            	  1096: ;		TRI x1,y1:x2,y2:x3,y3
                            	  1097: ; RECT specifies a point then width and height
                            	  1098: ;		RECT x1,y1:width,height
                            	  1099: ; Color is specified with four components (padding,red,green,blue)
                            	  1100: ;		COLOR 0,255,0,0		; is the color RED
                            	  1101: ; Color depth may be specified in the same manner
                            	  1102: ;		COLOR DEPTH	0,8,8,8	; specifies 24-bits for color
                            	  1103: ;******************************************************************
                            	  1104: 
                            	  1105: TEXT:
00:00006AE4 610002C4        	  1106: 	bsr INT_EXPR
00:00006AE8 61000D14        	  1107: 	bsr	TSTC					; it must be followed by a comma
00:00006AEC 2C              	  1108: 	DC.B	',',TEXTERR-*
00:00006AED 27
00:00006AEE 2F00            	  1109: 	move.l d0,-(sp)
00:00006AF0 610002B8        	  1110: 	bsr INT_EXPR
00:00006AF4 2400            	  1111: 	move.l d0,d2
00:00006AF6 221F            	  1112: 	move.l (sp)+,d1
00:00006AF8 13C20004008C    	  1113: 	move.b d2,TextRows
00:00006AFE 13C10004008D    	  1114: 	move.b d1,TextCols
00:00006B04 13C1FD080000    	  1115: 	move.b d1,TEXTREG+0	; set columns
00:00006B0A 13C2FD080001    	  1116: 	move.b d2,TEXTREG+1	; set rows
00:00006B10 60000DC2        	  1117: 	bra CLS
                            	  1118: TEXTERR
00:00006B14 60000AA0        	  1119: 	bra QWHAT
                            	  1120: 
                            	  1121: DRAWBUF:
00:00006B18 61000290        	  1122: 	bsr INT_EXPR
00:00006B1C 7E07            	  1123: 	moveq #7,d7
00:00006B1E 7C22            	  1124: 	moveq #DEV_SET_DESTBUF,d6
00:00006B20 2200            	  1125: 	move.l d0,d1
00:00006B22 4E40            	  1126: 	trap #0
00:00006B24 6000FC20        	  1127: 	bra FINISH
                            	  1128: 	
                            	  1129: DISPBUF:
00:00006B28 61000280        	  1130: 	bsr INT_EXPR
00:00006B2C 7E07            	  1131: 	moveq #7,d7
00:00006B2E 7C23            	  1132: 	moveq #DEV_SET_DISPBUF,d6
00:00006B30 2200            	  1133: 	move.l d0,d1
00:00006B32 4E40            	  1134: 	trap #0
00:00006B34 6000FC10        	  1135: 	bra FINISH
                            	  1136: 
                            	  1137: COLOR:
00:00006B38 43FAF8D3        	  1138: 	lea	TAB12,A1 			; use 'EXEC' to look for the
00:00006B3C 45FAF9E2        	  1139: 	lea	TAB12_1,A2		; word 'DEPTH'
00:00006B40 6000F9F6        	  1140: 	bra	EXEC
                            	  1141: COLOR2
00:00006B44 2F3C00000019    	  1142: 	move.l #DEV_SET_COLOR,-(sp)
00:00006B4A 6006            	  1143: 	bra COLOR3
                            	  1144: COLOR1
00:00006B4C 2F3C00000021    	  1145: 	move.l #DEV_SET_COLOR_DEPTH,-(sp)
                            	  1146: COLOR3
00:00006B52 61000256        	  1147: 	bsr INT_EXPR
00:00006B56 61000CA6        	  1148: 	bsr	TSTC								; it must be followed by a comma
00:00006B5A 2C              	  1149: 	DC.B	',',COLORERR-*
00:00006B5B 51
00:00006B5C 2F00            	  1150: 	move.l d0,-(sp)
00:00006B5E 6100024A        	  1151: 	bsr INT_EXPR
00:00006B62 61000C9A        	  1152: 	bsr	TSTC								; it must be followed by a comma
00:00006B66 2C              	  1153: 	DC.B	',',COLORERR1-*
00:00006B67 4B
00:00006B68 2F00            	  1154: 	move.l d0,-(sp)
00:00006B6A 6100023E        	  1155: 	bsr INT_EXPR
00:00006B6E 61000C8E        	  1156: 	bsr	TSTC								; it must be followed by a comma
00:00006B72 2C              	  1157: 	DC.B	',',COLORERR2-*
00:00006B73 45
00:00006B74 2F00            	  1158: 	move.l d0,-(sp)
00:00006B76 61000232        	  1159: 	bsr INT_EXPR
00:00006B7A 4880            	  1160: 	ext.w d0
00:00006B7C 48C0            	  1161: 	ext.l d0
00:00006B7E 221F            	  1162: 	move.l (sp)+,d1
00:00006B80 4881            	  1163: 	ext.w d1
00:00006B82 48C1            	  1164: 	ext.l d1
00:00006B84 E199            	  1165: 	rol.l #8,d1
00:00006B86 8081            	  1166: 	or.l d1,d0
00:00006B88 221F            	  1167: 	move.l (sp)+,d1
00:00006B8A 4881            	  1168: 	ext.w d1
00:00006B8C 48C1            	  1169: 	ext.l d1
00:00006B8E 4841            	  1170: 	swap d1
00:00006B90 8081            	  1171: 	or.l d1,d0
00:00006B92 221F            	  1172: 	move.l (sp)+,d1
00:00006B94 4881            	  1173: 	ext.w d1
00:00006B96 48C1            	  1174: 	ext.l d1
00:00006B98 4841            	  1175: 	swap d1
00:00006B9A E199            	  1176: 	rol.l #8,d1
00:00006B9C 8280            	  1177: 	or.l d0,d1
00:00006B9E 7E07            	  1178: 	moveq #7,d7						; graphics accelerator
00:00006BA0 2C1F            	  1179: 	move.l (sp)+,d6
00:00006BA2 4E40            	  1180: 	trap #0
00:00006BA4 7E06            	  1181: 	moveq #6,d7						; frame buffer
00:00006BA6 4E40            	  1182: 	trap #0
00:00006BA8 6000FB9C        	  1183: 	bra FINISH
                            	  1184: COLORERR
00:00006BAC 588F            	  1185: 	add.l #4,sp
00:00006BAE 60000A06        	  1186: 	bra QWHAT
                            	  1187: COLORERR1
00:00006BB2 508F            	  1188: 	add.l #8,sp
00:00006BB4 60000A00        	  1189: 	bra QWHAT
                            	  1190: COLORERR2
00:00006BB8 4FEF000C        	  1191: 	add.l #12,sp
00:00006BBC 600009F8        	  1192: 	bra QWHAT
                            	  1193: 
                            	  1194: POINT:
00:00006BC0 610001E8        	  1195: 	bsr INT_EXPR
00:00006BC4 61000C38        	  1196: 	bsr	TSTC		it must be followed by a comma
00:00006BC8 2C              	  1197: 	DC.B	',',POINTERR-*
00:00006BC9 19
00:00006BCA 2F00            	  1198: 	move.l d0,-(sp)
00:00006BCC 610001DC        	  1199: 	bsr INT_EXPR
00:00006BD0 2400            	  1200: 	move.l d0,d2
00:00006BD2 221F            	  1201: 	move.l (sp)+,d1
00:00006BD4 4841            	  1202: 	swap d1
00:00006BD6 4842            	  1203: 	swap d2
00:00006BD8 7E07            	  1204: 	moveq #7,d7
00:00006BDA 7C1B            	  1205: 	moveq #DEV_PLOT_POINT,d6
00:00006BDC 4E40            	  1206: 	trap #0
00:00006BDE 6000FB66        	  1207: 	bra FINISH
                            	  1208: POINTERR
00:00006BE2 600009D2        	  1209: 	bra QWHAT
                            	  1210: 
                            	  1211: LINE:
00:00006BE6 610001C2        	  1212: 	bsr INT_EXPR
00:00006BEA 61000C12        	  1213: 	bsr	TSTC							; it must be followed by a comma
00:00006BEE 2C              	  1214: 	DC.B	',',LINEERR-*
00:00006BEF 39
00:00006BF0 2F00            	  1215: 	move.l d0,-(sp)
00:00006BF2 610001B6        	  1216: 	bsr INT_EXPR
00:00006BF6 61000C06        	  1217: 	bsr	TSTC							; it must be followed by a comma
00:00006BFA 3A              	  1218: 	DC.B	':',LINEERR1-*
00:00006BFB 31
00:00006BFC 2F00            	  1219: 	move.l d0,-(sp)	
00:00006BFE 610001AA        	  1220: 	bsr INT_EXPR
00:00006C02 61000BFA        	  1221: 	bsr	TSTC							; it must be followed by a comma
00:00006C06 2C              	  1222: 	DC.B	',',LINEERR2-*
00:00006C07 2B
00:00006C08 2F00            	  1223: 	move.l d0,-(sp)
00:00006C0A 6100019E        	  1224: 	bsr INT_EXPR
00:00006C0E 2800            	  1225: 	move.l d0,d4
00:00006C10 4844            	  1226: 	swap d4
00:00006C12 261F            	  1227: 	move.l (sp)+,d3
00:00006C14 4843            	  1228: 	swap d3
00:00006C16 241F            	  1229: 	move.l (sp)+,d2
00:00006C18 4842            	  1230: 	swap d2
00:00006C1A 221F            	  1231: 	move.l (sp)+,d1	
00:00006C1C 4841            	  1232: 	swap d1
00:00006C1E 7E07            	  1233: 	moveq #7,d7
00:00006C20 7C1C            	  1234: 	moveq #DEV_DRAW_LINE,d6
00:00006C22 4E40            	  1235: 	trap #0
00:00006C24 6000FB20        	  1236: 	bra FINISH
                            	  1237: LINEERR
00:00006C28 6000098C        	  1238: 	bra QWHAT
                            	  1239: LINEERR1
00:00006C2C 588F            	  1240: 	add.l #4,sp
00:00006C2E 60000986        	  1241: 	bra QWHAT
                            	  1242: LINEERR2
00:00006C32 508F            	  1243: 	add.l #8,sp
00:00006C34 60000980        	  1244: 	bra QWHAT
                            	  1245: 
                            	  1246: RECT:
00:00006C38 61000170        	  1247: 	bsr INT_EXPR
00:00006C3C 61000BC0        	  1248: 	bsr	TSTC							; it must be followed by a comma
00:00006C40 2C              	  1249: 	DC.B	',',LINEERR-*
00:00006C41 E7
00:00006C42 2F00            	  1250: 	move.l d0,-(sp)
00:00006C44 61000164        	  1251: 	bsr INT_EXPR
00:00006C48 61000BB4        	  1252: 	bsr	TSTC							; it must be followed by a comma
00:00006C4C 3A              	  1253: 	DC.B	':',LINEERR1-*
00:00006C4D DF
00:00006C4E 2F00            	  1254: 	move.l d0,-(sp)	
00:00006C50 61000158        	  1255: 	bsr INT_EXPR
00:00006C54 61000BA8        	  1256: 	bsr	TSTC							; it must be followed by a comma
00:00006C58 2C              	  1257: 	DC.B	',',LINEERR2-*
00:00006C59 D9
00:00006C5A 2F00            	  1258: 	move.l d0,-(sp)
00:00006C5C 6100014C        	  1259: 	bsr INT_EXPR
00:00006C60 2800            	  1260: 	move.l d0,d4
00:00006C62 261F            	  1261: 	move.l (sp)+,d3
00:00006C64 241F            	  1262: 	move.l (sp)+,d2
00:00006C66 221F            	  1263: 	move.l (sp)+,d1
00:00006C68 D681            	  1264: 	add.l d1,d3
00:00006C6A D882            	  1265: 	add.l d2,d4	
00:00006C6C 4841            	  1266: 	swap d1
00:00006C6E 4842            	  1267: 	swap d2
00:00006C70 4843            	  1268: 	swap d3
00:00006C72 4844            	  1269: 	swap d4
00:00006C74 7E07            	  1270: 	moveq #7,d7
00:00006C76 7C1E            	  1271: 	moveq #DEV_DRAW_RECTANGLE,d6
00:00006C78 4E40            	  1272: 	trap #0
00:00006C7A 6000FACA        	  1273: 	bra FINISH
                            	  1274: 
                            	  1275: TRIANGLE:
00:00006C7E 6100012A        	  1276: 	bsr INT_EXPR
00:00006C82 61000B7A        	  1277: 	bsr	TSTC							; it must be followed by a comma
00:00006C86 2C              	  1278: 	DC.B	',',TRIERR-*
00:00006C87 57
00:00006C88 2F00            	  1279: 	move.l d0,-(sp)
00:00006C8A 6100011E        	  1280: 	bsr INT_EXPR
00:00006C8E 61000B6E        	  1281: 	bsr	TSTC							; it must be followed by a comma
00:00006C92 3A              	  1282: 	DC.B	':',TRIERR1-*
00:00006C93 4F
00:00006C94 2F00            	  1283: 	move.l d0,-(sp)	
00:00006C96 61000112        	  1284: 	bsr INT_EXPR
00:00006C9A 61000B62        	  1285: 	bsr	TSTC							; it must be followed by a comma
00:00006C9E 2C              	  1286: 	DC.B	',',TRIERR2-*
00:00006C9F 49
00:00006CA0 2F00            	  1287: 	move.l d0,-(sp)
00:00006CA2 61000106        	  1288: 	bsr INT_EXPR
00:00006CA6 61000B56        	  1289: 	bsr	TSTC							; it must be followed by a comma
00:00006CAA 3A              	  1290: 	DC.B	':',TRIERR3-*
00:00006CAB 43
00:00006CAC 2F00            	  1291: 	move.l d0,-(sp)
00:00006CAE 610000FA        	  1292: 	bsr INT_EXPR
00:00006CB2 61000B4A        	  1293: 	bsr	TSTC							; it must be followed by a comma
00:00006CB6 2C              	  1294: 	DC.B	',',TRIERR4-*
00:00006CB7 3F
00:00006CB8 2F00            	  1295: 	move.l d0,-(sp)
00:00006CBA 610000EE        	  1296: 	bsr INT_EXPR
00:00006CBE 2A1F            	  1297: 	move.l (sp)+,d5
00:00006CC0 281F            	  1298: 	move.l (sp)+,d4
00:00006CC2 261F            	  1299: 	move.l (sp)+,d3
00:00006CC4 241F            	  1300: 	move.l (sp)+,d2
00:00006CC6 221F            	  1301: 	move.l (sp)+,d1
00:00006CC8 4841            	  1302: 	swap d1
00:00006CCA 4842            	  1303: 	swap d2
00:00006CCC 4843            	  1304: 	swap d3
00:00006CCE 4844            	  1305: 	swap d4
00:00006CD0 4845            	  1306: 	swap d5
00:00006CD2 4840            	  1307: 	swap d0
00:00006CD4 7E07            	  1308: 	moveq #7,d7
00:00006CD6 7C1D            	  1309: 	moveq #DEV_DRAW_TRIANGLE,d6
00:00006CD8 4E40            	  1310: 	trap #0
00:00006CDA 6000FA6A        	  1311: 	bra FINISH
                            	  1312: TRIERR
00:00006CDE 600008D6        	  1313: 	bra QWHAT
                            	  1314: TRIERR1
00:00006CE2 588F            	  1315: 	add.l #4,sp
00:00006CE4 600008D0        	  1316: 	bra QWHAT
                            	  1317: TRIERR2
00:00006CE8 508F            	  1318: 	add.l #8,sp
00:00006CEA 600008CA        	  1319: 	bra QWHAT
                            	  1320: TRIERR3
00:00006CEE 4FEF000C        	  1321: 	add.l #12,sp
00:00006CF2 600008C2        	  1322: 	bra QWHAT
                            	  1323: TRIERR4
00:00006CF6 4FEF0010        	  1324: 	add.l #16,sp
00:00006CFA 600008BA        	  1325: 	bra QWHAT
                            	  1326: 
                            	  1327: CURVE:
00:00006CFE 610000AA        	  1328: 	bsr INT_EXPR
00:00006D02 61000AFA        	  1329: 	bsr	TSTC							; it must be followed by a comma
00:00006D06 2C              	  1330: 	DC.B	',',TRIERR-*
00:00006D07 D7
00:00006D08 2F00            	  1331: 	move.l d0,-(sp)
00:00006D0A 6100009E        	  1332: 	bsr INT_EXPR
00:00006D0E 61000AEE        	  1333: 	bsr	TSTC							; it must be followed by a comma
00:00006D12 3A              	  1334: 	DC.B	':',TRIERR1-*
00:00006D13 CF
00:00006D14 2F00            	  1335: 	move.l d0,-(sp)	
00:00006D16 61000092        	  1336: 	bsr INT_EXPR
00:00006D1A 61000AE2        	  1337: 	bsr	TSTC							; it must be followed by a comma
00:00006D1E 2C              	  1338: 	DC.B	',',TRIERR2-*
00:00006D1F C9
00:00006D20 2F00            	  1339: 	move.l d0,-(sp)
00:00006D22 61000086        	  1340: 	bsr INT_EXPR
00:00006D26 61000AD6        	  1341: 	bsr	TSTC							; it must be followed by a comma
00:00006D2A 3A              	  1342: 	DC.B	':',TRIERR3-*
00:00006D2B C3
00:00006D2C 2F00            	  1343: 	move.l d0,-(sp)
00:00006D2E 617A            	  1344: 	bsr INT_EXPR
00:00006D30 61000ACC        	  1345: 	bsr	TSTC							; it must be followed by a comma
00:00006D34 2C              	  1346: 	DC.B	',',TRIERR4-*
00:00006D35 C1
00:00006D36 2F00            	  1347: 	move.l d0,-(sp)
00:00006D38 6170            	  1348: 	bsr INT_EXPR
00:00006D3A 2A1F            	  1349: 	move.l (sp)+,d5
00:00006D3C 281F            	  1350: 	move.l (sp)+,d4
00:00006D3E 261F            	  1351: 	move.l (sp)+,d3
00:00006D40 241F            	  1352: 	move.l (sp)+,d2
00:00006D42 221F            	  1353: 	move.l (sp)+,d1
00:00006D44 4841            	  1354: 	swap d1
00:00006D46 4842            	  1355: 	swap d2
00:00006D48 4843            	  1356: 	swap d3
00:00006D4A 4844            	  1357: 	swap d4
00:00006D4C 4845            	  1358: 	swap d5
00:00006D4E 4840            	  1359: 	swap d0
00:00006D50 7E07            	  1360: 	moveq #7,d7
00:00006D52 7C1F            	  1361: 	moveq #DEV_DRAW_CURVE,d6
00:00006D54 4E40            	  1362: 	trap #0
00:00006D56 6000F9EE        	  1363: 	bra FINISH
                            	  1364: 
                            	  1365: 	
                            	  1366: ;******************************************************************
                            	  1367: ;
                            	  1368: ; *** EXPR ***
                            	  1369: ;
                            	  1370: ; 'EXPR' evaluates arithmetical or logical expressions.
                            	  1371: ; <EXPR>::=<EXPR2>
                            	  1372: ;	   <EXPR2><rel.op.><EXPR2>
                            	  1373: ; where <rel.op.> is one of the operators in TAB8 and the result
                            	  1374: ; of these operations is 1 if true and 0 if false.
                            	  1375: ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                            	  1376: ; where () are optional and (... are optional repeats.
                            	  1377: ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                            	  1378: ; <EXPR4>::=<variable>
                            	  1379: ;	    <function>
                            	  1380: ;	    (<EXPR>)
                            	  1381: ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                            	  1382: ; as an index, functions can have an <EXPR> as arguments, and
                            	  1383: ; <EXPR4> can be an <EXPR> in parenthesis.
                            	  1384: 
                            	  1385: ;-------------------------------------------------------------------------------
                            	  1386: ; Push a value on the stack.
                            	  1387: ;-------------------------------------------------------------------------------
                            	  1388: 
                            	  1389: XP_PUSH:
00:00006D5A 225F            	  1390: 	move.l (sp)+,a1				; a1 = return address
00:00006D5C 2F3900040098    	  1391: 	move.l _canary,-(sp)	; push the canary
00:00006D62 4FEFFFF0        	  1392: 	sub.l #16,sp					; allocate for value
00:00006D66 2E80            	  1393: 	move.l d0,(sp)				; push data type
00:00006D68 F22F68000004    	  1394: 	fmove.x fp0,4(sp)			; and value
00:00006D6E 4ED1            	  1395: 	jmp (a1)
                            	  1396: 
                            	  1397: ;-------------------------------------------------------------------------------
                            	  1398: ; Pop value from stack into first operand.
                            	  1399: ;-------------------------------------------------------------------------------
                            	  1400: 	
                            	  1401: XP_POP:
00:00006D70 225F            	  1402: 	move.l (sp)+,a1			; get return address
00:00006D72 2017            	  1403: 	move.l (sp),d0			; pop data type
00:00006D74 F22F48000004    	  1404: 	fmove.x 4(sp),fp0		; and data element
00:00006D7A 4FEF0010        	  1405: 	add.l #16,sp
00:00006D7E A2970003        	  1406: 	cchk (sp)						; check the canary
00:00006D82 588F            	  1407: 	add.l #4,sp					; pop canary	
00:00006D84 4ED1            	  1408: 	jmp (a1)
                            	  1409: 
                            	  1410: ;-------------------------------------------------------------------------------
                            	  1411: ; Pop value from stack into second operand.
                            	  1412: ;-------------------------------------------------------------------------------
                            	  1413: 
                            	  1414: XP_POP1:
00:00006D86 225F            	  1415: 	move.l (sp)+,a1			; get return address
00:00006D88 2217            	  1416: 	move.l (sp),d1			; pop data type
00:00006D8A F22F48800004    	  1417: 	fmove.x 4(sp),fp1		; and data element
00:00006D90 4FEF0010        	  1418: 	add.l #16,sp
00:00006D94 A2970003        	  1419: 	cchk (sp)						; check the canary
00:00006D98 588F            	  1420: 	add.l #4,sp					; pop canary
00:00006D9A 4ED1            	  1421: 	jmp (a1)
                            	  1422: 
                            	  1423: ;-------------------------------------------------------------------------------
                            	  1424: ; Get and expression and make sure it is numeric.
                            	  1425: ;-------------------------------------------------------------------------------
                            	  1426: 
                            	  1427: NUM_EXPR:
00:00006D9C 611E            	  1428: 	bsr EXPR
00:00006D9E 0C8000000001    	  1429: 	cmpi.l #DT_NUMERIC,d0
00:00006DA4 66000860        	  1430: 	bne ETYPE
00:00006DA8 4E75            	  1431: 	rts
                            	  1432: 
                            	  1433: ;-------------------------------------------------------------------------------
                            	  1434: ; Get and expression and make sure it is numeric. Convert to integer.
                            	  1435: ;-------------------------------------------------------------------------------
                            	  1436: 
                            	  1437: INT_EXPR:
00:00006DAA 6110            	  1438: 	bsr EXPR
00:00006DAC 0C8000000001    	  1439: 	cmpi.l #DT_NUMERIC,d0
00:00006DB2 66000852        	  1440: 	bne ETYPE
00:00006DB6 F2006000        	  1441: 	fmove.l fp0,d0
00:00006DBA 4E75            	  1442: 	rts
                            	  1443: 
                            	  1444: ;-------------------------------------------------------------------------------
                            	  1445: ; The top level of the expression parser.
                            	  1446: ; Get an expression, string or numeric.
                            	  1447: ;
                            	  1448: ; EXEC will smash a lot of regs, so push the current expression value before
                            	  1449: ; doing EXEC
                            	  1450: ;-------------------------------------------------------------------------------
                            	  1451: 
                            	  1452: EXPR:
                            	  1453: EXPR_OR:
00:00006DBC 6124            	  1454: 	BSR EXPR_AND
00:00006DBE 619A            	  1455: 	BSR XP_PUSH
00:00006DC0 43FAF643        	  1456: 	LEA TAB10,A1
00:00006DC4 45FAF74A        	  1457: 	LEA TAB10_1,A2
00:00006DC8 6000F76E        	  1458: 	BRA EXEC
                            	  1459: 	
                            	  1460: ;-------------------------------------------------------------------------------
                            	  1461: ; Boolean 'Or' level
                            	  1462: ;-------------------------------------------------------------------------------
                            	  1463: 
                            	  1464: XP_OR:
00:00006DCC 6114            	  1465: 	BSR EXPR_AND
00:00006DCE 61B6            	  1466: 	bsr XP_POP1
00:00006DD0 613E            	  1467: 	bsr CheckNumeric
00:00006DD2 F2016080        	  1468: 	FMOVE.L FP1,D1
00:00006DD6 F2006000        	  1469: 	FMOVE.L FP0,D0
00:00006DDA 8081            	  1470: 	OR.L D1,D0
00:00006DDC F2004000        	  1471: 	FMOVE.L D0,FP0
00:00006DE0 4E75            	  1472: 	rts
                            	  1473: 	
                            	  1474: ;-------------------------------------------------------------------------------
                            	  1475: ; Boolean 'And' level
                            	  1476: ;-------------------------------------------------------------------------------
                            	  1477: 
                            	  1478: EXPR_AND:
00:00006DE2 613E            	  1479: 	bsr EXPR_REL
00:00006DE4 6100FF74        	  1480: 	bsr XP_PUSH
00:00006DE8 43FAF617        	  1481: 	LEA TAB9,A1
00:00006DEC 45FAF71A        	  1482: 	LEA TAB9_1,A2
00:00006DF0 6000F746        	  1483: 	BRA EXEC
                            	  1484: 
                            	  1485: XP_AND:
00:00006DF4 612C            	  1486: 	BSR EXPR_REL
00:00006DF6 618E            	  1487: 	bsr XP_POP1
00:00006DF8 6116            	  1488: 	bsr CheckNumeric
00:00006DFA F2016080        	  1489: 	FMOVE.L FP1,D1
00:00006DFE F2006000        	  1490: 	FMOVE.L FP0,D0
00:00006E02 C081            	  1491: 	AND.L D1,D0
00:00006E04 F2004000        	  1492: 	FMOVE.L D0,FP0
00:00006E08 4E75            	  1493: 	RTS
                            	  1494: 	
                            	  1495: XP_ANDX:
                            	  1496: XP_ORX
00:00006E0A 6100FF64        	  1497: 	bsr XP_POP
00:00006E0E 4E75            	  1498: 	rts
                            	  1499: 
                            	  1500: ;-------------------------------------------------------------------------------
                            	  1501: ; Check that two numeric values are being used.
                            	  1502: ;-------------------------------------------------------------------------------
                            	  1503: 
                            	  1504: CheckNumeric:
00:00006E10 0C010001        	  1505: 	CMPI.B #DT_NUMERIC,D1
00:00006E14 660007F0        	  1506: 	BNE ETYPE
00:00006E18 0C000001        	  1507: 	CMPI.B #DT_NUMERIC,D0
00:00006E1C 660007E8        	  1508: 	BNE ETYPE
00:00006E20 4E75            	  1509: 	RTS
                            	  1510: 
                            	  1511: ;-------------------------------------------------------------------------------
                            	  1512: ; Relational operator level, <,<=,>=,>,=,<>
                            	  1513: ;-------------------------------------------------------------------------------
                            	  1514: 
                            	  1515: EXPR_REL:
00:00006E22 61000088        	  1516: 	bsr	EXPR2
00:00006E26 6100FF32        	  1517: 	bsr XP_PUSH
00:00006E2A 43FAF5CA        	  1518: 	LEA	TAB8,A1 				; look up a relational operator
00:00006E2E 45FAF6BC        	  1519: 	LEA	TAB8_1,A2
00:00006E32 6000F704        	  1520: 	bra	EXEC		go do it
                            	  1521: 
                            	  1522: XP11:
00:00006E36 6100FF38        	  1523: 	bsr XP_POP
00:00006E3A 615C            	  1524: 	BSR	XP18		is it ">="?
00:00006E3C F2940044        	  1525: 	FBLT XPRT0		no, return D0=0
00:00006E40 6048            	  1526: 	BRA	XPRT1		else return D0=1
                            	  1527: 
                            	  1528: XP12:
00:00006E42 6100FF2C        	  1529: 	bsr XP_POP
00:00006E46 6150            	  1530: 	BSR	XP18		is it "<>"?
00:00006E48 F2810038        	  1531: 	FBEQ XPRT0		no, return D0=0
00:00006E4C 603C            	  1532: 	BRA	XPRT1		else return D0=1
                            	  1533: 
                            	  1534: XP13:
00:00006E4E 6100FF20        	  1535: 	bsr XP_POP
00:00006E52 6144            	  1536: 	BSR	XP18		is it ">"?
00:00006E54 F295002C        	  1537: 	FBLE XPRT0		no, return D0=0
00:00006E58 6030            	  1538: 	BRA	XPRT1		else return D0=1
                            	  1539: 
                            	  1540: XP14:
00:00006E5A 6100FF14        	  1541: 	bsr XP_POP
00:00006E5E 6138            	  1542: 	BSR	XP18		;is it "<="?
00:00006E60 F2920020        	  1543: 	FBGT XPRT0	;	no, return D0=0
00:00006E64 6024            	  1544: 	BRA	XPRT1		;else return D0=1
                            	  1545: 
                            	  1546: XP15:
00:00006E66 6100FF08        	  1547: 	bsr XP_POP
00:00006E6A 612C            	  1548: 	BSR	XP18		; is it "="?
00:00006E6C F28E0014        	  1549: 	FBNE XPRT0	;	if not, return D0=0
00:00006E70 6018            	  1550: 	BRA	XPRT1		;else return D0=1
                            	  1551: XP15RT
00:00006E72 4E75            	  1552: 	RTS
                            	  1553: 
                            	  1554: XP16:
00:00006E74 6100FEFA        	  1555: 	bsr XP_POP
00:00006E78 611E            	  1556: 	BSR	XP18		; is it "<"?
00:00006E7A F2930006        	  1557: 	FBGE XPRT0	;	if not, return D0=0
00:00006E7E 600A            	  1558: 	BRA	XPRT1		; else return D0=1
00:00006E80 4E75            	  1559: 	RTS
                            	  1560: 
                            	  1561: XPRT0:
00:00006E82 F23C58000000    	  1562: 	FMOVE.B #0,FP0	; return fp0 = 0 (false)
00:00006E88 4E75            	  1563: 	RTS
                            	  1564: 
                            	  1565: XPRT1:
00:00006E8A F23C58000001    	  1566: 	FMOVE.B #1,FP0	; return fp0 = 1 (true)
00:00006E90 4E75            	  1567: 	RTS
                            	  1568: 
                            	  1569: XP17:								; it's not a rel. operator
00:00006E92 6100FEDC        	  1570: 	bsr XP_POP				;	return FP0=<EXPR2>
00:00006E96 4E75            	  1571: 	rts
                            	  1572: 
                            	  1573: XP18:
00:00006E98 6100FEC0        	  1574: 	bsr XP_PUSH
00:00006E9C 610E            	  1575: 	bsr	EXPR2					; do second <EXPR2>
00:00006E9E 6100FEE6        	  1576: 	bsr XP_POP1
00:00006EA2 6100FF6C        	  1577: 	bsr CheckNumeric
00:00006EA6 F20000B8        	  1578: 	fcmp fp0,fp1			; compare with the first result
00:00006EAA 4E75            	  1579: 	rts								; return the result
                            	  1580: 
                            	  1581: ;-------------------------------------------------------------------------------
                            	  1582: ; Add/Subtract operator level, +,-
                            	  1583: ;-------------------------------------------------------------------------------
                            	  1584: 
                            	  1585: EXPR2
00:00006EAC 61000950        	  1586: 	bsr	TSTC		; negative sign?
00:00006EB0 2D              	  1587: 	DC.B	'-',XP21-*
00:00006EB1 09
00:00006EB2 F23C58000000    	  1588: 	FMOVE.B #0,FP0
00:00006EB8 604C            	  1589: 	BRA	XP26
                            	  1590: XP21	
00:00006EBA 61000942        	  1591: 	bsr	TSTC		; positive sign? ignore it
00:00006EBE 2B              	  1592: 	DC.B	'+',XP22-*
00:00006EBF 01
                            	  1593: XP22
00:00006EC0 610000C8        	  1594: 	BSR	EXPR3		; first <EXPR3>
                            	  1595: XP23
00:00006EC4 61000938        	  1596: 	bsr	TSTC		; add?
00:00006EC8 2B              	  1597: 	DC.B	'+',XP25-*
00:00006EC9 37
00:00006ECA 6100FE8E        	  1598: 	bsr XP_PUSH
00:00006ECE 610000BA        	  1599: 	BSR	EXPR3					; get the second <EXPR3>
                            	  1600: XP24
00:00006ED2 6100FEB2        	  1601: 	bsr XP_POP1
00:00006ED6 B03C0001        	  1602: 	CMP.B #DT_NUMERIC,d0
00:00006EDA 660C            	  1603: 	BNE .notNum
00:00006EDC B23C0001        	  1604: 	CMP.B #DT_NUMERIC,d1
00:00006EE0 6606            	  1605: 	BNE .notNum
00:00006EE2 F2000422        	  1606: 	FADD FP1,FP0			; add it to the first <EXPR3>
                            	  1607: ;	FBVS	QHOW		branch if there's an overflow
00:00006EE6 60DC            	  1608: 	BRA	XP23		else go back for more operations
                            	  1609: .notNum
00:00006EE8 B0BC00000002    	  1610: 	cmp.l #DT_STRING,d0
00:00006EEE 66000716        	  1611: 	bne ETYPE
00:00006EF2 B2BC00000002    	  1612: 	cmp.l #DT_STRING,d1
00:00006EF8 6600070C        	  1613: 	bne ETYPE
00:00006EFC 611E            	  1614: 	bsr ConcatString
00:00006EFE 4E75            	  1615: 	rts
                            	  1616: 
                            	  1617: XP25
00:00006F00 610008FC        	  1618: 	bsr	TSTC							; subtract?
00:00006F04 2D              	  1619: 	dc.b	'-',XP27-*
00:00006F05 15
                            	  1620: XP26
00:00006F06 6100FE52        	  1621: 	bsr XP_PUSH
00:00006F0A 617E            	  1622: 	BSR	EXPR3					; get second <EXPR3>
00:00006F0C 0C000001        	  1623: 	cmpi.b #DT_NUMERIC,d0
00:00006F10 660006F4        	  1624: 	bne ETYPE
00:00006F14 F200001A        	  1625: 	FNEG FP0					; change its sign
00:00006F18 60B8            	  1626: 	JMP	XP24					; and do an addition
                            	  1627: 
                            	  1628: XP27
00:00006F1A 4E75            	  1629: 	rts
                            	  1630: 
                            	  1631: ;-------------------------------------------------------------------------------
                            	  1632: ; Concatonate strings, for the '+' operator.
                            	  1633: ;
                            	  1634: ; Parameters:
                            	  1635: ;		fp0 = holds string descriptor for second string
                            	  1636: ;		fp1 = holds string descriptor for first string
                            	  1637: ;	Returns:
                            	  1638: ;		fp0 = string descriptor for combined strings
                            	  1639: ;-------------------------------------------------------------------------------
                            	  1640: 
                            	  1641: ConcatString:
00:00006F1C F239688000040600	  1642: 	fmove.x fp1,_fpWork		; save first string descriptor to memory
00:00006F24 F239680000040610	  1643: 	fmove.x fp0,_fpWork+16; save second string descriptor to memory
00:00006F2C 343900040600    	  1644: 	move.w _fpWork,d2			; d2 = length of first string
00:00006F32 D47900040610    	  1645: 	add.w	_fpWork+16,d2		; add length of second string
00:00006F38 48C2            	  1646: 	ext.l d2							; make d2 a long word
00:00006F3A 61000164        	  1647: 	bsr AllocateString		; allocate
00:00006F3E 2849            	  1648: 	move.l a1,a4					; a4 = allocated string, saved for later
00:00006F40 2449            	  1649: 	move.l a1,a2					; a2 = allocated string
00:00006F42 3542FFFE        	  1650: 	move.w d2,-2(a2)			; save length of new string (a2)
00:00006F46 227900040604    	  1651: 	move.l _fpWork+4,a1		; a1 = pointer to string text of first string
00:00006F4C 2649            	  1652: 	move.l a1,a3					; compute pointer to end of first string
00:00006F4E 363900040600    	  1653: 	move.w _fpWork,d3			; d3 = length of first string
00:00006F54 48C3            	  1654: 	ext.l d3
00:00006F56 D7C3            	  1655: 	add.l d3,a3						; add length of first string
00:00006F58 61000786        	  1656: 	bsr MVUP							; move from A1 to A2 until A1=A3
00:00006F5C 227900040614    	  1657: 	move.l _fpWork+20,a1	; a1 = pointer to second string text
00:00006F62 2649            	  1658: 	move.l a1,a3
00:00006F64 363900040610    	  1659: 	move.w _fpWork+16,d3	; d3 = length of second string
00:00006F6A 48C3            	  1660: 	ext.l d3
00:00006F6C D7C3            	  1661: 	add.l d3,a3						; a3 points to end of second string
00:00006F6E 61000770        	  1662: 	bsr MVUP							; concatonate on second string
00:00006F72 33C200040600    	  1663: 	move.w d2,_fpWork			; save total string length in fp work
00:00006F78 23CC00040604    	  1664: 	move.l a4,_fpWork+4		; save pointer in fp work area
00:00006F7E 7002            	  1665: 	moveq #DT_STRING,d0		; set return data type = string
00:00006F80 F239480000040600	  1666: 	fmove.x _fpWork,fp0		; fp0 = string descriptor
00:00006F88 4E75            	  1667: 	rts
                            	  1668: 
                            	  1669: ;-------------------------------------------------------------------------------
                            	  1670: ; Multiply / Divide operator level, *,/,mod
                            	  1671: ;-------------------------------------------------------------------------------
                            	  1672: 
                            	  1673: EXPR3
00:00006F8A 6168            	  1674: 	bsr	EXPR4					; get first <EXPR4>
                            	  1675: XP36
00:00006F8C 6100FDCC        	  1676: 	bsr XP_PUSH
                            	  1677: XP30
00:00006F90 43FAF476        	  1678: 	lea TAB11,a1
00:00006F94 45FAF582        	  1679: 	lea TAB11_1,a2
00:00006F98 6000F59E        	  1680: 	bra EXEC
                            	  1681: XP31
00:00006F9C 61000860        	  1682: 	bsr	TSTC					; multiply?
00:00006FA0 2A              	  1683: 	dc.b	'*',XP34-*
00:00006FA1 11
00:00006FA2 6150            	  1684: 	bsr	EXPR4					; get second <EXPR4>
00:00006FA4 6100FDE0        	  1685: 	bsr XP_POP1
00:00006FA8 6100FE66        	  1686: 	bsr CheckNumeric
00:00006FAC F2000423        	  1687: 	fmul fp1,fp0			; multiply the two
00:00006FB0 60DA            	  1688: 	bra	XP36					; then look for more terms
                            	  1689: XP34
00:00006FB2 6100084A        	  1690: 	bsr	TSTC					; divide?
00:00006FB6 2F              	  1691: 	dc.b	'/',XP35-*
00:00006FB7 15
00:00006FB8 613A            	  1692: 	bsr	EXPR4					; get second <EXPR4>
00:00006FBA 6100FDCA        	  1693: 	bsr XP_POP1
00:00006FBE 6100FE50        	  1694: 	bsr CheckNumeric
00:00006FC2 F20000A0        	  1695: 	fdiv fp0,fp1			; do the division
00:00006FC6 F2000400        	  1696: 	fmove fp1,fp0
00:00006FCA 60C0            	  1697: 	bra	XP36					; go back for any more terms
                            	  1698: XP35
00:00006FCC 6100FDA2        	  1699: 	bsr XP_POP
00:00006FD0 4E75            	  1700: 	rts
                            	  1701: XP_MOD:
00:00006FD2 6120            	  1702: 	bsr EXPR4
00:00006FD4 6100FDB0        	  1703: 	bsr XP_POP1
00:00006FD8 F20000A0        	  1704: 	fdiv fp0,fp1			; divide
00:00006FDC F2006080        	  1705: 	fmove.l fp1,d0		; convert to integer
00:00006FE0 F2004180        	  1706: 	fmove.l d0,fp3		; convert back to float
00:00006FE4 F20001A3        	  1707: 	fmul fp0,fp3			; multiply quotient times divisor
00:00006FE8 F2000CA8        	  1708: 	fsub fp3,fp1			; subtract from original number
00:00006FEC F2000400        	  1709: 	fmove.x fp1,fp0		; return difference in fp0
00:00006FF0 7001            	  1710: 	moveq #DT_NUMERIC,d0
00:00006FF2 6098            	  1711: 	bra XP36					; go back and check for more multiply ops
                            	  1712: 	
                            	  1713: ;-------------------------------------------------------------------------------
                            	  1714: ; Lowest Level of expression evaluation.
                            	  1715: ;	Check for
                            	  1716: ;		a function or
                            	  1717: ;		a variable or
                            	  1718: ;		a number or
                            	  1719: ;		a string or
                            	  1720: ;		( expr )
                            	  1721: ;-------------------------------------------------------------------------------
                            	  1722: 
                            	  1723: EXPR4
00:00006FF4 43FAF3C6        	  1724: 	LEA	TAB4,A1 			; find possible function
00:00006FF8 45FAF4AE        	  1725: 	LEA	TAB4_1,A2
00:00006FFC 6000F53A        	  1726: 	BRA	EXEC
                            	  1727: XP40
00:00007000 61000236        	  1728: 	bsr	TSTV					; nope, not a function
00:00007004 650C            	  1729: 	bcs	XP41					; nor a variable
00:00007006 2240            	  1730: 	move.l d0,a1			; a1 = variable address
00:00007008 2011            	  1731: 	move.l (a1),d0		; return type in d0
00:0000700A F22948000004    	  1732: 	fmove.x 4(a1),fp0	; if a variable, return its value in fp0
                            	  1733: EXP4RT
00:00007010 4E75            	  1734: 	rts
                            	  1735: XP41
00:00007012 61000802        	  1736: 	bsr	TSTNUM				; or is it a number?
00:00007016 F2000400        	  1737: 	fmove fp1,fp0
00:0000701A 0C8000000001    	  1738: 	cmpi.l #DT_NUMERIC,d0
00:00007020 67EE            	  1739: 	beq	EXP4RT				; if so, return it in FP0
                            	  1740: XPSTNG
00:00007022 610007DA        	  1741: 	bsr TSTC					; is it a string constant?
00:00007026 22              	  1742: 	dc.b '"',XP44-*
00:00007027 57
00:00007028 163C0022        	  1743: 	move.b #'"',d3
                            	  1744: XP45
00:0000702C 2248            	  1745: 	move.l a0,a1			; record start of string in a1
00:0000702E 243C000001FF    	  1746: 	move.l #511,d2		; max 512 characters
                            	  1747: .0003	
00:00007034 1018            	  1748: 	move.b (a0)+,d0		; get a character
00:00007036 670E            	  1749: 	beq .0001					; should not be a NULL
00:00007038 0C00000D        	  1750: 	cmpi.b #CR,d0			; CR means the end of line was hit without a close quote
00:0000703C 6708            	  1751: 	beq .0001
00:0000703E B003            	  1752: 	cmp.b d3,d0				; close quote?
00:00007040 6708            	  1753: 	beq .0002
00:00007042 51CAFFF0        	  1754: 	dbra d2,.0003			; no close quote, go back for next char
                            	  1755: .0001
00:00007046 600005B6        	  1756: 	bra QHOW
                            	  1757: .0002
00:0000704A 2008            	  1758: 	move.l a0,d0				; d0 = end of string pointer
00:0000704C 9089            	  1759: 	sub.l a1,d0					; compute string length + 1
00:0000704E 5340            	  1760: 	subq #1,d0					; subtract out closing quote
00:00007050 2400            	  1761: 	move.l d0,d2				; d2 = string length
00:00007052 2649            	  1762: 	move.l a1,a3				; a3 = pointer to string text
00:00007054 614A            	  1763: 	bsr AllocateString
00:00007056 2449            	  1764: 	move.l a1,a2				; a2 points to new text area
00:00007058 2849            	  1765: 	move.l a1,a4				; save a1 for later
00:0000705A 224B            	  1766: 	move.l a3,a1				; a1 = pointer to string in program
00:0000705C 3542FFFE        	  1767: 	move.w d2,-2(a2)		; copy length into place
00:00007060 D7C2            	  1768: 	add.l d2,a3					; a3 points to end of string
00:00007062 6100067C        	  1769: 	bsr MVUP						; move from A1 to A2 until A1=A3
00:00007066 33C200040600    	  1770: 	move.w d2,_fpWork		; copy length into place
00:0000706C 23CC00040604    	  1771: 	move.l a4,_fpWork+4	; copy pointer to text into place
00:00007072 F239480000040600	  1772: 	fmove.x _fpWork,fp0	; put string descriptor into fp0
00:0000707A 7002            	  1773: 	moveq #DT_STRING,d0	; return string data type
00:0000707C 4E75            	  1774: 	rts
                            	  1775: XP44
00:0000707E 6100077E        	  1776: 	bsr TSTC					; alternate string constant?
00:00007082 27              	  1777: 	dc.b '''',PARN-*
00:00007083 07
00:00007084 163C0027        	  1778: 	move.b #'''',d3
00:00007088 60A2            	  1779: 	bra XP45
                            	  1780: PARN
00:0000708A 61000772        	  1781: 	bsr	TSTC					; else look for ( EXPR )
00:0000708E 28              	  1782: 	dc.b '(',XP43-*
00:0000708F 0D
00:00007090 6100FD2A        	  1783: 	bsr	EXPR
00:00007094 61000768        	  1784: 	bsr	TSTC
00:00007098 29              	  1785: 	dc.b ')',XP43-*
00:00007099 03
                            	  1786: XP42	
00:0000709A 4E75            	  1787: 	rts
                            	  1788: XP43
00:0000709C 60000518        	  1789: 	bra	QWHAT					; else say "What?"
                            	  1790: 
                            	  1791: ;-------------------------------------------------------------------------------	
                            	  1792: ; Allocate storage for a string variable.
                            	  1793: ;
                            	  1794: ; Parameters:
                            	  1795: ;		d2 = number of bytes needed
                            	  1796: ; Returns:
                            	  1797: ;		a1 = pointer to string text area
                            	  1798: ;-------------------------------------------------------------------------------	
                            	  1799: 
                            	  1800: AllocateString:
00:000070A0 48E7383C        	  1801: 	movem.l d2-d4/a2-a5,-(sp)
00:000070A4 283A0962        	  1802: 	move.l VARBGN,d4
00:000070A8 227A0956        	  1803: 	move.l LastStr,a1			; a1 = last string
00:000070AC 3611            	  1804: 	move.w (a1),d3				; d3 = length of last string (0)
00:000070AE 48C3            	  1805: 	ext.l d3
00:000070B0 9883            	  1806: 	sub.l d3,d4						; subtract off length
00:000070B2 5784            	  1807: 	subq.l #3,d4					; size of length field+1 for rounding
00:000070B4 9889            	  1808: 	sub.l a1,d4						; and start position
00:000070B6 B484            	  1809: 	cmp.l d4,d2						; is there enough room?
00:000070B8 6224            	  1810: 	bhi .needMoreRoom
                            	  1811: .0001
00:000070BA 227A0944        	  1812: 	move.l LastStr,a1
00:000070BE 2649            	  1813: 	move.l a1,a3
00:000070C0 5489            	  1814: 	addq.l #2,a1					; point a1 to text part of string
00:000070C2 3682            	  1815: 	move.w d2,(a3)				; save the length
00:000070C4 D7C2            	  1816: 	add.l d2,a3
00:000070C6 568B            	  1817: 	addq.l #3,a3					; 2 for length field, 1 for rounding
00:000070C8 260B            	  1818: 	move.l a3,d3
00:000070CA 0283FFFFFFFE    	  1819: 	andi.l #$FFFFFFFE,d3	; make pointer even wyde
00:000070D0 23CB00007A00    	  1820: 	move.l a3,LastStr			; set new last str position
00:000070D6 4253            	  1821: 	clr.w (a3)						; set zero length
00:000070D8 4CDF3C1C        	  1822: 	movem.l (sp)+,d2-d4/a2-a5
00:000070DC 4E75            	  1823: 	rts
                            	  1824: .needMoreRoom
00:000070DE 611E            	  1825: 	bsr GarbageCollectStrings
00:000070E0 283A0926        	  1826: 	move.l VARBGN,d4			; d4 = start of variables
00:000070E4 227A091A        	  1827: 	move.l LastStr,a1			; a1 = pointer to last string
00:000070E8 3611            	  1828: 	move.w (a1),d3				; d3 = length of last string (likely 0)
00:000070EA 48C3            	  1829: 	ext.l d3
00:000070EC D689            	  1830: 	add.l a1,d3						; d3 = pointer past end of last string
00:000070EE 5683            	  1831: 	addq.l #3,d3					; 2 for length, 1 for rounding
00:000070F0 9883            	  1832: 	sub.l d3,d4						; free = VARBGN - LastStr+length of (LastStr)
00:000070F2 B484            	  1833: 	cmp.l d4,d2						; request < free?
00:000070F4 65C4            	  1834: 	blo .0001
00:000070F6 4DFA089C        	  1835: 	lea NOSTRING,a6
00:000070FA 600004C0        	  1836: 	bra ERROR
                            	  1837: 		
                            	  1838: ;-------------------------------------------------------------------------------	
                            	  1839: ; Garbage collect strings. This copies all strings in use to the lower end of
                            	  1840: ; the string area and adjusts the string pointers in variables and on the
                            	  1841: ; stack to point to the new location.
                            	  1842: ;
                            	  1843: ; Modifies:
                            	  1844: ;		none
                            	  1845: ;-------------------------------------------------------------------------------	
                            	  1846: 
                            	  1847: GarbageCollectStrings:
00:000070FE 48E70074        	  1848: 	movem.l a1/a2/a3/a5,-(sp)
00:00007102 227A08F8        	  1849: 	move.l StrArea,a1			; source area pointer
00:00007106 247A08F4        	  1850: 	move.l StrArea,a2			; target area pointer
00:0000710A 2A7A08F4        	  1851: 	move.l LastStr,a5
                            	  1852: .0001
00:0000710E 6140            	  1853: 	bsr StringInVar				; check if the string is used by a variable
00:00007110 6506            	  1854: 	bcs .moveString
00:00007112 610000A6        	  1855: 	bsr StringOnStack			; check if string is on string expression stack
00:00007116 641C            	  1856: 	bcc .nextString				; if not on stack or in a var then move to next string
                            	  1857: 	
                            	  1858: 	; The string is in use, copy to active string area
                            	  1859: .moveString:
00:00007118 610000D0        	  1860: 	bsr UpdateStringPointers	; update pointer to string on stack or in variable
00:0000711C 611C            	  1861: 	bsr NextString				; a3 = pointer to next string
00:0000711E 610005CA        	  1862: 	bsr MVUPW							; will copy the length and string text
                            	  1863: .0005
00:00007122 B3CD            	  1864: 	cmp.l a5,a1						; is it the last string?
00:00007124 63E8            	  1865: 	bls .0001
00:00007126 23CA00007A00    	  1866: 	move.l a2,LastStr			; update last string pointer
00:0000712C 4252            	  1867: 	clr.w (a2)						; set zero length
00:0000712E 4CDF2E00        	  1868: 	movem.l (sp)+,a1/a2/a3/a5
00:00007132 4E75            	  1869: 	rts
                            	  1870: .nextString:
00:00007134 6104            	  1871: 	bsr NextString
00:00007136 224B            	  1872: 	move.l a3,a1
00:00007138 60E8            	  1873: 	bra .0005
                            	  1874: 
                            	  1875: ;-------------------------------------------------------------------------------	
                            	  1876: ; Parameters:
                            	  1877: ;		a1 - pointer to current string
                            	  1878: ; Returns:
                            	  1879: ;		a3 - pointer to next string
                            	  1880: ;-------------------------------------------------------------------------------	
                            	  1881: 
                            	  1882: NextString:
00:0000713A 2F04            	  1883: 	move.l d4,-(sp)
00:0000713C 3811            	  1884: 	move.w (a1),d4				; d4 = string length
00:0000713E 48C4            	  1885: 	ext.l d4							; make d4 long
00:00007140 5684            	  1886: 	addq.l #3,d4					; plus 2 for length field, 1 for rounding
00:00007142 D889            	  1887: 	add.l a1,d4
00:00007144 0284FFFFFFFE    	  1888: 	andi.l #$FFFFFFFE,d4	; make even wyde address
00:0000714A 2644            	  1889: 	move.l d4,a3
00:0000714C 281F            	  1890: 	move.l (sp)+,d4
00:0000714E 4E75            	  1891: 	rts
                            	  1892: 
                            	  1893: ;-------------------------------------------------------------------------------	
                            	  1894: ; Check if a variable is using a string
                            	  1895: ;
                            	  1896: ; Modifies:
                            	  1897: ;		d2,d3,a4
                            	  1898: ; Parameters:
                            	  1899: ;		a1 = pointer to string descriptor
                            	  1900: ; Returns:
                            	  1901: ;		cf = 1 if string in use, 0 otherwise
                            	  1902: ;-------------------------------------------------------------------------------	
                            	  1903: 
                            	  1904: StringInVar:
                            	  1905: 	; check global vars
00:00007150 287A08B6        	  1906: 	move.l VARBGN,a4
00:00007154 761F            	  1907: 	moveq #31,d3			; 32 vars
00:00007156 6116            	  1908: 	bsr SIV1
                            	  1909: 	; now check local vars
00:00007158 287A0866        	  1910: 	move.l STKFP,a4
                            	  1911: .0001
00:0000715C 588C            	  1912: 	addq.l #4,a4			; point to variable area
00:0000715E 7607            	  1913: 	moveq #7,d3
00:00007160 610C            	  1914: 	bsr SIV1					; check variable area
00:00007162 286CFFFC        	  1915: 	move.l -4(a4),a4	; get previous frame pointer
00:00007166 B9FAF058        	  1916: 	cmp.l ENDMEM,a4
00:0000716A 65F0            	  1917: 	blo .0001
00:0000716C 4E75            	  1918: 	rts
                            	  1919: 
                            	  1920: ;-------------------------------------------------------------------------------	
                            	  1921: ; SIV1 - string in variable helper. This routine does a two-up return if the
                            	  1922: ; string is found in a variable. No need to keep searching.
                            	  1923: ;
                            	  1924: ; Modifies:
                            	  1925: ;		d2,d3,a4
                            	  1926: ; Parameters:
                            	  1927: ;		d3 = number of variables-1 to check
                            	  1928: ;		a4 = string space
                            	  1929: ;		a1 = pointer to string descriptor
                            	  1930: ; Returns:
                            	  1931: ;		cf = 1 if string in use, 0 otherwise
                            	  1932: ;-------------------------------------------------------------------------------	
                            	  1933: 
                            	  1934: SIV1:
                            	  1935: .0003
00:0000716E 0C9400000002    	  1936: 	cmp.l #DT_STRING,(a4)
00:00007174 6612            	  1937: 	bne .0004
00:00007176 242C0008        	  1938: 	move.l 8(a4),d2
00:0000717A 5582            	  1939: 	subq.l #2,d2
00:0000717C B3C2            	  1940: 	cmp.l d2,a1
00:0000717E 6608            	  1941: 	bne .0004
00:00007180 588F            	  1942: 	addq.l #4,sp			; pop return address
00:00007182 003C0001        	  1943: 	ori #1,ccr
00:00007186 4E75            	  1944: 	rts								; do two up return
                            	  1945: .0004
00:00007188 508C            	  1946: 	addq.l #8,a4			;  increment pointer by 16
00:0000718A 508C            	  1947: 	addq.l #8,a4
00:0000718C 51CBFFE0        	  1948: 	dbra d3,.0003
00:00007190 023C00FE        	  1949: 	andi #$FE,ccr
00:00007194 4E75            	  1950: 	rts
                            	  1951: 
                            	  1952: ;-------------------------------------------------------------------------------	
                            	  1953: ; Check if a value could be a pointer into the string area.
                            	  1954: ; Even if the data type indicated a string, it may not be. It could just be a
                            	  1955: ; coincidence. So check that the pointer portion is pointing into string
                            	  1956: ; memory. It is extremely unlikely to have a data type and a valid pointer
                            	  1957: ; match and it not be a string.
                            	  1958: ;
                            	  1959: ; Returns
                            	  1960: ;		d3 = pointer to string
                            	  1961: ;		cf=1 if points into string area, 0 otherwise
                            	  1962: ;-------------------------------------------------------------------------------	
                            	  1963: 
                            	  1964: PointsIntoStringArea:
00:00007196 0C9400000002    	  1965: 	cmp.l #DT_STRING,(a4)		; is it a string data type?
00:0000719C 6616            	  1966: 	bne .0001
00:0000719E 262C0008        	  1967: 	move.l 8(a4),d3					; likely a string if
00:000071A2 B6BA0858        	  1968: 	cmp.l StrArea,d3				; flagged as a string, and pointer is into string area
00:000071A6 650C            	  1969: 	blo .0001
00:000071A8 B6BA085E        	  1970: 	cmp.l VARBGN,d3
00:000071AC 6406            	  1971: 	bhs .0001
00:000071AE 003C0001        	  1972: 	ori #1,ccr
00:000071B2 4E75            	  1973: 	rts
                            	  1974: .0001
00:000071B4 023C00FE        	  1975: 	andi #$FE,ccr
00:000071B8 4E75            	  1976: 	rts
                            	  1977: 
                            	  1978: ;-------------------------------------------------------------------------------	
                            	  1979: ; Check if the string is a temporary on stack
                            	  1980: ;
                            	  1981: ; Parameters:
                            	  1982: ;		a3 = pointer to old string text area
                            	  1983: ; Returns:
                            	  1984: ;		cf = 1 if string in use, 0 otherwise
                            	  1985: ;-------------------------------------------------------------------------------	
                            	  1986: 
                            	  1987: StringOnStack:
00:000071BA 48E72028        	  1988: 	movem.l d2/a2/a4,-(sp)
00:000071BE 7607            	  1989: 	moveq #7,d3
00:000071C0 284F            	  1990: 	move.l sp,a4
                            	  1991: .0002
00:000071C2 61D2            	  1992: 	bsr PointsIntoStringArea
00:000071C4 6408            	  1993: 	bcc .0003
00:000071C6 242C0008        	  1994: 	move.l 8(a4),d2			; d2 = string text pointer
00:000071CA B7C2            	  1995: 	cmp.l d2,a3					; compare string pointers
00:000071CC 6712            	  1996: 	beq .0001						; same pointer?
                            	  1997: .0003
00:000071CE 588C            	  1998: 	addq.l #4,a4				; bump pointer into stack
00:000071D0 B9FAEFEE        	  1999: 	cmp.l ENDMEM,a4			; have we hit end of stack yet?
00:000071D4 65EC            	  2000: 	blo .0002
00:000071D6 4CDF1404        	  2001: 	movem.l (sp)+,d2/a2/a4
00:000071DA 023C00FE        	  2002: 	andi #$FE,ccr
00:000071DE 4E75            	  2003: 	rts
                            	  2004: .0001
00:000071E0 4CDF1404        	  2005: 	movem.l (sp)+,d2/a2/a4
00:000071E4 003C0001        	  2006: 	ori #1,ccr
00:000071E8 4E75            	  2007: 	rts
                            	  2008: 	
                            	  2009: ;-------------------------------------------------------------------------------	
                            	  2010: ; Update pointers to string to point to new area. All string areas must be
                            	  2011: ; completely checked because there may be more than one pointer to the string.
                            	  2012: ;
                            	  2013: ; Modifies:
                            	  2014: ;		d2,d3,d4,a4
                            	  2015: ; Parameters:
                            	  2016: ;		a1 = old pointer to string
                            	  2017: ;		a2 = new pointer to string
                            	  2018: ;-------------------------------------------------------------------------------	
                            	  2019: 
                            	  2020: UpdateStringPointers:
00:000071EA 2F0B            	  2021: 	move.l a3,-(sp)
00:000071EC 47E90002        	  2022: 	lea 2(a1),a3						; a3 points to old string text area
                            	  2023: 	; check global variable space
00:000071F0 287A0816        	  2024: 	move.l VARBGN,a4
00:000071F4 761F            	  2025: 	moveq #31,d3						; 32 vars to check
00:000071F6 611E            	  2026: 	bsr USP1
                            	  2027: 	; check stack for strings
00:000071F8 284F            	  2028: 	move.l sp,a4						; start at stack bottom and work towards top
                            	  2029: .0002
00:000071FA 619A            	  2030: 	bsr PointsIntoStringArea
00:000071FC 640C            	  2031: 	bcc .0001
                            	  2032: 	; Here we probably have a string, one last check
00:000071FE B68A            	  2033: 	cmp.l a2,d3							; should be >= a2 as we are packing the space
00:00007200 6508            	  2034: 	blo .0001
00:00007202 294A0008        	  2035: 	move.l a2,8(a4)					; update pointer on stack with new address
00:00007206 546C0008        	  2036: 	addi.w #2,8(a4)					; bump up to text part of string
                            	  2037: .0001
00:0000720A 588C            	  2038: 	addq.l #4,a4
00:0000720C B9FAEFB2        	  2039: 	cmp.l ENDMEM,a4
00:00007210 65E8            	  2040: 	blo .0002
00:00007212 265F            	  2041: 	move.l (sp)+,a3
00:00007214 4E75            	  2042: 	rts
                            	  2043: 
                            	  2044: ;-------------------------------------------------------------------------------	
                            	  2045: ; Both global and local variable spaces are updated in the same manner.
                            	  2046: ;
                            	  2047: ; Parameters:
                            	  2048: ;		a1 = old pointer to string
                            	  2049: ;		a2 = new pointer to string
                            	  2050: ;		a4 = start of string space
                            	  2051: ;		d3 = number of string variables
                            	  2052: ;-------------------------------------------------------------------------------	
                            	  2053: 
                            	  2054: USP1:
                            	  2055: .0002
00:00007216 0C9400000002    	  2056: 	cmp.l #DT_STRING,(a4)		; check the data type
00:0000721C 6610            	  2057: 	bne .0001								; not a string, go to next
00:0000721E 242C0008        	  2058: 	move.l 8(a4),d2					; d2 = pointer to string text
00:00007222 B7C2            	  2059: 	cmp.l d2,a3							; does pointer match old pointer?
00:00007224 6608            	  2060: 	bne .0001
00:00007226 294A0008        	  2061: 	move.l a2,8(a4)					; copy in new pointer
00:0000722A 54AC0008        	  2062: 	addi.l #2,8(a4)					; point to string text
                            	  2063: .0001
00:0000722E 508C            	  2064: 	addq.l #8,a4						; increment pointer by 16
00:00007230 508C            	  2065: 	addq.l #8,a4
00:00007232 51CBFFE2        	  2066: 	dbra d3,.0002
00:00007236 4E75            	  2067: 	rts
                            	  2068: 
                            	  2069: ;-------------------------------------------------------------------------------	
                            	  2070: ; ===== Test for a valid variable name.  Returns Carry=1 if not
                            	  2071: ;	found, else returns Carry=0 and the address of the
                            	  2072: ;	variable in D0.
                            	  2073: 
                            	  2074: TSTV:
00:00007238 61000628        	  2075: 	bsr	IGNBLK
00:0000723C 7000            	  2076: 	CLR.L	D0
00:0000723E 1010            	  2077: 	MOVE.B (A0),D0 	 	; look at the program text
00:00007240 903C0040        	  2078: 	SUB.B	#'@',D0
00:00007244 6572            	  2079: 	BCS	TSTVRT				; C=1: not a variable
00:00007246 6638            	  2080: 	BNE	TV1						; branch if not "@" array
00:00007248 5248            	  2081: 	ADDQ #1,A0				; If it is, it should be
00:0000724A 6100FE3E        	  2082: 	BSR	PARN					; followed by (EXPR) as its index.
00:0000724E D080            	  2083: 	ADD.L	D0,D0
00:00007250 650003AC        	  2084: 	BCS	QHOW					; say "How?" if index is too big
00:00007254 D080            	  2085: 	ADD.L	D0,D0
00:00007256 650003A6        	  2086: 	BCS	QHOW
00:0000725A D080            	  2087: 	ADD.L	D0,D0
00:0000725C 650003A0        	  2088: 	BCS	QHOW
00:00007260 D080            	  2089: 	ADD.L	D0,D0
00:00007262 6500039A        	  2090: 	BCS	QHOW
00:00007266 2F00            	  2091: 	move.l d0,-(sp)		; save the index
00:00007268 6100012A        	  2092: 	bsr	SIZE					; get amount of free memory
00:0000726C 221F            	  2093: 	move.l (sp)+,d1		; get back the index
00:0000726E F2006000        	  2094: 	fmove.l fp0,d0		; convert to integer
00:00007272 B081            	  2095: 	cmp.l	d1,d0				; see if there's enough memory
00:00007274 63000380        	  2096: 	bls	QSORRY				; if not, say "Sorry"
00:00007278 203A078E        	  2097: 	move.l VARBGN,d0	; put address of array element...
00:0000727C 9081            	  2098: 	sub.l	d1,d0				; into D0
00:0000727E 4E75            	  2099: 	rts
                            	  2100: TV1
00:00007280 B03C001B        	  2101: 	CMP.B	#27,D0			; if not @, is it A through Z?
00:00007284 0A3C0001        	  2102: 	EOR	#1,CCR
00:00007288 652E            	  2103: 	BCS	TSTVRT				; if not, set Carry and return
00:0000728A 5248            	  2104: 	ADDQ #1,A0				; else bump the text pointer
00:0000728C 0C00004C        	  2105: 	cmpi.b #'L',d0		; is it a local? L0 to L7
00:00007290 661E            	  2106: 	bne TV2
00:00007292 1010            	  2107: 	move.b (a0),d0
00:00007294 0C000030        	  2108: 	cmpi.b #'0',d0
00:00007298 6516            	  2109: 	blo TV2
00:0000729A 0C000037        	  2110: 	cmpi.b #'7',d0
00:0000729E 6210            	  2111: 	bhi TV2
00:000072A0 903C0030        	  2112: 	sub.b #'0',d0
00:000072A4 5248            	  2113: 	addq #1,a0			; bump text pointer
00:000072A6 E988            	  2114: 	lsl.l #4,d0			; *16 bytes per var
00:000072A8 D0BA0716        	  2115: 	add.l STKFP,d0
00:000072AC 5880            	  2116: 	add.l #4,d0
00:000072AE 4E75            	  2117: 	rts
                            	  2118: TV2
00:000072B0 E988            	  2119: 	LSL.L #4,D0			; compute the variable's address
00:000072B2 223A0754        	  2120: 	MOVE.L VARBGN,D1
00:000072B6 D081            	  2121: 	ADD.L	D1,D0			; and return it in D0 with Carry=0
                            	  2122: TSTVRT
00:000072B8 4E75            	  2123: 	RTS
                            	  2124: 
                            	  2125: 
                            	  2126: * ===== Divide the 32 bit value in D0 by the 32 bit value in D1.
                            	  2127: *	Returns the 32 bit quotient in D0, remainder in D1.
                            	  2128: *
                            	  2129: DIV32
00:000072BA 4A81            	  2130: 	TST.L	D1		check for divide-by-zero
00:000072BC 67000340        	  2131: 	BEQ	QHOW		if so, say "How?"
00:000072C0 2401            	  2132: 	MOVE.L	D1,D2
00:000072C2 2801            	  2133: 	MOVE.L	D1,D4
00:000072C4 B184            	  2134: 	EOR.L	D0,D4		see if the signs are the same
00:000072C6 4A80            	  2135: 	TST.L	D0		take absolute value of D0
00:000072C8 6A02            	  2136: 	BPL	DIV1
00:000072CA 4480            	  2137: 	NEG.L	D0
00:000072CC 4A81            	  2138: DIV1	TST.L	D1		take absolute value of D1
00:000072CE 6A02            	  2139: 	BPL	DIV2
00:000072D0 4481            	  2140: 	NEG.L	D1
00:000072D2 761F            	  2141: DIV2	MOVEQ	#31,D3		iteration count for 32 bits
00:000072D4 2200            	  2142: 	MOVE.L	D0,D1
00:000072D6 7000            	  2143: 	CLR.L	D0
00:000072D8 D281            	  2144: DIV3	ADD.L	D1,D1		(This algorithm was translated from
00:000072DA D180            	  2145: 	ADDX.L	D0,D0		; the divide routine in Ron Cain's
00:000072DC 6708            	  2146: 	BEQ	DIV4		Small-C run time library.)
00:000072DE B082            	  2147: 	CMP.L	D2,D0
00:000072E0 6B04            	  2148: 	BMI	DIV4
00:000072E2 5281            	  2149: 	ADDQ.L	#1,D1
00:000072E4 9082            	  2150: 	SUB.L	D2,D0
00:000072E6 51CBFFF0        	  2151: DIV4	DBRA	D3,DIV3
00:000072EA C141            	  2152: 	EXG	D0,D1		put rem. & quot. in proper registers
00:000072EC 4A84            	  2153: 	TST.L	D4		were the signs the same?
00:000072EE 6A04            	  2154: 	BPL	DIVRT
00:000072F0 4480            	  2155: 	NEG.L	D0		if not, results are negative
00:000072F2 4481            	  2156: 	NEG.L	D1
00:000072F4 4E75            	  2157: DIVRT	RTS
                            	  2158: 
                            	  2159: 
                            	  2160: ; ===== The PEEK function returns the byte stored at the address
                            	  2161: ;	contained in the following expression.
                            	  2162: 
                            	  2163: PEEK
00:000072F6 1E3C0042        	  2164: 	MOVE.B #'B',d7
00:000072FA 1210            	  2165: 	MOVE.B (a0),d1
00:000072FC 0C01002E        	  2166: 	CMPI.B #'.',d1
00:00007300 6604            	  2167: 	BNE .0001
00:00007302 5248            	  2168: 	ADDQ #1,a0
00:00007304 1E18            	  2169: 	move.b (a0)+,d7
                            	  2170: .0001
00:00007306 6100FD82        	  2171: 	BSR	PARN		get the memory address
00:0000730A 0C8000000001    	  2172: 	cmpi.l #DT_NUMERIC,d0
00:00007310 660002F4        	  2173: 	bne ETYPE
00:00007314 F2006000        	  2174: 	FMOVE.L FP0,D0
00:00007318 2240            	  2175: 	MOVE.L D0,A1
00:0000731A 0C070042        	  2176: 	cmpi.b #'B',d7
00:0000731E 660C            	  2177: 	bne .0002
                            	  2178: .0005
00:00007320 7000            	  2179: 	CLR.L	D0				; upper 3 bytes will be zero
00:00007322 1011            	  2180: 	MOVE.B (A1),D0
00:00007324 F2005800        	  2181: 	FMOVE.B	D0,FP0 	; get the addressed byte
00:00007328 7001            	  2182: 	moveq #DT_NUMERIC,d0					; data type is a number
00:0000732A 4E75            	  2183: 	RTS							; and return it
                            	  2184: .0002
00:0000732C 0C070057        	  2185: 	cmpi.b #'W',d7
00:00007330 660C            	  2186: 	bne .0003
00:00007332 7000            	  2187: 	CLR.L d0
00:00007334 3011            	  2188: 	MOVE.W (A1),D0
00:00007336 F2005000        	  2189: 	FMOVE.W	D0,FP0	;	get the addressed word
00:0000733A 7001            	  2190: 	moveq #DT_NUMERIC,d0					; data type is a number
00:0000733C 4E75            	  2191: 	RTS							; and return it
                            	  2192: .0003
00:0000733E 0C07004C        	  2193: 	cmpi.b #'L',d7
00:00007342 660C            	  2194: 	bne .0004
00:00007344 7000            	  2195: 	CLR.L d0
00:00007346 2011            	  2196: 	MOVE.L (A1),D0
00:00007348 F2004000        	  2197: 	FMOVE.L	D0,FP0 	; get the lword
00:0000734C 7001            	  2198: 	moveq #DT_NUMERIC,d0					; data type is a number
00:0000734E 4E75            	  2199: 	RTS							; and return it
                            	  2200: .0004
00:00007350 0C070046        	  2201: 	cmpi.b #'F',d7
00:00007354 66CA            	  2202: 	bne .0005
00:00007356 F2114800        	  2203: 	FMOVE.X	(A1),FP0 		; get the addressed float
00:0000735A 7001            	  2204: 	moveq #DT_NUMERIC,d0					; data type is a number
00:0000735C 4E75            	  2205: 	RTS			and return it
                            	  2206: 
                            	  2207: ;-------------------------------------------------------------------------------
                            	  2208: ; The RND function returns a random number from 0 to the value of the following
                            	  2209: ; expression in fp0.
                            	  2210: ;-------------------------------------------------------------------------------
                            	  2211: 
                            	  2212: RND:
00:0000735E 6100FD2A        	  2213: 	bsr	PARN								; get the upper limit
00:00007362 0C8000000001    	  2214: 	cmpi.l #DT_NUMERIC,d0		; must be numeric
00:00007368 6600029C        	  2215: 	bne ETYPE
00:0000736C F200003A        	  2216: 	ftst.x fp0							; it must be positive and non-zero
00:00007370 F281028C        	  2217: 	fbeq QHOW
00:00007374 F2940288        	  2218: 	fblt QHOW
00:00007378 F2000100        	  2219: 	fmove fp0,fp2
00:0000737C 7028            	  2220: 	moveq #40,d0						; function #40 get random float
00:0000737E 4E4F            	  2221: 	trap #15
00:00007380 F2000823        	  2222: 	fmul fp2,fp0
00:00007384 7001            	  2223: 	moveq #DT_NUMERIC,d0		; data type is a number
00:00007386 4E75            	  2224: 	rts
                            	  2225: 
                            	  2226: ; ===== The ABS function returns an absolute value in D0.
                            	  2227: 
                            	  2228: ABS:	
00:00007388 6100FD00        	  2229: 	bsr	PARN			; get the following expr.'s value
00:0000738C F2000018        	  2230: 	fabs.x fp0
00:00007390 7001            	  2231: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00007392 4E75            	  2232: 	rts
                            	  2233: 
                            	  2234: ; ===== The SIZE function returns the size of free memory in D0.
                            	  2235: 
                            	  2236: SIZE:
00:00007394 203A0666        	  2237: 	move.l StrArea,d0		; get the number of free bytes...
00:00007398 90BA066A        	  2238: 	sub.l	 TXTUNF,d0		; between 'TXTUNF' and 'StrArea'
00:0000739C F2004000        	  2239: 	fmove.l d0,fp0
00:000073A0 7001            	  2240: 	moveq #DT_NUMERIC,d0	; data type is a number
00:000073A2 4E75            	  2241: 	rts										; return the number in fp0
                            	  2242: 	
                            	  2243: ; ===== The TICK function returns the processor tick register in D0.
                            	  2244: 
                            	  2245: TICK:
00:000073A4 4E7A0FF0        	  2246: 	movec tick,d0
00:000073A8 F2004000        	  2247: 	fmove.l d0,fp0
00:000073AC 7001            	  2248: 	moveq #DT_NUMERIC,d0					; data type is a number
00:000073AE 4E75            	  2249: 	rts
                            	  2250: 
                            	  2251: ; ===== The CORENO function returns the core number in D0.
                            	  2252: 
                            	  2253: CORENO:
00:000073B0 4E7A0FE0        	  2254: 	movec coreno,d0
00:000073B4 F2004000        	  2255: 	fmove.l d0,fp0
00:000073B8 7001            	  2256: 	moveq #DT_NUMERIC,d0					; data type is a number
00:000073BA 4E75            	  2257: 	rts
                            	  2258: 
                            	  2259: ;-------------------------------------------------------------------------------
                            	  2260: ; Get a pair of argments for the LEFT$ and RIGHT$ functions.
                            	  2261: ; 	(STRING, NUM)
                            	  2262: ; Returns:
                            	  2263: ;		fp0 = number
                            	  2264: ;		fp1 = string
                            	  2265: ;-------------------------------------------------------------------------------
                            	  2266: 
                            	  2267: LorRArgs:
00:000073BC 61000440        	  2268: 	bsr	TSTC						; else look for ( STRING EXPR, NUM EXPR )
00:000073C0 28              	  2269: 	dc.b	'(',LorR1-*
00:000073C1 33
00:000073C2 6100F9F8        	  2270: 	bsr	EXPR
00:000073C6 0C8000000002    	  2271: 	cmpi.l #DT_STRING,d0
00:000073CC 66000238        	  2272: 	bne ETYPE
00:000073D0 6100F988        	  2273: 	bsr XP_PUSH
00:000073D4 61000428        	  2274: 	bsr TSTC
00:000073D8 2C              	  2275: 	dc.b ',',LorR1-*
00:000073D9 1B
00:000073DA 6100F9E0        	  2276: 	bsr EXPR
00:000073DE 0C8000000001    	  2277: 	cmpi.l #DT_NUMERIC,d0
00:000073E4 66000220        	  2278: 	bne ETYPE
00:000073E8 61000414        	  2279: 	bsr	TSTC
00:000073EC 29              	  2280: 	dc.b	')',LorR1-*
00:000073ED 07
00:000073EE 6100F996        	  2281: 	bsr XP_POP1
00:000073F2 4E75            	  2282: 	rts
                            	  2283: LorR1
00:000073F4 60000208        	  2284: 	bra QHOW
                            	  2285: 	
                            	  2286: ;-------------------------------------------------------------------------------
                            	  2287: ; MID$ function gets a substring of characters from start position for
                            	  2288: ; requested length.
                            	  2289: ;-------------------------------------------------------------------------------
                            	  2290: 
                            	  2291: MID:
00:000073F8 61000404        	  2292: 	bsr	TSTC						; look for ( STRING EXPR, NUM EXPR [, NUM_EXPR] )
00:000073FC 28              	  2293: 	dc.b	'(',MID1-*
00:000073FD C1
00:000073FE 6100F9BC        	  2294: 	bsr	EXPR
00:00007402 0C8000000002    	  2295: 	cmpi.l #DT_STRING,d0
00:00007408 660001FC        	  2296: 	bne ETYPE
00:0000740C 6100F94C        	  2297: 	bsr XP_PUSH
00:00007410 610003EC        	  2298: 	bsr TSTC
00:00007414 2C              	  2299: 	dc.b ',',MID1-*
00:00007415 A9
00:00007416 6100F9A4        	  2300: 	bsr EXPR
00:0000741A 0C8000000001    	  2301: 	cmpi.l #DT_NUMERIC,d0
00:00007420 660001E4        	  2302: 	bne ETYPE
00:00007424 6100F934        	  2303: 	bsr XP_PUSH
00:00007428 7A02            	  2304: 	moveq #2,d5
00:0000742A 610003D2        	  2305: 	bsr	TSTC
00:0000742E 2C              	  2306: 	dc.b ',',MID2-*
00:0000742F 11
00:00007430 6100F98A        	  2307: 	bsr EXPR
00:00007434 0C8000000001    	  2308: 	cmpi.l #DT_NUMERIC,d0
00:0000743A 660001CA        	  2309: 	bne ETYPE
00:0000743E 7A03            	  2310: 	moveq #3,d5					; d5 indicates 3 params
                            	  2311: MID2
00:00007440 610003BC        	  2312: 	bsr TSTC
00:00007444 29              	  2313: 	dc.b ')',MID1-*
00:00007445 79
00:00007446 6100F93E        	  2314: 	bsr XP_POP1
00:0000744A 0C050003        	  2315: 	cmpi.b #3,d5				; did we have 3 arguments?
00:0000744E 6708            	  2316: 	beq MID5						; branch if did
00:00007450 F23C40000000FFFF	  2317: 	fmove.l #$FFFF,fp0	; set length = max
                            	  2318: MID5
00:00007458 F2000500        	  2319: 	fmove.x fp1,fp2			; fp2 = start pos
00:0000745C 6100F928        	  2320: 	bsr XP_POP1					; fp1 = string descriptor
                            	  2321: ;-------------------------------------------------------------------------------
                            	  2322: ; Perform MID$ function
                            	  2323: ; 	fp1 = string descriptor
                            	  2324: ; 	fp2 = starting position
                            	  2325: ; 	fp0 = length
                            	  2326: ;-------------------------------------------------------------------------------
                            	  2327: DOMID
00:00007460 F239688000040600	  2328: 	fmove.x fp1,_fpWork	; _fpWork = string descriptor
00:00007468 F2036100        	  2329: 	fmove.l fp2,d3			; d3 = start pos
00:0000746C B67900040600    	  2330: 	cmp.w _fpWork,d3		; is start pos < length
00:00007472 6400018A        	  2331: 	bhs QHOW
00:00007476 F2026000        	  2332: 	fmove.l fp0,d2			; d2=length
00:0000747A D682            	  2333: 	add.l d2,d3					; start pos + length < string length?
00:0000747C B47900040600    	  2334: 	cmp.w _fpWork,d2
00:00007482 6308            	  2335: 	bls MID4
00:00007484 343900040600    	  2336: 	move.w _fpWork,d2		; move string length to d2
00:0000748A 48C2            	  2337: 	ext.l d2
                            	  2338: MID4
00:0000748C 6100FC12        	  2339: 	bsr AllocateString	; a1 = pointer to new string
00:00007490 2449            	  2340: 	move.l a1,a2				; a2 = pointer to new string
00:00007492 227900040604    	  2341: 	move.l _fpWork+4,a1	; a1 = pointer to string
00:00007498 F2036100        	  2342: 	fmove.l fp2,d3			; d3 = start pos
00:0000749C D3C3            	  2343: 	add.l d3,a1					; a1 = pointer to start pos
00:0000749E 33C200040600    	  2344: 	move.w d2,_fpWork		; length
00:000074A4 23CA00040604    	  2345: 	move.l a2,_fpWork+4	; prep to return target string
00:000074AA 2649            	  2346: 	move.l a1,a3				; a3 = pointer to start pos
00:000074AC D7C2            	  2347: 	add.l d2,a3					; a3 = pointer to end pos
00:000074AE 61000230        	  2348: 	bsr MVUP						; move A1 to A2 until A1 = A3
00:000074B2 7002            	  2349: 	moveq #DT_STRING,d0	; data type is a string
00:000074B4 F239480000040600	  2350: 	fmove.x _fpWork,fp0	; string descriptor in fp0
00:000074BC 4E75            	  2351: 	rts
                            	  2352: MID1
00:000074BE 6000013E        	  2353: 	bra QHOW
                            	  2354: 	
                            	  2355: ;-------------------------------------------------------------------------------
                            	  2356: ; LEFT$ function truncates the string after fp0 characters.
                            	  2357: ; Just like MID$ but with a zero starting postion.
                            	  2358: ;-------------------------------------------------------------------------------
                            	  2359: 	
                            	  2360: LEFT:
00:000074C2 6100FEF8        	  2361: 	bsr LorRArgs				; get arguments
00:000074C6 F23C59000000    	  2362: 	fmove.b #0,fp2			; start pos = 0
00:000074CC 6092            	  2363: 	bra DOMID
                            	  2364: 
                            	  2365: ;-------------------------------------------------------------------------------
                            	  2366: ; RIGHT$ function gets the rightmost characters.
                            	  2367: ; The start position must be calculated based on the number of characters
                            	  2368: ; requested and the string length.
                            	  2369: ;-------------------------------------------------------------------------------
                            	  2370: 
                            	  2371: RIGHT:
00:000074CE 6100FEEC        	  2372: 	bsr LorRArgs				; get arguments
00:000074D2 F2026000        	  2373: 	fmove.l fp0,d2			; d2 = required length
00:000074D6 F239688000040600	  2374: 	fmove.x fp1,_fpWork	; _fpWork = string descriptor
00:000074DE 363900040600    	  2375: 	move.w _fpWork,d3		; d3 = string length
00:000074E4 48C3            	  2376: 	ext.l d3						; make d3 a long
00:000074E6 B682            	  2377: 	cmp.l d2,d3					; is length > right
00:000074E8 6202            	  2378: 	bhi .0001
00:000074EA 7400            	  2379: 	moveq #0,d2					; we want all the characters if length <= right
                            	  2380: .0001
00:000074EC 9682            	  2381: 	sub.l d2,d3					; d3 = startpos = length - right
00:000074EE F2034100        	  2382: 	fmove.l d3,fp2			; fp2 = start position
00:000074F2 6000FF6C        	  2383: 	bra DOMID
                            	  2384: 
                            	  2385: ;-------------------------------------------------------------------------------
                            	  2386: ; LEN( EXPR ) returns the length of a string expression.
                            	  2387: ;-------------------------------------------------------------------------------
                            	  2388: 
                            	  2389: LEN:
00:000074F6 6100FB92        	  2390: 	bsr PARN
00:000074FA 0C8000000002    	  2391: 	cmpi.l #DT_STRING,d0
00:00007500 66000104        	  2392: 	bne ETYPE
00:00007504 F239680000040600	  2393: 	fmove.x fp0,_fpWork
00:0000750C 303900040600    	  2394: 	move.w _fpWork,d0
00:00007512 48C0            	  2395: 	ext.l d0
00:00007514 F2005000        	  2396: 	fmove.w d0,fp0
00:00007518 7001            	  2397: 	moveq #DT_NUMERIC,d0
00:0000751A 4E75            	  2398: 	rts
                            	  2399: 
                            	  2400: ;-------------------------------------------------------------------------------
                            	  2401: ; INT( EXPR ) returns the integer value of the expression.
                            	  2402: ; the expression must be in the range of a 32-bit integer.
                            	  2403: ;-------------------------------------------------------------------------------
                            	  2404: 
                            	  2405: INT:
00:0000751C 6100FB6C        	  2406: 	bsr PARN
00:00007520 0C8000000001    	  2407: 	cmpi.l #DT_NUMERIC,d0
00:00007526 660000DE        	  2408: 	bne ETYPE
00:0000752A F2000003        	  2409: 	fintrz fp0,fp0
                            	  2410: ;	fmove.l fp0,d0
                            	  2411: ;	fmove.l d0,fp0
00:0000752E 7001            	  2412: 	moveq #DT_NUMERIC,d0
00:00007530 4E75            	  2413: 	rts
                            	  2414: 
                            	  2415: 
                            	  2416: ;-------------------------------------------------------------------------------
                            	  2417: ; CHR$( EXPR ) returns a one byte string containing the character.
                            	  2418: ;-------------------------------------------------------------------------------
                            	  2419: 
                            	  2420: CHR:
00:00007532 6100FB56        	  2421: 	bsr PARN
00:00007536 0C8000000001    	  2422: 	cmpi.l #DT_NUMERIC,d0
00:0000753C 660000C8        	  2423: 	bne ETYPE
00:00007540 F2006000        	  2424: 	fmove.l fp0,d0
00:00007544 7401            	  2425: 	moveq #1,d2
00:00007546 6100FB58        	  2426: 	bsr AllocateString
00:0000754A 1280            	  2427: 	move.b d0,(a1)
00:0000754C 42290001        	  2428: 	clr.b 1(a1)
00:00007550 7002            	  2429: 	moveq #DT_STRING,d0
00:00007552 23C900040604    	  2430: 	move.l a1,_fpWork+4
00:00007558 33FC000100040600	  2431: 	move.w #1,_fpWork
00:00007560 F239480000040600	  2432: 	fmove.x _fpWork,fp0
00:00007568 4E75            	  2433: 	rts
                            	  2434: 
                            	  2435: ********************************************************************
                            	  2436: *
                            	  2437: * *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                            	  2438: *
                            	  2439: * 'SETVAL' expects a variable, followed by an equal sign and then
                            	  2440: * an expression.  It evaluates the expression and sets the variable
                            	  2441: * to that value.
                            	  2442: *
                            	  2443: * 'FIN' checks the end of a command.  If it ended with ":",
                            	  2444: * execution continues.	If it ended with a CR, it finds the
                            	  2445: * the next line and continues from there.
                            	  2446: *
                            	  2447: * 'ENDCHK' checks if a command is ended with a CR. This is
                            	  2448: * required in certain commands, such as GOTO, RETURN, STOP, etc.
                            	  2449: *
                            	  2450: * 'ERROR' prints the string pointed to by A0. It then prints the
                            	  2451: * line pointed to by CURRNT with a "?" inserted at where the
                            	  2452: * old text pointer (should be on top of the stack) points to.
                            	  2453: * Execution of Tiny BASIC is stopped and a warm start is done.
                            	  2454: * If CURRNT is zero (indicating a direct command), the direct
                            	  2455: * command is not printed. If CURRNT is -1 (indicating
                            	  2456: * 'INPUT' command in progress), the input line is not printed
                            	  2457: * and execution is not terminated but continues at 'INPERR'.
                            	  2458: *
                            	  2459: * Related to 'ERROR' are the following:
                            	  2460: * 'QWHAT' saves text pointer on stack and gets "What?" message.
                            	  2461: * 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                            	  2462: * 'QSORRY' and 'ASORRY' do the same kind of thing.
                            	  2463: * 'QHOW' and 'AHOW' also do this for "How?".
                            	  2464: 
                            	  2465: ; SETVAL
                            	  2466: ; Returns:
                            	  2467: ;		a6 pointer to variable
                            	  2468: 
                            	  2469: SETVAL:	
00:0000756A 6100FCCC        	  2470: 	bsr	TSTV					; variable name?
00:0000756E 6546            	  2471: 	bcs	QWHAT					; if not, say "What?"
00:00007570 2F00            	  2472: 	move.l d0,-(sp)		; save the variable's address
00:00007572 6100028A        	  2473: 	bsr	TSTC					; get past the "=" sign
00:00007576 3D              	  2474: 	dc.b	'=',SV1-*
00:00007577 11
00:00007578 6100F842        	  2475: 	bsr	EXPR					; evaluate the expression
00:0000757C 2C5F            	  2476: 	move.l (sp)+,a6
00:0000757E 2C80            	  2477: 	move.l d0,(a6)		; save type
00:00007580 F22E68000004    	  2478: 	fmove.x fp0,4(a6) ; and save its value in the variable
00:00007586 4E75            	  2479: 	rts
                            	  2480: SV1
00:00007588 602C            	  2481: 	bra	QWHAT					; if no "=" sign
                            	  2482: 
                            	  2483: FIN
00:0000758A 61000272        	  2484: 	bsr	TSTC					; *** FIN ***
00:0000758E 3A              	  2485: 	DC.B ':',FI1-*
00:0000758F 07
00:00007590 588F            	  2486: 	ADDQ.L #4,SP			; if ":", discard return address
00:00007592 6000F0AC        	  2487: 	BRA	RUNSML				; continue on the same line
                            	  2488: FI1
00:00007596 61000266        	  2489: 	bsr	TSTC					; not ":", is it a CR?
00:0000759A 0D              	  2490: 	DC.B	CR,FI2-*
00:0000759B 07
00:0000759C 588F            	  2491: 	ADDQ.L #4,SP			; yes, purge return address
00:0000759E 6000F04A        	  2492: 	BRA	RUNNXL				; execute the next line
                            	  2493: FI2
00:000075A2 4E75            	  2494: 	RTS								; else return to the caller
                            	  2495: 
                            	  2496: ENDCHK
00:000075A4 610002BC        	  2497: 	bsr	IGNBLK
00:000075A8 0C10003A        	  2498: 	CMP.B #':',(a0)
00:000075AC 6706            	  2499: 	BEQ ENDCHK1
00:000075AE 0C10000D        	  2500: 	CMP.B	#CR,(A0)		; does it end with a CR?
00:000075B2 6602            	  2501: 	BNE	QWHAT					; if not, say "WHAT?"
                            	  2502: ENDCHK1:
00:000075B4 4E75            	  2503: 	RTS
                            	  2504: 
                            	  2505: QWHAT
00:000075B6 2F08            	  2506: 	MOVE.L A0,-(SP)
                            	  2507: AWHAT
00:000075B8 4DFA03CA        	  2508: 	LEA	WHTMSG,A6
                            	  2509: ERROR
00:000075BC 6100030A        	  2510: 	bsr	PRMESG		display the error message
00:000075C0 205F            	  2511: 	MOVE.L	(SP)+,A0	restore the text pointer
00:000075C2 203A03F8        	  2512: 	MOVE.L	CURRNT,D0	get the current line number
00:000075C6 6700EC68        	  2513: 	BEQ	WSTART		if zero, do a warm start
00:000075CA B0BCFFFFFFFF    	  2514: 	CMP.L	#-1,D0		is the line no. pointer = -1?
00:000075D0 6700F2E8        	  2515: 	BEQ	INPERR		if so, redo input
00:000075D4 1F10            	  2516: 	MOVE.B	(A0),-(SP)	save the char. pointed to
00:000075D6 4210            	  2517: 	CLR.B	(A0)		put a zero where the error is
00:000075D8 227A03E2        	  2518: 	MOVE.L	CURRNT,A1	point to start of current line
00:000075DC 61000202        	  2519: 	bsr	PRTLN		display the line in error up to the 0
00:000075E0 109F            	  2520: 	MOVE.B	(SP)+,(A0)	restore the character
00:000075E2 103C003F        	  2521: 	MOVE.B	#'?',D0         display a "?"
00:000075E6 6100EBC0        	  2522: 	BSR	GOOUT
00:000075EA 4240            	  2523: 	CLR	D0
00:000075EC 5389            	  2524: 	SUBQ.L	#1,A1		point back to the error char.
00:000075EE 6100017E        	  2525: 	bsr	PRTSTG		display the rest of the line
00:000075F2 6000EC3C        	  2526: 	BRA	WSTART		and do a warm start
                            	  2527: QSORRY
00:000075F6 2F08            	  2528: 	MOVE.L	A0,-(SP)
                            	  2529: ASORRY
00:000075F8 4DFA03AC        	  2530: 	LEA	SRYMSG,A6
00:000075FC 60BE            	  2531: 	BRA	ERROR
                            	  2532: QHOW
00:000075FE 2F08            	  2533: 	MOVE.L	A0,-(SP)	Error: "How?"
                            	  2534: AHOW
00:00007600 4DFA037B        	  2535: 	LEA	HOWMSG,A6
00:00007604 60B6            	  2536: 	BRA	ERROR
                            	  2537: ETYPE
00:00007606 4DFA0384        	  2538: 	lea TYPMSG,a6
00:0000760A 60B0            	  2539: 	bra ERROR
                            	  2540: 
                            	  2541: *******************************************************************
                            	  2542: *
                            	  2543: * *** GETLN *** FNDLN (& friends) ***
                            	  2544: *
                            	  2545: * 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                            	  2546: * the character in D0 (given by the caller), then it fills the
                            	  2547: * buffer and echos. It ignores LF's but still echos
                            	  2548: * them back. Control-H is used to delete the last character
                            	  2549: * entered (if there is one), and control-X is used to delete the
                            	  2550: * whole line and start over again. CR signals the end of a line,
                            	  2551: * and causes 'GETLN' to return.
                            	  2552: *
                            	  2553: * 'FNDLN' finds a line with a given line no. (in D1) in the
                            	  2554: * text save area.  A1 is used as the text pointer. If the line
                            	  2555: * is found, A1 will point to the beginning of that line
                            	  2556: * (i.e. the high byte of the line no.), and flags are NC & Z.
                            	  2557: * If that line is not there and a line with a higher line no.
                            	  2558: * is found, A1 points there and flags are NC & NZ. If we reached
                            	  2559: * the end of the text save area and cannot find the line, flags
                            	  2560: * are C & NZ.
                            	  2561: * 'FNDLN' will initialize A1 to the beginning of the text save
                            	  2562: * area to start the search. Some other entries of this routine
                            	  2563: * will not initialize A1 and do the search.
                            	  2564: * 'FNDLNP' will start with A1 and search for the line no.
                            	  2565: * 'FNDNXT' will bump A1 by 2, find a CR and then start search.
                            	  2566: * 'FNDSKP' uses A1 to find a CR, and then starts the search.
                            	  2567: 
                            	  2568: GETLN
00:0000760C 6100EB9A        	  2569: 	BSR	GOOUT		display the prompt
00:00007610 103C0020        	  2570: 	MOVE.B	#' ',D0         and a space
00:00007614 6100EB92        	  2571: 	BSR	GOOUT
00:00007618 41FA03FA        	  2572: 	LEA	BUFFER,A0	A0 is the buffer pointer
                            	  2573: GL1
00:0000761C 61000298        	  2574: 	bsr	CHKIO		check keyboard
00:00007620 67FA            	  2575: 	BEQ	GL1		wait for a char. to come in
00:00007622 B03C0008        	  2576: 	CMP.B	#CTRLH,D0	delete last character?
00:00007626 6726            	  2577: 	BEQ	GL3		if so
00:00007628 B03C0018        	  2578: 	CMP.B	#CTRLX,D0	delete the whole line?
00:0000762C 6744            	  2579: 	BEQ	GL4		if so
00:0000762E B03C000D        	  2580: 	CMP.B	#CR,D0		accept a CR
00:00007632 6706            	  2581: 	BEQ	GL2
00:00007634 B03C0020        	  2582: 	CMP.B	#' ',D0         if other control char., discard it
00:00007638 65E2            	  2583: 	BCS	GL1
                            	  2584: GL2
00:0000763A 10C0            	  2585: 	MOVE.B	D0,(A0)+	save the char.
00:0000763C 6100EB6A        	  2586: 	BSR	GOOUT		echo the char back out
00:00007640 B03C000D        	  2587: 	CMP.B	#CR,D0		if it's a CR, end the line
00:00007644 675C            	  2588: 	BEQ	GL7
00:00007646 B1FC00007A63    	  2589: 	CMP.L	#(BUFFER+BUFLEN-1),A0	any more room?
00:0000764C 65CE            	  2590: 	BCS	GL1		yes: get some more, else delete last char.
                            	  2591: GL3
00:0000764E 103C0008        	  2592: 	MOVE.B	#CTRLH,D0	delete a char. if possible
00:00007652 6100EB54        	  2593: 	BSR	GOOUT
00:00007656 103C0020        	  2594: 	MOVE.B	#' ',D0
00:0000765A 6100EB4C        	  2595: 	BSR	GOOUT
00:0000765E B1FC00007A14    	  2596: 	CMP.L	#BUFFER,A0	any char.'s left?
00:00007664 63B6            	  2597: 	BLS	GL1		if not
00:00007666 103C0008        	  2598: 	MOVE.B	#CTRLH,D0	if so, finish the BS-space-BS sequence
00:0000766A 6100EB3C        	  2599: 	BSR	GOOUT
00:0000766E 5388            	  2600: 	SUBQ.L	#1,A0		decrement the text pointer
00:00007670 60AA            	  2601: 	BRA	GL1		back for more
                            	  2602: GL4
00:00007672 2208            	  2603: 	MOVE.L	A0,D1		delete the whole line
00:00007674 92BC00007A14    	  2604: 	SUB.L	#BUFFER,D1	figure out how many backspaces we need
00:0000767A 671E            	  2605: 	BEQ	GL6		if none needed, branch
00:0000767C 5341            	  2606: 	SUBQ	#1,D1		adjust for DBRA
                            	  2607: GL5
00:0000767E 103C0008        	  2608: 	MOVE.B	#CTRLH,D0	and display BS-space-BS sequences
00:00007682 6100EB24        	  2609: 	BSR	GOOUT
00:00007686 103C0020        	  2610: 	MOVE.B	#' ',D0
00:0000768A 6100EB1C        	  2611: 	BSR	GOOUT
00:0000768E 103C0008        	  2612: 	MOVE.B	#CTRLH,D0
00:00007692 6100EB14        	  2613: 	BSR	GOOUT
00:00007696 51C9FFE6        	  2614: 	DBRA	D1,GL5
                            	  2615: GL6
00:0000769A 41FA0378        	  2616: 	LEA	BUFFER,A0	reinitialize the text pointer
00:0000769E 6000FF7C        	  2617: 	BRA	GL1		and go back for more
                            	  2618: GL7
00:000076A2 103C000A        	  2619: 	MOVE.B	#LF,D0		echo a LF for the CR
00:000076A6 6000EB00        	  2620: 	BRA	GOOUT
                            	  2621: 
                            	  2622: FNDLN
00:000076AA B2BC0000FFFF    	  2623: 	CMP.L	#$FFFF,D1	line no. must be < 65535
00:000076B0 6400FF4C        	  2624: 	BCC	QHOW
00:000076B4 227AEB06        	  2625: 	MOVE.L	TXTBGN,A1	init. the text save pointer
                            	  2626: 
                            	  2627: FNDLNP
00:000076B8 247A034A        	  2628: 	MOVE.L	TXTUNF,A2	check if we passed the end
00:000076BC 538A            	  2629: 	SUBQ.L	#1,A2
00:000076BE B5C9            	  2630: 	CMP.L	A1,A2
00:000076C0 650C            	  2631: 	BCS	FNDRET		if so, return with Z=0 & C=1
00:000076C2 1411            	  2632: 	MOVE.B	(A1),D2	if not, get a line no.
00:000076C4 E14A            	  2633: 	LSL	#8,D2
00:000076C6 14290001        	  2634: 	MOVE.B	1(A1),D2
00:000076CA B441            	  2635: 	CMP.W	D1,D2		is this the line we want?
00:000076CC 6502            	  2636: 	BCS	FNDNXT		no, not there yet
                            	  2637: FNDRET
00:000076CE 4E75            	  2638: 	RTS			return the cond. codes
                            	  2639: 
                            	  2640: FNDNXT
00:000076D0 5489            	  2641: 	ADDQ.L	#2,A1		find the next line
                            	  2642: 
                            	  2643: FNDSKP	
00:000076D2 0C19000D        	  2644: 	CMP.B	#CR,(A1)+	try to find a CR
00:000076D6 67E0            	  2645: 	BEQ		FNDLNP
00:000076D8 B3FA032A        	  2646: 	CMP.L	TXTUNF,A1
00:000076DC 65F4            	  2647: 	BLO		FNDSKP
00:000076DE 60D8            	  2648: 	BRA		FNDLNP		check if end of text
                            	  2649: 
                            	  2650: ;******************************************************************
                            	  2651: ;
                            	  2652: ; *** MVUP *** MVDOWN *** POPA *** PUSHA ***
                            	  2653: ;
                            	  2654: ; 'MVUP' moves a block up from where A1 points to where A2 points
                            	  2655: ; until A1=A3
                            	  2656: ;
                            	  2657: ; 'MVDOWN' moves a block down from where A1 points to where A3
                            	  2658: ; points until A1=A2
                            	  2659: ;
                            	  2660: ; 'POPA' restores the 'FOR' loop variable save area from the stack
                            	  2661: ;
                            	  2662: ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                            	  2663: ;
                            	  2664: 
                            	  2665: MVUP
00:000076E0 B7C9            	  2666: 	CMP.L	A1,A3					; see the above description
00:000076E2 6304            	  2667: 	BLS	MVRET
00:000076E4 14D9            	  2668: 	MOVE.B	(A1)+,(A2)+
00:000076E6 60F8            	  2669: 	BRA	MVUP
                            	  2670: MVRET
00:000076E8 4E75            	  2671: 	RTS
                            	  2672: 
                            	  2673: ; For string movements only suitable in some circumstances
                            	  2674: 
                            	  2675: MVUPW
00:000076EA B3CB            	  2676: 	cmp.l a3,a1
00:000076EC 6404            	  2677: 	bhs .0001
00:000076EE 34D9            	  2678: 	move.w (a1)+,(a2)+
00:000076F0 60F8            	  2679: 	bra MVUPW
                            	  2680: .0001
00:000076F2 4E75            	  2681: 	rts
                            	  2682: 
                            	  2683: MVDOWN
00:000076F4 B5C9            	  2684: 	CMP.L	A1,A2		see the above description
00:000076F6 67F0            	  2685: 	BEQ	MVRET
00:000076F8 1721            	  2686: 	MOVE.B	-(A1),-(A3)
00:000076FA 60F8            	  2687: 	BRA	MVDOWN
                            	  2688: 
                            	  2689: POPA
00:000076FC 2C5F            	  2690: 	MOVE.L	(SP)+,A6			; A6 = return address
00:000076FE 23DF000079CC    	  2691: 	MOVE.L	(SP)+,LOPVAR	restore LOPVAR, but zero means no more
00:00007704 6730            	  2692: 	BEQ	.0001
00:00007706 23DF000079D8    	  2693: 	MOVE.L	(SP)+,LOPINC+8	if not zero, restore the rest
00:0000770C 23DF000079D4    	  2694: 	MOVE.L	(SP)+,LOPINC+4
00:00007712 23DF000079D0    	  2695: 	MOVE.L	(SP)+,LOPINC
00:00007718 23DF000079E4    	  2696: 	MOVE.L	(SP)+,LOPLMT+8
00:0000771E 23DF000079E0    	  2697: 	MOVE.L	(SP)+,LOPLMT+4
00:00007724 23DF000079DC    	  2698: 	MOVE.L	(SP)+,LOPLMT
00:0000772A 23DF000079E8    	  2699: 	MOVE.L	(SP)+,LOPLN
00:00007730 23DF000079EC    	  2700: 	MOVE.L	(SP)+,LOPPT
                            	  2701: .0001
00:00007736 4ED6            	  2702: 	JMP	(A6)		return
                            	  2703: 
                            	  2704: PUSHA
00:00007738 223A02D2        	  2705: 	MOVE.L	STKLMT,D1		; Are we running out of stack room?
00:0000773C 928F            	  2706: 	SUB.L	SP,D1
00:0000773E 6400FEB6        	  2707: 	BCC	QSORRY					; if so, say we're sorry
00:00007742 2C5F            	  2708: 	MOVE.L	(SP)+,A6		; else get the return address
00:00007744 223A0286        	  2709: 	MOVE.L	LOPVAR,D1		; save loop variables
00:00007748 6720            	  2710: 	BEQ	.0001						; if LOPVAR is zero, that's all
00:0000774A 2F3A02A0        	  2711: 	MOVE.L	LOPPT,-(SP)	; else save all the others
00:0000774E 2F3A0298        	  2712: 	MOVE.L	LOPLN,-(SP)
00:00007752 2F3A0288        	  2713: 	MOVE.L	LOPLMT,-(SP)
00:00007756 2F3A0288        	  2714: 	MOVE.L	LOPLMT+4,-(SP)
00:0000775A 2F3A0288        	  2715: 	MOVE.L	LOPLMT+8,-(SP)
00:0000775E 2F3A0270        	  2716: 	MOVE.L	LOPINC,-(SP)
00:00007762 2F3A0270        	  2717: 	MOVE.L	LOPINC+4,-(SP)
00:00007766 2F3A0270        	  2718: 	MOVE.L	LOPINC+8,-(SP)
                            	  2719: .0001
00:0000776A 2F01            	  2720: 	MOVE.L	D1,-(SP)
00:0000776C 4ED6            	  2721: 	JMP	(A6)		return
                            	  2722: 
                            	  2723: *******************************************************************
                            	  2724: *
                            	  2725: * *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                            	  2726: *
                            	  2727: * 'PRTSTG' prints a string pointed to by A1. It stops printing
                            	  2728: * and returns to the caller when either a CR is printed or when
                            	  2729: * the next byte is the same as what was passed in D0 by the
                            	  2730: * caller.
                            	  2731: *
                            	  2732: * 'QTSTG' looks for an underline (back-arrow on some systems),
                            	  2733: * single-quote, or double-quote.  If none of these are found, returns
                            	  2734: * to the caller.  If underline, outputs a CR without a LF.  If single
                            	  2735: * or double quote, prints the quoted string and demands a matching
                            	  2736: * end quote.  After the printing, the next 2 bytes of the caller are
                            	  2737: * skipped over (usually a short branch instruction).
                            	  2738: *
                            	  2739: * 'PRTNUM' prints the 32 bit number in D1, leading blanks are added if
                            	  2740: * needed to pad the number of spaces to the number in D4.
                            	  2741: * However, if the number of digits is larger than the no. in
                            	  2742: * D4, all digits are printed anyway. Negative sign is also
                            	  2743: * printed and counted in, positive sign is not.
                            	  2744: *
                            	  2745: * 'PRTLN' prints the saved text line pointed to by A1
                            	  2746: * with line no. and all.
                            	  2747: *
                            	  2748: PRTSTG:
00:0000776E 1200            	  2749: 	MOVE.B	D0,D1		save the stop character
                            	  2750: PS1
00:00007770 1019            	  2751: 	MOVE.B	(A1)+,D0	get a text character
00:00007772 B200            	  2752: 	CMP.B	D0,D1		same as stop character?
00:00007774 6712            	  2753: 	BEQ	PRTRET		if so, return
00:00007776 6100EA30        	  2754: 	BSR	GOOUT		display the char.
00:0000777A B03C000D        	  2755: 	CMP.B	#CR,D0		is it a C.R.?
00:0000777E 66F0            	  2756: 	BNE	PS1		no, go back for more
00:00007780 103C000A        	  2757: 	MOVE.B	#LF,D0		yes, add a L.F.
00:00007784 6100EA22        	  2758: 	BSR	GOOUT
                            	  2759: PRTRET
00:00007788 4E75            	  2760: 	RTS			then return
                            	  2761: 
                            	  2762: PRTSTR2a
00:0000778A 1019            	  2763: 	move.b (a1)+,d0
00:0000778C 6100EA1A        	  2764: 	bsr GOOUT
                            	  2765: PRTSTR2:
00:00007790 51C9FFF8        	  2766: 	dbra d1,PRTSTR2a
00:00007794 4E75            	  2767: 	rts
                            	  2768: 	
                            	  2769: 	if 0
                            	  2770: QTSTG
                            	  2771: 	bsr	TSTC		*** QTSTG ***
                            	  2772: 	DC.B	'"',QT3-*
                            	  2773: 	MOVE.B	#'"',D0         it is a "
                            	  2774: QT1
                            	  2775: 	MOVE.L	A0,A1
                            	  2776: 	BSR	PRTSTG		print until another
                            	  2777: 	MOVE.L	A1,A0
                            	  2778: 	MOVE.L	(SP)+,A1	pop return address
                            	  2779: 	CMP.B	#LF,D0		was last one a CR?
                            	  2780: 	BEQ	RUNNXL		if so, run next line
                            	  2781: QT2
                            	  2782: 	ADDQ.L	#2,A1		skip 2 bytes on return
                            	  2783: 	JMP	(A1)		return
                            	  2784: QT3
                            	  2785: 	bsr	TSTC		is it a single quote?
                            	  2786: 	DC.B	'''',QT4-*
                            	  2787: 	MOVE.B	#'''',D0        if so, do same as above
                            	  2788: 	BRA	QT1
                            	  2789: QT4
                            	  2790: 	bsr	TSTC		is it an underline?
                            	  2791: 	DC.B	'_',QT5-*
                            	  2792: 	MOVE.B	#CR,D0		if so, output a CR without LF
                            	  2793: 	bsr	GOOUT
                            	  2794: 	MOVE.L	(SP)+,A1	pop return address
                            	  2795: 	BRA	QT2
                            	  2796: QT5
                            	  2797: 	RTS			none of the above
                            	  2798: 	endif
                            	  2799: 
                            	  2800: PRTNUM:
00:00007796 4E52FFD0        	  2801: 	link a2,#-48
00:0000779A 217900040098002C	  2802: 	move.l _canary,44(a0)
00:000077A2 48D7020F        	  2803: 	movem.l d0/d1/d2/d3/a1,(sp)
00:000077A6 F22F68000014    	  2804: 	fmove.x fp0,20(sp)
00:000077AC F22F68800020    	  2805: 	fmove.x fp1,32(sp)
00:000077B2 F2000400        	  2806: 	fmove.x fp1,fp0					; fp0 = number to print
00:000077B6 43F900040520    	  2807: 	lea _fpBuf,a1						; a1 = pointer to buffer to use
00:000077BC 7027            	  2808: 	moveq #39,d0						; d0 = function #39 print float
00:000077BE 2204            	  2809: 	move.l d4,d1						; d1 = width
00:000077C0 2404            	  2810: 	move.l d4,d2						; d2 = precision max
00:000077C2 7665            	  2811: 	moveq #'e',d3
00:000077C4 4E4F            	  2812: 	trap #15
00:000077C6 4CD7020F        	  2813: 	movem.l (sp),d0/d1/d2/d3/a1
00:000077CA F22F48000014    	  2814: 	fmove.x 20(sp),fp0
00:000077D0 F22F48800020    	  2815: 	fmove.x 32(sp),fp1
00:000077D6 A2A80003002C    	  2816: 	cchk 44(a0)
00:000077DC 4E5A            	  2817: 	unlk a2
00:000077DE 4E75            	  2818: 	rts
                            	  2819: 
                            	  2820: ; Debugging
                            	  2821: 	if 0
                            	  2822: PRTFP0:
                            	  2823: 	link a2,#-48
                            	  2824: 	move.l _canary,44(a0)
                            	  2825: 	movem.l d0/d1/d2/d3/a1,(sp)
                            	  2826: 	fmove.x fp0,20(sp)
                            	  2827: 	lea _fpBuf,a1						; a1 = pointer to buffer to use
                            	  2828: 	moveq #39,d0						; d0 = function #39 print float
                            	  2829: 	moveq #30,d1						; d1 = width
                            	  2830: 	moveq #25,d2						; d2 = precision max
                            	  2831: 	moveq #'e',d3
                            	  2832: 	trap #15
                            	  2833: 	movem.l (sp),d0/d1/d2/d3/a1
                            	  2834: 	fmove.x 20(sp),fp0
                            	  2835: 	cchk 44(a0)
                            	  2836: 	unlk a2
                            	  2837: 	rts
                            	  2838: 	endif
                            	  2839: 
                            	  2840: PRTLN:
00:000077E0 7200            	  2841: 	CLR.L	D1
00:000077E2 1219            	  2842: 	MOVE.B (A1)+,D1	get the binary line number
00:000077E4 E149            	  2843: 	LSL	#8,D1
00:000077E6 1219            	  2844: 	MOVE.B (A1)+,D1
00:000077E8 F2015080        	  2845: 	FMOVE.W D1,FP1
00:000077EC 7805            	  2846: 	MOVEQ	#5,D4			; display a 5 digit line no.
00:000077EE 61A6            	  2847: 	BSR	PRTNUM
00:000077F0 103C0020        	  2848: 	MOVE.B	#' ',D0         followed by a blank
00:000077F4 6100E9B2        	  2849: 	BSR	GOOUT
00:000077F8 4240            	  2850: 	CLR	D0		stop char. is a zero
00:000077FA 6000FF72        	  2851: 	BRA	PRTSTG		display the rest of the line
                            	  2852: 
                            	  2853: 
                            	  2854: ; ===== Test text byte following the call to this subroutine. If it
                            	  2855: ; equals the byte pointed to by A0, return to the code following
                            	  2856: ; the call. If they are not equal, branch to the point
                            	  2857: ;	indicated by the offset byte following the text byte.
                            	  2858: 
                            	  2859: TSTC:
00:000077FE 6162            	  2860: 	BSR	IGNBLK				; ignore leading blanks
00:00007800 225F            	  2861: 	MOVE.L (SP)+,A1		; get the return address
00:00007802 1219            	  2862: 	MOVE.B (A1)+,D1		; get the byte to compare
00:00007804 B210            	  2863: 	CMP.B	(A0),D1 		;	is it = to what A0 points to?
00:00007806 6708            	  2864: 	BEQ	TC1						; if so
00:00007808 7200            	  2865: 	CLR.L	D1					; If not, add the second
00:0000780A 1211            	  2866: 	MOVE.B (A1),D1 		; byte following the call to
00:0000780C D3C1            	  2867: 	ADD.L	D1,A1				; the return address.
00:0000780E 4ED1            	  2868: 	JMP	(A1)					; jump to the routine
                            	  2869: TC1
00:00007810 5288            	  2870: 	ADDQ.L #1,A0			; if equal, bump text pointer
00:00007812 5289            	  2871: 	ADDQ.L #1,A1			; Skip the 2 bytes following
00:00007814 4ED1            	  2872: 	JMP	(A1)					; the call and continue.
                            	  2873: 
                            	  2874: 
                            	  2875: ; ===== See if the text pointed to by A0 is a number. If so,
                            	  2876: ;	return the number in FP1 and the number of digits in D2,
                            	  2877: ;	else return zero in FP1 and D2.
                            	  2878: ; If text is not a number, then A0 is not updated, otherwise
                            	  2879: ; A0 is advanced past the number. Note A0 is always updated
                            	  2880: ; past leading spaces.
                            	  2881: 
                            	  2882: TSTNUM:
00:00007816 4E52FFE0        	  2883: 	link a2,#-32
00:0000781A 2F7900040098001C	  2884: 	move.l _canary,28(sp)
00:00007822 48D70202        	  2885: 	movem.l d1/a1,(sp)
00:00007826 F22F68000010    	  2886: 	fmove.x fp0,16(sp)
00:0000782C 7029            	  2887: 	moveq #41,d0						; function #41, get float
00:0000782E 7201            	  2888: 	moveq #1,d1							; d1 = input stride
00:00007830 2248            	  2889: 	move.l a0,a1						; a1 = pointer to input buffer
00:00007832 4E4F            	  2890: 	trap #15								; call BIOS get float function
00:00007834 2049            	  2891: 	move.l a1,a0						; set text pointer
00:00007836 7001            	  2892: 	moveq #DT_NUMERIC,d0		; default data type = number
00:00007838 F2000080        	  2893: 	fmove.x fp0,fp1					; return expected in fp1
00:0000783C 4A41            	  2894: 	tst.w d1								; check if a number (digits > 0?)
00:0000783E 6706            	  2895: 	beq .0002
00:00007840 7400            	  2896: 	clr.l d2								; d2.l = 0
00:00007842 3401            	  2897: 	move.w d1,d2						; d2 = number of digits
00:00007844 6008            	  2898: 	bra .0001
                            	  2899: .0002											; not a number, return with orignal text pointer
00:00007846 7000            	  2900: 	moveq #0,d0							; data type = not a number
00:00007848 7400            	  2901: 	moveq #0,d2							; d2 = 0
00:0000784A F2024080        	  2902: 	fmove.l d2,fp1					; return a zero
                            	  2903: .0001
00:0000784E 4CD70202        	  2904: 	movem.l (sp),d1/a1
00:00007852 F22F48000010    	  2905: 	fmove.x 16(sp),fp0
00:00007858 A2AF0003001C    	  2906: 	cchk 28(sp)
00:0000785E 4E5A            	  2907: 	unlk a2
00:00007860 4E75            	  2908: 	rts
                            	  2909: 		
                            	  2910: ; ===== Skip over blanks in the text pointed to by A0.
                            	  2911: 
                            	  2912: IGNBLK
00:00007862 0C180020        	  2913: 	CMP.B	#' ',(A0)+		; see if it's a space
00:00007866 67FA            	  2914: 	BEQ	IGNBLK					; if so, swallow it
00:00007868 5388            	  2915: 	SUBQ.L #1,A0				; decrement the text pointer
00:0000786A 4E75            	  2916: 	RTS
                            	  2917: 
                            	  2918: *
                            	  2919: * ===== Convert the line of text in the input buffer to upper
                            	  2920: *	case (except for stuff between quotes).
                            	  2921: *
00:0000786C 41FA01A6        	  2922: TOUPBUF LEA	BUFFER,A0	set up text pointer
00:00007870 4201            	  2923: 	CLR.B	D1		clear quote flag
                            	  2924: TOUPB1	
00:00007872 1018            	  2925: 	MOVE.B	(A0)+,D0	get the next text char.
00:00007874 B03C000D        	  2926: 	CMP.B	#CR,D0		is it end of line?
00:00007878 6718            	  2927: 	BEQ	TOUPBRT 	if so, return
00:0000787A B03C0022        	  2928: 	CMP.B	#'"',D0         a double quote?
00:0000787E 6714            	  2929: 	BEQ	DOQUO
00:00007880 B03C0027        	  2930: 	CMP.B	#'''',D0        or a single quote?
00:00007884 670E            	  2931: 	BEQ	DOQUO
00:00007886 4A01            	  2932: 	TST.B	D1		inside quotes?
00:00007888 66E8            	  2933: 	BNE	TOUPB1		if so, do the next one
00:0000788A 6118            	  2934: 	BSR	TOUPPER 	convert to upper case
00:0000788C 1100            	  2935: 	MOVE.B	D0,-(A0)	store it
00:0000788E 5288            	  2936: 	ADDQ.L	#1,A0
00:00007890 60E0            	  2937: 	BRA	TOUPB1		and go back for more
                            	  2938: TOUPBRT
00:00007892 4E75            	  2939: 	RTS
                            	  2940: 
00:00007894 4A01            	  2941: DOQUO	TST.B	D1		are we inside quotes?
00:00007896 6604            	  2942: 	BNE	DOQUO1
00:00007898 1200            	  2943: 	MOVE.B	D0,D1		if not, toggle inside-quotes flag
00:0000789A 60D6            	  2944: 	BRA	TOUPB1
00:0000789C B200            	  2945: DOQUO1	CMP.B	D0,D1		make sure we're ending proper quote
00:0000789E 66D2            	  2946: 	BNE	TOUPB1		if not, ignore it
00:000078A0 4201            	  2947: 	CLR.B	D1		else clear quote flag
00:000078A2 60CE            	  2948: 	BRA	TOUPB1
                            	  2949: 
                            	  2950: *
                            	  2951: * ===== Convert the character in D0 to upper case
                            	  2952: *
00:000078A4 B03C0061        	  2953: TOUPPER CMP.B	#'a',D0         is it < 'a'?
00:000078A8 650A            	  2954: 	BCS	TOUPRET
00:000078AA B03C007A        	  2955: 	CMP.B	#'z',D0         or > 'z'?
00:000078AE 6204            	  2956: 	BHI	TOUPRET
00:000078B0 903C0020        	  2957: 	SUB.B	#32,D0		if not, make it upper case
00:000078B4 4E75            	  2958: TOUPRET RTS
                            	  2959: 
                            	  2960: *
                            	  2961: * 'CHKIO' checks the input. If there's no input, it will return
                            	  2962: * to the caller with the Z flag set. If there is input, the Z
                            	  2963: * flag is cleared and the input byte is in D0. However, if a
                            	  2964: * control-C is read, 'CHKIO' will warm-start BASIC and will not
                            	  2965: * return to the caller.
                            	  2966: *
                            	  2967: CHKIO
00:000078B6 6100E8F4        	  2968: 	bsr	GOIN		get input if possible
00:000078BA 670A            	  2969: 	BEQ	CHKRET		if Zero, no input
00:000078BC B03C0003        	  2970: 	CMP.B	#CTRLC,D0	is it control-C?
00:000078C0 6604            	  2971: 	BNE	CHKRET		if not
00:000078C2 6000E96C        	  2972: 	BRA	WSTART		if so, do a warm start
                            	  2973: CHKRET
00:000078C6 4E75            	  2974: 	RTS
                            	  2975: 
                            	  2976: *
                            	  2977: * ===== Display a CR-LF sequence
                            	  2978: *
                            	  2979: ;CRLF	LEA	CLMSG,A6
                            	  2980: 
                            	  2981: 
                            	  2982: ; ===== Display a zero-ended string pointed to by register A6
                            	  2983: 
                            	  2984: PRMESG:
00:000078C8 101E            	  2985: 	MOVE.B (A6)+,D0		; get the char.
00:000078CA 6706            	  2986: 	BEQ	PRMRET				; if it's zero, we're done
00:000078CC 6100E8DA        	  2987: 	BSR	GOOUT					; else display it
00:000078D0 60F6            	  2988: 	BRA	PRMESG
                            	  2989: PRMRET
00:000078D2 4E75            	  2990: 	RTS
                            	  2991: 
                            	  2992: ;*****************************************************
                            	  2993: ; The following routines are the only ones that need *
                            	  2994: ; to be changed for a different I/O environment.     *
                            	  2995: ;*****************************************************
                            	  2996: 
                            	  2997: ; ===== Clear screen and home cursor
                            	  2998: 
                            	  2999: CLS:
00:000078D4 700B            	  3000: 	moveq #11,d0			; set cursor position
00:000078D6 323CFF00        	  3001: 	move.w #$FF00,d1	; home cursor and clear screen
00:000078DA 4E4F            	  3002: 	trap #15
00:000078DC 6000EE68        	  3003: 	bra FINISH
                            	  3004: 
                            	  3005: ; ===== Output character to the console (Port 1) from register D0
                            	  3006: ;(Preserves all registers.)
                            	  3007: 
                            	  3008: OUTC:
00:000078E0 48E7C000        	  3009: 	movem.l d0/d1,-(sp)
00:000078E4 2200            	  3010: 	move.l d0,d1
00:000078E6 7006            	  3011: 	moveq #6,d0
00:000078E8 4E4F            	  3012: 	trap #15
00:000078EA 4CDF0003        	  3013: 	movem.l (sp)+,d0/d1
00:000078EE 4E75            	  3014: 	rts
                            	  3015: 
                            	  3016: ; ===== Input a character from the console into register D0 (or
                            	  3017: ;	return Zero status if there's no character available).
                            	  3018: ;
                            	  3019: INC
00:000078F0 2F0E            	  3020: 	move.l	a6,-(a7)
00:000078F2 2C7A00C0        	  3021: 	move.l	INPPTR,a6
00:000078F6 4E96            	  3022: 	jsr			(a6)
00:000078F8 2C5F            	  3023: 	move.l	(a7)+,a6
00:000078FA 4E75            	  3024: 	rts
                            	  3025: 
                            	  3026: INC1
00:000078FC 2F01            	  3027: 	move.l	d1,-(a7)
00:000078FE 7005            	  3028: 	moveq.l	#5,d0			* function 5 GetKey
00:00007900 4E4F            	  3029: 	trap		#15
00:00007902 2001            	  3030: 	move.l	d1,d0
00:00007904 221F            	  3031: 	move.l	(a7)+,d1
00:00007906 0C0000FF        	  3032: 	cmpi.b	#-1,d0
00:0000790A 6602            	  3033: 	bne			.0001
00:0000790C 4200            	  3034: 	clr.b		d0
                            	  3035: .0001:
00:0000790E 4E75            	  3036: 	rts
                            	  3037: 
                            	  3038: *INC	BTST	#0,$10040	is character ready?
                            	  3039: *	BEQ	INCRET		if not, return Zero status
                            	  3040: *	MOVE.B	$10042,D0	else get the character
                            	  3041: *	AND.B	#$7F,D0 	zero out the high bit
                            	  3042: *INCRET	RTS
                            	  3043: 
                            	  3044: * ===== Output character to the host (Port 2) from register D0
                            	  3045: *	(Preserves all registers.)
                            	  3046: *
                            	  3047: AUXOUT:
00:00007910 13FC0002000400A8	  3048: 	move.b #2,OutputDevice
00:00007918 61C6            	  3049: 	bsr OUTC
00:0000791A 13FC0001000400A8	  3050: 	move.b #1,OutputDevice
00:00007922 4E75            	  3051: 	rts
                            	  3052: 
                            	  3053: *AUXOUT	BTST	#1,$10041	is port 2 ready for a character?
                            	  3054: *	BEQ	AUXOUT		if not, wait for it
                            	  3055: *	MOVE.B	D0,$10043	out it goes.
                            	  3056: *	RTS
                            	  3057: 
                            	  3058: *
                            	  3059: * ===== Input a character from the host into register D0 (or
                            	  3060: *	return Zero status if there's no character available).
                            	  3061: *
                            	  3062: AUXIN:
00:00007924 2F01            	  3063: 	move.l	d1,-(a7)
00:00007926 7024            	  3064: 	moveq		#36,d0				; serial get char from buffer
00:00007928 4E4F            	  3065: 	trap		#15
00:0000792A 2001            	  3066: 	move.l	d1,d0
00:0000792C 221F            	  3067: 	move.l	(a7)+,d1
00:0000792E 0C40FFFF        	  3068: 	cmpi.w	#-1,d0
00:00007932 670A            	  3069: 	beq			.0001
00:00007934 0200007F        	  3070: 	andi.b	#$7F,d0				; clear high bit
00:00007938 4880            	  3071: 	ext.w		d0						; return character in d0
00:0000793A 48C0            	  3072: 	ext.l		d0
00:0000793C 4E75            	  3073: 	rts
                            	  3074: .0001:
00:0000793E 7000            	  3075: 	moveq		#0,d0					; return zf=1 if no character available
00:00007940 4E75            	  3076: 	rts
                            	  3077: 
                            	  3078: ;AUXIN
                            	  3079: *AUXIN	BTST	#0,$10041	is character ready?
                            	  3080: *	BEQ	AXIRET		if not, return Zero status
                            	  3081: *	MOVE.B	$10043,D0	else get the character
                            	  3082: *	AND.B	#$7F,D0 	zero out the high bit
00:00007942 4E75            	  3083: AXIRET	RTS
                            	  3084: 
                            	  3085: ; ===== Return to the resident monitor, operating system, etc.
                            	  3086: ;
                            	  3087: BYEBYE	
00:00007944 23FC000000080004	  3088: 	move.l #8,_fpTextIncr
00:0000794C 0094
00:0000794E 600007E8        	  3089: 	bra		Monitor
                            	  3090: ;	MOVE.B	#228,D7 	return to Tutor
                            	  3091: ;	TRAP	#14
                            	  3092: 
00:00007952 0D              	  3093: INITMSG DC.B	CR,LF,'MC68000 Tiny Float BASIC, v1.0',CR,LF,LF,0
00:00007953 0A
00:00007954 4D43363830303020
00:0000795C 54696E7920466C6F
00:00007964 6174204241534943
00:0000796C 2C2076312E30
00:00007972 0D
00:00007973 0A
00:00007974 0A
00:00007975 00
00:00007976 0D              	  3094: OKMSG	DC.B	CR,LF,'OK',CR,LF,0
00:00007977 0A
00:00007978 4F4B
00:0000797A 0D
00:0000797B 0A
00:0000797C 00
00:0000797D 486F773F        	  3095: HOWMSG	DC.B	'How?',CR,LF,0
00:00007981 0D
00:00007982 0A
00:00007983 00
00:00007984 576861743F      	  3096: WHTMSG	DC.B	'What?',CR,LF,0
00:00007989 0D
00:0000798A 0A
00:0000798B 00
00:0000798C 547970653F      	  3097: TYPMSG	DC.B	'Type?',CR,LF,0
00:00007991 0D
00:00007992 0A
00:00007993 00
00:00007994 4E6F20737472696E	  3098: NOSTRING	DC.B 'No string space',CR,LF,0
00:0000799C 67207370616365
00:000079A3 0D
00:000079A4 0A
00:000079A5 00
00:000079A6 536F7272792E    	  3099: SRYMSG	DC.B	'Sorry.'
00:000079AC 0D              	  3100: CLMSG	DC.B	CR,LF,0
00:000079AD 0A
00:000079AE 00
00:000079AF 00              	  3101: 	DC.B	0	<- for aligning on a word boundary
                            	  3102: LSTROM	EQU	*		end of possible ROM area
                            	  3103: *
                            	  3104: * Internal variables follow:
                            	  3105: *
                            	  3106: 	align 2
00:000079B0 000061A2        	  3107: RANPNT	DC.L	START		random number pointer
00:000079B4 00000000        	  3108: INPPTR	DS.L	1		input pointer
00:000079B8 00000000        	  3109: OUTPTR	DS.L	1 	output pointer
00:000079BC 00000000        	  3110: CURRNT	DS.L	1		; Current line pointer
00:000079C0 00000000        	  3111: STKFP		DS.L	1		; saves frame pointer
00:000079C4 00000000        	  3112: STKGOS	DS.L	1		Saves stack pointer in 'GOSUB'
00:000079C8 00000000        	  3113: STKINP	DS.L	1		Saves stack pointer during 'INPUT'
00:000079CC 00000000        	  3114: LOPVAR	DS.L	1		'FOR' loop save area
00:000079D0 00000000        	  3115: LOPINC	DS.L	3		increment
00:000079D4 *
00:000079DC 00000000        	  3116: LOPLMT	DS.L	3		limit
00:000079E0 *
00:000079E8 00000000        	  3117: LOPLN	DS.L	1		line number
00:000079EC 00000000        	  3118: LOPPT	DS.L	1		text pointer
00:000079F0 00000000        	  3119: IRQROUT	DS.L	1
00:000079F4 00000000        	  3120: STRSTK	DS.L	1		; string pointer stack area, 8 entries
00:000079F8 00000000        	  3121: StrSp		DS.L	1		; string stack stack pointer
00:000079FC 00000000        	  3122: StrArea	DS.L	1		; pointer to string area
00:00007A00 00000000        	  3123: LastStr	DS.L	1		; pointer to last used string in area
00:00007A04 00000000        	  3124: TXTUNF	DS.L	1		points to unfilled text area
00:00007A08 00000000        	  3125: VARBGN	DS.L	1		points to variable area
00:00007A0C 00000000        	  3126: STKLMT	DS.L	1		holds lower limit for stack growth
00:00007A10 00000000        	  3127: DIRFLG	DS.L	1		; indicates 1=DIRECT mode
00:00007A14 00              	  3128: BUFFER	DS.B	BUFLEN		Keyboard input buffer
00:00007A15 *
                            	  3129: TXT	EQU	*		Beginning of program area
                            	  3130: ;	END
                            	  3131: 

Source: "boot.x68"
                            	   946: 
                            	   947: ; -----------------------------------------------------------------------------
                            	   948: ; -----------------------------------------------------------------------------
                            	   949: 
                            	   950: set_text_mode:
00:00007A64 7030            	   951: 	moveq #TEXTCOL,d0
00:00007A66 13C0FD080000    	   952: 	move.b d0,TEXTREG					; number of columns
00:00007A6C 7020            	   953: 	moveq #TEXTROW,d0
00:00007A6E 13C0FD080001    	   954: 	move.b d0,TEXTREG+1				; number of rows
00:00007A74 7000            	   955: 	moveq #0,d0
00:00007A76 13C0FD080003    	   956: 	move.b d0,TEXTREG+3				; text mode
00:00007A7C 7011            	   957: 	moveq #17,d0
00:00007A7E 13C0FD080008    	   958: 	move.b d0,TEXTREG+8				; max row scan
00:00007A84 700B            	   959: 	moveq #11,d0
00:00007A86 13C0FD08000A    	   960: 	move.b d0,TEXTREG+10			; max pix
00:00007A8C 4E75            	   961: 	rts
                            	   962: 	
                            	   963: set_graphics_mode:
00:00007A8E 7060            	   964: 	moveq #TEXTCOL*2,d0
00:00007A90 13C0FD080000    	   965: 	move.b d0,TEXTREG					; number of columns
00:00007A96 7040            	   966: 	moveq #TEXTROW*2,d0
00:00007A98 13C0FD080001    	   967: 	move.b d0,TEXTREG+1				; number of rows
00:00007A9E 7001            	   968: 	moveq #1,d0
00:00007AA0 13C0FD080003    	   969: 	move.b d0,TEXTREG+3				; graphics mode
00:00007AA6 7007            	   970: 	moveq #7,d0
00:00007AA8 13C0FD080008    	   971: 	move.b d0,TEXTREG+8				; max row scan
00:00007AAE 7007            	   972: 	moveq #7,d0
00:00007AB0 13C0FD08000A    	   973: 	move.b d0,TEXTREG+10			; max pix
00:00007AB6 4E75            	   974: 	rts
                            	   975: 
                            	   976: ; -----------------------------------------------------------------------------
                            	   977: ; -----------------------------------------------------------------------------
                            	   978: 
                            	   979: get_screen_address:
00:00007AB8 48E7E300        	   980: 	movem.l d0/d1/d2/d6/d7,-(a7)
00:00007ABC 7E02            	   981: 	moveq #2,d7
00:00007ABE 7C10            	   982: 	moveq #DEV_GETBUF1,d6
00:00007AC0 4E40            	   983: 	trap #0
00:00007AC2 2041            	   984: 	move.l d1,a0
00:00007AC4 4CDF00C7        	   985: 	movem.l (a7)+,d0/d1/d2/d6/d7
00:00007AC8 4E75            	   986: 	rts
                            	   987: 	
                            	   988: 
                            	   989: CRLF:
00:00007ACA 48E7C000        	   990: 	movem.l d0/d1,-(a7)
00:00007ACE 123C000D        	   991: 	move.b #13,d1
00:00007AD2 7006            	   992: 	moveq #6,d0						; output character function
00:00007AD4 4E4F            	   993: 	trap #15
00:00007AD6 123C000A        	   994: 	move.b #10,d1
00:00007ADA 7006            	   995: 	moveq #6,d0						; output character function
00:00007ADC 4E4F            	   996: 	trap #15
00:00007ADE 4CDF0003        	   997: 	movem.l (a7)+,d0/d1
00:00007AE2 4E75            	   998: 	rts
                            	   999: 
                            	  1000: ;------------------------------------------------------------------------------
                            	  1001: ; Display a string on standard output.
                            	  1002: ;------------------------------------------------------------------------------
                            	  1003: 
                            	  1004: DisplayString:
00:00007AE4 48E7C040        	  1005: 	movem.l	d0/d1/a1,-(a7)
                            	  1006: dspj1:
00:00007AE8 7200            	  1007: 	clr.l d1							; clear upper bits of d1
00:00007AEA 1219            	  1008: 	move.b (a1)+,d1				; move string char into d1
00:00007AEC 6706            	  1009: 	beq.s dsret						; is it end of string ?
00:00007AEE 7006            	  1010: 	moveq #6,d0						; output character function
00:00007AF0 4E4F            	  1011: 	trap #15
00:00007AF2 60F4            	  1012: 	bra.s	dspj1						; go back for next character
                            	  1013: dsret:
00:00007AF4 4CDF0203        	  1014: 	movem.l	(a7)+,d0/d1/a1
00:00007AF8 4E75            	  1015: 	rts
                            	  1016: 
                            	  1017: ;------------------------------------------------------------------------------
                            	  1018: ; Display a string on the screen followed by carriage return / linefeed.
                            	  1019: ;------------------------------------------------------------------------------
                            	  1020: 
                            	  1021: DisplayStringCRLF:
00:00007AFA 61E8            	  1022: 	bsr		DisplayString
00:00007AFC 60CC            	  1023: 	bra		CRLF
                            	  1024: 
                            	  1025: ;------------------------------------------------------------------------------
                            	  1026: ; Display a string on the screen limited to 255 chars max.
                            	  1027: ;------------------------------------------------------------------------------
                            	  1028: 
                            	  1029: DisplayStringLimited:
00:00007AFE 48E7E040        	  1030: 	movem.l	d0/d1/d2/a1,-(a7)
00:00007B02 3401            	  1031: 	move.w	d1,d2					; d2 = max count
00:00007B04 024200FF        	  1032: 	andi.w	#$00FF,d2			; limit to 255 chars
00:00007B08 600A            	  1033: 	bra.s		.0003					; enter loop at bottom
                            	  1034: .0001:
00:00007B0A 7200            	  1035: 	clr.l d1							; clear upper bits of d1
00:00007B0C 1219            	  1036: 	move.b (a1)+,d1				; move string char into d1
00:00007B0E 6708            	  1037: 	beq.s .0002						; is it end of string ?
00:00007B10 7006            	  1038: 	moveq #6,d0						; output character function
00:00007B12 4E4F            	  1039: 	trap #15
                            	  1040: .0003:
00:00007B14 51CAFFF4        	  1041: 	dbra		d2,.0001			; go back for next character
                            	  1042: .0002:
00:00007B18 4CDF0207        	  1043: 	movem.l	(a7)+,d0/d1/d2/a1
00:00007B1C 4E75            	  1044: 	rts
                            	  1045: 
                            	  1046: DisplayStringLimitedCRLF:
00:00007B1E 61DE            	  1047: 	bsr		DisplayStringLimited
00:00007B20 60A8            	  1048: 	bra		CRLF
                            	  1049: 	
                            	  1050: 
                            	  1051: ;==============================================================================
                            	  1052: ; TRAP #15 handler
                            	  1053: ;
                            	  1054: ; Parameters:
                            	  1055: ;		d0.w = function number to perform
                            	  1056: ;==============================================================================
                            	  1057: 
                            	  1058: TRAP15:
00:00007B22 48E78080        	  1059: 	movem.l	d0/a0,-(a7)
00:00007B26 41FA0014        	  1060: 	lea T15DispatchTable,a0
00:00007B2A 4880            	  1061: 	ext.w d0
00:00007B2C E548            	  1062: 	lsl.w #2,d0
00:00007B2E 20700000        	  1063: 	move.l (a0,d0.w),a0
00:00007B32 4E90            	  1064: 	jsr (a0)
00:00007B34 4CDF0101        	  1065: 	movem.l (a7)+,d0/a0
00:00007B38 4E73            	  1066: 	rte
                            	  1067: 
                            	  1068: 		align	2
                            	  1069: T15DispatchTable:
00:00007B3C 00007B1E        	  1070: 	dc.l	DisplayStringLimitedCRLF
00:00007B40 00007AFE        	  1071: 	dc.l	DisplayStringLimited
00:00007B44 00007FD2        	  1072: 	dc.l	StubRout
00:00007B48 00007FD2        	  1073: 	dc.l	StubRout
00:00007B4C 00007FD2        	  1074: 	dc.l	StubRout
00:00007B50 00000874        	  1075: 	dc.l	GetKey
00:00007B54 00009B8A        	  1076: 	dc.l	OutputChar
00:00007B58 00000868        	  1077: 	dc.l	CheckForKey
00:00007B5C 00007CDC        	  1078: 	dc.l	GetTick
00:00007B60 00007FD2        	  1079: 	dc.l	StubRout
                            	  1080: 	; 10
00:00007B64 00007FD2        	  1081: 	dc.l	StubRout
00:00007B68 00007F9A        	  1082: 	dc.l	Cursor1
00:00007B6C 00000860        	  1083: 	dc.l	SetKeyboardEcho
00:00007B70 00007AFA        	  1084: 	dc.l	DisplayStringCRLF
00:00007B74 00007AE4        	  1085: 	dc.l	DisplayString
00:00007B78 00007FD2        	  1086: 	dc.l	StubRout
00:00007B7C 00007FD2        	  1087: 	dc.l	StubRout
00:00007B80 00007FD2        	  1088: 	dc.l	StubRout
00:00007B84 00007FD2        	  1089: 	dc.l	StubRout
00:00007B88 00000868        	  1090: 	dc.l	CheckForKey
                            	  1091: 	; 20
00:00007B8C 00007FD2        	  1092: 	dc.l	StubRout
00:00007B90 00007FD2        	  1093: 	dc.l	StubRout
00:00007B94 00007FD2        	  1094: 	dc.l	StubRout
00:00007B98 00007CE4        	  1095: 	dc.l	T15Wait100ths
00:00007B9C 00007FD2        	  1096: 	dc.l	StubRout
00:00007BA0 00007FD2        	  1097: 	dc.l	StubRout
00:00007BA4 00007FD2        	  1098: 	dc.l	StubRout
00:00007BA8 00007FD2        	  1099: 	dc.l	StubRout
00:00007BAC 00007FD2        	  1100: 	dc.l	StubRout
00:00007BB0 00007FD2        	  1101: 	dc.l	StubRout
                            	  1102: 	; 30
00:00007BB4 00007FD2        	  1103: 	dc.l	StubRout
00:00007BB8 00007FD2        	  1104: 	dc.l	StubRout
00:00007BBC 00007CCC        	  1105: 	dc.l	SimHardware	;rotate_iofocus
00:00007BC0 00007D60        	  1106: 	dc.l	T15GetWindowSize	;SerialPeekCharDirect
00:00007BC4 0000173C        	  1107: 	dc.l	SerialPutChar
00:00007BC8 000016E6        	  1108: 	dc.l	SerialPeekChar
00:00007BCC 0000166E        	  1109: 	dc.l	SerialGetChar
00:00007BD0 000025D6        	  1110: 	dc.l	T15LockSemaphore
00:00007BD4 000025DC        	  1111: 	dc.l	T15UnlockSemaphore
00:00007BD8 00009AEA        	  1112: 	dc.l	prtflt
                            	  1113: 	; 40
00:00007BDC 0000251C        	  1114: 	dc.l  _GetRand
00:00007BE0 000025E2        	  1115: 	dc.l	T15GetFloat
00:00007BE4 000025F0        	  1116: 	dc.l	T15Abort
00:00007BE8 00009B30        	  1117: 	dc.l	T15FloatToString
00:00007BEC 00007FD2        	  1118: 	dc.l	StubRout
00:00007BF0 00007FD2        	  1119: 	dc.l	StubRout
00:00007BF4 00007FD2        	  1120: 	dc.l	StubRout
00:00007BF8 00007FD2        	  1121: 	dc.l	StubRout
00:00007BFC 00007FD2        	  1122: 	dc.l	StubRout
00:00007C00 00007FD2        	  1123: 	dc.l	StubRout
                            	  1124: 	; 50
00:00007C04 00007FD2        	  1125: 	dc.l	StubRout
00:00007C08 00007FD2        	  1126: 	dc.l	StubRout
00:00007C0C 00007FD2        	  1127: 	dc.l	StubRout
00:00007C10 00007FD2        	  1128: 	dc.l	StubRout
00:00007C14 00007FD2        	  1129: 	dc.l	StubRout
00:00007C18 00007FD2        	  1130: 	dc.l	StubRout
00:00007C1C 00007FD2        	  1131: 	dc.l	StubRout
00:00007C20 00007FD2        	  1132: 	dc.l	StubRout
00:00007C24 00007FD2        	  1133: 	dc.l	StubRout
00:00007C28 00007FD2        	  1134: 	dc.l	StubRout
                            	  1135: 	; 60
00:00007C2C 00007FD2        	  1136: 	dc.l	StubRout
00:00007C30 00007FD2        	  1137: 	dc.l	StubRout
00:00007C34 00007FD2        	  1138: 	dc.l	StubRout
00:00007C38 00007FD2        	  1139: 	dc.l	StubRout
00:00007C3C 00007FD2        	  1140: 	dc.l	StubRout
00:00007C40 00007FD2        	  1141: 	dc.l	StubRout
00:00007C44 00007FD2        	  1142: 	dc.l	StubRout
00:00007C48 00007FD2        	  1143: 	dc.l	StubRout
00:00007C4C 00007FD2        	  1144: 	dc.l	StubRout
00:00007C50 00007FD2        	  1145: 	dc.l	StubRout
                            	  1146: 	; 70
00:00007C54 00007FD2        	  1147: 	dc.l	StubRout
00:00007C58 00007FD2        	  1148: 	dc.l	StubRout
00:00007C5C 00007FD2        	  1149: 	dc.l	StubRout
00:00007C60 00007FD2        	  1150: 	dc.l	StubRout
00:00007C64 00007FD2        	  1151: 	dc.l	StubRout
00:00007C68 00007FD2        	  1152: 	dc.l	StubRout
00:00007C6C 00007FD2        	  1153: 	dc.l	StubRout
00:00007C70 00007FD2        	  1154: 	dc.l	StubRout
00:00007C74 00007FD2        	  1155: 	dc.l	StubRout
00:00007C78 00007FD2        	  1156: 	dc.l	StubRout
                            	  1157: 	; 80
00:00007C7C 00007D22        	  1158: 	dc.l	SetPenColor
00:00007C80 00007FD2        	  1159: 	dc.l	StubRout
00:00007C84 00007FD2        	  1160: 	dc.l	StubRout
00:00007C88 00007FD2        	  1161: 	dc.l	StubRout
00:00007C8C 00007FD2        	  1162: 	dc.l	StubRout
00:00007C90 00007EBA        	  1163: 	dc.l	DrawToXY
00:00007C94 00007EAC        	  1164: 	dc.l	MoveToXY
00:00007C98 00007FD2        	  1165: 	dc.l	StubRout
00:00007C9C 00007FD2        	  1166: 	dc.l	StubRout
00:00007CA0 00007FD2        	  1167: 	dc.l	StubRout
                            	  1168: 	; 90
00:00007CA4 00007D2E        	  1169: 	dc.l	T15Rectangle
00:00007CA8 00007FD2        	  1170: 	dc.l	StubRout
00:00007CAC 00007D00        	  1171: 	dc.l	SetDrawMode
00:00007CB0 00007FD2        	  1172: 	dc.l	StubRout
00:00007CB4 00007D76        	  1173: 	dc.l	GRBufferToScreen
00:00007CB8 00007FD2        	  1174: 	dc.l	StubRout
00:00007CBC 00007FD2        	  1175: 	dc.l	StubRout
00:00007CC0 00007FD2        	  1176: 	dc.l	StubRout
00:00007CC4 00007FD2        	  1177: 	dc.l	StubRout
00:00007CC8 00007FD2        	  1178: 	dc.l	StubRout
                            	  1179: 
                            	  1180: ;------------------------------------------------------------------------------
                            	  1181: 
                            	  1182: SimHardware:
00:00007CCC 0C410003        	  1183: 	cmpi.w #3,d1
00:00007CD0 6608            	  1184: 	bne.s .0001
00:00007CD2 223C000408B8    	  1185: 	move.l #sys_switches,d1
00:00007CD8 4E75            	  1186: 	rts
                            	  1187: .0001:
00:00007CDA 4E75            	  1188: 	rts
                            	  1189: 
                            	  1190: ;------------------------------------------------------------------------------
                            	  1191: ;
                            	  1192: GetTick:
00:00007CDC 22390004009C    	  1193: 	move.l tickcnt,d1
00:00007CE2 4E75            	  1194: 	rts
                            	  1195: 
                            	  1196: T15Wait100ths:
00:00007CE4 2F01            	  1197: 	move.l d1,-(a7)
00:00007CE6 B2BC00000002    	  1198: 	cmp.l #2,d1
00:00007CEC 630E            	  1199: 	bls.s .0002
00:00007CEE D2B90004009C    	  1200: 	add.l tickcnt,d1
                            	  1201: .0001:
00:00007CF4 B2B90004009C    	  1202: 	cmp.l tickcnt,d1
00:00007CFA 66F8            	  1203: 	bne.s .0001
                            	  1204: .0002:
00:00007CFC 221F            	  1205: 	move.l (a7)+,d1
00:00007CFE 4E75            	  1206: 	rts
                            	  1207: 
                            	  1208: ;------------------------------------------------------------------------------
                            	  1209: ;
                            	  1210: SetDrawMode:
00:00007D00 0C01000A        	  1211: 	cmpi.b #10,d1
00:00007D04 660A            	  1212: 	bne.s .0001
00:00007D06 13FC000500040D80	  1213: 	move.b #5,framebuf_dcb+DCB_OPCODE			; 'OR' operation
00:00007D0E 4E75            	  1214: 	rts
                            	  1215: .0001:
00:00007D10 0C010011        	  1216: 	cmpi.b #17,d1
00:00007D14 660A            	  1217: 	bne.s .0002
00:00007D16 33FC0001000408AC	  1218: 	move.w #1,gr_double_buffer
00:00007D1E 4E75            	  1219: 	rts
                            	  1220: .0002:
00:00007D20 4E75            	  1221: 	rts
                            	  1222: 	
                            	  1223: SetPenColor:
00:00007D22 6100A384        	  1224: 	bsr gfxaccel_set_color
00:00007D26 23C100040D7C    	  1225: 	move.l d1,framebuf_dcb+DCB_FGCOLOR
00:00007D2C 4E75            	  1226: 	rts
                            	  1227: 
                            	  1228: ; parameters:
                            	  1229: ;		d0 = color
                            	  1230: ;		d1 = width
                            	  1231: ;		d2 = height
                            	  1232: ;		d3 = x co-ord
                            	  1233: ;		d4 = y co-ord
                            	  1234: 
                            	  1235: T15Rectangle:
00:00007D2E 48E76000        	  1236: 	movem.l d1/d2,-(a7)
00:00007D32 D283            	  1237: 	add.l d3,d1
00:00007D34 D484            	  1238: 	add.l d4,d2
00:00007D36 6100A4F2        	  1239: 	bsr gfxaccel_draw_rectangle
00:00007D3A 4CDF0006        	  1240: 	movem.l (a7)+,d1/d2
00:00007D3E 4E75            	  1241: 	rts
                            	  1242: 
                            	  1243: T15GetPixel:
00:00007D40 48E76080        	  1244: 	movem.l d1/d2/a0,-(a7)
00:00007D44 48C1            	  1245: 	ext.l d1								; clear upper bits
00:00007D46 48C2            	  1246: 	ext.l d2
00:00007D48 207900040D54    	  1247: 	move.l framebuf_dcb+DCB_OUTBUFPTR,a0
00:00007D4E C4FC0320        	  1248: 	mulu #800,d2						; y * pixels per line
00:00007D52 D481            	  1249: 	add.l d1,d2							; + x
00:00007D54 E58A            	  1250: 	lsl.l #2,d2							; * 4 bytes per pixel
00:00007D56 20302800        	  1251: 	move.l (a0,d2.l),d0			; get color
00:00007D5A 4CDF0106        	  1252: 	movem.l (a7)+,d1/d2/a0
00:00007D5E 4E75            	  1253: 	rts
                            	  1254: 
                            	  1255: T15GetWindowSize:
00:00007D60 4A01            	  1256: 	cmpi.b #0,d1
00:00007D62 660C            	  1257: 	bne.s .0001
00:00007D64 323C0258        	  1258: 	move.w #600,d1
00:00007D68 4841            	  1259: 	swap d1
00:00007D6A 323C0320        	  1260: 	move.w #800,d1
00:00007D6E 4E75            	  1261: 	rts
                            	  1262: .0001:
00:00007D70 7200            	  1263: 	move.l #0,d1
00:00007D72 7200            	  1264: 	move.l #0,d1
00:00007D74 4E75            	  1265: 	rts
                            	  1266: 
                            	  1267: ;------------------------------------------------------------------------------
                            	  1268: ; Page flip between two buffers.
                            	  1269: ;------------------------------------------------------------------------------
                            	  1270: 
                            	  1271: GRBufferToScreen:
00:00007D76 7E06            	  1272: 	move.l #6,d7						; framebuffer device
00:00007D78 7C0D            	  1273: 	move.l #DEV_SWAPBUF,d6	; swap buffers
00:00007D7A 4E40            	  1274: 	trap #0
00:00007D7C 4E75            	  1275: 	rts
                            	  1276: 
                            	  1277: ; The following copies the buffer, why? Not needed if page flipping.
                            	  1278: ;	movem.l d0/a0/a1,-(a7)
                            	  1279: ;	move.l gr_bitmap_buffer,a1
                            	  1280: ;	move.l gr_bitmap_screen,a0
                            	  1281: ;	move.w gr_width,d0
                            	  1282: ;	mulu gr_height,d0
                            	  1283: ;	lsr.l #4,d0							; moving 16 pixels per iteration
                            	  1284: ;	move.l #0,$BFFFFFF8			; set burst length zero
                            	  1285: ;	bra.s .loop
                            	  1286: ;.loop2:
                            	  1287: ;	swap d0
                            	  1288: ;.loop:
                            	  1289: ;	move.l a1,$BFFFFFF0			; set source address
                            	  1290: ;	tst.l $BFFFFFFC					; do a read op, no value needed
                            	  1291: ;	move.l a0,$BFFFFFF4			; set destination address
                            	  1292: ;	move.l d0,$BFFFFFFC			; do a write operation (any value)
                            	  1293: ;	dbra d0,.loop
                            	  1294: ;	swap d0									; might go over 32/64 kB
                            	  1295: ;	dbra d0,.loop2
                            	  1296: ;	movem.l (a7)+,d0/a0/a1
                            	  1297: ;	rts
                            	  1298: 
                            	  1299: 
                            	  1300: TestBitmap:
                            	  1301: ;	move.w #$0700,pen_color		; dark blue
00:00007D7E 33FC070000040D78	  1302: 	move.w #$0700,framebuf_dcb+DCB_BKCOLOR
00:00007D86 7E06            	  1303: 	move.l #6,d7
00:00007D88 7C0C            	  1304: 	move.l #DEV_CLEAR,d6
00:00007D8A 4E40            	  1305: 	trap #0
                            	  1306: ;	bsr clear_bitmap_screen4
00:00007D8C 705E            	  1307: 	moveq #94,d0							; page flip (display blank screen)
00:00007D8E 4E4F            	  1308: 	trap #15
00:00007D90 33FC007C00040890	  1309: 	move.w #$007c,pen_color		; red pen
00:00007D98 7E06            	  1310: 	moveq #6,d7
00:00007D9A 7C07            	  1311: 	moveq #DEV_SET_OUTPOS,d6
00:00007D9C 7200            	  1312: 	moveq #0,d1
00:00007D9E 7401            	  1313: 	moveq #1,d2
00:00007DA0 4E40            	  1314: 	trap #0
00:00007DA2 7C14            	  1315: 	moveq #DEV_GET_DIMEN,d6
00:00007DA4 4E40            	  1316: 	trap #0
00:00007DA6 5381            	  1317: 	subq.l #1,d1
00:00007DA8 2601            	  1318: 	move.l d1,d3
00:00007DAA 7801            	  1319: 	moveq #1,d4
00:00007DAC 6100018A        	  1320: 	bsr DrawHorizTo
00:00007DB0 42B900040894    	  1321: 	clr.l gr_x
00:00007DB6 42B900040898    	  1322: 	clr.l gr_y
00:00007DBC 7600            	  1323: 	move.l #0,d3
00:00007DBE 2839000408A0    	  1324: 	move.l gr_height,d4
00:00007DC4 5384            	  1325: 	subq.l #1,d4
00:00007DC6 610001A2        	  1326: 	bsr DrawVertTo
00:00007DCA 33FCE00100040890	  1327: 	move.w #$E001,pen_color		; green pen
00:00007DD2 23FC000000020004	  1328: 	move.l #2,gr_x
00:00007DDA 0894
00:00007DDC 42B900040898    	  1329: 	clr.l gr_y
00:00007DE2 7602            	  1330: 	move.l #2,d3
00:00007DE4 2839000408A0    	  1331: 	move.l gr_height,d4
00:00007DEA 5384            	  1332: 	subq.l #1,d4
00:00007DEC 6100017C        	  1333: 	bsr DrawVertTo
00:00007DF0 42B900040894    	  1334: 	clr.l gr_x
00:00007DF6 42B900040898    	  1335: 	clr.l gr_y
00:00007DFC 26390004089C    	  1336: 	move.l gr_width,d3
00:00007E02 5383            	  1337: 	subq.l #1,d3
00:00007E04 23C300040894    	  1338: 	move.l d3,gr_x
00:00007E0A 2839000408A0    	  1339: 	move.l gr_height,d4
00:00007E10 5384            	  1340: 	subq.l #1,d4
00:00007E12 610000A6        	  1341: 	bsr DrawToXY
00:00007E16 705E            	  1342: 	moveq #94,d0							; page flip again
00:00007E18 4E4F            	  1343: 	trap #15
00:00007E1A 6000031C        	  1344: 	bra Monitor
                            	  1345: 
                            	  1346: Diagonal1:
00:00007E1E 42B900040894    	  1347: 	clr.l gr_x
00:00007E24 42B900040898    	  1348: 	clr.l gr_y
00:00007E2A 26390004089C    	  1349: 	move.l gr_width,d3
00:00007E30 5383            	  1350: 	subq.l #1,d3
00:00007E32 2839000408A0    	  1351: 	move.l gr_height,d4
00:00007E38 5384            	  1352: 	subq.l #1,d4
00:00007E3A 617E            	  1353: 	bsr DrawToXY
00:00007E3C 4E75            	  1354: 	rts
                            	  1355: 
                            	  1356: Diagonal2:
00:00007E3E 26390004089C    	  1357: 	move.l gr_width,d3
00:00007E44 5383            	  1358: 	subq.l #1,d3
00:00007E46 23C300040894    	  1359: 	move.l d3,gr_x
00:00007E4C 42B900040898    	  1360: 	clr.l gr_y
00:00007E52 2639000408A0    	  1361: 	move.l gr_height,d3
00:00007E58 5383            	  1362: 	subq.l #1,d3
00:00007E5A 7800            	  1363: 	moveq #0,d4
00:00007E5C 33FCE00100040890	  1364: 	move.w #$E001,pen_color
00:00007E64 6154            	  1365: 	bsr DrawToXY
00:00007E66 4E75            	  1366: 	rts
                            	  1367: 
                            	  1368: Vertical1:
00:00007E68 42B900040894    	  1369: 	clr.l gr_x
00:00007E6E 42B900040898    	  1370: 	clr.l gr_y
00:00007E74 7600            	  1371: 	move.l #0,d3
00:00007E76 2839000408A0    	  1372: 	move.l gr_height,d4
00:00007E7C 5384            	  1373: 	subq.l #1,d4
00:00007E7E 610000EA        	  1374: 	bsr DrawVertTo
00:00007E82 4E75            	  1375: 	rts
                            	  1376: 
                            	  1377: Vertical2:
00:00007E84 33FCE00100040890	  1378: 	move.w #$E001,pen_color		; green pen
00:00007E8C 23FC000000020004	  1379: 	move.l #2,gr_x
00:00007E94 0894
00:00007E96 42B900040898    	  1380: 	clr.l gr_y
00:00007E9C 7602            	  1381: 	move.l #2,d3
00:00007E9E 2839000408A0    	  1382: 	move.l gr_height,d4
00:00007EA4 5384            	  1383: 	subq.l #1,d4
00:00007EA6 610000C2        	  1384: 	bsr DrawVertTo
00:00007EAA 4E75            	  1385: 	rts
                            	  1386: 
                            	  1387: ;------------------------------------------------------------------------------
                            	  1388: ; Plot on bitmap screen using current pen color.
                            	  1389: ;
                            	  1390: ;	Parameters:
                            	  1391: ;		d1 = x co-ordinate
                            	  1392: ;		d2 = y co-ordinate
                            	  1393: ;------------------------------------------------------------------------------
                            	  1394: 	
                            	  1395: ;parameter OPBLACK = 4'd0;
                            	  1396: ;parameter OPCOPY = 4'd1;
                            	  1397: ;parameter OPINV = 4'd2;
                            	  1398: ;parameter OPAND = 4'd4;
                            	  1399: ;parameter OPOR = 4'd5;
                            	  1400: ;parameter OPXOR = 4'd6;
                            	  1401: ;parameter OPANDN = 4'd7;
                            	  1402: ;parameter OPNAND = 4'd8;
                            	  1403: ;parameter OPNOR = 4'd9;
                            	  1404: ;parameter OPXNOR = 4'd10;
                            	  1405: ;parameter OPORN = 4'd11;
                            	  1406: ;parameter OPWHITE = 4'd15;
                            	  1407: 
                            	  1408: ;------------------------------------------------------------------------------
                            	  1409: ; Set graphics cursor position.
                            	  1410: ;------------------------------------------------------------------------------
                            	  1411: 
                            	  1412: MoveToXY:
00:00007EAC 23C300040894    	  1413: 	move.l d3,gr_x
00:00007EB2 23C400040898    	  1414: 	move.l d4,gr_y
00:00007EB8 4E75            	  1415: 	rts
                            	  1416: 
                            	  1417: ;------------------------------------------------------------------------------
                            	  1418: ; Draw a line from the current graphics position to x1,y1.
                            	  1419: ;
                            	  1420: ; Register Usage:
                            	  1421: ;		d1 = x0
                            	  1422: ;		d2 = y0
                            	  1423: ;		d3 = x1
                            	  1424: ;		d4 = y1
                            	  1425: ;		d5 = dx
                            	  1426: ;		d6 = dy
                            	  1427: ;		d7 = sx
                            	  1428: ;		d0 = sy
                            	  1429: ;		a0 = err
                            	  1430: ;		a1 = 2*err
                            	  1431: ;------------------------------------------------------------------------------
                            	  1432: 
                            	  1433: DrawToXY:
00:00007EBA 48E7E7C0        	  1434: 	movem.l d0/d1/d2/d5/d6/d7/a0/a1,-(a7)
00:00007EBE 223900040894    	  1435: 	move.l gr_x,d1
00:00007EC4 243900040898    	  1436: 	move.l gr_y,d2
00:00007ECA 2A03            	  1437: 	move.l d3,d5
00:00007ECC 2C04            	  1438: 	move.l d4,d6
00:00007ECE 9A81            	  1439: 	sub.l d1,d5			; d5 = x1-x0
00:00007ED0 6608            	  1440: 	bne.s .notVert
00:00007ED2 4CDF03E7        	  1441: 	movem.l (a7)+,d0/d1/d2/d5/d6/d7/a0/a1
00:00007ED6 60000092        	  1442: 	bra DrawVertTo
                            	  1443: .notVert:
00:00007EDA 6A02            	  1444: 	bpl.s .0001
00:00007EDC 4485            	  1445: 	neg.l d5				
                            	  1446: .0001:						; d5 = dx = abs(x1-x0)
00:00007EDE 9C82            	  1447: 	sub.l d2,d6			; d6 = y1-y0
00:00007EE0 6606            	  1448: 	bne.s .notHoriz
00:00007EE2 4CDF03E7        	  1449: 	movem.l (a7)+,d0/d1/d2/d5/d6/d7/a0/a1
00:00007EE6 6050            	  1450: 	bra DrawHorizTo
                            	  1451: .notHoriz:
00:00007EE8 6B02            	  1452: 	bmi.s .0002
00:00007EEA 4486            	  1453: 	neg.l d6
                            	  1454: .0002:						; d6 = dy = -abs(y1-y0)
00:00007EEC 7E01            	  1455: 	move.l #1,d7		; d7 = sx (x0 < x1 ? 1 : -1)
00:00007EEE B681            	  1456: 	cmp.l d1,d3
00:00007EF0 6202            	  1457: 	bhi.s .0004
00:00007EF2 4487            	  1458: 	neg.l d7
                            	  1459: .0004:
00:00007EF4 7001            	  1460: 	move.l #1,d0		; d0 = sy (y0 < y1) ? 1 : -1)
00:00007EF6 B882            	  1461: 	cmp.l d2,d4
00:00007EF8 6202            	  1462: 	bhi.s .0006
00:00007EFA 4480            	  1463: 	neg.l d0
                            	  1464: .0006:
00:00007EFC 2045            	  1465: 	move.l d5,a0		; a0 = error = dx + dy
00:00007EFE D1C6            	  1466: 	adda.l d6,a0
                            	  1467: .loop:
00:00007F00 610089AC        	  1468: 	bsr CheckForCtrlC
00:00007F04 61009D18        	  1469: 	bsr plot				; plot(x0,y0)
00:00007F08 2248            	  1470: 	move.l a0,a1
00:00007F0A D3C9            	  1471: 	adda.l a1,a1		; a1 = error *2
00:00007F0C BC89            	  1472: 	cmp.l a1,d6			; e2 >= dy?
00:00007F0E 6E08            	  1473: 	bgt.s .0008
00:00007F10 B681            	  1474: 	cmp.l d1,d3			; x0==x1?
00:00007F12 6712            	  1475: 	beq.s .brkloop
00:00007F14 D1C6            	  1476: 	adda.l d6,a0		; err = err + dy
00:00007F16 D287            	  1477: 	add.l d7,d1			; x0 = x0 + sx
                            	  1478: .0008:
00:00007F18 BA89            	  1479: 	cmp.l a1,d5			; err2 <= dx?
00:00007F1A 6D08            	  1480: 	blt.s .0009
00:00007F1C B882            	  1481: 	cmp.l d2,d4			; y0==y1?
00:00007F1E 6706            	  1482: 	beq.s .brkloop
00:00007F20 D1C5            	  1483: 	adda.l d5,a0		; err = err + dx
00:00007F22 D480            	  1484: 	add.l d0,d2			; y0 = y0 + sy
                            	  1485: .0009:
00:00007F24 60DA            	  1486: 	bra.s .loop
                            	  1487: .brkloop:
00:00007F26 23C300040894    	  1488: 	move.l d3,gr_x
00:00007F2C 23C400040898    	  1489: 	move.l d4,gr_y
00:00007F32 4CDF03E7        	  1490: 	movem.l (a7)+,d0/d1/d2/d5/d6/d7/a0/a1
00:00007F36 4E75            	  1491: 	rts
                            	  1492: 
                            	  1493: ; Parameters:
                            	  1494: ;		d3 = x1
                            	  1495: ;		d4 = y1
                            	  1496: 
                            	  1497: DrawHorizTo:
00:00007F38 48E76400        	  1498: 	movem.l d1/d2/d5,-(a7)
00:00007F3C 7E06            	  1499: 	moveq #6,d7
00:00007F3E 7C17            	  1500: 	moveq #DEV_GET_OUTPOS,d6
00:00007F40 4E40            	  1501: 	trap #0
00:00007F42 7A01            	  1502: 	move.l #1,d5			; assume increment
00:00007F44 B681            	  1503: 	cmp.l d1,d3
00:00007F46 6202            	  1504: 	bhi.s .0001
00:00007F48 4485            	  1505: 	neg.l d5					; switch to decrement
                            	  1506: .0001:
00:00007F4A 7E06            	  1507: 	moveq #6,d7
00:00007F4C 7C12            	  1508: 	moveq #DEV_WRITEAT,d6
00:00007F4E 4E40            	  1509: 	trap #0
00:00007F50 B681            	  1510: 	cmp.l d1,d3
00:00007F52 670A            	  1511: 	beq.s .0002
00:00007F54 D285            	  1512: 	add.l d5,d1
00:00007F56 7E06            	  1513: 	moveq #6,d7
00:00007F58 7C07            	  1514: 	moveq #DEV_SET_OUTPOS,d6
00:00007F5A 4E40            	  1515: 	trap #0
00:00007F5C 60EC            	  1516: 	bra.s .0001
                            	  1517: .0002:
00:00007F5E 7E06            	  1518: 	moveq #6,d7
00:00007F60 7C07            	  1519: 	moveq #DEV_SET_OUTPOS,d6	; update output position
00:00007F62 4E40            	  1520: 	trap #0
00:00007F64 4CDF0026        	  1521: 	movem.l (a7)+,d1/d2/d5
00:00007F68 4E75            	  1522: 	rts
                            	  1523: 	
                            	  1524: 	
                            	  1525: ; Parameters:
                            	  1526: ;		d3 = x1
                            	  1527: ;		d4 = y1
                            	  1528: 
                            	  1529: DrawVertTo:
00:00007F6A 48E76400        	  1530: 	movem.l d1/d2/d5,-(a7)
00:00007F6E 223900040894    	  1531: 	move.l gr_x,d1
00:00007F74 243900040898    	  1532: 	move.l gr_y,d2
00:00007F7A 7A01            	  1533: 	move.l #1,d5			; assume increment
00:00007F7C B882            	  1534: 	cmp.l d2,d4
00:00007F7E 6202            	  1535: 	bhi.s .0001
00:00007F80 4485            	  1536: 	neg.l d5					; switch to decrement
                            	  1537: .0001:
00:00007F82 61009C9A        	  1538: 	bsr plot
00:00007F86 B882            	  1539: 	cmp.l d2,d4
00:00007F88 6704            	  1540: 	beq.s .0002
00:00007F8A D485            	  1541: 	add.l d5,d2
00:00007F8C 60F4            	  1542: 	bra.s .0001
                            	  1543: .0002:
00:00007F8E 23C200040898    	  1544: 	move.l d2,gr_y
00:00007F94 4CDF0026        	  1545: 	movem.l (a7)+,d1/d2/d5
00:00007F98 4E75            	  1546: 	rts
                            	  1547: 	
                            	  1548: 	
                            	  1549: ;plotLine(x0, y0, x1, y1)
                            	  1550: ;    dx = abs(x1 - x0)
                            	  1551: ;    sx = x0 < x1 ? 1 : -1
                            	  1552: ;    dy = -abs(y1 - y0)
                            	  1553: ;    sy = y0 < y1 ? 1 : -1
                            	  1554: ;    error = dx + dy
                            	  1555: ;    
                            	  1556: ;    while true
                            	  1557: ;        plot(x0, y0)
                            	  1558: ;        e2 = 2 * error
                            	  1559: ;        if e2 >= dy
                            	  1560: ;            if x0 == x1 break
                            	  1561: ;            error = error + dy
                            	  1562: ;            x0 = x0 + sx
                            	  1563: ;        end if
                            	  1564: ;        if e2 <= dx
                            	  1565: ;            if y0 == y1 break
                            	  1566: ;            error = error + dx
                            	  1567: ;            y0 = y0 + sy
                            	  1568: ;        end if
                            	  1569: ;    end while
                            	  1570:     
                            	  1571: ;------------------------------------------------------------------------------
                            	  1572: ; Cursor positioning / Clear screen
                            	  1573: ; - out of range settings are ignored
                            	  1574: ;
                            	  1575: ; Parameters:
                            	  1576: ;		d1.w cursor position, bits 0 to 7 are row, bits 8 to 15 are column.
                            	  1577: ;	Returns:
                            	  1578: ;		none
                            	  1579: ;------------------------------------------------------------------------------
                            	  1580: 
                            	  1581: Cursor1:
00:00007F9A 48E7F300        	  1582: 	movem.l d0/d1/d2/d3/d6/d7,-(a7)
00:00007F9E 0C41FF00        	  1583: 	cmpi.w #$FF00,d1
00:00007FA2 6616            	  1584: 	bne.s .0002
00:00007FA4 7E02            	  1585: 	moveq #2,d7
00:00007FA6 7C0C            	  1586: 	moveq #DEV_CLEAR,d6	; clear screen
00:00007FA8 4E40            	  1587: 	trap #0
00:00007FAA 7C07            	  1588: 	moveq #DEV_SET_OUTPOS,d6
00:00007FAC 7200            	  1589: 	moveq #0,d1
00:00007FAE 7400            	  1590: 	moveq #0,d2
00:00007FB0 7600            	  1591: 	moveq #0,d3
00:00007FB2 4E40            	  1592: 	trap #0
00:00007FB4 4CDF00CF        	  1593: 	movem.l (a7)+,d0/d1/d2/d3/d6/d7
00:00007FB8 4E75            	  1594: 	rts
                            	  1595: .0002:
00:00007FBA 7E02            	  1596: 	moveq #2,d7
00:00007FBC 7C07            	  1597: 	moveq #DEV_SET_OUTPOS,d6
00:00007FBE 7400            	  1598: 	clr.l d2
00:00007FC0 1401            	  1599: 	move.b d1,d2		; d2 = row (y pos)
00:00007FC2 E049            	  1600: 	lsr.w #8,d1			; d1 = col (x pos)
00:00007FC4 4881            	  1601: 	ext.w d1
00:00007FC6 48C1            	  1602: 	ext.l d1
00:00007FC8 7600            	  1603: 	moveq #0,d3
00:00007FCA 4E40            	  1604: 	trap #0
00:00007FCC 4CDF00CF        	  1605: 	movem.l (a7)+,d0/d1/d2/d3/d6/d7
00:00007FD0 4E75            	  1606: 	rts
                            	  1607: 
                            	  1608: ;------------------------------------------------------------------------------
                            	  1609: ; Stub routine for unimplemented functionality.
                            	  1610: ;------------------------------------------------------------------------------
                            	  1611: 
                            	  1612: StubRout:
00:00007FD2 4E75            	  1613: 	rts
                            	  1614: 
                            	  1615: ;------------------------------------------------------------------------------
                            	  1616: ; Select a specific IO focus.
                            	  1617: ;------------------------------------------------------------------------------
                            	  1618: 
                            	  1619: select_iofocus:
00:00007FD4 0C010002        	  1620: 	cmpi.b	#2,d1
00:00007FD8 650A            	  1621: 	blo.s		.0001
00:00007FDA 0C010005        	  1622: 	cmpi.b	#NCORES+1,d1
00:00007FDE 6204            	  1623: 	bhi.s		.0001
00:00007FE0 2001            	  1624: 	move.l	d1,d0
00:00007FE2 6014            	  1625: 	bra.s		select_focus1
                            	  1626: .0001:
00:00007FE4 4E75            	  1627: 	rts
                            	  1628: 
                            	  1629: ;------------------------------------------------------------------------------
                            	  1630: ; Rotate the IO focus, done when ALT-Tab is pressed.
                            	  1631: ;
                            	  1632: ; Modifies:
                            	  1633: ;		d0, IOFocus BIOS variable
                            	  1634: ;		updates the text screen pointer
                            	  1635: ;------------------------------------------------------------------------------
                            	  1636: 
                            	  1637: rotate_iofocus:
00:00007FE6 103900100000    	  1638: 	move.b IOFocus,d0					; d0 = focus, we can trash d0
00:00007FEC 5200            	  1639: 	add.b	#1,d0								; increment the focus
00:00007FEE B03C0005        	  1640: 	cmp.b	#NCORES+1,d0				; limit to 2 to 9
00:00007FF2 6304            	  1641: 	bls.s	.0001
00:00007FF4 103C0002        	  1642: 	move.b #2,d0
                            	  1643: .0001:
                            	  1644: select_focus1:
00:00007FF8 13C000100000    	  1645: 	move.b	d0,IOFocus				; set IO focus
                            	  1646: 	; reset keyboard processor to focus core
                            	  1647: ;	move.l #$3C060500,d0			; core=??,level sensitive,enabled,irq6,inta
                            	  1648: ;	or.b IOFocus,d0
                            	  1649: ;	move.l d0,PLIC+$80+4*30		; set register
                            	  1650: 	; Adjust text screen pointer
00:00007FFE 5500            	  1651: 	subi.b #2,d0							; screen is 0 to 7, focus is 2 to 9
00:00008000 4880            	  1652: 	ext.w	d0									; make into word value
00:00008002 C0FC0800        	  1653: 	mulu #2048,d0							; * 2048	cells per screen
00:00008006 E158            	  1654: 	rol.w	#8,d0								; swap byte order
00:00008008 4840            	  1655: 	swap d0										; get bits 16-31
00:0000800A E158            	  1656: 	rol.w	#8,d0								; swap byte order
00:0000800C 23C0FD080028    	  1657: 	move.l d0,TEXTREG+$28			; update screen address in text controller
00:00008012 600094BC        	  1658: 	bra	SyncCursor						; set cursor position
                            	  1659: 
                            	  1660: ;==============================================================================
                            	  1661: ; PLIC - platform level interrupt controller
                            	  1662: ;
                            	  1663: ; Register layout:
                            	  1664: ;   bits 0 to 7  = cause code to issue (vector number)
                            	  1665: ;   bits 8 to 11 = irq level to issue
                            	  1666: ;   bit 16 = irq enable
                            	  1667: ;   bit 17 = edge sensitivity
                            	  1668: ;   bit 18 = 0=vpa, 1=inta
                            	  1669: ;		bit 24 to 29 target core
                            	  1670: ;
                            	  1671: ; Note byte order must be reversed for PLIC.
                            	  1672: ;==============================================================================
                            	  1673: 
                            	  1674: init_plic:
00:00008016 41F9FD090000    	  1675: 	lea	PLIC,a0							; a0 points to PLIC
00:0000801C 43E800F4        	  1676: 	lea	$80+4*29(a0),a1			; point to timer registers (29)
00:00008020 22BC0006033F    	  1677: 	move.l #$0006033F,(a1)	; initialize, core=63,edge sensitive,enabled,irq6,vpa
00:00008026 5889            	  1678: 	lea	4(a1),a1						; point to keyboard registers (30)
00:00008028 22BC3C060502    	  1679: 	move.l #$3C060502,(a1)	; core=2,level sensitive,enabled,irq6,inta
00:0000802E 5889            	  1680: 	lea	4(a1),a1						; point to nmi button register (31)
00:00008030 22BC00070302    	  1681: 	move.l #$00070302,(a1)	; initialize, core=2,edge sensitive,enabled,irq7,vpa
00:00008036 43E800C0        	  1682: 	lea	$80+4*16(a0),a1			; a1 points to ACIA register
00:0000803A 22BC3D030502    	  1683: 	move.l #$3D030502,(a1)	; core=2,level sensitive,enabled,irq3,inta	
00:00008040 43E80090        	  1684: 	lea	$80+4*4(a0),a1			; a1 points to io_bitmap irq
00:00008044 22BC3B060702    	  1685: 	move.l #$3B060702,(a1)	; core=2,edge sensitive,enabled,irq6,inta	
00:0000804A 4E75            	  1686: 	rts
                            	  1687: 
                            	  1688: 
                            	  1689: ;==============================================================================
                            	  1690: ;==============================================================================
                            	  1691: ; Monitor
                            	  1692: ;==============================================================================
                            	  1693: ;==============================================================================
                            	  1694: 
                            	  1695: cmdString:
00:0000804C BF              	  1696: 	dc.b	'?'+$80						; ? display help
00:0000804D 41              	  1697: 	dc.b	'A','S'+$80				; AS = asteroids
00:0000804E D3
00:0000804F CC              	  1698: 	dc.b	'L'+$80						; L load S19 file
00:00008050 46              	  1699: 	dc.b	'F','B'+$80				; FB fill with byte
00:00008051 C2
00:00008052 46              	  1700: 	dc.b	'F','W'+$80				; FW fill with wyde
00:00008053 D7
00:00008054 46              	  1701: 	dc.b	'F','L'+$80				; FL fill with long wyde
00:00008055 CC
00:00008056 464D54          	  1702: 	dc.b	'FMT','K'+$80			; FMTK run Femtiki OS
00:00008059 CB
00:0000805A 42              	  1703: 	dc.b	'B','A'+$80				; BA start Tiny Basic
00:0000805B C1
00:0000805C 42              	  1704: 	dc.b	'B','R'+$80				; BR breakpoint
00:0000805D D2
00:0000805E 44              	  1705: 	dc.b	'D','I'+$80				; DI disassemble
00:0000805F C9
00:00008060 44              	  1706: 	dc.b	'D','R'+$80				; DR dump registers
00:00008061 D2
00:00008062 C4              	  1707: 	dc.b	'D'+$80						; D dump memory
00:00008063 CA              	  1708: 	dc.b	'J'+$80						; J jump to code
00:00008064 C5              	  1709: 	dc.b	'E'+$80						; : edit memory
00:00008065 434C            	  1710: 	dc.b	"CL",'S'+$80			; CLS clear screen
00:00008067 D3
00:00008068 434F52          	  1711: 	dc.b	"COR",'E'+$80			; CORE <n> switch to core
00:0000806B C5
00:0000806C 5446            	  1712: 	dc.b	"TF",'P'+$80			; TFP test fp
00:0000806E D0
00:0000806F 5447            	  1713: 	dc.b  "TG",'F'+$80			; TGF test get float
00:00008071 C6
00:00008072 545241          	  1714: 	dc.b  "TRA",'M'+$80			; TRAM test RAM
00:00008075 CD
00:00008076 54              	  1715: 	dc.b	'T','R'+$80				; TR test serial receive
00:00008077 D2
00:00008078 D4              	  1716: 	dc.b	'T'+$80						; T test CPU
00:00008079 D3              	  1717: 	dc.b	'S'+$80						; S send serial
00:0000807A 52455345        	  1718: 	dc.b	"RESE",'T'+$80		; RESET <n>
00:0000807E D4
00:0000807F 434C4F43        	  1719: 	dc.b	"CLOC",'K'+$80		; CLOCK <n>
00:00008083 CB
00:00008084 D2              	  1720: 	dc.b	'R'+$80						; R receive serial
00:00008085 D6              	  1721: 	dc.b	'V'+$80
00:00008086 47              	  1722: 	dc.b	'G','R'+$80				; graphics demo
00:00008087 D2
00:00008088 70              	  1723: 	dc.b	'p','l','a','n','t','s'+$80	; plants
00:00008089 6C
00:0000808A 61
00:0000808B 6E
00:0000808C 74
00:0000808D F3
00:0000808E 00              	  1724: 	dc.b	0,0
00:0000808F 00
                            	  1725: grCmdString:
00:00008090 43              	  1726: 	dc.b	'C','D'+$80				; set color depth
00:00008091 C4
00:00008092 4C494E          	  1727: 	dc.b	'LIN','E'+$80			; draw line
00:00008095 C5
00:00008096 524543          	  1728: 	dc.b	'REC','T'+$80			; draw rectangle
00:00008099 D4
00:0000809A 5452            	  1729: 	dc.b	'TR','I'+$80			; draw triangle
00:0000809C C9
00:0000809D 43555256        	  1730: 	dc.b	'CURV','E'+$80		; draw curve
00:000080A1 C5
00:000080A2 504F494E        	  1731: 	dc.b	'POIN','T'+$80		; plot point
00:000080A6 D4
00:000080A7 434F4C4F        	  1732: 	dc.b	'COLO','R'+$80		; set color
00:000080AB D2
00:000080AC 00              	  1733: 	dc.b	0,0
00:000080AD 00
                            	  1734: 
                            	  1735: 	align	2
                            	  1736: cmdTable:
00:000080B0 000083CA        	  1737: 	dc.l	cmdHelp
00:000080B4 00008240        	  1738: 	dc.l	cmdAsteroids
00:000080B8 00009502        	  1739: 	dc.l	cmdLoadS19
00:000080BC 0000869C        	  1740: 	dc.l	cmdFillB
00:000080C0 000086F0        	  1741: 	dc.l	cmdFillW
00:000080C4 00008744        	  1742: 	dc.l	cmdFillL
00:000080C8 00008296        	  1743: 	dc.l	cmdFMTK
00:000080CC 00008252        	  1744: 	dc.l	cmdTinyBasic
00:000080D0 0000821C        	  1745: 	dc.l	cmdBreakpoint
00:000080D4 00008BFE        	  1746: 	dc.l	cmdDisassemble
00:000080D8 00008D1A        	  1747: 	dc.l	cmdDumpRegs
00:000080DC 00008C4E        	  1748: 	dc.l	cmdDumpMemory
00:000080E0 00008864        	  1749: 	dc.l	cmdJump
00:000080E4 000087F0        	  1750: 	dc.l	cmdEditMemory
00:000080E8 00008266        	  1751: 	dc.l	cmdClearScreen
00:000080EC 00008272        	  1752: 	dc.l	cmdCore
00:000080F0 000082A0        	  1753: 	dc.l  cmdTestFP
00:000080F4 0000832C        	  1754: 	dc.l	cmdTestGF
00:000080F8 0000943A        	  1755: 	dc.l  cmdTestRAM
00:000080FC 00008DC4        	  1756: 	dc.l	cmdTestSerialReceive
00:00008100 00008256        	  1757: 	dc.l	cmdTestCPU
00:00008104 00008638        	  1758: 	dc.l	cmdSendSerial
00:00008108 00008378        	  1759: 	dc.l	cmdReset
00:0000810C 0000835A        	  1760: 	dc.l	cmdClock
00:00008110 00008668        	  1761: 	dc.l	cmdReceiveSerial	
00:00008114 000081DA        	  1762: 	dc.l	cmdVideoMode
00:00008118 00008874        	  1763: 	dc.l	cmdGrDemo
00:0000811C 00008248        	  1764: 	dc.l	cmdPlants
00:00008120 00008138        	  1765: 	dc.l	cmdMonitor
                            	  1766: 
                            	  1767: ; Get a word from screen memory and swap byte order
                            	  1768: 
                            	  1769: FromScreen:
00:00008124 2210            	  1770: 	move.l (a0),d1
00:00008126 610015FC        	  1771: 	bsr	rbo
                            	  1772: 	if (SCREEN_FORMAT==1)
00:0000812A 5888            	  1773: 		lea	4(a0),a0	; increment screen pointer
                            	  1774: 	else
                            	  1775: 		lea	8(a0),a0	; increment screen pointer
                            	  1776: 	endif
00:0000812C 4E75            	  1777: 	rts
                            	  1778: 
                            	  1779: StartMon:
00:0000812E 427900040202    	  1780: 	clr.w	NumSetBreakpoints
00:00008134 61001920        	  1781: 	bsr	ClearBreakpointList
                            	  1782: cmdMonitor:
                            	  1783: Monitor:
                            	  1784: 	; Reset the stack pointer on each entry into the monitor
00:00008138 2E7C00047FFC    	  1785: 	move.l #$47FFC,sp		; reset core's stack
00:0000813E 487AFFF8        	  1786: 	pea Monitor					; Cause any RTS to go here
00:00008142 46FC2200        	  1787: 	move.w #$2200,sr		; enable level 2 and higher interrupts
00:00008146 4E7A0FE0        	  1788: 	movec	coreno,d0
00:0000814A 4840            	  1789: 	swap d0
00:0000814C 7201            	  1790: 	moveq	#1,d1
00:0000814E 6100A46A        	  1791: 	bsr	UnlockSemaphore
00:00008152 42390004000C    	  1792: 	clr.b KeybdEcho			; turn off keyboard echo
                            	  1793: PromptLn:
00:00008158 6100F970        	  1794: 	bsr	CRLF
00:0000815C 123C0024        	  1795: 	move.b #'$',d1
00:00008160 61001A28        	  1796: 	bsr OutputChar
                            	  1797: 
                            	  1798: ; Get characters until a CR is keyed
                            	  1799: ;
                            	  1800: Prompt3:
00:00008164 6100870E        	  1801: 	bsr	GetKey
00:00008168 0C0100FF        	  1802: 	cmpi.b #-1,d1
00:0000816C 67F6            	  1803: 	beq.s	Prompt3
00:0000816E 0C01000D        	  1804: 	cmpi.b #CR,d1
00:00008172 6706            	  1805: 	beq.s	Prompt1
00:00008174 61001A14        	  1806: 	bsr	OutputChar
00:00008178 60EA            	  1807: 	bra.s	Prompt3
                            	  1808: 
                            	  1809: ; Process the screen line that the CR was keyed on
                            	  1810: 
                            	  1811: Prompt1:
00:0000817A 7E02            	  1812: 	moveq #2,d7
00:0000817C 7C17            	  1813: 	moveq #DEV_GET_OUTPOS,d6
00:0000817E 4E40            	  1814: 	trap #0
                            	  1815: ;	clr.b	CursorCol				; go back to the start of the line
00:00008180 7C07            	  1816: 	moveq #DEV_SET_OUTPOS,d6
00:00008182 7200            	  1817: 	moveq #0,d1						; go back to the start of the line
00:00008184 4E40            	  1818: 	trap #0
00:00008186 7C18            	  1819: 	moveq #DEV_GET_OUTPTR,d6
00:00008188 4E40            	  1820: 	trap #0
00:0000818A 2041            	  1821: 	move.l d1,a0					; a0 = pointer to buffer
                            	  1822: ;	bsr	CalcScreenLoc			; a0 = screen memory location
                            	  1823: .0001:
00:0000818C 6196            	  1824: 	bsr	FromScreen				; grab character off screen
00:0000818E 0C010024        	  1825: 	cmpi.b #'$',d1				; skip over '$' prompt character
00:00008192 67F8            	  1826: 	beq.s	.0001
                            	  1827: 
                            	  1828: ; Dispatch based on command string
                            	  1829: 
                            	  1830: cmdDispatch:
00:00008194 45FAFEB6        	  1831: 	lea	cmdString,a2
00:00008198 7800            	  1832: 	clr.l	d4							; command counter
                            	  1833: 	if (SCREEN_FORMAT==1)
00:0000819A 5988            	  1834: 		lea	-4(a0),a0				; backup a character
                            	  1835: 	else
                            	  1836: 		lea	-8(a0),a0				; backup a character
                            	  1837: 	endif
00:0000819C 2648            	  1838: 	move.l	a0,a3					; a3 = start of command on screen
                            	  1839: .checkNextCmd:
00:0000819E 6184            	  1840: 	bsr	FromScreen				; d1 = char from input screen
00:000081A0 1A1A            	  1841: 	move.b (a2)+,d5
00:000081A2 BB01            	  1842: 	eor.b	d5,d1						; does it match with command string?
00:000081A4 67F8            	  1843: 	beq.s	.checkNextCmd		; If it does, keep matching for longest match
00:000081A6 0C010080        	  1844: 	cmpi.b #$80,d1				; didn't match, was it the end of the command?
00:000081AA 6724            	  1845: 	beq.s	.foundCmd
00:000081AC 4A2AFFFF        	  1846: 	tst.b	-1(a2)					; was end of table hit?
00:000081B0 6712            	  1847: 	beq.s	.endOfTable
00:000081B2 5844            	  1848: 	addi.w #4,d4					; increment command counter
00:000081B4 204B            	  1849: 	move.l a3,a0					; reset input pointer
00:000081B6 4A2AFFFF        	  1850: 	tst.b	-1(a2)					; were we at the end of the command?
00:000081BA 6BE2            	  1851: 	bmi.s	.checkNextCmd		; if were at end continue, otherwise scan for end of cmd
                            	  1852: .scanToEndOfCmd
00:000081BC 4A1A            	  1853: 	tst.b	(a2)+						; scan to end of command
00:000081BE 6704            	  1854: 	beq.s	.endOfTable
00:000081C0 6AFA            	  1855: 	bpl.s	.scanToEndOfCmd
00:000081C2 6BDA            	  1856: 	bmi.s	.checkNextCmd
                            	  1857: .endOfTable
00:000081C4 43FA03AD        	  1858: 	lea	msgUnknownCmd,a1
00:000081C8 6100F930        	  1859: 	bsr	DisplayStringCRLF
00:000081CC 6000FF6A        	  1860: 	bra	Monitor
                            	  1861: .foundCmd:
00:000081D0 43FAFEDE        	  1862: 	lea	cmdTable,a1				; a1 = pointer to command address table
00:000081D4 22714000        	  1863: 	move.l (a1,d4.w),a1		; fetch command routine address from table
00:000081D8 4ED1            	  1864: 	jmp	(a1)							; go execute command
                            	  1865: 
                            	  1866: cmdVideoMode:
00:000081DA 610005B4        	  1867: 	bsr ignBlanks
00:000081DE 61000C08        	  1868: 	bsr GetHexNumber
00:000081E2 4A01            	  1869: 	cmpi.b #0,d1
00:000081E4 660E            	  1870: 	bne.s .0001
00:000081E6 6100F87C        	  1871: 	bsr set_text_mode
00:000081EA 7E02            	  1872: 	move.l #2,d7
00:000081EC 7C0C            	  1873: 	move.l #DEV_CLEAR,d6
00:000081EE 4E40            	  1874: 	trap #0
00:000081F0 6000FF46        	  1875: 	bra Monitor
                            	  1876: .0001:
00:000081F4 6100F898        	  1877: 	bsr set_graphics_mode
00:000081F8 6100F8BE        	  1878: 	bsr get_screen_address
00:000081FC 42B9FD0FFD04    	  1879: 	move.l #0,RAND+4		; select stream 0
00:00008202 343C1D4B        	  1880: 	move.w #7499,d2
                            	  1881: .0002:
00:00008206 2239FD0FFD00    	  1882: 	move.l RAND,d1
00:0000820C 42B9FD0FFD00    	  1883: 	move.l #0,RAND			; cause new number generation
00:00008212 20C1            	  1884: 	move.l d1,(a0)+			; random display
00:00008214 51CAFFF0        	  1885: 	dbra d2,.0002
00:00008218 6000FF1E        	  1886: 	bra Monitor
                            	  1887: 
                            	  1888: cmdBreakpoint:
00:0000821C 61000572        	  1889: 	bsr	ignBlanks
00:00008220 6100FF02        	  1890: 	bsr	FromScreen
00:00008224 0C01002B        	  1891: 	cmpi.b	#'+',d1
00:00008228 6700173A        	  1892: 	beq	ArmBreakpoint
00:0000822C 0C01002D        	  1893: 	cmpi.b	#'-',d1
00:00008230 670017B0        	  1894: 	beq	DisarmBreakpoint
00:00008234 0C01004C        	  1895: 	cmpi.b	#'L',d1
00:00008238 670017FC        	  1896: 	beq	ListBreakpoints
00:0000823C 6000FEFA        	  1897: 	bra	Monitor
                            	  1898: 
                            	  1899: cmdAsteroids:
00:00008240 487AFEF6        	  1900: 	pea Monitor
00:00008244 600028E4        	  1901: 	jmp asteroids_start
                            	  1902: 
                            	  1903: cmdPlants:
00:00008248 487AFEEE        	  1904: 	pea Monitor
00:0000824C 4EF900020000    	  1905: 	jmp start_plants
                            	  1906: 
                            	  1907: cmdTinyBasic:
00:00008252 6000DF70        	  1908: 	bra	CSTART
                            	  1909: 
                            	  1910: cmdTestCPU:
00:00008256 6100A3FC        	  1911: 	bsr	cpu_test
00:0000825A 43FA1B0D        	  1912: 	lea	msg_test_done,a1
00:0000825E 6100F89A        	  1913: 	bsr	DisplayStringCRLF
00:00008262 6000FED4        	  1914: 	bra	Monitor
                            	  1915: 
                            	  1916: cmdClearScreen:
00:00008266 610014B4        	  1917: 	bsr	ClearScreen
00:0000826A 61009252        	  1918: 	bsr	HomeCursor
00:0000826E 6000FEC8        	  1919: 	bra	Monitor
                            	  1920: 
                            	  1921: cmdCore:
00:00008272 6100051C        	  1922: 	bsr			ignBlanks
00:00008276 6100FEAC        	  1923: 	bsr			FromScreen
00:0000827A 0C010032        	  1924: 	cmpi.b	#'2',d1					; check range
00:0000827E 6500FEB8        	  1925: 	blo			Monitor
00:00008282 0C010035        	  1926: 	cmpi.b	#'0'+NCORES+1,d1
00:00008286 6200FEB0        	  1927: 	bhi			Monitor
00:0000828A 04010030        	  1928: 	subi.b	#'0',d1					; convert ascii to binary
00:0000828E 6100FD44        	  1929: 	bsr			select_iofocus
00:00008292 6000FEA4        	  1930: 	bra			Monitor
                            	  1931: 
                            	  1932: cmdFMTK:
00:00008296 4EB900000220    	  1933: 	bsr FemtikiInit
00:0000829C 6000FE9A        	  1934: 	bra Monitor
                            	  1935: 
                            	  1936: cmdTestFP:
00:000082A0 7029            	  1937: 	moveq #41,d0						; function #41, get float
00:000082A2 7208            	  1938: 	moveq #8,d1							; d1 = input stride
00:000082A4 2248            	  1939: 	move.l a0,a1						; a1 = pointer to input buffer
00:000082A6 4E4F            	  1940: 	trap #15
00:000082A8 2049            	  1941: 	move.l a1,a0
00:000082AA F2000200        	  1942: 	fmove.x fp0,fp4
00:000082AE 610004E0        	  1943: 	bsr ignBlanks
00:000082B2 6100FE70        	  1944: 	bsr FromScreen
00:000082B6 1E01            	  1945: 	move.b d1,d7
00:000082B8 7029            	  1946: 	moveq #41,d0						; function #41, get float
00:000082BA 7208            	  1947: 	move.l #8,d1						; d1 = input stride
00:000082BC 2248            	  1948: 	move.l a0,a1						; a1 = pointer to input buffer
00:000082BE 4E4F            	  1949: 	trap #15
00:000082C0 2049            	  1950: 	move.l a1,a0
00:000082C2 F2000100        	  1951: 	fmove.x fp0,fp2
00:000082C6 6100F802        	  1952: 	bsr CRLF
                            	  1953: ;	moveq #39,d0
                            	  1954: ;	moveq #40,d1
                            	  1955: ;	moveq #30,d2
                            	  1956: ;	moveq #'e',d3
                            	  1957: ;	trap #15
                            	  1958: ;	bsr CRLF
00:000082CA F2396A00000402C0	  1959: 	fmove.x fp4,fpBuf
00:000082D2 F2396900000402D0	  1960: 	fmove.x fp2,fpBuf+16
00:000082DA 0C07002B        	  1961: 	cmpi.b #'+',d7
00:000082DE 6606            	  1962: 	bne .0001
00:000082E0 F2000A22        	  1963: 	fadd fp2,fp4
00:000082E4 6022            	  1964: 	bra .0002
                            	  1965: .0001
00:000082E6 0C07002D        	  1966: 	cmpi.b #'-',d7
00:000082EA 6606            	  1967: 	bne .0003
00:000082EC F2000A28        	  1968: 	fsub fp2,fp4
00:000082F0 6016            	  1969: 	bra .0002
                            	  1970: .0003
00:000082F2 0C07002A        	  1971: 	cmpi.b #'*',d7
00:000082F6 6606            	  1972: 	bne .0004
00:000082F8 F2000A23        	  1973: 	fmul fp2,fp4
00:000082FC 600A            	  1974: 	bra .0002
                            	  1975: .0004
00:000082FE 0C07002F        	  1976: 	cmpi.b #'/',d7
00:00008302 6620            	  1977: 	bne .0005
00:00008304 F2000A20        	  1978: 	fdiv fp2,fp4
                            	  1979: 	bra .0002
                            	  1980: .0002
00:00008308 F2396A00000402E0	  1981: 	fmove.x fp4,fpBuf+32
00:00008310 F2001000        	  1982: 	fmove.x fp4,fp0
00:00008314 43F900040520    	  1983: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
00:0000831A 7027            	  1984: 	moveq #39,d0						; function #39 print float
00:0000831C 7228            	  1985: 	moveq #40,d1						; width
00:0000831E 741E            	  1986: 	moveq #30,d2						; precision
00:00008320 7665            	  1987: 	moveq #'e',d3
00:00008322 4E4F            	  1988: 	trap #15
                            	  1989: .0005
00:00008324 6100F7A4        	  1990: 	bsr CRLF
00:00008328 6000FE0E        	  1991: 	bra Monitor
                            	  1992: 
                            	  1993: cmdTestGF:
00:0000832C 6100F79C        	  1994: 	bsr CRLF
00:00008330 7029            	  1995: 	moveq #41,d0						; function #41, get float
00:00008332 7208            	  1996: 	move.l #8,d1						; d1 = input stride
00:00008334 2248            	  1997: 	move.l a0,a1						; a1 = pointer to input buffer
00:00008336 4E4F            	  1998: 	trap #15
00:00008338 F2396800000402E0	  1999: 	fmove.x fp0,fpBuf+32
00:00008340 43F900040520    	  2000: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
00:00008346 7027            	  2001: 	moveq #39,d0
00:00008348 7228            	  2002: 	moveq #40,d1
00:0000834A 741E            	  2003: 	moveq #30,d2
00:0000834C 7665            	  2004: 	moveq #'e',d3
00:0000834E 4E4F            	  2005: 	trap #15
00:00008350 2049            	  2006: 	move.l a1,a0
00:00008352 6100F776        	  2007: 	bsr CRLF
00:00008356 6000FDE0        	  2008: 	bra Monitor
                            	  2009: 		
                            	  2010: ;-------------------------------------------------------------------------------
                            	  2011: ; CLOCK <n>
                            	  2012: ;    Set the clock register to n which will turn off or on clocks to the CPUs.
                            	  2013: ;-------------------------------------------------------------------------------
                            	  2014: 
                            	  2015: cmdClock:
00:0000835A 61000434        	  2016: 	bsr			ignBlanks
00:0000835E 61000A88        	  2017: 	bsr			GetHexNumber
00:00008362 4A00            	  2018: 	tst.b		d0							; was there a number?
00:00008364 6700FDD2        	  2019: 	beq			Monitor
00:00008368 00400004        	  2020: 	ori.w		#4,d0						; primary core's clock cannot be turned off
00:0000836C E159            	  2021: 	rol.w		#8,d1						; switch byte order
00:0000836E 33C1FD0FFC02    	  2022: 	move.w	d1,RST_REG+2
00:00008374 6000FDC2        	  2023: 	bra			Monitor
                            	  2024: 
                            	  2025: ;-------------------------------------------------------------------------------
                            	  2026: ; RESET <n>
                            	  2027: ;    Reset the specified core. Resetting the core automatically turns on the 
                            	  2028: ; core's clock.
                            	  2029: ;-------------------------------------------------------------------------------
                            	  2030: 
                            	  2031: cmdReset:
00:00008378 61000416        	  2032: 	bsr			ignBlanks
00:0000837C 6100FDA6        	  2033: 	bsr			FromScreen
00:00008380 0C010032        	  2034: 	cmpi.b	#'2',d1					; check range
00:00008384 6500FDB2        	  2035: 	blo			Monitor
00:00008388 0C010039        	  2036: 	cmpi.b	#'9',d1
00:0000838C 6200FDAA        	  2037: 	bhi			Monitor
00:00008390 04010030        	  2038: 	subi.b	#'0',d1					; convert ascii to binary
00:00008394 E349            	  2039: 	lsl.w		#1,d1						; make into index
00:00008396 43FA0012        	  2040: 	lea			tblPow2,a1
00:0000839A 32311000        	  2041: 	move.w	(a1,d1.w),d1
00:0000839E E159            	  2042: 	rol.w		#8,d1						; reverse byte order
00:000083A0 33C1FD0FFC00    	  2043: 	move.w	d1,RST_REG
00:000083A6 6000FD90        	  2044: 	bra			Monitor
                            	  2045: 
                            	  2046: tblPow2:
00:000083AA 0001            	  2047: 	dc.w		1
00:000083AC 0002            	  2048: 	dc.w		2
00:000083AE 0004            	  2049: 	dc.w		4
00:000083B0 0008            	  2050: 	dc.w		8
00:000083B2 0010            	  2051: 	dc.w		16
00:000083B4 0020            	  2052: 	dc.w		32
00:000083B6 0040            	  2053: 	dc.w		64
00:000083B8 0080            	  2054: 	dc.w		128
00:000083BA 0100            	  2055: 	dc.w		256
00:000083BC 0200            	  2056: 	dc.w		512
00:000083BE 0400            	  2057: 	dc.w		1024
00:000083C0 0800            	  2058: 	dc.w		2048
00:000083C2 1000            	  2059: 	dc.w		4096
00:000083C4 2000            	  2060: 	dc.w		8192
00:000083C6 4000            	  2061: 	dc.w		16384
00:000083C8 8000            	  2062: 	dc.w		32768
                            	  2063: 	even
                            	  2064: 	
                            	  2065: cmdHelp:
                            	  2066: DisplayHelp:
00:000083CA 43FA000A        	  2067: 	lea			HelpMsg,a1
00:000083CE 6100F714        	  2068: 	bsr			DisplayString
00:000083D2 6000FD64        	  2069: 	bra			Monitor
                            	  2070: 
                            	  2071: HelpMsg:
00:000083D6 3F203D2044697370	  2072: 	dc.b	"? = Display help",LF,CR
00:000083DE 6C61792068656C70
00:000083E6 0A
00:000083E7 0D
00:000083E8 434F5245206E203D	  2073: 	dc.b  "CORE n = switch to core n, n = 2 to 9",LF,CR
00:000083F0 2073776974636820
00:000083F8 746F20636F726520
00:00008400 6E2C206E203D2032
00:00008408 20746F2039
00:0000840D 0A
00:0000840E 0D
00:0000840F 5245534554206E20	  2074: 	dc.b  "RESET n = reset core n",LF,CR
00:00008417 3D20726573657420
00:0000841F 636F7265206E
00:00008425 0A
00:00008426 0D
00:00008427 434C53203D20636C	  2075: 	dc.b	"CLS = clear screen",LF,CR
00:0000842F 6561722073637265
00:00008437 656E
00:00008439 0A
00:0000843A 0D
00:0000843B 4542203D20456469	  2076: 	dc.b	"EB = Edit memory bytes, EW, EL",LF,CR
00:00008443 74206D656D6F7279
00:0000844B 2062797465732C20
00:00008453 45572C20454C
00:00008459 0A
00:0000845A 0D
00:0000845B 4642203D2046696C	  2077: 	dc.b	"FB = Fill memory bytes, FW, FL",LF,CR
00:00008463 6C206D656D6F7279
00:0000846B 2062797465732C20
00:00008473 46572C20464C
00:00008479 0A
00:0000847A 0D
00:0000847B 464D544B203D2072	  2078: 	dc.b	"FMTK = run Femtiki OS",LF,CR
00:00008483 756E2046656D7469
00:0000848B 6B69204F53
00:00008490 0A
00:00008491 0D
00:00008492 4752203D20477261	  2079: 	dc.b	"GR = Graphics command",LF,CR
00:0000849A 706869637320636F
00:000084A2 6D6D616E64
00:000084A7 0A
00:000084A8 0D
00:000084A9 4C203D204C6F6164	  2080: 	dc.b	"L = Load S19 file",LF,CR
00:000084B1 205331392066696C
00:000084B9 65
00:000084BA 0A
00:000084BB 0D
00:000084BC 44203D2044756D70	  2081: 	dc.b	"D = Dump memory, DR = dump registers",LF,CR
00:000084C4 206D656D6F72792C
00:000084CC 204452203D206475
00:000084D4 6D70207265676973
00:000084DC 74657273
00:000084E0 0A
00:000084E1 0D
00:000084E2 4449203D20446973	  2082: 	dc.b	"DI = Disassemble",LF,CR
00:000084EA 617373656D626C65
00:000084F2 0A
00:000084F3 0D
00:000084F4 4241203D20737461	  2083: 	dc.b	"BA = start tiny basic",LF,CR
00:000084FC 72742074696E7920
00:00008504 6261736963
00:00008509 0A
00:0000850A 0D
00:0000850B 4252203D20736574	  2084: 	dc.b  "BR = set breakpoint",LF,CR
00:00008513 20627265616B706F
00:0000851B 696E74
00:0000851E 0A
00:0000851F 0D
00:00008520 4A203D204A756D70	  2085: 	dc.b	"J = Jump to code",LF,CR
00:00008528 20746F20636F6465
00:00008530 0A
00:00008531 0D
00:00008532 53203D2073656E64	  2086: 	dc.b  "S = send to serial port",LF,CR
00:0000853A 20746F2073657269
00:00008542 616C20706F7274
00:00008549 0A
00:0000854A 0D
00:0000854B 54203D2063707520	  2087: 	dc.b	"T = cpu test program",LF,CR
00:00008553 746573742070726F
00:0000855B 6772616D
00:0000855F 0A
00:00008560 0D
00:00008561 5452414D203D2074	  2088: 	dc.b	"TRAM = test RAM",LF,CR,0
00:00008569 6573742052414D
00:00008570 0A
00:00008571 0D
00:00008572 00
                            	  2089: 
                            	  2090: msgUnknownCmd:
00:00008573 636F6D6D616E6420	  2091: 	dc.b	"command unknown",0
00:0000857B 756E6B6E6F776E
00:00008582 00
                            	  2092: 
                            	  2093: msgHello:
00:00008583 0A              	  2094: 	dc.b	LF,CR,"Hello World!",LF,CR,0
00:00008584 0D
00:00008585 48656C6C6F20576F
00:0000858D 726C6421
00:00008591 0A
00:00008592 0D
00:00008593 00
                            	  2095: 	even
                            	  2096: 
                            	  2097: ;------------------------------------------------------------------------------
                            	  2098: ; This routine borrowed from Gordo's Tiny Basic interpreter.
                            	  2099: ; Used to fetch a command line. (Not currently used).
                            	  2100: ;
                            	  2101: ; d0.b	- command prompt
                            	  2102: ;------------------------------------------------------------------------------
                            	  2103: 
                            	  2104: GetCmdLine:
00:00008594 610015F4        	  2105: 		bsr		OutputChar		; display prompt
00:00008598 103C0020        	  2106: 		move.b	#' ',d0
00:0000859C 610015EC        	  2107: 		bsr		OutputChar
00:000085A0 41F900040040    	  2108: 		lea		CmdBuf,a0
                            	  2109: .0001:
00:000085A6 610082CC        	  2110: 		bsr		GetKey
00:000085AA B03C0008        	  2111: 		cmp.b	#CTRLH,d0
00:000085AE 6728            	  2112: 		beq.s	.0003
00:000085B0 B03C0018        	  2113: 		cmp.b	#CTRLX,d0
00:000085B4 6746            	  2114: 		beq.s	.0004
00:000085B6 B03C000D        	  2115: 		cmp.b	#CR,d0
00:000085BA 6706            	  2116: 		beq.s	.0002
00:000085BC B03C0020        	  2117: 		cmp.b	#' ',d0
00:000085C0 65E4            	  2118: 		bcs.s	.0001
                            	  2119: .0002:
00:000085C2 1080            	  2120: 		move.b	d0,(a0)
00:000085C4 5088            	  2121: 		lea			8(a0),a0
00:000085C6 610015C2        	  2122: 		bsr		OutputChar
00:000085CA B03C000D        	  2123: 		cmp.b	#CR,d0
00:000085CE 675E            	  2124: 		beq		.0007
00:000085D0 B1FC0004007F    	  2125: 		cmp.l	#CmdBufEnd-1,a0
00:000085D6 65CE            	  2126: 		bcs.s	.0001
                            	  2127: .0003:
00:000085D8 103C0008        	  2128: 		move.b	#CTRLH,d0
00:000085DC 610015AC        	  2129: 		bsr		OutputChar
00:000085E0 103C0020        	  2130: 		move.b	#' ',d0
00:000085E4 610015A4        	  2131: 		bsr		OutputChar
00:000085E8 B1FC00040040    	  2132: 		cmp.l	#CmdBuf,a0
00:000085EE 63B6            	  2133: 		bls.s	.0001
00:000085F0 103C0008        	  2134: 		move.b	#CTRLH,d0
00:000085F4 61001594        	  2135: 		bsr		OutputChar
00:000085F8 5388            	  2136: 		subq.l	#1,a0
00:000085FA 60AA            	  2137: 		bra.s	.0001
                            	  2138: .0004:
00:000085FC 2208            	  2139: 		move.l	a0,d1
00:000085FE 92BC00040040    	  2140: 		sub.l	#CmdBuf,d1
00:00008604 671E            	  2141: 		beq.s	.0006
00:00008606 5341            	  2142: 		subq	#1,d1
                            	  2143: .0005:
00:00008608 103C0008        	  2144: 		move.b	#CTRLH,d0
00:0000860C 6100157C        	  2145: 		bsr		OutputChar
00:00008610 103C0020        	  2146: 		move.b	#' ',d0
00:00008614 61001574        	  2147: 		bsr		OutputChar
00:00008618 103C0008        	  2148: 		move.b	#CTRLH,d0
00:0000861C 6100156C        	  2149: 		bsr		OutputChar
00:00008620 51C9FFE6        	  2150: 		dbra	d1,.0005
                            	  2151: .0006:
00:00008624 41F900040040    	  2152: 		lea		CmdBuf,a0
00:0000862A 6000FF7A        	  2153: 		bra		.0001
                            	  2154: .0007:
00:0000862E 103C000A        	  2155: 		move.b	#LF,d0
00:00008632 61001556        	  2156: 		bsr		OutputChar
00:00008636 4E75            	  2157: 		rts
                            	  2158: 
                            	  2159: ;------------------------------------------------------------------------------
                            	  2160: ; S <address> <length>
                            	  2161: ; Send data buffer to serial port
                            	  2162: ; S 40000 40
                            	  2163: ;------------------------------------------------------------------------------
                            	  2164: 
                            	  2165: cmdSendSerial:
00:00008638 61000156        	  2166: 	bsr			ignBlanks
00:0000863C 610007AA        	  2167: 	bsr			GetHexNumber
00:00008640 6700FAF6        	  2168: 	beq			Monitor
00:00008644 2C01            	  2169: 	move.l	d1,d6					; d6 points to buffer
00:00008646 61000148        	  2170: 	bsr			ignBlanks
00:0000864A 6100079C        	  2171: 	bsr			GetHexNumber
00:0000864E 6602            	  2172: 	bne.s		.0003
00:00008650 7210            	  2173: 	moveq		#16,d1
                            	  2174: .0003:
00:00008652 2246            	  2175: 	move.l	d6,a1					; a1 points to buffer
00:00008654 2401            	  2176: 	move.l	d1,d2					; d2 = count of bytes to send
00:00008656 6008            	  2177: 	bra.s		.0002					; enter loop at bottom
                            	  2178: .0001:
00:00008658 1219            	  2179: 	move.b	(a1)+,d1
00:0000865A 303C0022        	  2180: 	move.w	#34,d0				; serial putchar
00:0000865E 4E4F            	  2181: 	trap		#15
                            	  2182: .0002:
00:00008660 51CAFFF6        	  2183: 	dbra		d2,.0001
00:00008664 6000FAD2        	  2184: 	bra			Monitor
                            	  2185: 		
                            	  2186: ;------------------------------------------------------------------------------
                            	  2187: ; R <address> <length>
                            	  2188: ; Send data buffer to serial port
                            	  2189: ; R 10000 40
                            	  2190: ;------------------------------------------------------------------------------
                            	  2191: 
                            	  2192: cmdReceiveSerial:
00:00008668 61000126        	  2193: 	bsr			ignBlanks
00:0000866C 6100077A        	  2194: 	bsr			GetHexNumber
00:00008670 6700FAC6        	  2195: 	beq			Monitor
00:00008674 2C01            	  2196: 	move.l	d1,d6					; d6 points to buffer
00:00008676 61000118        	  2197: 	bsr			ignBlanks
00:0000867A 6100076C        	  2198: 	bsr			GetHexNumber
00:0000867E 6602            	  2199: 	bne.s		.0003
00:00008680 7210            	  2200: 	moveq		#16,d1
                            	  2201: .0003:
00:00008682 2246            	  2202: 	move.l	d6,a1					; a1 points to buffer
00:00008684 2401            	  2203: 	move.l	d1,d2					; d2 = count of bytes to send
00:00008686 600C            	  2204: 	bra.s		.0002					; enter loop at bottom
                            	  2205: .0001:
00:00008688 303C0024        	  2206: 	move.w	#36,d0				; serial peek char
00:0000868C 4E4F            	  2207: 	trap		#15
00:0000868E 4A81            	  2208: 	tst.l		d1
00:00008690 6BF6            	  2209: 	bmi.s		.0001
00:00008692 12C1            	  2210: 	move.b	d1,(a1)+
                            	  2211: .0002:
00:00008694 51CAFFF2        	  2212: 	dbra		d2,.0001
00:00008698 6000FA9E        	  2213: 	bra			Monitor
                            	  2214: 		
                            	  2215: ;------------------------------------------------------------------------------
                            	  2216: ; Fill memory
                            	  2217: ;
                            	  2218: ; FB = fill bytes		FB 00000010 100 FF	; fill starting at 10 for 256 bytes
                            	  2219: ; FB = fill bytes		FB 00000010 100 R		; fill with random bytes
                            	  2220: ; FW = fill words
                            	  2221: ; FL = fill longs
                            	  2222: ; F = fill bytes
                            	  2223: ;------------------------------------------------------------------------------
                            	  2224: 
                            	  2225: cmdFillB:
00:0000869C 610000F2        	  2226: 	bsr			ignBlanks
00:000086A0 61000746        	  2227: 	bsr			GetHexNumber
00:000086A4 2241            	  2228: 	move.l	d1,a1					; a1 = start
00:000086A6 610000E8        	  2229: 	bsr			ignBlanks
00:000086AA 6100073C        	  2230: 	bsr			GetHexNumber
00:000086AE 2601            	  2231: 	move.l	d1,d3					; d3 = count
00:000086B0 6700FA86        	  2232: 	beq			Monitor
00:000086B4 610000DA        	  2233: 	bsr			ignBlanks
00:000086B8 610000E8        	  2234: 	bsr PeekScreenChar
00:000086BC 0C010052        	  2235: 	cmpi.b #'R',d1
00:000086C0 660A            	  2236: 	bne.s .0002
00:000086C2 6100FA60        	  2237: 	bsr FromScreen
00:000086C6 1A3C0052        	  2238: 	move.b #'R',d5
00:000086CA 6006            	  2239: 	bra.s .fmem
                            	  2240: .0002:
00:000086CC 6100071A        	  2241: 	bsr	GetHexNumber		; fill value
00:000086D0 1801            	  2242: 	move.b d1,d4
                            	  2243: .fmem:
00:000086D2 3409            	  2244: 	move.w a1,d2
00:000086D4 4A42            	  2245: 	tst.w d2
00:000086D6 6604            	  2246: 	bne.s .0001
00:000086D8 610081D4        	  2247: 	bsr	CheckForCtrlC
                            	  2248: .0001:	
00:000086DC 0C050052        	  2249: 	cmpi.b #'R',d5
00:000086E0 6604            	  2250: 	bne.s .0003
00:000086E2 61009DAE        	  2251: 	bsr RandGetNum
                            	  2252: .0003:
00:000086E6 12C4            	  2253: 	move.b d4,(a1)+
00:000086E8 5383            	  2254: 	sub.l	#1,d3
00:000086EA 66E6            	  2255: 	bne.s	.fmem
00:000086EC 6000FA4A        	  2256: 	bra	Monitor
                            	  2257: 	
                            	  2258: cmdFillW:
00:000086F0 6100009E        	  2259: 	bsr			ignBlanks
00:000086F4 610006F2        	  2260: 	bsr			GetHexNumber
00:000086F8 2241            	  2261: 	move.l	d1,a1					; a1 = start
00:000086FA 61000094        	  2262: 	bsr			ignBlanks
00:000086FE 610006E8        	  2263: 	bsr			GetHexNumber
00:00008702 2601            	  2264: 	move.l	d1,d3					; d3 = count
00:00008704 6700FA32        	  2265: 	beq			Monitor
00:00008708 61000086        	  2266: 	bsr			ignBlanks
00:0000870C 61000094        	  2267: 	bsr PeekScreenChar
00:00008710 0C010052        	  2268: 	cmpi.b #'R',d1
00:00008714 660A            	  2269: 	bne.s .0002
00:00008716 6100FA0C        	  2270: 	bsr FromScreen
00:0000871A 1A3C0052        	  2271: 	move.b #'R',d5
00:0000871E 6006            	  2272: 	bra.s .fmem
                            	  2273: .0002:
00:00008720 610006C6        	  2274: 	bsr	GetHexNumber			; fill value
00:00008724 3801            	  2275: 	move.w d1,d4
                            	  2276: .fmem:
00:00008726 3409            	  2277: 	move.w a1,d2
00:00008728 4A42            	  2278: 	tst.w d2
00:0000872A 6604            	  2279: 	bne.s .0001
00:0000872C 61008180        	  2280: 	bsr	CheckForCtrlC
                            	  2281: .0001:	
00:00008730 0C050052        	  2282: 	cmpi.b #'R',d5
00:00008734 6604            	  2283: 	bne.s .0003
00:00008736 61009D5A        	  2284: 	bsr RandGetNum
                            	  2285: .0003:
00:0000873A 32C4            	  2286: 	move.w d4,(a1)+
00:0000873C 5383            	  2287: 	sub.l	#1,d3
00:0000873E 66E6            	  2288: 	bne.s	.fmem
00:00008740 6000F9F6        	  2289: 	bra	Monitor
                            	  2290: 	
                            	  2291: cmdFillL:
00:00008744 614A            	  2292: 	bsr			ignBlanks
00:00008746 610006A0        	  2293: 	bsr			GetHexNumber
00:0000874A 2241            	  2294: 	move.l	d1,a1					; a1 = start
00:0000874C 6142            	  2295: 	bsr			ignBlanks
00:0000874E 61000698        	  2296: 	bsr			GetHexNumber
00:00008752 2601            	  2297: 	move.l	d1,d3					; d3 = count
00:00008754 6700F9E2        	  2298: 	beq			Monitor
00:00008758 6136            	  2299: 	bsr			ignBlanks
00:0000875A 6146            	  2300: 	bsr PeekScreenChar
00:0000875C 0C010052        	  2301: 	cmpi.b #'R',d1
00:00008760 660A            	  2302: 	bne.s .0002
00:00008762 6100F9C0        	  2303: 	bsr FromScreen
00:00008766 1A3C0052        	  2304: 	move.b #'R',d5
00:0000876A 6006            	  2305: 	bra.s .fmem
                            	  2306: .0002:
00:0000876C 6100067A        	  2307: 	bsr			GetHexNumber	; fill value
00:00008770 2801            	  2308: 	move.l d1,d4
                            	  2309: .fmem:
00:00008772 3409            	  2310: 	move.w a1,d2
00:00008774 4A42            	  2311: 	tst.w d2
00:00008776 6604            	  2312: 	bne.s .0001
00:00008778 61008134        	  2313: 	bsr	CheckForCtrlC
                            	  2314: .0001:	
00:0000877C 0C050052        	  2315: 	cmpi.b #'R',d5
00:00008780 6604            	  2316: 	bne.s .0003
00:00008782 61009D0E        	  2317: 	bsr RandGetNum
                            	  2318: .0003:
00:00008786 22C4            	  2319: 	move.l d4,(a1)+
00:00008788 5383            	  2320: 	sub.l	#1,d3
00:0000878A 66E6            	  2321: 	bne.s	.fmem
00:0000878C 6000F9AA        	  2322: 	bra	Monitor
                            	  2323: 	
                            	  2324: ;------------------------------------------------------------------------------
                            	  2325: ; Modifies:
                            	  2326: ;	a0	- text pointer
                            	  2327: ;------------------------------------------------------------------------------
                            	  2328: 
                            	  2329: ignBlanks:
00:00008790 2F01            	  2330: 	move.l d1,-(a7)
                            	  2331: .0001:
00:00008792 6100F990        	  2332: 	bsr	FromScreen
00:00008796 0C010020        	  2333: 	cmpi.b #' ',d1
00:0000879A 67F6            	  2334: 	beq.s .0001
                            	  2335: 	if (SCREEN_FORMAT==1)
00:0000879C 5988            	  2336: 		lea	-4(a0),a0
                            	  2337: 	else
                            	  2338: 		lea	-8(a0),a0
                            	  2339: 	endif
00:0000879E 221F            	  2340: 	move.l (a7)+,d1
00:000087A0 4E75            	  2341: 	rts
                            	  2342: 
                            	  2343: 
                            	  2344: ;------------------------------------------------------------------------------
                            	  2345: ;------------------------------------------------------------------------------
                            	  2346: 
                            	  2347: PeekScreenChar:
00:000087A2 2210            	  2348: 	move.l (a0),d1
00:000087A4 60000F7E        	  2349: 	bra rbo
                            	  2350: 
                            	  2351: ;------------------------------------------------------------------------------
                            	  2352: ; Get the size character
                            	  2353: ; If the size is not recognized, assume a byte size
                            	  2354: ;
                            	  2355: ; Modifies:
                            	  2356: ;		a0	- text pointer
                            	  2357: ;		d1
                            	  2358: ; Returns:
                            	  2359: ;		d4 = size character 'B','W' or 'L'
                            	  2360: ;------------------------------------------------------------------------------
                            	  2361: 
                            	  2362: GetSzChar:
00:000087A8 61E6            	  2363: 	bsr	ignBlanks
00:000087AA 7842            	  2364: 	moveq #'B',d4		; assume byte
00:000087AC 2210            	  2365: 	move.l (a0),d1
00:000087AE 61000F74        	  2366: 	bsr	rbo
00:000087B2 0C010042        	  2367: 	cmpi.b #'B',d1
00:000087B6 670E            	  2368: 	beq.s .0002
00:000087B8 0C010057        	  2369: 	cmpi.b #'W',d1
00:000087BC 6708            	  2370: 	beq.s .0002
00:000087BE 0C01004C        	  2371: 	cmpi.b #'L',d1
00:000087C2 6702            	  2372: 	beq.s .0002
00:000087C4 4E75            	  2373: 	rts
                            	  2374: .0002:
00:000087C6 6100F95C        	  2375: 	bsr FromScreen
00:000087CA 1801            	  2376: 	move.b d1,d4
00:000087CC 4E75            	  2377: 	rts
                            	  2378: 
                            	  2379: ;------------------------------------------------------------------------------
                            	  2380: ; Edit memory byte.
                            	  2381: ;    Bytes are built into long words in case the memory is only longword
                            	  2382: ; accessible.
                            	  2383: ;------------------------------------------------------------------------------
                            	  2384: 
                            	  2385: EditMemHelper:
00:000087CE 61C0            	  2386: 	bsr ignBlanks
00:000087D0 61000616        	  2387: 	bsr GetHexNumber
00:000087D4 0C04004C        	  2388: 	cmpi.b #'L',d4
00:000087D8 6604            	  2389: 	bne.s .0001
00:000087DA 2401            	  2390: 	move.l d1,d2
00:000087DC 4E75            	  2391: 	rts
                            	  2392: .0001:
00:000087DE 0C040057        	  2393: 	cmpi.b #'W',d4
00:000087E2 6606            	  2394: 	bne.s .0002
00:000087E4 4842            	  2395: 	swap d2
00:000087E6 3401            	  2396: 	move.w d1,d2
00:000087E8 4E75            	  2397: 	rts
                            	  2398: .0002:
00:000087EA E18A            	  2399: 	lsl.l #8,d2
00:000087EC 1401            	  2400: 	move.b d1,d2
00:000087EE 4E75            	  2401: 	rts
                            	  2402: 	
                            	  2403: cmdEditMemory:
00:000087F0 61B6            	  2404: 	bsr GetSzChar
00:000087F2 619C            	  2405: 	bsr ignBlanks
00:000087F4 610005F2        	  2406: 	bsr	GetHexNumber
00:000087F8 2241            	  2407: 	move.l d1,a1
                            	  2408: edtmem1:
00:000087FA 0C04004C        	  2409: 	cmpi.b #'L',d4
00:000087FE 6610            	  2410: 	bne.s .0004
00:00008800 7400            	  2411: 	clr.l	d2
00:00008802 61CA            	  2412: 	bsr EditMemHelper
00:00008804 22C2            	  2413: 	move.l d2,(a1)+
00:00008806 7400            	  2414: 	clr.l	d2
00:00008808 61C4            	  2415: 	bsr EditMemHelper
00:0000880A 22C2            	  2416: 	move.l d2,(a1)+
00:0000880C 6000F92A        	  2417: 	bra Monitor
                            	  2418: .0004:
00:00008810 0C040057        	  2419: 	cmpi.b #'W',d4
00:00008814 6618            	  2420: 	bne.s .0005
00:00008816 7400            	  2421: 	clr.l	d2
00:00008818 61B4            	  2422: 	bsr EditMemHelper
00:0000881A 61B2            	  2423: 	bsr EditMemHelper
00:0000881C 4842            	  2424: 	swap d2
00:0000881E 22C2            	  2425: 	move.l d2,(a1)+
00:00008820 7400            	  2426: 	clr.l	d2
00:00008822 61AA            	  2427: 	bsr EditMemHelper
00:00008824 61A8            	  2428: 	bsr EditMemHelper
00:00008826 4842            	  2429: 	swap d2
00:00008828 22C2            	  2430: 	move.l d2,(a1)+
00:0000882A 6000F90C        	  2431: 	bra Monitor
                            	  2432: .0005:
00:0000882E 7400            	  2433: 	clr.l	d2
00:00008830 619C            	  2434: 	bsr EditMemHelper
00:00008832 619A            	  2435: 	bsr EditMemHelper
00:00008834 6198            	  2436: 	bsr EditMemHelper
00:00008836 6196            	  2437: 	bsr EditMemHelper
00:00008838 C342            	  2438: 	exg d1,d2
00:0000883A 61000EE8        	  2439: 	bsr rbo
00:0000883E 22C1            	  2440: 	move.l d1,(a1)+
00:00008840 61000EE2        	  2441: 	bsr rbo
00:00008844 C342            	  2442: 	exg d1,d2
00:00008846 7400            	  2443: 	clr.l	d2
00:00008848 6184            	  2444: 	bsr EditMemHelper
00:0000884A 6182            	  2445: 	bsr EditMemHelper
00:0000884C 6180            	  2446: 	bsr EditMemHelper
00:0000884E 6100FF7E        	  2447: 	bsr EditMemHelper
00:00008852 C342            	  2448: 	exg d1,d2
00:00008854 61000ECE        	  2449: 	bsr rbo
00:00008858 22C1            	  2450: 	move.l d1,(a1)+
00:0000885A 61000EC8        	  2451: 	bsr rbo
00:0000885E C342            	  2452: 	exg d1,d2
00:00008860 6000F8D6        	  2453: 	bra Monitor
                            	  2454: 
                            	  2455: ;------------------------------------------------------------------------------
                            	  2456: ; Execute code at the specified address.
                            	  2457: ;------------------------------------------------------------------------------
                            	  2458: 
                            	  2459: cmdJump:
                            	  2460: ExecuteCode:
00:00008864 6100FF2A        	  2461: 	bsr	ignBlanks
00:00008868 6100057E        	  2462: 	bsr	GetHexNumber
00:0000886C 2041            	  2463: 	move.l d1,a0
00:0000886E 4E90            	  2464: 	jsr	(a0)
00:00008870 6000F8C6        	  2465: 	bra Monitor
                            	  2466: 
                            	  2467: cmdGrDemo:
00:00008874 223C00008888    	  2468: 	move.l #$00008888,d1		; 32 bpp
00:0000887A 7E06            	  2469: 	moveq #6,d7							; framebuf device
00:0000887C 7C21            	  2470: 	moveq #DEV_SET_COLOR_DEPTH,d6
00:0000887E 4E40            	  2471: 	trap #0
00:00008880 7E07            	  2472: 	moveq #7,d7							; same for graphics accelerator device
00:00008882 4E40            	  2473: 	trap #0
00:00008884 223C00110001    	  2474: 	move.l #$00110001,d1		; enable, scale 1 clocks/scanlines per pixel, page zero
00:0000888A 61000E98        	  2475: 	bsr rbo
                            	  2476: ;	move.l d1,FRAMEBUF+FRAMEBUF_CTRL
00:0000888E 223C00F00063    	  2477: 	move.l #$0F00063,d1		; burst length of 100, interval of F00h
00:00008894 61000E8E        	  2478: 	bsr rbo
00:00008898 23C1FD200004    	  2479: 	move.l d1,FRAMEBUF+FRAMEBUF_CTRL+4		
00:0000889E 7E06            	  2480: 	moveq #6,d7							; framebuf device
00:000088A0 7C20            	  2481: 	moveq #DEV_SET_DIMEN,d6
00:000088A2 7000            	  2482: 	moveq #0,d0
00:000088A4 223C00000320    	  2483: 	move.l #VIDEO_X,d1
00:000088AA 243C00000258    	  2484: 	move.l #VIDEO_Y,d2
00:000088B0 7600            	  2485: 	move.l #0,d3
00:000088B2 4E40            	  2486: 	trap #0
00:000088B4 7E07            	  2487: 	moveq #7,d7							; same for graphics accelerator device
00:000088B6 4E40            	  2488: 	trap #0
00:000088B8 7E06            	  2489: 	moveq #6,d7
00:000088BA 7002            	  2490: 	moveq #2,d0							; set window dimensions
00:000088BC 4E40            	  2491: 	trap #0
                            	  2492: 	; Set destination buffer #0
00:000088BE 7E07            	  2493: 	moveq #7,d7
00:000088C0 7C22            	  2494: 	moveq #DEV_SET_DESTBUF,d6	; write to buffer 0
00:000088C2 7200            	  2495: 	moveq #0,d1
00:000088C4 4E40            	  2496: 	trap #0
                            	  2497: 	; Clear the screen
00:000088C6 7C0C            	  2498: 	moveq #DEV_CLEAR,d6
00:000088C8 4E40            	  2499: 	trap #0
                            	  2500: 	; Now display the clear screen
00:000088CA 7E06            	  2501: 	moveq #6,d7
00:000088CC 7C23            	  2502: 	moveq #DEV_SET_DISPBUF,d6
00:000088CE 7200            	  2503: 	moveq #0,d1							; display buffer 0
00:000088D0 4E40            	  2504: 	trap #0
                            	  2505: 
                            	  2506: ;	moveq #0,d1
                            	  2507: ;	moveq #0,d2
                            	  2508: ;	move.l #1920,d3
                            	  2509: ;	move.l #1080,d4
                            	  2510: ;	bsr gfxaccel_clip_rect
                            	  2511: 	; Draw two diagonal white lines
00:000088D2 263C00000258    	  2512: 	move.l #VIDEO_Y,d3
00:000088D8 287C40000000    	  2513: 	move.l #$40000000,a4
                            	  2514: .0002:
00:000088DE 243CFF7FFF7F    	  2515: 	move.l #$FF7FFF7F,d2	; white
00:000088E4 3882            	  2516: 	move.w d2,(a4)
00:000088E6 49EC0C84        	  2517: 	add.l #VIDEO_X*4+4,a4
00:000088EA 51CBFFF2        	  2518: 	dbra d3,.0002
00:000088EE 263C00000258    	  2519: 	move.l #VIDEO_Y,d3
00:000088F4 287C40000640    	  2520: 	move.l #$40000000+VIDEO_X*2,a4
                            	  2521: .0007:
00:000088FA 3882            	  2522: 	move.w d2,(a4)
00:000088FC 49EC0C7C        	  2523: 	add.l #VIDEO_X*4-4,a4
00:00008900 51CBFFF8        	  2524: 	dbra d3,.0007
00:00008904 6000F832        	  2525: 	bra Monitor
                            	  2526: 
                            	  2527: ;	bra Monitor
                            	  2528: plot_rand_points:
00:00008908 223C7F127F12    	  2529: 	move.l #$7F127F12,d1
00:0000890E 61000E14        	  2530: 	bsr rbo
00:00008912 61009794        	  2531: 	bsr gfxaccel_set_color
00:00008916 2A3C00002710    	  2532: 	move.l #10000,d5
                            	  2533: .0005:
00:0000891C 287C40000000    	  2534: 	move.l #$40000000,a4
00:00008922 61009B6E        	  2535: 	bsr RandGetNum
00:00008926 2801            	  2536: 	move.l d1,d4
00:00008928 61009B68        	  2537: 	bsr RandGetNum
00:0000892C 2401            	  2538: 	move.l d1,d2
00:0000892E 0282000000FF    	  2539: 	andi.l #$ff,d2
00:00008934 61009B5C        	  2540: 	bsr RandGetNum
00:00008938 0281000001FF    	  2541: 	andi.l #$1ff,d1
00:0000893E C4FC03C0        	  2542: 	mulu #960,d2
00:00008942 D481            	  2543: 	add.l d1,d2
00:00008944 D481            	  2544: 	add.l d1,d2
00:00008946 D9C2            	  2545: 	add.l d2,a4
00:00008948 3884            	  2546: 	move.w d4,(a4)				; plot point
00:0000894A 51CDFFD0        	  2547: 	dbra d5,.0005
00:0000894E 6000F7E8        	  2548: 	bra Monitor
                            	  2549: 
                            	  2550: ;clear_graphics_screen:
                            	  2551: ;	move.l #0,d1
                            	  2552: ;	moveq #6,d7
                            	  2553: ;	moveq #DEV_SET_COLOR,d6		; set color in frame buffer
                            	  2554: ;	trap #0
                            	  2555: ;	moveq #7,d7								; and in graphics accelerator
                            	  2556: ;	trap #0
                            	  2557: ;	moveq #6,d7								; clear frame buffer
                            	  2558: ;	moveq #DEV_CLEAR,d6
                            	  2559: ;	trap #0
                            	  2560: ;	moveq #DEV_SWAPBUF,d6			; and display it
                            	  2561: ;	trap #0
                            	  2562: ;	rts
                            	  2563: 
                            	  2564: ;	move.l #0,d1
                            	  2565: ;	bsr gfxaccel_set_color
                            	  2566: ;	move.l #0,d1
                            	  2567: ;	move.l #0,d2
                            	  2568: ;	move.l #1920<<16,d3
                            	  2569: ;	move.l #1080<<16,d4
                            	  2570: ;	bsr gfxaccel_draw_rectangle
00:00008952 2A3C00075300    	  2571: 	move.l #VIDEO_X*VIDEO_Y,d5		; compute number of strips to write
00:00008958 E68D            	  2572: 	lsr.l #3,d5						; 8 pixels per strip
                            	  2573: ;	move.l framebuf_dcb+DCB_OUTBUFPTR,a4
00:0000895A 287C40000000    	  2574: 	move.l #$40000000,a4
00:00008960 42B97FFFFFF8    	  2575: 	move.l #0,$7FFFFFF8		; burst length of zero
00:00008966 6002            	  2576: 	bra.s .0001
                            	  2577: .0002:
00:00008968 4845            	  2578: 	swap d5
                            	  2579: .0001:
00:0000896A 220C            	  2580: 	move.l a4,d1
00:0000896C 61000DB6        	  2581: 	bsr rbo
00:00008970 23C17FFFFFF4    	  2582: 	move.l d1,$7FFFFFF4		; target address
00:00008976 42B97FFFFFFC    	  2583: 	move.l #0,$7FFFFFFC		; value to write
00:0000897C 49EC0020        	  2584: 	lea.l 32(a4),a4
00:00008980 51CDFFE8        	  2585: 	dbra d5,.0001
                            	  2586: ;	swap d5
                            	  2587: ;	dbra d5,.0002
00:00008984 4E75            	  2588: 	rts
                            	  2589: 
                            	  2590: clear_graphics_screen2:
                            	  2591: ;	move.l #0,d1
                            	  2592: ;	bsr gfxaccel_set_color
                            	  2593: ;	move.l #0,d1
                            	  2594: ;	move.l #0,d2
                            	  2595: ;	move.l #1920<<16,d3
                            	  2596: ;	move.l #1080<<16,d4
                            	  2597: ;	bsr gfxaccel_draw_rectangle
00:00008986 2A3C00075300    	  2598: 	move.l #VIDEO_X*VIDEO_Y,d5		; compute number of strips to write
00:0000898C E68D            	  2599: 	lsr.l #3,d5						; 8 pixels per strip
00:0000898E E88D            	  2600: 	lsr.l #4,d5						; and burst writing 16 strips at once
00:00008990 287900040D54    	  2601: 	move.l framebuf_dcb+DCB_OUTBUFPTR,a4
00:00008996 23FC0000000F7FFF	  2602: 	move.l #15,$7FFFFFF8		; burst length = 16
00:0000899E FFF8
00:000089A0 6002            	  2603: 	bra.s .0001
                            	  2604: .0002:
00:000089A2 4845            	  2605: 	swap d5
                            	  2606: .0001:
00:000089A4 220C            	  2607: 	move.l a4,d1
00:000089A6 61000D7C        	  2608: 	bsr rbo
00:000089AA 23C17FFFFFF4    	  2609: 	move.l d1,$7FFFFFF4		; target address
00:000089B0 720F            	  2610: 	moveq #15,d1
00:000089B2 61000D70        	  2611: 	bsr rbo
00:000089B6 23C17FFFFFF8    	  2612: 	move.l d1,$7FFFFFF8	; burst length = 16
00:000089BC 42B97FFFFFFC    	  2613: 	move.l #0,$7FFFFFFC		; value to write
00:000089C2 49EC0200        	  2614: 	lea.l 32*16(a4),a4
00:000089C6 51CDFFDC        	  2615: 	dbra d5,.0001
                            	  2616: ;	swap d5
                            	  2617: ;	dbra d5,.0002
00:000089CA 6000F76C        	  2618: 	bra Monitor
                            	  2619: 
                            	  2620: white_rect:
00:000089CE 72FF            	  2621: 	move.l #$FFFFFFFF,d1
00:000089D0 610096D6        	  2622: 	bsr gfxaccel_set_color
00:000089D4 72644841        	  2623: 	move.l #100<<16,d1
00:000089D8 243C012C0000    	  2624: 	move.l #300<<16,d2
00:000089DE 263C00FA0000    	  2625: 	move.l #250<<16,d3
00:000089E4 283C02260000    	  2626: 	move.l #550<<16,d4
00:000089EA 6100983E        	  2627: 	bsr gfxaccel_draw_rectangle
00:000089EE 6000F748        	  2628: 	bra Monitor
                            	  2629: 
                            	  2630: rand_points:
00:000089F2 2A3C00007530    	  2631: 	move.l #30000,d5
                            	  2632: .0004:
00:000089F8 61009A98        	  2633: 	bsr RandGetNum
00:000089FC 610096AA        	  2634: 	bsr gfxaccel_set_color
00:00008A00 7600            	  2635: 	move.l #0,d3					; Z
00:00008A02 61009A8E        	  2636: 	bsr RandGetNum
00:00008A06 2401            	  2637: 	move.l d1,d2
                            	  2638: ;	divu #VIDEO_Y,d2			; Y
00:00008A08 0282000001FF    	  2639: 	andi.l #511,d2
00:00008A0E 4842            	  2640: 	swap d2
00:00008A10 61009A80        	  2641: 	bsr RandGetNum
                            	  2642: ;	divu #VIDEO_X,d1
00:00008A14 0281000001FF    	  2643: 	andi.l #511,d1
00:00008A1A 4841            	  2644: 	swap d1
00:00008A1C 61009752        	  2645: 	bsr gfxaccel_plot_point
00:00008A20 51CDFFD6        	  2646: 	dbra d5,.0004
00:00008A24 6000F712        	  2647: 	bra Monitor
                            	  2648: 
                            	  2649: rand_lines:
00:00008A28 2A3C00007530    	  2650: 	move.l #30000,d5
                            	  2651: .0001:
                            	  2652: .0006:
00:00008A2E 4EB9000008AE    	  2653: 	bsr CheckForCtrlC
00:00008A34 61009A5C        	  2654: 	bsr RandGetNum
00:00008A38 6100966E        	  2655: 	bsr gfxaccel_set_color
00:00008A3C 61009A54        	  2656: 	bsr RandGetNum
00:00008A40 2801            	  2657: 	move.l d1,d4
                            	  2658: ;	divu #VIDEO_Y,d4
00:00008A42 0284000001FF    	  2659: 	andi.l #511,d4
00:00008A48 4844            	  2660: 	swap d4
00:00008A4A 61009A46        	  2661: 	bsr RandGetNum
00:00008A4E 2601            	  2662: 	move.l d1,d3
                            	  2663: ;	divu #VIDEO_X,d3
00:00008A50 0283000001FF    	  2664: 	andi.l #511,d3
00:00008A56 4843            	  2665: 	swap d3
00:00008A58 61009A38        	  2666: 	bsr RandGetNum
00:00008A5C 2401            	  2667: 	move.l d1,d2
                            	  2668: ;	divu #VIDEO_Y,d2
00:00008A5E 0282000001FF    	  2669: 	andi.l #511,d2
00:00008A64 4842            	  2670: 	swap d2
00:00008A66 61009A2A        	  2671: 	bsr RandGetNum
                            	  2672: ;	divu #VIDEO_X,d1
00:00008A6A 0281000001FF    	  2673: 	andi.l #511,d1
00:00008A70 4841            	  2674: 	swap d1
00:00008A72 6100974E        	  2675: 	bsr gfxaccel_draw_line
00:00008A76 51CDFFB6        	  2676: 	dbra d5,.0001
00:00008A7A 6000F6BC        	  2677: 	bra Monitor
                            	  2678: 
                            	  2679: rand_rect:
00:00008A7E 2A3C00007530    	  2680: 	move.l #30000,d5
                            	  2681: .0003:
                            	  2682: .0006:
00:00008A84 4EB9000008AE    	  2683: 	bsr CheckForCtrlC
00:00008A8A 61009A06        	  2684: 	bsr RandGetNum
00:00008A8E 61009618        	  2685: 	bsr gfxaccel_set_color
00:00008A92 610099FE        	  2686: 	bsr RandGetNum
00:00008A96 2801            	  2687: 	move.l d1,d4
                            	  2688: ;	divu #VIDEO_Y,d4
00:00008A98 0284000001FF    	  2689: 	andi.l #511,d4
00:00008A9E 4844            	  2690: 	swap d4
00:00008AA0 610099F0        	  2691: 	bsr RandGetNum
00:00008AA4 2601            	  2692: 	move.l d1,d3
                            	  2693: ;	divu #VIDEO_X,d3
00:00008AA6 0283000001FF    	  2694: 	andi.l #511,d3
00:00008AAC 4843            	  2695: 	swap d3
00:00008AAE 610099E2        	  2696: 	bsr RandGetNum
00:00008AB2 2401            	  2697: 	move.l d1,d2
                            	  2698: ;	divu #VIDEO_Y,d2
00:00008AB4 0282000001FF    	  2699: 	andi.l #511,d2
00:00008ABA 4842            	  2700: 	swap d2
00:00008ABC 610099D4        	  2701: 	bsr RandGetNum
                            	  2702: ;	divu #VIDEO_X,d1
00:00008AC0 0281000001FF    	  2703: 	andi.l #511,d1
00:00008AC6 4841            	  2704: 	swap d1
00:00008AC8 61009760        	  2705: 	bsr gfxaccel_draw_rectangle
00:00008ACC 51CDFFB6        	  2706: 	dbra d5,.0003
00:00008AD0 6000F666        	  2707: 	bra Monitor
                            	  2708: 
                            	  2709: rand_rect2:
00:00008AD4 2A3C00002710    	  2710: 	move.l #10000,d5
                            	  2711: .0003:
                            	  2712: .0006:
00:00008ADA 4EB9000008AE    	  2713: 	bsr CheckForCtrlC
00:00008AE0 610099B0        	  2714: 	bsr RandGetNum
00:00008AE4 610095C2        	  2715: 	bsr gfxaccel_set_color
00:00008AE8 610099A8        	  2716: 	bsr RandGetNum
00:00008AEC 2801            	  2717: 	move.l d1,d4
00:00008AEE 88FC0258        	  2718: 	divu #VIDEO_Y,d4
00:00008AF2 6100999E        	  2719: 	bsr RandGetNum
00:00008AF6 2601            	  2720: 	move.l d1,d3
00:00008AF8 86FC0320        	  2721: 	divu #VIDEO_X,d3
00:00008AFC 61009994        	  2722: 	bsr RandGetNum
00:00008B00 2401            	  2723: 	move.l d1,d2
00:00008B02 84FC0258        	  2724: 	divu #VIDEO_Y,d2
00:00008B06 6100998A        	  2725: 	bsr RandGetNum
00:00008B0A 82FC0320        	  2726: 	divu #VIDEO_X,d1
00:00008B0E 6100971A        	  2727: 	bsr gfxaccel_draw_rectangle
00:00008B12 51CDFFC6        	  2728: 	dbra d5,.0003
00:00008B16 6000F620        	  2729: 	bra Monitor
                            	  2730: 
                            	  2731: rand_triangle:
00:00008B1A 2E3C00007530    	  2732: 	move.l #30000,d7
                            	  2733: .0006:
00:00008B20 4EB9000008AE    	  2734: 	bsr CheckForCtrlC
00:00008B26 6100996A        	  2735: 	bsr RandGetNum
00:00008B2A 6100957C        	  2736: 	bsr gfxaccel_set_color
00:00008B2E 61009962        	  2737: 	bsr RandGetNum
00:00008B32 2001            	  2738: 	move.l d1,d0
                            	  2739: ;	divu #VIDEO_Y,d6
00:00008B34 0280000001FF    	  2740: 	andi.l #511,d0
00:00008B3A 4840            	  2741: 	swap d0
00:00008B3C 61009954        	  2742: 	bsr RandGetNum
00:00008B40 2A01            	  2743: 	move.l d1,d5
                            	  2744: ;	divu #VIDEO_X,d5
00:00008B42 0285000001FF    	  2745: 	andi.l #511,d5
00:00008B48 4845            	  2746: 	swap d5
00:00008B4A 61009946        	  2747: 	bsr RandGetNum
00:00008B4E 2801            	  2748: 	move.l d1,d4
                            	  2749: ;	divu #VIDEO_Y,d4
00:00008B50 0284000001FF    	  2750: 	andi.l #511,d4
00:00008B56 4844            	  2751: 	swap d4
00:00008B58 61009938        	  2752: 	bsr RandGetNum
00:00008B5C 2601            	  2753: 	move.l d1,d3
                            	  2754: ;	divu #VIDEO_X,d3
00:00008B5E 0283000001FF    	  2755: 	andi.l #511,d3
00:00008B64 4843            	  2756: 	swap d3
00:00008B66 6100992A        	  2757: 	bsr RandGetNum
00:00008B6A 2401            	  2758: 	move.l d1,d2
                            	  2759: ;	divu #VIDEO_Y,d2
00:00008B6C 0282000001FF    	  2760: 	andi.l #511,d2
00:00008B72 4842            	  2761: 	swap d2
00:00008B74 6100991C        	  2762: 	bsr RandGetNum
                            	  2763: ;	divu #VIDEO_X,d1
00:00008B78 0281000001FF    	  2764: 	andi.l #511,d1
00:00008B7E 4841            	  2765: 	swap d1
00:00008B80 61009710        	  2766: 	bsr gfxaccel_draw_triangle
00:00008B84 51CFFF9A        	  2767: 	dbra d7,.0006
00:00008B88 6000F5AE        	  2768: 	bra Monitor
                            	  2769: 
                            	  2770: rand_curve:
00:00008B8C 2E3C00002710    	  2771: 	move.l #10000,d7
                            	  2772: .0006:
00:00008B92 4EB9000008AE    	  2773: 	bsr CheckForCtrlC
00:00008B98 610098F8        	  2774: 	bsr RandGetNum
00:00008B9C 6100950A        	  2775: 	bsr gfxaccel_set_color
00:00008BA0 610098F0        	  2776: 	bsr RandGetNum
00:00008BA4 2C01            	  2777: 	move.l d1,d6
                            	  2778: ;	divu #VIDEO_Y,d6
00:00008BA6 0286000001FF    	  2779: 	andi.l #511,d6
00:00008BAC 4846            	  2780: 	swap d6
00:00008BAE 610098E2        	  2781: 	bsr RandGetNum
00:00008BB2 2A01            	  2782: 	move.l d1,d5
                            	  2783: ;	divu #VIDEO_X,d5
00:00008BB4 0285000001FF    	  2784: 	andi.l #511,d5
00:00008BBA 4845            	  2785: 	swap d5
00:00008BBC 610098D4        	  2786: 	bsr RandGetNum
00:00008BC0 2801            	  2787: 	move.l d1,d4
                            	  2788: ;	divu #VIDEO_Y,d4
00:00008BC2 0284000001FF    	  2789: 	andi.l #511,d4
00:00008BC8 4844            	  2790: 	swap d4
00:00008BCA 610098C6        	  2791: 	bsr RandGetNum
00:00008BCE 2601            	  2792: 	move.l d1,d3
                            	  2793: ;	divu #VIDEO_X,d3
00:00008BD0 0283000001FF    	  2794: 	andi.l #511,d3
00:00008BD6 4843            	  2795: 	swap d3
00:00008BD8 610098B8        	  2796: 	bsr RandGetNum
00:00008BDC 2401            	  2797: 	move.l d1,d2
                            	  2798: ;	divu #VIDEO_Y,d2
00:00008BDE 0282000001FF    	  2799: 	andi.l #511,d2
00:00008BE4 4842            	  2800: 	swap d2
00:00008BE6 610098AA        	  2801: 	bsr RandGetNum
                            	  2802: ;	divu #VIDEO_X,d1
00:00008BEA 0281000001FF    	  2803: 	andi.l #511,d1
00:00008BF0 4841            	  2804: 	swap d1
00:00008BF2 61009726        	  2805: 	bsr gfxaccel_draw_curve
00:00008BF6 51CFFF9A        	  2806: 	dbra d7,.0006
00:00008BFA 6000F53C        	  2807: 	bra Monitor
                            	  2808: 
                            	  2809: ;------------------------------------------------------------------------------
                            	  2810: ; Disassemble code
                            	  2811: ; DI 1000
                            	  2812: ;------------------------------------------------------------------------------
                            	  2813: ;        CALLING SEQUENCE:
                            	  2814: ;   D0,D1,D2 = CODE TO BE DISASSEMBLED
                            	  2815: ;   A4 = VALUE OF PROGRAM COUNTER FOR THE CODE
                            	  2816: ;   A5 = POINTER TO STORE DATA (BUFSIZE = 80 ASSUMED)
                            	  2817: ;        JSR       DCODE68K
                            	  2818: ;
                            	  2819: ;        RETURN:
                            	  2820: ;   A4 = VALUE OF PROGRAM COUNTER FOR NEXT INSTRUCTION
                            	  2821: ;   A5 = POINTER TO LINE AS DISASSEMBLED
                            	  2822: ;   A6 = POINTER TO END OF LINE
                            	  2823: 
                            	  2824: 
                            	  2825: cmdDisassemble:
00:00008BFE 6100FB90        	  2826: 	bsr ignBlanks
00:00008C02 610001E4        	  2827: 	bsr GetHexNumber
00:00008C06 6700F530        	  2828: 	beq Monitor
00:00008C0A 363C0014        	  2829: 	move.w #20,d3			; number of lines to disassemble
                            	  2830: .0002:
00:00008C0E 2F03            	  2831: 	move.l d3,-(a7)
00:00008C10 2041            	  2832: 	move.l d1,a0
00:00008C12 2841            	  2833: 	move.l d1,a4			; a4 = PC of code
00:00008C14 3018            	  2834: 	move.w (a0)+,d0		; d0 to d2 = bytes of instruction to decode
00:00008C16 4840            	  2835: 	swap d0
00:00008C18 3018            	  2836: 	move.w (a0)+,d0
00:00008C1A 3218            	  2837: 	move.w (a0)+,d1		; d0 to d2 = bytes of instruction to decode
00:00008C1C 4841            	  2838: 	swap d1
00:00008C1E 3218            	  2839: 	move.w (a0)+,d1
00:00008C20 3418            	  2840: 	move.w (a0)+,d2		; d0 to d2 = bytes of instruction to decode
00:00008C22 4842            	  2841: 	swap d2
00:00008C24 3418            	  2842: 	move.w (a0)+,d2
00:00008C26 4BF900040800    	  2843: 	lea _dasmbuf,a5		; a5 = pointer to disassembly buffer
00:00008C2C 61001A56        	  2844: 	bsr DCODE68K	
00:00008C30 383C003E        	  2845: 	move.w #62,d4
                            	  2846: .0001:
00:00008C34 121D            	  2847: 	move.b (a5)+,d1
00:00008C36 61000F52        	  2848: 	bsr OutputChar
00:00008C3A 51CCFFF8        	  2849: 	dbra d4,.0001
00:00008C3E 6100EE8A        	  2850: 	bsr CRLF
00:00008C42 220C            	  2851: 	move.l a4,d1
00:00008C44 261F            	  2852: 	move.l (a7)+,d3
00:00008C46 51CBFFC6        	  2853: 	dbra d3,.0002
00:00008C4A 6000F4EC        	  2854: 	bra Monitor
                            	  2855: 	
                            	  2856: ;------------------------------------------------------------------------------
                            	  2857: ; Do a memory dump of the requested location.
                            	  2858: ; DB 0800 0850
                            	  2859: ;------------------------------------------------------------------------------
                            	  2860: 
                            	  2861: cmdDumpMemory:
00:00008C4E 6100FB58        	  2862: 	bsr GetSzChar
00:00008C52 6100FB3C        	  2863: 	bsr ignBlanks
00:00008C56 61000190        	  2864: 	bsr	GetHexNumber
00:00008C5A 6700F4DC        	  2865: 	beq	Monitor					; was there a number ? no, other garbage, just ignore
00:00008C5E 2601            	  2866: 	move.l d1,d3				; save off start of range
00:00008C60 6100FB2E        	  2867: 	bsr	ignBlanks
00:00008C64 61000182        	  2868: 	bsr	GetHexNumber
00:00008C68 6608            	  2869: 	bne.s	DumpMem1
00:00008C6A 2203            	  2870: 	move.l d3,d1
00:00008C6C 068100000040    	  2871: 	addi.l #64,d1				;	no end specified, just dump 64 bytes
                            	  2872: DumpMem1:
00:00008C72 2043            	  2873: 	move.l d3,a0
00:00008C74 2241            	  2874: 	move.l d1,a1
00:00008C76 6100EE52        	  2875: 	bsr	CRLF
                            	  2876: .0001:
00:00008C7A B3C8            	  2877: 	cmpa.l a0,a1
00:00008C7C 6300F4BA        	  2878: 	bls	Monitor
00:00008C80 6102            	  2879: 	bsr	DisplayMem
00:00008C82 60F6            	  2880: 	bra.s	.0001
                            	  2881: 
                            	  2882: ;------------------------------------------------------------------------------
                            	  2883: ; Display memory dump in a format suitable for edit.
                            	  2884: ;
                            	  2885: ;	EB 12345678 00 11 22 33 44 55 66 77  "........"
                            	  2886: ;
                            	  2887: ; Modifies:
                            	  2888: ;		d1,d2,a0
                            	  2889: ;------------------------------------------------------------------------------
                            	  2890: 	
                            	  2891: DisplayMem:
00:00008C84 123C0045        	  2892: 	move.b #'E',d1
00:00008C88 61000F00        	  2893: 	bsr	OutputChar
00:00008C8C 1204            	  2894: 	move.b d4,d1
00:00008C8E 61000EFA        	  2895: 	bsr OutputChar
00:00008C92 61000728        	  2896: 	bsr DisplaySpace
00:00008C96 2208            	  2897: 	move.l a0,d1
00:00008C98 6100072A        	  2898: 	bsr	DisplayTetra
00:00008C9C 7407            	  2899: 	moveq #7,d2						; assume bytes
00:00008C9E 0C04004C        	  2900: 	cmpi.b #'L',d4
00:00008CA2 6604            	  2901: 	bne.s .0004
00:00008CA4 7401            	  2902: 	moveq	#1,d2
00:00008CA6 6008            	  2903: 	bra.s dspmem1
                            	  2904: .0004:
00:00008CA8 0C040057        	  2905: 	cmpi.b #'W',d4
00:00008CAC 6602            	  2906: 	bne.s dspmem1
00:00008CAE 7403            	  2907: 	moveq #3,d2
                            	  2908: dspmem1:
00:00008CB0 123C0020        	  2909: 	move.b #' ',d1
00:00008CB4 61000ED4        	  2910: 	bsr	OutputChar
00:00008CB8 0C04004C        	  2911: 	cmpi.b #'L',d4
00:00008CBC 6608            	  2912: 	bne.s .0005
00:00008CBE 2218            	  2913: 	move.l (a0)+,d1
00:00008CC0 61000702        	  2914: 	bsr	DisplayTetra
00:00008CC4 6014            	  2915: 	bra.s .0006
                            	  2916: .0005:
00:00008CC6 0C040057        	  2917: 	cmpi.b #'W',d4
00:00008CCA 6608            	  2918: 	bne.s .0007
00:00008CCC 3218            	  2919: 	move.w (a0)+,d1
00:00008CCE 610006FA        	  2920: 	bsr	DisplayWyde
00:00008CD2 6006            	  2921: 	bra.s .0006
                            	  2922: .0007:
00:00008CD4 1218            	  2923: 	move.b (a0)+,d1
00:00008CD6 610006F8        	  2924: 	bsr DisplayByte
                            	  2925: .0006:
00:00008CDA 51CAFFD4        	  2926: 	dbra d2,dspmem1
00:00008CDE 610006CA        	  2927: 	bsr	DisplayTwoSpaces
00:00008CE2 123C0022        	  2928: 	move.b #34,d1
00:00008CE6 61000EA2        	  2929: 	bsr	OutputChar
00:00008CEA 5188            	  2930: 	lea	-8(a0),a0
00:00008CEC 7407            	  2931: 	moveq	#7,d2
                            	  2932: .0002:
00:00008CEE 1218            	  2933: 	move.b (a0)+,d1
00:00008CF0 B23C0020        	  2934: 	cmp.b	#' ',d1
00:00008CF4 6506            	  2935: 	blo.s	.0003
00:00008CF6 B23C007F        	  2936: 	cmp.b	#127,d1
00:00008CFA 6304            	  2937: 	bls.s	.0001
                            	  2938: .0003:
00:00008CFC 123C002E        	  2939: 	move.b #'.',d1
                            	  2940: .0001:
00:00008D00 61000E88        	  2941: 	bsr	OutputChar
00:00008D04 51CAFFE8        	  2942: 	dbra d2,.0002
00:00008D08 123C0022        	  2943: 	move.b #34,d1
00:00008D0C 61000E7C        	  2944: 	bsr	OutputChar
00:00008D10 4EB9000008AE    	  2945: 	bsr	CheckForCtrlC
00:00008D16 6000EDB2        	  2946: 	bra	CRLF
                            	  2947: 
                            	  2948: ;------------------------------------------------------------------------------
                            	  2949: ; Dump Registers
                            	  2950: ;    The dump is in a format that allows the register value to be edited.
                            	  2951: ;
                            	  2952: ; RegD0 12345678
                            	  2953: ; RegD1 77777777
                            	  2954: ;	... etc
                            	  2955: ;------------------------------------------------------------------------------
                            	  2956: 
                            	  2957: cmdDumpRegs:
00:00008D1A 6100EDAE        	  2958: 	bsr	CRLF
00:00008D1E 363C000F        	  2959: 	move.w #15,d3						; number of registers-1
00:00008D22 41FA007A        	  2960: 	lea	msg_reglist,a0			;
00:00008D26 43FA0072        	  2961: 	lea	msg_regs,a1
00:00008D2A 45F900040100    	  2962: 	lea	Regsave,a2					; a2 points to register save area
                            	  2963: .0001:
00:00008D30 6100EDB2        	  2964: 	bsr			DisplayString
00:00008D34 1218            	  2965: 	move.b	(a0)+,d1
00:00008D36 61000E52        	  2966: 	bsr			OutputChar
00:00008D3A 1218            	  2967: 	move.b	(a0)+,d1
00:00008D3C 61000E4C        	  2968: 	bsr			OutputChar
00:00008D40 6100067A        	  2969: 	bsr			DisplaySpace
00:00008D44 221A            	  2970: 	move.l	(a2)+,d1
00:00008D46 6100067C        	  2971: 	bsr			DisplayTetra
00:00008D4A 6100ED7E        	  2972: 	bsr			CRLF
00:00008D4E 51CBFFE0        	  2973: 	dbra		d3,.0001
00:00008D52 6100ED90        	  2974: 	bsr			DisplayString
00:00008D56 1218            	  2975: 	move.b	(a0)+,d1
00:00008D58 61000E30        	  2976: 	bsr			OutputChar
00:00008D5C 1218            	  2977: 	move.b	(a0)+,d1
00:00008D5E 61000E2A        	  2978: 	bsr			OutputChar
00:00008D62 61000658        	  2979: 	bsr			DisplaySpace
00:00008D66 223900040144    	  2980: 	move.l	Regsave+$44,d1
00:00008D6C 61000656        	  2981: 	bsr			DisplayTetra
00:00008D70 6100ED58        	  2982: 	bsr			CRLF
00:00008D74 6100ED6E        	  2983: 	bsr			DisplayString
00:00008D78 1218            	  2984: 	move.b	(a0)+,d1
00:00008D7A 61000E0E        	  2985: 	bsr			OutputChar
00:00008D7E 1218            	  2986: 	move.b	(a0)+,d1
00:00008D80 61000E08        	  2987: 	bsr			OutputChar
00:00008D84 61000636        	  2988: 	bsr			DisplaySpace
00:00008D88 323900040140    	  2989: 	move.w	Regsave+$40,d1
00:00008D8E 6100063A        	  2990: 	bsr			DisplayWyde
00:00008D92 6100ED36        	  2991: 	bsr			CRLF
00:00008D96 6000F3A0        	  2992: 	bra			Monitor
                            	  2993: 
                            	  2994: msg_regs:
00:00008D9A 526567          	  2995: 	dc.b	"Reg",0
00:00008D9D 00
                            	  2996: msg_reglist:
00:00008D9E 4430443144324433	  2997: 	dc.b	"D0D1D2D3D4D5D6D7A0A1A2A3A4A5A6A7PCSR",0
00:00008DA6 4434443544364437
00:00008DAE 4130413141324133
00:00008DB6 4134413541364137
00:00008DBE 50435352
00:00008DC2 00
                            	  2998: 
                            	  2999: 	align	1
                            	  3000: 
                            	  3001: ;------------------------------------------------------------------------------
                            	  3002: ;------------------------------------------------------------------------------
                            	  3003: 
                            	  3004: cmdTestSerialReceive:
                            	  3005: .0002:
00:00008DC4 7024            	  3006: 	moveq		#36,d0				; serial get char from buffer
00:00008DC6 4E4F            	  3007: 	trap		#15
                            	  3008: ;	bsr			SerialPeekCharDirect
00:00008DC8 4A41            	  3009: 	tst.w		d1
00:00008DCA 6B0A            	  3010: 	bmi.s		.0001
00:00008DCC 0C01001A        	  3011: 	cmpi.b	#CTRLZ,d1
00:00008DD0 670C            	  3012: 	beq			.0003
00:00008DD2 61000DB6        	  3013: 	bsr			OutputChar
                            	  3014: .0001:	
00:00008DD6 4EB9000008AE    	  3015: 	bsr			CheckForCtrlC
00:00008DDC 60E6            	  3016: 	bra			.0002
                            	  3017: .0003:
00:00008DDE 4EB9000006B4    	  3018: 	bsr			_KeybdInit
00:00008DE4 6000F352        	  3019: 	bra			Monitor
                            	  3020: 
                            	  3021: ;------------------------------------------------------------------------------
                            	  3022: ; Get a hexidecimal number. Maximum of eight digits.
                            	  3023: ;
                            	  3024: ; Returns:
                            	  3025: ;		d0 = number of digits
                            	  3026: ;		d1 = value of number
                            	  3027: ;		zf = number of digits == 0
                            	  3028: ;------------------------------------------------------------------------------
                            	  3029: 
                            	  3030: GetHexNumber:
00:00008DE8 2F02            	  3031: 	move.l d2,-(a7)
00:00008DEA 7400            	  3032: 	clr.l	d2
00:00008DEC 7000            	  3033: 	moveq	#0,d0
                            	  3034: .0002
00:00008DEE 6100F334        	  3035: 	bsr	FromScreen
00:00008DF2 6100057C        	  3036: 	bsr	AsciiToHexNybble
00:00008DF6 0C0100FF        	  3037: 	cmpi.b #$ff,d1
00:00008DFA 6712            	  3038: 	beq.s	.0001
00:00008DFC E98A            	  3039: 	lsl.l	#4,d2
00:00008DFE 02810000000F    	  3040: 	andi.l #$0f,d1
00:00008E04 8481            	  3041: 	or.l d1,d2
00:00008E06 5240            	  3042: 	addq #1,d0
00:00008E08 0C000008        	  3043: 	cmpi.b #8,d0
00:00008E0C 65E0            	  3044: 	blo.s	.0002
                            	  3045: .0001
00:00008E0E 2202            	  3046: 	move.l d2,d1
00:00008E10 241F            	  3047: 	move.l (a7)+,d2
00:00008E12 4A00            	  3048: 	tst.b	d0
00:00008E14 4E75            	  3049: 	rts	
                            	  3050: 
                            	  3051: GetDecNumber:
00:00008E16 48E73000        	  3052: 	movem.l d2/d3,-(a7)
00:00008E1A 7400            	  3053: 	clr.l d2
00:00008E1C 7000            	  3054: 	clr.l d0
                            	  3055: .0002
00:00008E1E 6100F304        	  3056: 	bsr FromScreen					; grab a character off the screen
00:00008E22 6100054C        	  3057: 	bsr	AsciiToHexNybble		; convert to an ascii nybble
00:00008E26 0C0100FF        	  3058: 	cmpi.b #$ff,d1
00:00008E2A 6718            	  3059: 	beq.s	.0001
00:00008E2C 02810000000F    	  3060: 	andi.l #$0F,d1					; d1 = 0 to 9
00:00008E32 2602            	  3061: 	move.l d2,d3						; d3 = current number
00:00008E34 D683            	  3062: 	add.l d3,d3							; d3*2
00:00008E36 E78A            	  3063: 	lsl.l #3,d2							; current number * 8
00:00008E38 D483            	  3064: 	add.l d3,d2							; current number * 10
00:00008E3A D481            	  3065: 	add.l d1,d2							; add in new digit
00:00008E3C 5240            	  3066: 	addq #1,d0							; increment number of digits
00:00008E3E 0C000009        	  3067: 	cmpi.b #9,d0						; make sure 9 or fewer
00:00008E42 65DA            	  3068: 	blo .0002
                            	  3069: .0001
00:00008E44 2202            	  3070: 	move.l d2,d1						; return number in d1
00:00008E46 4CDF000C        	  3071: 	movem.l (a7)+,d2/d3
00:00008E4A 4A00            	  3072: 	tst.b d0
00:00008E4C 4E75            	  3073: 	rts
                            	  3074: 	
                            	  3075: 	include "FloatToString.x68"

Source: "FloatToString.x68"
                            	     1: 	code
                            	     2: ;==============================================================================
                            	     3: ; Decimal-Floating point to string conversion routine.
                            	     4: ;
                            	     5: ; Modifies
                            	     6: ;		_fpWork work area
                            	     7: ; Register Usage:
                            	     8: ; 	fp0 = input decimal-float to convert
                            	     9: ;		fp1 = constant holder, 1.0, 10.0
                            	    10: ;		fp2 = 1.0e<fp0 exponent> value for conversion
                            	    11: ;		fp3 = holds digit value during significand conversion
                            	    12: ; 	a0 = pointer to string buffer, updated to point to NULL at end of string
                            	    13: ;		a1 = pointer to "Nan" or "Inf" message string
                            	    14: ;		d0 = temporary
                            	    15: ;		d1 = digit value during exponent, significand conversion
                            	    16: ; 	d6 = exponent
                            	    17: ;==============================================================================
                            	    18: 	align 4
00:00008E50 25FF0000        	    19: _dfOne	dc.l $25ff0000,$00000000,$00000000
00:00008E54 00000000
00:00008E58 00000000
00:00008E5C 2600C000        	    20: _dfTen	dc.l $2600C000,$00000000,$00000000
00:00008E60 00000000
00:00008E64 00000000
00:00008E68 2606DDFA        	    21: _dfMil  dc.l $2606DDFA,$1C000000,$00000000
00:00008E6C 1C000000
00:00008E70 00000000
                            	    22: 
00:00008E74 4E614E          	    23: _msgNan	dc.b "NaN",0
00:00008E77 00
00:00008E78 496E66          	    24: _msgInf dc.b "Inf",0
00:00008E7B 00
                            	    25: 	even
                            	    26: 
                            	    27: ;------------------------------------------------------------------------------
                            	    28: ; Check for the special Nan and infinity values. Output the appropriate string.
                            	    29: ;
                            	    30: ; Modifies
                            	    31: ;		_fpWork area
                            	    32: ;		a0
                            	    33: ; Parameters:
                            	    34: ;		fp0 = dbl
                            	    35: ;------------------------------------------------------------------------------
                            	    36: 
                            	    37: _CheckNan:
00:00008E7C 4E52FFF4        	    38: 	link a2,#-12
00:00008E80 48D70201        	    39: 	movem.l d0/a1,(sp)
00:00008E84 2F79000400980008	    40: 	move.l _canary,8(sp)
00:00008E8C F239680000040600	    41: 	fmove.x fp0,_fpWork
00:00008E94 103900040600    	    42: 	move.b _fpWork,d0				; get sign+combo
00:00008E9A 0200007C        	    43: 	andi.b #$7C,d0					; mask for combo bits
00:00008E9E 0C00007C        	    44: 	cmpi.b #$7C,d0					; is it the Nan combo?
00:00008EA2 6606            	    45: 	bne .notNan
00:00008EA4 43FAFFCE        	    46: 	lea _msgNan,a1					; output "Nan"
00:00008EA8 600A            	    47: 	bra .outStr
                            	    48: .notNan
00:00008EAA 0C000078        	    49: 	cmpi.b #$78,d0					; is it infinity combo?
00:00008EAE 661E            	    50: 	bne .notInf
00:00008EB0 43FAFFC6        	    51: 	lea _msgInf,a1
                            	    52: .outStr
00:00008EB4 10D9            	    53: 	move.b (a1)+,(a0)+			; output "Inf"
00:00008EB6 10D9            	    54: 	move.b (a1)+,(a0)+
00:00008EB8 10D9            	    55: 	move.b (a1)+,(a0)+
00:00008EBA 4210            	    56: 	clr.b (a0)
00:00008EBC 4CD70201        	    57: 	movem.l (sp),d0/a1
00:00008EC0 A2AF00030008    	    58: 	cchk 8(sp)
00:00008EC6 4E5A            	    59: 	unlk a2
00:00008EC8 003C0001        	    60: 	ori #1,ccr							; set carry and return
00:00008ECC 4E75            	    61: 	rts
                            	    62: .notInf
00:00008ECE 4CD70201        	    63: 	movem.l (sp),d0/a1
00:00008ED2 A2AF00030008    	    64: 	cchk 8(sp)
00:00008ED8 4E5A            	    65: 	unlk a2
00:00008EDA 023C00FE        	    66: 	andi #$FE,ccr						; clear carry and return
00:00008EDE 4E75            	    67: 	rts
                            	    68: 
                            	    69: ;------------------------------------------------------------------------------
                            	    70: ; Check for a zero value. Output a single "0" if zero,
                            	    71: ;
                            	    72: ; Modifies:
                            	    73: ;		a0
                            	    74: ; Parameters:
                            	    75: ;		fp0 = dbl
                            	    76: ;------------------------------------------------------------------------------
                            	    77: 
                            	    78: _CheckZero:
00:00008EE0 F200003A        	    79: 	ftst fp0								; check if number is zero
00:00008EE4 F28E000E        	    80: 	fbne .0003
00:00008EE8 10FC0030        	    81: 	move.b #'0',(a0)+				; if zero output "0"
00:00008EEC 4210            	    82: 	clr.b (a0)
00:00008EEE 003C0004        	    83: 	ori #4,ccr							; set zf
00:00008EF2 4E75            	    84: 	rts
                            	    85: .0003
00:00008EF4 023C00FB        	    86: 	andi #$FB,ccr						; clear zf
00:00008EF8 4E75            	    87: 	rts
                            	    88: 
                            	    89: ;------------------------------------------------------------------------------
                            	    90: ; Check for a negative number. This includes Nans and Infinities. Output a "-"
                            	    91: ; if negative.
                            	    92: ;
                            	    93: ;	Modifies
                            	    94: ;		a0
                            	    95: ; Parameters:
                            	    96: ;		fp0 = dbl
                            	    97: ;------------------------------------------------------------------------------
                            	    98: 
                            	    99: _CheckNegative:
00:00008EFA F200003A        	   100: 	ftst fp0								; is number negative?
00:00008EFE F293000A        	   101: 	fbge .0002
00:00008F02 10FC002D        	   102: 	move.b #'-',(a0)+				; yes, output '-'
00:00008F06 F200001A        	   103: 	fneg fp0								; make fp0 positive
                            	   104: .0002
00:00008F0A 4E75            	   105: 	rts
                            	   106: 
                            	   107: ;------------------------------------------------------------------------------
                            	   108: ; Make the input value larger so that digits may appear before the decimal
                            	   109: ; point.
                            	   110: ;
                            	   111: ; Modifies:
                            	   112: ;		fp0,fp1,d6
                            	   113: ; Parameters:
                            	   114: ;		fp0 = dbl
                            	   115: ;------------------------------------------------------------------------------
                            	   116: 
                            	   117: ;	if (dbl < 1.0) {
                            	   118: ;		while (dbl < 1.0) {
                            	   119: ;			dbl *= 1000000.0;
                            	   120: ;			exp -= 6;  
                            	   121: ;		}
                            	   122: ;	}
                            	   123: 
                            	   124: _MakeBig:
00:00008F0C F23C50800001    	   125: 	fmove.w #1,fp1
                            	   126: .0002
00:00008F12 F2000438        	   127: 	fcmp fp1,fp0						; is fp0 > 1?
00:00008F16 F293000E        	   128: 	fbge .0001							; yes, return
00:00008F1A F23C402600000006	   129: 	fscale.l #6,fp0					; multiply fp0 by a million
00:00008F22 5D46            	   130: 	subi.w #6,d6						; decrement exponent by six
00:00008F24 60EC            	   131: 	bra .0002								; keep trying until number is > 1
                            	   132: .0001
00:00008F26 4E75            	   133: 	rts
                            	   134: 	
                            	   135: ;------------------------------------------------------------------------------
                            	   136: ;	Create a number dbl2 on the same order of magnitude as dbl, but
                            	   137: ;	less than dbl. The number will be 1.0e<dbl's exponent>
                            	   138: ;
                            	   139: ; Modifies:
                            	   140: ;		d6,fp2
                            	   141: ; Parameters:
                            	   142: ;		fp0 = dbl
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: ;	// The following is similar to using log10() and pow() functions.
                            	   146: ;	// Now dbl is >= 1.0
                            	   147: ;	// Create a number dbl2 on the same order of magnitude as dbl, but
                            	   148: ;	// less than dbl.
                            	   149: ;	dbl2 = 1.0;
                            	   150: ;	dbla = dbl2;
                            	   151: ;	if (dbl > dbl2) {	// dbl > 1.0 ?
                            	   152: ;		while (dbl2 <= dbl) {
                            	   153: ;			dbla = dbl2;
                            	   154: ;			dbl2 *= 10.0;	// increase power of 10
                            	   155: ;			exp++;
                            	   156: ;		}
                            	   157: ;		// The above loop goes one too far, we want the last value less
                            	   158: ;		// than dbl.
                            	   159: ;		dbl2 = dbla;
                            	   160: ;		exp--;
                            	   161: ;	}
                            	   162: 
                            	   163: _LessThanDbl:
00:00008F28 F23C51000001    	   164: 	fmove.w #1,fp2			; setup fp2 = 1
00:00008F2E F2000838        	   165: 	fcmp fp2,fp0				; if (dbl > dbl2)
00:00008F32 F295001E        	   166: 	fble .0004
                            	   167: .0006
00:00008F36 F2000138        	   168: 	fcmp fp0,fp2				; while (dbl2 <= dbl)
00:00008F3A F292000C        	   169: 	fbgt .0005
00:00008F3E F23C51260001    	   170: 	fscale.w #1,fp2			; dbl2 *= 10 (increase exponent by one)
00:00008F44 5246            	   171: 	addi.w #1,d6				; exp++
00:00008F46 60EE            	   172: 	bra .0006
                            	   173: .0005
00:00008F48 F23C4126FFFFFFFF	   174: 	fscale.l #-1,fp2		; dbl2 /= 10 (decrease exponent by one)
00:00008F50 5346            	   175: 	subi.w #1,d6				; exp--;
                            	   176: .0004	
                            	   177: ;	fmove.x fp0,_fpWork	; debugging
                            	   178: ;	fmove.x fp2,_fpWork+12
00:00008F52 4E75            	   179: 	rts
                            	   180: 
                            	   181: ;------------------------------------------------------------------------------
                            	   182: ; Compute the number of digits before the decimal point.
                            	   183: ;
                            	   184: ; Modifies:
                            	   185: ;		d0,d6,_digits_before_decpt
                            	   186: ; Parameters:
                            	   187: ;		d6 = exponent
                            	   188: ;------------------------------------------------------------------------------
                            	   189: 
                            	   190: ; if (exp >= 0 && exp < 6) {
                            	   191: ;   digits_before_decpt = exp+1;
                            	   192: ;		exp = 0;
                            	   193: ;	}
                            	   194: ;	else if (exp >= -7)
                            	   195: ;		digits_before_decpt = 1;
                            	   196: ;	else
                            	   197: ;		digits_before_decpt = -1;
                            	   198: 
                            	   199: _ComputeDigitsBeforeDecpt:
00:00008F54 2F00            	   200: 	move.l d0,-(a7)
00:00008F56 4A46            	   201: 	tst.w d6
00:00008F58 6B16            	   202: 	bmi .0007
00:00008F5A 0C460006        	   203: 	cmpi.w #6,d6
00:00008F5E 6C10            	   204: 	bge .0007
00:00008F60 3006            	   205: 	move.w d6,d0
00:00008F62 5240            	   206: 	addi.w #1,d0
00:00008F64 33C000040510    	   207: 	move.w d0,_digits_before_decpt	
00:00008F6A 4246            	   208: 	clr.w d6
00:00008F6C 201F            	   209: 	move.l (a7)+,d0
00:00008F6E 4E75            	   210: 	rts
                            	   211: .0007
00:00008F70 0C46FFF9        	   212: 	cmpi.w #-7,d6
00:00008F74 6D0C            	   213: 	blt .0009
00:00008F76 33FC000100040510	   214: 	move.w #1,_digits_before_decpt
00:00008F7E 201F            	   215: 	move.l (a7)+,d0
00:00008F80 4E75            	   216: 	rts
                            	   217: .0009
00:00008F82 33FCFFFF00040510	   218: 	move.w #-1,_digits_before_decpt
00:00008F8A 201F            	   219: 	move.l (a7)+,d0
00:00008F8C 4E75            	   220: 	rts
                            	   221: 
                            	   222: ;------------------------------------------------------------------------------
                            	   223: ;	Spit out a leading zero before the decimal point for a small number.
                            	   224: ;
                            	   225: ; Modifies:
                            	   226: ;		a0
                            	   227: ; Parameters:
                            	   228: ;		d6 = exponent
                            	   229: ;------------------------------------------------------------------------------
                            	   230: 
                            	   231: ;  if (exp < -7) {
                            	   232: ;		 buf[ndx] = '0';
                            	   233: ;		 ndx++;
                            	   234: ;    buf[ndx] = '.';
                            	   235: ;    ndx++;
                            	   236: ;  }
                            	   237: 
                            	   238: _LeadingZero:
00:00008F8E 0C46FFF9        	   239: 	cmpi.w #-7,d6
00:00008F92 6C08            	   240: 	bge .0010
00:00008F94 10FC0030        	   241: 	move.b #'0',(a0)+
00:00008F98 10FC002E        	   242: 	move.b #'.',(a0)+
                            	   243: .0010
00:00008F9C 4E75            	   244: 	rts
                            	   245: 
                            	   246: ;------------------------------------------------------------------------------
                            	   247: ; Extract the digits of the significand.
                            	   248: ;
                            	   249: ; Modifies:
                            	   250: ;		_precision variable
                            	   251: ; Register Usage
                            	   252: ;		d0 = counter
                            	   253: ;		d1 = digit
                            	   254: ;		fp0 = dbl
                            	   255: ;		fp2 = dbl2
                            	   256: ;		fp3 = digit as decimal float
                            	   257: ;		fp7 = dbla
                            	   258: ; Parameters:
                            	   259: ;		fp0, fp2
                            	   260: ;------------------------------------------------------------------------------
                            	   261: 
                            	   262: ;	// Now loop processing one digit at a time.
                            	   263: ;  for (nn = 0; nn < 25 && precision > 0; nn++) {
                            	   264: ;    digit = 0;
                            	   265: ;		dbla = dbl;
                            	   266: ;		// dbl is on the same order of magnitude as dbl2 so
                            	   267: ;		// a repeated subtract can be used to find the digit.
                            	   268: ;    while (dbl >= dbl2) {
                            	   269: ;      dbl -= dbl2;
                            	   270: ;      digit++;
                            	   271: ;    }
                            	   272: ;    buf[ndx] = digit + '0';
                            	   273: ;		// Now go back and perform just a single subtract and
                            	   274: ;		// a multiply to find out how much to reduce dbl by.
                            	   275: ;		// This should improve the accuracy
                            	   276: ;		if (digit > 2)
                            	   277: ;			dbl = dbla - dbl2 * digit;
                            	   278: ;    ndx++;
                            	   279: ;    digits_before_decpt--;
                            	   280: ;    if (digits_before_decpt==0) {
                            	   281: ;			buf[ndx] = '.';
                            	   282: ;			ndx++;
                            	   283: ;    }
                            	   284: ;    else if (digits_before_decpt < 0)
                            	   285: ;      precision--;
                            	   286: ;		// Shift the next digit to be tested into position.
                            	   287: ;    dbl *= 10.0;
                            	   288: ;  }
                            	   289: 	
                            	   290: _SpitOutDigits:
00:00008F9E 4E52FFE8        	   291: 	link a2,#-24
00:00008FA2 2F79000400980014	   292: 	move.l _canary,20(sp)
00:00008FAA F2176B80        	   293: 	fmove.x fp7,(sp)
00:00008FAE 48EF0003000C    	   294: 	movem.l d0/d1,12(sp)
00:00008FB4 303C0018        	   295: 	move.w #24,d0			; d0 = nn
                            	   296: .0017	
00:00008FB8 4AB900040514    	   297: 	tst.l _precision
00:00008FBE 6F46            	   298: 	ble .0011
00:00008FC0 7200            	   299: 	moveq #0,d1				; digit = 0
00:00008FC2 F2000380        	   300: 	fmove fp0,fp7			; dbla = dbl
                            	   301: .0013
00:00008FC6 F2000838        	   302: 	fcmp fp2,fp0
00:00008FCA F294000A        	   303: 	fblt .0012
00:00008FCE F2000828        	   304: 	fsub fp2,fp0			; dbl -= dbl2
00:00008FD2 5201            	   305: 	addi.b #1,d1			; digit++
00:00008FD4 60F0            	   306: 	bra .0013
                            	   307: .0012
00:00008FD6 06010030        	   308: 	addi.b #'0',d1		; convert digit to ascii
00:00008FDA 10C1            	   309: 	move.b d1,(a0)+		; and store
00:00008FDC 04010030        	   310: 	subi.b #'0',d1		; d1 = binary digit again
                            	   311: ;	cmpi.b #2,d1
                            	   312: ;	ble .0014
                            	   313: 
                            	   314: ;	ext.w d1
                            	   315: ;	ext.l d1
                            	   316: ;	fmove.l d1,fp3		; fp3 = digit
                            	   317: ;	fmul fp2,fp3			; fp3 = dbl2 * digit
                            	   318: ;	fmove fp7,fp0
                            	   319: ;	fsub fp3,fp0			; dbl = dbla - dbl2 * digit
                            	   320: .0014
00:00008FE0 537900040510    	   321: 	subi.w #1,_digits_before_decpt
00:00008FE6 6604            	   322: 	bne .0015
00:00008FE8 10FC002E        	   323: 	move.b #'.',(a0)+
                            	   324: .0015
00:00008FEC 4A7900040510    	   325: 	tst.w _digits_before_decpt
00:00008FF2 6C06            	   326: 	bge .0016
00:00008FF4 53B900040514    	   327: 	subi.l #1,_precision
                            	   328: .0016
00:00008FFA F23C4126FFFFFFFF	   329: 	fscale.l #-1,fp2		; dbl *= 10.0
00:00009002 51C8FFB4        	   330: 	dbra d0,.0017
                            	   331: .0011
00:00009006 4CEF0003000C    	   332: 	movem.l 12(sp),d0/d1
00:0000900C F2174B80        	   333: 	fmove.x (sp),fp7
00:00009010 A2AF00030014    	   334: 	cchk 20(sp)
00:00009016 4E5A            	   335: 	unlk a2
00:00009018 4E75            	   336: 	rts
                            	   337: 
                            	   338: ;------------------------------------------------------------------------------
                            	   339: ; If the number ends in a decimal point, trim off the point.
                            	   340: ;
                            	   341: ; Registers Modified:
                            	   342: ;		none
                            	   343: ; Parameters:
                            	   344: ;		a0 = pointer to end of number
                            	   345: ; Returns:
                            	   346: ;		a0 = updated to point just past last digit.
                            	   347: ;------------------------------------------------------------------------------
                            	   348: 
                            	   349: _TrimTrailingPoint:
00:0000901A 0C28002EFFFF    	   350: 	cmpi.b #'.',-1(a0)
00:00009020 6604            	   351: 	bne .0001
00:00009022 4220            	   352: 	clr.b -(a0)
00:00009024 4E75            	   353: 	rts
                            	   354: .0001
00:00009026 0C10002E        	   355: 	cmpi.b #'.',(a0)
00:0000902A 660A            	   356: 	bne .0002
00:0000902C 4A280001        	   357: 	cmpi.b #0,1(a0)
00:00009030 6604            	   358: 	bne .0002
00:00009032 4210            	   359: 	clr.b (a0)
00:00009034 5348            	   360: 	subq #1,a0
                            	   361: .0002
00:00009036 4E75            	   362: 	rts
                            	   363: 	
                            	   364: ;------------------------------------------------------------------------------
                            	   365: ; If the number ends in .0 get rid of the .0
                            	   366: ;
                            	   367: ; Registers Modified:
                            	   368: ;		none
                            	   369: ; Parameters:
                            	   370: ;		a0 = pointer to last digits of number
                            	   371: ; Returns:
                            	   372: ;		a0 = updated to point just past last digit.
                            	   373: ;------------------------------------------------------------------------------
                            	   374: 
                            	   375: _TrimDotZero:
00:00009038 4A10            	   376: 	tst.b (a0)
00:0000903A 6616            	   377: 	bne .0004
00:0000903C 0C280030FFFF    	   378: 	cmpi.b #'0',-1(a0)
00:00009042 660E            	   379: 	bne .0004
00:00009044 0C28002EFFFE    	   380: 	cmpi.b #'.',-2(a0)
00:0000904A 6606            	   381: 	bne .0004
00:0000904C 4228FFFE        	   382: 	clr.b -2(a0)
00:00009050 5548            	   383: 	subq #2,a0
                            	   384: .0004
00:00009052 4E75            	   385: 	rts
                            	   386: 
                            	   387: ;------------------------------------------------------------------------------
                            	   388: ; Trim trailing zeros from the number. Generally there is no need to display
                            	   389: ; trailing zeros.
                            	   390: ; Turns a number like 652.000000000000000000000 into 650.0
                            	   391: ;
                            	   392: ; Registers Modified:
                            	   393: ;		none
                            	   394: ; Parameters:
                            	   395: ;		a0 = pointer to last digits of number
                            	   396: ; Returns:
                            	   397: ;		a0 = updated to point just past last digit.
                            	   398: ;------------------------------------------------------------------------------
                            	   399: 
                            	   400: ;	// Trim trailing zeros from the number
                            	   401: ;  do {
                            	   402: ;      ndx--;
                            	   403: ;  } while(buf[ndx]=='0');
                            	   404: ;  ndx++;
                            	   405: 
                            	   406: _TrimTrailingZeros:
                            	   407: .0018	
00:00009054 0C200030        	   408: 	cmpi.b #'0',-(a0)		; if the last digit was a zero, backup
00:00009058 67FA            	   409: 	beq .0018
00:0000905A 5248            	   410: 	addq #1,a0					; now advance by one
00:0000905C 4210            	   411: 	move.b #0,(a0)			; NULL terminate string
00:0000905E 4E75            	   412: 	rts
                            	   413: 
                            	   414: ;------------------------------------------------------------------------------
                            	   415: ; Output 'e+' or 'e-'
                            	   416: ;
                            	   417: ; Registers Modified:
                            	   418: ;		d6.w (if negative)
                            	   419: ; Parameters:
                            	   420: ;		a0 = pointer to last digits of number
                            	   421: ; Returns:
                            	   422: ;		a0 = updated to point just past '+' or '-'.
                            	   423: ;------------------------------------------------------------------------------
                            	   424: 
                            	   425: ;	// Spit out +/-E
                            	   426: ;  buf[ndx] = E;
                            	   427: ;  ndx++;
                            	   428: ;  if (exp < 0) {
                            	   429: ;    buf[ndx]='-';
                            	   430: ;    ndx++;
                            	   431: ;    exp = -exp;
                            	   432: ;  }
                            	   433: ;  else {
                            	   434: ;		buf[ndx]='+';
                            	   435: ;		ndx++;
                            	   436: ;  }
                            	   437: 
                            	   438: _SpitOutE:	
00:00009060 10F90004050C    	   439: 	move.b _E,(a0)+
00:00009066 4A46            	   440: 	tst.w d6
00:00009068 6C08            	   441: 	bge .0021
00:0000906A 10FC002D        	   442: 	move.b #'-',(a0)+
00:0000906E 4446            	   443: 	neg.w d6
00:00009070 6004            	   444: 	bra .0022
                            	   445: .0021
00:00009072 10FC002B        	   446: 	move.b #'+',(a0)+
                            	   447: .0022
00:00009076 4E75            	   448: 	rts
                            	   449: 
                            	   450: ;------------------------------------------------------------------------------
                            	   451: ; Extract a single digit of the exponent. Extract works from the leftmost digit
                            	   452: ; to the rightmost.
                            	   453: ;
                            	   454: ; Register Usage
                            	   455: ;		d2 = history of zeros
                            	   456: ;		d3 = digit
                            	   457: ; Modifies
                            	   458: ;		d2,d6,a0
                            	   459: ; Parameter
                            	   460: ; 	d1.w = power of ten
                            	   461: ;		d6.w = exponent
                            	   462: ;------------------------------------------------------------------------------
                            	   463: 
                            	   464: _ExtExpDigit:
00:00009078 2F03            	   465: 	move.l d3,-(a7)
00:0000907A 48C6            	   466: 	ext.l d6				; make d6 a long
00:0000907C 8CC1            	   467: 	divu d1,d6			; divide by power of ten
00:0000907E 1606            	   468: 	move.b d6,d3		; d3 = quotient (0 to 9)
00:00009080 4846            	   469: 	swap d6					; d6 = remainder, setup for next digit
00:00009082 8403            	   470: 	or.b d3,d2
00:00009084 4A03            	   471: 	tst.b d3
00:00009086 6604            	   472: 	bne .0003
00:00009088 4A02            	   473: 	tst.b d2	
00:0000908A 6706            	   474: 	beq .0004
                            	   475: .0003
00:0000908C 06030030        	   476: 	addi.b #'0',d3	; convert to ascii
00:00009090 10C3            	   477: 	move.b d3,(a0)+
                            	   478: .0004
00:00009092 261F            	   479: 	move.l (a7)+,d3
00:00009094 4E75            	   480: 	rts
                            	   481: 
                            	   482: ;------------------------------------------------------------------------------
                            	   483: ; Extract all the digits of the exponent.
                            	   484: ;
                            	   485: ; Register Usage
                            	   486: ;		d1 = power of 10
                            	   487: ;		d2 = history of zeros
                            	   488: ; Parameters
                            	   489: ;		a0 = pointer to string buffer
                            	   490: ;		d6 = exponent
                            	   491: ;------------------------------------------------------------------------------
                            	   492: 
                            	   493: ;	// If the number is times 10^0 don't output the exponent
                            	   494: ;  if (exp==0) {
                            	   495: ;    buf[ndx]='\0';
                            	   496: ;    goto prt;
                            	   497: ;  }
                            	   498: 
                            	   499: _ExtExpDigits:
00:00009096 2F01            	   500: 	move.l d1,-(a7)
00:00009098 4A46            	   501: 	tst.w d6							; is exponent zero?
00:0000909A 671C            	   502: 	beq .0002
00:0000909C 61C2            	   503: 	bsr _SpitOutE					; exponent is non-zero e+
00:0000909E 4202            	   504: 	clr.b d2							; d2 = history of zeros
00:000090A0 323C03E8        	   505: 	move.w #1000,d1
00:000090A4 61D2            	   506: 	bsr _ExtExpDigit
00:000090A6 323C0064        	   507: 	move.w #100,d1
00:000090AA 61CC            	   508: 	bsr _ExtExpDigit
00:000090AC 323C000A        	   509: 	move.w #10,d1
00:000090B0 61C6            	   510: 	bsr _ExtExpDigit
00:000090B2 323C0001        	   511: 	move.w #1,d1
00:000090B6 61C0            	   512: 	bsr _ExtExpDigit
                            	   513: .0002:
00:000090B8 221F            	   514: 	move.l (a7)+,d1
00:000090BA 4210            	   515: 	move.b #0,(a0)				; NULL terminate string
00:000090BC 4E75            	   516: 	rts										; and return
                            	   517: 
                            	   518: ;------------------------------------------------------------------------------
                            	   519: ; Pad the left side of the output string.
                            	   520: ;
                            	   521: ; Modifies:
                            	   522: ;		d0,d1,d2,d3
                            	   523: ;------------------------------------------------------------------------------
                            	   524: 
                            	   525: ;  // pad left
                            	   526: ;  if (width > 0) {
                            	   527: ;    if (ndx < width) {
                            	   528: ;      for (nn = 39; nn >= width-ndx; nn--)
                            	   529: ;        buf[nn] = buf[nn-(width-ndx)];
                            	   530: ;      for (; nn >= 0; nn--)
                            	   531: ;        buf[nn] = ' ';
                            	   532: ;    }
                            	   533: ;  }
                            	   534: 	
                            	   535: _PadLeft:
00:000090BE 48E7F000        	   536: 	movem.l d0/d1/d2/d3,-(a7)
00:000090C2 4A3900040508    	   537: 	tst.b _width
00:000090C8 6F3E            	   538: 	ble .0041
00:000090CA 2008            	   539: 	move.l a0,d0
00:000090CC 90BC00040520    	   540: 	sub.l #_fpBuf,d0	; d0 = ndx
00:000090D2 B03900040508    	   541: 	cmp.b _width,d0
00:000090D8 6C2E            	   542: 	bge .0041
00:000090DA 323C0031        	   543: 	move.w #49,d1			; d1 = nn
                            	   544: .0040
00:000090DE 143900040508    	   545: 	move.b _width,d2
00:000090E4 4882            	   546: 	ext.w d2
00:000090E6 9440            	   547: 	sub.w d0,d2				; d2 = width-ndx
00:000090E8 B242            	   548: 	cmp.w d2,d1
00:000090EA 6D0E            	   549: 	blt .0039
00:000090EC 3601            	   550: 	move.w d1,d3			; d3 = nn
00:000090EE 9642            	   551: 	sub.w d2,d3				; d3 = nn-(width-ndx)
00:000090F0 11B030001000    	   552: 	move.b (a0,d3.w),(a0,d1.w)
00:000090F6 5341            	   553: 	subi.w #1,d1
00:000090F8 60E4            	   554: 	bra .0040
                            	   555: .0039
00:000090FA 4A41            	   556: 	tst.w d1
00:000090FC 6B0A            	   557: 	bmi .0041
00:000090FE 11BC00201000    	   558: 	move.b #' ',(a0,d1.w)
00:00009104 5341            	   559: 	subi.w #1,d1
00:00009106 60F2            	   560: 	bra .0039
                            	   561: .0041
00:00009108 4CDF000F        	   562: 	movem.l (a7)+,d0/d1/d2/d3
00:0000910C 4E75            	   563: 	rts
                            	   564: 
                            	   565: ;------------------------------------------------------------------------------
                            	   566: ; Pad the right side of the output string.
                            	   567: ;
                            	   568: ; Parameters:
                            	   569: ;		a0 = pointer to end of string
                            	   570: ; Modifies:
                            	   571: ;		none
                            	   572: ; Returns:
                            	   573: ;		none
                            	   574: ;------------------------------------------------------------------------------
                            	   575: 
                            	   576: ;  // pad right
                            	   577: ;  if (width < 0) {
                            	   578: ;    width = -width;
                            	   579: ;    while (ndx < width) {
                            	   580: ;      buf[ndx]=' ';
                            	   581: ;      ndx++;
                            	   582: ;    }
                            	   583: ;    buf[ndx]='\0';
                            	   584: ;  }
                            	   585: ;  return (ndx);
                            	   586: 
                            	   587: _PadRight:
00:0000910E 2F00            	   588: 	move.l d0,-(a7)
00:00009110 4A3900040508    	   589: 	tst.b _width
00:00009116 6A24            	   590: 	bpl .0042
00:00009118 443900040508    	   591: 	neg.b _width
00:0000911E 2008            	   592: 	move.l a0,d0
00:00009120 90BC00040520    	   593: 	sub.l #_fpBuf,d0	; d0 = ndx
                            	   594: .0044
00:00009126 B03900040508    	   595: 	cmp.b _width,d0
00:0000912C 6C0A            	   596: 	bge .0043
00:0000912E 11BC00200000    	   597: 	move.b #' ',(a0,d0.w)
00:00009134 5240            	   598: 	addi.w #1,d0
00:00009136 60EE            	   599: 	bra .0044
                            	   600: .0043
00:00009138 42300000        	   601: 	move.b #0,(a0,d0.w)
                            	   602: .0042
00:0000913C 201F            	   603: 	move.l (a7)+,d0
00:0000913E 4E75            	   604: 	rts
                            	   605: 
                            	   606: ;------------------------------------------------------------------------------
                            	   607: ; Output a string representation of a decimal floating point number to a 
                            	   608: ; buffer.
                            	   609: ;
                            	   610: ; Register Usage
                            	   611: ;		a0 = pointer to string buffer
                            	   612: ;		d6 = exponent
                            	   613: ; Modifies:
                            	   614: ;		a0 = points to end of string
                            	   615: ; Parameters:
                            	   616: ;		fp0 = number to convert
                            	   617: ; Returns:
                            	   618: ;		none
                            	   619: ;------------------------------------------------------------------------------
                            	   620: 
                            	   621: _FloatToString:
00:00009140 2F06            	   622: 	move.l d6,-(a7)
00:00009142 6100FDB6        	   623: 	bsr _CheckNegative			; is number negative?
00:00009146 6100FD98        	   624: 	bsr _CheckZero					; check for zero
00:0000914A 6732            	   625: 	beq .0001								; branch since already output "0"
00:0000914C 6100FD2E        	   626: 	bsr _CheckNan						; check for Nan or infinity
00:00009150 652C            	   627: 	bcs .0001								; branch if nan/inf string output
                            	   628: 	; Now the fun begins
00:00009152 7C00            	   629: 	clr.l d6								; exponent = 0
00:00009154 6100FDB6        	   630: 	bsr _MakeBig
00:00009158 6100FDCE        	   631: 	bsr _LessThanDbl
00:0000915C 6100FDF6        	   632: 	bsr _ComputeDigitsBeforeDecpt
00:00009160 6100FE2C        	   633: 	bsr _LeadingZero
00:00009164 6100FE38        	   634: 	bsr _SpitOutDigits
00:00009168 6100FEEA        	   635: 	bsr _TrimTrailingZeros
00:0000916C 6100FEAC        	   636: 	bsr _TrimTrailingPoint
00:00009170 6100FEC6        	   637: 	bsr _TrimDotZero
00:00009174 6100FF20        	   638: 	bsr _ExtExpDigits				; extract exponent digits
00:00009178 6100FF44        	   639: 	bsr _PadLeft						; pad the number to the left or right
00:0000917C 6190            	   640: 	bsr _PadRight
                            	   641: .0001
00:0000917E 2C1F            	   642: 	move.l (a7)+,d6
00:00009180 4E75            	   643: 	rts
                            	   644: 
                            	   645: 

Source: "boot.x68"
                            	  3076: 	include "GetFloat.asm"

Source: "GetFloat.asm"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;
                            	    37: ; Get a floating point number
                            	    38: ;
                            	    39: _GetFloatGetChar:
00:00009182 1210            	    40: 	move.b (a0),d1
00:00009184 D1C0            	    41: 	add.l d0,a0
00:00009186 4E75            	    42: 	rts
                            	    43: _GetFloatIgnBlanks:
                            	    44: .0001
00:00009188 61F8            	    45: 	bsr _GetFloatGetChar
00:0000918A 0C010020        	    46: 	cmpi.b #' ',d1
00:0000918E 67F8            	    47: 	beq .0001
                            	    48: _GetFloatBackupChar:
00:00009190 91C0            	    49: 	sub.l d0,a0
00:00009192 4E75            	    50: 	rts
                            	    51: 
                            	    52: ;-------------------------------------------------------------------------------
                            	    53: ; Get fractional part of a number, 25 digits max, into a float register.
                            	    54: ;
                            	    55: ; Register Usage:
                            	    56: ;		d1 = digit from input screen
                            	    57: ;		d4 = digit count
                            	    58: ;		d6 = digit scaling factor
                            	    59: ;		fp1 = digit as float number
                            	    60: ; Returns:
                            	    61: ;		fp0 = fraction
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: _GetFraction:
00:00009194 4E52FFE4        	    65: 	link a2,#-28
00:00009198 2F79000400980018	    66: 	move.l _canary,24(sp)
00:000091A0 48D70052        	    67: 	movem.l d1/d4/d6,(sp)
00:000091A4 F22F6880000C    	    68: 	fmove.x fp1,12(sp)
00:000091AA 7C00            	    69: 	clr.l d6							; d6 = scale factor
00:000091AC F23C50000000    	    70: 	fmove.w #0,fp0				; fract = 0.0
00:000091B2 7818            	    71: 	moveq #24,d4
                            	    72: .0002
00:000091B4 61CC            	    73: 	bsr _GetFloatGetChar
00:000091B6 0C010030        	    74: 	cmpi.b #'0',d1
00:000091BA 6520            	    75: 	blo .0001
00:000091BC 0C010039        	    76: 	cmpi.b #'9',d1				; make sure between 0 and 9
00:000091C0 621A            	    77: 	bhi .0001
00:000091C2 04010030        	    78: 	subi.b #'0',d1
00:000091C6 F23C50260001    	    79: 	fscale.w #1,fp0				; fract * 10.0
00:000091CC 5246            	    80: 	addq #1,d6						; record scaling
00:000091CE F2015880        	    81: 	fmove.b d1,fp1				; fp1 = digit
00:000091D2 F2000422        	    82: 	fadd fp1,fp0					; fract += digit
00:000091D6 5245            	    83: 	addq.w #1,d5					; increment number of digits in number
00:000091D8 51CCFFDA        	    84: 	dbra d4,.0002
                            	    85: .0001
00:000091DC 61B2            	    86: 	bsr _GetFloatBackupChar
00:000091DE 4446            	    87: 	neg d6
00:000091E0 F2064026        	    88: 	fscale.l d6,fp0				; fract /= scale
00:000091E4 4CD70052        	    89: 	movem.l (sp),d1/d4/d6
00:000091E8 F22F4880000C    	    90: 	fmove.x 12(sp),fp1
00:000091EE A2AF00030018    	    91: 	cchk 24(sp)
00:000091F4 4E5A            	    92: 	unlk a2
00:000091F6 4E75            	    93: 	rts
                            	    94: 
                            	    95: ;-------------------------------------------------------------------------------
                            	    96: ; Get exponent part of a number, 4 digits max, into a float register.
                            	    97: ;
                            	    98: ; Register Usage:
                            	    99: ;		d1 = digit from input screen
                            	   100: ;		d2 = exponent
                            	   101: ;		d3 = temp, number times 2
                            	   102: ;		d4 = digit counter
                            	   103: ; Parameters:
                            	   104: ;		fp0 = float number
                            	   105: ; Returns:
                            	   106: ;		fp0 = float number with exponent factored in
                            	   107: ;-------------------------------------------------------------------------------
                            	   108: 
                            	   109: _GetExponent:
00:000091F8 4E52FFE0        	   110: 	link a2,#-32
00:000091FC 2F7900040098001C	   111: 	move.l _canary,28(sp)
00:00009204 48D7001E        	   112: 	movem.l d1/d2/d3/d4,(sp)
00:00009208 F22F69000010    	   113: 	fmove.x fp2,16(sp)
00:0000920E 7400            	   114: 	clr.l d2							; d2 = number = 0
00:00009210 F23C51000000    	   115: 	fmove.w #0,fp2				; fp2 = exp = 0.0
00:00009216 7601            	   116: 	moveq #1,d3						; d3 = exscale = 1
00:00009218 6100FF68        	   117: 	bsr _GetFloatGetChar
00:0000921C 0C01002D        	   118: 	cmpi.b #'-',d1
00:00009220 6608            	   119: 	bne .0001
00:00009222 4483            	   120: 	neg.l d3							; exscale = -1
                            	   121: .0006
00:00009224 6100FF62        	   122: 	bsr _GetFloatIgnBlanks
00:00009228 600A            	   123: 	bra .0002
                            	   124: .0001
00:0000922A 0C01002B        	   125: 	cmpi.b #'+',d1
00:0000922E 67F4            	   126: 	beq .0006
00:00009230 6100FF5E        	   127: 	bsr _GetFloatBackupChar
                            	   128: .0002	
00:00009234 7803            	   129: 	moveq #3,d4						; d4 = max 4 digits
                            	   130: .0004
00:00009236 6100FF4A        	   131: 	bsr _GetFloatGetChar	; d1 = digit char
00:0000923A 0C010030        	   132: 	cmpi.b #'0',d1
00:0000923E 651E            	   133: 	blo .0003
00:00009240 0C010039        	   134: 	cmpi.b #'9',d1				; ensure between 0 and 9
00:00009244 6218            	   135: 	bhi .0003
00:00009246 04010030        	   136: 	subi.b #'0',d1
00:0000924A D482            	   137: 	add.l d2,d2						; number *2
00:0000924C 2602            	   138: 	move.l d2,d3
00:0000924E E58A            	   139: 	lsl.l #2,d2						; number *8
00:00009250 D483            	   140: 	add.l d3,d2						; number *10	
00:00009252 4881            	   141: 	ext.w d1
00:00009254 48C1            	   142: 	ext.l d1
00:00009256 D481            	   143: 	add.l d1,d2						; number + digit
00:00009258 5245            	   144: 	addq.w #1,d5					; increment number of digits in number
00:0000925A 51CCFFDA        	   145: 	dbra d4,.0004
                            	   146: .0003
00:0000925E 6100FF30        	   147: 	bsr _GetFloatBackupChar	; backup a character
00:00009262 C4C3            	   148: 	mulu d3,d2						; *1 or *-1
00:00009264 48C2            	   149: 	ext.l d2
00:00009266 F2024126        	   150: 	fscale.l d2,fp2				; exp * exmul
00:0000926A F2000823        	   151: 	fmul fp2,fp0					; rval *= exp
00:0000926E 4CD7001E        	   152: 	movem.l (sp),d1/d2/d3/d4
00:00009272 F22F49000010    	   153: 	fmove.x 16(sp),fp2
00:00009278 A2AF0003001C    	   154: 	cchk 28(sp)
00:0000927E 4E5A            	   155: 	unlk a2
00:00009280 4E75            	   156: 	rts	
                            	   157: 
                            	   158: ;-------------------------------------------------------------------------------
                            	   159: ; Get an integer number, positive or negative, 25 digits max, into a float
                            	   160: ; register.
                            	   161: ;
                            	   162: ; Register Usage:
                            	   163: ;		d1 = digit from input screen
                            	   164: ;		d2 = digit down counter
                            	   165: ;		d3 = sign of number '+' or '-'
                            	   166: ;		fp1 = digit
                            	   167: ; Modifies:
                            	   168: ;		a0,fp0
                            	   169: ; Returns:
                            	   170: ;		a0 = updated buffer pointer
                            	   171: ;		fp0 = integer number
                            	   172: ;-------------------------------------------------------------------------------
                            	   173: 
                            	   174: _GetInteger:
00:00009282 4E52FFE4        	   175: 	link a2,#-28
00:00009286 2F79000400980018	   176: 	move.l _canary,24(sp)
00:0000928E 48D7000E        	   177: 	movem.l d1/d2/d3,(sp)
00:00009292 F22F6880000C    	   178: 	fmove.x fp1,12(sp)
00:00009298 F23C50000000    	   179: 	fmove.w #0,fp0
00:0000929E 7418            	   180: 	moveq #24,d2					; d2 = digit count (25 max)
00:000092A0 6100FEE6        	   181: 	bsr _GetFloatIgnBlanks
00:000092A4 6100FEDC        	   182: 	bsr _GetFloatGetChar	; get the sign of the number
00:000092A8 0C01002B        	   183: 	cmpi.b #'+',d1
00:000092AC 670A            	   184: 	beq .0002
                            	   185: .0003
00:000092AE 0C01002D        	   186: 	cmpi.b #'-',d1
00:000092B2 6608            	   187: 	bne .0004
00:000092B4 1E3C002D        	   188: 	move.b #'-',d7
                            	   189: .0002
00:000092B8 6100FEC8        	   190: 	bsr _GetFloatGetChar
                            	   191: .0004
00:000092BC 0C010030        	   192: 	cmpi.b #'0',d1				; only characters 0 to 9 valid
00:000092C0 651E            	   193: 	blo .0001
00:000092C2 0C010039        	   194: 	cmpi.b #'9',d1
00:000092C6 6218            	   195: 	bhi .0001
00:000092C8 04010030        	   196: 	subi.b #'0',d1
00:000092CC F23C50260001    	   197: 	fscale.w #1,fp0				; number *10
00:000092D2 F2015880        	   198: 	fmove.b d1,fp1				; fp1 = digit
00:000092D6 F2000422        	   199: 	fadd fp1,fp0
00:000092DA 5245            	   200: 	addq.w #1,d5
00:000092DC 51CAFFDA        	   201: 	dbra d2,.0002
                            	   202: .0001
00:000092E0 6100FEAE        	   203: 	bsr _GetFloatBackupChar
00:000092E4 4CD7000E        	   204: 	movem.l (sp),d1/d2/d3
00:000092E8 F22F4880000C    	   205: 	fmove.x 12(sp),fp1
00:000092EE A2AF00030018    	   206: 	cchk 24(sp)
00:000092F4 4E5A            	   207: 	unlk a2
00:000092F6 4E75            	   208: 	rts
                            	   209: 		
                            	   210: ;-------------------------------------------------------------------------------
                            	   211: ; Get a floating point number off the input screen.
                            	   212: ;
                            	   213: ; Parameters:
                            	   214: ;		a0 = pointer to buffer containing string
                            	   215: ;		d0 = stride of buffer (increment / decrement amount)
                            	   216: ; Register Usage:
                            	   217: ;		d1 = character from input screen
                            	   218: ;		d5.lo = number of digits in number, d5.hi = number of characters fetched
                            	   219: ; Returns:
                            	   220: ;		fp0 = number
                            	   221: ;		a0 = updated buffer pointer
                            	   222: ;		d0 = length of number >0 if a number
                            	   223: ;-------------------------------------------------------------------------------
                            	   224: 
                            	   225: _GetFloat:
00:000092F8 4E52FFE0        	   226: 	link a2,#-32
00:000092FC 2F7900040098001C	   227: 	move.l _canary,28(sp)
00:00009304 48D702A2        	   228: 	movem.l d1/d5/d7/a1,(sp)
00:00009308 F22F69000010    	   229: 	fmove.x fp2,16(sp)
00:0000930E 7A00            	   230: 	clr.l d5
00:00009310 1E3C002B        	   231: 	move.b #'+',d7				; assume a positive number
00:00009314 2248            	   232: 	move.l a0,a1					; a1 = copy of pointer to buffer
00:00009316 6100FF6A        	   233: 	bsr _GetInteger				; rval = integer
00:0000931A F2000100        	   234: 	fmove.x fp0,fp2
00:0000931E 6100FE62        	   235: 	bsr _GetFloatGetChar
00:00009322 0C01002E        	   236: 	cmpi.b #'.',d1
00:00009326 6706            	   237: 	beq .0004
                            	   238: .0005
00:00009328 6100FE66        	   239: 	bsr _GetFloatBackupChar
00:0000932C 601C            	   240: 	bra .0002
                            	   241: .0004
00:0000932E 6100FE64        	   242: 	bsr _GetFraction
00:00009332 F2000822        	   243: 	fadd fp2,fp0					; rval += fraction
00:00009336 6100FE4A        	   244: 	bsr _GetFloatGetChar
00:0000933A 0C010065        	   245: 	cmpi.b #'e',d1				; accept either 'e' or 'E' indicating exponent
00:0000933E 6706            	   246: 	beq .0001
00:00009340 0C010045        	   247: 	cmpi.b #'E',d1
00:00009344 66E2            	   248: 	bne .0005
                            	   249: .0001
00:00009346 6100FEB0        	   250: 	bsr _GetExponent			; factor exponent into fp0
                            	   251: .0002
00:0000934A 0C07002D        	   252: 	cmpi.b #'-',d7				; adjust number for sign
00:0000934E 6604            	   253: 	bne .0003
00:00009350 F200001A        	   254: 	fneg fp0
                            	   255: .0003
00:00009354 93C8            	   256: 	suba.l a0,a1					; compute number of characters fetched
00:00009356 3009            	   257: 	move.w a1,d0					; move it to d0.hi
00:00009358 4840            	   258: 	swap d0
00:0000935A 3005            	   259: 	move.w d5,d0					; return digit/character count in d0 (non zero for a number)
00:0000935C 4CD702A2        	   260: 	movem.l (sp),d1/d5/d7/a1
00:00009360 F22F49000010    	   261: 	fmove.x 16(sp),fp2
00:00009366 A2AF0003001C    	   262: 	cchk 28(sp)
00:0000936C 4E5A            	   263: 	unlk a2
00:0000936E 4E75            	   264: 	rts	
                            	   265: 
                            	   266: 		

Source: "boot.x68"
                            	  3077: 
                            	  3078: ;------------------------------------------------------------------------------
                            	  3079: ; Convert ASCII character in the range '0' to '9', 'a' tr 'f' or 'A' to 'F'
                            	  3080: ; to a hex nybble.
                            	  3081: ;------------------------------------------------------------------------------
                            	  3082: 
                            	  3083: AsciiToHexNybble:
00:00009370 0C010030        	  3084: 	cmpi.b	#'0',d1
00:00009374 6530            	  3085: 	blo.s		gthx3
00:00009376 0C010039        	  3086: 	cmpi.b	#'9',d1
00:0000937A 6206            	  3087: 	bhi.s		gthx5
00:0000937C 04010030        	  3088: 	subi.b	#'0',d1
00:00009380 4E75            	  3089: 	rts
                            	  3090: gthx5:
00:00009382 0C010041        	  3091: 	cmpi.b	#'A',d1
00:00009386 651E            	  3092: 	blo.s		gthx3
00:00009388 0C010046        	  3093: 	cmpi.b	#'F',d1
00:0000938C 6206            	  3094: 	bhi.s		gthx6
00:0000938E 060100C9        	  3095: 	addi.b	#10-'A',d1
00:00009392 4E75            	  3096: 	rts
                            	  3097: gthx6:
00:00009394 0C010061        	  3098: 	cmpi.b	#'a',d1
00:00009398 650C            	  3099: 	blo.s		gthx3
00:0000939A 0C010066        	  3100: 	cmpi.b	#'f',d1
00:0000939E 6206            	  3101: 	bhi.s		gthx3
00:000093A0 060100A9        	  3102: 	addi.b	#10-'a',d1
00:000093A4 4E75            	  3103: 	rts
                            	  3104: gthx3:
00:000093A6 72FF            	  3105: 	moveq	#-1,d1		; not a hex number
00:000093A8 4E75            	  3106: 	rts
                            	  3107: 
                            	  3108: ;------------------------------------------------------------------------------
                            	  3109: ;------------------------------------------------------------------------------
                            	  3110: 
                            	  3111: DisplayTwoSpaces:
00:000093AA 2F01            	  3112: 	move.l	d1,-(a7)
00:000093AC 123C0020        	  3113: 	move.b	#' ',d1
00:000093B0 610007D8        	  3114: 	bsr			OutputChar
                            	  3115: dspspc1:
00:000093B4 610007D4        	  3116: 	bsr			OutputChar
00:000093B8 221F            	  3117: 	move.l	(a7)+,d1
00:000093BA 4E75            	  3118: 	rts
                            	  3119: 
                            	  3120: DisplaySpace:
00:000093BC 2F01            	  3121: 	move.l	d1,-(a7)
00:000093BE 123C0020        	  3122: 	move.b	#' ',d1
00:000093C2 60F0            	  3123: 	bra			dspspc1
                            	  3124: 
                            	  3125: ;------------------------------------------------------------------------------
                            	  3126: ; Display the 32 bit word in D1.L
                            	  3127: ;------------------------------------------------------------------------------
                            	  3128: 
                            	  3129: DisplayTetra:
00:000093C4 4841            	  3130: 	swap	d1
00:000093C6 6102            	  3131: 	bsr		DisplayWyde
00:000093C8 4841            	  3132: 	swap	d1
                            	  3133: 
                            	  3134: ;------------------------------------------------------------------------------
                            	  3135: ; Display the byte in D1.W
                            	  3136: ;------------------------------------------------------------------------------
                            	  3137: 
                            	  3138: DisplayWyde:
00:000093CA E059            	  3139: 	ror.w		#8,d1
00:000093CC 6102            	  3140: 	bsr			DisplayByte
00:000093CE E159            	  3141: 	rol.w		#8,d1
                            	  3142: 
                            	  3143: ;------------------------------------------------------------------------------
                            	  3144: ; Display the byte in D1.B
                            	  3145: ;------------------------------------------------------------------------------
                            	  3146: 
                            	  3147: DisplayByte:
00:000093D0 E819            	  3148: 	ror.b		#4,d1
00:000093D2 6102            	  3149: 	bsr			DisplayNybble
00:000093D4 E919            	  3150: 	rol.b		#4,d1
                            	  3151: 
                            	  3152: ;------------------------------------------------------------------------------
                            	  3153: ; Display nybble in D1.B
                            	  3154: ;------------------------------------------------------------------------------
                            	  3155: 
                            	  3156: DisplayNybble:
00:000093D6 2F01            	  3157: 	move.l	d1,-(a7)
00:000093D8 0201000F        	  3158: 	andi.b	#$F,d1
00:000093DC 06010030        	  3159: 	addi.b	#'0',d1
00:000093E0 0C010039        	  3160: 	cmpi.b	#'9',d1
00:000093E4 6302            	  3161: 	bls.s		.0001
00:000093E6 5E01            	  3162: 	addi.b	#7,d1
                            	  3163: .0001:
00:000093E8 610007A0        	  3164: 	bsr			OutputChar
00:000093EC 221F            	  3165: 	move.l	(a7)+,d1
00:000093EE 4E75            	  3166: 	rts
                            	  3167: 
                            	  3168: ;------------------------------------------------------------------------------
                            	  3169: ; Buffer tetra in d0 to buffer pointed to by a6
                            	  3170: ;------------------------------------------------------------------------------
                            	  3171: 
                            	  3172: BufTetra:
00:000093F0 4840            	  3173: 	swap d0
00:000093F2 6102            	  3174: 	bsr BufWyde
00:000093F4 4840            	  3175: 	swap d0
                            	  3176: 
                            	  3177: BufWyde:
00:000093F6 E058            	  3178: 	ror.w #8,d0
00:000093F8 6102            	  3179: 	bsr BufByte
00:000093FA E158            	  3180: 	rol.w #8,d0
                            	  3181: 	
                            	  3182: BufByte:
00:000093FC E818            	  3183: 	ror.b #4,d0
00:000093FE 6102            	  3184: 	bsr BufNybble
00:00009400 E918            	  3185: 	rol.b #4,d0
                            	  3186: 
                            	  3187: BufNybble:
00:00009402 2F00            	  3188: 	move.l d0,-(a7)
00:00009404 0200000F        	  3189: 	andi.b #$F,d0
00:00009408 06000030        	  3190: 	addi.b #'0',d0
00:0000940C 0C000039        	  3191: 	cmpi.b #'9',d0
00:00009410 6302            	  3192: 	bls.s .0001
00:00009412 5E00            	  3193: 	addi.b #7,d0
                            	  3194: .0001:
00:00009414 1CC0            	  3195: 	move.b d0,(a6)+
00:00009416 201F            	  3196: 	move.l (a7)+,d0
00:00009418 4E75            	  3197: 	rts
                            	  3198: 
                            	  3199: ;------------------------------------------------------------------------------
                            	  3200: ;------------------------------------------------------------------------------
                            	  3201: ;
                            	  3202: ;DisplayHexNumber:
                            	  3203: ;	move.w	#$A6A6,leds		; diagnostics
                            	  3204: ;	move.l	#VDGREG,a6
                            	  3205: ;	move.w	#7,d2		; number-1 of digits to display
                            	  3206: ;disphnum1:
                            	  3207: ;	move.b	d1,d0		; get digit into d0.b
                            	  3208: ;	andi.w	#$0f,d0
                            	  3209: ;	cmpi.w	#$09,d0
                            	  3210: ;	bls.s	disphnum2
                            	  3211: ;	addi.w	#7,d0
                            	  3212: ;disphnum2:
                            	  3213: ;	addi.w	#$30,d0	; convert to display char
                            	  3214: ;	move.w	d2,d3		; char count into d3
                            	  3215: ;	asl.w	#3,d3		; scale * 8
                            	  3216: ;disphnum3:
                            	  3217: ;	move.w	$42C(a6),d4			; read character queue index into d4
                            	  3218: ;	cmp.w	#28,d4					; allow up 28 entries to be in progress
                            	  3219: ;	bhs.s	disphnum3				; branch if too many chars queued
                            	  3220: ;	ext.w	d0						; zero out high order bits
                            	  3221: ;	move.w	d0,$420(a6)			; set char code
                            	  3222: ;	move.w	#WHITE,$422(a6)		; set fg color
                            	  3223: ;	move.w	#DARK_BLUE,$424(a6)	; set bk color
                            	  3224: ;	move.w	d3,$426(a6)			; set x pos
                            	  3225: ;	move.w	#8,$428(a6)			; set y pos
                            	  3226: ;	move.w	#$0707,$42A(a6)		; set font x,y extent
                            	  3227: ;	move.w	#0,$42E(a6)			; pulse character queue write signal
                            	  3228: ;	ror.l	#4,d1					; rot to next digit
                            	  3229: ;	dbeq	d2,disphnum1
                            	  3230: ;	jmp		(a5)
                            	  3231: 
                            	  3232: 	include "ramtest.x68"

Source: "ramtest.x68"
                            	     1: ;===============================================================================
                            	     2: ;    Perform ram test. (Uses checkerboard testing).
                            	     3: ; 
                            	     4: ;    Local ram, which does not get tested, is used for the stack.
                            	     5: ;===============================================================================
                            	     6: 	code
                            	     7: 	even
                            	     8: DisplayAddr:
00:0000941A 2208            	     9: 	move.l a0,d1
00:0000941C E089            	    10: 	lsr.l #8,d1
00:0000941E E089            	    11: 	lsr.l #8,d1
00:00009420 E889            	    12: 	lsr.l #4,d1
00:00009422 04410400        	    13: 	subi.w #1024,d1
00:00009426 A2C10000        	    14: 	bin2bcd d1
00:0000942A 619E            	    15: 	bsr	DisplayWyde
00:0000942C 618E            	    16: 	bsr DisplaySpace
00:0000942E 123C000D        	    17: 	move.b #CR,d1
00:00009432 61000756        	    18: 	bsr OutputChar
00:00009436 08000083        	    19: 	btst #$83,d0
                            	    20: 	
                            	    21: cmdTestRAM:
                            	    22: ramtest:
00:0000943A 33FCA5A5FD0FFF00	    23: 	move.w	#$A5A5,leds		; diagnostics
00:00009442 263CAAAAAAAA    	    24:   move.l #$aaaaaaaa,d3
00:00009448 283C55555555    	    25:   move.l #$55555555,d4
00:0000944E 6134            	    26:   bsr ramtest0
                            	    27:   ; switch checkerboard pattern and repeat test.
00:00009450 C744            	    28:   exg d3,d4
00:00009452 6130            	    29:   bsr ramtest0
                            	    30: 	; Save last ram address in end of memory pointer.
                            	    31: rmtst5:
00:00009454 7025            	    32: 	moveq #37,d0					; lock semaphore
00:00009456 7206            	    33: 	moveq #MEMORY_SEMA,d1
                            	    34: ;	trap #15
00:00009458 207C7FFFFFF8    	    35:   movea.l #$7FFFFFF8,a0
00:0000945E 23C800100004    	    36:   move.l a0,memend
                            	    37: 	; Create very first memory block.
00:00009464 207C3FFFFFF4    	    38:   movea.l #$3FFFFFF4,a0
00:0000946A 23C840000004    	    39:   move.l a0,$40000004		; length of block
00:00009470 23FC465245454000	    40:   move.l #$46524545,$40000000
00:00009478 0000
00:0000947A 7026            	    41: 	moveq #38,d0					; unlock semaphore
00:0000947C 7206            	    42: 	moveq #MEMORY_SEMA,d1
00:0000947E 4E4F            	    43: 	trap #15
00:00009480 6000ECB6        	    44: 	bra Monitor
                            	    45: ;  rts
                            	    46: 
                            	    47: ramtest0:
00:00009484 2003            	    48: 	move.l d3,d0
00:00009486 207C40000000    	    49:   movea.l #$40000000,a0
                            	    50: ;-----------------------------------------------------------
                            	    51: ;   Write checkerboard pattern to ram then read it back to
                            	    52: ; find the highest usable ram address (maybe). This address
                            	    53: ; must be lower than the start of the rom (0xe00000).
                            	    54: ;-----------------------------------------------------------
                            	    55: ramtest1:
00:0000948C 20C3            	    56:   move.l d3,(a0)+
00:0000948E 20C4            	    57:   move.l d4,(a0)+
00:00009490 2208            	    58:   move.l a0,d1
00:00009492 4A41            	    59:   tst.w	d1
00:00009494 6608            	    60:   bne.s rmtst1
00:00009496 6182            	    61:   bsr DisplayAddr
00:00009498 4EB9000008AE    	    62:   bsr CheckForCtrlC
                            	    63: rmtst1:
00:0000949E B1FC7FFFFFF8    	    64:   cmpa.l #$7FFFFFF8,a0
00:000094A4 65E6            	    65:   blo.s ramtest1
00:000094A6 6100E622        	    66:   bsr	CRLF
                            	    67: ;------------------------------------------------------
                            	    68: ;   Save maximum useable address for later comparison.
                            	    69: ;------------------------------------------------------
                            	    70: ramtest6:
00:000094AA 33FCA7A7FD0FFF00	    71: 	move.w	#$A7A7,leds		; diagnostics
00:000094B2 2448            	    72:   movea.l a0,a2
00:000094B4 207C40000000    	    73:   movea.l #$40000000,a0
                            	    74: ;--------------------------------------------
                            	    75: ;   Read back checkerboard pattern from ram.
                            	    76: ;--------------------------------------------
                            	    77: ramtest2
00:000094BA 2A18            	    78:   move.l (a0)+,d5
00:000094BC 2C18            	    79:   move.l (a0)+,d6
00:000094BE B1CA            	    80:   cmpa.l a2,a0
00:000094C0 643E            	    81:   bhs.s	ramtest3
00:000094C2 2208            	    82:   move.l a0,d1
00:000094C4 4A41            	    83:   tst.w	d1
00:000094C6 660A            	    84:   bne.s	rmtst2
00:000094C8 6100FF50        	    85:   bsr	DisplayAddr
00:000094CC 4EB9000008AE    	    86: 	bsr CheckForCtrlC
                            	    87: rmtst2
00:000094D2 BA83            	    88:   cmp.l d3,d5
00:000094D4 6604            	    89:   bne.s rmtst3
00:000094D6 BC84            	    90:   cmp.l d4,d6
00:000094D8 67E0            	    91:   beq.s ramtest2
                            	    92: ;----------------------------------
                            	    93: ; Report error in ram.
                            	    94: ;----------------------------------
                            	    95: rmtst3
00:000094DA 6100E5EE        	    96: 	bsr CRLF
00:000094DE 7245            	    97: 	moveq	#'E',d1
00:000094E0 610006A8        	    98: 	bsr OutputChar
00:000094E4 6100FED6        	    99: 	bsr DisplaySpace
00:000094E8 2208            	   100: 	move.l a0,d1
00:000094EA 6100FED8        	   101: 	bsr DisplayTetra
00:000094EE 6100FECC        	   102: 	bsr DisplaySpace
00:000094F2 2205            	   103: 	move.l d5,d1
00:000094F4 6100FECE        	   104: 	bsr DisplayTetra
00:000094F8 4EB9000008AE    	   105: 	bsr CheckForCtrlC
00:000094FE 60BA            	   106: 	bra ramtest2
                            	   107: ramtest3
00:00009500 4E75            	   108: 	rts
                            	   109: 

Source: "boot.x68"
                            	  3233: 	include "LoadS19.x68"

Source: "LoadS19.x68"
                            	     1: ;==============================================================================
                            	     2: ; Load an S19 format file
                            	     3: ;==============================================================================
                            	     4: 	code
                            	     5: 	even
                            	     6: cmdLoadS19:
00:00009502 6100E5C6        	     7: 	bsr			CRLF					; move display to next line
00:00009506 6012            	     8: 	bra			ProcessRec
                            	     9: NextRec:
00:00009508 610001E4        	    10: 	bsr			sGetChar			; get character from serial port routines
00:0000950C 0C01000A        	    11: 	cmpi.b	#LF,d1				; look for a line-feed
00:00009510 66F6            	    12: 	bne			NextRec
00:00009512 123C002E        	    13: 	move.b	#'.',d1				; progress display
00:00009516 61000672        	    14: 	bsr			OutputChar
                            	    15: ProcessRec:
00:0000951A 4EB9000008AE    	    16: 	bsr			CheckForCtrlC	; check for CTRL-C once per record
00:00009520 610001CC        	    17: 	bsr			sGetChar
00:00009524 0C01000D        	    18: 	cmpi.b	#CR,d1
00:00009528 67F0            	    19: 	beq.s		ProcessRec
00:0000952A 423900100150    	    20: 	clr.b		S19Checksum		; clear the checksum
00:00009530 1801            	    21: 	move.b	d1,d4
00:00009532 0C04001A        	    22: 	cmpi.b	#CTRLZ,d4			; CTRL-Z ?
00:00009536 6700EC00        	    23: 	beq			Monitor
00:0000953A 0C040053        	    24: 	cmpi.b	#'S',d4				; All records must begin with an 'S'
00:0000953E 66C8            	    25: 	bne.s		NextRec
00:00009540 610001AC        	    26: 	bsr			sGetChar
00:00009544 1801            	    27: 	move.b	d1,d4
00:00009546 0C040030        	    28: 	cmpi.b	#'0',d4				; Record type must be between '0' and '9'
00:0000954A 65BC            	    29: 	blo.s		NextRec
00:0000954C 0C040039        	    30: 	cmpi.b	#'9',d4				; d4 = record type
00:00009550 62B6            	    31: 	bhi.s		NextRec
00:00009552 6100019A        	    32: 	bsr			sGetChar			; get byte count for record
00:00009556 6100FE18        	    33: 	bsr			AsciiToHexNybble
00:0000955A 1401            	    34: 	move.b	d1,d2
00:0000955C 61000190        	    35: 	bsr			sGetChar
00:00009560 6100FE0E        	    36: 	bsr			AsciiToHexNybble
00:00009564 E90A            	    37: 	lsl.b		#4,d2
00:00009566 8202            	    38: 	or.b		d2,d1					; d1 = byte count
00:00009568 1601            	    39: 	move.b	d1,d3					; d3 = byte count
00:0000956A D73900100150    	    40: 	add.b		d3,S19Checksum
00:00009570 0C040030        	    41: 	cmpi.b	#'0',d4				; manufacturer ID record, ignore
00:00009574 6792            	    42: 	beq			NextRec
00:00009576 0C040031        	    43: 	cmpi.b	#'1',d4
00:0000957A 670000A2        	    44: 	beq			ProcessS1
00:0000957E 0C040032        	    45: 	cmpi.b	#'2',d4
00:00009582 6700009E        	    46: 	beq			ProcessS2
00:00009586 0C040033        	    47: 	cmpi.b	#'3',d4
00:0000958A 6700009A        	    48: 	beq			ProcessS3
00:0000958E 0C040035        	    49: 	cmpi.b	#'5',d4				; record count record, ignore
00:00009592 6700FF74        	    50: 	beq			NextRec
00:00009596 0C040037        	    51: 	cmpi.b	#'7',d4
00:0000959A 6700008E        	    52: 	beq			ProcessS7
00:0000959E 0C040038        	    53: 	cmpi.b	#'8',d4
00:000095A2 67000098        	    54: 	beq			ProcessS8
00:000095A6 0C040039        	    55: 	cmpi.b	#'9',d4
00:000095AA 670000A2        	    56: 	beq			ProcessS9
00:000095AE 6000FF58        	    57: 	bra			NextRec
                            	    58: 
                            	    59: pcssxa:
00:000095B2 2209            	    60: 	move.l	a1,d1
00:000095B4 6100FE0E        	    61: 	bsr			DisplayTetra
00:000095B8 123C000D        	    62: 	move.b	#CR,d1
00:000095BC 610005CC        	    63: 	bsr			OutputChar
00:000095C0 024300FF        	    64: 	andi.w	#$ff,d3
00:000095C4 5343            	    65: 	subi.w	#1,d3			; one less for dbra
                            	    66: .0001:
00:000095C6 7400            	    67: 	clr.l		d2
00:000095C8 61000124        	    68: 	bsr			sGetChar
00:000095CC 6100FDA2        	    69: 	bsr			AsciiToHexNybble
00:000095D0 E98A            	    70: 	lsl.l		#4,d2
00:000095D2 8401            	    71: 	or.b		d1,d2
00:000095D4 61000118        	    72: 	bsr			sGetChar
00:000095D8 6100FD96        	    73: 	bsr			AsciiToHexNybble
00:000095DC E98A            	    74: 	lsl.l		#4,d2
00:000095DE 8401            	    75: 	or.b		d1,d2
00:000095E0 D53900100150    	    76: 	add.b		d2,S19Checksum
00:000095E6 12C2            	    77: 	move.b	d2,(a1)+			; move byte to memory
00:000095E8 51CBFFDC        	    78: 	dbra		d3,.0001
                            	    79: 	; Get the checksum byte
00:000095EC 7400            	    80: 	clr.l		d2
00:000095EE 610000FE        	    81: 	bsr			sGetChar
00:000095F2 6100FD7C        	    82: 	bsr			AsciiToHexNybble
00:000095F6 E98A            	    83: 	lsl.l		#4,d2
00:000095F8 8401            	    84: 	or.b		d1,d2
00:000095FA 610000F2        	    85: 	bsr			sGetChar
00:000095FE 6100FD70        	    86: 	bsr			AsciiToHexNybble
00:00009602 E98A            	    87: 	lsl.l		#4,d2
00:00009604 8401            	    88: 	or.b		d1,d2
00:00009606 4602            	    89: 	eor.b		#$FF,d2
00:00009608 B43900100150    	    90: 	cmp.b		S19Checksum,d2
00:0000960E 6700FEF8        	    91: 	beq			NextRec
00:00009612 123C0045        	    92: 	move.b	#'E',d1
00:00009616 61000572        	    93: 	bsr			OutputChar
00:0000961A 6000FEEC        	    94: 	bra			NextRec
                            	    95: 
                            	    96: ProcessS1:
00:0000961E 6140            	    97: 	bsr			S19Get16BitAddress
00:00009620 6090            	    98: 	bra			pcssxa
                            	    99: ProcessS2:
00:00009622 614A            	   100: 	bsr			S19Get24BitAddress
00:00009624 608C            	   101: 	bra			pcssxa
                            	   102: ProcessS3:
00:00009626 6152            	   103: 	bsr			S19Get32BitAddress
00:00009628 6088            	   104: 	bra			pcssxa
                            	   105: ProcessS7:
00:0000962A 614E            	   106: 	bsr			S19Get32BitAddress
00:0000962C 23C900040008    	   107: 	move.l	a1,S19StartAddress
00:00009632 4EB9000006B4    	   108: 	bsr			_KeybdInit
00:00009638 6000EAFE        	   109: 	bra			Monitor
                            	   110: ProcessS8:
00:0000963C 6130            	   111: 	bsr			S19Get24BitAddress
00:0000963E 23C900040008    	   112: 	move.l	a1,S19StartAddress
00:00009644 4EB9000006B4    	   113: 	bsr			_KeybdInit
00:0000964A 6000EAEC        	   114: 	bra			Monitor
                            	   115: ProcessS9:
00:0000964E 6110            	   116: 	bsr			S19Get16BitAddress
00:00009650 23C900040008    	   117: 	move.l	a1,S19StartAddress
00:00009656 4EB9000006B4    	   118: 	bsr			_KeybdInit
00:0000965C 6000EADA        	   119: 	bra			Monitor
                            	   120: 
                            	   121: S19Get16BitAddress:
00:00009660 7400            	   122: 	clr.l		d2
00:00009662 6100008A        	   123: 	bsr			sGetChar
00:00009666 6100FD08        	   124: 	bsr			AsciiToHexNybble
00:0000966A 1401            	   125: 	move.b	d1,d2
00:0000966C 603E            	   126: 	bra			S1932b
                            	   127: 
                            	   128: S19Get24BitAddress:
00:0000966E 7400            	   129: 	clr.l		d2
00:00009670 617C            	   130: 	bsr			sGetChar
00:00009672 6100FCFC        	   131: 	bsr			AsciiToHexNybble
00:00009676 1401            	   132: 	move.b	d1,d2
00:00009678 601E            	   133: 	bra			S1932a
                            	   134: 
                            	   135: S19Get32BitAddress:
00:0000967A 7400            	   136: 	clr.l		d2
00:0000967C 6170            	   137: 	bsr			sGetChar
00:0000967E 6100FCF0        	   138: 	bsr			AsciiToHexNybble
00:00009682 1401            	   139: 	move.b	d1,d2
00:00009684 6168            	   140: 	bsr			sGetChar
00:00009686 6100FCE8        	   141: 	bsr			AsciiToHexNybble
00:0000968A E98A            	   142: 	lsl.l		#4,d2
00:0000968C 8401            	   143: 	or.b		d1,d2
00:0000968E 615E            	   144: 	bsr			sGetChar
00:00009690 6100FCDE        	   145: 	bsr			AsciiToHexNybble
00:00009694 E98A            	   146: 	lsl.l		#4,d2
00:00009696 8401            	   147: 	or.b		d1,d2
                            	   148: S1932a:
00:00009698 6154            	   149: 	bsr			sGetChar
00:0000969A 6100FCD4        	   150: 	bsr			AsciiToHexNybble
00:0000969E E98A            	   151: 	lsl.l		#4,d2
00:000096A0 8401            	   152: 	or.b		d1,d2
00:000096A2 614A            	   153: 	bsr			sGetChar
00:000096A4 6100FCCA        	   154: 	bsr			AsciiToHexNybble
00:000096A8 E98A            	   155: 	lsl.l		#4,d2
00:000096AA 8401            	   156: 	or.b		d1,d2
                            	   157: S1932b:
00:000096AC 6140            	   158: 	bsr			sGetChar
00:000096AE 6100FCC0        	   159: 	bsr			AsciiToHexNybble
00:000096B2 E98A            	   160: 	lsl.l		#4,d2
00:000096B4 8401            	   161: 	or.b		d1,d2
00:000096B6 6136            	   162: 	bsr			sGetChar
00:000096B8 6100FCB6        	   163: 	bsr			AsciiToHexNybble
00:000096BC E98A            	   164: 	lsl.l		#4,d2
00:000096BE 8401            	   165: 	or.b		d1,d2
00:000096C0 612C            	   166: 	bsr			sGetChar
00:000096C2 6100FCAC        	   167: 	bsr			AsciiToHexNybble
00:000096C6 E98A            	   168: 	lsl.l		#4,d2
00:000096C8 8401            	   169: 	or.b		d1,d2
00:000096CA 7800            	   170: 	clr.l		d4
00:000096CC 2242            	   171: 	move.l	d2,a1
                            	   172: 	; Add bytes from address value to checksum
00:000096CE D53900100150    	   173: 	add.b		d2,S19Checksum
00:000096D4 E08A            	   174: 	lsr.l		#8,d2
00:000096D6 D53900100150    	   175: 	add.b		d2,S19Checksum
00:000096DC E08A            	   176: 	lsr.l		#8,d2
00:000096DE D53900100150    	   177: 	add.b		d2,S19Checksum
00:000096E4 E08A            	   178: 	lsr.l		#8,d2
00:000096E6 D53900100150    	   179: 	add.b		d2,S19Checksum
00:000096EC 4E75            	   180: 	rts
                            	   181: 
                            	   182: ;------------------------------------------------------------------------------
                            	   183: ; Get a character from auxillary input. Waiting for a character is limited to
                            	   184: ; 32000 tries. If a character is not available within the limit, then a return
                            	   185: ; to the monitor is done.
                            	   186: ;
                            	   187: ;	Parameters:
                            	   188: ;		none
                            	   189: ; Returns:
                            	   190: ;		d1 = character from receive buffer or -1 if no char available
                            	   191: ;------------------------------------------------------------------------------
                            	   192: 
                            	   193: sGetChar:
00:000096EE 48E7A000        	   194: 	movem.l	d0/d2,-(a7)
00:000096F2 343C7D00        	   195: 	move.w	#32000,d2
                            	   196: .0001:
00:000096F6 7024            	   197: 	moveq		#36,d0				; serial get char from buffer
00:000096F8 4E4F            	   198: 	trap		#15
00:000096FA 4A41            	   199: 	tst.w		d1						; was there a char available?
00:000096FC 6A0C            	   200: 	bpl.s		.0002
00:000096FE 51CAFFF6        	   201: 	dbra		d2,.0001			; no - try again
00:00009702 4CDF0005        	   202: 	movem.l	(a7)+,d0/d2
                            	   203: .0003:
                            	   204: ;	bsr			_KeybdInit
00:00009706 6000EA30        	   205: 	bra			Monitor				; ran out of tries
                            	   206: .0002:
00:0000970A 4CDF0005        	   207: 	movem.l	(a7)+,d0/d2
00:0000970E 0C01001A        	   208: 	cmpi.b	#CTRLZ,d1			; receive end of file?
00:00009712 67F2            	   209: 	beq			.0003
00:00009714 4E75            	   210: 	rts
                            	   211: 
                            	   212: 

Source: "boot.x68"
                            	  3234: 	
                            	  3235: AudioInputTest:
00:00009716 4E75            	  3236: 	rts
                            	  3237: BouncingBalls:
00:00009718 4E75            	  3238: 	rts
                            	  3239: GraphicsDemo:
00:0000971A 4E75            	  3240: 	rts
                            	  3241: ClearScreen:
00:0000971C 7E02            	  3242: 	move.l #2,d7
00:0000971E 7C0C            	  3243: 	move.l #DEV_CLEAR,d6
00:00009720 4E40            	  3244: 	trap #0
00:00009722 4E75            	  3245: 	rts
                            	  3246: 
                            	  3247: ;------------------------------------------------------------------------------
                            	  3248: ; Reverse the order of bytes in d1.
                            	  3249: ;------------------------------------------------------------------------------
                            	  3250: 
                            	  3251: rbo:
00:00009724 E159            	  3252: 	rol.w	#8,d1
00:00009726 4841            	  3253: 	swap d1
00:00009728 E159            	  3254: 	rol.w	#8,d1
00:0000972A 4E75            	  3255: 	rts
                            	  3256: 
                            	  3257: ;===============================================================================
                            	  3258: ; Generic I2C routines
                            	  3259: ;===============================================================================
                            	  3260: 
                            	  3261: 	even
                            	  3262: ; i2c
                            	  3263: i2c_setup:
                            	  3264: ;		lea		I2C,a6				
                            	  3265: ;		move.w	#19,I2C_PREL(a6)	; setup prescale for 400kHz clock
                            	  3266: ;		move.w	#0,I2C_PREH(a6)
                            	  3267: init_i2c:
00:0000972C 4DF9FD069000    	  3268: 	lea	I2C2,a6				
00:00009732 1CBC0013        	  3269: 	move.b #19,I2C_PREL(a6)	; setup prescale for 400kHz clock, 40MHz master
00:00009736 422E0001        	  3270: 	move.b #0,I2C_PREH(a6)
00:0000973A 4E75            	  3271: 	rts
                            	  3272: 
                            	  3273: ; Wait for I2C transfer to complete
                            	  3274: ;
                            	  3275: ; Parameters
                            	  3276: ; 	a6 - I2C controller base address
                            	  3277: 
                            	  3278: i2c_wait_tip:
00:0000973C 2F00            	  3279: 	move.l d0,-(a7)
                            	  3280: .0001				
00:0000973E 102E0004        	  3281: 	move.b I2C_STAT(a6),d0		; wait for tip to clear
00:00009742 08000001        	  3282: 	btst #1,d0
00:00009746 66F6            	  3283: 	bne.s	.0001
00:00009748 201F            	  3284: 	move.l (a7)+,d0
00:0000974A 4E75            	  3285: 	rts
                            	  3286: 
                            	  3287: ; Parameters
                            	  3288: ;	d0.b - data to transmit
                            	  3289: ;	d1.b - command value
                            	  3290: ;	a6	 - I2C controller base address
                            	  3291: ;
                            	  3292: i2c_wr_cmd:
00:0000974C 1D400003        	  3293: 	move.b d0,I2C_TXR(a6)
00:00009750 1D410004        	  3294: 	move.b d1,I2C_CMD(a6)
00:00009754 61E6            	  3295: 	bsr	i2c_wait_tip
00:00009756 102E0004        	  3296: 	move.b I2C_STAT(a6),d0
00:0000975A 4E75            	  3297: 	rts
                            	  3298: 
                            	  3299: i2c_xmit1:
00:0000975C 2F00            	  3300: 	move.l d0,-(a7)
00:0000975E 1D7C00010002    	  3301: 	move.b #1,I2C_CTRL(a6)		; enable the core
00:00009764 7076            	  3302: 	moveq	#$76,d0				; set slave address = %0111011
00:00009766 323C0090        	  3303: 	move.w #$90,d1				; set STA, WR
00:0000976A 61E0            	  3304: 	bsr i2c_wr_cmd
00:0000976C 610C            	  3305: 	bsr	i2c_wait_rx_nack
00:0000976E 201F            	  3306: 	move.l (a7)+,d0
00:00009770 323C0050        	  3307: 	move.w #$50,d1				; set STO, WR
00:00009774 61D6            	  3308: 	bsr i2c_wr_cmd
00:00009776 61000002        	  3309: 	bsr	i2c_wait_rx_nack
                            	  3310: 
                            	  3311: i2c_wait_rx_nack:
00:0000977A 2F00            	  3312: 	move.l d0,-(a7)
                            	  3313: .0001						
00:0000977C 102E0004        	  3314: 	move.b I2C_STAT(a6),d0		; wait for RXack = 0
00:00009780 08000007        	  3315: 	btst #7,d0
00:00009784 66F6            	  3316: 	bne.s	.0001
00:00009786 201F            	  3317: 	move.l (a7)+,d0
00:00009788 4E75            	  3318: 	rts
                            	  3319: 
                            	  3320: ;===============================================================================
                            	  3321: ; Realtime clock routines
                            	  3322: ;===============================================================================
                            	  3323: 
                            	  3324: rtc_read:
00:0000978A 2C7CFD069000    	  3325: 	movea.l	#I2C2,a6
00:00009790 4BF900100200    	  3326: 	lea	RTCBuf,a5
00:00009796 1D7C00800002    	  3327: 	move.b	#$80,I2C_CTRL(a6)	; enable I2C
00:0000979C 103C00DE        	  3328: 	move.b	#$DE,d0				; read address, write op
00:000097A0 123C0090        	  3329: 	move.b	#$90,d1				; STA + wr bit
00:000097A4 61A6            	  3330: 	bsr	i2c_wr_cmd
00:000097A6 4A00            	  3331: 	tst.b	d0
00:000097A8 6B66            	  3332: 	bmi	.rxerr
00:000097AA 4200            	  3333: 	move.b #$00,d0				; address zero
00:000097AC 123C0010        	  3334: 	move.b #$10,d1				; wr bit
00:000097B0 619A            	  3335: 	bsr	i2c_wr_cmd
00:000097B2 4A00            	  3336: 	tst.b	d0
00:000097B4 6B5A            	  3337: 	bmi	.rxerr
00:000097B6 103C00DF        	  3338: 	move.b #$DF,d0				; read address, read op
00:000097BA 123C0090        	  3339: 	move.b #$90,d1				; STA + wr bit
00:000097BE 618C            	  3340: 	bsr i2c_wr_cmd
00:000097C0 4A00            	  3341: 	tst.b	d0
00:000097C2 6B4C            	  3342: 	bmi	.rxerr
                            	  3343: 		
00:000097C4 343C0020        	  3344: 	move.w #$20,d2
                            	  3345: .0001
00:000097C8 1D7C00200004    	  3346: 	move.b #$20,I2C_CMD(a6)	; rd bit
00:000097CE 6100FF6C        	  3347: 	bsr	i2c_wait_tip
00:000097D2 61A6            	  3348: 	bsr	i2c_wait_rx_nack
00:000097D4 102E0004        	  3349: 	move.b I2C_STAT(a6),d0
00:000097D8 4A00            	  3350: 	tst.b	d0
00:000097DA 6B34            	  3351: 	bmi	.rxerr
00:000097DC 102E0003        	  3352: 	move.b I2C_RXR(a6),d0
00:000097E0 1B802000        	  3353: 	move.b d0,(a5,d2.w)
00:000097E4 5242            	  3354: 	addi.w #1,d2
00:000097E6 0C42005F        	  3355: 	cmpi.w #$5F,d2
00:000097EA 66DC            	  3356: 	bne	.0001
00:000097EC 1D7C00680004    	  3357: 	move.b #$68,I2C_CMD(a6)	; STO, rd bit + nack
00:000097F2 6100FF48        	  3358: 	bsr i2c_wait_tip
00:000097F6 6182            	  3359: 	bsr i2c_wait_rx_nack
00:000097F8 102E0004        	  3360: 	move.b I2C_STAT(a6),d0
00:000097FC 4A00            	  3361: 	tst.b	d0
00:000097FE 6B10            	  3362: 	bmi	.rxerr
00:00009800 102E0003        	  3363: 	move.b I2C_RXR(a6),d0
00:00009804 1B802000        	  3364: 	move.b d0,(a5,d2.w)
00:00009808 422E0002        	  3365: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
00:0000980C 7000            	  3366: 	moveq	#0,d0
00:0000980E 4E75            	  3367: 	rts
                            	  3368: .rxerr
00:00009810 422E0002        	  3369: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
00:00009814 4E75            	  3370: 	rts
                            	  3371: 
                            	  3372: rtc_write:
00:00009816 2C7CFD069000    	  3373: 	movea.l	#I2C2,a6
00:0000981C 4BF900100200    	  3374: 	lea	RTCBuf,a5
00:00009822 1D7C00800002    	  3375: 	move.b #$80,I2C_CTRL(a6)	; enable I2C
00:00009828 103C00DE        	  3376: 	move.b #$DE,d0				; read address, write op
00:0000982C 123C0090        	  3377: 	move.b #$90,d1				; STA + wr bit
00:00009830 6100FF1A        	  3378: 	bsr	i2c_wr_cmd
00:00009834 4A00            	  3379: 	tst.b	d0
00:00009836 6B42            	  3380: 	bmi	.rxerr
00:00009838 4200            	  3381: 	move.b #$00,d0				; address zero
00:0000983A 123C0010        	  3382: 	move.b #$10,d1				; wr bit
00:0000983E 6100FF0C        	  3383: 	bsr	i2c_wr_cmd
00:00009842 4A00            	  3384: 	tst.b	d0
00:00009844 6B34            	  3385: 	bmi	.rxerr
00:00009846 343C0020        	  3386: 	move.w #$20,d2
                            	  3387: .0001
00:0000984A 10352000        	  3388: 	move.b (a5,d2.w),d0
00:0000984E 123C0010        	  3389: 	move.b #$10,d1
00:00009852 6100FEF8        	  3390: 	bsr	i2c_wr_cmd
00:00009856 4A00            	  3391: 	tst.b	d0
00:00009858 6B20            	  3392: 	bmi	.rxerr
00:0000985A 5242            	  3393: 	addi.w #1,d2
00:0000985C 0C42005F        	  3394: 	cmpi.w #$5F,d2
00:00009860 66E8            	  3395: 	bne.s	.0001
00:00009862 10352000        	  3396: 	move.b (a5,d2.w),d0
00:00009866 123C0050        	  3397: 	move.b #$50,d1				; STO, wr bit
00:0000986A 6100FEE0        	  3398: 	bsr	i2c_wr_cmd
00:0000986E 4A00            	  3399: 	tst.b	d0
00:00009870 6B08            	  3400: 	bmi	.rxerr
00:00009872 422E0002        	  3401: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
00:00009876 7000            	  3402: 	moveq	#0,d0
00:00009878 4E75            	  3403: 	rts
                            	  3404: .rxerr:
00:0000987A 422E0002        	  3405: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
00:0000987E 4E75            	  3406: 	rts
                            	  3407: 
                            	  3408: msgRtcReadFail:
00:00009880 5254432072656164	  3409: 	dc.b	"RTC read/write failed.",$0A,$0D,$00
00:00009888 2F77726974652066
00:00009890 61696C65642E
00:00009896 0A
00:00009897 0D
00:00009898 00
                            	  3410: 
                            	  3411: msgBusErr:
00:00009899 0A              	  3412: 	dc.b	$0A,$0D,"Bus error at: ",$00
00:0000989A 0D
00:0000989B 427573206572726F
00:000098A3 722061743A20
00:000098A9 00
                            	  3413: 	even
                            	  3414: 
                            	  3415: ;------------------------------------------------------------------------------
                            	  3416: ;------------------------------------------------------------------------------
                            	  3417: 	even
                            	  3418: 
                            	  3419: bus_err:
00:000098AA 4E71            	  3420: 	nop
00:000098AC 43FAFFEB        	  3421: 	lea.l msgBusErr,a1
00:000098B0 6100E232        	  3422: 	bsr DisplayString
00:000098B4 222F0002        	  3423: 	move.l 2(a7),d1
00:000098B8 6100FB0A        	  3424: 	bsr DisplayTetra
00:000098BC 6100E20C        	  3425: 	bsr CRLF
00:000098C0 6000E876        	  3426: 	bra	Monitor
                            	  3427: 
                            	  3428: trap3:
                            	  3429: 	; First save all registers
00:000098C4 48F9FFFF00040100	  3430: 	movem.l		d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
00:000098CC 33DF00040140    	  3431: 	move.w		(a7)+,Regsave+$40
00:000098D2 23DF00040144    	  3432: 	move.l		(a7)+,Regsave+$44
00:000098D8 2E7C00040FFC    	  3433: 	move.l		#$40FFC,a7			; reset stack pointer
00:000098DE 46FC2500        	  3434: 	move.w		#$2500,sr				; enable interrupts
00:000098E2 303900040202    	  3435: 	move.w		NumSetBreakpoints,d0
00:000098E8 5340            	  3436: 	subi.w		#1,d0
00:000098EA 41F900040220    	  3437: 	lea				Breakpoints,a0
00:000098F0 223900040144    	  3438: 	move.l		Regsave+$44,d1
                            	  3439: .0001:
00:000098F6 B298            	  3440: 	cmp.l			(a0)+,d1
00:000098F8 6708            	  3441: 	beq.s			ProcessBreakpoint
00:000098FA 51C8FFFA        	  3442: 	dbra			d0,.0001
00:000098FE 6000E838        	  3443: 	bra				Monitor					; not a breakpoint
                            	  3444: ProcessBreakpoint:
00:00009902 6104            	  3445: 	bsr				DisarmAllBreakpoints
00:00009904 6000F414        	  3446: 	bra				cmdDumpRegs
                            	  3447: 
                            	  3448: ;------------------------------------------------------------------------------
                            	  3449: ; DisarmAllBreakpoints, used when entering the monitor.
                            	  3450: ;------------------------------------------------------------------------------
                            	  3451: 
                            	  3452: DisarmAllBreakpoints:
00:00009908 48E780E0        	  3453: 	movem.l	d0/a0/a1/a2,-(a7)			; stack some regs
00:0000990C 303900040202    	  3454: 	move.w	NumSetBreakpoints,d0	; d0 = number of breakpoints that are set
00:00009912 0C400008        	  3455: 	cmpi.w	#numBreakpoints,d0		; check for valid number
00:00009916 641A            	  3456: 	bhs.s		.0001
00:00009918 45F900040220    	  3457: 	lea			Breakpoints,a2				; a2 = pointer to breakpoint address table
00:0000991E 41F900040280    	  3458: 	lea			BreakpointWords,a0		; a0 = pointer to breakpoint instruction word table
00:00009924 6004            	  3459: 	bra.s		.0003									; enter loop at bottom
                            	  3460: .0002:
00:00009926 225A            	  3461: 	move.l	(a2)+,a1							; a1 = address of breakpoint
00:00009928 3298            	  3462: 	move.w	(a0)+,(a1)						; copy instruction word back to code
                            	  3463: .0003:
00:0000992A 51C8FFFA        	  3464: 	dbra		d0,.0002
00:0000992E 4CDF0701        	  3465: 	movem.l	(a7)+,d0/a0/a1/a2			; restore regs
                            	  3466: .0001:
00:00009932 4E75            	  3467: 	rts	
                            	  3468: 
                            	  3469: ;------------------------------------------------------------------------------
                            	  3470: ; ArmAllBreakpoints, used when entering the monitor.
                            	  3471: ;------------------------------------------------------------------------------
                            	  3472: 
                            	  3473: ArmAllBreakpoints:
00:00009934 48E780E0        	  3474: 	movem.l		d0/a0/a1/a2,-(a7)			; stack some regs
00:00009938 303900040202    	  3475: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:0000993E 0C400008        	  3476: 	cmpi.w		#numBreakpoints,d0		; is the number valid?
00:00009942 641E            	  3477: 	bhs.s			.0001
00:00009944 45F900040220    	  3478: 	lea				Breakpoints,a2				; a2 = pointer to breakpoint address table
00:0000994A 41F900040280    	  3479: 	lea				BreakpointWords,a0		; a0 = pointer to instruction word table
00:00009950 6008            	  3480: 	bra.s			.0003									; enter loop at bottom
                            	  3481: .0002:
00:00009952 225A            	  3482: 	move.l		(a2)+,a1							; a1 = address of breakpoint
00:00009954 3091            	  3483: 	move.w		(a1),(a0)							; copy instruction word to table
00:00009956 30FC4E43        	  3484: 	move.w		#$4E43,(a0)+					; set instruction = TRAP3
                            	  3485: .0003:
00:0000995A 51C8FFF6        	  3486: 	dbra			d0,.0002
00:0000995E 4CDF0701        	  3487: 	movem.l		(a7)+,d0/a0/a1/a2			; restore regs
                            	  3488: .0001:
00:00009962 4E75            	  3489: 	rts	
                            	  3490: 
                            	  3491: ;------------------------------------------------------------------------------
                            	  3492: ;------------------------------------------------------------------------------
                            	  3493: 
                            	  3494: ArmBreakpoint:
00:00009964 48E7E0E0        	  3495: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
00:00009968 303900040202    	  3496: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:0000996E 0C400008        	  3497: 	cmpi.w		#numBreakpoints,d0		; check if too many
00:00009972 645A            	  3498: 	bhs.s			.0001
00:00009974 527900040202    	  3499: 	addi.w		#1,NumSetBreakpoints	; increment number of breakpoints
00:0000997A 2400            	  3500: 	move.l		d0,d2
00:0000997C 6100EE12        	  3501: 	bsr				ignBlanks
00:00009980 6100F466        	  3502: 	bsr				GetHexNumber
00:00009984 6748            	  3503: 	beq.s			.0001									; was there an address?
00:00009986 08010000        	  3504: 	btst			#0,d1									; address value must be even
00:0000998A 6642            	  3505: 	bne.s			.0001
                            	  3506: 	; See if the breakpoint is in the table already
00:0000998C 43F900040220    	  3507: 	lea				Breakpoints,a1				; a1 points to breakpoint table
00:00009992 343C0007        	  3508: 	move.w		#numBreakpoints-1,d2
                            	  3509: .0002:
00:00009996 B299            	  3510: 	cmp.l			(a1)+,d1
00:00009998 673A            	  3511: 	beq.s			.0003									; breakpoint is in table already
00:0000999A 51CAFFFA        	  3512: 	dbra			d2,.0002
                            	  3513: 	; Add breakpoint to table
                            	  3514: 	; Search for empty entry
00:0000999E 43F900040220    	  3515: 	lea				Breakpoints,a1				; a1 = pointer to breakpoint address table
00:000099A4 4242            	  3516: 	clr.w			d2										; d2 = count
                            	  3517: .0006:
00:000099A6 4A91            	  3518: 	tst.l			(a1)									; is the entry empty?
00:000099A8 670C            	  3519: 	beq.s			.0005									; branch if found empty entry
00:000099AA 5889            	  3520: 	lea				4(a1),a1							; point to next entry
00:000099AC 5242            	  3521: 	addi.w		#1,d2									; increment count
00:000099AE 0C420008        	  3522: 	cmpi.w		#numBreakpoints,d2		; safety: check against max number
00:000099B2 65F2            	  3523: 	blo.s			.0006
00:000099B4 6018            	  3524: 	bra.s			.0001									; what? no empty entries found, table corrupt?
                            	  3525: .0005:
00:000099B6 E542            	  3526: 	asl.w			#2,d2									; d2 = long word index
00:000099B8 23812000        	  3527: 	move.l		d1,(a1,d2.w)					; move breakpoint address to table
00:000099BC 2441            	  3528: 	move.l		d1,a2
00:000099BE E24A            	  3529: 	lsr.w			#1,d2									; d2 = word index
                            	  3530: .0004:
00:000099C0 43F900040280    	  3531: 	lea				BreakpointWords,a1
00:000099C6 33922000        	  3532: 	move.w		(a2),(a1,d2.w)				; copy instruction word to table
00:000099CA 34BC4E43        	  3533: 	move.w		#$4E43,(a2)						; replace word with TRAP3
                            	  3534: .0001:
00:000099CE 4CDF0707        	  3535: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
00:000099D2 4E75            	  3536: 	rts
                            	  3537: .0003:
00:000099D4 2469FFFC        	  3538: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
00:000099D8 0C524E43        	  3539: 	cmpi.w		#$4E43,(a2)						; see if breakpoint already armed
00:000099DC 67F0            	  3540: 	beq.s			.0001
00:000099DE D482            	  3541: 	asl.l			#1,d2									; d2 = word index
00:000099E0 60DE            	  3542: 	bra.s			.0004
                            	  3543: 
                            	  3544: 
                            	  3545: ;------------------------------------------------------------------------------
                            	  3546: ;------------------------------------------------------------------------------
                            	  3547: 
                            	  3548: DisarmBreakpoint:
00:000099E2 48E7E0E0        	  3549: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
00:000099E6 303900040202    	  3550: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:000099EC 0C400008        	  3551: 	cmpi.w		#numBreakpoints,d0		; check if too many
00:000099F0 623E            	  3552: 	bhi.s			.0001
00:000099F2 2400            	  3553: 	move.l		d0,d2
00:000099F4 6100ED9A        	  3554: 	bsr				ignBlanks
00:000099F8 6100F3EE        	  3555: 	bsr				GetHexNumber
00:000099FC 6732            	  3556: 	beq.s			.0001									; was there an address?
00:000099FE 08010000        	  3557: 	btst			#0,d1									; address value must be even
00:00009A02 662C            	  3558: 	bne.s			.0001
                            	  3559: 	; See if the breakpoint is in the table already
00:00009A04 43F900040220    	  3560: 	lea				Breakpoints,a1				; a1 points to breakpoint table
00:00009A0A 5342            	  3561: 	subi.w		#1,d2
                            	  3562: .0002:
00:00009A0C B299            	  3563: 	cmp.l			(a1)+,d1
00:00009A0E 6706            	  3564: 	beq.s			.0003									; breakpoint is in table already
00:00009A10 51CAFFFA        	  3565: 	dbra			d2,.0002
00:00009A14 601A            	  3566: 	bra				.0001									; breakpoint was not in table
                            	  3567: .0003:
                            	  3568: 	; Remove breakpoint from table
00:00009A16 537900040202    	  3569: 	subi.w		#1,NumSetBreakpoints	; decrement number of breakpoints
00:00009A1C 2469FFFC        	  3570: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
00:00009A20 42A9FFFC        	  3571: 	clr.l			-4(a1)								; empty out breakpoint
00:00009A24 43F900040280    	  3572: 	lea				BreakpointWords,a1
00:00009A2A D482            	  3573: 	asl.l			#1,d2									; d2 = word index
00:00009A2C 34B12000        	  3574: 	move.w		(a1,d2.w),(a2)				; copy instruction from table back to code
                            	  3575: .0001:
00:00009A30 4CDF0707        	  3576: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
00:00009A34 4E75            	  3577: 	rts
                            	  3578: 
                            	  3579: ;------------------------------------------------------------------------------
                            	  3580: ;------------------------------------------------------------------------------
                            	  3581: 
                            	  3582: ListBreakpoints:
00:00009A36 6100E092        	  3583: 	bsr			CRLF
00:00009A3A 343C0008        	  3584: 	move.w	#numBreakpoints,d2
00:00009A3E 43F900040220    	  3585: 	lea			Breakpoints,a1
                            	  3586: .0001:
00:00009A44 2219            	  3587: 	move.l	(a1)+,d1
00:00009A46 6100F97C        	  3588: 	bsr			DisplayTetra
00:00009A4A 6100E07E        	  3589: 	bsr			CRLF
00:00009A4E 51CAFFF4        	  3590: 	dbra		d2,.0001
00:00009A52 6000E6E4        	  3591: 	bra			Monitor
                            	  3592: 
                            	  3593: ;------------------------------------------------------------------------------
                            	  3594: ;------------------------------------------------------------------------------
                            	  3595: 
                            	  3596: ClearBreakpointList:
00:00009A56 343C0008        	  3597: 	move.w	#numBreakpoints,d2
00:00009A5A 43F900040220    	  3598: 	lea			Breakpoints,a1
                            	  3599: .0001:
00:00009A60 4299            	  3600: 	clr.l		(a1)+
00:00009A62 51CAFFFC        	  3601: 	dbra		d2,.0001
00:00009A66 4E75            	  3602: 	rts
                            	  3603: 
                            	  3604: ;------------------------------------------------------------------------------
                            	  3605: ; SendMsg
                            	  3606: ; 00100xy0
                            	  3607: ;
                            	  3608: ; Parameters:
                            	  3609: ;		d1 = target core number
                            	  3610: ;		d2 = argument 1
                            	  3611: ;		d3 = argument 2
                            	  3612: ;		d4 = argument 3
                            	  3613: ;
                            	  3614: ;------------------------------------------------------------------------------
                            	  3615: 
                            	  3616: SendMsg:
00:00009A68 48E70440        	  3617: 	movem.l	d5/a1,-(a7)
00:00009A6C E149            	  3618: 	lsl.w		#8,d1
00:00009A6E 4E7A5FE0        	  3619: 	movec		coreno,d5
00:00009A72 E94D            	  3620: 	lsl.w		#4,d5
00:00009A74 8245            	  3621: 	or.w		d5,d1
00:00009A76 43F900100000    	  3622: 	lea			$00100000,a1
00:00009A7C 4AB11000        	  3623: 	tst.l		0(a1,d1.w)
00:00009A80 661C            	  3624: 	bne			.msgFull
00:00009A82 4E7A5FE0        	  3625: 	movec		coreno,d5
00:00009A86 23851000        	  3626: 	move.l	d5,0(a1,d1.w)
00:00009A8A 23821004        	  3627: 	move.l	d2,4(a1,d1.w)
00:00009A8E 23831008        	  3628: 	move.l	d3,8(a1,d1.w)
00:00009A92 2384100C        	  3629: 	move.l	d4,12(a1,d1.w)
00:00009A96 4CDF0220        	  3630: 	movem.l	(a7)+,d5/a1
00:00009A9A 7200            	  3631: 	moveq		#0,d1
00:00009A9C 4E75            	  3632: 	rts
                            	  3633: .msgFull:
00:00009A9E 4CDF0220        	  3634: 	movem.l	(a7)+,d5/a1
00:00009AA2 72FF            	  3635: 	moveq		#-1,d1
00:00009AA4 4E75            	  3636: 	rts
                            	  3637: 
                            	  3638: ;------------------------------------------------------------------------------
                            	  3639: ; ReceiveMsg
                            	  3640: ;		Scan the message table for messages and dispatch them.
                            	  3641: ; 00100xy0
                            	  3642: ;
                            	  3643: ; Parameters:
                            	  3644: ;------------------------------------------------------------------------------
                            	  3645: 
                            	  3646: ReceiveMsg:
00:00009AA6 48E77F40        	  3647: 	movem.l		d1/d2/d3/d4/d5/d6/d7/a1,-(a7)
00:00009AAA 43F900100000    	  3648: 	lea				$00100000,a1
00:00009AB0 4E7A5FE0        	  3649: 	movec			coreno,d5
00:00009AB4 E14D            	  3650: 	lsl.w			#8,d5
00:00009AB6 7C02            	  3651: 	moveq			#2,d6
                            	  3652: .nextCore:
00:00009AB8 3E06            	  3653: 	move.w		d6,d7
00:00009ABA E94F            	  3654: 	lsl.w			#4,d7
00:00009ABC DE45            	  3655: 	add.w			d5,d7
00:00009ABE 4AB17000        	  3656: 	tst.l			0(a1,d7.w)			; Is there a message from core d6?
00:00009AC2 6716            	  3657: 	beq.s			.noMsg
00:00009AC4 22317000        	  3658: 	move.l		0(a1,d7.w),d1
00:00009AC8 24317004        	  3659: 	move.l		4(a1,d7.w),d2
00:00009ACC 26317008        	  3660: 	move.l		8(a1,d7.w),d3
00:00009AD0 2831700C        	  3661: 	move.l		12(a1,d7.w),d4
00:00009AD4 42B17000        	  3662: 	clr.l			0(a1,d7.w)			; indicate message was received
00:00009AD8 610E            	  3663: 	bsr				DispatchMsg
                            	  3664: .noMsg:
00:00009ADA 5246            	  3665: 	addq			#1,d6
00:00009ADC BC7C0009        	  3666: 	cmp.w			#9,d6
00:00009AE0 63D6            	  3667: 	bls				.nextCore
00:00009AE2 4CDF02FE        	  3668: 	movem.l		(a7)+,d1/d2/d3/d4/d5/d6/d7/a1
00:00009AE6 4E75            	  3669: 	rts
                            	  3670: 
                            	  3671: ;------------------------------------------------------------------------------
                            	  3672: ;------------------------------------------------------------------------------
                            	  3673: 
                            	  3674: DispatchMsg:
00:00009AE8 4E75            	  3675: 	rts
                            	  3676: 
                            	  3677: ;------------------------------------------------------------------------------
                            	  3678: ; Trap #15, function 39 - convert floating-point to string and display
                            	  3679: ;
                            	  3680: ; Parameters
                            	  3681: ;		a1 = pointer to buffer
                            	  3682: ;		fp0 = number to print
                            	  3683: ;		d1 = width of print field
                            	  3684: ;		d2 = precision
                            	  3685: ;		d3 = 'E' or 'e'
                            	  3686: ;------------------------------------------------------------------------------
                            	  3687: 
                            	  3688: prtflt:
00:00009AEA 4E52FFD0        	  3689: 	link a2,#-48
00:00009AEE 2F7900040098002C	  3690: 	move.l _canary,44(sp)
00:00009AF6 48D7074F        	  3691: 	movem.l d0/d1/d2/d3/d6/a0/a1/a2,(sp)
00:00009AFA F22F68000020    	  3692: 	fmove.x fp0,32(sp)
00:00009B00 2049            	  3693: 	move.l a1,a0						; a0 = pointer to buffer to use
00:00009B02 13C100040508    	  3694: 	move.b d1,_width
00:00009B08 23C200040514    	  3695: 	move.l d2,_precision
00:00009B0E 13C30004050C    	  3696: 	move.b d3,_E
00:00009B14 6100F62A        	  3697: 	bsr _FloatToString
00:00009B18 6100DFCA        	  3698: 	bsr DisplayString
00:00009B1C F22F48000020    	  3699: 	fmove.x 32(sp),fp0
00:00009B22 4CD7074F        	  3700: 	movem.l (sp),d0/d1/d2/d3/d6/a0/a1/a2
00:00009B26 A2AF0003002C    	  3701: 	cchk 44(sp)
00:00009B2C 4E5A            	  3702: 	unlk a2
00:00009B2E 4E75            	  3703: 	rts
                            	  3704: 
                            	  3705: T15FloatToString:
00:00009B30 4E52FFD4        	  3706: 	link a2,#-44
00:00009B34 48D7034F        	  3707: 	movem.l d0/d1/d2/d3/d6/a0/a1,(sp)
00:00009B38 F22F6800001C    	  3708: 	fmove.x fp0,28(sp)
00:00009B3E 2049            	  3709: 	move.l a1,a0						; a0 = pointer to buffer to use
00:00009B40 13C100040508    	  3710: 	move.b d1,_width
00:00009B46 23C200040514    	  3711: 	move.l d2,_precision
00:00009B4C 13C30004050C    	  3712: 	move.b d3,_E
00:00009B52 6100F5EC        	  3713: 	bsr _FloatToString
00:00009B56 F22F4800001C    	  3714: 	fmove.x 28(sp),fp0
00:00009B5C 4CD7034F        	  3715: 	movem.l (sp),d0/d1/d2/d3/d6/a0/a1
00:00009B60 4E5A            	  3716: 	unlk a2
00:00009B62 4E75            	  3717: 	rts
                            	  3718: 
                            	  3719: ;==============================================================================
                            	  3720: ; Parameters:
                            	  3721: ;		d7 = device number
                            	  3722: ;		d6 = function number
                            	  3723: ;		d0 to d5 = arguments
                            	  3724: ;==============================================================================
                            	  3725: 
                            	  3726: io_trap:
00:00009B64 0C070007        	  3727: 	cmpi.b #7,d7							; make sure legal device
00:00009B68 621C            	  3728: 	bhi.s .0002
00:00009B6A 48E70180        	  3729: 	movem.l d7/a0,-(a7)
00:00009B6E 4887            	  3730: 	ext.w d7
00:00009B70 CEFC0084        	  3731: 	mulu #DCB_SIZE,d7					; index to DCB
00:00009B74 207C00040A00    	  3732: 	move.l #null_dcb,a0
00:00009B7A 20707018        	  3733: 	move.l DCB_CMDPROC(a0,d7.w),a0
00:00009B7E 4E90            	  3734: 	jsr (a0)
00:00009B80 4CDF0180        	  3735: 	movem.l (a7)+,d7/a0
00:00009B84 4E73            	  3736: 	rte
                            	  3737: .0002:
00:00009B86 7020            	  3738: 	moveq #E_BadDevNum,d0
00:00009B88 4E73            	  3739: 	rte
                            	  3740: 
                            	  3741: ;==============================================================================
                            	  3742: ; Output a character to the current output device.
                            	  3743: ;
                            	  3744: ; Parameters:
                            	  3745: ;		d1.b	 character to output
                            	  3746: ; Returns:
                            	  3747: ;		none
                            	  3748: ;==============================================================================
                            	  3749: 
                            	  3750: OutputChar:
00:00009B8A 48E78300        	  3751: 	movem.l d0/d6/d7,-(a7)
00:00009B8E 7E00            	  3752: 	clr.l d7
00:00009B90 7C00            	  3753: 	clr.l d6
00:00009B92 1E39000400A8    	  3754: 	move.b OutputDevice,d7		; d7 = output device
00:00009B98 3C3C0002        	  3755: 	move.w #DEV_PUTCHAR,d6		; d6 = function
00:00009B9C 4E40            	  3756: 	trap #0
00:00009B9E 4CDF00C1        	  3757: 	movem.l (a7)+,d0/d6/d7
00:00009BA2 4E75            	  3758: 	rts
                            	  3759: 
                            	  3760: ;------------------------------------------------------------------------------
                            	  3761: ;------------------------------------------------------------------------------
                            	  3762: 
                            	  3763: InitIRQ:
00:00009BA4 7006            	  3764: 	moveq		#6,d0
00:00009BA6 41F900000B7A    	  3765: 	lea			KeybdIRQ,a0
00:00009BAC 610E            	  3766: 	bsr			InstallIRQ
00:00009BAE 41FA0050        	  3767: 	lea			TickIRQ,a0
00:00009BB2 6108            	  3768: 	bsr			InstallIRQ
00:00009BB4 7003            	  3769: 	moveq		#3,d0
00:00009BB6 41F9000017E4    	  3770: 	lea			SerialIRQ,a0
                            	  3771: 	; fall through
                            	  3772: 
                            	  3773: ;------------------------------------------------------------------------------
                            	  3774: ; Install an IRQ handler.
                            	  3775: ;
                            	  3776: ; Parameters:
                            	  3777: ;		a0 = pointer to bucket containing vector
                            	  3778: ;		d0 = vector (64 to 255)
                            	  3779: ; Returns:
                            	  3780: ;		d0 = 0 if successfully added, otherwise E_NotAlloc
                            	  3781: ;		nf = 0, zf = 1 if successfully added, otherwise nf = 1, zf = 0
                            	  3782: ;------------------------------------------------------------------------------
                            	  3783: 
                            	  3784: InstallIRQ:
00:00009BBC 48E70060        	  3785: 	movem.l a1/a2,-(a7)				; save working register
00:00009BC0 4A90            	  3786: 	tst.l (a0)								; link field must be NULL
00:00009BC2 6634            	  3787: 	bne.s .0003
00:00009BC4 0C400040        	  3788: 	cmpi.w #64,d0							; is vector in range (64 to 255)?
00:00009BC8 652E            	  3789: 	blo.s .0003
00:00009BCA 0C4000FF        	  3790: 	cmpi.w #255,d0
00:00009BCE 6228            	  3791: 	bhi.s .0003
00:00009BD0 45F80400        	  3792: 	lea	irq_list_tbl,a2				; a2 points to installed IRQ list
00:00009BD4 E748            	  3793: 	lsl.w	#3,d0								; multiply by 2 long words
00:00009BD6 22720000        	  3794: 	move.l (a2,d0.w),a1				; get first link
00:00009BDA 45F20000        	  3795: 	lea (a2,d0.w),a2					; 
                            	  3796: .0002:
00:00009BDE B1C9            	  3797: 	cmpa.l a1,a0							; installed already?
00:00009BE0 6716            	  3798: 	beq.s .0003
00:00009BE2 B2FC0000        	  3799: 	cmpa.l #0,a1							; is link NULL?
00:00009BE6 6706            	  3800: 	beq.s .0001
00:00009BE8 2449            	  3801: 	move.l a1,a2							; save previous link
00:00009BEA 2251            	  3802: 	move.l (a1),a1						; get next link
00:00009BEC 60F0            	  3803: 	bra .0002
                            	  3804: .0001:
00:00009BEE 2488            	  3805: 	move.l a0,(a2)						; set link
00:00009BF0 225F245F        	  3806: 	movem.l (a7)+,a1/a2
00:00009BF4 7000            	  3807: 	moveq #E_Ok,d0
00:00009BF6 4E75            	  3808: 	rts
                            	  3809: .0003:
00:00009BF8 225F245F        	  3810: 	movem.l (a7)+,a1/a2
00:00009BFC 7009            	  3811: 	moveq #E_NotAlloc,d0			; return failed to add
00:00009BFE 4E75            	  3812: 	rts
                            	  3813: 
                            	  3814: ;------------------------------------------------------------------------------
                            	  3815: ; TickIRQ
                            	  3816: ; - this IRQ is processed by all cores.
                            	  3817: ; - reset the edge circuit.
                            	  3818: ; - an IRQ live indicator is updated on the text screen for the core
                            	  3819: ;------------------------------------------------------------------------------
                            	  3820: 
                            	  3821: TickIRQ:
00:00009C00 46FC2600        	  3822: 	move.w #$2600,sr					; disable lower level IRQs
00:00009C04 48E77080        	  3823: 	movem.l	d1/d2/d3/a0,-(a7)
00:00009C08 52B90004009C    	  3824: 	addi.l #1,tickcnt
00:00009C0E 13FC0001000400A0	  3825: 	move.b #1,IRQFlag					; tick interrupt indicator in local memory
00:00009C16 4E7A1FE0        	  3826: 	movec	coreno,d1						; d1 = core number
00:00009C1A 2601            	  3827: 	move.l d1,d3
                            	  3828: 	if (SCREEN_FORMAT==1)
00:00009C1C E583            	  3829: 		asl.l #2,d3								; 4 bytes per text cell
                            	  3830: 	else
                            	  3831: 		asl.l #3,d3								; 8 bytes per text cell
                            	  3832: 	endif
00:00009C1E 23FC1D000000FD09	  3833: 	move.l #$1D000000,PLIC+$14	; reset edge sense circuit
00:00009C26 0014
00:00009C28 41F9FD000098    	  3834: 	lea $FD000000+(TEXTCOL-10)*4,a0			; display field address
00:00009C2E 24303004        	  3835: 	move.l 4(a0,d3.w),d2			; get char from screen
                            	  3836: ;	rol.l #8,d2								; extract char field
                            	  3837: ;	clr.b d2									; clear char field
                            	  3838: ;	addi.b #'0',d1						; binary to ascii core number
                            	  3839: ;	or.b	d1,d2								; insert core number
                            	  3840: ;	ror.l #8,d2								; reposition to proper place
                            	  3841: ;	addi.w #1,d2							; flashy colors
00:00009C32 5282            	  3842: 	addi.l #$0001,d2
00:00009C34 21823004        	  3843: 	move.l d2,4(a0,d3.w)			; update onscreen IRQ flag
00:00009C38 6100FE6C        	  3844: 	bsr	ReceiveMsg
00:00009C3C 4CDF010E        	  3845: 	movem.l	(a7)+,d1/d2/d3/a0
00:00009C40 4E73            	  3846: 	rte
                            	  3847: 
                            	  3848: ;------------------------------------------------------------------------------
                            	  3849: ;------------------------------------------------------------------------------
                            	  3850: 
                            	  3851: irq3_rout:
                            	  3852: ;	movem.l	d0/d1/a0/a1,-(a7)
                            	  3853: ;	lea			InstalledIRQ+8*4*3,a0
                            	  3854: ;	bra			irq_rout
                            	  3855: 
                            	  3856: irq6_rout:
                            	  3857: ;	movem.l	d0/d1/a0/a1,-(a7)
                            	  3858: ;	lea			InstalledIRQ+8*4*6,a0
                            	  3859: irq_rout:
00:00009C42 7007            	  3860: 	moveq		#7,d0
                            	  3861: .nextHandler:
00:00009C44 2258            	  3862: 	move.l	(a0)+,a1
00:00009C46 6706            	  3863: 	beq.s		.0003
00:00009C48 4E91            	  3864: 	jsr			(a1)
00:00009C4A 4A81            	  3865: 	tst.l		d1								; was IRQ handled?
00:00009C4C 6B04            	  3866: 	bmi.s		.0002							; first one to return handled quits loop
                            	  3867: .0003:
00:00009C4E 51C8FFF4        	  3868: 	dbra		d0,.nextHandler
                            	  3869: .0002:
00:00009C52 4CDF0303        	  3870: 	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  3871: 
                            	  3872: ; Load head of list into an address register, then branch to a generic routine.
                            	  3873: 
                            	  3874: ;	rept 192
                            	  3875: ;	macIRQ_proc_label REPTN
                            	  3876: ;	movem.l a0/a1,-(a7)
                            	  3877: ;	move.l irq_list_tbl+REPTN*4,a1	; get the head of the list
                            	  3878: ;	jmp irq_proc_generic
                            	  3879: ;	endr
                            	  3880: 
                            	  3881: irq_proc_generic:
                            	  3882: .0003:
00:00009C56 20690004        	  3883: 	move.l 4(a1),a0									; a0 = vector
00:00009C5A B0FC0000        	  3884: 	cmpa.l #0,a0										; ugh. move to address does not set flags
00:00009C5E 6706            	  3885: 	beq.s .0001											; valid vector?
00:00009C60 4E90            	  3886: 	jsr (a0)												; call the interrupt routine
00:00009C62 4A81            	  3887: 	tst.l d1												; IRQ handled?
00:00009C64 6B08            	  3888: 	bmi.s .0002											
                            	  3889: .0001:
00:00009C66 2251            	  3890: 	move.l (a1),a1
00:00009C68 B0FC0000        	  3891: 	cmpa.l #0,a0										; end of list?
00:00009C6C 66E8            	  3892: 	bne.s .0003
                            	  3893: .0002:
00:00009C6E 205F225F        	  3894: 	movem.l (a7)+,a0/a1
00:00009C72 4E73            	  3895: 	rte 
                            	  3896: 
                            	  3897: SpuriousIRQ:
00:00009C74 4E73            	  3898: 	rte
                            	  3899: 
                            	  3900: ;	bsr			KeybdIRQ
                            	  3901: ;	tst.l		d1								; handled by KeybdIRQ?
                            	  3902: ;	bmi.s		.0002							; if yes, go return
                            	  3903: ;.0001:
                            	  3904: ;	move.l	#$1D000000,PLIC+$14	; reset edge sense circuit
                            	  3905: ;	move.l	TextScr,a0				; a0 = screen address
                            	  3906: ;	addi.l	#1,40(a0)					; update onscreen IRQ flag
                            	  3907: ;.0002:	
                            	  3908: ;	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  3909: ;	rte
                            	  3910: 
                            	  3911: nmi_rout:
00:00009C76 48E7C080        	  3912: 	movem.l	d0/d1/a0,-(a7)
00:00009C7A 123C004E        	  3913: 	move.b	#'N',d1
00:00009C7E 6100FF0A        	  3914: 	bsr			OutputChar
00:00009C82 4CDF0103        	  3915: 	movem.l	(a7)+,d0/d1/a0		; return
00:00009C86 4E73            	  3916: 	rte
                            	  3917: 
                            	  3918: addr_err:
00:00009C88 544F            	  3919: 	addq		#2,sp						; get rid of sr
00:00009C8A 221F            	  3920: 	move.l	(sp)+,d1				; pop exception address
00:00009C8C 6100F736        	  3921: 	bsr			DisplayTetra		; and display it
00:00009C90 43FA00A6        	  3922: 	lea			msgAddrErr,a1	; followed by message
00:00009C94 6100DE64        	  3923: 	bsr			DisplayStringCRLF
                            	  3924: .0001:
00:00009C98 60FE            	  3925: 	bra			.0001
00:00009C9A 6000E49C        	  3926: 	bra			Monitor
                            	  3927: 	
                            	  3928: brdisp_trap:
00:00009C9E 48F9FFFF00040100	  3929: 	movem.l	d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
00:00009CA6 33DF00040140    	  3930: 	move.w	(a7)+,Regsave+$40
00:00009CAC 23DF00040144    	  3931: 	move.l	(a7)+,Regsave+$44
00:00009CB2 2E7C00047FFC    	  3932: 	move.l	#$47FFC,a7			; reset stack pointer
00:00009CB8 46FC2500        	  3933: 	move.w	#$2500,sr				; enable interrupts
00:00009CBC 43FA0099        	  3934: 	lea			msg_bad_branch_disp,a1
00:00009CC0 6100DE22        	  3935: 	bsr			DisplayString
00:00009CC4 6100F6F6        	  3936: 	bsr			DisplaySpace
00:00009CC8 223900040144    	  3937: 	move.l	Regsave+$44,d1	; exception address
00:00009CCE 6100F6F4        	  3938: 	bsr			DisplayTetra		; and display it
                            	  3939: ;	move.l	(sp)+,d1				; pop format word 68010 mode only
00:00009CD2 6000F046        	  3940: 	bra			cmdDumpRegs
                            	  3941: 
                            	  3942: illegal_trap:
00:00009CD6 544F            	  3943: 	addq		#2,sp						; get rid of sr
00:00009CD8 221F            	  3944: 	move.l	(sp)+,d1				; pop exception address
00:00009CDA 6100F6E8        	  3945: 	bsr			DisplayTetra		; and display it
00:00009CDE 43FA0065        	  3946: 	lea			msg_illegal,a1	; followed by message
00:00009CE2 6100DE00        	  3947: 	bsr			DisplayString
                            	  3948: .0001:
00:00009CE6 60FE            	  3949: 	bra			.0001
00:00009CE8 6000E44E        	  3950: 	bra			Monitor
                            	  3951: 	
                            	  3952: io_irq:
00:00009CEC 544F            	  3953: 	addq #2,sp
00:00009CEE 221F            	  3954: 	move.l (sp)+,d1
00:00009CF0 6100F6D2        	  3955: 	bsr DisplayTetra
00:00009CF4 43FA0083        	  3956: 	lea msg_io_access,a1
00:00009CF8 6100DDEA        	  3957: 	bsr DisplayString
00:00009CFC 6000F01C        	  3958: 	bra cmdDumpRegs
                            	  3959: 
                            	  3960: ; -----------------------------------------------------------------------------
                            	  3961: ; -----------------------------------------------------------------------------
                            	  3962: 
                            	  3963: msg_start:
00:00009D00 46656D74696B6920	  3964: 	dc.b	"Femtiki rf68k Multi-core OS Starting",LF,CR,0
00:00009D08 726636386B204D75
00:00009D10 6C74692D636F7265
00:00009D18 204F532053746172
00:00009D20 74696E67
00:00009D24 0A
00:00009D25 0D
00:00009D26 00
                            	  3965: ;	dc.b	"rf68k System Starting",CR,LF,0
                            	  3966: msg_core_start:
00:00009D27 20636F7265207374	  3967: 	dc.b	" core starting",CR,LF,0
00:00009D2F 617274696E67
00:00009D35 0D
00:00009D36 0A
00:00009D37 00
                            	  3968: msgAddrErr
00:00009D38 2061646472657373	  3969: 	dc.b	" address err",0
00:00009D40 20657272
00:00009D44 00
                            	  3970: msg_illegal:
00:00009D45 20696C6C6567616C	  3971: 	dc.b	" illegal opcode",CR,LF,0
00:00009D4D 206F70636F6465
00:00009D54 0D
00:00009D55 0A
00:00009D56 00
                            	  3972: msg_bad_branch_disp:
00:00009D57 206272616E636820	  3973: 	dc.b	" branch selfref: ",0
00:00009D5F 73656C667265663A
00:00009D67 20
00:00009D68 00
                            	  3974: msg_test_done:
00:00009D69 2043505520746573	  3975: 	dc.b	" CPU test done.",0
00:00009D71 7420646F6E652E
00:00009D78 00
                            	  3976: msg_io_access
00:00009D79 20756E7065726D69	  3977: 	dc.b " unpermitted access to I/O",0
00:00009D81 7474656420616363
00:00009D89 65737320746F2049
00:00009D91 2F4F
00:00009D93 00
                            	  3978: msgChk
00:00009D94 20636865636B2066	  3979: 	dc.b " check failed",0
00:00009D9C 61696C6564
00:00009DA1 00
                            	  3980: msgStackCanary
00:00009DA2 20737461636B2063	  3981: 	dc.b " stack canary overwritten",0
00:00009DAA 616E617279206F76
00:00009DB2 6572777269747465
00:00009DBA 6E
00:00009DBB 00
                            	  3982: 
                            	  3983: 	even
                            	  3984: 
                            	  3985: ;-------------------------------------------------------------------------
                            	  3986: ; File HEX2DEC   HEX2DEC convert hex to decimal                   11/02/81
                            	  3987: ;
                            	  3988: ;    CONVERT BINARY TO DECIMAL  REG  D0 PUT IN ( A6) BUFFER AS ASCII
                            	  3989: 
                            	  3990: ; Shift buffer one character to left
                            	  3991: ShiftBuf:
00:00009DBC 48E78028        	  3992: 	movem.l d0/a2/a4,-(a7)
00:00009DC0 200B            	  3993: 	move.l a3,d0
00:00009DC2 06800000003F    	  3994: 	addi.l #BUFSIZE,d0
                            	  3995: .0001:
00:00009DC8 18EC0001        	  3996: 	move.b 1(a4),(a4)+
00:00009DCC B08C            	  3997: 	cmp.l a4,d0
00:00009DCE 65F8            	  3998: 	blo.s .0001
00:00009DD0 4CDF1401        	  3999: 	movem.l (a7)+,d0/a2/a4
00:00009DD4 4E75            	  4000: 	rts
                            	  4001: 
                            	  4002: HEX2DEC2:
00:00009DD6 48E7C01C        	  4003: 	movem.l d0/d1/a3/a4/a5,-(a7)
00:00009DDA 264E            	  4004: 	move.l a6,a3
00:00009DDC 284E            	  4005: 	move.l a6,a4
00:00009DDE 2200            	  4006: 	move.l d0,d1
00:00009DE0 6A0A            	  4007: 	bpl.s .0001
00:00009DE2 4480            	  4008: 	neg.l d0										;
00:00009DE4 6B32            	  4009: 	bmi.s .0002									; neg and still minus, must be -tve zero
00:00009DE6 1CFC002D        	  4010: 	move.b #'-',(a6)+
00:00009DEA 284E            	  4011: 	move.l a6,a4
                            	  4012: .0001:
00:00009DEC 82FC0064        	  4013: 	divu #100,d1								; scale d1 - chop last 2 decimal digits
00:00009DF0 A2C10000        	  4014: 	bin2bcd d1									; convert to BCD
00:00009DF4 6100F5FA        	  4015: 	bsr BufTetra								; capture in buffer (8 digits)
00:00009DF8 2200            	  4016: 	move.l d0,d1
00:00009DFA A2C10000        	  4017: 	bin2bcd d1									; convert to BCD
00:00009DFE 6100F5FC        	  4018: 	bsr BufByte									; capture last 2 digits in buffer
                            	  4019: .0004:
00:00009E02 0C140030        	  4020: 	cmpi.b #'0',(a4)						; Is there a leading zero?
00:00009E06 6606            	  4021: 	bne.s .0003									; No, we're done shifting
00:00009E08 61B2            	  4022: 	bsr ShiftBuf								; Shift the buffer over a character
00:00009E0A 538E            	  4023: 	subq.l #1,a6								; adjust buffer pos.
00:00009E0C 60F4            	  4024: 	bra.s .0004									; go check next character
                            	  4025: .0003:
00:00009E0E 4A14            	  4026: 	tst.b (a4)
00:00009E10 6706            	  4027: 	beq.s .0002
00:00009E12 0C140020        	  4028: 	cmpi.b #' ',(a4)						; is the buffer empty?
00:00009E16 6606            	  4029: 	bne.s .0005
                            	  4030: .0002:
00:00009E18 18FC0030        	  4031: 	move.b #'0',(a4)+						; ensure at least a '0'
00:00009E1C 2C4C            	  4032: 	move.l a4,a6
                            	  4033: .0005:
00:00009E1E 4CDF3803        	  4034: 	movem.l (a7)+,d0/d1/a3/a4/a5
00:00009E22 4E75            	  4035: 	rts
                            	  4036: 
                            	  4037: HEX2DEC: 
00:00009E24 48E77B00        	  4038: 	movem.l D1-D4/D6-D7,-(A7)   ; SAVE REGISTERS
00:00009E28 2E00            	  4039: 	move.l D0,D7          			; SAVE IT HERE
00:00009E2A 6A08            	  4040: 	bpl.s HX2DC
00:00009E2C 4487            	  4041: 	neg.l D7              			; CHANGE TO POSITIVE
00:00009E2E 6B4E            	  4042: 	bmi.s HX2DC57          			; SPECIAL CASE (-0)
00:00009E30 1CFC002D        	  4043: 	move.b #'-',(A6)+      			; PUT IN NEG SIGN
                            	  4044: HX2DC:  
00:00009E34 4244            	  4045: 	clr.w D4              			; FOR ZERO SURPRESS
00:00009E36 7C0A            	  4046: 	moveq #10,D6          			; COUNTER
                            	  4047: HX2DC0:
00:00009E38 7401            	  4048:   moveq #1,D2           			; VALUE TO SUB
00:00009E3A 2206            	  4049: 	move.l D6,D1          			; COUNTER
00:00009E3C 5381            	  4050: 	subq.l #1,D1           			; ADJUST - FORM POWER OF TEN
00:00009E3E 671A            	  4051: 	beq.s HX2DC2           			; IF POWER IS ZERO
                            	  4052: HX2DC1:
00:00009E40 3602            	  4053:   move.w D2,D3          			; D3=LOWER WORD
00:00009E42 C6FC000A        	  4054: 	mulu #10,D3
00:00009E46 4842            	  4055: 	swap D2              				; D2=UPPER WORD
00:00009E48 C4FC000A        	  4056: 	mulu #10,D2
00:00009E4C 4843            	  4057: 	swap D3              				; ADD UPPER TO UPPER
00:00009E4E D443            	  4058: 	add.w D3,D2
00:00009E50 4842            	  4059: 	swap D2              				; PUT UPPER IN UPPER
00:00009E52 4843            	  4060: 	swap D3              				; PUT LOWER IN LOWER
00:00009E54 3403            	  4061: 	move.w D3,D2          			; D2=UPPER & LOWER
00:00009E56 5381            	  4062: 	subq.l #1,D1
00:00009E58 66E6            	  4063: 	bne.s HX2DC1
                            	  4064: HX2DC2:
00:00009E5A 7000            	  4065:   clr.l D0              			; HOLDS SUB AMT
                            	  4066: HX2DC22:
00:00009E5C BE82            	  4067: 	cmp.l D2,D7
00:00009E5E 6D06            	  4068:   blt.s HX2DC3           			; IF NO MORE SUB POSSIBLE
00:00009E60 5280            	  4069: 	addq.l #1,D0           			; BUMP SUBS
00:00009E62 9E82            	  4070: 	sub.l D2,D7          				; COUNT DOWN BY POWERS OF TEN
00:00009E64 60F6            	  4071: 	bra.s HX2DC22          			; DO MORE
                            	  4072: HX2DC3:
00:00009E66 4A00            	  4073:   tst.b D0              			; ANY VALUE?
00:00009E68 6604            	  4074: 	bne.s HX2DC4
00:00009E6A 4A44            	  4075: 	tst.w D4              			; ZERO SURPRESS
00:00009E6C 6708            	  4076: 	beq.s HX2DC5
                            	  4077: HX2DC4:
00:00009E6E 06000030        	  4078:   addi.b #$30,D0         		; BINARY TO ASCII
00:00009E72 1CC0            	  4079: 	move.b D0,(A6)+       			; PUT IN BUFFER
00:00009E74 1800            	  4080: 	move.b D0,D4          			; MARK AS NON ZERO SURPRESS
                            	  4081: HX2DC5:
00:00009E76 5386            	  4082:   subq.l #1,D6           			; NEXT POWER
00:00009E78 66BE            	  4083: 	bne.s HX2DC0
00:00009E7A 4A44            	  4084: 	tst.w D4              			; SEE IF ANYTHING PRINTED
00:00009E7C 6604            	  4085: 	bne.s HX2DC6
                            	  4086: HX2DC57:
00:00009E7E 1CFC0030        	  4087:  move.b #'0',(A6)+      			; PRINT AT LEST A ZERO
                            	  4088: HX2DC6:
00:00009E82 4CDF00DE        	  4089: 	movem.l (A7)+,D1-D4/D6-D7 ; RESTORE REGISTERS
00:00009E86 4E75            	  4090:   rts                      	; END OF ROUTINE
                            	  4091: 
                            	  4092: 
                            	  4093: PNT4HX:
                            	  4094: PNT4HEX:
00:00009E88 6000F56C        	  4095: 	bra BufWyde
                            	  4096: PNT6HX:
00:00009E8C 4840            	  4097: 	swap d0
00:00009E8E 6100F56C        	  4098: 	bsr BufByte
00:00009E92 4840            	  4099: 	swap d0
00:00009E94 6000F560        	  4100: 	bra BufWyde
                            	  4101: PNT8HX:
00:00009E98 6000F556        	  4102: 	bra BufTetra
                            	  4103: 	
                            	  4104: ; FORMAT RELATIVE ADDRESS  AAAAAA+Rn
                            	  4105: ;        ENTER     D0 = VALUE
                            	  4106: ;                  A6 = STORE POINTER
                            	  4107: ;
                            	  4108: FRELADDR:
00:00009E9C 48E74780        	  4109: 	movem.l D1/D5-D7/A0,-(A7)
00:00009EA0 41F900040880    	  4110: 	lea OFFSET,A0
00:00009EA6 7EFF            	  4111: 	moveq #-1,D7        	; D7 = DIFF. BEST FIT
00:00009EA8 7C00            	  4112: 	clr.l D6            	; D6 = OFFSET POSITION
                            	  4113: FREL10:
00:00009EAA 2200            	  4114:   move.l D0,D1
00:00009EAC 4A90            	  4115: 	tst.l (a0)
00:00009EAE 670C            	  4116: 	beq.s FREL15         	; ZERO OFFSET
00:00009EB0 9290            	  4117: 	sub.l (a0),d1      		; D1 = DIFF.
00:00009EB2 6B08            	  4118: 	bmi.s FREL15         	; NO FIT
00:00009EB4 B287            	  4119: 	cmp.l D7,D1
00:00009EB6 6404            	  4120: 	bcc.s FREL15         	; OLD FIT BETTER
00:00009EB8 2E01            	  4121: 	move.l D1,D7        	; D7 = NEW BEST FIT
00:00009EBA 2A06            	  4122: 	move.l D6,D5        	; D5 = POSITION
                            	  4123: FREL15:
00:00009EBC 5888            	  4124:   addq.l #4,A0
00:00009EBE 5286            	  4125: 	addq.l #1,D6
00:00009EC0 0C460008        	  4126: 	cmpi.w #8,D6
00:00009EC4 66E4            	  4127: 	bne.s FREL10         	; MORE OFFSETS TO CHECK
00:00009EC6 4A87            	  4128: 	tst.l D7
00:00009EC8 6B1E            	  4129: 	bmi.s FREL25         	; NO FIT
00:00009ECA 4A46            	  4130: 	tst D6
00:00009ECC 6608            	  4131: 	bne.s FREL20
00:00009ECE 4AB900040880    	  4132: 	tst.l OFFSET
00:00009ED4 6712            	  4133: 	beq.s FREL25         	; R0 = 000000; NO FIT
                            	  4134: FREL20:
00:00009ED6 2007            	  4135:   move.l D7,D0
00:00009ED8 61B2            	  4136: 	bsr	PNT6HX         		; FORMAT OFFSET
00:00009EDA 1CFC002B        	  4137: 	move.b #'+',(A6)+    	; +
00:00009EDE 1CFC0052        	  4138: 	move.b #'R',(A6)+    	; R
00:00009EE2 06050030        	  4139: 	addi.b #'0',D5       	; MAKE ASCII
00:00009EE6 600A            	  4140: 	bra.s FREL30
                            	  4141: FREL25:
00:00009EE8 61A2            	  4142:   bsr	PNT6HX         	; FORMAT ADDRESS AS IS
00:00009EEA 1A3C0020        	  4143: 	move.b #BLANK,D5
00:00009EEE 1CC5            	  4144: 	move.b D5,(A6)+     	; THREE SPACES FOR ALIGNMENT
00:00009EF0 1CC5            	  4145: 	move.b D5,(A6)+
                            	  4146: FREL30:
00:00009EF2 1CC5            	  4147:   move.b D5,(A6)+
00:00009EF4 4CDF01E2        	  4148: 	movem.l (A7)+,D1/D5-D7/A0
00:00009EF8 4E75            	  4149: 	rts
                            	  4150: 
                            	  4151: 	include "dcode68k.x68"

Source: "dcode68k.x68"
                            	     1: ;-------------------------------------------------------------------------
                            	     2: ; File DCODE68K  68K ONE LINE DISASSEMBLER                        07/28/82
                            	     3: ;
                            	     4: ;        CALLING SEQUENCE:
                            	     5: ;   D0,D1,D2 = CODE TO BE DISASSEMBLED
                            	     6: ;   A4 = VALUE OF PROGRAM COUNTER FOR THE CODE
                            	     7: ;   A5 = POINTER TO STORE DATA (BUFSIZE = 80 ASSUMED)
                            	     8: ;        JSR       DCODE68K
                            	     9: ;
                            	    10: ;        RETURN:
                            	    11: ;   A4 = VALUE OF PROGRAM COUNTER FOR NEXT INSTRUCTION
                            	    12: ;   A5 = POINTER TO LINE AS DISASSEMBLED
                            	    13: ;   A6 = POINTER TO END OF LINE
                            	    14: ;
                            	    15: ; 01234567890123456789012345678901234567890123456789
                            	    16: ; AAAAAA FDATA.DDDDDDDDDDDDDD FOC.... FOP.....
                            	    17: ;
                            	    18: ;FDATA   =       10             DATA FIELD
                            	    19: ;FOC     =       31             OP-CODE FIELD
                            	    20: ;FOP     =       39             OPERAND FIELD
                            	    21: ;
                            	    22: ; CAUSES ORGIN MODULO 4
                            	    23: ; LONG:    macro
                            	    24: ;         .align  2
                            	    25: ;         DS.B    (;-X)&2
                            	    26: ;         endm
                            	    27: LOCVARSZ = 16
                            	    28: BUFSIZE  = 63
                            	    29: FDATA    =       10        ; OFFSET TO DATA
                            	    30: FOL      =       31        ; OFFSET TO LABEL
                            	    31: FOC      =       31        ; OFFSET TO OP-CODE (NO LABEL FIELD)
                            	    32: FOP      =       39        ; OFFSET TO OPERAND (NO LABEL FIELD)
                            	    33: 
                            	    34: 					code
                            	    35: 					even
                            	    36: X:       ;              ; BASE ADDRESS THIS MODULE
                            	    37:                                 ; LONG
                            	    38: 
                            	    39: ;  MOVEM REGISTERS TO EA
                            	    40: ;
                            	    41: ;        01001D001S......
                            	    42: ;        ..........XXXXXX       EFFECTIVE ADDRESS
                            	    43: ;        .........0......       WORD
                            	    44: ;        .........1......       LONG
                            	    45: ;        .....0..........       REGISTER TO MEMORY
                            	    46: ;        .....1..........       MEMORY TO REGISTER
                            	    47: ;
                            	    48: ;
                            	    49: IMOVEMFR:
00:00009EFA 610006F8        	    50:          BSR     MOVEMS         ; SIZE
                            	    51: 
00:00009EFE 7C38            	    52:          MOVEQ   #$0038,D6
00:00009F00 CC54            	    53:          AND.W   (A4),D6
00:00009F02 0C460020        	    54:          CMPI.W  #$0020,D6
00:00009F06 6706            	    55:          BEQ.S   IM7788         ; PREDECREMENT MODE
                            	    56: 
00:00009F08 7C01            	    57:          MOVEQ   #1,D6         ; D6 = INCREMENTER (BIT POSITION)
00:00009F0A 7200            	    58:          MOVEQ   #0,D1         ; D1 = BIT POSITION
00:00009F0C 6004            	    59:          BRA.S   IM7799
                            	    60: 
00:00009F0E 7CFF            	    61: IM7788:  MOVEQ   #-1,D6        ; D6 = DECREMENTER (BIT POSITION)
00:00009F10 720F            	    62:          MOVEQ   #15,D1        ; D1 = BIT POSITION
00:00009F12 610006F4        	    63: IM7799:  BSR     MOVEMR         ; BUILD MASK WORD
                            	    64: 
00:00009F16 1CFC002C        	    65:          MOVE.B  #',',(A6)+    ; STORE COMMA
                            	    66: 
00:00009F1A 5483            	    67:          ADDQ.L  #2,D3
00:00009F1C 3814            	    68:          MOVE.W  (A4),D4
00:00009F1E 3E3C01F4        	    69:          MOVE.W  #$1F4,D7     ; CONTROL + PREDECREMENT
00:00009F22 6100050E        	    70:          BSR     EEA
00:00009F26 601A            	    71:          BRA.S   CS16           ; COMMON
                            	    72: 
                            	    73:          
                            	    74: 
                            	    75: ; MOVEM  EA  TO REGISTERS
                            	    76: ;
00:00009F28 610006CA        	    77: IMOVEMTR:BSR     MOVEMS         ; SIZE
00:00009F2C 5483            	    78:          ADDQ.L  #2,D3
00:00009F2E 3E3C07EC        	    79:          MOVE.W  #$7EC,D7     ; CONTROL + POSTINCREMENT
00:00009F32 610004FE        	    80:          BSR     EEA
                            	    81: 
00:00009F36 1CFC002C        	    82:          MOVE.B  #',',(A6)+    ; STORE COMMA
                            	    83: 
00:00009F3A 7C01            	    84:          MOVEQ   #1,D6         ; D6 = BIT POSITION INCREMENTER
00:00009F3C 7200            	    85:          MOVEQ   #0,D1         ; D1 = BIT POSITION
00:00009F3E 610006C8        	    86:          BSR     MOVEMR
                            	    87: 
00:00009F42 606C            	    88: CS16:    BRA.S   CS15           ; COMMON
                            	    89: 
                            	    90:          
                            	    91: ISTOP:
00:00009F44 302C0002        	    92: 	move.w 2(A4),D0
00:00009F48 1CFC0023        	    93: 	move.b #'#',(A6)+    	; IMMEDIATE
00:00009F4C 1CFC0024        	    94: 	move.b #'$',(A6)+    	; HEX
00:00009F50 6100FF36        	    95: 	bsr PNT4HX         		; VALUE
00:00009F54 600007C6        	    96: 	bra COMMON4
                            	    97: 
                            	    98: IMMED:   ;.align  2              ; ADD  AND  CMP #  EOR  OR  SUB
00:00009F58 6100044E        	    99: 	bsr FORMSIZE
00:00009F5C 5483            	   100: 	addq.l #2,D3         	; SIZE = 4
00:00009F5E 1CFC0023        	   101: 	move.b #'#',(A6)+    	; IMMEDIATE
00:00009F62 7000            	   102: 	clr.l D0
00:00009F64 302C0002        	   103: 	move.w 2(A4),D0     	; D0 = EXTENSION WORD
00:00009F68 3214            	   104: 	move.w (A4),D1
00:00009F6A EC49            	   105: 	lsr.w #6,D1
00:00009F6C 02410003        	   106: 	andi.w #3,D1
00:00009F70 6746            	   107: 	beq.s IMMED65        	; .BYTE
00:00009F72 0C010001        	   108: 	cmpi.b #1,D1
00:00009F76 6750            	   109: 	beq.s IMMED75        	; .WORD
00:00009F78 5483            	   110: 	addq.l #2,D3         	; .LONG    SIZE = 6
00:00009F7A 202C0002        	   111: 	move.l 2(A4),D0     	; D0 = LONG EXTENSION WORD
                            	   112: 
                            	   113: IMMED45:
00:00009F7E 6100FEA4        	   114: 	bsr HEX2DEC        		; DECIMAL
00:00009F82 1CC5            	   115: 	move.b D5,(A6)+     	; COMMA SEPARATOR
00:00009F84 3014            	   116: 	move (A4),D0
00:00009F86 0240003F        	   117: 	andi.w #$003F,D0
00:00009F8A 0C40003C        	   118: 	cmpi.w #$003C,D0    	; DESTINATION ADDRESS MODE 111100  "SR"
00:00009F8E 6622            	   119: 	bne.s IMMED55        	; NOT FOUND
00:00009F90 3014            	   120: 	move.w (A4),D0      	; "SR"  ILLEGAL FOR
00:00009F92 02404000        	   121: 	andi.w #$4000,D0    	; ADDI   SUBI  CMPI
00:00009F96 660007AE        	   122: 	bne FERROR         		; 0600   0400  0C00
00:00009F9A 3214            	   123: 	move.w (A4),D1
00:00009F9C 024100C0        	   124: 	andi.w #$00C0,D1
00:00009FA0 0C410080        	   125: 	cmpi.w #$0080,D1
00:00009FA4 670007A0        	   126: 	beq FERROR         		; .LONG NOT ALLOWED
00:00009FA8 1CFC0053        	   127: 	move.b #'S',(A6)+    	; #,SR FOR ANDI, EORI, ORI
00:00009FAC 1CFC0052        	   128: 	move.b #'R',(A6)+
                            	   129: CS15:
00:00009FB0 603C            	   130: 	bra.s CS14           	; COMMON
                            	   131: IMMED55:
00:00009FB2 6100047E        	   132: 	bsr EEA
00:00009FB6 6036            	   133: 	bra.s CS14           	; COMMON
                            	   134: IMMED65:
00:00009FB8 2200            	   135: 	move.l D0,D1        	; D1 = XXXXXXXX........
00:00009FBA E049            	   136: 	lsr.w #8,D1         	; D1 = 00000000XXXXXXXX
00:00009FBC 670A            	   137: 	beq.s IMMED75
00:00009FBE 2200            	   138: 	move.l D0,D1
00:00009FC0 EE41            	   139: 	asr.w #7,D1
00:00009FC2 5241            	   140: 	addq.w #1,D1         ; CHECK FOR NEGATIVE
00:00009FC4 66000780        	   141: 	bne FERROR
                            	   142: IMMED75:
00:00009FC8 48C0            	   143: 	ext.l D0
00:00009FCA 60B2            	   144: 	bra.s IMMED45
                            	   145: 
                            	   146: ;  BIT   5432109876543210
                            	   147: ;        ....RRRMMM......       ; DESTINATION REGISTER MODE
                            	   148: ;        ..........MMMRRR       ; SOURCE MODE REGISTER
                            	   149: ;        0001............       ; .BYTE
                            	   150: ;        0011............       ; .WORD
                            	   151: ;        0010............       ; .LONG
                            	   152: ;
                            	   153: ; IF BYTE SIZE; DESTINATION ADDRESS DIRECT NOT ALLOWED
                            	   154:    
                            	   155: IMOVE:
00:00009FCC 6000037E        	   156: 	bra IMOVEA1
                            	   157: 
                            	   158: ILINK:
00:00009FD0 6158            	   159: 	bsr.s FORMREGA
00:00009FD2 1CC5            	   160: 	move.b D5,(A6)+     ; COMMA SERARATOR
00:00009FD4 1CFC0023        	   161: 	move.b #'#',(A6)+
00:00009FD8 302C0002        	   162: 	move.w 2(A4),D0
00:00009FDC 48C0            	   163: 	ext.l D0
00:00009FDE 6100FE44        	   164: 	bsr HEX2DEC        	; DECIMAL DISPLACEMENT
00:00009FE2 60000738        	   165: 	bra COMMON4
                            	   166:          
                            	   167:          ; CLR  NEG  NEGX  NOT TST
                            	   168: FORM1:
00:00009FE6 610003C0        	   169: 	bsr FORMSIZE
                            	   170: ;                               ; NBCD TAS
                            	   171: FORM1A:
00:00009FEA 61000446        	   172: 	bsr EEA            	; DATA ALTERABLE ONLY
                            	   173: CS14:
00:00009FEE 6068            	   174: 	bra.s CS13          ; COMMON
                            	   175:      
                            	   176: 
                            	   177: 				;.align  2              ; EXT  SWAP
                            	   178: FORM3:   
00:00009FF0 6148            	   179: 	bsr.s FORMREGD
00:00009FF2 6064            	   180: 	bra.s CS13           	; COMMON
                            	   181:          
                            	   182: 
                            	   183: FORM4:	;   .align  2              ; TRAP
00:00009FF4 1CFC0023        	   184:          MOVE.B  #'#',(A6)+
00:00009FF8 3014            	   185:          MOVE.W  (A4),D0
00:00009FFA 02800000000F    	   186:          ANDI.L  #$0F,D0
00:0000A000 6100FE22        	   187:          BSR     HEX2DEC        ; DECIMAL
00:0000A004 6052            	   188:          BRA.S   CS13           ; COMMON
                            	   189: 
                            	   190:          
                            	   191: 
                            	   192: FORM5:	;   .align  2              ; UNLNK
00:0000A006 6122            	   193:          BSR.S   FORMREGA
00:0000A008 604E            	   194:          BRA.S   CS13           ; COMMON
                            	   195: 
                            	   196: ;  BIT   5432109876543210
                            	   197: ;        ....RRR.........       ; ADDRESS REGISTER
                            	   198: ;        ..........XXXXXX       ; EFFECTIVE ADDRESS
                            	   199: ;
                            	   200:          
                            	   201: 
                            	   202: FORM6A:	;  .align  2              ; LEA
00:0000A00A 3E3C07E4        	   203:          MOVE.W  #$7E4,D7     ; CONTROL ADDRESSING
00:0000A00E 6150            	   204:          BSR.S   EEA10
                            	   205: 
00:0000A010 1CC5            	   206:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   207: 
00:0000A012 3814            	   208:          MOVE.W  (A4),D4
00:0000A014 EF5C            	   209:          ROL.W   #7,D4
00:0000A016 6112            	   210:          BSR.S   FORMREGA
00:0000A018 603E            	   211:          BRA.S   CS13           ; COMMON
                            	   212: 
                            	   213: ;  BIT   5432109876543210
                            	   214: ;        ....DDD.........       ; DATA REGISTER
                            	   215: ;        ..........XXXXXX       ; EFFECTIVE ADDRESS
                            	   216: ;
                            	   217:          
                            	   218: 
                            	   219: FORM6D:  ;.align  2              ; CHK  DIVS  DIVU  MULS  MULU
00:0000A01A 3E3C0FFD        	   220:          MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:0000A01E 6140            	   221:          BSR.S   EEA10
                            	   222: 
00:0000A020 1CC5            	   223:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   224: 
00:0000A022 3814            	   225:          MOVE.W  (A4),D4
00:0000A024 EF5C            	   226:          ROL.W   #7,D4
00:0000A026 6112            	   227:          BSR.S   FORMREGD
00:0000A028 602E            	   228:          BRA.S   CS13           ; COMMON
                            	   229: 
00:0000A02A 1CFC0041        	   230: FORMREGA:MOVE.B  #'A',(A6)+    ; FORMAT A@
00:0000A02E 02040007        	   231: FORMREG5:ANDI.B  #$07,D4
00:0000A032 00040030        	   232:          ORI.B   #'0',D4
00:0000A036 1CC4            	   233:          MOVE.B  D4,(A6)+
00:0000A038 4E75            	   234:          RTS
                            	   235: 
00:0000A03A 1CFC0044        	   236: FORMREGD:MOVE.B  #'D',(A6)+    ; FORMAT D@
00:0000A03E 60EE            	   237:          BRA.S   FORMREG5
                            	   238: 
                            	   239: ;  BIT   5432109876543210
                            	   240: ;        ....DDD......DDD       ; DATA REGISTERS
                            	   241: ;
                            	   242:         
                            	   243: FORM7: ;  .align  2              ; EXG
00:0000A040 EF5C            	   244: 	rol.w #7,D4
00:0000A042 61F6            	   245: 	bsr.s FORMREGD
00:0000A044 1CC5            	   246: 	move.b D5,(A6)+     	; COMMA SEPARATOR
00:0000A046 3814            	   247: 	move.w (A4),D4
00:0000A048 61F0            	   248: 	bsr.s FORMREGD
00:0000A04A 600C            	   249: 	bra.s CS13           	; COMMON
                            	   250: 
                            	   251: ;  BIT   5432109876543210
                            	   252: ;        ....AAA......AAA       ; ADDRESS REGISTERS
                            	   253: ;
                            	   254:          
                            	   255: FORM8:   ;.align  2              ; EXG
00:0000A04C EF5C            	   256:          ROL.W   #7,D4
00:0000A04E 61DA            	   257:          BSR.S   FORMREGA
                            	   258: 
                            	   259: FORM815:
00:0000A050 1CFC002C        	   260: 	MOVE.B  #',',(A6)+    ; COMMA SEPARATOR
00:0000A054 3814            	   261: 	MOVE.W  (A4),D4
00:0000A056 61D2            	   262: 	BSR.S   FORMREGA
                            	   263: CS13:
00:0000A058 6078            	   264: 	BRA     CS12           ; COMMON
                            	   265: 
                            	   266: ;  BIT   5432109876543210
                            	   267: ;        ....DDD.........       ; DATA REGISTER
                            	   268: ;        .............AAA       ; ADDRESS REGISTER
                            	   269: ;
                            	   270:          
                            	   271: 
                            	   272: FORM9:   ;.align  2              ; EXG
00:0000A05A EF5C            	   273:          ROL.W   #7,D4
00:0000A05C 61DC            	   274:          BSR.S   FORMREGD       ; DATA REGISTER
00:0000A05E 60F0            	   275:          BRA.S   FORM815
                            	   276: 
00:0000A060 600003D0        	   277: EEA10:   BRA     EEA
                            	   278: 
                            	   279: ;  BIT   5432109876543210
                            	   280: ;        ..........AAAAAA         EFFECTIVE ADDRESS
                            	   281: ;        .......MMM......         OP-MODE
                            	   282: ;        ....RRR.........         D-REGISTER
                            	   283: ;        .......011......         WORD  EA,A@
                            	   284: ;        .......111......         LONG  EA,A@
                            	   285: ;        .......000......         EA,D@ BYTE (ADDRESS REGISTER DIRECT NOT ALLOWED)
                            	   286: ;        .......0........         EA,D@
                            	   287: ;        .......1........         D@,EA
                            	   288: ;        ........00......         BYTE
                            	   289: ;        ........01......         WORD
                            	   290: ;        ........10......         LONG
                            	   291: ;
                            	   292:          
                            	   293: 
                            	   294: ;                               ADD <EA>,A@   CMP <EA>,A@   SUB <EA>,A@
                            	   295: FORM10EX:	;.align  2              ; ADD  CMP  SUB
00:0000A064 3E3C0FFF        	   296:          MOVE.W  #$FFF,D7     ; ALL MODES ALLOWED
00:0000A068 2004            	   297:          MOVE.L  D4,D0
00:0000A06A 024001C0        	   298:          ANDI.W  #$01C0,D0
00:0000A06E 6738            	   299:          BEQ.S   FORM103        ; .......000......
00:0000A070 0C4001C0        	   300:          CMPI.W  #$01C0,D0
00:0000A074 6710            	   301:          BEQ.S   FORM10E3       ; .......111......
00:0000A076 0C4000C0        	   302:          CMPI.W  #$00C0,D0
00:0000A07A 661E            	   303:          BNE.S   FORM10E6
                            	   304: 
00:0000A07C 1AFC002E        	   305:          MOVE.B  #'.',(A5)+    ; .......011......       STORE PERIOD
00:0000A080 1AFC0057        	   306:          MOVE.B  #'W',(A5)+
00:0000A084 6008            	   307:          BRA.S   FORM10E4
                            	   308: 
00:0000A086 1AFC002E        	   309: FORM10E3:MOVE.B  #'.',(A5)+
00:0000A08A 1AFC004C        	   310:          MOVE.B  #'L',(A5)+
                            	   311: 
00:0000A08E 61D0            	   312: FORM10E4:BSR.S   EEA10
                            	   313: 
00:0000A090 1CC5            	   314:          MOVE.B  D5,(A6)+     ; STORE COMMA SEPARATOR
                            	   315: 
00:0000A092 3814            	   316:          MOVE.W  (A4),D4
00:0000A094 EF5C            	   317:          ROL.W   #7,D4
00:0000A096 6192            	   318:          BSR.S   FORMREGA       ; <EA>,A@
00:0000A098 6038            	   319:          BRA.S   CS12           ; COMMON
                            	   320: 
00:0000A09A 08140000        	   321: FORM10E6:BTST.B  #0,(A4)
00:0000A09E 661C            	   322:          BNE.S   FORM105        ; .......1........    D@,<EA>
00:0000A0A0 600A            	   323:          BRA.S   FORM104        ; .......0........    <EA>,D@
                            	   324: 
                            	   325: ;  BIT   5432109876543210
                            	   326: ;        ..........AAAAAA       EFFECTIVE ADDRESS
                            	   327: ;        .......MMM......       OP-MODE
                            	   328: ;        ....RRR.........       D-REGISTER
                            	   329: ;        .......0........       EA,D@
                            	   330: ;        .......1........       D@,EA
                            	   331: ;        ........00......       BYTE
                            	   332: ;        ........01......       WORD
                            	   333: ;        ........10......       LONG
                            	   334: 
                            	   335:          
                            	   336: 
                            	   337: FORM10:  ;.align  2              ; AND  EOR  OR
00:0000A0A2 08140000        	   338:          BTST.B  #0,(A4)
00:0000A0A6 6614            	   339:          BNE.S   FORM105
                            	   340: 
00:0000A0A8 3E3C0FFD        	   341: FORM103: MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:0000A0AC 610002FA        	   342: FORM104: BSR     FORMSIZE
00:0000A0B0 61AE            	   343:          BSR.S   EEA10          ; <EA>,D@
                            	   344: 
00:0000A0B2 1CC5            	   345:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   346: 
00:0000A0B4 1814            	   347:          MOVE.B  (A4),D4
00:0000A0B6 E20C            	   348:          LSR.B   #1,D4
00:0000A0B8 6180            	   349:          BSR     FORMREGD
00:0000A0BA 6016            	   350:          BRA.S   CS12           ; COMMON
                            	   351: 
00:0000A0BC 610002EA        	   352: FORM105: BSR     FORMSIZE       ; D@,<EA>
00:0000A0C0 1814            	   353:          MOVE.B  (A4),D4
00:0000A0C2 E20C            	   354:          LSR.B   #1,D4
00:0000A0C4 6100FF74        	   355:          BSR     FORMREGD
                            	   356: 
00:0000A0C8 1CC5            	   357:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   358: 
00:0000A0CA 3814            	   359:          MOVE.W  (A4),D4
00:0000A0CC 3E3C01FD        	   360:          MOVE.W  #$1FD,D7     ; ALTERABLE MEMORY ADDRESSING
00:0000A0D0 618E            	   361:          BSR.S   EEA10
00:0000A0D2 6000064A        	   362: CS12:    BRA     COMMON
                            	   363: 
                            	   364:          
                            	   365: 
                            	   366: ;                               PEA     (JMP  JSR)
00:0000A0D6 3E3C07E4        	   367: FORM11:  MOVE.W  #$7E4,D7     ; CONTROL ADDERSSING
00:0000A0DA 6184            	   368:          BSR     EEA10
00:0000A0DC 60F4            	   369:          BRA.S   CS12           ; COMMON
                            	   370: 
                            	   371:          
                            	   372: 
                            	   373: ;                               ; JMP  JSR
00:0000A0DE 2004            	   374: FORM11SL:MOVE.L  D4,D0        ; LOOK FOR .S  OR  .L
00:0000A0E0 0240003F        	   375:          ANDI.W  #$3F,D0
00:0000A0E4 0C400038        	   376:          CMPI.W  #$38,D0
00:0000A0E8 6608            	   377:          BNE.S   FORM112        ; NOT .S
00:0000A0EA 1AFC002E        	   378:          MOVE.B  #'.',(A5)+    ; PERIOD
00:0000A0EE 1AFC0053        	   379:          MOVE.B  #'S',(A5)+    ; S
00:0000A0F2 0C400039        	   380: FORM112: CMPI.W  #$39,D0
00:0000A0F6 6608            	   381:          BNE.S   FORM114
00:0000A0F8 1AFC002E        	   382:          MOVE.B  #'.',(A5)+    ; PERIOD
00:0000A0FC 1AFC004C        	   383:          MOVE.B  #'L',(A5)+    ; L
00:0000A100 60D4            	   384: FORM114: BRA.S   FORM11
                            	   385: 
                            	   386: ;  BIT   5432109876543210
                            	   387: ;        ....XXX.....0...       DATA DESTINATION REGISTER
                            	   388: ;        ....XXX.....1...       ADDRESS REGISTER
                            	   389: ;        ....XXX.00......       BYTE
                            	   390: ;        ........01......       WORD
                            	   391: ;        ........10......       LONG
                            	   392: ;        ............0...       DATA REGISTER TO DATA REGISTER
                            	   393: ;        ............1...       MEMORY TO MEMORY
                            	   394: ;        ............0xXX       DATA SOURCE REGISTER
                            	   395: ;        ............1XXX       ADDRESS SOURCE REGISTER
                            	   396: ;
                            	   397:          
                            	   398: 
                            	   399: FORM12:  ;.align  2              ; ABCD  ADDX  SBCD  SUBX
00:0000A102 610002A4        	   400:          BSR     FORMSIZE
                            	   401: 
00:0000A106 08040003        	   402:          BTST    #3,D4
00:0000A10A 6610            	   403:          BNE.S   FORM125
                            	   404: 
00:0000A10C 6100FF2C        	   405:          BSR     FORMREGD       ; D@,D@;   FORMAT SOURCE
                            	   406: 
00:0000A110 1CC5            	   407:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   408: 
00:0000A112 1814            	   409:          MOVE.B  (A4),D4
00:0000A114 E20C            	   410:          LSR.B   #1,D4
00:0000A116 6100FF22        	   411:          BSR     FORMREGD       ; FORMAT DESTINATION
00:0000A11A 6046            	   412:          BRA.S   CS11           ; COMMON
                            	   413: 
00:0000A11C 1CFC002D        	   414: FORM125: MOVE.B  #'-',(A6)+    ; -
00:0000A120 1CFC0028        	   415:          MOVE.B  #'(',(A6)+    ; (
00:0000A124 6100FF04        	   416:          BSR     FORMREGA       ; A@    SOURCE
                            	   417: 
00:0000A128 203C282D2C29    	   418:          MOVE.L  #$282d2c29,D0 ; ),-(
00:0000A12E 6152            	   419:          BSR.S   SCHR           ; STORE CHARS
                            	   420: 
00:0000A130 1814            	   421:          MOVE.B  (A4),D4
00:0000A132 E20C            	   422:          LSR.B   #1,D4
00:0000A134 6100FEF4        	   423:          BSR     FORMREGA       ; A@   DESTINATION
00:0000A138 1CFC0029        	   424:          MOVE.B  #')',(A6)+
00:0000A13C 6024            	   425:          BRA.S   CS11           ; COMMON
                            	   426: 
                            	   427: ;  BIT   5432109876543210
                            	   428: ;        ....XXX.....1...       ADDRESS REGISTER    DESTINATION
                            	   429: ;        ....XXX.00......       BYTE
                            	   430: ;        ........01......       WORD
                            	   431: ;        ........10......       LONG
                            	   432: ;        ............1...       MEMORY TO MEMORY
                            	   433: ;        ............1XXX       ADDRESS SOURCE REGISTER
                            	   434: ;
                            	   435:          
                            	   436: 
                            	   437: FORM12A: ;.align  2              ; CMPM
00:0000A13E 61000268        	   438:          BSR     FORMSIZE
                            	   439: 
00:0000A142 1CFC0028        	   440:          MOVE.B  #'(',(A6)+    ; (
00:0000A146 6100FEE2        	   441:          BSR     FORMREGA       ; A@
                            	   442: 
00:0000A14A 203C282C2B29    	   443:          MOVE.L  #$282c2b29,D0  ; )+,(
00:0000A150 6130            	   444:          BSR.S   SCHR           ; STORE CHARS
                            	   445: 
00:0000A152 1814            	   446:          MOVE.B  (A4),D4
00:0000A154 E20C            	   447:          LSR.B   #1,D4
00:0000A156 6100FED2        	   448:          BSR     FORMREGA       ; A@
00:0000A15A 1CFC0029        	   449:          MOVE.B  #')',(A6)+
00:0000A15E 1CFC002B        	   450:          MOVE.B  #'+',(A6)+
00:0000A162 600005BA        	   451: CS11:    BRA     COMMON
                            	   452: 
                            	   453:          
                            	   454: 
00:0000A166 60000210        	   455: IQUICK:  BRA     IQUICKA        ; ADDQ  SUBQ
                            	   456: 
                            	   457: ;  BIT   5432109876543210
                            	   458: ;        0111...0........       FIXED
                            	   459: ;        ....RRR.........       DATA REGISTER
                            	   460: ;        ........DDDDDDDD       SIGN EXTENDED DATA
                            	   461: ;
                            	   462:          
                            	   463: 
                            	   464: IMOVEQ:  ;.align  2
00:0000A16A 1CFC0023        	   465:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	   466: 
00:0000A16E 3014            	   467:          MOVE.W  (A4),D0
00:0000A170 4880            	   468:          EXT.W   D0
00:0000A172 48C0            	   469:          EXT.L   D0
00:0000A174 6100FCAE        	   470:          BSR     HEX2DEC        ; DECIMAL
                            	   471: 
00:0000A178 1CC5            	   472:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   473: 
00:0000A17A EF5C            	   474:          ROL.W   #7,D4
00:0000A17C 6100FEBC        	   475:          BSR     FORMREGD
00:0000A180 60E0            	   476:          BRA.S   CS11           ; COMMON
                            	   477: 
00:0000A182 1CC0            	   478: SCHR:    MOVE.B  D0,(A6)+     ; OUTPUT STRING
00:0000A184 E088            	   479:          LSR.L   #8,D0
00:0000A186 66FA            	   480:          BNE.S   SCHR           ; MORE TO OUTPUT
00:0000A188 4E75            	   481:          RTS
                            	   482: 
                            	   483: ; MOVE FROM SR  (STATUS REGISTER)
                            	   484: ;
                            	   485:          
                            	   486: 
00:0000A18A 203C002C5253    	   487: IMVFSR:  MOVE.L  #$002c5253,D0 ; SR,
                            	   488: 
00:0000A190 61F0            	   489:          BSR.S   SCHR
00:0000A192 6100029E        	   490:          BSR     EEA            ; DATA ALTERABLE
00:0000A196 60CA            	   491:          BRA.S   CS11           ; COMMON
                            	   492: 
                            	   493: ; MOVE FROM USP (USER STACK POINTER)
                            	   494: ;
                            	   495:          
                            	   496: 
00:0000A198 203C2C505355    	   497: IMVFUSP: MOVE.L  #$2c505355,D0 ; USP,
00:0000A19E 61E2            	   498:          BSR.S   SCHR
00:0000A1A0 6100FE88        	   499:          BSR     FORMREGA
00:0000A1A4 60BC            	   500:          BRA.S   CS11           ; COMMON
                            	   501: 
                            	   502: ; MOVE TO SR (STATUS REGISTER)
                            	   503: ;
                            	   504:          
                            	   505: 
00:0000A1A6 3E3C0FFD        	   506: IMVTSR:  MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:0000A1AA 61000286        	   507:          BSR     EEA
00:0000A1AE 203C0052532C    	   508:          MOVE.L  #$0052532c,D0 ; ,SR
00:0000A1B4 61CC            	   509: IMVT44:  BSR.S   SCHR
00:0000A1B6 60AA            	   510:          BRA.S   CS11           ; COMMON
                            	   511: 
                            	   512: ; MOVE TO USP (USER STACK POINTER)
                            	   513: ;
                            	   514:          
                            	   515: 
00:0000A1B8 6100FE70        	   516: IMVTUSP: BSR     FORMREGA
00:0000A1BC 203C5053552C    	   517:          MOVE.L  #$5053552c,D0 ; ,USP
00:0000A1C2 60F0            	   518:          BRA.S   IMVT44
                            	   519: 
                            	   520: ;  MOVE TO CCR (CONDITION CODE REGISTER)
                            	   521: ;
                            	   522:          
                            	   523: 
00:0000A1C4 3E3C0FFD        	   524: IMVTCCR: MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:0000A1C8 61000268        	   525:          BSR     EEA
00:0000A1CC 203C5243432C    	   526:          MOVE.L  #$5243432c,D0 ; ,CCR
00:0000A1D2 60E0            	   527:          BRA.S   IMVT44
                            	   528: 
                            	   529: ;  BIT   5432109876543210
                            	   530: ;        0000...1..001...       FIXED
                            	   531: ;        ....XXX.........       DATA REGISTER
                            	   532: ;        ........0.......       MEMORY TO REGISTER
                            	   533: ;        ........1.......       REGISTER TO MEMORY
                            	   534: ;        .........0......       WORD
                            	   535: ;        .........1......       LONG
                            	   536: ;        .............XXX       ADDRESS REGISTER
                            	   537: ;
                            	   538:          
                            	   539: 
                            	   540: IMOVEP:  ;.align  2
00:0000A1D4 1AFC002E        	   541:          MOVE.B  #'.',(A5)+    ; D@,#(A@)
00:0000A1D8 303C4C57        	   542:          MOVE.W  #$4c57,D0    ; "LW"
00:0000A1DC 08040006        	   543:          BTST    #6,D4
00:0000A1E0 6702            	   544:          BEQ.S   IMOVEP11       ; USE "W"
00:0000A1E2 E048            	   545:          LSR.W   #8,D0         ; USE "L"
00:0000A1E4 1AC0            	   546: IMOVEP11:MOVE.B  D0,(A5)+     ; LENGTH
                            	   547: 
00:0000A1E6 1814            	   548:          MOVE.B  (A4),D4
00:0000A1E8 E20C            	   549:          LSR.B   #1,D4
                            	   550: 
00:0000A1EA 082C00070001    	   551:          BTST.B  #7,1(A4)
00:0000A1F0 670E            	   552:          BEQ.S   IMOVEP35
                            	   553: 
00:0000A1F2 6100FE46        	   554:          BSR     FORMREGD       ; D@,$HHHH(A@)
                            	   555: 
00:0000A1F6 1CC5            	   556:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   557: 
00:0000A1F8 3814            	   558:          MOVE.W  (A4),D4
00:0000A1FA 6112            	   559:          BSR.S   IMOVEP66
00:0000A1FC 6000051E        	   560: CS20:    BRA     COMMON4
                            	   561: 
00:0000A200 610C            	   562: IMOVEP35:BSR.S   IMOVEP66       ; $HHHH(A@),D@
                            	   563: 
00:0000A202 1CC5            	   564:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   565: 
00:0000A204 1814            	   566:          MOVE.B  (A4),D4
00:0000A206 E20C            	   567:          LSR.B   #1,D4
00:0000A208 6100FE30        	   568:          BSR     FORMREGD
00:0000A20C 60EE            	   569:          BRA.S   CS20           ; COMMON4
                            	   570: 
00:0000A20E 1CFC0024        	   571: IMOVEP66:MOVE.B  #'$',(A6)+    ; FORMAT DISPLACEMENT
00:0000A212 302C0002        	   572:          MOVE.W  2(A4),D0
00:0000A216 6100FC70        	   573:          BSR     PNT4HX
                            	   574: 
00:0000A21A 1CFC0028        	   575:          MOVE.B  #'(',(A6)+
                            	   576: 
00:0000A21E 3814            	   577:          MOVE.W  (A4),D4
00:0000A220 6100FE08        	   578:          BSR     FORMREGA
00:0000A224 1CFC0029        	   579:          MOVE.B  #')',(A6)+
00:0000A228 4E75            	   580:          RTS
                            	   581: 
                            	   582: SCOMMON:
00:0000A22A 600004F2        	   583: 	bra COMMON         ; NOP RESET RTE RTR RTS TRAPV
                            	   584:         
                            	   585: 
00:0000A22E 610000E4        	   586: ISCC:    BSR     ICCCC          ; GET REST OF OP-CODE
00:0000A232 610001FE        	   587:          BSR     EEA            ; DATA ALTERABLE
00:0000A236 60F2            	   588:          BRA.S   SCOMMON
                            	   589: 
                            	   590:          
                            	   591: 
                            	   592: IDBCC:   ;.align  2              ; DB--
00:0000A238 3814            	   593:          MOVE.W  (A4),D4
00:0000A23A 6100FDFE        	   594:          BSR     FORMREGD
                            	   595: 
00:0000A23E 1CC5            	   596:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
00:0000A240 1CFC0024        	   597:          MOVE.B  #'$',(A6)+    ; HEX FIELD TO FOLLOW
                            	   598: 
00:0000A244 610000CE        	   599:          BSR     ICCCC
00:0000A248 602C            	   600:          BRA.S   ICC55
                            	   601: 
                            	   602: ;  BIT   5432109876543210
                            	   603: ;        0110............       FIXED
                            	   604: ;        ....CCCC........       CONDITION
                            	   605: ;        ........DDDDDDD0       DISPLACEMENT
                            	   606: ;        ...............1       ERROR (ODD BOUNDRY DISPLACEMENT)
                            	   607: ;
                            	   608:          
                            	   609: 
                            	   610: ICC:     ;.align  2              ; B--
00:0000A24A 610000C8        	   611:          BSR     ICCCC
                            	   612: 
00:0000A24E 1CFC0024        	   613: IBSR:    MOVE.B  #'$',(A6)+    ; BSR.S BRA
                            	   614: 
00:0000A252 4A04            	   615:          TST.B   D4
00:0000A254 6720            	   616:          BEQ.S   ICC55          ; 16 BIT DISPLACEMENT
                            	   617: 
00:0000A256 1AFC002E        	   618:          MOVE.B  #'.',(A5)+
00:0000A25A 1AFC0053        	   619:          MOVE.B  #'S',(A5)+
00:0000A25E 4884            	   620:          EXT.W   D4            ; 8 BIT DISPLACEMENT
                            	   621: 
00:0000A260 48C4            	   622: ICC35:   EXT.L   D4            ; SIGN-EXTENDED DISPLACEMENT
00:0000A262 D8A9FFFC        	   623:          ADD.L   HISPC(A1),D4  ; + PROGRAM COUNTER
00:0000A266 5484            	   624:          ADDQ.L  #2,D4         ; + TWO
00:0000A268 2004            	   625:          MOVE.L  D4,D0
                            	   626: 
00:0000A26A E284            	   627:          ASR.L   #1,D4
00:0000A26C 650004D8        	   628:          BCS     FERROR         ; ODD BOUNDRY DISPLACEMENT
                            	   629: 
00:0000A270 6100FC1A        	   630:          BSR     PNT6HX
00:0000A274 60B4            	   631:          BRA.S   SCOMMON
                            	   632: 
00:0000A276 5483            	   633: ICC55:   ADDQ.L  #2,D3         ; SIZE
00:0000A278 382C0002        	   634:          MOVE.W  2(A4),D4
00:0000A27C 1AFC002E        	   635:          MOVE.B  #'.',(A5)+
00:0000A280 1AFC004C        	   636:          MOVE.B  #'L',(A5)+    ; .L FOR 16 BIT DISPLACEMENT
00:0000A284 60DA            	   637:          BRA.S   ICC35
                            	   638: 
                            	   639:          
                            	   640: ;                               ; BCHG  BCLR  BSET  BTST
                            	   641: ISETD:   ;.align  2              ; DYNAMIC BIT
00:0000A286 EF5C            	   642:          ROL.W   #7,D4
00:0000A288 6100FDB0        	   643:          BSR     FORMREGD       ; DATA REGISTER
                            	   644: 
00:0000A28C 1CC5            	   645: ISETD12: MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   646: 
00:0000A28E 3814            	   647:          MOVE.W  (A4),D4
00:0000A290 610001A0        	   648:          BSR     EEA            ; DATA ALTERABLE
00:0000A294 6094            	   649: CS18:    BRA.S   SCOMMON
                            	   650: 
                            	   651:          ;.align   4
                            	   652: 
                            	   653: ;                            BCHG  BCLR  BSET  BTST
                            	   654: ;  1ST WORD     .... .... ..XX XXXX    EA   DATA ALTERABLE ONLY
                            	   655: ;  2ND WORD     0000 0000 000Y YYYY    BIT NUMBER
                            	   656: ;
                            	   657: ISETS:   ;.align  2              ; STATIC BIT
00:0000A296 5483            	   658:          ADDQ.L  #2,D3         ; SIZE
00:0000A298 1CFC0023        	   659:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	   660: 
00:0000A29C 7000            	   661:          CLR.L   D0
00:0000A29E 302C0002        	   662:          MOVE.W  2(A4),D0     ; GET BIT POSITION FROM 2ND WORD
00:0000A2A2 2200            	   663:          MOVE.L  D0,D1
00:0000A2A4 EA89            	   664:          LSR.L   #5,D1
00:0000A2A6 6600049E        	   665:          BNE     FERROR
00:0000A2AA 6100FB78        	   666:          BSR     HEX2DEC        ; DECIMAL
                            	   667: 
00:0000A2AE 60DC            	   668:          BRA.S   ISETD12
                            	   669: 
                            	   670: ;   BIT  5432109876543210
                            	   671: ;        ....XXX.........       IMMEDIATE COUNT/REGISTER
                            	   672: ;        .......0........       RIGHT SHIFT
                            	   673: ;        .......1........       LEFT SHIFT
                            	   674: ;        ........00......       BYTE
                            	   675: ;        ........01......       WORD
                            	   676: ;        ........10......       LONG
                            	   677: ;        ....0...11......       WORD (MEMORY)
                            	   678: ;        ....0...11AAAAAA       EFFECTIVE ADDRESS
                            	   679: ;        ..........0.....       SHIFT IMMEDIATE COUNT
                            	   680: ;        ..........1.....       SHIFT COUNT (MODULO 64) IN DATA REGISTER
                            	   681: ;
                            	   682:          ;.align   4
                            	   683: 
                            	   684: ISHIFT:  ;.align   2             ; AS-  LS-  RO-  ROX-
00:0000A2B0 303C4C52        	   685:          MOVE.W  #$4c52,D0    ; "LR"
00:0000A2B4 08040008        	   686:          BTST    #8,D4         ; DIRECTION BIT
00:0000A2B8 6702            	   687:          BEQ.S   ISHIFT13       ; RIGHT
00:0000A2BA E048            	   688:          LSR.W   #8,D0         ; LEFT
00:0000A2BC 1AC0            	   689: ISHIFT13:MOVE.B  D0,(A5)+     ; DIRECTION; "L" OR "R"
                            	   690: 
00:0000A2BE 3014            	   691:          MOVE.W  (A4),D0
00:0000A2C0 024000C0        	   692:          ANDI.W  #$00C0,D0
00:0000A2C4 0C4000C0        	   693:          CMPI.W  #$00C0,D0
00:0000A2C8 6730            	   694:          BEQ.S   ISHIFTM1       ; MEMORY SHIFT
                            	   695: 
00:0000A2CA 610000DC        	   696:          BSR     FORMSIZE
                            	   697: 
00:0000A2CE EF5C            	   698:          ROL.W   #7,D4
00:0000A2D0 0804000C        	   699:          BTST    #12,D4        ; I/R BIT
00:0000A2D4 6616            	   700:          BNE.S   ISHIFT33       ; COUNT IN REGISTER
                            	   701: 
00:0000A2D6 02040007        	   702:          ANDI.B  #$07,D4      ; IMMEDIATE COUNT
00:0000A2DA 6604            	   703:          BNE.S   ISHIFT23
00:0000A2DC 00040008        	   704:          ORI.B   #$08,D4      ; CHANGE ZERO TO EIGHT
00:0000A2E0 00040030        	   705: ISHIFT23:ORI.B   #'0',D4
00:0000A2E4 1CFC0023        	   706:          MOVE.B  #'#',(A6)+
00:0000A2E8 1CC4            	   707:          MOVE.B  D4,(A6)+
00:0000A2EA 6004            	   708:          BRA.S   ISHIFT44
                            	   709: 
00:0000A2EC 6100FD4C        	   710: ISHIFT33:BSR     FORMREGD
                            	   711: 
00:0000A2F0 1CC5            	   712: ISHIFT44:MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   713: 
00:0000A2F2 3814            	   714:          MOVE.W  (A4),D4
00:0000A2F4 6100FD44        	   715:          BSR     FORMREGD
00:0000A2F8 609A            	   716: CS17:    BRA.S   CS18           ; COMMON
                            	   717: 
00:0000A2FA 1AFC002E        	   718: ISHIFTM1:MOVE.B  #'.',(A5)+    ; PERIOD
00:0000A2FE 1AFC0057        	   719:          MOVE.B  #'W',(A5)+    ; .WORD
                            	   720: 
00:0000A302 0804000B        	   721:          BTST    #11,D4
00:0000A306 6600043E        	   722:          BNE     FERROR         ; BIT 11 MUST BE ZERO
                            	   723: 
00:0000A30A 3E3C01FC        	   724:          MOVE.W  #$1FC,D7     ; MEMORY ALTERABLE ADDRESSING
00:0000A30E 61000122        	   725:          BSR     EEA
00:0000A312 60E4            	   726:          BRA.S   CS17           ; COMMON
                            	   727: 
00:0000A314 700F            	   728: ICCCC:   MOVEQ   #$0F,D0      ; APPEND CONDITION CODE
00:0000A316 C014            	   729:          AND.B   (A4),D0      ; D0 = CCC
00:0000A318 E388            	   730:          LSL.L   #1,D0         ; D0 = CCC;2
                            	   731: 
00:0000A31A 323B0010        	   732:          MOVE.W  BRTBL(PC,D0.W),D1 ; GET BRANCH MNEMONIC
00:0000A31E 1AC1            	   733:          MOVE.B  D1,(A5)+     ; (REVERSED) FROM THE TABLE
00:0000A320 E049            	   734:          LSR.W   #8,D1         ; AND ADD THE NONBLANK PORTION
00:0000A322 0C010020        	   735:          CMPI.B  #BLANK,D1     ; TO THE BUFFER.
00:0000A326 6702            	   736:          BEQ.S   ICCCC9
00:0000A328 1AC1            	   737:          MOVE.B  D1,(A5)+
00:0000A32A 4E75            	   738: ICCCC9:  RTS
                            	   739: 
00:0000A32C 2054            	   740: BRTBL:   dc.b  " T"           ; "T " BRA ACCEPTED
00:0000A32E 2046            	   741:          dc.b  " F"           ; "F "
00:0000A330 4948            	   742:          dc.b  "IH"           ; "HI"
00:0000A332 534C            	   743:          dc.b  "SL"           ; "LS"
00:0000A334 4343            	   744:          dc.b  "CC"           ; "CC"
00:0000A336 5343            	   745:          dc.b  "SC"           ; "CS"
00:0000A338 454E            	   746:          dc.b  "EN"           ; "NE"
00:0000A33A 5145            	   747:          dc.b  "QE"           ; "EQ"
00:0000A33C 4356            	   748:          dc.b  "CV"           ; "VC"
00:0000A33E 5356            	   749:          dc.b  "SV"           ; "VS"
00:0000A340 4C50            	   750:          dc.b  "LP"           ; "PL"
00:0000A342 494D            	   751:          dc.b  "IM"           ; "MI"
00:0000A344 4547            	   752:          dc.b  "EG"           ; "GE"
00:0000A346 544C            	   753:          dc.b  "TL"           ; "LT"
00:0000A348 5447            	   754:          dc.b  "TG"           ; "GT"
00:0000A34A 454C            	   755:          dc.b  "EL"           ; "LE"
                            	   756: 
                            	   757: ;   BIT  5432109876543210
                            	   758: ;        ....RRRMMM......    DESTINATION REGISTER MODE
                            	   759: ;        ..........MMMRRR    SOURCE MODE REGISTER
                            	   760: ;
                            	   761: ; IF BYTE SIZE; ADDRESS DIRECT NOT ALLOWED AS SOURCE
                            	   762: ;
                            	   763: 					even
                            	   764: IMOVEA1: ;.align  2
00:0000A34C 3E3C0FFF        	   765:          MOVE.W  #$FFF,D7     ; ALL MODES
00:0000A350 610000E0        	   766:          BSR     EEA
                            	   767: 
00:0000A354 1CC5            	   768:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   769: 
00:0000A356 3814            	   770:          MOVE.W  (A4),D4      ; ....RRRMMM......
00:0000A358 E24C            	   771:          LSR.W   #1,D4         ; .....RRRMMM.....
00:0000A35A EA0C            	   772:          LSR.B   #5,D4         ; .....RRR.....MMM
00:0000A35C E05C            	   773:          ROR.W   #8,D4         ; .....MMM.....RRR
00:0000A35E EB0C            	   774:          LSL.B   #5,D4         ; .....MMMRRR.....
00:0000A360 EA4C            	   775:          LSR.W   #5,D4         ; ..........MMMRRR
                            	   776: 
                            	   777: ; IF .BYTE DESTINATION A@ NOT ALLOWED
00:0000A362 3E3C01FF        	   778:          MOVE.W  #$1FF,D7     ; DATA ALTERABLE + A@
00:0000A366 1014            	   779:          MOVE.B  (A4),D0
00:0000A368 0C000001        	   780:          CMPI.B  #$01,D0
00:0000A36C 6604            	   781:          BNE.S   IMOVE19        ; NOT BYTE SIZE
                            	   782: 
00:0000A36E 3E3C01FD        	   783:          MOVE.W  #$1FD,D7     ; DATA ALTERABLE
                            	   784: IMOVE19:
                            	   785: 
00:0000A372 610000BE        	   786:          BSR     EEA
00:0000A376 602C            	   787:          BRA.S   CS19           ; COMMON
                            	   788: 
                            	   789: ;  IF BYTE; ADDRESS REGISTER DIRECT NOT ALLOWED
                            	   790: IQUICKA: ;.align  2              ; ADDQ  SUBQ
00:0000A378 612E            	   791:          BSR.S   FORMSIZE
                            	   792: 
00:0000A37A 1CFC0023        	   793:          MOVE.B  #'#',(A6)+
00:0000A37E EF5C            	   794:          ROL.W   #7,D4
00:0000A380 02040007        	   795:          ANDI.B  #7,D4
00:0000A384 6604            	   796:          BNE.S   IQUICK21
00:0000A386 00040008        	   797:          ORI.B   #8,D4         ; MAKE ZERO INTO EIGHT
00:0000A38A 00040030        	   798: IQUICK21:ORI.B   #'0',D4       ; MAKE ASCII
00:0000A38E 1CC4            	   799:          MOVE.B  D4,(A6)+
                            	   800: 
00:0000A390 1CC5            	   801:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   802: 
00:0000A392 3814            	   803:          MOVE.W  (A4),D4
                            	   804: 
00:0000A394 3014            	   805:          MOVE.W  (A4),D0
00:0000A396 024000C0        	   806:          ANDI.W  #$00C0,D0
00:0000A39A 6704            	   807:          BEQ.S   IQUICK31       ; DATA ALTERABLE
00:0000A39C 3E3C01FF        	   808:          MOVE.W  #$1FF,D7     ; ALTERABLE ADDRESSING
00:0000A3A0 61000090        	   809: IQUICK31:BSR     EEA
00:0000A3A4 60000378        	   810: CS19:    BRA     COMMON
                            	   811: 
                            	   812: ;  BIT   5432109876543210
                            	   813: ;        ........00......       BYTE
                            	   814: ;        ........01......       WORD
                            	   815: ;        ........10......       LONG
                            	   816: ;        ........11......       ERROR
                            	   817: ;
                            	   818: FORMSIZE: ;.align  2
00:0000A3A8 3414            	   819:          MOVE.W  (A4),D2
00:0000A3AA 1AFC002E        	   820:          MOVE.B  #'.',(A5)+    ; STORE PERIOD
00:0000A3AE EC4A            	   821:          LSR.W   #6,D2
00:0000A3B0 02420003        	   822:          ANDI.W  #$03,D2
00:0000A3B4 6606            	   823:          BNE.S   FORM91
00:0000A3B6 1AFC0042        	   824:          MOVE.B  #'B',(A5)+    ; STORE "B"
00:0000A3BA 6016            	   825:          BRA.S   FORM95
                            	   826: 
00:0000A3BC 103C0057        	   827: FORM91:  MOVE.B  #'W',D0
00:0000A3C0 0C020001        	   828:          CMPI.B  #1,D2
00:0000A3C4 670A            	   829:          BEQ.S   FORM93
00:0000A3C6 103C004C        	   830:          MOVE.B  #'L',D0
00:0000A3CA 0C020002        	   831:          CMPI.B  #2,D2
00:0000A3CE 665E            	   832:          BNE.S   FE10           ; FERROR
00:0000A3D0 1AC0            	   833: FORM93:  MOVE.B  D0,(A5)+     ; STORE "W" OR "L"
00:0000A3D2 4E75            	   834: FORM95:  RTS
                            	   835: 
00:0000A3D4 6100FC64        	   836: EA000:   BSR     FORMREGD
00:0000A3D8 08070000        	   837:          BTST    #0,D7
00:0000A3DC 6750            	   838:          BEQ.S   FE10           ; FERROR
00:0000A3DE 4E75            	   839:          RTS
                            	   840: 
00:0000A3E0 6100FC48        	   841: EA001:   BSR     FORMREGA
00:0000A3E4 08070001        	   842:          BTST    #1,D7
00:0000A3E8 6744            	   843:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:0000A3EA 4E75            	   844:          RTS
                            	   845: 
00:0000A3EC 1CFC0028        	   846: EA010:   MOVE.B  #'(',(A6)+
00:0000A3F0 6100FC38        	   847:          BSR     FORMREGA
00:0000A3F4 1CFC0029        	   848:          MOVE.B  #')',(A6)+
00:0000A3F8 08070002        	   849:          BTST    #2,D7
00:0000A3FC 6730            	   850:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:0000A3FE 4E75            	   851:          RTS
                            	   852: 
00:0000A400 1CFC0028        	   853: EA011:   MOVE.B  #'(',(A6)+
00:0000A404 6100FC24        	   854:          BSR     FORMREGA
00:0000A408 1CFC0029        	   855:          MOVE.B  #')',(A6)+
00:0000A40C 1CFC002B        	   856:          MOVE.B  #'+',(A6)+
00:0000A410 08070003        	   857:          BTST    #3,D7
00:0000A414 6718            	   858:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:0000A416 4E75            	   859: EA011RTS:RTS
                            	   860: 
00:0000A418 1CFC002D        	   861: EA100:   MOVE.B  #'-',(A6)+
00:0000A41C 1CFC0028        	   862:          MOVE.B  #'(',(A6)+
00:0000A420 6100FC08        	   863:          BSR     FORMREGA
00:0000A424 1CFC0029        	   864:          MOVE.B  #')',(A6)+
00:0000A428 08070004        	   865:          BTST    #4,D7
00:0000A42C 66E8            	   866:          BNE.S   EA011RTS
00:0000A42E 60000316        	   867: FE10:    BRA     FERROR         ; THIS MODE NOT ALLOWED
                            	   868: 
                            	   869: ;  ENTER       A4 = POINTER TO FIRST WORD
                            	   870: ;              D3 = OFFSET TO EXTENSION
                            	   871: ;              D4 = VALUE TO PROCESS
                            	   872: ;              D7 = MODES ALLOWED MASK
                            	   873: ;
                            	   874: EEA:     ;.align  2
00:0000A432 2004            	   875: 	move.l D4,D0
00:0000A434 E648            	   876: 	lsr.w #3,D0
00:0000A436 02400007        	   877: 	andi.w #$7,D0
00:0000A43A 6798            	   878: 	beq.s EA000
00:0000A43C 0C000001        	   879: 	cmpi.b #1,D0
00:0000A440 679E            	   880: 	beq.s EA001
00:0000A442 0C000002        	   881: 	cmpi.b #2,D0
00:0000A446 67A4            	   882: 	beq.s EA010
00:0000A448 0C000003        	   883: 	cmpi.b #3,D0
00:0000A44C 67B2            	   884: 	beq.s EA011
00:0000A44E 0C000004        	   885: 	cmpi.b #4,D0
00:0000A452 67C4            	   886: 	beq.s EA100
00:0000A454 0C000005        	   887: 	cmpi.b #5,D0
00:0000A458 6760            	   888: 	beq.s EA101
00:0000A45A 0C000007        	   889: 	cmpi.b #7,D0
00:0000A45E 6770            	   890: 	beq.s EA111
                            	   891: 
                            	   892: ;    EXTENSION WORD
                            	   893: ;   BIT  5432109876543210
                            	   894: ;        0...............    DATA REGISTER
                            	   895: ;        1...............    ADDRESS REGISTER
                            	   896: ;        .RRR............    REGISTER
                            	   897: ;        ....0...........    SIGN EXTENDED, LOW ORDER INTEGER IN INDEX REG
                            	   898: ;        ....1...........    LONG VALUE IN INDEX REGISTER
                            	   899: ;        .....000........
                            	   900: ;        ........DDDDDDDD    DISPLACEMENT INTEGER
                            	   901: ;
                            	   902: ; EA110            ADDRESS REGISTER INDIRECT WITH INDEX
                            	   903: 
00:0000A460 08070006        	   904:          BTST    #6,D7
00:0000A464 67C8            	   905:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
                            	   906: 
00:0000A466 32343000        	   907:          MOVE.W  (A4,D3.W),D1
00:0000A46A 02410700        	   908:          ANDI.W  #$0700,D1
00:0000A46E 66BE            	   909:          BNE.S   FE10           ; FERROR  BITS 10-8 MUST BE ZERO
                            	   910: 
00:0000A470 30343000        	   911:          MOVE.W  (A4,D3.W),D0  ; D0 = DISPLACEMENT
00:0000A474 4880            	   912:          EXT.W   D0
00:0000A476 48C0            	   913:          EXT.L   D0
00:0000A478 6100F9AA        	   914:          BSR     HEX2DEC        ; DECIMAL
00:0000A47C 1CFC0028        	   915:          MOVE.B  #'(',(A6)+    ; (
                            	   916: 
00:0000A480 6100FBA8        	   917:          BSR     FORMREGA       ; XX(A@
                            	   918: 
00:0000A484 1CFC002C        	   919:          MOVE.B  #',',(A6)+    ; XX(A@,
                            	   920: 
00:0000A488 18343000        	   921:          MOVE.B  (A4,D3.W),D4
00:0000A48C E804            	   922:          ASR.B   #4,D4
00:0000A48E 6A06            	   923:          BPL.S   EA1105
00:0000A490 6100FB98        	   924:          BSR     FORMREGA
00:0000A494 6004            	   925:          BRA.S   EA1107
                            	   926: 
00:0000A496 6100FBA2        	   927: EA1105:  BSR     FORMREGD
00:0000A49A 1CFC002E        	   928: EA1107:  MOVE.B  #'.',(A6)+    ; XX(A@,X@.
                            	   929: 
00:0000A49E 38343000        	   930:          MOVE.W  (A4,D3.W),D4 ; D4 = R@
00:0000A4A2 103C0057        	   931:          MOVE.B  #'W',D0       ; ..........W
00:0000A4A6 0804000B        	   932:          BTST    #11,D4
00:0000A4AA 6704            	   933:          BEQ.S   EA1109
00:0000A4AC 103C004C        	   934:          MOVE.B  #'L',D0       ; ..........L
00:0000A4B0 1CC0            	   935: EA1109:  MOVE.B  D0,(A6)+
00:0000A4B2 1CFC0029        	   936:          MOVE.B  #')',(A6)+    ; ...........)
00:0000A4B6 5483            	   937:          ADDQ.L  #2,D3
00:0000A4B8 4E75            	   938:          RTS
                            	   939: 
                            	   940: ; ADDRESS REGISTER INDIRECT WITH DISPLACEMENT
                            	   941: ;
                            	   942: EA101:
00:0000A4BA 08070005        	   943: 	btst #5,D7         	; 101000;   DIS(A@)
00:0000A4BE 6756            	   944: 	beq.s FE11          ; FERROR;  THIS MODE NOT ALLOWED
00:0000A4C0 30343000        	   945: 	move.w (A4,D3.W),D0
00:0000A4C4 48C0            	   946: 	ext.l D0
00:0000A4C6 6100F95C        	   947: 	bsr HEX2DEC        	; DECIMAL
00:0000A4CA 5483            	   948: 	addq.l #2,D3        ; SIZE
00:0000A4CC 6000FF1E        	   949: 	bra EA010
                            	   950: 
                            	   951: ;  111000        ABSOLUTE SHORT
                            	   952: ;  111001        ABSOLUTE LONG
                            	   953: ;  111010        PROGRAM COUNTER WITH DISPLACEMENT
                            	   954: ;  111011        PROGRAM COUNTER WITH INDEX
                            	   955: ;  111100        IMMEDIATE OR STATUS REG
                            	   956: ;
                            	   957: EA111:
00:0000A4D0 02440007        	   958: 	andi.w #7,D4
00:0000A4D4 6618            	   959: 	bne.s EA1112
00:0000A4D6 08070007        	   960: 	btst #7,D7
00:0000A4DA 673A            	   961: 	beq.s FE11           	; FERROR;  THIS MODE NOT ALLOWED
00:0000A4DC 30343000        	   962: 	move.w (A4,D3.W),D0 	; 111000;   ABSOLUTE SHORT
00:0000A4E0 48C0            	   963: 	ext.l D0
00:0000A4E2 1CFC0024        	   964: 	move.b #'$',(A6)+
00:0000A4E6 6100F9B0        	   965: 	bsr PNT8HX         		; SIGN EXTENDED VALUE
00:0000A4EA 5483            	   966: 	addq.l #2,D3         	; SIZE + 2
00:0000A4EC 4E75            	   967: 	rts
                            	   968: 
                            	   969: EA1112:
00:0000A4EE 0C040001        	   970: 	cmpi.b #1,D4
00:0000A4F2 6616            	   971: 	bne.s EA1113
00:0000A4F4 08070008        	   972: 	btst #8,D7
00:0000A4F8 671C            	   973: 	beq.s FE11          	; FERROR;  THIS MODE NOT ALLOWED
00:0000A4FA 1CFC0024        	   974: 	move.b #'$',(A6)+    	; HEX
00:0000A4FE 20343000        	   975: 	move.l (A4,D3.W),D0  	; 111001;     ABSOLUTE LONG
00:0000A502 6100F994        	   976: 	bsr PNT8HX
                            	   977: 	;-       MOVE.B  #'.',(A6)+    ; FORCE LONG FORMAT
                            	   978: 	;-       MOVE.B  #'L',(A6)+    ; IE   .L
00:0000A506 5883            	   979: 	addq.l #4,D3
00:0000A508 4E75            	   980: 	rts
                            	   981: 
                            	   982: EA1113:
00:0000A50A 0C040002        	   983: 	cmpi.b #2,D4
00:0000A50E 662C            	   984: 	bne.s EA1114
00:0000A510 08070009        	   985: 	btst #9,D7
00:0000A514 6604            	   986: 	bne.s EA1113A
                            	   987: FE11:
00:0000A516 6000022E        	   988: 	bra FERROR         	; THIS MODE NOT ALLOWED
                            	   989: 
                            	   990: EA1113A:
00:0000A51A 30343000        	   991: 	move.w (A4,D3.W),D0  ; 111010;  PC + DISPLACEMENT  DESTINATION(PC)
00:0000A51E 48C0            	   992: 	ext.l D0
00:0000A520 D0A9FFFC        	   993: 	add.l HISPC(A1),D0
00:0000A524 5480            	   994: 	addq.l #2,D0
00:0000A526 1CFC0024        	   995: 	move.b #'$',(A6)+    ; HEX "$"
00:0000A52A 6100F96C        	   996: 	bsr PNT8HX         ; DESTINATION
00:0000A52E 203C29435028    	   997: 	move.l #$29435028,D0  ; (PC)
00:0000A534 6100FC4C        	   998: 	bsr SCHR           ; STORE WORD
00:0000A538 5483            	   999: 	addq.l #2,D3         ; SIZE
00:0000A53A 4E75            	  1000: 	rts
                            	  1001: 
                            	  1002: EA1114:
00:0000A53C 0C040003        	  1003: 	cmpi.b #3,D4
00:0000A540 6664            	  1004: 	bne.s EA1115
                            	  1005: 
                            	  1006: ; PROGRAM COUNTER WITH INDEX    DESTINATION(PC,R@.X)
                            	  1007: ;
                            	  1008: ;        5432109876543210       SECOND WORD
                            	  1009: ;        0...............       DATA REGISTER
                            	  1010: ;        1...............       ADDRESS REGISTER
                            	  1011: ;        .XXX............       REGISTER
                            	  1012: ;        ....0...........       SIGN-EXTENDED, LOW ORDER WORD INTEGER
                            	  1013: ;                               ..IN INDEX REGISTER
                            	  1014: ;        ....1...........       LONG VALUE IN INDEX REGISTER
                            	  1015: ;        .....000........
                            	  1016: ;        ........XXXXXXXX       DISPLACEMENT INTEGER
                            	  1017: ;
00:0000A542 0807000A        	  1018:          BTST    #10,D7
00:0000A546 67CE            	  1019:          BEQ.S   FE11           ; FERROR  THIS MODE NOT ASLLOWED
                            	  1020: 
00:0000A548 32343000        	  1021:          MOVE.W  (A4,D3.W),D1
00:0000A54C 02410700        	  1022:          ANDI.W  #$0700,D1
00:0000A550 66C4            	  1023:          BNE.S   FE11           ; FERROR;  BITS 10-8 MUST BE ZERO
                            	  1024: 
00:0000A552 10343001        	  1025:          MOVE.B  1(A4,D3.W),D0 ; 111100;   DESTINATION(PC,R@.X)
00:0000A556 4880            	  1026:          EXT.W   D0
00:0000A558 48C0            	  1027:          EXT.L   D0
00:0000A55A D0A9FFFC        	  1028:          ADD.L   HISPC(A1),D0
00:0000A55E 5480            	  1029:          ADDQ.L  #2,D0
00:0000A560 1CFC0024        	  1030:          MOVE.B  #'$',(A6)+    ; HEX "$"
00:0000A564 6100F932        	  1031:          BSR     PNT8HX         ; DESTINATION
                            	  1032: 
00:0000A568 203C2C435028    	  1033:          MOVE.L  #$2c435028,D0
00:0000A56E 6100FC12        	  1034:          BSR     SCHR           ; DES(PC,
                            	  1035: 
00:0000A572 38343000        	  1036:          MOVE.W  (A4,D3.W),D4
00:0000A576 E95C            	  1037:          ROL.W   #4,D4
00:0000A578 08040003        	  1038:          BTST    #3,D4
00:0000A57C 6706            	  1039:          BEQ.S   EAF25
00:0000A57E 6100FAAA        	  1040:          BSR     FORMREGA
00:0000A582 6004            	  1041:          BRA.S   EAF27
00:0000A584 6100FAB4        	  1042: EAF25:   BSR     FORMREGD       ; DES(PC,R@
                            	  1043: EAF27:
                            	  1044: 
00:0000A588 1CFC002E        	  1045:          MOVE.B  #'.',(A6)+    ; DES(PC,R@.
                            	  1046: 
00:0000A58C 38343000        	  1047:          MOVE.W  (A4,D3.W),D4
00:0000A590 303C4C57        	  1048:          MOVE.W  #$4c57,D0    ; "LW"
00:0000A594 0804000B        	  1049:          BTST    #11,D4
00:0000A598 6702            	  1050:          BEQ.S   EAF35
00:0000A59A E048            	  1051:          LSR.W   #8,D0
00:0000A59C 1CC0            	  1052: EAF35:   MOVE.B  D0,(A6)+     ; DES(PC,R@.X
                            	  1053: 
00:0000A59E 1CFC0029        	  1054:          MOVE.B  #')',(A6)+    ; DES(PC,R@.X)
00:0000A5A2 5483            	  1055:          ADDQ.L  #2,D3
00:0000A5A4 4E75            	  1056:          RTS
                            	  1057: 
                            	  1058: ;   BIT  5432109876543210
                            	  1059: ;        ..........111100       ; FIRST WORD;  #<IMMEDIATE>
                            	  1060: ;
00:0000A5A6 0C040004        	  1061: EA1115:  CMPI.B  #4,D4
00:0000A5AA 6600FF6A        	  1062:          BNE     FE11           ; FERROR
                            	  1063: 
00:0000A5AE 0807000B        	  1064:          BTST    #11,D7
00:0000A5B2 6700FF62        	  1065:          BEQ     FE11           ; FERROR;  THIS MODE NOT ALLOWED
                            	  1066: 
00:0000A5B6 1CFC0023        	  1067:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	  1068: 
00:0000A5BA 122DFFFF        	  1069:          MOVE.B  -1(A5),D1
00:0000A5BE 0C01004C        	  1070:          CMPI.B  #'L',D1
00:0000A5C2 6724            	  1071:          BEQ.S   EA11155        ; LONG
                            	  1072: 
00:0000A5C4 30343000        	  1073:          MOVE.W  (A4,D3.W),D0
                            	  1074: 
00:0000A5C8 0C010042        	  1075:          CMPI.B  #'B',D1
00:0000A5CC 6610            	  1076:          BNE.S   EA11153        ; .WORD
                            	  1077: 
                            	  1078: ; BYTE SIZE; DATA ALLOWED
                            	  1079: ;  0000 0000 XXXX XXXX
                            	  1080: ;  1111 1111 1XXX XXXX
00:0000A5CE 2200            	  1081:          MOVE.L  D0,D1
00:0000A5D0 E049            	  1082:          LSR.W   #8,D1
00:0000A5D2 670A            	  1083:          BEQ.S   EA11153
00:0000A5D4 2200            	  1084:          MOVE.L  D0,D1
00:0000A5D6 EE41            	  1085:          ASR.W   #7,D1
00:0000A5D8 5241            	  1086:          ADDQ.W  #1,D1
00:0000A5DA 6600FF3A        	  1087:          BNE     FE11           ; FERROR
                            	  1088: 
00:0000A5DE 48C0            	  1089: EA11153: EXT.L   D0
00:0000A5E0 6100F842        	  1090:          BSR     HEX2DEC
00:0000A5E4 5483            	  1091:          ADDQ.L  #2,D3
00:0000A5E6 4E75            	  1092:          RTS
                            	  1093: 
00:0000A5E8 20343000        	  1094: EA11155: MOVE.L  (A4,D3.W),D0
00:0000A5EC 6100F836        	  1095:          BSR     HEX2DEC
00:0000A5F0 5883            	  1096:          ADDQ.L  #4,D3         ; SIZE
00:0000A5F2 4E75            	  1097:          RTS
                            	  1098: 
00:0000A5F4 1AFC002E        	  1099: MOVEMS:  MOVE.B  #'.',(A5)+    ; PERIOD
00:0000A5F8 303C4C57        	  1100:          MOVE.W  #$4c57,D0    ; "LW"
00:0000A5FC 08040006        	  1101:          BTST    #6,D4
00:0000A600 6702            	  1102:          BEQ.S   MOVEMS2
00:0000A602 E048            	  1103:          LSR.W   #8,D0
00:0000A604 1AC0            	  1104: MOVEMS2: MOVE.B  D0,(A5)+     ; SIZE
00:0000A606 4E75            	  1105:          RTS
                            	  1106: 
                            	  1107: ; MOVEM - REGISTER EXPANSION
                            	  1108: ;
                            	  1109: MOVEMR:  ;.align  2
00:0000A608 342C0002        	  1110:          MOVE.W  2(A4),D2     ; D2 = SECOND WORD
00:0000A60C 7020            	  1111:          MOVEQ   #$20,D0      ; D0 = SPACE
00:0000A60E 7E2F            	  1112:          MOVEQ   #$2F,D7      ; D7 = /
00:0000A610 538E            	  1113:          SUBQ.L  #1,A6         ; ADJUST STORE POINTER
00:0000A612 7A30            	  1114:          MOVEQ   #$30,D5      ; D5 = REGISTER #
00:0000A614 383C4144        	  1115:          MOVE.W  #$4144,D4    ; "AD" D4 = REG CLASS
                            	  1116: 
00:0000A618 0302            	  1117: MOVEMR11:BTST    D1,D2
00:0000A61A 6730            	  1118:          BEQ.S   MOVEMR77       ; BIT RESET
                            	  1119: 
00:0000A61C B016            	  1120:          CMP.B   (A6),D0      ; BIT SET
00:0000A61E 6612            	  1121:          BNE.S   MOVEMR44       ; NOT SPACE
                            	  1122: 
00:0000A620 1D440001        	  1123: MOVEMR33:MOVE.B  D4,1(A6)     ; REG TYPE
00:0000A624 1D450002        	  1124:          MOVE.B  D5,2(A6)     ; REG #
00:0000A628 1D7C002D0003    	  1125:          MOVE.B  #'-',3(A6)    ; -
00:0000A62E 568E            	  1126:          ADDQ.L  #3,A6
00:0000A630 602E            	  1127:          BRA.S   MOVEMR88
                            	  1128: 
                            	  1129: MOVEMR44:
00:0000A632 0C16002C        	  1130: 	cmpi.b #',',(A6)
00:0000A636 67E8            	  1131: 	beq.s MOVEMR33      ; COMMA SEPARATOR
00:0000A638 BE16            	  1132: 	cmp.b (A6),D7      	; / SEPARATOR
00:0000A63A 67E4            	  1133: 	beq.s MOVEMR33
00:0000A63C 1D440001        	  1134: 	move.b D4,1(A6)     ; REG TYPE
00:0000A640 1D450002        	  1135: 	move.b D5,2(A6)     ; REG #
00:0000A644 1D7C002D0003    	  1136: 	move.b #'-',3(A6)   ; - SEPARATOR
00:0000A64A 6014            	  1137: 	bra.s MOVEMR88
                            	  1138: 
                            	  1139: MOVEMR77:
00:0000A64C 0C16002C        	  1140: 	cmpi.b #',',(A6)
00:0000A650 670E            	  1141: 	beq.s MOVEMR88       ; COMMA
00:0000A652 B016            	  1142: 	cmp.b (A6),D0
00:0000A654 670A            	  1143: 	beq.s MOVEMR88       ; SPACE
00:0000A656 B02E0001        	  1144: 	cmp.b 1(A6),D0
00:0000A65A 6702            	  1145: 	beq.s MOVEMR79       ; SPACE
00:0000A65C 568E            	  1146: 	addq.l #3,A6
                            	  1147: MOVEMR79:
00:0000A65E 1C87            	  1148: 	move.b D7,(A6)      ; / SEPARATOR
                            	  1149: 
                            	  1150: MOVEMR88:
00:0000A660 5285            	  1151: 	addq.l #1,D5
00:0000A662 D286            	  1152: 	add.l D6,D1        ; D1 = BIT POSITION
00:0000A664 0C050038        	  1153: 	cmpi.b #'8',D5
00:0000A668 66AE            	  1154: 	bne.s MOVEMR11
00:0000A66A B016            	  1155: 	cmp.b (A6),D0      ; SPACE
00:0000A66C 670A            	  1156: 	beq.s MOVEMR94
00:0000A66E B02E0001        	  1157: 	cmp.b 1(A6),D0     ; SPACE
00:0000A672 6704            	  1158: 	beq.s MOVEMR94
00:0000A674 568E            	  1159: 	addq.l #3,A6
00:0000A676 1C87            	  1160: 	move.b D7,(A6)      ; /   SEPARATOR
                            	  1161: 
                            	  1162: MOVEMR94:
00:0000A678 1A3C0030        	  1163: 	move.b #'0',D5       	; RESET REG TO ZERO
00:0000A67C E04C            	  1164: 	lsr.w #8,D4         	; CHANGE REG TYPE
00:0000A67E 6698            	  1165: 	bne.s MOVEMR11       	; MORE
00:0000A680 1C80            	  1166: 	move.b D0,(A6)      	; SPACE
00:0000A682 4E75            	  1167: 	rts
                            	  1168: 
                            	  1169: DCODE68K:
00:0000A684 4E51FFF0        	  1170: 	link A1,#-LOCVARSZ 	; CREATE A FRAME FOR THE
00:0000A688 48E91007FFF0    	  1171: 	movem.l D0-D2/A4,DDATA(A1)  ; CODE AND ITS PC.  A4
00:0000A68E 49E9FFF0        	  1172: 	lea DDATA(A1),A4 		; POINTS TO THE CODE.
00:0000A692 264D            	  1173: 	move.l A5,A3        ; A3 = START OF OUTPUT BUFFER
00:0000A694 2C4D            	  1174: 	move.l A5,A6
00:0000A696 703F            	  1175: 	moveq #BUFSIZE,D0
                            	  1176: DEC311:
00:0000A698 1CFC0020        	  1177:   move.b #BLANK,(a6)+  ; SPACE FILL BUFFER
00:0000A69C 5380            	  1178: 	subq.l #1,D0
00:0000A69E 66F8            	  1179: 	bne.s DEC311
00:0000A6A0 421E            	  1180: 	clr.b (a6)+					; NULL temrinate
00:0000A6A2 2C4B            	  1181: 	move.l A3,A6        ; FORMAT ADDRESS
00:0000A6A4 2029FFFC        	  1182: 	move.l HISPC(A1),D0
00:0000A6A8 6100F7F2        	  1183: 	bsr FRELADDR
                            	  1184: 
                            	  1185: ; CHECK FOR KNOWN ILLEGAL CODES
00:0000A6AC 3014            	  1186: 	move.w (a4),d0
00:0000A6AE 4BFA00C0        	  1187: 	lea KI(PC),a5
00:0000A6B2 2C4D            	  1188: 	move.l a5,a6
00:0000A6B4 548E            	  1189: 	add.l #KIEND-KI,a6
                            	  1190: DEC404:
00:0000A6B6 B05D            	  1191:   cmp.w (a5)+,d0
00:0000A6B8 671A            	  1192: 	beq.s FE12           ; FERROR;  ILLEGAL CODE
00:0000A6BA BBCE            	  1193: 	cmp.l a6,a5
00:0000A6BC 66F8            	  1194: 	bne.s DEC404
                            	  1195: 
                            	  1196: ; LOOK FOR MATCH OF OP-CODE
                            	  1197: ;
00:0000A6BE 4BFA00B2        	  1198: 	lea TBL(PC),A5   		; A5 = POINTER TO DECODE TABLE
00:0000A6C2 4DFA0366        	  1199: 	lea TBLE(PC),A6  		; A6 = POINTER TO END OF TABLE
                            	  1200: DEC411:
00:0000A6C6 3014            	  1201: 	move.w (A4),D0      ;  FIRST WORD
00:0000A6C8 C05D            	  1202: 	and.w (A5)+,D0     	;  MASK
00:0000A6CA B05D            	  1203: 	cmp.w (A5)+,D0
00:0000A6CC 6708            	  1204: 	beq.s DEC425        ; FOUND MATCH
00:0000A6CE 588D            	  1205: 	addq.l #4,A5        ; UPDATE POINTER
00:0000A6D0 BBCE            	  1206: 	cmp.l A6,A5
00:0000A6D2 65F2            	  1207: 	blo.s DEC411        ; MORE TABLE
                            	  1208: FE12:
00:0000A6D4 6070            	  1209: 	bra.s FERROR        ; ILLEGAL INSTRUCTION
                            	  1210: DEC425:
00:0000A6D6 7C00            	  1211:   clr.l D6
00:0000A6D8 3C1D            	  1212: 	move.w (A5)+,D6     ; D6 = (GOTO OFFSET)/4
                            	  1213: ;         LSL.L   #2,D6
00:0000A6DA 7E00            	  1214: 	clr.l D7
00:0000A6DC 3E1D            	  1215: 	move.w (A5)+,D7     ; D7 = INDEX TO OP-CODE
                            	  1216: 
                            	  1217: ; MOVE OP-CODE TO BUFFER
                            	  1218: ;
00:0000A6DE 41FA034A        	  1219: 	lea OPCTBL(PC),A0
                            	  1220: DEC510:
00:0000A6E2 4A47            	  1221:   tst D7
00:0000A6E4 6708            	  1222: 	beq.s DEC530         	; AT INDEX
                            	  1223: DEC515:
00:0000A6E6 4A18            	  1224:   tst.b (A0)+
00:0000A6E8 6AFC            	  1225: 	bpl.s DEC515         	; MOVE THROUGH FIELD
00:0000A6EA 5387            	  1226: 	subq.l #1,D7
00:0000A6EC 60F4            	  1227: 	bra.s DEC510
                            	  1228: DEC530:
00:0000A6EE 701F            	  1229: 	moveq #FOC,D0
00:0000A6F0 4BF30000        	  1230: 	lea.l (A3,D0.W),A5 		; A5 = STORE POINTER  OP-CODE
                            	  1231: DEC535:
00:0000A6F4 1018            	  1232:   move.b (A0)+,D0
00:0000A6F6 08800007        	  1233: 	bclr #7,D0
00:0000A6FA 6604            	  1234: 	bne.s DEC537         	; END OF MOVE
00:0000A6FC 1AC0            	  1235: 	move.b D0,(A5)+
00:0000A6FE 60F4            	  1236: 	bra.s DEC535
                            	  1237: DEC537:
00:0000A700 1AC0            	  1238:   move.b D0,(A5)+
                            	  1239: 
                            	  1240: ; CALCULATE GOTO AND GO
                            	  1241: ;
00:0000A702 7602            	  1242: 	moveq #2,D3         ; D3= SIZE
00:0000A704 41FAF7F4        	  1243: 	lea X(PC),A0
00:0000A708 D1C6            	  1244: 	add.l D6,A0
00:0000A70A 7027            	  1245: 	moveq #FOP,D0
00:0000A70C 4DF30000        	  1246: 	lea.l (A3,D0.W),A6 	; A6 = POINTER FOR OPERAND
00:0000A710 3814            	  1247: 	move.w (A4),D4      ; D4 = FIRST WORD
00:0000A712 1A3C002C        	  1248: 	move.b #',',D5      ; D5 = CONTAINS ASCII COMMA
00:0000A716 3E3C01FD        	  1249: 	move.w #$1FD,D7     ; D7 = DATA ALTERABLE MODES ALLOWED
00:0000A71A 4ED0            	  1250: 	jmp (A0)
                            	  1251: 
                            	  1252: ;	 A3 = pointer to beginning of buffer
                            	  1253: ;  A4 = POINTER TO DATA IN FRAME CREATED BY "LINK A1,..."
                            	  1254: ;  A5 = POINTER STORE OP-CODE
                            	  1255: ;  A6 = POINTER STORE OPERAND
                            	  1256: ;  D3 = SIZE = 2 BYTES
                            	  1257: ;  D4 = FIRST WORD
                            	  1258: ;  D7 = ADDRESS MODES ALLOWED ($1FD) DATA ALTERABLE
                            	  1259: 
                            	  1260: COMMON4:
00:0000A71C 5483            	  1261: 	addq.l #2,D3         	; SIZE = 4
                            	  1262: COMMON:
00:0000A71E 2C03            	  1263: 	move.l D3,D6        	; D6 = SIZE
00:0000A720 1CFC0020        	  1264: 	move.b #BLANK,(A6)+ 	; SPACE AS LAST CHAR
00:0000A724 2A4E            	  1265: 	move.l A6,A5        	; SAVE END OF BUFFER POINTER
00:0000A726 700A            	  1266: 	moveq #FDATA,D0
00:0000A728 4DF30000        	  1267: 	lea.l (A3,D0.W),A6
                            	  1268: COMMON35:
00:0000A72C 301C            	  1269: 	move.w (A4)+,D0     	; GET NEXT WORD OF DATA.
00:0000A72E 54A9FFFC        	  1270: 	addq.l #2,HISPC(A1)  	; ADJUST PROG COUNTER.
00:0000A732 6100F754        	  1271: 	bsr PNT4HX         		; FORMAT DATA. (A6)+
00:0000A736 5503            	  1272: 	subq.b #2,D3
00:0000A738 66F2            	  1273: 	bne.s COMMON35
00:0000A73A 2C4D            	  1274: 	move.l A5,A6        	; A6 = RESTORE END POINTER
00:0000A73C 2A4B            	  1275: 	move.l A3,A5        	; A5 =  BEGINNING OF BUFFER
00:0000A73E 2869FFFC        	  1276: 	move.l HISPC(A1),A4 	; MOVE THE UPDATED PC
00:0000A742 4E59            	  1277: 	unlk A1            		; TO A4 AND UNDO FRAME.
00:0000A744 4E75            	  1278: 	rts
                            	  1279: 
                            	  1280: FERROR:  ;.align  2
                            	  1281: ; ILLEGAL INSTRUCTION
                            	  1282: ;
00:0000A746 701F            	  1283: 	moveq #FOC,D0
00:0000A748 4DF30000        	  1284: 	lea.l (A3,D0.W),A6
00:0000A74C 4BFA0018        	  1285: 	lea MSG111(PC),A5
                            	  1286: FERROR35:
00:0000A750 101D            	  1287: 	move.b (A5)+,D0
00:0000A752 0C000004        	  1288: 	cmpi.b #EOT,D0
00:0000A756 6704            	  1289: 	beq.s FERROR39
00:0000A758 1CC0            	  1290: 	move.b D0,(A6)+
00:0000A75A 60F4            	  1291: 	bra.s FERROR35
                            	  1292: FERROR39:
00:0000A75C 3014            	  1293: 	move.w (A4),D0
00:0000A75E 6100F728        	  1294: 	bsr PNT4HX
00:0000A762 7602            	  1295: 	moveq #2,D3         ; SIZE
00:0000A764 60B8            	  1296: 	bra.s COMMON
                            	  1297: MSG111:  
00:0000A766 44432E5720202020	  1298: 	dc.b "DC.W    $"
00:0000A76E 24
00:0000A76F 04              	  1299: 	dc.b EOT
                            	  1300: 
                            	  1301: KI:
00:0000A770 4AFB            	  1302: 	dc.w $4AFB         ; KNOWN ILLEGAL CODES
                            	  1303: KIEND:   
                            	  1304: 	even
                            	  1305: 
                            	  1306: ;  \1   MASK
                            	  1307: ;  \2   OP-CODE PATTERN
                            	  1308: ;  \3   GOTO OFFSET
                            	  1309: ;  \4   INDEX TO OP-CODE
                            	  1310: C68:     macro arg1,arg2,arg3,arg4
                            	  1311:          DC.W    $\1
                            	  1312:          DC.W    $\2
                            	  1313:          DC.W    (\3-X)
                            	  1314:          DC.w    \4
                            	  1315:          endm
                            	  1316: 
                            	  1317: 				 even
                            	  1318: TBL:     ;.align  2
                            	  1319:          C68     FEC0,E6C0,ISHIFT,56           ; RO
00:0000A772 FEC0            	     1M          DC.W    $FEC0
00:0000A774 E6C0            	     2M          DC.W    $E6C0
00:0000A776 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A778 0038            	     4M          DC.w    56
                            	  1320:          C68     FEC0,E4C0,ISHIFT,57           ; ROX
00:0000A77A FEC0            	     1M          DC.W    $FEC0
00:0000A77C E4C0            	     2M          DC.W    $E4C0
00:0000A77E 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A780 0039            	     4M          DC.w    57
                            	  1321:          C68     FEC0,E2C0,ISHIFT,55           ; LS
00:0000A782 FEC0            	     1M          DC.W    $FEC0
00:0000A784 E2C0            	     2M          DC.W    $E2C0
00:0000A786 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A788 0037            	     4M          DC.w    55
                            	  1322:          C68     FEC0,E0C0,ISHIFT,54           ; AS
00:0000A78A FEC0            	     1M          DC.W    $FEC0
00:0000A78C E0C0            	     2M          DC.W    $E0C0
00:0000A78E 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A790 0036            	     4M          DC.w    54
                            	  1323:          C68     F018,E018,ISHIFT,56           ; RO
00:0000A792 F018            	     1M          DC.W    $F018
00:0000A794 E018            	     2M          DC.W    $E018
00:0000A796 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A798 0038            	     4M          DC.w    56
                            	  1324:          C68     F018,E010,ISHIFT,57           ; ROX
00:0000A79A F018            	     1M          DC.W    $F018
00:0000A79C E010            	     2M          DC.W    $E010
00:0000A79E 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A7A0 0039            	     4M          DC.w    57
                            	  1325:          C68     F018,E008,ISHIFT,55           ; LS
00:0000A7A2 F018            	     1M          DC.W    $F018
00:0000A7A4 E008            	     2M          DC.W    $E008
00:0000A7A6 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A7A8 0037            	     4M          DC.w    55
                            	  1326:          C68     F018,E000,ISHIFT,54           ; AS
00:0000A7AA F018            	     1M          DC.W    $F018
00:0000A7AC E000            	     2M          DC.W    $E000
00:0000A7AE 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A7B0 0036            	     4M          DC.w    54
                            	  1327:          C68     F0C0,D0C0,FORM10EX,4          ; ADD       <EA>,A@
00:0000A7B2 F0C0            	     1M          DC.W    $F0C0
00:0000A7B4 D0C0            	     2M          DC.W    $D0C0
00:0000A7B6 016A            	     3M          DC.W    (FORM10EX-X)
00:0000A7B8 0004            	     4M          DC.w    4
                            	  1328:          C68     F130,D100,FORM12,53           ; ADDX
00:0000A7BA F130            	     1M          DC.W    $F130
00:0000A7BC D100            	     2M          DC.W    $D100
00:0000A7BE 0208            	     3M          DC.W    (FORM12-X)
00:0000A7C0 0035            	     4M          DC.w    53
                            	  1329:          C68     F000,D000,FORM10EX,4          ; ADD
00:0000A7C2 F000            	     1M          DC.W    $F000
00:0000A7C4 D000            	     2M          DC.W    $D000
00:0000A7C6 016A            	     3M          DC.W    (FORM10EX-X)
00:0000A7C8 0004            	     4M          DC.w    4
                            	  1330:          C68     F1F8,C188,FORM9,50            ; EXG
00:0000A7CA F1F8            	     1M          DC.W    $F1F8
00:0000A7CC C188            	     2M          DC.W    $C188
00:0000A7CE 0160            	     3M          DC.W    (FORM9-X)
00:0000A7D0 0032            	     4M          DC.w    50
                            	  1331:          C68     F1F8,C148,FORM8,50            ; EXG
00:0000A7D2 F1F8            	     1M          DC.W    $F1F8
00:0000A7D4 C148            	     2M          DC.W    $C148
00:0000A7D6 0152            	     3M          DC.W    (FORM8-X)
00:0000A7D8 0032            	     4M          DC.w    50
                            	  1332:          C68     F1F8,C140,FORM7,50            ; EXG
00:0000A7DA F1F8            	     1M          DC.W    $F1F8
00:0000A7DC C140            	     2M          DC.W    $C140
00:0000A7DE 0146            	     3M          DC.W    (FORM7-X)
00:0000A7E0 0032            	     4M          DC.w    50
                            	  1333:          C68     F1F0,C100,FORM12,49           ; ABCD
00:0000A7E2 F1F0            	     1M          DC.W    $F1F0
00:0000A7E4 C100            	     2M          DC.W    $C100
00:0000A7E6 0208            	     3M          DC.W    (FORM12-X)
00:0000A7E8 0031            	     4M          DC.w    49
                            	  1334:          C68     F1C0,C1C0,FORM6D,48           ; MULS
00:0000A7EA F1C0            	     1M          DC.W    $F1C0
00:0000A7EC C1C0            	     2M          DC.W    $C1C0
00:0000A7EE 0120            	     3M          DC.W    (FORM6D-X)
00:0000A7F0 0030            	     4M          DC.w    48
                            	  1335:          C68     F1C0,C0C0,FORM6D,47           ; MULU
00:0000A7F2 F1C0            	     1M          DC.W    $F1C0
00:0000A7F4 C0C0            	     2M          DC.W    $C0C0
00:0000A7F6 0120            	     3M          DC.W    (FORM6D-X)
00:0000A7F8 002F            	     4M          DC.w    47
                            	  1336:          C68     F000,C000,FORM10,2            ; AND
00:0000A7FA F000            	     1M          DC.W    $F000
00:0000A7FC C000            	     2M          DC.W    $C000
00:0000A7FE 01A8            	     3M          DC.W    (FORM10-X)
00:0000A800 0002            	     4M          DC.w    2
                            	  1337:          C68     F0C0,B0C0,FORM10EX,6          ; CMP     <EA>,A@
00:0000A802 F0C0            	     1M          DC.W    $F0C0
00:0000A804 B0C0            	     2M          DC.W    $B0C0
00:0000A806 016A            	     3M          DC.W    (FORM10EX-X)
00:0000A808 0006            	     4M          DC.w    6
                            	  1338:          C68     F138,B108,FORM12A,46          ; CMPM
00:0000A80A F138            	     1M          DC.W    $F138
00:0000A80C B108            	     2M          DC.W    $B108
00:0000A80E 0244            	     3M          DC.W    (FORM12A-X)
00:0000A810 002E            	     4M          DC.w    46
                            	  1339:          C68     F100,B100,FORM10,5            ; EOR
00:0000A812 F100            	     1M          DC.W    $F100
00:0000A814 B100            	     2M          DC.W    $B100
00:0000A816 01A8            	     3M          DC.W    (FORM10-X)
00:0000A818 0005            	     4M          DC.w    5
                            	  1340:          C68     F000,B000,FORM10EX,6          ; CMP
00:0000A81A F000            	     1M          DC.W    $F000
00:0000A81C B000            	     2M          DC.W    $B000
00:0000A81E 016A            	     3M          DC.W    (FORM10EX-X)
00:0000A820 0006            	     4M          DC.w    6
                            	  1341:          C68     F0C0,90C0,FORM10EX,44         ; SUB       <EA>,A@
00:0000A822 F0C0            	     1M          DC.W    $F0C0
00:0000A824 90C0            	     2M          DC.W    $90C0
00:0000A826 016A            	     3M          DC.W    (FORM10EX-X)
00:0000A828 002C            	     4M          DC.w    44
                            	  1342:          C68     F130,9100,FORM12,45           ; SUBX
00:0000A82A F130            	     1M          DC.W    $F130
00:0000A82C 9100            	     2M          DC.W    $9100
00:0000A82E 0208            	     3M          DC.W    (FORM12-X)
00:0000A830 002D            	     4M          DC.w    45
                            	  1343:          C68     F000,9000,FORM10EX,44         ; SUB
00:0000A832 F000            	     1M          DC.W    $F000
00:0000A834 9000            	     2M          DC.W    $9000
00:0000A836 016A            	     3M          DC.W    (FORM10EX-X)
00:0000A838 002C            	     4M          DC.w    44
                            	  1344:          C68     F1F0,8100,FORM12,43           ; SBCD
00:0000A83A F1F0            	     1M          DC.W    $F1F0
00:0000A83C 8100            	     2M          DC.W    $8100
00:0000A83E 0208            	     3M          DC.W    (FORM12-X)
00:0000A840 002B            	     4M          DC.w    43
                            	  1345:          C68     F1C0,81C0,FORM6D,42           ; DIVS
00:0000A842 F1C0            	     1M          DC.W    $F1C0
00:0000A844 81C0            	     2M          DC.W    $81C0
00:0000A846 0120            	     3M          DC.W    (FORM6D-X)
00:0000A848 002A            	     4M          DC.w    42
                            	  1346:          C68     F1C0,80C0,FORM6D,41           ; DIVU
00:0000A84A F1C0            	     1M          DC.W    $F1C0
00:0000A84C 80C0            	     2M          DC.W    $80C0
00:0000A84E 0120            	     3M          DC.W    (FORM6D-X)
00:0000A850 0029            	     4M          DC.w    41
                            	  1347:          C68     F000,8000,FORM10,40           ; OR
00:0000A852 F000            	     1M          DC.W    $F000
00:0000A854 8000            	     2M          DC.W    $8000
00:0000A856 01A8            	     3M          DC.W    (FORM10-X)
00:0000A858 0028            	     4M          DC.w    40
                            	  1348:          C68     F100,7000,IMOVEQ,39           ; MOVEQ
00:0000A85A F100            	     1M          DC.W    $F100
00:0000A85C 7000            	     2M          DC.W    $7000
00:0000A85E 0270            	     3M          DC.W    (IMOVEQ-X)
00:0000A860 0027            	     4M          DC.w    39
                            	  1349:          C68     FF00,6100,IBSR,51             ; BSR
00:0000A862 FF00            	     1M          DC.W    $FF00
00:0000A864 6100            	     2M          DC.W    $6100
00:0000A866 0354            	     3M          DC.W    (IBSR-X)
00:0000A868 0033            	     4M          DC.w    51
                            	  1350:          C68     FF00,6000,IBSR,65             ; BRA
00:0000A86A FF00            	     1M          DC.W    $FF00
00:0000A86C 6000            	     2M          DC.W    $6000
00:0000A86E 0354            	     3M          DC.W    (IBSR-X)
00:0000A870 0041            	     4M          DC.w    65
                            	  1351:          C68     F000,6000,ICC,38              ; B
00:0000A872 F000            	     1M          DC.W    $F000
00:0000A874 6000            	     2M          DC.W    $6000
00:0000A876 0350            	     3M          DC.W    (ICC-X)
00:0000A878 0026            	     4M          DC.w    38
                            	  1352:          C68     F0F8,50C8,IDBCC,37            ; DB
00:0000A87A F0F8            	     1M          DC.W    $F0F8
00:0000A87C 50C8            	     2M          DC.W    $50C8
00:0000A87E 033E            	     3M          DC.W    (IDBCC-X)
00:0000A880 0025            	     4M          DC.w    37
                            	  1353:          C68     F0C0,50C0,ISCC,36             ; S
00:0000A882 F0C0            	     1M          DC.W    $F0C0
00:0000A884 50C0            	     2M          DC.W    $50C0
00:0000A886 0334            	     3M          DC.W    (ISCC-X)
00:0000A888 0024            	     4M          DC.w    36
                            	  1354:          C68     F100,5100,IQUICK,35           ; SUBQ
00:0000A88A F100            	     1M          DC.W    $F100
00:0000A88C 5100            	     2M          DC.W    $5100
00:0000A88E 026C            	     3M          DC.W    (IQUICK-X)
00:0000A890 0023            	     4M          DC.w    35
                            	  1355:          C68     F100,5000,IQUICK,34           ; ADDQ
00:0000A892 F100            	     1M          DC.W    $F100
00:0000A894 5000            	     2M          DC.W    $5000
00:0000A896 026C            	     3M          DC.W    (IQUICK-X)
00:0000A898 0022            	     4M          DC.w    34
                            	  1356:          C68     F1C0,41C0,FORM6A,33           ; LEA
00:0000A89A F1C0            	     1M          DC.W    $F1C0
00:0000A89C 41C0            	     2M          DC.W    $41C0
00:0000A89E 0110            	     3M          DC.W    (FORM6A-X)
00:0000A8A0 0021            	     4M          DC.w    33
                            	  1357:          C68     F1C0,4180,FORM6D,32           ; CHK
00:0000A8A2 F1C0            	     1M          DC.W    $F1C0
00:0000A8A4 4180            	     2M          DC.W    $4180
00:0000A8A6 0120            	     3M          DC.W    (FORM6D-X)
00:0000A8A8 0020            	     4M          DC.w    32
                            	  1358:          C68     FFC0,4EC0,FORM11SL,31         ; JMP
00:0000A8AA FFC0            	     1M          DC.W    $FFC0
00:0000A8AC 4EC0            	     2M          DC.W    $4EC0
00:0000A8AE 01E4            	     3M          DC.W    (FORM11SL-X)
00:0000A8B0 001F            	     4M          DC.w    31
                            	  1359:          C68     FFC0,4E80,FORM11SL,30         ; JSR
00:0000A8B2 FFC0            	     1M          DC.W    $FFC0
00:0000A8B4 4E80            	     2M          DC.W    $4E80
00:0000A8B6 01E4            	     3M          DC.W    (FORM11SL-X)
00:0000A8B8 001E            	     4M          DC.w    30
                            	  1360:          C68     FFFF,4E77,SCOMMON,29          ; RTR
00:0000A8BA FFFF            	     1M          DC.W    $FFFF
00:0000A8BC 4E77            	     2M          DC.W    $4E77
00:0000A8BE 0330            	     3M          DC.W    (SCOMMON-X)
00:0000A8C0 001D            	     4M          DC.w    29
                            	  1361:          C68     FFFF,4E76,SCOMMON,28          ; TRAPV
00:0000A8C2 FFFF            	     1M          DC.W    $FFFF
00:0000A8C4 4E76            	     2M          DC.W    $4E76
00:0000A8C6 0330            	     3M          DC.W    (SCOMMON-X)
00:0000A8C8 001C            	     4M          DC.w    28
                            	  1362:          C68     FFFF,4E75,SCOMMON,27          ; RTS
00:0000A8CA FFFF            	     1M          DC.W    $FFFF
00:0000A8CC 4E75            	     2M          DC.W    $4E75
00:0000A8CE 0330            	     3M          DC.W    (SCOMMON-X)
00:0000A8D0 001B            	     4M          DC.w    27
                            	  1363:          C68     FFFF,4E73,SCOMMON,26          ; RTE
00:0000A8D2 FFFF            	     1M          DC.W    $FFFF
00:0000A8D4 4E73            	     2M          DC.W    $4E73
00:0000A8D6 0330            	     3M          DC.W    (SCOMMON-X)
00:0000A8D8 001A            	     4M          DC.w    26
                            	  1364:          C68     FFFF,4E72,ISTOP,25            ; STOP
00:0000A8DA FFFF            	     1M          DC.W    $FFFF
00:0000A8DC 4E72            	     2M          DC.W    $4E72
00:0000A8DE 004A            	     3M          DC.W    (ISTOP-X)
00:0000A8E0 0019            	     4M          DC.w    25
                            	  1365:          C68     FFFF,4E71,SCOMMON,24          ; NOP
00:0000A8E2 FFFF            	     1M          DC.W    $FFFF
00:0000A8E4 4E71            	     2M          DC.W    $4E71
00:0000A8E6 0330            	     3M          DC.W    (SCOMMON-X)
00:0000A8E8 0018            	     4M          DC.w    24
                            	  1366:          C68     FFFF,4E70,SCOMMON,23          ; RESET
00:0000A8EA FFFF            	     1M          DC.W    $FFFF
00:0000A8EC 4E70            	     2M          DC.W    $4E70
00:0000A8EE 0330            	     3M          DC.W    (SCOMMON-X)
00:0000A8F0 0017            	     4M          DC.w    23
                            	  1367:          C68     FFF8,4E68,IMVFUSP,60          ; MOVE FROM USP
00:0000A8F2 FFF8            	     1M          DC.W    $FFF8
00:0000A8F4 4E68            	     2M          DC.W    $4E68
00:0000A8F6 029E            	     3M          DC.W    (IMVFUSP-X)
00:0000A8F8 003C            	     4M          DC.w    60
                            	  1368:          C68     FFF8,4E60,IMVTUSP,60          ; MOVE TO USP
00:0000A8FA FFF8            	     1M          DC.W    $FFF8
00:0000A8FC 4E60            	     2M          DC.W    $4E60
00:0000A8FE 02BE            	     3M          DC.W    (IMVTUSP-X)
00:0000A900 003C            	     4M          DC.w    60
                            	  1369:          C68     FFF8,4E58,FORM5,22            ; UNLINK
00:0000A902 FFF8            	     1M          DC.W    $FFF8
00:0000A904 4E58            	     2M          DC.W    $4E58
00:0000A906 010C            	     3M          DC.W    (FORM5-X)
00:0000A908 0016            	     4M          DC.w    22
                            	  1370:          C68     FFF8,4E50,ILINK,21            ; LINK
00:0000A90A FFF8            	     1M          DC.W    $FFF8
00:0000A90C 4E50            	     2M          DC.W    $4E50
00:0000A90E 00D6            	     3M          DC.W    (ILINK-X)
00:0000A910 0015            	     4M          DC.w    21
                            	  1371:          C68     FFF0,4E40,FORM4,20            ; TRAP
00:0000A912 FFF0            	     1M          DC.W    $FFF0
00:0000A914 4E40            	     2M          DC.W    $4E40
00:0000A916 00FA            	     3M          DC.W    (FORM4-X)
00:0000A918 0014            	     4M          DC.w    20
                            	  1372:          C68     FF80,4C80,IMOVEMTR,15         ; MOVEM FROM REGISTERS
00:0000A91A FF80            	     1M          DC.W    $FF80
00:0000A91C 4C80            	     2M          DC.W    $4C80
00:0000A91E 002E            	     3M          DC.W    (IMOVEMTR-X)
00:0000A920 000F            	     4M          DC.w    15
                            	  1373:          C68     FFC0,4AC0,FORM1A,19           ; TAS
00:0000A922 FFC0            	     1M          DC.W    $FFC0
00:0000A924 4AC0            	     2M          DC.W    $4AC0
00:0000A926 00F0            	     3M          DC.W    (FORM1A-X)
00:0000A928 0013            	     4M          DC.w    19
                            	  1374:          C68     FF00,4A00,FORM1,18            ; TST
00:0000A92A FF00            	     1M          DC.W    $FF00
00:0000A92C 4A00            	     2M          DC.W    $4A00
00:0000A92E 00EC            	     3M          DC.W    (FORM1-X)
00:0000A930 0012            	     4M          DC.w    18
                            	  1375:          C68     FFF8,48C0,FORM3,17            ; EXT.L
00:0000A932 FFF8            	     1M          DC.W    $FFF8
00:0000A934 48C0            	     2M          DC.W    $48C0
00:0000A936 00F6            	     3M          DC.W    (FORM3-X)
00:0000A938 0011            	     4M          DC.w    17
                            	  1376:          C68     FFF8,4880,FORM3,16            ; EXT.W
00:0000A93A FFF8            	     1M          DC.W    $FFF8
00:0000A93C 4880            	     2M          DC.W    $4880
00:0000A93E 00F6            	     3M          DC.W    (FORM3-X)
00:0000A940 0010            	     4M          DC.w    16
                            	  1377:          C68     FF80,4880,IMOVEMFR,15         ; MOVEA TO REGISTERS
00:0000A942 FF80            	     1M          DC.W    $FF80
00:0000A944 4880            	     2M          DC.W    $4880
00:0000A946 0000            	     3M          DC.W    (IMOVEMFR-X)
00:0000A948 000F            	     4M          DC.w    15
                            	  1378:          C68     FFF8,4840,FORM3,14            ; SWAP
00:0000A94A FFF8            	     1M          DC.W    $FFF8
00:0000A94C 4840            	     2M          DC.W    $4840
00:0000A94E 00F6            	     3M          DC.W    (FORM3-X)
00:0000A950 000E            	     4M          DC.w    14
                            	  1379:          C68     FFC0,4840,FORM11,13           ; PEA
00:0000A952 FFC0            	     1M          DC.W    $FFC0
00:0000A954 4840            	     2M          DC.W    $4840
00:0000A956 01DC            	     3M          DC.W    (FORM11-X)
00:0000A958 000D            	     4M          DC.w    13
                            	  1380:          C68     FFC0,4800,FORM1A,12           ; NBCD
00:0000A95A FFC0            	     1M          DC.W    $FFC0
00:0000A95C 4800            	     2M          DC.W    $4800
00:0000A95E 00F0            	     3M          DC.W    (FORM1A-X)
00:0000A960 000C            	     4M          DC.w    12
                            	  1381:          C68     FFC0,46C0,IMVTSR,59           ; MOVE TO SR
00:0000A962 FFC0            	     1M          DC.W    $FFC0
00:0000A964 46C0            	     2M          DC.W    $46C0
00:0000A966 02AC            	     3M          DC.W    (IMVTSR-X)
00:0000A968 003B            	     4M          DC.w    59
                            	  1382:          C68     FF00,4600,FORM1,11            ; NOT
00:0000A96A FF00            	     1M          DC.W    $FF00
00:0000A96C 4600            	     2M          DC.W    $4600
00:0000A96E 00EC            	     3M          DC.W    (FORM1-X)
00:0000A970 000B            	     4M          DC.w    11
                            	  1383:          C68     FFC0,44C0,IMVTCCR,59          ; MOVE TO CCR
00:0000A972 FFC0            	     1M          DC.W    $FFC0
00:0000A974 44C0            	     2M          DC.W    $44C0
00:0000A976 02CA            	     3M          DC.W    (IMVTCCR-X)
00:0000A978 003B            	     4M          DC.w    59
                            	  1384:          C68     FF00,4400,FORM1,10            ; NEG
00:0000A97A FF00            	     1M          DC.W    $FF00
00:0000A97C 4400            	     2M          DC.W    $4400
00:0000A97E 00EC            	     3M          DC.W    (FORM1-X)
00:0000A980 000A            	     4M          DC.w    10
                            	  1385:          C68     FF00,4200,FORM1,9             ; CLR
00:0000A982 FF00            	     1M          DC.W    $FF00
00:0000A984 4200            	     2M          DC.W    $4200
00:0000A986 00EC            	     3M          DC.W    (FORM1-X)
00:0000A988 0009            	     4M          DC.w    9
                            	  1386:          C68     FFC0,40C0,IMVFSR,59           ; MOVE.W  FROM  SR
00:0000A98A FFC0            	     1M          DC.W    $FFC0
00:0000A98C 40C0            	     2M          DC.W    $40C0
00:0000A98E 0290            	     3M          DC.W    (IMVFSR-X)
00:0000A990 003B            	     4M          DC.w    59
                            	  1387:          C68     FF00,4000,FORM1,8             ; NEGX
00:0000A992 FF00            	     1M          DC.W    $FF00
00:0000A994 4000            	     2M          DC.W    $4000
00:0000A996 00EC            	     3M          DC.W    (FORM1-X)
00:0000A998 0008            	     4M          DC.w    8
                            	  1388:          C68     F000,3000,IMOVE,59            ; MOVE.W
00:0000A99A F000            	     1M          DC.W    $F000
00:0000A99C 3000            	     2M          DC.W    $3000
00:0000A99E 00D2            	     3M          DC.W    (IMOVE-X)
00:0000A9A0 003B            	     4M          DC.w    59
                            	  1389:          C68     F000,2000,IMOVE,60            ; MOVE.L
00:0000A9A2 F000            	     1M          DC.W    $F000
00:0000A9A4 2000            	     2M          DC.W    $2000
00:0000A9A6 00D2            	     3M          DC.W    (IMOVE-X)
00:0000A9A8 003C            	     4M          DC.w    60
                            	  1390:          C68     F000,1000,IMOVE,58            ; MOVE.B
00:0000A9AA F000            	     1M          DC.W    $F000
00:0000A9AC 1000            	     2M          DC.W    $1000
00:0000A9AE 00D2            	     3M          DC.W    (IMOVE-X)
00:0000A9B0 003A            	     4M          DC.w    58
                            	  1391:          C68     FF00,0C00,IMMED,6             ; CMP       #
00:0000A9B2 FF00            	     1M          DC.W    $FF00
00:0000A9B4 0C00            	     2M          DC.W    $0C00
00:0000A9B6 005E            	     3M          DC.W    (IMMED-X)
00:0000A9B8 0006            	     4M          DC.w    6
                            	  1392:          C68     FF00,0A00,IMMED,5             ; EOR       #
00:0000A9BA FF00            	     1M          DC.W    $FF00
00:0000A9BC 0A00            	     2M          DC.W    $0A00
00:0000A9BE 005E            	     3M          DC.W    (IMMED-X)
00:0000A9C0 0005            	     4M          DC.w    5
                            	  1393:          C68     FF00,0600,IMMED,4             ; ADD       #
00:0000A9C2 FF00            	     1M          DC.W    $FF00
00:0000A9C4 0600            	     2M          DC.W    $0600
00:0000A9C6 005E            	     3M          DC.W    (IMMED-X)
00:0000A9C8 0004            	     4M          DC.w    4
                            	  1394:          C68     FF00,0400,IMMED,3             ; SUB       #
00:0000A9CA FF00            	     1M          DC.W    $FF00
00:0000A9CC 0400            	     2M          DC.W    $0400
00:0000A9CE 005E            	     3M          DC.W    (IMMED-X)
00:0000A9D0 0003            	     4M          DC.w    3
                            	  1395:          C68     FF00,0200,IMMED,2             ; AND       #
00:0000A9D2 FF00            	     1M          DC.W    $FF00
00:0000A9D4 0200            	     2M          DC.W    $0200
00:0000A9D6 005E            	     3M          DC.W    (IMMED-X)
00:0000A9D8 0002            	     4M          DC.w    2
                            	  1396:          C68     FF00,0000,IMMED,1             ; OR        #
00:0000A9DA FF00            	     1M          DC.W    $FF00
00:0000A9DC 0000            	     2M          DC.W    $0000
00:0000A9DE 005E            	     3M          DC.W    (IMMED-X)
00:0000A9E0 0001            	     4M          DC.w    1
                            	  1397:          C68     F138,0108,IMOVEP,0            ; MOVEP
00:0000A9E2 F138            	     1M          DC.W    $F138
00:0000A9E4 0108            	     2M          DC.W    $0108
00:0000A9E6 02DA            	     3M          DC.W    (IMOVEP-X)
00:0000A9E8 0000            	     4M          DC.w    0
                            	  1398:          C68     FFC0,08C0,ISETS,64            ; BSET
00:0000A9EA FFC0            	     1M          DC.W    $FFC0
00:0000A9EC 08C0            	     2M          DC.W    $08C0
00:0000A9EE 039C            	     3M          DC.W    (ISETS-X)
00:0000A9F0 0040            	     4M          DC.w    64
                            	  1399:          C68     FFC0,0880,ISETS,63            ; BCLR
00:0000A9F2 FFC0            	     1M          DC.W    $FFC0
00:0000A9F4 0880            	     2M          DC.W    $0880
00:0000A9F6 039C            	     3M          DC.W    (ISETS-X)
00:0000A9F8 003F            	     4M          DC.w    63
                            	  1400:          C68     FFC0,0840,ISETS,62            ; BCHG
00:0000A9FA FFC0            	     1M          DC.W    $FFC0
00:0000A9FC 0840            	     2M          DC.W    $0840
00:0000A9FE 039C            	     3M          DC.W    (ISETS-X)
00:0000AA00 003E            	     4M          DC.w    62
                            	  1401:          C68     FFC0,0800,ISETS,61            ; BTST
00:0000AA02 FFC0            	     1M          DC.W    $FFC0
00:0000AA04 0800            	     2M          DC.W    $0800
00:0000AA06 039C            	     3M          DC.W    (ISETS-X)
00:0000AA08 003D            	     4M          DC.w    61
                            	  1402:          C68     F1C0,01C0,ISETD,64            ; BSET
00:0000AA0A F1C0            	     1M          DC.W    $F1C0
00:0000AA0C 01C0            	     2M          DC.W    $01C0
00:0000AA0E 038C            	     3M          DC.W    (ISETD-X)
00:0000AA10 0040            	     4M          DC.w    64
                            	  1403:          C68     F1C0,0180,ISETD,63            ; BCLR
00:0000AA12 F1C0            	     1M          DC.W    $F1C0
00:0000AA14 0180            	     2M          DC.W    $0180
00:0000AA16 038C            	     3M          DC.W    (ISETD-X)
00:0000AA18 003F            	     4M          DC.w    63
                            	  1404:          C68     F1C0,0140,ISETD,62            ; BCHG
00:0000AA1A F1C0            	     1M          DC.W    $F1C0
00:0000AA1C 0140            	     2M          DC.W    $0140
00:0000AA1E 038C            	     3M          DC.W    (ISETD-X)
00:0000AA20 003E            	     4M          DC.w    62
                            	  1405:          C68     F1C0,0100,ISETD,61            ; BTST
00:0000AA22 F1C0            	     1M          DC.W    $F1C0
00:0000AA24 0100            	     2M          DC.W    $0100
00:0000AA26 038C            	     3M          DC.W    (ISETD-X)
00:0000AA28 003D            	     4M          DC.w    61
                            	  1406: TBLE:
                            	  1407:           even
                            	  1408: 
                            	  1409: N68:     macro arg1,arg2
                            	  1410:          dc.b  "\1",\2
                            	  1411:          endm
                            	  1412: 
                            	  1413: 				even
                            	  1414: OPCTBL:  ;.align  2
                            	  1415:          N68     MOVE,$d0    ; 0
00:0000AA2A 4D4F5645        	     1M          dc.b  "MOVE",$d0
00:0000AA2E D0
                            	  1416:          N68     O,$d2       ; 1
00:0000AA2F 4F              	     1M          dc.b  "O",$d2
00:0000AA30 D2
                            	  1417:          N68     AN,$c4      ; 2
00:0000AA31 414E            	     1M          dc.b  "AN",$c4
00:0000AA33 C4
                            	  1418:          N68     SU,$c2      ; 3
00:0000AA34 5355            	     1M          dc.b  "SU",$c2
00:0000AA36 C2
                            	  1419:          N68     AD,$c4      ; 4
00:0000AA37 4144            	     1M          dc.b  "AD",$c4
00:0000AA39 C4
                            	  1420:          N68     EO,$d2      ; 5
00:0000AA3A 454F            	     1M          dc.b  "EO",$d2
00:0000AA3C D2
                            	  1421:          N68     CM,$d0      ; 6
00:0000AA3D 434D            	     1M          dc.b  "CM",$d0
00:0000AA3F D0
                            	  1422:          N68     MOV,$c5     ; 7
00:0000AA40 4D4F56          	     1M          dc.b  "MOV",$c5
00:0000AA43 C5
                            	  1423:          N68     NEG,$d8     ; 8
00:0000AA44 4E4547          	     1M          dc.b  "NEG",$d8
00:0000AA47 D8
                            	  1424:          N68     CL,$d2      ; 9
00:0000AA48 434C            	     1M          dc.b  "CL",$d2
00:0000AA4A D2
                            	  1425:          N68     NE,$c7      ; 10
00:0000AA4B 4E45            	     1M          dc.b  "NE",$c7
00:0000AA4D C7
                            	  1426:          N68     NO,$d4      ; 11
00:0000AA4E 4E4F            	     1M          dc.b  "NO",$d4
00:0000AA50 D4
                            	  1427:          N68     NBC,$c4     ; 12
00:0000AA51 4E4243          	     1M          dc.b  "NBC",$c4
00:0000AA54 C4
                            	  1428:          N68     PEA.,$cc    ; 13
00:0000AA55 5045412E        	     1M          dc.b  "PEA.",$cc
00:0000AA59 CC
                            	  1429:          N68     SWAP.,$d7   ; 14
00:0000AA5A 535741502E      	     1M          dc.b  "SWAP.",$d7
00:0000AA5F D7
                            	  1430:          N68     MOVE,$cd    ; 15
00:0000AA60 4D4F5645        	     1M          dc.b  "MOVE",$cd
00:0000AA64 CD
                            	  1431:          N68     EXT.,$d7    ; 16
00:0000AA65 4558542E        	     1M          dc.b  "EXT.",$d7
00:0000AA69 D7
                            	  1432:          N68     EXT.,$cc    ; 17
00:0000AA6A 4558542E        	     1M          dc.b  "EXT.",$cc
00:0000AA6E CC
                            	  1433:          N68     TS,$d4      ; 18
00:0000AA6F 5453            	     1M          dc.b  "TS",$d4
00:0000AA71 D4
                            	  1434:          N68     TAS.,$c2    ; 19
00:0000AA72 5441532E        	     1M          dc.b  "TAS.",$c2
00:0000AA76 C2
                            	  1435:          N68     TRA,$d0     ; 20
00:0000AA77 545241          	     1M          dc.b  "TRA",$d0
00:0000AA7A D0
                            	  1436:          N68     LIN,$cb     ; 21
00:0000AA7B 4C494E          	     1M          dc.b  "LIN",$cb
00:0000AA7E CB
                            	  1437:          N68     UNL,$cb     ; 22
00:0000AA7F 554E4C          	     1M          dc.b  "UNL",$cb
00:0000AA82 CB
                            	  1438:          N68     RESE,$d4    ; 23
00:0000AA83 52455345        	     1M          dc.b  "RESE",$d4
00:0000AA87 D4
                            	  1439:          N68     NO,$d0      ; 24
00:0000AA88 4E4F            	     1M          dc.b  "NO",$d0
00:0000AA8A D0
                            	  1440:          N68     STO,$d0     ; 25
00:0000AA8B 53544F          	     1M          dc.b  "STO",$d0
00:0000AA8E D0
                            	  1441:          N68     RT,$c5      ; 26
00:0000AA8F 5254            	     1M          dc.b  "RT",$c5
00:0000AA91 C5
                            	  1442:          N68     RT,$d3      ; 27
00:0000AA92 5254            	     1M          dc.b  "RT",$d3
00:0000AA94 D3
                            	  1443:          N68     TRAP,$d6    ; 28
00:0000AA95 54524150        	     1M          dc.b  "TRAP",$d6
00:0000AA99 D6
                            	  1444:          N68     RT,$d2      ; 29
00:0000AA9A 5254            	     1M          dc.b  "RT",$d2
00:0000AA9C D2
                            	  1445:          N68     JS,$d2      ; 30
00:0000AA9D 4A53            	     1M          dc.b  "JS",$d2
00:0000AA9F D2
                            	  1446:          N68     JM,$d0      ; 31
00:0000AAA0 4A4D            	     1M          dc.b  "JM",$d0
00:0000AAA2 D0
                            	  1447:          N68     CHK.,$d7    ; 32
00:0000AAA3 43484B2E        	     1M          dc.b  "CHK.",$d7
00:0000AAA7 D7
                            	  1448:          N68     LEA.,$cc    ; 33
00:0000AAA8 4C45412E        	     1M          dc.b  "LEA.",$cc
00:0000AAAC CC
                            	  1449:          N68     ADD,$d1     ; 34
00:0000AAAD 414444          	     1M          dc.b  "ADD",$d1
00:0000AAB0 D1
                            	  1450:          N68     SUB,$d1     ; 35
00:0000AAB1 535542          	     1M          dc.b  "SUB",$d1
00:0000AAB4 D1
00:0000AAB5 D3              	  1451:          DC.B    $d3         ; 36
                            	  1452:          N68     D,$c2       ; 37
00:0000AAB6 44              	     1M          dc.b  "D",$c2
00:0000AAB7 C2
00:0000AAB8 C2              	  1453:          DC.B    $c2         ; 38
                            	  1454:          N68     MOVEQ.,$cc  ; .....39
00:0000AAB9 4D4F5645512E    	     1M          dc.b  "MOVEQ.",$cc
00:0000AABF CC
                            	  1455:          N68     O,$d2       ; 40
00:0000AAC0 4F              	     1M          dc.b  "O",$d2
00:0000AAC1 D2
                            	  1456:          N68     DIVU.,$d7   ; 41
00:0000AAC2 444956552E      	     1M          dc.b  "DIVU.",$d7
00:0000AAC7 D7
                            	  1457:          N68     DIVS.,$d7   ; 42
00:0000AAC8 444956532E      	     1M          dc.b  "DIVS.",$d7
00:0000AACD D7
                            	  1458:          N68     SBC,$c4     ; 43
00:0000AACE 534243          	     1M          dc.b  "SBC",$c4
00:0000AAD1 C4
                            	  1459:          N68     SU,$c2      ; 44
00:0000AAD2 5355            	     1M          dc.b  "SU",$c2
00:0000AAD4 C2
                            	  1460:          N68     SUB,$d8     ; 45
00:0000AAD5 535542          	     1M          dc.b  "SUB",$d8
00:0000AAD8 D8
                            	  1461:          N68     CMP,$cd     ; 46
00:0000AAD9 434D50          	     1M          dc.b  "CMP",$cd
00:0000AADC CD
                            	  1462:          N68     MULU.,$d7   ; 47
00:0000AADD 4D554C552E      	     1M          dc.b  "MULU.",$d7
00:0000AAE2 D7
                            	  1463:          N68     MULS.,$d7   ; 48
00:0000AAE3 4D554C532E      	     1M          dc.b  "MULS.",$d7
00:0000AAE8 D7
                            	  1464:          N68     ABC,$c4     ; 49
00:0000AAE9 414243          	     1M          dc.b  "ABC",$c4
00:0000AAEC C4
                            	  1465:          N68     EX,$c7      ; 50
00:0000AAED 4558            	     1M          dc.b  "EX",$c7
00:0000AAEF C7
                            	  1466:          N68     BS,$d2      ; .....51
00:0000AAF0 4253            	     1M          dc.b  "BS",$d2
00:0000AAF2 D2
                            	  1467:          N68     NUL,$cc     ; .....52
00:0000AAF3 4E554C          	     1M          dc.b  "NUL",$cc
00:0000AAF6 CC
                            	  1468:          N68     ADD,$d8     ; 53
00:0000AAF7 414444          	     1M          dc.b  "ADD",$d8
00:0000AAFA D8
                            	  1469:          N68     A,$d3       ; 54
00:0000AAFB 41              	     1M          dc.b  "A",$d3
00:0000AAFC D3
                            	  1470:          N68     L,$d3       ; 55
00:0000AAFD 4C              	     1M          dc.b  "L",$d3
00:0000AAFE D3
                            	  1471:          N68     R,$cf       ; 56
00:0000AAFF 52              	     1M          dc.b  "R",$cf
00:0000AB00 CF
                            	  1472:          N68     RO,$d8      ; 57
00:0000AB01 524F            	     1M          dc.b  "RO",$d8
00:0000AB03 D8
                            	  1473:          N68     MOVE.,$c2   ; 58
00:0000AB04 4D4F56452E      	     1M          dc.b  "MOVE.",$c2
00:0000AB09 C2
                            	  1474:          N68     MOVE.,$d7   ; 59
00:0000AB0A 4D4F56452E      	     1M          dc.b  "MOVE.",$d7
00:0000AB0F D7
                            	  1475:          N68     MOVE.,$cc   ; 60
00:0000AB10 4D4F56452E      	     1M          dc.b  "MOVE.",$cc
00:0000AB15 CC
                            	  1476:          N68     BTS,$d4     ; 61
00:0000AB16 425453          	     1M          dc.b  "BTS",$d4
00:0000AB19 D4
                            	  1477:          N68     BCH,$c7     ; 62
00:0000AB1A 424348          	     1M          dc.b  "BCH",$c7
00:0000AB1D C7
                            	  1478:          N68     BCL,$d2     ; 63
00:0000AB1E 42434C          	     1M          dc.b  "BCL",$d2
00:0000AB21 D2
                            	  1479:          N68     BSE,$d4     ; 64
00:0000AB22 425345          	     1M          dc.b  "BSE",$d4
00:0000AB25 D4
                            	  1480:          N68     BR,$c1      ; 65
00:0000AB26 4252            	     1M          dc.b  "BR",$c1
00:0000AB28 C1
                            	  1481: 
00:0000AB29 00              	  1482:          DC.B    0         ; PAD BYTE
                            	  1483: 
                            	  1484: 

Source: "boot.x68"
                            	  4152:  	include "games/asteroids/asteroids 1_0.x68"

Source: "games\asteroids\asteroids 1_0.x68"
                            	     1: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	     2: ;														;
                            	     3: ;	ASTEROIDS type game for the EASy68k simulator	2009/05/17	V1.00			;
                            	     4: ;														;
                            	     5: ;	The objective of of the game is to score as many points as possible by		;
                            	     6: ;	destroying asteroids and flying saucers. You control a triangular ship		;
                            	     7: ;	that can rotate, fire shots forward and thrust forward. As the ship moves,	;
                            	     8: ;	momentum is not conserved, the ship eventually comes to a stop when not		;
                            	     9: ;	thrusting. In moments of extreme danger you can send the ship into		;
                            	    10: ;	hyperspace, causing it to disappear and reappear in a random location.		;
                            	    11: ;														;
                            	    12: ;	Each wave starts with the asteroids drifting in random directions onto the	;
                            	    13: ;	screen. Objects wrap around screen edges, an asteroid that drifts off the	;
                            	    14: ;	left edge of the screen reappears at the right and continues moving in the	;
                            	    15: ;	same direction. As you shoot asteroids they break into smaller asteroids	;
                            	    16: ;	that often move faster and are more difficult to hit. The smaller the		;
                            	    17: ;	asteroid the higher the points scored.							;
                            	    18: ;														;
                            	    19: ;	Every so often a flying saucer will appear on one side of the screen and	;
                            	    20: ;	move to the other before disappearing again. Large saucers fire in random	;
                            	    21: ;	directions, while small saucers aim their fire towards the player's ship.	;
                            	    22: ;														;
                            	    23: ;	Once all of the asteroids and flying saucers have been cleared a new set of	;
                            	    24: ;	large asteroids appears. The number of asteroids increases by two each round	;
                            	    25: ;	up to a maximum of eleven. The game continues until all the player lives	;
                            	    26: ;	are lost, a bonus life being awarded for each 10,000 points scored up to a	;
                            	    27: ;	maximum of 255 lives. A maximum of only 18 lives are shown on screen.		;
                            	    28: ;														;
                            	    29: ;	Like the original game the maximum possible score in this game is 99,990	;
                            	    30: ;	points after which it rolls over back to zero.						;
                            	    31: ;														;
                            	    32: ;	Also like the original game some game parameters can be set using the		;
                            	    33: ;	switches in the hardware window. These can be changed at any time during	;
                            	    34: ;	the game.												;
                            	    35: ;														;
                            	    36: ;	Switch	Function										;
                            	    37: ;	------	--------										;
                            	    38: ;	7 - 3		Unused										;
                            	    39: ;	  2		Starting ship count. On = 4, off = 3					;
                            	    40: ;	1 - 0		Language	1	0								;
                            	    41: ;					off	off	English						;
                            	    42: ;					off	on	German						;
                            	    43: ;					on	off	French						;
                            	    44: ;					on	on	Spanish						;
                            	    45: ;														;
                            	    46: ;	Game controls...											;
                            	    47: ;														;
                            	    48: ;	 [1] or [2] for a one or two player game start						;
                            	    49: ;	 [s] to toggle the sound off and on								;
                            	    50: ;														;
                            	    51: ;	 [q] to rotate the ship widdershins								;
                            	    52: ;	 [w] to rotate the ship deocil								;
                            	    53: ;	 [l] to fire the ship thruster								;
                            	    54: ;	 [p] to fire the ship weapon									;
                            	    55: ;	 [SPACE] to jump to hyperspace								;
                            	    56: ;														;
                            	    57: ;	Other keys are:											;
                            	    58: ;														;
                            	    59: ;	 The F2, F3 and F4 keys can be used to select a screen size of 640 x 480,	;
                            	    60: ;	 800 x 600 and 1024 x 768 respectively.							;
                            	    61: ;														;
                            	    62: ;	The game saves the high scores in the file asteroids.hi If this file is		;
                            	    63: ;	not present it will be created after the first high score is entered. If	;
                            	    64: ;	this file is read only new high scores will not be saved. No check is made	;
                            	    65: ;	on the validity of this file, editing the file may cause the game to crash.	;
                            	    66: ;														;
                            	    67: ;	This version for Sim68K 4.6.0 or later							;
                            	    68: ;														;
                            	    69: ;	More 68000 and other projects can be found on my website at ..			;
                            	    70: ;														;
                            	    71: ;	 http://mycorner.no-ip.org/index.html							;
                            	    72: ;														;
                            	    73: ;	mail : leeedavison@googlemail.com								;
                            	    74: ;														;
                            	    75: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    76: 
                            	    77: ; a0 = system calls and volatile
                            	    78: ; a1 = system calls and volatile
                            	    79: ; a2 = volatile
                            	    80: ; a3 = variables base address
                            	    81: ; a4 = vector list pointer
                            	    82: ; a5 = player 1 / current player
                            	    83: ; a6 = player 2 / other player
                            	    84: ; a7 = stack pointer
                            	    85: 
                            	    86: 
                            	    87: 	ORG	$10000
                            	    88: 	code
                            	    89: 	even
                            	    90: 
                            	    91: asteroids_start:
00:0000AB2A 61001222        	    92: 	bsr	Initialise				; go setup everything
00:0000AB2E 610006DA        	    93: 	bsr reset_game				; clear the scores and set the ship start count
                            	    94: 
                            	    95: ; main loop. this is executed at most once every 16ms, as it waits for the 16ms counter
                            	    96: ; to be incremented from zero since the last loop
                            	    97: 
                            	    98: main_loop:
00:0000AB32 705E            	    99: 	moveq	#94,d0					; copy screen buffer to main (page flip)
00:0000AB34 4E4F            	   100: 	trap #15
                            	   101: 
00:0000AB36 7E06            	   102: 	moveq #6,d7						; video frame buffer
00:0000AB38 7C0C            	   103: 	moveq #DEV_CLEAR,d6
00:0000AB3A 4E40            	   104: 	trap #0
                            	   105: 
                            	   106: ;	move.w #$FF00,d1			; clear screen
                            	   107: ;	moveq #11,d0					; position cursor
                            	   108: ;	trap #15
                            	   109: 
                            	   110: ;	bsr sound_key					; handle the sound key
00:0000AB3C 61001204        	   111: 	bsr s_controls				; go check the screen controls
                            	   112: 
00:0000AB40 20390004009C    	   113: 	move.l tickcnt,d0
                            	   114: .0001:
00:0000AB46 B0B90004009C    	   115: 	cmp.l tickcnt,d0
00:0000AB4C 67F8            	   116: 	beq.s .0001
00:0000AB4E 7001            	   117: 	moveq #1,d0
                            	   118: ;wait_16ms
                            	   119: ;	MOVE.b	sixteen_ms(a3),d0		; get the 16ms counter
                            	   120: ;	BEQ.s		wait_16ms			; if not there yet just loop
                            	   121: 
                            	   122: ;	clr.b	sixteen_ms(a3)			; clear the 16ms counter
00:0000AB50 D16B0059        	   123: 	add.w d0,game_count(a3)		; increment the game counter
00:0000AB54 D12B0025        	   124: 	add.b d0,time_count(a3)		; increment the timeout counter
                            	   125: 
00:0000AB58 49FA13D4        	   126: 	lea vector(pc),a4			; reset the vector RAM pointer
                            	   127: 
00:0000AB5C 6168            	   128: 	bsr game_message			; do "PLAYER x", "GAME OVER" or credit messages
                            	   129: 
00:0000AB5E 61000F1C        	   130: 	bsr check_hiscores		; do the high score checks
00:0000AB62 610004C0        	   131: 	bsr enter_hiscores		; get the player high score entries
00:0000AB66 6A30            	   132: 	bpl.s no_play					; if the high scores are being entered skip the
                            	   133: 												; active play routines
                            	   134: 
00:0000AB68 61000C70        	   135: 	bsr high_scores				; display the high score table if the game is
                            	   136: 												; over
00:0000AB6C 652A            	   137: 	bcs.s	no_play					; if the high score table was displayed skip
                            	   138: 												; active play
                            	   139: 
00:0000AB6E 4A2B001C        	   140: 	tst.b px_time(a3)			; test the "PLAYER x" timer
00:0000AB72 661C            	   141: 	bne.s px_hide					; skip the control checks if the "PLAYER x"
                            	   142: 												; timer is not timed out
                            	   143: 
00:0000AB74 4A2B001A        	   144: 	tst.b num_players(a3)	; test the number of players in the game
00:0000AB78 6712            	   145: 	beq.s skip_player_cont		; if no players skip the player controls
                            	   146: 
00:0000AB7A 4A2D0027        	   147: 	tst.b p_flag_off(a5)			; test the player flag
00:0000AB7E 6B08            	   148: 	bmi.s skip_player_move		; if the player is exploding skip the player
                            	   149: 														; move controls
                            	   150: 
00:0000AB80 610003FA        	   151: 	bsr	ship_fire					; handle the fire button			##
00:0000AB84 610005F4        	   152: 	bsr	hyperspace				; handle the hyperspace button		##
                            	   153: skip_player_move
00:0000AB88 610007F0        	   154: 	bsr ship_move					; handle ship rotation and thrust		##
                            	   155: skip_player_cont
00:0000AB8C 61000280        	   156: 	bsr do_saucer					; handle the saucer
                            	   157: px_hide
00:0000AB90 610006F6        	   158: 	bsr move_items				; move all the objects and add them to the
                            	   159: 												; vector list
00:0000AB94 61000146        	   160: 	bsr check_hits				; check for player/saucer/shot hits
                            	   161: no_play
00:0000AB98 61000AB0        	   162: 	bsr static_messages		; add (c), scores and players ships to the
                            	   163: 												; vector list
                            	   164: 
00:0000AB9C 61000E26        	   165: 	bsr fx_sounds					; do the saucer and thump sounds
                            	   166: 
00:0000ABA0 38FCB000        	   167: 	move.w #HALT,(a4)+		; add HALT to the vector list
                            	   168: 
00:0000ABA4 49FA1388        	   169: 	lea vector(pc),a4			; reset the vector RAM pointer
00:0000ABA8 6100123A        	   170: 	bsr do_vector					; go do the vector list, draw them
                            	   171: 
00:0000ABAC 102D007B        	   172: 	move.b new_rocks(a5),d0			; test the generate new rocks flag
00:0000ABB0 6704            	   173: 	beq.s no_dec_new_rocks			; if counted out skip the decrement
                            	   174: 
00:0000ABB2 532D007B        	   175: 	subq.b #1,new_rocks(a5)			; else decrement the generate new rocks flag
                            	   176: no_dec_new_rocks
00:0000ABB6 802D0076        	   177: 	or.b rock_count(a5),d0			; OR the new rocks flag with the rock count
00:0000ABBA 6600FF76        	   178: 	bne main_loop					; if not counted out or still rocks go do the
                            	   179: 												; main loop
                            	   180: 
00:0000ABBE 487AFF72        	   181: 	pea main_loop					; return to the main loop
00:0000ABC2 6000090C        	   182: 	bra make_rocks				; go generate new rocks
                            	   183: 
                            	   184: 
                            	   185: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   186: ;
                            	   187: ; do "PLAYER x", "GAME OVER" or credit messages
                            	   188: 
                            	   189: game_message:
00:0000ABC6 4A2B001A        	   190: 	tst.b num_players(a3)		; test the number of players in the game
00:0000ABCA 670E            	   191: 	beq.s do_start_mess			; if no players go do the start message
                            	   192: 
00:0000ABCC 4A2B001C        	   193: 	tst.b px_time(a3)				; test the "PLAYER x" timer
00:0000ABD0 6778            	   194: 	beq.s game_over					; if timed out go do "GAME OVER" or thump
                            	   195: 													; sound count
                            	   196: 
00:0000ABD2 532B001C        	   197: 	subq.b #1,px_time(a3)		; decrement the "PLAYER x" timer
00:0000ABD6 60001100        	   198: 	bra player_x						; add "PLAYER x" to the vector list and return
                            	   199: 
                            	   200: ; do the push start message
                            	   201: 
                            	   202: do_start_mess:
00:0000ABDA 7005            	   203: 	moveq #5,d0					; GetKey
00:0000ABDC 4E4F            	   204: 	trap #15
00:0000ABDE 7001            	   205: 	moveq #1,d0
00:0000ABE0 0C010031        	   206: 	cmpi.b #'1',d1
00:0000ABE4 6718            	   207: 	beq.s start_game
00:0000ABE6 0C010032        	   208: 	cmpi.b #'2',d1
00:0000ABEA 6646            	   209: 	bne.s push_start_mess
                            	   210: 
                            	   211: ;	MOVE.l	#'2121',d1			; [2][1][2][1] key
                            	   212: ;	MOVEQ		#19,d0			; check for keypress
                            	   213: ;	TRAP		#15
                            	   214: 
                            	   215: ;	MOVEQ		#1,d0				; default to one player
                            	   216: ;	TST.b		d1				; test the [1] key result
                            	   217: ;	BMI.s		start_game			; if pressed go start a one player game
                            	   218: 
                            	   219: ;	TST.w		d1				; test the [2] key result
                            	   220: 	;BPL.s		push_start_mess		; if not pressed go do the "PUSH START" message
                            	   221: 
                            	   222: 							; else the two player start was pressed
00:0000ABEC 4BEB01F7        	   223: 	lea player_2(a3),a5		; set the pointer to player two's variables
00:0000ABF0 61000618        	   224: 	bsr reset_game				; clear the score and set the ship start count
00:0000ABF4 61000982        	   225: 	bsr player_init				; initialise the player variables
00:0000ABF8 610008D6        	   226: 	bsr make_rocks				; generate new rocks
00:0000ABFC 7002            	   227: 	moveq #2,d0						; set two players in this game
                            	   228: 
                            	   229: ; one or two player game start
                            	   230: 
                            	   231: start_game:
00:0000ABFE 1740001A        	   232: 	move.b d0,num_players(a3)	; save the number of players in the game
                            	   233: 
00:0000AC02 422B0018        	   234: 	clr.b player_idx(a3)			; clear the player index
00:0000AC06 4BEB00F3        	   235: 	lea	player_1(a3),a5				; set the pointer to player one's variables
00:0000AC0A 4DEB01F7        	   236: 	lea player_2(a3),a6				; set the pointer to player two's variables
                            	   237: 
00:0000AC0E 610005FA        	   238: 	bsr reset_game				; clear the scores and set the ship start count
00:0000AC12 61000964        	   239: 	bsr player_init				; initialise the player variables
00:0000AC16 610008B8        	   240: 	bsr make_rocks				; generate new rocks
                            	   241: 
00:0000AC1A 7000            	   242: 	moveq #0,d0						; clear the longword
00:0000AC1C 3B400080        	   243: 	move.w d0,score_off(a5)		; clear player 1's score
00:0000AC20 3D400080        	   244: 	move.w d0,score_off(a6)		; clear player 2's score
                            	   245: 
00:0000AC24 177C0080001C    	   246: 	move.b #$80,px_time(a3)		; set the "PLAYER x" timer
00:0000AC2A 177C00040024    	   247: 	move.b #$04,thump_time(a3)	; set the thump sound change timer
00:0000AC30 4E75            	   248: 	rts
                            	   249: 
                            	   250: ; else do the "PUSH START" message
                            	   251: 
                            	   252: push_start_mess:
00:0000AC32 102B0176        	   253: 	move.b p1_high(a3),d0			; get the player 1 highscore flag
00:0000AC36 C02B027A        	   254: 	and.b p2_high(a3),d0			; and with the player 2 highscore flag
00:0000AC3A 6A0C            	   255: 	bpl.s exit_push_start			; if either player is entering their high score
                            	   256: 														; skip the "PUSH START" message
                            	   257: 
00:0000AC3C 7206            	   258: 	moveq #$06,d1								; message 6 - "PUSH START"
00:0000AC3E 082B0005005A    	   259: 	btst.b #5,game_count+1(a3)	; test a bit in the game counter low byte
00:0000AC44 67001024        	   260: 	beq add_message							; if set add message d1 to the display list
                            	   261: 															; and return
                            	   262: exit_push_start
00:0000AC48 4E75            	   263: 	rts
                            	   264: 
                            	   265: ; do "GAME OVER" or thump sound count
                            	   266: 
                            	   267: game_over:
00:0000AC4A 703F            	   268: 	moveq #$3F,d0							; set the game counter mask
00:0000AC4C C06B0059        	   269: 	and.w game_count(a3),d0		; mask the game counter
00:0000AC50 660C            	   270: 	bne.s nodec_thmpi					; branch if not zero
                            	   271: 
                            	   272: 							; gets here 1/64th of the time
00:0000AC52 0C2D0006007C    	   273: 	cmpi.b #6,thmp_sndi(a5)		; compare the thump sound change timer initial
                            	   274: 							; value with the minimum value
00:0000AC58 6704            	   275: 	beq.s nodec_thmpi					; if there already don't decrement it
                            	   276: 
00:0000AC5A 532D007C        	   277: 	subq.b #1,thmp_sndi(a5)		; else decrement the thump sound change timer
                            	   278: 							; initial value
                            	   279: nodec_thmpi
00:0000AC5E 4A2D0082        	   280: 	tst.b ships_off(a5)			; test the player ship count
00:0000AC62 6624            	   281: 	bne.s no_game_over			; if ships left skip game over
                            	   282: 
                            	   283: 							; else this player has no ships left
00:0000AC64 102D002B        	   284: 	move.b p_fire_off(a5),d0		; get player fire 1
00:0000AC68 802D002C        	   285: 	or.b p_fire_off+1(a5),d0		; OR with player fire 2
00:0000AC6C 802D002D        	   286: 	or.b p_fire_off+2(a5),d0		; OR with player fire 3
00:0000AC70 802D002E        	   287: 	or.b p_fire_off+3(a5),d0		; OR with player fire 4
00:0000AC74 6612            	   288: 	bne.s no_game_over			; if shots still flying skip the game over
                            	   289: 
00:0000AC76 7207            	   290: 	moveq #7,d1							; else message 7 - "GAME OVER"
00:0000AC78 61000FF0        	   291: 	bsr add_message					; add message d1 to the display list
                            	   292: 
00:0000AC7C 0C2B0002001A    	   293: 	cmpi.b #$02,num_players(a3)	; compare the number of players with two
00:0000AC82 6604            	   294: 	bne.s no_game_over			; if not two player skip which game's over
                            	   295: 
00:0000AC84 61001052        	   296: 	bsr player_x						; add "PLAYER x" to the vector list
                            	   297: no_game_over
00:0000AC88 4A2D0027        	   298: 	tst.b p_flag_off(a5)		; test the player flag
00:0000AC8C 6638            	   299: 	bne.s	exit_game_message		; if alive or exploding just exit
                            	   300: 
00:0000AC8E 0C2D0080007A    	   301: 	cmpi.b #$80,hide_p_cnt(a5)	; compare with about to die - 1 with the hide
                            	   302: 							; the player count
00:0000AC94 6630            	   303: 	bne.s exit_game_message			; if not about to die just exit
                            	   304: 
00:0000AC96 1B7C0010007A    	   305: 	move.b #$10,hide_p_cnt(a5)	; set the hide the player count
                            	   306: 
00:0000AC9C 122B001A        	   307: 	move.b num_players(a3),d1	; get the number of players in the game
                            	   308: 
00:0000ACA0 102B0175        	   309: 	move.b p1_ships(a3),d0		; get player 1's ship count
00:0000ACA4 802B0279        	   310: 	or.b p2_ships(a3),d0			; OR with player 2's ship count
00:0000ACA8 671E            	   311: 	beq.s end_game					; if no ships left go end the game
                            	   312: 
00:0000ACAA 610006BA        	   313: 	bsr clear_saucer				; clear the saucer and restart the saucer timer
00:0000ACAE 5301            	   314: 	subq.b #1,d1						; decrement the number of players in the game
00:0000ACB0 6714            	   315: 	beq.s exit_game_message	; if that was the last player go flag no game
                            	   316: 							; and exit
                            	   317: 
00:0000ACB2 177C0080001C    	   318: 	move.b #$80,px_time(a3)		; set the "PLAYER x" timer
                            	   319: 
00:0000ACB8 4A2E0082        	   320: 	tst.b ships_off(a6)			; test the other player's ship count
00:0000ACBC 6708            	   321: 	beq.s exit_game_message		; if no ships left go flag no game and exit
                            	   322: 
                            	   323: 														; else change to the other player
00:0000ACBE 0A2B00010018    	   324: 	eori.b #1,player_idx(a3)		; toggle the player index
00:0000ACC4 CB4E            	   325: 	exg a5,a6									; swap the player pointers
                            	   326: exit_game_message
00:0000ACC6 4E75            	   327: 	rts
                            	   328: 
                            	   329: ; neither player has any ships left so end the game
                            	   330: 
                            	   331: end_game:
00:0000ACC8 17410019        	   332: 	move.b d1,past_play(a3)		; save the number of players that were in the
                            	   333: 							; game
00:0000ACCC 177C00FF001A    	   334: 	move.b #$FF,num_players(a3)	; clear the number of players in the game
00:0000ACD2 4BEB00F3        	   335: 	lea player_1(a3),a5		; set the pointer to player one's variables
00:0000ACD6 4DEB01F7        	   336: 	lea player_2(a3),a6		; set the pointer to player two's variables
00:0000ACDA 4E75            	   337: 	rts
                            	   338: 
                            	   339: 
                            	   340: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   341: ;
                            	   342: ; check for player/saucer/shot hits
                            	   343: 
                            	   344: check_hits:
00:0000ACDC 7C07            	   345: 	moveq #flag_end-p_flag_off-1,d6
                            	   346: 							; set the count/index for player/saucer/shots
                            	   347: pss_check_loop
00:0000ACDE 4A356027        	   348: 	tst.b p_flag_off(a5,d6.w)	; test if the player/saucer/shot exists
00:0000ACE2 6E06            	   349: 	bgt.s check_pss			; if the item exists and is not exploding go
                            	   350: 							; test it
                            	   351: 
                            	   352: next_pss
00:0000ACE4 51CEFFF8        	   353: 	dbf d6,pss_check_loop	; decrement count/index and loop if more to do
                            	   354: 
00:0000ACE8 4E75            	   355: 	rts
                            	   356: 
                            	   357: ; the player/saucer/shot exists and is not exploding
                            	   358: 
                            	   359: check_pss
00:0000ACEA 7E1C            	   360: 	moveq #s_flag_off-flags_off,d7
                            	   361: 							; set the item index to the saucer
00:0000ACEC 0C460004        	   362: 	cmpi.w #p_fire_off-p_flag_off,d6
                            	   363: 							; compare the player/saucer/shot index with the
                            	   364: 							; first player shot
00:0000ACF0 640A            	   365: 	bcc.s check_all			; if it is a player shot go test it against all
                            	   366: 							; the items
                            	   367: 
00:0000ACF2 5347            	   368: 	subq.w #1,d7				; else skip the saucer
00:0000ACF4 4A46            	   369: 	tst.w d6						; test the player/saucer/shot index
00:0000ACF6 6604            	   370: 	bne.s check_all			; if not the player go test against everything
                            	   371: 
                            	   372: 							; else skip the player
                            	   373: check_next_object
00:0000ACF8 5347            	   374: 	subq.w #1,d7				; decrement the item index
00:0000ACFA 6BE8            	   375: 	bmi.s next_pss			; if all done go do next player/saucer/shot
                            	   376: 
                            	   377: check_all
00:0000ACFC 1435700C        	   378: 	move.b flags_off(a5,d7.w),d2	; get the item flag indexed by d7
00:0000AD00 6FF6            	   379: 	ble.s	check_next_object		; if the item doesn't exist or the item is
                            	   380: 							; exploding go try the next item
                            	   381: 
00:0000AD02 3A07            	   382: 	move.w d7,d5				; copy the item index
00:0000AD04 DA45            	   383: 	add.w d5,d5					; *2 for the item position index
                            	   384: 
00:0000AD06 3806            	   385: 	move.w d6,d4				; copy the fire item index
00:0000AD08 D844            	   386: 	add.w	d4,d4					; * 2 for the fire item position index
                            	   387: 
00:0000AD0A 30355080        	   388: 	move.w x_pos_off(a5,d5.w),d0	; get item x position
00:0000AD0E 907540B6        	   389: 	sub.w p_xpos_off(a5,d4.w),d0	; subtract the player/saucer/shot x position
00:0000AD12 6A02            	   390: 	bpl.s delta_x_pos			; if the delta is positive skip the negate
                            	   391: 
00:0000AD14 4440            	   392: 	neg.w	d0						; else negate the delta
                            	   393: delta_x_pos
00:0000AD16 0C400151        	   394: 	CMPI.w	#$0151,d0			; compare the range with $0151
00:0000AD1A 64DC            	   395: 	BCC.s		check_next_object		; if it's out of range go try the next item
                            	   396: 
00:0000AD1C 323550C6        	   397: 	MOVE.w	y_pos_off(a5,d5.w),d1	; get item y position
00:0000AD20 927540FC        	   398: 	SUB.w		p_ypos_off(a5,d4.w),d1	; subtract the player/saucer/shot y position
00:0000AD24 6A02            	   399: 	BPL.s		delta_y_pos			; if the delta is positive skip the negate
                            	   400: 
00:0000AD26 4441            	   401: 	NEG.w		d1				; else negate the delta
                            	   402: delta_y_pos
00:0000AD28 0C410151        	   403: 	CMPI.w	#$0151,d1			; compare the range with $0151
00:0000AD2C 64CA            	   404: 	BCC.s		check_next_object		; if it's out of range go try the next item
                            	   405: 
00:0000AD2E C0C0            	   406: 	MULU.w	d0,d0				; calculate delta x^2
00:0000AD30 C2C1            	   407: 	MULU.w	d1,d1				; calculate delta y^2
00:0000AD32 D081            	   408: 	ADD.l		d1,d0				; calculate delta x^2 + delta y^2
00:0000AD34 E480            	   409: 	ASR.l		#2,d0				; / 4 makes it a word value again
                            	   410: 
00:0000AD36 02420007        	   411: 	ANDI.w	#$07,d2			; mask the size bits
00:0000AD3A 5302            	   412: 	SUBQ.b	#1,d2				; make $01 to $04 into $00 to $03
00:0000AD3C D402            	   413: 	ADD.b		d2,d2				; ; 2 bytes per size^2
                            	   414: 
00:0000AD3E 0C460001        	   415: 	CMPI.w	#s_flag_off-p_flag_off,d6
                            	   416: 							; compare the player/saucer/shot index with the
                            	   417: 							; saucer
00:0000AD42 6E10            	   418: 	BGT.s		no_add_size			; if shot index just go get the collision size
                            	   419: 
00:0000AD44 6B0C            	   420: 	BMI.s		add_p_size			; if player index only add the player offset
                            	   421: 
00:0000AD46 083500016027    	   422: 	BTST.b	#1,p_flag_off(a5,d6.w)	; else test the saucer size flag
00:0000AD4C 6702            	   423: 	BEQ.s		small_s_size		; if not size $02 only add the small saucer size
                            	   424: 
00:0000AD4E 5042            	   425: 	ADDQ.w	#col_table_l-col_table_s,d2
                            	   426: 							; add the offset to the item + large saucer size
                            	   427: 							; table
                            	   428: small_s_size
00:0000AD50 5042            	   429: 	ADDQ.w	#col_table_s-col_table_p,d2
                            	   430: 							; add the offset to the item + small saucer size
                            	   431: 							; table
                            	   432: add_p_size
00:0000AD52 5042            	   433: 	ADDQ.w	#col_table_p-col_table,d2
                            	   434: 							; add the offset to the item + player size table
                            	   435: no_add_size
00:0000AD54 343B200C        	   436: 	MOVE.w	col_table(pc,d2.w),d2	; get the collision size from the table
                            	   437: 
00:0000AD58 B440            	   438: 	CMP.w		d0,d2				; compare the distance^2 with the collision size
00:0000AD5A 659C            	   439: 	BCS.s		check_next_object		; if it's out of range go try the next item
                            	   440: 
00:0000AD5C 487AFF86        	   441: 	PEA		next_pss(pc)		; now go try the next fire item, this one died
00:0000AD60 6020            	   442: 	BRA.s		handle_collision		; else go handle a collision between items
                            	   443: 
                            	   444: ; table of collision distance squares
                            	   445: 
                            	   446: col_table
00:0000AD62 06E4            	   447: 	dc.w	$06E4			; $24^2		small rock, small saucer, player
00:0000AD64 1440            	   448: 	dc.w	$1440			; $48^2		medium rock, large saucer
00:0000AD66 0000            	   449: 	dc.w	$0000			; no size 3 rock
00:0000AD68 4410            	   450: 	dc.w	$4410			; $84^2		large rock
                            	   451: col_table_p
00:0000AD6A 1000            	   452: 	dc.w	$1000			; ($24 + $1C)^2	small rock  + player
00:0000AD6C 2710            	   453: 	dc.w	$2710			; ($48 + $1C)^2	medium rock + player
00:0000AD6E 0000            	   454: 	dc.w	$0000			; no size 3 rock
00:0000AD70 6400            	   455: 	dc.w	$6400			; ($84 + $1C)^2	large rock  + player
                            	   456: col_table_s
00:0000AD72 0B64            	   457: 	dc.w	$0B64			; ($24 + $12)^2	small rock  + small saucer
00:0000AD74 1FA4            	   458: 	dc.w	$1FA4			; ($48 + $12)^2	medium rock + small saucer
00:0000AD76 0000            	   459: 	dc.w	$0000			; no size 3 rock
00:0000AD78 57E4            	   460: 	dc.w	$57E4			; ($84 + $12)^2	large rock  + small saucer
                            	   461: col_table_l
00:0000AD7A 1440            	   462: 	dc.w	$1440			; ($24 + $24)^2	small rock  + large saucer
00:0000AD7C 2D90            	   463: 	dc.w	$2D90			; ($48 + $24)^2	medium rock + large saucer
00:0000AD7E 0000            	   464: 	dc.w	$0000			; no size 3 rock
00:0000AD80 6E40            	   465: 	dc.w	$6E40			; ($84 + $24)^2	large rock  + large saucer
                            	   466: 
                            	   467: 
                            	   468: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   469: ;
                            	   470: ; handle collision between items
                            	   471: ;
                            	   472: ; d6 = X = player/saucer/shot index
                            	   473: ; d7 = Y = object index
                            	   474: 
                            	   475: handle_collision:
00:0000AD82 0C460001        	   476: 	CMPI.w	#s_flag_off-p_flag_off,d6
                            	   477: 							; compare the player/saucer/shot index with the
                            	   478: 							; saucer
00:0000AD86 660A            	   479: 	BNE.s		not_saucer			; if not the saucer go find out what it was
                            	   480: 
                            	   481: 							; else the saucer hit something
00:0000AD88 0C47001B        	   482: 	CMPI.w	#p_flag_off-flags_off,d7
                            	   483: 							; compare the object with the player index
00:0000AD8C 6612            	   484: 	BNE.s		not_player			; if not the player go find out what it was
                            	   485: 
                            	   486: 							; else the saucer hit the player so make it that
                            	   487: 							; the player hit the saucer
00:0000AD8E 7E1C            	   488: 	MOVEQ		#s_flag_off-flags_off,d7
                            	   489: 							; make the object the saucer
00:0000AD90 7C00            	   490: 	MOVEQ		#p_flag_off-p_flag_off,d6
                            	   491: 							; make the player/saucer/shot index the player
                            	   492: not_saucer
00:0000AD92 4A46            	   493: 	TST.w		d6				; test the player/saucer/shot index
00:0000AD94 6622            	   494: 	BNE.s		not_pss_player		; if it's not the player go find out what it was
                            	   495: 
                            	   496: ; the player hit something
                            	   497: 
00:0000AD96 1B7C0081007A    	   498: 	MOVE.b	#$81,hide_p_cnt(a5)	; set the hide the player count
00:0000AD9C 532D0082        	   499: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
                            	   500: 
                            	   501: ; either the player hit the saucer or the player or saucer hit either a rock or a shot
                            	   502: 
                            	   503: not_player
00:0000ADA0 1BBC00A06027    	   504: 	MOVE.b	#$A0,p_flag_off(a5,d6.w)
                            	   505: 							; set the item is exploding flag
00:0000ADA6 7000            	   506: 	MOVEQ		#0,d0				; clear the longword
00:0000ADA8 1B80604A        	   507: 	MOVE.b	d0,p_xvel_off(a5,d6.w)	; clear the player/saucer/shot x velocity
00:0000ADAC 1B80606D        	   508: 	MOVE.b	d0,p_yvel_off(a5,d6.w)	; clear the player/saucer/shot y velocity
00:0000ADB0 0C47001B        	   509: 	CMPI.w	#p_flag_off-flags_off,d7
                            	   510: 							; compare the object with the player index
00:0000ADB4 650E            	   511: 	BCS.s		what_hit_rock		; if less go handle something hitting a rock
                            	   512: 
00:0000ADB6 6038            	   513: 	BRA.s		what_hit_saucer		; else go handle something hitting the saucer
                            	   514: 
                            	   515: ; else a shot hit something
                            	   516: 
                            	   517: not_pss_player
00:0000ADB8 42356027        	   518: 	CLR.b		p_flag_off(a5,d6.w)	; clear the shot object
00:0000ADBC 0C07001B        	   519: 	CMPI.b	#p_flag_off-flags_off,d7
                            	   520: 							; compare the item with the player's index
00:0000ADC0 6722            	   521: 	BEQ.s		player_shot			; if it's the player go handle a shot hitting
                            	   522: 							; the player
                            	   523: 
00:0000ADC2 642C            	   524: 	BCC.s		what_hit_saucer		; if it's the saucer go handle a shot hitting
                            	   525: 							; the saucer
                            	   526: 
                            	   527: what_hit_rock
00:0000ADC4 61000C40        	   528: 	BSR		hit_a_rock			; handle something hitting a rock
                            	   529: 
                            	   530: ; explode the object
                            	   531: 
                            	   532: explode_object
00:0000ADC8 7203            	   533: 	MOVEQ		#$03,d1			; set the mask for the two size bits
00:0000ADCA C235700C        	   534: 	AND.b		flags_off(a5,d7.w),d1	; and it with the item flag
00:0000ADCE 5A01            	   535: 	ADDQ.b	#sexpl_snd,d1		; add the small explosion sound to the size
00:0000ADD0 61002B8C        	   536: 	BSR		play_sample			; go play the sample
                            	   537: 
00:0000ADD4 1BBC00A0700C    	   538: 	MOVE.b	#$A0,flags_off(a5,d7.w)	; set the item to exploding
00:0000ADDA 4235702F        	   539: 	CLR.b		x_vel_off(a5,d7.w)	; clear the item x velocity byte
00:0000ADDE 42357052        	   540: 	CLR.b		y_vel_off(a5,d7.w)	; clear the item y velocity byte
00:0000ADE2 4E75            	   541: 	RTS
                            	   542: 
                            	   543: ; handle a shot hitting the player
                            	   544: 
                            	   545: player_shot
00:0000ADE4 532D0082        	   546: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
00:0000ADE8 1B7C0081007A    	   547: 	MOVE.b	#$81,hide_p_cnt(a5)	; set the hide the player count
00:0000ADEE 60D8            	   548: 	BRA.s		explode_object		; go explode the player
                            	   549: 
                            	   550: ; handle something hitting the saucer
                            	   551: 
                            	   552: what_hit_saucer
00:0000ADF0 1B6D00780077    	   553: 	MOVE.b	i_sauc_tim(a5),sauc_cntdn(a5)
                            	   554: 							; save the small saucer boundary/initial saucer
                            	   555: 							; value to the saucer countdown timer
00:0000ADF6 4A2B001A        	   556: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000ADFA 67CC            	   557: 	BEQ.s		explode_object		; if no players skip adding the score
                            	   558: 
00:0000ADFC 7299            	   559: 	MOVEQ		#$99,d1			; default to 990 points for a small saucer
00:0000ADFE 082D00000028    	   560: 	BTST.b	#0,s_flag_off(a5)		; test the saucer size bit
00:0000AE04 6602            	   561: 	BNE.s		keep_small			; if it was a small saucer keep the score value
                            	   562: 
00:0000AE06 7220            	   563: 	MOVEQ		#$20,d1			; else set 200 points for the large saucer
                            	   564: keep_small
00:0000AE08 6100099C        	   565: 	BSR		add_score			; add d1 to the current player's score
00:0000AE0C 60BA            	   566: 	BRA.s		explode_object		; go explode the saucer
                            	   567: 
                            	   568: 
                            	   569: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   570: ;
                            	   571: ; handle the saucer
                            	   572: 
                            	   573: do_saucer
00:0000AE0E 70FC            	   574: 	MOVEQ		#-4,d0			; set the timeout counter mask
00:0000AE10 C02B0025        	   575: 	AND.b		time_count(a3),d0		; mask the timeout counter
00:0000AE14 670000B0        	   576: 	BEQ		exit_do_saucer		; 3/4 of the time just exit
                            	   577: 
00:0000AE18 B12B0025        	   578: 	EOR.b		d0,time_count(a3)		; reset the timeout counter
                            	   579: 
00:0000AE1C 4A2D0028        	   580: 	TST.b		s_flag_off(a5)		; test the saucer flag
00:0000AE20 6B0000A4        	   581: 	BMI		exit_do_saucer		; if the saucer is exploding just exit
                            	   582: 
00:0000AE24 660000A2        	   583: 	BNE		existing_saucer		; if a saucer exists go handle it
                            	   584: 
                            	   585: ; no saucer exists so possibly generate a new one
                            	   586: 
00:0000AE28 4A2B001A        	   587: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000AE2C 670C            	   588: 	BEQ.s		attract_saucer		; if no players go do the attract mode saucer
                            	   589: 
00:0000AE2E 4A2D0027        	   590: 	TST.b		p_flag_off(a5)		; test the player flag
00:0000AE32 67000092        	   591: 	BEQ		exit_do_saucer		; if this player doesn't exist just exit
                            	   592: 
00:0000AE36 6B00008E        	   593: 	BMI		exit_do_saucer		; if this player is exploding just exit
                            	   594: 
                            	   595: attract_saucer
00:0000AE3A 4A2D0079        	   596: 	TST.b		r_hit_tim(a5)		; test the rock hit timer
00:0000AE3E 6704            	   597: 	BEQ.s		rock_hit_out		; if counted out skip the decrement
                            	   598: 
00:0000AE40 532D0079        	   599: 	SUBQ.b	#1,r_hit_tim(a5)		; else decrement the rock hit timer
                            	   600: rock_hit_out
00:0000AE44 532D0077        	   601: 	SUBQ.b	#1,sauc_cntdn(a5)		; decrement the saucer countdown timer
00:0000AE48 667C            	   602: 	BNE		exit_do_saucer		; if not there yet just exit
                            	   603: 
00:0000AE4A 1B7C00120077    	   604: 	MOVE.b	#$12,sauc_cntdn(a5)	; set the first saucer fire count
                            	   605: 
00:0000AE50 4A2D0079        	   606: 	TST.b		r_hit_tim(a5)		; test the rock hit timer
00:0000AE54 670C            	   607: 	BEQ.s		dec_isaucer_time		; if timed out go decrement the initial saucer
                            	   608: 							; timer
                            	   609: 
00:0000AE56 102D0076        	   610: 	MOVE.b	rock_count(a5),d0		; get the rock count
00:0000AE5A 676A            	   611: 	BEQ.s		exit_do_saucer		; if no rocks just exit
                            	   612: 
00:0000AE5C B02D007D        	   613: 	CMP.b		min_rocks(a5),d0		; compare the rock count with the minimum rock
                            	   614: 							; count before the saucer initial timer starts
                            	   615: 							; to decrement
00:0000AE60 6364            	   616: 	BLS.s		exit_do_saucer		; if the minimum rock count is >= the rock count
                            	   617: 							; just exit
                            	   618: 
                            	   619: dec_isaucer_time
00:0000AE62 70FA            	   620: 	MOVEQ		#-6,d0			; set to subtract 6
00:0000AE64 D02D0078        	   621: 	ADD.b		i_sauc_tim(a5),d0		; subtract it from the small saucer
                            	   622: 							; boundary/initial saucer timer
00:0000AE68 0C000020        	   623: 	CMPI.b	#$20,d0			; compare it with the minimum value
00:0000AE6C 6504            	   624: 	BCS.s		no_save_ist			; if less skip the save
                            	   625: 
00:0000AE6E 1B400078        	   626: 	MOVE.b	d0,i_sauc_tim(a5)		; save the small saucer boundary/initial saucer
                            	   627: 							; timer
                            	   628: no_save_ist
00:0000AE72 61000F5E        	   629: 	BSR		gen_prng			; generate the next pseudo random number
00:0000AE76 302B000A        	   630: 	MOVE.w	PRNlword(a3),d0		; get a pseudo random word
00:0000AE7A 0C401800        	   631: 	CMPI.w	#$1800,d0			; compare with $1800
00:0000AE7E 6504            	   632: 	BCS.s		saucer_yok			; if less than $1800 just use it
                            	   633: 
00:0000AE80 024017FF        	   634: 	ANDI.w	#$17FF,d0			; else mask to $17xx
                            	   635: saucer_yok
00:0000AE84 3B40FFFE        	   636: 	MOVE.w	d0,s_ypos_off(a5)		; save the saucer y position
                            	   637: 
00:0000AE88 7000            	   638: 	MOVEQ		#0,d0				; clear the saucer x position
00:0000AE8A 7210            	   639: 	MOVEQ		#$10,d1			; set the saucer x velocity to + $10
00:0000AE8C 4A6B000C        	   640: 	TST.w		PRNlword+2(a3)		; test a pseudo random word
00:0000AE90 6B06            	   641: 	BMI.s		start_left			; if bit set start on the left
                            	   642: 
                            	   643: 							; else start at the right side and move left
00:0000AE92 303C1FFF        	   644: 	MOVE.w	#$1FFF,d0			; set the saucer x position
00:0000AE96 72F0            	   645: 	MOVEQ		#$F0,d1			; set the saucer x velocity to - $10
                            	   646: start_left
00:0000AE98 1B41004B        	   647: 	MOVE.b	d1,s_xvel_off(a5)		; save the saucer x velocity byte
00:0000AE9C 3B40FFB8        	   648: 	MOVE.w	d0,s_xpos_off(a5)		; save the saucer x position
                            	   649: 
00:0000AEA0 7202            	   650: 	MOVEQ		#$02,d1			; default to a large saucer
00:0000AEA2 4A2D0078        	   651: 	TST.b		i_sauc_tim(a5)		; test the small saucer boundary/initial saucer
                            	   652: 							; timer
00:0000AEA6 6B1A            	   653: 	BMI.s		save_saucer			; if > $80 always make a big saucer
                            	   654: 
00:0000AEA8 0C2D00300080    	   655: 	CMPI.b	#$30,score_off(a5)	; compare the player's score with 30000 points
00:0000AEAE 6410            	   656: 	BCC.s		small_saucer		; if >= 30000 points go make a small saucer
                            	   657: 
00:0000AEB0 61000F20        	   658: 	BSR		gen_prng			; generate the next pseudo random number
00:0000AEB4 142D0078        	   659: 	MOVE.b	i_sauc_tim(a5),d2		; get the small saucer boundary/initial saucer
                            	   660: 							; timer
00:0000AEB8 E20A            	   661: 	LSR.b		#1,d2				; / 2
00:0000AEBA B42B000C        	   662: 	CMP.b		PRNlword+2(a3),d2		; compare it with the random byte
00:0000AEBE 6402            	   663: 	BCC.s		save_saucer			; if the small saucer boundary is > the random
                            	   664: 							; byte go save the large saucer
                            	   665: 
                            	   666: small_saucer
00:0000AEC0 7201            	   667: 	MOVEQ		#$01,d1			; else make it a small saucer
                            	   668: save_saucer
00:0000AEC2 1B410028        	   669: 	MOVE.b	d1,s_flag_off(a5)		; save the saucer flag
                            	   670: exit_do_saucer
00:0000AEC6 4E75            	   671: 	RTS
                            	   672: 
                            	   673: ; there is an existing saucer
                            	   674: 
                            	   675: existing_saucer
00:0000AEC8 707E            	   676: 	MOVEQ		#$7E,d0			; set saucer change mask
00:0000AECA C06B0059        	   677: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000AECE 6610            	   678: 	BNE.s		keep_saucer_dir		; if it was not x000 000x skip the saucer
                            	   679: 							; direction change
                            	   680: 
00:0000AED0 61000F00        	   681: 	BSR		gen_prng			; generate the next pseudo random number
00:0000AED4 7003            	   682: 	MOVEQ		#3,d0				; set the direction mask
00:0000AED6 C02B000A        	   683: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000AEDA 1B7B0018006E    	   684: 	MOVE.b	saucer_yvel(pc,d0.w),s_yvel_off(a5)
                            	   685: 							; save the saucer y velocity byte
                            	   686: keep_saucer_dir
00:0000AEE0 4A2B001A        	   687: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000AEE4 6706            	   688: 	BEQ.s		attract_fire		; if no players just go do the fire countdown
                            	   689: 
00:0000AEE6 4A2D007A        	   690: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:0000AEEA 6606            	   691: 	BNE.s		exit_existing_saucer	; if the player is hidden just exit
                            	   692: 
                            	   693: attract_fire
00:0000AEEC 532D0077        	   694: 	SUBQ.b	#1,sauc_cntdn(a5)		; decrement the saucer countdown timer
00:0000AEF0 6706            	   695: 	BEQ.s		fire_saucer			; if counted out go fire
                            	   696: 
                            	   697: exit_existing_saucer
00:0000AEF2 4E75            	   698: 	RTS
                            	   699: 
                            	   700: ; saucer y velocity byte
                            	   701: 
                            	   702: saucer_yvel
00:0000AEF4 F0              	   703: 	dc.b	$F0			; down
00:0000AEF5 00              	   704: 	dc.b	$00			; horizontal
00:0000AEF6 00              	   705: 	dc.b	$00			; horizontal
00:0000AEF7 10              	   706: 	dc.b	$10			; up
                            	   707: 
                            	   708: 
                            	   709: ; handle the saucer fire
                            	   710: 
                            	   711: fire_saucer
00:0000AEF8 1B7C000A0077    	   712: 	MOVE.b	#$0A,sauc_cntdn(a5)	; set the time between saucer shots, save the
                            	   713: 							; countdown timer
00:0000AEFE 7001            	   714: 	MOVEQ		#1,d0				; set the mask for a small saucer
00:0000AF00 C02D0028        	   715: 	AND.b		s_flag_off(a5),d0		; mask the saucer flag
00:0000AF04 660A            	   716: 	BNE.s		aim_shot			; if it's a small saucer go aim at the player
                            	   717: 
00:0000AF06 61000ECA        	   718: 	BSR		gen_prng			; generate the next pseudo random number
00:0000AF0A 102B000A        	   719: 	MOVE.b	PRNlword(a3),d0		; get a pseudo random byte
00:0000AF0E 6056            	   720: 	BRA.s		no_aim_shot			; and go fire wildly in any direction
                            	   721: 
                            	   722: ; aim the shot at the player
                            	   723: 
                            	   724: aim_shot
00:0000AF10 1F2D004B        	   725: 	MOVE.b	s_xvel_off(a5),-(sp)	; copy the saucer x velocity byte
00:0000AF14 301F            	   726: 	MOVE.w	(sp)+,d0			; get the byte as a word
00:0000AF16 4200            	   727: 	CLR.b		d0				; clear the low byte
00:0000AF18 E240            	   728: 	ASR.w		#1,d0				; / 2
                            	   729: 
00:0000AF1A 322DFFB6        	   730: 	MOVE.w	p_xpos_off(a5),d1		; get the player x position
00:0000AF1E 926DFFB8        	   731: 	SUB.w		s_xpos_off(a5),d1		; subtract the saucer x position
00:0000AF22 E541            	   732: 	ASL.w		#2,d1				; ; 4 delta x
                            	   733: 
00:0000AF24 9240            	   734: 	SUB.w		d0,d1				; subtract the half saucer x velocity word
                            	   735: 
00:0000AF26 1F2D006E        	   736: 	MOVE.b	s_yvel_off(a5),-(sp)	; copy the saucer y velocity byte
00:0000AF2A 301F            	   737: 	MOVE.w	(sp)+,d0			; get the byte as a word
00:0000AF2C 4200            	   738: 	CLR.b		d0				; clear the low byte
00:0000AF2E E240            	   739: 	ASR.w		#1,d0				; / 2
                            	   740: 
00:0000AF30 342DFFFC        	   741: 	MOVE.w	p_ypos_off(a5),d2		; get the player y position
00:0000AF34 946DFFFE        	   742: 	SUB.w		s_ypos_off(a5),d2		; subtract the saucer y position
00:0000AF38 E542            	   743: 	ASL.w		#2,d2				; ; 4 delta x low byte
                            	   744: 
00:0000AF3A 9440            	   745: 	SUB.w		d0,d2				; subtract the half saucer y velocity word
                            	   746: 
00:0000AF3C 61000BE4        	   747: 	BSR		get_atn			; calculate the angle given the delta x,y in
                            	   748: 							; d1.w,d2.w
00:0000AF40 1740001F        	   749: 	MOVE.b	d0,s_orient(a3)		; save the saucer shot direction
                            	   750: 
00:0000AF44 61000E8C        	   751: 	BSR		gen_prng			; generate the next pseudo random number
00:0000AF48 7200            	   752: 	MOVEQ		#0,d1				; set index to +/- $0F degree units perturbation
00:0000AF4A 102B000A        	   753: 	MOVE.b	PRNlword(a3),d0		; get a pseudo random byte
00:0000AF4E 0C2D00350080    	   754: 	CMPI.b	#$35,score_off(a5)	; compare the player's score with 35000
00:0000AF54 6502            	   755: 	BCS.s		wide_shot			; if less than 35000 skip the index change
                            	   756: 
00:0000AF56 7201            	   757: 	MOVEQ		#1,d1				; set index to +/- $07 degree units perturbation
                            	   758: wide_shot
00:0000AF58 C03B101E        	   759: 	AND.b		shot_mask(pc,d1.w),d0	; mask with the shot AND mask
00:0000AF5C 6A04            	   760: 	BPL.s		no_shot_or			; if the result is positive skip the bit set
                            	   761: 
00:0000AF5E 803B101A        	   762: 	OR.b		shot_or(pc,d1.w),d0	; else set the correct bits for a negative
                            	   763: 							; perturbation
                            	   764: no_shot_or
00:0000AF62 D02B001F        	   765: 	ADD.b		s_orient(a3),d0		; add the saucer shot direction to the
                            	   766: 							; perturbation
                            	   767: no_aim_shot
00:0000AF66 1740001F        	   768: 	MOVE.b	d0,s_orient(a3)		; save the saucer shot direction
                            	   769: 
00:0000AF6A 7801            	   770: 	MOVEQ		#1,d4				; set the index to the saucer velocity
00:0000AF6C 7A02            	   771: 	MOVEQ		#2,d5				; set the index to the saucer position
00:0000AF6E 7CFF            	   772: 	MOVEQ		#-1,d6			; set the minimum shot index - 1
00:0000AF70 7E01            	   773: 	MOVEQ		#1,d7				; set the shot start index
                            	   774: 
00:0000AF72 122B0021        	   775: 	MOVE.b	last_fire(a3),d1		; get the fire last state
00:0000AF76 6022            	   776: 	BRA.s		test_fire_loop		; go fire the shot
                            	   777: 
                            	   778: 
                            	   779: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   780: ;
                            	   781: ; these two byte pairs together effect the accuracy of the small saucer's shooting
                            	   782: ; by limiting the range of the random perturbation to the saucer's aim
                            	   783: 
                            	   784: ; shot AND mask, masks the perturbation to either +/- $0F or +/- $07 degree units
                            	   785: 
                            	   786: shot_mask
00:0000AF78 8F              	   787: 	dc.b	$8F			; AND mask to +/- $0F degree units
00:0000AF79 87              	   788: 	dc.b	$87			; AND mask to +/- $07 degree units
                            	   789: 
                            	   790: ; shot OR byte, sets the needed bits for a negative perturbation result
                            	   791: 
                            	   792: shot_or
00:0000AF7A 70              	   793: 	dc.b	$70			; OR to set bits after - $0F mask result
00:0000AF7B 78              	   794: 	dc.b	$78			; OR to set bits after - $07 mask result
                            	   795: 
                            	   796: 
                            	   797: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   798: ;
                            	   799: ; handle the fire button
                            	   800: 
                            	   801: ship_fire:
                            	   802: ;##	TST.b		num_players(a3)		; test the number of players in the game
                            	   803: ;##	BEQ.s		exit_ship_fire		; if no players just exit
                            	   804: 
                            	   805: ;##	TST.b		hide_p_cnt(a5)		; test the hide the player count
                            	   806: ;##	BNE.s		exit_ship_fire		; if the player is hidden just exit
                            	   807: 
                            	   808: ;	MOVEQ		#'P',d1			; [P] key
                            	   809: ;	MOVEQ		#19,d0			; check for keypress
                            	   810: ;	TRAP		#15
                            	   811: 
00:0000AF7C 7005            	   812: 	moveq #5,d0					; getkey
00:0000AF7E 4E4F            	   813: 	trap #15
00:0000AF80 0C010050        	   814: 	cmpi.b #'P',d1
00:0000AF84 6620            	   815: 	bne.s save_ship_fire
                            	   816: 
                            	   817: ;	TST.b		d1				; test the result
                            	   818: ;	BEQ.s		save_ship_fire		; if fire not pressed go clear the fire state
                            	   819: 							; and exit
                            	   820: 
00:0000AF86 4A2B0021        	   821: 	tst.b last_fire(a3)		; test the fire last state
00:0000AF8A 661E            	   822: 	bne.s exit_ship_fire	; if the fire button is held just exit
                            	   823: 
00:0000AF8C 7800            	   824: 	moveq #0,d4					; set the index to the player velocity
00:0000AF8E 7A00            	   825: 	moveq #0,d5					; set the index to the player position
00:0000AF90 7C01            	   826: 	moveq #1,d6					; set the minimum shot index - 1
00:0000AF92 7E05            	   827: 	moveq #5,d7					; set the shot start index
                            	   828: 
00:0000AF94 176B001E001F    	   829: 	move.b p_orient(a3),s_orient(a3)
                            	   830: 							; copy the player orientation
                            	   831: 
                            	   832: ; fire the shot, player or saucer
                            	   833: 
                            	   834: test_fire_loop
00:0000AF9A 4A357029        	   835: 	tst.b s_fire_off(a5,d7.w)	; test this fire object
00:0000AF9E 670C            	   836: 	beq.s fire_shot			; if this shot is free go use it
                            	   837: 
00:0000AFA0 5347            	   838: 	subq.w #1,d7				; decrement the shot index
00:0000AFA2 BC47            	   839: 	cmp.w d7,d6					; compare with minimum - 1 index
00:0000AFA4 66F4            	   840: 	bne.s test_fire_loop		; loop if more to do
                            	   841: 
                            	   842: save_ship_fire
00:0000AFA6 17410021        	   843: 	move.b d1,last_fire(a3)		; save the fire last state
                            	   844: exit_ship_fire
00:0000AFAA 4E75            	   845: 	rts
                            	   846: 
                            	   847: ; player/saucer fired and a shot, indexed by d7, is free
                            	   848: 
                            	   849: fire_shot:
00:0000AFAC 3C07            	   850: 	move.w d7,d6				; copy the item index
00:0000AFAE DC46            	   851: 	add.w d6,d6					; 2 for position index
                            	   852: 
00:0000AFB0 1BBC00127029    	   853: 	MOVE.b	#$12,s_fire_off(a5,d7.w)
                            	   854: 							; set the fire item flag
                            	   855: 
00:0000AFB6 102B001F        	   856: 	MOVE.b	s_orient(a3),d0		; get the player/saucer orientation
00:0000AFBA 61000C0E        	   857: 	BSR		cos_d0			; do COS(d0)
                            	   858: 
00:0000AFBE 1635404A        	   859: 	MOVE.b	p_xvel_off(a5,d4.w),d3	; get the player/saucer x velocity byte
00:0000AFC2 613A            	   860: 	BSR.s		calc_fire_byte		; test the fire velocity and make 3/4 sin/cos
00:0000AFC4 1B83704C        	   861: 	MOVE.b	d3,f_xvel_off(a5,d7.w)	; save the shot x velocity byte
                            	   862: 
00:0000AFC8 D07550B6        	   863: 	ADD.w		p_xpos_off(a5,d5.w),d0	; add the player/saucer x position
00:0000AFCC 3B8060BA        	   864: 	MOVE.w	d0,f_xpos_off(a5,d6.w)	; save the shot x position
                            	   865: 
00:0000AFD0 102B001F        	   866: 	MOVE.b	s_orient(a3),d0		; get the player/saucer orientation
00:0000AFD4 61000BF8        	   867: 	BSR		sin_d0			; do SIN(d0)
                            	   868: 
00:0000AFD8 1635406D        	   869: 	MOVE.b	p_yvel_off(a5,d4.w),d3	; get the player/saucer y velocity byte
00:0000AFDC 6120            	   870: 	BSR		calc_fire_byte		; test the fire velocity and make 3/4 sin/cos
00:0000AFDE 1B83706F        	   871: 	MOVE.b	d3,f_yvel_off(a5,d7.w)	; save the shot y velocity byte
                            	   872: 
00:0000AFE2 D07550FC        	   873: 	ADD.w		p_ypos_off(a5,d5.w),d0	; add the player/saucer y position
00:0000AFE6 3B806000        	   874: 	MOVE.w	d0,f_ypos_off(a5,d6.w)	; save the shot y position
                            	   875: 
00:0000AFEA 17410021        	   876: 	MOVE.b	d1,last_fire(a3)		; save the fire last state
                            	   877: 
00:0000AFEE 7201            	   878: 	MOVEQ		#pfire_snd,d1		; default to the player fire sound
00:0000AFF0 0C470002        	   879: 	CMPI.w	#2,d7				; compare the index with the lowest player fire
00:0000AFF4 64002968        	   880: 	BCC		play_sample			; if it was the player go play the sample and
                            	   881: 							; return
                            	   882: 
                            	   883: 							; else it must be the saucer that fired so
00:0000AFF8 7200            	   884: 	MOVEQ		#sfire_snd,d1		; set the saucer fire sound
00:0000AFFA 60002962        	   885: 	BRA		play_sample			; play the sample and return
                            	   886: 
                            	   887: 
                            	   888: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   889: ;
                            	   890: ; test the fire velocity and make 3/4 sin/cos
                            	   891: 
                            	   892: calc_fire_byte
00:0000AFFE E240            	   893: 	ASR.w		#1,d0				; / 2
                            	   894: 
00:0000B000 3F00            	   895: 	MOVE.w	d0,-(sp)			; push the word value
00:0000B002 101F            	   896: 	MOVE.b	(sp)+,d0			; pop it as a byte value
                            	   897: 
00:0000B004 D600            	   898: 	ADD.b		d0,d3				; add it to the COS / 2 value
00:0000B006 6B0A            	   899: 	BMI.s		test_neg_fire		; if negative go test the negative limit
                            	   900: 
00:0000B008 0C030070        	   901: 	CMPI.b	#$70,d3			; else compare it with the positive limit
00:0000B00C 650C            	   902: 	BCS.s		fire_ok			; if < the positive limit skip the adjust
                            	   903: 
00:0000B00E 766F            	   904: 	MOVEQ		#$6F,d3			; else set the value to the positive limit
00:0000B010 6008            	   905: 	BRA.s		fire_ok			; go save the shot x velocity
                            	   906: 
                            	   907: test_neg_fire
00:0000B012 0C030091        	   908: 	CMPI.b	#$91,d3			; compare it with the negative limit
00:0000B016 6402            	   909: 	BCC.s		fire_ok			; if < the negative limit skip the adjust
                            	   910: 
00:0000B018 7691            	   911: 	MOVEQ		#$91,d3			; else set the value to the negative limit
                            	   912: fire_ok
00:0000B01A 4880            	   913: 	EXT.w		d0				; make the byte value into a word
                            	   914: 
00:0000B01C 3400            	   915: 	MOVE.w	d0,d2				; get the COS / 2 back
00:0000B01E E242            	   916: 	ASR.w		#1,d2				; / 4
00:0000B020 D142            	   917: 	ADDX.w	d2,d0				; make 3 / 4 COS and round up
                            	   918: 
00:0000B022 4E75            	   919: 	RTS
                            	   920: 
                            	   921: 
                            	   922: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   923: ;
                            	   924: ; get the player high score entries
                            	   925: 
                            	   926: enter_hiscores
00:0000B024 102D0083        	   927: 	MOVE.b	high_off(a5),d0		; get the player 1 highscore flag
00:0000B028 C02E0083        	   928: 	AND.b		high_off(a6),d0		; and with the player 2 highscore flag
00:0000B02C 6B00014A        	   929: 	BMI		exit_enter_hiscores	; if neither player is entering their high
                            	   930: 							; score just exit
                            	   931: 
00:0000B030 102D0083        	   932: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:0000B034 6B000088        	   933: 	BMI		next_p_high			; if this player isn't entering their high
                            	   934: 							; score go try the other player
                            	   935: 
                            	   936: 							; get a player high score entry
00:0000B038 0C2B00010019    	   937: 	CMPI.b	#1,past_play(a3)		; compare 1 with the number of players that
                            	   938: 							; were in the game
00:0000B03E 6712            	   939: 	BEQ.s		no_playerx			; if it was only 1 player skip the "PLAYER x"
                            	   940: 							; message
                            	   941: 
00:0000B040 7201            	   942: 	MOVEQ		#1,d1				; message 1 - "PLAYER "
00:0000B042 61000C26        	   943: 	BSR		add_message			; add message d1 to the display list
                            	   944: 
00:0000B046 7010            	   945: 	MOVEQ		#$10,d0			; set game counter mask
00:0000B048 C06B0059        	   946: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000B04C 6604            	   947: 	BNE.s		no_playerx			; if bit set skip the player number write
                            	   948: 
00:0000B04E 61000C8C        	   949: 	BSR		player_n			; add the player number to the vector list
                            	   950: no_playerx
00:0000B052 7202            	   951: 	MOVEQ		#2,d1				; message 2 - "YOUR SCORE IS ONE OF THE TE..."
00:0000B054 61000C14        	   952: 	BSR		add_message			; add message d1 to the display list
00:0000B058 7203            	   953: 	MOVEQ		#3,d1				; message 3 - "PLEASE ENTER YOUR INITIALS"
00:0000B05A 61000C0E        	   954: 	BSR		add_message			; add message d1 to the display list
00:0000B05E 7204            	   955: 	MOVEQ		#4,d1				; message 4 - "PUSH ROTATE TO SELECT LETTER"
00:0000B060 61000C08        	   956: 	BSR		add_message			; add message d1 to the display list
00:0000B064 7205            	   957: 	MOVEQ		#5,d1				; message 5 - "PUSH HYPERSPACE WHEN LETTER..."
00:0000B066 61000C02        	   958: 	BSR		add_message			; add message d1 to the display list
                            	   959: 
00:0000B06A 36BC2000        	   960: 	MOVE.w	#$2000,glob_scale(a3)	; set the global scale
                            	   961: 
00:0000B06E 7264            	   962: 	MOVEQ		#$64,d1			; set the x co-ordinate
00:0000B070 7439            	   963: 	MOVEQ		#$39,d2			; set the y co-ordinate
00:0000B072 61000CAC        	   964: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	   965: 							; a draw command
                            	   966: 
00:0000B076 323C7000        	   967: 	MOVE.w	#REL7,d1			; make a $7000,$0000 command
00:0000B07A 61000CBE        	   968: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	   969: 
00:0000B07E 7000            	   970: 	MOVEQ		#0,d0				; clear the longword
00:0000B080 102D0083        	   971: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:0000B084 41F3003B        	   972: 	LEA		hinames(a3,d0.w),a0	; point to the high score names
                            	   973: 
00:0000B088 610001AA        	   974: 	BSR		write_initial		; write a high score initial to the vector list
00:0000B08C 610001A6        	   975: 	BSR		write_initial		; write a high score initial to the vector list
00:0000B090 610001A2        	   976: 	BSR		write_initial		; write a high score initial to the vector list
                            	   977: 
                            	   978: ;	MOVEQ		#' ',d1			; [SPACE] key
                            	   979: ;	MOVEQ		#19,d0			; check for keypress
                            	   980: ;	TRAP		#15
00:0000B094 7005            	   981: 	moveq #5,d0
00:0000B096 4E4F            	   982: 	trap #15
00:0000B098 4A81            	   983: 	tst.l d1
00:0000B09A 6B6E            	   984: 	bmi.s save_hbutton
00:0000B09C 0C010020        	   985: 	cmpi.b #' ',d1
00:0000B0A0 6668            	   986: 	bne.s save_hbutton
                            	   987: 
                            	   988: ;	TST.b		d1				; test the result
                            	   989: ;	BEQ.s		save_hbutton		; if hyperspace not pressed go save the state
                            	   990: 
00:0000B0A2 4A2B0022        	   991: 	TST.b		last_hype(a3)		; test the hyperspace last state
00:0000B0A6 6662            	   992: 	BNE.s		save_hbutton		; if hyperspace is held go save the state
                            	   993: 
                            	   994: ; the hyperspace button has just been pressed
                            	   995: 
00:0000B0A8 522B0020        	   996: 	ADDQ.b	#1,hi_char(a3)		; increment the input character index
00:0000B0AC 0C2B00030020    	   997: 	CMPI.b	#3,hi_char(a3)		; compare with end + 1
00:0000B0B2 653E            	   998: 	BCS.s		next_hi_char		; if not there yet go and increment to the next
                            	   999: 							; character
                            	  1000: 
                            	  1001: 							; else that was the last character
00:0000B0B4 17410022        	  1002: 	MOVE.b	d1,last_hype(a3)		; save the hyperspace last state
00:0000B0B8 1B7C00FF0083    	  1003: 	MOVE.b	#$FF,high_off(a5)		; clear the player highscore flag
                            	  1004: next_p_high
00:0000B0BE 7000            	  1005: 	MOVEQ		#0,d0				; clear the longword
00:0000B0C0 17400020        	  1006: 	MOVE.b	d0,hi_char(a3)		; clear the input character index
                            	  1007: 
00:0000B0C4 43FA29AA        	  1008: 	LEA		filename(pc),a1		; point to the highscore filename
00:0000B0C8 7034            	  1009: 	MOVEQ		#52,d0			; open new file
00:0000B0CA 4E4F            	  1010: 	TRAP		#15
                            	  1011: 
00:0000B0CC 4A40            	  1012: 	TST.w		d0				; check for errors
00:0000B0CE 660A            	  1013: 	BNE.s		close_all			; if error go close all files
                            	  1014: 
00:0000B0D0 43EB0027        	  1015: 	LEA		hiscores(a3),a1		; point to the highscore tables
00:0000B0D4 7432            	  1016: 	MOVEQ		#50,d2			; set the table length
00:0000B0D6 7036            	  1017: 	MOVEQ		#54,d0			; write file
00:0000B0D8 4E4F            	  1018: 	TRAP		#15
                            	  1019: 
                            	  1020: close_all
00:0000B0DA 7032            	  1021: 	MOVEQ		#50,d0			; close all files
00:0000B0DC 4E4F            	  1022: 	TRAP		#15
                            	  1023: 
00:0000B0DE 17400018        	  1024: 	MOVE.b	d0,player_idx(a3)		; clear the player index
00:0000B0E2 4BEB00F3        	  1025: 	LEA		player_1(a3),a5		; get the pointer to player one's variables
00:0000B0E6 4DEB01F7        	  1026: 	LEA		player_2(a3),a6		; get the pointer to player two's variables
                            	  1027: 
00:0000B0EA 177C00F00059    	  1028: 	MOVE.b	#$F0,game_count(a3)	; set the game counter high byte, high score
                            	  1029: 							; entry timeout
00:0000B0F0 4E75            	  1030: 	RTS
                            	  1031: 
                            	  1032: ; hyperspace button press accepted and not at initials end
                            	  1033: 
                            	  1034: next_hi_char
00:0000B0F2 177C00F40059    	  1035: 	MOVE.b	#$F4,game_count(a3)	; set the game counter high byte, high score
                            	  1036: 							; entry timeout
                            	  1037: 
00:0000B0F8 7000            	  1038: 	MOVEQ		#0,d0				; clear the longword
00:0000B0FA 102D0083        	  1039: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:0000B0FE D02B0020        	  1040: 	ADD.b		hi_char(a3),d0		; add the input character index
00:0000B102 41F3003B        	  1041: 	LEA		hinames(a3,d0.w),a0	; point to the high score names
00:0000B106 10BC000B        	  1042: 	MOVE.b	#$0B,(a0)			; set the next character to "A"
                            	  1043: save_hbutton
00:0000B10A 17410022        	  1044: 	MOVE.b	d1,last_hype(a3)		; save the hyperspace button last state
                            	  1045: 
00:0000B10E 4A2B0059        	  1046: 	TST.b		game_count(a3)		; test the game counter high byte
00:0000B112 660C            	  1047: 	BNE.s		not_timed_out		; if not timed out just continue
                            	  1048: 
00:0000B114 70FF            	  1049: 	MOVEQ		#-1,d0			; flag high score done
00:0000B116 1B400083        	  1050: 	MOVE.b	d0,high_off(a5)		; clear the player 1 highscore flag
00:0000B11A 1D400083        	  1051: 	MOVE.b	d0,high_off(a6)		; clear the player 2 highscore flag
00:0000B11E 609E            	  1052: 	BRA.s		next_p_high			; go save the entry end exit, branch always
                            	  1053: 
                            	  1054: not_timed_out
00:0000B120 70F8            	  1055: 	MOVEQ		#-8,d0			; set the timeout counter mask
00:0000B122 C02B0025        	  1056: 	AND.b		time_count(a3),d0		; mask the timeout counter
00:0000B126 674E            	  1057: 	BEQ.s		exit_not_done		; just exit 7/8ths of the time
                            	  1058: 
00:0000B128 B12B0025        	  1059: 	EOR.b		d0,time_count(a3)		; reset the timeout counter
                            	  1060: 
00:0000B12C 7400            	  1061: 	MOVEQ		#0,d2				; assume no rotate
                            	  1062: ;	MOVE.w	#'WQ',d1			; [WQ] keys
                            	  1063: ;	MOVEQ		#19,d0			; check for keypress
                            	  1064: ;	TRAP		#15
00:0000B12E 7005            	  1065: 	moveq #5,d0
00:0000B130 4E4F            	  1066: 	trap #15
00:0000B132 0C010051        	  1067: 	cmpi.b #'Q',d1
00:0000B136 6604            	  1068: 	bne.s not_rot_left
00:0000B138 7401            	  1069: 	moveq #1,d2
00:0000B13A 6008            	  1070: 	bra.s was_rot_left
                            	  1071: not_rot_left:
00:0000B13C 0C010057        	  1072: 	cmpi.b #'W',d1
00:0000B140 6602            	  1073: 	bne.s not_rot_right2
00:0000B142 5302            	  1074: 	subq.b #1,d2	
                            	  1075: 
                            	  1076: ;	TST.b		d1				; test the result
                            	  1077: ;	BPL.s		rot_not_left		; if not pressed go test rotate right
                            	  1078: ;
                            	  1079: ;	MOVEQ		#1,d2				; if pressed set the offset to + 1
                            	  1080: rot_not_left
                            	  1081: ;	TST.w		d1				; test the result
                            	  1082: ;	BPL.s		rot_not_right		; if not pressed go add the rotation
                            	  1083: 
                            	  1084: ;	SUBQ.b	#1,d2				; if pressed set the offset to - 1
                            	  1085: not_rot_right2
                            	  1086: was_rot_left:
00:0000B144 7000            	  1087: 	MOVEQ		#0,d0				; clear the longword
00:0000B146 102D0083        	  1088: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:0000B14A D02B0020        	  1089: 	ADD.b		hi_char(a3),d0		; add the input character index
00:0000B14E D433003B        	  1090: 	ADD.b		hinames(a3,d0.w),d2	; add the character to the offset
00:0000B152 6B14            	  1091: 	BMI.s		wrap_to_z			; if negative go set "Z"
                            	  1092: 
00:0000B154 0C02000B        	  1093: 	CMPI.b	#$0B,d2			; compare with "A"
00:0000B158 6410            	  1094: 	BCC.s		check_alpha			; if >= "A" go test for <= "Z"
                            	  1095: 
00:0000B15A 0C020001        	  1096: 	CMPI.b	#$01,d2			; compare with "0"
00:0000B15E 6704            	  1097: 	BEQ.s		wrap_to_a			; if "0" go set to "A"
                            	  1098: 
                            	  1099: 							; gets here if it was "2" to "9"
00:0000B160 7400            	  1100: 	MOVEQ		#0,d2				; else set to " "
00:0000B162 600E            	  1101: 	BRA.s		save_char			; go save the new character
                            	  1102: 
                            	  1103: wrap_to_a
00:0000B164 740B            	  1104: 	MOVEQ		#$0B,d2			; set to "A"
00:0000B166 600A            	  1105: 	BRA.s		save_char			; go save the new character
                            	  1106: 
                            	  1107: wrap_to_z
00:0000B168 7424            	  1108: 	MOVEQ		#$24,d2			; set to "Z"
                            	  1109: check_alpha
00:0000B16A 0C020025        	  1110: 	CMPI.b	#$25,d2			; compare with "Z" + 1
00:0000B16E 6502            	  1111: 	BCS.s		save_char			; if less skip the reset
                            	  1112: 
00:0000B170 7400            	  1113: 	MOVEQ		#0,d2				; else reset it to " "
                            	  1114: save_char
00:0000B172 1782003B        	  1115: 	MOVE.b	d2,hinames(a3,d0.w)	; save the new character
                            	  1116: exit_not_done
00:0000B176 7000            	  1117: 	MOVEQ		#0,d0				; flag high score not complete
                            	  1118: exit_enter_hiscores
00:0000B178 4E75            	  1119: 	RTS
                            	  1120: 
                            	  1121: 
                            	  1122: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1123: ;
                            	  1124: ; handle the hyperspace button
                            	  1125: 
                            	  1126: hyperspace
                            	  1127: ;##	TST.b		num_players(a3)		; test the number of players in the game
                            	  1128: ;##	BEQ		exit_hyperspace		; if no players just exit
                            	  1129: 
                            	  1130: ;##	TST.b		hide_p_cnt(a5)		; test the hide the player count
                            	  1131: ;##	BNE		exit_hyperspace		; if the player is hidden just exit
                            	  1132: 
00:0000B17A 4A2D0027        	  1133: 	tst.b p_flag_off(a5)		; test the player flag
00:0000B17E 6F000088        	  1134: 	ble exit_hyperspace			; if no player or player exploding just exit
                            	  1135: 
                            	  1136: ;	MOVEQ		#' ',d1			; [SPACE] key, read the hyperspace button
                            	  1137: ;	MOVEQ		#19,d0			; check for keypress
                            	  1138: ;	TRAP		#15
00:0000B182 7005            	  1139: 	moveq #5,d0
00:0000B184 4E4F            	  1140: 	trap #15
00:0000B186 0C010020        	  1141: 	cmpi.b #' ',d1
00:0000B18A 667C            	  1142: 	bne.s exit_hyperspace
                            	  1143: 
                            	  1144: ;	TST.b		d1				; test the result
                            	  1145: ;	BEQ.s		exit_hyperspace		; if the key is not pressed just exit
                            	  1146: 
00:0000B18C 7000            	  1147: 	MOVEQ		#0,d0				; clear the longword
00:0000B18E 1B400027        	  1148: 	MOVE.b	d0,p_flag_off(a5)		; clear the player flag
00:0000B192 1B40004A        	  1149: 	MOVE.b	d0,p_xvel_off(a5)		; clear the player x velocity
00:0000B196 1B40006D        	  1150: 	MOVE.b	d0,p_yvel_off(a5)		; clear the player y velocity
                            	  1151: 
00:0000B19A 1B7C0030007A    	  1152: 	MOVE.b	#$30,hide_p_cnt(a5)	; set the hide the player count
                            	  1153: 
00:0000B1A0 61000C30        	  1154: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B1A4 302B000A        	  1155: 	MOVE.w	PRNlword(a3),d0		; get a pseudo random word
00:0000B1A8 02401FFF        	  1156: 	ANDI.w	#$1FFF,d0			; mask to $1Fxx
00:0000B1AC 0C401E00        	  1157: 	CMPI.w	#$1E00,d0			; compare with $1E00
00:0000B1B0 6504            	  1158: 	BCS.s		hype_xok1			; if less than $1E00 just use it
                            	  1159: 
00:0000B1B2 02401CFF        	  1160: 	ANDI.w	#$1CFF,d0			; else restrict it to $1Cxx
                            	  1161: hype_xok1
00:0000B1B6 0C400400        	  1162: 	CMPI.w	#$0400,d0			; compare it with $0400
00:0000B1BA 6404            	  1163: 	BCC.s		hype_xok2			; if >= $0400 go use it
                            	  1164: 
00:0000B1BC 00400300        	  1165: 	ORI.w		#$0300,d0			; else make it $03xx
                            	  1166: hype_xok2
00:0000B1C0 3B40FFB6        	  1167: 	MOVE.w	d0,p_xpos_off(a5)		; save the player x position
                            	  1168: 
00:0000B1C4 61000C0C        	  1169: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B1C8 302B000A        	  1170: 	MOVE.w	PRNlword(a3),d0		; get a pseudo random word
00:0000B1CC 02401FFF        	  1171: 	ANDI.w	#$1FFF,d0			; mask to $1Fxx
                            	  1172: 
00:0000B1D0 3F00            	  1173: 	MOVE.w	d0,-(sp)			; push the word
00:0000B1D2 141F            	  1174: 	MOVE.b	(sp)+,d2			; pull the byte for later success/fail check
                            	  1175: 
00:0000B1D4 0C401600        	  1176: 	CMPI.w	#$1600,d0			; compare with $1600
00:0000B1D8 6504            	  1177: 	BCS.s		hype_yok1			; if less than $1600 just use it
                            	  1178: 
00:0000B1DA 024014FF        	  1179: 	ANDI.w	#$14FF,d0			; else restrict it to $14xx
                            	  1180: hype_yok1
00:0000B1DE 0C400400        	  1181: 	CMPI.w	#$0400,d0			; compare it with $0400
00:0000B1E2 6404            	  1182: 	BCC.s		hype_yok2			; if >= $0400 go use it
                            	  1183: 
00:0000B1E4 00400300        	  1184: 	ORI.w		#$0300,d0			; else make it $03xx
                            	  1185: hype_yok2
00:0000B1E8 3B40FFFC        	  1186: 	MOVE.w	d0,p_ypos_off(a5)		; save the player y position
                            	  1187: 
00:0000B1EC 7201            	  1188: 	MOVEQ		#1,d1				; default to a successful hyperspace jump
                            	  1189: 
00:0000B1EE 0C020018        	  1190: 	CMPI.b	#$18,d2			; compare with $18xx
00:0000B1F2 6510            	  1191: 	BCS.s		save_hyperspace		; if less than $18xx go save the hyperspace flag
                            	  1192: 
00:0000B1F4 02020007        	  1193: 	ANDI.b	#$07,d2			; else mask it
00:0000B1F8 D402            	  1194: 	ADD.b		d2,d2				; ; 2
00:0000B1FA 5802            	  1195: 	ADDI.b	#$04,d2			; + 4
00:0000B1FC B42D0076        	  1196: 	CMP.b		rock_count(a5),d2		; compare this with the rock count
00:0000B200 6502            	  1197: 	BCS.s		save_hyperspace		; if < the rock count allow the jump
                            	  1198: 
00:0000B202 7280            	  1199: 	MOVEQ		#$80,d1			; else flag an unsuccessful hyperspace jump
                            	  1200: save_hyperspace
00:0000B204 17410026        	  1201: 	MOVE.b	d1,hyper(a3)		; save the hyperspace flag
                            	  1202: exit_hyperspace
00:0000B208 4E75            	  1203: 	RTS
                            	  1204: 
                            	  1205: 
                            	  1206: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1207: ;
                            	  1208: ; clear the items and set the ship start count
                            	  1209: 
                            	  1210: reset_game:
00:0000B20A 7003            	  1211: 	MOVEQ		#3,d0				; default to a 3 ship game
00:0000B20C 206B000E        	  1212: 	MOVEA.l	switch_addr(a3),a0	; point to the switch
00:0000B210 08100002        	  1213: 	BTST		#2,(a0)			; test the ship start switch
00:0000B214 6702            	  1214: 	BEQ.s		three_ship_start		; if 0 go start with three ships
                            	  1215: 
00:0000B216 7004            	  1216: 	MOVEQ		#4,d0				; else make it a 4 ship game
                            	  1217: three_ship_start
00:0000B218 1740001B        	  1218: 	MOVE.b	d0,ss_count(a3)		; save the starting ship count
                            	  1219: 
00:0000B21C 1B7C00020075    	  1220: 	MOVE.b	#2,i_rk_count(a5)		; set the previous initial rock count
                            	  1221: 
00:0000B222 7000            	  1222: 	MOVEQ		#0,d0				; clear the longword
00:0000B224 7E22            	  1223: 	MOVEQ		#flag_end-flags_off-1,d7
                            	  1224: 							; set the count for the number of items
                            	  1225: clear_items_loop
00:0000B226 1B80700C        	  1226: 	MOVE.b	d0,flags_off(a5,d7.w)	; clear an item
00:0000B22A 51CFFFFA        	  1227: 	DBF		d7,clear_items_loop	; loop if more to do
                            	  1228: 
00:0000B22E 1B400076        	  1229: 	MOVE.b	d0,rock_count(a5)		; clear the rock count
                            	  1230: 
00:0000B232 4E75            	  1231: 	RTS
                            	  1232: 
                            	  1233: 
                            	  1234: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1235: ;
                            	  1236: ; write a high score initial to the vector list
                            	  1237: 
                            	  1238: write_initial:
00:0000B234 7200            	  1239: 	MOVEQ		#0,d1				; clear the longword
00:0000B236 1218            	  1240: 	MOVE.b	(a0)+,d1			; get a high score initial
00:0000B238 6614            	  1241: 	BNE.s		add_character		; if not [SPACE] just go add it
                            	  1242: 
00:0000B23A 102B0176        	  1243: 	MOVE.b	p1_high(a3),d0		; get the player 1 highscore flag
00:0000B23E C02B027A        	  1244: 	AND.b		p2_high(a3),d0		; and with the player 2 highscore flag
00:0000B242 6B0A            	  1245: 	BMI.s		add_character		; if neither is entering their initials just
                            	  1246: 							; go add the character
                            	  1247: 
                            	  1248: 							; else add a "_" instead of a [SPACE]
00:0000B244 38FCF872        	  1249: 	MOVE.w	#$F872,(a4)+		; add the underline vector word to the vector
                            	  1250: 							; list
00:0000B248 38FCF801        	  1251: 	MOVE.w	#$F801,(a4)+		; add the step to next character vector word
                            	  1252: 							; to the vector list
00:0000B24C 4E75            	  1253: 	RTS
                            	  1254: 
                            	  1255: 
                            	  1256: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1257: ;
                            	  1258: ; add character (d1) to the vector list
                            	  1259: 
                            	  1260: add_character:
00:0000B24E 2F08            	  1261: 	MOVE.l	a0,-(sp)			; save a0
00:0000B250 D241            	  1262: 	ADD.w		d1,d1				; ; 2 bytes per character (d1) JSRL
00:0000B252 41FA22F6        	  1263: 	LEA		char_set(pc),a0		; point to the character JSRL table
00:0000B256 38F01000        	  1264: 	MOVE.w	(a0,d1.w),(a4)+		; add the JSRL word to the vector list
00:0000B25A 205F            	  1265: 	MOVE.l	(sp)+,a0			; restore a0
00:0000B25C 4E75            	  1266: 	RTS
                            	  1267: 
                            	  1268: 
                            	  1269: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1270: ;
                            	  1271: ; add d7 ships to the vector list. this is limited to a maximum of eighteen ships for
                            	  1272: ; speed and clarity
                            	  1273: 
                            	  1274: add_ships:
00:0000B25E 6726            	  1275: 	BEQ.s		exit_add_ships		; if no ships left just exit
                            	  1276: 
00:0000B260 7012            	  1277: 	MOVEQ		#18,d0			; set the maximum ship count
00:0000B262 B047            	  1278: 	CMP.w		d7,d0				; compare the ship count with the max count
00:0000B264 6402            	  1279: 	BCC.s		show_ships			; if <= to max go show the ships
                            	  1280: 
00:0000B266 3E00            	  1281: 	MOVE.w	d0,d7				; else set the ship count to the maximum
                            	  1282: show_ships
00:0000B268 9247            	  1283: 	SUB.w		d7,d1				; subtract the ship count twice to move the ..
00:0000B26A 9247            	  1284: 	SUB.w		d7,d1				; .. ships further right the more there are
                            	  1285: 
00:0000B26C 36BCE000        	  1286: 	MOVE.w	#$E000,glob_scale(a3)	; set the global scale
00:0000B270 343C00D1        	  1287: 	MOVE.w	#$D1,d2			; set the ships y co-ordinate
00:0000B274 61000AAA        	  1288: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1289: 							; a draw command
00:0000B278 5347            	  1290: 	SUBQ.w	#1,d7				; adjust for loop type
                            	  1291: add_ships_loop
00:0000B27A 43FA20D4        	  1292: 	LEA		play_liv(pc),a1		; set the pointer to ships left
00:0000B27E 61000A8A        	  1293: 	BSR		add_address			; convert the a1 address and add it to the
                            	  1294: 							; vector list as a vector subroutine call
00:0000B282 51CFFFF6        	  1295: 	DBF		d7,add_ships_loop		; decrement the ship count and loop if more
                            	  1296: 							; to do
                            	  1297: exit_add_ships
00:0000B286 4E75            	  1298: 	RTS
                            	  1299: 
                            	  1300: 
                            	  1301: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1302: ;
                            	  1303: ; move all the items and add them to the vector list
                            	  1304: 
                            	  1305: ; d6 = object index
                            	  1306: ; d7 = position index
                            	  1307: 
                            	  1308: move_items:
00:0000B288 7E44            	  1309: 	MOVEQ		#x_pos_end-x_pos_off-2,d7
                            	  1310: 							; set the index to the last object position
00:0000B28A 7C22            	  1311: 	MOVEQ		#flag_end-flags_off-1,d6
                            	  1312: 							; set the count to the last object
                            	  1313: move_next_item
00:0000B28C 1035600C        	  1314: 	MOVE.b	flags_off(a5,d6.w),d0	; get an object flag
00:0000B290 670000CC        	  1315: 	BEQ		move_next_object		; if no item go do the next one
                            	  1316: 
                            	  1317: ; have an active item
                            	  1318: 
00:0000B294 6A5C            	  1319: 	BPL.s		move_item			; if the item is not exploding go move the item
                            	  1320: 
                            	  1321: 							; else the item is exploding
00:0000B296 4400            	  1322: 	NEG.b		d0				; do twos complement [$A0 becones $60]
00:0000B298 E808            	  1323: 	LSR.b		#4,d0				; shift the high nibble to the low nibble
                            	  1324: 							; [$60 becomes $06]
00:0000B29A 5200            	  1325: 	ADDQ.b	#1,d0				; + 1
00:0000B29C 0C06001B        	  1326: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  1327: 							; compare the index with the player index
00:0000B2A0 6606            	  1328: 	BNE.s		skip_play_inc		; if not the player skip setting the player
                            	  1329: 							; increment
                            	  1330: 
                            	  1331: ; set the player explosion increment to 1/2 by only setting it to 1 on alternate loops
                            	  1332: 
00:0000B2A2 7001            	  1333: 	MOVEQ		#1,d0				; set game counter mask
00:0000B2A4 C06B0059        	  1334: 	AND.w		game_count(a3),d0		; mask the game counter
                            	  1335: skip_play_inc
00:0000B2A8 D035600C        	  1336: 	ADD.b		flags_off(a5,d6.w),d0	; add the item flag
00:0000B2AC 6B2A            	  1337: 	BMI.s		item_exploding		; go handle the item still exploding
                            	  1338: 
00:0000B2AE 0C46001B        	  1339: 	CMPI.w	#p_flag_off-flags_off,d6
                            	  1340: 							; compare the index with the player index
00:0000B2B2 6716            	  1341: 	BEQ.s		go_reset_play		; if the player go reset the player and do next
                            	  1342: 
00:0000B2B4 641A            	  1343: 	BCC.s		go_reset_sauc		; if the saucer go reset the saucer and do next
                            	  1344: 
                            	  1345: 							; else it was a rock so clear it
00:0000B2B6 532D0076        	  1346: 	SUBQ.b	#1,rock_count(a5)		; decrement the rock count
00:0000B2BA 6606            	  1347: 	BNE.s		no_new_rocks		; skip flag set if rocks still left
                            	  1348: 
00:0000B2BC 1B7C007F007B    	  1349: 	MOVE.b	#$7F,new_rocks(a5)	; else set the generate new rocks flag
                            	  1350: no_new_rocks
00:0000B2C2 4235600C        	  1351: 	CLR.b		flags_off(a5,d6.w)	; clear the item flag
00:0000B2C6 60000096        	  1352: 	BRA		move_next_object		; go check next item
                            	  1353: 
                            	  1354: go_reset_play
00:0000B2CA 610002E2        	  1355: 	BSR		player_reset		; reset the player velocity and position
00:0000B2CE 60F2            	  1356: 	BRA		no_new_rocks		; go clear the player and do the next item
                            	  1357: 
                            	  1358: ; reset the saucer timer
                            	  1359: 
                            	  1360: go_reset_sauc
00:0000B2D0 1B6D00780077    	  1361: 	MOVE.b	i_sauc_tim(a5),sauc_cntdn(a5)
                            	  1362: 							; get the small saucer boundary/initial saucer
                            	  1363: 							; timer and reset the saucer countdown timer
00:0000B2D6 60EA            	  1364: 	BRA.s		no_new_rocks		; go clear the saucer and do the next item
                            	  1365: 
                            	  1366: ; the item is still exploding
                            	  1367: 
                            	  1368: item_exploding
00:0000B2D8 1B80600C        	  1369: 	MOVE.b	d0,flags_off(a5,d6.w)	; save the incremented item flag
00:0000B2DC 1F00            	  1370: 	MOVE.b	d0,-(sp)			; save the byte
00:0000B2DE 321F            	  1371: 	MOVE.w	(sp)+,d1			; pull the word
00:0000B2E0 C27CF000        	  1372: 	AND.w		#$F000,d1			; mask the top nibble as the scale
00:0000B2E4 D27C1000        	  1373: 	ADD.w		#$1000,d1			; + $10
00:0000B2E8 0C06001B        	  1374: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  1375: 							; compare the index with the player index
00:0000B2EC 6602            	  1376: 	BNE.s		no_reset_scale		; if not the player ship skip the scale reset
                            	  1377: 
00:0000B2EE 7200            	  1378: 	MOVEQ		#$0000,d1			; else it was the player so reset the scale
                            	  1379: no_reset_scale
00:0000B2F0 6066            	  1380: 	BRA.s		keep_scale			; go add the object to the vector list and do
                            	  1381: 							; the next item
                            	  1382: 
                            	  1383: ; the item is not exploding so move the item
                            	  1384: 
                            	  1385: move_item:
00:0000B2F2 1035602F        	  1386: 	MOVE.b	x_vel_off(a5,d6.w),d0	; get the x velocity byte
00:0000B2F6 4880            	  1387: 	EXT.w		d0				; extend it to a word value
00:0000B2F8 D0757080        	  1388: 	ADD.w		x_pos_off(a5,d7.w),d0	; add the x position
00:0000B2FC 6B06            	  1389: 	BMI.s		x_pos_neg			; if negative go mask to $2000
                            	  1390: 
00:0000B2FE B07C2000        	  1391: 	CMP.w		#$2000,d0			; compare the object x position with $2000
00:0000B302 6510            	  1392: 	BCS.s		not_x_max			; if less go do y position
                            	  1393: 
                            	  1394: x_pos_neg
00:0000B304 02401FFF        	  1395: 	ANDI.w	#$1FFF,d0			; else wrap round the x position
                            	  1396: 
00:0000B308 0C06001C        	  1397: 	CMPI.b	#s_flag_off-flags_off,d6
                            	  1398: 							; compare the index with the saucer index
00:0000B30C 6606            	  1399: 	BNE.s		not_x_max			; if not saucer continue
                            	  1400: 
                            	  1401: 							; else the saucer has passed the screen end
00:0000B30E 487A004E        	  1402: 	PEA		move_next_object(pc)	; on RTS go check the next item
00:0000B312 6052            	  1403: 	BRA.s		clear_saucer		; clear the saucer and restart the saucer timer
                            	  1404: 
                            	  1405: not_x_max
00:0000B314 3B807080        	  1406: 	MOVE.w	d0,x_pos_off(a5,d7.w)	; save the new x position
                            	  1407: 
00:0000B318 10356052        	  1408: 	MOVE.b	y_vel_off(a5,d6.w),d0	; get the y velocity byte
00:0000B31C 4880            	  1409: 	EXT.w		d0				; extend it to a word value
00:0000B31E D07570C6        	  1410: 	ADD.w		y_pos_off(a5,d7.w),d0	; add the y position
00:0000B322 6A06            	  1411: 	BPL.s		y_not_neg			; skip add if not < 0
                            	  1412: 
00:0000B324 D07C1800        	  1413: 	ADD.w		#$1800,d0			; else wrap round the y position
00:0000B328 600A            	  1414: 	BRA.s		not_y_max			; and skip the max check
                            	  1415: 
                            	  1416: y_not_neg
00:0000B32A B07C1800        	  1417: 	CMP.w		#$1800,d0			; compare the object y position with $1800
00:0000B32E 6504            	  1418: 	BCS.s		not_y_max			; if less just continue
                            	  1419: 
00:0000B330 907C1800        	  1420: 	SUB.w		#$1800,d0			; else wrap round the y position
                            	  1421: not_y_max
00:0000B334 3B8070C6        	  1422: 	MOVE.w	d0,y_pos_off(a5,d7.w)	; save the new y position
                            	  1423: 
00:0000B338 323CE000        	  1424: 	MOVE.w	#$E000,d1			; set the scale to $E000
00:0000B33C 0C46001D        	  1425: 	CMPI.w	#s_fire_off-flags_off,d6
                            	  1426: 							; compare the index with the fire objects
00:0000B340 6416            	  1427: 	BCC.s		keep_scale			; if fire object keep this scale and go add the
                            	  1428: 							; item and do next
                            	  1429: 
00:0000B342 1035600C        	  1430: 	MOVE.b	flags_off(a5,d6.w),d0	; get the object flag
00:0000B346 08000000        	  1431: 	BTST.l	#0,d0				; test bit 0
00:0000B34A 660C            	  1432: 	BNE.s		keep_scale			; if %xx1 keep this scale and go add the item
                            	  1433: 							; and do next
                            	  1434: 
00:0000B34C 323CF000        	  1435: 	MOVE.w	#$F000,d1			; set the scale to $F000
00:0000B350 08000001        	  1436: 	BTST.l	#1,d0				; test bit 0
00:0000B354 6602            	  1437: 	BNE.s		keep_scale			; if %x10 keep this scale and go add the item
                            	  1438: 							; and do next
                            	  1439: 
00:0000B356 7200            	  1440: 	MOVEQ		#0,d1				; set the scale to $0000
                            	  1441: 
                            	  1442: ; add the item to the vector list and go do the next item
                            	  1443: 
                            	  1444: keep_scale
00:0000B358 3681            	  1445: 	MOVE.w	d1,glob_scale(a3)		; save the global scale
00:0000B35A 610003DE        	  1446: 	BSR		add_to_list			; add an object to the vector list
                            	  1447: move_next_object
00:0000B35E 5547            	  1448: 	SUBQ.w	#2,d7				; decrement the position index
00:0000B360 51CEFF2A        	  1449: 	DBF		d6,move_next_item		; decrement the count and loop if more to do
                            	  1450: 
00:0000B364 4E75            	  1451: 	RTS
                            	  1452: 
                            	  1453: 
                            	  1454: 
                            	  1455: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1456: ;
                            	  1457: ; clear the saucer and restart the saucer timer
                            	  1458: 
                            	  1459: clear_saucer:
00:0000B366 1B6D00780077    	  1460: 	move.b i_sauc_tim(a5),sauc_cntdn(a5)	
                            	  1461: 							; copy the small saucer boundary/initial saucer
                            	  1462: 							; timer to the saucer countdown timer
00:0000B36C 422D0028        	  1463: 	clr.b s_flag_off(a5)		; clear the saucer flag
00:0000B370 422D004B        	  1464: 	clr.b s_xvel_off(a5)		; clear the saucer x velocity byte
00:0000B374 422D006E        	  1465: 	clr.b s_yvel_off(a5)		; clear the saucer y velocity byte
00:0000B378 4E75            	  1466: 	rts
                            	  1467: 
                            	  1468: 
                            	  1469: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1470: ;
                            	  1471: ; handle ship rotation and thrust
                            	  1472: 
                            	  1473: ship_move:
                            	  1474: ;##	TST.b		num_players(a3)		; test the number of players in the game
                            	  1475: ;##	BEQ.s		exit_ship_move		; if no players just exit
                            	  1476: 
00:0000B37A 4A2D0027        	  1477: 	TST.b		p_flag_off(a5)		; test the player flag
00:0000B37E 6B4A            	  1478: 	BMI.s		exit_ship_move		; if the player is exploding just exit
                            	  1479: 
00:0000B380 4A2D007A        	  1480: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:0000B384 6746            	  1481: 	BEQ.s		rot_and_thrust		; if the player is visible go handle the ship
                            	  1482: 							; rotate and thrust
                            	  1483: 
00:0000B386 532D007A        	  1484: 	SUBQ.b	#1,hide_p_cnt(a5)		; else decrement the hide the player count
00:0000B38A 663E            	  1485: 	BNE.s		exit_ship_move		; if not timed out just exit
                            	  1486: 
00:0000B38C 4A2B0026        	  1487: 	TST.b		hyper(a3)			; test the hyperspace flag
00:0000B390 6B1E            	  1488: 	BMI.s		kill_the_player		; if negative go handle an unsuccessful
                            	  1489: 							; hyperspace jump
                            	  1490: 
00:0000B392 6614            	  1491: 	BNE.s		reveal_player		; else if non zero go handle a successful
                            	  1492: 							; hyperspace jump
                            	  1493: 
                            	  1494: 							; else the player has just become visible
00:0000B394 610000F8        	  1495: 	BSR		check_clear			; check items within $0400 range of the player
00:0000B398 662C            	  1496: 	BNE.s		clear_hyper			; if there are items within range go clear the
                            	  1497: 							; hyperspace flag and exit
                            	  1498: 
00:0000B39A 4A2D0028        	  1499: 	TST.b		s_flag_off(a5)		; test the saucer flag
00:0000B39E 6708            	  1500: 	BEQ.s		reveal_player		; if there's no saucer go reveal the player
                            	  1501: 
00:0000B3A0 1B7C0002007A    	  1502: 	MOVE.b	#$02,hide_p_cnt(a5)	; else set the hide the player count
00:0000B3A6 4E75            	  1503: 	RTS
                            	  1504: 
                            	  1505: ; handle a successful hyperspace jump
                            	  1506: 
                            	  1507: reveal_player
00:0000B3A8 1B7C00010027    	  1508: 	MOVE.b	#$01,p_flag_off(a5)	; set the player flag
00:0000B3AE 6016            	  1509: 	BRA.s		clear_hyper			; go clear the hyperspace flag and return
                            	  1510: 
                            	  1511: ; handle an unsuccessful hyperspace jump
                            	  1512: 
                            	  1513: kill_the_player:
00:0000B3B0 1B7C00A00027    	  1514: 	MOVE.b	#$A0,p_flag_off(a5)	; flag that the player's ship is exploding
00:0000B3B6 532D0082        	  1515: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
00:0000B3BA 1B7C0081007A    	  1516: 	MOVE.b	#$81,hide_p_cnt(a5)	; set the hide the player count
                            	  1517: 
00:0000B3C0 7206            	  1518: 	MOVEQ		#mexpl_snd,d1		; set the medium explosion sound
00:0000B3C2 6100259A        	  1519: 	BSR		play_sample			; go play the sample
                            	  1520: clear_hyper
00:0000B3C6 422B0026        	  1521: 	CLR.b		hyper(a3)			; clear the hyperspace flag
                            	  1522: exit_ship_move
00:0000B3CA 4E75            	  1523: 	RTS
                            	  1524: 
                            	  1525: ; handle the ship rotate and thrust
                            	  1526: 
                            	  1527: rot_and_thrust
                            	  1528: ;	MOVEQ		#0,d2				; assume no rotate
                            	  1529: ;	MOVE.l	#'L WQ',d1			; [L WQ] keys
                            	  1530: ;	MOVEQ		#19,d0			; check for keypress
                            	  1531: ;	TRAP		#15
00:0000B3CC 7005            	  1532: 	moveq #5,d0
00:0000B3CE 4E4F            	  1533: 	trap #15
00:0000B3D0 0C010051        	  1534: 	cmpi.b #'Q',d1
00:0000B3D4 6602            	  1535: 	bne.s not_rot_left1
00:0000B3D6 7403            	  1536: 	moveq #3,d2
                            	  1537: not_rot_left1:
00:0000B3D8 0C010057        	  1538: 	cmpi.b #'W',d1
00:0000B3DC 6602            	  1539: 	bne.s not_rot_right1
00:0000B3DE 5702            	  1540: 	subq.b #3,d2
                            	  1541: not_rot_right1:
                            	  1542: 
                            	  1543: ;	TST.b		d1				; test the [Q] result
                            	  1544: ;	BPL.s		not_rot_left		; if not pressed go test rotate right
                            	  1545: 
                            	  1546: ;	MOVEQ		#3,d2				; if pressed set the rotation angle to + 3
                            	  1547: ;not_rot_left
                            	  1548: ;	TST.w		d1				; test the [W] result
                            	  1549: ;	BPL.s		not_rot_right		; if not pressed go add the rotation
                            	  1550: 
                            	  1551: ;	SUBQ.b	#3,d2				; if pressed set the rotation angle to - 3
                            	  1552: ;not_rot_right
00:0000B3E0 D52B001E        	  1553: 	add.b d2,p_orient(a3)		; add the roataion to the player orientation
                            	  1554: 
00:0000B3E4 7001            	  1555: 	moveq #1,d0				; set game counter mask
00:0000B3E6 C06B0059        	  1556: 	and.w game_count(a3),d0		; mask the game counter
00:0000B3EA 66DE            	  1557: 	bne.s exit_ship_move		; just exit half the time
                            	  1558: 
00:0000B3EC 0C01004C        	  1559: 	cmpi.b #'L',d1
00:0000B3F0 664C            	  1560: 	bne.s not_thrust
                            	  1561: ;	TST.l		d1				; test the [L] result
                            	  1562: ;	BPL.s		not_thrust			; if not pressed then go slow the ship
                            	  1563: 
                            	  1564: ; thrust button is pressed so increase the ship velocity
                            	  1565: 
00:0000B3F2 7202            	  1566: 	MOVEQ		#thrst_snd,d1		; set the thrust sound
00:0000B3F4 61002568        	  1567: 	BSR		play_sample			; play the sample and return
                            	  1568: 
00:0000B3F8 102B001E        	  1569: 	MOVE.b	p_orient(a3),d0		; get the player orientation
00:0000B3FC 610007CC        	  1570: 	BSR		cos_d0			; do COS(d0)
00:0000B400 EE40            	  1571: 	ASR.w		#7,d0				; scale to 1/128th
                            	  1572: 
00:0000B402 1F2D004A        	  1573: 	MOVE.b	p_xvel_off(a5),-(sp)	; get the x velocity high byte
00:0000B406 321F            	  1574: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000B408 122D007E        	  1575: 	MOVE.b	p_xvlo_off(a5),d1		; get the x velocity low byte
00:0000B40C D240            	  1576: 	ADD.w		d0,d1				; add the thrust x component
00:0000B40E 6164            	  1577: 	BSR.s		check_velocity		; limit check the velocity in d1
00:0000B410 1B41007E        	  1578: 	MOVE.b	d1,p_xvlo_off(a5)		; save the x velocity low byte
00:0000B414 3F01            	  1579: 	MOVE.w	d1,-(sp)			; save the word
00:0000B416 1B5F004A        	  1580: 	MOVE.b	(sp)+,p_xvel_off(a5)	; save the x velocity high byte
                            	  1581: 
00:0000B41A 102B001E        	  1582: 	MOVE.b	p_orient(a3),d0		; get the player orientation
00:0000B41E 610007AE        	  1583: 	BSR		sin_d0			; do SIN(d0)
00:0000B422 EE40            	  1584: 	ASR.w		#7,d0				; scale to 1/128th
                            	  1585: 
00:0000B424 1F2D006D        	  1586: 	MOVE.b	p_yvel_off(a5),-(sp)	; get the y velocity high byte
00:0000B428 321F            	  1587: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000B42A 122D007F        	  1588: 	MOVE.b	p_yvlo_off(a5),d1		; get the y velocity low byte
00:0000B42E D240            	  1589: 	ADD.w		d0,d1				; add the thrust y component
00:0000B430 6142            	  1590: 	BSR.s		check_velocity		; limit check the velocity in d1
00:0000B432 1B41007F        	  1591: 	MOVE.b	d1,p_yvlo_off(a5)		; save the y velocity low byte
00:0000B436 3F01            	  1592: 	MOVE.w	d1,-(sp)			; save the word
00:0000B438 1B5F006D        	  1593: 	MOVE.b	(sp)+,p_yvel_off(a5)	; save the y velocity high byte
                            	  1594: 
00:0000B43C 4E75            	  1595: 	RTS
                            	  1596: 
                            	  1597: ; thrust button is not pressed so slow the ship by adding - 128 ; velocity
                            	  1598: 
                            	  1599: not_thrust
00:0000B43E 1F2D004A        	  1600: 	MOVE.b	p_xvel_off(a5),-(sp)	; get the x velocity high byte
00:0000B442 321F            	  1601: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000B444 122D007E        	  1602: 	MOVE.b	p_xvlo_off(a5),d1		; get the x velocity low byte
00:0000B448 3001            	  1603: 	MOVE.w	d1,d0				; copy the x velocity
00:0000B44A EE40            	  1604: 	ASR.w		#7,d0				; scale to 1/128th
00:0000B44C 9240            	  1605: 	SUB.w		d0,d1				; subtract the x drag component
00:0000B44E 1B41007E        	  1606: 	MOVE.b	d1,p_xvlo_off(a5)		; save the x velocity low byte
00:0000B452 3F01            	  1607: 	MOVE.w	d1,-(sp)			; save the word
00:0000B454 1B5F004A        	  1608: 	MOVE.b	(sp)+,p_xvel_off(a5)	; save the x velocity high byte
                            	  1609: 
                            	  1610: ; done the x velocity now do the y
                            	  1611: 
00:0000B458 1F2D006D        	  1612: 	MOVE.b	p_yvel_off(a5),-(sp)	; get the y velocity high byte
00:0000B45C 321F            	  1613: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000B45E 122D007F        	  1614: 	MOVE.b	p_yvlo_off(a5),d1		; get the y velocity low byte
00:0000B462 3001            	  1615: 	MOVE.w	d1,d0				; copy the y velocity
00:0000B464 EE40            	  1616: 	ASR.w		#7,d0				; scale to 1/128th
00:0000B466 9240            	  1617: 	SUB.w		d0,d1				; subtract the y drag component
00:0000B468 1B41007F        	  1618: 	MOVE.b	d1,p_yvlo_off(a5)		; save the y velocity low byte
00:0000B46C 3F01            	  1619: 	MOVE.w	d1,-(sp)			; save the word
00:0000B46E 1B5F006D        	  1620: 	MOVE.b	(sp)+,p_yvel_off(a5)	; save the y velocity high byte
                            	  1621: 
00:0000B472 4E75            	  1622: 	RTS
                            	  1623: 
                            	  1624: 
                            	  1625: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1626: ;
                            	  1627: ; limit check the velocity in XA
                            	  1628: 
                            	  1629: check_velocity:
00:0000B474 6B0C            	  1630: 	BMI.s		check_neg_velocity	; if negative go check negative limit
                            	  1631: 
00:0000B476 0C414000        	  1632: 	CMPI.w	#$4000,d1			; compare velocity with positive limit
00:0000B47A 6510            	  1633: 	BCS.s		exit_check_velocity	; if less just exit
                            	  1634: 
00:0000B47C 323C3FFF        	  1635: 	MOVE.w	#$3FFF,d1			; else set the velocity
00:0000B480 4E75            	  1636: 	rts
                            	  1637: 
                            	  1638: ; velocity is negative so check against the negative limit
                            	  1639: 
                            	  1640: check_neg_velocity
00:0000B482 0C41C002        	  1641: 	CMPI.w	#$C002,d1			; compare velocity with negative limit
00:0000B486 6404            	  1642: 	BCC.s		exit_check_velocity	; if greater or equal just exit
                            	  1643: 
00:0000B488 323CC001        	  1644: 	MOVE.w	#$C001,d1			; else set the velocity
                            	  1645: exit_check_velocity
00:0000B48C 4E75            	  1646: 	rts
                            	  1647: 
                            	  1648: 
                            	  1649: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1650: ;
                            	  1651: ; check items within $0400 range of the player
                            	  1652: 
                            	  1653: check_clear:
00:0000B48E 7C1C            	  1654: 	moveq #s_flag_off-flags_off,d6
                            	  1655: 							; set the count/index to the saucer
00:0000B490 7E38            	  1656: 	moveq #s_xpos_off-x_pos_off,d7
                            	  1657: 							; set the index to the saucer position
                            	  1658: check_clear_loop
00:0000B492 4A35600C        	  1659: 	tst.b flags_off(a5,d6.w)	; test the item flag
00:0000B496 6F28            	  1660: 	BLE.s		not_closer			; if no item or exploding go do the next item
                            	  1661: 
00:0000B498 30357080        	  1662: 	MOVE.w	x_pos_off(a5,d7.w),d0	; get the item x position
00:0000B49C 906DFFB6        	  1663: 	SUB.w		p_xpos_off(a5),d0		; subtract the player x position
00:0000B4A0 0C400400        	  1664: 	CMPI.w	#$0400,d0			; compare the result with $0400
00:0000B4A4 6506            	  1665: 	BCS.s		check_clear_y		; if closer go check the y distance
                            	  1666: 
00:0000B4A6 0C40FC00        	  1667: 	CMPI.w	#$FC00,d0			; compare the result with -$0400
00:0000B4AA 6514            	  1668: 	BCS.s		not_closer			; if not closer go do the next item
                            	  1669: 
                            	  1670: check_clear_y
00:0000B4AC 303570C6        	  1671: 	MOVE.w	y_pos_off(a5,d7.w),d0	; get the item y position
00:0000B4B0 906DFFFC        	  1672: 	SUB.w		p_ypos_off(a5),d0		; subtract the player y position
00:0000B4B4 0C400400        	  1673: 	CMPI.w	#$0400,d0			; compare the result with $0400
00:0000B4B8 6510            	  1674: 	BCS.s		is_closer			; if closer go flag within distance and
                            	  1675: 							; increment the hide the player count
                            	  1676: 
00:0000B4BA 0C40FC00        	  1677: 	CMPI.w	#$FC00,d0			; compare the result with -$0400
00:0000B4BE 640A            	  1678: 	BCC.s		is_closer			; if closer go flag within distance and
                            	  1679: 							; increment the hide the player count
                            	  1680: 
                            	  1681: not_closer
00:0000B4C0 5547            	  1682: 	SUBQ.w	#2,d7				; decrement the position index
00:0000B4C2 51CEFFCE        	  1683: 	DBF		d6,check_clear_loop	; decrement the count and loop if more to do
                            	  1684: 
00:0000B4C6 7000            	  1685: 	MOVEQ		#0,d0				; return Zb = 1
00:0000B4C8 4E75            	  1686: 	rts
                            	  1687: 
                            	  1688: is_closer
00:0000B4CA 522D007A        	  1689: 	ADDQ.b	#1,hide_p_cnt(a5)		; increment the hide the player count
                            	  1690: 							; return Zb = 0
00:0000B4CE 4E75            	  1691: 	rts
                            	  1692: 
                            	  1693: 
                            	  1694: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1695: ;
                            	  1696: ; generate new rocks
                            	  1697: 
                            	  1698: make_rocks:
00:0000B4D0 4A2D0028        	  1699: 	TST.b		s_flag_off(a5)		; test the saucer flag
00:0000B4D4 660000A0        	  1700: 	BNE		exit_make_rocks		; if existing saucer just exit
                            	  1701: 
00:0000B4D8 7C34            	  1702: 	MOVEQ		#p_xpos_off-x_pos_off-2,d6
                            	  1703: 							; set the index to the last rock position
00:0000B4DA 7A1A            	  1704: 	MOVEQ		#p_flag_off-flags_off-1,d5
                            	  1705: 							; set the count/index to the last rock flag
00:0000B4DC 4A2D007B        	  1706: 	TST.b		new_rocks(a5)		; test the generate new rocks flag
00:0000B4E0 6600008A        	  1707: 	BNE		clear_rocks			; if not counted out go clear all the rocks
                            	  1708: 
                            	  1709: ; these are used as the new rock initial velocity
                            	  1710: 
00:0000B4E4 7000            	  1711: 	MOVEQ		#0,d0				; clear the longword
00:0000B4E6 1B40004B        	  1712: 	MOVE.b	d0,s_xvel_off(a5)		; clear the saucer x velocity byte
00:0000B4EA 1B40006E        	  1713: 	MOVE.b	d0,s_yvel_off(a5)		; clear the saucer y velocity byte
                            	  1714: 
00:0000B4EE 700A            	  1715: 	MOVEQ		#$0A,d0			; set the max value
00:0000B4F0 B02D007D        	  1716: 	CMP.b		min_rocks(a5),d0		; compare minimum rock count with $0A
00:0000B4F4 6504            	  1717: 	BCS.s		no_inc_min			; if > skip the increment
                            	  1718: 
00:0000B4F6 522D007D        	  1719: 	ADDQ.b	#1,min_rocks(a5)		; else decrement the minimum rock count before
                            	  1720: 							; the saucer initial timer starts to decrement
                            	  1721: no_inc_min
00:0000B4FA 7800            	  1722: 	MOVEQ		#0,d4				; clear the longword
00:0000B4FC 182D0075        	  1723: 	MOVE.b	i_rk_count(a5),d4		; get the initial rock count
00:0000B500 5404            	  1724: 	ADDQ.b	#2,d4				; + 2
00:0000B502 0C04000B        	  1725: 	CMPI.b	#11,d4			; compare the new rock count with 11 rocks
00:0000B506 6302            	  1726: 	BLS.s		no_set_max			; if less or equal just use it
                            	  1727: 
00:0000B508 780B            	  1728: 	MOVEQ		#11,d4			; else set the new rock count to 11
                            	  1729: no_set_max
00:0000B50A 1B440076        	  1730: 	MOVE.b	d4,rock_count(a5)		; save the rock count
00:0000B50E 1B440075        	  1731: 	MOVE.b	d4,i_rk_count(a5)		; save the initial rock count
                            	  1732: 
00:0000B512 7E1C            	  1733: 	MOVEQ		#s_xvel_off-x_vel_off,d7
                            	  1734: 							; set the index to the saucer for a zero initial
                            	  1735: 							; velocity
                            	  1736: 
00:0000B514 5344            	  1737: 	SUBQ.w	#1,d4				; adjust for the loop type
                            	  1738: gen_rock_loop
00:0000B516 610008BA        	  1739: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B51A 7018            	  1740: 	MOVEQ		#$18,d0			; set the rock type mask
00:0000B51C C02B000A        	  1741: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000B520 00000004        	  1742: 	ORI.b		#$04,d0			; set the rock size to the largest
00:0000B524 1B80500C        	  1743: 	MOVE.b	d0,flags_off(a5,d5.w)	; save the rock flag
00:0000B528 610000C4        	  1744: 	BSR		copy_velocity		; copy the saucer velocity, (d7), plus a random
                            	  1745: 							; delta x,y velocity to the new rock, (d5),
                            	  1746: 							; velocity
                            	  1747: 
00:0000B52C 610008A4        	  1748: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B530 7200            	  1749: 	MOVEQ		#0,d1				; clear the other axis position
00:0000B532 303C3FFF        	  1750: 	MOVE.w	#$3FFF,d0			; set the starting position mask
00:0000B536 C06B000A        	  1751: 	AND.w		PRNlword(a3),d0		; mask a pseudo random word
00:0000B53A E248            	  1752: 	LSR.w		#1,d0				; shift a random bit into Cb
00:0000B53C 640C            	  1753: 	BCC.s		rock_on_x			; if Cb = 0 go set the rock at a point along
                            	  1754: 							; the x axis
                            	  1755: 
                            	  1756: ; set the rock at a point along the y axis
                            	  1757: 
00:0000B53E 0C401800        	  1758: 	CMPI.w	#$1800,d0			; compare the position with the y axis maximum
00:0000B542 6504            	  1759: 	BCS.s		rock_y_ok			; if less just use it
                            	  1760: 
00:0000B544 024017FF        	  1761: 	ANDI.w	#$17FF,d0			; mask the position to the y axis maximum
                            	  1762: rock_y_ok
00:0000B548 C340            	  1763: 	EXG		d1,d0				; swap y value to d1, zero to d0
                            	  1764: 
                            	  1765: ; set the rock at a point along the x axis
                            	  1766: 
                            	  1767: rock_on_x
00:0000B54A 3B806080        	  1768: 	MOVE.w	d0,x_pos_off(a5,d6.w)	; save the rock x position
00:0000B54E 3B8160C6        	  1769: 	MOVE.w	d1,y_pos_off(a5,d6.w)	; save the rock y position
00:0000B552 5546            	  1770: 	SUBQ.w	#2,d6				; decrement the rock position index
00:0000B554 5345            	  1771: 	SUBQ.w	#1,d5				; decrement the rock count/index
00:0000B556 51CCFFBE        	  1772: 	DBF		d4,gen_rock_loop		; decrement the new rock count and loop if more
                            	  1773: 							; to do
                            	  1774: 
00:0000B55A 1B7C007F0077    	  1775: 	MOVE.b	#$7F,sauc_cntdn(a5)	; set the saucer countdown timer
00:0000B560 1B7C0034007C    	  1776: 	MOVE.b	#$34,thmp_sndi(a5)	; reset the thump sound change timer initial
                            	  1777: 							; value
00:0000B566 177C00080023    	  1778: 	MOVE.b	#beat1_snd,thump_snd(a3)
                            	  1779: 							; reset the thump sound value
                            	  1780: 
                            	  1781: ; now clear all the other rocks
                            	  1782: 
                            	  1783: clear_rocks
00:0000B56C 7000            	  1784: 	MOVEQ		#0,d0				; clear the longword
                            	  1785: clear_rocks_loop
00:0000B56E 1B80500C        	  1786: 	MOVE.b	d0,flags_off(a5,d5.w)	; clear the rock flag
00:0000B572 51CDFFFA        	  1787: 	DBF		d5,clear_rocks_loop	; decrement the count and loop if more to do
                            	  1788: 
                            	  1789: exit_make_rocks
00:0000B576 4E75            	  1790: 	rts
                            	  1791: 
                            	  1792: 
                            	  1793: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1794: ;
                            	  1795: ; initialise the player variables
                            	  1796: 
                            	  1797: player_init:
00:0000B578 1B6B001B0082    	  1798: 	move.b ss_count(a3),ships_off(a5)
                            	  1799: 							; set the player's starting ship count
00:0000B57E 1B7C00920078    	  1800: 	move.b #$92,i_sauc_tim(a5)	; set the small saucer boundary/initial saucer
                            	  1801: 							; timer
00:0000B584 1B7C00920077    	  1802: 	move.b #$92,sauc_cntdn(a5)	; set the saucer countdown timer
00:0000B58A 1B7C007F007B    	  1803: 	move.b #$7F,new_rocks(a5)	; set the generate new rocks flag
                            	  1804: 
00:0000B590 1B7C0005007D    	  1805: 	move.b #$05,min_rocks(a5)	; set the minimum rock count before the saucer
                            	  1806: 							; initial timer starts to decrement
00:0000B596 1B7C0034007C    	  1807: 	move.b #$34,thmp_sndi(a5)	; reset the thump sound change timer initial
                            	  1808: 							; value
00:0000B59C 177C00080023    	  1809: 	move.b #beat1_snd,thump_snd(a3)	; reset the thump sound value
00:0000B5A2 1B7C00FF0083    	  1810: 	move.b #$FF,high_off(a5)		; clear the player highscore flag
00:0000B5A8 1B7C0001007A    	  1811: 	move.b #$01,hide_p_cnt(a5)	; set the hide the player count
                            	  1812: 
                            	  1813: 
                            	  1814: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1815: ;
                            	  1816: ; reset the player velocity and position
                            	  1817: 
                            	  1818: player_reset:
00:0000B5AE 3B7C1000FFB6    	  1819: 	move.w #$1000,p_xpos_off(a5)	; set the player x position
00:0000B5B4 3B7C0C00FFFC    	  1820: 	move.w #$0C00,p_ypos_off(a5)	; set the player y position
00:0000B5BA 422D004A        	  1821: 	clr.b p_xvel_off(a5)					; clear the player x velocity
00:0000B5BE 422D006D        	  1822: 	clr.b p_yvel_off(a5)					; clear the player y velocity
00:0000B5C2 4E75            	  1823: 	rts
                            	  1824: 
                            	  1825: 
                            	  1826: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1827: ;
                            	  1828: ; copy the item parameters from the old rock, (d7), to the new rock, (d5)
                            	  1829: 
                            	  1830: copy_rock:
00:0000B5C4 3807            	  1831: 	MOVE.w	d7,d4				; copy the old rock index
00:0000B5C6 D844            	  1832: 	ADD.w		d4,d4				; ; 2 for the old rock position index
                            	  1833: 
                            	  1834: copy_rock_2
00:0000B5C8 3605            	  1835: 	MOVE.w	d5,d3				; copy the new rock index
00:0000B5CA D643            	  1836: 	ADD.w		d3,d3				; ; 2 for the new rock position index
                            	  1837: 
00:0000B5CC 7207            	  1838: 	MOVEQ		#$07,d1			; set the size mask
00:0000B5CE C235700C        	  1839: 	AND.b		flags_off(a5,d7.w),d1	; mask the old rock size
00:0000B5D2 610007FE        	  1840: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B5D6 7018            	  1841: 	MOVEQ		#$18,d0			; set the rock type mask
00:0000B5D8 C02B000A        	  1842: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000B5DC 8001            	  1843: 	OR.b		d1,d0				; OR in the old rock size
00:0000B5DE 1B80500C        	  1844: 	MOVE.b	d0,flags_off(a5,d5.w)	; save the new rock flag
                            	  1845: 
00:0000B5E2 3BB540803080    	  1846: 	MOVE.w	x_pos_off(a5,d4.w),x_pos_off(a5,d3.w)
                            	  1847: 							; copy the old rock x position to the new rock
                            	  1848: 							; x position
00:0000B5E8 3BB540C630C6    	  1849: 	MOVE.w	y_pos_off(a5,d4.w),y_pos_off(a5,d3.w)
                            	  1850: 							; copy the old rock y position to the new rock
                            	  1851: 							; y position
                            	  1852: 
                            	  1853: 
                            	  1854: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1855: ;
                            	  1856: ; copy the old rock, (d7), velocity plus random delta x,y velocity to the new rock,
                            	  1857: ; (d5), velocity
                            	  1858: 
                            	  1859: copy_velocity:
00:0000B5EE 610007E2        	  1860: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B5F2 708F            	  1861: 	MOVEQ		#$8F,d0			; mask +/- $00 to $0F
00:0000B5F4 C02B000A        	  1862: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000B5F8 6A04            	  1863: 	BPL.s		x_off_pos			; skip bits set if positive
                            	  1864: 
00:0000B5FA 00000070        	  1865: 	ORI.b		#$70,d0			; else make $Fx
                            	  1866: x_off_pos
00:0000B5FE D035702F        	  1867: 	ADD.b		x_vel_off(a5,d7.w),d0	; add the item (d7) to the delta x velocity
00:0000B602 6120            	  1868: 	BSR.s		limit_velocity		; ensure velocity is within limits
00:0000B604 1B80502F        	  1869: 	MOVE.b	d0,x_vel_off(a5,d5.w)	; save the rock x velocity
                            	  1870: 
                            	  1871: 
00:0000B608 610007C8        	  1872: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B60C 708F            	  1873: 	MOVEQ		#$8F,d0			; mask +/- $00 to $0F
00:0000B60E C02B000A        	  1874: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000B612 6A04            	  1875: 	BPL.s		y_off_pos			; skip bits set if positive
                            	  1876: 
00:0000B614 00000070        	  1877: 	ORI.b		#$70,d0			; else make $Fx
                            	  1878: y_off_pos
00:0000B618 D0357052        	  1879: 	ADD.b		y_vel_off(a5,d7.w),d0	; add the item (d5) to the delta y velocity
00:0000B61C 6106            	  1880: 	BSR.s		limit_velocity		; ensure velocity is within limits
00:0000B61E 1B805052        	  1881: 	MOVE.b	d0,y_vel_off(a5,d5.w)	; save the rock y velocity
                            	  1882: 
00:0000B622 4E75            	  1883: 	RTS
                            	  1884: 
                            	  1885: 
                            	  1886: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1887: ;
                            	  1888: ; ensure velocity is within limits
                            	  1889: 
                            	  1890: limit_velocity:
00:0000B624 6A12            	  1891: 	BPL.s		limit_p_vel			; if positive go test positive limit
                            	  1892: 
00:0000B626 0C0000E1        	  1893: 	CMPI.b	#$E1,d0			; compare velocity with upper limit
00:0000B62A 6402            	  1894: 	BCC.s		neg_upper_ok		; if less skip set
                            	  1895: 
00:0000B62C 70E1            	  1896: 	MOVEQ		#$E1,d0			; else set velocity to -$1F
                            	  1897: neg_upper_ok
00:0000B62E 0C0000FB        	  1898: 	CMPI.b	#$FB,d0			; compare velocity with lower limit
00:0000B632 6514            	  1899: 	BCS.s		exit_limit_velocity	; if greater just exit
                            	  1900: 
00:0000B634 70FA            	  1901: 	MOVEQ		#$FA,d0			; else set velocity to -$06
00:0000B636 4E75            	  1902: 	RTS
                            	  1903: 
                            	  1904: ; test velocity positive limit
                            	  1905: 
                            	  1906: limit_p_vel
00:0000B638 0C000006        	  1907: 	CMPI.b	#$06,d0			; compare velocity with lower limit
00:0000B63C 6402            	  1908: 	BCC.s		pos_lower_ok		; skip set if greater
                            	  1909: 
00:0000B63E 7006            	  1910: 	MOVEQ		#$06,d0			; else set velocity to $06
                            	  1911: pos_lower_ok
00:0000B640 0C000020        	  1912: 	CMPI.b	#$20,d0			; compare velocity with upper limit
00:0000B644 6502            	  1913: 	BCS.s		exit_limit_velocity	; if less just exit
                            	  1914: 
00:0000B646 701F            	  1915: 	MOVEQ		#$1F,d0			; else set velocity to $1F
                            	  1916: exit_limit_velocity
00:0000B648 4E75            	  1917: 	RTS
                            	  1918: 
                            	  1919: 
                            	  1920: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1921: ;
                            	  1922: ; add (c), scores and players ships to the vector list
                            	  1923: 
                            	  1924: static_messages:
00:0000B64A 43FA18E2        	  1925: 	LEA		copy_msg(pc),a1		; set the pointer to the copyright message
00:0000B64E 610006BA        	  1926: 	BSR		add_address			; convert the a1 address and add it to the
                            	  1927: 							; vector list as a vector subroutine call
                            	  1928: 
00:0000B652 36BC1000        	  1929: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
00:0000B656 7219            	  1930: 	MOVEQ		#$19,d1			; set the score x co-ordinate
00:0000B658 343C00D7        	  1931: 	MOVE.w	#$D7,d2			; set the score y co-ordinate
00:0000B65C 610006C2        	  1932: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1933: 							; a draw command
                            	  1934: 
00:0000B660 323C7000        	  1935: 	MOVE.w	#REL7,d1			; make a $7000,$0000 command
00:0000B664 610006D4        	  1936: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  1937: 
00:0000B668 0C2B0002001A    	  1938: 	CMPI.b	#$02,num_players(a3)	; compare the number of players in the game
00:0000B66E 661E            	  1939: 	BNE.s		skip_play_flash		; if not two players skip flashing the active
                            	  1940: 							; player
                            	  1941: 
00:0000B670 4A2B0018        	  1942: 	TST.b		player_idx(a3)		; test the player index
00:0000B674 6618            	  1943: 	BNE.s		skip_play_flash		; if player 2 go add the player to the vector
                            	  1944: 							; list
                            	  1945: 
00:0000B676 102D0027        	  1946: 	MOVE.b	p_flag_off(a5),d0		; get the player flag
00:0000B67A 802B0026        	  1947: 	OR.b		hyper(a3),d0		; OR with the hyperspace flag
00:0000B67E 660E            	  1948: 	BNE.s		skip_play_flash		; if playing go add player 1's score to the
                            	  1949: 							; vector list
                            	  1950: 
00:0000B680 4A2D007A        	  1951: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:0000B684 6B08            	  1952: 	BMI.s		skip_play_flash		; if the player is dieing go display the score
                            	  1953: 
00:0000B686 082B0004005A    	  1954: 	BTST.b	#4,game_count+1(a3)	; test a bit in the game counter low byte
00:0000B68C 6714            	  1955: 	BEQ.s		do_p1_ships			; skip the score display if the flash is off
                            	  1956: 
                            	  1957: ; add the active player to the vector list
                            	  1958: 
                            	  1959: skip_play_flash
00:0000B68E 43EB0173        	  1960: 	LEA		p1_score(a3),a1		; point to player 1's score
00:0000B692 7E02            	  1961: 	MOVEQ		#$02,d7			; set the number byte count
00:0000B694 17470016        	  1962: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000B698 61000512        	  1963: 	BSR		output_number		; output the number (a1) as a leading zero
                            	  1964: 							; suppressed character string
00:0000B69C 7200            	  1965: 	MOVEQ		#0,d1				; add player 1's score's trailing "0"
00:0000B69E 61000650        	  1966: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  1967: 
                            	  1968: do_p1_ships
00:0000B6A2 7229            	  1969: 	MOVEQ		#$29,d1			; set the x co-ordinate for player 1's ships
00:0000B6A4 7E00            	  1970: 	MOVEQ		#0,d7				; clear the longword
00:0000B6A6 1E2B0175        	  1971: 	MOVE.b	p1_ships(a3),d7		; get player 1's ship count
00:0000B6AA 6100FBB2        	  1972: 	BSR		add_ships			; add d7 ships to the vector list
                            	  1973: 
00:0000B6AE 4253            	  1974: 	MOVE.w	#$0000,glob_scale(a3)	; set the global scale
                            	  1975: 
00:0000B6B0 7278            	  1976: 	MOVEQ		#$78,d1			; set the high score x co-ordinate
00:0000B6B2 343C00D7        	  1977: 	MOVE.w	#$D7,d2			; set the high score y co-ordinate
00:0000B6B6 61000668        	  1978: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1979: 							; a draw command
00:0000B6BA 323C5000        	  1980: 	MOVE.w	#REL5,d1			; make a $5000,$0000 command
00:0000B6BE 6100067A        	  1981: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  1982: 
00:0000B6C2 43EB0027        	  1983: 	LEA		hiscores(a3),a1		; point to the highest high score
00:0000B6C6 7E02            	  1984: 	MOVEQ		#$02,d7			; set the number byte count
00:0000B6C8 17470016        	  1985: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000B6CC 610004DE        	  1986: 	BSR		output_number		; output the number (a1) as a leading zero
                            	  1987: 							; suppressed character string
                            	  1988: 
00:0000B6D0 7200            	  1989: 	MOVEQ		#0,d1				; add the high score trailing "0"
00:0000B6D2 6100061C        	  1990: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  1991: 
00:0000B6D6 36BC1000        	  1992: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
                            	  1993: 
00:0000B6DA 323C00C0        	  1994: 	MOVE.w	#$C0,d1			; set the score x co-ordinate
00:0000B6DE 343C00D7        	  1995: 	MOVE.w	#$D7,d2			; set the score y co-ordinate
00:0000B6E2 6100063C        	  1996: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1997: 							; a draw command
00:0000B6E6 323C5000        	  1998: 	MOVE.w	#REL5,d1			; make a $5000,$0000 command
00:0000B6EA 6100064E        	  1999: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  2000: 
00:0000B6EE 0C2B0001001A    	  2001: 	CMPI.b	#$01,num_players(a3)	; compare the number of players in the game
                            	  2002: 							; with one
00:0000B6F4 6742            	  2003: 	BEQ.s		exit_static			; if just one player skip displaying p2 score
                            	  2004: 
00:0000B6F6 651E            	  2005: 	BCS.s		do_p2_score			; if no players go add player 2's score to
                            	  2006: 							; the vector list
                            	  2007: 
00:0000B6F8 4A2B0018        	  2008: 	TST.b		player_idx(a3)		; test the player index
00:0000B6FC 6718            	  2009: 	BEQ.s		do_p2_score			; if player 1 go add the player to the vector
                            	  2010: 							; list
                            	  2011: 
00:0000B6FE 102D0027        	  2012: 	MOVE.b	p_flag_off(a5),d0		; get the player flag
00:0000B702 802B0026        	  2013: 	OR.b		hyper(a3),d0		; OR with the hyperspace flag
00:0000B706 660E            	  2014: 	BNE.s		do_p2_score			; if playing go add player 2's score to the
                            	  2015: 							; vector list
                            	  2016: 
00:0000B708 4A2D007A        	  2017: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:0000B70C 6B08            	  2018: 	BMI.s		do_p2_score			; if the player is dieing go display the score
                            	  2019: 
00:0000B70E 082B0004005A    	  2020: 	BTST.b	#4,game_count+1(a3)	; test a bit in the game counter low byte
00:0000B714 6714            	  2021: 	BEQ.s		skip_p2_score		; skip the score display if the flash is off
                            	  2022: 
                            	  2023: do_p2_score
00:0000B716 43EB0277        	  2024: 	LEA		p2_score(a3),a1		; point to player 2's score
00:0000B71A 7E02            	  2025: 	MOVEQ		#$02,d7			; set the number byte count
00:0000B71C 17470016        	  2026: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000B720 6100048A        	  2027: 	BSR		output_number		; output the number (a1) as a leading zero
                            	  2028: 							; suppressed character string
00:0000B724 7200            	  2029: 	MOVEQ		#0,d1				; add player 2's score's trailing "0"
00:0000B726 610005C8        	  2030: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  2031: 
                            	  2032: skip_p2_score
00:0000B72A 323C00D0        	  2033: 	MOVE.w	#$D0,d1			; set the x co-ordinate for player 2's ships
00:0000B72E 7E00            	  2034: 	MOVEQ		#0,d7				; clear the longword
00:0000B730 1E2B0279        	  2035: 	MOVE.b	p2_ships(a3),d7		; get player 2's ship count
00:0000B734 6000FB28        	  2036: 	BRA		add_ships			; add d7 ships to the vector list and return
                            	  2037: 
                            	  2038: exit_static
00:0000B738 4E75            	  2039: 	RTS
                            	  2040: 
                            	  2041: 
                            	  2042: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2043: ;
                            	  2044: ; add an item to the vector list
                            	  2045: ;
                            	  2046: ; d6 = object flag offset
                            	  2047: ; d7 = position offset
                            	  2048: 
                            	  2049: 							; first add the DRAW to the item's origin
                            	  2050: add_to_list:
00:0000B73A 303570C6        	  2051: 	MOVE.w	y_pos_off(a5,d7.w),d0	; get the y position
00:0000B73E D07C0400        	  2052: 	ADD.w		#$0400,d0			; add offset so y is centred around 512
00:0000B742 E648            	  2053: 	LSR.w		#3,d0				; / 8
00:0000B744 0040A000        	  2054: 	ORI.w		#DRAW,d0			; OR in the draw command
00:0000B748 38C0            	  2055: 	MOVE.w	d0,(a4)+			; add it to the vector list
                            	  2056: 
00:0000B74A 30357080        	  2057: 	MOVE.w	x_pos_off(a5,d7.w),d0	; get the x position
00:0000B74E E648            	  2058: 	LSR.w		#3,d0				; / 8
00:0000B750 8041            	  2059: 	OR.w		d1,d0				; OR in the global scale
00:0000B752 38C0            	  2060: 	MOVE.w	d0,(a4)+			; add it to the vector list
                            	  2061: 
00:0000B754 7200            	  2062: 	MOVEQ		#0,d1				; clear the longword
00:0000B756 1235600C        	  2063: 	MOVE.b	flags_off(a5,d6.w),d1	; get the object flag
00:0000B75A 6A12            	  2064: 	BPL.s		add_item			; if not exploding go add the item to the
                            	  2065: 							; vector list
                            	  2066: 
                            	  2067: 							; else add an exploding item
00:0000B75C 0C06001B        	  2068: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  2069: 							; compare the index with the player index
00:0000B760 6700014A        	  2070: 	BEQ		add_play_explode		; if it is the player go add ship pieces to the
                            	  2071: 							; vector list
                            	  2072: 
00:0000B764 0201000C        	  2073: 	ANDI.b	#$0C,d1			; else mask the rock type
00:0000B768 43FA1804        	  2074: 	LEA		expl_tab(pc),a1		; point to the explosion JSRL table
00:0000B76C 601A            	  2075: 	BRA.s		add_explode			; go add the JSRL word to the vector list and
                            	  2076: 							; return
                            	  2077: 
                            	  2078: ; add item d6 to the vector list
                            	  2079: 
                            	  2080: add_item:
00:0000B76E 0C06001B        	  2081: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  2082: 							; compare the index with the player index
00:0000B772 670001DE        	  2083: 	BEQ		add_player			; if = go add the player to the vector list
                            	  2084: 
00:0000B776 0C06001C        	  2085: 	CMPI.b	#s_flag_off-flags_off,d6
                            	  2086: 							; compare the index with the saucer index
00:0000B77A 6712            	  2087: 	BEQ.s		add_saucer			; if = go add the saucer to the vector list
                            	  2088: 
00:0000B77C 6416            	  2089: 	BCC.s		add_fire			; if > saucer go add fire to the vector list
                            	  2090: 
                            	  2091: 							; else add a rock to the vector list
00:0000B77E 02410018        	  2092: 	ANDI.w	#$0018,d1			; mask the rock type
00:0000B782 E449            	  2093: 	LSR.w		#2,d1				; >> 3 << 1
00:0000B784 43FA18CE        	  2094: 	LEA		rock_tab(pc),a1		; point to the rock JSRL table
                            	  2095: add_explode
00:0000B788 38F11000        	  2096: 	MOVE.w	(a1,d1.w),(a4)+		; add the JSRL word to the vector list
00:0000B78C 4E75            	  2097: 	RTS
                            	  2098: 
                            	  2099: ; add the saucer to the vector list
                            	  2100: 
                            	  2101: add_saucer:
00:0000B78E 38FA1936        	  2102: 	MOVE.w	sauc_jsr(pc),(a4)+	; add the saucer JSRL to the vector list
00:0000B792 4E75            	  2103: 	RTS
                            	  2104: 
                            	  2105: ; add fire to the vector list
                            	  2106: 
                            	  2107: add_fire:
00:0000B794 38FA1DFE        	  2108: 	MOVE.w	shot_jsr(pc),(a4)+	; add the shot JSRL to the vector list
                            	  2109: 
00:0000B798 7003            	  2110: 	MOVEQ		#3,d0				; set the game counter mask
00:0000B79A C06B0059        	  2111: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000B79E 6604            	  2112: 	BNE.s		no_shot_dec			; skip the shot decrement 3/4 of the time
                            	  2113: 
00:0000B7A0 5335600C        	  2114: 	SUBQ.b	#1,flags_off(a5,d6.w)	; decrement fire item (d7) flag
                            	  2115: no_shot_dec
00:0000B7A4 4E75            	  2116: 	RTS
                            	  2117: 
                            	  2118: 
                            	  2119: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2120: ;
                            	  2121: ; add d1.b to the current player's score
                            	  2122: 
                            	  2123: add_score:
00:0000B7A6 44FC0004        	  2124: 	MOVE.w	#4,CCR			; set Zb, clear everything else
00:0000B7AA 142D0081        	  2125: 	MOVE.b	score_off+1(a5),d2	; get the player's score, tens
00:0000B7AE C501            	  2126: 	ABCD.b	d1,d2				; add the value to the score
00:0000B7B0 6422            	  2127: 	BCC.s		exit_add_score		; if no carry just exit
                            	  2128: 
00:0000B7B2 7200            	  2129: 	MOVEQ		#0,d1				; clear the add high byte
00:0000B7B4 102D0080        	  2130: 	MOVE.b	score_off(a5),d0		; get the player's score, thousands
00:0000B7B8 C101            	  2131: 	ABCD.b	d1,d0				; add the value to the score
00:0000B7BA 1B400080        	  2132: 	MOVE.b	d0,score_off(a5)		; save the player's score, thousands
                            	  2133: 
00:0000B7BE 0200000F        	  2134: 	ANDI.b	#$0F,d0			; mask the units of thousands
00:0000B7C2 6610            	  2135: 	BNE.s		exit_add_score		; if the score is not x0000 just exit
                            	  2136: 
00:0000B7C4 720A            	  2137: 	MOVEQ		#extra_snd,d1		; set the bonus ship sound
00:0000B7C6 61002196        	  2138: 	BSR		play_sample			; go play the sample
                            	  2139: 
00:0000B7CA 522D0082        	  2140: 	ADDQ.b	#1,ships_off(a5)		; increment the player's ship count
00:0000B7CE 6604            	  2141: 	BNE.s		exit_add_score		; exit if not wrappwd
                            	  2142: 
00:0000B7D0 532D0082        	  2143: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
                            	  2144: exit_add_score
00:0000B7D4 1B420081        	  2145: 	MOVE.b	d2,score_off+1(a5)	; save the player's score, tens
00:0000B7D8 4E75            	  2146: 	RTS
                            	  2147: 
                            	  2148: 
                            	  2149: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2150: ;
                            	  2151: ; display the high score table if the game is over
                            	  2152: 
                            	  2153: high_scores:
00:0000B7DA 4A2B001A        	  2154: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000B7DE 660000A0        	  2155: 	BNE		exit_no_scores		; if playing skip the high scores
                            	  2156: 
00:0000B7E2 082B00020059    	  2157: 	BTST.b	#2,game_count(a3)		; test a bit in the game counter high byte
00:0000B7E8 66000096        	  2158: 	BNE		exit_no_scores		; if not high score time just exit
                            	  2159: 
00:0000B7EC 45EB0027        	  2160: 	LEA		hiscores(a3),a2		; point to the high score table
                            	  2161: 
00:0000B7F0 4A52            	  2162: 	TST.w		(a2)				; test the highest high score
00:0000B7F2 6700008C        	  2163: 	BEQ		exit_no_scores		; if the high score table is empty just exit
                            	  2164: 
00:0000B7F6 7200            	  2165: 	MOVEQ		#0,d1				; message 0 - "HIGH SCORES"
00:0000B7F8 61000470        	  2166: 	BSR		add_message			; add message d1 to the display list
                            	  2167: 
00:0000B7FC 36BC1000        	  2168: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
                            	  2169: 
00:0000B800 41EB003B        	  2170: 	LEA		hinames(a3),a0		; point to the high score names
00:0000B804 7C00            	  2171: 	MOVEQ		#0,d6				; clear the high score index
00:0000B806 377C00A70012    	  2172: 	MOVE.w	#$00A7,hiscore_y(a3)	; set the score's y co-ordinate
                            	  2173: high_scores_loop
00:0000B80C 4A52            	  2174: 	TST.w		(a2)				; test the high score entry
00:0000B80E 676A            	  2175: 	BEQ.s		exit_high_scores		; if this score is zero just exit
                            	  2176: 
00:0000B810 725F            	  2177: 	MOVEQ		#$5F,d1			; set the score's x co-ordinate
00:0000B812 342B0012        	  2178: 	MOVE.w	hiscore_y(a3),d2		; get the score's y co-ordinate
00:0000B816 61000508        	  2179: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  2180: 							; a draw command
                            	  2181: 
00:0000B81A 323C4000        	  2182: 	MOVE.w	#REL4,d1			; make a $4000,$0000 command
00:0000B81E 6100051A        	  2183: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  2184: 
00:0000B822 43EB0017        	  2185: 	LEA		high_idx(a3),a1		; point to the high score index
00:0000B826 7E01            	  2186: 	MOVEQ		#$01,d7			; set the number byte count and the increment
00:0000B828 44FC0004        	  2187: 	MOVE.w	#4,CCR			; set Zb, clear everything else
00:0000B82C CD07            	  2188: 	ABCD.b	d7,d6				; add to the high score index
00:0000B82E 1286            	  2189: 	MOVE.b	d6,(a1)			; save the high score decimal index
00:0000B830 17470016        	  2190: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000B834 61000376        	  2191: 	BSR		output_number		; output a number as a leading zero suppressed
                            	  2192: 							; string
                            	  2193: 
                            	  2194: 							; set the point after the high score number
00:0000B838 323C4000        	  2195: 	MOVE.w	#REL4,d1			; make a $4000,$xx00 command
00:0000B83C 3401            	  2196: 	MOVE.w	d1,d2				; make a $4000,$4000 command, point after entry
                            	  2197: 							; number
00:0000B83E 610004FC        	  2198: 	BSR		add_pair			; add (d1)00,(d2)00 to the vector list
                            	  2199: 
00:0000B842 7200            	  2200: 	MOVEQ		#0,d1				; set [SPACE] character
00:0000B844 6100FA08        	  2201: 	BSR		add_character		; add character (d1) to the vector list
                            	  2202: 
00:0000B848 224A            	  2203: 	MOVEA.l	a2,a1				; point to the high score entry
00:0000B84A 7E02            	  2204: 	MOVEQ		#$02,d7			; set the number byte count
00:0000B84C 177C00FF0016    	  2205: 	MOVE.b	#-1,suppress_0(a3)	; set the flag to suppress leading zeros
00:0000B852 61000358        	  2206: 	BSR		output_number		; output a number as a leading zero suppressed
                            	  2207: 							; string
                            	  2208: 
00:0000B856 7200            	  2209: 	MOVEQ		#0,d1				; add the final "0"
00:0000B858 61000496        	  2210: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  2211: 
00:0000B85C 7200            	  2212: 	MOVEQ		#0,d1				; set [SPACE] character
00:0000B85E 6100F9EE        	  2213: 	BSR		add_character		; add character (d1) to the vector list
                            	  2214: 
00:0000B862 6100F9D0        	  2215: 	BSR		write_initial		; write a high score initial to the vector list
00:0000B866 6100F9CC        	  2216: 	BSR		write_initial		; write a high score initial to the vector list
00:0000B86A 6100F9C8        	  2217: 	BSR		write_initial		; write a high score initial to the vector list
                            	  2218: 
00:0000B86E 516B0012        	  2219: 	SUBQ.w	#8,hiscore_y(a3)		; subtract 8 from the score's y co-ordinate
00:0000B872 544A            	  2220: 	ADDQ.w	#2,a2				; increment the high score pointer
                            	  2221: 
00:0000B874 0C060010        	  2222: 	CMPI.b	#$10,d6			; compare the high score index with 10
00:0000B878 6592            	  2223: 	BCS.s		high_scores_loop		; loop if more to do
                            	  2224: 
                            	  2225: exit_high_scores
00:0000B87A 003C0001        	  2226: 	ORI.b		#$01,CCR			; set the carry, flag scores displayed
00:0000B87E 4E75            	  2227: 	RTS
                            	  2228: 
                            	  2229: exit_no_scores
00:0000B880 023C00FE        	  2230: 	ANDI.b	#$FE,CCR			; clear the carry, flag scores not displayed
00:0000B884 4E75            	  2231: 	RTS
                            	  2232: 
                            	  2233: 
                            	  2234: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2235: ;
                            	  2236: ; find a free rock item, the index is returned in d5
                            	  2237: 
                            	  2238: find_rock:
00:0000B886 7A1A            	  2239: 	MOVEQ		#p_flag_off-flags_off-1,d5
                            	  2240: 							; set the count/index to the last rock flag
                            	  2241: 
                            	  2242: ; find a free rock item from d5
                            	  2243: 
                            	  2244: find_next_rock
00:0000B888 4A35500C        	  2245: 	TST.b		flags_off(a5,d5.w)	; test the rock flag
00:0000B88C 6704            	  2246: 	BEQ.s		exit_find_rock		; if free return this index
                            	  2247: 
00:0000B88E 51CDFFF8        	  2248: 	DBF		d5,find_next_rock		; else loop if more to do
                            	  2249: 
                            	  2250: exit_find_rock
00:0000B892 4E75            	  2251: 	RTS
                            	  2252: 
                            	  2253: 
                            	  2254: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2255: ;
                            	  2256: ; wrecked ship piece x,y velocities
                            	  2257: 
                            	  2258: ship_wrk_x
00:0000B894 FFD8            	  2259: 	dc.w	$FFD8					; x
00:0000B896 0032            	  2260: 	dc.w	$0032					; x
00:0000B898 0000            	  2261: 	dc.w	$0000					; x
00:0000B89A 003C            	  2262: 	dc.w	$003C					; x
00:0000B89C 000A            	  2263: 	dc.w	$000A					; x
00:0000B89E FFD8            	  2264: 	dc.w	$FFD8					; x
                            	  2265: 
                            	  2266: ship_wrk_y
00:0000B8A0 001E            	  2267: 	dc.w	$001E					; y
00:0000B8A2 FFEC            	  2268: 	dc.w	$FFEC					; y
00:0000B8A4 FFC4            	  2269: 	dc.w	$FFC4					; y
00:0000B8A6 0014            	  2270: 	dc.w	$0014					; y
00:0000B8A8 0046            	  2271: 	dc.w	$0046					; y
00:0000B8AA FFD8            	  2272: 	dc.w	$FFD8					; y
                            	  2273: 
                            	  2274: 
                            	  2275: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2276: ;
                            	  2277: ; add the player explosion to the vector list
                            	  2278: 
                            	  2279: add_play_explode:
00:0000B8AC 48E70300        	  2280: 	MOVEM.l	d6-d7,-(sp)			; save the registers
00:0000B8B0 7200            	  2281: 	MOVEQ		#0,d1				; clear the longword
00:0000B8B2 122D0027        	  2282: 	MOVE.b	p_flag_off(a5),d1		; get the player flag
00:0000B8B6 0C0100A2        	  2283: 	CMPI.b	#$A2,d1			; compare the player flag with $A2
00:0000B8BA 641A            	  2284: 	BCC.s		no_reset_xy			; if >= $A2 skip resetting the explosion
                            	  2285: 							; start point
                            	  2286: 
                            	  2287: 							; else reset the explosion start point
00:0000B8BC 7E0A            	  2288: 	MOVEQ		#$0A,d7			; set the index to the last piece x,y pair
                            	  2289: reset_xy_loop
00:0000B8BE 303B70D4        	  2290: 	MOVE.w	ship_wrk_x(pc,d7.w),d0	; get the x velocity word
00:0000B8C2 E948            	  2291: 	LSL.w		#4,d0				; ; 16
00:0000B8C4 3780705B        	  2292: 	MOVE.w	d0,expl_x_pos(a3,d7.w)	; save the x position word
                            	  2293: 
00:0000B8C8 303B70D6        	  2294: 	MOVE.w	ship_wrk_y(pc,d7.w),d0	; get the y velocity word
00:0000B8CC E948            	  2295: 	LSL.w		#4,d0				; ; 16
00:0000B8CE 37807067        	  2296: 	MOVE.w	d0,expl_y_pos(a3,d7.w)	; save the y position word
                            	  2297: 
00:0000B8D2 5547            	  2298: 	SUBQ.w	#2,d7				; decrement the index
00:0000B8D4 6AE8            	  2299: 	BPL.s		reset_xy_loop		; loop if more to do
                            	  2300: 
                            	  2301: ; now use the player flag as the start index to the ship pieces. this means there will
                            	  2302: ; be less pieces as the explosion progresses
                            	  2303: 
                            	  2304: no_reset_xy
00:0000B8D6 7070            	  2305: 	MOVEQ		#$70,d0			; set the mask
00:0000B8D8 B101            	  2306: 	EOR.b		d0,d1				; toggle the player flag
00:0000B8DA C200            	  2307: 	AND.b		d0,d1				; mask the player flag
00:0000B8DC E609            	  2308: 	LSR.b		#3,d1				; / 16 ; 2 gives the piece start index
00:0000B8DE 3E01            	  2309: 	MOVE.w	d1,d7				; copy the index
                            	  2310: 
                            	  2311: 							; the piece draw loop	
                            	  2312: piece_draw_loop
00:0000B8E0 303B70B2        	  2313: 	MOVE.w	ship_wrk_x(pc,d7.w),d0	; get the x velocity word
00:0000B8E4 D073705B        	  2314: 	ADD.w		expl_x_pos(a3,d7.w),d0	; add the x position word
00:0000B8E8 3780705B        	  2315: 	MOVE.w	d0,expl_x_pos(a3,d7.w)	; save the x position word
                            	  2316: 
00:0000B8EC 323B70B2        	  2317: 	MOVE.w	ship_wrk_y(pc,d7.w),d1	; get the y velocity word
00:0000B8F0 D2737067        	  2318: 	ADD.w		expl_y_pos(a3,d7.w),d1	; add the y position word
00:0000B8F4 37817067        	  2319: 	MOVE.w	d1,expl_y_pos(a3,d7.w)	; save the y position word
                            	  2320: 
00:0000B8F8 244C            	  2321: 	MOVEA.l	a4,a2				; copy the vector pointer
                            	  2322: 
00:0000B8FA 7400            	  2323: 	MOVEQ		#0,d2				; clear the x sign bit
00:0000B8FC 4A40            	  2324: 	TST.w		d0				; test the x position word
00:0000B8FE 6A06            	  2325: 	BPL.s		vec_x_pos			; if positive skip the negate
                            	  2326: 
00:0000B900 4440            	  2327: 	NEG.w		d0				; else negate the x position, make it positive
00:0000B902 343C0400        	  2328: 	MOVE.w	#$0400,d2			; and set the x sign bit
                            	  2329: vec_x_pos
                            	  2330: 
00:0000B906 7600            	  2331: 	MOVEQ		#0,d3				; clear the y sign bit
00:0000B908 4A41            	  2332: 	TST.w		d1				; test the y position word
00:0000B90A 6A06            	  2333: 	BPL.s		vec_y_pos			; if positive skip the negate
                            	  2334: 
00:0000B90C 4441            	  2335: 	NEG.w		d1				; else negate the y position, make it positive
00:0000B90E 363C0400        	  2336: 	MOVE.w	#$0400,d3			; and set the y sign bit
                            	  2337: vec_y_pos
00:0000B912 E848            	  2338: 	LSR.w		#4,d0				; shift the x position
00:0000B914 E849            	  2339: 	LSR.w		#4,d1				; shift the y position
                            	  2340: 
00:0000B916 8042            	  2341: 	OR.w		d2,d0				; OR in the x sign bit
00:0000B918 00416000        	  2342: 	ORI.w		#$6000,d1			; fix the scale
00:0000B91C 8243            	  2343: 	OR.w		d3,d1				; OR in the y sign bit
                            	  2344: 
00:0000B91E 38C1            	  2345: 	MOVE.w	d1,(a4)+			; add y position to the vector list
00:0000B920 38C0            	  2346: 	MOVE.w	d0,(a4)+			; add x position to the vector list
                            	  2347: 
                            	  2348: 							; add the piece vector to the list
                            	  2349: 
00:0000B922 303B7022        	  2350: 	MOVE.w	ship_parts(pc,d7.w),d0	; get wrecked ship piece vector word
00:0000B926 38C0            	  2351: 	MOVE.w	d0,(a4)+			; add the wrecked ship piece vector word to the
                            	  2352: 							; vector list
                            	  2353: 
00:0000B928 0A400404        	  2354: 	EORI.w	#$0404,d0			; toggle the sign bits
00:0000B92C 0240FF0F        	  2355: 	ANDI.w	#$FF0F,d0			; clear the intensity bits
00:0000B930 38C0            	  2356: 	MOVE.w	d0,(a4)+			; add the inverse wrecked ship piece vector word
                            	  2357: 							; to the vector list
                            	  2358: 
                            	  2359: 							; now copy an inverse relative long vector to
                            	  2360: 							; the list
00:0000B932 2012            	  2361: 	MOVE.l	(a2),d0			; get the vector to the piece
00:0000B934 0A8004000400    	  2362: 	EORI.l	#$04000400,d0		; toggle the sign bits
00:0000B93A 28C0            	  2363: 	MOVE.l	d0,(a4)+			; save the inverse vector to the list
                            	  2364: 
00:0000B93C 5547            	  2365: 	SUBQ.w	#2,d7				; decrement the index
00:0000B93E 6AA0            	  2366: 	BPL		piece_draw_loop		; loop if more to do
                            	  2367: 
00:0000B940 4CDF00C0        	  2368: 	MOVEM.l	(sp)+,d6-d7			; restore the registers
00:0000B944 4E75            	  2369: 	rts
                            	  2370: 
                            	  2371: 
                            	  2372: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2373: ;
                            	  2374: ; pieces of wrecked ship
                            	  2375: 
                            	  2376: ship_parts
00:0000B946 FFC6            	  2377: 	dc.w	$FFC6				; x = -2, Y = -3
00:0000B948 FEC1            	  2378: 	dc.w	$FEC1				; x =  1, Y = -2
00:0000B94A F1C3            	  2379: 	dc.w	$F1C3				; x =  3, Y =  1
00:0000B94C F1CD            	  2380: 	dc.w	$F1CD				; x = -1, Y =  1
00:0000B94E F1C7            	  2381: 	dc.w	$F1C7				; x = -3, Y =  1
00:0000B950 FDC1            	  2382: 	dc.w	$FDC1				; x =  1, Y = -1
                            	  2383: 
                            	  2384: 
                            	  2385: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2386: ;
                            	  2387: ; add the player ship to the vector list
                            	  2388: 
                            	  2389: add_player:
00:0000B952 7600            	  2390: 	MOVEQ		#0,d3				; clear the x_sign
00:0000B954 7400            	  2391: 	MOVEQ		#0,d2				; clear the y_sign
00:0000B956 7800            	  2392: 	MOVEQ		#0,d4				; yx_sign
                            	  2393: 
00:0000B958 122B001E        	  2394: 	MOVE.b	p_orient(a3),d1		; get the player orientation
00:0000B95C 6A0A            	  2395: 	BPL.s		no_pos_reflect		; if positive skip reflection
                            	  2396: 
00:0000B95E 343C0400        	  2397: 	MOVE.w	#$0400,d2			; set the y_sign
00:0000B962 3802            	  2398: 	MOVE.w	d2,d4				; set the yx_sign
00:0000B964 4401            	  2399: 	NEG.b		d1				; make ABS orientation
00:0000B966 6B06            	  2400: 	BMI.s		third_quad			; if still negative go do the third quad
                            	  2401: 
                            	  2402: no_pos_reflect
00:0000B968 08010006        	  2403: 	BTST.l	#6,d1				; test the quadrant
00:0000B96C 670E            	  2404: 	BEQ.s		first_quad			; skip reflect if in first quadrant
                            	  2405: 
                            	  2406: third_quad
00:0000B96E 363C0400        	  2407: 	MOVE.w	#$0400,d3			; set the x_sign
00:0000B972 183C0004        	  2408: 	MOVE.b	#$04,d4			; set the yx_sign
                            	  2409: 
00:0000B976 4401            	  2410: 	NEG.b		d1				; negate the byte
00:0000B978 D23C0080        	  2411: 	ADD.b		#$80,d1			; reflect the quadrant
                            	  2412: first_quad
00:0000B97C E209            	  2413: 	LSR.b		#1,d1				; do quadrant value / 2
00:0000B97E C23C003E        	  2414: 	AND.b		#$3E,d1			; mask to word boundary, value is $00 to $20
                            	  2415: 
00:0000B982 43FA1760        	  2416: 	LEA		play_tab(pc),a1		; point to the player ship table
00:0000B986 32311000        	  2417: 	MOVE.w	(a1,d1.w),d1		; get the offset to the player ship
00:0000B98A 43F11000        	  2418: 	LEA		(a1,d1.w),a1		; get the pointer to the player ship
00:0000B98E 6118            	  2419: 	BSR.s		copy_vectors		; copy the vectors from (a1) to the vector list
                            	  2420: 
                            	  2421: ;	MOVEQ		#'L',d1			; set for the thrust button
                            	  2422: ;	MOVEQ		#19,d0			; check for keypress
                            	  2423: ;	TRAP		#15
00:0000B990 7005            	  2424: 	moveq #5,d0
00:0000B992 4E4F            	  2425: 	trap #15
00:0000B994 0C01004C        	  2426: 	cmpi.b #'L',d1
00:0000B998 6608            	  2427: 	bne.s no_thrust
                            	  2428: 
                            	  2429: ;	TST.b		d1				; test the result
                            	  2430: ;	BEQ.s		no_thrust			; if not pressed then skip the thrust copy
                            	  2431: 
00:0000B99A 7003            	  2432: 	MOVEQ		#3,d0				; set the game counter mask
00:0000B99C C06B0059        	  2433: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000B9A0 6606            	  2434: 	BNE.s		copy_vectors		; 3/4 of the time go copy the vectors from (a1)
                            	  2435: 							; to the vector list and return
                            	  2436: no_thrust
00:0000B9A2 4E75            	  2437: 	RTS
                            	  2438: 
                            	  2439: 
                            	  2440: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2441: ;
                            	  2442: ; copy the vectors from (a1) to the vector list
                            	  2443: 
                            	  2444: copy_short:
00:0000B9A4 B940            	  2445: 	EOR.w		d4,d0				; possibly toggle the x and y signs
00:0000B9A6 38C0            	  2446: 	MOVE.w	d0,(a4)+			; copy the word to the vector list
                            	  2447: 
                            	  2448: copy_vectors
00:0000B9A8 3019            	  2449: 	MOVE.w	(a1)+,d0			; get a vector word
00:0000B9AA B07CF000        	  2450: 	CMP.w		#SHRT,d0			; compare with short form vector
00:0000B9AE 64F4            	  2451: 	BCC.s		copy_short			; if short vector go copy it
                            	  2452: 
00:0000B9B0 B07CA000        	  2453: 	CMP.w		#DRAW,d0			; compare with the DRAW command
00:0000B9B4 640C            	  2454: 	BCC.s		exit_copy_vectors		; if DRAW or greater exit the vector copy
                            	  2455: 
                            	  2456: ; else it is a long vector
                            	  2457: 
00:0000B9B6 B540            	  2458: 	EOR.w		d2,d0				; possibly toggle the y sign
00:0000B9B8 38C0            	  2459: 	MOVE.w	d0,(a4)+			; copy the word to the vector list
00:0000B9BA 3019            	  2460: 	MOVE.w	(a1)+,d0			; get the second vector word
00:0000B9BC B740            	  2461: 	EOR.w		d3,d0				; possibly toggle the x sign
00:0000B9BE 38C0            	  2462: 	MOVE.w	d0,(a4)+			; copy the word to the vector list
00:0000B9C0 60E6            	  2463: 	BRA.s		copy_vectors		; go do the next word
                            	  2464: 
                            	  2465: ; it's a short form vector
                            	  2466: 
                            	  2467: exit_copy_vectors
00:0000B9C2 4E75            	  2468: 	RTS
                            	  2469: 
                            	  2470: 
                            	  2471: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2472: ;
                            	  2473: ; do the game sounds
                            	  2474: 
                            	  2475: fx_sounds:
00:0000B9C4 7200            	  2476: 	MOVEQ		#0,d1				; clear the longword
00:0000B9C6 122D0028        	  2477: 	MOVE.b	s_flag_off(a5),d1		; get the saucer flag
00:0000B9CA 6F06            	  2478: 	BLE.s		no_saucer_sound		; if no saucer or the saucer is exploding skip
                            	  2479: 							; the saucer sound
                            	  2480: 
00:0000B9CC 5401            	  2481: 	ADDQ.b	#smsau_snd-1,d1		; add the small saucer sound to the size
00:0000B9CE 61001F8E        	  2482: 	BSR		play_sample			; go play the sample
                            	  2483: no_saucer_sound
00:0000B9D2 4A2D0076        	  2484: 	TST.b		rock_count(a5)		; test the rock count
00:0000B9D6 672C            	  2485: 	BEQ.s		no_thump_sound		; if no rocks skip the thump sound
                            	  2486: 
00:0000B9D8 4A2D0027        	  2487: 	TST.b		p_flag_off(a5)		; test the player flag
00:0000B9DC 6F26            	  2488: 	BLE.s		no_thump_sound		; if no player or the player is exploding skip
                            	  2489: 							; the thump sound
                            	  2490: 
00:0000B9DE 4A2B0026        	  2491: 	TST.b		hyper(a3)			; test the hyperspace flag
00:0000B9E2 6620            	  2492: 	BNE.s		no_thump_sound		; if in hyperspace skip the thump sound
                            	  2493: 
00:0000B9E4 532B0024        	  2494: 	SUBQ.b	#1,thump_time(a3)		; decrement the thump sound change timer
00:0000B9E8 661A            	  2495: 	BNE.s		no_thump_sound		; skip changing the sound if not timed out
                            	  2496: 
00:0000B9EA 7004            	  2497: 	MOVEQ		#4,d0				; add the sound on time
00:0000B9EC D02D007C        	  2498: 	ADD.b		thmp_sndi(a5),d0		; add the thump sound change timer initial
00:0000B9F0 17400024        	  2499: 	MOVE.b	d0,thump_time(a3)		; save the thump sound change timer
                            	  2500: 
00:0000B9F4 7001            	  2501: 	MOVEQ		#1,d0				; set the bitmap change mask
00:0000B9F6 122B0023        	  2502: 	MOVE.b	thump_snd(a3),d1		; get the thump sound value
00:0000B9FA B101            	  2503: 	EOR.b		d0,d1				; change the thump sound value
00:0000B9FC 17410023        	  2504: 	MOVE.b	d1,thump_snd(a3)		; save the thump sound value
00:0000BA00 60001F5C        	  2505: 	BRA		play_sample			; go play the sample and return
                            	  2506: 
                            	  2507: no_thump_sound
00:0000BA04 4E75            	  2508: 	RTS
                            	  2509: 
                            	  2510: 
                            	  2511: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2512: ;
                            	  2513: ; handle something hitting a rock
                            	  2514: 
                            	  2515: ; d6 = player/saucer/shot object index
                            	  2516: ; d7 = object index
                            	  2517: 
                            	  2518: hit_a_rock:
00:0000BA06 1B7C00500079    	  2519: 	MOVE.b	#$50,r_hit_tim(a5)	; set the rock hit timer
00:0000BA0C 1035700C        	  2520: 	MOVE.b	flags_off(a5,d7.w),d0	; get the rock flag
00:0000BA10 7278            	  2521: 	MOVEQ		#$78,d1			; set the mask for the rock type
00:0000BA12 C200            	  2522: 	AND.b		d0,d1				; mask the rock type
                            	  2523: 
00:0000BA14 02400007        	  2524: 	ANDI.w	#$07,d0			; mask the rock size
00:0000BA18 E248            	  2525: 	LSR.w		#1,d0				; / 2
00:0000BA1A 3400            	  2526: 	MOVE.w	d0,d2				; copy the size
00:0000BA1C 6702            	  2527: 	BEQ.s		clear_rock			; if the size is zero then the rock is destroyed
                            	  2528: 							; so go clear the rock flag
                            	  2529: 
00:0000BA1E 8001            	  2530: 	OR.b		d1,d0				; else OR back the rock type
                            	  2531: clear_rock
00:0000BA20 1B80700C        	  2532: 	MOVE.b	d0,flags_off(a5,d7.w)	; save the rock flag
                            	  2533: 
00:0000BA24 4A2B001A        	  2534: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000BA28 6712            	  2535: 	BEQ.s		skip_add			; if no players skip the score add
                            	  2536: 
00:0000BA2A 4A46            	  2537: 	TST.w		d6				; test the player/saucer/shot index
00:0000BA2C 6706            	  2538: 	BEQ.s		add_to_score		; if the player hit the rock go add it to the
                            	  2539: 							; player's score
                            	  2540: 
00:0000BA2E 0C460004        	  2541: 	CMPI.w	#p_fire_off-p_flag_off,d6
                            	  2542: 							; compare the player/saucer/shot index with the
                            	  2543: 							; first of the player's fire
00:0000BA32 6508            	  2544: 	BCS.s		skip_add			; if < the player's fire skip adding to the
                            	  2545: 							; player's score
                            	  2546: 
                            	  2547: add_to_score
00:0000BA34 123B2042        	  2548: 	MOVE.b	rock_score(pc,d2.w),d1	; get the score per rock size
00:0000BA38 6100FD6C        	  2549: 	BSR		add_score			; add d1.b to the current player's score
                            	  2550: skip_add
00:0000BA3C 4A35700C        	  2551: 	TST.b		flags_off(a5,d7.w)	; test the rock flag
00:0000BA40 6734            	  2552: 	BEQ.s		exit_hit_a_rock		; if the rock was destroyed just exit
                            	  2553: 
                            	  2554: ; else break the rock into none, one, or two smaller rocks
                            	  2555: 
00:0000BA42 6100FE42        	  2556: 	BSR		find_rock			; find a free rock, the index is returned in d5
00:0000BA46 662E            	  2557: 	BNE.s		exit_hit_a_rock		; if there are no free rocks just exit
                            	  2558: 
00:0000BA48 522D0076        	  2559: 	ADDQ.b	#1,rock_count(a5)		; else increment the rock count
                            	  2560: 
00:0000BA4C 6100FB76        	  2561: 	BSR		copy_rock			; copy the item parameters from the old rock,
                            	  2562: 							; (d7), to the new rock, (d5)
                            	  2563: 
00:0000BA50 701F            	  2564: 	MOVEQ		#$1F,d0			; set the mask for the low 5 bits
00:0000BA52 C035502F        	  2565: 	AND.b		x_vel_off(a5,d5.w),d0	; get the new rock x velocity byte
00:0000BA56 D000            	  2566: 	ADD.b		d0,d0				; ; 2
00:0000BA58 B1353081        	  2567: 	EOR.b		d0,x_pos_off+1(a5,d3.w)	; purturb the new rock x position low byte
                            	  2568: 
00:0000BA5C 6100FE2A        	  2569: 	BSR		find_next_rock		; find a free rock from d5, the index is
                            	  2570: 							; returned in d5
00:0000BA60 6614            	  2571: 	BNE.s		exit_hit_a_rock		; if there are no free rocks just exit
                            	  2572: 
00:0000BA62 522D0076        	  2573: 	ADDQ.b	#1,rock_count(a5)		; else increment the rock count
                            	  2574: 
00:0000BA66 6100FB60        	  2575: 	BSR		copy_rock_2			; copy the item parameters from the old rock,
                            	  2576: 							; (d7), to the new rock, (d5)
                            	  2577: 
00:0000BA6A 701F            	  2578: 	MOVEQ		#$1F,d0			; set the mask for the low 5 bits
00:0000BA6C C0355052        	  2579: 	AND.b		y_vel_off(a5,d5.w),d0	; get the new rock y velocity byte
00:0000BA70 D000            	  2580: 	ADD.b		d0,d0				; ; 2
00:0000BA72 B13530C7        	  2581: 	EOR.b		d0,y_pos_off+1(a5,d3.w)	; purturb the new rock y position low byte
                            	  2582: exit_hit_a_rock
00:0000BA76 4E75            	  2583: 	RTS
                            	  2584: 
                            	  2585: 
                            	  2586: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2587: ;
                            	  2588: ; score per rock size
                            	  2589: 
                            	  2590: rock_score
00:0000BA78 10              	  2591: 	dc.b	$10					; 100 points, small rock
00:0000BA79 05              	  2592: 	dc.b	$05					;  50 points, medium rock
00:0000BA7A 02              	  2593: 	dc.b	$02					;  20 points, large rock
00:0000BA7B 00              	  2594: 	dc.b	$00					;   0 points, null pad byte
                            	  2595: 
                            	  2596: 
                            	  2597: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2598: ;
                            	  2599: ; do the high score checks
                            	  2600: 
                            	  2601: check_hiscores:
00:0000BA7C 102B001A        	  2602: 	MOVE.b	num_players(a3),d0	; get the number of players in the game
00:0000BA80 6A5A            	  2603: 	BPL.s		exit_check_hiscores	; if still players just exit
                            	  2604: 
00:0000BA82 1B400083        	  2605: 	MOVE.b	d0,high_off(a5)		; clear the player 2 highscore flag
00:0000BA86 1D400083        	  2606: 	MOVE.b	d0,high_off(a6)		; clear the player 1 highscore flag
                            	  2607: 
00:0000BA8A 177C00010018    	  2608: 	MOVE.b	#$01,player_idx(a3)	; set the player index for player two
00:0000BA90 4BEB01F7        	  2609: 	LEA		player_2(a3),a5		; set the pointer to player two's variables
00:0000BA94 4DEB00F3        	  2610: 	LEA		player_1(a3),a6		; set the pointer to player one's variables
                            	  2611: check_hi_player
00:0000BA98 7400            	  2612: 	MOVEQ		#0,d2				; clear the high score index
00:0000BA9A 302D0080        	  2613: 	MOVE.w	score_off(a5),d0		; get the player score
00:0000BA9E 670E            	  2614: 	BEQ.s		check_hi_next		; if zero go try the other player
                            	  2615: 
                            	  2616: check_hi_loop
00:0000BAA0 B0732027        	  2617: 	CMP.w		hiscores(a3,d2.w),d0	; compare the high score with the player score
00:0000BAA4 6238            	  2618: 	BHI.s		insert_hiscore		; if the player score was more go insert the
                            	  2619: 							; score
                            	  2620: 
00:0000BAA6 5442            	  2621: 	ADDQ.w	#2,d2				; increment the high score index
00:0000BAA8 0C420014        	  2622: 	CMPI.w	#20,d2			; compare with max + 2
00:0000BAAC 65F2            	  2623: 	BCS.s		check_hi_loop		; loop if more high scores to do
                            	  2624: 
                            	  2625: 							; else change to the other player
                            	  2626: check_hi_next
00:0000BAAE CB4E            	  2627: 	EXG		a5,a6				; swap the players
00:0000BAB0 0A2B00010018    	  2628: 	EORI.b	#1,player_idx(a3)		; toggle the player index
00:0000BAB6 67E0            	  2629: 	BEQ.s		check_hi_player		; loop if more players to do
                            	  2630: 
00:0000BAB8 102D0083        	  2631: 	MOVE.b	high_off(a5),d0		; get player 2's highscore flag
00:0000BABC 6B14            	  2632: 	BMI.s		exit_hi_chk			; if not entering a high score go clear the
                            	  2633: 							; player count and exit
                            	  2634: 
00:0000BABE B02E0083        	  2635: 	CMP.b		high_off(a6),d0		; compare with the player 1 highscore flag
00:0000BAC2 650E            	  2636: 	BCS.s		exit_hi_chk			; if player 2's position < player 1's position
                            	  2637: 							; just exit
                            	  2638: 
00:0000BAC4 5600            	  2639: 	ADDQ.b	#3,d0				; else increment player 2's position to the
                            	  2640: 							; next entry
00:0000BAC6 0C00001E        	  2641: 	CMPI.b	#$1E,d0			; compare the result with max + 1
00:0000BACA 6502            	  2642: 	BCS.s		save_hi_index		; if less go save the new player 1 index
                            	  2643: 
00:0000BACC 70FF            	  2644: 	MOVEQ		#-1,d0			; else reset player 2's highscore flag
                            	  2645: save_hi_index
00:0000BACE 1B400083        	  2646: 	MOVE.b	d0,high_off(a5)		; save player 2's highscore flag
                            	  2647: exit_hi_chk
00:0000BAD2 7000            	  2648: 	MOVEQ		#0,d0				; clear the longword
00:0000BAD4 1740001A        	  2649: 	MOVE.b	d0,num_players(a3)	; clear the number of players in the game
00:0000BAD8 17400020        	  2650: 	MOVE.b	d0,hi_char(a3)		; clear the input character index
                            	  2651: exit_check_hiscores
00:0000BADC 4E75            	  2652: 	RTS
                            	  2653: 
                            	  2654: ; insert a new high score into the high score table. the index is in d2.w
                            	  2655: 
                            	  2656: insert_hiscore:
00:0000BADE 7612            	  2657: 	MOVEQ		#18,d3			; index to the last high score
00:0000BAE0 781B            	  2658: 	MOVEQ		#27,d4			; index to the last high score initials
                            	  2659: insert_loop
00:0000BAE2 B443            	  2660: 	CMP.w		d3,d2				; compare the current high score with the insert
                            	  2661: 							; point
00:0000BAE4 671E            	  2662: 	BEQ.s		exit_insert_loop		; if there exit the loop
                            	  2663: 
00:0000BAE6 37B330253027    	  2664: 	MOVE.w	hiscores-2(a3,d3.w),hiscores(a3,d3.w)
                            	  2665: 							; copy the (n-1)th high score to this one
00:0000BAEC 17B34038403B    	  2666: 	MOVE.b	hinames-3(a3,d4.w),hinames(a3,d4.w)
                            	  2667: 							; copy the (n-1)th high score name first byte
00:0000BAF2 17B34039403C    	  2668: 	MOVE.b	hinames-2(a3,d4.w),hinames+1(a3,d4.w)
                            	  2669: 							; copy the (n-1)th high score name second byte
00:0000BAF8 17B3403A403D    	  2670: 	MOVE.b	hinames-1(a3,d4.w),hinames+2(a3,d4.w)
                            	  2671: 							; copy the (n-1)th high score name third byte
                            	  2672: 
00:0000BAFE 5543            	  2673: 	SUBQ.w	#2,d3				; decrement the index to the previous score
00:0000BB00 5744            	  2674: 	SUBQ.w	#3,d4				; decrement the index to the previous initials
00:0000BB02 66DE            	  2675: 	BNE.s		insert_loop			; loop for the next high score
                            	  2676: 
                            	  2677: exit_insert_loop
00:0000BB04 1B440083        	  2678: 	MOVE.b	d4,high_off(a5)		; save the player highscore flag
00:0000BB08 37803027        	  2679: 	MOVE.w	d0,hiscores(a3,d3.w)	; copy the player score to this one
00:0000BB0C 17BC000B403B    	  2680: 	MOVE.b	#$0B,hinames(a3,d4.w)	; make the high score name first byte "A"
00:0000BB12 4233403C        	  2681: 	CLR.b		hinames+1(a3,d4.w)	; make the high score name second byte " "
00:0000BB16 4233403D        	  2682: 	CLR.b		hinames+2(a3,d4.w)	; make the high score name third byte " "
                            	  2683: 
00:0000BB1A 177C00F00059    	  2684: 	MOVE.b	#$F0,game_count(a3)	; set the game counter high byte, high score
                            	  2685: 							; entry timeout
                            	  2686: 
00:0000BB20 608C            	  2687: 	BRA.s		check_hi_next		; loop for the other player
                            	  2688: 
                            	  2689: 
                            	  2690: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2691: ;
                            	  2692: ; calculate the angle given the delta x,y. the delta is calculated by subtracting the
                            	  2693: ; source x,y co-ordinates from the target x,y co-ordinates. the angle is returned in
                            	  2694: ; d0.b with $00 being 3 o'clock
                            	  2695: ;
                            	  2696: ; d1.w = delta x = target x - source x
                            	  2697: ; d2.w = delta y = target y - source y
                            	  2698: 
                            	  2699: get_atn:
00:0000BB22 4A42            	  2700: 	TST.w		d2				; test the delta y
00:0000BB24 6A08            	  2701: 	BPL.s		atn_semi			; if +ve skip the delta y negate
                            	  2702: 
00:0000BB26 4442            	  2703: 	NEG.w		d2				; else make delta y positive
00:0000BB28 6104            	  2704: 	BSR.s		atn_semi			; get arctan(y/x) for the semicircle
00:0000BB2A 4400            	  2705: 	NEG.b		d0				; negate the result
00:0000BB2C 4E75            	  2706: 	RTS
                            	  2707: 
                            	  2708: ; get arctan(y/x) for the semicircle
                            	  2709: 
                            	  2710: atn_semi:
00:0000BB2E 4A41            	  2711: 	TST.w		d1				; test the delta x
00:0000BB30 6A0C            	  2712: 	BPL.s		atn_quad			; if +ve skip the delta x negate
                            	  2713: 
00:0000BB32 4441            	  2714: 	NEG.w		d1				; else make delta x positive
00:0000BB34 6108            	  2715: 	BSR.s		atn_quad			; get arctan(y/x) or arctan(x/y)
00:0000BB36 0A000080        	  2716: 	EORI.b	#$80,d0			; reflect 180 degrees
00:0000BB3A 4400            	  2717: 	NEG.b		d0				; negate the result
00:0000BB3C 4E75            	  2718: 	RTS
                            	  2719: 
                            	  2720: 
                            	  2721: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2722: ;
                            	  2723: ; get arctan(y/x) or arctan(x/y) for one quadrant.
                            	  2724: 
                            	  2725: atn_quad:
00:0000BB3E B441            	  2726: 	CMP.w		d1,d2				; compare y with x
00:0000BB40 650C            	  2727: 	BCS.s		atn_eight			; if x > y get arctan(y/x) from the table
                            	  2728: 							; and return
                            	  2729: 
00:0000BB42 C342            	  2730: 	EXG		d1,d2				; else swap x,y
00:0000BB44 6108            	  2731: 	BSR.s		atn_eight			; get arctan(x/y) from the table
00:0000BB46 04000040        	  2732: 	SUBI.b	#$40,d0			; reflect the quadrant
00:0000BB4A 4400            	  2733: 	NEG.b		d0				; and negate the result
00:0000BB4C 4E75            	  2734: 	RTS
                            	  2735: 
                            	  2736: 
                            	  2737: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2738: ;
                            	  2739: ; divide d2.w by d1.w, the six bit result in d0.w is then used to index the ATN()
                            	  2740: ; table to get the result for this octant. (is that the right word for one eighth
                            	  2741: ; of a circle?)
                            	  2742: 
                            	  2743: atn_eight:
00:0000BB4E 7000            	  2744: 	MOVEQ		#0,d0				; clear the result
00:0000BB50 7E05            	  2745: 	MOVEQ		#6-1,d7			; set the bit count
                            	  2746: loop_atn
00:0000BB52 D442            	  2747: 	ADD.w		d2,d2				; shift the dividend
00:0000BB54 3602            	  2748: 	MOVE.w	d2,d3				; copy the dividend
00:0000BB56 9641            	  2749: 	SUB.w		d1,d3				; compare it with the divisor
00:0000BB58 6502            	  2750: 	BCS.s		skip_sub			; if the dividend < the divisor skip the
                            	  2751: 							; subtract
                            	  2752: 
00:0000BB5A 9441            	  2753: 	SUB.w		d1,d2				; else subtract the divisor
                            	  2754: skip_sub
00:0000BB5C D100            	  2755: 	ADDX.b	d0,d0				; shift a bit into the result
00:0000BB5E 51CFFFF2        	  2756: 	DBF		d7,loop_atn			; loop if more to do
                            	  2757: 
00:0000BB62 0200003F        	  2758: 	ANDI.b	#$3F,d0			; mask the result to $0000 to $003F
00:0000BB66 103B0004        	  2759: 	MOVE.b	atn_tab(pc,d0.w),d0	; get the arctan from the table
00:0000BB6A 4E75            	  2760: 	RTS
                            	  2761: 
                            	  2762: 
                            	  2763: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2764: ;
                            	  2765: ; arctangent table. returns the effective angle of the dx/dy ratio for scaled values
                            	  2766: ; of dx/dy of up to 0.984375 or 63/64ths. this is only 1/8th of a full circle but it
                            	  2767: ; is easy to rotate and reflect these values to cover the other 7/8ths.
                            	  2768: 
                            	  2769: atn_tab
00:0000BB6C 20              	  2770: 	dc.b	$20,$20,$1F,$1F,$1F,$1E,$1E,$1E,$1D,$1D,$1C,$1C,$1C,$1B,$1B,$1A
00:0000BB6D 20
00:0000BB6E 1F
00:0000BB6F 1F
00:0000BB70 1F
00:0000BB71 1E
00:0000BB72 1E
00:0000BB73 1E
00:0000BB74 1D
00:0000BB75 1D
00:0000BB76 1C
00:0000BB77 1C
00:0000BB78 1C
00:0000BB79 1B
00:0000BB7A 1B
00:0000BB7B 1A
00:0000BB7C 1A              	  2771: 	dc.b	$1A,$1A,$19,$19,$18,$18,$17,$17,$17,$16,$16,$15,$15,$14,$14,$13
00:0000BB7D 1A
00:0000BB7E 19
00:0000BB7F 19
00:0000BB80 18
00:0000BB81 18
00:0000BB82 17
00:0000BB83 17
00:0000BB84 17
00:0000BB85 16
00:0000BB86 16
00:0000BB87 15
00:0000BB88 15
00:0000BB89 14
00:0000BB8A 14
00:0000BB8B 13
00:0000BB8C 13              	  2772: 	dc.b	$13,$12,$12,$11,$11,$10,$0F,$0F,$0E,$0E,$0D,$0D,$0C,$0B,$0B,$0A
00:0000BB8D 12
00:0000BB8E 12
00:0000BB8F 11
00:0000BB90 11
00:0000BB91 10
00:0000BB92 0F
00:0000BB93 0F
00:0000BB94 0E
00:0000BB95 0E
00:0000BB96 0D
00:0000BB97 0D
00:0000BB98 0C
00:0000BB99 0B
00:0000BB9A 0B
00:0000BB9B 0A
00:0000BB9C 0A              	  2773: 	dc.b	$0A,$09,$08,$08,$07,$07,$06,$05,$05,$04,$03,$03,$02,$02,$01,$00
00:0000BB9D 09
00:0000BB9E 08
00:0000BB9F 08
00:0000BBA0 07
00:0000BBA1 07
00:0000BBA2 06
00:0000BBA3 05
00:0000BBA4 05
00:0000BBA5 04
00:0000BBA6 03
00:0000BBA7 03
00:0000BBA8 02
00:0000BBA9 02
00:0000BBAA 01
00:0000BBAB 00
                            	  2774: 
                            	  2775: 
                            	  2776: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2777: ;
                            	  2778: ; output a number as a leading zero suppressed character string
                            	  2779: ;
                            	  2780: ; a1 = number address
                            	  2781: ; d7 = number byte count
                            	  2782: 
                            	  2783: output_number:
00:0000BBAC 5347            	  2784: 	SUBQ.w	#1,d7				; adjust for the loop type
                            	  2785: output_number_loop
00:0000BBAE 1211            	  2786: 	MOVE.b	(a1),d1			; get a byte
00:0000BBB0 E809            	  2787: 	LSR.b		#4,d1				; shift the high nibble to the low nibble
00:0000BBB2 61000130        	  2788: 	BSR		add_sup_hex_chr		; add a leading zero suppressed character
00:0000BBB6 4A47            	  2789: 	TST.w		d7				; test the byte count
00:0000BBB8 6604            	  2790: 	BNE.s		zero_suppress		; if this isn't the last byte skip the zero
                            	  2791: 							; suppress clear
                            	  2792: 
00:0000BBBA 422B0016        	  2793: 	CLR.b		suppress_0(a3)		; clear the zero suppress for the last digit
                            	  2794: zero_suppress
00:0000BBBE 1219            	  2795: 	MOVE.b	(a1)+,d1			; get a byte and increment the pointer
00:0000BBC0 61000122        	  2796: 	BSR		add_sup_hex_chr		; add a leading zero suppressed character
00:0000BBC4 51CFFFE8        	  2797: 	DBF		d7,output_number_loop	; decrement count and loop if more to do
                            	  2798: 
00:0000BBC8 4E75            	  2799: 	RTS
                            	  2800: 
                            	  2801: 
                            	  2802: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2803: ;
                            	  2804: ; get COS(d0) in d0. d0 is an eight bit value representing a full circle with the
                            	  2805: ; value increasing as you turn widdershins
                            	  2806: 
                            	  2807: cos_d0
00:0000BBCA 06000040        	  2808: 	ADDI.b	#$40,d0			; add 1/4 rotation
                            	  2809: 
                            	  2810: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2811: ;
                            	  2812: ; get SIN(d0) in d0. d0 is an eight bit value representing a full circle with the
                            	  2813: ; value increasing as you turn widdershins
                            	  2814: 
                            	  2815: sin_d0
00:0000BBCE 024000FF        	  2816: 	ANDI.w	#$00FF,d0			; mask one full circle
00:0000BBD2 4A00            	  2817: 	TST.b		d0				; test angle sign
00:0000BBD4 6A06            	  2818: 	BPL.s		cossin_d0			; if +ve just get SIN/COS and return
                            	  2819: 
00:0000BBD6 6104            	  2820: 	BSR.s		cossin_d0			; else get SIN/COS
00:0000BBD8 4440            	  2821: 	NEG.w		d0				; now do twos complement
00:0000BBDA 4E75            	  2822: 	RTS
                            	  2823: 
                            	  2824: ; get d0 from SIN/COS table
                            	  2825: 
                            	  2826: cossin_d0
00:0000BBDC D000            	  2827: 	ADD.b		d0,d0				; ; 2 bytes per word value
00:0000BBDE 6A02            	  2828: 	BPL.s		a_was_less			; branch if the angle < 1/4 circle
                            	  2829: 
00:0000BBE0 4400            	  2830: 	NEG.b		d0				; wrap $82 to $FE to $7E to $02
                            	  2831: a_was_less
00:0000BBE2 303B0004        	  2832: 	MOVE.w	sin_cos(pc,d0.w),d0	; get the SIN/COS value
00:0000BBE6 4E75            	  2833: 	RTS
                            	  2834: 
                            	  2835: 
                            	  2836: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2837: ;
                            	  2838: ; SIN/COS table, returns values between $0000 and $7FFF. the last value should be
                            	  2839: ; $8000 but that can cause an overflow in the word length calculations and it's
                            	  2840: ; easier to fudge the table a bit. no one will ever notice.
                            	  2841: 
                            	  2842: sin_cos
00:0000BBE8 0000            	  2843: 	dc.w	$0000,$0324,$0648,$096B,$0C8C,$0FAB,$12C8,$15E2
00:0000BBEA 0324
00:0000BBEC 0648
00:0000BBEE 096B
00:0000BBF0 0C8C
00:0000BBF2 0FAB
00:0000BBF4 12C8
00:0000BBF6 15E2
00:0000BBF8 18F9            	  2844: 	dc.w	$18F9,$1C0C,$1F1A,$2224,$2528,$2827,$2B1F,$2E11
00:0000BBFA 1C0C
00:0000BBFC 1F1A
00:0000BBFE 2224
00:0000BC00 2528
00:0000BC02 2827
00:0000BC04 2B1F
00:0000BC06 2E11
00:0000BC08 30FC            	  2845: 	dc.w	$30FC,$33DF,$36BA,$398D,$3C57,$3F17,$41CE,$447B
00:0000BC0A 33DF
00:0000BC0C 36BA
00:0000BC0E 398D
00:0000BC10 3C57
00:0000BC12 3F17
00:0000BC14 41CE
00:0000BC16 447B
00:0000BC18 471D            	  2846: 	dc.w	$471D,$49B4,$4C40,$4EC0,$5134,$539B,$55F6,$5843
00:0000BC1A 49B4
00:0000BC1C 4C40
00:0000BC1E 4EC0
00:0000BC20 5134
00:0000BC22 539B
00:0000BC24 55F6
00:0000BC26 5843
00:0000BC28 5A82            	  2847: 	dc.w	$5A82,$5CB4,$5ED7,$60EC,$62F2,$64E9,$66CF,$68A7
00:0000BC2A 5CB4
00:0000BC2C 5ED7
00:0000BC2E 60EC
00:0000BC30 62F2
00:0000BC32 64E9
00:0000BC34 66CF
00:0000BC36 68A7
00:0000BC38 6A6E            	  2848: 	dc.w	$6A6E,$6C24,$6DCA,$6F5F,$70E3,$7255,$73B6,$7505
00:0000BC3A 6C24
00:0000BC3C 6DCA
00:0000BC3E 6F5F
00:0000BC40 70E3
00:0000BC42 7255
00:0000BC44 73B6
00:0000BC46 7505
00:0000BC48 7642            	  2849: 	dc.w	$7642,$776C,$7885,$798A,$7A7D,$7B5D,$7C2A,$7CE4
00:0000BC4A 776C
00:0000BC4C 7885
00:0000BC4E 798A
00:0000BC50 7A7D
00:0000BC52 7B5D
00:0000BC54 7C2A
00:0000BC56 7CE4
00:0000BC58 7D8A            	  2850: 	dc.w	$7D8A,$7E1E,$7E9D,$7F0A,$7F62,$7FA7,$7FD9,$7FF6
00:0000BC5A 7E1E
00:0000BC5C 7E9D
00:0000BC5E 7F0A
00:0000BC60 7F62
00:0000BC62 7FA7
00:0000BC64 7FD9
00:0000BC66 7FF6
00:0000BC68 7FFF            	  2851: 	dc.w	$7FFF
                            	  2852: 
                            	  2853: 
                            	  2854: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2855: ;
                            	  2856: ; add message d1 to the display list
                            	  2857: 
                            	  2858: add_message:
00:0000BC6A 36BC1000        	  2859: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
                            	  2860: 
00:0000BC6E D241            	  2861: 	ADD.w		d1,d1				; make into a word index
00:0000BC70 3F01            	  2862: 	MOVE.w	d1,-(sp)			; save the index
                            	  2863: 
00:0000BC72 D241            	  2864: 	ADD.w		d1,d1				; make into a word pair index
00:0000BC74 41FA1932        	  2865: 	LEA		mess_origin(pc),a0	; point to the mesage co-ordinate table
00:0000BC78 34301002        	  2866: 	MOVE.w	2(a0,d1.w),d2		; get the message y co-ordinate
00:0000BC7C 32301000        	  2867: 	MOVE.w	(a0,d1.w),d1		; get the message x co-ordinate
00:0000BC80 6100009E        	  2868: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  2869: 							; a draw command
                            	  2870: 
00:0000BC84 323C7000        	  2871: 	MOVE.w	#REL7,d1			; make a $7000,$0000 command
00:0000BC88 610000B0        	  2872: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  2873: 
00:0000BC8C 7003            	  2874: 	MOVEQ		#$03,d0			; set the mask for the language bits
00:0000BC8E 206B000E        	  2875: 	MOVEA.l	switch_addr(a3),a0	; point to the switch
00:0000BC92 C010            	  2876: 	AND.b		(a0),d0			; get and mask the switch bits
00:0000BC94 D040            	  2877: 	ADD.w		d0,d0				; make into a word pointer
                            	  2878: 
00:0000BC96 41FA1930        	  2879: 	LEA		mess_table(pc),a0		; point to the mesage language table
00:0000BC9A 30300000        	  2880: 	MOVE.w	(a0,d0.w),d0		; get the offset to the messages
00:0000BC9E 41F00000        	  2881: 	LEA		(a0,d0.w),a0		; get the pointer to the messages
                            	  2882: 
00:0000BCA2 321F            	  2883: 	MOVE.w	(sp)+,d1			; restore the message index
                            	  2884: 
00:0000BCA4 32301000        	  2885: 	MOVE.w	(a0,d1.w),d1		; get the offset to the message
00:0000BCA8 41F01000        	  2886: 	LEA		(a0,d1.w),a0		; get the pointer to the message
00:0000BCAC 43FA189C        	  2887: 	LEA		char_set(pc),a1		; get the pointer to the character JSRL table
00:0000BCB0 7000            	  2888: 	MOVEQ		#0,d0				; clear the longword
                            	  2889: add_char_loop
00:0000BCB2 1018            	  2890: 	MOVE.b	(a0)+,d0			; get the next character
00:0000BCB4 671A            	  2891: 	BEQ.s		exit_add_message		; if null just exit
                            	  2892: 
                            	  2893: ; convert the character and add it to the vector list
                            	  2894: 
00:0000BCB6 903C0020        	  2895: 	SUB.b		#' ',d0			; subtract [SPACE]
00:0000BCBA 670C            	  2896: 	BEQ.s		add_the_char		; if it was [SPACE] go add it
                            	  2897: 
00:0000BCBC 903C000F        	  2898: 	SUB.b		#15,d0			; convert a number
00:0000BCC0 0C00000B        	  2899: 	CMPI.b	#11,d0			; compare with converted "9"+1
00:0000BCC4 6502            	  2900: 	BCS.s		add_the_char		; if it was <="9" go add it
                            	  2901: 
00:0000BCC6 5F00            	  2902: 	SUBQ.b	#7,d0				; else convert "A" to "Z"
                            	  2903: add_the_char
00:0000BCC8 D000            	  2904: 	ADD.b		d0,d0				; ; 2
00:0000BCCA 38F10000        	  2905: 	MOVE.w	(a1,d0.w),(a4)+		; copy the JSRL to the vector list
00:0000BCCE 60E2            	  2906: 	BRA.s		add_char_loop		; loop for next
                            	  2907: 
                            	  2908: exit_add_message
00:0000BCD0 4E75            	  2909: 	RTS
                            	  2910: 
                            	  2911: 
                            	  2912: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2913: ;
                            	  2914: ; timer interrupt. the timer interrupt should be triggered every 16ms
                            	  2915: 
                            	  2916: timer_interrupt
00:0000BCD2 522B001D        	  2917: 	ADDQ.b	#1,sixteen_ms(a3)		; increment the 16ms counter
00:0000BCD6 4E73            	  2918: 	RTE
                            	  2919: 
                            	  2920: 
                            	  2921: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2922: ;
                            	  2923: ; add "PLAYER x" to the vector list
                            	  2924: 
                            	  2925: player_x:
00:0000BCD8 7201            	  2926: 	MOVEQ		#1,d1				; message 1 - "PLAYER "
00:0000BCDA 618E            	  2927: 	BSR		add_message			; add message d1 to the display list
                            	  2928: player_n
00:0000BCDC 7201            	  2929: 	MOVEQ		#1,d1				; make 0,1 into 1,2
00:0000BCDE D22B0018        	  2930: 	ADD.b		player_idx(a3),d1		; add the player index
00:0000BCE2 600C            	  2931: 	BRA.s		add_hex_chr			; write a hex character to the vector list
                            	  2932: 							; and return
                            	  2933: 
                            	  2934: 
                            	  2935: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2936: ;
                            	  2937: ; if suppress_0 <> 0 write a leading zero suppressed hex character to the vector list
                            	  2938: 
                            	  2939: add_sup_hex_chr
00:0000BCE4 4A2B0016        	  2940: 	TST.b		suppress_0(a3)		; test the leading zero suppressed flag
00:0000BCE8 6706            	  2941: 	BEQ.s		add_hex_chr			; if not suppressed go write a hex character
                            	  2942: 							; to the vector list
                            	  2943: 
                            	  2944: ; if supressed write a [SPACE] instead of a "0"
                            	  2945: 
00:0000BCEA 700F            	  2946: 	MOVEQ		#$0F,d0			; set the nibble mask
00:0000BCEC C240            	  2947: 	AND.w		d0,d1				; mask the low nibble
00:0000BCEE 670A            	  2948: 	BEQ.s		add_sup_zero		; if it is zero go write a space
                            	  2949: 
                            	  2950: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2951: ;
                            	  2952: ; write a hex character d1 to the vector list
                            	  2953: 
                            	  2954: add_hex_chr
00:0000BCF0 C27C000F        	  2955: 	AND.w		#$0F,d1			; mask the low nibble
00:0000BCF4 5241            	  2956: 	ADDQ.w	#1,d1				; add 1 to pass the [SPACE] character
00:0000BCF6 422B0016        	  2957: 	CLR.b		suppress_0(a3)		; clear the leading zero suppressed flag
                            	  2958: add_sup_zero
00:0000BCFA D241            	  2959: 	ADD.w		d1,d1				; ; 2, bytes per character
00:0000BCFC 2F08            	  2960: 	MOVE.l	a0,-(sp)			; save a0
00:0000BCFE 41FA184A        	  2961: 	LEA		char_set(pc),a0		; point to the character JSRL table
00:0000BD02 38F01000        	  2962: 	MOVE.w	(a0,d1.w),(a4)+		; copy the character JSRL to the vector list
00:0000BD06 205F            	  2963: 	MOVE.l	(sp)+,a0			; restore a0
                            	  2964: 
00:0000BD08 4E75            	  2965: 	RTS
                            	  2966: 
                            	  2967: 
                            	  2968: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2969: ;
                            	  2970: ; convert the a1 address and add it to the vector list as a vector subroutine call
                            	  2971: 
                            	  2972: add_address:
00:0000BD0A 41FA0222        	  2973: 	LEA		vector(pc),a0		; point to the vector memory
00:0000BD0E 93C8            	  2974: 	SUBA.l	a0,a1				; convert the pointer to an offset
00:0000BD10 2209            	  2975: 	MOVE.l	a1,d1				; copy the result
00:0000BD12 E249            	  2976: 	LSR.w		#1,d1				; / 2
00:0000BD14 C27C0FFF        	  2977: 	AND.w		#$0FFF,d1			; mask the address bits
00:0000BD18 0041C000        	  2978: 	ORI.w		#JSRL,d1			; OR with vector subroutine call
00:0000BD1C 38C1            	  2979: 	MOVE.w	d1,(a4)+			; copy to the vector list
00:0000BD1E 4E75            	  2980: 	RTS
                            	  2981: 
                            	  2982: 
                            	  2983: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2984: ;
                            	  2985: ; add 4 ; the co-ordinate pair in d1,d2 to the list as a draw command
                            	  2986: 
                            	  2987: add_coords:
00:0000BD20 7002            	  2988: 	MOVEQ		#2,d0				; set shift count
00:0000BD22 E161            	  2989: 	ASL.w		d0,d1				; x co-ordinate ; 4
00:0000BD24 E162            	  2990: 	ASL.w		d0,d2				; y co-ordinate ; 4
                            	  2991: 
00:0000BD26 303C0FFC        	  2992: 	MOVE.w	#$0FFC,d0			; set the co-ordinate mask
00:0000BD2A C240            	  2993: 	AND.w		d0,d1				; mask the x co-ordinate
00:0000BD2C C440            	  2994: 	AND.w		d0,d2				; mask the y co-ordinate
                            	  2995: 
00:0000BD2E 0042A000        	  2996: 	ORI.w		#DRAW,d2			; OR in the draw command
00:0000BD32 8253            	  2997: 	OR.w		glob_scale(a3),d1		; OR in the global scale
                            	  2998: 
00:0000BD34 38C2            	  2999: 	MOVE.w	d2,(a4)+			; save the command/y co-ordinate to the list
00:0000BD36 38C1            	  3000: 	MOVE.w	d1,(a4)+			; save the scale/x co-ordinate to the list
00:0000BD38 4E75            	  3001: 	RTS
                            	  3002: 
                            	  3003: 
                            	  3004: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3005: ;
                            	  3006: ; add (d1)00,0000 to the vector list
                            	  3007: 
                            	  3008: add_single
00:0000BD3A 7400            	  3009: 	MOVEQ		#0,d2				; clear the second word
                            	  3010: 
                            	  3011: 
                            	  3012: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3013: ;
                            	  3014: ; add (A)00,(X)00 to the vector list
                            	  3015: 
                            	  3016: add_pair
00:0000BD3C 38C1            	  3017: 	MOVE.w	d1,(a4)+			; save the first word to the vector list
00:0000BD3E 38C2            	  3018: 	MOVE.w	d2,(a4)+			; save the second word to the vector list
00:0000BD40 4E75            	  3019: 	RTS
                            	  3020: 
                            	  3021: 
                            	  3022: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3023: ;
                            	  3024: ; check the [F2], [F3] and [F4] keys. set the screen size to 640 x 480, 800 x 600 or
                            	  3025: ; 1024 x 768 if the corresponding key has been pressed
                            	  3026: 
                            	  3027: s_controls
                            	  3028: ;	MOVE.l	#$71007273,d1		; [F2], [], [F3] and [F4] keys
                            	  3029: ;	MOVEQ		#19,d0			; check for keypress
                            	  3030: ;	TRAP		#15
                            	  3031: 
                            	  3032: ;	MOVEQ		#33,d0			; set/get output window size
                            	  3033: 
                            	  3034: ;	MOVE.l	d1,d2				; copy result
                            	  3035: ;	BEQ.s		notscreen			; skip screen size if no F key
                            	  3036: 
                            	  3037: ;	MOVE.l	#$028001E0,d1		; set 640 x 480
                            	  3038: ;	TST.l		d2				; test result
                            	  3039: ;	BMI.s		setscreen			; if F2 go set window size
                            	  3040: 
                            	  3041: ;	MOVE.l	#$03200258,d1		; set 800 x 600
                            	  3042: ;	TST.w		d2				; test result
                            	  3043: ;	BMI.s		setscreen			; if F3 go set window size
                            	  3044: 
                            	  3045: 							; else was F4 so ..
                            	  3046: ;	MOVE.l	#$04000300,d1		; set 1024 x 768
                            	  3047: setscreen
                            	  3048: ;	CMP.l		scr_x(a3),d1		; compare with current screen size
                            	  3049: ;	BEQ.s		notscreen			; if already set skip setting it now
                            	  3050: 
                            	  3051: ;	TRAP		#15
                            	  3052: 
                            	  3053: notscreen
                            	  3054: ;	MOVEQ		#0,d1				; get the current window size
                            	  3055: ;	TRAP		#15
                            	  3056: 
00:0000BD42 223C03200258    	  3057: 	move.l #$03200258,d1		; always 800x600
00:0000BD48 27410006        	  3058: 	move.l d1,scr_x(a3)			; save the screen x and y size
00:0000BD4C 4E75            	  3059: 	rts
                            	  3060: 
                            	  3061: 
                            	  3062: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3063: ;
                            	  3064: ; setup stuff.
                            	  3065: 
                            	  3066: Initialise:
00:0000BD4E 7200            	  3067: 	moveq	#0,d1					; turn off echo
00:0000BD50 700C            	  3068: 	moveq	#12,d0				; keyboard echo
00:0000BD52 4E4F            	  3069: 	trap #15
                            	  3070: 
                            	  3071: ;	move.w #$FF00,d1		; clear screen
                            	  3072: ;	moveq #11,d0				; position cursor
                            	  3073: ;	trap #15
                            	  3074: 
00:0000BD54 7211            	  3075: 	moveq #17,d1				; enable double buffering
00:0000BD56 705C            	  3076: 	moveq	#92,d0				; set draw mode
00:0000BD58 4E4F            	  3077: 	trap #15
                            	  3078: 
00:0000BD5A 720A            	  3079: 	moveq #10,d1				; OR mode drawing, this helps on two ways.
                            	  3080: 							; first it emulates a vector display where
                            	  3081: 							; the vectors that cross can bright up the
                            	  3082: 							; intersection and second it means we can
                            	  3083: 							; forget depth sorting of objects
00:0000BD5C 705C            	  3084: 	moveq #92,d0				; set draw mode
00:0000BD5E 4E4F            	  3085: 	trap #15
                            	  3086: 
00:0000BD60 47FA1D1B        	  3087: 	lea	variables(pc),a3	; get the pointer to the variables base
00:0000BD64 4BEB00F3        	  3088: 	lea player_1(a3),a5		; get the pointer to player one's variables
00:0000BD68 4DEB01F7        	  3089: 	lea player_2(a3),a6		; get the pointer to player two's variables
                            	  3090: 
                            	  3091: 										; clear all the variable space
00:0000BD6C 7000            	  3092: 	moveq #0,d0				; clear the longword
00:0000BD6E 41EB0012        	  3093: 	lea hiscore_y(a3),a0		; get the start address
00:0000BD72 43EB027B        	  3094: 	lea p_2_end(a3),a1			; get the end address
                            	  3095: clear_loop
00:0000BD76 30C0            	  3096: 	move.w d0,(a0)+			; clear the word
00:0000BD78 B1C9            	  3097: 	cmpa.l a1,a0				; compare the addresses
00:0000BD7A 66FA            	  3098: 	bne.s clear_loop		; if not at end loop
                            	  3099: 
00:0000BD7C 7008            	  3100: 	moveq #8,d0					; get the time in 1/100 ths seconds
00:0000BD7E 4E4F            	  3101: 	trap #15
                            	  3102: 
00:0000BD80 0A81DEADBEEF    	  3103: 	eori.l	#$DEADBEEF,d1		; EOR with the initial PRNG seed, this must
                            	  3104: 													; result in any value but zero
00:0000BD86 4EB900002428    	  3105: 	jsr InitRand
00:0000BD8C 2741000A        	  3106: 	move.l	d1,PRNlword(a3)		; save the initial PRNG seed
                            	  3107: 
00:0000BD90 7203            	  3108: 	moveq #3,d1					; get the switches address
00:0000BD92 7020            	  3109: 	moveq #32,d0				; simulator hardware
00:0000BD94 4E4F            	  3110: 	trap #15
                            	  3111: 
00:0000BD96 2741000E        	  3112: 	move.l d1,switch_addr(a3)	; save the switches address
                            	  3113: 
                            	  3114: 	;LEA		timer_interrupt(pc),a0	; get the timer interrupt routine address
                            	  3115: 	;MOVE.l	a0,$64.w			; save the timer interrupt as interrupt 1
                            	  3116: 
                            	  3117: 	;MOVEQ		#6,d1				; set auto IRQ
                            	  3118: 	;MOVEQ		#$81,d2			; enable IRQ 1
                            	  3119: 	;MOVEQ		#16,d3			; set the time in ms
                            	  3120: 	;MOVEQ		#32,d0			; set simulator hardware
                            	  3121: 	;TRAP		#15
                            	  3122: 
                            	  3123: 	;MOVEQ		#5,d1				; enable exceptions
                            	  3124: 	;MOVEQ		#32,d0			; set simulator hardware
                            	  3125: 	;TRAP		#15
                            	  3126: 
00:0000BD9A 49FA0192        	  3127: 	lea vector(pc),a4			; get the pointer to the vector list RAM
00:0000BD9E 38BCB000        	  3128: 	move.w #HALT,(a4)			; add HALT to the vector list
                            	  3129: 
00:0000BDA2 61001B4D        	  3130: 	bsr sound_init				; initialise the sounds
                            	  3131: 
00:0000BDA6 70FF            	  3132: 	moveq #-1,d0					; flag high score done
00:0000BDA8 17400176        	  3133: 	move.b d0,p1_high(a3)	; save the player 1 highscore flag
00:0000BDAC 1740027A        	  3134: 	move.b d0,p2_high(a3)	; save the player 2 highscore flag
                            	  3135: 
00:0000BDB0 43FA1CBE        	  3136: 	lea filename(pc),a1		; point to the highscore filename
00:0000BDB4 7033            	  3137: 	moveq	#51,d0					; open existing file
00:0000BDB6 4E4F            	  3138: 	trap #15
                            	  3139: 
00:0000BDB8 4A40            	  3140: 	tst.w d0							; check for errors
00:0000BDBA 6706            	  3141: 	beq.s read_hi					; if no error go read the file
                            	  3142: 
00:0000BDBC 0C400003        	  3143: 	cmpi.w #3,d0					; compare with read only
00:0000BDC0 660A            	  3144: 	bne.s	close_all_2			; if not read only go close all files
                            	  3145: 
                            	  3146: read_hi
00:0000BDC2 43EB0027        	  3147: 	lea hiscores(a3),a1		; point to the highscore tables
00:0000BDC6 7432            	  3148: 	moveq	#50,d2					; set the table length
00:0000BDC8 7035            	  3149: 	moveq	#53,d0					; read file
00:0000BDCA 4E4F            	  3150: 	trap #15
                            	  3151: 
                            	  3152: close_all_2
00:0000BDCC 7032            	  3153: 	moveq #50,d0					; close all files
00:0000BDCE 4E4F            	  3154: 	trap #15
                            	  3155: 
00:0000BDD0 4E75            	  3156: 	rts
                            	  3157: 
                            	  3158: 
                            	  3159: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3160: ;
                            	  3161: ; This is the code that generates the pseudo random sequence. A seed word located in
                            	  3162: ; PRNlword(a3) is loaded into a register before being operated on to generate the
                            	  3163: ; next number in the sequence. This number is then saved as the seed for the next
                            	  3164: ; time it's called.
                            	  3165: ;
                            	  3166: ; This code is adapted from the 32 bit version of RND(n) used in EhBASIC68. Taking
                            	  3167: ; the 19th next number is slower but helps to hide the shift and add nature of this
                            	  3168: ; generator as can be seen from analysing the output.
                            	  3169: 
                            	  3170: gen_prng:
00:0000BDD2 2F01            	  3171: 	move.l d1,-(a7)
00:0000BDD4 4EB900002492    	  3172: 	jsr RandGetNum
00:0000BDDA 2741000A        	  3173: 	move.l d1,PRNlword(a3)
00:0000BDDE 221F            	  3174: 	move.l (a7)+,d1
00:0000BDE0 4E75            	  3175: 	rts
                            	  3176: 
                            	  3177: ;	MOVEM.l	d0-d2,-(sp)			; save d0, d1 and d2
                            	  3178: ;	MOVE.l	PRNlword(a3),d0		; get current seed longword
                            	  3179: ;	MOVEQ		#$AF-$100,d1		; set the EOR value
                            	  3180: ;	MOVEQ		#18,d2			; do this 19 times
                            	  3181: Ninc0
                            	  3182: ;	ADD.l		d0,d0				; shift left 1 bit
                            	  3183: ;	BCC.s		Ninc1				; if bit not set skip feedback
                            	  3184: 
                            	  3185: ;	EOR.b		d1,d0				; do Galois LFSR feedback
                            	  3186: Ninc1
                            	  3187: ;	DBF		d2,Ninc0			; loop
                            	  3188: 
                            	  3189: ;	MOVE.l	d0,PRNlword(a3)		; save back to seed longword
                            	  3190: ;	MOVEM.l	(sp)+,d0-d2			; restore d0, d1 and d2
                            	  3191: 
                            	  3192: ;	RTS
                            	  3193: 
                            	  3194: 
                            	  3195: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3196: ;
                            	  3197: ; vector generator subroutines. this code emulates the atari digital vector generator
                            	  3198: ; and truns the vector draw list into lines on the screen
                            	  3199: 
                            	  3200: ; vector subroutine return code. if a vector subroutine is called the address for this
                            	  3201: ; code is pushed on the stack
                            	  3202: 
                            	  3203: op_rtsvec:
00:0000BDE2 285F            	  3204: 	MOVE.l	(sp)+,a4			; restore the vector pointer
                            	  3205: 
                            	  3206: ; evaluate the next vector command. the command is pointed to by (a4) and execution
                            	  3207: ; will continue until an RTSL or HALT command is encountered. this is a subset of the
                            	  3208: ; battlezone DVG command set
                            	  3209: 
                            	  3210: do_vector:
00:0000BDE4 381C            	  3211: 	MOVE.w	(a4)+,d4			; get the vector opcode
00:0000BDE6 3004            	  3212: 	MOVE.w	d4,d0				; copy it
00:0000BDE8 ED58            	  3213: 	ROL.w		#6,d0				; shift opcode bits to b5-b2
00:0000BDEA 0240003C        	  3214: 	ANDI.w	#$003C,d0			; mask the opcode bits
00:0000BDEE 4EFB0076        	  3215: 	JMP		vector_base(pc,d0.w)	; go do the vector opcode
                            	  3216: 
                            	  3217: ; call vector subroutine, push the vector pointer and then the vector subroutine
                            	  3218: ; address as the return address then do jump to vector address
                            	  3219: 
                            	  3220: op_call
00:0000BDF2 2F0C            	  3221: 	MOVE.l	a4,-(sp)			; save the vector pointer
00:0000BDF4 487AFFEC        	  3222: 	PEA		op_rtsvec(pc)		; push vector return code as return address
                            	  3223: 
                            	  3224: ; jump to vector, the address is a thirteen bit address
                            	  3225: 
                            	  3226: op_jump
00:0000BDF8 C87C0FFF        	  3227: 	AND.w		#$0FFF,d4			; mask the address
00:0000BDFC D844            	  3228: 	ADD.w		d4,d4				; make it a word address
00:0000BDFE 49FA012E        	  3229: 	LEA		vector(pc),a4		; reset the vector RAM pointer
00:0000BE02 49F44000        	  3230: 	LEA		(a4,d4.w),a4		; calculate the new address
00:0000BE06 60DC            	  3231: 	BRA.s		do_vector			; go do the next vector
                            	  3232: 
                            	  3233: ; relative vector routine. co-ordinates are ten bit with sign numbers
                            	  3234: 
                            	  3235: op_vctr
00:0000BE08 3E3C07FF        	  3236: 	MOVE.w	#$07FF,d7			; set the co-ordinate and sign bits mask
00:0000BE0C 720A            	  3237: 	MOVEQ		#10,d1			; set the sign bit number
                            	  3238: 
00:0000BE0E C847            	  3239: 	AND.w		d7,d4				; mask the y co-ordinate and sign
00:0000BE10 0384            	  3240: 	BCLR.l	d1,d4				; test and clear the sign bit
00:0000BE12 6702            	  3241: 	BEQ.s		no_neg_y11			; if positive skip the negate
                            	  3242: 
00:0000BE14 4444            	  3243: 	NEG.w		d4				; else negate the y co-ordinate
                            	  3244: no_neg_y11
                            	  3245: 
00:0000BE16 361C            	  3246: 	MOVE.w	(a4)+,d3			; get the second word
00:0000BE18 3403            	  3247: 	MOVE.w	d3,d2				; copy the intensity
                            	  3248: 
00:0000BE1A C647            	  3249: 	AND.w		d7,d3				; mask the x co-ordinate and sign
00:0000BE1C 0383            	  3250: 	BCLR.l	d1,d3				; test and clear the sign bit
00:0000BE1E 6702            	  3251: 	BEQ.s		no_neg_x11			; if positive skip the negate
                            	  3252: 
00:0000BE20 4443            	  3253: 	NEG.w		d3				; else negate the x co-ordinate
                            	  3254: no_neg_x11
                            	  3255: 
00:0000BE22 E440            	  3256: 	ASR.w		#2,d0				; make the scale count from the masked JMP
00:0000BE24 4440            	  3257: 	NEG.w		d0				; make negative
00:0000BE26 D07C0009        	  3258: 	ADD.w		#9,d0				; make 9 - scale
                            	  3259: 
00:0000BE2A E063            	  3260: 	ASR.w		d0,d3				; scale the x co-ordinate
00:0000BE2C E064            	  3261: 	ASR.w		d0,d4				; scale the y co-ordinate
                            	  3262: 
00:0000BE2E 600000A2        	  3263: 	BRA		end_vector			; go do the end of the vector draw
                            	  3264: 
                            	  3265: ; set scale and position the beam
                            	  3266: 
                            	  3267: op_abs
00:0000BE32 3E3C07FF        	  3268: 	MOVE.w	#$07FF,d7			; set the co-ordinate and sign bits mask
00:0000BE36 720A            	  3269: 	MOVEQ		#10,d1			; set the sign bit number
                            	  3270: 
00:0000BE38 C847            	  3271: 	AND.w		d7,d4				; mask the y co-ordinate and sign
00:0000BE3A 0384            	  3272: 	BCLR.l	d1,d4				; test and clear the sign bit
00:0000BE3C 6702            	  3273: 	BEQ.s		no_neg_y10			; if positive skip the negate
                            	  3274: 
00:0000BE3E 4444            	  3275: 	NEG.w		d4				; else negate the y co-ordinate
                            	  3276: no_neg_y10
                            	  3277: 
00:0000BE40 361C            	  3278: 	MOVE.w	(a4)+,d3			; get the second word
00:0000BE42 3403            	  3279: 	MOVE.w	d3,d2				; copy the scale
                            	  3280: 
00:0000BE44 C647            	  3281: 	AND.w		d7,d3				; mask the x co-ordinate and sign
00:0000BE46 0383            	  3282: 	BCLR.l	d1,d3				; test and clear the sign bit
00:0000BE48 6702            	  3283: 	BEQ.s		no_neg_x10			; if positive skip the negate
                            	  3284: 
00:0000BE4A 4443            	  3285: 	NEG.w		d3				; else negate the x co-ordinate
                            	  3286: no_neg_x10
                            	  3287: 
                            	  3288: ; now convert the scale so it is b15 = direction flag and the rest is the shift count
                            	  3289: 
00:0000BE4C E95A            	  3290: 	ROL.w		#4,d2				; move the scale bits to bits 3 to 0
00:0000BE4E 0242000F        	  3291: 	ANDI.w	#$000F,d2			; mask the scale bits
00:0000BE52 08820003        	  3292: 	BCLR.l	#3,d2				; clear the top bit
00:0000BE56 6706            	  3293: 	BEQ.s		not_right			; ship right shift adjust
                            	  3294: 
00:0000BE58 4442            	  3295: 	NEG.w		d2				; make negative
00:0000BE5A D47C8008        	  3296: 	ADD.w		#$8008,d2			; add offset and flag right shift
                            	  3297: not_right
00:0000BE5E 3682            	  3298: 	MOVE.w	d2,(a3)			; save the global scal, offset is zero	##
                            	  3299: ;##	MOVE.w	d2,vector_s(a3)		; save the global scale
                            	  3300: 
00:0000BE60 7056            	  3301: 	MOVEQ		#86,d0			; set move to x,y
00:0000BE62 6000009E        	  3302: 	BRA		vector_move			; go do the move
                            	  3303: 
                            	  3304: vector_base
00:0000BE66 4E75            	  3305: 	RTS						; treat $0xxx as HALT, quit processing vectors
00:0000BE68 4E71            	  3306: 	NOP						; filler
00:0000BE6A 6000FF9C        	  3307: 	BRA.w		op_vctr			; scale 1 relative long vector
00:0000BE6E 6000FF98        	  3308: 	BRA.w		op_vctr			; scale 2 relative long vector
00:0000BE72 6000FF94        	  3309: 	BRA.w		op_vctr			; scale 3 relative long vector
00:0000BE76 6000FF90        	  3310: 	BRA.w		op_vctr			; scale 4 relative long vector
00:0000BE7A 6000FF8C        	  3311: 	BRA.w		op_vctr			; scale 5 relative long vector
00:0000BE7E 6000FF88        	  3312: 	BRA.w		op_vctr			; scale 6 relative long vector
00:0000BE82 6000FF84        	  3313: 	BRA.w		op_vctr			; scale 7 relative long vector
00:0000BE86 6000FF80        	  3314: 	BRA.w		op_vctr			; scale 8 relative long vector
00:0000BE8A 6000FF7C        	  3315: 	BRA.w		op_vctr			; scale 9 relative long vector
00:0000BE8E 6000FFA2        	  3316: 	BRA.w		op_abs			; set scale and position beam
00:0000BE92 4E75            	  3317: 	RTS						; do HALT, quit processing vectors
00:0000BE94 4E71            	  3318: 	NOP						; filler
00:0000BE96 6000FF5A        	  3319: 	BRA.w		op_call			; call vector subroutine
00:0000BE9A 4E75            	  3320: 	RTS						; return from vector subroutine
00:0000BE9C 4E71            	  3321: 	NOP						; filler
00:0000BE9E 6000FF58        	  3322: 	BRA.w		op_jump			; do vector jump
                            	  3323: ;##	BRA.w		op_short			; draw relative short vector
                            	  3324: 
                            	  3325: ; do relative short vector
                            	  3326: 
                            	  3327: op_short
00:0000BEA2 3E04            	  3328: 	MOVE.w	d4,d7				; copy the opcode
00:0000BEA4 02470808        	  3329: 	ANDI.w	#$0808,d7			; mask the scale bits	0000 x000 0000 y000
00:0000BEA8 E94F            	  3330: 	LSL.w		#4,d7				; shift bits to b8,b0	x000 0000 y000 0000
00:0000BEAA E31F            	  3331: 	ROL.b		#1,d7				; shift bits together	x000 0000 0000 000y
00:0000BEAC E35F            	  3332: 	ROL.w		#1,d7				; shift bits to b1,b0	0000 0000 0000 00yx
00:0000BEAE 5247            	  3333: 	ADDQ.w	#1,d7				; make 1 to 4
                            	  3334: 
00:0000BEB0 1F04            	  3335: 	MOVE.b	d4,-(sp)			; push the intensity byte
00:0000BEB2 341F            	  3336: 	MOVE.w	(sp)+,d2			; pull the word, intensity now in high byte
                            	  3337: 
00:0000BEB4 7007            	  3338: 	MOVEQ		#7,d0				; set the co-ordinate and sign bits mask
00:0000BEB6 7202            	  3339: 	MOVEQ		#2,d1				; set the sign bit number
                            	  3340: 
00:0000BEB8 3604            	  3341: 	MOVE.w	d4,d3				; copy the opcode for the x co-ordinate
                            	  3342: 
00:0000BEBA 3F04            	  3343: 	MOVE.w	d4,-(sp)			; push the opcode
00:0000BEBC 181F            	  3344: 	MOVE.b	(sp)+,d4			; pull the y co-ordinate byte
                            	  3345: 
00:0000BEBE C840            	  3346: 	AND.w		d0,d4				; mask the y co-ordinate and sign bits
00:0000BEC0 0384            	  3347: 	BCLR.l	d1,d4				; test and clear the sign bit
00:0000BEC2 6702            	  3348: 	BEQ.s		no_neg_y2			; if positive just exit
                            	  3349: 
00:0000BEC4 4444            	  3350: 	NEG.w		d4				; else negate the y co-ordinate
                            	  3351: no_neg_y2
                            	  3352: 
00:0000BEC6 C640            	  3353: 	AND.w		d0,d3				; mask the x co-ordinate and sign bits
00:0000BEC8 0383            	  3354: 	BCLR.l	d1,d3				; test and clear the sign bit
00:0000BECA 6702            	  3355: 	BEQ.s		no_neg_x2			; if positive just exit
                            	  3356: 
00:0000BECC 4443            	  3357: 	NEG.w		d3				; else negate the x co-ordinate
                            	  3358: no_neg_x2
                            	  3359: 
00:0000BECE EF63            	  3360: 	ASL.w		d7,d3				; scale the x magnitude
00:0000BED0 EF64            	  3361: 	ASL.w		d7,d4				; scale the y magnitude
                            	  3362: 
                            	  3363: end_vector
00:0000BED2 3E13            	  3364: 	MOVE.w	(a3),d7			; get the global scale, offset is zero	##
                            	  3365: ;##	MOVE.w	vector_s(a3),d7		; get the global scale
00:0000BED4 6A06            	  3366: 	BPL.s		shift_left			; if positive go shift left
                            	  3367: 
                            	  3368: 							; else shift right
00:0000BED6 EE63            	  3369: 	ASR.w		d7,d3				; scale the x co-ordinate
00:0000BED8 EE64            	  3370: 	ASR.w		d7,d4				; scale the y co-ordinate
00:0000BEDA 6004            	  3371: 	BRA.s		last_vector			; continue
                            	  3372: 
                            	  3373: shift_left
00:0000BEDC EF63            	  3374: 	ASL.w		d7,d3				; scale the x co-ordinate
00:0000BEDE EF64            	  3375: 	ASL.w		d7,d4				; scale the y co-ordinate
                            	  3376: last_vector
00:0000BEE0 D66B0002        	  3377: 	ADD.w		local_x(a3),d3		; add x the co-ordinate to vector x
00:0000BEE4 D86B0004        	  3378: 	ADD.w		local_y(a3),d4		; add y the co-ordinate to vector y
                            	  3379: 
00:0000BEE8 7056            	  3380: 	MOVEQ		#86,d0			; set move to x,y
                            	  3381: 
00:0000BEEA C47CF000        	  3382: 	AND.w		#$F000,d2			; d2 is intensity
00:0000BEEE 6712            	  3383: 	BEQ.s		vector_move			; if zero intensity just do move
                            	  3384: 
00:0000BEF0 7200            	  3385: 	MOVEQ		#0,d1				; clear the longword
00:0000BEF2 3F02            	  3386: 	MOVE.w	d2,-(sp)			; copy the intensity
00:0000BEF4 141F            	  3387: 	MOVE.b	(sp)+,d2			; to the low byte byte
00:0000BEF6 1202            	  3388: 	MOVE.b	d2,d1				; copy the intensity byte
00:0000BEF8 4841            	  3389: 	SWAP		d1				; move to the high word
00:0000BEFA 3202            	  3390: 	MOVE.w	d2,d1				; get the other word
                            	  3391: 
00:0000BEFC 7050            	  3392: 	MOVEQ		#80,d0			; set pen colour
00:0000BEFE 4E4F            	  3393: 	TRAP		#15
                            	  3394: 
00:0000BF00 7055            	  3395: 	MOVEQ		#85,d0			; set draw to x,y
                            	  3396: vector_move
00:0000BF02 3404            	  3397: 	MOVE.w	d4,d2				; copy the y co-ordinate
00:0000BF04 3203            	  3398: 	MOVE.w	d3,d1				; copy the x co-ordinate
                            	  3399: ;##	BRA.s		display_vector		; display the vector
                            	  3400: 
                            	  3401: 
                            	  3402: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3403: ;
                            	  3404: ; display vector and do next. takes the vector, scales the x and y to the current
                            	  3405: ; screen size - does axis inversion if needed - and then displays it. set up the
                            	  3406: ; graphics function in d0, x co-ordinate in d1.w and y co-ordinate in d2.w
                            	  3407: 
                            	  3408: ;##display_vector
00:0000BF06 37410002        	  3409: 	MOVE.w	d1,local_x(a3)		; save as new local x co-ordinate
00:0000BF0A 37420004        	  3410: 	MOVE.w	d2,local_y(a3)		; save as new local y co-ordinate
                            	  3411: 
00:0000BF0E 760A            	  3412: 	MOVEQ		#10,d3			; set the shift count for / 1024
                            	  3413: 
00:0000BF10 C3EB0006        	  3414: 	MULS.w	scr_x(a3),d1		; x ; screen x
00:0000BF14 E6A1            	  3415: 	ASR.l		d3,d1				; / 1024
                            	  3416: 
00:0000BF16 947C0080        	  3417: 	SUB.w		#128,d2			; subtract offset to centre vertically
00:0000BF1A C5EB0006        	  3418: 	MULS.w	scr_x(a3),d2		; y ; screen x
00:0000BF1E E6A2            	  3419: 	ASR.l		d3,d2				; / 1024
00:0000BF20 4442            	  3420: 	NEG.w		d2				; y = 0 is top of screen remember
00:0000BF22 D46B0008        	  3421: 	ADD.w		scr_y(a3),d2		; + screen y
00:0000BF26 5342            	  3422: 	SUBQ.w	#1,d2				; - 1
                            	  3423: 
00:0000BF28 4E4F            	  3424: 	TRAP		#15				; do move or draw
                            	  3425: 
00:0000BF2A 6000FEB8        	  3426: 	BRA		do_vector			; go do the next vector opcode
                            	  3427: 
                            	  3428: 
                            	  3429: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3430: ;
                            	  3431: ; vector commands
                            	  3432: 
                            	  3433: REL1		EQU $1000				; draw relative
                            	  3434: REL2		EQU $2000				; draw relative
                            	  3435: REL3		EQU $3000				; draw relative
                            	  3436: REL4		EQU $4000				; draw relative
                            	  3437: REL5		EQU $5000				; draw relative
                            	  3438: REL6		EQU $6000				; draw relative
                            	  3439: REL7		EQU $7000				; draw relative
                            	  3440: REL8		EQU $8000				; draw relative
                            	  3441: REL9		EQU $9000				; draw relative
                            	  3442: DRAW		EQU $A000				; draw absolute
                            	  3443: HALT		EQU $B000				; halt
                            	  3444: JSRL		EQU $C000				; vector subroutine call
                            	  3445: RTSL		EQU $D000				; return from vector subroutine
                            	  3446: JMPL		EQU $E000				; vector jump
                            	  3447: SHRT		EQU $F000				; relative short vector
                            	  3448: 
                            	  3449: 
                            	  3450: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3451: ;
                            	  3452: ; vector list RAM
                            	  3453: 
                            	  3454: vector
00:0000BF2E 00              	  3455: 	ds.b	$1000					; 4k of space
00:0000BF2F *
                            	  3456: 
                            	  3457: 
                            	  3458: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3459: ;
                            	  3460: ; vector ROM
                            	  3461: 
                            	  3462: ; copyright symbol followed by JSR's to write "2009 LEE DAVISO", followed by a JMP to
                            	  3463: ; char_n, which is the routine for "N"
                            	  3464: 
                            	  3465: copy_msg
00:0000CF2E A088            	  3466: 	dc.w	$A088,$019A,$7000,$0000,$F573,$F173,$F178,$F177
00:0000CF30 019A
00:0000CF32 7000
00:0000CF34 0000
00:0000CF36 F573
00:0000CF38 F173
00:0000CF3A F178
00:0000CF3C F177
00:0000CF3E F577            	  3467: 	dc.w	$F577,$F578,$3180,$0200,$F875,$FD70,$F871,$FD02
00:0000CF40 F578
00:0000CF42 3180
00:0000CF44 0200
00:0000CF46 F875
00:0000CF48 FD70
00:0000CF4A F871
00:0000CF4C FD02
00:0000CF4E CAD6            	  3468: 	dc.w	JSRL+(char_2-vector)>>1		; 2
00:0000CF50 CA81            	  3469: 	dc.w	JSRL+(char_o0-vector)>>1	; 0
00:0000CF52 CA81            	  3470: 	dc.w	JSRL+(char_o0-vector)>>1	; 0
00:0000CF54 CB07            	  3471: 	dc.w	JSRL+(char_9-vector)>>1		; 9
00:0000CF56 CAD0            	  3472: 	dc.w	JSRL+(char_spc-vector)>>1	; [SPACE]
00:0000CF58 CA71            	  3473: 	dc.w	JSRL+(char_l-vector)>>1		; L
00:0000CF5A CA3F            	  3474: 	dc.w	JSRL+(char_e-vector)>>1		; E
00:0000CF5C CA3F            	  3475: 	dc.w	JSRL+(char_e-vector)>>1		; E
00:0000CF5E CAD0            	  3476: 	dc.w	JSRL+(char_spc-vector)>>1	; [SPACE]
00:0000CF60 CA37            	  3477: 	dc.w	JSRL+(char_d-vector)>>1		; D
00:0000CF62 CA1C            	  3478: 	dc.w	JSRL+(char_a-vector)>>1		; A
00:0000CF64 CAB2            	  3479: 	dc.w	JSRL+(char_v-vector)>>1		; V
00:0000CF66 CA5E            	  3480: 	dc.w	JSRL+(char_i-vector)>>1		; I
00:0000CF68 CA9F            	  3481: 	dc.w	JSRL+(char_s-vector)>>1		; S
00:0000CF6A CA81            	  3482: 	dc.w	JSRL+(char_o0-vector)>>1	; O
00:0000CF6C EA7C            	  3483: 	dc.w	JMPL+(char_n-vector)>>1		; N
                            	  3484: 
                            	  3485: ; table for the various saucer and rock explosions
                            	  3486: 
                            	  3487: expl_tab
00:0000CF6E C874            	  3488: 	dc.w	JSRL+(expl_0-vector)>>1		; explosion 0
00:0000CF70 C859            	  3489: 	dc.w	JSRL+(expl_1-vector)>>1		; explosion 1
00:0000CF72 C83A            	  3490: 	dc.w	JSRL+(expl_2-vector)>>1		; explosion 2
00:0000CF74 C824            	  3491: 	dc.w	JSRL+(expl_3-vector)>>1		; explosion 3
                            	  3492: 
                            	  3493: ; explosion 3
                            	  3494: 
                            	  3495: expl_3
00:0000CF76 F80D            	  3496: 	dc.w	$F80D,$F8F8,$FD0D,$F8F8,$FD09,$F8F8,$F10B,$F8F8
00:0000CF78 F8F8
00:0000CF7A FD0D
00:0000CF7C F8F8
00:0000CF7E FD09
00:0000CF80 F8F8
00:0000CF82 F10B
00:0000CF84 F8F8
00:0000CF86 F50A            	  3497: 	dc.w	$F50A,$F8F8,$F908,$F8F8,$F309,$F8F8,$F30D,$F8F8
00:0000CF88 F8F8
00:0000CF8A F908
00:0000CF8C F8F8
00:0000CF8E F309
00:0000CF90 F8F8
00:0000CF92 F30D
00:0000CF94 F8F8
00:0000CF96 5480            	  3498: 	dc.w	$5480,$0600,$F8F8,$F10F,$F8F8,RTSL
00:0000CF98 0600
00:0000CF9A F8F8
00:0000CF9C F10F
00:0000CF9E F8F8
00:0000CFA0 D000
                            	  3499: 
                            	  3500: ; explosion 2
                            	  3501: 
                            	  3502: expl_2
00:0000CFA2 3000            	  3503: 	dc.w	$3000,$0780,$F8F8,$3780,$0780,$F8F8,$3780,$0380
00:0000CFA4 0780
00:0000CFA6 F8F8
00:0000CFA8 3780
00:0000CFAA 0780
00:0000CFAC F8F8
00:0000CFAE 3780
00:0000CFB0 0380
00:0000CFB2 F8F8            	  3504: 	dc.w	$F8F8,$40E0,$02A0,$F8F8,$35C0,$0380,$F8F8,$3380
00:0000CFB4 40E0
00:0000CFB6 02A0
00:0000CFB8 F8F8
00:0000CFBA 35C0
00:0000CFBC 0380
00:0000CFBE F8F8
00:0000CFC0 3380
00:0000CFC2 0000            	  3505: 	dc.w	$0000,$F8F8,$42A0,$00E0,$F8F8,$42A0,$04E0,$F8F8
00:0000CFC4 F8F8
00:0000CFC6 42A0
00:0000CFC8 00E0
00:0000CFCA F8F8
00:0000CFCC 42A0
00:0000CFCE 04E0
00:0000CFD0 F8F8
00:0000CFD2 44E0            	  3506: 	dc.w	$44E0,$0780,$F8F8,$40E0,$06A0,$F8F8,RTSL
00:0000CFD4 0780
00:0000CFD6 F8F8
00:0000CFD8 40E0
00:0000CFDA 06A0
00:0000CFDC F8F8
00:0000CFDE D000
                            	  3507: 
                            	  3508: ; explosion 1
                            	  3509: 
                            	  3510: expl_1
00:0000CFE0 F807            	  3511: 	dc.w	$F807,$F8F8,$FF07,$F8F8,$FF03,$F8F8,$40C0,$0240
00:0000CFE2 F8F8
00:0000CFE4 FF07
00:0000CFE6 F8F8
00:0000CFE8 FF03
00:0000CFEA F8F8
00:0000CFEC 40C0
00:0000CFEE 0240
00:0000CFF0 F8F8            	  3512: 	dc.w	$F8F8,$3580,$0300,$F8F8,$FB00,$F8F8,$4240,$00C0
00:0000CFF2 3580
00:0000CFF4 0300
00:0000CFF6 F8F8
00:0000CFF8 FB00
00:0000CFFA F8F8
00:0000CFFC 4240
00:0000CFFE 00C0
00:0000D000 F8F8            	  3513: 	dc.w	$F8F8,$4240,$04C0,$F8F8,$44C0,$0700,$F8F8,$40C0
00:0000D002 4240
00:0000D004 04C0
00:0000D006 F8F8
00:0000D008 44C0
00:0000D00A 0700
00:0000D00C F8F8
00:0000D00E 40C0
00:0000D010 0640            	  3514: 	dc.w	$0640,$F8F8,RTSL
00:0000D012 F8F8
00:0000D014 D000
                            	  3515: 
                            	  3516: ; explosion 0
                            	  3517: 
                            	  3518: expl_0
00:0000D016 3000            	  3519: 	dc.w	$3000,$0680,$F8F8,$3680,$0680,$F8F8,$3680,$0280
00:0000D018 0680
00:0000D01A F8F8
00:0000D01C 3680
00:0000D01E 0680
00:0000D020 F8F8
00:0000D022 3680
00:0000D024 0280
00:0000D026 F8F8            	  3520: 	dc.w	$F8F8,$3140,$03C0,$F8F8,$3540,$0280,$F8F8,$3280
00:0000D028 3140
00:0000D02A 03C0
00:0000D02C F8F8
00:0000D02E 3540
00:0000D030 0280
00:0000D032 F8F8
00:0000D034 3280
00:0000D036 0000            	  3521: 	dc.w	$0000,$F8F8,$33C0,$0140,$F8F8,$33C0,$0540,$F8F8
00:0000D038 F8F8
00:0000D03A 33C0
00:0000D03C 0140
00:0000D03E F8F8
00:0000D040 33C0
00:0000D042 0540
00:0000D044 F8F8
00:0000D046 44A0            	  3522: 	dc.w	$44A0,$0680,$F8F8,$3140,$07C0,$F8F8,RTSL
00:0000D048 0680
00:0000D04A F8F8
00:0000D04C 3140
00:0000D04E 07C0
00:0000D050 F8F8
00:0000D052 D000
                            	  3523: 
                            	  3524: ; table for rocks
                            	  3525: 
                            	  3526: rock_tab
00:0000D054 C897            	  3527: 	dc.w	JSRL+(rock_0-vector)>>1		; top notch rock
00:0000D056 C8A3            	  3528: 	dc.w	JSRL+(rock_1-vector)>>1		; "X" rock
00:0000D058 C8B1            	  3529: 	dc.w	JSRL+(rock_2-vector)>>1		; bottom and left notch rock
00:0000D05A C8BE            	  3530: 	dc.w	JSRL+(rock_3-vector)>>1		; left and right notch rock
                            	  3531: 
                            	  3532: ; top notch rock
                            	  3533: 
                            	  3534: rock_0
00:0000D05C F908            	  3535: 	dc.w	$F908,$F979,$FD79,$F67D,$F679,$F68F,$F08F,$F97D
00:0000D05E F979
00:0000D060 FD79
00:0000D062 F67D
00:0000D064 F679
00:0000D066 F68F
00:0000D068 F08F
00:0000D06A F97D
00:0000D06C FA78            	  3536: 	dc.w	$FA78,$F979,$FD79,RTSL
00:0000D06E F979
00:0000D070 FD79
00:0000D072 D000
                            	  3537: 
                            	  3538: ; "X" rock
                            	  3539: 
                            	  3540: rock_1
00:0000D074 F10A            	  3541: 	dc.w	$F10A,$F17A,$F97D,$F57E,$F17E,$FD7D,$F679,$F67D
00:0000D076 F17A
00:0000D078 F97D
00:0000D07A F57E
00:0000D07C F17E
00:0000D07E FD7D
00:0000D080 F679
00:0000D082 F67D
00:0000D084 FD79            	  3542: 	dc.w	$FD79,$F179,$F58B,$F38A,$F97D,RTSL
00:0000D086 F179
00:0000D088 F58B
00:0000D08A F38A
00:0000D08C F97D
00:0000D08E D000
                            	  3543: 
                            	  3544: ; bottom and left notch rock
                            	  3545: 
                            	  3546: rock_2
00:0000D090 F80D            	  3547: 	dc.w	$F80D,$F57E,$F77A,$F37A,$F778,$F879,$F37A,$F978
00:0000D092 F57E
00:0000D094 F77A
00:0000D096 F37A
00:0000D098 F778
00:0000D09A F879
00:0000D09C F37A
00:0000D09E F978
00:0000D0A0 F37E            	  3548: 	dc.w	$F37E,$F07F,$F77F,$F57A,RTSL
00:0000D0A2 F07F
00:0000D0A4 F77F
00:0000D0A6 F57A
00:0000D0A8 D000
                            	  3549: 
                            	  3550: ; left and right notch rock
                            	  3551: 
                            	  3552: rock_3
00:0000D0AA F009            	  3553: 	dc.w	$F009,$F17B,$F168,$F27F,$F07F,$F669,$F07F,$F778
00:0000D0AC F17B
00:0000D0AE F168
00:0000D0B0 F27F
00:0000D0B2 F07F
00:0000D0B4 F669
00:0000D0B6 F07F
00:0000D0B8 F778
00:0000D0BA F77A            	  3554: 	dc.w	$F77A,$F17B,$F569,$F969,$F27F,RTSL
00:0000D0BC F17B
00:0000D0BE F569
00:0000D0C0 F969
00:0000D0C2 F27F
00:0000D0C4 D000
                            	  3555: 
                            	  3556: ; indirect saucer table
                            	  3557: 
                            	  3558: sauc_jsr
00:0000D0C6 C8CD            	  3559: 	dc.w	JSRL+(sauc_vec-vector)>>1	; saucer
                            	  3560: 
                            	  3561: ; saucer
                            	  3562: 
                            	  3563: sauc_vec
00:0000D0C8 F10E            	  3564: 	dc.w	$F10E,$F8CA,$F60B,$6000,$D680,$F6DB,$F8CA,$F2DB
00:0000D0CA F8CA
00:0000D0CC F60B
00:0000D0CE 6000
00:0000D0D0 D680
00:0000D0D2 F6DB
00:0000D0D4 F8CA
00:0000D0D6 F2DB
00:0000D0D8 F2DF            	  3565: 	dc.w	$F2DF,$F2CD,$F8CD,$F6CD,$F6DF,RTSL
00:0000D0DA F2CD
00:0000D0DC F8CD
00:0000D0DE F6CD
00:0000D0E0 F6DF
00:0000D0E2 D000
                            	  3566: 
                            	  3567: ; player ship address table
                            	  3568: 
                            	  3569: play_tab
00:0000D0E4 0022            	  3570: 	dc.w	play_00-play_tab
00:0000D0E6 003A            	  3571: 	dc.w	play_01-play_tab
00:0000D0E8 005E            	  3572: 	dc.w	play_02-play_tab
00:0000D0EA 0082            	  3573: 	dc.w	play_03-play_tab
00:0000D0EC 00A6            	  3574: 	dc.w	play_04-play_tab
00:0000D0EE 00C8            	  3575: 	dc.w	play_05-play_tab
00:0000D0F0 00EC            	  3576: 	dc.w	play_06-play_tab
00:0000D0F2 0110            	  3577: 	dc.w	play_07-play_tab
00:0000D0F4 0134            	  3578: 	dc.w	play_08-play_tab
00:0000D0F6 0158            	  3579: 	dc.w	play_09-play_tab
00:0000D0F8 017C            	  3580: 	dc.w	play_0A-play_tab
00:0000D0FA 01A0            	  3581: 	dc.w	play_0B-play_tab
00:0000D0FC 01C4            	  3582: 	dc.w	play_0C-play_tab
00:0000D0FE 01E8            	  3583: 	dc.w	play_0D-play_tab
00:0000D100 020C            	  3584: 	dc.w	play_0E-play_tab
00:0000D102 0230            	  3585: 	dc.w	play_0F-play_tab
00:0000D104 0254            	  3586: 	dc.w	play_10-play_tab
                            	  3587: 
                            	  3588: ; ship and thrust outlines. each ship outline is followed by its thrust outline which
                            	  3589: ; is only copied if the thrust button is pressed
                            	  3590: 
                            	  3591: play_00
00:0000D106 F60F            	  3592: 	dc.w	$F60F,$FAC8,$F9BD,$6500,$C300,$6500,$C700,$F9B9
00:0000D108 FAC8
00:0000D10A F9BD
00:0000D10C 6500
00:0000D10E C300
00:0000D110 6500
00:0000D112 C700
00:0000D114 F9B9
00:0000D116 D000            	  3593: 	dc.w	RTSL
00:0000D118 F9CE            	  3594: 	dc.w	$F9CE,$F9CA,RTSL
00:0000D11A F9CA
00:0000D11C D000
                            	  3595: play_01
00:0000D11E 4640            	  3596: 	dc.w	$4640,$06C0,$5200,$C430,$41C0,$C620,$64B0,$C318
00:0000D120 06C0
00:0000D122 5200
00:0000D124 C430
00:0000D126 41C0
00:0000D128 C620
00:0000D12A 64B0
00:0000D12C C318
00:0000D12E 6548            	  3597: 	dc.w	$6548,$C6E0,$4220,$C1C0,RTSL
00:0000D130 C6E0
00:0000D132 4220
00:0000D134 C1C0
00:0000D136 D000
00:0000D138 50D0            	  3598: 	dc.w	$50D0,$C610,$4260,$C3C0,RTSL
00:0000D13A C610
00:0000D13C 4260
00:0000D13E C3C0
00:0000D140 D000
                            	  3599: play_02
00:0000D142 4680            	  3600: 	dc.w	$4680,$0680,$43E0,$C4C0,$41A0,$C660,$6468,$C320
00:0000D144 0680
00:0000D146 43E0
00:0000D148 C4C0
00:0000D14A 41A0
00:0000D14C C660
00:0000D14E 6468
00:0000D150 C320
00:0000D152 6590            	  3601: 	dc.w	$6590,$C6C0,$4260,$C1A0,RTSL
00:0000D154 C6C0
00:0000D156 4260
00:0000D158 C1A0
00:0000D15A D000
00:0000D15C 5090            	  3602: 	dc.w	$5090,$C630,$42C0,$C380,RTSL
00:0000D15E C630
00:0000D160 42C0
00:0000D162 C380
00:0000D164 D000
                            	  3603: play_03
00:0000D166 46C0            	  3604: 	dc.w	$46C0,$0640,$43E0,$C520,$4160,$C680,$6418,$C328
00:0000D168 0640
00:0000D16A 43E0
00:0000D16C C520
00:0000D16E 4160
00:0000D170 C680
00:0000D172 6418
00:0000D174 C328
00:0000D176 65D0            	  3605: 	dc.w	$65D0,$C698,$4280,$C160,RTSL
00:0000D178 C698
00:0000D17A 4280
00:0000D17C C160
00:0000D17E D000
00:0000D180 5060            	  3606: 	dc.w	$5060,$C630,$4320,$C340,RTSL
00:0000D182 C630
00:0000D184 4320
00:0000D186 C340
00:0000D188 D000
                            	  3607: play_04
00:0000D18A F70E            	  3608: 	dc.w	$F70E,$43C0,$C580,$4120,$C6A0,$6038,$C328,$6610
00:0000D18C 43C0
00:0000D18E C580
00:0000D190 4120
00:0000D192 C6A0
00:0000D194 6038
00:0000D196 C328
00:0000D198 6610
00:0000D19A C660            	  3609: 	dc.w	$C660,$42A0,$C120,RTSL
00:0000D19C 42A0
00:0000D19E C120
00:0000D1A0 D000
00:0000D1A2 5030            	  3610: 	dc.w	$5030,$C640,$4360,$C2E0,RTSL
00:0000D1A4 C640
00:0000D1A6 4360
00:0000D1A8 C2E0
00:0000D1AA D000
                            	  3611: play_05
00:0000D1AC 4720            	  3612: 	dc.w	$4720,$05C0,$4380,$C5E0,$40E0,$C6C0,$6088,$C320
00:0000D1AE 05C0
00:0000D1B0 4380
00:0000D1B2 C5E0
00:0000D1B4 40E0
00:0000D1B6 C6C0
00:0000D1B8 6088
00:0000D1BA C320
00:0000D1BC 6648            	  3613: 	dc.w	$6648,$C630,$42C0,$C0E0,RTSL
00:0000D1BE C630
00:0000D1C0 42C0
00:0000D1C2 C0E0
00:0000D1C4 D000
00:0000D1C6 5410            	  3614: 	dc.w	$5410,$C640,$43A0,$C2A0,RTSL
00:0000D1C8 C640
00:0000D1CA 43A0
00:0000D1CC C2A0
00:0000D1CE D000
                            	  3615: play_06
00:0000D1D0 4760            	  3616: 	dc.w	$4760,$0560,$4360,$C640,$4080,$C6C0,$60D8,$C310
00:0000D1D2 0560
00:0000D1D4 4360
00:0000D1D6 C640
00:0000D1D8 4080
00:0000D1DA C6C0
00:0000D1DC 60D8
00:0000D1DE C310
00:0000D1E0 6680            	  3617: 	dc.w	$6680,$C5F0,$42C0,$C080,RTSL
00:0000D1E2 C5F0
00:0000D1E4 42C0
00:0000D1E6 C080
00:0000D1E8 D000
00:0000D1EA 5440            	  3618: 	dc.w	$5440,$C630,$43E0,$C240,RTSL
00:0000D1EC C630
00:0000D1EE 43E0
00:0000D1F0 C240
00:0000D1F2 D000
                            	  3619: play_07
00:0000D1F4 4780            	  3620: 	dc.w	$4780,$0500,$4320,$C680,$4040,$C6E0,$6120,$C2F8
00:0000D1F6 0500
00:0000D1F8 4320
00:0000D1FA C680
00:0000D1FC 4040
00:0000D1FE C6E0
00:0000D200 6120
00:0000D202 C2F8
00:0000D204 66B0            	  3621: 	dc.w	$66B0,$C5B0,$42E0,$C040,RTSL
00:0000D206 C5B0
00:0000D208 42E0
00:0000D20A C040
00:0000D20C D000
00:0000D20E 5480            	  3622: 	dc.w	$5480,$C630,$5210,$C0F0,RTSL
00:0000D210 C630
00:0000D212 5210
00:0000D214 C0F0
00:0000D216 D000
                            	  3623: play_08
00:0000D218 4780            	  3624: 	dc.w	$4780,$04C0,$42E0,$C6E0,$4000,$C6E0,$6168,$C2D8
00:0000D21A 04C0
00:0000D21C 42E0
00:0000D21E C6E0
00:0000D220 4000
00:0000D222 C6E0
00:0000D224 6168
00:0000D226 C2D8
00:0000D228 66D8            	  3625: 	dc.w	$66D8,$C568,$42E0,$C000,RTSL
00:0000D22A C568
00:0000D22C 42E0
00:0000D22E C000
00:0000D230 D000
00:0000D232 54B0            	  3626: 	dc.w	$54B0,$C620,$5220,$C0B0,RTSL
00:0000D234 C620
00:0000D236 5220
00:0000D238 C0B0
00:0000D23A D000
                            	  3627: play_09
00:0000D23C 47A0            	  3628: 	dc.w	$47A0,$0460,$4280,$C720,$4440,$C6E0,$61B0,$C2B0
00:0000D23E 0460
00:0000D240 4280
00:0000D242 C720
00:0000D244 4440
00:0000D246 C6E0
00:0000D248 61B0
00:0000D24A C2B0
00:0000D24C 66F8            	  3629: 	dc.w	$66F8,$C520,$42E0,$C440,RTSL
00:0000D24E C520
00:0000D250 42E0
00:0000D252 C440
00:0000D254 D000
00:0000D256 54F0            	  3630: 	dc.w	$54F0,$C610,$5230,$C080,RTSL
00:0000D258 C610
00:0000D25A 5230
00:0000D25C C080
00:0000D25E D000
                            	  3631: play_0A
00:0000D260 47A0            	  3632: 	dc.w	$47A0,$0000,$4240,$C760,$4480,$C6C0,$61F0,$C280
00:0000D262 0000
00:0000D264 4240
00:0000D266 C760
00:0000D268 4480
00:0000D26A C6C0
00:0000D26C 61F0
00:0000D26E C280
00:0000D270 6710            	  3633: 	dc.w	$6710,$C4D8,$42C0,$C480,RTSL
00:0000D272 C4D8
00:0000D274 42C0
00:0000D276 C480
00:0000D278 D000
00:0000D27A 4640            	  3634: 	dc.w	$4640,$C7E0,$5230,$C040,RTSL
00:0000D27C C7E0
00:0000D27E 5230
00:0000D280 C040
00:0000D282 D000
                            	  3635: play_0B
00:0000D284 47A0            	  3636: 	dc.w	$47A0,$0060,$41E0,$C780,$44E0,$C6C0,$6230,$C248
00:0000D286 0060
00:0000D288 41E0
00:0000D28A C780
00:0000D28C 44E0
00:0000D28E C6C0
00:0000D290 6230
00:0000D292 C248
00:0000D294 6720            	  3637: 	dc.w	$6720,$C488,$42C0,$C4E0,RTSL
00:0000D296 C488
00:0000D298 42C0
00:0000D29A C4E0
00:0000D29C D000
00:0000D29E 46A0            	  3638: 	dc.w	$46A0,$C7A0,$5240,$C010,RTSL
00:0000D2A0 C7A0
00:0000D2A2 5240
00:0000D2A4 C010
00:0000D2A6 D000
                            	  3639: play_0C
00:0000D2A8 4780            	  3640: 	dc.w	$4780,$00C0,$4180,$C7C0,$4520,$C6A0,$6260,$C210
00:0000D2AA 00C0
00:0000D2AC 4180
00:0000D2AE C7C0
00:0000D2B0 4520
00:0000D2B2 C6A0
00:0000D2B4 6260
00:0000D2B6 C210
00:0000D2B8 6728            	  3641: 	dc.w	$6728,$C438,$42A0,$C520,RTSL
00:0000D2BA C438
00:0000D2BC 42A0
00:0000D2BE C520
00:0000D2C0 D000
00:0000D2C2 46E0            	  3642: 	dc.w	$46E0,$C760,$5240,$C430,RTSL
00:0000D2C4 C760
00:0000D2C6 5240
00:0000D2C8 C430
00:0000D2CA D000
                            	  3643: play_0D
00:0000D2CC 4780            	  3644: 	dc.w	$4780,$0100,$4120,$C7E0,$4560,$C680,$6298,$C1D0
00:0000D2CE 0100
00:0000D2D0 4120
00:0000D2D2 C7E0
00:0000D2D4 4560
00:0000D2D6 C680
00:0000D2D8 6298
00:0000D2DA C1D0
00:0000D2DC 6728            	  3645: 	dc.w	$6728,$C018,$4280,$C560,RTSL
00:0000D2DE C018
00:0000D2E0 4280
00:0000D2E2 C560
00:0000D2E4 D000
00:0000D2E6 4740            	  3646: 	dc.w	$4740,$C720,$5230,$C460,RTSL
00:0000D2E8 C720
00:0000D2EA 5230
00:0000D2EC C460
00:0000D2EE D000
                            	  3647: play_0E
00:0000D2F0 4760            	  3648: 	dc.w	$4760,$0160,$40C0,$C7E0,$45A0,$C660,$62C0,$C190
00:0000D2F2 0160
00:0000D2F4 40C0
00:0000D2F6 C7E0
00:0000D2F8 45A0
00:0000D2FA C660
00:0000D2FC 62C0
00:0000D2FE C190
00:0000D300 6720            	  3649: 	dc.w	$6720,$C068,$4260,$C5A0,RTSL
00:0000D302 C068
00:0000D304 4260
00:0000D306 C5A0
00:0000D308 D000
00:0000D30A 4780            	  3650: 	dc.w	$4780,$C6C0,$5230,$C490,RTSL
00:0000D30C C6C0
00:0000D30E 5230
00:0000D310 C490
00:0000D312 D000
                            	  3651: play_0F
00:0000D314 4720            	  3652: 	dc.w	$4720,$01C0,$5030,$C600,$45C0,$C620,$62E0,$C148
00:0000D316 01C0
00:0000D318 5030
00:0000D31A C600
00:0000D31C 45C0
00:0000D31E C620
00:0000D320 62E0
00:0000D322 C148
00:0000D324 6718            	  3653: 	dc.w	$6718,$C0B0,$4220,$C5C0,RTSL
00:0000D326 C0B0
00:0000D328 4220
00:0000D32A C5C0
00:0000D32C D000
00:0000D32E 47C0            	  3654: 	dc.w	$47C0,$C660,$5210,$C4D0,RTSL
00:0000D330 C660
00:0000D332 5210
00:0000D334 C4D0
00:0000D336 D000
                            	  3655: play_10
00:0000D338 F70A            	  3656: 	dc.w	$F70A,$F8CE,$FDCD,$6300,$C100,$6700,$C100,$F9CD
00:0000D33A F8CE
00:0000D33C FDCD
00:0000D33E 6300
00:0000D340 C100
00:0000D342 6700
00:0000D344 C100
00:0000D346 F9CD
00:0000D348 D000            	  3657: 	dc.w	RTSL
00:0000D34A FECD            	  3658: 	dc.w	$FECD,$FACD,RTSL
00:0000D34C FACD
00:0000D34E D000
                            	  3659: 
                            	  3660: ; ship outline for player lives
                            	  3661: 
                            	  3662: play_liv
00:0000D350 F70E            	  3663: 	dc.w	$F70E,$F87A,$FD79,$6300,$7500,$6700,$7500,$F979
00:0000D352 F87A
00:0000D354 FD79
00:0000D356 6300
00:0000D358 7500
00:0000D35A 6700
00:0000D35C 7500
00:0000D35E F979
00:0000D360 60C0            	  3664: 	dc.w	$60C0,$0280,$D09F
00:0000D362 0280
00:0000D364 D09F
                            	  3665: 
                            	  3666: ; character set
                            	  3667: 
                            	  3668: char_a						; A
00:0000D366 FA70            	  3669: 	dc.w	$FA70,$F272,$F672,$FE70
00:0000D368 F272
00:0000D36A F672
00:0000D36C FE70
00:0000D36E F906            	  3670: 	dc.w	$F906,$F872,$F602,RTSL
00:0000D370 F872
00:0000D372 F602
00:0000D374 D000
                            	  3671: char_b						; B
00:0000D376 FB70            	  3672: 	dc.w	$FB70,$F073,$F571,$F570
00:0000D378 F073
00:0000D37A F571
00:0000D37C F570
00:0000D37E F575            	  3673: 	dc.w	$F575,$F077,$F003,$F571
00:0000D380 F077
00:0000D382 F003
00:0000D384 F571
00:0000D386 F570            	  3674: 	dc.w	$F570,$F575,$F077,$F803,RTSL
00:0000D388 F575
00:0000D38A F077
00:0000D38C F803
00:0000D38E D000
                            	  3675: char_c						; C
00:0000D390 FB70            	  3676: 	dc.w	$FB70,$F872,$FF06,$F872
00:0000D392 F872
00:0000D394 FF06
00:0000D396 F872
00:0000D398 F002            	  3677: 	dc.w	$F002,RTSL
00:0000D39A D000
                            	  3678: char_d						; D
00:0000D39C FB70            	  3679: 	dc.w	$FB70,$F072,$F672,$F670
00:0000D39E F072
00:0000D3A0 F672
00:0000D3A2 F670
00:0000D3A4 F676            	  3680: 	dc.w	$F676,$F076,$F803,RTSL
00:0000D3A6 F076
00:0000D3A8 F803
00:0000D3AA D000
                            	  3681: char_e						; E
00:0000D3AC FB70            	  3682: 	dc.w	$FB70,$F872,$F705,$F077
00:0000D3AE F872
00:0000D3B0 F705
00:0000D3B2 F077
00:0000D3B4 F700            	  3683: 	dc.w	$F700,$F872,$F002,RTSL
00:0000D3B6 F872
00:0000D3B8 F002
00:0000D3BA D000
                            	  3684: char_f						; F
00:0000D3BC FB70            	  3685: 	dc.w	$FB70,$F872,$F705,$F077
00:0000D3BE F872
00:0000D3C0 F705
00:0000D3C2 F077
00:0000D3C4 F700            	  3686: 	dc.w	$F700,$F803,RTSL
00:0000D3C6 F803
00:0000D3C8 D000
                            	  3687: char_g						; G
00:0000D3CA FB70            	  3688: 	dc.w	$FB70,$F872,$F670,$F606
00:0000D3CC F872
00:0000D3CE F670
00:0000D3D0 F606
00:0000D3D2 F072            	  3689: 	dc.w	$F072,$F670,$F876,$F803
00:0000D3D4 F670
00:0000D3D6 F876
00:0000D3D8 F803
00:0000D3DA D000            	  3690: 	dc.w	RTSL
                            	  3691: char_h						; H
00:0000D3DC FB70            	  3692: 	dc.w	$FB70,$F700,$F872,$F300
00:0000D3DE F700
00:0000D3E0 F872
00:0000D3E2 F300
00:0000D3E4 FF70            	  3693: 	dc.w	$FF70,$F002,RTSL
00:0000D3E6 F002
00:0000D3E8 D000
                            	  3694: char_i						; I
00:0000D3EA F872            	  3695: 	dc.w	$F872,$F006,$FB70,$F002
00:0000D3EC F006
00:0000D3EE FB70
00:0000D3F0 F002
00:0000D3F2 F876            	  3696: 	dc.w	$F876,$FF03,RTSL
00:0000D3F4 FF03
00:0000D3F6 D000
                            	  3697: char_j						; J
00:0000D3F8 F200            	  3698: 	dc.w	$F200,$F672,$F072,$FB70
00:0000D3FA F672
00:0000D3FC F072
00:0000D3FE FB70
00:0000D400 FF01            	  3699: 	dc.w	$FF01,RTSL
00:0000D402 D000
                            	  3700: char_k						; K
00:0000D404 FB70            	  3701: 	dc.w	$FB70,$F003,$F777,$F773
00:0000D406 F003
00:0000D408 F777
00:0000D40A F773
00:0000D40C F003            	  3702: 	dc.w	$F003,RTSL
00:0000D40E D000
                            	  3703: char_l						; L
00:0000D410 FB00            	  3704: 	dc.w	$FB00,$FF70,$F872,$F002,RTSL
00:0000D412 FF70
00:0000D414 F872
00:0000D416 F002
00:0000D418 D000
                            	  3705: char_m						; M
00:0000D41A FB70            	  3706: 	dc.w	$FB70,$F672,$F272,$FF70
00:0000D41C F672
00:0000D41E F272
00:0000D420 FF70
00:0000D422 F002            	  3707: 	dc.w	$F002,RTSL
00:0000D424 D000
                            	  3708: char_n						; N
00:0000D426 FB70            	  3709: 	dc.w	$FB70,$FF72,$FB70,$FF01,RTSL
00:0000D428 FF72
00:0000D42A FB70
00:0000D42C FF01
00:0000D42E D000
                            	  3710: char_o0						; O,0
00:0000D430 FB70            	  3711: 	dc.w	$FB70,$F872,$FF70,$F876
00:0000D432 F872
00:0000D434 FF70
00:0000D436 F876
00:0000D438 F803            	  3712: 	dc.w	$F803,RTSL
00:0000D43A D000
                            	  3713: char_p						; P
00:0000D43C FB70            	  3714: 	dc.w	$FB70,$F872,$F770,$F876
00:0000D43E F872
00:0000D440 F770
00:0000D442 F876
00:0000D444 F703            	  3715: 	dc.w	$F703,$F003,RTSL
00:0000D446 F003
00:0000D448 D000
                            	  3716: char_q						; Q
00:0000D44A FB70            	  3717: 	dc.w	$FB70,$F872,$FE70,$F676
00:0000D44C F872
00:0000D44E FE70
00:0000D450 F676
00:0000D452 F076            	  3718: 	dc.w	$F076,$F202,$F672,$F002
00:0000D454 F202
00:0000D456 F672
00:0000D458 F002
00:0000D45A D000            	  3719: 	dc.w	RTSL
                            	  3720: char_r						; R
00:0000D45C FB70            	  3721: 	dc.w	$FB70,$F872,$F770,$F876
00:0000D45E F872
00:0000D460 F770
00:0000D462 F876
00:0000D464 F001            	  3722: 	dc.w	$F001,$F773,$F002,RTSL
00:0000D466 F773
00:0000D468 F002
00:0000D46A D000
                            	  3723: char_s						; S
00:0000D46C F872            	  3724: 	dc.w	$F872,$F370,$F876,$F370
00:0000D46E F370
00:0000D470 F876
00:0000D472 F370
00:0000D474 F872            	  3725: 	dc.w	$F872,$FF01,RTSL
00:0000D476 FF01
00:0000D478 D000
                            	  3726: char_t						; T
00:0000D47A F002            	  3727: 	dc.w	$F002,$FB70,$F006,$F872
00:0000D47C FB70
00:0000D47E F006
00:0000D480 F872
00:0000D482 FF01            	  3728: 	dc.w	$FF01,RTSL
00:0000D484 D000
                            	  3729: char_u						; U
00:0000D486 FB00            	  3730: 	dc.w	$FB00,$FF70,$F872,$FB70
00:0000D488 FF70
00:0000D48A F872
00:0000D48C FB70
00:0000D48E FF01            	  3731: 	dc.w	$FF01,RTSL
00:0000D490 D000
                            	  3732: char_v						; V
00:0000D492 FB00            	  3733: 	dc.w	$FB00,$FF71,$FB71,$FF01,RTSL
00:0000D494 FF71
00:0000D496 FB71
00:0000D498 FF01
00:0000D49A D000
                            	  3734: char_w						; W
00:0000D49C FB00            	  3735: 	dc.w	$FB00,$FF70,$F272,$F672
00:0000D49E FF70
00:0000D4A0 F272
00:0000D4A2 F672
00:0000D4A4 FB70            	  3736: 	dc.w	$FB70,$FF01,RTSL
00:0000D4A6 FF01
00:0000D4A8 D000
                            	  3737: char_x						; X
00:0000D4AA FB72            	  3738: 	dc.w	$FB72,$F806,$FF72,$F002,RTSL
00:0000D4AC F806
00:0000D4AE FF72
00:0000D4B0 F002
00:0000D4B2 D000
                            	  3739: char_y						; Y
00:0000D4B4 F002            	  3740: 	dc.w	$F002,$FA70,$F276,$F802
00:0000D4B6 FA70
00:0000D4B8 F276
00:0000D4BA F802
00:0000D4BC F676            	  3741: 	dc.w	$F676,$FE02,RTSL
00:0000D4BE FE02
00:0000D4C0 D000
                            	  3742: char_z						; Z
00:0000D4C2 FB00            	  3743: 	dc.w	$FB00,$F872,$FF76,$F872
00:0000D4C4 F872
00:0000D4C6 FF76
00:0000D4C8 F872
00:0000D4CA F002            	  3744: 	dc.w	$F002,RTSL
00:0000D4CC D000
                            	  3745: char_spc						; [SPACE]
00:0000D4CE F803            	  3746: 	dc.w	$F803,RTSL
00:0000D4D0 D000
                            	  3747: char_1						; 1
00:0000D4D2 F002            	  3748: 	dc.w	$F002,$FB70,$FF02,RTSL
00:0000D4D4 FB70
00:0000D4D6 FF02
00:0000D4D8 D000
                            	  3749: char_2						; 2
00:0000D4DA FB00            	  3750: 	dc.w	$FB00,$F872,$F770,$F876
00:0000D4DC F872
00:0000D4DE F770
00:0000D4E0 F876
00:0000D4E2 F770            	  3751: 	dc.w	$F770,$F872,$F002,RTSL
00:0000D4E4 F872
00:0000D4E6 F002
00:0000D4E8 D000
                            	  3752: char_3						; 3
00:0000D4EA F872            	  3753: 	dc.w	$F872,$FB70,$F876,$F700
00:0000D4EC FB70
00:0000D4EE F876
00:0000D4F0 F700
00:0000D4F2 F872            	  3754: 	dc.w	$F872,$F702,RTSL
00:0000D4F4 F702
00:0000D4F6 D000
                            	  3755: char_4						; 4
00:0000D4F8 FB00            	  3756: 	dc.w	$FB00,$F770,$F872,$F300
00:0000D4FA F770
00:0000D4FC F872
00:0000D4FE F300
00:0000D500 FF70            	  3757: 	dc.w	$FF70,$F002,RTSL
00:0000D502 F002
00:0000D504 D000
                            	  3758: char_5						; 6
00:0000D506 F872            	  3759: 	dc.w	$F872,$F370,$F876,$F370
00:0000D508 F370
00:0000D50A F876
00:0000D50C F370
00:0000D50E F872            	  3760: 	dc.w	$F872,$FF01,RTSL
00:0000D510 FF01
00:0000D512 D000
                            	  3761: char_6						; 6
00:0000D514 F300            	  3762: 	dc.w	$F300,$F872,$F770,$F876
00:0000D516 F872
00:0000D518 F770
00:0000D51A F876
00:0000D51C FB70            	  3763: 	dc.w	$FB70,$FF03,RTSL
00:0000D51E FF03
00:0000D520 D000
                            	  3764: char_7						; 7
00:0000D522 FB00            	  3765: 	dc.w	$FB00,$F872,$FF70,$F002,RTSL
00:0000D524 F872
00:0000D526 FF70
00:0000D528 F002
00:0000D52A D000
                            	  3766: char_8						; 8
00:0000D52C F872            	  3767: 	dc.w	$F872,$FB70,$F876,$FF70
00:0000D52E FB70
00:0000D530 F876
00:0000D532 FF70
00:0000D534 F300            	  3768: 	dc.w	$F300,$F872,$F702,RTSL
00:0000D536 F872
00:0000D538 F702
00:0000D53A D000
                            	  3769: char_9						; 9
00:0000D53C F802            	  3770: 	dc.w	$F802,$FB70,$F876,$F770
00:0000D53E FB70
00:0000D540 F876
00:0000D542 F770
00:0000D544 F872            	  3771: 	dc.w	$F872,$F702,RTSL
00:0000D546 F702
00:0000D548 D000
                            	  3772: 
                            	  3773: ; indirect table for character set
                            	  3774: 
                            	  3775: char_set
00:0000D54A CAD0            	  3776: 	dc.w	JSRL+(char_spc-vector)>>1	; [SPACE]
00:0000D54C CA81            	  3777: 	dc.w	JSRL+(char_o0-vector)>>1	; 0 also O
00:0000D54E CAD2            	  3778: 	dc.w	JSRL+(char_1-vector)>>1		; 1
00:0000D550 CAD6            	  3779: 	dc.w	JSRL+(char_2-vector)>>1		; 2
00:0000D552 CADE            	  3780: 	dc.w	JSRL+(char_3-vector)>>1		; 3
00:0000D554 CAE5            	  3781: 	dc.w	JSRL+(char_4-vector)>>1		; 4
00:0000D556 CAEC            	  3782: 	dc.w	JSRL+(char_5-vector)>>1		; 5
00:0000D558 CAF3            	  3783: 	dc.w	JSRL+(char_6-vector)>>1		; 6
00:0000D55A CAFA            	  3784: 	dc.w	JSRL+(char_7-vector)>>1		; 7
00:0000D55C CAFF            	  3785: 	dc.w	JSRL+(char_8-vector)>>1		; 8
00:0000D55E CB07            	  3786: 	dc.w	JSRL+(char_9-vector)>>1		; 9
00:0000D560 CA1C            	  3787: 	dc.w	JSRL+(char_a-vector)>>1		; A
00:0000D562 CA24            	  3788: 	dc.w	JSRL+(char_b-vector)>>1		; B
00:0000D564 CA31            	  3789: 	dc.w	JSRL+(char_c-vector)>>1		; C
00:0000D566 CA37            	  3790: 	dc.w	JSRL+(char_d-vector)>>1		; D
00:0000D568 CA3F            	  3791: 	dc.w	JSRL+(char_e-vector)>>1		; E
00:0000D56A CA47            	  3792: 	dc.w	JSRL+(char_f-vector)>>1		; F
00:0000D56C CA4E            	  3793: 	dc.w	JSRL+(char_g-vector)>>1		; G
00:0000D56E CA57            	  3794: 	dc.w	JSRL+(char_h-vector)>>1		; H
00:0000D570 CA5E            	  3795: 	dc.w	JSRL+(char_i-vector)>>1		; I
00:0000D572 CA65            	  3796: 	dc.w	JSRL+(char_j-vector)>>1		; J
00:0000D574 CA6B            	  3797: 	dc.w	JSRL+(char_k-vector)>>1		; K
00:0000D576 CA71            	  3798: 	dc.w	JSRL+(char_l-vector)>>1		; L
00:0000D578 CA76            	  3799: 	dc.w	JSRL+(char_m-vector)>>1		; M
00:0000D57A CA7C            	  3800: 	dc.w	JSRL+(char_n-vector)>>1		; N
00:0000D57C CA81            	  3801: 	dc.w	JSRL+(char_o0-vector)>>1	; O also 0
00:0000D57E CA87            	  3802: 	dc.w	JSRL+(char_p-vector)>>1		; P
00:0000D580 CA8E            	  3803: 	dc.w	JSRL+(char_q-vector)>>1		; Q
00:0000D582 CA97            	  3804: 	dc.w	JSRL+(char_r-vector)>>1		; R
00:0000D584 CA9F            	  3805: 	dc.w	JSRL+(char_s-vector)>>1		; S
00:0000D586 CAA6            	  3806: 	dc.w	JSRL+(char_t-vector)>>1		; T
00:0000D588 CAAC            	  3807: 	dc.w	JSRL+(char_u-vector)>>1		; U
00:0000D58A CAB2            	  3808: 	dc.w	JSRL+(char_v-vector)>>1		; V
00:0000D58C CAB7            	  3809: 	dc.w	JSRL+(char_w-vector)>>1		; W
00:0000D58E CABE            	  3810: 	dc.w	JSRL+(char_x-vector)>>1		; X
00:0000D590 CAC3            	  3811: 	dc.w	JSRL+(char_y-vector)>>1		; Y
00:0000D592 CACA            	  3812: 	dc.w	JSRL+(char_z-vector)>>1		; Z
                            	  3813: 
                            	  3814: ; indirect shot table
                            	  3815: 
                            	  3816: shot_jsr
00:0000D594 CB34            	  3817: 	dc.w	JSRL+(shot_vec-vector)>>1	; shot
                            	  3818: 
                            	  3819: ; shot vector object, a small cross of intensity $F
                            	  3820: 
                            	  3821: shot_vec
00:0000D596 7420            	  3822: 	dc.w	$7420,$0000
00:0000D598 0000
00:0000D59A 7040            	  3823: 	dc.w	$7040,$F000
00:0000D59C F000
00:0000D59E 7420            	  3824: 	dc.w	$7420,$0420
00:0000D5A0 0420
00:0000D5A2 7000            	  3825: 	dc.w	$7000,$F040
00:0000D5A4 F040
00:0000D5A6 D000            	  3826: 	dc.w	RTSL
                            	  3827: 
                            	  3828: 
                            	  3829: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3830: ;
                            	  3831: ; canned messages
                            	  3832: 
                            	  3833: ; x,y co-ordinates for the message origins
                            	  3834: 
                            	  3835: mess_origin
00:0000D5A8 0064            	  3836: 	dc.w	$0064,$00B6				; message 0 x,y
00:0000D5AA 00B6
00:0000D5AC 0064            	  3837: 	dc.w	$0064,$00B6				; message 1 x,y
00:0000D5AE 00B6
00:0000D5B0 000C            	  3838: 	dc.w	$000C,$00AA				; message 2 x,y
00:0000D5B2 00AA
00:0000D5B4 000C            	  3839: 	dc.w	$000C,$00A2				; message 3 x,y
00:0000D5B6 00A2
00:0000D5B8 000C            	  3840: 	dc.w	$000C,$009A				; message 4 x,y
00:0000D5BA 009A
00:0000D5BC 000C            	  3841: 	dc.w	$000C,$0092				; message 5 x,y
00:0000D5BE 0092
00:0000D5C0 0064            	  3842: 	dc.w	$0064,$00C6				; message 6 x,y
00:0000D5C2 00C6
00:0000D5C4 0064            	  3843: 	dc.w	$0064,$009D				; message 7 x,y
00:0000D5C6 009D
                            	  3844: 
                            	  3845: ; message tables
                            	  3846: 
                            	  3847: mess_table
00:0000D5C8 0008            	  3848: 	dc.w	e_messages-mess_table		; english
00:0000D5CA 00C2            	  3849: 	dc.w	d_messages-mess_table		; german
00:0000D5CC 019E            	  3850: 	dc.w	f_messages-mess_table		; french
00:0000D5CE 026C            	  3851: 	dc.w	s_messages-mess_table		; spanish
                            	  3852: 
                            	  3853: ; message offset table
                            	  3854: 
                            	  3855: e_messages
00:0000D5D0 0010            	  3856: 	dc.w	e_mess_0-e_messages		; message 0
00:0000D5D2 001C            	  3857: 	dc.w	e_mess_1-e_messages		; message 1
00:0000D5D4 0024            	  3858: 	dc.w	e_mess_2-e_messages		; message 2
00:0000D5D6 0046            	  3859: 	dc.w	e_mess_3-e_messages		; message 3
00:0000D5D8 0061            	  3860: 	dc.w	e_mess_4-e_messages		; message 4
00:0000D5DA 007E            	  3861: 	dc.w	e_mess_5-e_messages		; message 5
00:0000D5DC 00A5            	  3862: 	dc.w	e_mess_6-e_messages		; message 6
00:0000D5DE 00B0            	  3863: 	dc.w	e_mess_7-e_messages		; message 7
                            	  3864: 
                            	  3865: e_mess_0
00:0000D5E0 484947482053434F	  3866: 	dc.b	'HIGH SCORES',$00
00:0000D5E8 524553
00:0000D5EB 00
                            	  3867: e_mess_1
00:0000D5EC 504C4159455220  	  3868: 	dc.b	'PLAYER ',$00
00:0000D5F3 00
                            	  3869: e_mess_2
00:0000D5F4 594F55522053434F	  3870: 	dc.b	'YOUR SCORE IS ONE OF THE TEN BEST',$00
00:0000D5FC 5245204953204F4E
00:0000D604 45204F4620544845
00:0000D60C 2054454E20424553
00:0000D614 54
00:0000D615 00
                            	  3871: e_mess_3
00:0000D616 504C454153452045	  3872: 	dc.b	'PLEASE ENTER YOUR INITIALS',$00
00:0000D61E 4E54455220594F55
00:0000D626 5220494E49544941
00:0000D62E 4C53
00:0000D630 00
                            	  3873: e_mess_4
00:0000D631 5055534820524F54	  3874: 	dc.b	'PUSH ROTATE TO SELECT LETTER',$00
00:0000D639 41544520544F2053
00:0000D641 454C454354204C45
00:0000D649 54544552
00:0000D64D 00
                            	  3875: e_mess_5
00:0000D64E 5055534820485950	  3876: 	dc.b	'PUSH HYPERSPACE WHEN LETTER IS CORRECT',$00
00:0000D656 4552535041434520
00:0000D65E 5748454E204C4554
00:0000D666 5445522049532043
00:0000D66E 4F5252454354
00:0000D674 00
                            	  3877: e_mess_6
00:0000D675 5055534820535441	  3878: 	dc.b	'PUSH START',$00
00:0000D67D 5254
00:0000D67F 00
                            	  3879: e_mess_7
00:0000D680 47414D45204F5645	  3880: 	dc.b	'GAME OVER',$00
00:0000D688 52
00:0000D689 00
                            	  3881: 
                            	  3882: 	ds.w	0					; ensure even
                            	  3883: 
                            	  3884: ; german message offset table
                            	  3885: 
                            	  3886: d_messages
00:0000D68A 0010            	  3887: 	dc.w	d_mess_0-d_messages		; message 0
00:0000D68C 0020            	  3888: 	dc.w	d_mess_1-d_messages		; message 1
00:0000D68E 0029            	  3889: 	dc.w	d_mess_2-d_messages		; message 2
00:0000D690 0050            	  3890: 	dc.w	d_mess_3-d_messages		; message 3
00:0000D692 0073            	  3891: 	dc.w	d_mess_4-d_messages		; message 4
00:0000D694 0096            	  3892: 	dc.w	d_mess_5-d_messages		; message 5
00:0000D696 00BC            	  3893: 	dc.w	d_mess_6-d_messages		; message 6
00:0000D698 00D2            	  3894: 	dc.w	d_mess_7-d_messages		; message 7
                            	  3895: 
                            	  3896: d_mess_0
00:0000D69A 484F454348535445	  3897: 	dc.b	'HOECHSTERGEBNIS',$00
00:0000D6A2 524745424E4953
00:0000D6A9 00
                            	  3898: d_mess_1
00:0000D6AA 535049454C455220	  3899: 	dc.b	'SPIELER ',$00
00:0000D6B2 00
                            	  3900: d_mess_2
00:0000D6B3 4948522045524745	  3901: 	dc.b	'IHR ERGEBNIS IST EINES DER ZEHN BESTEN',$00
00:0000D6BB 424E495320495354
00:0000D6C3 2045494E45532044
00:0000D6CB 4552205A45484E20
00:0000D6D3 42455354454E
00:0000D6D9 00
                            	  3902: d_mess_3
00:0000D6DA 4249545445204745	  3903: 	dc.b	'BITTE GEBEN SIE IHRE INITIALEN EIN',$00
00:0000D6E2 42454E2053494520
00:0000D6EA 4948524520494E49
00:0000D6F2 5449414C454E2045
00:0000D6FA 494E
00:0000D6FC 00
                            	  3904: d_mess_4
00:0000D6FD 5A55522042554348	  3905: 	dc.b	'ZUR BUCHSTABENWAHL ROTATE DRUECKEN',$00
00:0000D705 53544142454E5741
00:0000D70D 484C20524F544154
00:0000D715 452044525545434B
00:0000D71D 454E
00:0000D71F 00
                            	  3906: d_mess_5
00:0000D720 57454E4E20425543	  3907: 	dc.b	'WENN BUCHSTABE OK HYPERSPACE DRUECKEN',$00
00:0000D728 485354414245204F
00:0000D730 4B20485950455253
00:0000D738 5041434520445255
00:0000D740 45434B454E
00:0000D745 00
                            	  3908: d_mess_6
00:0000D746 53544152544B4E4F	  3909: 	dc.b	'STARTKNOEPFE DRUECKEN',$00
00:0000D74E 4550464520445255
00:0000D756 45434B454E
00:0000D75B 00
                            	  3910: d_mess_7
00:0000D75C 535049454C454E44	  3911: 	dc.b	'SPIELENDE',$00
00:0000D764 45
00:0000D765 00
                            	  3912: 
                            	  3913: 	ds.w	0					; ensure even
                            	  3914: 
                            	  3915: ; french message offset table
                            	  3916: 
                            	  3917: f_messages
00:0000D766 0010            	  3918: 	dc.w	f_mess_0-f_messages		; message 0
00:0000D768 001F            	  3919: 	dc.w	f_mess_1-f_messages		; message 1
00:0000D76A 0026            	  3920: 	dc.w	f_mess_2-f_messages		; message 2
00:0000D76C 004A            	  3921: 	dc.w	f_mess_3-f_messages		; message 3
00:0000D76E 0063            	  3922: 	dc.w	f_mess_4-f_messages		; message 4
00:0000D770 0085            	  3923: 	dc.w	f_mess_5-f_messages		; message 5
00:0000D772 00AE            	  3924: 	dc.w	f_mess_6-f_messages		; message 6
00:0000D774 00C0            	  3925: 	dc.w	f_mess_7-f_messages		; message 7
                            	  3926: 
                            	  3927: f_mess_0
00:0000D776 4D45494C4C455552	  3928: 	dc.b	'MEILLEUR SCORE',$00
00:0000D77E 2053434F5245
00:0000D784 00
                            	  3929: f_mess_1
00:0000D785 4A4F55455220    	  3930: 	dc.b	'JOUER ',$00
00:0000D78B 00
                            	  3931: f_mess_2
00:0000D78C 564F545245205343	  3932: 	dc.b	'VOTRE SCORE EST UN DES 10 MEILLEURS',$00
00:0000D794 4F52452045535420
00:0000D79C 554E204445532031
00:0000D7A4 30204D45494C4C45
00:0000D7AC 555253
00:0000D7AF 00
                            	  3933: f_mess_3
00:0000D7B0 53565020454E5452	  3934: 	dc.b	'SVP ENTREZ VOS INITIALES',$00
00:0000D7B8 455A20564F532049
00:0000D7C0 4E495449414C4553
00:0000D7C8 00
                            	  3935: f_mess_4
00:0000D7C9 504F555353455A20	  3936: 	dc.b	'POUSSEZ ROTATE POUR VOS INITIALES',$00
00:0000D7D1 524F544154452050
00:0000D7D9 4F555220564F5320
00:0000D7E1 494E495449414C45
00:0000D7E9 53
00:0000D7EA 00
                            	  3937: f_mess_5
00:0000D7EB 504F555353455A20	  3938: 	dc.b	'POUSSEZ HYPERSPACE QUAND LETTRE CORRECTE',$00
00:0000D7F3 4859504552535041
00:0000D7FB 4345205155414E44
00:0000D803 204C455454524520
00:0000D80B 434F525245435445
00:0000D813 00
                            	  3939: f_mess_6
00:0000D814 4150505559455220	  3940: 	dc.b	'APPUYER SUR START',$00
00:0000D81C 5355522053544152
00:0000D824 54
00:0000D825 00
                            	  3941: f_mess_7
00:0000D826 46494E2044452050	  3942: 	dc.b	'FIN DE PARTIE',$00
00:0000D82E 4152544945
00:0000D833 00
                            	  3943: 
                            	  3944: 	ds.w	0					; ensure even
                            	  3945: 
                            	  3946: ; spanish message offset table
                            	  3947: 
                            	  3948: s_messages
00:0000D834 0010            	  3949: 	dc.w	s_mess_0-s_messages		; message 0
00:0000D836 0018            	  3950: 	dc.w	s_mess_1-s_messages		; message 1
00:0000D838 0021            	  3951: 	dc.w	s_mess_2-s_messages		; message 2
00:0000D83A 0048            	  3952: 	dc.w	s_mess_3-s_messages		; message 3
00:0000D83C 0066            	  3953: 	dc.w	s_mess_4-s_messages		; message 4
00:0000D83E 008E            	  3954: 	dc.w	s_mess_5-s_messages		; message 5
00:0000D840 00A0            	  3955: 	dc.w	s_mess_6-s_messages		; message 6
00:0000D842 00AD            	  3956: 	dc.w	s_mess_7-s_messages		; message 7
                            	  3957: 
                            	  3958: s_mess_0
00:0000D844 5245434F524453  	  3959: 	dc.b	'RECORDS',$00
00:0000D84B 00
                            	  3960: s_mess_1
00:0000D84C 4A554741444F5220	  3961: 	dc.b	'JUGADOR ',$00
00:0000D854 00
                            	  3962: s_mess_2
00:0000D855 53552050554E5441	  3963: 	dc.b	'SU PUNTAJE ESTA ENTRE LOS DIEZ MEJORES',$00
00:0000D85D 4A45204553544120
00:0000D865 454E545245204C4F
00:0000D86D 53204449455A204D
00:0000D875 454A4F524553
00:0000D87B 00
                            	  3964: s_mess_3
00:0000D87C 504F52204641564F	  3965: 	dc.b	'POR FAVOR ENTRE SUS INICIALES',$00
00:0000D884 5220454E54524520
00:0000D88C 53555320494E4943
00:0000D894 49414C4553
00:0000D899 00
                            	  3966: s_mess_4
00:0000D89A 4F5052494D412052	  3967: 	dc.b	'OPRIMA ROTATE PARA SELECCIONAR LA LETRA',$00
00:0000D8A2 4F54415445205041
00:0000D8AA 52412053454C4543
00:0000D8B2 43494F4E4152204C
00:0000D8BA 41204C45545241
00:0000D8C1 00
                            	  3968: s_mess_5
00:0000D8C2 4F5052494D412048	  3969: 	dc.b	'OPRIMA HYPERSPACE',$00
00:0000D8CA 5950455253504143
00:0000D8D2 45
00:0000D8D3 00
                            	  3970: s_mess_6
00:0000D8D4 50554C5341522053	  3971: 	dc.b	'PULSAR START',$00
00:0000D8DC 54415254
00:0000D8E0 00
                            	  3972: s_mess_7
00:0000D8E1 4A5545474F205445	  3973: 	dc.b	'JUEGO TERMINADO',$00
00:0000D8E9 524D494E41444F
00:0000D8F0 00
                            	  3974: 
                            	  3975: 	ds.w	0					; ensure even
                            	  3976: 
                            	  3977: 
                            	  3978: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3979: ;
                            	  3980: ; include files
                            	  3981: 
                            	  3982: 	INCLUDE	"games/asteroids/sounds.x68"

Source: "games\asteroids\sounds.x68"
                            	     1: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	     2: ;														;
                            	     3: ;	Sound routines V1.00. This is an include file for asteroids 1_0.x68		;
                            	     4: ;														;
                            	     5: ;	load the sounds, play an indexed sample. Uses the DirextX sound play and	;
                            	     6: ;	requires EASy68K 3.7.10 beta or later.							;
                            	     7: ;														;
                            	     8: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	     9: 
                            	    10: sfire_snd	EQU  0
                            	    11: pfire_snd	EQU  1
                            	    12: thrst_snd	EQU  2
                            	    13: smsau_snd	EQU  3
                            	    14: lgsau_snd	EQU  4
                            	    15: sexpl_snd	EQU  5
                            	    16: mexpl_snd	EQU  sexpl_snd+1
                            	    17: lexpl_snd	EQU  sexpl_snd+2
                            	    18: beat1_snd	EQU  8				; beat_2 must be beat_1 XOR 1
                            	    19: beat2_snd	EQU  9				; see above
                            	    20: extra_snd	EQU 10
                            	    21: 
                            	    22: 
                            	    23: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    24: ;
                            	    25: ; initialise the sounds routine
                            	    26: 
                            	    27: sound_init
00:0000D8F2 422B0014        	    28: 	MOVE.b	#0,s_key(a3)		; clear the last [S] key status
00:0000D8F6 177C00FF0015    	    29: 	MOVE.b	#-1,play_sound(a3)	; set the sound flag
                            	    30: 
00:0000D8FC 43FA0098        	    31: 	LEA		beat1_sound(pc),a1	; point to the background beat sound file name
00:0000D900 7208            	    32: 	MOVEQ		#beat1_snd,d1		; index 10
00:0000D902 614E            	    33: 	BSR.s		load_sound			; load the sound into directx memory
                            	    34: 
00:0000D904 43FA00A2        	    35: 	LEA		beat2_sound(pc),a1	; point to the background beat sound file name
00:0000D908 7209            	    36: 	MOVEQ		#beat2_snd,d1		; index 9
00:0000D90A 6146            	    37: 	BSR.s		load_sound			; load the sound into directx memory
                            	    38: 
00:0000D90C 43FA00AC        	    39: 	LEA		lexpl_sound(pc),a1	; point to the large explosion sound file name
00:0000D910 7207            	    40: 	MOVEQ		#lexpl_snd,d1		; index 8
00:0000D912 613E            	    41: 	BSR.s		load_sound			; load the sound into directx memory
                            	    42: 
00:0000D914 43FA00B9        	    43: 	LEA		mexpl_sound(pc),a1	; point to the medium explosion sound file name
00:0000D918 7206            	    44: 	MOVEQ		#mexpl_snd,d1		; index 7
00:0000D91A 6136            	    45: 	BSR.s		load_sound			; load the sound into directx memory
                            	    46: 
00:0000D91C 43FA00C6        	    47: 	LEA		sexpl_sound(pc),a1	; point to the small explosion sound file name
00:0000D920 7205            	    48: 	MOVEQ		#sexpl_snd,d1		; index 6
00:0000D922 612E            	    49: 	BSR.s		load_sound			; load the sound into directx memory
                            	    50: 
00:0000D924 43FA00D3        	    51: 	LEA		extra_sound(pc),a1	; point to the extra life sound file name
00:0000D928 720A            	    52: 	MOVEQ		#extra_snd,d1		; index 5
00:0000D92A 6126            	    53: 	BSR.s		load_sound			; load the sound into directx memory
                            	    54: 
00:0000D92C 43FA00E1        	    55: 	LEA		lgsau_sound(pc),a1	; point to the large saucer sound file name
00:0000D930 7204            	    56: 	MOVEQ		#lgsau_snd,d1		; index 4
00:0000D932 6124            	    57: 	BSR.s		load_old_sound		; load the sound into sound memory
                            	    58: 
00:0000D934 43FA00EE        	    59: 	LEA		smsau_sound(pc),a1	; point to the small saucer sound file name
00:0000D938 7203            	    60: 	MOVEQ		#smsau_snd,d1		; index 3
00:0000D93A 611C            	    61: 	BSR.s		load_old_sound		; load the sound into directx memory
                            	    62: 
00:0000D93C 43FA00FB        	    63: 	LEA		thrst_sound(pc),a1	; point to the ship thrust sound file name
00:0000D940 7202            	    64: 	MOVEQ		#thrst_snd,d1		; index 2
00:0000D942 610E            	    65: 	BSR.s		load_sound			; load the sound into directx memory
                            	    66: 
00:0000D944 43FA0106        	    67: 	LEA		pfire_sound(pc),a1	; point to the player fire sound file name
00:0000D948 7201            	    68: 	MOVEQ		#pfire_snd,d1		; index 1
00:0000D94A 6106            	    69: 	BSR.s		load_sound			; load the sound into directx memory
                            	    70: 
00:0000D94C 43FA0110        	    71: 	LEA		sfire_sound(pc),a1	; point to the saucer fire sound file name
00:0000D950 7200            	    72: 	MOVEQ		#sfire_snd,d1		; index 0
                            	    73: 
                            	    74: 
                            	    75: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    76: ;
                            	    77: ; load the sound into directx memory
                            	    78: 
                            	    79: load_sound
00:0000D952 704A            	    80: 	MOVEQ		#74,d0			; load the sound into directx memory
00:0000D954 4E4F            	    81: 	TRAP		#15
                            	    82: 
00:0000D956 4E75            	    83: 	RTS
                            	    84: 
                            	    85: 
                            	    86: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    87: ;
                            	    88: ; load the sound into sound memory
                            	    89: 
                            	    90: load_old_sound
00:0000D958 7047            	    91: 	MOVEQ		#71,d0			; load the sound into sound memory
00:0000D95A 4E4F            	    92: 	TRAP		#15
                            	    93: 
00:0000D95C 4E75            	    94: 	RTS
                            	    95: 
                            	    96: 
                            	    97: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    98: ;
                            	    99: ; play a sound sample
                            	   100: 
                            	   101: play_sample
00:0000D95E 4A2B001A        	   102: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000D962 6718            	   103: 	BEQ.s		exit_play_sample		; if no players left just exit
                            	   104: 
00:0000D964 4A2B0015        	   105: 	TST.b		play_sound(a3)		; test the sound flag
00:0000D968 6712            	   106: 	BEQ.s		exit_play_sample		; if the sound is off just exit
                            	   107: 
00:0000D96A 7048            	   108: 	MOVEQ		#72,d0			; play a sound from sound memory
00:0000D96C 0C410003        	   109: 	CMPI.w	#smsau_snd,d1		; is it the small saucer sound
00:0000D970 6708            	   110: 	BEQ.s		old_sound_play		; if so go play it with the old player
                            	   111: 
00:0000D972 0C410004        	   112: 	CMPI.w	#lgsau_snd,d1		; is it the large saucer sound
00:0000D976 6702            	   113: 	BEQ.s		old_sound_play		; if so go play it with the old player
                            	   114: 
00:0000D978 704B            	   115: 	MOVEQ		#75,d0			; play a sound from directx memory
                            	   116: old_sound_play
00:0000D97A 4E4F            	   117: 	TRAP		#15
                            	   118: 
                            	   119: exit_play_sample
00:0000D97C 4E75            	   120: 	RTS
                            	   121: 
                            	   122: 
                            	   123: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   124: ;
                            	   125: ; test the sound key
                            	   126: 
                            	   127: sound_key
00:0000D97E 7253            	   128: 	MOVEQ		#$53,d1			; [][][][S] key
00:0000D980 7013            	   129: 	MOVEQ		#19,d0			; check for keypress
00:0000D982 4E4F            	   130: 	TRAP		#15
                            	   131: 
00:0000D984 102B0014        	   132: 	MOVE.b	s_key(a3),d0		; get the last key(s) state
00:0000D988 B300            	   133: 	EOR.b		d1,d0				; compare the result with the last key(s) state,
                            	   134: 							; each byte is now $FF if a key has changed or
                            	   135: 							; $00 if a key has not changed
00:0000D98A C001            	   136: 	AND.b		d1,d0				; make each byte $FF if key just pressed or
                            	   137: 							; $00 if key not just pressed
00:0000D98C B12B0015        	   138: 	EOR.b		d0,play_sound(a3)		; if key just pressed toggle the sound flag
00:0000D990 17410014        	   139: 	MOVE.b	d1,s_key(a3)		; save the last [S] key status
00:0000D994 4E75            	   140: 	RTS
                            	   141: 
                            	   142: 
                            	   143: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   144: ;
                            	   145: ; sound file names
                            	   146: 
                            	   147: beat1_sound
00:0000D996 73616D706C65735C	   148: 	dc.b	'samples\beat1.wav',$00		; background beat sound
00:0000D99E 62656174312E7761
00:0000D9A6 76
00:0000D9A7 00
                            	   149: 
                            	   150: beat2_sound
00:0000D9A8 73616D706C65735C	   151: 	dc.b	'samples\beat2.wav',$00		; background beat sound
00:0000D9B0 62656174322E7761
00:0000D9B8 76
00:0000D9B9 00
                            	   152: 
                            	   153: lexpl_sound
00:0000D9BA 73616D706C65735C	   154: 	dc.b	'samples\lexplode.wav',$00	; large explosion sound
00:0000D9C2 6C6578706C6F6465
00:0000D9CA 2E776176
00:0000D9CE 00
                            	   155: 
                            	   156: mexpl_sound
00:0000D9CF 73616D706C65735C	   157: 	dc.b	'samples\mexplode.wav',$00	; medium explosion sound
00:0000D9D7 6D6578706C6F6465
00:0000D9DF 2E776176
00:0000D9E3 00
                            	   158: 
                            	   159: sexpl_sound
00:0000D9E4 73616D706C65735C	   160: 	dc.b	'samples\sexplode.wav',$00	; small explosion sound
00:0000D9EC 736578706C6F6465
00:0000D9F4 2E776176
00:0000D9F8 00
                            	   161: 
                            	   162: extra_sound
00:0000D9F9 73616D706C65735C	   163: 	dc.b	'samples\extraship.wav',$00	; extra life sound
00:0000DA01 6578747261736869
00:0000DA09 702E776176
00:0000DA0E 00
                            	   164: 
                            	   165: lgsau_sound
00:0000DA0F 73616D706C65735C	   166: 	dc.b	'samples\lgsaucer.wav',$00	; large saucer sound
00:0000DA17 6C67736175636572
00:0000DA1F 2E776176
00:0000DA23 00
                            	   167: 
                            	   168: smsau_sound
00:0000DA24 73616D706C65735C	   169: 	dc.b	'samples\smsaucer.wav',$00	; small saucer sound
00:0000DA2C 736D736175636572
00:0000DA34 2E776176
00:0000DA38 00
                            	   170: 
                            	   171: thrst_sound
00:0000DA39 73616D706C65735C	   172: 	dc.b	'samples\thrust.wav',$00	; ship thrust sound
00:0000DA41 7468727573742E77
00:0000DA49 6176
00:0000DA4B 00
                            	   173: 
                            	   174: pfire_sound
00:0000DA4C 73616D706C65735C	   175: 	dc.b	'samples\pfire.wav',$00		; player fire sound
00:0000DA54 70666972652E7761
00:0000DA5C 76
00:0000DA5D 00
                            	   176: 
                            	   177: sfire_sound
00:0000DA5E 73616D706C65735C	   178: 	dc.b	'samples\sfire.wav',$00		; saucer fire sound
00:0000DA66 73666972652E7761
00:0000DA6E 76
00:0000DA6F 00
                            	   179: 
                            	   180: 	ds.w	0					; ensure even
                            	   181: 
                            	   182: 
                            	   183: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   184: 
                            	   185: 

Source: "games\asteroids\asteroids 1_0.x68"
                            	  3983: 							; sound routines
                            	  3984: 
                            	  3985: 
                            	  3986: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3987: ;
                            	  3988: ; high score table filename
                            	  3989: 
                            	  3990: filename
00:0000DA70 61737465726F6964	  3991: 	dc.b		'asteroids.hi',0		; highscore filename
00:0000DA78 732E6869
00:0000DA7C 00
                            	  3992: 	ds.w		0				; ensure even
                            	  3993: 
                            	  3994: 
                            	  3995: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3996: ;
                            	  3997: ; variables
                            	  3998: 
                            	  3999: variables
                            	  4000: 
                            	  4001: 	OFFSET	0				; going to use relative addressing
                            	  4002: 
                            	  4003: vector_s
                            	  4004: ;##	ds.w	1				; vector scale
02:00000000 0000            	  4005: glob_scale	ds.w	1				; global scale
                            	  4006: 
                            	  4007: 
02:00000002 0000            	  4008: local_x	ds.w	1				; local screen x co-ordinate offset
02:00000004 0000            	  4009: local_y	ds.w	1				; local screen y co-ordinate offset
                            	  4010: 
02:00000006 0000            	  4011: scr_x		ds.w	1				; screen x size
02:00000008 0000            	  4012: scr_y		ds.w	1				; screen y size
                            	  4013: 
02:0000000A 00000000        	  4014: PRNlword	ds.l	1				; PRNG seed long word
                            	  4015: 
02:0000000E 00000000        	  4016: switch_addr	ds.l	1				; hardware switch address
                            	  4017: 
02:00000012 0000            	  4018: hiscore_y	ds.w	1				; high score y co-ordinate
                            	  4019: 
                            	  4020: 
02:00000014 00              	  4021: s_key		ds.b	1				; last [s] key status
02:00000015 00              	  4022: play_sound	ds.b	1				; sound flag
                            	  4023: 
02:00000016 00              	  4024: suppress_0	ds.b	1				; leading zero suppress flag
                            	  4025: 							; 0 = don't suppress
                            	  4026: 
02:00000017 00              	  4027: high_idx	ds.b	1				; high score index, single byte, 1 to 10 in BCD
                            	  4028: 
02:00000018 00              	  4029: player_idx	ds.b	1				; player index
                            	  4030: 							; 0 = player 1
                            	  4031: 							; 1 = player 2
                            	  4032: 
02:00000019 00              	  4033: past_play	ds.b	1				; number of players that were in the game
                            	  4034: 
02:0000001A 00              	  4035: num_players	ds.b	1				; number of players in the game
                            	  4036: 							; $00 - game over
                            	  4037: 							; $01 - 1 player game
                            	  4038: 							; $02 - 2 player game
                            	  4039: 							; $FF - game over, high score not checked
                            	  4040: 
02:0000001B 00              	  4041: ss_count	ds.b	1				; starting ship count
                            	  4042: 
02:0000001C 00              	  4043: px_time	ds.b	1				; "PLAYER x" timer. while this is non zero
                            	  4044: 							; "PLAYER x" will be displayed. this is used at
                            	  4045: 							; the beginning of any game and at the beginning
                            	  4046: 							; of each turn in a two player game
                            	  4047: 
02:0000001D 00              	  4048: sixteen_ms	ds.b	1				; 16ms counter, incremented every 16ms by the
                            	  4049: 							; timer interrupt and cleared by the main
                            	  4050: 							; program loop
                            	  4051: 
02:0000001E 00              	  4052: p_orient	ds.b	1				; player orientation, this is shared by both
                            	  4053: 							; players as it is in the arcade machine
                            	  4054: 							;
                            	  4055: 							; $00 = right
                            	  4056: 							; $40 = up
                            	  4057: 							; $80 = left
                            	  4058: 							; $C0 = down
                            	  4059: 							;
                            	  4060: 							; this is $00 = right then anticlockwise each
                            	  4061: 							; positive step being 1.40625 degrees so that
                            	  4062: 							; by the time you get back to $00 one full
                            	  4063: 							; rotation has been done
                            	  4064: 
02:0000001F 00              	  4065: s_orient	ds.b	1				; shot direction, see above
                            	  4066: 
02:00000020 00              	  4067: hi_char	ds.b	1				; high score input character index
                            	  4068: 
02:00000021 00              	  4069: last_fire	ds.b	1				; fire key last state register
02:00000022 00              	  4070: last_hype	ds.b	1				; hyperspace key last state register
                            	  4071: 
02:00000023 00              	  4072: thump_snd	ds.b	1				; thump sound value
02:00000024 00              	  4073: thump_time	ds.b	1				; thump sound change timer
02:00000025 00              	  4074: time_count	ds.b	1				; game counter byte
                            	  4075: 
02:00000026 00              	  4076: hyper		ds.b	1				; hyperspace flag
                            	  4077: 							; $00 = no jump
                            	  4078: 							; $01 = jump successful
                            	  4079: 							; $80 = jump unsuccessful
                            	  4080: 							; $xx = 
                            	  4081: 
                            	  4082: 		ds.w	0
                            	  4083: 
02:00000027 0000            	  4084: hiscores	ds.w	10				; high score table, each score is a BCD word
02:00000029 *
02:0000003B 00              	  4085: hinames	ds.b	3*10				; high score initials table
02:0000003C *
                            	  4086: 
02:00000059 0000            	  4087: game_count	ds.w	1				; game counter word
                            	  4088: 
02:0000005B 0000            	  4089: expl_x_pos	ds.w	6				; player ship explosion pieces x positions
02:0000005D *
                            	  4090: 
02:00000067 0000            	  4091: expl_y_pos	ds.w	6				; player ship explosion pieces y positions
02:00000069 *
                            	  4092: 
                            	  4093: 
                            	  4094: ; player 1 variables
                            	  4095: 
                            	  4096: player_1	EQU	*+$80				; player one variables base
                            	  4097: 
                            	  4098: x_pos_off	EQU	*-player_1			; offset to the x position base
02:00000073 0000            	  4099: 		ds.w	$1B				; item x position base address
02:00000075 *
                            	  4100: 
                            	  4101: p_xpos_off	EQU	*-player_1			; offset to the player x position
02:000000A9 0000            	  4102: 		ds.w	1				; player x position
                            	  4103: 
                            	  4104: s_xpos_off	EQU	*-player_1			; offset to the saucer x position
02:000000AB 0000            	  4105: 		ds.w	1				; saucer x position
                            	  4106: 
                            	  4107: f_xpos_off	EQU	*-player_1			; offset to the player x position
02:000000AD 0000            	  4108: 		ds.w	6				; fire objects x position
02:000000AF *
                            	  4109: x_pos_end	EQU	*-player_1			; offset to the flags end
                            	  4110: 
                            	  4111: y_pos_off	EQU	*-player_1			; offset to the y position base
02:000000B9 0000            	  4112: 		ds.w	$1B				; item y position base address
02:000000BB *
                            	  4113: 
                            	  4114: p_ypos_off	EQU	*-player_1			; offset to the player y position
02:000000EF 0000            	  4115: 		ds.w	1				; player y position
                            	  4116: s_ypos_off	EQU	*-player_1			; offset to the saucer y position
02:000000F1 0000            	  4117: 		ds.w	1				; saucer y position
                            	  4118: 
                            	  4119: f_ypos_off	EQU	*-player_1			; offset to the player y position
02:000000F3 0000            	  4120: 		ds.w	6				; fire objects y position
02:000000F5 *
                            	  4121: 
                            	  4122: 							; items $xx00 to $xx1A are rocks
                            	  4123: 							; $00 = no item
                            	  4124: 							; $0x = item exists
                            	  4125: 							; $Ax = item exploding
                            	  4126: 
                            	  4127: flags_off	EQU	*-player_1			; offset to the flags base
02:000000FF 00              	  4128: 		ds.b	$1B				; space for the rock flags
02:00000100 *
                            	  4129: 
                            	  4130: p_flag_off	EQU	*-player_1			; offset to the player flag
02:0000011A 00              	  4131: 		ds.b	1				; player flag
                            	  4132: 
                            	  4133: s_flag_off	EQU	*-player_1			; offset to the saucer flag
02:0000011B 00              	  4134: 		ds.b	1				; saucer flag
                            	  4135: 							; $00 = no saucer
                            	  4136: 							; $01 = small saucer
                            	  4137: 							; $02 = large saucer
                            	  4138: 							; $8x = saucer exploding
                            	  4139: 
                            	  4140: s_fire_off	EQU	*-player_1			; offset to the saucer fire flags
02:0000011C 00              	  4141: 		ds.b	2				; saucer fire objects
02:0000011D *
                            	  4142: 
                            	  4143: p_fire_off	EQU	*-player_1			; offset to the player fire flags
02:0000011E 00              	  4144: 		ds.b	4				; player fire objects
02:0000011F *
                            	  4145: flag_end	EQU	*-player_1			; offset to the flags end
                            	  4146: 
                            	  4147: x_vel_off	EQU	*-player_1			; offset to the x velocity base
02:00000122 00              	  4148: 		ds.b	$1B				; item x velocity base address
02:00000123 *
                            	  4149: 
                            	  4150: p_xvel_off	EQU	*-player_1			; offset to the player x velocity
02:0000013D 00              	  4151: 		ds.b	1				; player x velocity
                            	  4152: 
                            	  4153: s_xvel_off	EQU	*-player_1			; offset to the saucer x velocity
02:0000013E 00              	  4154: 		ds.b	1				; saucer x velocity
                            	  4155: 
                            	  4156: f_xvel_off	EQU	*-player_1			; offset to the fire objects x velocity
02:0000013F 00              	  4157: 		ds.b	6				; fire objects x velocity
02:00000140 *
                            	  4158: 
                            	  4159: y_vel_off	EQU	*-player_1			; offset to the x velocity base
02:00000145 00              	  4160: 		ds.b	$1B				; item y velocity base address
02:00000146 *
                            	  4161: 
                            	  4162: p_yvel_off	EQU	*-player_1			; offset to the player y velocity
02:00000160 00              	  4163: 		ds.b	1				; player y velocity
                            	  4164: 
                            	  4165: s_yvel_off	EQU	*-player_1			; offset to the saucer y velocity
02:00000161 00              	  4166: 		ds.b	1				; saucer y velocity
                            	  4167: 
                            	  4168: f_yvel_off	EQU	*-player_1			; offset to the fire objects y velocity
02:00000162 00              	  4169: 		ds.b	6				; fire objects y velocity
02:00000163 *
                            	  4170: 
                            	  4171: 
                            	  4172: i_rk_count	EQU	*-player_1			; offset to the initial rock count
02:00000168 00              	  4173: 		ds.b	1				; initial rock count
                            	  4174: rock_count	EQU	*-player_1			; offset to the rock count
02:00000169 00              	  4175: 		ds.b	1				; rock count
                            	  4176: 
                            	  4177: sauc_cntdn	EQU	*-player_1			; offset to the saucer countdown timer
02:0000016A 00              	  4178: 		ds.b	1				; saucer countdown timer
                            	  4179: 
                            	  4180: i_sauc_tim	EQU	*-player_1			; offset to the initial saucer timer
02:0000016B 00              	  4181: 		ds.b	1				; small saucer boundary/initial saucer timer
                            	  4182: 
                            	  4183: r_hit_tim	EQU	*-player_1			; offset to the rock hit timer
02:0000016C 00              	  4184: 		ds.b	1				; rock hit timer. if this times out because the
                            	  4185: 							; player hasn't shot a rock for a while then
                            	  4186: 							; the saucer timer initial value is decremented
                            	  4187: 							; so that the saucers come faster if the player
                            	  4188: 							; is just ignoring the last rock
                            	  4189: 
                            	  4190: hide_p_cnt	EQU	*-player_1			; offset to the hide the player count
02:0000016D 00              	  4191: 		ds.b	1				; hide the player count. when this count is non
                            	  4192: 							; zero the player is not displayed and the
                            	  4193: 							; thump sound does not sound. this count is set
                            	  4194: 							; to various lengths after certain events have
                            	  4195: 							; occured
                            	  4196: 							;
                            	  4197: 							; $0x player hidden, will appear
                            	  4198: 							; $8x player hidden, gonna die
                            	  4199: 
                            	  4200: new_rocks	EQU	*-player_1			; offset to the new rocks flag
02:0000016E 00              	  4201: 		ds.b	1				; generate new rocks flag
                            	  4202: 							; 0 = generate new rocks
                            	  4203: thmp_sndi	EQU	*-player_1			; offset to the thump sound change initial value
02:0000016F 00              	  4204: 		ds.b	1				; thump sound change timer initial value
                            	  4205: 
                            	  4206: min_rocks	EQU	*-player_1			; offset to the minimum rock count
02:00000170 00              	  4207: 		ds.b	1				; minimum rock count before the saucer initial
                            	  4208: 							; timer starts to decrement
                            	  4209: 
                            	  4210: p_xvlo_off	EQU	*-player_1			; offset to the player y velocity low byte
02:00000171 00              	  4211: 		ds.b	1				; player x velocity low byte
                            	  4212: p_yvlo_off	EQU	*-player_1			; offset to the player y velocity low byte
02:00000172 00              	  4213: 		ds.b	1				; player y velocity low byte
                            	  4214: 
                            	  4215: 		ds.w	0				; ensure even
                            	  4216: 
                            	  4217: score_off	EQU	*-player_1			; offset to the score word
02:00000173 0000            	  4218: p1_score	ds.w	1				; player score
                            	  4219: 
                            	  4220: ships_off	EQU	*-player_1			; offset to the ship count
02:00000175 00              	  4221: p1_ships	ds.b	1				; player 1 ship count
                            	  4222: 
                            	  4223: high_off	EQU	*-player_1			; offset to the player entering hiscore flag
02:00000176 00              	  4224: p1_high	ds.b	1				; player 1 highscore flag
                            	  4225: 							; $0x - entering high score, also index
                            	  4226: 							; $8x - done
                            	  4227: 
                            	  4228: 
                            	  4229: 		ds.w	0				; ensure even
                            	  4230: 
                            	  4231: ; player 2 variables
                            	  4232: 
                            	  4233: 
                            	  4234: player_2	EQU	*+$80				; player two variables base
02:00000177 00              	  4235: 		ds.b	score_off+$80		; space for the player two variables
02:00000178 *
                            	  4236: 
02:00000277 0000            	  4237: p2_score	ds.w	1				; player 2 score
                            	  4238: 
02:00000279 00              	  4239: p2_ships	ds.b	1				; player 2 ship count
                            	  4240: 
02:0000027A 00              	  4241: p2_high	ds.b	1				; player 2 highscore flag
                            	  4242: 							; $0x - entering high score, also index
                            	  4243: 							; $8x - done
                            	  4244: 
                            	  4245: 		ds.w	0				; ensure even
                            	  4246: 
                            	  4247: p_2_end
                            	  4248: 
                            	  4249: 
                            	  4250: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  4251: 
                            	  4252: 
                            	  4253: ;	END	asteroids_start
                            	  4254: 
                            	  4255: 
                            	  4256: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  4257: 

Source: "boot.x68"
                            	  4153: 	include "games/plants/plants.x68"

Source: "games\plants\plants.x68"
                            	     1: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	     2: ;														;
                            	     3: ;	Plants and animals demo EASy68K V1.20			2011/05/30			;
                            	     4: ;														;
                            	     5: ;	This world is inhabited by two types of life. Plants, which are photosyn-	;
                            	     6: ;	thetic and will grow until they fill all space, and animals which eat the	;
                            	     7: ;	foliage of the plants and will multiply while food is available.			;
                            	     8: ;														;
                            	     9: ;	The growing tip of the plant is a redish bud, this tip not only grows but	;
                            	    10: ;	sprouts new buds as it goes up to a preset maximum number of buds. As a		;
                            	    11: ;	bud grows and moves on it leaves behind green foliage. If a bud has no		;
                            	    12: ;	space to grow into that bud stops growing and another bud can be spawned	;
                            	    13: ;	elsewhere on the plant.										;
                            	    14: ;														;
                            	    15: ;	The animals eat the plant's green foliage and once they have eaten enough	;
                            	    16: ;	they will spawn a new animal which will go its own way eating another share	;
                            	    17: ;	of green foliage. If there is no green foliage to eat an animal will starve.	;
                            	    18: ;														;
                            	    19: ;	Also a bud trying to grow into the space where there is an animal will get	;
                            	    20: ;	stepped on and die, and animal trying to eat the bud of a plant will get	;
                            	    21: ;	sick and die. Watching over all this is a benevolent deity who, on seeing	;
                            	    22: ;	the extinction of growing plants or eating animals will spawn a new proge-	;
                            	    23: ;	nitor for the extinct species.								;
                            	    24: ;														;
                            	    25: ;														;
                            	    26: ;	The main loop time is throttled by measuring the time the loop took and		;
                            	    27: ;	then waiting the remains of the required time using task #23, delay. This,	;
                            	    28: ;	on my laptop, reduces the CPU loading from 100% to 65%.				;
                            	    29: ;														;
                            	    30: ;	Changes to the way new plants and animals are spawned, the plant or animal	;
                            	    31: ;	array is not searched if it is already full, has further reduced the CPU	;
                            	    32: ;	loading to 50% on my laptop.									;
                            	    33: ;														;
                            	    34: ;														;
                            	    35: ;	The [F2], [F3] and [F4]	keys can be used to select a screen size of 640 x	;
                            	    36: ;	480, 800 x 600 and 1024 x 768 respectively.						;
                            	    37: ;														;
                            	    38: ;	[ESC] can be used to quit the program.							;
                            	    39: ;														;
                            	    40: ;	More 68000 and other projects can be found on my website at ..			;
                            	    41: ;														;
                            	    42: ;	 http://mycorner.no-ip.org/index.html							;
                            	    43: ;														;
                            	    44: ;	mail : leeedavison@googlemail.com								;
                            	    45: ;														;
                            	    46: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    47: ;
                            	    48: ; some equates
                            	    49: 
                            	    50: ESC		EQU	$1B				; [ESC] character
                            	    51: ;CR		EQU	$0D				; [CR] character
                            	    52: ;LF		EQU	$0A				; [LF] character
                            	    53: 
                            	    54: def_back	EQU	$000000			; the default background colour
                            	    55: def_animal	EQU	$FFFFFF		; the default animal colour
                            	    56: def_plant	EQU	$8080FF			; the default plant colour
                            	    57: def_leaf	EQU	$008000			; the default leaf colour
                            	    58: 
                            	    59: def_plants	EQU	50				; the default plant count
                            	    60: def_p_spawn	EQU	1				; the default plant spawn level
                            	    61: def_animals	EQU	50				; the default animal count
                            	    62: def_a_spawn	EQU	5				; the default animal spawn level
                            	    63: 
                            	    64: 
                            	    65: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    66: ;
                            	    67: 
                            	    68: 	ORG		$20000
                            	    69: 
                            	    70: start_plants
02:00020000 13FC000EFD0FFF00	    71: 	move.b #14,leds
02:00020008 61000360        	    72: 	bsr InitialisePlants	; go setup everything but the world
                            	    73: restart
02:0002000C 13FC000FFD0FFF00	    74: 	move.b #15,leds
02:00020014 6100008C        	    75: 	bsr	init_world				; go setup the world
                            	    76: 
                            	    77: ; main loop
                            	    78: 
                            	    79: plants_main_loop
02:00020018 7008            	    80: 	MOVEQ		#8,d0				; get the time in 1/100 ths seconds
02:0002001A 4E4F            	    81: 	TRAP		#15
                            	    82: 
02:0002001C 2F01            	    83: 	MOVE.l	d1,-(sp)			; save the time on the stack
                            	    84: 
02:0002001E 705E            	    85: 	MOVEQ		#94,d0			; copy buffer screen to main
02:00020020 4E4F            	    86: 	TRAP		#15
02:00020022 13FC0003FD0FFF00	    87: 	move.b #$03,leds
                            	    88: 
                            	    89: ; animate the scene
                            	    90: 
02:0002002A 61000116        	    91: 	BSR		do_plants			; do the plants
02:0002002E 61000148        	    92: 	BSR		do_animals			; do the animals
                            	    93: 
                            	    94: ; test the keys used
                            	    95: 
02:00020032 610003C2        	    96: 	BSR		screen_size			; test and handle widow size change keys
02:00020036 6151            	    97: 	BSR		test_escape			; test if the user wants to quit
                            	    98: 
                            	    99: ; now see if we need to wait for some time
                            	   100: 
02:00020038 2E1F            	   101: 	MOVE.l	(sp)+,d7			; get the main loop start time
02:0002003A 7008            	   102: 	MOVEQ		#8,d0				; get time in 1/100 ths seconds
02:0002003C 4E4F            	   103: 	TRAP		#15
                            	   104: 
02:0002003E 13FC0004FD0FFF00	   105: 	move.b #$04,leds
                            	   106: 
                            	   107: ; doing the BGT means that if the clock passed midnight while the code was in the main
                            	   108: ; loop then the delay is skipped this go. this means things may run a bit fast for one
                            	   109: ; loop which is waaaaay better than waiting for a few 100ths of a second shy of twenty
                            	   110: ; four hours by mistake
                            	   111: 
02:00020046 9E81            	   112: 	SUB.l		d1,d7				; subtract the current time from the start time
02:00020048 6E1A            	   113: 	BGT.s		end_main_loop		; if the time crossed midnight just contimue
                            	   114: 
                            	   115: ; moving the wait time into d1 like this menas we can have any wait up to 1.27 seconds
                            	   116: ; and still use the MOVEQ form to load it
                            	   117: 
02:0002004A 7205            	   118: 	MOVEQ		#5,d1				; set the wait time in 100ths of a second
02:0002004C D287            	   119: 	ADD.l		d7,d1				; add the loop negative time delta
02:0002004E 6F14            	   120: 	BLE.s		end_main_loop		; if the time is up just contimue
                            	   121: 
02:00020050 13FC0005FD0FFF00	   122: 	move.b #$05,leds
02:00020058 7017            	   123: 	MOVEQ		#23,d0			; else wait d1 100ths of a second
02:0002005A 4E4F            	   124: 	TRAP		#15
02:0002005C 13FC0006FD0FFF00	   125: 	move.b #$06,leds
                            	   126: 
                            	   127: end_main_loop
02:00020064 4A6B0002        	   128: 	TST.w		redraw(a3)			; test the redraw flag
02:00020068 66A2            	   129: 	BNE.s		restart			; if redraw go initialise the world
                            	   130: 
02:0002006A 4A53            	   131: 	TST.w		quit(a3)			; test the quit flag
02:0002006C 67AA            	   132: 	BEQ.s		plants_main_loop			; if not quit go get another key
                            	   133: 
                            	   134: ; all done so tidy up and stop
                            	   135: 
                            	   136: ;	MOVE.b	#16,d1			; disable double buffering
                            	   137: ;	MOVE.b	#92,d0			; set draw mode
                            	   138: ;	TRAP		#15
                            	   139: 
02:0002006E 43FA000C        	   140: 	LEA		goodbye_message(pc),a1	; set the goodbye message pointer
02:00020072 700D            	   141: 	MOVEQ		#13,d0			; display a string with [CR][LF]
02:00020074 4E4F            	   142: 	TRAP		#15
                            	   143: 
02:00020076 4EF900008138    	   144: 	jmp Monitor
                            	   145: ;	MOVEQ		#9,d0				; halt the simulator
                            	   146: ;	TRAP		#15
                            	   147: 
                            	   148: goodbye_message
02:0002007C 0C              	   149: 	dc.b	$0C,CR,LF
02:0002007D 0D
02:0002007E 0A
02:0002007F 2020476F6F646279	   150: 	dc.b	'  Goodbye',0
02:00020087 65
02:00020088 00
                            	   151: 
                            	   152: 	ds.w	0					; ensure even
                            	   153: 
                            	   154: 
                            	   155: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   156: ;
                            	   157: ; test if the user wants to quit
                            	   158: 
                            	   159: test_escape
02:0002008A 7007            	   160: 	MOVEQ		#7,d0				; read the key status
02:0002008C 4E4F            	   161: 	TRAP		#15
                            	   162: 
02:0002008E 4A01            	   163: 	TST.b		d1				; test the result
02:00020090 670E            	   164: 	BEQ.s		exit_test_escape		; if no key just exit
                            	   165: 
02:00020092 7005            	   166: 	MOVEQ		#5,d0				; read a key
02:00020094 4E4F            	   167: 	TRAP		#15
                            	   168: 
02:00020096 0C01001B        	   169: 	CMPI.b	#ESC,d1			; compare with [ESC]
02:0002009A 6604            	   170: 	BNE.s		exit_test_escape		; if not [ESC] just exit
                            	   171: 
02:0002009C 72FF            	   172: 	MOVEQ		#-1,d1			; set the longword
02:0002009E 3681            	   173: 	MOVE.w	d1,quit(a3)			; set the quit flag
                            	   174: exit_test_escape
02:000200A0 4E75            	   175: 	RTS
                            	   176: 
                            	   177: 
                            	   178: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   179: ;
                            	   180: ; setup the world
                            	   181: 
                            	   182: init_world:
                            	   183: ;	MOVE.w	#$FF00,d1			; clear screen
                            	   184: ;	MOVEQ		#11,d0			; position cursor
                            	   185: ;	TRAP		#15
02:000200A2 4EB900001D18    	   186: 	jsr clear_graphics_screen
02:000200A8 123C0045        	   187: 	move.b #'E',d1
02:000200AC 4EB900000000    	   188: 	jsr DisplayChar
                            	   189: 
02:000200B2 203C00FFFFFF    	   190: 	MOVE.l	#def_animal,d0		; set the default animal colour
02:000200B8 27400014        	   191: 	MOVE.l	d0,animal_colour(a3)	; save the animal colour
02:000200BC 7000            	   192: 	MOVE.l	#def_back,d0		; set the default background colour
02:000200BE 27400018        	   193: 	MOVE.l	d0,animal_fill(a3)	; save the animal fill colour
                            	   194: 
                            	   195: 
02:000200C2 203C008080FF    	   196: 	MOVE.l	#def_plant,d0		; set the default plant colour
02:000200C8 27400010        	   197: 	MOVE.l	d0,plant_colour(a3)	; save the plant colour
02:000200CC 203C00008000    	   198: 	MOVE.l	#def_leaf,d0		; set the default leaf colour
02:000200D2 27400012        	   199: 	MOVE.l	d0,plant_fill(a3)		; save the plant fill colour
                            	   200: 
02:000200D6 7032            	   201: 	MOVEQ		#def_plants,d0		; set the default plant count
02:000200D8 3740000A        	   202: 	MOVE.w	d0,max_plants(a3)		; save the maximum plants count
02:000200DC 7001            	   203: 	MOVEQ		#def_p_spawn,d0		; set the default plant spawn value
02:000200DE 17400220        	   204: 	MOVE.b	d0,plant_spawn(a3)	; save the plant spawn value
                            	   205: 
02:000200E2 7032            	   206: 	MOVEQ		#def_animals,d0		; set the default animal count
02:000200E4 3740000E        	   207: 	MOVE.w	d0,max_animals(a3)	; save the maximum animals count
02:000200E8 7005            	   208: 	MOVEQ		#def_a_spawn,d0		; set the default animal spawn value
02:000200EA 17400221        	   209: 	MOVE.b	d0,animal_spawn(a3)	; save the animal spawn value
                            	   210: 
02:000200EE 7000            	   211: 	MOVEQ		#0,d0				; clear the longword
02:000200F0 37400002        	   212: 	MOVE.w	d0,redraw(a3)		; clear the redraw flag
                            	   213: 
                            	   214: ; clear all the plants
                            	   215: 
02:000200F4 41EB00F4        	   216: 	LEA		plant_flag(a3),a0		; set the pointer to the plant flags
02:000200F8 3E2B000A        	   217: 	MOVE.w	max_plants(a3),d7		; get the maximum plants count
02:000200FC 5347            	   218: 	SUBQ.w	#1,d7				; adjust for the loop type
02:000200FE 13FC0001FD0FFF00	   219: 	move.b #$01,leds
                            	   220: clr_plant_loop
02:00020106 10C0            	   221: 	MOVE.b	d0,(a0)+			; clear the plant flag
02:00020108 51CFFFFC        	   222: 	DBF		d7,clr_plant_loop		; loop if more to do
                            	   223: 
02:0002010C 37400008        	   224: 	MOVE.w	d0,num_plants(a3)		; clear the plants count
                            	   225: 
                            	   226: ; clear all the animals
                            	   227: 
02:00020110 41EB01EE        	   228: 	LEA		animal_flag(a3),a0	; set the pointer to the animal flags
02:00020114 3E2B000E        	   229: 	MOVE.w	max_animals(a3),d7	; get the maximum animals count
02:00020118 5347            	   230: 	SUBQ.w	#1,d7				; adjust for the loop type
                            	   231: clr_animals_loop
02:0002011A 10C0            	   232: 	MOVE.b	d0,(a0)+			; clear the animal flag
02:0002011C 51CFFFFC        	   233: 	DBF		d7,clr_animals_loop	; loop if more to do
                            	   234: 
02:00020120 3740000C        	   235: 	MOVE.w	d0,num_animals(a3)	; clear the animals count
                            	   236: 
                            	   237: ; get the screen size
02:00020124 13FC0002FD0FFF00	   238: 	move.b #$02,leds
                            	   239: 
02:0002012C 7200            	   240: 	MOVEQ		#0,d1				; get current window size
02:0002012E 7021            	   241: 	MOVEQ		#33,d0			; set/get output window size
02:00020130 4E4F            	   242: 	TRAP		#15
02:00020132 13FC0003FD0FFF00	   243: 	move.b #$03,leds
                            	   244: 
02:0002013A E289            	   245: 	LSR.l		#1,d1				; / 2 for 2x2 pixels
02:0002013C 27410004        	   246: 	MOVE.l	d1,width(a3)		; save the screen x,y size
                            	   247: 
02:00020140 4E75            	   248: 	rts
                            	   249: 
                            	   250: 
                            	   251: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   252: ;
                            	   253: ; do the plants
                            	   254: 
                            	   255: do_plants
02:00020142 13FC0007FD0FFF00	   256: 	move.b #$07,leds
02:0002014A 41EB0008        	   257: 	LEA		num_plants(a3),a0		; point to the plants count
02:0002014E 326B000A        	   258: 	MOVE.w	max_plants(a3),a1		; get the plants maximum
02:00020152 45EB0220        	   259: 	LEA		plant_spawn(a3),a2	; point to the plant spawn level
02:00020156 49EB002C        	   260: 	LEA		plant_xy(a3),a4		; point to the plant position array
02:0002015A 4BEB00F4        	   261: 	LEA		plant_flag(a3),a5		; point to the plant flags
02:0002015E 276B0010001C    	   262: 	MOVE.l	plant_colour(a3),thing_colour(a3)
                            	   263: 							; copy the plant colour
02:00020164 276B00120020    	   264: 	MOVE.l	plant_fill(a3),fill_colour(a3)
                            	   265: 							; copy the plant fill colour
02:0002016A 276B00180024    	   266: 	MOVE.l	animal_fill(a3),food_colour(a3)
                            	   267: 							; copy the animal fill colour
02:00020170 276B00140028    	   268: 	MOVE.l	animal_colour(a3),poison_colour(a3)
                            	   269: 							; copy the animal colour
02:00020176 6034            	   270: 	BRA.s		do_things			; go do the plants
                            	   271: 
                            	   272: 
                            	   273: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   274: ;
                            	   275: ; do the animals
                            	   276: 
                            	   277: do_animals
02:00020178 13FC0008FD0FFF00	   278: 	move.b #$08,leds
02:00020180 41EB000C        	   279: 	LEA		num_animals(a3),a0	; point to the animals count
02:00020184 326B000E        	   280: 	MOVE.w	max_animals(a3),a1	; get the animals maximum
02:00020188 45EB0221        	   281: 	LEA		animal_spawn(a3),a2	; point to the animal spawn level
02:0002018C 49EB0126        	   282: 	LEA		animal_xy(a3),a4		; point to the animal position array
02:00020190 4BEB01EE        	   283: 	LEA		animal_flag(a3),a5	; point to the animal flags
02:00020194 276B0014001C    	   284: 	MOVE.l	animal_colour(a3),thing_colour(a3)
                            	   285: 							; copy the animal colour
02:0002019A 276B00180020    	   286: 	MOVE.l	animal_fill(a3),fill_colour(a3)
                            	   287: 							; copy the animal fill colour
02:000201A0 276B00120024    	   288: 	MOVE.l	plant_fill(a3),food_colour(a3)
                            	   289: 							; copy the plant fill colour
02:000201A6 276B00100028    	   290: 	MOVE.l	plant_colour(a3),poison_colour(a3)
                            	   291: 							; copy the plant colour
                            	   292: 
                            	   293: 
                            	   294: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   295: ;
                            	   296: ; do things
                            	   297: 
                            	   298: do_things
02:000201AC 13FC0009FD0FFF00	   299: 	move.b #$09,leds
02:000201B4 3E10            	   300: 	MOVE.w	(a0),d7			; get the things count
02:000201B6 6636            	   301: 	BNE.s		things_exist		; if things exist go make them eat
                            	   302: 
                            	   303: ; else get a random position for thing zero
                            	   304: 
02:000201B8 302B0004        	   305: 	MOVE.w	width(a3),d0		; get the screen width
02:000201BC 61000228        	   306: 	BSR		get_prng			; get a random number between 0 and d0.w - 1
02:000201C0 3600            	   307: 	MOVE.w	d0,d3				; copy the x co-ordinate
02:000201C2 3800            	   308: 	MOVE.w	d0,d4				; copy the x co-ordinate again
02:000201C4 4844            	   309: 	SWAP		d4				; swap it to the high word
02:000201C6 302B0006        	   310: 	MOVE.w	height(a3),d0		; get the screen height
02:000201CA 6100021A        	   311: 	BSR		get_prng			; get a random number between 0 and d0.w - 1
02:000201CE 3800            	   312: 	MOVE.w	d0,d4				; copy the x co-ordinate
02:000201D0 2884            	   313: 	MOVE.l	d4,(a4)			; set the x,y for thing zero
                            	   314: 
02:000201D2 7008            	   315: 	MOVEQ		#8,d0				; direction is this position
02:000201D4 610000DE        	   316: 	BSR		neighbour			; get the neighbouring pixel colour in
                            	   317: 							; direction d0
02:000201D8 BAAB0024        	   318: 	CMP.l		food_colour(a3),d5	; compare the colour with the food colour
02:000201DC 660000D4        	   319: 	BNE		exit_do_things		; if it is not food just exit
                            	   320: 
                            	   321: ; else make thing zero active
                            	   322: 
02:000201E0 5250            	   323: 	ADDQ.w	#1,(a0)			; increment the thing count
02:000201E2 1ABC0001        	   324: 	MOVE.b	#1,(a5)			; flag thing zero active
                            	   325: 
02:000201E6 2F2B001C        	   326: 	MOVE.l	thing_colour(a3),-(sp)	; fill the old position with the thing colour
02:000201EA 600000BC        	   327: 	BRA		fill_old_thing		; go draw thing zero, d7.w = 0 here
                            	   328: 
                            	   329: ; set the direction delta, randomly setting -1 and +1 should remove any bias toward
                            	   330: ; sweeping round the screen clockwise or anticlockwise
                            	   331: 
                            	   332: things_exist
02:000201EE 13FC000AFD0FFF00	   333: 	move.b #10,leds
02:000201F6 7002            	   334: 	MOVEQ		#2,d0				; set for 0 or 1
02:000201F8 610001EC        	   335: 	BSR		get_prng			; get a random number between 0 and d0.w - 1
02:000201FC D040            	   336: 	ADD.w		d0,d0				; now 0 or 2
02:000201FE 5340            	   337: 	SUBQ.w	#1,d0				; -1 or + 1
02:00020200 3C40            	   338: 	MOVE.w	d0,a6				; copy the direction delta
                            	   339: 
                            	   340: ; scan through all the possible things
02:00020202 5349            	   341: 	SUBQ.w	#1,a1				; - 1 for loop type
02:00020204 3E09            	   342: 	MOVE.w	a1,d7				; get the maximum things count
                            	   343: do_things_loop
02:00020206 4A357000        	   344: 	TST.b		(a5,d7.w)			; test the thing status
02:0002020A 670000A2        	   345: 	BEQ		next_thing			; if not active skip this thing
                            	   346: 
                            	   347: ; get this thing's x,y position
                            	   348: 
                            	   349: thing_zero_only
02:0002020E 13FC000BFD0FFF00	   350: 	move.b #11,leds
02:00020216 3807            	   351: 	MOVE.w	d7,d4				; copy the index
02:00020218 E544            	   352: 	ASL.w		#2,d4				; ; 4 bytes per word
02:0002021A 28344000        	   353: 	MOVE.l	(a4,d4.w),d4		; get the thing's x,y position
02:0002021E 2604            	   354: 	MOVE.l	d4,d3				; copy the thing's x position
02:00020220 4843            	   355: 	SWAP		d3				; move the thing's x position to the low word
                            	   356: 
                            	   357: ; fill the thing's current position
                            	   358: 
02:00020222 2F2B0020        	   359: 	MOVE.l	fill_colour(a3),-(sp)	; set the fill behind colour
                            	   360: 
                            	   361: ; get a random direction
                            	   362: 
02:00020226 610001BC        	   363: 	BSR		get_direction		; get a random direction
                            	   364: 
                            	   365: ; remember the direction we start from
                            	   366: 
02:0002022A 3C00            	   367: 	MOVE.w	d0,d6				; copy the start direction
                            	   368: check_for_food
02:0002022C 13FC000CFD0FFF00	   369: 	move.b #12,leds
02:00020234 617E            	   370: 	BSR.s		neighbour			; get the neighbouring pixel colour in
                            	   371: 							; direction d0
02:00020236 BAAB0024        	   372: 	CMP.l		food_colour(a3),d5	; compare the colour with the food colour
02:0002023A 6720            	   373: 	BEQ.s		is_food			; if it is food go move the thing
                            	   374: 
02:0002023C BAAB0028        	   375: 	CMP.l		poison_colour(a3),d5	; compare the colour with the poison colour
02:00020240 670A            	   376: 	BEQ.s		kill_thing			; if it is poison go kill the thing
                            	   377: 
                            	   378: ; no food in the direction looked so try the next direction
                            	   379: 
02:00020242 D04E            	   380: 	ADD.w		a6,d0				; add the direction delta
02:00020244 02400007        	   381: 	ANDI.w	#7,d0				; mask 0 to 7
02:00020248 BC40            	   382: 	CMP.w		d0,d6				; compare it with the start direction
02:0002024A 66E0            	   383: 	BNE.s		check_for_food		; if not back at the start go check for food
                            	   384: 
                            	   385: ; else this thing has starved so kill it
                            	   386: 
                            	   387: kill_thing
02:0002024C 13FC000DFD0FFF00	   388: 	move.b #13,leds
02:00020254 5350            	   389: 	SUBQ.w	#1,(a0)			; decrement the thing count
02:00020256 42357000        	   390: 	MOVE.b	#0,(a5,d7.w)		; clear the thing flag
02:0002025A 604C            	   391: 	BRA.s		fill_old_thing		; go fill this thing with the fill behind colour
                            	   392: 
                            	   393: ; found food beside the thing so move it there
                            	   394: 
                            	   395: is_food
02:0002025C 13FC000EFD0FFF00	   396: 	move.b #14,leds
02:00020264 3007            	   397: 	MOVE.w	d7,d0				; copy the index
02:00020266 E540            	   398: 	ASL.w		#2,d0				; ; 4 bytes per word
02:00020268 39810000        	   399: 	MOVE.w	d1,(a4,d0.w)		; save the thing's new x position
02:0002026C 39820002        	   400: 	MOVE.w	d2,2(a4,d0.w)		; save the thing's new y position
                            	   401: 
02:00020270 52357000        	   402: 	ADDQ.b	#1,(a5,d7.w)		; increment the thing flag
                            	   403: 
                            	   404: ; check for spawning a new thing
                            	   405: 
02:00020274 10357000        	   406: 	MOVE.b	(a5,d7.w),d0		; get the thing flag
02:00020278 9012            	   407: 	SUB.b		(a2),d0			; compare it with the spawn level
02:0002027A 6F2A            	   408: 	BLE.s		draw_old_thing		; if not there yet skip the spawn
                            	   409: 
                            	   410: ; else the thing is going to try to spawn
                            	   411: 
02:0002027C 1B807000        	   412: 	MOVE.b	d0,(a5,d7.w)		; reset the flag for this thing, d0 = 1
                            	   413: 
                            	   414: ; search for a free thing slot
                            	   415: 
02:00020280 3C09            	   416: 	MOVE.w	a1,d6				; get the maximum things count
02:00020282 BC50            	   417: 	CMP.w		(a0),d6			; compare it with the things count
02:00020284 6B20            	   418: 	BMI.s		draw_old_thing		; if no space just draw the old thing
                            	   419: 
                            	   420: new_thing_loop
02:00020286 13FC000FFD0FFF00	   421: 	move.b #15,leds
02:0002028E 4A356000        	   422: 	TST.b		(a5,d6.w)			; test this thing flag
02:00020292 57CEFFF2        	   423: 	DBEQ		d6,new_thing_loop		; loop if active
                            	   424: 
                            	   425: ; found one of the free thing slots so flag that the new thing is active
                            	   426: 
02:00020296 5250            	   427: 	ADDQ.w	#1,(a0)			; increment the thing count
02:00020298 1B806000        	   428: 	MOVE.b	d0,(a5,d6.w)		; set the new thing's active flag, d0 = 1
                            	   429: 
                            	   430: ; save the new thing position
                            	   431: 
02:0002029C E546            	   432: 	ASL.w		#2,d6				; ; 4 bytes per word
02:0002029E 29846000        	   433: 	MOVE.l	d4,(a4,d6.w)		; save the new thing's x,y position
                            	   434: 
                            	   435: ; set the new thing's colour to fill the thing's old position
                            	   436: 
02:000202A2 2EAB001C        	   437: 	MOVE.l	thing_colour(a3),(sp)	; fill the old position with the thing colour
                            	   438: 
                            	   439: ; now draw the current thing in the new position and fill the old position
                            	   440: 
                            	   441: draw_old_thing
02:000202A6 617C            	   442: 	BSR.s		set_thing_pixel		; set the pixel at d1,d2 to the thing's colour
                            	   443: fill_old_thing
02:000202A8 201F            	   444: 	MOVE.l	(sp)+,d0			; get the d3,d4 pixel's colout
02:000202AA 6100008E        	   445: 	BSR		set_a_pixel			; set the pixel at d3,d4 to the d0's colour
                            	   446: next_thing
02:000202AE 51CFFF56        	   447: 	DBF		d7,do_things_loop		; decrement and loop if more things to do
                            	   448: 
                            	   449: exit_do_things
02:000202B2 4E75            	   450: 	RTS
                            	   451: 
                            	   452: 
                            	   453: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   454: ;
                            	   455: ; get the neighbouring 2x2 pixel colour in direction d0.w
                            	   456: ;
                            	   457: ; x is in d3.w, y is in d4.w
                            	   458: ;
                            	   459: ; returns the pixel colour or -1 of out of range in d5.l
                            	   460: ; returns the new x,y in d1,d2
                            	   461: 
                            	   462: neighbour
02:000202B4 13FC0010FD0FFF00	   463: 	move.b #16,leds
02:000202BC 48E78000        	   464: 	MOVEM.l	d0,-(sp)			; save the direction
                            	   465: 
02:000202C0 7AFF            	   466: 	MOVEQ		#-1,d5			; flag out of range
                            	   467: 
02:000202C2 3203            	   468: 	MOVE.w	d3,d1				; copy x
02:000202C4 3404            	   469: 	MOVE.w	d4,d2				; copy y
                            	   470: 
02:000202C6 D040            	   471: 	ADD.w		d0,d0				; ; 2 bytes per word
02:000202C8 D27B0036        	   472: 	ADD.w		delta_x(pc,d0.w),d1	; add the direction delta x to x
02:000202CC 6B2C            	   473: 	BMI.s		exit_neighbour		; if x < screen x minimum just exit
                            	   474: 
02:000202CE B26B0004        	   475: 	CMP.w		width(a3),d1		; compare it with the screen width
02:000202D2 6C26            	   476: 	BGE.s		exit_neighbour		; if x > screen x maximum just exit
                            	   477: 
02:000202D4 D47B003C        	   478: 	ADD.w		delta_y(pc,d0.w),d2	; add the direction delta y to y
02:000202D8 6B20            	   479: 	BMI.s		exit_neighbour		; if y < screen y minimum just exit
                            	   480: 
02:000202DA B46B0006        	   481: 	CMP.w		height(a3),d2		; compare it with the screen height
02:000202DE 6C1A            	   482: 	BGE.s		exit_neighbour		; if y > screen y maximum just exit
                            	   483: 
02:000202E0 48E76000        	   484: 	MOVEM.l	d1-d2,-(sp)			; save the new x,y
                            	   485: 
02:000202E4 D241            	   486: 	ADD.w		d1,d1				; * 2
02:000202E6 D442            	   487: 	ADD.w		d2,d2				; * 2
02:000202E8 7053            	   488: 	MOVEQ		#83,d0			; read a pixel
02:000202EA 4E4F            	   489: 	TRAP		#15
02:000202EC 13FC0011FD0FFF00	   490: 	move.b #17,leds
                            	   491: 
02:000202F4 4CDF0006        	   492: 	MOVEM.l	(sp)+,d1-d2			; restore the new x,y
                            	   493: 
02:000202F8 2A00            	   494: 	MOVE.l	d0,d5				; copy the pixel colour
                            	   495: exit_neighbour
02:000202FA 4CDF0001        	   496: 	MOVEM.l	(sp)+,d0			; restore the direction
                            	   497: 
02:000202FE 4E75            	   498: 	RTS
                            	   499: 
                            	   500: ; direction deltas				; the directions are
                            	   501: 							;
                            	   502: 							; +---+---+---+
                            	   503: 							; | 5 | 4 | 3 |
                            	   504: 							; +---+---+---+
                            	   505: 							; | 6 | 8 | 2 |
                            	   506: 							; +---+---+---+
                            	   507: 							; | 7 | 0 | 1 |
                            	   508: 							; +---+---+---+
                            	   509: delta_x
02:00020300 0000            	   510: 	dc.w	0					; direction 0 dx,dy =  0, 1
02:00020302 0001            	   511: 	dc.w	1					; direction 1 dx,dy =  1, 1
02:00020304 0001            	   512: 	dc.w	1					; direction 2 dx,dy =  1, 0
02:00020306 0001            	   513: 	dc.w	1					; direction 3 dx,dy =  1,-1
02:00020308 0000            	   514: 	dc.w	0					; direction 4 dx,dy =  0,-1
02:0002030A FFFF            	   515: 	dc.w	-1					; direction 5 dx,dy = -1,-1
02:0002030C FFFF            	   516: 	dc.w	-1					; direction 6 dx,dy = -1, 0
02:0002030E FFFF            	   517: 	dc.w	-1					; direction 7 dx,dy = -1, 1
02:00020310 0000            	   518: 	dc.w	0					; direction 8 dx,dy =  0, 0
                            	   519: 
                            	   520: delta_y
02:00020312 0001            	   521: 	dc.w	1					; direction 0 dx,dy =  0, 1
02:00020314 0001            	   522: 	dc.w	1					; direction 1 dx,dy =  1, 1
02:00020316 0000            	   523: 	dc.w	0					; direction 2 dx,dy =  1, 0
02:00020318 FFFF            	   524: 	dc.w	-1					; direction 3 dx,dy =  1,-1
02:0002031A FFFF            	   525: 	dc.w	-1					; direction 4 dx,dy =  0,-1
02:0002031C FFFF            	   526: 	dc.w	-1					; direction 5 dx,dy = -1,-1
02:0002031E 0000            	   527: 	dc.w	0					; direction 6 dx,dy = -1, 0
02:00020320 0001            	   528: 	dc.w	1					; direction 7 dx,dy = -1, 1
02:00020322 0000            	   529: 	dc.w	0					; direction 8 dx,dy =  0, 0
                            	   530: 
                            	   531: 
                            	   532: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   533: ;
                            	   534: ; set the 2x2 pixel at d1,d2 to the thing's
                            	   535: 
                            	   536: set_thing_pixel
02:00020324 13FC0012FD0FFF00	   537: 	move.b #18,leds
02:0002032C 48E77800        	   538: 	MOVEM.l	d1-d4,-(sp)			; save the registers
02:00020330 3601            	   539: 	MOVE.w	d1,d3				; copy the thing's new x position
02:00020332 3802            	   540: 	MOVE.w	d2,d4				; copy the thing's new y position
02:00020334 202B001C        	   541: 	MOVE.l	thing_colour(a3),d0	; get the thing colour
02:00020338 600C            	   542: 	BRA.s		set_this_pixel		; go set this pixel
                            	   543: 
                            	   544: 
                            	   545: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   546: ;
                            	   547: ; set the 2x2 pixel at d3,d4 to colour d0
                            	   548: 
                            	   549: set_a_pixel
02:0002033A 13FC0013FD0FFF00	   550: 	move.b #19,leds
02:00020342 48E77800        	   551: 	MOVEM.l	d1-d4,-(sp)			; save the registers
                            	   552: 
                            	   553: set_this_pixel
02:00020346 13FC0014FD0FFF00	   554: 	move.b #20,leds
02:0002034E 2200            	   555: 	MOVE.l	d0,d1				; copy the colour
02:00020350 7050            	   556: 	MOVEQ		#80,d0			; set the pen colour
02:00020352 4E4F            	   557: 	TRAP		#15
                            	   558: 
02:00020354 7201            	   559: 	MOVEQ		#1,d1				; + 1
02:00020356 7401            	   560: 	MOVEQ		#1,d2				; + 1
02:00020358 D643            	   561: 	ADD.w		d3,d3				; x*2
02:0002035A D844            	   562: 	ADD.w		d4,d4				; y*2
02:0002035C D243            	   563: 	ADD.w		d3,d1				; x*2 + 1
02:0002035E D444            	   564: 	ADD.w		d4,d2				; y*2 + 1
02:00020360 705A            	   565: 	MOVEQ		#90,d0			; draw a rectangle in the pen colour
02:00020362 4E4F            	   566: 	TRAP		#15
                            	   567: 
02:00020364 4CDF001E        	   568: 	MOVEM.l	(sp)+,d1-d4			; restore the registers
02:00020368 4E75            	   569: 	RTS
                            	   570: 
                            	   571: 
                            	   572: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   573: ;
                            	   574: ; setup stuff
                            	   575: 
                            	   576: InitialisePlants:
02:0002036A 123C0040        	   577: 	move.b #'@',d1
02:0002036E 4EB900000000    	   578: 	jsr DisplayChar
                            	   579: 	
02:00020374 123C0011        	   580: 	MOVE.b	#17,d1			; enable double buffering
02:00020378 103C005C        	   581: 	MOVE.b	#92,d0			; set draw mode
02:0002037C 4E4F            	   582: 	TRAP		#15
                            	   583: 	
02:0002037E 123C0041        	   584: 	move.b #'A',d1
02:00020382 4EB900000000    	   585: 	jsr DisplayChar
                            	   586: 	
02:00020388 7200            	   587: 	MOVEQ		#0,d1				; echo off
02:0002038A 700C            	   588: 	MOVEQ		#12,d0			; set keyboard echo
02:0002038C 4E4F            	   589: 	TRAP		#15
02:0002038E 123C0042        	   590: 	move.b #'B',d1
02:00020392 4EB900000000    	   591: 	jsr DisplayChar
                            	   592: 
02:00020398 223C00008888    	   593: 	move.l #$00008888,d1		; 32 bpp
02:0002039E 7E06            	   594: 	moveq #6,d7							; framebuf device
02:000203A0 7C21            	   595: 	moveq #DEV_SET_COLOR_DEPTH,d6
02:000203A2 4E40            	   596: 	trap #0
02:000203A4 7E07            	   597: 	moveq #7,d7							; graphics accelerator device
02:000203A6 4E40            	   598: 	trap #0
02:000203A8 223C0F003F63    	   599: 	move.l #$0F003F63,d1		; set burst length, max burst number and interval
02:000203AE 4EB900009724    	   600: 	jsr rbo
02:000203B4 23C1FD200004    	   601: 	move.l d1,FRAMEBUF+4
02:000203BA 123C0043        	   602: 	move.b #'C',d1
02:000203BE 4EB900000000    	   603: 	jsr DisplayChar
                            	   604: 
02:000203C4 47FA006E        	   605: 	LEA		pvariables(pc),a3		; get the variables base address
                            	   606: 
02:000203C8 3681            	   607: 	MOVE.w	d1,quit(a3)			; clear the quit flag
                            	   608: 
02:000203CA 7008            	   609: 	MOVEQ		#8,d0				; get time in 1/100 ths seconds
02:000203CC 4E4F            	   610: 	TRAP		#15
02:000203CE 123C0044        	   611: 	move.b #'D',d1
02:000203D2 4EB900000000    	   612: 	jsr DisplayChar
                            	   613: 
02:000203D8 0A81DEADBEEF    	   614: 	EORI.l	#$DEADBEEF,d1		; EOR with the initial PRNG seed, this must
                            	   615: 							; result in any value but zero
02:000203DE 2741000A        	   616: 	MOVE.l	d1,PRNlword(a3)		; save the initial PRNG seed
                            	   617: 
02:000203E2 4E75            	   618: 	rts
                            	   619: 
                            	   620: 
                            	   621: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   622: ;
                            	   623: ; get a random direction
                            	   624: 
                            	   625: get_direction
02:000203E4 7008            	   626: 	MOVEQ		#8,d0				; set for direction 0 to 7
                            	   627: 
                            	   628: 
                            	   629: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   630: ;
                            	   631: ; get a random number between 0 and d0.w - 1
                            	   632: 
                            	   633: get_prng
02:000203E6 4EB90000BDD2    	   634: 	jsr gen_prng			; call the PRNG code
02:000203EC C0EB000A        	   635: 	MULU.w	PRNlword(a3),d0		; random word times scale
02:000203F0 4240            	   636: 	CLR.w		d0				; clear the low word
02:000203F2 4840            	   637: 	SWAP		d0				; return the high word as the result
02:000203F4 4E75            	   638: 	RTS
                            	   639: 
                            	   640: 
                            	   641: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   642: ;
                            	   643: ; This is the code that generates the pseudo random sequence. A seed word located in
                            	   644: ; PRNlword(a3) is loaded into a register before being operated on to generate the
                            	   645: ; next number in the sequence. This number is then saved as the seed for the next
                            	   646: ; time it's called.
                            	   647: ;
                            	   648: ; This code is adapted from the 32 bit version of RND(n) used in EhBASIC68. Taking
                            	   649: ; the 19th next number is slower but helps to hide the shift and add nature of this
                            	   650: ; generator as can be seen from analysing the output.
                            	   651: 
                            	   652: ;gen_prng
                            	   653: ;	MOVEM.l	d0-d2,-(sp)			; save d0, d1 and d2
                            	   654: ;	MOVE.l	PRNlword(a3),d0		; get current seed longword
                            	   655: ;	MOVEQ		#$AF-$100,d1		; set EOR value
                            	   656: ;	MOVEQ		#18,d2			; do this 19 times
                            	   657: ;Ninc0
                            	   658: ;	ADD.l		d0,d0				; shift left 1 bit
                            	   659: ;	BCC.s		Ninc1				; if bit not set skip feedback
                            	   660: 
                            	   661: ;	EOR.b		d1,d0				; do Galois LFSR feedback
                            	   662: ;Ninc1
                            	   663: ;	DBF		d2,Ninc0			; loop;
                            	   664: 
                            	   665: ;	MOVE.l	d0,PRNlword(a3)		; save back to seed longword
                            	   666: ;	MOVEM.l	(sp)+,d0-d2			; restore d0, d1 and d2
                            	   667: 
                            	   668: ;	RTS
                            	   669: 
                            	   670: 
                            	   671: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   672: ;
                            	   673: ; check the [F2], [F3] and [F4] keys. set the screen size to 640 x 480, 800 x 600 or
                            	   674: ; 1024 x 768 if the corresponding key has been pressed
                            	   675: 
                            	   676: screen_size
02:000203F6 4E75            	   677: 	rts
02:000203F8 223C71007273    	   678: 	MOVE.l	#$71007273,d1		; [F2], [], [F3] and [F4] keys
02:000203FE 7013            	   679: 	MOVEQ		#19,d0			; check for keypress
02:00020400 4E4F            	   680: 	TRAP		#15
                            	   681: 
02:00020402 2401            	   682: 	MOVE.l	d1,d2				; copy result
02:00020404 672C            	   683: 	BEQ.s		pnotscreen			; skip screen size if no F key
                            	   684: 
02:00020406 223C014000F0    	   685: 	MOVE.l	#$028001E0/2,d1		; set 640 x 480
02:0002040C 4A82            	   686: 	TST.l		d2				; test result
02:0002040E 6B10            	   687: 	BMI.s		psetscreen			; if F2 go set window size
                            	   688: 
02:00020410 223C0190012C    	   689: 	MOVE.l	#$03200258/2,d1		; set 800 x 600
02:00020416 4A42            	   690: 	TST.w		d2				; test result
02:00020418 6B06            	   691: 	BMI.s		psetscreen			; if F3 go set window size
                            	   692: 
                            	   693: 							; else was F4 so ..
02:0002041A 223C02000180    	   694: 	MOVE.l	#$04000300/2,d1		; set 1024 x 768
                            	   695: psetscreen
02:00020420 B2AB0004        	   696: 	CMP.l		width(a3),d1		; compare with current screen size
02:00020424 670C            	   697: 	BEQ.s		.0001			; if already set skip setting it now
                            	   698: 
02:00020426 D281            	   699: 	ADD.l		d1,d1				; make it the full size
02:00020428 7021            	   700: 	MOVEQ 	#33,d0			; get/set window size
02:0002042A 4E4F            	   701: 	TRAP		#15
                            	   702: 
02:0002042C 70FF            	   703: 	MOVEQ		#-1,d0			; set the longword
02:0002042E 37400002        	   704: 	MOVE.w	d0,redraw(a3)		; set the redraw flag
                            	   705: .0001
                            	   706: pnotscreen:
02:00020432 4E75            	   707: 	rts
                            	   708: 
                            	   709: 
                            	   710: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   711: ;
                            	   712: ; variables
                            	   713: 
                            	   714: pvariables
                            	   715: 
                            	   716: 	OFFSET	0				; going to use relative addressing
                            	   717: 
                            	   718: ;PRNlword
                            	   719: ;	ds.l	1					; PRNG seed long word
                            	   720: quit
03:00000000 0000            	   721: 	ds.w	1					; quit flag
                            	   722: redraw
03:00000002 0000            	   723: 	ds.w	1					; redraw the world flag
                            	   724: 
                            	   725: width
03:00000004 0000            	   726: 	ds.w	1					; screen width
                            	   727: height
03:00000006 0000            	   728: 	ds.w	1					; screen height
                            	   729: 
                            	   730: num_plants
03:00000008 0000            	   731: 	ds.w	1					; the number of plants
                            	   732: max_plants
03:0000000A 0000            	   733: 	ds.w	1					; the maximum number of plants
                            	   734: 
                            	   735: num_animals
03:0000000C 0000            	   736: 	ds.w	1					; the number of animals
                            	   737: max_animals
03:0000000E 0000            	   738: 	ds.w	1					; the maximum number of animals
                            	   739: 
                            	   740: plant_colour
03:00000010 0000            	   741: 	ds.w	1					; plant colour
                            	   742: plant_fill
03:00000012 0000            	   743: 	ds.w	1					; plant overfill
                            	   744: 
                            	   745: animal_colour
03:00000014 00000000        	   746: 	ds.l	1					; animal colour
                            	   747: animal_fill
03:00000018 00000000        	   748: 	ds.l	1					; animal overfill
                            	   749: 
                            	   750: thing_colour
03:0000001C 00000000        	   751: 	ds.l	1					; the colour of things
                            	   752: fill_colour
03:00000020 00000000        	   753: 	ds.l	1					; the colour that things leave
                            	   754: food_colour
03:00000024 00000000        	   755: 	ds.l	1					; the colour that things eat
                            	   756: poison_colour
03:00000028 00000000        	   757: 	ds.l	1					; the colour that kills things
                            	   758: 
                            	   759: plant_xy
03:0000002C 0000            	   760: 	ds.w	def_plants*2			; plant x,y positions
03:0000002E *
                            	   761: plant_flag
03:000000F4 00              	   762: 	ds.b	def_plants				; plant active flags
03:000000F5 *
                            	   763: 
                            	   764: animal_xy
03:00000126 0000            	   765: 	ds.w	def_animals*2			; animal x,y positions
03:00000128 *
                            	   766: animal_flag
03:000001EE 00              	   767: 	ds.b	def_animals				; animal active and state
03:000001EF *
                            	   768: 
                            	   769: plant_spawn
03:00000220 00              	   770: 	ds.b	1					; the space count at which a plant reproduces
                            	   771: animal_spawn
03:00000221 00              	   772: 	ds.b	1					; the leaf count at which a animal reproduces
                            	   773: 
                            	   774: 	ds.w	0					; ensure even
                            	   775: 
                            	   776: 
                            	   777: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   778: 
                            	   779: 	END		start_plants
                            	   780: 
                            	   781: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   782: 

Source: "boot.x68"
                            	  4154: 


Symbols by name:
ABCD_INNER1                     00:000049D0
ABCD_INNER2                     00:00004A3E
ABCD_NO_C1                      00:000049EC
ABCD_NO_C2                      00:000049F4
ABCD_NO_C3                      00:00004A5A
ABCD_NO_C4                      00:00004A62
ABCD_OUTER1                     00:000049CE
ABCD_OUTER2                     00:00004A3C
ABS                             00:00007388
ACIA                             E:FD060000
ACIA_CMD                         E:00000008
ACIA_CTRL                        E:0000000C
ACIA_RX                          E:00000000
ACIA_STAT                        E:00000004
ACIA_TX                          E:00000000
ADDA_OUTER1                     00:0000553E
ADDQ_LOOP1                      00:00004D58
ADDQ_LOOP2                      00:00004D96
ADDQ_LOOP3                      00:00004DCC
ADDX_LOOP3                      00:00005664
ADDX_LOOP4                      00:00005680
ADDX_LOOP5                      00:0000569C
ADDX_OUTER1                     00:000055D0
ADD_OUTER1                      00:00005364
ADD_OUTER2                      00:000053D8
AHOW                            00:00007600
ALL_DONE                        00:00002732
AND_OUTER1                      00:00005082
AND_OUTER2                      00:000050F6
ASORRY                          00:000075F8
AUXIN                           00:00007924
AUXOUT                          00:00007910
AWHAT                           00:000075B8
AXIRET                          00:00007942
AllocateString                  00:000070A0
ArmAllBreakpoints               00:00009934
ArmBreakpoint                   00:00009964
AsciiToHexNybble                00:00009370
AudioInputTest                  00:00009716
BCC1                            00:00004C76
BCC10                           00:00004CC8
BCC11                           00:00004CD0
BCC12                           00:00004CDA
BCC13                           00:00004CE2
BCC14                           00:00004CEC
BCC2                            00:00004C80
BCC3                            00:00004C88
BCC4                            00:00004C92
BCC5                            00:00004C9A
BCC6                            00:00004CA4
BCC7                            00:00004CAC
BCC8                            00:00004CB6
BCC9                            00:00004CBE
BLANK                            E:00000020
BRTBL                           00:0000A32C
BSR_CLOSE1                      00:00003806
BSR_CLOSE2                      00:0000383C
BSR_FAR1                        00:00002734
BSR_FAR2                        00:00004C66
BUFFER                          00:00007A14
BUFLEN                           E:00000050
BUFSIZE                          E:0000003F
BYEBYE                          00:00007944
BlankLastLine                   00:00001464
BouncingBalls                   00:00009718
BreakpointWords                  E:00040280
Breakpoints                      E:00040220
BufByte                         00:000093FC
BufNybble                       00:00009402
BufTetra                        00:000093F0
BufWyde                         00:000093F6
CALL                            00:00006ACE
CHKIO                           00:000078B6
CHKRET                          00:000078C6
CHR                             00:00007532
CLMSG                           00:000079AC
CLS                             00:000078D4
CMPA_OUTER1                     00:00005258
CMPM_LOOP1                      00:000052E6
CMPM_LOOP2                      00:00005300
CMPM_LOOP3                      00:0000531A
CMP_OUTER1                      00:000051E2
COLOR                           00:00006B38
COLOR1                          00:00006B4C
COLOR2                          00:00006B44
COLOR3                          00:00006B52
COLORERR                        00:00006BAC
COLORERR1                       00:00006BB2
COLORERR2                       00:00006BB8
COMMON                          00:0000A71E
COMMON35                        00:0000A72C
COMMON4                         00:0000A71C
COM_CMDTBL                      00:00001544
CORENO                          00:000073B0
CR                               E:0000000D
CRLF                            00:00007ACA
CS11                            00:0000A162
CS12                            00:0000A0D2
CS13                            00:0000A058
CS14                            00:00009FEE
CS15                            00:00009FB0
CS16                            00:00009F42
CS17                            00:0000A2F8
CS18                            00:0000A294
CS19                            00:0000A3A4
CS20                            00:0000A1FC
CSTART                          00:000061C4
CTRLC                            E:00000003
CTRLH                            E:00000008
CTRLS                            E:00000013
CTRLX                            E:00000018
CTRLZ                            E:0000001A
CURRNT                          00:000079BC
CURVE                           00:00006CFE
CalcScreenLoc                   00:00001238
CallOS                          00:00000240
CheckForCtrlC                   00:000008AE
CheckForKey                     00:00000868
CheckNumeric                    00:00006E10
ClearBreakpointList             00:00009A56
ClearScreen                     00:0000971C
ClearStringArea                 00:000062F0
ClearStringStack                00:00006310
CmdBuf                           E:00040040
CmdBufEnd                        E:00040080
ConcatString                    00:00006F1C
Cursor1                         00:00007F9A
DBCC_LOOP1                      00:00004CF6
DBCC_LOOP2                      00:00004D04
DCB_BKCOLOR                      E:00000060
DCB_CMDPROC                      E:00000018
DCB_FGCOLOR                      E:00000064
DCB_INBUFPTR                     E:00000038
DCB_INBUFPTR2                    E:00000070
DCB_INBUFSIZE                    E:00000040
DCB_INDIMX                       E:00000048
DCB_INDIMY                       E:0000004C
DCB_INDIMZ                       E:00000050
DCB_INPOSX                       E:0000002C
DCB_INPOSY                       E:00000030
DCB_INPOSZ                       E:00000034
DCB_MAGIC                        E:00000000
DCB_NAME                         E:00000004
DCB_OPCODE                       E:00000068
DCB_OUTBUFPTR                    E:0000003C
DCB_OUTBUFPTR2                   E:00000074
DCB_OUTBUFSIZE                   E:00000044
DCB_OUTBUFSIZE2                  E:0000007C
DCB_OUTDIMX                      E:00000054
DCB_OUTDIMY                      E:00000058
DCB_OUTDIMZ                      E:0000005C
DCB_OUTPOSX                      E:00000020
DCB_OUTPOSY                      E:00000024
DCB_OUTPOSZ                      E:00000028
DCB_SIZE                         E:00000084
DCB_UNIT                         E:00000080
DCODE68K                        00:0000A684
DDATA                            E:FFFFFFF0
DEC311                          00:0000A698
DEC404                          00:0000A6B6
DEC411                          00:0000A6C6
DEC425                          00:0000A6D6
DEC510                          00:0000A6E2
DEC515                          00:0000A6E6
DEC530                          00:0000A6EE
DEC535                          00:0000A6F4
DEC537                          00:0000A700
DEFLT                           00:0000695E
DEV_CLEAR                        E:0000000C
DEV_DRAW_CURVE                   E:0000001F
DEV_DRAW_LINE                    E:0000001C
DEV_DRAW_RECTANGLE               E:0000001E
DEV_DRAW_TRIANGLE                E:0000001D
DEV_GETBUF1                      E:00000010
DEV_GET_DIMEN                    E:00000014
DEV_GET_OUTPOS                   E:00000017
DEV_GET_OUTPTR                   E:00000018
DEV_PLOT_POINT                   E:0000001B
DEV_PUTCHAR                      E:00000002
DEV_SET_COLOR                    E:00000019
DEV_SET_COLOR_DEPTH              E:00000021
DEV_SET_DESTBUF                  E:00000022
DEV_SET_DIMEN                    E:00000020
DEV_SET_DISPBUF                  E:00000023
DEV_SET_OUTPOS                   E:00000007
DEV_SWAPBUF                      E:0000000D
DEV_WRITEAT                      E:00000012
DIRECT                          00:00006528
DIRFLG                          00:00007A10
DISPBUF                         00:00006B28
DIV1                            00:000072CC
DIV2                            00:000072D2
DIV3                            00:000072D8
DIV32                           00:000072BA
DIV4                            00:000072E6
DIVRT                           00:000072F4
DIVS_OUTER1                     00:00004F42
DIVU_OUTER1                     00:00004EF0
DOMID                           00:00007460
DOQUO                           00:00007894
DOQUO1                          00:0000789C
DRAW                             E:0000A000
DRAWBUF                         00:00006B18
DT_NUMERIC                       E:00000001
DT_STRING                        E:00000002
Delay3s                         00:00002614
Delay3s2                        00:00002638
Diagonal1                       00:00007E1E
Diagonal2                       00:00007E3E
DisarmAllBreakpoints            00:00009908
DisarmBreakpoint                00:000099E2
DispatchMsg                     00:00009AE8
DisplayAddr                     00:0000941A
DisplayByte                     00:000093D0
DisplayChar                     external
DisplayHelp                     00:000083CA
DisplayMem                      00:00008C84
DisplayNybble                   00:000093D6
DisplaySpace                    00:000093BC
DisplayString                   00:00007AE4
DisplayStringCRLF               00:00007AFA
DisplayStringLimited            00:00007AFE
DisplayStringLimitedCRLF        00:00007B1E
DisplayTetra                    00:000093C4
DisplayTwoSpaces                00:000093AA
DisplayWyde                     00:000093CA
DrawHorizTo                     00:00007F38
DrawToXY                        00:00007EBA
DrawVertTo                      00:00007F6A
DumpMem1                        00:00008C72
EA000                           00:0000A3D4
EA001                           00:0000A3E0
EA010                           00:0000A3EC
EA011                           00:0000A400
EA011RTS                        00:0000A416
EA100                           00:0000A418
EA101                           00:0000A4BA
EA1105                          00:0000A496
EA1107                          00:0000A49A
EA1109                          00:0000A4B0
EA111                           00:0000A4D0
EA1112                          00:0000A4EE
EA1113                          00:0000A50A
EA1113A                         00:0000A51A
EA1114                          00:0000A53C
EA1115                          00:0000A5A6
EA11153                         00:0000A5DE
EA11155                         00:0000A5E8
EAF25                           00:0000A584
EAF27                           00:0000A588
EAF35                           00:0000A59C
EEA                             00:0000A432
EEA10                           00:0000A060
ENDCHK                          00:000075A4
ENDCHK1                         00:000075B4
ENDMEM                          00:000061C0
EOR_OUTER2                      00:0000516C
EOT                              E:00000004
ERROR                           00:000075BC
ESC                              E:0000001B
ETYPE                           00:00007606
EX1                             00:00006562
EXCEPTION_6                     00:0000273C
EXCEPTION_7                     00:00002744
EXEC                            00:00006538
EXGO                            00:0000656E
EXLP                            00:00006540
EXMAT                           00:00006568
EXNGO                           00:0000654A
EXP4RT                          00:00007010
EXPR                            00:00006DBC
EXPR2                           00:00006EAC
EXPR3                           00:00006F8A
EXPR4                           00:00006FF4
EXPR_AND                        00:00006DE2
EXPR_OR                         00:00006DBC
EXPR_REL                        00:00006E22
E_BadDevNum                      E:00000020
E_Func                           E:00000002
E_NotAlloc                       E:00000009
E_NotSupported                   E:0000000A
E_Ok                             E:00000000
EditMemHelper                   00:000087CE
ExecuteCode                     00:00008864
FDATA                            E:0000000A
FE10                            00:0000A42E
FE11                            00:0000A516
FE12                            00:0000A6D4
FERROR                          00:0000A746
FERROR35                        00:0000A750
FERROR39                        00:0000A75C
FI1                             00:00007596
FI2                             00:000075A2
FIN                             00:0000758A
FINISH                          00:00006746
FMTK_SEMA                        E:00000008
FNDLN                           00:000076AA
FNDLNP                          00:000076B8
FNDNXT                          00:000076D0
FNDRET                          00:000076CE
FNDSKP                          00:000076D2
FOC                              E:0000001F
FOP                              E:00000027
FOR                             00:000067B4
FORM1                           00:00009FE6
FORM10                          00:0000A0A2
FORM103                         00:0000A0A8
FORM104                         00:0000A0AC
FORM105                         00:0000A0BC
FORM10E3                        00:0000A086
FORM10E4                        00:0000A08E
FORM10E6                        00:0000A09A
FORM10EX                        00:0000A064
FORM11                          00:0000A0D6
FORM112                         00:0000A0F2
FORM114                         00:0000A100
FORM11SL                        00:0000A0DE
FORM12                          00:0000A102
FORM125                         00:0000A11C
FORM12A                         00:0000A13E
FORM1A                          00:00009FEA
FORM3                           00:00009FF0
FORM4                           00:00009FF4
FORM5                           00:0000A006
FORM6A                          00:0000A00A
FORM6D                          00:0000A01A
FORM7                           00:0000A040
FORM8                           00:0000A04C
FORM815                         00:0000A050
FORM9                           00:0000A05A
FORM91                          00:0000A3BC
FORM93                          00:0000A3D0
FORM95                          00:0000A3D2
FORMREG5                        00:0000A02E
FORMREGA                        00:0000A02A
FORMREGD                        00:0000A03A
FORMSIZE                        00:0000A3A8
FR1                             00:000067CE
FR2                             00:000067E6
FR3                             00:000067EC
FR4                             00:000067F2
FR5                             00:000067FA
FR6                             00:0000680C
FR7                             00:00006818
FR8                             00:00006830
FRAMEBUF                         E:FD200000
FRAMEBUF_BMPSIZE_X               E:00000068
FRAMEBUF_BMPSIZE_Y               E:0000006C
FRAMEBUF_CMDTBL                 00:000018C4
FRAMEBUF_COLOR_COMP              E:00000098
FRAMEBUF_CTRL                    E:00000000
FRAMEBUF_PAGE1_ADDR              E:00000010
FRAMEBUF_PAGE2_ADDR              E:00000018
FRAMEBUF_PPS                     E:000000B0
FRAMEBUF_WINDOW_DIMEN            E:00000078
FREL10                          00:00009EAA
FREL15                          00:00009EBC
FREL20                          00:00009ED6
FREL25                          00:00009EE8
FREL30                          00:00009EF2
FRELADDR                        00:00009E9C
FemtikiInit                     00:00000220
FemtikiInitIRQ                  00:00000230
FemtikiTimerIRQ                 00:0000030E
ForceUnlockSemaphore            00:000025A0
FreeTCB                          E:0010030C
FromScreen                      00:00008124
GBYTE                           00:000069B6
GBYTE1                          00:000069BA
GBYTE2                          00:000069C8
GETLN                           00:0000760C
GFXACCEL                         E:FD300000
GFXACCEL_CMDTBL                 00:00001DEC
GFX_CLIP_PIXEL0_X                E:00000074
GFX_CLIP_PIXEL0_Y                E:00000078
GFX_CLIP_PIXEL1_X                E:0000007C
GFX_CLIP_PIXEL1_Y                E:00000080
GFX_COLOR0                       E:00000084
GFX_COLOR1                       E:00000088
GFX_COLOR2                       E:0000008C
GFX_COLOR_COMP                   E:000000D0
GFX_CTRL                         E:00000000
GFX_DEST_PIXEL_X                 E:00000038
GFX_DEST_PIXEL_Y                 E:0000003C
GFX_DEST_PIXEL_Z                 E:00000040
GFX_PPS                          E:000000D4
GFX_STATUS                       E:00000004
GFX_TARGET_BASE                  E:00000010
GFX_TARGET_SIZE_X                E:00000014
GFX_TARGET_SIZE_Y                E:00000018
GFX_TARGET_X0                    E:000000B0
GFX_TARGET_X1                    E:000000B8
GFX_TARGET_Y0                    E:000000B4
GFX_TARGET_Y1                    E:000000BC
GL1                             00:0000761C
GL2                             00:0000763A
GL3                             00:0000764E
GL4                             00:00007672
GL5                             00:0000767E
GL6                             00:0000769A
GL7                             00:000076A2
GOAUXI                          00:000061B4
GOAUXO                          00:000061B0
GOBYE                           00:000061B8
GOIN                            00:000061AC
GOOUT                           00:000061A8
GOSUB                           00:0000674E
GOTO                            00:00006650
GOWARM                          00:000061A4
GRBufferToScreen                00:00007D76
GarbageCollectStrings           00:000070FE
GetCmdLine                      00:00008594
GetDecNumber                    00:00008E16
GetHexNumber                    00:00008DE8
GetKey                          00:00000874
GetRunningTCBPointer            00:000002AA
GetSzChar                       00:000087A8
GetTick                         00:00007CDC
GlobalReadLong                  00:000023CE
GlobalWriteLong                 00:000023D4
GraphicsDemo                    00:0000971A
HALT                             E:0000B000
HAS_MMU                          E:00000000
HEX2DEC                         00:00009E24
HEX2DEC2                        00:00009DD6
HISPC                            E:FFFFFFFC
HOWMSG                          00:0000797D
HX2DC                           00:00009E34
HX2DC0                          00:00009E38
HX2DC1                          00:00009E40
HX2DC2                          00:00009E5A
HX2DC22                         00:00009E5C
HX2DC3                          00:00009E66
HX2DC4                          00:00009E6E
HX2DC5                          00:00009E76
HX2DC57                         00:00009E7E
HX2DC6                          00:00009E82
HelpMsg                         00:000083D6
HomeCursor                      00:000014BE
I2C2                             E:FD069000
I2C_CMD                          E:00000004
I2C_CTRL                         E:00000002
I2C_PREH                         E:00000001
I2C_PREL                         E:00000000
I2C_RXR                          E:00000003
I2C_STAT                         E:00000004
I2C_TXR                          E:00000003
IBSR                            00:0000A24E
ICC                             00:0000A24A
ICC35                           00:0000A260
ICC55                           00:0000A276
ICCCC                           00:0000A314
ICCCC9                          00:0000A32A
IDBCC                           00:0000A238
IF                              00:000068A0
IF1                             00:000068A4
IF2                             00:000068AA
IGNBLK                          00:00007862
ILINK                           00:00009FD0
IM7788                          00:00009F0E
IM7799                          00:00009F12
IMMED                           00:00009F58
IMMED45                         00:00009F7E
IMMED55                         00:00009FB2
IMMED65                         00:00009FB8
IMMED75                         00:00009FC8
IMOVE                           00:00009FCC
IMOVE19                         00:0000A372
IMOVEA1                         00:0000A34C
IMOVEMFR                        00:00009EFA
IMOVEMTR                        00:00009F28
IMOVEP                          00:0000A1D4
IMOVEP11                        00:0000A1E4
IMOVEP35                        00:0000A200
IMOVEP66                        00:0000A20E
IMOVEQ                          00:0000A16A
IMVFSR                          00:0000A18A
IMVFUSP                         00:0000A198
IMVT44                          00:0000A1B4
IMVTCCR                         00:0000A1C4
IMVTSR                          00:0000A1A6
IMVTUSP                         00:0000A1B8
INC                             00:000078F0
INC1                            00:000078FC
INCOM                           00:00006580
INCON                           00:00006572
INITMSG                         00:00007952
INPERR                          00:000068BA
INPPTR                          00:000079B4
INPUT                           00:000068C8
INT                             00:0000751C
INT_EXPR                        00:00006DAA
IOCOM                           00:0000658E
IOCON                           00:000065A4
IOFocus                          E:00100000
IP2                             00:000068FA
IP3                             00:00006914
IP4                             00:0000694E
IP5                             00:0000695A
IP6                             00:000068F6
IP7                             00:000068EC
IQUICK                          00:0000A166
IQUICK21                        00:0000A38A
IQUICK31                        00:0000A3A0
IQUICKA                         00:0000A378
IRQFlag                          E:000400A0
IRQROUT                         00:000079F0
IRQ_trampolines                 01:00000100
ISCC                            00:0000A22E
ISETD                           00:0000A286
ISETD12                         00:0000A28C
ISETS                           00:0000A296
ISHIFT                          00:0000A2B0
ISHIFT13                        00:0000A2BC
ISHIFT23                        00:0000A2E0
ISHIFT33                        00:0000A2EC
ISHIFT44                        00:0000A2F0
ISHIFTM1                        00:0000A2FA
ISTOP                           00:00009F44
IncCursorPos                    00:000013DA
IncCursorRow                    00:000013F4
InitIOPBitmap                   00:000023DC
InitIRQ                         00:00009BA4
InitRand                        00:00002428
InitSemaphores                  00:00002558
Initialise                      00:0000BD4E
InitialisePlants                 A:0002036A
InputDevice                      E:000400A4
InstallIRQ                      00:00009BBC
JMPL                             E:0000E000
JSRL                             E:0000C000
KBD_CMDTBL                      00:000005EC
KEYBD                            E:FD0FFE00
KEYBD_SEMA                       E:00000003
KI                              00:0000A770
KIEND                           00:0000A772
KeybdEcho                        E:0004000C
KeybdGetChar                    00:000008CE
KeybdGetCharNoWait              00:000008BE
KeybdGetCharWait                00:000008C6
KeybdGetID                      00:0000064A
KeybdID                          E:00100018
KeybdIRQ                        00:00000B7A
KeybdInit                       00:000006B4
KeybdLEDs                        E:0010000E
KeybdRecvByte                   00:00000818
KeybdSendByte                   00:00000B3A
KeybdSetLED                     00:00000688
KeybdSetLEDStatus               00:00000AEA
KeybdWaitFlag                    E:0004000D
KeybdWaitTx                     00:0000083A
LEA1                            00:00004212
LEFT                            00:000074C2
LEN                             00:000074F6
LET                             00:00006966
LF                               E:0000000A
LINE                            00:00006BE6
LINEERR                         00:00006C28
LINEERR1                        00:00006C2C
LINEERR2                        00:00006C32
LIST                            00:00006698
LOAD                            00:00006976
LOCVARSZ                         E:00000010
LOD1                            00:00006982
LOD2                            00:0000699C
LODEND                          00:000069AC
LOPINC                          00:000079D0
LOPLMT                          00:000079DC
LOPLN                           00:000079E8
LOPPT                           00:000079EC
LOPVAR                          00:000079CC
LS1                             00:000066A4
LS2                             00:000066B8
LS3                             00:000066BE
LSTROM                          00:000079B0
LT1                             00:00006972
LastStr                         00:00007A00
ListBreakpoints                 00:00009A36
LockSemaphore                   00:0000257E
LockSysSemaphore                00:00000396
LorR1                           00:000073F4
LorRArgs                        00:000073BC
MAX_TID                          E:00000FFF
MEMORY_SEMA                      E:00000006
MID                             00:000073F8
MID1                            00:000074BE
MID2                            00:00007440
MID4                            00:0000748C
MID5                            00:00007458
MMU                              E:FDC00000
MOVE1                           00:00003E80
MOVE2                           00:00003E04
MOVE3                           00:00003F00
MOVE4                           00:0000405A
MOVEMR                          00:0000A608
MOVEMR11                        00:0000A618
MOVEMR33                        00:0000A620
MOVEMR44                        00:0000A632
MOVEMR77                        00:0000A64C
MOVEMR79                        00:0000A65E
MOVEMR88                        00:0000A660
MOVEMR94                        00:0000A678
MOVEMS                          00:0000A5F4
MOVEMS2                         00:0000A604
MSG111                          00:0000A766
MULS_OUTER1                     00:00005838
MULU_OUTER1                     00:000057EC
MVDOWN                          00:000076F4
MVRET                           00:000076E8
MVUP                            00:000076E0
MVUPW                           00:000076EA
Monitor                         00:00008138
MoveToXY                        00:00007EAC
NBCD_LOOP                       00:00004BB6
NBCD_LOOP1                      00:00004BFC
NBCD_NO_C                       00:00004BC2
NBCD_NO_C1                      00:00004C10
NBCD_NO_Z                       00:00004BC6
NBCD_NO_Z1                      00:00004C14
NCORES                           E:00000004
NEW                             00:000065BA
NEXT                            00:00006834
NOSTRING                        00:00007994
NR_TCB                           E:00001000
NUM_EXPR                        00:00006D9C
NX0                             00:0000683E
NX1                             00:0000687E
NX2                             00:00006896
NX3                             00:00006850
NextRec                         00:00009508
NextString                      00:0000713A
Ninc0                           00:0000BDE2
Ninc1                           00:0000BDE2
NumSetBreakpoints                E:00040202
OFFSET                           E:00040880
OKMSG                           00:00007976
ONIRQ                           00:00006664
ONIRQ1                          00:0000667E
OPCTBL                          00:0000AA2A
OR_OUTER1                       00:00004F98
OR_OUTER2                       00:0000500C
OSCallTable                     00:0000023E
OUTC                            00:000078E0
OUTCOM                          00:00006598
OUTCON                          00:000065AE
OUTPTR                          00:000079B8
OutputChar                      00:00009B8A
OutputDevice                     E:000400A8
PARN                            00:0000708A
PBYTE                           00:00006A34
PBYTE1                          00:00006A36
PBYTE2                          00:00006A4A
PEEK                            00:000072F6
PKER                            00:00006ACA
PLIC                             E:FD090000
PNT4HEX                         00:00009E88
PNT4HX                          00:00009E88
PNT6HX                          00:00009E8C
PNT8HX                          00:00009E98
POINT                           00:00006BC0
POINTERR                        00:00006BE2
POKE                            00:00006A54
POPA                            00:000076FC
PR0                             00:000066E2
PR1                             00:000066F0
PR2                             00:000066D4
PR3                             00:000066FE
PR6                             00:0000670A
PR8                             00:00006710
PR9                             00:0000672C
PRINT                           00:000066C4
PRMESG                          00:000078C8
PRMRET                          00:000078D2
PRNlword                         S:0000000A
PRTLN                           00:000077E0
PRTNUM                          00:00007796
PRTRET                          00:00007788
PRTSTG                          00:0000776E
PRTSTR2                         00:00007790
PRTSTR2a                        00:0000778A
PS1                             00:00007770
PUSHA                           00:00007738
PeekScreenChar                  00:000087A2
PointsIntoStringArea            00:00007196
ProcessBreakpoint               00:00009902
ProcessRec                      00:0000951A
ProcessS1                       00:0000961E
ProcessS2                       00:00009622
ProcessS3                       00:00009626
ProcessS7                       00:0000962A
ProcessS8                       00:0000963C
ProcessS9                       00:0000964E
Prompt1                         00:0000817A
Prompt3                         00:00008164
PromptLn                        00:00008158
QHOW                            00:000075FE
QSORRY                          00:000075F6
QWHAT                           00:000075B6
QueueCycle                       E:0010031C
RAND                             E:FD0FFD00
RAND_MW                          E:FD0FFD0C
RAND_MZ                          E:FD0FFD08
RAND_NUM                         E:FD0FFD00
RAND_SEMA                        E:00000004
RAND_STRM                        E:FD0FFD04
RANPNT                          00:000079B0
RECT                            00:00006C38
REL4                             E:00004000
REL5                             E:00005000
REL7                             E:00007000
REM                             00:0000689E
RETURN                          00:00006788
RIGHT                           00:000074CE
RND                             00:0000735E
ROXx_FLAGS                      00:00005B00
ROXx_LOOP1                      00:00005B16
ROXx_LOOP2                      00:00005B36
ROXx_LOOP3                      00:00005B56
ROXx_LOOP4                      00:00005B76
ROXx_LOOP5                      00:00005B96
ROXx_LOOP6                      00:00005BB8
ROx_FLAGS                       00:000058CA
ROx_LOOP1                       00:000058E0
ROx_LOOP2                       00:00005900
ROx_LOOP3                       00:00005920
ROx_LOOP4                       00:00005940
ROx_LOOP5                       00:00005960
ROx_LOOP6                       00:00005982
RST_REG                          E:FD0FFC00
RTCBuf                           E:00100200
RTR_DONE                        00:00004C58
RTSL                             E:0000D000
RUN                             00:000065D6
RUN1                            00:0000662A
RUNNXL                          00:000065EA
RUNSML                          00:00006640
RUNTSL                          00:00006636
RandGetNum                      00:00002492
RandInit                        00:00002428
RandWait                        00:00002540
ReceiveMsg                      00:00009AA6
Regsave                          E:00040100
RunningTCB                       E:00100224
S1932a                          00:00009698
S1932b                          00:000096AC
S19Checksum                      E:00100150
S19Get16BitAddress              00:00009660
S19Get24BitAddress              00:0000966E
S19Get32BitAddress              00:0000967A
S19StartAddress                  E:00040008
SAVE                            00:000069D6
SAVE1                           00:000069DE
SAVE2                           00:00006A02
SAVEND                          00:00006A10
SBCD_INNER1                     00:00004AC8
SBCD_INNER2                     00:00004B36
SBCD_NO_C1                      00:00004AE4
SBCD_NO_C2                      00:00004AEC
SBCD_NO_C3                      00:00004B52
SBCD_NO_C4                      00:00004B5A
SBCD_OUTER1                     00:00004AC6
SBCD_OUTER2                     00:00004B34
SCHR                            00:0000A182
SCOMMON                         00:0000A22A
SCREEN_FORMAT                    E:00000001
SCREEN_SEMA                      E:00000005
SC_ALT                           E:00000011
SC_CAPSLOCK                      E:00000058
SC_CTRL                          E:00000014
SC_EXTEND                        E:000000E0
SC_KEYUP                         E:000000F0
SC_LSHIFT                        E:00000012
SC_NUMLOCK                       E:00000077
SC_RSHIFT                        E:00000059
SC_SCROLLLOCK                    E:0000007E
SC_TAB                           E:0000000D
SERIAL_SEMA                      E:00000002
SETVAL                          00:0000756A
SHIFTS2_FLAGS                   00:00005F78
SHIFTS2_LOOP1                   00:00005F8E
SHIFTS2_LOOP2                   00:00005FAA
SHIFTS2_LOOP3                   00:00005FC6
SHIFTS2_LOOP4                   00:00005FE2
SHIFTS2_LOOP5                   00:00005FFE
SHIFTS2_LOOP6                   00:0000601C
SHIFTS_FLAGS                    00:00005D36
SHIFTS_LOOP1                    00:00005D4C
SHIFTS_LOOP2                    00:00005D6C
SHIFTS_LOOP3                    00:00005D8C
SHIFTS_LOOP4                    00:00005DAC
SHIFTS_LOOP5                    00:00005DCC
SHIFTS_LOOP6                    00:00005DEE
SHRT                             E:0000F000
SIV1                            00:0000716E
SIZE                            00:00007394
SRYMSG                          00:000079A6
ST3                             00:00006264
ST4                             00:000062B6
START                           00:000061A2
STKFP                           00:000079C0
STKGOS                          00:000079C4
STKINP                          00:000079C8
STKLMT                          00:00007A0C
STOP                            00:000065CE
STRAREASIZE                      E:00000800
STRSTK                          00:000079F4
SUBA_OUTER1                     00:0000558A
SUBQ_LOOP1                      00:00004E16
SUBQ_LOOP2                      00:00004E50
SUBQ_LOOP3                      00:00004E86
SUBX_LOOP3                      00:00005774
SUBX_LOOP4                      00:00005790
SUBX_LOOP5                      00:000057AC
SUBX_OUTER1                     00:000056E0
SUB_OUTER1                      00:0000544E
SUB_OUTER2                      00:000054C2
SV1                             00:00007588
ScrollUp                        00:0000141E
SelectThreadToRun               00:000002C2
SendMsg                         00:00009A68
SerHeadRcv                       E:00100162
SerHeadXmit                      E:00100168
SerRcvBuf                        E:00101000
SerRcvXoff                       E:00100165
SerRcvXon                        E:00100164
SerTailRcv                       E:00100160
SerTailXmit                      E:00100166
SerXmitBuf                       E:00102000
SerXmitXoff                      E:0010016A
SerialGetChar                   00:0000166E
SerialIRQ                       00:000017E4
SerialInit                      00:00001630
SerialPeekChar                  00:000016E6
SerialPeekCharDirect            00:00001722
SerialPutChar                   00:0000173C
SerialPutCharDirect             00:000017A0
SerialRbo                       00:000017BC
SerialRcvCount                  00:000017C4
SetDrawMode                     00:00007D00
SetKeyboardEcho                 00:00000860
SetPenColor                     00:00007D22
ShiftBuf                        00:00009DBC
SimHardware                     00:00007CCC
SpuriousIRQ                     00:00009C74
StartMon                        00:0000812E
StartQ                          00:00000172
StrArea                         00:000079FC
StrSp                           00:000079F8
StringInVar                     00:00007150
StringOnStack                   00:000071BA
StubRout                        00:00007FD2
SyncCursor                      00:000014D0
T15Abort                        00:000025F0
T15DispatchTable                00:00007B3C
T15FloatToString                00:00009B30
T15GetFloat                     00:000025E2
T15GetPixel                     00:00007D40
T15GetWindowSize                00:00007D60
T15LockSemaphore                00:000025D6
T15Rectangle                    00:00007D2E
T15UnlockSemaphore              00:000025DC
T15Wait100ths                   00:00007CE4
TAB1                            00:00006324
TAB10                           00:00006405
TAB10_1                         00:00006510
TAB11                           00:00006408
TAB11_1                         00:00006518
TAB12                           00:0000640D
TAB12_1                         00:00006520
TAB1_1                          00:00006414
TAB2                            00:00006353
TAB2_1                          00:00006444
TAB4                            00:000063BC
TAB4_1                          00:000064A8
TAB5                            00:000063EE
TAB5_1                          00:000064DC
TAB6                            00:000063F1
TAB6_1                          00:000064E4
TAB8                            00:000063F6
TAB8_1                          00:000064EC
TAB9                            00:00006401
TAB9_1                          00:00006508
TBL                             00:0000A772
TBLE                            00:0000AA2A
TC1                             00:00007810
TCBAffineChose                  00:000000A0
TCBAffinity                      E:00000084
TCBAffinityBase                  E:00000082
TCBAlloc                        00:0000006E
TCBEndTick                       E:00000070
TCBFree                         00:00000092
TCBHandleToPointer              00:00000028
TCBIAlloc                       00:00000050
TCBIFree                        00:0000007C
TCBInit                         00:00000000
TCBInsertIntoReadyQueue         00:000000D8
TCBNext                          E:0000007C
TCBPC                            E:00000050
TCBPointerToHandle              00:00000040
TCBPopReadyQueue                00:0000017A
TCBPrev                          E:00000080
TCBPriority                      E:00000055
TCBRegs                          E:00000004
TCBRemoveFromReadyQueue         00:00000150
TCBSR                            E:0000004C
TCBSSP                           E:00000048
TCBStartTick                     E:0000006C
TCBStatus                        E:00000054
TCBTicks                         E:00000074
TCBUSP                           E:00000044
TCB_SIZE                         E:00000100
TEXT                            00:00006AE4
TEXTCOL                          E:00000030
TEXTERR                         00:00006B14
TEXTREG                          E:FD080000
TEXTROW                          E:00000020
TEXTVID_CMDTBL                  00:00000F30
TICK                            00:000073A4
TOUPB1                          00:00007872
TOUPBRT                         00:00007892
TOUPBUF                         00:0000786C
TOUPPER                         00:000078A4
TOUPRET                         00:000078B4
TRAP15                          00:00007B22
TRIANGLE                        00:00006C7E
TRIERR                          00:00006CDE
TRIERR1                         00:00006CE2
TRIERR2                         00:00006CE8
TRIERR3                         00:00006CEE
TRIERR4                         00:00006CF6
TSTC                            00:000077FE
TSTNUM                          00:00007816
TSTV                            00:00007238
TSTVRT                          00:000072B8
TS_PREEMPT                       E:00000020
TS_RUNNING                       E:00000080
TV1                             00:00007280
TV2                             00:000072B0
TXT                             00:00007A64
TXTBGN                          00:000061BC
TXTUNF                          00:00007A04
TYPMSG                          00:0000798C
TestBitmap                      00:00007D7E
TextCols                         E:0004008D
TextRows                         E:0004008C
TextScr                          E:00040004
TickIRQ                         00:00009C00
TimerStack                       E:00041BFC
USP1                            00:00007216
UnlockSemaphore                 00:000025BA
UnlockSysSemaphore              00:000003A6
UpdateIRQLive                   00:000002EC
UpdateStringPointers            00:000071EA
VARBGN                          00:00007A08
VIDEO_X                          E:00000320
VIDEO_Y                          E:00000258
Vertical1                       00:00007E68
Vertical2                       00:00007E84
WAITIRQ                         00:00006688
WHTMSG                          00:00007984
WSTART                          00:00006230
Wait10ms                        00:00000B42
Wait300ms                       00:00000B5E
X                               00:00009EFA
XOFF                             E:00000013
XON                              E:00000011
XP11                            00:00006E36
XP12                            00:00006E42
XP13                            00:00006E4E
XP14                            00:00006E5A
XP15                            00:00006E66
XP15RT                          00:00006E72
XP16                            00:00006E74
XP17                            00:00006E92
XP18                            00:00006E98
XP21                            00:00006EBA
XP22                            00:00006EC0
XP23                            00:00006EC4
XP24                            00:00006ED2
XP25                            00:00006F00
XP26                            00:00006F06
XP27                            00:00006F1A
XP30                            00:00006F90
XP31                            00:00006F9C
XP34                            00:00006FB2
XP35                            00:00006FCC
XP36                            00:00006F8C
XP40                            00:00007000
XP41                            00:00007012
XP42                            00:0000709A
XP43                            00:0000709C
XP44                            00:0000707E
XP45                            00:0000702C
XPRT0                           00:00006E82
XPRT1                           00:00006E8A
XPSTNG                          00:00007022
XP_AND                          00:00006DF4
XP_ANDX                         00:00006E0A
XP_MOD                          00:00006FD2
XP_OR                           00:00006DCC
XP_ORX                          00:00006E0A
XP_POP                          00:00006D70
XP_POP1                         00:00006D86
XP_PUSH                         00:00006D5A
_CheckNan                       00:00008E7C
_CheckNegative                  00:00008EFA
_CheckZero                      00:00008EE0
_ComputeDigitsBeforeDecpt       00:00008F54
_E                               E:0004050C
_ExtExpDigit                    00:00009078
_ExtExpDigits                   00:00009096
_FloatToString                  00:00009140
_GetExponent                    00:000091F8
_GetFloat                       00:000092F8
_GetFloatBackupChar             00:00009190
_GetFloatGetChar                00:00009182
_GetFloatIgnBlanks              00:00009188
_GetFraction                    00:00009194
_GetInteger                     00:00009282
_GetRand                        00:0000251C
_KeyState1                       E:0010000F
_KeyState2                       E:00100010
_KeybdBuf                        E:00100020
_KeybdClearIRQ                  00:00000802
_KeybdCnt                        E:00100013
_KeybdGetScancode               00:000007E4
_KeybdGetStatus                 00:000007C6
_KeybdHead                       E:00100011
_KeybdInit                      00:000006B4
_KeybdOBuf                       E:00100080
_KeybdTail                       E:00100012
_Keybd_tick                      E:0001001C
_LeadingZero                    00:00008F8E
_LessThanDbl                    00:00008F28
_MakeBig                        00:00008F0C
_PadLeft                        00:000090BE
_PadRight                       00:0000910E
_SpitOutDigits                  00:00008F9E
_SpitOutE                       00:00009060
_TrimDotZero                    00:00009038
_TrimTrailingPoint              00:0000901A
_TrimTrailingZeros              00:00009054
_canary                          E:00040098
_dasmbuf                         E:00040800
_dfMil                          00:00008E68
_dfOne                          00:00008E50
_dfTen                          00:00008E5C
_digits_before_decpt             E:00040510
_fpBuf                           E:00040520
_fpTextIncr                      E:00040094
_fpWork                          E:00040600
_keybdControlCodes              00:00000E30
_keybdExtendedCodes             00:00000EB0
_msgInf                         00:00008E78
_msgNan                         00:00008E74
_precision                       E:00040514
_shiftedScanCodes               00:00000D30
_unshiftedScanCodes             00:00000C30
_width                           E:00040508
a_was_less                      00:0000BBE2
add_address                     00:0000BD0A
add_char_loop                   00:0000BCB2
add_character                   00:0000B24E
add_coords                      00:0000BD20
add_explode                     00:0000B788
add_fire                        00:0000B794
add_hex_chr                     00:0000BCF0
add_item                        00:0000B76E
add_message                     00:0000BC6A
add_p_size                      00:0000AD52
add_pair                        00:0000BD3C
add_play_explode                00:0000B8AC
add_player                      00:0000B952
add_saucer                      00:0000B78E
add_score                       00:0000B7A6
add_ships                       00:0000B25E
add_ships_loop                  00:0000B27A
add_single                      00:0000BD3A
add_sup_hex_chr                 00:0000BCE4
add_sup_zero                    00:0000BCFA
add_the_char                    00:0000BCC8
add_to_list                     00:0000B73A
add_to_score                    00:0000BA34
addr_err                        00:00009C88
aim_shot                        00:0000AF10
animal_colour                    S:00000014
animal_fill                      S:00000018
animal_flag                      S:000001EE
animal_spawn                     S:00000221
animal_xy                        S:00000126
asteroids_start                 00:0000AB2A
atn_eight                       00:0000BB4E
atn_quad                        00:0000BB3E
atn_semi                        00:0000BB2E
atn_tab                         00:0000BB6C
attract_fire                    00:0000AEEC
attract_saucer                  00:0000AE3A
beat1_snd                        E:00000008
beat1_sound                     00:0000D996
beat2_snd                        E:00000009
beat2_sound                     00:0000D9A8
bkColor                          E:00040088
brdisp_trap                     00:00009C9E
bus_err                         00:000098AA
calc_fire_byte                  00:0000AFFE
char_1                          00:0000D4D2
char_2                          00:0000D4DA
char_3                          00:0000D4EA
char_4                          00:0000D4F8
char_5                          00:0000D506
char_6                          00:0000D514
char_7                          00:0000D522
char_8                          00:0000D52C
char_9                          00:0000D53C
char_a                          00:0000D366
char_b                          00:0000D376
char_c                          00:0000D390
char_d                          00:0000D39C
char_e                          00:0000D3AC
char_f                          00:0000D3BC
char_g                          00:0000D3CA
char_h                          00:0000D3DC
char_i                          00:0000D3EA
char_j                          00:0000D3F8
char_k                          00:0000D404
char_l                          00:0000D410
char_m                          00:0000D41A
char_n                          00:0000D426
char_o0                         00:0000D430
char_p                          00:0000D43C
char_q                          00:0000D44A
char_r                          00:0000D45C
char_s                          00:0000D46C
char_set                        00:0000D54A
char_spc                        00:0000D4CE
char_t                          00:0000D47A
char_u                          00:0000D486
char_v                          00:0000D492
char_w                          00:0000D49C
char_x                          00:0000D4AA
char_y                          00:0000D4B4
char_z                          00:0000D4C2
check_all                       00:0000ACFC
check_alpha                     00:0000B16A
check_clear                     00:0000B48E
check_clear_loop                00:0000B492
check_clear_y                   00:0000B4AC
check_for_food                   A:0002022C
check_hi_loop                   00:0000BAA0
check_hi_next                   00:0000BAAE
check_hi_player                 00:0000BA98
check_hiscores                  00:0000BA7C
check_hits                      00:0000ACDC
check_neg_velocity              00:0000B482
check_next_object               00:0000ACF8
check_pss                       00:0000ACEA
check_velocity                  00:0000B474
chk_exception                   00:00002600
clear_graphics_screen           00:00001D18
clear_graphics_screen2          00:00008986
clear_hyper                     00:0000B3C6
clear_items_loop                00:0000B226
clear_loop                      00:0000BD76
clear_rock                      00:0000BA20
clear_rocks                     00:0000B56C
clear_rocks_loop                00:0000B56E
clear_saucer                    00:0000B366
close_all                       00:0000B0DA
close_all_2                     00:0000BDCC
clr_animals_loop                 A:0002011A
clr_plant_loop                   A:00020106
cmdAsteroids                    00:00008240
cmdBreakpoint                   00:0000821C
cmdClearScreen                  00:00008266
cmdClock                        00:0000835A
cmdCore                         00:00008272
cmdDisassemble                  00:00008BFE
cmdDispatch                     00:00008194
cmdDumpMemory                   00:00008C4E
cmdDumpRegs                     00:00008D1A
cmdEditMemory                   00:000087F0
cmdFMTK                         00:00008296
cmdFillB                        00:0000869C
cmdFillL                        00:00008744
cmdFillW                        00:000086F0
cmdGrDemo                       00:00008874
cmdHelp                         00:000083CA
cmdJump                         00:00008864
cmdLoadS19                      00:00009502
cmdMonitor                      00:00008138
cmdPlants                       00:00008248
cmdReceiveSerial                00:00008668
cmdReset                        00:00008378
cmdSendSerial                   00:00008638
cmdString                       00:0000804C
cmdTable                        00:000080B0
cmdTestCPU                      00:00008256
cmdTestFP                       00:000082A0
cmdTestGF                       00:0000832C
cmdTestRAM                      00:0000943A
cmdTestSerialReceive            00:00008DC4
cmdTinyBasic                    00:00008252
cmdVideoMode                    00:000081DA
col_table                       00:0000AD62
col_table_l                     00:0000AD7A
col_table_p                     00:0000AD6A
col_table_s                     00:0000AD72
copy_msg                        00:0000CF2E
copy_rock                       00:0000B5C4
copy_rock_2                     00:0000B5C8
copy_short                      00:0000B9A4
copy_vectors                    00:0000B9A8
copy_velocity                   00:0000B5EE
cos_d0                          00:0000BBCA
cossin_d0                       00:0000BBDC
cpu_test                        00:00002654
d_mess_0                        00:0000D69A
d_mess_1                        00:0000D6AA
d_mess_2                        00:0000D6B3
d_mess_3                        00:0000D6DA
d_mess_4                        00:0000D6FD
d_mess_5                        00:0000D720
d_mess_6                        00:0000D746
d_mess_7                        00:0000D75C
d_messages                      00:0000D68A
dccr                            00:0000128C
dclf                            00:00001360
dcx10                           00:000012F4
dcx11                           00:00001316
dcx12                           00:0000130C
dcx14                           00:00001280
dcx16                           00:00001364
dcx4                            00:00001368
dcx6                            00:000012AA
dcx7                            00:00001284
dcx8                            00:000012C0
dcx9                            00:000012D6
dec_isaucer_time                00:0000AE62
def_a_spawn                      E:00000005
def_animal                       E:00FFFFFF
def_animals                      E:00000032
def_back                         E:00000000
def_leaf                         E:00008000
def_p_spawn                      E:00000001
def_plant                        E:008080FF
def_plants                       E:00000032
delta_x                          A:00020300
delta_x_pos                     00:0000AD16
delta_y                          A:00020312
delta_y_pos                     00:0000AD28
dly3s1                          00:00002624
dly3s2                          00:00002622
doBackspace                     00:00001372
doCtrlX                         00:000013B6
doDelete                        00:00001380
do_animals                       A:00020178
do_nothing                      00:0000051A
do_p1_ships                     00:0000B6A2
do_p2_score                     00:0000B716
do_plants                        A:00020142
do_saucer                       00:0000AE0E
do_start_mess                   00:0000ABDA
do_things                        A:000201AC
do_things_loop                   A:00020206
do_vector                       00:0000BDE4
draw_old_thing                   A:000202A6
dspj1                           00:00007AE8
dspmem1                         00:00008CB0
dspspc1                         00:000093B4
dsret                           00:00007AF4
e_mess_0                        00:0000D5E0
e_mess_1                        00:0000D5EC
e_mess_2                        00:0000D5F4
e_mess_3                        00:0000D616
e_mess_4                        00:0000D631
e_mess_5                        00:0000D64E
e_mess_6                        00:0000D675
e_mess_7                        00:0000D680
e_messages                      00:0000D5D0
edtmem1                         00:000087FA
end_game                        00:0000ACC8
end_main_loop                    A:00020064
end_vector                      00:0000BED2
enter_hiscores                  00:0000B024
err_cmdproc                     00:00001540
err_dcb                          E:00040B8C
err_init                        00:00001512
err_ret                         00:0000153E
existing_saucer                 00:0000AEC8
exit_add_message                00:0000BCD0
exit_add_score                  00:0000B7D4
exit_add_ships                  00:0000B286
exit_check_hiscores             00:0000BADC
exit_check_velocity             00:0000B48C
exit_copy_vectors               00:0000B9C2
exit_do_saucer                  00:0000AEC6
exit_do_things                   A:000202B2
exit_enter_hiscores             00:0000B178
exit_existing_saucer            00:0000AEF2
exit_find_rock                  00:0000B892
exit_game_message               00:0000ACC6
exit_hi_chk                     00:0000BAD2
exit_high_scores                00:0000B87A
exit_hit_a_rock                 00:0000BA76
exit_hyperspace                 00:0000B208
exit_insert_loop                00:0000BB04
exit_limit_velocity             00:0000B648
exit_make_rocks                 00:0000B576
exit_neighbour                   A:000202FA
exit_no_scores                  00:0000B880
exit_not_done                   00:0000B176
exit_play_sample                00:0000D97C
exit_push_start                 00:0000AC48
exit_ship_fire                  00:0000AFAA
exit_ship_move                  00:0000B3CA
exit_static                     00:0000B738
exit_test_escape                 A:000200A0
expl_0                          00:0000D016
expl_1                          00:0000CFE0
expl_2                          00:0000CFA2
expl_3                          00:0000CF76
expl_tab                        00:0000CF6E
expl_x_pos                       S:0000005B
expl_y_pos                       S:00000067
explode_object                  00:0000ADC8
extra_snd                        E:0000000A
extra_sound                     00:0000D9F9
f_mess_0                        00:0000D776
f_mess_1                        00:0000D785
f_mess_2                        00:0000D78C
f_mess_3                        00:0000D7B0
f_mess_4                        00:0000D7C9
f_mess_5                        00:0000D7EB
f_mess_6                        00:0000D814
f_mess_7                        00:0000D826
f_messages                      00:0000D766
f_xpos_off                       E:FFFFFFBA
f_xvel_off                       E:0000004C
f_ypos_off                       E:00000000
f_yvel_off                       E:0000006F
fgColor                          E:00040084
filename                        00:0000DA70
fill_colour                      S:00000020
fill_old_thing                   A:000202A8
find_next_rock                  00:0000B888
find_rock                       00:0000B886
fire_ok                         00:0000B01A
fire_saucer                     00:0000AEF8
fire_shot                       00:0000AFAC
first_quad                      00:0000B97C
flag_end                         E:0000002F
flags_off                        E:0000000C
food_colour                      S:00000024
fpBuf                            E:000402C0
framebuf_clear                  00:00001D4C
framebuf_cmdproc                00:00001954
framebuf_dcb                     E:00040D18
framebuf_get_color              00:00001B62
framebuf_get_dimen              00:00001B72
framebuf_getbuf                 00:00001B4C
framebuf_getbuf1                00:00001AAE
framebuf_getbuf2                00:00001AB6
framebuf_getchar                00:00001A90
framebuf_init                   00:000019E6
framebuf_putbuf                 00:00001B4C
framebuf_putchar                00:00001A90
framebuf_set_color_depth        00:00001B50
framebuf_set_destbuf            00:00001A90
framebuf_set_dimen              00:00001BA2
framebuf_set_dispbuf            00:00001B38
framebuf_set_inpos              00:00001A92
framebuf_set_outpos             00:00001AA0
framebuf_set_unit               00:00001B42
framebuf_setbuf1                00:00001ABE
framebuf_setbuf2                00:00001ACC
framebuf_stat                   00:00001A90
framebuf_stub                   00:00001B4C
framebuf_swapbuf                00:00001ADA
framebuf_writeat                00:00001C1E
fx_sounds                       00:0000B9C4
game_count                       S:00000059
game_message                    00:0000ABC6
game_over                       00:0000AC4A
gen_prng                        00:0000BDD2
gen_rock_loop                   00:0000B516
get_atn                         00:0000BB22
get_direction                    A:000203E4
get_prng                         A:000203E6
get_screen_address              00:00007AB8
get_screen_color                00:00001218
gfxaccel_clear                  00:00001FF4
gfxaccel_clip_rect              00:00002100
gfxaccel_cmdproc                00:00001E7C
gfxaccel_ctrl                    E:000408C0
gfxaccel_dcb                     E:00040D9C
gfxaccel_draw_curve             00:0000231A
gfxaccel_draw_line              00:000021C2
gfxaccel_draw_rectangle         00:0000222A
gfxaccel_draw_triangle          00:00002292
gfxaccel_get_color              00:0000209A
gfxaccel_get_dimen              00:00001F90
gfxaccel_get_inpos              00:00001F90
gfxaccel_get_outpos             00:00001F90
gfxaccel_get_outptr             00:00001F90
gfxaccel_getbuf                 00:00001F90
gfxaccel_getbuf1                00:00001F90
gfxaccel_getbuf2                00:00001F90
gfxaccel_getchar                00:00001F90
gfxaccel_init                   00:00001F20
gfxaccel_plot_point             00:00002170
gfxaccel_putbuf                 00:00001F90
gfxaccel_putchar                00:00001F90
gfxaccel_set_active_point       00:00002144
gfxaccel_set_color              00:000020A8
gfxaccel_set_color123           00:000020C8
gfxaccel_set_color_depth        00:00002088
gfxaccel_set_destbuf            00:00001FC8
gfxaccel_set_dimen              00:00001F94
gfxaccel_set_dispbuf            00:00001F90
gfxaccel_set_inpos              00:00001F90
gfxaccel_set_outpos             00:00001F90
gfxaccel_set_unit               00:00001F90
gfxaccel_setbuf1                00:00001F90
gfxaccel_setbuf2                00:00001F90
gfxaccel_stat                   00:00001F82
gfxaccel_stub                   00:00001F90
gfxaccel_swapbuf                00:00001F90
gfxaccel_wait                   00:000023A0
gfxaccel_writeat                00:00001F90
glob_scale                       S:00000000
go_reset_play                   00:0000B2CA
go_reset_sauc                   00:0000B2D0
goodbye_message                  A:0002007C
grCmdString                     00:00008090
gr_double_buffer                 E:000408AC
gr_height                        E:000408A0
gr_width                         E:0004089C
gr_x                             E:00040894
gr_y                             E:00040898
gthx3                           00:000093A6
gthx5                           00:00009382
gthx6                           00:00009394
handle_collision                00:0000AD82
height                           S:00000006
hi_char                          S:00000020
hide_p_cnt                       E:0000007A
high_idx                         S:00000017
high_off                         E:00000083
high_scores                     00:0000B7DA
high_scores_loop                00:0000B80C
hinames                          S:0000003B
hiscore_y                        S:00000012
hiscores                         S:00000027
hit_a_rock                      00:0000BA06
hype_xok1                       00:0000B1B6
hype_xok2                       00:0000B1C0
hype_yok1                       00:0000B1DE
hype_yok2                       00:0000B1E8
hyper                            S:00000026
hyperspace                      00:0000B17A
i2c_setup                       00:0000972C
i2c_wait_rx_nack                00:0000977A
i2c_wait_tip                    00:0000973C
i2c_wr_cmd                      00:0000974C
i2c_xmit1                       00:0000975C
i_rk_count                       E:00000075
i_sauc_tim                       E:00000078
icc1                            00:0000141C
ignBlanks                       00:00008790
illegal_trap                    00:00009CD6
init_i2c                        00:0000972C
init_plic                       00:00008016
init_world                       A:000200A2
insert_hiscore                  00:0000BADE
insert_loop                     00:0000BAE2
io_irq                          00:00009CEC
io_trap                         00:00009B64
irq3_rout                       00:00009C42
irq6_rout                       00:00009C42
irq_list_tbl                     A:00000400
irq_proc_generic                00:00009C56
irq_rout                        00:00009C42
is_closer                       00:0000B4CA
is_food                          A:0002025C
item_exploding                  00:0000B2D8
kbdi0002                        00:000006E0
kbdi0004                        00:00000758
kbdi0005                        00:00000774
kbdiTryAgain                    00:0000074A
kbdiXmitBusy                    00:0000078E
keep_saucer_dir                 00:0000AEE0
keep_scale                      00:0000B358
keep_small                      00:0000AE08
keybd_cmdproc                   00:0000060C
keybd_dcb                        E:00040A84
keybd_getbuf                    00:00000646
keybd_getchar                   00:0000063E
keybd_init                      00:00000568
keybd_putbuf                    00:00000646
keybd_putchar                   00:00000636
keybd_set_inpos                 00:00000646
keybd_set_outpos                00:00000646
keybd_stat                      00:0000062E
kgid1                           00:0000067C
kgnotKbd                        00:00000684
kill_the_player                 00:0000B3B0
kill_thing                       A:0002024C
last_fire                        S:00000021
last_hype                        S:00000022
last_vector                     00:0000BEE0
leds                             E:FD0FFF00
ledxit                          00:00000778
lexpl_snd                        E:00000007
lexpl_sound                     00:0000D9BA
lgsau_snd                        E:00000004
lgsau_sound                     00:0000DA0F
limit_p_vel                     00:0000B638
limit_velocity                  00:0000B624
load_old_sound                  00:0000D958
load_sound                      00:0000D952
local_x                          S:00000002
local_y                          S:00000004
loop1                           00:000004E2
loop2                           00:000004E0
loop3                           00:000011FA
loop_atn                        00:0000BB52
m_w                              E:000408D4
m_z                              E:000408D0
main_loop                       00:0000AB32
make_rocks                      00:0000B4D0
max_animals                      S:0000000E
max_plants                       S:0000000A
memend                           E:00100004
mess_origin                     00:0000D5A8
mess_table                      00:0000D5C8
mexpl_snd                        E:00000006
mexpl_sound                     00:0000D9CF
min_rocks                        E:0000007D
move_item                       00:0000B2F2
move_items                      00:0000B288
move_next_item                  00:0000B28C
move_next_object                00:0000B35E
msgAddrErr                      00:00009D38
msgBadKeybd                     00:0000079C
msgBusErr                       00:00009899
msgChk                          00:00009D94
msgHello                        00:00008583
msgRtcReadFail                  00:00009880
msgStackCanary                  00:00009DA2
msgUnknownCmd                   00:00008573
msgXmitBusy                     00:000007AB
msg_bad_branch_disp             00:00009D57
msg_core_start                  00:00009D27
msg_illegal                     00:00009D45
msg_io_access                   00:00009D79
msg_reglist                     00:00008D9E
msg_regs                        00:00008D9A
msg_start                       00:00009D00
msg_test_done                   00:00009D69
nd1                             00:000023D8
nd2                             00:000023D8
nd3                             00:000023D8
nd4                             00:000023D8
neg_upper_ok                    00:0000B62E
neighbour                        A:000202B4
net_delay                       00:000023D8
new_rocks                        E:0000007B
new_thing_loop                   A:00020286
next_hi_char                    00:0000B0F2
next_m_w                         E:000408DC
next_m_z                         E:000408D8
next_p_high                     00:0000B0BE
next_pss                        00:0000ACE4
next_thing                       A:000202AE
nmeSerial                       00:000018BA
nmi_rout                        00:00009C76
no_add_size                     00:0000AD54
no_aim_shot                     00:0000AF66
no_dec_new_rocks                00:0000ABB6
no_game_over                    00:0000AC88
no_inc_min                      00:0000B4FA
no_neg_x10                      00:0000BE4C
no_neg_x11                      00:0000BE22
no_neg_x2                       00:0000BECE
no_neg_y10                      00:0000BE40
no_neg_y11                      00:0000BE16
no_neg_y2                       00:0000BEC6
no_new_rocks                    00:0000B2C2
no_play                         00:0000AB98
no_playerx                      00:0000B052
no_pos_reflect                  00:0000B968
no_reset_scale                  00:0000B2F0
no_reset_xy                     00:0000B8D6
no_saucer_sound                 00:0000B9D2
no_save_ist                     00:0000AE72
no_set_max                      00:0000B50A
no_shot_dec                     00:0000B7A4
no_shot_or                      00:0000AF62
no_thrust                       00:0000B9A2
no_thump_sound                  00:0000BA04
nodec_thmpi                     00:0000AC5E
notRxInt                        00:0000185A
notTxInt                        00:000018A8
not_closer                      00:0000B4C0
not_player                      00:0000ADA0
not_pss_player                  00:0000ADB8
not_right                       00:0000BE5E
not_rot_left                    00:0000B13C
not_rot_left1                   00:0000B3D8
not_rot_right1                  00:0000B3E0
not_rot_right2                  00:0000B144
not_saucer                      00:0000AD92
not_thrust                      00:0000B43E
not_timed_out                   00:0000B120
not_x_max                       00:0000B314
not_y_max                       00:0000B334
notscreen                       00:0000BD42
null_cmdproc                    00:00000564
null_dcb                         E:00040A00
null_init                       00:00000520
null_ret                        00:00000562
numBreakpoints                   E:00000008
num_animals                      S:0000000C
num_plants                       S:00000008
num_players                      S:0000001A
old_sound_play                  00:0000D97A
op_ABCD                         00:000049AE
op_ADD                          00:00005344
op_ADDA                         00:00005518
op_ADDQ                         00:00004D44
op_ADDX                         00:000055B0
op_ADD_I                        00:00003A2C
op_AND                          00:00005062
op_ANDI_TO_CCR                  00:000027DC
op_ANDI_TO_SR                   00:00002802
op_BCC                          00:00004C6E
op_BCHG                         00:00002BD2
op_BCLR                         00:00002F3A
op_BOOL_I                       00:0000365C
op_BSET                         00:00003288
op_BSR                          00:0000380E
op_BTST                         00:00002828
op_BTST0                        00:000029B2
op_BTST1                        00:000029BE
op_BTST10                       00:00002A06
op_BTST11                       00:00002A0E
op_BTST12                       00:00002A14
op_BTST2                        00:000029C6
op_BTST20                       00:00002B6C
op_BTST21                       00:00002B76
op_BTST22                       00:00002B7C
op_BTST23                       00:00002B82
op_BTST24                       00:00002B88
op_BTST25                       00:00002B8E
op_BTST26                       00:00002B94
op_BTST27                       00:00002B9A
op_BTST28                       00:00002BA0
op_BTST29                       00:00002BA6
op_BTST3                        00:000029CE
op_BTST30                       00:00002BAC
op_BTST31                       00:00002BB2
op_BTST32                       00:00002BB6
op_BTST4                        00:000029D6
op_BTST5                        00:000029DE
op_BTST6                        00:000029E6
op_BTST7                        00:000029EE
op_BTST8                        00:000029F6
op_BTST9                        00:000029FE
op_CHK                          00:000042B8
op_CMP                          00:000051C2
op_CMPA                         00:00005238
op_CMPM                         00:0000529E
op_CMP_I                        00:00003844
op_DBCC                         00:00004CEE
op_DIVS                         00:00004F26
op_DIVU                         00:00004ED4
op_EOR                          00:0000514C
op_EORI_TO_CCR                  00:00002790
op_EORI_TO_SR                   00:000027B6
op_EXG                          00:00005868
op_EXT                          00:00004138
op_LEAPEA                       00:0000417A
op_LINKS                        00:0000428A
op_MOVE                         00:00003D38
op_MOVEM                        00:00004690
op_MOVEP                        00:000035D0
op_MOVEQ                        00:00004EB8
op_MOVE_USP                     00:000042A8
op_MOVE_xxx_FLAGS               00:00003F44
op_MULS                         00:0000581C
op_MULU                         00:000057D0
op_NBCD                         00:00004B9E
op_NEGS                         00:00004302
op_OR                           00:00004F78
op_ORI_TO_CCR                   00:0000274C
op_ORI_TO_SR                    00:0000276E
op_ROXx                         00:00005B0C
op_ROx                          00:000058D6
op_RTR                          00:00004C4C
op_SBCD                         00:00004AA6
op_SCC                          00:00004D14
op_SHIFTS                       00:00005D42
op_SHIFTS2                      00:00005F84
op_SUB                          00:0000542E
op_SUBA                         00:00005564
op_SUBQ                         00:00004DFE
op_SUBX                         00:000056C0
op_SUB_I                        00:00003BB2
op_SWAP                         00:00004164
op_TAS                          00:00004226
op_TRAPV                        00:00004C30
op_TST                          00:0000424C
op_abs                          00:0000BE32
op_call                         00:0000BDF2
op_jump                         00:0000BDF8
op_rtsvec                       00:0000BDE2
op_short                        00:0000BEA2
op_vctr                         00:0000BE08
output_number                   00:0000BBAC
output_number_loop              00:0000BBAE
p1_high                          S:00000176
p1_score                         S:00000173
p1_ships                         S:00000175
p2_high                          S:0000027A
p2_score                         S:00000277
p2_ships                         S:00000279
p_2_end                          S:0000027B
p_fire_off                       E:0000002B
p_flag_off                       E:00000027
p_orient                         S:0000001E
p_xpos_off                       E:FFFFFFB6
p_xvel_off                       E:0000004A
p_xvlo_off                       E:0000007E
p_ypos_off                       E:FFFFFFFC
p_yvel_off                       E:0000006D
p_yvlo_off                       E:0000007F
past_play                        S:00000019
pcssxa                          00:000095B2
pen_color                        E:00040890
pfire_snd                        E:00000001
pfire_sound                     00:0000DA4C
piece_draw_loop                 00:0000B8E0
plant_colour                     S:00000010
plant_fill                       S:00000012
plant_flag                       S:000000F4
plant_spawn                      S:00000220
plant_xy                         S:0000002C
plants_main_loop                 A:00020018
play_00                         00:0000D106
play_01                         00:0000D11E
play_02                         00:0000D142
play_03                         00:0000D166
play_04                         00:0000D18A
play_05                         00:0000D1AC
play_06                         00:0000D1D0
play_07                         00:0000D1F4
play_08                         00:0000D218
play_09                         00:0000D23C
play_0A                         00:0000D260
play_0B                         00:0000D284
play_0C                         00:0000D2A8
play_0D                         00:0000D2CC
play_0E                         00:0000D2F0
play_0F                         00:0000D314
play_10                         00:0000D338
play_liv                        00:0000D350
play_sample                     00:0000D95E
play_sound                       S:00000015
play_tab                        00:0000D0E4
player_1                         E:000000F3
player_2                         E:000001F7
player_idx                       S:00000018
player_init                     00:0000B578
player_n                        00:0000BCDC
player_reset                    00:0000B5AE
player_shot                     00:0000ADE4
player_x                        00:0000BCD8
plot                            00:00001C1E
plot_and                        00:00001CE0
plot_black                      00:00001D02
plot_copy                       00:00001CF4
plot_or                         00:00001CB6
plot_rand_points                00:00008908
plot_sw                         00:00001C90
plot_white                      00:00001D0C
plot_xor                        00:00001CCA
plottbl                         00:00001C54
pnotscreen                       A:00020432
poison_colour                    S:00000028
pos_lower_ok                    00:0000B640
prng                            00:000024C2
prtflt                          00:00009AEA
psetscreen                       A:00020420
pss_check_loop                  00:0000ACDE
push_start_mess                 00:0000AC32
pvariables                       A:00020434
px_hide                         00:0000AB90
px_time                          S:0000001C
quit                             S:00000000
r_hit_tim                        E:00000079
ramtest                         00:0000943A
ramtest0                        00:00009484
ramtest1                        00:0000948C
ramtest2                        00:000094BA
ramtest3                        00:00009500
ramtest6                        00:000094AA
rand_curve                      00:00008B8C
rand_lines                      00:00008A28
rand_points                     00:000089F2
rand_rect                       00:00008A7E
rand_rect2                      00:00008AD4
rand_triangle                   00:00008B1A
rbo                             00:00009724
read_hi                         00:0000BDC2
readyQ                           E:00100320
redraw                           S:00000002
reset_game                      00:0000B20A
reset_xy_loop                   00:0000B8BE
restart                          A:0002000C
reveal_player                   00:0000B3A8
rmtst1                          00:0000949E
rmtst2                          00:000094D2
rmtst3                          00:000094DA
rmtst5                          00:00009454
rock_0                          00:0000D05C
rock_1                          00:0000D074
rock_2                          00:0000D090
rock_3                          00:0000D0AA
rock_count                       E:00000076
rock_hit_out                    00:0000AE44
rock_on_x                       00:0000B54A
rock_score                      00:0000BA78
rock_tab                        00:0000D054
rock_y_ok                       00:0000B548
rot_and_thrust                  00:0000B3CC
rot_not_left                    00:0000B144
rotate_iofocus                  00:00007FE6
rtc_read                        00:0000978A
rtc_write                       00:00009816
sGetChar                        00:000096EE
s_controls                      00:0000BD42
s_fire_off                       E:00000029
s_flag_off                       E:00000028
s_key                            S:00000014
s_mess_0                        00:0000D844
s_mess_1                        00:0000D84C
s_mess_2                        00:0000D855
s_mess_3                        00:0000D87C
s_mess_4                        00:0000D89A
s_mess_5                        00:0000D8C2
s_mess_6                        00:0000D8D4
s_mess_7                        00:0000D8E1
s_messages                      00:0000D834
s_orient                         S:0000001F
s_xpos_off                       E:FFFFFFB8
s_xvel_off                       E:0000004B
s_ypos_off                       E:FFFFFFFE
s_yvel_off                       E:0000006E
sauc_cntdn                       E:00000077
sauc_jsr                        00:0000D0C6
sauc_vec                        00:0000D0C8
saucer_yok                      00:0000AE84
saucer_yvel                     00:0000AEF4
save_char                       00:0000B172
save_hbutton                    00:0000B10A
save_hi_index                   00:0000BACE
save_hyperspace                 00:0000B204
save_saucer                     00:0000AEC2
save_ship_fire                  00:0000AFA6
score_off                        E:00000080
scr_x                            S:00000006
scr_y                            S:00000008
screen_size                      A:000203F6
select_focus1                   00:00007FF8
select_iofocus                  00:00007FD4
semamem                          E:FD050000
serial_cmdproc                  00:000015D8
serial_dcb                       E:00040C94
serial_getbuf                   00:0000162C
serial_getchar                  00:00001606
serial_getchar_direct           00:0000160C
serial_init                     00:00001574
serial_peek_char                00:00001614
serial_peek_char_direct         00:0000161C
serial_putbuf                   00:0000162C
serial_putchar                  00:000015FE
serial_putchar_direct           00:00001624
serial_set_inpos                00:0000162C
serial_set_outpos               00:0000162C
serial_stat                     00:000015FA
set_a_pixel                      A:0002033A
set_graphics_mode               00:00007A8E
set_text_mode                   00:00007A64
set_thing_pixel                  A:00020324
set_this_pixel                   A:00020346
setscreen                       00:0000BD42
setup_err                       00:00001512
setup_framebuf                  00:00001978
setup_gfxaccel                  00:00001EA0
setup_keybd                     00:00000568
setup_null                      00:00000520
setup_serial                    00:00001574
setup_textvid                   00:00000FB8
sexpl_snd                        E:00000005
sexpl_sound                     00:0000D9E4
sfire_snd                        E:00000000
sfire_sound                     00:0000DA5E
shift_left                      00:0000BEDC
ship_fire                       00:0000AF7C
ship_move                       00:0000B37A
ship_parts                      00:0000B946
ship_wrk_x                      00:0000B894
ship_wrk_y                      00:0000B8A0
ships_off                        E:00000082
shot_jsr                        00:0000D594
shot_mask                       00:0000AF78
shot_or                         00:0000AF7A
shot_vec                        00:0000D596
show_ships                      00:0000B268
sin_cos                         00:0000BBE8
sin_d0                          00:0000BBCE
sirq0001                        00:0000180A
sirq0002                        00:000018A8
sirqNxtByte                     00:000017F8
sirqRxFull                      00:0000185A
sirqTxEmpty                     00:000018A8
sirqXmitOff                     00:000018A8
sixteen_ms                       S:0000001D
skip_add                        00:0000BA3C
skip_p2_score                   00:0000B72A
skip_play_flash                 00:0000B68E
skip_play_inc                   00:0000B2A8
skip_player_cont                00:0000AB8C
skip_player_move                00:0000AB88
skip_sub                        00:0000BB5C
small_s_size                    00:0000AD50
small_saucer                    00:0000AEC0
smsau_snd                        E:00000003
smsau_sound                     00:0000DA24
sound_init                      00:0000D8F1
sound_key                       00:0000D97E
ss_count                         S:0000001B
start                           00:000003B8
start_game                      00:0000ABFE
start_left                      00:0000AE98
start_other                     00:000004F4
start_plants                     A:00020000
static_messages                 00:0000B64A
suppress_0                       S:00000016
switch_addr                      S:0000000E
sys_switches                     E:000408B8
tblPow2                         00:000083AA
tcbs                             E:20010000
test_escape                      A:00020089
test_fire_loop                  00:0000AF9A
test_neg_fire                   00:0000B012
textvid_clear                   00:000011A0
textvid_cmdproc                 00:00000F94
textvid_dcb                      E:00040B08
textvid_get_color               00:00001146
textvid_get_dimen               00:00001170
textvid_get_inpos               00:000010C8
textvid_get_outpos              00:0000110A
textvid_get_outptr              00:00001120
textvid_getbuf                  00:000010C4
textvid_getbuf1                 00:00001156
textvid_getchar                 00:000010BC
textvid_init                    00:00001010
textvid_putbuf                  00:000010C4
textvid_putchar                 00:00001262
textvid_set_inpos               00:000010DE
textvid_set_outpos              00:000010F4
textvid_set_unit                00:00001166
textvid_stat                    00:000010B8
textvid_stub                    00:000010C4
thing_colour                     S:0000001C
thing_zero_only                  A:0002020E
things_exist                     A:000201EE
third_quad                      00:0000B96E
thmp_sndi                        E:0000007C
three_ship_start                00:0000B218
thrst_snd                        E:00000002
thrst_sound                     00:0000DA39
thump_snd                        S:00000023
thump_time                       S:00000024
tickcnt                          E:0004009C
time_count                       S:00000025
timer_interrupt                 00:0000BCD2
trap3                           00:000098C4
variables                       00:0000DA7D
vec_x_pos                       00:0000B906
vec_y_pos                       00:0000B912
vector                          00:0000BF2E
vector_base                     00:0000BE66
vector_move                     00:0000BF02
was_rot_left                    00:0000B144
what_hit_rock                   00:0000ADC4
what_hit_saucer                 00:0000ADF0
white_rect                      00:000089CE
wide_shot                       00:0000AF58
width                            S:00000004
wrap_to_a                       00:0000B164
wrap_to_z                       00:0000B168
write_initial                   00:0000B234
x_off_pos                       00:0000B5FE
x_pos_end                        E:FFFFFFC6
x_pos_neg                       00:0000B304
x_pos_off                        E:FFFFFF80
x_vel_off                        E:0000002F
y_not_neg                       00:0000B32A
y_off_pos                       00:0000B618
y_pos_off                        E:FFFFFFC6
y_vel_off                        E:00000052
zero_suppress                   00:0000BBBE

Symbols by value:
FD050000 semamem
FD060000 ACIA
FD069000 I2C2
FD080000 TEXTREG
FD090000 PLIC
FD0FFC00 RST_REG
FD0FFD00 RAND_NUM
FD0FFD00 RAND
FD0FFD04 RAND_STRM
FD0FFD08 RAND_MZ
FD0FFD0C RAND_MW
FD0FFE00 KEYBD
FD0FFF00 leds
FD200000 FRAMEBUF
FD300000 GFXACCEL
FDC00000 MMU
FFFFFF80 x_pos_off
FFFFFFB6 p_xpos_off
FFFFFFB8 s_xpos_off
FFFFFFBA f_xpos_off
FFFFFFC6 x_pos_end
FFFFFFC6 y_pos_off
FFFFFFF0 DDATA
FFFFFFFC p_ypos_off
FFFFFFFC HISPC
FFFFFFFE s_ypos_off
00000000 TCBInit
00000000 f_ypos_off
00000000 glob_scale
00000000 sfire_snd
00000000 HAS_MMU
00000000 DCB_MAGIC
00000000 GFX_CTRL
00000000 quit
00000000 def_back
00000000 ACIA_RX
00000000 FRAMEBUF_CTRL
00000000 E_Ok
00000000 ACIA_TX
00000000 I2C_PREL
00000001 I2C_PREH
00000001 pfire_snd
00000001 def_p_spawn
00000001 SCREEN_FORMAT
00000001 DT_NUMERIC
00000002 DEV_PUTCHAR
00000002 local_x
00000002 redraw
00000002 thrst_snd
00000002 I2C_CTRL
00000002 SERIAL_SEMA
00000002 DT_STRING
00000002 E_Func
00000003 smsau_snd
00000003 KEYBD_SEMA
00000003 I2C_RXR
00000003 CTRLC
00000003 I2C_TXR
00000004 RAND_SEMA
00000004 GFX_STATUS
00000004 lgsau_snd
00000004 EOT
00000004 local_y
00000004 width
00000004 ACIA_STAT
00000004 TCBRegs
00000004 I2C_CMD
00000004 DCB_NAME
00000004 NCORES
00000004 I2C_STAT
00000005 sexpl_snd
00000005 def_a_spawn
00000005 SCREEN_SEMA
00000006 scr_x
00000006 mexpl_snd
00000006 height
00000006 MEMORY_SEMA
00000007 DEV_SET_OUTPOS
00000007 lexpl_snd
00000008 scr_y
00000008 ACIA_CMD
00000008 numBreakpoints
00000008 FMTK_SEMA
00000008 beat1_snd
00000008 CTRLH
00000008 num_plants
00000009 beat2_snd
00000009 E_NotAlloc
0000000A FDATA
0000000A PRNlword
0000000A E_NotSupported
0000000A extra_snd
0000000A LF
0000000A max_plants
0000000C flags_off
0000000C ACIA_CTRL
0000000C DEV_CLEAR
0000000C num_animals
0000000D CR
0000000D SC_TAB
0000000D DEV_SWAPBUF
0000000E switch_addr
0000000E max_animals
00000010 DEV_GETBUF1
00000010 plant_colour
00000010 LOCVARSZ
00000010 FRAMEBUF_PAGE1_ADDR
00000010 GFX_TARGET_BASE
00000011 XON
00000011 SC_ALT
00000012 hiscore_y
00000012 plant_fill
00000012 DEV_WRITEAT
00000012 SC_LSHIFT
00000013 CTRLS
00000013 XOFF
00000014 s_key
00000014 DEV_GET_DIMEN
00000014 SC_CTRL
00000014 animal_colour
00000014 GFX_TARGET_SIZE_X
00000015 play_sound
00000016 suppress_0
00000017 high_idx
00000017 DEV_GET_OUTPOS
00000018 animal_fill
00000018 CTRLX
00000018 FRAMEBUF_PAGE2_ADDR
00000018 DCB_CMDPROC
00000018 player_idx
00000018 DEV_GET_OUTPTR
00000018 GFX_TARGET_SIZE_Y
00000019 DEV_SET_COLOR
00000019 past_play
0000001A num_players
0000001A CTRLZ
0000001B ESC
0000001B DEV_PLOT_POINT
0000001B ss_count
0000001C thing_colour
0000001C DEV_DRAW_LINE
0000001C px_time
0000001D sixteen_ms
0000001D DEV_DRAW_TRIANGLE
0000001E p_orient
0000001E DEV_DRAW_RECTANGLE
0000001F FOC
0000001F s_orient
0000001F DEV_DRAW_CURVE
00000020 DCB_OUTPOSX
00000020 DEV_SET_DIMEN
00000020 fill_colour
00000020 BLANK
00000020 TS_PREEMPT
00000020 TEXTROW
00000020 hi_char
00000020 E_BadDevNum
00000021 DEV_SET_COLOR_DEPTH
00000021 last_fire
00000022 DEV_SET_DESTBUF
00000022 last_hype
00000023 thump_snd
00000023 DEV_SET_DISPBUF
00000024 food_colour
00000024 DCB_OUTPOSY
00000024 thump_time
00000025 time_count
00000026 hyper
00000027 p_flag_off
00000027 hiscores
00000027 FOP
00000028 poison_colour
00000028 s_flag_off
00000028 DCB_OUTPOSZ
00000028 TCBHandleToPointer
00000029 s_fire_off
0000002B p_fire_off
0000002C plant_xy
0000002C DCB_INPOSX
0000002F flag_end
0000002F x_vel_off
00000030 DCB_INPOSY
00000030 TEXTCOL
00000032 def_animals
00000032 def_plants
00000034 DCB_INPOSZ
00000038 DCB_INBUFPTR
00000038 GFX_DEST_PIXEL_X
0000003B hinames
0000003C DCB_OUTBUFPTR
0000003C GFX_DEST_PIXEL_Y
0000003F BUFSIZE
00000040 DCB_INBUFSIZE
00000040 GFX_DEST_PIXEL_Z
00000040 TCBPointerToHandle
00000044 DCB_OUTBUFSIZE
00000044 TCBUSP
00000048 TCBSSP
00000048 DCB_INDIMX
0000004A p_xvel_off
0000004B s_xvel_off
0000004C DCB_INDIMY
0000004C f_xvel_off
0000004C TCBSR
00000050 TCBIAlloc
00000050 DCB_INDIMZ
00000050 BUFLEN
00000050 TCBPC
00000052 y_vel_off
00000054 TCBStatus
00000054 DCB_OUTDIMX
00000055 TCBPriority
00000058 DCB_OUTDIMY
00000058 SC_CAPSLOCK
00000059 SC_RSHIFT
00000059 game_count
0000005B expl_x_pos
0000005C DCB_OUTDIMZ
00000060 DCB_BKCOLOR
00000064 DCB_FGCOLOR
00000067 expl_y_pos
00000068 DCB_OPCODE
00000068 FRAMEBUF_BMPSIZE_X
0000006C FRAMEBUF_BMPSIZE_Y
0000006C TCBStartTick
0000006D p_yvel_off
0000006E TCBAlloc
0000006E s_yvel_off
0000006F f_yvel_off
00000070 TCBEndTick
00000070 DCB_INBUFPTR2
00000074 DCB_OUTBUFPTR2
00000074 GFX_CLIP_PIXEL0_X
00000074 TCBTicks
00000075 i_rk_count
00000076 rock_count
00000077 SC_NUMLOCK
00000077 sauc_cntdn
00000078 FRAMEBUF_WINDOW_DIMEN
00000078 GFX_CLIP_PIXEL0_Y
00000078 i_sauc_tim
00000079 r_hit_tim
0000007A hide_p_cnt
0000007B new_rocks
0000007C DCB_OUTBUFSIZE2
0000007C TCBNext
0000007C GFX_CLIP_PIXEL1_X
0000007C thmp_sndi
0000007C TCBIFree
0000007D min_rocks
0000007E p_xvlo_off
0000007E SC_SCROLLLOCK
0000007F p_yvlo_off
00000080 TCBPrev
00000080 TS_RUNNING
00000080 score_off
00000080 DCB_UNIT
00000080 GFX_CLIP_PIXEL1_Y
00000082 ships_off
00000082 TCBAffinityBase
00000083 high_off
00000084 DCB_SIZE
00000084 GFX_COLOR0
00000084 TCBAffinity
00000088 GFX_COLOR1
0000008C GFX_COLOR2
00000092 TCBFree
00000098 FRAMEBUF_COLOR_COMP
000000A0 TCBAffineChose
000000B0 FRAMEBUF_PPS
000000B0 GFX_TARGET_X0
000000B4 GFX_TARGET_Y0
000000B8 GFX_TARGET_X1
000000BC GFX_TARGET_Y1
000000D0 GFX_COLOR_COMP
000000D4 GFX_PPS
000000D8 TCBInsertIntoReadyQueue
000000E0 SC_EXTEND
000000F0 SC_KEYUP
000000F3 player_1
000000F4 plant_flag
00000100 TCB_SIZE
00000100 IRQ_trampolines
00000126 animal_xy
00000150 TCBRemoveFromReadyQueue
00000172 StartQ
00000173 p1_score
00000175 p1_ships
00000176 p1_high
0000017A TCBPopReadyQueue
000001EE animal_flag
000001F7 player_2
00000220 FemtikiInit
00000220 plant_spawn
00000221 animal_spawn
00000230 FemtikiInitIRQ
0000023E OSCallTable
00000240 CallOS
00000258 VIDEO_Y
00000277 p2_score
00000279 p2_ships
0000027A p2_high
0000027B p_2_end
000002AA GetRunningTCBPointer
000002C2 SelectThreadToRun
000002EC UpdateIRQLive
0000030E FemtikiTimerIRQ
00000320 VIDEO_X
00000396 LockSysSemaphore
000003A6 UnlockSysSemaphore
000003B8 start
00000400 irq_list_tbl
000004E0 loop2
000004E2 loop1
000004F4 start_other
0000051A do_nothing
00000520 setup_null
00000520 null_init
00000562 null_ret
00000564 null_cmdproc
00000568 keybd_init
00000568 setup_keybd
000005EC KBD_CMDTBL
0000060C keybd_cmdproc
0000062E keybd_stat
00000636 keybd_putchar
0000063E keybd_getchar
00000646 keybd_set_inpos
00000646 keybd_getbuf
00000646 keybd_putbuf
00000646 keybd_set_outpos
0000064A KeybdGetID
0000067C kgid1
00000684 kgnotKbd
00000688 KeybdSetLED
000006B4 KeybdInit
000006B4 _KeybdInit
000006E0 kbdi0002
0000074A kbdiTryAgain
00000758 kbdi0004
00000774 kbdi0005
00000778 ledxit
0000078E kbdiXmitBusy
0000079C msgBadKeybd
000007AB msgXmitBusy
000007C6 _KeybdGetStatus
000007E4 _KeybdGetScancode
00000800 STRAREASIZE
00000802 _KeybdClearIRQ
00000818 KeybdRecvByte
0000083A KeybdWaitTx
00000860 SetKeyboardEcho
00000868 CheckForKey
00000874 GetKey
000008AE CheckForCtrlC
000008BE KeybdGetCharNoWait
000008C6 KeybdGetCharWait
000008CE KeybdGetChar
00000AEA KeybdSetLEDStatus
00000B3A KeybdSendByte
00000B42 Wait10ms
00000B5E Wait300ms
00000B7A KeybdIRQ
00000C30 _unshiftedScanCodes
00000D30 _shiftedScanCodes
00000E30 _keybdControlCodes
00000EB0 _keybdExtendedCodes
00000F30 TEXTVID_CMDTBL
00000F94 textvid_cmdproc
00000FB8 setup_textvid
00000FFF MAX_TID
00001000 NR_TCB
00001010 textvid_init
000010B8 textvid_stat
000010BC textvid_getchar
000010C4 textvid_getbuf
000010C4 textvid_putbuf
000010C4 textvid_stub
000010C8 textvid_get_inpos
000010DE textvid_set_inpos
000010F4 textvid_set_outpos
0000110A textvid_get_outpos
00001120 textvid_get_outptr
00001146 textvid_get_color
00001156 textvid_getbuf1
00001166 textvid_set_unit
00001170 textvid_get_dimen
000011A0 textvid_clear
000011FA loop3
00001218 get_screen_color
00001238 CalcScreenLoc
00001262 textvid_putchar
00001280 dcx14
00001284 dcx7
0000128C dccr
000012AA dcx6
000012C0 dcx8
000012D6 dcx9
000012F4 dcx10
0000130C dcx12
00001316 dcx11
00001360 dclf
00001364 dcx16
00001368 dcx4
00001372 doBackspace
00001380 doDelete
000013B6 doCtrlX
000013DA IncCursorPos
000013F4 IncCursorRow
0000141C icc1
0000141E ScrollUp
00001464 BlankLastLine
000014BE HomeCursor
000014D0 SyncCursor
00001512 err_init
00001512 setup_err
0000153E err_ret
00001540 err_cmdproc
00001544 COM_CMDTBL
00001574 setup_serial
00001574 serial_init
000015D8 serial_cmdproc
000015FA serial_stat
000015FE serial_putchar
00001606 serial_getchar
0000160C serial_getchar_direct
00001614 serial_peek_char
0000161C serial_peek_char_direct
00001624 serial_putchar_direct
0000162C serial_set_inpos
0000162C serial_putbuf
0000162C serial_set_outpos
0000162C serial_getbuf
00001630 SerialInit
0000166E SerialGetChar
000016E6 SerialPeekChar
00001722 SerialPeekCharDirect
0000173C SerialPutChar
000017A0 SerialPutCharDirect
000017BC SerialRbo
000017C4 SerialRcvCount
000017E4 SerialIRQ
000017F8 sirqNxtByte
0000180A sirq0001
0000185A sirqRxFull
0000185A notRxInt
000018A8 notTxInt
000018A8 sirqXmitOff
000018A8 sirqTxEmpty
000018A8 sirq0002
000018BA nmeSerial
000018C4 FRAMEBUF_CMDTBL
00001954 framebuf_cmdproc
00001978 setup_framebuf
000019E6 framebuf_init
00001A90 framebuf_set_destbuf
00001A90 framebuf_putchar
00001A90 framebuf_getchar
00001A90 framebuf_stat
00001A92 framebuf_set_inpos
00001AA0 framebuf_set_outpos
00001AAE framebuf_getbuf1
00001AB6 framebuf_getbuf2
00001ABE framebuf_setbuf1
00001ACC framebuf_setbuf2
00001ADA framebuf_swapbuf
00001B38 framebuf_set_dispbuf
00001B42 framebuf_set_unit
00001B4C framebuf_getbuf
00001B4C framebuf_stub
00001B4C framebuf_putbuf
00001B50 framebuf_set_color_depth
00001B62 framebuf_get_color
00001B72 framebuf_get_dimen
00001BA2 framebuf_set_dimen
00001C1E plot
00001C1E framebuf_writeat
00001C54 plottbl
00001C90 plot_sw
00001CB6 plot_or
00001CCA plot_xor
00001CE0 plot_and
00001CF4 plot_copy
00001D02 plot_black
00001D0C plot_white
00001D18 clear_graphics_screen
00001D4C framebuf_clear
00001DEC GFXACCEL_CMDTBL
00001E7C gfxaccel_cmdproc
00001EA0 setup_gfxaccel
00001F20 gfxaccel_init
00001F82 gfxaccel_stat
00001F90 gfxaccel_stub
00001F90 gfxaccel_getbuf2
00001F90 gfxaccel_getbuf1
00001F90 gfxaccel_set_inpos
00001F90 gfxaccel_set_dispbuf
00001F90 gfxaccel_getbuf
00001F90 gfxaccel_set_outpos
00001F90 gfxaccel_swapbuf
00001F90 gfxaccel_set_unit
00001F90 gfxaccel_get_outpos
00001F90 gfxaccel_get_inpos
00001F90 gfxaccel_setbuf2
00001F90 gfxaccel_get_dimen
00001F90 gfxaccel_writeat
00001F90 gfxaccel_putchar
00001F90 gfxaccel_putbuf
00001F90 gfxaccel_get_outptr
00001F90 gfxaccel_getchar
00001F90 gfxaccel_setbuf1
00001F94 gfxaccel_set_dimen
00001FC8 gfxaccel_set_destbuf
00001FF4 gfxaccel_clear
00002088 gfxaccel_set_color_depth
0000209A gfxaccel_get_color
000020A8 gfxaccel_set_color
000020C8 gfxaccel_set_color123
00002100 gfxaccel_clip_rect
00002144 gfxaccel_set_active_point
00002170 gfxaccel_plot_point
000021C2 gfxaccel_draw_line
0000222A gfxaccel_draw_rectangle
00002292 gfxaccel_draw_triangle
0000231A gfxaccel_draw_curve
000023A0 gfxaccel_wait
000023CE GlobalReadLong
000023D4 GlobalWriteLong
000023D8 nd2
000023D8 net_delay
000023D8 nd1
000023D8 nd4
000023D8 nd3
000023DC InitIOPBitmap
00002428 InitRand
00002428 RandInit
00002492 RandGetNum
000024C2 prng
0000251C _GetRand
00002540 RandWait
00002558 InitSemaphores
0000257E LockSemaphore
000025A0 ForceUnlockSemaphore
000025BA UnlockSemaphore
000025D6 T15LockSemaphore
000025DC T15UnlockSemaphore
000025E2 T15GetFloat
000025F0 T15Abort
00002600 chk_exception
00002614 Delay3s
00002622 dly3s2
00002624 dly3s1
00002638 Delay3s2
00002654 cpu_test
00002732 ALL_DONE
00002734 BSR_FAR1
0000273C EXCEPTION_6
00002744 EXCEPTION_7
0000274C op_ORI_TO_CCR
0000276E op_ORI_TO_SR
00002790 op_EORI_TO_CCR
000027B6 op_EORI_TO_SR
000027DC op_ANDI_TO_CCR
00002802 op_ANDI_TO_SR
00002828 op_BTST
000029B2 op_BTST0
000029BE op_BTST1
000029C6 op_BTST2
000029CE op_BTST3
000029D6 op_BTST4
000029DE op_BTST5
000029E6 op_BTST6
000029EE op_BTST7
000029F6 op_BTST8
000029FE op_BTST9
00002A06 op_BTST10
00002A0E op_BTST11
00002A14 op_BTST12
00002B6C op_BTST20
00002B76 op_BTST21
00002B7C op_BTST22
00002B82 op_BTST23
00002B88 op_BTST24
00002B8E op_BTST25
00002B94 op_BTST26
00002B9A op_BTST27
00002BA0 op_BTST28
00002BA6 op_BTST29
00002BAC op_BTST30
00002BB2 op_BTST31
00002BB6 op_BTST32
00002BD2 op_BCHG
00002F3A op_BCLR
00003288 op_BSET
000035D0 op_MOVEP
0000365C op_BOOL_I
00003806 BSR_CLOSE1
0000380E op_BSR
0000383C BSR_CLOSE2
00003844 op_CMP_I
00003A2C op_ADD_I
00003BB2 op_SUB_I
00003D38 op_MOVE
00003E04 MOVE2
00003E80 MOVE1
00003F00 MOVE3
00003F44 op_MOVE_xxx_FLAGS
00004000 REL4
0000405A MOVE4
00004138 op_EXT
00004164 op_SWAP
0000417A op_LEAPEA
00004212 LEA1
00004226 op_TAS
0000424C op_TST
0000428A op_LINKS
000042A8 op_MOVE_USP
000042B8 op_CHK
00004302 op_NEGS
00004690 op_MOVEM
000049AE op_ABCD
000049CE ABCD_OUTER1
000049D0 ABCD_INNER1
000049EC ABCD_NO_C1
000049F4 ABCD_NO_C2
00004A3C ABCD_OUTER2
00004A3E ABCD_INNER2
00004A5A ABCD_NO_C3
00004A62 ABCD_NO_C4
00004AA6 op_SBCD
00004AC6 SBCD_OUTER1
00004AC8 SBCD_INNER1
00004AE4 SBCD_NO_C1
00004AEC SBCD_NO_C2
00004B34 SBCD_OUTER2
00004B36 SBCD_INNER2
00004B52 SBCD_NO_C3
00004B5A SBCD_NO_C4
00004B9E op_NBCD
00004BB6 NBCD_LOOP
00004BC2 NBCD_NO_C
00004BC6 NBCD_NO_Z
00004BFC NBCD_LOOP1
00004C10 NBCD_NO_C1
00004C14 NBCD_NO_Z1
00004C30 op_TRAPV
00004C4C op_RTR
00004C58 RTR_DONE
00004C66 BSR_FAR2
00004C6E op_BCC
00004C76 BCC1
00004C80 BCC2
00004C88 BCC3
00004C92 BCC4
00004C9A BCC5
00004CA4 BCC6
00004CAC BCC7
00004CB6 BCC8
00004CBE BCC9
00004CC8 BCC10
00004CD0 BCC11
00004CDA BCC12
00004CE2 BCC13
00004CEC BCC14
00004CEE op_DBCC
00004CF6 DBCC_LOOP1
00004D04 DBCC_LOOP2
00004D14 op_SCC
00004D44 op_ADDQ
00004D58 ADDQ_LOOP1
00004D96 ADDQ_LOOP2
00004DCC ADDQ_LOOP3
00004DFE op_SUBQ
00004E16 SUBQ_LOOP1
00004E50 SUBQ_LOOP2
00004E86 SUBQ_LOOP3
00004EB8 op_MOVEQ
00004ED4 op_DIVU
00004EF0 DIVU_OUTER1
00004F26 op_DIVS
00004F42 DIVS_OUTER1
00004F78 op_OR
00004F98 OR_OUTER1
00005000 REL5
0000500C OR_OUTER2
00005062 op_AND
00005082 AND_OUTER1
000050F6 AND_OUTER2
0000514C op_EOR
0000516C EOR_OUTER2
000051C2 op_CMP
000051E2 CMP_OUTER1
00005238 op_CMPA
00005258 CMPA_OUTER1
0000529E op_CMPM
000052E6 CMPM_LOOP1
00005300 CMPM_LOOP2
0000531A CMPM_LOOP3
00005344 op_ADD
00005364 ADD_OUTER1
000053D8 ADD_OUTER2
0000542E op_SUB
0000544E SUB_OUTER1
000054C2 SUB_OUTER2
00005518 op_ADDA
0000553E ADDA_OUTER1
00005564 op_SUBA
0000558A SUBA_OUTER1
000055B0 op_ADDX
000055D0 ADDX_OUTER1
00005664 ADDX_LOOP3
00005680 ADDX_LOOP4
0000569C ADDX_LOOP5
000056C0 op_SUBX
000056E0 SUBX_OUTER1
00005774 SUBX_LOOP3
00005790 SUBX_LOOP4
000057AC SUBX_LOOP5
000057D0 op_MULU
000057EC MULU_OUTER1
0000581C op_MULS
00005838 MULS_OUTER1
00005868 op_EXG
000058CA ROx_FLAGS
000058D6 op_ROx
000058E0 ROx_LOOP1
00005900 ROx_LOOP2
00005920 ROx_LOOP3
00005940 ROx_LOOP4
00005960 ROx_LOOP5
00005982 ROx_LOOP6
00005B00 ROXx_FLAGS
00005B0C op_ROXx
00005B16 ROXx_LOOP1
00005B36 ROXx_LOOP2
00005B56 ROXx_LOOP3
00005B76 ROXx_LOOP4
00005B96 ROXx_LOOP5
00005BB8 ROXx_LOOP6
00005D36 SHIFTS_FLAGS
00005D42 op_SHIFTS
00005D4C SHIFTS_LOOP1
00005D6C SHIFTS_LOOP2
00005D8C SHIFTS_LOOP3
00005DAC SHIFTS_LOOP4
00005DCC SHIFTS_LOOP5
00005DEE SHIFTS_LOOP6
00005F78 SHIFTS2_FLAGS
00005F84 op_SHIFTS2
00005F8E SHIFTS2_LOOP1
00005FAA SHIFTS2_LOOP2
00005FC6 SHIFTS2_LOOP3
00005FE2 SHIFTS2_LOOP4
00005FFE SHIFTS2_LOOP5
0000601C SHIFTS2_LOOP6
000061A2 START
000061A4 GOWARM
000061A8 GOOUT
000061AC GOIN
000061B0 GOAUXO
000061B4 GOAUXI
000061B8 GOBYE
000061BC TXTBGN
000061C0 ENDMEM
000061C4 CSTART
00006230 WSTART
00006264 ST3
000062B6 ST4
000062F0 ClearStringArea
00006310 ClearStringStack
00006324 TAB1
00006353 TAB2
000063BC TAB4
000063EE TAB5
000063F1 TAB6
000063F6 TAB8
00006401 TAB9
00006405 TAB10
00006408 TAB11
0000640D TAB12
00006414 TAB1_1
00006444 TAB2_1
000064A8 TAB4_1
000064DC TAB5_1
000064E4 TAB6_1
000064EC TAB8_1
00006508 TAB9_1
00006510 TAB10_1
00006518 TAB11_1
00006520 TAB12_1
00006528 DIRECT
00006538 EXEC
00006540 EXLP
0000654A EXNGO
00006562 EX1
00006568 EXMAT
0000656E EXGO
00006572 INCON
00006580 INCOM
0000658E IOCOM
00006598 OUTCOM
000065A4 IOCON
000065AE OUTCON
000065BA NEW
000065CE STOP
000065D6 RUN
000065EA RUNNXL
0000662A RUN1
00006636 RUNTSL
00006640 RUNSML
00006650 GOTO
00006664 ONIRQ
0000667E ONIRQ1
00006688 WAITIRQ
00006698 LIST
000066A4 LS1
000066B8 LS2
000066BE LS3
000066C4 PRINT
000066D4 PR2
000066E2 PR0
000066F0 PR1
000066FE PR3
0000670A PR6
00006710 PR8
0000672C PR9
00006746 FINISH
0000674E GOSUB
00006788 RETURN
000067B4 FOR
000067CE FR1
000067E6 FR2
000067EC FR3
000067F2 FR4
000067FA FR5
0000680C FR6
00006818 FR7
00006830 FR8
00006834 NEXT
0000683E NX0
00006850 NX3
0000687E NX1
00006896 NX2
0000689E REM
000068A0 IF
000068A4 IF1
000068AA IF2
000068BA INPERR
000068C8 INPUT
000068EC IP7
000068F6 IP6
000068FA IP2
00006914 IP3
0000694E IP4
0000695A IP5
0000695E DEFLT
00006966 LET
00006972 LT1
00006976 LOAD
00006982 LOD1
0000699C LOD2
000069AC LODEND
000069B6 GBYTE
000069BA GBYTE1
000069C8 GBYTE2
000069D6 SAVE
000069DE SAVE1
00006A02 SAVE2
00006A10 SAVEND
00006A34 PBYTE
00006A36 PBYTE1
00006A4A PBYTE2
00006A54 POKE
00006ACA PKER
00006ACE CALL
00006AE4 TEXT
00006B14 TEXTERR
00006B18 DRAWBUF
00006B28 DISPBUF
00006B38 COLOR
00006B44 COLOR2
00006B4C COLOR1
00006B52 COLOR3
00006BAC COLORERR
00006BB2 COLORERR1
00006BB8 COLORERR2
00006BC0 POINT
00006BE2 POINTERR
00006BE6 LINE
00006C28 LINEERR
00006C2C LINEERR1
00006C32 LINEERR2
00006C38 RECT
00006C7E TRIANGLE
00006CDE TRIERR
00006CE2 TRIERR1
00006CE8 TRIERR2
00006CEE TRIERR3
00006CF6 TRIERR4
00006CFE CURVE
00006D5A XP_PUSH
00006D70 XP_POP
00006D86 XP_POP1
00006D9C NUM_EXPR
00006DAA INT_EXPR
00006DBC EXPR
00006DBC EXPR_OR
00006DCC XP_OR
00006DE2 EXPR_AND
00006DF4 XP_AND
00006E0A XP_ORX
00006E0A XP_ANDX
00006E10 CheckNumeric
00006E22 EXPR_REL
00006E36 XP11
00006E42 XP12
00006E4E XP13
00006E5A XP14
00006E66 XP15
00006E72 XP15RT
00006E74 XP16
00006E82 XPRT0
00006E8A XPRT1
00006E92 XP17
00006E98 XP18
00006EAC EXPR2
00006EBA XP21
00006EC0 XP22
00006EC4 XP23
00006ED2 XP24
00006F00 XP25
00006F06 XP26
00006F1A XP27
00006F1C ConcatString
00006F8A EXPR3
00006F8C XP36
00006F90 XP30
00006F9C XP31
00006FB2 XP34
00006FCC XP35
00006FD2 XP_MOD
00006FF4 EXPR4
00007000 XP40
00007000 REL7
00007010 EXP4RT
00007012 XP41
00007022 XPSTNG
0000702C XP45
0000707E XP44
0000708A PARN
0000709A XP42
0000709C XP43
000070A0 AllocateString
000070FE GarbageCollectStrings
0000713A NextString
00007150 StringInVar
0000716E SIV1
00007196 PointsIntoStringArea
000071BA StringOnStack
000071EA UpdateStringPointers
00007216 USP1
00007238 TSTV
00007280 TV1
000072B0 TV2
000072B8 TSTVRT
000072BA DIV32
000072CC DIV1
000072D2 DIV2
000072D8 DIV3
000072E6 DIV4
000072F4 DIVRT
000072F6 PEEK
0000735E RND
00007388 ABS
00007394 SIZE
000073A4 TICK
000073B0 CORENO
000073BC LorRArgs
000073F4 LorR1
000073F8 MID
00007440 MID2
00007458 MID5
00007460 DOMID
0000748C MID4
000074BE MID1
000074C2 LEFT
000074CE RIGHT
000074F6 LEN
0000751C INT
00007532 CHR
0000756A SETVAL
00007588 SV1
0000758A FIN
00007596 FI1
000075A2 FI2
000075A4 ENDCHK
000075B4 ENDCHK1
000075B6 QWHAT
000075B8 AWHAT
000075BC ERROR
000075F6 QSORRY
000075F8 ASORRY
000075FE QHOW
00007600 AHOW
00007606 ETYPE
0000760C GETLN
0000761C GL1
0000763A GL2
0000764E GL3
00007672 GL4
0000767E GL5
0000769A GL6
000076A2 GL7
000076AA FNDLN
000076B8 FNDLNP
000076CE FNDRET
000076D0 FNDNXT
000076D2 FNDSKP
000076E0 MVUP
000076E8 MVRET
000076EA MVUPW
000076F4 MVDOWN
000076FC POPA
00007738 PUSHA
0000776E PRTSTG
00007770 PS1
00007788 PRTRET
0000778A PRTSTR2a
00007790 PRTSTR2
00007796 PRTNUM
000077E0 PRTLN
000077FE TSTC
00007810 TC1
00007816 TSTNUM
00007862 IGNBLK
0000786C TOUPBUF
00007872 TOUPB1
00007892 TOUPBRT
00007894 DOQUO
0000789C DOQUO1
000078A4 TOUPPER
000078B4 TOUPRET
000078B6 CHKIO
000078C6 CHKRET
000078C8 PRMESG
000078D2 PRMRET
000078D4 CLS
000078E0 OUTC
000078F0 INC
000078FC INC1
00007910 AUXOUT
00007924 AUXIN
00007942 AXIRET
00007944 BYEBYE
00007952 INITMSG
00007976 OKMSG
0000797D HOWMSG
00007984 WHTMSG
0000798C TYPMSG
00007994 NOSTRING
000079A6 SRYMSG
000079AC CLMSG
000079B0 LSTROM
000079B0 RANPNT
000079B4 INPPTR
000079B8 OUTPTR
000079BC CURRNT
000079C0 STKFP
000079C4 STKGOS
000079C8 STKINP
000079CC LOPVAR
000079D0 LOPINC
000079DC LOPLMT
000079E8 LOPLN
000079EC LOPPT
000079F0 IRQROUT
000079F4 STRSTK
000079F8 StrSp
000079FC StrArea
00007A00 LastStr
00007A04 TXTUNF
00007A08 VARBGN
00007A0C STKLMT
00007A10 DIRFLG
00007A14 BUFFER
00007A64 set_text_mode
00007A64 TXT
00007A8E set_graphics_mode
00007AB8 get_screen_address
00007ACA CRLF
00007AE4 DisplayString
00007AE8 dspj1
00007AF4 dsret
00007AFA DisplayStringCRLF
00007AFE DisplayStringLimited
00007B1E DisplayStringLimitedCRLF
00007B22 TRAP15
00007B3C T15DispatchTable
00007CCC SimHardware
00007CDC GetTick
00007CE4 T15Wait100ths
00007D00 SetDrawMode
00007D22 SetPenColor
00007D2E T15Rectangle
00007D40 T15GetPixel
00007D60 T15GetWindowSize
00007D76 GRBufferToScreen
00007D7E TestBitmap
00007E1E Diagonal1
00007E3E Diagonal2
00007E68 Vertical1
00007E84 Vertical2
00007EAC MoveToXY
00007EBA DrawToXY
00007F38 DrawHorizTo
00007F6A DrawVertTo
00007F9A Cursor1
00007FD2 StubRout
00007FD4 select_iofocus
00007FE6 rotate_iofocus
00007FF8 select_focus1
00008000 def_leaf
00008016 init_plic
0000804C cmdString
00008090 grCmdString
000080B0 cmdTable
00008124 FromScreen
0000812E StartMon
00008138 cmdMonitor
00008138 Monitor
00008158 PromptLn
00008164 Prompt3
0000817A Prompt1
00008194 cmdDispatch
000081DA cmdVideoMode
0000821C cmdBreakpoint
00008240 cmdAsteroids
00008248 cmdPlants
00008252 cmdTinyBasic
00008256 cmdTestCPU
00008266 cmdClearScreen
00008272 cmdCore
00008296 cmdFMTK
000082A0 cmdTestFP
0000832C cmdTestGF
0000835A cmdClock
00008378 cmdReset
000083AA tblPow2
000083CA DisplayHelp
000083CA cmdHelp
000083D6 HelpMsg
00008573 msgUnknownCmd
00008583 msgHello
00008594 GetCmdLine
00008638 cmdSendSerial
00008668 cmdReceiveSerial
0000869C cmdFillB
000086F0 cmdFillW
00008744 cmdFillL
00008790 ignBlanks
000087A2 PeekScreenChar
000087A8 GetSzChar
000087CE EditMemHelper
000087F0 cmdEditMemory
000087FA edtmem1
00008864 cmdJump
00008864 ExecuteCode
00008874 cmdGrDemo
00008908 plot_rand_points
00008986 clear_graphics_screen2
000089CE white_rect
000089F2 rand_points
00008A28 rand_lines
00008A7E rand_rect
00008AD4 rand_rect2
00008B1A rand_triangle
00008B8C rand_curve
00008BFE cmdDisassemble
00008C4E cmdDumpMemory
00008C72 DumpMem1
00008C84 DisplayMem
00008CB0 dspmem1
00008D1A cmdDumpRegs
00008D9A msg_regs
00008D9E msg_reglist
00008DC4 cmdTestSerialReceive
00008DE8 GetHexNumber
00008E16 GetDecNumber
00008E50 _dfOne
00008E5C _dfTen
00008E68 _dfMil
00008E74 _msgNan
00008E78 _msgInf
00008E7C _CheckNan
00008EE0 _CheckZero
00008EFA _CheckNegative
00008F0C _MakeBig
00008F28 _LessThanDbl
00008F54 _ComputeDigitsBeforeDecpt
00008F8E _LeadingZero
00008F9E _SpitOutDigits
0000901A _TrimTrailingPoint
00009038 _TrimDotZero
00009054 _TrimTrailingZeros
00009060 _SpitOutE
00009078 _ExtExpDigit
00009096 _ExtExpDigits
000090BE _PadLeft
0000910E _PadRight
00009140 _FloatToString
00009182 _GetFloatGetChar
00009188 _GetFloatIgnBlanks
00009190 _GetFloatBackupChar
00009194 _GetFraction
000091F8 _GetExponent
00009282 _GetInteger
000092F8 _GetFloat
00009370 AsciiToHexNybble
00009382 gthx5
00009394 gthx6
000093A6 gthx3
000093AA DisplayTwoSpaces
000093B4 dspspc1
000093BC DisplaySpace
000093C4 DisplayTetra
000093CA DisplayWyde
000093D0 DisplayByte
000093D6 DisplayNybble
000093F0 BufTetra
000093F6 BufWyde
000093FC BufByte
00009402 BufNybble
0000941A DisplayAddr
0000943A ramtest
0000943A cmdTestRAM
00009454 rmtst5
00009484 ramtest0
0000948C ramtest1
0000949E rmtst1
000094AA ramtest6
000094BA ramtest2
000094D2 rmtst2
000094DA rmtst3
00009500 ramtest3
00009502 cmdLoadS19
00009508 NextRec
0000951A ProcessRec
000095B2 pcssxa
0000961E ProcessS1
00009622 ProcessS2
00009626 ProcessS3
0000962A ProcessS7
0000963C ProcessS8
0000964E ProcessS9
00009660 S19Get16BitAddress
0000966E S19Get24BitAddress
0000967A S19Get32BitAddress
00009698 S1932a
000096AC S1932b
000096EE sGetChar
00009716 AudioInputTest
00009718 BouncingBalls
0000971A GraphicsDemo
0000971C ClearScreen
00009724 rbo
0000972C i2c_setup
0000972C init_i2c
0000973C i2c_wait_tip
0000974C i2c_wr_cmd
0000975C i2c_xmit1
0000977A i2c_wait_rx_nack
0000978A rtc_read
00009816 rtc_write
00009880 msgRtcReadFail
00009899 msgBusErr
000098AA bus_err
000098C4 trap3
00009902 ProcessBreakpoint
00009908 DisarmAllBreakpoints
00009934 ArmAllBreakpoints
00009964 ArmBreakpoint
000099E2 DisarmBreakpoint
00009A36 ListBreakpoints
00009A56 ClearBreakpointList
00009A68 SendMsg
00009AA6 ReceiveMsg
00009AE8 DispatchMsg
00009AEA prtflt
00009B30 T15FloatToString
00009B64 io_trap
00009B8A OutputChar
00009BA4 InitIRQ
00009BBC InstallIRQ
00009C00 TickIRQ
00009C42 irq_rout
00009C42 irq6_rout
00009C42 irq3_rout
00009C56 irq_proc_generic
00009C74 SpuriousIRQ
00009C76 nmi_rout
00009C88 addr_err
00009C9E brdisp_trap
00009CD6 illegal_trap
00009CEC io_irq
00009D00 msg_start
00009D27 msg_core_start
00009D38 msgAddrErr
00009D45 msg_illegal
00009D57 msg_bad_branch_disp
00009D69 msg_test_done
00009D79 msg_io_access
00009D94 msgChk
00009DA2 msgStackCanary
00009DBC ShiftBuf
00009DD6 HEX2DEC2
00009E24 HEX2DEC
00009E34 HX2DC
00009E38 HX2DC0
00009E40 HX2DC1
00009E5A HX2DC2
00009E5C HX2DC22
00009E66 HX2DC3
00009E6E HX2DC4
00009E76 HX2DC5
00009E7E HX2DC57
00009E82 HX2DC6
00009E88 PNT4HEX
00009E88 PNT4HX
00009E8C PNT6HX
00009E98 PNT8HX
00009E9C FRELADDR
00009EAA FREL10
00009EBC FREL15
00009ED6 FREL20
00009EE8 FREL25
00009EF2 FREL30
00009EFA IMOVEMFR
00009EFA X
00009F0E IM7788
00009F12 IM7799
00009F28 IMOVEMTR
00009F42 CS16
00009F44 ISTOP
00009F58 IMMED
00009F7E IMMED45
00009FB0 CS15
00009FB2 IMMED55
00009FB8 IMMED65
00009FC8 IMMED75
00009FCC IMOVE
00009FD0 ILINK
00009FE6 FORM1
00009FEA FORM1A
00009FEE CS14
00009FF0 FORM3
00009FF4 FORM4
0000A000 DRAW
0000A006 FORM5
0000A00A FORM6A
0000A01A FORM6D
0000A02A FORMREGA
0000A02E FORMREG5
0000A03A FORMREGD
0000A040 FORM7
0000A04C FORM8
0000A050 FORM815
0000A058 CS13
0000A05A FORM9
0000A060 EEA10
0000A064 FORM10EX
0000A086 FORM10E3
0000A08E FORM10E4
0000A09A FORM10E6
0000A0A2 FORM10
0000A0A8 FORM103
0000A0AC FORM104
0000A0BC FORM105
0000A0D2 CS12
0000A0D6 FORM11
0000A0DE FORM11SL
0000A0F2 FORM112
0000A100 FORM114
0000A102 FORM12
0000A11C FORM125
0000A13E FORM12A
0000A162 CS11
0000A166 IQUICK
0000A16A IMOVEQ
0000A182 SCHR
0000A18A IMVFSR
0000A198 IMVFUSP
0000A1A6 IMVTSR
0000A1B4 IMVT44
0000A1B8 IMVTUSP
0000A1C4 IMVTCCR
0000A1D4 IMOVEP
0000A1E4 IMOVEP11
0000A1FC CS20
0000A200 IMOVEP35
0000A20E IMOVEP66
0000A22A SCOMMON
0000A22E ISCC
0000A238 IDBCC
0000A24A ICC
0000A24E IBSR
0000A260 ICC35
0000A276 ICC55
0000A286 ISETD
0000A28C ISETD12
0000A294 CS18
0000A296 ISETS
0000A2B0 ISHIFT
0000A2BC ISHIFT13
0000A2E0 ISHIFT23
0000A2EC ISHIFT33
0000A2F0 ISHIFT44
0000A2F8 CS17
0000A2FA ISHIFTM1
0000A314 ICCCC
0000A32A ICCCC9
0000A32C BRTBL
0000A34C IMOVEA1
0000A372 IMOVE19
0000A378 IQUICKA
0000A38A IQUICK21
0000A3A0 IQUICK31
0000A3A4 CS19
0000A3A8 FORMSIZE
0000A3BC FORM91
0000A3D0 FORM93
0000A3D2 FORM95
0000A3D4 EA000
0000A3E0 EA001
0000A3EC EA010
0000A400 EA011
0000A416 EA011RTS
0000A418 EA100
0000A42E FE10
0000A432 EEA
0000A496 EA1105
0000A49A EA1107
0000A4B0 EA1109
0000A4BA EA101
0000A4D0 EA111
0000A4EE EA1112
0000A50A EA1113
0000A516 FE11
0000A51A EA1113A
0000A53C EA1114
0000A584 EAF25
0000A588 EAF27
0000A59C EAF35
0000A5A6 EA1115
0000A5DE EA11153
0000A5E8 EA11155
0000A5F4 MOVEMS
0000A604 MOVEMS2
0000A608 MOVEMR
0000A618 MOVEMR11
0000A620 MOVEMR33
0000A632 MOVEMR44
0000A64C MOVEMR77
0000A65E MOVEMR79
0000A660 MOVEMR88
0000A678 MOVEMR94
0000A684 DCODE68K
0000A698 DEC311
0000A6B6 DEC404
0000A6C6 DEC411
0000A6D4 FE12
0000A6D6 DEC425
0000A6E2 DEC510
0000A6E6 DEC515
0000A6EE DEC530
0000A6F4 DEC535
0000A700 DEC537
0000A71C COMMON4
0000A71E COMMON
0000A72C COMMON35
0000A746 FERROR
0000A750 FERROR35
0000A75C FERROR39
0000A766 MSG111
0000A770 KI
0000A772 TBL
0000A772 KIEND
0000AA2A TBLE
0000AA2A OPCTBL
0000AB2A asteroids_start
0000AB32 main_loop
0000AB88 skip_player_move
0000AB8C skip_player_cont
0000AB90 px_hide
0000AB98 no_play
0000ABB6 no_dec_new_rocks
0000ABC6 game_message
0000ABDA do_start_mess
0000ABFE start_game
0000AC32 push_start_mess
0000AC48 exit_push_start
0000AC4A game_over
0000AC5E nodec_thmpi
0000AC88 no_game_over
0000ACC6 exit_game_message
0000ACC8 end_game
0000ACDC check_hits
0000ACDE pss_check_loop
0000ACE4 next_pss
0000ACEA check_pss
0000ACF8 check_next_object
0000ACFC check_all
0000AD16 delta_x_pos
0000AD28 delta_y_pos
0000AD50 small_s_size
0000AD52 add_p_size
0000AD54 no_add_size
0000AD62 col_table
0000AD6A col_table_p
0000AD72 col_table_s
0000AD7A col_table_l
0000AD82 handle_collision
0000AD92 not_saucer
0000ADA0 not_player
0000ADB8 not_pss_player
0000ADC4 what_hit_rock
0000ADC8 explode_object
0000ADE4 player_shot
0000ADF0 what_hit_saucer
0000AE08 keep_small
0000AE0E do_saucer
0000AE3A attract_saucer
0000AE44 rock_hit_out
0000AE62 dec_isaucer_time
0000AE72 no_save_ist
0000AE84 saucer_yok
0000AE98 start_left
0000AEC0 small_saucer
0000AEC2 save_saucer
0000AEC6 exit_do_saucer
0000AEC8 existing_saucer
0000AEE0 keep_saucer_dir
0000AEEC attract_fire
0000AEF2 exit_existing_saucer
0000AEF4 saucer_yvel
0000AEF8 fire_saucer
0000AF10 aim_shot
0000AF58 wide_shot
0000AF62 no_shot_or
0000AF66 no_aim_shot
0000AF78 shot_mask
0000AF7A shot_or
0000AF7C ship_fire
0000AF9A test_fire_loop
0000AFA6 save_ship_fire
0000AFAA exit_ship_fire
0000AFAC fire_shot
0000AFFE calc_fire_byte
0000B000 HALT
0000B012 test_neg_fire
0000B01A fire_ok
0000B024 enter_hiscores
0000B052 no_playerx
0000B0BE next_p_high
0000B0DA close_all
0000B0F2 next_hi_char
0000B10A save_hbutton
0000B120 not_timed_out
0000B13C not_rot_left
0000B144 not_rot_right2
0000B144 was_rot_left
0000B144 rot_not_left
0000B164 wrap_to_a
0000B168 wrap_to_z
0000B16A check_alpha
0000B172 save_char
0000B176 exit_not_done
0000B178 exit_enter_hiscores
0000B17A hyperspace
0000B1B6 hype_xok1
0000B1C0 hype_xok2
0000B1DE hype_yok1
0000B1E8 hype_yok2
0000B204 save_hyperspace
0000B208 exit_hyperspace
0000B20A reset_game
0000B218 three_ship_start
0000B226 clear_items_loop
0000B234 write_initial
0000B24E add_character
0000B25E add_ships
0000B268 show_ships
0000B27A add_ships_loop
0000B286 exit_add_ships
0000B288 move_items
0000B28C move_next_item
0000B2A8 skip_play_inc
0000B2C2 no_new_rocks
0000B2CA go_reset_play
0000B2D0 go_reset_sauc
0000B2D8 item_exploding
0000B2F0 no_reset_scale
0000B2F2 move_item
0000B304 x_pos_neg
0000B314 not_x_max
0000B32A y_not_neg
0000B334 not_y_max
0000B358 keep_scale
0000B35E move_next_object
0000B366 clear_saucer
0000B37A ship_move
0000B3A8 reveal_player
0000B3B0 kill_the_player
0000B3C6 clear_hyper
0000B3CA exit_ship_move
0000B3CC rot_and_thrust
0000B3D8 not_rot_left1
0000B3E0 not_rot_right1
0000B43E not_thrust
0000B474 check_velocity
0000B482 check_neg_velocity
0000B48C exit_check_velocity
0000B48E check_clear
0000B492 check_clear_loop
0000B4AC check_clear_y
0000B4C0 not_closer
0000B4CA is_closer
0000B4D0 make_rocks
0000B4FA no_inc_min
0000B50A no_set_max
0000B516 gen_rock_loop
0000B548 rock_y_ok
0000B54A rock_on_x
0000B56C clear_rocks
0000B56E clear_rocks_loop
0000B576 exit_make_rocks
0000B578 player_init
0000B5AE player_reset
0000B5C4 copy_rock
0000B5C8 copy_rock_2
0000B5EE copy_velocity
0000B5FE x_off_pos
0000B618 y_off_pos
0000B624 limit_velocity
0000B62E neg_upper_ok
0000B638 limit_p_vel
0000B640 pos_lower_ok
0000B648 exit_limit_velocity
0000B64A static_messages
0000B68E skip_play_flash
0000B6A2 do_p1_ships
0000B716 do_p2_score
0000B72A skip_p2_score
0000B738 exit_static
0000B73A add_to_list
0000B76E add_item
0000B788 add_explode
0000B78E add_saucer
0000B794 add_fire
0000B7A4 no_shot_dec
0000B7A6 add_score
0000B7D4 exit_add_score
0000B7DA high_scores
0000B80C high_scores_loop
0000B87A exit_high_scores
0000B880 exit_no_scores
0000B886 find_rock
0000B888 find_next_rock
0000B892 exit_find_rock
0000B894 ship_wrk_x
0000B8A0 ship_wrk_y
0000B8AC add_play_explode
0000B8BE reset_xy_loop
0000B8D6 no_reset_xy
0000B8E0 piece_draw_loop
0000B906 vec_x_pos
0000B912 vec_y_pos
0000B946 ship_parts
0000B952 add_player
0000B968 no_pos_reflect
0000B96E third_quad
0000B97C first_quad
0000B9A2 no_thrust
0000B9A4 copy_short
0000B9A8 copy_vectors
0000B9C2 exit_copy_vectors
0000B9C4 fx_sounds
0000B9D2 no_saucer_sound
0000BA04 no_thump_sound
0000BA06 hit_a_rock
0000BA20 clear_rock
0000BA34 add_to_score
0000BA3C skip_add
0000BA76 exit_hit_a_rock
0000BA78 rock_score
0000BA7C check_hiscores
0000BA98 check_hi_player
0000BAA0 check_hi_loop
0000BAAE check_hi_next
0000BACE save_hi_index
0000BAD2 exit_hi_chk
0000BADC exit_check_hiscores
0000BADE insert_hiscore
0000BAE2 insert_loop
0000BB04 exit_insert_loop
0000BB22 get_atn
0000BB2E atn_semi
0000BB3E atn_quad
0000BB4E atn_eight
0000BB52 loop_atn
0000BB5C skip_sub
0000BB6C atn_tab
0000BBAC output_number
0000BBAE output_number_loop
0000BBBE zero_suppress
0000BBCA cos_d0
0000BBCE sin_d0
0000BBDC cossin_d0
0000BBE2 a_was_less
0000BBE8 sin_cos
0000BC6A add_message
0000BCB2 add_char_loop
0000BCC8 add_the_char
0000BCD0 exit_add_message
0000BCD2 timer_interrupt
0000BCD8 player_x
0000BCDC player_n
0000BCE4 add_sup_hex_chr
0000BCF0 add_hex_chr
0000BCFA add_sup_zero
0000BD0A add_address
0000BD20 add_coords
0000BD3A add_single
0000BD3C add_pair
0000BD42 notscreen
0000BD42 s_controls
0000BD42 setscreen
0000BD4E Initialise
0000BD76 clear_loop
0000BDC2 read_hi
0000BDCC close_all_2
0000BDD2 gen_prng
0000BDE2 Ninc1
0000BDE2 op_rtsvec
0000BDE2 Ninc0
0000BDE4 do_vector
0000BDF2 op_call
0000BDF8 op_jump
0000BE08 op_vctr
0000BE16 no_neg_y11
0000BE22 no_neg_x11
0000BE32 op_abs
0000BE40 no_neg_y10
0000BE4C no_neg_x10
0000BE5E not_right
0000BE66 vector_base
0000BEA2 op_short
0000BEC6 no_neg_y2
0000BECE no_neg_x2
0000BED2 end_vector
0000BEDC shift_left
0000BEE0 last_vector
0000BF02 vector_move
0000BF2E vector
0000C000 JSRL
0000CF2E copy_msg
0000CF6E expl_tab
0000CF76 expl_3
0000CFA2 expl_2
0000CFE0 expl_1
0000D000 RTSL
0000D016 expl_0
0000D054 rock_tab
0000D05C rock_0
0000D074 rock_1
0000D090 rock_2
0000D0AA rock_3
0000D0C6 sauc_jsr
0000D0C8 sauc_vec
0000D0E4 play_tab
0000D106 play_00
0000D11E play_01
0000D142 play_02
0000D166 play_03
0000D18A play_04
0000D1AC play_05
0000D1D0 play_06
0000D1F4 play_07
0000D218 play_08
0000D23C play_09
0000D260 play_0A
0000D284 play_0B
0000D2A8 play_0C
0000D2CC play_0D
0000D2F0 play_0E
0000D314 play_0F
0000D338 play_10
0000D350 play_liv
0000D366 char_a
0000D376 char_b
0000D390 char_c
0000D39C char_d
0000D3AC char_e
0000D3BC char_f
0000D3CA char_g
0000D3DC char_h
0000D3EA char_i
0000D3F8 char_j
0000D404 char_k
0000D410 char_l
0000D41A char_m
0000D426 char_n
0000D430 char_o0
0000D43C char_p
0000D44A char_q
0000D45C char_r
0000D46C char_s
0000D47A char_t
0000D486 char_u
0000D492 char_v
0000D49C char_w
0000D4AA char_x
0000D4B4 char_y
0000D4C2 char_z
0000D4CE char_spc
0000D4D2 char_1
0000D4DA char_2
0000D4EA char_3
0000D4F8 char_4
0000D506 char_5
0000D514 char_6
0000D522 char_7
0000D52C char_8
0000D53C char_9
0000D54A char_set
0000D594 shot_jsr
0000D596 shot_vec
0000D5A8 mess_origin
0000D5C8 mess_table
0000D5D0 e_messages
0000D5E0 e_mess_0
0000D5EC e_mess_1
0000D5F4 e_mess_2
0000D616 e_mess_3
0000D631 e_mess_4
0000D64E e_mess_5
0000D675 e_mess_6
0000D680 e_mess_7
0000D68A d_messages
0000D69A d_mess_0
0000D6AA d_mess_1
0000D6B3 d_mess_2
0000D6DA d_mess_3
0000D6FD d_mess_4
0000D720 d_mess_5
0000D746 d_mess_6
0000D75C d_mess_7
0000D766 f_messages
0000D776 f_mess_0
0000D785 f_mess_1
0000D78C f_mess_2
0000D7B0 f_mess_3
0000D7C9 f_mess_4
0000D7EB f_mess_5
0000D814 f_mess_6
0000D826 f_mess_7
0000D834 s_messages
0000D844 s_mess_0
0000D84C s_mess_1
0000D855 s_mess_2
0000D87C s_mess_3
0000D89A s_mess_4
0000D8C2 s_mess_5
0000D8D4 s_mess_6
0000D8E1 s_mess_7
0000D8F1 sound_init
0000D952 load_sound
0000D958 load_old_sound
0000D95E play_sample
0000D97A old_sound_play
0000D97C exit_play_sample
0000D97E sound_key
0000D996 beat1_sound
0000D9A8 beat2_sound
0000D9BA lexpl_sound
0000D9CF mexpl_sound
0000D9E4 sexpl_sound
0000D9F9 extra_sound
0000DA0F lgsau_sound
0000DA24 smsau_sound
0000DA39 thrst_sound
0000DA4C pfire_sound
0000DA5E sfire_sound
0000DA70 filename
0000DA7D variables
0000E000 JMPL
0000F000 SHRT
0001001C _Keybd_tick
00020000 start_plants
0002000C restart
00020018 plants_main_loop
00020064 end_main_loop
0002007C goodbye_message
00020089 test_escape
000200A0 exit_test_escape
000200A2 init_world
00020106 clr_plant_loop
0002011A clr_animals_loop
00020142 do_plants
00020178 do_animals
000201AC do_things
000201EE things_exist
00020206 do_things_loop
0002020E thing_zero_only
0002022C check_for_food
0002024C kill_thing
0002025C is_food
00020286 new_thing_loop
000202A6 draw_old_thing
000202A8 fill_old_thing
000202AE next_thing
000202B2 exit_do_things
000202B4 neighbour
000202FA exit_neighbour
00020300 delta_x
00020312 delta_y
00020324 set_thing_pixel
0002033A set_a_pixel
00020346 set_this_pixel
0002036A InitialisePlants
000203E4 get_direction
000203E6 get_prng
000203F6 screen_size
00020420 psetscreen
00020432 pnotscreen
00020434 pvariables
00040004 TextScr
00040008 S19StartAddress
0004000C KeybdEcho
0004000D KeybdWaitFlag
00040040 CmdBuf
00040080 CmdBufEnd
00040084 fgColor
00040088 bkColor
0004008C TextRows
0004008D TextCols
00040094 _fpTextIncr
00040098 _canary
0004009C tickcnt
000400A0 IRQFlag
000400A4 InputDevice
000400A8 OutputDevice
00040100 Regsave
00040202 NumSetBreakpoints
00040220 Breakpoints
00040280 BreakpointWords
000402C0 fpBuf
00040508 _width
0004050C _E
00040510 _digits_before_decpt
00040514 _precision
00040520 _fpBuf
00040600 _fpWork
00040800 _dasmbuf
00040880 OFFSET
00040890 pen_color
00040894 gr_x
00040898 gr_y
0004089C gr_width
000408A0 gr_height
000408AC gr_double_buffer
000408B8 sys_switches
000408C0 gfxaccel_ctrl
000408D0 m_z
000408D4 m_w
000408D8 next_m_z
000408DC next_m_w
00040A00 null_dcb
00040A84 keybd_dcb
00040B08 textvid_dcb
00040B8C err_dcb
00040C94 serial_dcb
00040D18 framebuf_dcb
00040D9C gfxaccel_dcb
00041BFC TimerStack
00100000 IOFocus
00100004 memend
0010000E KeybdLEDs
0010000F _KeyState1
00100010 _KeyState2
00100011 _KeybdHead
00100012 _KeybdTail
00100013 _KeybdCnt
00100018 KeybdID
00100020 _KeybdBuf
00100080 _KeybdOBuf
00100150 S19Checksum
00100160 SerTailRcv
00100162 SerHeadRcv
00100164 SerRcvXon
00100165 SerRcvXoff
00100166 SerTailXmit
00100168 SerHeadXmit
0010016A SerXmitXoff
00100200 RTCBuf
00100224 RunningTCB
0010030C FreeTCB
0010031C QueueCycle
00100320 readyQ
00101000 SerRcvBuf
00102000 SerXmitBuf
008080FF def_plant
00FFFFFF def_animal
20010000 tcbs

Sections:
00: "CODE" (0-D537)
01: "DATA" (0-700)


Source: "boot.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022-2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;-------------------------------------------------------------------------------
                            	    37: ;
                            	    38: ; system memory map
                            	    39: ;
                            	    40: ;
                            	    41: ; 00000000 +----------------+      <+
                            	    42: ;          | startup sp,pc  | 8 B   |
                            	    43: ; 00000008 +----------------+       |
                            	    44: ;					 |    vectors     | pair shared+
                            	    45: ; 00000400 +----------------+       |
                            	    46: ;					 |   bios mem     |       |
                            	    47: ; 00001000 +----------------+       |
                            	    48: ;					 |   bios code    |       |
                            	    49: ; 00020000 +----------------+      <+
                            	    50: ;					 |    unused      |
                            	    51: ; 00040000 +----------------+
                            	    52: ;					 |   local ram    |
                            	    53: ; 00048000 +----------------+
                            	    54: ;					 |    unused      |
                            	    55: ; 00100000 +----------------+
                            	    56: ;					 |   global ram   |
                            	    57: ; 00101000 +----------------+
                            	    58: ;					 | serial rcvbuf  |
                            	    59: ; 00102000 +----------------+
                            	    60: ;          | serial xmitbuf |
                            	    61: ; 00103000 +----------------+
                            	    62: ;					 |    unused      |
                            	    63: ; 40000000 +----------------+
                            	    64: ;          |                |
                            	    65: ;          |                |
                            	    66: ;          |                |
                            	    67: ;          :  dram memory   : 1GB MB
                            	    68: ;          |                |
                            	    69: ;          |                |
                            	    70: ;          |                |
                            	    71: ; 80000000 +----------------+
                            	    72: ;          |                |
                            	    73: ;          |                |
                            	    74: ;          |                |
                            	    75: ;          :  dram memory   : 1GB MB
                            	    76: ;          |     mirror     |
                            	    77: ;          |                |
                            	    78: ;          |                |
                            	    79: ; C0000000 +----------------+
                            	    80: ;          |                |
                            	    81: ;          :     unused     :
                            	    82: ;          |                |
                            	    83: ; FD000000 +----------------+
                            	    84: ;          |                |
                            	    85: ;          :    I/O area    : 1.0 M
                            	    86: ;          |                |
                            	    87: ; FFE00000 +----------------+
                            	    88: ;          |                |
                            	    89: ;          :     unused     :
                            	    90: ;          |                |
                            	    91: ; FFFFFFFF +----------------+
                            	    92: ;
                            	    93: ;-------------------------------------------------------------------------------
                            	    94: ;
                            	    95: HAS_MMU equ 0
                            	    96: NCORES equ 4
                            	    97: TEXTCOL equ 64
                            	    98: TEXTROW	equ	32
                            	    99: 
                            	   100: CTRLC	EQU		$03
                            	   101: CTRLH	EQU		$08
                            	   102: CTRLS	EQU		$13
                            	   103: CTRLX	EQU		$18
                            	   104: CTRLZ	EQU		$1A
                            	   105: LF		EQU		$0A
                            	   106: CR		EQU		$0D
                            	   107: XON		EQU		$11
                            	   108: XOFF	EQU		$13
                            	   109: EOT		EQU		$04
                            	   110: BLANK EQU		$20
                            	   111: 
                            	   112: SC_F12  EQU    $07
                            	   113: SC_C    EQU    $21
                            	   114: SC_T    EQU    $2C
                            	   115: SC_Z    EQU    $1A
                            	   116: SC_KEYUP	EQU		$F0
                            	   117: SC_EXTEND   EQU		$E0
                            	   118: SC_CTRL		EQU		$14
                            	   119: SC_RSHIFT	EQU		$59
                            	   120: SC_NUMLOCK	EQU		$77
                            	   121: SC_SCROLLLOCK	EQU	$7E
                            	   122: SC_CAPSLOCK		EQU	$58
                            	   123: SC_ALT		EQU		$11
                            	   124: SC_LSHIFT	EQU		$12
                            	   125: SC_DEL		EQU		$71		; extend
                            	   126: SC_LCTRL	EQU		$58
                            	   127: SC_TAB      EQU		$0D
                            	   128: 
                            	   129: 	include "..\Femtiki\device.x68"

Source: "..\Femtiki\device.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: DEV_INIT equ 0
                            	    38: DEV_STAT equ 1
                            	    39: DEV_PUTCHAR equ 2
                            	    40: DEV_PUTBUF equ 3
                            	    41: DEV_GETCHAR equ 4
                            	    42: DEV_GETBUF equ 5
                            	    43: DEV_SET_INPOS equ 6
                            	    44: DEV_SET_OUTPOS equ 7
                            	    45: DEV_GETCHAR_DIRECT equ 8
                            	    46: DEV_PEEKCHAR equ 9
                            	    47: DEV_PEEKCHAR_DIRECT equ 10
                            	    48: DEV_PUTCHAR_DIRECT equ 11
                            	    49: DEV_CLEAR equ 12
                            	    50: DEV_SWAPBUF equ 13
                            	    51: DEV_SETBUF1 equ 14
                            	    52: DEV_SETBUF2 equ 15
                            	    53: DEV_GETBUF1 equ 16
                            	    54: DEV_GETBUF2 equ 17
                            	    55: DEV_WRITEAT equ 18
                            	    56: DEV_SETUNIT equ 19
                            	    57: DEV_GET_DIMEN equ 20
                            	    58: DEV_GET_COLOR equ 21
                            	    59: DEV_GET_INPOS equ 22
                            	    60: DEV_GET_OUTPOS equ 23
                            	    61: DEV_GET_OUTPTR equ 24
                            	    62: DEV_SET_COLOR equ 25
                            	    63: DEV_SET_COLOR123 equ 26
                            	    64: DEV_PLOT_POINT equ 27
                            	    65: DEV_DRAW_LINE equ 28
                            	    66: DEV_DRAW_TRIANGLE equ 29
                            	    67: DEV_DRAW_RECTANGLE equ 30
                            	    68: DEV_DRAW_CURVE equ 31
                            	    69: DEV_SET_DIMEN equ 32
                            	    70: DEV_SET_COLOR_DEPTH equ 33
                            	    71: 
                            	    72: 
                            	    73: DCB_MAGIC equ	0			; 'DCB'
                            	    74: DCB_NAME	equ 4			; 15 chars+NULL
                            	    75: DCB_CMDPROC	equ 24	; 8 byte pointer to command processor
                            	    76: DCB_OUTPOSX equ 32
                            	    77: DCB_OUTPOSY equ 36
                            	    78: DCB_OUTPOSZ equ 40
                            	    79: DCB_INPOSX equ 44
                            	    80: DCB_INPOSY equ 48
                            	    81: DCB_INPOSZ equ 52
                            	    82: DCB_INBUFPTR equ 56
                            	    83: DCB_OUTBUFPTR equ 60
                            	    84: DCB_INBUFSIZE equ 64
                            	    85: DCB_OUTBUFSIZE equ 68
                            	    86: DCB_INDIMX equ 72
                            	    87: DCB_INDIMY equ 76
                            	    88: DCB_INDIMZ equ 80
                            	    89: DCB_OUTDIMX equ 84
                            	    90: DCB_OUTDIMY equ 88
                            	    91: DCB_OUTDIMZ equ 92
                            	    92: DCB_BKCOLOR equ 96
                            	    93: DCB_FGCOLOR equ 100
                            	    94: DCB_OPCODE equ 104
                            	    95: DCB_LASTERC equ 108
                            	    96: DCB_INBUFPTR2 equ 112
                            	    97: DCB_OUTBUFPTR2 equ 116
                            	    98: DCB_INBUFSIZE2 equ 120
                            	    99: DCB_OUTBUFSIZE2 equ 124
                            	   100: DCB_UNIT equ 128
                            	   101: DCB_SIZE equ 132
                            	   102: 
                            	   103: ;Standard Devices are:
                            	   104: 
                            	   105: ;#		Device					Standard name
                            	   106: 
                            	   107: ;0		NULL device 			NUL		(OS built-in)
                            	   108: ;1		Keyboard (sequential)	KBD		(OS built-in, ReadOnly)
                            	   109: ;2		Video (sequential)		VID		(OS built-in, WriteOnly)
                            	   110: ;3		Printer (parallel 1)	LPT		(OS built-in)
                            	   111: ;4		Printer (parallel 2)	LPT2	(OS built-in)
                            	   112: ;5		RS-232 1				COM1	(OS built-in)
                            	   113: ;6		RS-232 2				COM2	(OS built-in)
                            	   114: ;7		RS-232 3				COM3	(OS built-in)
                            	   115: ;8		RS-232 4				COM4	(OS built-in)
                            	   116: ;9
                            	   117: ;10		Floppy					FD0 	(OS built-in)
                            	   118: ;11		Floppy					FD1 	(OS built-in)
                            	   119: ;12		Hard disk				HD0 	(OS built-in)
                            	   120: ;13		Hard disk				HD1 	(OS built-in)
                            	   121: ;14
                            	   122: ;15
                            	   123: ;16
                            	   124: ;17
                            	   125: ;18
                            	   126: ;19
                            	   127: ;20
                            	   128: ;21
                            	   129: ;22
                            	   130: ;23
                            	   131: 

Source: "boot.x68"
                            	   130: 	include "..\Femtiki\FemtikiTop.x68"

Source: "..\Femtiki\FemtikiTop.x68"
                            	     1: 	include "..\Femtiki\const.x68"

Source: "..\Femtiki\const.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2020-2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: TS_NONE			EQU		0
                            	    38: TS_READY		EQU		1
                            	    39: TS_DEAD			EQU		2
                            	    40: TS_MSGRDY		EQU		4
                            	    41: TS_WAITMSG	EQU		8
                            	    42: TS_TIMEOUT	EQU		16
                            	    43: TS_PREEMPT	EQU		32
                            	    44: TS_RUNNING	EQU		128
                            	    45: 
                            	    46: ; error codes
                            	    47: E_Ok		EQU		$00
                            	    48: E_Arg		EQU		$01
                            	    49: E_Func  EQU    $02
                            	    50: E_BadMbx	EQU		$04
                            	    51: E_QueFull	EQU		$05
                            	    52: E_NoThread	EQU		$06
                            	    53: E_NotAlloc	EQU		$09
                            	    54: E_NotSupported EQU $0A
                            	    55: E_NoMsg		EQU		$0b
                            	    56: E_Timeout	EQU		$10
                            	    57: E_BadAlarm	EQU		$11
                            	    58: E_NotOwner	EQU		$12
                            	    59: E_QueStrategy EQU		$13
                            	    60: E_DCBInUse	EQU		$19
                            	    61: ; Device driver errors
                            	    62: E_BadDevNum	EQU		$20
                            	    63: E_NoDev		EQU		$21
                            	    64: E_BadDevOp	EQU		$22
                            	    65: E_ReadError	EQU		$23
                            	    66: E_WriteError EQU		$24
                            	    67: E_BadBlockNum	EQU	$25
                            	    68: E_TooManyBlocks	EQU	$26
                            	    69: 
                            	    70: ; resource errors
                            	    71: E_NoMoreMbx	EQU		$40
                            	    72: E_NoMoreMsgBlks	EQU	$41
                            	    73: E_NoMoreAlarmBlks	EQU $44
                            	    74: E_NoMoreTCBs	EQU	$45
                            	    75: E_NoMem		EQU 12
                            	    76: 
                            	    77: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     2: 	include "..\Femtiki\config.x68"

Source: "..\Femtiki\config.x68"
                            	     1: MAX_TID		EQU		4095
                            	     2: NR_TCB		EQU		4096
                            	     3: NTASK     EQU   4096    ; number of threads allowed
                            	     4: LOG_TCBSZ	EQU		8
                            	     5: LOG_PGSZ	EQU		10
                            	     6: LOG_ACBSZ EQU   12
                            	     7: OSPAGES		EQU		16			; pages of memory dedicated to OS
                            	     8: PAGESZ    EQU   16384  	; size of a page of memory
                            	     9: MEMSZ     EQU   32768   ; pages
                            	    10: MBX_BLOCKPTR_BUFSZ  EQU   8 ; number of block pointer entries
                            	    11: NR_MSG		EQU		21842		; number of messages available
                            	    12: NR_MBX		EQU		9792
                            	    13: 
                            	    14: 
                            	    15: 
                            	    16: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     3: 	include "..\Femtiki\types.x68"

Source: "..\Femtiki\types.x68"
                            	     1: ; Thread Control Block
                            	     2: TCBMagic    EQU		$0000
                            	     3: TCBRegs  		EQU   $0004		; register set storage area
                            	     4: TCBUSP			EQU		$0044
                            	     5: TCBSSP			EQU		$0048
                            	     6: TCBSR				EQU		$004C
                            	     7: TCBPC				EQU		$0050
                            	     8: TCBStatus		EQU		$0054
                            	     9: TCBPriority	EQU		$0055
                            	    10: TCBWaitMbx	EQU		$0056
                            	    11: TCBHasFocus EQU   $005A
                            	    12: TCBStackBot	EQU		$005C
                            	    13: TCBMsgD1		EQU		$0060
                            	    14: TCBMsgD2		EQU		$0064
                            	    15: TCBMsgD3		EQU		$0068
                            	    16: TCBStartTick	EQU	$006C
                            	    17: TCBEndTick	EQU		$0070
                            	    18: TCBTicks		EQU		$0074
                            	    19: TCBException	EQU	$0078
                            	    20: TCBNext			EQU		$007C
                            	    21: TCBPrev			EQU		$0080
                            	    22: TCBAffinityBase	EQU	$0082
                            	    23: TCBAffinity	EQU		$0084
                            	    24: TCBTimeout	EQU		$0088
                            	    25: TCBtid      EQU   $008C
                            	    26: TCBmid      EQU   $0090
                            	    27: TCBappid    EQU   $0094
                            	    28: TCBOpMode   EQU   $0098
                            	    29: TCBMbxNext  EQU   $009C
                            	    30: TCBMbxPrev  EQU   $00A0
                            	    31: TCBThreadNum  EQU   $00A4
                            	    32: TCBAcbNext	EQU		$00A8
                            	    33: TCBAcbPrev	EQU		$00AC
                            	    34: TCBhMailboxes	EQU		$00B0
                            	    35: TCBName			EQU		$00C0
                            	    36: TCB_SIZE		EQU		$0100
                            	    37: 
                            	    38: MBX_MAGIC		equ		0
                            	    39: MBX_OWNER		equ		4		; tid of owning task
                            	    40: MBX_LINK    equ   8
                            	    41: MBX_TQHEAD  equ   12   ; link field for free list shared with task queue head
                            	    42: MBX_TQTAIL  equ   16
                            	    43: MBX_MQHEAD	equ		20
                            	    44: MBX_MQTAIL	equ		24
                            	    45: MBX_SIZE		equ		32
                            	    46: 
                            	    47: MSG_MAGIC   equ   0
                            	    48: MSG_LINK	  equ		4
                            	    49: MSG_RETADR  equ   8
                            	    50: MSG_TGTADR  equ   12
                            	    51: MSG_TYPE    equ   16
                            	    52: MSG_D1		  equ		20
                            	    53: MSG_D2		  equ		24
                            	    54: MSG_D3		  equ		28
                            	    55: MSG_SIZE	  equ		32
                            	    56: 
                            	    57: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     4: 
                            	     5: 	include "..\Femtiki\source\kernel\Femtiki_vars.x68"

Source: "..\Femtiki\source\kernel\Femtiki_vars.x68"
                            	     1: 
                            	     2: PAMShareCounts	EQU	$20000000	; one byte for each physical page of memory
                            	     3: tcbs						EQU	$20010000	; 4095*256 = 1MB
                            	     4: tcbs_end				EQU	$20020000
                            	     5: messages				EQU	$20020000	; 32*8192 (680*16=21760 messages)
                            	     6: messages_end		EQU	$20060000
                            	     7: mailboxes				EQU	$20060000
                            	     8: mailboxes_end		EQU	$20078000	;	12*8192 (816*12=9792 mailboxes)
                            	     9: acbs						EQU	$20080000	; 32*2*8192 =512kB
                            	    10: acbs_end				EQU	$20100000
                            	    11: 
                            	    12: 
                            	    13: sys_stacks			EQU	$DF0000
                            	    14: 
                            	    15: FemtikiVars			EQU	$00100200
                            	    16: PAMLastAllocate2	EQU		$00100218
                            	    17: RunningAID		EQU		$00100220
                            	    18: RunningTCB			EQU		$00100224
                            	    19: ACBPtrs				EQU		$00100228
                            	    20: MidStackBottoms	EQU		$00100264
                            	    21: FemtikiInited	EQU		$00100284
                            	    22: missed_ticks	EQU		$00100288
                            	    23: IOFocusList		EQU		$0010028C
                            	    24: IOFocusID			EQU		$001002AC
                            	    25: iof_switch		EQU		$001002AD
                            	    26: nMessage			EQU		$001002AE
                            	    27: nMailbox			EQU		$001002B0
                            	    28: hKeybdMbx			EQU		$001002BA
                            	    29: hFocusSwitchMbx		EQU		$001002BC
                            	    30: BIOS_RespMbx	EQU		$001002BE
                            	    31: hasUltraHighPriorityTasks	EQU		$001002C0
                            	    32: im_save				EQU		$001002C2
                            	    33: sp_tmp				EQU		$001002C4
                            	    34: startQNdx			EQU		$001002C6
                            	    35: NPAGES				EQU		$001002D8
                            	    36: syspages			EQU		$001002DA
                            	    37: mmu_FreeMaps	EQU		$001002E0
                            	    38: mmu_entries		EQU		$00100300
                            	    39: freelist			EQU		$00100302
                            	    40: hSearchMap		EQU		$00100304
                            	    41: OSActive			EQU		$00100305
                            	    42: FreeACB				EQU		$00100308
                            	    43: FreeTCB				EQU		$0010030C
                            	    44: FreeMSG				EQU		$00100310
                            	    45: FreeMBX				EQU		$00100314
                            	    46: TimeoutList		EQU		$00100318
                            	    47: QueueCycle    EQU   $0010031C
                            	    48: readyQ				EQU		$00100320		; 32 bytes per queue per core, 2 cores for now
                            	    49: readyQEnd			EQU		$00100360
                            	    50: FemtikiVars_end	EQU	$00100400
                            	    51: 
                            	    52: ;gc_stack		rmb		512
                            	    53: ;gc_pc				fcdw		0
                            	    54: ;gc_omapno		fcw			0
                            	    55: ;gc_mapno		fcw			0
                            	    56: ;gc_dl				fcw			0
                            	    57: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     6: 	code
                            	     7: 	even
                            	     8: 	include "..\Femtiki\source\kernel\tcb.x68"

Source: "..\Femtiki\source\kernel\tcb.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;------------------------------------------------------------------------------
                            	    38: ; Initialize variables related to TCBs.
                            	    39: ;------------------------------------------------------------------------------
                            	    40: 
                            	    41: TCBInit:
00:00000000 41F920010000    	    42: 	lea tcbs,a0
00:00000006 4E7B8013        	    43: 	movec a0,tcba
00:0000000A 700F            	    44: 	moveq #2*8-1,d0		; 2 cores, 32 bytes (8 lwords) per queue
00:0000000C 72FF            	    45: 	moveq #-1,d1			; value to set
00:0000000E 41F900100320    	    46: 	lea readyQ,a0			; clear out ready queue
                            	    47: .0001
00:00000014 20C1            	    48: 	move.l d1,(a0)+
00:00000016 51C8FFFC        	    49: 	dbra d0,.0001
00:0000001A 203C0003FFFF    	    50: 	move.l #TCB_SIZE*NR_TCB/4-1,d0
                            	    51: .clearTCBs
00:00000020 4298            	    52: 	clr.l (a0)+
00:00000022 51C8FFFC        	    53: 	dbra d0,.clearTCBs
00:00000026 4E75            	    54: 	rts
                            	    55: 
                            	    56: ;------------------------------------------------------------------------------
                            	    57: ; Convert a TCB handle into a pointer.
                            	    58: ;
                            	    59: ; Parameters:
                            	    60: ;		d0 = TCB handle
                            	    61: ; Returns:
                            	    62: ;		a0 = pointer to TCB
                            	    63: ;------------------------------------------------------------------------------
                            	    64: 
                            	    65: TCBHandleToPointer:
00:00000028 2F01            	    66: 	move.l d1,-(a7)
00:0000002A 028000000FFF    	    67: 	andi.l #MAX_TID,d0		; limit to # threads
00:00000030 4E7A1013        	    68: 	movec tcba,d1
00:00000034 E188            	    69: 	lsl.l #8,d0
00:00000036 D280            	    70: 	add.l d0,d1
00:00000038 2041            	    71: 	move.l d1,a0
00:0000003A E088            	    72: 	lsr.l #8,d0						; restore d0
00:0000003C 221F            	    73: 	move.l (a7)+,d1
00:0000003E 4E75            	    74: 	rts
                            	    75: 
                            	    76: ;------------------------------------------------------------------------------
                            	    77: ; Convert a TCB pointer into a handle.
                            	    78: ;
                            	    79: ; Parameters:
                            	    80: ;		a0 = TCB pointer
                            	    81: ; Returns:
                            	    82: ;		d0 = TCB handle
                            	    83: ;------------------------------------------------------------------------------
                            	    84: 
                            	    85: TCBPointerToHandle:
00:00000040 2F01            	    86: 	move.l d1,-(a7)				; save d1
00:00000042 4E7A1013        	    87: 	movec tcba,d1
00:00000046 91C1            	    88: 	sub.l d1,a0
00:00000048 2008            	    89: 	move.l a0,d0
00:0000004A E088            	    90: 	lsr.l #8,d0
00:0000004C 221F            	    91: 	move.l (a7)+,d1				; restore d1
00:0000004E 4E75            	    92: 	rts
                            	    93: 
                            	    94: ;------------------------------------------------------------------------------
                            	    95: ; Internal TCB allocation function.
                            	    96: ;
                            	    97: ; Parameters:
                            	    98: ;		none
                            	    99: ; Returns:
                            	   100: ;		d0 = handle for allocated TCB, NULL if none available
                            	   101: ;------------------------------------------------------------------------------
                            	   102: 
                            	   103: TCBIAlloc:
00:00000050 30390010030C    	   104: 	move.w FreeTCB,d0				; d1 = Free handle
00:00000056 6714            	   105: 	beq .0001
00:00000058 2F08            	   106: 	move.l a0,-(sp)
00:0000005A 61CC            	   107: 	bsr TCBHandleToPointer	; convert to pointer
00:0000005C 3228007C        	   108: 	move.w TCBNext(a0),d1		; d1 = next on free list
00:00000060 33C10010030C    	   109: 	move.w d1,FreeTCB				; update head of free list
00:00000066 61D8            	   110: 	bsr TCBPointerToHandle	; convert pointer to handle
00:00000068 205F            	   111: 	move.l (sp)+,a0
00:0000006A 4E75            	   112: 	rts
                            	   113: 	; Here there was no free TCB available. Return a NULL
                            	   114: .0001
00:0000006C 4E75            	   115: 	rts
                            	   116: 	
                            	   117: ;------------------------------------------------------------------------------
                            	   118: ; TCB allocation function. Locks the system semaphore during allocation.
                            	   119: ;
                            	   120: ; Parameters:
                            	   121: ;		none
                            	   122: ; Returns:
                            	   123: ;		d0 = handle for allocated TCB, NULL if none available
                            	   124: ;		d1 = E_Ok
                            	   125: ;------------------------------------------------------------------------------
                            	   126: 
                            	   127: TCBAlloc:
00:0000006E 61000326        	   128: 	bsr LockSysSemaphore
00:00000072 61DC            	   129: 	bsr	TCBIAlloc
00:00000074 61000330        	   130: 	bsr UnlockSysSemaphore
00:00000078 7200            	   131: 	moveq #E_Ok,d1
00:0000007A 4E75            	   132: 	rts
                            	   133: 	
                            	   134: ;------------------------------------------------------------------------------
                            	   135: ; Internal TCB free function.
                            	   136: ;
                            	   137: ; Modifies:
                            	   138: ;		none
                            	   139: ; Parameters:
                            	   140: ;		d0 = handle to TCB
                            	   141: ; Returns:
                            	   142: ;		d0 = handle to TCB
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: TCBIFree:
00:0000007C 2F08            	   146: 	move.l a0,-(sp)
00:0000007E 61A8            	   147: 	bsr TCBHandleToPointer
00:00000080 31790010030C007C	   148: 	move.w FreeTCB,TCBNext(a0)
00:00000088 33C00010030C    	   149: 	move.w d0,FreeTCB
00:0000008E 205F            	   150: 	move.l (sp)+,a0
00:00000090 4E75            	   151: 	rts
                            	   152: 
                            	   153: ;------------------------------------------------------------------------------
                            	   154: ; TCB free function. Locks the system sempaphore while freeing.
                            	   155: ;
                            	   156: ; Modifies:
                            	   157: ;		none
                            	   158: ; Parameters:
                            	   159: ;		d0 = handle to TCB
                            	   160: ; Returns:
                            	   161: ;		d0 = handle to TCB
                            	   162: ;		d1 = E_Ok
                            	   163: ;------------------------------------------------------------------------------
                            	   164: 
                            	   165: TCBFree:
00:00000092 61000302        	   166: 	bsr LockSysSemaphore
00:00000096 61E4            	   167: 	bsr TCBIFree
00:00000098 6100030C        	   168: 	bsr UnlockSysSemaphore
00:0000009C 7200            	   169: 	moveq #E_Ok,d1
00:0000009E 4E75            	   170: 	rts
                            	   171: 
                            	   172: ;------------------------------------------------------------------------------
                            	   173: ; Given an affinity, chose the core number to run on.
                            	   174: ;
                            	   175: ; Parameters:
                            	   176: ;		a0 = pointer to TCB
                            	   177: ;	Returns:
                            	   178: ;		d0 = core number to run on
                            	   179: ;------------------------------------------------------------------------------
                            	   180: 
                            	   181: TCBAffineChose:
00:000000A0 48E75000        	   182: 	movem.l d1/d3,-(sp)
00:000000A4 363C001F        	   183: 	move.w #31,d3										; limit number of bit selects to 32
00:000000A8 12280082        	   184: 	move.b TCBAffinityBase(a0),d1		; d1 = starting bit
00:000000AC 20280084        	   185: 	move.l TCBAffinity(a0),d0				; d0 = affinity mask
                            	   186: .0002
00:000000B0 0300            	   187: 	btst.l d1,d0										; is bit d1 set?
00:000000B2 6610            	   188: 	bne .0001												; if set, exit loop
00:000000B4 5241            	   189: 	addq #1,d1
00:000000B6 51CBFFF8        	   190: 	dbra d3,.0002
                            	   191: 	; no bits set? How?
00:000000BA 117C00020082    	   192: 	move.b #2,TCBAffinityBase(a0)
00:000000C0 7000            	   193: 	moveq #0,d0											; just return core #2 (0)
00:000000C2 4E75            	   194: 	rts
                            	   195: .0001
00:000000C4 1001            	   196: 	move.b d1,d0
00:000000C6 5500            	   197: 	subi.b #2,d0										; cores start at #2
00:000000C8 4880            	   198: 	ext.w d0
00:000000CA 48C0            	   199: 	ext.l d0
00:000000CC 5241            	   200: 	addq #1,d1											; increment bit selection for next time
00:000000CE 11410082        	   201: 	move.b d1,TCBAffinityBase(a0)		; and store in TCB
00:000000D2 4CDF000A        	   202: 	movem.l (sp)+,d1/d3
00:000000D6 4E75            	   203: 	rts
                            	   204: 
                            	   205: ;------------------------------------------------------------------------------
                            	   206: ; Insert thread into ready queue. The thread is added at the tail of the 
                            	   207: ; queue. The queue is a doubly linked list.
                            	   208: ;
                            	   209: ; Stack Space:
                            	   210: ;		8 lwords
                            	   211: ; Modifies:
                            	   212: ;		none
                            	   213: ; Parameters:
                            	   214: ;		d0 = thread id to insert
                            	   215: ; Returns:
                            	   216: ;		d0 = TCB handle
                            	   217: ; ----------------------------------------------------------------------------
                            	   218: 
                            	   219: TCBInsertIntoReadyQueue:
00:000000D8 48E770F0        	   220: 	movem.l d1-d3/a0-a3,-(sp)
00:000000DC 2400            	   221: 	move.l d0,d2											; d2 = thread to insert
00:000000DE 6100FF48        	   222: 	bsr TCBHandleToPointer
00:000000E2 2648            	   223: 	move.l a0,a3											; a3 = TCB pointer of thread to insert
00:000000E4 610002B0        	   224: 	bsr LockSysSemaphore
00:000000E8 002800800054    	   225: 	ori.b #TS_RUNNING,TCBStatus(a0)
00:000000EE 61B0            	   226: 	bsr TCBAffineChose								; Chose which cores queue to use
00:000000F0 EB88            	   227: 	lsl.l #5,d0												; 32 bytes per readyQ head/tail per core
00:000000F2 7200            	   228: 	clr.l d1
00:000000F4 12280055        	   229: 	move.b TCBPriority(a0),d1					; d1 = priority
00:000000F8 028100000007    	   230: 	andi.l #7,d1
00:000000FE E589            	   231: 	lsl.l #2,d1												; 4 bytes per priority level
00:00000100 D280            	   232: 	add.l d0,d1												; add in base queue
00:00000102 D2BC00100320    	   233: 	add.l #readyQ,d1									; add in start of ready queues
00:00000108 2241            	   234: 	move.l d1,a1
00:0000010A 30290004        	   235: 	move.w 4(a1),d0										; d0 = tail entry
00:0000010E 3600            	   236: 	move.w d0,d3											; d3 = tail entry
00:00000110 4A40            	   237: 	tst.w d0
00:00000112 6D20            	   238: 	blt .qempty
00:00000114 6100FF12        	   239: 	bsr TCBHandleToPointer						; a0 = pointer to tail
00:00000118 2448            	   240: 	move.l a0,a2
00:0000011A 2038007C        	   241: 	move.l TCBNext,d0
00:0000011E 6100FF08        	   242: 	bsr TCBHandleToPointer						; a0 = tail->next
00:00000122 21420080        	   243: 	move.l d2,TCBPrev(a0)							; tail->next->prev = new entry
00:00000126 2542007C        	   244: 	move.l d2,TCBNext(a2)							; tail->next = new entry
00:0000012A 2740007C        	   245: 	move.l d0,TCBNext(a3)							; new entry->next = tail->next
00:0000012E 27430080        	   246: 	move.l d3,TCBPrev(a3)							; new entry->prev = tail
00:00000132 6012            	   247: 	bra .0002
                            	   248: .qempty
00:00000134 4A51            	   249: 	tst.w (a1)												; check if there is a list head
00:00000136 6C0E            	   250: 	bge .0002													; head with no tail -> list corrupt
00:00000138 33420004        	   251: 	move.w d2,4(a1)										; head and tail equal new entry
00:0000013C 3282            	   252: 	move.w d2,(a1)
00:0000013E 3742007C        	   253: 	move.w d2,TCBNext(a3)							; next and prev of new entry point to self
00:00000142 37420080        	   254: 	move.w d2,TCBPrev(a3)
                            	   255: 	; Head but no tail, list corrupt?
                            	   256: .0002
00:00000146 6100025E        	   257: 	bsr UnlockSysSemaphore
00:0000014A 4CDF0F0E        	   258: 	movem.l (sp)+,d1-d3/a0-a3
00:0000014E 4E75            	   259: 	rts
                            	   260: 
                            	   261: ;------------------------------------------------------------------------------
                            	   262: ; Remove a thread from the ready queue. Actual removal is not done here, it
                            	   263: ; is done the next time the thread is selected to run. Just mark the thread as
                            	   264: ; not running.
                            	   265: ;
                            	   266: ; Parameters:
                            	   267: ;		d0 = thread id to remove
                            	   268: ; Returns:
                            	   269: ;		none
                            	   270: ; -----------------------------------------------------------------------------
                            	   271: 
                            	   272: TCBRemoveFromReadyQueue:
00:00000150 4A40            	   273: 	cmpi.w #0,d0
00:00000152 6D1C            	   274: 	blt .0001
00:00000154 028000000FFF    	   275: 	andi.l #MAX_TID,d0									; limit to # of threads
00:0000015A 2F08            	   276: 	move.l a0,-(sp)
00:0000015C 6100FECA        	   277: 	bsr	TCBHandleToPointer
00:00000160 61000234        	   278: 	bsr LockSysSemaphore
00:00000164 0228007F0054    	   279: 	andi.b #TS_RUNNING^$FF,TCBStatus(a0)
00:0000016A 6100023A        	   280: 	bsr UnlockSysSemaphore
00:0000016E 205F            	   281: 	move.l (sp)+,a0
                            	   282: .0001
00:00000170 4E75            	   283: 	rts
                            	   284: 	
                            	   285: ; ----------------------------------------------------------------------------
                            	   286: ; Register Usage
                            	   287: ;		d0 = temporary
                            	   288: ;		d1 = index into list of queues
                            	   289: ;		d2 = index to queue set
                            	   290: ;		d4 = queue counter, goes from 7 down to 0
                            	   291: ;		d5 = temporary
                            	   292: ;		d6 = next on list
                            	   293: ;		a0 = temporary pointer to TCB
                            	   294: ;		a1 = pointer to queue
                            	   295: ;		a2 = pointer to old head of list
                            	   296: ;		a3 = pointer to TCB at head of queue
                            	   297: ; Modifies:
                            	   298: ;		none
                            	   299: ; Parameters:
                            	   300: ;		none
                            	   301: ; Returns:
                            	   302: ;		a0 = pointer to TCB, NULL if none on list
                            	   303: ;		d0 = TCB handle
                            	   304: ; ----------------------------------------------------------------------------
                            	   305: 
                            	   306: StartQ
00:00000172 01              	   307: 	dc.b 1,2,3,4,1,5,6,7
00:00000173 02
00:00000174 03
00:00000175 04
00:00000176 01
00:00000177 05
00:00000178 06
00:00000179 07
                            	   308: 
                            	   309: 	even
                            	   310: TCBPopReadyQueue:
00:0000017A 48E77E70        	   311: 	movem.l	d1-d6/a1-a3,-(a7)
00:0000017E 4E7A2FE0        	   312: 	movec coreno,d2					; select the queue set based on the core number
00:00000182 5502            	   313: 	subi.b #2,d2						; cores start at #2
00:00000184 EB8A            	   314: 	lsl.l #5,d2							; d2 = index to queue set, 32 bytes per queue set
00:00000186 7807            	   315: 	moveq #7,d4							; d4 = queue count
00:00000188 6100020C        	   316: 	bsr LockSysSemaphore
                            	   317: 	; One in four tries pick a different priority to start searching from. 
00:0000018C 12390010031C    	   318: 	move.b QueueCycle,d1		; increment Queue cycle counter
00:00000192 5201            	   319: 	addi.b #1,d1
00:00000194 02010007        	   320: 	andi.b #7,d1
00:00000198 13C10010031C    	   321: 	move.b d1,QueueCycle
00:0000019E 6612            	   322: 	bne	.0001
00:000001A0 43FAFFD0        	   323: 	lea StartQ,a1
00:000001A4 4881            	   324: 	ext.w d1
00:000001A6 12311000        	   325: 	move.b (a1,d1.w),d1
00:000001AA 02410007        	   326: 	andi.w #7,d1						; limit to number of queues
00:000001AE E549            	   327: 	lsl.w #2,d1							; make into lword index
00:000001B0 6002            	   328: 	bra .0002
                            	   329: .0001
00:000001B2 7200            	   330: 	moveq #0,d1							; start at Queue #0
                            	   331: .0002
00:000001B4 43F900100320    	   332: 	lea readyQ,a1						; a1 = pointer to list of ready queues
00:000001BA D3C2            	   333: 	add.l d2,a1							; a1 = pointer to queue set
00:000001BC 36311000        	   334: 	move.w (a1,d1.w),d3			; d3 = old head of list
00:000001C0 6D4E            	   335: 	blt .nextQ							; anything on list?, if not go next queue
00:000001C2 3003            	   336: 	move.w d3,d0						; d0 = old head of list
00:000001C4 6100FE62        	   337: 	bsr TCBHandleToPointer
00:000001C8 2448            	   338: 	move.l a0,a2						; a2 = pointer to old head of list
00:000001CA 3A2A007C        	   339: 	move.w TCBNext(a2),d5		; remove head of list from list
00:000001CE BA80            	   340: 	cmp.l d0,d5							; removing last TCB?
00:000001D0 6736            	   341: 	beq .removeLast
00:000001D2 3C05            	   342: 	move.w d5,d6						; d6 = next on list
00:000001D4 3005            	   343: 	move.w d5,d0						; d0 = next on list
00:000001D6 6100FE50        	   344: 	bsr TCBHandleToPointer	; a0 = pointer to next TCB on list
00:000001DA 3A2A0080        	   345: 	move.w TCBPrev(a2),d5		; d5 = previous TCB from head
00:000001DE 31450080        	   346: 	move.w d5,TCBPrev(a0)		; next->prev = head->prev
00:000001E2 3005            	   347: 	move.w d5,d0
00:000001E4 6100FE42        	   348: 	bsr TCBHandleToPointer	; a0 = pointer to previous TCB from head
00:000001E8 3146007C        	   349: 	move.w d6,TCBNext(a0)		; head->prev->next = next
                            	   350: .0003
00:000001EC 33861000        	   351: 	move.w d6,(a1,d1.w)			; reset head of list to next
00:000001F0 3543007C        	   352: 	move.w d3,TCBNext(a2)		; point links back to self
00:000001F4 35430080        	   353: 	move.w d3,TCBPrev(a2)
00:000001F8 3003            	   354: 	move.w d3,d0						; return handle in d0
00:000001FA 48C0            	   355: 	ext.l d0
00:000001FC 204A            	   356: 	move.l a2,a0						; return pointer in a0
                            	   357: .0004
00:000001FE 610001A6        	   358: 	bsr UnlockSysSemaphore
00:00000202 4CDF0E7E        	   359: 	movem.l	(a7)+,d1-d6/a1-a3
00:00000206 4E75            	   360: 	rts
                            	   361: .removeLast
00:00000208 7CFF            	   362: 	moveq #-1,d6						; set head to negative when removing last
00:0000020A 33861002        	   363: 	move.w d6,2(a1,d1.w)		; tail = negative
00:0000020E 60DC            	   364: 	bra .0003
                            	   365: .nextQ
00:00000210 5841            	   366: 	addi.w #4,d1						; increment queue number by lword
00:00000212 0241001C        	   367: 	andi.w #$1C,d1					; limit to number of queues
00:00000216 51CCFF9C        	   368: 	dbra d4,.0002						; go back and check the next queue
00:0000021A 70FF            	   369: 	moveq #-1,d0						; return handle < 0 if nothing in any queue
00:0000021C 91C8            	   370: 	suba.l a0,a0						; and NULL pointer
00:0000021E 60DE            	   371: 	bra	.0004								; return NULL pointer if nothing in any queue
                            	   372: 
                            	   373: ;------------------------------------------------------------------------------
                            	   374: ; Remove a thread from the timeout list.
                            	   375: ; Called when a mailbox is freed and a thread is waiting at the
                            	   376: ; mailbox.
                            	   377: ;
                            	   378: ; Parameters:
                            	   379: ;		B = task id to remove
                            	   380: ; Modifies:
                            	   381: ;		none
                            	   382: ; Returns:
                            	   383: ;		none
                            	   384: ;------------------------------------------------------------------------------
                            	   385: 	if 0
                            	   386: RemoveFromTimeoutList:
                            	   387: 	pshs	d,w,x,y,u
                            	   388: 	cmpb	TimeoutList			; head of list?
                            	   389: 	beq		0001f
                            	   390: 	lbsr	TCBHandleToPointer
                            	   391: 	tfr		d,x
                            	   392: 	ldb		TCBNext,x
                            	   393: 	clra
                            	   394: 	tfr		d,u
                            	   395: 	ldf		TCBPrev,x
                            	   396: 	lbsr	TCBHandleToPointer
                            	   397: 	tfr		d,y
                            	   398: 	stf		TCBPrev,y
                            	   399: 	tfr		f,b
                            	   400: 	clra
                            	   401: 	lbsr	TCBHandleToPointer
                            	   402: 	tfr		d,y
                            	   403: 	tfr		u,d
                            	   404: 	stb		TCBNext,y
                            	   405: 	bra		0002f
                            	   406: 	; Removing from head of timeout list
                            	   407: 0001:
                            	   408: 	lbsr	TCBHandleToPointer
                            	   409: 	tfr		d,x
                            	   410: 	ldb		TCBNext,x
                            	   411: 	stb		TimeoutList		; set new head of list
                            	   412: 	clra
                            	   413: 	lbsr	TCBHandleToPointer
                            	   414: 	tfr		d,y
                            	   415: 	clrb
                            	   416: 	stb		TCBPrev,y			; next->prev = NULL
                            	   417: 0002:
                            	   418: 	clrd
                            	   419: 	std		TCBNext,x			; next = NULL
                            	   420: 	std		TCBPrev,x			; prev = NULL
                            	   421: 	puls	d,w,x,y,u,pc
                            	   422: 	
                            	   423: ;// ----------------------------------------------------------------------------
                            	   424: ;// Pop the top entry from the timeout list.
                            	   425: ;// ----------------------------------------------------------------------------
                            	   426: ;
                            	   427: ;hTCB PopTimeoutList()
                            	   428: ;{
                            	   429: ;    TCB *p;
                            	   430: ;    hTCB h;
                            	   431: ;
                            	   432: ;    h = TimeoutList;
                            	   433: ;    if (TimeoutList > 0 && TimeoutList < NR_TCB) {
                            	   434: ;        TimeoutList = tcbs[TimeoutList].next;
                            	   435: ;        if (TimeoutList >= 0 && TimeoutList < NR_TCB) {
                            	   436: ;            tcbs[TimeoutList].prev = h->prev;
                            	   437: ;            h->prev->next = TimeoutList;
                            	   438: ;        }
                            	   439: ;    }
                            	   440: ;    return h;
                            	   441: ;}
                            	   442: ;
                            	   443: ; Returns:
                            	   444: ;		B = task at top of list
                            	   445: ;
                            	   446: 
                            	   447: PopTimeoutList:
                            	   448: 	pshs	w,x,y
                            	   449: 	ldb		TimeoutList
                            	   450: 	pshs	b
                            	   451: 	beq		0001f
                            	   452: 	cmpb	#NR_TCB
                            	   453: 	bhs		0001f
                            	   454: 	bsr		TCBHandleToPointer
                            	   455: 	tfr		d,x
                            	   456: 	ldb		TCBNext,x
                            	   457: 	tfr		b,f
                            	   458: 	lde		TCBPrev,x
                            	   459: 	stb		TimeoutList
                            	   460: 	beq		0001f
                            	   461: 	cmpb	#NR_TCB
                            	   462: 	bhs		0001f
                            	   463: 	bsr		TCBHandleToPointer
                            	   464: 	tfr		d,y
                            	   465: 	ste		TCBPrev,y
                            	   466: 	tfr		e,b
                            	   467: 	bsr		TCBHandleToPointer
                            	   468: 	tfr		d,y
                            	   469: 	stf		TCBNext,y
                            	   470: 	clr		TCBPrev,x
                            	   471: 	clr		TCBNext,x
                            	   472: 0001:
                            	   473: 	puls	b
                            	   474: 	puls	x,y,w,pc
                            	   475: 
                            	   476: ; ----------------------------------------------------------------------------
                            	   477: ; ----------------------------------------------------------------------------
                            	   478: DispTwoSpace:
                            	   479: 	bsr	DispSpace
                            	   480: DispSpace:
                            	   481: 	ldb		#' '
                            	   482: 	swi
                            	   483: 	fcb		MF_OUTCH
                            	   484: 	rts
                            	   485: 
                            	   486: DumpTCBs:
                            	   487: 	swi
                            	   488: 	fcb		MF_CRLF
                            	   489: 	ldb		#1
                            	   490: 0002:
                            	   491: 	lbsr	TCBHandleToPointer
                            	   492: 	tfr		d,x
                            	   493: 	ldb		TCBtid,x
                            	   494: 	swi
                            	   495: 	fcb		MF_DisplayByteAsHex
                            	   496: 	bsr		DispSpace
                            	   497: 	ldb		TCBStatus,x
                            	   498: 	swi
                            	   499: 	fcb		MF_DisplayByteAsHex
                            	   500: 	bsr		DispTwoSpace
                            	   501: 	swi
                            	   502: 	fcb		MF_CRLF
                            	   503: 	ldb		TCBNext,x
                            	   504: 	beq		0001f
                            	   505: 	bra		0002b
                            	   506: 0001:
                            	   507: 	rts
                            	   508: 	
                            	   509: fcb	"TID Stat"
                            	   510: 	endif
                            	   511: 
                            	   512: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	     9: 	include "..\Femtiki\source\kernel\Femtiki.x68"

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	     1: 	code
                            	     2: 	even
                            	     3: ;------------------------------------------------------------------------------
                            	     4: ; Initialize the Femtiki OS.
                            	     5: ;------------------------------------------------------------------------------
                            	     6: 
                            	     7: FemtikiInit:
00:00000220 7000            	     8: 	moveq #0,d0
00:00000222 4E7B0012        	     9: 	movec d0,tr
00:00000226 6100FDD8        	    10: 	bsr TCBInit
00:0000022A 42390010031C    	    11: 	clr.b QueueCycle
                            	    12: FemtikiInitIRQ:
00:00000230 43FA00DC        	    13: 	lea FemtikiTimerIRQ,a1						; Set timer IRQ vector to Femtiki
00:00000234 4E7A8801        	    14: 	movec vbr,a0
00:00000238 21490078        	    15: 	move.l a1,30*4(a0)								; vector #30
00:0000023C 4E75            	    16: 	rts
                            	    17: 
                            	    18: ;------------------------------------------------------------------------------
                            	    19: ; Operating system call dispatcher.
                            	    20: ; On entry, the task state has been saved including the system stack pointer,
                            	    21: ; in the task control block.
                            	    22: ;------------------------------------------------------------------------------
                            	    23: 
                            	    24: OSCallTable
00:0000023E 0000            	    25: 	dc.w		0
                            	    26: 
                            	    27: 	even
                            	    28: CallOS:
00:00000240 2F08            	    29: 	move.l	a0,-(a7)
00:00000242 207900100224    	    30: 	move.l	RunningTCB,a0
00:00000248 48E8FFFF0004    	    31: 	movem.l d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,TCBRegs(a0)
00:0000024E 225F            	    32: 	move.l	(a7)+,a1
00:00000250 21490020        	    33: 	move.l	a1,32(a0)
00:00000254 4E7A9800        	    34: 	movec		usp,a1
00:00000258 21490044        	    35: 	move.l	a1,TCBUSP(a0)
00:0000025C 301F            	    36: 	move.w	(a7)+,d0					; pop the status register
00:0000025E 3140004C        	    37: 	move.w	d0,TCBSR(a0)			; save in TCB
00:00000262 225F            	    38: 	move.l	(a7)+,a1					; pop the program counter
00:00000264 5489            	    39: 	lea	2(a1),a1							; increment past inline callno argument
00:00000266 21490050        	    40: 	move.l	a1,TCBPC(a0)			; save PC in TCB
00:0000026A 214F0048        	    41: 	move.l	a7,TCBSSP(a0)			; finally save SSP
00:0000026E 3029FFFE        	    42: 	move.w	-2(a1),d0					; d0 = call number
00:00000272 E548            	    43: 	lsl.w		#2,d0							; make into table index
00:00000274 43FAFFC8        	    44: 	lea			OSCallTable,a1
00:00000278 22710000        	    45: 	move.l	(a1,d0.w),a1
00:0000027C 4E91            	    46: 	jsr			(a1)							; call the OS function
                            	    47: 	; Restore the thread context and return
00:0000027E 207900100224    	    48: 	move.l	RunningTCB,a0
00:00000284 2E780048        	    49: 	move.l	TCBSSP,a7
00:00000288 2F280050        	    50: 	move.l	TCBPC(a0),-(a7)		; setup the PC and the SR on the stack
00:0000028C 3F28004C        	    51: 	move.w	TCBSR(a0),-(a7)		; prep for RTE
00:00000290 20380044        	    52: 	move.l	TCBUSP,d0					; restore user stack pointer
00:00000294 4E7B0800        	    53: 	movec		d0,usp
00:00000298 4CE800FF0004    	    54: 	movem.l	TCBRegs(a0),d0/d1/d2/d3/d4/d5/d6/d7
00:0000029E 4CE87E00002C    	    55: 	movem.l TCBRegs+40(a0),a1/a2/a3/a4/a5/a6
00:000002A4 20680024        	    56: 	move.l	TCBRegs+32(a0),a0
00:000002A8 4E73            	    57: 	rte
                            	    58: 
                            	    59: ;------------------------------------------------------------------------------
                            	    60: ; Get a pointer to the currently running TCB.
                            	    61: ;
                            	    62: ; Returns:
                            	    63: ;		a0 = pointer to running TCB
                            	    64: ;------------------------------------------------------------------------------
                            	    65: 
                            	    66: GetRunningTCBPointer:
00:000002AA 48E7C000        	    67: 	movem.l d0/d1,-(a7)
00:000002AE 4E7A0012        	    68: 	movec tr,d0
00:000002B2 6100FD74        	    69: 	bsr TCBHandleToPointer
00:000002B6 028000000FFF    	    70: 	andi.l #MAX_TID,d0		; limit to # threads
00:000002BC 4CDF0003        	    71: 	movem.l (a7)+,d0/d1
00:000002C0 4E75            	    72: 	rts
                            	    73: 
                            	    74: ; ----------------------------------------------------------------------------
                            	    75: ; Select a thread to run. Relatively easy. All that needs to be done is to
                            	    76: ; keep popping the queue until a valid running task is found. There should
                            	    77: ; always be at least one thread in the queue.
                            	    78: ;
                            	    79: ; Modifies:
                            	    80: ;		none
                            	    81: ; Returns:
                            	    82: ;		d0 = handle of the next thread to run
                            	    83: ; ----------------------------------------------------------------------------
                            	    84: 
                            	    85: SelectThreadToRun:
                            	    86: .0001										; keep popping tasks from the readyQ until a valid one
00:000002C2 6100FEB6        	    87: 	bsr	TCBPopReadyQueue	; is found.
00:000002C6 4A40            	    88: 	tst.w d0
00:000002C8 6B0C            	    89: 	bmi	.0002
00:000002CA 0C2800800054    	    90: 	cmpi.b #TS_RUNNING,TCBStatus(a0)	; ensure the thread is to be running
00:000002D0 66F0            	    91: 	bne	.0001													; if not, go get the next thread
00:000002D2 6000FE04        	    92: 	bra	TCBInsertIntoReadyQueue				; insert thread back into queue
                            	    93: 	; Nothing in queues? There is supposed to be. Add the OS task to the queue.
                            	    94: .0002
00:000002D6 4E7A8013        	    95: 	movec tcba,a0
00:000002DA 117C00800054    	    96: 	move.b #TS_RUNNING,TCBStatus(a0)	; flag as RUNNING
00:000002E0 117C00040055    	    97: 	move.b #4,TCBPriority(a0)					; OS has normal priority
00:000002E6 7000            	    98: 	moveq #0,d0												; fast pointer to handle
00:000002E8 6000FDEE        	    99: 	bra TCBInsertIntoReadyQueue
                            	   100: 
                            	   101: ; ----------------------------------------------------------------------------
                            	   102: ; Update the IRQ live indicator on screen.
                            	   103: ; ----------------------------------------------------------------------------
                            	   104: 
                            	   105: UpdateIRQLive:
00:000002EC 227900040004    	   106: 	move.l TextScr,a1					; a1 = screen address
00:000002F2 2411            	   107: 	move.l (a1),d2
00:000002F4 E15A            	   108: 	rol.w	#8,d2								; reverse byte order of d2
00:000002F6 4842            	   109: 	swap d2
00:000002F8 E15A            	   110: 	rol.w	#8,d2
00:000002FA 06010030        	   111: 	addi.b #'0',d1						; binary to ascii core number
00:000002FE D202            	   112: 	add.b	d2,d1
00:00000300 E159            	   113: 	rol.w	#8,d1								; put bytes back in order
00:00000302 4841            	   114: 	swap d1
00:00000304 E159            	   115: 	rol.w	#8,d1
00:00000306 23410004        	   116: 	move.l d1,4(a1)						; update onscreen IRQ flag
00:0000030A 5291            	   117: 	addi.l #1,(a1)						; flashy colors
00:0000030C 4E75            	   118: 	rts
                            	   119: 
                            	   120: ; ----------------------------------------------------------------------------
                            	   121: ; Femtiki IRQ service routine. This is where a thread switch can occur so,
                            	   122: ; the thread context is saved and restored.
                            	   123: ; ----------------------------------------------------------------------------
                            	   124: 
                            	   125: FemtikiTimerIRQ:
00:0000030E 46FC2600        	   126: 	move.w #$2600,sr							; disable lower level IRQs
00:00000312 2F00            	   127: 	move.l d0,-(a7)
00:00000314 2F08            	   128: 	move.l a0,-(a7)
00:00000316 6192            	   129: 	bsr GetRunningTCBPointer			; a0 = pointer to running TCB
00:00000318 48E8FFFF0004    	   130: 	movem.l #$FFFF,TCBRegs(a0)		; save all registers
00:0000031E 201F            	   131: 	move.l (a7)+,d0
00:00000320 21400020        	   132: 	move.l d0,32(a0)							; save original a0 value
00:00000324 201F            	   133: 	move.l (a7)+,d0
00:00000326 2080            	   134: 	move.l d0,(a0)								; save original d0 value
00:00000328 4E7A0800        	   135: 	movec usp,d0									; save user stack pointer
00:0000032C 21400044        	   136: 	move.l d0,TCBUSP(a0)
00:00000330 2E7C00041BFC    	   137: 	move.l #TimerStack,a7					; reset stack pointer
00:00000336 4E7A1FE0        	   138: 	movec	coreno,d1								; d1 = core number
00:0000033A 0C010002        	   139: 	cmpi.b #2,d1
00:0000033E 6612            	   140: 	bne.s	.0002
00:00000340 23FC1D000000FD09	   141: 	move.l #$1D000000,PLIC+$14		; reset edge sense circuit
00:00000348 0014
00:0000034A 13FC0001000400A0	   142: 	move.b #1,IRQFlag							; set IRQ flag for TinyBasic shell
                            	   143: .0002
00:00000352 6198            	   144: 	bsr UpdateIRQLive							; Update IRQ live indicator
                            	   145: ;	bsr ReceiveMsg								; Check for RPC
00:00000354 4E7A0FF0        	   146: 	movec tick,d0									; Update time accounting
00:00000358 21400070        	   147: 	move.l d0,TCBEndTick(a0)			; compute number of ticks thread was running
00:0000035C 90A8006C        	   148: 	sub.l	TCBStartTick(a0),d0
00:00000360 D1A80074        	   149: 	add.l	d0,TCBTicks(a0)					; add to cumulative ticks
00:00000364 117C00200054    	   150: 	move.b #TS_PREEMPT,TCBStatus(a0)	; set thread status to PREEMPT
00:0000036A 6100FF56        	   151: 	bsr	SelectThreadToRun					; d0 = TCB handle
00:0000036E 4E7B0012        	   152: 	movec d0,tr										; set running thread number in tr
00:00000372 6100FF36        	   153: 	bsr GetRunningTCBPointer			; a0 = pointer to TCB
00:00000376 117C00800054    	   154: 	move.b #TS_RUNNING,TCBStatus(a0)	; set thread status to RUNNING
00:0000037C 4E7A0FF0        	   155: 	movec	tick,d0
00:00000380 2140006C        	   156: 	move.l d0,TCBStartTick(a0)		; record starting tick
00:00000384 20280044        	   157: 	move.l TCBUSP(a0),d0					; restore user stack pointer
00:00000388 4E7B0800        	   158: 	movec d0,usp
00:0000038C 4CE8FFFF0004    	   159: 	movem.l TCBRegs(a0),#$FFFF		; restore all registers
00:00000392 504F            	   160: 	addq #8,sp										; "pop" d0/a0, saved stack pointer is off by 8
00:00000394 4E73            	   161: 	rte														; and return
                            	   162: 
                            	   163: 	include "..\Femtiki\source\kernel\Semaphore.x68"

Source: "..\Femtiki\source\kernel\Semaphore.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@finitron.ca
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;-------------------------------------------------------------------------------
                            	    38: ; Lock the system semaphore. Call the BIOS.
                            	    39: ;
                            	    40: ; Parameters:
                            	    41: ;		none
                            	    42: ; Returns:
                            	    43: ;		none
                            	    44: ;-------------------------------------------------------------------------------
                            	    45: 
                            	    46: LockSysSemaphore:
00:00000396 48E7C000        	    47: 	movem.l d0/d1,-(sp)
00:0000039A 7025            	    48: 	moveq #37,d0				; lock semaphore
00:0000039C 7208            	    49: 	moveq #FMTK_SEMA,d1
00:0000039E 4E4F            	    50: 	trap #15
00:000003A0 4CDF0003        	    51: 	movem.l (sp)+,d0/d1
00:000003A4 4E75            	    52: 	rts
                            	    53: 
                            	    54: 
                            	    55: ;-------------------------------------------------------------------------------
                            	    56: ; Unlock the system semaphore.
                            	    57: ;
                            	    58: ; Parameters:
                            	    59: ;		none
                            	    60: ; Returns:
                            	    61: ;		none
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: UnlockSysSemaphore:
00:000003A6 48E7C000        	    65: 	movem.l d0/d1,-(sp)
00:000003AA 7026            	    66: 	moveq #38,d0				; unlock semaphore
00:000003AC 7208            	    67: 	moveq #FMTK_SEMA,d1
00:000003AE 4E4F            	    68: 	trap #15
00:000003B0 4CDF0003        	    69: 	movem.l (sp)+,d0/d1
00:000003B4 4E75            	    70: 	rts
                            	    71: 
                            	    72: 

Source: "..\Femtiki\source\kernel\Femtiki.x68"
                            	   164: 
                            	   165: 

Source: "..\Femtiki\FemtikiTop.x68"
                            	    10: 

Source: "boot.x68"
                            	   131: 
                            	   132: DDATA EQU $FFFFFFF0     ; DS.L    3
                            	   133: HISPC EQU $FFFFFFFC     ; DS.L    1
                            	   134: SCREEN_FORMAT = 1
                            	   135: 
                            	   136: 	if HAS_MMU
                            	   137: TEXTREG		EQU	$1E3FF00	; virtual addresses
                            	   138: txtscreen	EQU	$1E00000
                            	   139: semamem		EQU	$1E50000
                            	   140: ACIA			EQU	$1E60000
                            	   141: ACIA_RX		EQU	0
                            	   142: ACIA_TX		EQU	0
                            	   143: ACIA_STAT	EQU	4
                            	   144: ACIA_CMD	EQU	8
                            	   145: ACIA_CTRL	EQU	12
                            	   146: I2C2 			equ $01E69000
                            	   147: I2C_PREL 	equ 0
                            	   148: I2C_PREH 	equ 1
                            	   149: I2C_CTRL 	equ 2
                            	   150: I2C_RXR 	equ 3
                            	   151: I2C_TXR 	equ 3
                            	   152: I2C_CMD 	equ 4
                            	   153: I2C_STAT 	equ 4
                            	   154: PLIC			EQU	$1E90000
                            	   155: MMU				EQU $FDC00000	; physical address
                            	   156: leds			EQU	$1EFFF00	; virtual addresses
                            	   157: keybd			EQU	$1EFFE00
                            	   158: KEYBD			EQU	$1EFFE00
                            	   159: RAND			EQU	$1EFFD00
                            	   160: RAND_NUM	EQU	$1EFFD00
                            	   161: RAND_STRM	EQU	$1EFFD04
                            	   162: RAND_MZ		EQU $1EFFD08
                            	   163: RAND_MW		EQU	$1EFFD0C
                            	   164: RST_REG		EQU	$1EFFC00
                            	   165: IO_BITMAP	EQU $1F00000
                            	   166: 	else
                            	   167: TEXTREG		EQU	$FD080000
                            	   168: txtscreen	EQU	$FD000000
                            	   169: semamem		EQU	$FD050000
                            	   170: ACIA			EQU	$FD060000
                            	   171: ACIA_RX		EQU	0
                            	   172: ACIA_TX		EQU	0
                            	   173: ACIA_STAT	EQU	4
                            	   174: ACIA_CMD	EQU	8
                            	   175: ACIA_CTRL	EQU	12
                            	   176: I2C2 			equ $FD069000
                            	   177: I2C_PREL 	equ 0
                            	   178: I2C_PREH 	equ 1
                            	   179: I2C_CTRL 	equ 2
                            	   180: I2C_RXR 	equ 3
                            	   181: I2C_TXR 	equ 3
                            	   182: I2C_CMD 	equ 4
                            	   183: I2C_STAT 	equ 4
                            	   184: PLIC			EQU	$FD090000
                            	   185: MMU				EQU $FDC00000	; physical address
                            	   186: leds			EQU	$FD0FFF00	; virtual addresses
                            	   187: keybd			EQU	$FD0FFE00
                            	   188: KEYBD			EQU	$FD0FFE00
                            	   189: RAND			EQU	$FD0FFD00
                            	   190: RAND_NUM	EQU	$FD0FFD00
                            	   191: RAND_STRM	EQU	$FD0FFD04
                            	   192: RAND_MZ		EQU $FD0FFD08
                            	   193: RAND_MW		EQU	$FD0FFD0C
                            	   194: RST_REG		EQU	$FD0FFC00
                            	   195: IO_BITMAP	EQU $FD100000
                            	   196: FRAMEBUF	EQU	$FD200000
                            	   197: GFXACCEL	EQU	$FD300000
                            	   198: 	endif
                            	   199: 
                            	   200: SERIAL_SEMA	EQU	2
                            	   201: KEYBD_SEMA	EQU	3
                            	   202: RAND_SEMA		EQU	4
                            	   203: SCREEN_SEMA	EQU	5
                            	   204: MEMORY_SEMA EQU 6
                            	   205: TCB_SEMA 		EQU	7
                            	   206: FMTK_SEMA		EQU	8
                            	   207: 
                            	   208: macIRQ_proc	macro arg1
                            	   209: 	dc.l IRQ_proc\1
                            	   210: endm
                            	   211: 
                            	   212: macIRQ_proc_label	macro arg1
                            	   213: IRQ_proc\1:
                            	   214: endm
                            	   215: 
                            	   216: 	data
                            	   217: 	; 0
01:00000000 00040FFC        	   218: 	dc.l		$00040FFC
01:00000004 000003B8        	   219: 	dc.l		start
01:00000008 0000935A        	   220: 	dc.l		bus_err
01:0000000C 00009736        	   221: 	dc.l		addr_err
01:00000010 00009784        	   222: 	dc.l		illegal_trap		* ILLEGAL instruction
01:00000014 00000000        	   223: 	dc.l		0
01:00000018 00002482        	   224: 	dc.l		chk_exception		; CHK
01:0000001C 000025C6        	   225: 	dc.l		EXCEPTION_7			* TRAPV
01:00000020 00000000        	   226: 	dc.l		0
01:00000024 00000000        	   227: 	dc.l		0
                            	   228: 	
                            	   229: 	; 10
01:00000028 00000000        	   230: 	dc.l		0
01:0000002C 00000000        	   231: 	dc.l		0
01:00000030 00000000        	   232: 	dc.l		0
01:00000034 00000000        	   233: 	dc.l		0
01:00000038 00000000        	   234: 	dc.l		0
01:0000003C 00000000        	   235: 	dc.l		0
01:00000040 00000000        	   236: 	dc.l		0
01:00000044 00000000        	   237: 	dc.l		0
01:00000048 00000000        	   238: 	dc.l		0
01:0000004C 00000000        	   239: 	dc.l		0
                            	   240: 	
                            	   241: 	; 20
01:00000050 00000000        	   242: 	dc.l		0
01:00000054 00000000        	   243: 	dc.l		0
01:00000058 00000000        	   244: 	dc.l		0
01:0000005C 00000000        	   245: 	dc.l		0
01:00000060 00009722        	   246: 	dc.l		SpuriousIRQ
01:00000064 00000000        	   247: 	dc.l		0
01:00000068 00000000        	   248: 	dc.l		0
01:0000006C 000096F0        	   249: 	dc.l		irq3_rout
01:00000070 00000000        	   250: 	dc.l		0
01:00000074 00000000        	   251: 	dc.l		0
                            	   252: 	
                            	   253: 	; 30
01:00000078 000096AE        	   254: 	dc.l		TickIRQ						; IRQ 30 - timer / keyboard
01:0000007C 00009724        	   255: 	dc.l		nmi_rout
01:00000080 00009614        	   256: 	dc.l		io_trap						; TRAP zero
01:00000084 00000000        	   257: 	dc.l		0
01:00000088 00000000        	   258: 	dc.l		0
01:0000008C 00009374        	   259: 	dc.l		trap3							; breakpoint
01:00000090 00000000        	   260: 	dc.l		0
01:00000094 00000000        	   261: 	dc.l		0
01:00000098 00000000        	   262: 	dc.l		0
01:0000009C 00000000        	   263: 	dc.l		0
                            	   264: 
                            	   265: 	; 40
01:000000A0 00000000        	   266: 	dc.l		0
01:000000A4 00000000        	   267: 	dc.l		0
01:000000A8 00000000        	   268: 	dc.l		0
01:000000AC 00000000        	   269: 	dc.l		0
01:000000B0 00000000        	   270: 	dc.l		0
01:000000B4 00000000        	   271: 	dc.l		0
01:000000B8 00000000        	   272: 	dc.l		0
01:000000BC 000076CE        	   273: 	dc.l		TRAP15
01:000000C0 00000000        	   274: 	dc.l		0
01:000000C4 00000000        	   275: 	dc.l		0
                            	   276: 
                            	   277: 	; 50	
01:000000C8 00000000        	   278: 	dc.l		0
01:000000CC 00000000        	   279: 	dc.l		0
01:000000D0 00000000        	   280: 	dc.l		0
01:000000D4 00000000        	   281: 	dc.l		0
01:000000D8 00000000        	   282: 	dc.l		0
01:000000DC 00000000        	   283: 	dc.l		0
01:000000E0 00000000        	   284: 	dc.l		0
01:000000E4 00000000        	   285: 	dc.l		0
01:000000E8 00000000        	   286: 	dc.l		0
01:000000EC 0000979A        	   287: 	dc.l		io_irq
                            	   288: 
                            	   289: 	; 60
01:000000F0 00000B7A        	   290: 	dc.l		KeybdIRQ
01:000000F4 000017D8        	   291: 	dc.l		SerialIRQ
01:000000F8 00000000        	   292: 	dc.l		0
01:000000FC 0000974C        	   293: 	dc.l		brdisp_trap
                            	   294: 	
                            	   295: 	; 64
                            	   296: 
                            	   297: IRQ_trampolines:
                            	   298: ;	rept 192
                            	   299: ;	macIRQ_proc REPTN
                            	   300: ;	endr
                            	   301: 
                            	   302: 	org			$400
                            	   303: 
                            	   304: irq_list_tbl:
                            	   305: 	rept 192
                            	   306: 	dc.l 0
                            	   307: 	dc.l 0
                            	   308: 	endr
01:00000400 00000000        	     1R 	dc.l 0
01:00000404 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000408 00000000        	     1R 	dc.l 0
01:0000040C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000410 00000000        	     1R 	dc.l 0
01:00000414 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000418 00000000        	     1R 	dc.l 0
01:0000041C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000420 00000000        	     1R 	dc.l 0
01:00000424 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000428 00000000        	     1R 	dc.l 0
01:0000042C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000430 00000000        	     1R 	dc.l 0
01:00000434 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000438 00000000        	     1R 	dc.l 0
01:0000043C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000440 00000000        	     1R 	dc.l 0
01:00000444 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000448 00000000        	     1R 	dc.l 0
01:0000044C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000450 00000000        	     1R 	dc.l 0
01:00000454 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000458 00000000        	     1R 	dc.l 0
01:0000045C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000460 00000000        	     1R 	dc.l 0
01:00000464 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000468 00000000        	     1R 	dc.l 0
01:0000046C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000470 00000000        	     1R 	dc.l 0
01:00000474 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000478 00000000        	     1R 	dc.l 0
01:0000047C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000480 00000000        	     1R 	dc.l 0
01:00000484 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000488 00000000        	     1R 	dc.l 0
01:0000048C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000490 00000000        	     1R 	dc.l 0
01:00000494 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000498 00000000        	     1R 	dc.l 0
01:0000049C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004A0 00000000        	     1R 	dc.l 0
01:000004A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004A8 00000000        	     1R 	dc.l 0
01:000004AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004B0 00000000        	     1R 	dc.l 0
01:000004B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004B8 00000000        	     1R 	dc.l 0
01:000004BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004C0 00000000        	     1R 	dc.l 0
01:000004C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004C8 00000000        	     1R 	dc.l 0
01:000004CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004D0 00000000        	     1R 	dc.l 0
01:000004D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004D8 00000000        	     1R 	dc.l 0
01:000004DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004E0 00000000        	     1R 	dc.l 0
01:000004E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004E8 00000000        	     1R 	dc.l 0
01:000004EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004F0 00000000        	     1R 	dc.l 0
01:000004F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000004F8 00000000        	     1R 	dc.l 0
01:000004FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000500 00000000        	     1R 	dc.l 0
01:00000504 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000508 00000000        	     1R 	dc.l 0
01:0000050C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000510 00000000        	     1R 	dc.l 0
01:00000514 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000518 00000000        	     1R 	dc.l 0
01:0000051C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000520 00000000        	     1R 	dc.l 0
01:00000524 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000528 00000000        	     1R 	dc.l 0
01:0000052C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000530 00000000        	     1R 	dc.l 0
01:00000534 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000538 00000000        	     1R 	dc.l 0
01:0000053C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000540 00000000        	     1R 	dc.l 0
01:00000544 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000548 00000000        	     1R 	dc.l 0
01:0000054C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000550 00000000        	     1R 	dc.l 0
01:00000554 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000558 00000000        	     1R 	dc.l 0
01:0000055C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000560 00000000        	     1R 	dc.l 0
01:00000564 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000568 00000000        	     1R 	dc.l 0
01:0000056C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000570 00000000        	     1R 	dc.l 0
01:00000574 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000578 00000000        	     1R 	dc.l 0
01:0000057C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000580 00000000        	     1R 	dc.l 0
01:00000584 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000588 00000000        	     1R 	dc.l 0
01:0000058C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000590 00000000        	     1R 	dc.l 0
01:00000594 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000598 00000000        	     1R 	dc.l 0
01:0000059C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005A0 00000000        	     1R 	dc.l 0
01:000005A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005A8 00000000        	     1R 	dc.l 0
01:000005AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005B0 00000000        	     1R 	dc.l 0
01:000005B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005B8 00000000        	     1R 	dc.l 0
01:000005BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005C0 00000000        	     1R 	dc.l 0
01:000005C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005C8 00000000        	     1R 	dc.l 0
01:000005CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005D0 00000000        	     1R 	dc.l 0
01:000005D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005D8 00000000        	     1R 	dc.l 0
01:000005DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005E0 00000000        	     1R 	dc.l 0
01:000005E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005E8 00000000        	     1R 	dc.l 0
01:000005EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005F0 00000000        	     1R 	dc.l 0
01:000005F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000005F8 00000000        	     1R 	dc.l 0
01:000005FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000600 00000000        	     1R 	dc.l 0
01:00000604 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000608 00000000        	     1R 	dc.l 0
01:0000060C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000610 00000000        	     1R 	dc.l 0
01:00000614 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000618 00000000        	     1R 	dc.l 0
01:0000061C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000620 00000000        	     1R 	dc.l 0
01:00000624 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000628 00000000        	     1R 	dc.l 0
01:0000062C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000630 00000000        	     1R 	dc.l 0
01:00000634 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000638 00000000        	     1R 	dc.l 0
01:0000063C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000640 00000000        	     1R 	dc.l 0
01:00000644 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000648 00000000        	     1R 	dc.l 0
01:0000064C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000650 00000000        	     1R 	dc.l 0
01:00000654 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000658 00000000        	     1R 	dc.l 0
01:0000065C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000660 00000000        	     1R 	dc.l 0
01:00000664 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000668 00000000        	     1R 	dc.l 0
01:0000066C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000670 00000000        	     1R 	dc.l 0
01:00000674 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000678 00000000        	     1R 	dc.l 0
01:0000067C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000680 00000000        	     1R 	dc.l 0
01:00000684 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000688 00000000        	     1R 	dc.l 0
01:0000068C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000690 00000000        	     1R 	dc.l 0
01:00000694 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000698 00000000        	     1R 	dc.l 0
01:0000069C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006A0 00000000        	     1R 	dc.l 0
01:000006A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006A8 00000000        	     1R 	dc.l 0
01:000006AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006B0 00000000        	     1R 	dc.l 0
01:000006B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006B8 00000000        	     1R 	dc.l 0
01:000006BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006C0 00000000        	     1R 	dc.l 0
01:000006C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006C8 00000000        	     1R 	dc.l 0
01:000006CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006D0 00000000        	     1R 	dc.l 0
01:000006D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006D8 00000000        	     1R 	dc.l 0
01:000006DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006E0 00000000        	     1R 	dc.l 0
01:000006E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006E8 00000000        	     1R 	dc.l 0
01:000006EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006F0 00000000        	     1R 	dc.l 0
01:000006F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000006F8 00000000        	     1R 	dc.l 0
01:000006FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000700 00000000        	     1R 	dc.l 0
01:00000704 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000708 00000000        	     1R 	dc.l 0
01:0000070C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000710 00000000        	     1R 	dc.l 0
01:00000714 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000718 00000000        	     1R 	dc.l 0
01:0000071C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000720 00000000        	     1R 	dc.l 0
01:00000724 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000728 00000000        	     1R 	dc.l 0
01:0000072C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000730 00000000        	     1R 	dc.l 0
01:00000734 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000738 00000000        	     1R 	dc.l 0
01:0000073C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000740 00000000        	     1R 	dc.l 0
01:00000744 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000748 00000000        	     1R 	dc.l 0
01:0000074C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000750 00000000        	     1R 	dc.l 0
01:00000754 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000758 00000000        	     1R 	dc.l 0
01:0000075C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000760 00000000        	     1R 	dc.l 0
01:00000764 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000768 00000000        	     1R 	dc.l 0
01:0000076C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000770 00000000        	     1R 	dc.l 0
01:00000774 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000778 00000000        	     1R 	dc.l 0
01:0000077C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000780 00000000        	     1R 	dc.l 0
01:00000784 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000788 00000000        	     1R 	dc.l 0
01:0000078C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000790 00000000        	     1R 	dc.l 0
01:00000794 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000798 00000000        	     1R 	dc.l 0
01:0000079C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007A0 00000000        	     1R 	dc.l 0
01:000007A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007A8 00000000        	     1R 	dc.l 0
01:000007AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007B0 00000000        	     1R 	dc.l 0
01:000007B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007B8 00000000        	     1R 	dc.l 0
01:000007BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007C0 00000000        	     1R 	dc.l 0
01:000007C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007C8 00000000        	     1R 	dc.l 0
01:000007CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007D0 00000000        	     1R 	dc.l 0
01:000007D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007D8 00000000        	     1R 	dc.l 0
01:000007DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007E0 00000000        	     1R 	dc.l 0
01:000007E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007E8 00000000        	     1R 	dc.l 0
01:000007EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007F0 00000000        	     1R 	dc.l 0
01:000007F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000007F8 00000000        	     1R 	dc.l 0
01:000007FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000800 00000000        	     1R 	dc.l 0
01:00000804 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000808 00000000        	     1R 	dc.l 0
01:0000080C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000810 00000000        	     1R 	dc.l 0
01:00000814 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000818 00000000        	     1R 	dc.l 0
01:0000081C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000820 00000000        	     1R 	dc.l 0
01:00000824 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000828 00000000        	     1R 	dc.l 0
01:0000082C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000830 00000000        	     1R 	dc.l 0
01:00000834 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000838 00000000        	     1R 	dc.l 0
01:0000083C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000840 00000000        	     1R 	dc.l 0
01:00000844 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000848 00000000        	     1R 	dc.l 0
01:0000084C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000850 00000000        	     1R 	dc.l 0
01:00000854 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000858 00000000        	     1R 	dc.l 0
01:0000085C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000860 00000000        	     1R 	dc.l 0
01:00000864 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000868 00000000        	     1R 	dc.l 0
01:0000086C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000870 00000000        	     1R 	dc.l 0
01:00000874 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000878 00000000        	     1R 	dc.l 0
01:0000087C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000880 00000000        	     1R 	dc.l 0
01:00000884 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000888 00000000        	     1R 	dc.l 0
01:0000088C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000890 00000000        	     1R 	dc.l 0
01:00000894 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000898 00000000        	     1R 	dc.l 0
01:0000089C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008A0 00000000        	     1R 	dc.l 0
01:000008A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008A8 00000000        	     1R 	dc.l 0
01:000008AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008B0 00000000        	     1R 	dc.l 0
01:000008B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008B8 00000000        	     1R 	dc.l 0
01:000008BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008C0 00000000        	     1R 	dc.l 0
01:000008C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008C8 00000000        	     1R 	dc.l 0
01:000008CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008D0 00000000        	     1R 	dc.l 0
01:000008D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008D8 00000000        	     1R 	dc.l 0
01:000008DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008E0 00000000        	     1R 	dc.l 0
01:000008E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008E8 00000000        	     1R 	dc.l 0
01:000008EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008F0 00000000        	     1R 	dc.l 0
01:000008F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000008F8 00000000        	     1R 	dc.l 0
01:000008FC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000900 00000000        	     1R 	dc.l 0
01:00000904 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000908 00000000        	     1R 	dc.l 0
01:0000090C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000910 00000000        	     1R 	dc.l 0
01:00000914 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000918 00000000        	     1R 	dc.l 0
01:0000091C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000920 00000000        	     1R 	dc.l 0
01:00000924 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000928 00000000        	     1R 	dc.l 0
01:0000092C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000930 00000000        	     1R 	dc.l 0
01:00000934 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000938 00000000        	     1R 	dc.l 0
01:0000093C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000940 00000000        	     1R 	dc.l 0
01:00000944 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000948 00000000        	     1R 	dc.l 0
01:0000094C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000950 00000000        	     1R 	dc.l 0
01:00000954 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000958 00000000        	     1R 	dc.l 0
01:0000095C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000960 00000000        	     1R 	dc.l 0
01:00000964 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000968 00000000        	     1R 	dc.l 0
01:0000096C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000970 00000000        	     1R 	dc.l 0
01:00000974 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000978 00000000        	     1R 	dc.l 0
01:0000097C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000980 00000000        	     1R 	dc.l 0
01:00000984 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000988 00000000        	     1R 	dc.l 0
01:0000098C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000990 00000000        	     1R 	dc.l 0
01:00000994 00000000        	     2R 	dc.l 0
                            	     3R 	
01:00000998 00000000        	     1R 	dc.l 0
01:0000099C 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009A0 00000000        	     1R 	dc.l 0
01:000009A4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009A8 00000000        	     1R 	dc.l 0
01:000009AC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009B0 00000000        	     1R 	dc.l 0
01:000009B4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009B8 00000000        	     1R 	dc.l 0
01:000009BC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009C0 00000000        	     1R 	dc.l 0
01:000009C4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009C8 00000000        	     1R 	dc.l 0
01:000009CC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009D0 00000000        	     1R 	dc.l 0
01:000009D4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009D8 00000000        	     1R 	dc.l 0
01:000009DC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009E0 00000000        	     1R 	dc.l 0
01:000009E4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009E8 00000000        	     1R 	dc.l 0
01:000009EC 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009F0 00000000        	     1R 	dc.l 0
01:000009F4 00000000        	     2R 	dc.l 0
                            	     3R 	
01:000009F8 00000000        	     1R 	dc.l 0
01:000009FC 00000000        	     2R 	dc.l 0
                            	     3R 	
                            	   309: 
                            	   310: 	org			$A00
                            	   311: 
                            	   312: ;-------------------------------------------------------------------------------
                            	   313: ;-------------------------------------------------------------------------------
                            	   314: 
                            	   315: ; BIOS variables which must be local (not shared) to each core
                            	   316: 
                            	   317: CursorRow	equ		$40000
                            	   318: CursorCol	equ		$40001
                            	   319: TextPos		equ		$40002
                            	   320: TextCurpos	equ	$40002
                            	   321: TextScr			equ	$40004
                            	   322: S19StartAddress	equ	$40008
                            	   323: KeybdEcho		equ	$4000C
                            	   324: KeybdWaitFlag	equ	$4000D
                            	   325: CmdBuf			equ $40040
                            	   326: CmdBufEnd		equ	$40080
                            	   327: fgColor			equ	$40084
                            	   328: bkColor			equ	$40088
                            	   329: TextRows		equ	$4008C
                            	   330: TextCols		equ	$4008D
                            	   331: _fpTextIncr	equ $40094
                            	   332: _canary			equ $40098
                            	   333: tickcnt			equ $4009C
                            	   334: IRQFlag			equ $400A0
                            	   335: InputDevice	equ $400A4
                            	   336: OutputDevice	equ $400A8
                            	   337: Regsave			equ	$40100
                            	   338: numBreakpoints	equ		8
                            	   339: BreakpointFlag	equ		$40200
                            	   340: NumSetBreakpoints	equ	$40202	; to $40203
                            	   341: Breakpoints			equ		$40220	; to $40240
                            	   342: BreakpointWords	equ		$40280	; to $402A0
                            	   343: fpBuf       equ $402C0
                            	   344: ;RunningTCB  equ $40300
                            	   345: _exp equ $40500
                            	   346: _digit equ $40504
                            	   347: _width equ $40508
                            	   348: _E equ $4050C
                            	   349: _digits_before_decpt equ $40510
                            	   350: _precision equ $40514
                            	   351: _fpBuf equ $40520	; to $40560
                            	   352: _fpWork equ $40600
                            	   353: _dasmbuf	equ	$40800
                            	   354: OFFSET equ $40880
                            	   355: pen_color equ $40890
                            	   356: gr_x equ $40894
                            	   357: gr_y equ $40898
                            	   358: gr_width equ $4089C
                            	   359: gr_height equ $408A0
                            	   360: gr_bitmap_screen equ $408A4
                            	   361: gr_raster_op equ $408A8
                            	   362: gr_double_buffer equ $408AC
                            	   363: gr_bitmap_buffer equ $408B0
                            	   364: sys_switches equ $408B8
                            	   365: gfxaccel_ctrl equ $408C0
                            	   366: m_z equ $408D0
                            	   367: m_w equ $408D4
                            	   368: next_m_z equ $408D8
                            	   369: next_m_w equ $408DC
                            	   370: EightPixels equ $40100000	; to $40200020
                            	   371: 
                            	   372: null_dcb equ $0040A00		; 0
                            	   373: keybd_dcb equ null_dcb+DCB_SIZE	; 1
                            	   374: textvid_dcb equ keybd_dcb+DCB_SIZE	; 2
                            	   375: err_dcb equ textvid_dcb+DCB_SIZE		; 3
                            	   376: serial_dcb equ err_dcb+DCB_SIZE*2		; 5
                            	   377: framebuf_dcb equ serial_dcb+DCB_SIZE	; 6
                            	   378: gfxaccel_dcb equ framebuf_dcb+DCB_SIZE	; 7
                            	   379: 
                            	   380: TimerStack	equ	$41BFC
                            	   381: 
                            	   382: ; Keyboard buffer is in shared memory
                            	   383: IOFocus			EQU	$00100000
                            	   384: memend			equ $00100004
                            	   385: KeybdLEDs		equ	$0010000E
                            	   386: _KeyState1	equ	$0010000F
                            	   387: _KeyState2	equ	$00100010
                            	   388: _KeybdHead	equ	$00100011
                            	   389: _KeybdTail	equ	$00100012
                            	   390: _KeybdCnt		equ	$00100013
                            	   391: KeybdID			equ	$00100018
                            	   392: _Keybd_tick	equ $0001001C
                            	   393: _KeybdBuf		equ	$00100020
                            	   394: _KeybdOBuf	equ	$00100080
                            	   395: S19Checksum	equ	$00100150
                            	   396: SerTailRcv	equ	$00100160
                            	   397: SerHeadRcv	equ	$00100162
                            	   398: SerRcvXon		equ	$00100164
                            	   399: SerRcvXoff	equ	$00100165
                            	   400: SerTailXmit	equ	$00100166
                            	   401: SerHeadXmit	equ	$00100168
                            	   402: SerXmitXoff	equ	$0010016A
                            	   403: SerRcvBuf		equ	$00101000
                            	   404: SerXmitBuf	equ	$00102000
                            	   405: RTCBuf			equ $00100200	; to $0010023F
                            	   406: 
                            	   407: 	code
                            	   408: 	align		2
                            	   409: start:
                            	   410: ;	fadd (a0)+,fp2
00:000003B8 13FC0001FD0FFF00	   411: 	move.b #1,leds
00:000003C0 46FC2700        	   412: 	move.w #$2700,sr					; enable level 6 and higher interrupts
00:000003C4 7000            	   413: 	moveq #0,d0								; set address space zero
00:000003C6 4E7B0003        	   414: 	movec d0,asid
                            	   415: 	; Setup circuit select signals
00:000003CA 203CFDC00000    	   416: 	move.l #MMU,d0
00:000003D0 4E7B0014        	   417: 	movec d0,mmus
                            	   418: 	if HAS_MMU
                            	   419: 		move.l #$01F00000,d0			; set virtual address for iop bitmap
                            	   420: 		movec d0,iops
                            	   421: 		move.l #$01E00000,d0			; set virtual address for io block
                            	   422: 		movec d0,ios
                            	   423: 	else
00:000003D4 203CFD100000    	   424: 		move.l #$FD100000,d0			; set virtual address for iop bitmap
00:000003DA 4E7B0016        	   425: 		movec d0,iops
00:000003DE 203CFD000000    	   426: 		move.l #$FD000000,d0			; set virtual address for io block
00:000003E4 4E7B0015        	   427: 		movec d0,ios
                            	   428: 	endif
                            	   429: ;	move.l $4000000C,d0
00:000003E8 13FC0002FD0FFF00	   430: 	move.b #2,leds
00:000003F0 4E7A0FE0        	   431: 	movec coreno,d0							; set initial value of thread register
00:000003F4 4840            	   432: 	swap d0											; coreno in high eight bits
00:000003F6 E188            	   433: 	lsl.l #8,d0
00:000003F8 4E7B0012        	   434: 	movec d0,tr
                            	   435: 	; Prepare local variable storage
00:000003FC 303C03FF        	   436: 	move.w #1023,d0						; 1024 longs to clear
00:00000400 41F900040000    	   437: 	lea	$40000,a0							; non shared local memory address
                            	   438: .0111:
00:00000406 4298            	   439: 	clr.l	(a0)+								; clear the memory area
00:00000408 51C8FFFC        	   440: 	dbra d0,.0111
00:0000040C 13FC0005FD0FFF00	   441: 	move.b #5,leds
00:00000414 13FC0001000400A4	   442: 	move.b #1,InputDevice			; select keyboard input
00:0000041C 13FC0002000400A8	   443: 	move.b #2,OutputDevice		; select text screen output
00:00000424 61000B92        	   444: 	bsr setup_textvid
00:00000428 13FC0003FD0FFF00	   445: 	move.b #3,leds
00:00000430 610000EE        	   446: 	bsr setup_null
00:00000434 13FC0004FD0FFF00	   447: 	move.b #4,leds
00:0000043C 6100012A        	   448: 	bsr setup_keybd
00:00000440 13FC0006FD0FFF00	   449: 	move.b #6,leds
00:00000448 6100111E        	   450: 	bsr setup_serial
00:0000044C 13FC0007FD0FFF00	   451: 	move.b #7,leds
00:00000454 4E7A0FE0        	   452: 	movec.l	coreno,d0					; get core number
00:00000458 0C000002        	   453: 	cmpi.b #2,d0
00:0000045C 66000096        	   454: 	bne	start_other
00:00000460 61001500        	   455: 	bsr setup_framebuf
00:00000464 13FC0008FD0FFF00	   456: 	move.b #8,leds
00:0000046C 61001968        	   457: 	bsr setup_gfxaccel
00:00000470 13FC0009FD0FFF00	   458: 	move.b #9,leds
00:00000478 42B9000408B8    	   459: 	clr.l sys_switches
00:0000047E 4E7A0FE0        	   460: 	movec.l	coreno,d0					; get core number
00:00000482 13C000100000    	   461: 	move.b d0,IOFocus					; Set the IO focus in global memory
                            	   462: 	if HAS_MMU
                            	   463: 		bsr InitMMU							; Can't access anything till this is done'
                            	   464: 	endif
00:00000488 61001DD4        	   465: 	bsr	InitIOPBitmap					; not going to get far without this
00:0000048C 61001F4C        	   466: 	bsr	InitSemaphores
00:00000490 61001E18        	   467: 	bsr	InitRand
00:00000494 61001E7E        	   468: 	bsr RandGetNum
00:00000498 0281FFFFFF00    	   469: 	andi.l #$FFFFFF00,d1
00:0000049E 23C100040098    	   470: 	move.l d1,_canary
00:000004A4 4E7B1020        	   471: 	movec d1,canary
                            	   472: ;	bsr	Delay3s						; give devices time to reset
                            	   473: ;	moveq #2,d7					; device 2
                            	   474: ;	moveq #DEV_CLEAR,d6	; clear
                            	   475: ;	trap #0
                            	   476: ;	bsr	textvid_clear
                            	   477: 
00:000004A8 6100020A        	   478: 	bsr	_KeybdInit
                            	   479: ;	bsr	InitIRQ
00:000004AC 61001176        	   480: 	bsr	SerialInit
                            	   481: ;	bsr init_i2c
                            	   482: ;	bsr rtc_read
                            	   483: 
                            	   484: 	; Write startup message to screen
                            	   485: 
00:000004B0 43F9000097AE    	   486: 	lea	msg_start,a1
00:000004B6 610071D8        	   487: 	bsr	DisplayString
                            	   488: ;	bsr	FemtikiInit
00:000004BA 4E7A0FE0        	   489: 	movec	coreno,d0
00:000004BE 4840            	   490: 	swap d0
00:000004C0 7201            	   491: 	moveq	#1,d1
00:000004C2 61001F78        	   492: 	bsr	UnlockSemaphore	; allow another cpu access
00:000004C6 7200            	   493: 	moveq	#0,d1
00:000004C8 61001F72        	   494: 	bsr	UnlockSemaphore	; allow other cpus to proceed
00:000004CC 33FCA4A4FD0FFF00	   495: 	move.w #$A4A4,leds			; diagnostics
00:000004D4 610076B6        	   496: 	bsr	init_plic				; initialize platform level interrupt controller
00:000004D8 600077A0        	   497: 	bra	StartMon
00:000004DC 61001FF8        	   498: 	bsr	cpu_test
                            	   499: ;	lea	brdisp_trap,a0	; set brdisp trap vector
                            	   500: ;	move.l	a0,64*4
                            	   501: 
                            	   502: loop2:
00:000004E0 70FF            	   503: 	move.l	#-1,d0
                            	   504: loop1:
00:000004E2 2200            	   505: 	move.l	d0,d1
00:000004E4 E089            	   506: 	lsr.l		#8,d1
00:000004E6 E089            	   507: 	lsr.l		#8,d1
00:000004E8 13C1FD0FFF00    	   508: 	move.b	d1,leds
00:000004EE 51C8FFF2        	   509: 	dbra		d0,loop1
00:000004F2 60EC            	   510: 	bra			loop2
                            	   511: 
                            	   512: start_other:
00:000004F4 61001FC4        	   513: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:000004F8 61001FC0        	   514: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:000004FC 61001FBC        	   515: 	bsr			Delay3s2						; need time for system setup (io_bitmap etc.)
00:00000500 7E02            	   516: 	move.l #2,d7
00:00000502 7C0C            	   517: 	move.l #DEV_CLEAR,d6
00:00000504 4E40            	   518: 	trap #0
00:00000506 4E7A1FE0        	   519: 	movec		coreno,d1
00:0000050A 4EB900008E80    	   520: 	bsr			DisplayByte
00:00000510 43F9000097D5    	   521: 	lea			msg_core_start,a1
00:00000516 61007178        	   522: 	bsr			DisplayString
                            	   523: ;	bsr			FemtikiInitIRQ
                            	   524: do_nothing:	
00:0000051A 6000775E        	   525: 	bra			StartMon
00:0000051E 60FA            	   526: 	bra			do_nothing
                            	   527: 
                            	   528: ;------------------------------------------------------------------------------
                            	   529: ; Initialize the MMU to allow thread #0 access to IO
                            	   530: ;------------------------------------------------------------------------------
                            	   531: 	if HAS_MMU
                            	   532: 	align 2
                            	   533: mmu_adrtbl:	; virtual address[24:16], physical address[31:16] bytes reversed!
                            	   534: 	dc.l	$0010,$10000300	; global scratch pad
                            	   535: 	dc.l	$01E0,$00FD0300	
                            	   536: 	dc.l	$01E1,$01FD0300
                            	   537: 	dc.l	$01E2,$02FD0300
                            	   538: 	dc.l  $01E3,$03FD0300
                            	   539: 	dc.l	$01E5,$05FD0300
                            	   540: 	dc.l	$01E6,$06FD0300
                            	   541: 	dc.l	$01E9,$09FD0300
                            	   542: 	dc.l	$01EF,$0FFD0300
                            	   543: 	dc.l	$01F0,$10FD0300
                            	   544: 	dc.l  $01FF,$FFFF0300	; all ones output for IRQ ack needed
                            	   545: 
                            	   546: 	even
                            	   547: InitMMU:
                            	   548: 	lea MMU+8,a0				; first 128kB is local RAM
                            	   549: 	move.l #$32000,d2		; map all pages to DRAM
                            	   550: 	move.l #510,d0			; then override for IO later
                            	   551: .0002
                            	   552: 	move.l d2,d1
                            	   553: 	bsr rbo
                            	   554: 	move.l d1,(a0)+
                            	   555: 	addi.w #1,d2				; increment DRAM page number
                            	   556: 	dbra d0,.0002
                            	   557: 	lea MMU,a0					; now program IO access
                            	   558: 	lea mmu_adrtbl,a1
                            	   559: 	moveq #10,d0
                            	   560: .0001
                            	   561: 	move.l (a1)+,d2
                            	   562: 	lsl.l #2,d2
                            	   563: 	move.l (a1)+,(a0,d2.w)
                            	   564: 	dbra d0,.0001
                            	   565: 	rts	
                            	   566: 	endif
                            	   567: 
                            	   568: ;------------------------------------------------------------------------------
                            	   569: ; Device drivers
                            	   570: ;------------------------------------------------------------------------------
                            	   571: 
                            	   572: 	include "null.x68"

Source: "null.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;------------------------------------------------------------------------------
                            	    38: ;------------------------------------------------------------------------------
                            	    39: ; Setup the NULL device
                            	    40: ;------------------------------------------------------------------------------
                            	    41: ;------------------------------------------------------------------------------
                            	    42: 
                            	    43: setup_null:
                            	    44: null_init:
00:00000520 48E780C0        	    45: 	movem.l d0/a0/a1,-(a7)
00:00000524 7020            	    46: 	moveq #32,d0
00:00000526 41F900040A00    	    47: 	lea.l null_dcb,a0
                            	    48: .0001:
00:0000052C 4298            	    49: 	clr.l (a0)+
00:0000052E 51C8FFFC        	    50: 	dbra d0,.0001
00:00000532 23FC444342200004	    51: 	move.l #$44434220,null_dcb+DCB_MAGIC				; 'DCB'
00:0000053A 0A00
00:0000053C 23FC4E554C4C0004	    52: 	move.l #$4E554C4C,null_dcb+DCB_NAME					; 'NULL'
00:00000544 0A04
00:00000546 23FC000005640004	    53: 	move.l #null_cmdproc,null_dcb+DCB_CMDPROC
00:0000054E 0A18
00:00000550 43F900040A00    	    54: 	lea.l null_dcb+DCB_MAGIC,a1
00:00000556 61007138        	    55: 	jsr DisplayString
00:0000055A 6100711A        	    56: 	jsr CRLF
00:0000055E 4CDF0301        	    57: 	movem.l (a7)+,d0/a0/a1
                            	    58: null_ret:
00:00000562 4E75            	    59: 	rts
                            	    60: 
                            	    61: null_cmdproc:
00:00000564 7000            	    62: 	moveq #E_Ok,d0
00:00000566 4E75            	    63: 	rts
                            	    64: 
                            	    65: 

Source: "boot.x68"
                            	   573: 	include "keybd.x68"

Source: "keybd.x68"
                            	     1: ;==============================================================================
                            	     2: ; Keyboard stuff
                            	     3: ;
                            	     4: ; KeyState2_
                            	     5: ; 876543210
                            	     6: ; ||||||||+ = shift
                            	     7: ; |||||||+- = alt
                            	     8: ; ||||||+-- = control
                            	     9: ; |||||+--- = numlock
                            	    10: ; ||||+---- = capslock
                            	    11: ; |||+----- = scrolllock
                            	    12: ; ||+------ =
                            	    13: ; |+------- = 
                            	    14: ; +-------- = extended
                            	    15: ;
                            	    16: ;==============================================================================
                            	    17: 
                            	    18: ;------------------------------------------------------------------------------
                            	    19: ; Setup the Keyboard device
                            	    20: ;------------------------------------------------------------------------------
                            	    21: setup_keybd:
                            	    22: keybd_init:
00:00000568 48E780C0        	    23: 	movem.l d0/a0/a1,-(a7)
00:0000056C 7020            	    24: 	moveq #32,d0
00:0000056E 41F900040A84    	    25: 	lea.l keybd_dcb,a0
                            	    26: .0001:
00:00000574 4298            	    27: 	clr.l (a0)+
00:00000576 51C8FFFC        	    28: 	dbra d0,.0001
00:0000057A 23FC444342200004	    29: 	move.l #$44434220,keybd_dcb+DCB_MAGIC				; 'DCB '
00:00000582 0A84
00:00000584 23FC4B4244000004	    30: 	move.l #$4B424400,keybd_dcb+DCB_NAME				; 'KBD'
00:0000058C 0A88
00:0000058E 23FC0000060C0004	    31: 	move.l #keybd_cmdproc,keybd_dcb+DCB_CMDPROC
00:00000596 0A9C
00:00000598 23FC001000200004	    32: 	move.l #_KeybdBuf,keybd_dcb+DCB_INBUFPTR
00:000005A0 0ABC
00:000005A2 23FC001000800004	    33: 	move.l #_KeybdOBuf,keybd_dcb+DCB_OUTBUFPTR
00:000005AA 0AC0
00:000005AC 23FC000000200004	    34: 	move.l #32,keybd_dcb+DCB_INBUFSIZE
00:000005B4 0AC4
00:000005B6 23FC000000200004	    35: 	move.l #32,keybd_dcb+DCB_OUTBUFSIZE
00:000005BE 0AC8
00:000005C0 423900040AD8    	    36: 	clr.b keybd_dcb+DCB_OUTDIMX	; set rows and columns
00:000005C6 423900040ADC    	    37: 	clr.b keybd_dcb+DCB_OUTDIMY
00:000005CC 423900040ACC    	    38: 	clr.b keybd_dcb+DCB_INDIMX		; set rows and columns
00:000005D2 423900040AD0    	    39: 	clr.b keybd_dcb+DCB_INDIMY
                            	    40: ;	bsr KeybdInit
00:000005D8 43F900040A84    	    41: 	lea.l keybd_dcb+DCB_MAGIC,a1
00:000005DE 610070B0        	    42: 	jsr DisplayString
00:000005E2 61007092        	    43: 	jsr CRLF
00:000005E6 4CDF0301        	    44: 	movem.l (a7)+,d0/a0/a1
00:000005EA 4E75            	    45: 	rts
                            	    46: 
                            	    47: 	align 2
                            	    48: KBD_CMDTBL:
00:000005EC 00000568        	    49: 	dc.l keybd_init				; 0
00:000005F0 0000062E        	    50: 	dc.l keybd_stat
00:000005F4 00000636        	    51: 	dc.l keybd_putchar
00:000005F8 00000646        	    52: 	dc.l keybd_putbuf
00:000005FC 0000063E        	    53: 	dc.l keybd_getchar
00:00000600 00000646        	    54: 	dc.l keybd_getbuf
00:00000604 00000646        	    55: 	dc.l keybd_set_inpos
00:00000608 00000646        	    56: 	dc.l keybd_set_outpos
                            	    57: 
                            	    58: keybd_cmdproc:
00:0000060C 0C060008        	    59: 	cmpi.b #8,d6
00:00000610 6418            	    60: 	bhs.s .0001
00:00000612 48E70280        	    61: 	movem.l d6/a0,-(a7)
00:00000616 E506            	    62: 	asl.b #2,d6
00:00000618 4886            	    63: 	ext.w d6
00:0000061A 41FAFFD0        	    64: 	lea KBD_CMDTBL,a0
00:0000061E 20706000        	    65: 	move.l (a0,d6.w),a0
00:00000622 4E90            	    66: 	jsr (a0)
00:00000624 4CDF0140        	    67: 	movem.l (a7)+,d6/a0
00:00000628 4E75            	    68: 	rts
                            	    69: .0001:
00:0000062A 7002            	    70: 	moveq #E_Func,d0
00:0000062C 4E75            	    71: 	rts
                            	    72: 
                            	    73: keybd_stat:
00:0000062E 61000196        	    74: 	bsr _KeybdGetStatus
00:00000632 7000            	    75: 	moveq #E_Ok,d0
00:00000634 4E75            	    76: 	rts
                            	    77: 
                            	    78: keybd_putchar:
00:00000636 61000502        	    79: 	bsr KeybdSendByte
00:0000063A 7000            	    80: 	moveq #E_Ok,d0
00:0000063C 4E75            	    81: 	rts
                            	    82: 
                            	    83: keybd_getchar:
00:0000063E 61000234        	    84: 	bsr GetKey
00:00000642 7000            	    85: 	moveq #E_Ok,d0
00:00000644 4E75            	    86: 	rts
                            	    87: 
                            	    88: keybd_putbuf:
                            	    89: keybd_getbuf:
                            	    90: keybd_set_inpos:
                            	    91: keybd_set_outpos:
00:00000646 700A            	    92: 	moveq #E_NotSupported,d0
00:00000648 4E75            	    93: 	rts
                            	    94: 
                            	    95: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	    96: ; Get ID - get the keyboards identifier code.
                            	    97: ;
                            	    98: ; Parameters: none
                            	    99: ; Returns: d = $AB83, $00 on fail
                            	   100: ; Modifies: d, KeybdID updated
                            	   101: ; Stack Space: 2 words
                            	   102: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   103: 
                            	   104: KeybdGetID:
00:0000064A 323C00F2        	   105: 	move.w	#$F2,d1
00:0000064E 610004EA        	   106: 	bsr			KeybdSendByte
00:00000652 610001E6        	   107: 	bsr			KeybdWaitTx
00:00000656 610001C0        	   108: 	bsr			KeybdRecvByte
00:0000065A 08010007        	   109: 	btst		#7,d1
00:0000065E 6624            	   110: 	bne			kgnotKbd
00:00000660 0C0100AB        	   111: 	cmpi.b	#$AB,d1
00:00000664 661E            	   112: 	bne			kgnotKbd
00:00000666 610001B0        	   113: 	bsr			KeybdRecvByte
00:0000066A 08010007        	   114: 	btst		#7,d1
00:0000066E 6614            	   115: 	bne			kgnotKbd
00:00000670 0C010083        	   116: 	cmpi.b	#$83,d1
00:00000674 660E            	   117: 	bne			kgnotKbd
00:00000676 223C0000AB83    	   118: 	move.l	#$AB83,d1
                            	   119: kgid1:
00:0000067C 33C100100018    	   120: 	move.w	d1,KeybdID
00:00000682 4E75            	   121: 	rts
                            	   122: kgnotKbd:
00:00000684 7200            	   123: 	moveq		#0,d1
00:00000686 60F4            	   124: 	bra			kgid1
                            	   125: 
                            	   126: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   127: ; Set the LEDs on the keyboard.
                            	   128: ;
                            	   129: ; Parameters:
                            	   130: ;		d1.b = LED state
                            	   131: ;	Modifies:
                            	   132: ;		none
                            	   133: ; Returns:
                            	   134: ;		none
                            	   135: ; Stack Space:
                            	   136: ;		1 long word
                            	   137: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   138: 
                            	   139: KeybdSetLED:
00:00000688 2F01            	   140: 	move.l	d1,-(a7)
00:0000068A 123C00ED        	   141: 	move.b	#$ED,d1
00:0000068E 610004AA        	   142: 	bsr			KeybdSendByte
00:00000692 610001A6        	   143: 	bsr			KeybdWaitTx
00:00000696 61000180        	   144: 	bsr			KeybdRecvByte
00:0000069A 4A01            	   145: 	tst.b		d1
00:0000069C 6B12            	   146: 	bmi			.0001
00:0000069E 0C0100FA        	   147: 	cmpi.b	#$FA,d1
00:000006A2 2217            	   148: 	move.l	(a7),d1
00:000006A4 61000494        	   149: 	bsr			KeybdSendByte
00:000006A8 61000190        	   150: 	bsr			KeybdWaitTx
00:000006AC 6100016A        	   151: 	bsr			KeybdRecvByte
                            	   152: .0001:
00:000006B0 221F            	   153: 	move.l	(a7)+,d1
00:000006B2 4E75            	   154: 	rts
                            	   155: 
                            	   156: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   157: ; Initialize the keyboard.
                            	   158: ;
                            	   159: ; Parameters:
                            	   160: ;		none
                            	   161: ;	Modifies:
                            	   162: ;		none
                            	   163: ; Returns:
                            	   164: ;		none
                            	   165: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   166: 
                            	   167: _KeybdInit:
                            	   168: KeybdInit:
                            	   169: ;	movem.l	d0/d1/d3/a1,-(a7)
00:000006B4 42390010000F    	   170: 	clr.b	_KeyState1		; records key up/down state
00:000006BA 423900100010    	   171: 	clr.b	_KeyState2		; records shift,ctrl,alt state
00:000006C0 4E75            	   172: 	rts
                            	   173: 
00:000006C2 6100049A        	   174: 	bsr			Wait300ms
00:000006C6 610000FE        	   175: 	bsr			_KeybdGetStatus	; wait for response from keyboard
00:000006CA 4A01            	   176: 	tst.b		d1
00:000006CC 6A10            	   177: 	bpl			.0001					; is input buffer full ? no, branch
00:000006CE 61000114        	   178: 	bsr	_KeybdGetScancode
00:000006D2 6100012E        	   179: 	bsr _KeybdClearIRQ
00:000006D6 0C0100AA        	   180: 	cmpi.b	#$AA,d1				; keyboard Okay
00:000006DA 67000098        	   181: 	beq			kbdi0005
                            	   182: .0001:
00:000006DE 760A            	   183: 	moveq		#10,d3
                            	   184: kbdi0002:
00:000006E0 61000460        	   185: 	bsr			Wait10ms
00:000006E4 4239FD0FFE01    	   186: 	clr.b		KEYBD+1				; clear receive register (write $00 to status reg)
00:000006EA 61001B6E        	   187: 	bsr net_delay
00:000006EE 72FF            	   188: 	moveq		#-1,d1				; send reset code to keyboard
00:000006F0 13C1FD0FFE01    	   189: 	move.b	d1,KEYBD+1		; write $FF to status reg to clear TX state
00:000006F6 61001B62        	   190: 	bsr net_delay
00:000006FA 6100043E        	   191: 	bsr			KeybdSendByte	; now write ($FF) to transmit register for reset
00:000006FE 6100013A        	   192: 	bsr			KeybdWaitTx		; wait until no longer busy
00:00000702 4A81            	   193: 	tst.l		d1
00:00000704 6B000088        	   194: 	bmi			kbdiXmitBusy
00:00000708 6100010E        	   195: 	bsr			KeybdRecvByte	; look for an ACK ($FA)
00:0000070C 0C0100FA        	   196: 	cmpi.b	#$FA,d1
00:00000710 6604            	   197: 	bne			.0001
00:00000712 61000104        	   198: 	bsr			KeybdRecvByte	; look for BAT completion code ($AA)
                            	   199: .0001:
00:00000716 0C0100FC        	   200: 	cmpi.b	#$FC,d1				; reset error ?
00:0000071A 672E            	   201: 	beq			kbdiTryAgain
00:0000071C 0C0100AA        	   202: 	cmpi.b	#$AA,d1				; reset complete okay ?
00:00000720 6628            	   203: 	bne			kbdiTryAgain
                            	   204: 
                            	   205: 	; After a reset, scan code set #2 should be active
                            	   206: .config:
00:00000722 323C00F0        	   207: 	move.w	#$F0,d1			; send scan code select
00:00000726 13C1FD0FFF00    	   208: 	move.b	d1,leds
00:0000072C 61001B2C        	   209: 	bsr net_delay
00:00000730 61000408        	   210: 	bsr			KeybdSendByte
00:00000734 61000104        	   211: 	bsr			KeybdWaitTx
00:00000738 4A81            	   212: 	tst.l		d1
00:0000073A 6B52            	   213: 	bmi			kbdiXmitBusy
00:0000073C 610000DA        	   214: 	bsr			KeybdRecvByte	; wait for response from keyboard
00:00000740 4A41            	   215: 	tst.w		d1
00:00000742 6B06            	   216: 	bmi			kbdiTryAgain
00:00000744 0C0100FA        	   217: 	cmpi.b	#$FA,d1				; ACK
00:00000748 670E            	   218: 	beq			kbdi0004
                            	   219: kbdiTryAgain:
00:0000074A 51CBFF94        	   220: 	dbra		d3,kbdi0002
                            	   221: .keybdErr:
00:0000074E 43FA004C        	   222: 	lea			msgBadKeybd,a1
00:00000752 61006F52        	   223: 	bsr			DisplayStringCRLF
00:00000756 6020            	   224: 	bra			ledxit
                            	   225: kbdi0004:
00:00000758 7202            	   226: 	moveq		#2,d1			; select scan code set #2
00:0000075A 610003DE        	   227: 	bsr			KeybdSendByte
00:0000075E 610000DA        	   228: 	bsr			KeybdWaitTx
00:00000762 4A81            	   229: 	tst.l		d1
00:00000764 6B28            	   230: 	bmi			kbdiXmitBusy
00:00000766 610000B0        	   231: 	bsr			KeybdRecvByte	; wait for response from keyboard
00:0000076A 4A41            	   232: 	tst.w		d1
00:0000076C 6BDC            	   233: 	bmi			kbdiTryAgain
00:0000076E 0C0100FA        	   234: 	cmpi.b	#$FA,d1
00:00000772 66D6            	   235: 	bne			kbdiTryAgain
                            	   236: kbdi0005:
00:00000774 6100FED4        	   237: 	bsr			KeybdGetID
                            	   238: ledxit:
00:00000778 7207            	   239: 	moveq		#$07,d1
00:0000077A 6100FF0C        	   240: 	bsr			KeybdSetLED
00:0000077E 610003DE        	   241: 	bsr			Wait300ms
00:00000782 7200            	   242: 	moveq		#$00,d1
00:00000784 6100FF02        	   243: 	bsr			KeybdSetLED
00:00000788 4CDF020B        	   244: 	movem.l	(a7)+,d0/d1/d3/a1
00:0000078C 4E75            	   245: 	rts
                            	   246: kbdiXmitBusy:
00:0000078E 43FA001B        	   247: 	lea			msgXmitBusy,a1
00:00000792 61006F12        	   248: 	bsr			DisplayStringCRLF
00:00000796 4CDF020B        	   249: 	movem.l	(a7)+,d0/d1/d3/a1
00:0000079A 4E75            	   250: 	rts
                            	   251: 	
                            	   252: msgBadKeybd:
00:0000079C 4B6579626F617264	   253: 	dc.b		"Keyboard error",0
00:000007A4 206572726F72
00:000007AA 00
                            	   254: msgXmitBusy:
00:000007AB 4B6579626F617264	   255: 	dc.b		"Keyboard transmitter stuck",0
00:000007B3 207472616E736D69
00:000007BB 7474657220737475
00:000007C3 636B
00:000007C5 00
                            	   256: 
                            	   257: 	even
                            	   258: _KeybdGetStatus:
00:000007C6 4E7A1FE0        	   259: 	movec coreno,d1
00:000007CA 0C010002        	   260: 	cmpi.b #2,d1
00:000007CE 660A            	   261: 	bne .0001
00:000007D0 7200            	   262: 	moveq	#0,d1
00:000007D2 1239FD0FFE01    	   263: 	move.b KEYBD+1,d1
00:000007D8 4E75            	   264: 	rts
                            	   265: .0001:
00:000007DA 7200            	   266: 	moveq #0,d1
00:000007DC 1239FD0FFE03    	   267: 	move.b KEYBD+3,d1
00:000007E2 4E75            	   268: 	rts
                            	   269: 
                            	   270: ; Get the scancode from the keyboard port
                            	   271: 
                            	   272: _KeybdGetScancode:
00:000007E4 4E7A1FE0        	   273: 	movec coreno,d1
00:000007E8 0C010002        	   274: 	cmpi.b #2,d1
00:000007EC 660A            	   275: 	bne .0001
00:000007EE 7200            	   276: 	moveq		#0,d1
00:000007F0 1239FD0FFE00    	   277: 	move.b	KEYBD,d1				; get the scan code
00:000007F6 4E75            	   278: 	rts
                            	   279: .0001:
00:000007F8 7200            	   280: 	moveq #0,d1
00:000007FA 1239FD0FFE02    	   281: 	move.b KEYBD+2,d1
00:00000800 4E75            	   282: 	rts
                            	   283: 
                            	   284: _KeybdClearIRQ:
00:00000802 2F01            	   285: 	move.l d1,-(a7)
00:00000804 4E7A1FE0        	   286: 	movec coreno,d1
00:00000808 0C010002        	   287: 	cmpi.b #2,d1
00:0000080C 6606            	   288: 	bne .0001
00:0000080E 4239FD0FFE01    	   289: 	move.b	#0,KEYBD+1			; clear receive register
                            	   290: .0001:
00:00000814 221F            	   291: 	move.l (a7)+,d1
00:00000816 4E75            	   292: 	rts
                            	   293: 
                            	   294: ; Recieve a byte from the keyboard, used after a command is sent to the
                            	   295: ; keyboard in order to wait for a response.
                            	   296: ;
                            	   297: KeybdRecvByte:
00:00000818 2F03            	   298: 	move.l	d3,-(a7)
00:0000081A 363C0064        	   299: 	move.w	#100,d3		; wait up to 1s
                            	   300: .0003:
00:0000081E 61A6            	   301: 	bsr			_KeybdGetStatus	; wait for response from keyboard
00:00000820 4A01            	   302: 	tst.b		d1
00:00000822 6B0E            	   303: 	bmi			.0004			; is input buffer full ? yes, branch
00:00000824 6100031C        	   304: 	bsr			Wait10ms	; wait a bit
00:00000828 51CBFFF4        	   305: 	dbra		d3,.0003	; go back and try again
00:0000082C 261F            	   306: 	move.l	(a7)+,d3
00:0000082E 72FF            	   307: 	moveq		#-1,d1		; return -1
00:00000830 4E75            	   308: 	rts
                            	   309: .0004:
00:00000832 61B0            	   310: 	bsr	_KeybdGetScancode
00:00000834 61CC            	   311: 	bsr _KeybdClearIRQ
00:00000836 261F            	   312: 	move.l	(a7)+,d3
00:00000838 4E75            	   313: 	rts
                            	   314: 
                            	   315: 
                            	   316: ; Wait until the keyboard transmit is complete
                            	   317: ; Returns -1 if timedout, 0 if transmit completed
                            	   318: ;
                            	   319: KeybdWaitTx:
00:0000083A 48E73000        	   320: 	movem.l	d2/d3,-(a7)
00:0000083E 7664            	   321: 	moveq		#100,d3		; wait a max of 1s
                            	   322: .0001:
00:00000840 6184            	   323: 	bsr	_KeybdGetStatus
00:00000842 08010006        	   324: 	btst #6,d1				; check for transmit complete bit
00:00000846 6610            	   325: 	bne	.0002					; branch if bit set
00:00000848 610002F8        	   326: 	bsr	Wait10ms			; delay a little bit
00:0000084C 51CBFFF2        	   327: 	dbra d3,.0001			; go back and try again
00:00000850 4CDF000C        	   328: 	movem.l	(a7)+,d2/d3
00:00000854 72FF            	   329: 	moveq	#-1,d1			; return -1
00:00000856 4E75            	   330: 	rts
                            	   331: .0002:
00:00000858 4CDF000C        	   332: 	movem.l	(a7)+,d2/d3
00:0000085C 7200            	   333: 	moveq	#0,d1		; return 0
00:0000085E 4E75            	   334: 	rts
                            	   335: 
                            	   336: ;------------------------------------------------------------------------------
                            	   337: ; d1.b 0=echo off, non-zero = echo on
                            	   338: ;------------------------------------------------------------------------------
                            	   339: 
                            	   340: SetKeyboardEcho:
00:00000860 13C10004000C    	   341: 	move.b	d1,KeybdEcho
00:00000866 4E75            	   342: 	rts
                            	   343: 
                            	   344: ;------------------------------------------------------------------------------
                            	   345: ; Get key pending status into d1.b
                            	   346: ;
                            	   347: ; Returns:
                            	   348: ;		d1.b = 1 if a key is available, otherwise zero.
                            	   349: ;------------------------------------------------------------------------------
                            	   350: 
                            	   351: CheckForKey:
00:00000868 7200            	   352: 	moveq.l	#0,d1					; clear high order bits
                            	   353: ;	move.b	KEYBD+1,d1		; get keyboard port status
                            	   354: ;	smi.b		d1						; set true/false
                            	   355: ;	andi.b	#1,d1					; return true (1) if key available, 0 otherwise
00:0000086A 4A3900100013    	   356: 	tst.b	_KeybdCnt
00:00000870 56C1            	   357: 	sne.b	d1
00:00000872 4E75            	   358: 	rts
                            	   359: 
                            	   360: ;------------------------------------------------------------------------------
                            	   361: ; GetKey
                            	   362: ; 	Get a character from the keyboard. 
                            	   363: ;
                            	   364: ; Modifies:
                            	   365: ;		d1
                            	   366: ; Returns:
                            	   367: ;		d1 = -1 if no key available or not in focus, otherwise key
                            	   368: ;------------------------------------------------------------------------------
                            	   369: 
                            	   370: GetKey:
00:00000874 2F00            	   371: 	move.l	d0,-(a7)					; push d0
00:00000876 123900100000    	   372: 	move.b	IOFocus,d1				; Check if the core has the IO focus
00:0000087C 4E7A0FE0        	   373: 	movec.l	coreno,d0
00:00000880 B200            	   374: 	cmp.b	d0,d1
00:00000882 6624            	   375: 	bne.s	.0004								; go return no key available, if not in focus
00:00000884 6138            	   376: 	bsr	KeybdGetCharNoWait		; get a character
00:00000886 4A81            	   377: 	tst.l	d1									; was a key available?
00:00000888 6B1E            	   378: 	bmi.s	.0004
00:0000088A 4A390004000C    	   379: 	tst.b	KeybdEcho						; is keyboard echo on ?
00:00000890 6712            	   380: 	beq.s	.0003								; no echo, just return the key
00:00000892 0C01000D        	   381: 	cmpi.b #CR,d1							; convert CR keystroke into CRLF
00:00000896 6606            	   382: 	bne.s	.0005
00:00000898 61006DDC        	   383: 	bsr	CRLF
00:0000089C 6006            	   384: 	bra.s	.0003
                            	   385: .0005:
00:0000089E 4EB90000963A    	   386: 	bsr	OutputChar
                            	   387: .0003:
00:000008A4 201F            	   388: 	move.l (a7)+,d0						; pop d0
00:000008A6 4E75            	   389: 	rts												; return key
                            	   390: ; Return -1 indicating no char was available
                            	   391: .0004:
00:000008A8 201F            	   392: 	move.l (a7)+,d0						; pop d0
00:000008AA 72FF            	   393: 	moveq	#-1,d1							; return no key available
00:000008AC 4E75            	   394: 	rts
                            	   395: 
                            	   396: ;------------------------------------------------------------------------------
                            	   397: ; Check for the cntrl-C keyboard sequence. Abort running routine and drop
                            	   398: ; back into the monitor.
                            	   399: ;------------------------------------------------------------------------------
                            	   400: 
                            	   401: CheckForCtrlC:
00:000008AE 2F01            	   402: 	move.l d1,-(a7)
00:000008B0 610C            	   403: 	bsr	KeybdGetCharNoWait
00:000008B2 0C010003        	   404: 	cmpi.b #CTRLC,d1
00:000008B6 670073CC        	   405: 	beq	Monitor
00:000008BA 221F            	   406: 	move.l (a7)+,d1
00:000008BC 4E75            	   407: 	rts
                            	   408: 
                            	   409: ;------------------------------------------------------------------------------
                            	   410: ;------------------------------------------------------------------------------
                            	   411: 
                            	   412: KeybdGetCharNoWait:
00:000008BE 42390004000D    	   413: 	clr.b	KeybdWaitFlag
00:000008C4 6008            	   414: 	bra	KeybdGetChar
                            	   415: 
                            	   416: KeybdGetCharWait:
00:000008C6 13FC00FF0004000D	   417: 	move.b #-1,KeybdWaitFlag
                            	   418: 
                            	   419: KeybdGetChar:
00:000008CE 48E7B080        	   420: 	movem.l	d0/d2/d3/a0,-(a7)
                            	   421: .0003:
00:000008D2 4E7A0FE0        	   422: 	movec	coreno,d0
00:000008D6 4840            	   423: 	swap d0
00:000008D8 7203            	   424: 	moveq	#KEYBD_SEMA,d1
00:000008DA 61001B24        	   425: 	bsr	LockSemaphore
00:000008DE 143900100013    	   426: 	move.b	_KeybdCnt,d2		; get count of buffered scan codes
00:000008E4 673E            	   427: 	beq.s		.0015						;
00:000008E6 143900100011    	   428: 	move.b	_KeybdHead,d2		; d2 = buffer head
00:000008EC 4882            	   429: 	ext.w		d2
00:000008EE 41F900100020    	   430: 	lea			_KeybdBuf,a0		; a0 = pointer to keyboard buffer
00:000008F4 7200            	   431: 	clr.l		d1
00:000008F6 12302000        	   432: 	move.b	(a0,d2.w),d1		; d1 = scan code from buffer
00:000008FA 5202            	   433: 	addi.b	#1,d2						; increment keyboard head index
00:000008FC 0202001F        	   434: 	andi.b	#31,d2					; and wrap around at buffer size
00:00000900 13C200100011    	   435: 	move.b	d2,_KeybdHead
00:00000906 533900100013    	   436: 	subi.b	#1,_KeybdCnt		; decrement count of scan codes in buffer
00:0000090C C342            	   437: 	exg			d1,d2						; save scancode value in d2
00:0000090E 4E7A0FE0        	   438: 	movec		coreno,d0
00:00000912 4840            	   439: 	swap		d0
00:00000914 7203            	   440: 	moveq		#KEYBD_SEMA,d1
00:00000916 61001B24        	   441: 	bsr			UnlockSemaphore
00:0000091A C541            	   442: 	exg			d2,d1						; restore scancode value
00:0000091C 602A            	   443: 	bra			.0001						; go process scan code
                            	   444: .0014:
00:0000091E 6100FEA6        	   445: 	bsr		_KeybdGetStatus		; check keyboard status for key available
00:00000922 6B1C            	   446: 	bmi		.0006							; yes, go process
                            	   447: .0015:
00:00000924 4E7A0FE0        	   448: 	movec		coreno,d0
00:00000928 4840            	   449: 	swap		d0
00:0000092A 7203            	   450: 	moveq		#KEYBD_SEMA,d1
00:0000092C 61001B0E        	   451: 	bsr			UnlockSemaphore
00:00000930 4A390004000D    	   452: 	tst.b		KeybdWaitFlag			; are we willing to wait for a key ?
00:00000936 6B9A            	   453: 	bmi			.0003							; yes, branch back
00:00000938 4CDF010D        	   454: 	movem.l	(a7)+,d0/d2/d3/a0
00:0000093C 72FF            	   455: 	moveq		#-1,d1						; flag no char available
00:0000093E 4E75            	   456: 	rts
                            	   457: .0006:
00:00000940 6100FEA2        	   458: 	bsr	_KeybdGetScancode
00:00000944 6100FEBC        	   459: 	bsr _KeybdClearIRQ
                            	   460: .0001:
00:00000948 33FC0001FD0FFF00	   461: 	move.w	#1,leds
00:00000950 B23C00F0        	   462: 	cmp.b	#SC_KEYUP,d1
00:00000954 670000C0        	   463: 	beq		.doKeyup
00:00000958 B23C00E0        	   464: 	cmp.b	#SC_EXTEND,d1
00:0000095C 670000C4        	   465: 	beq		.doExtend
00:00000960 B23C0014        	   466: 	cmp.b	#SC_CTRL,d1
00:00000964 670000C8        	   467: 	beq		.doCtrl
00:00000968 B23C0012        	   468: 	cmp.b	#SC_LSHIFT,d1
00:0000096C 6700012A        	   469: 	beq		.doShift
00:00000970 B23C0059        	   470: 	cmp.b	#SC_RSHIFT,d1
00:00000974 67000122        	   471: 	beq		.doShift
00:00000978 B23C0077        	   472: 	cmp.b	#SC_NUMLOCK,d1
00:0000097C 67000142        	   473: 	beq		.doNumLock
00:00000980 B23C0058        	   474: 	cmp.b	#SC_CAPSLOCK,d1
00:00000984 67000148        	   475: 	beq		.doCapsLock
00:00000988 B23C007E        	   476: 	cmp.b	#SC_SCROLLLOCK,d1
00:0000098C 6700014E        	   477: 	beq		.doScrollLock
00:00000990 B23C0011        	   478: 	cmp.b   #SC_ALT,d1
00:00000994 670000C0        	   479: 	beq     .doAlt
00:00000998 14390010000F    	   480: 	move.b	_KeyState1,d2			; check key up/down
00:0000099E 42390010000F    	   481: 	move.b	#0,_KeyState1			; clear keyup status
00:000009A4 4A02            	   482: 	tst.b	d2
00:000009A6 6600FF2A        	   483: 	bne	    .0003					; ignore key up
00:000009AA B23C000D        	   484: 	cmp.b   #SC_TAB,d1
00:000009AE 670000CE        	   485: 	beq     .doTab
                            	   486: .0013:
00:000009B2 143900100010    	   487: 	move.b	_KeyState2,d2
00:000009B8 6A1A            	   488: 	bpl		.0010					; is it extended code ?
00:000009BA C43C007F        	   489: 	and.b	#$7F,d2					; clear extended bit
00:000009BE 13C200100010    	   490: 	move.b	d2,_KeyState2
00:000009C4 42390010000F    	   491: 	move.b	#0,_KeyState1			; clear keyup
00:000009CA 41FA04E4        	   492: 	lea		_keybdExtendedCodes,a0
00:000009CE 12301000        	   493: 	move.b	(a0,d1.w),d1
00:000009D2 6034            	   494: 	bra		.0008
                            	   495: .0010:
00:000009D4 08020002        	   496: 	btst	#2,d2					; is it CTRL code ?
00:000009D8 670E            	   497: 	beq		.0009
00:000009DA C27C007F        	   498: 	and.w	#$7F,d1
00:000009DE 41FA0450        	   499: 	lea		_keybdControlCodes,a0
00:000009E2 12301000        	   500: 	move.b	(a0,d1.w),d1
00:000009E6 6020            	   501: 	bra		.0008
                            	   502: .0009:
00:000009E8 08020000        	   503: 	btst	#0,d2					; is it shift down ?
00:000009EC 670A            	   504: 	beq  	.0007
00:000009EE 41FA0340        	   505: 	lea		_shiftedScanCodes,a0
00:000009F2 12301000        	   506: 	move.b	(a0,d1.w),d1
00:000009F6 6010            	   507: 	bra		.0008
                            	   508: .0007:
00:000009F8 41FA0236        	   509: 	lea		_unshiftedScanCodes,a0
00:000009FC 12301000        	   510: 	move.b	(a0,d1.w),d1
00:00000A00 33FC0202FD0FFF00	   511: 	move.w	#$0202,leds
                            	   512: .0008:
00:00000A08 33FC0303FD0FFF00	   513: 	move.w	#$0303,leds
00:00000A10 4CDF010D        	   514: 	movem.l	(a7)+,d0/d2/d3/a0
00:00000A14 4E75            	   515: 	rts
                            	   516: .doKeyup:
00:00000A16 13FC00FF0010000F	   517: 	move.b	#-1,_KeyState1
00:00000A1E 6000FEB2        	   518: 	bra		.0003
                            	   519: .doExtend:
00:00000A22 0039008000100010	   520: 	or.b	#$80,_KeyState2
00:00000A2A 6000FEA6        	   521: 	bra		.0003
                            	   522: .doCtrl:
00:00000A2E 12390010000F    	   523: 	move.b	_KeyState1,d1
00:00000A34 42390010000F    	   524: 	clr.b	_KeyState1
00:00000A3A 4A01            	   525: 	tst.b	d1
00:00000A3C 6A0C            	   526: 	bpl.s	.0004
00:00000A3E 08B9000200100010	   527: 	bclr	#2,_KeyState2
00:00000A46 6000FE8A        	   528: 	bra		.0003
                            	   529: .0004:
00:00000A4A 08F9000200100010	   530: 	bset	#2,_KeyState2
00:00000A52 6000FE7E        	   531: 	bra		.0003
                            	   532: .doAlt:
00:00000A56 12390010000F    	   533: 	move.b	_KeyState1,d1
00:00000A5C 42390010000F    	   534: 	clr.b	_KeyState1
00:00000A62 4A01            	   535: 	tst.b	d1
00:00000A64 6A0C            	   536: 	bpl		.0011
00:00000A66 08B9000100100010	   537: 	bclr	#1,_KeyState2
00:00000A6E 6000FE62        	   538: 	bra		.0003
                            	   539: .0011:
00:00000A72 08F9000100100010	   540: 	bset	#1,_KeyState2
00:00000A7A 6000FE56        	   541: 	bra		.0003
                            	   542: .doTab:
00:00000A7E 2F01            	   543: 	move.l	d1,-(a7)
00:00000A80 123900100010    	   544:   move.b  _KeyState2,d1
00:00000A86 08010001        	   545:   btst	#1,d1                 ; is ALT down ?
00:00000A8A 6706            	   546:   beq     .0012
                            	   547: ;    	inc     _iof_switch
00:00000A8C 221F            	   548:   move.l	(a7)+,d1
00:00000A8E 6000FE42        	   549:   bra     .0003
                            	   550: .0012:
00:00000A92 221F            	   551:   move.l	(a7)+,d1
00:00000A94 6000FF1C        	   552:   bra     .0013
                            	   553: .doShift:
00:00000A98 12390010000F    	   554: 	move.b	_KeyState1,d1
00:00000A9E 42390010000F    	   555: 	clr.b	_KeyState1
00:00000AA4 4A01            	   556: 	tst.b	d1
00:00000AA6 6A0C            	   557: 	bpl.s	.0005
00:00000AA8 08B9000000100010	   558: 	bclr	#0,_KeyState2
00:00000AB0 6000FE20        	   559: 	bra		.0003
                            	   560: .0005:
00:00000AB4 08F9000000100010	   561: 	bset	#0,_KeyState2
00:00000ABC 6000FE14        	   562: 	bra		.0003
                            	   563: .doNumLock:
00:00000AC0 0879000400100010	   564: 	bchg	#4,_KeyState2
00:00000AC8 6120            	   565: 	bsr		KeybdSetLEDStatus
00:00000ACA 6000FE06        	   566: 	bra		.0003
                            	   567: .doCapsLock:
00:00000ACE 0879000500100010	   568: 	bchg	#5,_KeyState2
00:00000AD6 6112            	   569: 	bsr		KeybdSetLEDStatus
00:00000AD8 6000FDF8        	   570: 	bra		.0003
                            	   571: .doScrollLock:
00:00000ADC 0879000600100010	   572: 	bchg	#6,_KeyState2
00:00000AE4 6104            	   573: 	bsr		KeybdSetLEDStatus
00:00000AE6 6000FDEA        	   574: 	bra		.0003
                            	   575: 
                            	   576: KeybdSetLEDStatus:
00:00000AEA 48E73000        	   577: 	movem.l	d2/d3,-(a7)
00:00000AEE 42390010000E    	   578: 	clr.b		KeybdLEDs
00:00000AF4 0839000400100010	   579: 	btst		#4,_KeyState2
00:00000AFC 6708            	   580: 	beq.s		.0002
00:00000AFE 13FC00020010000E	   581: 	move.b	#2,KeybdLEDs
                            	   582: .0002:
00:00000B06 0839000500100010	   583: 	btst		#5,_KeyState2
00:00000B0E 6708            	   584: 	beq.s		.0003
00:00000B10 08F900020010000E	   585: 	bset		#2,KeybdLEDs
                            	   586: .0003:
00:00000B18 0839000600100010	   587: 	btst		#6,_KeyState2
00:00000B20 6708            	   588: 	beq.s		.0004
00:00000B22 08F900000010000E	   589: 	bset		#0,KeybdLEDs
                            	   590: .0004:
00:00000B2A 12390010000E    	   591: 	move.b	KeybdLEDs,d1
00:00000B30 6100FB56        	   592: 	bsr			KeybdSetLED
00:00000B34 4CDF000C        	   593: 	movem.l	(a7)+,d2/d3
00:00000B38 4E75            	   594: 	rts
                            	   595: 
                            	   596: KeybdSendByte:
00:00000B3A 13C1FD0FFE00    	   597: 	move.b d1,KEYBD
00:00000B40 4E75            	   598: 	rts
                            	   599: 	
                            	   600: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   601: ; Wait for 10 ms
                            	   602: ;
                            	   603: ; Parameters: none
                            	   604: ; Returns: none
                            	   605: ; Modifies: none
                            	   606: ; Stack Space: 2 long words
                            	   607: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   608: 
                            	   609: Wait10ms:
00:00000B42 48E7C000        	   610: 	movem.l	d0/d1,-(a7)
00:00000B46 4E7A0FF0        	   611: 	movec	tick,d0
00:00000B4A 068000061A80    	   612: 	addi.l #400000,d0			; 400,000 cycles at 40MHz
                            	   613: .0001:
00:00000B50 4E7A1FF0        	   614: 	movec	tick,d1
00:00000B54 B081            	   615: 	cmp.l	d1,d0
00:00000B56 62F8            	   616: 	bhi	.0001
00:00000B58 4CDF0003        	   617: 	movem.l	(a7)+,d0/d1
00:00000B5C 4E75            	   618: 	rts
                            	   619: 
                            	   620: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   621: ; Wait for 300 ms
                            	   622: ;
                            	   623: ; Parameters: none
                            	   624: ; Returns: none
                            	   625: ; Modifies: none
                            	   626: ; Stack Space: 2 long words
                            	   627: ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   628: 
                            	   629: Wait300ms:
00:00000B5E 48E7C000        	   630: 	movem.l	d0/d1,-(a7)
00:00000B62 4E7A0FF0        	   631: 	movec		tick,d0
00:00000B66 068000B71B00    	   632: 	addi.l	#12000000,d0			; 12,000,000 cycles at 40MHz
                            	   633: .0001:
00:00000B6C 4E7A1FF0        	   634: 	movec		tick,d1
00:00000B70 B081            	   635: 	cmp.l		d1,d0
00:00000B72 62F8            	   636: 	bhi			.0001
00:00000B74 4CDF0003        	   637: 	movem.l	(a7)+,d0/d1
00:00000B78 4E75            	   638: 	rts
                            	   639: 
                            	   640: ;--------------------------------------------------------------------------
                            	   641: ; Keyboard IRQ routine.
                            	   642: ; - only core 2 processes keyboard interrupts.
                            	   643: ; - the keyboard buffer is in shared global scratchpad space.
                            	   644: ;
                            	   645: ; Returns:
                            	   646: ; 	d1 = -1 if keyboard routine handled interrupt, otherwise positive.
                            	   647: ;--------------------------------------------------------------------------
                            	   648: 
                            	   649: KeybdIRQ:
00:00000B7A 46FC2600        	   650: 	move.w #$2600,sr					; disable lower interrupts
00:00000B7E 48E7C080        	   651: 	movem.l	d0/d1/a0,-(a7)
00:00000B82 46B9FD000000    	   652: 	eori.l #-1,$FD000000
00:00000B88 7200            	   653: 	moveq	#0,d1								; check if keyboard IRQ
00:00000B8A 1239FD0FFE01    	   654: 	move.b KEYBD+1,d1					; get status reg
00:00000B90 4A01            	   655: 	tst.b	d1
00:00000B92 6A000096        	   656: 	bpl	.0001									; branch if not keyboard
00:00000B96 4E7A0FE0        	   657: 	movec	coreno,d0
00:00000B9A 4840            	   658: 	swap d0
00:00000B9C 7203            	   659: 	moveq	#KEYBD_SEMA,d1
00:00000B9E 61001860        	   660: 	bsr LockSemaphore
00:00000BA2 1239FD0FFE00    	   661: 	move.b KEYBD,d1						; get scan code
00:00000BA8 4239FD0FFE01    	   662: 	clr.b KEYBD+1							; clear status register (clears IRQ AND scancode)
00:00000BAE 0839000100100010	   663: 	btst #1,_KeyState2				; Is Alt down?
00:00000BB6 6738            	   664: 	beq.s	.0003
00:00000BB8 0C01000D        	   665: 	cmpi.b #SC_TAB,d1					; is Alt-Tab?
00:00000BBC 6632            	   666: 	bne.s	.0003
00:00000BBE 4E7A0FF0        	   667: 	movec tick,d0
00:00000BC2 90B90001001C    	   668: 	sub.l _Keybd_tick,d0
00:00000BC8 B0BC0000000A    	   669: 	cmp.l #10,d0							; has it been 10 or more ticks?
                            	   670: ;	blo.s .0002
00:00000BCE 4E7A0FF0        	   671: 	movec tick,d0							; update tick of last ALT-Tab
00:00000BD2 23C00001001C    	   672: 	move.l d0,_Keybd_tick
00:00000BD8 61006F82        	   673: 	bsr	rotate_iofocus
00:00000BDC 423900100011    	   674: 	clr.b	_KeybdHead					; clear keyboard buffer
00:00000BE2 423900100012    	   675: 	clr.b	_KeybdTail
00:00000BE8 423900100013    	   676: 	clr.b	_KeybdCnt
00:00000BEE 602E            	   677: 	bra	.0002									; do not store Alt-Tab
                            	   678: .0003:
                            	   679: 	; Insert keyboard scan code into raw keyboard buffer
00:00000BF0 0C39002000100013	   680: 	cmpi.b #32,_KeybdCnt			; see if keyboard buffer full
00:00000BF8 6424            	   681: 	bhs.s	.0002
00:00000BFA 103900100012    	   682: 	move.b _KeybdTail,d0			; keyboard buffer not full, add to tail
00:00000C00 4880            	   683: 	ext.w	d0
00:00000C02 41F900100020    	   684: 	lea	_KeybdBuf,a0					; a0 = pointer to buffer
00:00000C08 11810000        	   685: 	move.b d1,(a0,d0.w)				; put scancode in buffer
00:00000C0C 5200            	   686: 	addi.b #1,d0							; increment tail index
00:00000C0E 0200001F        	   687: 	andi.b #31,d0							; wrap at buffer limit
00:00000C12 13C000100012    	   688: 	move.b d0,_KeybdTail			; update tail index
00:00000C18 523900100013    	   689: 	addi.b #1,_KeybdCnt				; increment buffer count
                            	   690: .0002:
00:00000C1E 4E7A0FE0        	   691: 	movec	coreno,d0
00:00000C22 4840            	   692: 	swap d0
00:00000C24 7203            	   693: 	moveq	#KEYBD_SEMA,d1
00:00000C26 61001814        	   694: 	bsr	UnlockSemaphore
                            	   695: .0001:
00:00000C2A 4CDF0103        	   696: 	movem.l	(a7)+,d0/d1/a0		; return
00:00000C2E 4E73            	   697: 	rte
                            	   698: 
                            	   699: ;--------------------------------------------------------------------------
                            	   700: ; PS2 scan codes to ascii conversion tables.
                            	   701: ;--------------------------------------------------------------------------
                            	   702: ;
                            	   703: _unshiftedScanCodes:
00:00000C30 2E              	   704: 	dc.b	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
00:00000C31 A9
00:00000C32 2E
00:00000C33 A5
00:00000C34 A3
00:00000C35 A1
00:00000C36 A2
00:00000C37 AC
00:00000C38 2E              	   705: 	dc.b	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
00:00000C39 AA
00:00000C3A A8
00:00000C3B A6
00:00000C3C A4
00:00000C3D 09
00:00000C3E 60
00:00000C3F 2E
00:00000C40 2E              	   706: 	dc.b	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
00:00000C41 2E
00:00000C42 2E
00:00000C43 2E
00:00000C44 2E
00:00000C45 71
00:00000C46 31
00:00000C47 2E
00:00000C48 2E              	   707: 	dc.b	$2e,$2e,$7a,$73,$61,$77,$32,$2e
00:00000C49 2E
00:00000C4A 7A
00:00000C4B 73
00:00000C4C 61
00:00000C4D 77
00:00000C4E 32
00:00000C4F 2E
00:00000C50 2E              	   708: 	dc.b	$2e,$63,$78,$64,$65,$34,$33,$2e
00:00000C51 63
00:00000C52 78
00:00000C53 64
00:00000C54 65
00:00000C55 34
00:00000C56 33
00:00000C57 2E
00:00000C58 2E              	   709: 	dc.b	$2e,$20,$76,$66,$74,$72,$35,$2e
00:00000C59 20
00:00000C5A 76
00:00000C5B 66
00:00000C5C 74
00:00000C5D 72
00:00000C5E 35
00:00000C5F 2E
00:00000C60 2E              	   710: 	dc.b	$2e,$6e,$62,$68,$67,$79,$36,$2e
00:00000C61 6E
00:00000C62 62
00:00000C63 68
00:00000C64 67
00:00000C65 79
00:00000C66 36
00:00000C67 2E
00:00000C68 2E              	   711: 	dc.b	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
00:00000C69 2E
00:00000C6A 6D
00:00000C6B 6A
00:00000C6C 75
00:00000C6D 37
00:00000C6E 38
00:00000C6F 2E
00:00000C70 2E              	   712: 	dc.b	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
00:00000C71 2C
00:00000C72 6B
00:00000C73 69
00:00000C74 6F
00:00000C75 30
00:00000C76 39
00:00000C77 2E
00:00000C78 2E              	   713: 	dc.b	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
00:00000C79 2E
00:00000C7A 2F
00:00000C7B 6C
00:00000C7C 3B
00:00000C7D 70
00:00000C7E 2D
00:00000C7F 2E
00:00000C80 2E              	   714: 	dc.b	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
00:00000C81 2E
00:00000C82 27
00:00000C83 2E
00:00000C84 5B
00:00000C85 3D
00:00000C86 2E
00:00000C87 2E
00:00000C88 AD              	   715: 	dc.b	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
00:00000C89 2E
00:00000C8A 0D
00:00000C8B 5D
00:00000C8C 2E
00:00000C8D 5C
00:00000C8E 2E
00:00000C8F 2E
00:00000C90 2E              	   716: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:00000C91 2E
00:00000C92 2E
00:00000C93 2E
00:00000C94 2E
00:00000C95 2E
00:00000C96 08
00:00000C97 2E
00:00000C98 2E              	   717: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
00:00000C99 95
00:00000C9A 2E
00:00000C9B 93
00:00000C9C 94
00:00000C9D 2E
00:00000C9E 2E
00:00000C9F 2E
00:00000CA0 98              	   718: 	dc.b	$98,$7f,$92,$2e,$91,$90,$1b,$af
00:00000CA1 7F
00:00000CA2 92
00:00000CA3 2E
00:00000CA4 91
00:00000CA5 90
00:00000CA6 1B
00:00000CA7 AF
00:00000CA8 AB              	   719: 	dc.b	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
00:00000CA9 2E
00:00000CAA 97
00:00000CAB 2E
00:00000CAC 2E
00:00000CAD 96
00:00000CAE AE
00:00000CAF 2E
                            	   720: 
00:00000CB0 2E              	   721: 	dc.b	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
00:00000CB1 2E
00:00000CB2 2E
00:00000CB3 A7
00:00000CB4 2E
00:00000CB5 2E
00:00000CB6 2E
00:00000CB7 2E
00:00000CB8 2E              	   722: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CB9 2E
00:00000CBA 2E
00:00000CBB 2E
00:00000CBC 2E
00:00000CBD 2E
00:00000CBE 2E
00:00000CBF 2E
00:00000CC0 2E              	   723: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CC1 2E
00:00000CC2 2E
00:00000CC3 2E
00:00000CC4 2E
00:00000CC5 2E
00:00000CC6 2E
00:00000CC7 2E
00:00000CC8 2E              	   724: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CC9 2E
00:00000CCA 2E
00:00000CCB 2E
00:00000CCC 2E
00:00000CCD 2E
00:00000CCE 2E
00:00000CCF 2E
00:00000CD0 2E              	   725: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CD1 2E
00:00000CD2 2E
00:00000CD3 2E
00:00000CD4 2E
00:00000CD5 2E
00:00000CD6 2E
00:00000CD7 2E
00:00000CD8 2E              	   726: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CD9 2E
00:00000CDA 2E
00:00000CDB 2E
00:00000CDC 2E
00:00000CDD 2E
00:00000CDE 2E
00:00000CDF 2E
00:00000CE0 2E              	   727: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CE1 2E
00:00000CE2 2E
00:00000CE3 2E
00:00000CE4 2E
00:00000CE5 2E
00:00000CE6 2E
00:00000CE7 2E
00:00000CE8 2E              	   728: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CE9 2E
00:00000CEA 2E
00:00000CEB 2E
00:00000CEC 2E
00:00000CED 2E
00:00000CEE 2E
00:00000CEF 2E
00:00000CF0 2E              	   729: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CF1 2E
00:00000CF2 2E
00:00000CF3 2E
00:00000CF4 2E
00:00000CF5 2E
00:00000CF6 2E
00:00000CF7 2E
00:00000CF8 2E              	   730: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000CF9 2E
00:00000CFA 2E
00:00000CFB 2E
00:00000CFC 2E
00:00000CFD 2E
00:00000CFE 2E
00:00000CFF 2E
00:00000D00 2E              	   731: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D01 2E
00:00000D02 2E
00:00000D03 2E
00:00000D04 2E
00:00000D05 2E
00:00000D06 2E
00:00000D07 2E
00:00000D08 2E              	   732: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D09 2E
00:00000D0A 2E
00:00000D0B 2E
00:00000D0C 2E
00:00000D0D 2E
00:00000D0E 2E
00:00000D0F 2E
00:00000D10 2E              	   733: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D11 2E
00:00000D12 2E
00:00000D13 2E
00:00000D14 2E
00:00000D15 2E
00:00000D16 2E
00:00000D17 2E
00:00000D18 2E              	   734: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D19 2E
00:00000D1A 2E
00:00000D1B 2E
00:00000D1C 2E
00:00000D1D 2E
00:00000D1E 2E
00:00000D1F 2E
00:00000D20 2E              	   735: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D21 2E
00:00000D22 2E
00:00000D23 2E
00:00000D24 2E
00:00000D25 2E
00:00000D26 2E
00:00000D27 2E
00:00000D28 2E              	   736: 	dc.b	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
00:00000D29 2E
00:00000D2A FA
00:00000D2B 2E
00:00000D2C 2E
00:00000D2D 2E
00:00000D2E 2E
00:00000D2F 2E
                            	   737: 
                            	   738: _shiftedScanCodes:
00:00000D30 2E              	   739: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D31 2E
00:00000D32 2E
00:00000D33 2E
00:00000D34 2E
00:00000D35 2E
00:00000D36 2E
00:00000D37 2E
00:00000D38 2E              	   740: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
00:00000D39 2E
00:00000D3A 2E
00:00000D3B 2E
00:00000D3C 2E
00:00000D3D 09
00:00000D3E 7E
00:00000D3F 2E
00:00000D40 2E              	   741: 	dc.b	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
00:00000D41 2E
00:00000D42 2E
00:00000D43 2E
00:00000D44 2E
00:00000D45 51
00:00000D46 21
00:00000D47 2E
00:00000D48 2E              	   742: 	dc.b	$2e,$2e,$5a,$53,$41,$57,$40,$2e
00:00000D49 2E
00:00000D4A 5A
00:00000D4B 53
00:00000D4C 41
00:00000D4D 57
00:00000D4E 40
00:00000D4F 2E
00:00000D50 2E              	   743: 	dc.b	$2e,$43,$58,$44,$45,$24,$23,$2e
00:00000D51 43
00:00000D52 58
00:00000D53 44
00:00000D54 45
00:00000D55 24
00:00000D56 23
00:00000D57 2E
00:00000D58 2E              	   744: 	dc.b	$2e,$20,$56,$46,$54,$52,$25,$2e
00:00000D59 20
00:00000D5A 56
00:00000D5B 46
00:00000D5C 54
00:00000D5D 52
00:00000D5E 25
00:00000D5F 2E
00:00000D60 2E              	   745: 	dc.b	$2e,$4e,$42,$48,$47,$59,$5e,$2e
00:00000D61 4E
00:00000D62 42
00:00000D63 48
00:00000D64 47
00:00000D65 59
00:00000D66 5E
00:00000D67 2E
00:00000D68 2E              	   746: 	dc.b	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
00:00000D69 2E
00:00000D6A 4D
00:00000D6B 4A
00:00000D6C 55
00:00000D6D 26
00:00000D6E 2A
00:00000D6F 2E
00:00000D70 2E              	   747: 	dc.b	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
00:00000D71 3C
00:00000D72 4B
00:00000D73 49
00:00000D74 4F
00:00000D75 29
00:00000D76 28
00:00000D77 2E
00:00000D78 2E              	   748: 	dc.b	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
00:00000D79 3E
00:00000D7A 3F
00:00000D7B 4C
00:00000D7C 3A
00:00000D7D 50
00:00000D7E 5F
00:00000D7F 2E
00:00000D80 2E              	   749: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
00:00000D81 2E
00:00000D82 22
00:00000D83 2E
00:00000D84 7B
00:00000D85 2B
00:00000D86 2E
00:00000D87 2E
00:00000D88 2E              	   750: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
00:00000D89 2E
00:00000D8A 0D
00:00000D8B 7D
00:00000D8C 2E
00:00000D8D 7C
00:00000D8E 2E
00:00000D8F 2E
00:00000D90 2E              	   751: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:00000D91 2E
00:00000D92 2E
00:00000D93 2E
00:00000D94 2E
00:00000D95 2E
00:00000D96 08
00:00000D97 2E
00:00000D98 2E              	   752: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000D99 2E
00:00000D9A 2E
00:00000D9B 2E
00:00000D9C 2E
00:00000D9D 2E
00:00000D9E 2E
00:00000D9F 2E
00:00000DA0 2E              	   753: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
00:00000DA1 7F
00:00000DA2 2E
00:00000DA3 2E
00:00000DA4 2E
00:00000DA5 2E
00:00000DA6 1B
00:00000DA7 2E
00:00000DA8 2E              	   754: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DA9 2E
00:00000DAA 2E
00:00000DAB 2E
00:00000DAC 2E
00:00000DAD 2E
00:00000DAE 2E
00:00000DAF 2E
                            	   755: 
00:00000DB0 2E              	   756: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DB1 2E
00:00000DB2 2E
00:00000DB3 2E
00:00000DB4 2E
00:00000DB5 2E
00:00000DB6 2E
00:00000DB7 2E
00:00000DB8 2E              	   757: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DB9 2E
00:00000DBA 2E
00:00000DBB 2E
00:00000DBC 2E
00:00000DBD 2E
00:00000DBE 2E
00:00000DBF 2E
00:00000DC0 2E              	   758: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DC1 2E
00:00000DC2 2E
00:00000DC3 2E
00:00000DC4 2E
00:00000DC5 2E
00:00000DC6 2E
00:00000DC7 2E
00:00000DC8 2E              	   759: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DC9 2E
00:00000DCA 2E
00:00000DCB 2E
00:00000DCC 2E
00:00000DCD 2E
00:00000DCE 2E
00:00000DCF 2E
00:00000DD0 2E              	   760: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DD1 2E
00:00000DD2 2E
00:00000DD3 2E
00:00000DD4 2E
00:00000DD5 2E
00:00000DD6 2E
00:00000DD7 2E
00:00000DD8 2E              	   761: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DD9 2E
00:00000DDA 2E
00:00000DDB 2E
00:00000DDC 2E
00:00000DDD 2E
00:00000DDE 2E
00:00000DDF 2E
00:00000DE0 2E              	   762: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DE1 2E
00:00000DE2 2E
00:00000DE3 2E
00:00000DE4 2E
00:00000DE5 2E
00:00000DE6 2E
00:00000DE7 2E
00:00000DE8 2E              	   763: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DE9 2E
00:00000DEA 2E
00:00000DEB 2E
00:00000DEC 2E
00:00000DED 2E
00:00000DEE 2E
00:00000DEF 2E
00:00000DF0 2E              	   764: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DF1 2E
00:00000DF2 2E
00:00000DF3 2E
00:00000DF4 2E
00:00000DF5 2E
00:00000DF6 2E
00:00000DF7 2E
00:00000DF8 2E              	   765: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000DF9 2E
00:00000DFA 2E
00:00000DFB 2E
00:00000DFC 2E
00:00000DFD 2E
00:00000DFE 2E
00:00000DFF 2E
00:00000E00 2E              	   766: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E01 2E
00:00000E02 2E
00:00000E03 2E
00:00000E04 2E
00:00000E05 2E
00:00000E06 2E
00:00000E07 2E
00:00000E08 2E              	   767: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E09 2E
00:00000E0A 2E
00:00000E0B 2E
00:00000E0C 2E
00:00000E0D 2E
00:00000E0E 2E
00:00000E0F 2E
00:00000E10 2E              	   768: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E11 2E
00:00000E12 2E
00:00000E13 2E
00:00000E14 2E
00:00000E15 2E
00:00000E16 2E
00:00000E17 2E
00:00000E18 2E              	   769: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E19 2E
00:00000E1A 2E
00:00000E1B 2E
00:00000E1C 2E
00:00000E1D 2E
00:00000E1E 2E
00:00000E1F 2E
00:00000E20 2E              	   770: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E21 2E
00:00000E22 2E
00:00000E23 2E
00:00000E24 2E
00:00000E25 2E
00:00000E26 2E
00:00000E27 2E
00:00000E28 2E              	   771: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E29 2E
00:00000E2A 2E
00:00000E2B 2E
00:00000E2C 2E
00:00000E2D 2E
00:00000E2E 2E
00:00000E2F 2E
                            	   772: 
                            	   773: ; control
                            	   774: _keybdControlCodes:
00:00000E30 2E              	   775: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E31 2E
00:00000E32 2E
00:00000E33 2E
00:00000E34 2E
00:00000E35 2E
00:00000E36 2E
00:00000E37 2E
00:00000E38 2E              	   776: 	dc.b	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
00:00000E39 2E
00:00000E3A 2E
00:00000E3B 2E
00:00000E3C 2E
00:00000E3D 09
00:00000E3E 7E
00:00000E3F 2E
00:00000E40 2E              	   777: 	dc.b	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
00:00000E41 2E
00:00000E42 2E
00:00000E43 2E
00:00000E44 2E
00:00000E45 11
00:00000E46 21
00:00000E47 2E
00:00000E48 2E              	   778: 	dc.b	$2e,$2e,$1a,$13,$01,$17,$40,$2e
00:00000E49 2E
00:00000E4A 1A
00:00000E4B 13
00:00000E4C 01
00:00000E4D 17
00:00000E4E 40
00:00000E4F 2E
00:00000E50 2E              	   779: 	dc.b	$2e,$03,$18,$04,$05,$24,$23,$2e
00:00000E51 03
00:00000E52 18
00:00000E53 04
00:00000E54 05
00:00000E55 24
00:00000E56 23
00:00000E57 2E
00:00000E58 2E              	   780: 	dc.b	$2e,$20,$16,$06,$14,$12,$25,$2e
00:00000E59 20
00:00000E5A 16
00:00000E5B 06
00:00000E5C 14
00:00000E5D 12
00:00000E5E 25
00:00000E5F 2E
00:00000E60 2E              	   781: 	dc.b	$2e,$0e,$02,$08,$07,$19,$5e,$2e
00:00000E61 0E
00:00000E62 02
00:00000E63 08
00:00000E64 07
00:00000E65 19
00:00000E66 5E
00:00000E67 2E
00:00000E68 2E              	   782: 	dc.b	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
00:00000E69 2E
00:00000E6A 0D
00:00000E6B 0A
00:00000E6C 15
00:00000E6D 26
00:00000E6E 2A
00:00000E6F 2E
00:00000E70 2E              	   783: 	dc.b	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
00:00000E71 3C
00:00000E72 0B
00:00000E73 09
00:00000E74 0F
00:00000E75 29
00:00000E76 28
00:00000E77 2E
00:00000E78 2E              	   784: 	dc.b	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
00:00000E79 3E
00:00000E7A 3F
00:00000E7B 0C
00:00000E7C 3A
00:00000E7D 10
00:00000E7E 5F
00:00000E7F 2E
00:00000E80 2E              	   785: 	dc.b	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
00:00000E81 2E
00:00000E82 22
00:00000E83 2E
00:00000E84 7B
00:00000E85 2B
00:00000E86 2E
00:00000E87 2E
00:00000E88 2E              	   786: 	dc.b	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
00:00000E89 2E
00:00000E8A 0D
00:00000E8B 7D
00:00000E8C 2E
00:00000E8D 7C
00:00000E8E 2E
00:00000E8F 2E
00:00000E90 2E              	   787: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
00:00000E91 2E
00:00000E92 2E
00:00000E93 2E
00:00000E94 2E
00:00000E95 2E
00:00000E96 08
00:00000E97 2E
00:00000E98 2E              	   788: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000E99 2E
00:00000E9A 2E
00:00000E9B 2E
00:00000E9C 2E
00:00000E9D 2E
00:00000E9E 2E
00:00000E9F 2E
00:00000EA0 2E              	   789: 	dc.b	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
00:00000EA1 7F
00:00000EA2 2E
00:00000EA3 2E
00:00000EA4 2E
00:00000EA5 2E
00:00000EA6 1B
00:00000EA7 2E
00:00000EA8 2E              	   790: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EA9 2E
00:00000EAA 2E
00:00000EAB 2E
00:00000EAC 2E
00:00000EAD 2E
00:00000EAE 2E
00:00000EAF 2E
                            	   791: 
                            	   792: _keybdExtendedCodes:
00:00000EB0 2E              	   793: 	dc.b	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
00:00000EB1 2E
00:00000EB2 2E
00:00000EB3 2E
00:00000EB4 A3
00:00000EB5 A1
00:00000EB6 A2
00:00000EB7 2E
00:00000EB8 2E              	   794: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EB9 2E
00:00000EBA 2E
00:00000EBB 2E
00:00000EBC 2E
00:00000EBD 2E
00:00000EBE 2E
00:00000EBF 2E
00:00000EC0 2E              	   795: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EC1 2E
00:00000EC2 2E
00:00000EC3 2E
00:00000EC4 2E
00:00000EC5 2E
00:00000EC6 2E
00:00000EC7 2E
00:00000EC8 2E              	   796: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EC9 2E
00:00000ECA 2E
00:00000ECB 2E
00:00000ECC 2E
00:00000ECD 2E
00:00000ECE 2E
00:00000ECF 2E
00:00000ED0 2E              	   797: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000ED1 2E
00:00000ED2 2E
00:00000ED3 2E
00:00000ED4 2E
00:00000ED5 2E
00:00000ED6 2E
00:00000ED7 2E
00:00000ED8 2E              	   798: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000ED9 2E
00:00000EDA 2E
00:00000EDB 2E
00:00000EDC 2E
00:00000EDD 2E
00:00000EDE 2E
00:00000EDF 2E
00:00000EE0 2E              	   799: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EE1 2E
00:00000EE2 2E
00:00000EE3 2E
00:00000EE4 2E
00:00000EE5 2E
00:00000EE6 2E
00:00000EE7 2E
00:00000EE8 2E              	   800: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EE9 2E
00:00000EEA 2E
00:00000EEB 2E
00:00000EEC 2E
00:00000EED 2E
00:00000EEE 2E
00:00000EEF 2E
00:00000EF0 2E              	   801: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EF1 2E
00:00000EF2 2E
00:00000EF3 2E
00:00000EF4 2E
00:00000EF5 2E
00:00000EF6 2E
00:00000EF7 2E
00:00000EF8 2E              	   802: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000EF9 2E
00:00000EFA 2E
00:00000EFB 2E
00:00000EFC 2E
00:00000EFD 2E
00:00000EFE 2E
00:00000EFF 2E
00:00000F00 2E              	   803: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000F01 2E
00:00000F02 2E
00:00000F03 2E
00:00000F04 2E
00:00000F05 2E
00:00000F06 2E
00:00000F07 2E
00:00000F08 2E              	   804: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000F09 2E
00:00000F0A 2E
00:00000F0B 2E
00:00000F0C 2E
00:00000F0D 2E
00:00000F0E 2E
00:00000F0F 2E
00:00000F10 2E              	   805: 	dc.b	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
00:00000F11 2E
00:00000F12 2E
00:00000F13 2E
00:00000F14 2E
00:00000F15 2E
00:00000F16 2E
00:00000F17 2E
00:00000F18 2E              	   806: 	dc.b	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
00:00000F19 95
00:00000F1A 2E
00:00000F1B 93
00:00000F1C 94
00:00000F1D 2E
00:00000F1E 2E
00:00000F1F 2E
00:00000F20 98              	   807: 	dc.b	$98,$99,$92,$2e,$91,$90,$2e,$2e
00:00000F21 99
00:00000F22 92
00:00000F23 2E
00:00000F24 91
00:00000F25 90
00:00000F26 2E
00:00000F27 2E
00:00000F28 2E              	   808: 	dc.b	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
00:00000F29 2E
00:00000F2A 97
00:00000F2B 2E
00:00000F2C 2E
00:00000F2D 96
00:00000F2E 2E
00:00000F2F 2E
                            	   809: 
                            	   810: 

Source: "boot.x68"
                            	   574: 	include "textvid.x68"

Source: "textvid.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;------------------------------------------------------------------------------
                            	    38: ;------------------------------------------------------------------------------
                            	    39: ; Setup the text video device
                            	    40: ; stdout = text screen controller
                            	    41: ;------------------------------------------------------------------------------
                            	    42: ;------------------------------------------------------------------------------
                            	    43: 
                            	    44: TBLE macro arg1
                            	    45: 	dc.l (\1)
                            	    46: endm
                            	    47: 
                            	    48: 	code
                            	    49: 	even
                            	    50: 
                            	    51: 	align 2
                            	    52: TEXTVID_CMDTBL:
                            	    53: 	TBLE textvid_init					; 0
00:00000F30 00001010        	     1M 	dc.l (textvid_init)
                            	    54: 	TBLE textvid_stat
00:00000F34 000010B8        	     1M 	dc.l (textvid_stat)
                            	    55: 	TBLE textvid_putchar
00:00000F38 00001254        	     1M 	dc.l (textvid_putchar)
                            	    56: 	TBLE textvid_putbuf
00:00000F3C 000010C4        	     1M 	dc.l (textvid_putbuf)
                            	    57: 	TBLE textvid_getchar
00:00000F40 000010BC        	     1M 	dc.l (textvid_getchar)
                            	    58: 	TBLE textvid_getbuf
00:00000F44 000010C4        	     1M 	dc.l (textvid_getbuf)
                            	    59: 	TBLE textvid_set_inpos
00:00000F48 000010DE        	     1M 	dc.l (textvid_set_inpos)
                            	    60: 	TBLE textvid_set_outpos
00:00000F4C 000010F4        	     1M 	dc.l (textvid_set_outpos)
                            	    61: 	TBLE textvid_stub
00:00000F50 000010C4        	     1M 	dc.l (textvid_stub)
                            	    62: 	TBLE textvid_stub
00:00000F54 000010C4        	     1M 	dc.l (textvid_stub)
                            	    63: 	TBLE textvid_stub				; 10
00:00000F58 000010C4        	     1M 	dc.l (textvid_stub)
                            	    64: 	TBLE textvid_stub
00:00000F5C 000010C4        	     1M 	dc.l (textvid_stub)
                            	    65: 	TBLE textvid_clear
00:00000F60 000011A0        	     1M 	dc.l (textvid_clear)
                            	    66: 	TBLE textvid_stub
00:00000F64 000010C4        	     1M 	dc.l (textvid_stub)
                            	    67: 	TBLE textvid_stub
00:00000F68 000010C4        	     1M 	dc.l (textvid_stub)
                            	    68: 	TBLE textvid_stub
00:00000F6C 000010C4        	     1M 	dc.l (textvid_stub)
                            	    69: 	TBLE textvid_getbuf1
00:00000F70 00001156        	     1M 	dc.l (textvid_getbuf1)
                            	    70: 	TBLE textvid_stub
00:00000F74 000010C4        	     1M 	dc.l (textvid_stub)
                            	    71: 	TBLE textvid_stub
00:00000F78 000010C4        	     1M 	dc.l (textvid_stub)
                            	    72: 	TBLE textvid_set_unit
00:00000F7C 00001166        	     1M 	dc.l (textvid_set_unit)
                            	    73: 	TBLE textvid_get_dimen	; 20
00:00000F80 00001170        	     1M 	dc.l (textvid_get_dimen)
                            	    74: 	TBLE textvid_get_color
00:00000F84 00001146        	     1M 	dc.l (textvid_get_color)
                            	    75: 	TBLE textvid_get_inpos
00:00000F88 000010C8        	     1M 	dc.l (textvid_get_inpos)
                            	    76: 	TBLE textvid_get_outpos
00:00000F8C 0000110A        	     1M 	dc.l (textvid_get_outpos)
                            	    77: 	TBLE textvid_get_outptr
00:00000F90 00001120        	     1M 	dc.l (textvid_get_outptr)
                            	    78: 
                            	    79: 	code
                            	    80: 	even
                            	    81: textvid_cmdproc:
00:00000F94 0C060019        	    82: 	cmpi.b #25,d6
00:00000F98 641A            	    83: 	bhs.s .0001
00:00000F9A 48E70280        	    84: 	movem.l d6/a0,-(a7)
00:00000F9E 4886            	    85: 	ext.w d6
00:00000FA0 48C6            	    86: 	ext.l d6
00:00000FA2 E54E            	    87: 	lsl.w #2,d6
00:00000FA4 41FAFF8A        	    88: 	lea TEXTVID_CMDTBL,a0
00:00000FA8 20706000        	    89: 	move.l (a0,d6.w),a0
00:00000FAC 4E90            	    90: 	jsr (a0)
00:00000FAE 4CDF0140        	    91: 	movem.l (a7)+,d6/a0
00:00000FB2 4E75            	    92: 	rts
                            	    93: .0001:
00:00000FB4 7002            	    94: 	moveq #E_Func,d0
00:00000FB6 4E75            	    95: 	rts
                            	    96: 
                            	    97: setup_textvid:
00:00000FB8 48E780C0        	    98: 	movem.l d0/a0/a1,-(a7)
00:00000FBC 7020            	    99: 	moveq #32,d0
00:00000FBE 41F900040B08    	   100: 	lea.l textvid_dcb,a0
                            	   101: .0001:
00:00000FC4 4298            	   102: 	clr.l (a0)+
00:00000FC6 51C8FFFC        	   103: 	dbra d0,.0001
00:00000FCA 23FC444342200004	   104: 	move.l #$44434220,textvid_dcb+DCB_MAGIC				; 'DCB '
00:00000FD2 0B08
00:00000FD4 23FC544558540004	   105: 	move.l #$54455854,textvid_dcb+DCB_NAME				; 'TEXTVID'
00:00000FDC 0B0C
00:00000FDE 23FC564944000004	   106: 	move.l #$56494400,textvid_dcb+DCB_NAME+4			;
00:00000FE6 0B10
00:00000FE8 23FC00000F940004	   107: 	move.l #textvid_cmdproc,textvid_dcb+DCB_CMDPROC
00:00000FF0 0B20
00:00000FF2 611C            	   108: 	bsr textvid_init
00:00000FF4 610014A0        	   109: 	jsr Delay3s
00:00000FF8 610001A6        	   110: 	bsr textvid_clear
00:00000FFC 43F900040B08    	   111: 	lea.l textvid_dcb+DCB_MAGIC,a1
00:00001002 6100668C        	   112: 	jsr DisplayString
00:00001006 6100666E        	   113: 	jsr CRLF
00:0000100A 4CDF0301        	   114: 	movem.l (a7)+,d0/a0/a1
00:0000100E 4E75            	   115: 	rts
                            	   116: 
                            	   117: textvid_init:
00:00001010 2F00            	   118: 	move.l d0,-(a7)
                            	   119: 	if (SCREEN_FORMAT==1)
00:00001012 23FC000000FF0004	   120: 		move.l #$0000ff,fgColor		; set foreground / background color (white)
00:0000101A 0084
00:0000101C 23FC000000020004	   121: 		move.l #$000002,bkColor		; medium blue
00:00001024 0088
00:00001026 23FC000000FF0004	   122: 		move.l #$0000ff,textvid_dcb+DCB_FGCOLOR
00:0000102E 0B6C
00:00001030 23FC000000020004	   123: 		move.l #$000002,textvid_dcb+DCB_BKCOLOR		; medium blue
00:00001038 0B68
                            	   124: 	else
                            	   125: 		move.l #$1fffff,fgColor		; set foreground / background color (white)
                            	   126: 		move.l #$00003f,bkColor		; medium blue
                            	   127: 		move.l #$1fffff,textvid_dcb+DCB_FGCOLOR		; set foreground / background color (white)
                            	   128: 		move.l #$00003f,textvid_dcb+DCB_BKCOLOR		; medium blue
                            	   129: 	endif
00:0000103A 4E7A0FE0        	   130: 	movec.l	coreno,d0					; get core number (2 to 9)
00:0000103E 5500            	   131: 	subi.b #2,d0							; adjust (0 to 7)
                            	   132: 	if (SCREEN_FORMAT==1)
00:00001040 C0FC2000        	   133: 		mulu #8192,d0						; compute screen location
                            	   134: 	else
                            	   135: 		mulu #16384,d0						; compute screen location
                            	   136: 	endif
                            	   137: 	if HAS_MMU
                            	   138: 		addi.l #$01E00000,d0
                            	   139: 	else
00:00001044 0680FD000000    	   140: 		addi.l #$FD000000,d0
                            	   141: 	endif
00:0000104A 23C000040B40    	   142: 	move.l d0,textvid_dcb+DCB_INBUFPTR
00:00001050 23C000040B44    	   143: 	move.l d0,textvid_dcb+DCB_OUTBUFPTR
00:00001056 23C000040004    	   144: 	move.l d0,TextScr
                            	   145: 	if (SCREEN_FORMAT==1)
00:0000105C 23FC000020000004	   146: 		move.l #8192,textvid_dcb+DCB_INBUFSIZE
00:00001064 0B48
00:00001066 23FC000020000004	   147: 		move.l #8192,textvid_dcb+DCB_OUTBUFSIZE
00:0000106E 0B4C
                            	   148: 	else
                            	   149: 		move.l #16384,textvid_dcb+DCB_INBUFSIZE
                            	   150: 		move.l #16384,textvid_dcb+DCB_OUTBUFSIZE
                            	   151: 	endif
00:00001070 23FC000000400004	   152: 	move.l #TEXTCOL,textvid_dcb+DCB_OUTDIMX	; set rows and columns
00:00001078 0B5C
00:0000107A 23FC000000200004	   153: 	move.l #TEXTROW,textvid_dcb+DCB_OUTDIMY
00:00001082 0B60
00:00001084 23FC000000400004	   154: 	move.l #TEXTCOL,textvid_dcb+DCB_INDIMX		; set rows and columns
00:0000108C 0B50
00:0000108E 23FC000000200004	   155: 	move.l #TEXTROW,textvid_dcb+DCB_INDIMY
00:00001096 0B54
00:00001098 13FC00400004008D	   156: 	move.b #TEXTCOL,TextCols				; set rows and columns
00:000010A0 13FC00200004008C	   157: 	move.b #TEXTROW,TextRows
00:000010A8 42B900040B28    	   158: 	clr.l textvid_dcb+DCB_OUTPOSX
00:000010AE 42B900040B2C    	   159: 	clr.l textvid_dcb+DCB_OUTPOSY
00:000010B4 201F            	   160: 	move.l (a7)+,d0
00:000010B6 4E75            	   161: 	rts
                            	   162: 
                            	   163: textvid_stat:
00:000010B8 7000            	   164: 	moveq #E_Ok,d0
00:000010BA 4E75            	   165: 	rts
                            	   166: 
                            	   167: textvid_getchar:
00:000010BC 61006BB2        	   168: 	bsr FromScreen
00:000010C0 7000            	   169: 	moveq #E_Ok,d0
00:000010C2 4E75            	   170: 	rts
                            	   171: 
                            	   172: textvid_putbuf:
                            	   173: textvid_getbuf:
                            	   174: textvid_stub:
00:000010C4 700A            	   175: 	moveq #E_NotSupported,d0
00:000010C6 4E75            	   176: 	rts
                            	   177: 
                            	   178: textvid_get_inpos:
00:000010C8 223900040B34    	   179: 	move.l textvid_dcb+DCB_INPOSX,d1
00:000010CE 243900040B38    	   180: 	move.l textvid_dcb+DCB_INPOSY,d2
00:000010D4 263900040B3C    	   181: 	move.l textvid_dcb+DCB_INPOSZ,d3
00:000010DA 7000            	   182: 	move.l #E_Ok,d0
00:000010DC 4E75            	   183: 	rts
                            	   184: 
                            	   185: textvid_set_inpos:
00:000010DE 23C100040B34    	   186: 	move.l d1,textvid_dcb+DCB_INPOSX
00:000010E4 23C200040B38    	   187: 	move.l d2,textvid_dcb+DCB_INPOSY
00:000010EA 23C300040B3C    	   188: 	move.l d3,textvid_dcb+DCB_INPOSZ
00:000010F0 7000            	   189: 	move.l #E_Ok,d0
00:000010F2 4E75            	   190: 	rts
                            	   191: 
                            	   192: textvid_set_outpos:
00:000010F4 23C100040B28    	   193: 	move.l d1,textvid_dcb+DCB_OUTPOSX
00:000010FA 23C200040B2C    	   194: 	move.l d2,textvid_dcb+DCB_OUTPOSY
00:00001100 23C300040B30    	   195: 	move.l d3,textvid_dcb+DCB_OUTPOSZ
00:00001106 7000            	   196: 	move.l #E_Ok,d0
00:00001108 4E75            	   197: 	rts
                            	   198: 
                            	   199: textvid_get_outpos:
00:0000110A 223900040B28    	   200: 	move.l textvid_dcb+DCB_OUTPOSX,d1
00:00001110 243900040B2C    	   201: 	move.l textvid_dcb+DCB_OUTPOSY,d2
00:00001116 263900040B30    	   202: 	move.l textvid_dcb+DCB_OUTPOSZ,d3
00:0000111C 7000            	   203: 	move.l #E_Ok,d0
00:0000111E 4E75            	   204: 	rts
                            	   205: 
                            	   206: textvid_get_outptr:
00:00001120 2F02            	   207: 	move.l d2,-(a7)
00:00001122 223900040B28    	   208: 	move.l textvid_dcb+DCB_OUTPOSX,d1
00:00001128 203900040B2C    	   209: 	move.l textvid_dcb+DCB_OUTPOSY,d0
00:0000112E 243900040B5C    	   210: 	move.l textvid_dcb+DCB_OUTDIMX,d2
00:00001134 C0C2            	   211: 	mulu d2,d0
00:00001136 D280            	   212: 	add.l d0,d1
                            	   213: 	if (SCREEN_FORMAT==1)
00:00001138 E589            	   214: 		lsl.l #2,d1
                            	   215: 	else
                            	   216: 		lsl.l #3,d1
                            	   217: 	endif
00:0000113A D2B900040B44    	   218: 	add.l textvid_dcb+DCB_OUTBUFPTR,d1
00:00001140 241F            	   219: 	move.l (a7)+,d2
00:00001142 7000            	   220: 	move.l #E_Ok,d0
00:00001144 4E75            	   221: 	rts
                            	   222: 
                            	   223: textvid_get_color:
00:00001146 223900040B6C    	   224: 	move.l textvid_dcb+DCB_FGCOLOR,d1
00:0000114C 243900040B68    	   225: 	move.l textvid_dcb+DCB_BKCOLOR,d2
00:00001152 7000            	   226: 	move.l #E_Ok,d0
00:00001154 4E75            	   227: 	rts
                            	   228: 
                            	   229: textvid_getbuf1:
00:00001156 223900040B44    	   230: 	move.l textvid_dcb+DCB_OUTBUFPTR,d1
00:0000115C 243900040B4C    	   231: 	move.l textvid_dcb+DCB_OUTBUFSIZE,d2
00:00001162 7000            	   232: 	move.l #E_Ok,d0
00:00001164 4E75            	   233: 	rts
                            	   234: 
                            	   235: textvid_set_unit:
00:00001166 23C100040B88    	   236: 	move.l d1,textvid_dcb+DCB_UNIT
00:0000116C 7000            	   237: 	move.l #E_Ok,d0
00:0000116E 4E75            	   238: 	rts
                            	   239: 
                            	   240: textvid_get_dimen:
00:00001170 4A00            	   241: 	cmpi.b #0,d0
00:00001172 6616            	   242: 	bne.s .0001
00:00001174 223900040B5C    	   243: 	move.l textvid_dcb+DCB_OUTDIMX,d1
00:0000117A 243900040B60    	   244: 	move.l textvid_dcb+DCB_OUTDIMY,d2
00:00001180 263900040B64    	   245: 	move.l textvid_dcb+DCB_OUTDIMZ,d3
00:00001186 7000            	   246: 	move.l #E_Ok,d0
00:00001188 4E75            	   247: 	rts
                            	   248: .0001:
00:0000118A 223900040B50    	   249: 	move.l textvid_dcb+DCB_INDIMX,d1
00:00001190 243900040B54    	   250: 	move.l textvid_dcb+DCB_INDIMY,d2
00:00001196 263900040B58    	   251: 	move.l textvid_dcb+DCB_INDIMZ,d3
00:0000119C 7000            	   252: 	move.l #E_Ok,d0
00:0000119E 4E75            	   253: 	rts
                            	   254: 
                            	   255: ; -----------------------------------------------------------------------------
                            	   256: ; -----------------------------------------------------------------------------
                            	   257: 
                            	   258: textvid_clear:
00:000011A0 23FCFFFFFFFFFD0F	   259: 	move.l #$FFFFFFFF,leds
00:000011A8 FF00
00:000011AA 48E77B80        	   260: 	movem.l	d1/d2/d3/d4/d6/d7/a0,-(a7)
00:000011AE 4E7A0FE0        	   261: 	movec	coreno,d0
00:000011B2 4840            	   262: 	swap d0	
                            	   263: ;	moveq		#SCREEN_SEMA,d1
                            	   264: ;	bsr			LockSemaphore
00:000011B4 7E02            	   265: 	moveq #2,d7									; device 2
00:000011B6 7C10            	   266: 	moveq #DEV_GETBUF1,d6
00:000011B8 4E40            	   267: 	trap #0
00:000011BA 23FCFEFEFEFEFD0F	   268: 	move.l #$FEFEFEFE,leds
00:000011C2 FF00
00:000011C4 2041            	   269: 	move.l d1,a0								; a0 = pointer to screen area
00:000011C6 2802            	   270: 	move.l d2,d4
                            	   271: 	if (SCREEN_FORMAT==1)
00:000011C8 E48C            	   272: 		lsr.l #2,d4									; number of cells to clear
                            	   273: 	else
                            	   274: 		lsr.l #3,d4									; number of cells to clear
                            	   275: 	endif
00:000011CA 7C15            	   276: 	move.l #DEV_GET_COLOR,d6
00:000011CC 4E40            	   277: 	trap #0
00:000011CE 23FCFDFDFDFDFD0F	   278: 	move.l #$FDFDFDFD,leds
00:000011D6 FF00
                            	   279: ;	bsr	get_screen_color				; get the color bits
                            	   280: 	if (SCREEN_FORMAT==1)
00:000011D8 48C1            	   281: 		ext.l d1
00:000011DA E189            	   282: 		lsl.l #8,d1
00:000011DC 48C2            	   283: 		ext.l d2									; clear high order bits
00:000011DE 8481            	   284: 		or.l d1,d2								; forground color in bits 24 to 31
00:000011E0 4842            	   285: 		swap d2										; color in bits 16 to 23
00:000011E2 00420020        	   286: 		ori.w #32,d2							; insert character to display (space)
00:000011E6 E15A            	   287: 		rol.w #8,d2								; reverse byte order
00:000011E8 4842            	   288: 		swap d2
00:000011EA E15A            	   289: 		rol.w #8,d2
                            	   290: loop3:
00:000011EC 20C2            	   291: 		move.l d2,(a0)+						; copy to cell
                            	   292: 	else
                            	   293: 		lsl.l #5,d1								; high order background color bits go in bits 0 to 4
                            	   294: 		move.l d2,d3
                            	   295: 		swap d3
                            	   296: 		andi.l #$1f,d3
                            	   297: 		or.l d3,d1
                            	   298: 		; we want bkcolor in bits 16 to 32
                            	   299: 		; char in bits 0 to 15
                            	   300: 		swap d2										; color in bits 16 to 32
                            	   301: 		move.w #32,d2							; load space character
                            	   302: 		rol.w	#8,d2								; swap endian, text controller expects little endian
                            	   303: 		swap d2
                            	   304: 		rol.w	#8,d2
                            	   305: 		rol.w	#8,d0								; swap endian
                            	   306: 		swap d0
                            	   307: 		rol.w	#8,d0
                            	   308: loop3:
                            	   309: 		move.l d2,(a0)+						; copy char plus bkcolor to cell
                            	   310: 		move.l d1,(a0)+						; copy fgcolor to cell
                            	   311: 	endif
00:000011EE 51CCFFFC        	   312: 	dbra d4,loop3
00:000011F2 4E7A0FE0        	   313: 	movec coreno,d0
00:000011F6 4840            	   314: 	swap d0	
                            	   315: ;	moveq #SCREEN_SEMA,d1
                            	   316: ;	bsr UnlockSemaphore
00:000011F8 23FCFCFCFCFCFD0F	   317: 	move.l #$FCFCFCFC,leds
00:00001200 FF00
00:00001202 4CDF01DE        	   318: 	movem.l (a7)+,d1/d2/d3/d4/d6/d7/a0
00:00001206 7000            	   319: 	move.l #E_Ok,d0
00:00001208 4E75            	   320: 	rts
                            	   321: 
                            	   322: ; -----------------------------------------------------------------------------
                            	   323: ; Gets the screen color in d0 and d1. Setup already to be able to insert
                            	   324: ; character code.
                            	   325: ; -----------------------------------------------------------------------------
                            	   326: 
                            	   327: get_screen_color:
00:0000120A 2F02            	   328: 	move.l d2,-(a7)
00:0000120C 223900040B6C    	   329: 	move.l textvid_dcb+DCB_FGCOLOR,d1
00:00001212 243900040B68    	   330: 	move.l textvid_dcb+DCB_BKCOLOR,d2
                            	   331: 	if (SCREEN_FORMAT==1)
00:00001218 E189            	   332: 		lsl.l #8,d1							; foreground color in bits 8 to 15
00:0000121A 024200FF        	   333: 		andi.w #$ff,d2
00:0000121E 8242            	   334: 		or.w d2,d1							; background color in bits 0 to 7
00:00001220 4841            	   335: 		swap d1									; foreground color in bits 24 to 31, bk in 16 to 23
00:00001222 4241            	   336: 		move.w #0,d1						; clear character
00:00001224 2001            	   337: 		move.l d1,d0
                            	   338: 	else
                            	   339: 		asl.l	#5,d1							; shift into position
                            	   340: 		ori.l	#$40000000,d1			; set priority
                            	   341: 		move.l d2,d0
                            	   342: 		lsr.l	#8,d2
                            	   343: 		lsr.l	#8,d2
                            	   344: 		andi.l #31,d2						; mask off extra bits
                            	   345: 		or.l d2,d1							; set background color bits in upper long word
                            	   346: 		asl.l	#8,d0							; shift into position for display ram
                            	   347: 		asl.l	#8,d0
                            	   348: 	endif
00:00001226 241F            	   349: 	move.l (a7)+,d2
00:00001228 4E75            	   350: 	rts
                            	   351: 
                            	   352: ;------------------------------------------------------------------------------
                            	   353: ; Calculate screen memory location from CursorRow,CursorCol.
                            	   354: ; Destroys d0,d2,a0
                            	   355: ;------------------------------------------------------------------------------
                            	   356: 
                            	   357: CalcScreenLoc:
00:0000122A 48E7C400        	   358: 	movem.l d0/d1/d5,-(a7)
00:0000122E 203900040B28    	   359: 	move.l textvid_dcb+DCB_OUTPOSX,d0
00:00001234 2A3900040B2C    	   360: 	move.l textvid_dcb+DCB_OUTPOSY,d5
00:0000123A 223900040B5C    	   361: 	move.l textvid_dcb+DCB_OUTDIMX,d1
00:00001240 CAC1            	   362: 	mulu d1,d5							; y * num cols
00:00001242 D085            	   363: 	add.l d5,d0							; plus x
                            	   364: 	if (SCREEN_FORMAT==1)
00:00001244 E580            	   365: 		asl.l #2,d0							; 4 bytes per char
                            	   366: 	else
                            	   367: 		asl.l	#3,d0							; 8 bytes per char
                            	   368: 	endif
00:00001246 207900040B44    	   369: 	move.l textvid_dcb+DCB_OUTBUFPTR,a0
00:0000124C D1C0            	   370: 	add.l	d0,a0								; a0 = screen location
00:0000124E 4CDF0023        	   371: 	movem.l (a7)+,d0/d1/d5
00:00001252 4E75            	   372: 	rts
                            	   373: 
                            	   374: ;------------------------------------------------------------------------------
                            	   375: ; Display a character on the screen
                            	   376: ; Parameters:
                            	   377: ; 	d1.b = char to display
                            	   378: ;------------------------------------------------------------------------------
                            	   379: 
                            	   380: textvid_putchar:
00:00001254 48E77000        	   381: 	movem.l	d1/d2/d3,-(a7)
00:00001258 4E7A2FE0        	   382: 	movec	coreno,d2
00:0000125C 0C020002        	   383: 	cmpi.b #2,d2
                            	   384: ;	bne.s		.0001
                            	   385: ;	bsr			SerialPutChar
                            	   386: .0001:
00:00001260 0281000000FF    	   387: 	andi.l #$ff,d1				; zero out upper bytes of d1
00:00001266 0C01000D        	   388: 	cmpi.b #13,d1				; carriage return ?
00:0000126A 6612            	   389: 	bne.s	dccr
00:0000126C 42B900040B28    	   390: 	clr.l	textvid_dcb+DCB_OUTPOSX	; just set cursor column to zero on a CR
                            	   391: dcx14:
00:00001272 6100024E        	   392: 	bsr	SyncCursor				; set position in text controller
                            	   393: dcx7:
00:00001276 4CDF000E        	   394: 	movem.l	(a7)+,d1/d2/d3
00:0000127A 7000            	   395: 	moveq #E_Ok,d0
00:0000127C 4E75            	   396: 	rts
                            	   397: dccr:
00:0000127E 0C010091        	   398: 	cmpi.b #$91,d1			; cursor right ?
00:00001282 6618            	   399: 	bne.s dcx6
00:00001284 243900040B5C    	   400: 	move.l textvid_dcb+DCB_OUTDIMX,d2
00:0000128A 5382            	   401: 	subq.l #1,d2
00:0000128C 94B900040B28    	   402: 	sub.l	textvid_dcb+DCB_OUTPOSX,d2
00:00001292 67E2            	   403: 	beq.s	dcx7
00:00001294 52B900040B28    	   404: 	addq.l #1,textvid_dcb+DCB_OUTPOSX
00:0000129A 60D6            	   405: 	bra.s dcx14
                            	   406: dcx6:
00:0000129C 0C010090        	   407: 	cmpi.b #$90,d1			; cursor up ?
00:000012A0 6610            	   408: 	bne.s	dcx8
00:000012A2 4AB900040B2C    	   409: 	tst.l textvid_dcb+DCB_OUTPOSY
00:000012A8 67CC            	   410: 	beq.s	dcx7
00:000012AA 53B900040B2C    	   411: 	subq.l #1,textvid_dcb+DCB_OUTPOSY
00:000012B0 60C0            	   412: 	bra.s	dcx14
                            	   413: dcx8:
00:000012B2 0C010093        	   414: 	cmpi.b #$93,d1			; cursor left?
00:000012B6 6610            	   415: 	bne.s	dcx9
00:000012B8 4AB900040B28    	   416: 	tst.l textvid_dcb+DCB_OUTPOSX
00:000012BE 67B6            	   417: 	beq.s	dcx7
00:000012C0 53B900040B28    	   418: 	subq.l #1,textvid_dcb+DCB_OUTPOSX
00:000012C6 60AA            	   419: 	bra.s	dcx14
                            	   420: dcx9:
00:000012C8 0C010092        	   421: 	cmpi.b #$92,d1			; cursor down ?
00:000012CC 6618            	   422: 	bne.s	dcx10
00:000012CE 243900040B60    	   423: 	move.l textvid_dcb+DCB_OUTDIMY,d2
00:000012D4 5382            	   424: 	subq.l #1,d2
00:000012D6 B4B900040B2C    	   425: 	cmp.l	textvid_dcb+DCB_OUTPOSY,d2
00:000012DC 6798            	   426: 	beq.s	dcx7
00:000012DE 52B900040B2C    	   427: 	addq.l #1,textvid_dcb+DCB_OUTPOSY
00:000012E4 608C            	   428: 	bra.s	dcx14
                            	   429: dcx10:
00:000012E6 0C010094        	   430: 	cmpi.b #$94,d1			; cursor home ?
00:000012EA 661C            	   431: 	bne.s	dcx11
00:000012EC 4AB900040B28    	   432: 	tst.l	textvid_dcb+DCB_OUTPOSX
00:000012F2 670A            	   433: 	beq.s	dcx12
00:000012F4 42B900040B28    	   434: 	clr.l	textvid_dcb+DCB_OUTPOSX
00:000012FA 6000FF76        	   435: 	bra	dcx14
                            	   436: dcx12:
00:000012FE 42B900040B2C    	   437: 	clr.l	textvid_dcb+DCB_OUTPOSY
00:00001304 6000FF6C        	   438: 	bra	dcx14
                            	   439: dcx11:
00:00001308 48E70080        	   440: 	movem.l	a0,-(a7)
00:0000130C 0C010099        	   441: 	cmpi.b #$99,d1				; delete ?
00:00001310 6760            	   442: 	beq.s	doDelete
00:00001312 0C010008        	   443: 	cmpi.b #CTRLH,d1			; backspace ?
00:00001316 674C            	   444: 	beq.s doBackspace
00:00001318 0C010018        	   445: 	cmpi.b #CTRLX,d1			; delete line ?
00:0000131C 6700008A        	   446: 	beq	doCtrlX
00:00001320 0C01000A        	   447: 	cmpi.b #10,d1					; linefeed ?
00:00001324 672C            	   448: 	beq.s dclf
                            	   449: 
                            	   450: 	; regular char
00:00001326 23FCFFFFFFFFFD0F	   451: 	move.l #$FFFFFFFF,leds
00:0000132E FF00
00:00001330 6100FEF8        	   452: 	bsr	CalcScreenLoc			; a0 = screen location
00:00001334 23FCFFFFFFFEFD0F	   453: 	move.l #$FFFFFFFE,leds
00:0000133C FF00
00:0000133E 2401            	   454: 	move.l d1,d2					; d2 = char
00:00001340 6100FEC8        	   455: 	bsr get_screen_color	; d0,d1 = color
00:00001344 8082            	   456: 	or.l d2,d0						; d0 = char + color
00:00001346 E158            	   457: 	rol.w	#8,d0						; swap bytes - text controller expects little endian data
00:00001348 4840            	   458: 	swap d0								; swap halfs
00:0000134A E158            	   459: 	rol.w	#8,d0						; swap remaining bytes
                            	   460: 	if (SCREEN_FORMAT==1)
00:0000134C 20C0            	   461: 		move.l d0,(a0)+
                            	   462: 	else
                            	   463: 		move.l d0,(a0)+
                            	   464: 		rol.w	#8,d1					; swap bytes
                            	   465: 		swap d1							; swap halfs
                            	   466: 		rol.w	#8,d1					; swap remaining bytes
                            	   467: 		move.l d1,(a0)
                            	   468: 	endif
00:0000134E 617C            	   469: 	bsr	IncCursorPos
00:00001350 6004            	   470: 	bra	dcx16
                            	   471: dclf:
00:00001352 61000092        	   472: 	bsr IncCursorRow
                            	   473: dcx16:
00:00001356 6100016A        	   474: 	bsr	SyncCursor
                            	   475: dcx4:
00:0000135A 205F            	   476: 	movem.l	(a7)+,a0			; get back a0
00:0000135C 4CDF000E        	   477: 	movem.l	(a7)+,d1/d2/d3
00:00001360 7000            	   478: 	moveq #E_Ok,d0
00:00001362 4E75            	   479: 	rts
                            	   480: 
                            	   481: 	;---------------------------
                            	   482: 	; CTRL-H: backspace
                            	   483: 	;---------------------------
                            	   484: doBackspace:
00:00001364 4AB900040B28    	   485: 	tst.l	textvid_dcb+DCB_OUTPOSX		; if already at start of line
00:0000136A 67EE            	   486: 	beq.s dcx4						; nothing to do
00:0000136C 53B900040B28    	   487: 	subq.l #1,textvid_dcb+DCB_OUTPOSX		; decrement column
                            	   488: 
                            	   489: 	;---------------------------
                            	   490: 	; Delete key
                            	   491: 	;---------------------------
                            	   492: doDelete:
00:00001372 48E7C080        	   493: 	movem.l	d0/d1/a0,-(a7)	; save off screen location
00:00001376 6100FEB2        	   494: 	bsr	CalcScreenLoc				; a0 = screen location
00:0000137A 203900040B28    	   495: 	move.l textvid_dcb+DCB_OUTPOSX,d0
                            	   496: .0001:
                            	   497: 	if (SCREEN_FORMAT==1)
00:00001380 20A80004        	   498: 		move.l 4(a0),(a0)				; pull remaining characters on line over 1
00:00001384 5888            	   499: 		adda.l #4,a0
                            	   500: 	else
                            	   501: 		move.l 8(a0),(a0)				; pull remaining characters on line over 1
                            	   502: 		move.l 12(a0),4(a0)
                            	   503: 		adda.l #8,a0
                            	   504: 	endif
00:00001386 5280            	   505: 	addq.l #1,d0
00:00001388 B0B900040B5C    	   506: 	cmp.l	textvid_dcb+DCB_OUTDIMX,d0
00:0000138E 65F0            	   507: 	blo.s	.0001
00:00001390 6100FE78        	   508: 	bsr	get_screen_color
                            	   509: 	if (SCREEN_FORMAT==1)
00:00001394 303C0020        	   510: 		move.w #' ',d0
00:00001398 E158            	   511: 		rol.w	#8,d0
00:0000139A 4840            	   512: 		swap d0
00:0000139C E158            	   513: 		rol.w	#8,d0
00:0000139E 2140FFFC        	   514: 		move.l d0,-4(a0)
                            	   515: 	else
                            	   516: 		move.w #' ',d0					; terminate line with a space
                            	   517: 		rol.w	#8,d0
                            	   518: 		swap d0
                            	   519: 		rol.w	#8,d0
                            	   520: 		move.l d0,-8(a0)
                            	   521: 	endif
00:000013A2 4CDF0103        	   522: 	movem.l	(a7)+,d0/d1/a0
00:000013A6 60AE            	   523: 	bra.s		dcx16				; finished
                            	   524: 
                            	   525: 	;---------------------------
                            	   526: 	; CTRL-X: erase line
                            	   527: 	;---------------------------
                            	   528: doCtrlX:
00:000013A8 42B900040B28    	   529: 	clr.l	textvid_dcb+DCB_OUTPOSX			; Reset cursor to start of line
00:000013AE 203900040B5C    	   530: 	move.l textvid_dcb+DCB_OUTDIMX,d0	; and display TextCols number of spaces
00:000013B4 4880            	   531: 	ext.w	d0
00:000013B6 48C0            	   532: 	ext.l	d0
00:000013B8 123C0020        	   533: 	move.b #' ',d1			; d1 = space char
                            	   534: .0001:
                            	   535: 	; textvid_putchar is called recursively here
                            	   536: 	; It's safe to do because we know it won't recurse again due to the
                            	   537: 	; fact we know the character being displayed is a space char
00:000013BC 6100FE96        	   538: 	bsr	textvid_putchar
00:000013C0 5340            	   539: 	subq #1,d0
00:000013C2 66F8            	   540: 	bne.s	.0001
00:000013C4 42B900040B28    	   541: 	clr.l	textvid_dcb+DCB_OUTPOSX			; now really go back to start of line
00:000013CA 608A            	   542: 	bra	dcx16						; we're done
                            	   543: 
                            	   544: ;------------------------------------------------------------------------------
                            	   545: ; Increment the cursor position, scroll the screen if needed.
                            	   546: ;------------------------------------------------------------------------------
                            	   547: 
                            	   548: IncCursorPos:
00:000013CC 52B900040B28    	   549: 	addq.l #1,textvid_dcb+DCB_OUTPOSX
00:000013D2 203900040B5C    	   550: 	move.l textvid_dcb+DCB_OUTDIMX,d0
00:000013D8 B0B900040B28    	   551: 	cmp.l	textvid_dcb+DCB_OUTPOSX,d0
00:000013DE 642E            	   552: 	bhs.s	icc1
00:000013E0 42B900040B28    	   553: 	clr.l textvid_dcb+DCB_OUTPOSX
                            	   554: IncCursorRow:
00:000013E6 52B900040B2C    	   555: 	addq.l #1,textvid_dcb+DCB_OUTPOSY
00:000013EC 203900040B60    	   556: 	move.l textvid_dcb+DCB_OUTDIMY,d0
00:000013F2 B0B900040B2C    	   557: 	cmp.l textvid_dcb+DCB_OUTPOSY,d0
00:000013F8 6214            	   558: 	bhi.s	icc1
00:000013FA 203900040B60    	   559: 	move.l textvid_dcb+DCB_OUTDIMY,d0
00:00001400 23C000040B2C    	   560: 	move.l d0,textvid_dcb+DCB_OUTPOSY		; in case CursorRow is way over
00:00001406 53B900040B2C    	   561: 	subq.l #1,textvid_dcb+DCB_OUTPOSY
00:0000140C 6102            	   562: 	bsr	ScrollUp
                            	   563: icc1:
00:0000140E 4E75            	   564: 	rts
                            	   565: 
                            	   566: ;------------------------------------------------------------------------------
                            	   567: ; Scroll screen up.
                            	   568: ;------------------------------------------------------------------------------
                            	   569: 
                            	   570: ScrollUp:
00:00001410 48E7C084        	   571: 	movem.l	d0/d1/a0/a5,-(a7)		; save off some regs
00:00001414 4E7A0FE0        	   572: 	movec	coreno,d0
00:00001418 4840            	   573: 	swap d0	
00:0000141A 7205            	   574: 	moveq	#SCREEN_SEMA,d1
00:0000141C 61000FE2        	   575: 	bsr	LockSemaphore
00:00001420 207900040B44    	   576: 	move.l textvid_dcb+DCB_OUTBUFPTR,a0
00:00001426 2A48            	   577: 	move.l a0,a5								; a5 = pointer to text screen
                            	   578: .0003:								
00:00001428 203900040B5C    	   579: 	move.l textvid_dcb+DCB_OUTDIMX,d0					; d0 = columns
00:0000142E 223900040B60    	   580: 	move.l textvid_dcb+DCB_OUTDIMY,d1					; d1 = rows
                            	   581: 	if (SCREEN_FORMAT==1)
00:00001434 E580            	   582: 		asl.l	#2,d0								; make into cell index
                            	   583: 	else
                            	   584: 		asl.l	#3,d0								; make into cell index
                            	   585: 	endif
00:00001436 41F50800        	   586: 	lea	0(a5,d0.l),a0						; a0 = pointer to second row of text screen
                            	   587: 	if (SCREEN_FORMAT==1)
00:0000143A E488            	   588: 		lsr.l	#2,d0								; get back d0
                            	   589: 	else
                            	   590: 		lsr.l	#3,d0								; get back d0
                            	   591: 	endif
00:0000143C 5381            	   592: 	subq.l #1,d1									; number of rows-1
00:0000143E C0C1            	   593: 	mulu d1,d0									; d0 = count of characters to move
                            	   594: 	if (SCREEN_FORMAT==1)
                            	   595: 	else
                            	   596: 		add.l d0,d0									; d0*2 2 longs per char
                            	   597: 	endif
                            	   598: .0001:
00:00001440 2AD8            	   599: 	move.l (a0)+,(a5)+
00:00001442 51C8FFFC        	   600: 	dbra d0,.0001
00:00001446 4E7A0FE0        	   601: 	movec coreno,d0
00:0000144A 4840            	   602: 	swap d0	
00:0000144C 7205            	   603: 	moveq #SCREEN_SEMA,d1
00:0000144E 61000FEC        	   604: 	bsr UnlockSemaphore
00:00001452 4CDF2103        	   605: 	movem.l (a7)+,d0/d1/a0/a5
                            	   606: 	; Fall through into blanking out last line
                            	   607: 
                            	   608: ;------------------------------------------------------------------------------
                            	   609: ; Blank out the last line on the screen.
                            	   610: ;------------------------------------------------------------------------------
                            	   611: 
                            	   612: BlankLastLine:
00:00001456 48E7E080        	   613: 	movem.l	d0/d1/d2/a0,-(a7)
00:0000145A 4E7A0FE0        	   614: 	movec	coreno,d0
00:0000145E 4840            	   615: 	swap d0	
00:00001460 7205            	   616: 	moveq	#SCREEN_SEMA,d1
00:00001462 61000F9C        	   617: 	bsr	LockSemaphore
00:00001466 207900040B44    	   618: 	move.l textvid_dcb+DCB_OUTBUFPTR,a0
00:0000146C 203900040B5C    	   619: 	move.l textvid_dcb+DCB_OUTDIMX,d0					; d0 = columns
00:00001472 223900040B60    	   620: 	move.l textvid_dcb+DCB_OUTDIMY,d1					; d1 = rows
00:00001478 5341            	   621: 	subq #1,d1									; last row = #rows-1
00:0000147A C0C1            	   622: 	mulu d1,d0									; d0 = index of last line
                            	   623: 	if (SCREEN_FORMAT==1)
00:0000147C E588            	   624: 		lsl.l	#2,d0								; *4 bytes per char
                            	   625: 	else
                            	   626: 		lsl.l	#3,d0								; *8 bytes per char
                            	   627: 	endif
00:0000147E 41F00800        	   628: 	lea	(a0,d0.l),a0						; point a0 to last row
00:00001482 243900040B5C    	   629: 	move.l textvid_dcb+DCB_OUTDIMX,d2					; number of text cells to clear
00:00001488 5382            	   630: 	subq.l #1,d2								; count must be one less than desired
00:0000148A 6100FD7E        	   631: 	bsr	get_screen_color				; d0,d1 = screen color
                            	   632: 	if (SCREEN_FORMAT==1)
00:0000148E 303C0020        	   633: 		move.w #32,d0
                            	   634: 	else
                            	   635: 		move.w #32,d0								; set the character for display in low 16 bits
                            	   636: 	endif
00:00001492 E158            	   637: 	rol.w	#8,d0
00:00001494 4840            	   638: 	swap d0
00:00001496 E158            	   639: 	rol.w	#8,d0
                            	   640: .0001:
                            	   641: 	if (SCREEN_FORMAT==1)
00:00001498 20C0            	   642: 		move.l d0,(a0)+
                            	   643: 	else
                            	   644: 		move.l d0,(a0)+
                            	   645: 		bsr rbo
                            	   646: 		move.l d1,(a0)+
                            	   647: 	endif
00:0000149A 51CAFFFC        	   648: 	dbra d2,.0001
00:0000149E 4E7A0FE0        	   649: 	movec	coreno,d0
00:000014A2 4840            	   650: 	swap d0	
00:000014A4 7205            	   651: 	moveq #SCREEN_SEMA,d1
00:000014A6 61000F94        	   652: 	bsr UnlockSemaphore
00:000014AA 4CDF0107        	   653: 	movem.l	(a7)+,d0/d1/d2/a0
00:000014AE 4E75            	   654: 	rts
                            	   655: 
                            	   656: ;------------------------------------------------------------------------------
                            	   657: ; Set cursor position to top left of screen.
                            	   658: ;
                            	   659: ; Parameters:
                            	   660: ;		<none>
                            	   661: ; Returns:
                            	   662: ;		<none>
                            	   663: ; Registers Affected:
                            	   664: ;		<none>
                            	   665: ;------------------------------------------------------------------------------
                            	   666: 
                            	   667: HomeCursor:
00:000014B0 42B900040B28    	   668: 	clr.l textvid_dcb+DCB_OUTPOSX
00:000014B6 42B900040B2C    	   669: 	clr.l textvid_dcb+DCB_OUTPOSY
00:000014BC 42B900040B30    	   670: 	clr.l textvid_dcb+DCB_OUTPOSZ
                            	   671: 	; fall through
                            	   672: 
                            	   673: ;------------------------------------------------------------------------------
                            	   674: ; SyncCursor:
                            	   675: ;
                            	   676: ; Sync the hardware cursor's position to the text cursor position but only for
                            	   677: ; the core with the IO focus.
                            	   678: ;
                            	   679: ; Parameters:
                            	   680: ;		<none>
                            	   681: ; Returns:
                            	   682: ;		<none>
                            	   683: ; Registers Affected:
                            	   684: ;		<none>
                            	   685: ;------------------------------------------------------------------------------
                            	   686: 
                            	   687: SyncCursor:
00:000014C2 23FCFFFFFFFDFD0F	   688: 	move.l #$FFFFFFFD,leds
00:000014CA FF00
00:000014CC 48E7E000        	   689: 	movem.l	d0/d1/d2,-(a7)
00:000014D0 4E7A0FE0        	   690: 	movec	coreno,d0
00:000014D4 B03900100000    	   691: 	cmp.b	IOFocus,d0
00:000014DA 6622            	   692: 	bne.s .0001
00:000014DC 203900040B28    	   693: 	move.l textvid_dcb+DCB_OUTPOSX,d0
00:000014E2 223900040B2C    	   694: 	move.l textvid_dcb+DCB_OUTPOSY,d1
00:000014E8 243900040B5C    	   695: 	move.l textvid_dcb+DCB_OUTDIMX,d2
00:000014EE C4C1            	   696: 	mulu d1,d2
00:000014F0 D480            	   697: 	add.l d0,d2
00:000014F2 E15A            	   698: 	rol.w	#8,d2					; swap byte order
00:000014F4 4842            	   699: 	swap d2
00:000014F6 E15A            	   700: 	rol.w #8,d2
00:000014F8 23C2FD080024    	   701: 	move.l d2,TEXTREG+$24
                            	   702: .0001:	
00:000014FE 4CDF0007        	   703: 	movem.l	(a7)+,d0/d1/d2
00:00001502 4E75            	   704: 	rts
                            	   705: 
                            	   706: 

Source: "boot.x68"
                            	   575: 	include "err.x68"

Source: "err.x68"
                            	     1: ;------------------------------------------------------------------------------
                            	     2: ;------------------------------------------------------------------------------
                            	     3: ; Setup the err device
                            	     4: ;------------------------------------------------------------------------------
                            	     5: ;------------------------------------------------------------------------------
                            	     6: 
                            	     7: setup_err:
                            	     8: err_init:
00:00001504 7020            	     9: 	moveq #32,d0
00:00001506 41F900040B8C    	    10: 	lea.l err_dcb,a0
                            	    11: .0001:
00:0000150C 4298            	    12: 	clr.l (a0)+
00:0000150E 51C8FFFC        	    13: 	dbra d0,.0001
00:00001512 23FC204243440004	    14: 	move.l #$20424344,err_dcb+DCB_MAGIC				; 'DCB'
00:0000151A 0B8C
00:0000151C 23FC4C4C554E0004	    15: 	move.l #$4C4C554E,err_dcb+DCB_NAME					; 'err'
00:00001524 0B90
00:00001526 23FC000015320004	    16: 	move.l #err_cmdproc,err_dcb+DCB_CMDPROC
00:0000152E 0BA4
                            	    17: err_ret:
00:00001530 4E75            	    18: 	rts
                            	    19: 
                            	    20: err_cmdproc:
00:00001532 7000            	    21: 	moveq #E_Ok,d0
00:00001534 4E75            	    22: 	rts
                            	    23: 
                            	    24: 

Source: "boot.x68"
                            	   576: 	include "serial.x68"

Source: "serial.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: ;==============================================================================
                            	    38: ; Serial I/O routines
                            	    39: ;==============================================================================
                            	    40: 
                            	    41: 	code
                            	    42: 	align 2
                            	    43: COM_CMDTBL:
00:00001538 00001568        	    44: 	dc.l serial_init
00:0000153C 000015EE        	    45: 	dc.l serial_stat
00:00001540 000015F2        	    46: 	dc.l serial_putchar
00:00001544 00001620        	    47: 	dc.l serial_putbuf
00:00001548 000015FA        	    48: 	dc.l serial_getchar
00:0000154C 00001620        	    49: 	dc.l serial_getbuf
00:00001550 00001620        	    50: 	dc.l serial_set_inpos
00:00001554 00001620        	    51: 	dc.l serial_set_outpos
00:00001558 00001600        	    52: 	dc.l serial_getchar_direct
00:0000155C 00001608        	    53: 	dc.l serial_peek_char
00:00001560 00001610        	    54: 	dc.l serial_peek_char_direct
00:00001564 00001618        	    55: 	dc.l serial_putchar_direct
                            	    56: 
                            	    57: ;------------------------------------------------------------------------------
                            	    58: ; Setup the console device
                            	    59: ; stdout = text screen controller
                            	    60: ;------------------------------------------------------------------------------
                            	    61: 	even
                            	    62: 
                            	    63: serial_init:
                            	    64: setup_serial:
00:00001568 48E780C0        	    65: 	movem.l d0/a0/a1,-(a7)
00:0000156C 701F            	    66: 	moveq #31,d0
00:0000156E 41F900040C94    	    67: 	lea.l serial_dcb,a0
                            	    68: .0001:
00:00001574 4298            	    69: 	clr.l (a0)+
00:00001576 51C8FFFC        	    70: 	dbra d0,.0001
00:0000157A 23FC444342200004	    71: 	move.l #$44434220,serial_dcb+DCB_MAGIC			; 'DCB'
00:00001582 0C94
00:00001584 23FC434F4D000004	    72: 	move.l #$434F4D00,serial_dcb+DCB_NAME				; 'COM'
00:0000158C 0C98
00:0000158E 23FC000015CC0004	    73: 	move.l #serial_cmdproc,serial_dcb+DCB_CMDPROC
00:00001596 0CAC
00:00001598 23FC001010000004	    74: 	move.l #SerRcvBuf,serial_dcb+DCB_INBUFPTR
00:000015A0 0CCC
00:000015A2 23FC001020000004	    75: 	move.l #SerXmitBuf,serial_dcb+DCB_OUTBUFPTR
00:000015AA 0CD0
00:000015AC 23FC000010000004	    76: 	move.l #4096,serial_dcb+DCB_INBUFSIZE
00:000015B4 0CD4
00:000015B6 616C            	    77: 	bsr SerialInit
00:000015B8 43F900040C94    	    78: 	lea.l serial_dcb,a1
00:000015BE 610060D0        	    79: 	jsr DisplayString
00:000015C2 610060B2        	    80: 	jsr CRLF
00:000015C6 4CDF0301        	    81: 	movem.l (a7)+,d0/a0/a1
00:000015CA 4E75            	    82: 	rts
                            	    83: 
                            	    84: serial_cmdproc:
00:000015CC 0C06000C        	    85: 	cmpi.b #12,d6
00:000015D0 6418            	    86: 	bhs.s .0001
00:000015D2 48E70280        	    87: 	movem.l d6/a0,-(a7)
00:000015D6 4886            	    88: 	ext.w d6
00:000015D8 E54E            	    89: 	lsl.w #2,d6
00:000015DA 41FAFF5C        	    90: 	lea COM_CMDTBL,a0
00:000015DE 20706000        	    91: 	move.l (a0,d6.w),a0
00:000015E2 4E90            	    92: 	jsr (a0)
00:000015E4 4CDF0140        	    93: 	movem.l (a7)+,d6/a0
00:000015E8 4E75            	    94: 	rts
                            	    95: .0001:
00:000015EA 7002            	    96: 	moveq #E_Func,d0
00:000015EC 4E75            	    97: 	rts
                            	    98: 
                            	    99: serial_stat:
00:000015EE 7000            	   100: 	moveq #E_Ok,d0
00:000015F0 4E75            	   101: 	rts
                            	   102: 
                            	   103: serial_putchar:
00:000015F2 6100013C        	   104: 	bsr SerialPutChar
00:000015F6 7000            	   105: 	moveq #E_Ok,d0
00:000015F8 4E75            	   106: 	rts
                            	   107: 
                            	   108: serial_getchar:
00:000015FA 6166            	   109: 	bsr SerialGetChar
00:000015FC 7000            	   110: 	moveq #E_Ok,d0
00:000015FE 4E75            	   111: 	rts
                            	   112: 
                            	   113: serial_getchar_direct:
00:00001600 61000114        	   114: 	bsr SerialPeekCharDirect
00:00001604 7000            	   115: 	moveq #E_Ok,d0
00:00001606 4E75            	   116: 	rts
                            	   117: 
                            	   118: serial_peek_char:
00:00001608 610000D0        	   119: 	bsr SerialPeekChar
00:0000160C 7000            	   120: 	moveq #E_Ok,d0
00:0000160E 4E75            	   121: 	rts
                            	   122: 
                            	   123: serial_peek_char_direct:
00:00001610 61000104        	   124: 	bsr SerialPeekCharDirect
00:00001614 7000            	   125: 	moveq #E_Ok,d0
00:00001616 4E75            	   126: 	rts
                            	   127: 
                            	   128: serial_putchar_direct:
00:00001618 6100017A        	   129: 	bsr SerialPutCharDirect
00:0000161C 7000            	   130: 	moveq #E_Ok,d0
00:0000161E 4E75            	   131: 	rts
                            	   132: 
                            	   133: serial_putbuf:
                            	   134: serial_getbuf:
                            	   135: serial_set_inpos:
                            	   136: serial_set_outpos:
00:00001620 700A            	   137: 	moveq #E_NotSupported,d0
00:00001622 4E75            	   138: 	rts
                            	   139: 
                            	   140: ;------------------------------------------------------------------------------
                            	   141: ; Initialize the serial port an enhanced 6551 circuit.
                            	   142: ;
                            	   143: ; Select internal baud rate clock divider for 9600 baud
                            	   144: ; Reset fifos, set threshold to 3/4 full on transmit and 3/4 empty on receive
                            	   145: ; Note that the byte order is swapped.
                            	   146: ;------------------------------------------------------------------------------
                            	   147: 
                            	   148: SerialInit:
00:00001624 427900100162    	   149: 	clr.w		SerHeadRcv					; clear receive buffer indexes
00:0000162A 427900100160    	   150: 	clr.w		SerTailRcv
00:00001630 427900100168    	   151: 	clr.w		SerHeadXmit					; clear transmit buffer indexes
00:00001636 427900100166    	   152: 	clr.w		SerTailXmit
00:0000163C 423900100164    	   153: 	clr.b		SerRcvXon						; and Xon,Xoff flags
00:00001642 423900100165    	   154: 	clr.b		SerRcvXoff
00:00001648 203C09000000    	   155: 	move.l	#$09000000,d0				; dtr,rts active, rxint enabled, no parity
00:0000164E 23C0FD060008    	   156: 	move.l	d0,ACIA+ACIA_CMD
                            	   157: ;	move.l	#$1E00F700,d0				; fifos enabled
00:00001654 203C1E000000    	   158: 	move.l	#$1E000000,d0				; fifos disabled
00:0000165A 23C0FD06000C    	   159: 	move.l	d0,ACIA+ACIA_CTRL
00:00001660 4E75            	   160: 	rts
                            	   161: ;	move.l	#$0F000000,d0				; transmit a break for a while
                            	   162: ;	move.l	d0,ACIA+ACIA_CMD
                            	   163: ;	move.l	#300000,d2					; wait 100 ms
                            	   164: ;	bra			.0001
                            	   165: ;.0003:
                            	   166: ;	swap		d2
                            	   167: ;.0001:
                            	   168: ;	nop
                            	   169: ;	dbra		d2,.0001
                            	   170: ;.0002:
                            	   171: ;	swap		d2
                            	   172: ;	dbra		d2,.0003
                            	   173: ;	move.l	#$07000000,d0				; clear break
                            	   174: ;	move.l	d0,ACIA+ACIA_CMD
                            	   175: ;	rts
                            	   176: 	
                            	   177: ;------------------------------------------------------------------------------
                            	   178: ; SerialGetChar
                            	   179: ;
                            	   180: ; Check the serial port buffer to see if there's a char available. If there's
                            	   181: ; a char available then return it. If the buffer is almost empty then send an
                            	   182: ; XON.
                            	   183: ;
                            	   184: ; Stack Space:
                            	   185: ;		2 long words
                            	   186: ; Parameters:
                            	   187: ;		none
                            	   188: ; Modifies:
                            	   189: ;		d0,a0
                            	   190: ; Returns:
                            	   191: ;		d1 = character or -1
                            	   192: ;------------------------------------------------------------------------------
                            	   193: 
                            	   194: SerialGetChar:
00:00001662 2F02            	   195: 	move.l		d2,-(a7)
00:00001664 4E7A0FE0        	   196: 	movec			coreno,d0
00:00001668 4840            	   197: 	swap			d0
00:0000166A 7202            	   198: 	moveq			#SERIAL_SEMA,d1
00:0000166C 61000D92        	   199: 	bsr				LockSemaphore
00:00001670 61000146        	   200: 	bsr				SerialRcvCount			; check number of chars in receive buffer
00:00001674 0C400008        	   201: 	cmpi.w		#8,d0								; less than 8?
00:00001678 621C            	   202: 	bhi				.sgc2
00:0000167A 4A3900100164    	   203: 	tst.b			SerRcvXon						; skip sending XON if already sent
00:00001680 6614            	   204: 	bne	  		.sgc2            		; XON already sent?
00:00001682 123C0011        	   205: 	move.b		#XON,d1							; if <8 send an XON
00:00001686 423900100165    	   206: 	clr.b			SerRcvXoff					; clear XOFF status
00:0000168C 13C100100164    	   207: 	move.b		d1,SerRcvXon				; flag so we don't send it multiple times
00:00001692 6100009C        	   208: 	bsr				SerialPutChar				; send it
                            	   209: .sgc2:
00:00001696 323900100162    	   210: 	move.w		SerHeadRcv,d1				; check if anything is in buffer
00:0000169C B27900100160    	   211: 	cmp.w			SerTailRcv,d1
00:000016A2 6720            	   212: 	beq				.NoChars						; no?
00:000016A4 41F900101000    	   213: 	lea				SerRcvBuf,a0
00:000016AA 12301000        	   214: 	move.b		(a0,d1.w),d1				; get byte from buffer
00:000016AE 527900100162    	   215: 	addi.w		#1,SerHeadRcv
00:000016B4 02790FFF00100162	   216: 	andi.w		#$FFF,SerHeadRcv		; 4k wrap around
00:000016BC 0281000000FF    	   217: 	andi.l		#$FF,d1
00:000016C2 6002            	   218: 	bra				.Xit
                            	   219: .NoChars:
00:000016C4 72FF            	   220: 	moveq			#-1,d1
                            	   221: .Xit:
00:000016C6 C342            	   222: 	exg				d1,d2
00:000016C8 4E7A0FE0        	   223: 	movec			coreno,d0
00:000016CC 4840            	   224: 	swap			d0
00:000016CE 7202            	   225: 	moveq			#SERIAL_SEMA,d1
00:000016D0 61000D6A        	   226: 	bsr				UnlockSemaphore
00:000016D4 C541            	   227: 	exg				d2,d1
00:000016D6 241F            	   228: 	move.l		(a7)+,d2
00:000016D8 4E75            	   229: 	rts
                            	   230: 
                            	   231: ;------------------------------------------------------------------------------
                            	   232: ; SerialPeekChar
                            	   233: ;
                            	   234: ; Check the serial port buffer to see if there's a char available. If there's
                            	   235: ; a char available then return it. But don't update the buffer indexes. No need
                            	   236: ; to send an XON here.
                            	   237: ;
                            	   238: ; Stack Space:
                            	   239: ;		1 long word
                            	   240: ; Parameters:
                            	   241: ;		none
                            	   242: ; Modifies:
                            	   243: ;		d0,a0
                            	   244: ; Returns:
                            	   245: ;		d1 = character or -1
                            	   246: ;------------------------------------------------------------------------------
                            	   247: 
                            	   248: SerialPeekChar:
00:000016DA 2F02            	   249: 	move.l d2,-(a7)
00:000016DC 4E7A0FE0        	   250: 	movec	coreno,d0
00:000016E0 4840            	   251: 	swap d0
00:000016E2 7202            	   252: 	moveq	#SERIAL_SEMA,d1
00:000016E4 61000D1A        	   253: 	bsr	LockSemaphore
00:000016E8 343900100162    	   254: 	move.w SerHeadRcv,d2		; check if anything is in buffer
00:000016EE B47900100160    	   255: 	cmp.w	SerTailRcv,d2
00:000016F4 670C            	   256: 	beq	.NoChars				; no?
00:000016F6 41F900101000    	   257: 	lea	SerRcvBuf,a0
00:000016FC 14302000        	   258: 	move.b (a0,d2.w),d2		; get byte from buffer
00:00001700 6002            	   259: 	bra	.Xit
                            	   260: .NoChars:
00:00001702 74FF            	   261: 	moveq	#-1,d2
                            	   262: .Xit:
00:00001704 4E7A0FE0        	   263: 	movec	coreno,d0
00:00001708 4840            	   264: 	swap d0
00:0000170A 7202            	   265: 	moveq	#SERIAL_SEMA,d1
00:0000170C 61000D2E        	   266: 	bsr	UnlockSemaphore
00:00001710 2202            	   267: 	move.l	d2,d1
00:00001712 241F            	   268: 	move.l (a7)+,d2
00:00001714 4E75            	   269: 	rts
                            	   270: 
                            	   271: ;------------------------------------------------------------------------------
                            	   272: ; SerialPeekChar
                            	   273: ;		Get a character directly from the I/O port. This bypasses the input
                            	   274: ; buffer.
                            	   275: ;
                            	   276: ; Stack Space:
                            	   277: ;		0 words
                            	   278: ; Parameters:
                            	   279: ;		none
                            	   280: ; Modifies:
                            	   281: ;		d
                            	   282: ; Returns:
                            	   283: ;		d1 = character or -1
                            	   284: ;------------------------------------------------------------------------------
                            	   285: 
                            	   286: SerialPeekCharDirect:
00:00001716 1239FD060004    	   287: 	move.b	ACIA+ACIA_STAT,d1	; get serial status
00:0000171C 08010003        	   288: 	btst		#3,d1							; look for Rx not empty
00:00001720 670A            	   289: 	beq.s		.0001
00:00001722 7200            	   290: 	moveq.l	#0,d1							; clear upper bits of return value
00:00001724 1239FD060000    	   291: 	move.b	ACIA+ACIA_RX,d1		; get data from ACIA
00:0000172A 4E75            	   292: 	rts												; return
                            	   293: .0001:
00:0000172C 72FF            	   294: 	moveq		#-1,d1
00:0000172E 4E75            	   295: 	rts
                            	   296: 
                            	   297: ;------------------------------------------------------------------------------
                            	   298: ; SerialPutChar
                            	   299: ;		If there is a transmit buffer, adds the character to the transmit buffer
                            	   300: ; if it can, otherwise will wait for a byte to be freed up in the transmit
                            	   301: ; buffer (blocks).
                            	   302: ;		If there is no transmit buffer, put a character to the directly to the
                            	   303: ; serial transmitter. This routine blocks until the transmitter is empty. 
                            	   304: ;
                            	   305: ; Stack Space
                            	   306: ;		4 long words
                            	   307: ; Parameters:
                            	   308: ;		d1.b = character to put
                            	   309: ; Modifies:
                            	   310: ;		none
                            	   311: ;------------------------------------------------------------------------------
                            	   312: 
                            	   313: SerialPutChar:
                            	   314: .0004:
00:00001730 4A7900040CD8    	   315: 	tst.w serial_dcb+DCB_OUTBUFSIZE	; buffered output?
00:00001736 675C            	   316: 	beq.s SerialPutCharDirect
00:00001738 48E7E080        	   317: 	movem.l d0/d1/d2/a0,-(a7)
00:0000173C 4E7A0FE0        	   318: 	movec	coreno,d0
00:00001740 4840            	   319: 	swap d0
00:00001742 7202            	   320: 	moveq	#SERIAL_SEMA,d1
00:00001744 61000CBA        	   321: 	bsr	LockSemaphore
00:00001748 303900100166    	   322: 	move.w SerTailXmit,d0
00:0000174E 3400            	   323: 	move.w d0,d2
00:00001750 5240            	   324: 	addi.w #1,d0
00:00001752 B07900040CD8    	   325: 	cmp.w serial_dcb+DCB_OUTBUFSIZE,d0
00:00001758 6502            	   326: 	blo.s .0002
00:0000175A 4240            	   327: 	clr.w d0
                            	   328: .0002:
00:0000175C B07900100168    	   329: 	cmp.w SerHeadXmit,d0			; Is Xmit buffer full?
00:00001762 660E            	   330: 	bne.s .0003
00:00001764 4E7A0FE0        	   331: 	movec	coreno,d0						; buffer full, unlock semaphore and wait
00:00001768 4840            	   332: 	swap d0
00:0000176A 7202            	   333: 	moveq	#SERIAL_SEMA,d1
00:0000176C 61000CCE        	   334: 	bsr	UnlockSemaphore
00:00001770 60BE            	   335: 	bra.s .0004
                            	   336: .0003:
00:00001772 33C000100166    	   337: 	move.w d0,SerTailXmit			; update tail pointer
00:00001778 41F900102000    	   338: 	lea SerXmitBuf,a0
00:0000177E 11812000        	   339: 	move.b d1,(a0,d2.w)				; store byte in Xmit buffer
00:00001782 4E7A0FE0        	   340: 	movec	coreno,d0						; unlock semaphore
00:00001786 4840            	   341: 	swap d0
00:00001788 7202            	   342: 	moveq	#SERIAL_SEMA,d1
00:0000178A 61000CB0        	   343: 	bsr	UnlockSemaphore
00:0000178E 4CDF0107        	   344: 	movem.l (a7)+,d0/d1/d2/a0
00:00001792 4E75            	   345: 	rts
                            	   346: 
                            	   347: SerialPutCharDirect:
00:00001794 48E7C000        	   348: 	movem.l	d0/d1,-(a7)							; push d0,d1
                            	   349: .0001:
00:00001798 1039FD060004    	   350: 	move.b ACIA+ACIA_STAT,d0	; wait until the uart indicates tx empty
00:0000179E 08000004        	   351: 	btst #4,d0								; bit #4 of the status reg
00:000017A2 67F4            	   352: 	beq.s	.0001			    			; branch if transmitter is not empty
00:000017A4 13C1FD060000    	   353: 	move.b d1,ACIA+ACIA_TX		; send the byte
00:000017AA 4CDF0003        	   354: 	movem.l	(a7)+,d0/d1				; pop d0,d1
00:000017AE 4E75            	   355: 	rts
                            	   356: 	
                            	   357: ;------------------------------------------------------------------------------
                            	   358: ; Reverse the order of bytes in d1.
                            	   359: ;------------------------------------------------------------------------------
                            	   360: 
                            	   361: SerialRbo:
00:000017B0 E159            	   362: 	rol.w		#8,d1
00:000017B2 4841            	   363: 	swap		d1
00:000017B4 E159            	   364: 	rol.w		#8,d1
00:000017B6 4E75            	   365: 	rts
                            	   366: 
                            	   367: ;------------------------------------------------------------------------------
                            	   368: ; Calculate number of character in input buffer
                            	   369: ;
                            	   370: ; Returns:
                            	   371: ;		d0 = number of bytes in buffer.
                            	   372: ;------------------------------------------------------------------------------
                            	   373: 
                            	   374: SerialRcvCount:
00:000017B8 303900100160    	   375: 	move.w	SerTailRcv,d0
00:000017BE 907900100162    	   376: 	sub.w		SerHeadRcv,d0
00:000017C4 6C10            	   377: 	bge			.0001
00:000017C6 303C1000        	   378: 	move.w	#$1000,d0
00:000017CA 907900100162    	   379: 	sub.w		SerHeadRcv,d0
00:000017D0 D07900100160    	   380: 	add.w		SerTailRcv,d0
                            	   381: .0001:
00:000017D6 4E75            	   382: 	rts
                            	   383: 
                            	   384: ;------------------------------------------------------------------------------
                            	   385: ; Serial IRQ routine
                            	   386: ;
                            	   387: ; Keeps looping as long as it finds characters in the ACIA recieve buffer/fifo.
                            	   388: ; Received characters are buffered. If the buffer becomes full, new characters
                            	   389: ; will be lost.
                            	   390: ;
                            	   391: ; Parameters:
                            	   392: ;		none
                            	   393: ; Modifies:
                            	   394: ;		none
                            	   395: ; Returns:
                            	   396: ;		d1 = -1 if IRQ handled, otherwise zero
                            	   397: ;------------------------------------------------------------------------------
                            	   398: 
                            	   399: SerialIRQ:
00:000017D8 46FC2300        	   400: 	move.w	#$2300,sr						; disable lower level IRQs
00:000017DC 48E7E080        	   401: 	movem.l	d0/d1/d2/a0,-(a7)
00:000017E0 4E7A0FE0        	   402: 	movec	coreno,d0
00:000017E4 4840            	   403: 	swap d0
00:000017E6 7202            	   404: 	moveq	#SERIAL_SEMA,d1
00:000017E8 61000C16        	   405: 	bsr	LockSemaphore
                            	   406: sirqNxtByte:
00:000017EC 1239FD060004    	   407: 	move.b ACIA+ACIA_STAT,d1		; check the status
00:000017F2 08010003        	   408: 	btst #3,d1									; bit 3 = rx full
00:000017F6 6756            	   409: 	beq	notRxInt
00:000017F8 1239FD060000    	   410: 	move.b ACIA+ACIA_RX,d1
                            	   411: sirq0001:
00:000017FE 303900100160    	   412: 	move.w SerTailRcv,d0				; check if recieve buffer full
00:00001804 5240            	   413: 	addi.w #1,d0
00:00001806 02400FFF        	   414: 	andi.w #$FFF,d0
00:0000180A B07900100162    	   415: 	cmp.w	SerHeadRcv,d0
00:00001810 673C            	   416: 	beq	sirqRxFull
00:00001812 33C000100160    	   417: 	move.w d0,SerTailRcv				; update tail pointer
00:00001818 5340            	   418: 	subi.w #1,d0								; backup
00:0000181A 02400FFF        	   419: 	andi.w #$FFF,d0
00:0000181E 41F900101000    	   420: 	lea	SerRcvBuf,a0						; a0 = buffer address
00:00001824 11810000        	   421: 	move.b d1,(a0,d0.w)					; store recieved byte in buffer
00:00001828 4A3900100165    	   422: 	tst.b	SerRcvXoff						; check if xoff already sent
00:0000182E 66BC            	   423: 	bne	sirqNxtByte
00:00001830 6186            	   424: 	bsr	SerialRcvCount					; if more than 4080 chars in buffer
00:00001832 0C400FF0        	   425: 	cmpi.w #4080,d0
00:00001836 65B4            	   426: 	blo	sirqNxtByte
00:00001838 123C0013        	   427: 	move.b #XOFF,d1							; send an XOFF
00:0000183C 423900100164    	   428: 	clr.b	SerRcvXon							; clear XON status
00:00001842 13C100100165    	   429: 	move.b d1,SerRcvXoff				; set XOFF status
00:00001848 6100FEE6        	   430: 	bsr	SerialPutChar						; send XOFF
00:0000184C 609E            	   431: 	bra	sirqNxtByte     				; check the status for another byte
                            	   432: sirqRxFull:
                            	   433: notRxInt:
00:0000184E 08010004        	   434: 	btst #4,d1									; TX empty?
00:00001852 6748            	   435: 	beq.s notTxInt
00:00001854 4A390010016A    	   436: 	tst.b SerXmitXoff						; and allowed to send?
00:0000185A 6640            	   437: 	bne.s sirqXmitOff
00:0000185C 4AB900040CD8    	   438: 	tst.l serial_dcb+DCB_OUTBUFSIZE	; Is there a buffer being transmitted?
00:00001862 6738            	   439: 	beq.s notTxInt
00:00001864 303900100168    	   440: 	move.w SerHeadXmit,d0
00:0000186A B07900100166    	   441: 	cmp.w SerTailXmit,d0
00:00001870 672A            	   442: 	beq.s sirqTxEmpty
00:00001872 41F900102000    	   443: 	lea SerXmitBuf,a0
00:00001878 12300000        	   444: 	move.b (a0,d0.w),d1
00:0000187C 13C1FD060000    	   445: 	move.b d1,ACIA+ACIA_TX			; transmit character
00:00001882 527900100168    	   446: 	addi.w #1,SerHeadXmit				; advance head index
00:00001888 303900040CD8    	   447: 	move.w serial_dcb+DCB_OUTBUFSIZE,d0
00:0000188E B07900100168    	   448: 	cmp.w SerHeadXmit,d0
00:00001894 6206            	   449: 	bhi.s sirq0002
00:00001896 427900100168    	   450: 	clr.w SerHeadXmit						; wrap around
                            	   451: sirq0002:
                            	   452: sirqXmitOff:
                            	   453: sirqTxEmpty:
                            	   454: notTxInt:
00:0000189C 4E7A0FE0        	   455: 	movec	coreno,d0
00:000018A0 4840            	   456: 	swap d0
00:000018A2 7202            	   457: 	moveq	#SERIAL_SEMA,d1
00:000018A4 61000B96        	   458: 	bsr	UnlockSemaphore
00:000018A8 4CDF0107        	   459: 	movem.l	(a7)+,d0/d1/d2/a0
00:000018AC 4E73            	   460: 	rte
                            	   461: 
                            	   462: nmeSerial:
00:000018AE 53657269616C    	   463: 	dc.b		"Serial",0
00:000018B4 00
                            	   464: 
                            	   465: 

Source: "boot.x68"
                            	   577: 	include "framebuf.x68"

Source: "framebuf.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: FRAMEBUF_CTRL equ 0
                            	    38: FRAMEBUF_WINDOW_DIMEN	equ	15*8
                            	    39: FRAMEBUF_COLOR_COMP	equ 19*8
                            	    40: 
                            	    41: ;------------------------------------------------------------------------------
                            	    42: ;------------------------------------------------------------------------------
                            	    43: ; Video frame buffer
                            	    44: ;------------------------------------------------------------------------------
                            	    45: ;------------------------------------------------------------------------------
                            	    46: 	code
                            	    47: 	even
                            	    48: 	align 2
                            	    49: FRAMEBUF_CMDTBL:
00:000018B8 000019D4        	    50: 	dc.l framebuf_init				; 0
00:000018BC 00001A82        	    51: 	dc.l framebuf_stat
00:000018C0 00001A82        	    52: 	dc.l framebuf_putchar
00:000018C4 00001B34        	    53: 	dc.l framebuf_putbuf
00:000018C8 00001A82        	    54: 	dc.l framebuf_getchar
00:000018CC 00001B34        	    55: 	dc.l framebuf_getbuf
00:000018D0 00001A84        	    56: 	dc.l framebuf_set_inpos
00:000018D4 00001A92        	    57: 	dc.l framebuf_set_outpos
00:000018D8 00001B34        	    58: 	dc.l framebuf_stub
00:000018DC 00001B34        	    59: 	dc.l framebuf_stub
00:000018E0 00001B34        	    60: 	dc.l framebuf_stub				; 10
00:000018E4 00001B34        	    61: 	dc.l framebuf_stub
00:000018E8 00001CCC        	    62: 	dc.l framebuf_clear
00:000018EC 00001ACC        	    63: 	dc.l framebuf_swapbuf
00:000018F0 00001AB0        	    64: 	dc.l framebuf_setbuf1
00:000018F4 00001ABE        	    65: 	dc.l framebuf_setbuf2
00:000018F8 00001AA0        	    66: 	dc.l framebuf_getbuf1
00:000018FC 00001AA8        	    67: 	dc.l framebuf_getbuf2
00:00001900 00001BD4        	    68: 	dc.l framebuf_writeat
00:00001904 00001B2A        	    69: 	dc.l framebuf_set_unit
00:00001908 00001B5A        	    70: 	dc.l framebuf_get_dimen	; 20
00:0000190C 00001B4A        	    71: 	dc.l framebuf_get_color
00:00001910 00001B34        	    72: 	dc.l framebuf_stub
00:00001914 00001B34        	    73: 	dc.l framebuf_stub
00:00001918 00001B34        	    74: 	dc.l framebuf_stub
00:0000191C 00001B34        	    75: 	dc.l framebuf_stub
00:00001920 00001B34        	    76: 	dc.l framebuf_stub
00:00001924 00001B34        	    77: 	dc.l framebuf_stub
00:00001928 00001B34        	    78: 	dc.l framebuf_stub
00:0000192C 00001B34        	    79: 	dc.l framebuf_stub
00:00001930 00001B34        	    80: 	dc.l framebuf_stub			; 30
00:00001934 00001B34        	    81: 	dc.l framebuf_stub
00:00001938 00001B8A        	    82: 	dc.l framebuf_set_dimen
00:0000193C 00001B38        	    83: 	dc.l framebuf_set_color_depth
                            	    84: 
                            	    85: 	code
                            	    86: 	even
                            	    87: framebuf_cmdproc:
00:00001940 0C060022        	    88: 	cmpi.b #34,d6
00:00001944 6418            	    89: 	bhs.s .0001
00:00001946 48E70280        	    90: 	movem.l d6/a0,-(a7)
00:0000194A 4886            	    91: 	ext.w d6
00:0000194C E546            	    92: 	asl.w #2,d6
00:0000194E 41FAFF68        	    93: 	lea FRAMEBUF_CMDTBL,a0
00:00001952 20706000        	    94: 	move.l (a0,d6.w),a0
00:00001956 4E90            	    95: 	jsr (a0)
00:00001958 4CDF0140        	    96: 	movem.l (a7)+,d6/a0
00:0000195C 4E75            	    97: 	rts
                            	    98: .0001:
00:0000195E 7002            	    99: 	moveq #E_Func,d0
00:00001960 4E75            	   100: 	rts
                            	   101: 
                            	   102: setup_framebuf:
00:00001962 48E780C0        	   103: 	movem.l d0/a0/a1,-(a7)
00:00001966 7020            	   104: 	moveq #32,d0
00:00001968 41F900040D18    	   105: 	lea.l framebuf_dcb,a0
                            	   106: .0001:
00:0000196E 4298            	   107: 	clr.l (a0)+
00:00001970 51C8FFFC        	   108: 	dbra d0,.0001
00:00001974 23FC444342200004	   109: 	move.l #$44434220,framebuf_dcb+DCB_MAGIC			; 'DCB '
00:0000197C 0D18
00:0000197E 23FC4652414D0004	   110: 	move.l #$4652414D,framebuf_dcb+DCB_NAME				; 'FRAMEBUF'
00:00001986 0D1C
00:00001988 23FC425546000004	   111: 	move.l #$42554600,framebuf_dcb+DCB_NAME+4
00:00001990 0D20
00:00001992 23FC000019400004	   112: 	move.l #framebuf_cmdproc,framebuf_dcb+DCB_CMDPROC
00:0000199A 0D30
00:0000199C 203C40000000    	   113: 	move.l #$40000000,d0
00:000019A2 23C000040D50    	   114: 	move.l d0,framebuf_dcb+DCB_INBUFPTR
00:000019A8 23C000040D54    	   115: 	move.l d0,framebuf_dcb+DCB_OUTBUFPTR
00:000019AE 23FC004000000004	   116: 	move.l #$00400000,framebuf_dcb+DCB_INBUFSIZE
00:000019B6 0D58
00:000019B8 23FC004000000004	   117: 	move.l #$00400000,framebuf_dcb+DCB_OUTBUFSIZE
00:000019C0 0D5C
00:000019C2 43F900040D18    	   118: 	lea.l framebuf_dcb+DCB_MAGIC,a1
00:000019C8 61005CC6        	   119: 	jsr DisplayString
00:000019CC 61005CA8        	   120: 	jsr CRLF
00:000019D0 4CDF0301        	   121: 	movem.l (a7)+,d0/a0/a1
                            	   122: 	; fall through
                            	   123: 
                            	   124: framebuf_init:
00:000019D4 13FC0001FD200000	   125: 	move.b #1,FRAMEBUF+0		; turn on frame buffer
00:000019DC 13FC0001FD200001	   126: 	move.b #1,FRAMEBUF+1		; color depth 16 BPP
00:000019E4 13FC0011FD200002	   127: 	move.b #$11,FRAMEBUF+2	; hres 1:1 vres 1:1
00:000019EC 13FC0077FD200004	   128: 	move.b #119,FRAMEBUF+4		; burst length
00:000019F4 23FC0000FF3F0004	   129: 	move.l #$ff3f,framebuf_dcb+DCB_FGCOLOR	; white
00:000019FC 0D7C
00:000019FE 23FC0000000F0004	   130: 	move.l #$000f,framebuf_dcb+DCB_BKCOLOR	; medium blue
00:00001A06 0D78
00:00001A08 42B900040D38    	   131: 	clr.l framebuf_dcb+DCB_OUTPOSX
00:00001A0E 42B900040D3C    	   132: 	clr.l framebuf_dcb+DCB_OUTPOSY
00:00001A14 42B900040D44    	   133: 	clr.l framebuf_dcb+DCB_INPOSX
00:00001A1A 42B900040D48    	   134: 	clr.l framebuf_dcb+DCB_INPOSY
00:00001A20 13FC000100040D80	   135: 	move.b #1,framebuf_dcb+DCB_OPCODE	; raster op = copy
00:00001A28 33FC078000040D6C	   136: 	move.w #1920,framebuf_dcb+DCB_OUTDIMX		; set rows and columns
00:00001A30 33FC043800040D70	   137: 	move.w #1080,framebuf_dcb+DCB_OUTDIMY
00:00001A38 33FC078000040D60	   138: 	move.w #1920,framebuf_dcb+DCB_INDIMX			; set rows and columns
00:00001A40 33FC043800040D64	   139: 	move.w #1080,framebuf_dcb+DCB_INDIMY
00:00001A48 23FC400000000004	   140: 	move.l #$40000000,framebuf_dcb+DCB_INBUFPTR
00:00001A50 0D50
00:00001A52 23FC404000000004	   141: 	move.l #$40400000,framebuf_dcb+DCB_INBUFPTR2
00:00001A5A 0D88
00:00001A5C 23FC400000000004	   142: 	move.l #$40000000,framebuf_dcb+DCB_OUTBUFPTR
00:00001A64 0D54
00:00001A66 23FC404000000004	   143: 	move.l #$40400000,framebuf_dcb+DCB_OUTBUFPTR2
00:00001A6E 0D8C
00:00001A70 42B9FD200010    	   144: 	move.l #$00000000,FRAMEBUF+16	; base addr 1
00:00001A76 23FC00004000FD20	   145: 	move.l #$00004000,FRAMEBUF+24	; base addr 2
00:00001A7E 0018
00:00001A80 4E75            	   146: 	rts
                            	   147: 
                            	   148: framebuf_stat:
                            	   149: framebuf_putchar:
                            	   150: framebuf_getchar:
00:00001A82 4E75            	   151: 	rts
                            	   152: 
                            	   153: framebuf_set_inpos:
00:00001A84 23C100040D44    	   154: 	move.l d1,framebuf_dcb+DCB_INPOSX
00:00001A8A 23C200040D48    	   155: 	move.l d2,framebuf_dcb+DCB_INPOSY
00:00001A90 4E75            	   156: 	rts
                            	   157: framebuf_set_outpos:
00:00001A92 23C100040D38    	   158: 	move.l d1,framebuf_dcb+DCB_OUTPOSX
00:00001A98 23C200040D3C    	   159: 	move.l d2,framebuf_dcb+DCB_OUTPOSY
00:00001A9E 4E75            	   160: 	rts
                            	   161: 
                            	   162: framebuf_getbuf1:
00:00001AA0 223900040D54    	   163: 	move.l framebuf_dcb+DCB_OUTBUFPTR,d1
00:00001AA6 4E75            	   164: 	rts
                            	   165: framebuf_getbuf2:
00:00001AA8 223900040D8C    	   166: 	move.l framebuf_dcb+DCB_OUTBUFPTR2,d1
00:00001AAE 4E75            	   167: 	rts
                            	   168: framebuf_setbuf1:
00:00001AB0 23C100040D54    	   169: 	move.l d1,framebuf_dcb+DCB_OUTBUFPTR
00:00001AB6 23C200040D5C    	   170: 	move.l d2,framebuf_dcb+DCB_OUTBUFSIZE
00:00001ABC 4E75            	   171: 	rts
                            	   172: framebuf_setbuf2:
00:00001ABE 23C100040D8C    	   173: 	move.l d1,framebuf_dcb+DCB_OUTBUFPTR2
00:00001AC4 23C200040D94    	   174: 	move.l d2,framebuf_dcb+DCB_OUTBUFSIZE2
00:00001ACA 4E75            	   175: 	rts
                            	   176: 
                            	   177: framebuf_swapbuf:
00:00001ACC 48E76000        	   178: 	movem.l d1/d2,-(a7)
00:00001AD0 1239FD200003    	   179: 	move.b FRAMEBUF+3,d1
00:00001AD6 0A010001        	   180: 	eor.b #1,d1
00:00001ADA 13C1FD200003    	   181: 	move.b d1,FRAMEBUF+3					; page flip
00:00001AE0 243900040D54    	   182: 	move.l framebuf_dcb+DCB_OUTBUFPTR,d2
00:00001AE6 203900040D8C    	   183: 	move.l framebuf_dcb+DCB_OUTBUFPTR2,d0
00:00001AEC 23C200040D8C    	   184: 	move.l d2,framebuf_dcb+DCB_OUTBUFPTR2
00:00001AF2 23C000040D54    	   185: 	move.l d0,framebuf_dcb+DCB_OUTBUFPTR
00:00001AF8 90BC40000000    	   186: 	sub.l #$40000000,d0
00:00001AFE 2200            	   187: 	move.l d0,d1
00:00001B00 610076D2        	   188: 	bsr rbo
00:00001B04 23C1FD300010    	   189: 	move.l d1,GFXACCEL+16
00:00001B0A 243900040D50    	   190: 	move.l framebuf_dcb+DCB_INBUFPTR,d2
00:00001B10 203900040D88    	   191: 	move.l framebuf_dcb+DCB_INBUFPTR2,d0
00:00001B16 23C200040D88    	   192: 	move.l d2,framebuf_dcb+DCB_INBUFPTR2
00:00001B1C 23C000040D50    	   193: 	move.l d0,framebuf_dcb+DCB_INBUFPTR
00:00001B22 4CDF0006        	   194: 	movem.l (a7)+,d1/d2
00:00001B26 7000            	   195: 	move.l #E_Ok,d0
00:00001B28 4E75            	   196: 	rts
                            	   197: 
                            	   198: framebuf_set_unit:
00:00001B2A 23C100040D98    	   199: 	move.l d1,framebuf_dcb+DCB_UNIT
00:00001B30 7000            	   200: 	move.l #E_Ok,d0
00:00001B32 4E75            	   201: 	rts
                            	   202: 
                            	   203: framebuf_getbuf:
                            	   204: framebuf_putbuf:
                            	   205: framebuf_stub:
00:00001B34 700A            	   206: 	moveq #E_NotSupported,d0
00:00001B36 4E75            	   207: 	rts
                            	   208: 
                            	   209: framebuf_set_color_depth:
00:00001B38 2001            	   210: 	move.l d1,d0
00:00001B3A 61007698        	   211: 	bsr rbo
00:00001B3E 23C1FD200098    	   212: 	move.l d1,FRAMEBUF+FRAMEBUF_COLOR_COMP
00:00001B44 2200            	   213: 	move.l d0,d1
00:00001B46 7000            	   214: 	move.l #E_Ok,d0
00:00001B48 4E75            	   215: 	rts
                            	   216: 	
                            	   217: framebuf_get_color:
00:00001B4A 223900040D7C    	   218: 	move.l framebuf_dcb+DCB_FGCOLOR,d1
00:00001B50 243900040D78    	   219: 	move.l framebuf_dcb+DCB_BKCOLOR,d2
00:00001B56 7000            	   220: 	move.l #E_Ok,d0
00:00001B58 4E75            	   221: 	rts
                            	   222: 
                            	   223: framebuf_get_dimen:
00:00001B5A 4A00            	   224: 	cmpi.b #0,d0
00:00001B5C 6616            	   225: 	bne.s .0001
00:00001B5E 223900040D6C    	   226: 	move.l framebuf_dcb+DCB_OUTDIMX,d1
00:00001B64 243900040D70    	   227: 	move.l framebuf_dcb+DCB_OUTDIMY,d2
00:00001B6A 263900040D74    	   228: 	move.l framebuf_dcb+DCB_OUTDIMZ,d3
00:00001B70 7000            	   229: 	move.l #E_Ok,d0
00:00001B72 4E75            	   230: 	rts
                            	   231: .0001:
00:00001B74 223900040D60    	   232: 	move.l framebuf_dcb+DCB_INDIMX,d1
00:00001B7A 243900040D64    	   233: 	move.l framebuf_dcb+DCB_INDIMY,d2
00:00001B80 263900040D68    	   234: 	move.l framebuf_dcb+DCB_INDIMZ,d3
00:00001B86 7000            	   235: 	move.l #E_Ok,d0
00:00001B88 4E75            	   236: 	rts
                            	   237: 
                            	   238: framebuf_set_dimen:
00:00001B8A 4A00            	   239: 	cmpi.b #0,d0
00:00001B8C 6630            	   240: 	bne.s .0001
00:00001B8E 48E76000        	   241: 	movem.l d1/d2,-(a7)
00:00001B92 23C100040D6C    	   242: 	move.l d1,framebuf_dcb+DCB_OUTDIMX
00:00001B98 23C200040D70    	   243: 	move.l d2,framebuf_dcb+DCB_OUTDIMY
00:00001B9E 23C300040D74    	   244: 	move.l d3,framebuf_dcb+DCB_OUTDIMZ
00:00001BA4 48C2            	   245: 	ext.l d2
00:00001BA6 4842            	   246: 	swap d2
00:00001BA8 48C1            	   247: 	ext.l d1
00:00001BAA 8282            	   248: 	or.l d2,d1
00:00001BAC 61007626        	   249: 	bsr rbo
00:00001BB0 23C1FD200078    	   250: 	move.l d1,FRAMEBUF+FRAMEBUF_WINDOW_DIMEN
00:00001BB6 4CDF0006        	   251: 	movem.l (a7)+,d1/d2
00:00001BBA 7000            	   252: 	move.l #E_Ok,d0
00:00001BBC 4E75            	   253: 	rts
                            	   254: .0001:
00:00001BBE 23C100040D60    	   255: 	move.l d1,framebuf_dcb+DCB_INDIMX
00:00001BC4 23C200040D64    	   256: 	move.l d2,framebuf_dcb+DCB_INDIMY
00:00001BCA 23C300040D68    	   257: 	move.l d3,framebuf_dcb+DCB_INDIMZ
00:00001BD0 7000            	   258: 	move.l #E_Ok,d0
00:00001BD2 4E75            	   259: 	rts
                            	   260: 
                            	   261: ;---------------------------------------------------------------------
                            	   262: ; The following uses point plot hardware built into the frame buffer.
                            	   263: ; It is assumed that previous commands have finished already.
                            	   264: ; It may take a few dozen clocks for a command to complete. As long
                            	   265: ; as this routine is not called to fast in succession it should be
                            	   266: ; okay.
                            	   267: ;---------------------------------------------------------------------
                            	   268: 
                            	   269: framebuf_writeat:
                            	   270: plot:
00:00001BD4 606E            	   271: 	bra plot_sw
00:00001BD6 48E76080        	   272: 	movem.l d1/d2/a0,-(a7)
00:00001BDA 207CFD200000    	   273: 	move.l #FRAMEBUF,a0
                            	   274: .0001:
                            	   275: ;	tst.b 40(a0)				; wait for any previous command to finish
                            	   276: ;	bne.s .0001										; Then set:
00:00001BE0 E159            	   277: 	rol.w #8,d1										; reverse byte order
00:00001BE2 31410020        	   278: 	move.w d1,32(a0)							; pixel x co-ord
00:00001BE6 E15A            	   279: 	rol.w #8,d2										; reverse byte order
00:00001BE8 31420022        	   280: 	move.w d2,34(a0)							; pixel y co-ord
00:00001BEC 317900040D7C002C	   281: 	move.w framebuf_dcb+DCB_FGCOLOR,44(a0)	; pixel color
00:00001BF4 117900040D800029	   282: 	move.b framebuf_dcb+DCB_OPCODE,41(a0)	; set raster operation
00:00001BFC 117C00020028    	   283: 	move.b #2,40(a0)							; point plot command
00:00001C02 4CDF0106        	   284: 	movem.l (a7)+,d1/d2/a0
00:00001C06 4E75            	   285: 	rts
                            	   286: 
                            	   287: ;-------------------------------------------
                            	   288: ; In case of lacking hardware plot
                            	   289: ;-------------------------------------------
                            	   290: 	align 2
                            	   291: plottbl:
00:00001C08 00001CB6        	   292: 	dc.l plot_black
00:00001C0C 00001CA8        	   293: 	dc.l plot_copy
00:00001C10 00001CA8        	   294: 	dc.l plot_copy
00:00001C14 00001C94        	   295: 	dc.l plot_and
00:00001C18 00001C6A        	   296: 	dc.l plot_or
00:00001C1C 00001C7E        	   297: 	dc.l plot_xor
00:00001C20 00001CA8        	   298: 	dc.l plot_copy
00:00001C24 00001CA8        	   299: 	dc.l plot_copy
00:00001C28 00001CA8        	   300: 	dc.l plot_copy
00:00001C2C 00001CA8        	   301: 	dc.l plot_copy
00:00001C30 00001CA8        	   302: 	dc.l plot_copy
00:00001C34 00001CA8        	   303: 	dc.l plot_copy
00:00001C38 00001CA8        	   304: 	dc.l plot_copy
00:00001C3C 00001CA8        	   305: 	dc.l plot_copy
00:00001C40 00001CC0        	   306: 	dc.l plot_white
                            	   307: 
                            	   308: plot_sw:
00:00001C44 48E778C0        	   309: 	movem.l d1/d2/d3/d4/a0/a1,-(a7)
00:00001C48 C4F900040D6C    	   310: 	mulu framebuf_dcb+DCB_OUTDIMX,d2	; multiply y by screen width
                            	   311: ;	move.l d1,d3
                            	   312: ;	andi.l #30,d3
                            	   313: ;	moveq #30,d4
                            	   314: ;	sub.l d4,d3
                            	   315: ;	andi.l #$FFFFFFE0,d1
                            	   316: ;	or.l d3,d1
00:00001C4E 48C1            	   317: 	ext.l d1											; clear high-order word of x
00:00001C50 D481            	   318: 	add.l d1,d2										; add in x co-ord
00:00001C52 D482            	   319: 	add.l d2,d2										; *2 for 16 BPP
00:00001C54 207900040D8C    	   320: 	move.l framebuf_dcb+DCB_OUTBUFPTR2,a0		; where the draw occurs
00:00001C5A 163900040D80    	   321: 	move.b framebuf_dcb+DCB_OPCODE,d3				; raster operation
00:00001C60 4883            	   322: 	ext.w d3
00:00001C62 E54B            	   323: 	lsl.w #2,d3
00:00001C64 227B30A2        	   324: 	move.l plottbl(pc,d3.w),a1
00:00001C68 4ED1            	   325: 	jmp (a1)
                            	   326: plot_or:
00:00001C6A 38302800        	   327: 	move.w (a0,d2.l),d4	
00:00001C6E 887900040D7C    	   328: 	or.w framebuf_dcb+DCB_FGCOLOR,d4
00:00001C74 31842800        	   329: 	move.w d4,(a0,d2.l)
00:00001C78 4CDF031E        	   330: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001C7C 4E75            	   331: 	rts
                            	   332: plot_xor:
00:00001C7E 38302800        	   333: 	move.w (a0,d2.l),d4
00:00001C82 363900040D7C    	   334: 	move.w framebuf_dcb+DCB_FGCOLOR,d3	
00:00001C88 B744            	   335: 	eor.w d3,d4
00:00001C8A 31842800        	   336: 	move.w d4,(a0,d2.l)
00:00001C8E 4CDF031E        	   337: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001C92 4E75            	   338: 	rts
                            	   339: plot_and:
00:00001C94 38302800        	   340: 	move.w (a0,d2.l),d4	
00:00001C98 C87900040D7C    	   341: 	and.w framebuf_dcb+DCB_FGCOLOR,d4
00:00001C9E 31842800        	   342: 	move.w d4,(a0,d2.l)
00:00001CA2 4CDF031E        	   343: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001CA6 4E75            	   344: 	rts
                            	   345: plot_copy:
00:00001CA8 31B900040D7C2800	   346: 	move.w framebuf_dcb+DCB_FGCOLOR,(a0,d2.l)
00:00001CB0 4CDF031E        	   347: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001CB4 4E75            	   348: 	rts
                            	   349: plot_black:
00:00001CB6 42702800        	   350: 	clr.w (a0,d2.l)
00:00001CBA 4CDF031E        	   351: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001CBE 4E75            	   352: 	rts
                            	   353: plot_white:
00:00001CC0 31BCFF7F2800    	   354: 	move.w #$FF7F,(a0,d2.l)
00:00001CC6 4CDF031E        	   355: 	movem.l (a7)+,d1/d2/d3/d4/a0/a1
00:00001CCA 4E75            	   356: 	rts
                            	   357: 
                            	   358: 
                            	   359: framebuf_clear:
00:00001CCC 48E76880        	   360: 	movem.l d1/d2/d4/a0,-(a7)
00:00001CD0 243900040D78    	   361: 	move.l framebuf_dcb+DCB_BKCOLOR,d2
00:00001CD6 2202            	   362: 	move.l d2,d1
00:00001CD8 E15A            	   363: 	rol.w #8,d2							; d2 = background color
00:00001CDA 4842            	   364: 	swap d2									; high bits = background color
00:00001CDC 3401            	   365: 	move.w d1,d2						; low bits = background color
00:00001CDE E15A            	   366: 	rol.w #8,d2
00:00001CE0 2802            	   367: 	move.l d2,d4						; save for later
00:00001CE2 207900040D8C    	   368: 	move.l framebuf_dcb+DCB_OUTBUFPTR2,a0		; where the draw occurs
00:00001CE8 42B97FFFFFF8    	   369: 	move.l #0,$7FFFFFF8			; set burst length zero
00:00001CEE 223900040D6C    	   370: 	move.l framebuf_dcb+DCB_OUTDIMX,d1
00:00001CF4 243900040D70    	   371: 	move.l framebuf_dcb+DCB_OUTDIMY,d2
00:00001CFA C2C2            	   372: 	mulu d2,d1							; X dimen * Y dimen
00:00001CFC E888            	   373: 	lsr.l #4,d0							; moving 16 pixels per iteration
00:00001CFE 6002            	   374: 	bra.s .loop
                            	   375: .loop2:
00:00001D00 4840            	   376: 	swap d0
                            	   377: .loop:
00:00001D02 2208            	   378: 	move.l a0,d1
00:00001D04 610074CE        	   379: 	bsr rbo
00:00001D08 23C17FFFFFF4    	   380: 	move.l d1,$7FFFFFF4			; set destination address
00:00001D0E 23C47FFFFFFC    	   381: 	move.l d4,$7FFFFFFC			; write value (color) to use and trigger write op
00:00001D14 41E80020        	   382: 	add.l #32,a0						; advance pointer
00:00001D18 51C8FFE8        	   383: 	dbra d0,.loop
00:00001D1C 4840            	   384: 	swap d0
00:00001D1E 51C8FFE0        	   385: 	dbra d0,.loop2
00:00001D22 4CDF0116        	   386: 	movem.l (a7)+,d1/d2/d4/a0
00:00001D26 7000            	   387: 	move.l #E_Ok,d0
00:00001D28 4E75            	   388: 	rts
                            	   389: 
                            	   390: ; The following code using bursts of 1k pixels did not work (hardware).
                            	   391: ;
                            	   392: ;clear_bitmap_screen2:
                            	   393: ;	move.l gr_bitmap_screen,a0
                            	   394: ;clear_bitmap_screen3:
                            	   395: ;	movem.l d0/d2/a0,-(a7)
                            	   396: ;	move.l #$3F3F3F3F,$BFFFFFF4	; 32x64 byte burst
                            	   397: ;	move.w pen_color,d0
                            	   398: ;	swap d0
                            	   399: ;	move.w pen_color,d0
                            	   400: ;	move.w gr_width,d2		; calc. number of pixels on screen
                            	   401: ;	mulu gr_height,d2
                            	   402: ;	add.l #1023,d2				; rounding up
                            	   403: ;	lsr.l #8,d2						; divide by 1024 pixel update
                            	   404: ;	lsr.l #2,d2
                            	   405: ;.0001:
                            	   406: ;	move.l a0,$BFFFFFF8		; write update address
                            	   407: ;	add.l #2048,a0				; update pointer
                            	   408: ;	move.l d0,$BFFFFFFC		; trigger burst write of 2048 bytes
                            	   409: ;	dbra d2,.0001
                            	   410: ;	movem.l (a7)+,d0/d2/a0
                            	   411: ;	rts
                            	   412: 
                            	   413: ; More conventional but slow way of clearing the screen.
                            	   414: ;
                            	   415: ;clear_bitmap_screen:
                            	   416: ;	move.l gr_bitmap_screen,a0
                            	   417: ;clear_bitmap_screen1:
                            	   418: ;	movem.l d0/d2/a0,-(a7)
                            	   419: ;	move.w pen_color,d0
                            	   420: ;	swap d0
                            	   421: ;	move.w pen_color,d0
                            	   422: ;	move.w gr_width,d2		; calc. number of pixels on screen
                            	   423: ;	mulu gr_height,d2			; 800x600 = 480000
                            	   424: ;	bra.s .0001
                            	   425: ;.0002:
                            	   426: ;	swap d2
                            	   427: ;.0001:
                            	   428: ;	move.l d0,(a0)+
                            	   429: ;	dbra d2,.0001
                            	   430: ;	swap d2
                            	   431: ;	dbra d2,.0002
                            	   432: ;	movem.l (a7)+,d0/d2/a0
                            	   433: ;	rts
                            	   434: 
                            	   435: 

Source: "boot.x68"
                            	   578: 	include "gfxaccel.x68"

Source: "gfxaccel.x68"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2025  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: 
                            	    37: GFX_CTRL		equ	$00
                            	    38: GFX_STATUS	equ $04
                            	    39: GFX_TARGET_BASE		equ $10
                            	    40: GFX_TARGET_SIZE_X	equ $14
                            	    41: GFX_TARGET_SIZE_Y equ $18
                            	    42: GFX_DEST_PIXEL_X  equ $38
                            	    43: GFX_DEST_PIXEL_Y  equ $3c
                            	    44: GFX_DEST_PIXEL_Z  equ $40
                            	    45: GFX_CLIP_PIXEL0_X	equ $74
                            	    46: GFX_CLIP_PIXEL0_Y	equ $78
                            	    47: GFX_CLIP_PIXEL1_X	equ $7C
                            	    48: GFX_CLIP_PIXEL1_Y	equ $80
                            	    49: GFX_COLOR0	equ $84
                            	    50: GFX_COLOR1	equ $88
                            	    51: GFX_COLOR2	equ $8C
                            	    52: GFX_TARGET_X0	equ $B0
                            	    53: GFX_TARGET_Y0 equ $B4
                            	    54: GFX_TARGET_X1	equ $B8
                            	    55: GFX_TARGET_Y1	equ $BC
                            	    56: 
                            	    57: ;------------------------------------------------------------------------------
                            	    58: ;------------------------------------------------------------------------------
                            	    59: ; Graphics accelerator
                            	    60: ;------------------------------------------------------------------------------
                            	    61: ;------------------------------------------------------------------------------
                            	    62: 	align 2
                            	    63: GFXACCEL_CMDTBL:
00:00001D2C 00001E48        	    64: 	dc.l gfxaccel_init				; 0
00:00001D30 00001EB0        	    65: 	dc.l gfxaccel_stat
00:00001D34 00001EC2        	    66: 	dc.l gfxaccel_putchar
00:00001D38 00001EC2        	    67: 	dc.l gfxaccel_putbuf
00:00001D3C 00001EC2        	    68: 	dc.l gfxaccel_getchar
00:00001D40 00001EC2        	    69: 	dc.l gfxaccel_getbuf
00:00001D44 00001EC2        	    70: 	dc.l gfxaccel_set_inpos
00:00001D48 00001EC2        	    71: 	dc.l gfxaccel_set_outpos
00:00001D4C 00001EC2        	    72: 	dc.l gfxaccel_stub
00:00001D50 00001EC2        	    73: 	dc.l gfxaccel_stub
00:00001D54 00001EC2        	    74: 	dc.l gfxaccel_stub				; 10
00:00001D58 00001EC2        	    75: 	dc.l gfxaccel_stub
00:00001D5C 00001EBE        	    76: 	dc.l gfxaccel_clear
00:00001D60 00001EC2        	    77: 	dc.l gfxaccel_swapbuf
00:00001D64 00001EC2        	    78: 	dc.l gfxaccel_setbuf1
00:00001D68 00001EC2        	    79: 	dc.l gfxaccel_setbuf2
00:00001D6C 00001EC2        	    80: 	dc.l gfxaccel_getbuf1
00:00001D70 00001EC2        	    81: 	dc.l gfxaccel_getbuf2
00:00001D74 00001EC2        	    82: 	dc.l gfxaccel_writeat
00:00001D78 00001EC2        	    83: 	dc.l gfxaccel_set_unit
00:00001D7C 00001EC2        	    84: 	dc.l gfxaccel_get_dimen	; 20
00:00001D80 00001F1C        	    85: 	dc.l gfxaccel_get_color
00:00001D84 00001EC2        	    86: 	dc.l gfxaccel_get_inpos
00:00001D88 00001EC2        	    87: 	dc.l gfxaccel_get_outpos
00:00001D8C 00001EC2        	    88: 	dc.l gfxaccel_get_outptr
00:00001D90 00001F26        	    89: 	dc.l gfxaccel_set_color
00:00001D94 00001F46        	    90: 	dc.l gfxaccel_set_color123
00:00001D98 00001FEE        	    91: 	dc.l gfxaccel_plot_point
00:00001D9C 00002044        	    92: 	dc.l gfxaccel_draw_line
00:00001DA0 00002114        	    93: 	dc.l gfxaccel_draw_triangle
00:00001DA4 000020AC        	    94: 	dc.l gfxaccel_draw_rectangle	;30
00:00001DA8 0000219C        	    95: 	dc.l gfxaccel_draw_curve
00:00001DAC 00001EC6        	    96: 	dc.l gfxaccel_set_dimen
00:00001DB0 00001EFA        	    97: 	dc.l gfxaccel_set_color_depth
                            	    98: 
                            	    99: 	code
                            	   100: 	even
                            	   101: 
                            	   102: gfxaccel_cmdproc:
00:00001DB4 0C060022        	   103: 	cmpi.b #34,d6
00:00001DB8 6418            	   104: 	bhs.s .0001
00:00001DBA 48E70280        	   105: 	movem.l d6/a0,-(a7)
00:00001DBE 4886            	   106: 	ext.w d6
00:00001DC0 E54E            	   107: 	lsl.w #2,d6
00:00001DC2 41FAFF68        	   108: 	lea GFXACCEL_CMDTBL,a0
00:00001DC6 20706000        	   109: 	move.l (a0,d6.w),a0
00:00001DCA 4E90            	   110: 	jsr (a0)
00:00001DCC 4CDF0140        	   111: 	movem.l (a7)+,d6/a0
00:00001DD0 4E75            	   112: 	rts
                            	   113: .0001:
00:00001DD2 7002            	   114: 	moveq #E_Func,d0
00:00001DD4 4E75            	   115: 	rts
                            	   116: 
                            	   117: setup_gfxaccel:
00:00001DD6 48E780C0        	   118: 	movem.l d0/a0/a1,-(a7)
00:00001DDA 7020            	   119: 	moveq #32,d0
00:00001DDC 41F900040D9C    	   120: 	lea.l gfxaccel_dcb,a0
                            	   121: .0001:
00:00001DE2 4298            	   122: 	clr.l (a0)+
00:00001DE4 51C8FFFC        	   123: 	dbra d0,.0001
00:00001DE8 23FC444342200004	   124: 	move.l #$44434220,gfxaccel_dcb+DCB_MAGIC			; 'DCB'
00:00001DF0 0D9C
00:00001DF2 23FC474658410004	   125: 	move.l #$47465841,gfxaccel_dcb+DCB_NAME				; 'GFXACCEL'
00:00001DFA 0DA0
00:00001DFC 23FC4343454C0004	   126: 	move.l #$4343454C,gfxaccel_dcb+DCB_NAME+4
00:00001E04 0DA4
00:00001E06 23FC00001DB40004	   127: 	move.l #gfxaccel_cmdproc,gfxaccel_dcb+DCB_CMDPROC
00:00001E0E 0DB4
00:00001E10 203C40000000    	   128: 	move.l #$40000000,d0
00:00001E16 23C000040DD4    	   129: 	move.l d0,gfxaccel_dcb+DCB_INBUFPTR
00:00001E1C 23C000040DD8    	   130: 	move.l d0,gfxaccel_dcb+DCB_OUTBUFPTR
00:00001E22 23FC004000000004	   131: 	move.l #$00400000,gfxaccel_dcb+DCB_INBUFSIZE
00:00001E2A 0DDC
00:00001E2C 23FC004000000004	   132: 	move.l #$00400000,gfxaccel_dcb+DCB_OUTBUFSIZE
00:00001E34 0DE0
00:00001E36 43F900040D9C    	   133: 	lea.l gfxaccel_dcb+DCB_MAGIC,a1
00:00001E3C 61005852        	   134: 	jsr DisplayString
00:00001E40 61005834        	   135: 	jsr CRLF
00:00001E44 4CDF0301        	   136: 	movem.l (a7)+,d0/a0/a1
                            	   137: 
                            	   138: gfxaccel_init:
00:00001E48 2F01            	   139: 	move.l d1,-(a7)
00:00001E4A 720A            	   140: 	moveq #10,d1
00:00001E4C 610003D4        	   141: 	bsr gfxaccel_wait
00:00001E50 42B9000408C0    	   142: 	clr.l gfxaccel_ctrl
00:00001E56 7201            	   143: 	move.l #1,d1
00:00001E58 23C1000408C0    	   144: 	move.l d1,gfxaccel_ctrl
00:00001E5E 61007374        	   145: 	bsr rbo
00:00001E62 23C1FD300000    	   146: 	move.l d1,GFXACCEL+GFX_CTRL	; select 16bpp color
00:00001E68 7200            	   147: 	move.l #$00000000,d1
00:00001E6A 61007368        	   148: 	bsr rbo
00:00001E6E 23C1FD300010    	   149: 	move.l d1,GFXACCEL+GFX_TARGET_BASE	; base draw address
00:00001E74 223C00000780    	   150: 	move.l #1920,d1
00:00001E7A 61007358        	   151: 	bsr rbo
00:00001E7E 23C1FD300014    	   152: 	move.l d1,GFXACCEL+GFX_TARGET_SIZE_X	; render target x dimension
00:00001E84 23C1FD3000B8    	   153: 	move.l d1,GFXACCEL+GFX_TARGET_X1
00:00001E8A 223C00000438    	   154: 	move.l #1080,d1
00:00001E90 61007342        	   155: 	bsr rbo
00:00001E94 23C1FD300018    	   156: 	move.l d1,GFXACCEL+GFX_TARGET_SIZE_Y	; render target y dimension
00:00001E9A 23C1FD3000BC    	   157: 	move.l d1,GFXACCEL+GFX_TARGET_Y1
00:00001EA0 42B9FD3000B0    	   158: 	move.l #0,GFXACCEL+GFX_TARGET_X0
00:00001EA6 42B9FD3000B4    	   159: 	move.l #0,GFXACCEL+GFX_TARGET_Y0
00:00001EAC 221F            	   160: 	move.l (a7)+,d1
00:00001EAE 4E75            	   161: 	rts
                            	   162: 
                            	   163: gfxaccel_stat:
00:00001EB0 2239FD300004    	   164: 	move.l GFXACCEL+GFX_STATUS,d1
00:00001EB6 6100731C        	   165: 	bsr rbo
00:00001EBA 7000            	   166: 	moveq #E_Ok,d0
00:00001EBC 4E75            	   167: 	rts
                            	   168: 	
                            	   169: gfxaccel_clear:
00:00001EBE 7000            	   170: 	moveq #E_Ok,d0
00:00001EC0 4E75            	   171: 	rts
                            	   172: 
                            	   173: gfxaccel_putchar:
                            	   174: gfxaccel_getchar:
                            	   175: gfxaccel_putbuf:
                            	   176: gfxaccel_getbuf:
                            	   177: gfxaccel_set_inpos:
                            	   178: gfxaccel_set_outpos:
                            	   179: gfxaccel_stub:
                            	   180: gfxaccel_swapbuf:
                            	   181: gfxaccel_setbuf1:
                            	   182: gfxaccel_setbuf2:
                            	   183: gfxaccel_getbuf1:
                            	   184: gfxaccel_getbuf2:
                            	   185: gfxaccel_writeat:
                            	   186: gfxaccel_set_unit:
                            	   187: gfxaccel_get_dimen:
                            	   188: gfxaccel_get_inpos:
                            	   189: gfxaccel_get_outpos:
                            	   190: gfxaccel_get_outptr:
00:00001EC2 700A            	   191: 	move.l #E_NotSupported,d0
00:00001EC4 4E75            	   192: 	rts
                            	   193: 
                            	   194: gfxaccel_set_dimen:
00:00001EC6 2F01            	   195: 	move.l d1,-(a7)
00:00001EC8 2001            	   196: 	move.l d1,d0
00:00001ECA 7206            	   197: 	moveq #6,d1
00:00001ECC 61000354        	   198: 	bsr gfxaccel_wait					; wait for an open slot
00:00001ED0 2200            	   199: 	move.l d0,d1
00:00001ED2 61007300        	   200: 	bsr rbo
00:00001ED6 23C1FD300014    	   201: 	move.l d1,GFXACCEL+GFX_TARGET_SIZE_X	; render target x dimension
00:00001EDC 23C1FD3000B8    	   202: 	move.l d1,GFXACCEL+GFX_TARGET_X1
00:00001EE2 2202            	   203: 	move.l d2,d1
00:00001EE4 610072EE        	   204: 	bsr rbo
00:00001EE8 23C1FD300018    	   205: 	move.l d1,GFXACCEL+GFX_TARGET_SIZE_Y	; render target y dimension
00:00001EEE 23C1FD3000BC    	   206: 	move.l d1,GFXACCEL+GFX_TARGET_Y1
00:00001EF4 221F            	   207: 	move.l (a7)+,d1
00:00001EF6 7000            	   208: 	moveq #E_Ok,d0
00:00001EF8 4E75            	   209: 	rts
                            	   210: 
                            	   211: gfxaccel_set_color_depth:
00:00001EFA 2001            	   212: 	move.l d1,d0
00:00001EFC 02010003        	   213: 	andi.b #3,d1
00:00001F00 82B9000408C0    	   214: 	or.l gfxaccel_ctrl,d1
00:00001F06 23C1000408C0    	   215: 	move.l d1,gfxaccel_ctrl
00:00001F0C 610072C6        	   216: 	bsr rbo
00:00001F10 23C1FD300000    	   217: 	move.l d1,GFXACCEL+GFX_CTRL
00:00001F16 2200            	   218: 	move.l d0,d1
00:00001F18 7000            	   219: 	moveq #E_Ok,d0
00:00001F1A 4E75            	   220: 	rts
                            	   221: 	
                            	   222: gfxaccel_get_color:
00:00001F1C 2239FD300084    	   223: 	move.l GFXACCEL+GFX_COLOR0,d1
00:00001F22 7000            	   224: 	moveq #E_Ok,d0
00:00001F24 4E75            	   225: 	rts
                            	   226: 
                            	   227: gfxaccel_set_color:
00:00001F26 48E75000        	   228: 	movem.l d1/d3,-(a7)
00:00001F2A 2601            	   229: 	move.l d1,d3
00:00001F2C 7203            	   230: 	moveq #3,d1
00:00001F2E 610002F2        	   231: 	bsr gfxaccel_wait					; wait for an open slot
00:00001F32 2203            	   232: 	move.l d3,d1
00:00001F34 6100729E        	   233: 	bsr rbo
00:00001F38 23C1FD300084    	   234: 	move.l d1,GFXACCEL+GFX_COLOR0
00:00001F3E 4CDF000A        	   235: 	movem.l (a7)+,d1/d3
00:00001F42 7000            	   236: 	moveq #E_Ok,d0
00:00001F44 4E75            	   237: 	rts
                            	   238: 
                            	   239: gfxaccel_set_color123:
00:00001F46 48E74800        	   240: 	movem.l d1/d4,-(a7)
00:00001F4A 2801            	   241: 	move.l d1,d4
00:00001F4C 7205            	   242: 	moveq #5,d1
00:00001F4E 610002D2        	   243: 	bsr gfxaccel_wait					; wait for an open slot
00:00001F52 2204            	   244: 	move.l d4,d1
00:00001F54 6100727E        	   245: 	bsr rbo
00:00001F58 23C1FD300084    	   246: 	move.l d1,GFXACCEL+GFX_COLOR0
00:00001F5E 2202            	   247: 	move.l d2,d1
00:00001F60 61007272        	   248: 	bsr rbo
00:00001F64 23C1FD300088    	   249: 	move.l d1,GFXACCEL+GFX_COLOR1
00:00001F6A 2203            	   250: 	move.l d3,d1
00:00001F6C 61007266        	   251: 	bsr rbo
00:00001F70 23C1FD30008C    	   252: 	move.l d1,GFXACCEL+GFX_COLOR2
00:00001F76 4CDF0012        	   253: 	movem.l (a7)+,d1/d4
00:00001F7A 7000            	   254: 	moveq #E_Ok,d0
00:00001F7C 4E75            	   255: 	rts
                            	   256: 
                            	   257: gfxaccel_clip_rect:
00:00001F7E 48E74400        	   258: 	movem.l d1/d5,-(a7)
00:00001F82 2A01            	   259: 	move.l d1,d5
00:00001F84 7206            	   260: 	moveq #6,d1
00:00001F86 6100029A        	   261: 	bsr gfxaccel_wait					; wait for an open slot
00:00001F8A 2205            	   262: 	move.l d5,d1
00:00001F8C 61007246        	   263: 	bsr rbo
00:00001F90 23C1FD300074    	   264: 	move.l d1,GFXACCEL+GFX_CLIP_PIXEL0_X
00:00001F96 2202            	   265: 	move.l d2,d1
00:00001F98 6100723A        	   266: 	bsr rbo
00:00001F9C 23C1FD300078    	   267: 	move.l d1,GFXACCEL+GFX_CLIP_PIXEL0_Y
00:00001FA2 2203            	   268: 	move.l d3,d1
00:00001FA4 6100722E        	   269: 	bsr rbo
00:00001FA8 23C1FD30007C    	   270: 	move.l d1,GFXACCEL+GFX_CLIP_PIXEL1_X
00:00001FAE 2204            	   271: 	move.l d4,d1
00:00001FB0 61007222        	   272: 	bsr rbo
00:00001FB4 23C1FD300080    	   273: 	move.l d1,GFXACCEL+GFX_CLIP_PIXEL1_Y
00:00001FBA 4CDF0022        	   274: 	movem.l (a7)+,d1/d5
00:00001FBE 7000            	   275: 	moveq #E_Ok,d0
00:00001FC0 4E75            	   276: 	rts
                            	   277: 
                            	   278: ; Parameters:
                            	   279: ;		d2.b = active point to set
                            	   280: ;
                            	   281: gfxaccel_set_active_point:
00:00001FC2 4882            	   282: 	ext.w d2
00:00001FC4 48C2            	   283: 	ext.l d2
00:00001FC6 4842            	   284: 	swap d2													; point number in bits 16,17
00:00001FC8 2239000408C0    	   285: 	move.l gfxaccel_ctrl,d1
00:00001FCE 0281FFF8FFFF    	   286: 	andi.l #$FFF8FFFF,d1						; clear point number bits
00:00001FD4 8282            	   287: 	or.l d2,d1											; set the point number bits
00:00001FD6 008100040000    	   288: 	ori.l #$00040000,d1							; set active point
00:00001FDC 23C1000408C0    	   289: 	move.l d1,gfxaccel_ctrl
00:00001FE2 610071F0        	   290: 	bsr rbo
00:00001FE6 23C1FD300000    	   291: 	move.l d1,GFXACCEL+GFX_CTRL
00:00001FEC 4E75            	   292: 	rts
                            	   293: 
                            	   294: ; Graphics accelerator expects that co-ordinates are in 16.16 format.
                            	   295: ; 
                            	   296: gfxaccel_plot_point:
00:00001FEE 6100FE58        	   297: 	bsr gfxaccel_init
00:00001FF2 48E74400        	   298: 	movem.l d1/d5,-(a7)
00:00001FF6 2A01            	   299: 	move.l d1,d5
00:00001FF8 7206            	   300: 	moveq #6,d1
00:00001FFA 61000226        	   301: 	bsr gfxaccel_wait								; wait for an open slot
00:00001FFE 2205            	   302: 	move.l d5,d1
00:00002000 610071D2        	   303: 	bsr rbo
00:00002004 23C1FD300038    	   304: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:0000200A 2202            	   305: 	move.l d2,d1
00:0000200C 610071C6        	   306: 	bsr rbo
00:00002010 23C1FD30003C    	   307: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:00002016 2203            	   308: 	move.l d3,d1
00:00002018 610071BA        	   309: 	bsr rbo
00:0000201C 23C1FD300040    	   310: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Z
00:00002022 4242            	   311: 	move.w #0,d2										; point 0
00:00002024 619C            	   312: 	bsr gfxaccel_set_active_point
00:00002026 2239000408C0    	   313: 	move.l gfxaccel_ctrl,d1
00:0000202C 008100000080    	   314: 	ori.l #$00000080,d1							; point write, bit will clear automatically
00:00002032 610071A0        	   315: 	bsr rbo
00:00002036 23C1FD300000    	   316: 	move.l d1,GFXACCEL+GFX_CTRL
00:0000203C 4CDF0022        	   317: 	movem.l (a7)+,d1/d5
00:00002040 7000            	   318: 	moveq #E_Ok,d0
00:00002042 4E75            	   319: 	rts
                            	   320: 
                            	   321: gfxaccel_draw_line:
00:00002044 48E76400        	   322: 	movem.l d1/d2/d5,-(a7)
00:00002048 2A01            	   323: 	move.l d1,d5
00:0000204A 7209            	   324: 	moveq #9,d1
00:0000204C 610001D4        	   325: 	bsr gfxaccel_wait								; wait for an open slot
00:00002050 2205            	   326: 	move.l d5,d1
00:00002052 61007180        	   327: 	bsr rbo
00:00002056 23C1FD300038    	   328: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:0000205C 2202            	   329: 	move.l d2,d1
00:0000205E 61007174        	   330: 	bsr rbo
00:00002062 23C1FD30003C    	   331: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:00002068 4242            	   332: 	move.w #0,d2										; point 0
00:0000206A 6100FF56        	   333: 	bsr gfxaccel_set_active_point
00:0000206E 2203            	   334: 	move.l d3,d1
00:00002070 61007162        	   335: 	bsr rbo
00:00002074 23C1FD300038    	   336: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:0000207A 2204            	   337: 	move.l d4,d1
00:0000207C 61007156        	   338: 	bsr rbo
00:00002080 23C1FD30003C    	   339: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:00002086 343C0001        	   340: 	move.w #1,d2										; point 1
00:0000208A 6100FF36        	   341: 	bsr gfxaccel_set_active_point
00:0000208E 2239000408C0    	   342: 	move.l gfxaccel_ctrl,d1					; get the control reg
00:00002094 008100000200    	   343: 	ori.l #$00000200,d1							; trigger draw line
00:0000209A 61007138        	   344: 	bsr rbo
00:0000209E 23C1FD300000    	   345: 	move.l d1,GFXACCEL+GFX_CTRL
00:000020A4 4CDF0026        	   346: 	movem.l (a7)+,d1/d2/d5
00:000020A8 7000            	   347: 	moveq #E_Ok,d0
00:000020AA 4E75            	   348: 	rts
                            	   349: 
                            	   350: ; Draw a rectangle in the currently selected color
                            	   351: ;
                            	   352: ; Parameters:
                            	   353: ;		d1 	- x0 pos
                            	   354: ;		d2	- y0 pos
                            	   355: ;		d3	- x1 pos
                            	   356: ;		d4	- y1 pos
                            	   357: 
                            	   358: gfxaccel_draw_rectangle:
00:000020AC 48E76400        	   359: 	movem.l d1/d2/d5,-(a7)
00:000020B0 2A01            	   360: 	move.l d1,d5
00:000020B2 7209            	   361: 	moveq #9,d1
00:000020B4 6100016C        	   362: 	bsr gfxaccel_wait								; wait for an open slot
00:000020B8 2205            	   363: 	move.l d5,d1
00:000020BA 61007118        	   364: 	bsr rbo
00:000020BE 23C1FD300038    	   365: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:000020C4 2202            	   366: 	move.l d2,d1
00:000020C6 6100710C        	   367: 	bsr rbo
00:000020CA 23C1FD30003C    	   368: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:000020D0 4242            	   369: 	move.w #0,d2										; point 0
00:000020D2 6100FEEE        	   370: 	bsr gfxaccel_set_active_point
00:000020D6 2203            	   371: 	move.l d3,d1
00:000020D8 610070FA        	   372: 	bsr rbo
00:000020DC 23C1FD300038    	   373: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:000020E2 2204            	   374: 	move.l d4,d1
00:000020E4 610070EE        	   375: 	bsr rbo
00:000020E8 23C1FD30003C    	   376: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:000020EE 343C0001        	   377: 	move.w #1,d2										; point 1
00:000020F2 6100FECE        	   378: 	bsr gfxaccel_set_active_point
00:000020F6 2239000408C0    	   379: 	move.l gfxaccel_ctrl,d1					; get the control reg
00:000020FC 008100000100    	   380: 	ori.l #$00000100,d1							; trigger draw rectangle
00:00002102 610070D0        	   381: 	bsr rbo
00:00002106 23C1FD300000    	   382: 	move.l d1,GFXACCEL+GFX_CTRL
00:0000210C 4CDF0026        	   383: 	movem.l (a7)+,d1/d2/d5
00:00002110 7000            	   384: 	moveq #E_Ok,d0
00:00002112 4E75            	   385: 	rts
                            	   386: 
                            	   387: ; Draw a triangle in the currently selected color
                            	   388: ;
                            	   389: ; Parameters:
                            	   390: ;		d1 	- x0 pos
                            	   391: ;		d2	- y0 pos
                            	   392: ;		d3	- x1 pos
                            	   393: ;		d4	- y1 pos
                            	   394: ;	  d5	- x2 pos
                            	   395: ;		d6	- y2 pos
                            	   396: 
                            	   397: gfxaccel_draw_triangle:
00:00002114 48E76100        	   398: 	movem.l d1/d2/d7,-(a7)
00:00002118 2E01            	   399: 	move.l d1,d7
00:0000211A 720C            	   400: 	moveq #12,d1
00:0000211C 61000104        	   401: 	bsr gfxaccel_wait								; wait for an open slot
00:00002120 2207            	   402: 	move.l d7,d1
00:00002122 610070B0        	   403: 	bsr rbo
00:00002126 23C1FD300038    	   404: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:0000212C 2202            	   405: 	move.l d2,d1
00:0000212E 610070A4        	   406: 	bsr rbo
00:00002132 23C1FD30003C    	   407: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:00002138 4242            	   408: 	move.w #0,d2										; point 0
00:0000213A 6100FE86        	   409: 	bsr gfxaccel_set_active_point
00:0000213E 2203            	   410: 	move.l d3,d1
00:00002140 61007092        	   411: 	bsr rbo
00:00002144 23C1FD300038    	   412: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:0000214A 2204            	   413: 	move.l d4,d1
00:0000214C 61007086        	   414: 	bsr rbo
00:00002150 23C1FD30003C    	   415: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:00002156 343C0001        	   416: 	move.w #1,d2										; point 1
00:0000215A 6100FE66        	   417: 	bsr gfxaccel_set_active_point
00:0000215E 2205            	   418: 	move.l d5,d1
00:00002160 61007072        	   419: 	bsr rbo
00:00002164 23C1FD300038    	   420: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:0000216A 2206            	   421: 	move.l d6,d1
00:0000216C 61007066        	   422: 	bsr rbo
00:00002170 23C1FD30003C    	   423: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:00002176 343C0002        	   424: 	move.w #2,d2										; point 2
00:0000217A 6100FE46        	   425: 	bsr gfxaccel_set_active_point
00:0000217E 2239000408C0    	   426: 	move.l gfxaccel_ctrl,d1					; get the control reg
00:00002184 008100000400    	   427: 	ori.l #$00000400,d1							; trigger draw triangle
00:0000218A 61007048        	   428: 	bsr rbo
00:0000218E 23C1FD300000    	   429: 	move.l d1,GFXACCEL+GFX_CTRL
00:00002194 4CDF0086        	   430: 	movem.l (a7)+,d1/d2/d7
00:00002198 7000            	   431: 	moveq #E_Ok,d0
00:0000219A 4E75            	   432: 	rts
                            	   433: 
                            	   434: gfxaccel_draw_curve:
00:0000219C 48E76100        	   435: 	movem.l d1/d2/d7,-(a7)
00:000021A0 2E01            	   436: 	move.l d1,d7
00:000021A2 720C            	   437: 	moveq #12,d1
00:000021A4 617C            	   438: 	bsr gfxaccel_wait								; wait for an open slot
00:000021A6 2207            	   439: 	move.l d7,d1
00:000021A8 6100702A        	   440: 	bsr rbo
00:000021AC 23C1FD300038    	   441: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:000021B2 2202            	   442: 	move.l d2,d1
00:000021B4 6100701E        	   443: 	bsr rbo
00:000021B8 23C1FD30003C    	   444: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:000021BE 4242            	   445: 	move.w #0,d2										; point 0
00:000021C0 6100FE00        	   446: 	bsr gfxaccel_set_active_point
00:000021C4 2203            	   447: 	move.l d3,d1
00:000021C6 6100700C        	   448: 	bsr rbo
00:000021CA 23C1FD300038    	   449: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:000021D0 2204            	   450: 	move.l d4,d1
00:000021D2 61007000        	   451: 	bsr rbo
00:000021D6 23C1FD30003C    	   452: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:000021DC 343C0001        	   453: 	move.w #1,d2										; point 1
00:000021E0 6100FDE0        	   454: 	bsr gfxaccel_set_active_point
00:000021E4 2205            	   455: 	move.l d5,d1
00:000021E6 61006FEC        	   456: 	bsr rbo
00:000021EA 23C1FD300038    	   457: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_X
00:000021F0 2206            	   458: 	move.l d6,d1
00:000021F2 61006FE0        	   459: 	bsr rbo
00:000021F6 23C1FD30003C    	   460: 	move.l d1,GFXACCEL+GFX_DEST_PIXEL_Y
00:000021FC 343C0002        	   461: 	move.w #2,d2										; point 2
00:00002200 6100FDC0        	   462: 	bsr gfxaccel_set_active_point
00:00002204 2239000408C0    	   463: 	move.l gfxaccel_ctrl,d1					; get the control reg
00:0000220A 008100001C00    	   464: 	ori.l #$00001C00,d1							; trigger draw curve+triangle+interp
00:00002210 61006FC2        	   465: 	bsr rbo
00:00002214 23C1FD300000    	   466: 	move.l d1,GFXACCEL+GFX_CTRL
00:0000221A 4CDF0086        	   467: 	movem.l (a7)+,d1/d2/d7
00:0000221E 7000            	   468: 	moveq #E_Ok,d0
00:00002220 4E75            	   469: 	rts
                            	   470: 
                            	   471: ; Waits until the specified number of queue slots are available.
                            	   472: ;
                            	   473: ; Parameters:
                            	   474: ;		d1 = number of queue slots required
                            	   475: 
                            	   476: gfxaccel_wait:
00:00002222 48E77000        	   477: 	movem.l d1/d2/d3,-(a7)
00:00002226 2401            	   478: 	move.l d1,d2
00:00002228 2601            	   479: 	move.l d1,d3
                            	   480: .0001:
00:0000222A 2239FD300004    	   481: 	move.l GFXACCEL+GFX_STATUS,d1
00:00002230 61006FA2        	   482: 	bsr rbo
00:00002234 08010000        	   483: 	btst.l #0,d1			; first check busy bit
00:00002238 66F0            	   484: 	bne.s .0001
00:0000223A 4841            	   485: 	swap d1
00:0000223C 48C1            	   486: 	ext.l d1
00:0000223E 2403            	   487: 	move.l d3,d2
00:00002240 D481            	   488: 	add.l d1,d2
00:00002242 0C82000007F8    	   489: 	cmpi.l #2040,d2
00:00002248 62E0            	   490: 	bhi.s .0001
00:0000224A 4CDF000E        	   491: 	movem.l (a7)+,d1/d2/d3
00:0000224E 4E75            	   492: 	rts
                            	   493: 

Source: "boot.x68"
                            	   579: 
                            	   580: ;------------------------------------------------------------------------------
                            	   581: ;------------------------------------------------------------------------------
                            	   582: ;------------------------------------------------------------------------------
                            	   583: 
                            	   584: GlobalReadLong:
00:00002250 2210            	   585: 		move.l (a0),d1
00:00002252 4E75            	   586: 		rts
00:00002254 6004            	   587: 		bra nd1
                            	   588: GlobalWriteLong:
00:00002256 2081            	   589: 		move.l d1,(a0)
00:00002258 4E75            	   590: 		rts
                            	   591: net_delay:
                            	   592: 		bra nd1
                            	   593: nd1	bra nd2
                            	   594: nd2 bra nd3
                            	   595: nd3 bra nd4
00:0000225A 4E71            	   596: nd4	nop
00:0000225C 4E75            	   597: 		rts
                            	   598: 	
                            	   599: 
                            	   600: ;------------------------------------------------------------------------------
                            	   601: ; The IO bitmap needs to be initialized to allow access to IO.
                            	   602: ;------------------------------------------------------------------------------
                            	   603: 
                            	   604: InitIOPBitmap:
00:0000225E 7600            	   605: 	moveq #0,d3				; d3 = asid value
00:00002260 303C003F        	   606: 	move.w #63,d0			; 64 bitmaps to setup
00:00002264 4E7A8016        	   607: 	movec iops,a0			; a0 = IOP bitmap address
00:00002268 2248            	   608: 	movea.l a0,a1			; a1 = table address
                            	   609: .0004
00:0000226A 4A03            	   610: 	tst.b d3
00:0000226C 57C1            	   611: 	seq d1						; set entire bitmap for asid 0, otherwise clear entire bitmap
00:0000226E 4881            	   612: 	ext.w	d1					; make into a long value
00:00002270 48C1            	   613: 	ext.l d1
00:00002272 383C007F        	   614: 	move.w #127,d4
                            	   615: .0001
00:00002276 22C1            	   616: 	move.l d1,(a1)+		; set or clear entire table
00:00002278 51CCFFFC        	   617: 	dbra d4,.0001
00:0000227C 72FF            	   618: 	moveq #-1,d1
00:0000227E 214100A0        	   619: 	move.l d1,160(a0)	; all io address spaces have access to semaphores
00:00002282 214100A4        	   620: 	move.l d1,164(a0)
00:00002286 214100A8        	   621: 	move.l d1,168(a0)
00:0000228A 214100AC        	   622: 	move.l d1,172(a0)
00:0000228E 214101FC        	   623: 	move.l d1,508(a0)	; all io address spaces access random # generator
00:00002292 4840            	   624: 	swap d0
00:00002294 303C001F        	   625: 	move.w #31,d0			; 32 long words for the screen area per bitmap
                            	   626: .0003
00:00002298 20C1            	   627: 	move.l d1,(a0)+		; all cores have access to a screen
00:0000229A 51C8FFFC        	   628: 	dbra d0,.0003
00:0000229E 4840            	   629: 	swap d0
00:000022A0 5203            	   630: 	addi.b #1,d3			; do next address space
00:000022A2 2049            	   631: 	movea.l a1,a0			; a0 points to area for next address space
00:000022A4 51C8FFC4        	   632: 	dbra d0,.0004
00:000022A8 4E75            	   633: 	rts	
                            	   634: 	
                            	   635: ;------------------------------------------------------------------------------
                            	   636: ; RandInit
                            	   637: ; 	Initialize random number generator.
                            	   638: ;
                            	   639: ; Modifies:
                            	   640: ;		none
                            	   641: ; Parameters:
                            	   642: ;		none
                            	   643: ;	Returns:
                            	   644: ;		none
                            	   645: ;------------------------------------------------------------------------------
                            	   646: 
                            	   647: InitRand:
                            	   648: RandInit:
00:000022AA 23FC123456780004	   649: 	move.l #$12345678,m_z		; initialize to some value
00:000022B2 08D0
00:000022B4 23FC987654320004	   650: 	move.l #$98765432,m_w
00:000022BC 08D4
00:000022BE 23FC828354380004	   651: 	move.l #$82835438,next_m_z
00:000022C6 08D8
00:000022C8 23FC087237460004	   652: 	move.l #$08723746,next_m_w
00:000022D0 08DC
00:000022D2 48E7C000        	   653: 	movem.l	d0/d1,-(a7)
00:000022D6 7025            	   654: 	moveq #37,d0								; lock semaphore
00:000022D8 7204            	   655: 	moveq	#RAND_SEMA,d1
00:000022DA 4E4F            	   656: 	trap #15
00:000022DC 4E7A0FE0        	   657: 	movec coreno,d0							; d0 = core number
00:000022E0 5580            	   658: 	sub.l #2,d0									; make 0 to 9
00:000022E2 ED88            	   659: 	lsl.l	#6,d0									; allow 64 streams per core
00:000022E4 23C0FD0FFD04    	   660: 	move.l d0,RAND_STRM					; select the stream
00:000022EA 23FC12345678FD0F	   661: 	move.l #$12345678,RAND_MZ		; initialize to some value
00:000022F2 FD08
00:000022F4 23FC98765432FD0F	   662: 	move.l #$98765432,RAND_MW
00:000022FC FD0C
00:000022FE 23FC2E5BF271FD0F	   663: 	move.l #777777777,RAND_NUM	; generate first number
00:00002306 FD00
00:00002308 7026            	   664: 	moveq #38,d0								; unlock semaphore
00:0000230A 7204            	   665: 	moveq	#RAND_SEMA,d1
00:0000230C 4E4F            	   666: 	trap #15
00:0000230E 4CDF0003        	   667: 	movem.l	(a7)+,d0/d1
00:00002312 4E75            	   668: 	rts
                            	   669: 
                            	   670: ;------------------------------------------------------------------------------
                            	   671: ; Returns
                            	   672: ;		d1 = random integer
                            	   673: ;------------------------------------------------------------------------------
                            	   674: 
                            	   675: RandGetNum:
00:00002314 48E7A000        	   676: 	movem.l	d0/d2,-(a7)
00:00002318 7204            	   677: 	moveq #RAND_SEMA,d1
00:0000231A 6100013C        	   678: 	bsr T15LockSemaphore
00:0000231E 4E7A0FE0        	   679: 	movec	coreno,d0
00:00002322 5580            	   680: 	sub.l #2,d0									; make 0 to 9
00:00002324 ED88            	   681: 	lsl.l	#6,d0
00:00002326 23C0FD0FFD04    	   682: 	move.l d0,RAND_STRM					; select the stream
00:0000232C 2439FD0FFD00    	   683: 	move.l RAND_NUM,d2					; d2 = random number
00:00002332 23C2FD0FFD00    	   684: 	move.l d2,RAND_NUM		 		  ; generate next number
00:00002338 61000124        	   685: 	bsr T15UnlockSemaphore
00:0000233C 2202            	   686: 	move.l d2,d1
00:0000233E 4CDF0005        	   687: 	movem.l	(a7)+,d0/d2
00:00002342 4E75            	   688: 	rts
                            	   689: 
                            	   690: prng:
00:00002344 2F02            	   691: 	move.l d2,-(a7)
00:00002346 2239000408D0    	   692: 	move.l m_z,d1
00:0000234C 2401            	   693: 	move.l d1,d2
00:0000234E C2FC1B39        	   694: 	mulu #6969,d1
00:00002352 4842            	   695: 	swap d2
00:00002354 48C2            	   696: 	ext.l d2
00:00002356 D481            	   697: 	add.l d1,d2
00:00002358 23C2000408D8    	   698: 	move.l d2,next_m_z
                            	   699: 
00:0000235E 2239000408D4    	   700: 	move.l m_w,d1
00:00002364 2401            	   701: 	move.l d1,d2
00:00002366 C2FC4650        	   702: 	mulu #18000,d1
00:0000236A 4842            	   703: 	swap d2
00:0000236C 48C2            	   704: 	ext.l d2
00:0000236E D481            	   705: 	add.l d1,d2
00:00002370 23C2000408DC    	   706: 	move.l d2,next_m_w
                            	   707: 	
00:00002376 2239000408D0    	   708: 	move.l m_z,d1
00:0000237C 4841            	   709: 	swap d1
00:0000237E 4241            	   710: 	clr.w d1
00:00002380 D2B9000408D4    	   711: 	add.l m_w,d1
00:00002386 23F9000408D80004	   712: 	move.l next_m_z,m_z
00:0000238E 08D0
00:00002390 23F9000408DC0004	   713: 	move.l next_m_w,m_w
00:00002398 08D4
00:0000239A 241F            	   714: 	move.l (a7)+,d2
00:0000239C 4E75            	   715: 	rts
                            	   716: 	
                            	   717: ;------------------------------------------------------------------------------
                            	   718: ; Modifies:
                            	   719: ;		none
                            	   720: ; Returns
                            	   721: ;		fp0 = random float between 0 and 1.
                            	   722: ;------------------------------------------------------------------------------
                            	   723: 
                            	   724: _GetRand:
00:0000239E 2F01            	   725: 	move.l d1,-(sp)
00:000023A0 F2276880        	   726: 	fmove.x fp1,-(sp)
00:000023A4 6100FF6E        	   727: 	bsr RandGetNum
00:000023A8 E289            	   728: 	lsr.l #1,d1									; make number between 0 and 2^31
00:000023AA F2014000        	   729: 	fmove.l d1,fp0
00:000023AE F23C40807FFFFFFF	   730: 	fmove.l #$7FFFFFFF,fp1			; divide by 2^31
00:000023B6 F2000420        	   731: 	fdiv fp1,fp0
00:000023BA F21F4880        	   732: 	fmove.x (sp)+,fp1
00:000023BE 221F            	   733: 	move.l (sp)+,d1
00:000023C0 4E75            	   734: 	rts
                            	   735: 
                            	   736: ;------------------------------------------------------------------------------
                            	   737: ; RandWait
                            	   738: ;    Wait some random number of clock cycles before returning.
                            	   739: ;------------------------------------------------------------------------------
                            	   740: 
                            	   741: RandWait:
00:000023C2 48E7C000        	   742: 	movem.l	d0/d1,-(a7)
00:000023C6 6100FF4C        	   743: 	bsr			RandGetNum
00:000023CA 0241000F        	   744: 	andi.w	#15,d1
                            	   745: .0001:
00:000023CE 4E71            	   746: 	nop
00:000023D0 51C9FFFC        	   747: 	dbra		d1,.0001
00:000023D4 4CDF0003        	   748: 	movem.l	(a7)+,d0/d1
00:000023D8 4E75            	   749: 	rts
                            	   750: 
                            	   751: ;------------------------------------------------------------------------------
                            	   752: ; Initialize semaphores
                            	   753: ; - all semaphores are set to unlocked except the first one, which is locked
                            	   754: ; for core #2.
                            	   755: ;
                            	   756: ; Parameters:
                            	   757: ;		<none>
                            	   758: ; Modifies:
                            	   759: ;		<none>
                            	   760: ; Returns:
                            	   761: ;		<none>
                            	   762: ;------------------------------------------------------------------------------
                            	   763: 
                            	   764: InitSemaphores:
00:000023DA 48E74080        	   765: 	movem.l	d1/a0,-(a7)
00:000023DE 41F9FD050000    	   766: 	lea			semamem,a0
00:000023E4 217C000200002000	   767: 	move.l	#$20000,$2000(a0)	; lock the first semaphore for core #2, thread #0
00:000023EC 323C00FE        	   768: 	move.w	#254,d1
                            	   769: .0001:
00:000023F0 5888            	   770: 	lea			4(a0),a0
00:000023F2 42A82000        	   771: 	clr.l		$2000(a0)					; write zeros to unlock
00:000023F6 51C9FFF8        	   772: 	dbra		d1,.0001
00:000023FA 4CDF0102        	   773: 	movem.l	(a7)+,d1/a0
00:000023FE 4E75            	   774: 	rts
                            	   775: 
                            	   776: ; -----------------------------------------------------------------------------
                            	   777: ; Parameters:
                            	   778: ;		d1 semaphore number
                            	   779: ;
                            	   780: ; Side Effects:
                            	   781: ;		increments semaphore, saturates at 255
                            	   782: ;
                            	   783: ; Returns:	
                            	   784: ; 	z flag set if semaphore was zero
                            	   785: ; -----------------------------------------------------------------------------
                            	   786: 
                            	   787: ;IncrementSemaphore:
                            	   788: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   789: ;	lea			semamem,a0			; point to semaphore memory
                            	   790: ;	ext.w		d1							; make d1 word value
                            	   791: ;	asl.w		#4,d1						; align to memory
                            	   792: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   793: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   794: ;	rts
                            	   795: 	
                            	   796: ; -----------------------------------------------------------------------------
                            	   797: ; Parameters:
                            	   798: ;		d1 semaphore number
                            	   799: ;
                            	   800: ; Side Effects:
                            	   801: ;		decrements semaphore, saturates at zero
                            	   802: ;
                            	   803: ; Returns:	
                            	   804: ; 	z flag set if semaphore was zero
                            	   805: ; -----------------------------------------------------------------------------
                            	   806: 
                            	   807: ;DecrementSemaphore:
                            	   808: ;	movem.l	d1/a0,-(a7)			; save registers
                            	   809: ;	lea			semamem,a0			; point to semaphore memory
                            	   810: ;	andi.w	#255,d1					; make d1 word value
                            	   811: ;	asl.w		#4,d1						; align to memory
                            	   812: ;	tst.b		1(a0,d1.w)			; read (test) value for zero
                            	   813: ;	movem.l	(a7)+,a0/d1			; restore regs
                            	   814: ;	rts
                            	   815: 
                            	   816: ; -----------------------------------------------------------------------------
                            	   817: ; Lock a semaphore
                            	   818: ;
                            	   819: ; Parameters:
                            	   820: ;		d0 = key
                            	   821: ;		d1 = semaphore number
                            	   822: ; -----------------------------------------------------------------------------
                            	   823: 
                            	   824: LockSemaphore:
00:00002400 4E75            	   825: 	rts
00:00002402 48E74080        	   826: 	movem.l	d1/a0,-(a7)			; save registers
00:00002406 41F9FD050000    	   827: 	lea			semamem,a0			; point to semaphore memory lock area
00:0000240C 024100FF        	   828: 	andi.w	#255,d1					; make d1 word value
00:00002410 E549            	   829: 	lsl.w		#2,d1						; align to memory
                            	   830: .0001
00:00002412 21801000        	   831: 	move.l	d0,(a0,d1.w)		; try and write the semaphore
00:00002416 B0B01000        	   832: 	cmp.l		(a0,d1.w),d0		; did it lock?
00:0000241A 66F6            	   833: 	bne.s		.0001						; no, try again
00:0000241C 4CDF0102        	   834: 	movem.l	(a7)+,a0/d1			; restore regs
00:00002420 4E75            	   835: 	rts
                            	   836: 	
                            	   837: ; -----------------------------------------------------------------------------
                            	   838: ; Unlocks a semaphore even if not the owner.
                            	   839: ;
                            	   840: ; Parameters:
                            	   841: ;		d1 semaphore number
                            	   842: ; -----------------------------------------------------------------------------
                            	   843: 
                            	   844: ForceUnlockSemaphore:
00:00002422 48E74080        	   845: 	movem.l	d1/a0,-(a7)				; save registers
00:00002426 41F9FD053000    	   846: 	lea			semamem+$3000,a0	; point to semaphore memory read/write area
00:0000242C 024100FF        	   847: 	andi.w	#255,d1						; make d1 word value
00:00002430 E549            	   848: 	lsl.w		#2,d1							; align to memory
00:00002432 42B01000        	   849: 	clr.l		(a0,d1.w)					; write zero to unlock
00:00002436 4CDF0102        	   850: 	movem.l	(a7)+,a0/d1				; restore regs
00:0000243A 4E75            	   851: 	rts
                            	   852: 
                            	   853: ; -----------------------------------------------------------------------------
                            	   854: ; Unlocks a semaphore. Must be the owner to have effect.
                            	   855: ; Three cases:
                            	   856: ;	1) the owner, the semaphore will be reset to zero
                            	   857: ;	2) not the owner, the write will be ignored
                            	   858: ; 3) already unlocked, the write will be ignored
                            	   859: ;
                            	   860: ; Parameters:
                            	   861: ;		d0 = key
                            	   862: ;		d1 = semaphore number
                            	   863: ; -----------------------------------------------------------------------------
                            	   864: 
                            	   865: UnlockSemaphore:
00:0000243C 60E4            	   866: 	bra ForceUnlockSemaphore
00:0000243E 48E74080        	   867: 	movem.l	d1/a0,-(a7)				; save registers
00:00002442 41F9FD051000    	   868: 	lea			semamem+$1000,a0	; point to semaphore memory unlock area
00:00002448 024100FF        	   869: 	andi.w	#255,d1						; make d1 word value
00:0000244C E549            	   870: 	lsl.w		#2,d1							; align to memory
00:0000244E 21801000        	   871: 	move.l	d0,(a0,d1.w)			; write matching value to unlock
00:00002452 4CDF0102        	   872: 	movem.l	(a7)+,a0/d1				; restore regs
00:00002456 4E75            	   873: 	rts
                            	   874: 
                            	   875: ; -----------------------------------------------------------------------------
                            	   876: ; Parameters:
                            	   877: ;		d1 = semaphore to lock / unlock
                            	   878: ; -----------------------------------------------------------------------------
                            	   879: 
                            	   880: T15LockSemaphore:	
00:00002458 4E7A0012        	   881: 	movec tr,d0
00:0000245C 60A2            	   882: 	bra LockSemaphore
                            	   883: 
                            	   884: T15UnlockSemaphore:
00:0000245E 4E7A0012        	   885: 	movec tr,d0
00:00002462 60D8            	   886: 	bra UnlockSemaphore
                            	   887: 
                            	   888: T15GetFloat:
00:00002464 2049            	   889: 	move.l a1,a0
00:00002466 2001            	   890: 	move.l d1,d0
00:00002468 6100693E        	   891: 	bsr _GetFloat
00:0000246C 2248            	   892: 	move.l a0,a1
00:0000246E 2200            	   893: 	move.l d0,d1
00:00002470 4E75            	   894: 	rts
                            	   895: 
                            	   896: T15Abort:
00:00002472 61006A0C        	   897: 	bsr DisplayByte
00:00002476 43FA73D8        	   898: 	lea msgStackCanary,a1
00:0000247A 6100522A        	   899: 	bsr DisplayStringCRLF
00:0000247E 60005804        	   900: 	bra Monitor
                            	   901: 
                            	   902: chk_exception:
00:00002482 222F0002        	   903: 	move.l 2(sp),d1
00:00002486 610069EC        	   904: 	bsr DisplayTetra
00:0000248A 43FA73B6        	   905: 	lea msgChk,a1
00:0000248E 61005216        	   906: 	bsr DisplayStringCRLF
00:00002492 600057F0        	   907: 	bra Monitor
                            	   908: 
                            	   909: ; -----------------------------------------------------------------------------
                            	   910: ; Delay for a few seconds to allow some I/O reset operations to take place.
                            	   911: ; -----------------------------------------------------------------------------
                            	   912: 
                            	   913: Delay3s:
00:00002496 203C002DC6C0    	   914: 	move.l	#3000000,d0		; this should take a few seconds to loop
00:0000249C 41F9FD0FFF00    	   915: 	lea			leds,a0				; a0 = address of LED output register
00:000024A2 6002            	   916: 	bra			dly3s1				; branch to the loop
                            	   917: dly3s2:	
00:000024A4 4840            	   918: 	swap		d0						; loop is larger than 16-bits
                            	   919: dly3s1:
00:000024A6 2200            	   920: 	move.l	d0,d1					; the counter cycles fast, so use upper bits for display
00:000024A8 E199            	   921: 	rol.l		#8,d1					; could use swap here, but lets test rol
00:000024AA E199            	   922: 	rol.l		#8,d1
00:000024AC 1081            	   923: 	move.b	d1,(a0)				; set the LEDs
00:000024AE 51C8FFF6        	   924: 	dbra		d0,dly3s1			; decrement and branch back
00:000024B2 4840            	   925: 	swap		d0
00:000024B4 51C8FFEE        	   926: 	dbra		d0,dly3s2
00:000024B8 4E75            	   927: 	rts
                            	   928: 
                            	   929: Delay3s2:
00:000024BA 4E7A0FE0        	   930: 	movec		coreno,d0			; vary delay by core to stagger startup
00:000024BE E188            	   931: 	lsl.l		#8,d0
00:000024C0 0680002DC6C0    	   932: 	addi.l	#3000000,d0		; this should take a few seconds to loop
00:000024C6 6002            	   933: 	bra			.0001					; branch to the loop
                            	   934: .0002	
00:000024C8 4840            	   935: 	swap		d0						; loop is larger than 16-bits
                            	   936: .0001
00:000024CA 51C8FFFE        	   937: 	dbra		d0,.0001			; decrement and branch back
00:000024CE 4840            	   938: 	swap		d0
00:000024D0 51C8FFF6        	   939: 	dbra		d0,.0002
00:000024D4 4E75            	   940: 	rts
                            	   941: 
                            	   942: 	include "cputest.x68"

Source: "cputest.x68"
                            	     1: ;; @name cputest.s Tests 68000 cpu
                            	     2: ;
                            	     3: ; Based on https://github.com/MicroCoreLabs/Projects/blob/master/MCL68/MC68000_Test_Code/MC68000_test_all_opcodes.X68
                            	     4: ;
                            	     5: ; Converted into a CD-i system ROM image by CD-i Fan:
                            	     6: ; - comment lines must start in first column
                            	     7: ; - replaced org instructions by suitable rept
                            	     8: ; - copy vectors to low memory at startup
                            	     9: ; - replaced jsr/jmp by bsr/bra for position independence
                            	    10: ; - replaced move.l by moveq whenever possible
                            	    11: ; - converted branches to short form whenever possible (e.g. beq => beq.s)
                            	    12: ; - added immediate suffix to opcodes where required (e.g. and => andi)
                            	    13: ; The last three modifications are required to make the test work;
                            	    14: ; apparently the original assembler was somewhat smarter then
                            	    15: ; the Microware OS-9 assembler and did this automatically.
                            	    16: ;
                            	    17: ; In some cases the opcodes of the test are used as test data!
                            	    18: ;
                            	    19: ; Original file header follows.
                            	    20: ;
                            	    21: ;  File Name   :  MCL68 Opcode Tests
                            	    22: ;  Used on     :
                            	    23: ;  Author      :  Ted Fried, MicroCore Labs
                            	    24: ;  Creation    :  7/14/2020
                            	    25: ;
                            	    26: ;   Description:
                            	    27: ;   ============
                            	    28: ;
                            	    29: ;  Program to test all of the Motorola 68000's opcodes.
                            	    30: ;
                            	    31: ;  If failures are detected, the code will immediately loop on itself.
                            	    32: ;  All addressing modes, data sizes, and opcode combinations are tested.
                            	    33: ;
                            	    34: ;  This code was developed using the Easy68K simulator where all tests passed!
                            	    35: ;
                            	    36: ;------------------------------------------------------------------------
                            	    37: ;
                            	    38: ; Modification History:
                            	    39: ; =====================
                            	    40: ;
                            	    41: ; Revision 1 7/14/2020
                            	    42: ; Initial revision
                            	    43: ;
                            	    44: ;
                            	    45: ;------------------------------------------------------------------------
                            	    46: ;
                            	    47: ; Copyright (c) 2020 Ted Fried
                            	    48: ;
                            	    49: ; Permission is hereby granted, free of charge, to any person obtaining a copy
                            	    50: ; of this software and associated documentation files (the "Software"), to deal
                            	    51: ; in the Software without restriction, including without limitation the rights
                            	    52: ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                            	    53: ; copies of the Software, and to permit persons to whom the Software is
                            	    54: ; furnished to do so, subject to the following conditions:
                            	    55: ;
                            	    56: ; The above copyright notice and this permission notice shall be included in all
                            	    57: ; copies or substantial portions of the Software.
                            	    58: ;
                            	    59: ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                            	    60: ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                            	    61: ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                            	    62: ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                            	    63: ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                            	    64: ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                            	    65: ; SOFTWARE.
                            	    66: 
                            	    67: ; Modified for rf68000 project (c) 2022 Robert Finch
                            	    68: 
                            	    69: ;	data
                            	    70: ;	dc.l		$0001FFFC						; top of local ram area
                            	    71: ;	dc.l		start
                            	    72: 
                            	    73: ;    org $1000												; code starts at $400 in local ram
                            	    74: *start:
                            	    75: ;	move.l	$FFFFFFE0,d0		; get core number
                            	    76: ;	cmpi.b	#2,d0
                            	    77: ;	bne			do_nothing
                            	    78: 
                            	    79: ;	lea			EXCEPTION_6,a0	; check exception vector
                            	    80: ;	move.l	a0,6*4
                            	    81: ;	lea			EXCEPTION_7,a0	; TRAPV exception vector
                            	    82: ;	move.l	a0,7*4
                            	    83: 
                            	    84: cpu_test:
00:000024D6 610000F6        	    85: 	bsr	op_ORI_TO_CCR
00:000024DA 61000114        	    86: 	bsr	op_ORI_TO_SR
00:000024DE 61000132        	    87: 	bsr	op_EORI_TO_CCR
00:000024E2 61000154        	    88: 	bsr	op_EORI_TO_SR
00:000024E6 61000176        	    89: 	bsr	op_ANDI_TO_CCR
00:000024EA 61000198        	    90: 	bsr	op_ANDI_TO_SR
00:000024EE 610001BA        	    91: 	bsr	op_BTST
00:000024F2 61000560        	    92: 	bsr	op_BCHG
00:000024F6 610008C4        	    93: 	bsr	op_BCLR
00:000024FA 61000C0E        	    94: 	bsr	op_BSET
00:000024FE 61000F52        	    95: 	bsr op_MOVEP
00:00002502 61000FDA        	    96: 	bsr op_BOOL_I
00:00002506 610011BE        	    97: 	bsr op_CMP_I
00:0000250A 610013A2        	    98: 	bsr op_ADD_I
00:0000250E 61001524        	    99: 	bsr op_SUB_I
00:00002512 610016A6        	   100: 	bsr op_MOVE
00:00002516 610018AE        	   101: 	bsr op_MOVE_xxx_FLAGS
00:0000251A 61001A9E        	   102: 	bsr op_EXT
00:0000251E 61001AC6        	   103: 	bsr op_SWAP
00:00002522 61001AD8        	   104: 	bsr op_LEAPEA
00:00002526 61001B80        	   105: 	bsr op_TAS
00:0000252A 61001BA2        	   106: 	bsr op_TST
00:0000252E 61001BDC        	   107: 	bsr op_LINKS
00:00002532 61001BF6        	   108: 	bsr op_MOVE_USP
00:00002536 61001C02        	   109: 	bsr op_CHK
00:0000253A 61001C48        	   110: 	bsr op_NEGS
00:0000253E 61001FD2        	   111: 	bsr op_MOVEM
                            	   112: ;	bsr op_ABCD
                            	   113: ;	bsr op_SBCD
                            	   114: ;	bsr op_NBCD
00:00002542 6100256E        	   115: 	bsr op_TRAPV
00:00002546 61002586        	   116: 	bsr op_RTR
00:0000254A 61001144        	   117: 	bsr op_BSR
00:0000254E 610025A0        	   118: 	bsr op_BCC
00:00002552 6100261C        	   119: 	bsr op_DBCC
00:00002556 6100263E        	   120: 	bsr op_SCC
00:0000255A 6100266A        	   121: 	bsr op_ADDQ
00:0000255E 61002720        	   122: 	bsr op_SUBQ
00:00002562 610027D6        	   123: 	bsr op_MOVEQ
                            	   124: ;	bsr op_DIVU
                            	   125: ;	bsr op_DIVS
00:00002566 61002892        	   126: 	bsr op_OR
00:0000256A 61002978        	   127: 	bsr op_AND
00:0000256E 61002A5E        	   128: 	bsr op_EOR
00:00002572 61002AD0        	   129: 	bsr op_CMP
00:00002576 61002B42        	   130: 	bsr op_CMPA
00:0000257A 61002BA4        	   131: 	bsr op_CMPM
00:0000257E 61002C46        	   132: 	bsr op_ADD
00:00002582 61002D2C        	   133: 	bsr op_SUB
00:00002586 61002E12        	   134: 	bsr op_ADDA
00:0000258A 61002E5A        	   135: 	bsr op_SUBA
00:0000258E 61002EA2        	   136: 	bsr op_ADDX	
00:00002592 61002FAE        	   137: 	bsr op_SUBX
00:00002596 610030BA        	   138: 	bsr op_MULU
00:0000259A 61003102        	   139: 	bsr op_MULS
00:0000259E 6100314A        	   140: 	bsr op_EXG
00:000025A2 610031B4        	   141: 	bsr op_ROx
00:000025A6 610033E6        	   142: 	bsr op_ROXx
00:000025AA 61003618        	   143: 	bsr op_SHIFTS
00:000025AE 61003856        	   144: 	bsr op_SHIFTS2
                            	   145: 
00:000025B2 4E75            	   146: 	rts
                            	   147: 	bra ALL_DONE
                            	   148: 
                            	   149: * Loop here when all tests pass
                            	   150: *
                            	   151: 
00:000025B4 60FE            	   152: ALL_DONE: bra.s ALL_DONE
                            	   153: 
00:000025B6 263C33333333    	   154: BSR_FAR1:       move.l #$33333333,d3
00:000025BC 4E75            	   155:                 rts
                            	   156: 
                            	   157: ;	moveq		#-1,d0
                            	   158: ;	move.l	d0,$FD0FFF00
                            	   159: ;do_nothing:
                            	   160: ;	bra			*		
                            	   161: 
                            	   162: 
                            	   163: ;' Exception Vector = 6   CHK Instruction
                            	   164: ;
                            	   165: ;	align	4
                            	   166: EXCEPTION_6:
00:000025BE 2C3CEEEE0006    	   167: 	move.l #$EEEE0006,d6      * Set d6 to the exception vector
00:000025C4 4E73            	   168: 	rte
                            	   169: 
                            	   170: ; Exception Vector = 7   TRAPV Instruction
                            	   171: ;
                            	   172: ;	align	4
                            	   173: EXCEPTION_7:
00:000025C6 203C12345678    	   174: 	move.l #$12345678,d0      * Set d6 to the exception vector
00:000025CC 4E73            	   175: 	rte
                            	   176: 
                            	   177: ;-----------------------------------------------------------
                            	   178: ;-----------------------------------------------------------
                            	   179: ; OPCODE : ORI_TO_CCR
                            	   180: ;-----------------------------------------------------------
                            	   181: ;-----------------------------------------------------------
                            	   182: op_ORI_TO_CCR:
                            	   183: 
00:000025CE 003C00FF        	   184:     ori.b #$FF,CCR
00:000025D2 6AFE            	   185:     bpl.s *                   ; branch if Z clear
00:000025D4 66FE            	   186:     bne.s *                   ; branch if N clear
00:000025D6 68FE            	   187:     bvc.s *                   ; branch if V clear
00:000025D8 64FE            	   188:     bcc.s *                   ; branch if C clear
                            	   189: 
00:000025DA 44FC0000        	   190:     move #$00,CCR
00:000025DE 003C0000        	   191:     ori.b #$00,CCR
00:000025E2 67FE            	   192:     beq.s *                   ; branch if Z set
00:000025E4 6BFE            	   193:     bmi.s *                   ; branch if N set
00:000025E6 69FE            	   194:     bvs.s *                   ; branch if V set
00:000025E8 65FE            	   195:     bcs.s *                   ; branch if C set
                            	   196: 
00:000025EA 46FC2700        	   197:     move.w #$2700,SR          ; Put flags back to initial value
                            	   198: 
00:000025EE 4E75            	   199:     rts
                            	   200: 
                            	   201: ;-----------------------------------------------------------
                            	   202: ;-----------------------------------------------------------
                            	   203: ; OPCODE : ORI_TO_SR
                            	   204: ;-----------------------------------------------------------
                            	   205: ;-----------------------------------------------------------
                            	   206: 
                            	   207: op_ORI_TO_SR:
                            	   208: 
00:000025F0 007C2FFF        	   209:     ori.w #$2FFF,SR
00:000025F4 6AFE            	   210:     bpl.s *                   * branch if Z clear
00:000025F6 66FE            	   211:     bne.s *                   * branch if N clear
00:000025F8 68FE            	   212:     bvc.s *                   * branch if V clear
00:000025FA 64FE            	   213:     bcc.s *                   * branch if C clear
                            	   214: 
00:000025FC 46FC2000        	   215:     move.w #$2000,SR
00:00002600 007C0000        	   216:     ori.w #$0000,SR
00:00002604 67FE            	   217:     beq.s *                   * branch if Z set
00:00002606 6BFE            	   218:     bmi.s *                   * branch if N set
00:00002608 69FE            	   219:     bvs.s *                   * branch if V set
00:0000260A 65FE            	   220:     bcs.s *                   * branch if C set
                            	   221: 
00:0000260C 46FC2700        	   222:     move.w #$2700,sr         * Put flags back to initial value
                            	   223: 
00:00002610 4E75            	   224:     rts
                            	   225: ; 
                            	   226: ;-----------------------------------------------------------
                            	   227: ;-----------------------------------------------------------
                            	   228: ; OPCODE : EORI_TO_CCR
                            	   229: ;-----------------------------------------------------------
                            	   230: ;-----------------------------------------------------------
                            	   231: op_EORI_TO_CCR:
                            	   232: 
00:00002612 44FC0000        	   233:     move #$00,CCR
00:00002616 0A3C00FF        	   234:     eori.b #$FF,CCR
00:0000261A 6AFE            	   235:     bpl.s *                   ; branch if Z clear
00:0000261C 66FE            	   236:     bne.s *                   ; branch if N clear
00:0000261E 68FE            	   237:     bvc.s *                   ; branch if V clear
00:00002620 64FE            	   238:     bcc.s *                   ; branch if C clear
                            	   239: 
00:00002622 44FC0000        	   240:     move #$00,CCR
00:00002626 0A3C0000        	   241:     eori.b #$00,CCR
00:0000262A 67FE            	   242:     beq.s *                   ; branch if Z set
00:0000262C 6BFE            	   243:     bmi.s *                   ; branch if N set
00:0000262E 69FE            	   244:     bvs.s *                   ; branch if V set
00:00002630 65FE            	   245:     bcs.s *                   ; branch if C set
                            	   246: 
00:00002632 46FC2700        	   247:     move.w #$2700,sr           ; Put flags back to initial value
                            	   248: 
00:00002636 4E75            	   249:     rts
                            	   250: 
                            	   251: 
                            	   252: 
                            	   253: *-----------------------------------------------------------
                            	   254: *-----------------------------------------------------------
                            	   255: * OPCODE : EORI_TO_SR
                            	   256: *-----------------------------------------------------------
                            	   257: *-----------------------------------------------------------
                            	   258: op_EORI_TO_SR:
                            	   259: 
00:00002638 46FC2000        	   260:     move.w #$2000,SR
00:0000263C 0A7C0FFF        	   261:     eori.w #$0FFF,SR
00:00002640 6AFE            	   262:     bpl.s *                   * branch if Z clear
00:00002642 66FE            	   263:     bne.s *                   * branch if N clear
00:00002644 68FE            	   264:     bvc.s *                   * branch if V clear
00:00002646 64FE            	   265:     bcc.s *                   * branch if C clear
                            	   266: 
00:00002648 46FC2000        	   267:     move.w #$2000,SR
00:0000264C 0A7C0000        	   268:     eori.w #$0000,SR
00:00002650 67FE            	   269:     beq.s *                   * branch if Z set
00:00002652 6BFE            	   270:     bmi.s *                   * branch if N set
00:00002654 69FE            	   271:     bvs.s *                   * branch if V set
00:00002656 65FE            	   272:     bcs.s *                   * branch if C set
                            	   273: 
00:00002658 46FC2700        	   274:     move.w #$2700,sr          * Put flags back to initial value
                            	   275: 
00:0000265C 4E75            	   276:     rts
                            	   277: 
                            	   278: 
                            	   279: 
                            	   280: *-----------------------------------------------------------
                            	   281: *-----------------------------------------------------------
                            	   282: * OPCODE : ANDI_TO_CCR
                            	   283: *-----------------------------------------------------------
                            	   284: *-----------------------------------------------------------
                            	   285: op_ANDI_TO_CCR:
                            	   286: 
00:0000265E 44FC00FF        	   287:     move #$FF,CCR
00:00002662 023C00FF        	   288:     andi.b #$FF,CCR
00:00002666 6AFE            	   289:     bpl.s *                   * branch if Z clear
00:00002668 66FE            	   290:     bne.s *                   * branch if N clear
00:0000266A 68FE            	   291:     bvc.s *                   * branch if V clear
00:0000266C 64FE            	   292:     bcc.s *                   * branch if C clear
                            	   293: 
00:0000266E 44FC00FF        	   294:     move #$FF,CCR
00:00002672 023C0000        	   295:     andi.b #$00,CCR
00:00002676 67FE            	   296:     beq.s *                   * branch if Z set
00:00002678 6BFE            	   297:     bmi.s *                   * branch if N set
00:0000267A 69FE            	   298:     bvs.s *                   * branch if V set
00:0000267C 65FE            	   299:     bcs.s *                   * branch if C set
                            	   300: 
00:0000267E 46FC2700        	   301:     move #$2700,SR           * Put flags back to initial value
                            	   302: 
00:00002682 4E75            	   303:     rts
                            	   304: 
                            	   305: 
                            	   306: 
                            	   307: *-----------------------------------------------------------
                            	   308: *-----------------------------------------------------------
                            	   309: * OPCODE : ANDI_TO_SR
                            	   310: *-----------------------------------------------------------
                            	   311: *-----------------------------------------------------------
                            	   312: op_ANDI_TO_SR:
00:00002684 46FC20FF        	   313:     move.w #$20FF,SR
00:00002688 027CFFFF        	   314:     andi.w #$FFFF,SR
00:0000268C 6AFE            	   315:     bpl.s *                   * branch if Z clear
00:0000268E 66FE            	   316:     bne.s *                   * branch if N clear
00:00002690 68FE            	   317:     bvc.s *                   * branch if V clear
00:00002692 64FE            	   318:     bcc.s *                   * branch if C clear
                            	   319: 
00:00002694 46FC20FF        	   320:     move.w #$20FF,SR
00:00002698 027CFF00        	   321:     andi.w #$FF00,SR
00:0000269C 67FE            	   322:     beq.s *                   * branch if Z set
00:0000269E 6BFE            	   323:     bmi.s *                   * branch if N set
00:000026A0 69FE            	   324:     bvs.s *                   * branch if V set
00:000026A2 65FE            	   325:     bcs.s *                   * branch if C set
                            	   326: 
00:000026A4 46FC2700        	   327:     move.w #$2700,sr           * Put flags back to initial value
                            	   328: 
00:000026A8 4E75            	   329:     rts
                            	   330: 
                            	   331: 
                            	   332: *-----------------------------------------------------------
                            	   333: *-----------------------------------------------------------
                            	   334: * OPCODE : BTST
                            	   335: *-----------------------------------------------------------
                            	   336: *-----------------------------------------------------------
                            	   337: op_BTST:
                            	   338: 
                            	   339: *  Bit Number.s Static
                            	   340: 
                            	   341: *             EA = Dn  - LONG only
00:000026AA 203C80000001    	   342:             move.l #$80000001,d0      * populate test data
00:000026B0 08000000        	   343:             btst.l #0,d0
00:000026B4 67FE            	   344:             beq.s *               * branch if Z set
00:000026B6 08000001        	   345:             btst.l #1,d0              *
00:000026BA 66FE            	   346:             bne.s *               * branch if Z clear
00:000026BC 0800001F        	   347:             btst.l #31,d0             *
00:000026C0 67FE            	   348:             beq.s *               * branch if Z set
                            	   349: 
                            	   350: 
                            	   351: *             EA = (An)  - BYTE only
00:000026C2 307C0100        	   352:             move.l #$00000100,a0      * point to memory to address 0x100
00:000026C6 10BC0081        	   353:             move.b #$81,(a0)          * populate test data
00:000026CA 1210            	   354:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:000026CC 08100000        	   355:             btst.b #0,(a0)
00:000026D0 67FE            	   356:             beq.s *               * branch if Z set
00:000026D2 08100001        	   357:             btst.b #1,(a0)            *
00:000026D6 66FE            	   358:             bne.s *               * branch if Z clear
00:000026D8 08100007        	   359:             btst.b #7,(a0)            *
00:000026DC 67FE            	   360:             beq.s *               * branch if Z set
                            	   361: 
                            	   362: 
                            	   363: *             EA = (An)+  - BYTE only
00:000026DE 307C0100        	   364:             move.l #$00000100,a0      * point to memory to address 0x100
00:000026E2 10FC0001        	   365:             move.b #$01,(a0)+         * populate test data
00:000026E6 10FC00FC        	   366:             move.b #$FC,(a0)+         * populate test data
00:000026EA 10FC0080        	   367:             move.b #$80,(a0)+         * populate test data
00:000026EE 307C0100        	   368:             move.l #$00000100,a0      * point to memory to address 0x100
00:000026F2 08180000        	   369:             btst.b #0,(a0)+
00:000026F6 67FE            	   370:             beq.s *               * branch if Z set
00:000026F8 08180001        	   371:             btst.b #1,(a0)+           *
00:000026FC 66FE            	   372:             bne.s *               * branch if Z clear
00:000026FE 08180007        	   373:             btst.b #7,(a0)+           *
00:00002702 67FE            	   374:             beq.s *               * branch if Z set
                            	   375: 
                            	   376: 
                            	   377: *             EA = -(An)  - BYTE only
00:00002704 307C0100        	   378:             move.l #$00000100,a0      * point to memory to address
00:00002708 10FC0080        	   379:             move.b #$80,(a0)+         * populate test data
00:0000270C 10FC00FC        	   380:             move.b #$FC,(a0)+         * populate test data
00:00002710 10FC0001        	   381:             move.b #$01,(a0)+         * populate test data
00:00002714 307C0103        	   382:             move.l #$00000103,a0      * point to memory to address
00:00002718 08200000        	   383:             btst.b #0,-(a0)
00:0000271C 67FE            	   384:             beq.s *               * branch if Z set
00:0000271E 08200001        	   385:             btst.b #1,-(a0)           *
00:00002722 66FE            	   386:             bne.s *               * branch if Z clear
00:00002724 08200007        	   387:             btst.b #7,-(a0)           *
00:00002728 67FE            	   388:             beq.s *               * branch if Z set
                            	   389: 
                            	   390: 
                            	   391: *             EA = n(An)  - BYTE only
00:0000272A 307C0100        	   392:             move.l #$00000100,a0      * point to memory to address
00:0000272E 10FC0001        	   393:             move.b #$01,(a0)+         * populate test data
00:00002732 10FC00FC        	   394:             move.b #$FC,(a0)+         * populate test data
00:00002736 10FC0080        	   395:             move.b #$80,(a0)+         * populate test data
00:0000273A 307C0100        	   396:             move.l #$00000100,a0      * point to memory to address
00:0000273E 08100000        	   397:             btst.b #0,0(a0)
00:00002742 67FE            	   398:             beq.s *               * branch if Z set
00:00002744 082800010001    	   399:             btst.b #1,1(a0)           *
00:0000274A 66FE            	   400:             bne.s *               * branch if Z clear
00:0000274C 082800070002    	   401:             btst.b #7,2(a0)           *
00:00002752 67FE            	   402:             beq.s *               * branch if Z set
                            	   403: 
                            	   404: 
                            	   405: *             EA = n(An,R.W)  - BYTE only
00:00002754 307C0100        	   406:             move.l #$00000100,a0      * point to memory to address
00:00002758 93C9            	   407:             move.l #$00000000,a1      * point to memory to address
00:0000275A 347C0001        	   408:             move.l #$00000001,a2      * point to memory to address
00:0000275E 7000            	   409:             moveq  #$00000000,d0      * point to memory to address
00:00002760 7201            	   410:             moveq  #$00000001,d1      * point to memory to address
00:00002762 083000000000    	   411:             btst.b #0,0(a0,d0.w)
00:00002768 67FE            	   412:             beq.s *               * branch if Z set
00:0000276A 083000011000    	   413:             btst.b #1,0(a0,d1.w)      *
00:00002770 66FE            	   414:             bne.s *               * branch if Z clear
00:00002772 083000071001    	   415:             btst.b #7,1(a0,d1.w)      *
00:00002778 67FE            	   416:             beq.s *               * branch if Z set
                            	   417: *             EA = n(An,R.L)  - BYTE only
00:0000277A 083000000800    	   418:             btst.b #0,0(a0,d0.l)
00:00002780 67FE            	   419:             beq.s *               * branch if Z set
00:00002782 083000011800    	   420:             btst.b #1,0(a0,d1.l)      *
00:00002788 66FE            	   421:             bne.s *               * branch if Z clear
00:0000278A 083000071801    	   422:             btst.b #7,1(a0,d1.l)      *
00:00002790 67FE            	   423:             beq.s *               * branch if Z set
                            	   424: *             EA = n(An,A.W)  - BYTE only
00:00002792 083000009000    	   425:             btst.b #0,0(a0,a1.w)
00:00002798 67FE            	   426:             beq.s *               * branch if Z set
00:0000279A 08300001A000    	   427:             btst.b #1,0(a0,a2.w)      *
00:000027A0 66FE            	   428:             bne.s *               * branch if Z clear
00:000027A2 08300007A001    	   429:             btst.b #7,1(a0,a2.w)      *
00:000027A8 67FE            	   430:             beq.s *               * branch if Z set
                            	   431: *             EA = n(An,A.L)  - BYTE only
00:000027AA 083000009800    	   432:             btst.b #0,0(a0,a1.l)
00:000027B0 67FE            	   433:             beq.s *               * branch if Z set
00:000027B2 08300001A800    	   434:             btst.b #1,0(a0,a2.l)      *
00:000027B8 66FE            	   435:             bne.s *               * branch if Z clear
00:000027BA 08300007A801    	   436:             btst.b #7,1(a0,a2.l)      *
00:000027C0 67FE            	   437:             beq.s *               * branch if Z set
                            	   438: 
                            	   439: 
                            	   440: *             EA = x.W  - BYTE only
00:000027C2 083800000100    	   441:             btst.b #0,$0100
00:000027C8 67FE            	   442:             beq.s *               * branch if Z set
00:000027CA 083800010101    	   443:             btst.b #1,$0101           *
00:000027D0 66FE            	   444:             bne.s *               * branch if Z clear
00:000027D2 083800070102    	   445:             btst.b #7,$0102           *
00:000027D8 67FE            	   446:             beq.s *               * branch if Z set
                            	   447: 
                            	   448: 
                            	   449: *             EA = x.L  - BYTE only
00:000027DA 207C0000F100    	   450:             move.l #$F100,a0      * point to memory to address 0x100
00:000027E0 10FC0001        	   451:             move.b #$01,(a0)+         * populate test data
00:000027E4 10FC00FC        	   452:             move.b #$FC,(a0)+         * populate test data
00:000027E8 10FC0080        	   453:             move.b #$80,(a0)+         * populate test data
00:000027EC 083900000000F100	   454:             btst.b #0,$F100
00:000027F4 67FE            	   455:             beq.s *               * branch if Z set
00:000027F6 083900010000F101	   456:             btst.b #1,$F101       *
00:000027FE 66FE            	   457:             bne.s *               * branch if Z clear
00:00002800 083900070000F102	   458:             btst.b #7,$F102       *
00:00002808 67FE            	   459:             beq.s *               * branch if Z set
                            	   460: 
                            	   461: 
                            	   462: *             EA = x(PC)  - BYTE only
00:0000280A 4BFAFE9E        	   463:             lea op_BTST(pc),a5
00:0000280E 083A0000FE98    	   464:             btst.b #0,op_BTST(pc)
00:00002814 66FE            	   465:             bne.s *               * branch if Z clear
00:00002816 083A0003001A    	   466:             btst.b #3,op_BTST0(pc)     *
00:0000281C 67FE            	   467:             beq.s *               * branch if Z set
00:0000281E 083A00060074    	   468:             btst.b #6,op_BTST12(pc)    *
00:00002824 67FE            	   469:             beq.s *               * branch if Z set
                            	   470: 
                            	   471: 
                            	   472: *             EA = n(PC,R.W)  - BYTE only
00:00002826 307C0100        	   473:             move.l #$00000100,a0      * point to memory to address
00:0000282A 93C9            	   474:             move.l #$00000000,a1      * point to memory to address
00:0000282C 347C0001        	   475:             move.l #$00000001,a2      * point to memory to address
00:00002830 7000            	   476:             moveq  #$00000000,d0      * point to memory to address
00:00002832 7201            	   477:             moveq  #$00000001,d1      * point to memory to address
                            	   478: 
00:00002834 083B000000FC    	   479: op_BTST0:   btst.b #0,op_BTST0(pc,d0.w)
00:0000283A 66FE            	   480:             bne.s *               * branch if Z clear
                            	   481: 
00:0000283C 4BFB1002        	   482:             lea op_BTST1(pc,d1.w),a5
00:00002840 083B000110FC    	   483: op_BTST1:   btst.b #1,op_BTST1(pc,d1.w)      *
00:00002846 67FE            	   484:             beq.s *               * branch if Z set
00:00002848 083B000710FC    	   485: op_BTST2:   btst.b #7,op_BTST2(pc,d1.w)      *
00:0000284E 66FE            	   486:             bne.s *               * branch if Z clear
                            	   487: *             EA = n(PC,R.L)  - BYTE only
00:00002850 083B000008FC    	   488: op_BTST3:   btst.b #0,op_BTST3(pc,d0.l)
00:00002856 66FE            	   489:             bne.s *               * branch if Z clear
00:00002858 083B000118FC    	   490: op_BTST4:   btst.b #1,op_BTST4(pc,d1.l)      *
00:0000285E 67FE            	   491:             beq.s *               * branch if Z set
00:00002860 083B000718FC    	   492: op_BTST5:   btst.b #7,op_BTST5(pc,d1.l)      *
00:00002866 66FE            	   493:             bne.s *               * branch if Z clear
                            	   494: *             EA = n(PC,A.W)  - BYTE only
00:00002868 083B000090FC    	   495: op_BTST6    btst.b #0,op_BTST6(pc,a1.w)
00:0000286E 66FE            	   496:             bne.s *               * branch if Z clear
00:00002870 083B0001A0FC    	   497: op_BTST7:   btst.b #1,op_BTST7(pc,a2.w)      *
00:00002876 67FE            	   498:             beq.s *               * branch if Z set
00:00002878 083B0007A0FC    	   499: op_BTST8:   btst.b #7,op_BTST8(pc,a2.w)      *
00:0000287E 66FE            	   500:             bne.s *               * branch if Z clear
                            	   501: *             EA = n(PC,A.L)  - BYTE only
00:00002880 083B000098FC    	   502: op_BTST9:   btst.b #0,op_BTST9(pc,a1.l)
00:00002886 66FE            	   503:             bne.s *               * branch if Z clear
00:00002888 083B0001A8FC    	   504: op_BTST10:  btst.b #1,op_BTST10(pc,a2.l)      *
00:0000288E 67FE            	   505:             beq.s *               * branch if Z set
00:00002890 083B0007A8FC    	   506: op_BTST11:  btst.b #7,op_BTST11(pc,a2.l)      *
00:00002896 66FE            	   507: op_BTST12:  bne.s *               * branch if Z clear
                            	   508: 
                            	   509: 
                            	   510: 
                            	   511: * Bit Number.s Dynamic
                            	   512: 
                            	   513: *             EA = Dn  - LONG only
00:00002898 203C80000001    	   514:             move.l #$80000001,d0      * populate test data
00:0000289E 7A00            	   515:             move.l #0,d5              * populate bit.s number to test
00:000028A0 7C01            	   516:             move.l #1,d6              * populate bit.s number to test
00:000028A2 7E1F            	   517:             move.l #31,d7              * populate bit.s number to test
                            	   518: 
00:000028A4 0B00            	   519:             btst.l d5,d0
00:000028A6 67FE            	   520:             beq.s *               * branch if Z set
00:000028A8 0D00            	   521:             btst.l d6,d0              *
00:000028AA 66FE            	   522:             bne.s *               * branch if Z clear
00:000028AC 0F00            	   523:             btst.l d7,d0             *
00:000028AE 67FE            	   524:             beq.s *               * branch if Z set
                            	   525: 
                            	   526: 
                            	   527: *             EA = (An)  - BYTE only
00:000028B0 7A00            	   528:             move.l #0,d5              * populate bit.s number to test
00:000028B2 7C01            	   529:             move.l #1,d6              * populate bit.s number to test
00:000028B4 7E07            	   530:             move.l #7,d7              * populate bit.s number to test
00:000028B6 307C0100        	   531:             move.l #$00000100,a0      * point to memory to address 0x100
00:000028BA 10BC0081        	   532:             move.b #$81,(a0)          * populate test data
00:000028BE 1210            	   533:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:000028C0 0B10            	   534:             btst.b d5,(a0)
00:000028C2 67FE            	   535:             beq.s *               * branch if Z set
00:000028C4 0D10            	   536:             btst.b d6,(a0)            *
00:000028C6 66FE            	   537:             bne.s *               * branch if Z clear
00:000028C8 0F10            	   538:             btst.b d7,(a0)            *
00:000028CA 67FE            	   539:             beq.s *               * branch if Z set
                            	   540: 
                            	   541: * ---
                            	   542: 
                            	   543: 
                            	   544: *             EA = (An)+  - BYTE only
00:000028CC 307C0100        	   545:             move.l #$00000100,a0      * point to memory to address 0x100
00:000028D0 10FC0001        	   546:             move.b #$01,(a0)+         * populate test data
00:000028D4 10FC00FC        	   547:             move.b #$FC,(a0)+         * populate test data
00:000028D8 10FC0080        	   548:             move.b #$80,(a0)+         * populate test data
00:000028DC 307C0100        	   549:             move.l #$00000100,a0      * point to memory to address 0x100
00:000028E0 0B18            	   550:             btst.b d5,(a0)+
00:000028E2 67FE            	   551:             beq.s *               * branch if Z set
00:000028E4 0D18            	   552:             btst.b d6,(a0)+           *
00:000028E6 66FE            	   553:             bne.s *               * branch if Z clear
00:000028E8 0F18            	   554:             btst.b d7,(a0)+           *
00:000028EA 67FE            	   555:             beq.s *               * branch if Z set
                            	   556: 
                            	   557: 
                            	   558: *             EA = -(An)  - BYTE only
00:000028EC 307C0100        	   559:             move.l #$00000100,a0      * point to memory to address
00:000028F0 10FC0080        	   560:             move.b #$80,(a0)+         * populate test data
00:000028F4 10FC00FC        	   561:             move.b #$FC,(a0)+         * populate test data
00:000028F8 10FC0001        	   562:             move.b #$01,(a0)+         * populate test data
00:000028FC 307C0103        	   563:             move.l #$00000103,a0      * point to memory to address
00:00002900 0B20            	   564:             btst.b d5,-(a0)
00:00002902 67FE            	   565:             beq.s *               * branch if Z set
00:00002904 0D20            	   566:             btst.b d6,-(a0)           *
00:00002906 66FE            	   567:             bne.s *               * branch if Z clear
00:00002908 0F20            	   568:             btst.b d7,-(a0)           *
00:0000290A 67FE            	   569:             beq.s *               * branch if Z set
                            	   570: 
                            	   571: 
                            	   572: *             EA = n(An)  - BYTE only
00:0000290C 307C0100        	   573:             move.l #$00000100,a0      * point to memory to address
00:00002910 10FC0001        	   574:             move.b #$01,(a0)+         * populate test data
00:00002914 10FC00FC        	   575:             move.b #$FC,(a0)+         * populate test data
00:00002918 10FC0080        	   576:             move.b #$80,(a0)+         * populate test data
00:0000291C 307C0100        	   577:             move.l #$00000100,a0      * point to memory to address
00:00002920 0B10            	   578:             btst.b d5,0(a0)
00:00002922 67FE            	   579:             beq.s *               * branch if Z set
00:00002924 0D280001        	   580:             btst.b d6,1(a0)           *
00:00002928 66FE            	   581:             bne.s *               * branch if Z clear
00:0000292A 0F280002        	   582:             btst.b d7,2(a0)           *
00:0000292E 67FE            	   583:             beq.s *               * branch if Z set
                            	   584: 
                            	   585: 
                            	   586: *             EA = n(An,R.W)  - BYTE only
00:00002930 307C0100        	   587:             move.l #$00000100,a0      * point to memory to address
00:00002934 93C9            	   588:             move.l #$00000000,a1      * point to memory to address
00:00002936 347C0001        	   589:             move.l #$00000001,a2      * point to memory to address
00:0000293A 7000            	   590:             moveq  #$00000000,d0      * point to memory to address
00:0000293C 7201            	   591:             moveq  #$00000001,d1      * point to memory to address
00:0000293E 0B300000        	   592:             btst.b d5,0(a0,d0.w)
00:00002942 67FE            	   593:             beq.s *               * branch if Z set
00:00002944 0D301000        	   594:             btst.b d6,0(a0,d1.w)      *
00:00002948 66FE            	   595:             bne.s *               * branch if Z clear
00:0000294A 0F301001        	   596:             btst.b d7,1(a0,d1.w)      *
00:0000294E 67FE            	   597:             beq.s *               * branch if Z set
                            	   598: *             EA = n(An,R.L)  - BYTE only
00:00002950 0B300800        	   599:             btst.b d5,0(a0,d0.l)
00:00002954 67FE            	   600:             beq.s *               * branch if Z set
00:00002956 0D301800        	   601:             btst.b d6,0(a0,d1.l)      *
00:0000295A 66FE            	   602:             bne.s *               * branch if Z clear
00:0000295C 0F301801        	   603:             btst.b d7,1(a0,d1.l)      *
00:00002960 67FE            	   604:             beq.s *               * branch if Z set
                            	   605: *             EA = n(An,A.W)  - BYTE only
00:00002962 0B309000        	   606:             btst.b d5,0(a0,a1.w)
00:00002966 67FE            	   607:             beq.s *               * branch if Z set
00:00002968 0D30A000        	   608:             btst.b d6,0(a0,a2.w)      *
00:0000296C 66FE            	   609:             bne.s *               * branch if Z clear
00:0000296E 0F30A001        	   610:             btst.b d7,1(a0,a2.w)      *
00:00002972 67FE            	   611:             beq.s *               * branch if Z set
                            	   612: *             EA = n(An,A.L)  - BYTE only
00:00002974 0B309800        	   613:             btst.b d5,0(a0,a1.l)
00:00002978 67FE            	   614:             beq.s *               * branch if Z set
00:0000297A 0D30A800        	   615:             btst.b d6,0(a0,a2.l)      *
00:0000297E 66FE            	   616:             bne.s *               * branch if Z clear
00:00002980 0F30A801        	   617:             btst.b d7,1(a0,a2.l)      *
00:00002984 67FE            	   618:             beq.s *               * branch if Z set
                            	   619: 
                            	   620: 
                            	   621: *             EA = x.W  - BYTE only
00:00002986 0B380100        	   622:             btst.b d5,$0100
00:0000298A 67FE            	   623:             beq.s *               * branch if Z set
00:0000298C 0D380101        	   624:             btst.b d6,$0101           *
00:00002990 66FE            	   625:             bne.s *               * branch if Z clear
00:00002992 0F380102        	   626:             btst.b d7,$0102           *
00:00002996 67FE            	   627:             beq.s *               * branch if Z set
                            	   628: 
                            	   629: 
                            	   630: *             EA = x.L  - BYTE only
00:00002998 207C0000F100    	   631:             move.l #$F100,a0      * point to memory to address 0x100
00:0000299E 10FC0001        	   632:             move.b #$01,(a0)+         * populate test data
00:000029A2 10FC00FC        	   633:             move.b #$FC,(a0)+         * populate test data
00:000029A6 10FC0080        	   634:             move.b #$80,(a0)+         * populate test data
00:000029AA 0B390000F100    	   635:             btst.b d5,$F100
00:000029B0 67FE            	   636:             beq.s *               * branch if Z set
00:000029B2 0D390000F101    	   637:             btst.b d6,$F101       *
00:000029B8 66FE            	   638:             bne.s *               * branch if Z clear
00:000029BA 0F390000F102    	   639:             btst.b d7,$F102       *
00:000029C0 67FE            	   640:             beq.s *               * branch if Z set
                            	   641: 
                            	   642: 
                            	   643: *             EA = x(PC)  - BYTE only
00:000029C2 7C03            	   644:             move.l #3,d6              * populate bit.s number to test
00:000029C4 7E06            	   645:             move.l #6,d7              * populate bit.s number to test
00:000029C6 4BFAFCE2        	   646:             lea op_BTST(pc),a5
00:000029CA 0B3AFCDE        	   647:             btst.b d5,op_BTST(pc)
00:000029CE 66FE            	   648:             bne.s *               * branch if Z clear
00:000029D0 0D3AFE62        	   649:             btst.b d6,op_BTST0(pc)     *
00:000029D4 67FE            	   650:             beq.s *               * branch if Z set
00:000029D6 0F3AFEBE        	   651:             btst.b d7,op_BTST12(pc)    *
00:000029DA 67FE            	   652:             beq.s *               * branch if Z set
                            	   653: 
                            	   654: 
                            	   655: *             EA = n(PC,R.W)  - BYTE only
00:000029DC 307C0100        	   656:             move.l #$00000100,a0      * point to memory to address
00:000029E0 93C9            	   657:             move.l #$00000000,a1      * point to memory to address
00:000029E2 347C0001        	   658:             move.l #$00000001,a2      * point to memory to address
00:000029E6 7000            	   659:             moveq  #$00000000,d0      * point to memory to address
00:000029E8 7201            	   660:             moveq  #$00000001,d1      * point to memory to address
00:000029EA 7C01            	   661:             move.l #1,d6              * populate bit.s number to test
00:000029EC 7E07            	   662:             move.l #7,d7              * populate bit.s number to test
                            	   663: 
00:000029EE 0B3B00FE        	   664: op_BTST20:  btst.b d5,op_BTST20(pc,d0.w)
00:000029F2 67FE            	   665:             beq.s *               * branch if Z set
00:000029F4 4BFB1002        	   666:             lea op_BTST21(pc,d1.w),a5
00:000029F8 0D3B10FE        	   667: op_BTST21:  btst.b d6,op_BTST21(pc,d1.w)      *
00:000029FC 67FE            	   668:             beq.s *               * branch if Z set
00:000029FE 0F3B10FE        	   669: op_BTST22:  btst.b d7,op_BTST22(pc,d1.w)      *
00:00002A02 66FE            	   670:             bne.s *               * branch if Z clear
                            	   671: *             EA = n(PC,R.L)  - BYTE only
00:00002A04 0B3B08FE        	   672: op_BTST23:  btst.b d5,op_BTST23(pc,d0.l)
00:00002A08 67FE            	   673:             beq.s *               * branch if Z set
00:00002A0A 0D3B18FE        	   674: op_BTST24: btst.b d6,op_BTST24(pc,d1.l)      *
00:00002A0E 67FE            	   675:             beq.s *               * branch if Z set
00:00002A10 0F3B18FE        	   676: op_BTST25  btst.b d7,op_BTST25(pc,d1.l)      *
00:00002A14 66FE            	   677:             bne.s *               * branch if Z clear
                            	   678: *             EA = n(PC,A.W)  - BYTE only
00:00002A16 0B3B90FE        	   679: op_BTST26   btst.b d5,op_BTST26(pc,a1.w)
00:00002A1A 67FE            	   680:             beq.s *               * branch if Z set
00:00002A1C 0D3BA0FE        	   681: op_BTST27:  btst.b d6,op_BTST27(pc,a2.w)      *
00:00002A20 67FE            	   682:             beq.s *               * branch if Z set
00:00002A22 0F3BA0FE        	   683: op_BTST28:  btst.b d7,op_BTST28(pc,a2.w)      *
00:00002A26 66FE            	   684:             bne.s *               * branch if Z clear
                            	   685: *             EA = n(PC,A.L)  - BYTE only
00:00002A28 0B3B98FE        	   686: op_BTST29:  btst.b d5,op_BTST29(pc,a1.l)
00:00002A2C 67FE            	   687:             beq.s *               * branch if Z set
00:00002A2E 0D3BA8FE        	   688: op_BTST30:  btst.b d6,op_BTST30(pc,a2.l)      *
00:00002A32 67FE            	   689:             beq.s *               * branch if Z set
00:00002A34 0F3BA8FE        	   690: op_BTST31:  btst.b d7,op_BTST31(pc,a2.l)      *
00:00002A38 66FE            	   691: op_BTST32:  bne.s *               * branch if Z clear
                            	   692: 
                            	   693: *             EA = #x  - BYTE only
                            	   694: 
00:00002A3A 7A00            	   695:             move.l #0,d5              * populate bit.s number to test
00:00002A3C 7C03            	   696:             move.l #3,d6              * populate bit.s number to test
00:00002A3E 7E07            	   697:             move.l #7,d7              * populate bit.s number to test
                            	   698: 
00:00002A40 0B3C0088        	   699:             btst.b d5,#$88
00:00002A44 66FE            	   700:             bne.s *               * branch if Z clear
00:00002A46 0D3C0088        	   701:             btst.b d6,#$88
00:00002A4A 67FE            	   702:             beq.s *               * branch if Z set
00:00002A4C 0F3C0088        	   703:             btst.b d7,#$88
00:00002A50 67FE            	   704:             beq.s *               * branch if Z set
                            	   705: 
                            	   706: 
00:00002A52 4E75            	   707:     rts
                            	   708: 
                            	   709: *-----------------------------------------------------------
                            	   710: *-----------------------------------------------------------
                            	   711: * OPCODE : BCHG
                            	   712: *-----------------------------------------------------------
                            	   713: *-----------------------------------------------------------
                            	   714: op_BCHG:
                            	   715: 
                            	   716: 
                            	   717: *  Bit Number.s Static
                            	   718: 
                            	   719: *             EA = Dn  - LONG only
00:00002A54 203C80000001    	   720:             move.l #$80000001,d0      * populate test data
00:00002A5A 08400000        	   721:             bchg.l #0,d0
00:00002A5E 67FE            	   722:             beq.s *               * branch if Z set
00:00002A60 08400001        	   723:             bchg.l #1,d0              *
00:00002A64 66FE            	   724:             bne.s *               * branch if Z clear
00:00002A66 0840001F        	   725:             bchg.l #31,d0             *
00:00002A6A 67FE            	   726:             beq.s *               * branch if Z set
00:00002A6C 0C8000000002    	   727:             cmpi.l #$00000002,d0
00:00002A72 66FE            	   728:             bne.s *               * branch if Z clear
                            	   729: 
                            	   730: 
                            	   731: *             EA = (An)  - BYTE only
00:00002A74 307C0100        	   732:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002A78 10BC0081        	   733:             move.b #$81,(a0)          * populate test data
00:00002A7C 1210            	   734:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00002A7E 08500000        	   735:             bchg.b #0,(a0)
00:00002A82 67FE            	   736:             beq.s *               * branch if Z set
00:00002A84 08500001        	   737:             bchg.b #1,(a0)            *
00:00002A88 66FE            	   738:             bne.s *               * branch if Z clear
00:00002A8A 08500007        	   739:             bchg.b #7,(a0)            *
00:00002A8E 67FE            	   740:             beq.s *               * branch if Z set
00:00002A90 0C100002        	   741:             cmpi.b #$02,(a0)
00:00002A94 66FE            	   742:             bne.s *               * branch if Z clear
                            	   743: 
                            	   744: *             EA = (An)+  - BYTE only
00:00002A96 307C0100        	   745:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002A9A 10FC0001        	   746:             move.b #$01,(a0)+         * populate test data
00:00002A9E 10FC00FC        	   747:             move.b #$FC,(a0)+         * populate test data
00:00002AA2 10FC0080        	   748:             move.b #$80,(a0)+         * populate test data
00:00002AA6 307C0100        	   749:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002AAA 08580000        	   750:             bchg.b #0,(a0)+
00:00002AAE 67FE            	   751:             beq.s *               * branch if Z set
00:00002AB0 08580001        	   752:             bchg.b #1,(a0)+           *
00:00002AB4 66FE            	   753:             bne.s *               * branch if Z clear
00:00002AB6 08580007        	   754:             bchg.b #7,(a0)+           *
00:00002ABA 67FE            	   755:             beq.s *               * branch if Z set
00:00002ABC 307C0100        	   756:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002AC0 4A18            	   757:             cmpi.b #$00,(a0)+
00:00002AC2 66FE            	   758:             bne.s *               * branch if Z clear
00:00002AC4 0C1800FE        	   759:             cmpi.b #$FE,(a0)+
00:00002AC8 66FE            	   760:             bne.s *               * branch if Z clear
00:00002ACA 4A18            	   761:             cmpi.b #$00,(a0)+
00:00002ACC 66FE            	   762:             bne.s *               * branch if Z clear
                            	   763: 
                            	   764: *             EA = -(An)  - BYTE only
00:00002ACE 307C0100        	   765:             move.l #$00000100,a0      * point to memory to address
00:00002AD2 10FC0080        	   766:             move.b #$80,(a0)+         * populate test data
00:00002AD6 10FC00FC        	   767:             move.b #$FC,(a0)+         * populate test data
00:00002ADA 10FC0001        	   768:             move.b #$01,(a0)+         * populate test data
00:00002ADE 307C0103        	   769:             move.l #$00000103,a0      * point to memory to address
00:00002AE2 08600000        	   770:             bchg.b #0,-(a0)
00:00002AE6 67FE            	   771:             beq.s *               * branch if Z set
00:00002AE8 08600001        	   772:             bchg.b #1,-(a0)           *
00:00002AEC 66FE            	   773:             bne.s *               * branch if Z clear
00:00002AEE 08600007        	   774:             bchg.b #7,-(a0)           *
00:00002AF2 67FE            	   775:             beq.s *               * branch if Z set
00:00002AF4 307C0103        	   776:             move.l #$00000103,a0      * point to memory to address 0x100
00:00002AF8 4A20            	   777:             cmpi.b #$00,-(a0)
00:00002AFA 66FE            	   778:             bne.s *               * branch if Z clear
00:00002AFC 0C2000FE        	   779:             cmpi.b #$FE,-(a0)
00:00002B00 66FE            	   780:             bne.s *               * branch if Z clear
00:00002B02 4A20            	   781:             cmpi.b #$00,-(a0)
00:00002B04 66FE            	   782:             bne.s *               * branch if Z clear
                            	   783: 
                            	   784: 
                            	   785: *             EA = n(An)  - BYTE only
00:00002B06 307C0100        	   786:             move.l #$00000100,a0      * point to memory to address
00:00002B0A 10FC0001        	   787:             move.b #$01,(a0)+         * populate test data
00:00002B0E 10FC00FC        	   788:             move.b #$FC,(a0)+         * populate test data
00:00002B12 10FC0080        	   789:             move.b #$80,(a0)+         * populate test data
00:00002B16 307C0100        	   790:             move.l #$00000100,a0      * point to memory to address
00:00002B1A 08500000        	   791:             bchg.b #0,0(a0)
00:00002B1E 67FE            	   792:             beq.s *               * branch if Z set
00:00002B20 086800010001    	   793:             bchg.b #1,1(a0)           *
00:00002B26 66FE            	   794:             bne.s *               * branch if Z clear
00:00002B28 086800070002    	   795:             bchg.b #7,2(a0)           *
00:00002B2E 67FE            	   796:             beq.s *               * branch if Z set
00:00002B30 307C0100        	   797:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002B34 4A18            	   798:             cmpi.b #$00,(a0)+
00:00002B36 66FE            	   799:             bne.s *               * branch if Z clear
00:00002B38 0C1800FE        	   800:             cmpi.b #$FE,(a0)+
00:00002B3C 66FE            	   801:             bne.s *               * branch if Z clear
00:00002B3E 4A18            	   802:             cmpi.b #$00,(a0)+
00:00002B40 66FE            	   803:             bne.s *               * branch if Z clear
                            	   804: 
                            	   805: 
                            	   806: *             EA = n(An,D.W)  - BYTE only
00:00002B42 307C0100        	   807:             move.l #$00000100,a0      * point to memory to address
00:00002B46 93C9            	   808:             move.l #$00000000,a1      * point to memory to address
00:00002B48 347C0001        	   809:             move.l #$00000001,a2      * point to memory to address
00:00002B4C 7000            	   810:             moveq  #$00000000,d0      * point to memory to address
00:00002B4E 7201            	   811:             moveq  #$00000001,d1      * point to memory to address
00:00002B50 087000000000    	   812:             bchg.b #0,0(a0,d0.w)
00:00002B56 66FE            	   813:             bne.s *               * branch if Z clear
00:00002B58 087000011000    	   814:             bchg.b #1,0(a0,d1.w)      *
00:00002B5E 67FE            	   815:             beq.s *               * branch if Z set
00:00002B60 087000071001    	   816:             bchg.b #7,1(a0,d1.w)      *
00:00002B66 66FE            	   817:             bne.s *               * branch if Z clear
                            	   818: *             EA = n(An,D.L)  - BYTE only
00:00002B68 087000000800    	   819:             bchg.b #0,0(a0,d0.l)
00:00002B6E 67FE            	   820:             beq.s *               * branch if Z set
00:00002B70 087000011800    	   821:             bchg.b #1,0(a0,d1.l)      *
00:00002B76 66FE            	   822:             bne.s *               * branch if Z clear
00:00002B78 087000071801    	   823:             bchg.b #7,1(a0,d1.l)      *
00:00002B7E 67FE            	   824:             beq.s *               * branch if Z set
                            	   825: *             EA = n(An,A.W)  - BYTE only
00:00002B80 087000009000    	   826:             bchg.b #0,0(a0,a1.w)
00:00002B86 66FE            	   827:             bne.s *               * branch if Z clear
00:00002B88 08700001A000    	   828:             bchg.b #1,0(a0,a2.w)      *
00:00002B8E 67FE            	   829:             beq.s *               * branch if Z set
00:00002B90 08700007A001    	   830:             bchg.b #7,1(a0,a2.w)      *
00:00002B96 66FE            	   831:             bne.s *               * branch if Z clear
                            	   832: *             EA = n(An,A.L)  - BYTE only
00:00002B98 087000009800    	   833:             bchg.b #0,0(a0,a1.l)
00:00002B9E 67FE            	   834:             beq.s *               * branch if Z set
00:00002BA0 08700001A800    	   835:             bchg.b #1,0(a0,a2.l)      *
00:00002BA6 66FE            	   836:             bne.s *               * branch if Z clear
00:00002BA8 08700007A801    	   837:             bchg.b #7,1(a0,a2.l)      *
00:00002BAE 67FE            	   838:             beq.s *               * branch if Z set
00:00002BB0 307C0100        	   839:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002BB4 4A18            	   840:             cmpi.b #$00,(a0)+
00:00002BB6 66FE            	   841:             bne.s *               * branch if Z clear
00:00002BB8 0C1800FE        	   842:             cmpi.b #$FE,(a0)+
00:00002BBC 66FE            	   843:             bne.s *               * branch if Z clear
00:00002BBE 4A18            	   844:             cmpi.b #$00,(a0)+
00:00002BC0 66FE            	   845:             bne.s *               * branch if Z clear
                            	   846: 
                            	   847: 
                            	   848: *             EA = x.W  - BYTE only
00:00002BC2 087800000100    	   849:             bchg.b #0,$0100
00:00002BC8 66FE            	   850:             bne.s *               * branch if Z clear
00:00002BCA 087800010101    	   851:             bchg.b #1,$0101           *
00:00002BD0 67FE            	   852:             beq.s *               * branch if Z set
00:00002BD2 087800070102    	   853:             bchg.b #7,$0102           *
00:00002BD8 66FE            	   854:             bne.s *               * branch if Z clear
00:00002BDA 307C0100        	   855:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002BDE 0C180001        	   856:             cmpi.b #$01,(a0)+
00:00002BE2 66FE            	   857:             bne.s *               * branch if Z clear
00:00002BE4 0C1800FC        	   858:             cmpi.b #$FC,(a0)+
00:00002BE8 66FE            	   859:             bne.s *               * branch if Z clear
00:00002BEA 0C180080        	   860:             cmpi.b #$80,(a0)+
00:00002BEE 66FE            	   861:             bne.s *               * branch if Z clear
                            	   862: 
                            	   863: *             EA = x.L  - BYTE only
00:00002BF0 207C0000F100    	   864:             move.l #$F100,a0      * point to memory to address 0x100
00:00002BF6 10FC0001        	   865:             move.b #$01,(a0)+         * populate test data
00:00002BFA 10FC00FC        	   866:             move.b #$FC,(a0)+         * populate test data
00:00002BFE 10FC0080        	   867:             move.b #$80,(a0)+         * populate test data
00:00002C02 087900000000F100	   868:             bchg.b #0,$F100
00:00002C0A 67FE            	   869:             beq.s *               * branch if Z set
00:00002C0C 087900010000F101	   870:             bchg.b #1,$F101       *
00:00002C14 66FE            	   871:             bne.s *               * branch if Z clear
00:00002C16 087900070000F102	   872:             bchg.b #7,$F102       *
00:00002C1E 67FE            	   873:             beq.s *               * branch if Z set
00:00002C20 307C0100        	   874:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002C24 0C180001        	   875:             cmpi.b #$01,(a0)+
00:00002C28 66FE            	   876:             bne.s *               * branch if Z clear
00:00002C2A 0C1800FC        	   877:             cmpi.b #$FC,(a0)+
00:00002C2E 66FE            	   878:             bne.s *               * branch if Z clear
00:00002C30 0C180080        	   879:             cmpi.b #$80,(a0)+
00:00002C34 66FE            	   880:             bne.s *               * branch if Z clear
                            	   881: 
                            	   882: 
                            	   883: * Bit Number.s Dynamic
                            	   884: 
                            	   885: *             EA = Dn  - LONG only
00:00002C36 203C80000001    	   886:             move.l #$80000001,d0      * populate test data
00:00002C3C 7A00            	   887:             move.l #0,d5              * populate bit.s number to test
00:00002C3E 7C01            	   888:             move.l #1,d6              * populate bit.s number to test
00:00002C40 7E1F            	   889:             move.l #31,d7              * populate bit.s number to test
                            	   890: 
00:00002C42 0B40            	   891:             bchg.l d5,d0
00:00002C44 67FE            	   892:             beq.s *               * branch if Z set
00:00002C46 0D40            	   893:             bchg.l d6,d0              *
00:00002C48 66FE            	   894:             bne.s *               * branch if Z clear
00:00002C4A 0F40            	   895:             bchg.l d7,d0             *
00:00002C4C 67FE            	   896:             beq.s *               * branch if Z set
00:00002C4E 0C8000000002    	   897:             cmpi.l #$00000002,d0
00:00002C54 66FE            	   898:             bne.s *               * branch if Z clear
                            	   899: 
                            	   900: 
                            	   901: *             EA = (An)  - BYTE only
00:00002C56 7A00            	   902:             move.l #0,d5              * populate bit.s number to test
00:00002C58 7C01            	   903:             move.l #1,d6              * populate bit.s number to test
00:00002C5A 7E07            	   904:             move.l #7,d7              * populate bit.s number to test
00:00002C5C 307C0100        	   905:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002C60 10BC0081        	   906:             move.b #$81,(a0)          * populate test data
00:00002C64 1210            	   907:             move.b (a0),d1            * Check to see if data in memory is 0x81
00:00002C66 0B50            	   908:             bchg.b d5,(a0)
00:00002C68 67FE            	   909:             beq.s *               * branch if Z set
00:00002C6A 0D50            	   910:             bchg.b d6,(a0)            *
00:00002C6C 66FE            	   911:             bne.s *               * branch if Z clear
00:00002C6E 0F50            	   912:             bchg.b d7,(a0)            *
00:00002C70 67FE            	   913:             beq.s *               * branch if Z set
00:00002C72 0C100002        	   914:             cmpi.b #$02,(a0)
00:00002C76 66FE            	   915:             bne.s *               * branch if Z clear
                            	   916: 
                            	   917: 
                            	   918: *             EA = (An)+  - BYTE only
00:00002C78 307C0100        	   919:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002C7C 10FC0001        	   920:             move.b #$01,(a0)+         * populate test data
00:00002C80 10FC00FC        	   921:             move.b #$FC,(a0)+         * populate test data
00:00002C84 10FC0080        	   922:             move.b #$80,(a0)+         * populate test data
00:00002C88 307C0100        	   923:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002C8C 0B58            	   924:             bchg.b d5,(a0)+
00:00002C8E 67FE            	   925:             beq.s *               * branch if Z set
00:00002C90 0D58            	   926:             bchg.b d6,(a0)+           *
00:00002C92 66FE            	   927:             bne.s *               * branch if Z clear
00:00002C94 0F58            	   928:             bchg.b d7,(a0)+           *
00:00002C96 67FE            	   929:             beq.s *               * branch if Z set
00:00002C98 307C0100        	   930:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002C9C 4A18            	   931:             cmpi.b #$00,(a0)+
00:00002C9E 66FE            	   932:             bne.s *               * branch if Z clear
00:00002CA0 0C1800FE        	   933:             cmpi.b #$FE,(a0)+
00:00002CA4 66FE            	   934:             bne.s *               * branch if Z clear
00:00002CA6 4A18            	   935:             cmpi.b #$00,(a0)+
00:00002CA8 66FE            	   936:             bne.s *               * branch if Z clear
                            	   937: 
                            	   938: *             EA = -(An)  - BYTE only
00:00002CAA 307C0100        	   939:             move.l #$00000100,a0      * point to memory to address
00:00002CAE 10FC0080        	   940:             move.b #$80,(a0)+         * populate test data
00:00002CB2 10FC00FC        	   941:             move.b #$FC,(a0)+         * populate test data
00:00002CB6 10FC0001        	   942:             move.b #$01,(a0)+         * populate test data
00:00002CBA 307C0103        	   943:             move.l #$00000103,a0      * point to memory to address
00:00002CBE 0B60            	   944:             bchg.b d5,-(a0)
00:00002CC0 67FE            	   945:             beq.s *               * branch if Z set
00:00002CC2 0D60            	   946:             bchg.b d6,-(a0)           *
00:00002CC4 66FE            	   947:             bne.s *               * branch if Z clear
00:00002CC6 0F60            	   948:             bchg.b d7,-(a0)           *
00:00002CC8 67FE            	   949:             beq.s *               * branch if Z set
00:00002CCA 307C0103        	   950:             move.l #$00000103,a0      * point to memory to address 0x100
00:00002CCE 4A20            	   951:             cmpi.b #$00,-(a0)
00:00002CD0 66FE            	   952:             bne.s *               * branch if Z clear
00:00002CD2 0C2000FE        	   953:             cmpi.b #$FE,-(a0)
00:00002CD6 66FE            	   954:             bne.s *               * branch if Z clear
00:00002CD8 4A20            	   955:             cmpi.b #$00,-(a0)
00:00002CDA 66FE            	   956:             bne.s *               * branch if Z clear
                            	   957: 
                            	   958: *             EA = n(An)  - BYTE only
00:00002CDC 307C0100        	   959:             move.l #$00000100,a0      * point to memory to address
00:00002CE0 10FC0001        	   960:             move.b #$01,(a0)+         * populate test data
00:00002CE4 10FC00FC        	   961:             move.b #$FC,(a0)+         * populate test data
00:00002CE8 10FC0080        	   962:             move.b #$80,(a0)+         * populate test data
00:00002CEC 307C0100        	   963:             move.l #$00000100,a0      * point to memory to address
00:00002CF0 0B50            	   964:             bchg.b d5,0(a0)
00:00002CF2 67FE            	   965:             beq.s *               * branch if Z set
00:00002CF4 0D680001        	   966:             bchg.b d6,1(a0)           *
00:00002CF8 66FE            	   967:             bne.s *               * branch if Z clear
00:00002CFA 0F680002        	   968:             bchg.b d7,2(a0)           *
00:00002CFE 67FE            	   969:             beq.s *               * branch if Z set
00:00002D00 307C0100        	   970:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002D04 4A18            	   971:             cmpi.b #$00,(a0)+
00:00002D06 66FE            	   972:             bne.s *               * branch if Z clear
00:00002D08 0C1800FE        	   973:             cmpi.b #$FE,(a0)+
00:00002D0C 66FE            	   974:             bne.s *               * branch if Z clear
00:00002D0E 4A18            	   975:             cmpi.b #$00,(a0)+
00:00002D10 66FE            	   976:             bne.s *               * branch if Z clear
                            	   977: 
                            	   978: *             EA = n(An,R.W)  - BYTE only
00:00002D12 307C0100        	   979:             move.l #$00000100,a0      * point to memory to address
00:00002D16 93C9            	   980:             move.l #$00000000,a1      * point to memory to address
00:00002D18 347C0001        	   981:             move.l #$00000001,a2      * point to memory to address
00:00002D1C 7000            	   982:             moveq  #$00000000,d0      * point to memory to address
00:00002D1E 7201            	   983:             moveq  #$00000001,d1      * point to memory to address
00:00002D20 0B700000        	   984:             bchg.b d5,0(a0,d0.w)
00:00002D24 66FE            	   985:             bne.s *               * branch if Z clear
00:00002D26 0D701000        	   986:             bchg.b d6,0(a0,d1.w)      *
00:00002D2A 67FE            	   987:             beq.s *               * branch if Z set
00:00002D2C 0F701001        	   988:             bchg.b d7,1(a0,d1.w)      *
00:00002D30 66FE            	   989:             bne.s *               * branch if Z clear
                            	   990: *             EA = n(An,R.L)  - BYTE only
00:00002D32 0B700800        	   991:             bchg.b d5,0(a0,d0.l)
00:00002D36 67FE            	   992:             beq.s *               * branch if Z set
00:00002D38 0D701800        	   993:             bchg.b d6,0(a0,d1.l)      *
00:00002D3C 66FE            	   994:             bne.s *               * branch if Z clear
00:00002D3E 0F701801        	   995:             bchg.b d7,1(a0,d1.l)      *
00:00002D42 67FE            	   996:             beq.s *               * branch if Z set
                            	   997: *             EA = n(An,A.W)  - BYTE only
00:00002D44 0B709000        	   998:             bchg.b d5,0(a0,a1.w)
00:00002D48 66FE            	   999:             bne.s *               * branch if Z clear
00:00002D4A 0D70A000        	  1000:             bchg.b d6,0(a0,a2.w)      *
00:00002D4E 67FE            	  1001:             beq.s *               * branch if Z set
00:00002D50 0F70A001        	  1002:             bchg.b d7,1(a0,a2.w)      *
00:00002D54 66FE            	  1003:             bne.s *               * branch if Z clear
                            	  1004: *             EA = n(An,A.L)  - BYTE only
00:00002D56 0B709800        	  1005:             bchg.b d5,0(a0,a1.l)
00:00002D5A 67FE            	  1006:             beq.s *               * branch if Z set
00:00002D5C 0D70A800        	  1007:             bchg.b d6,0(a0,a2.l)      *
00:00002D60 66FE            	  1008:             bne.s *               * branch if Z clear
00:00002D62 0F70A801        	  1009:             bchg.b d7,1(a0,a2.l)      *
00:00002D66 67FE            	  1010:             beq.s *               * branch if Z set
00:00002D68 4A18            	  1011:             cmpi.b #$00,(a0)+
00:00002D6A 66FE            	  1012:             bne.s *               * branch if Z clear
                            	  1013: 
                            	  1014: *             EA = x.W  - BYTE only
00:00002D6C 0B780100        	  1015:             bchg.b d5,$0100
00:00002D70 66FE            	  1016:             bne.s *               * branch if Z clear
00:00002D72 0D780101        	  1017:             bchg.b d6,$0101           *
00:00002D76 67FE            	  1018:             beq.s *               * branch if Z set
00:00002D78 0F780102        	  1019:             bchg.b d7,$0102           *
00:00002D7C 66FE            	  1020:             bne.s *               * branch if Z clear
00:00002D7E 0C1800FC        	  1021:             cmpi.b #$FC,(a0)+
00:00002D82 66FE            	  1022:             bne.s *               * branch if Z clear
                            	  1023: 
                            	  1024: *             EA = x.L  - BYTE only
00:00002D84 207C0000F100    	  1025:             move.l #$F100,a0      * point to memory to address 0x100
00:00002D8A 10FC0001        	  1026:             move.b #$01,(a0)+         * populate test data
00:00002D8E 10FC00FC        	  1027:             move.b #$FC,(a0)+         * populate test data
00:00002D92 10FC0080        	  1028:             move.b #$80,(a0)+         * populate test data
00:00002D96 0B790000F100    	  1029:             bchg.b d5,$F100
00:00002D9C 67FE            	  1030:             beq.s *               * branch if Z set
00:00002D9E 0D790000F101    	  1031:             bchg.b d6,$F101       *
00:00002DA4 66FE            	  1032:             bne.s *               * branch if Z clear
00:00002DA6 0F790000F102    	  1033:             bchg.b d7,$F102       *
00:00002DAC 67FE            	  1034:             beq.s *               * branch if Z set
00:00002DAE 207C0000F101    	  1035:             move.l #$F101,a0      * point to memory to address 0x100
00:00002DB4 0C1000FE        	  1036:             cmpi.b #$FE,(a0)
00:00002DB8 66FE            	  1037:             bne.s *               * branch if Z clear
                            	  1038: 
                            	  1039: 
00:00002DBA 4E75            	  1040:     rts
                            	  1041: 
                            	  1042: *-----------------------------------------------------------
                            	  1043: *-----------------------------------------------------------
                            	  1044: * OPCODE : BCLR
                            	  1045: *-----------------------------------------------------------
                            	  1046: *-----------------------------------------------------------
                            	  1047: op_BCLR:
                            	  1048: 
                            	  1049: 
                            	  1050: *  Bit Number.s Static
                            	  1051: 
                            	  1052: *             EA = Dn  - LONG only
00:00002DBC 203CFF0000FF    	  1053:             move.l #$FF0000FF,d0      * populate test data
00:00002DC2 08800000        	  1054:             bclr.l #0,d0
00:00002DC6 67FE            	  1055:             beq.s *               * branch if Z set
00:00002DC8 08800001        	  1056:             bclr.l #1,d0              *
00:00002DCC 67FE            	  1057:             beq.s *               * branch if Z set
00:00002DCE 0880000F        	  1058:             bclr.l #15,d0             *
00:00002DD2 66FE            	  1059:             bne.s *               * branch if Z clear
00:00002DD4 0880001F        	  1060:             bclr.l #31,d0             *
00:00002DD8 67FE            	  1061:             beq.s *               * branch if Z set
00:00002DDA 0C807F0000FC    	  1062:             cmpi.l #$7F0000FC,d0
00:00002DE0 66FE            	  1063:             bne.s *               * branch if Z clear
                            	  1064: 
                            	  1065: 
                            	  1066: *             EA = (An)  - BYTE only
00:00002DE2 307C0100        	  1067:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002DE6 10BC000F        	  1068:             move.b #$0F,(a0)          * populate test data
00:00002DEA 08900000        	  1069:             bclr.b #0,(a0)
00:00002DEE 67FE            	  1070:             beq.s *               * branch if Z set
00:00002DF0 08900007        	  1071:             bclr.b #7,(a0)            *
00:00002DF4 66FE            	  1072:             bne.s *               * branch if Z clear
00:00002DF6 0C10000E        	  1073:             cmpi.b #$0E,(a0)
00:00002DFA 66FE            	  1074:             bne.s *               * branch if Z clear
                            	  1075: 
                            	  1076: *             EA = (An)+  - BYTE only
00:00002DFC 307C0100        	  1077:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002E00 10FC0001        	  1078:             move.b #$01,(a0)+         * populate test data
00:00002E04 4218            	  1079:             move.b #$00,(a0)+         * populate test data
00:00002E06 307C0100        	  1080:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002E0A 08980000        	  1081:             bclr.b #0,(a0)+
00:00002E0E 67FE            	  1082:             beq.s *               * branch if Z set
00:00002E10 08980001        	  1083:             bclr.b #1,(a0)+           *
00:00002E14 66FE            	  1084:             bne.s *               * branch if Z clear
00:00002E16 307C0100        	  1085:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002E1A 4A18            	  1086:             cmpi.b #$00,(a0)+
00:00002E1C 66FE            	  1087:             bne.s *               * branch if Z clear
00:00002E1E 4A18            	  1088:             cmpi.b #$00,(a0)+
00:00002E20 66FE            	  1089:             bne.s *               * branch if Z clear
                            	  1090: 
                            	  1091: 
                            	  1092: *             EA = -(An)  - BYTE only
00:00002E22 307C0100        	  1093:             move.l #$00000100,a0      * point to memory to address
00:00002E26 10FC0001        	  1094:             move.b #$01,(a0)+         * populate test data
00:00002E2A 10FC0080        	  1095:             move.b #$80,(a0)+         * populate test data
00:00002E2E 08A00007        	  1096:             bclr.b #7,-(a0)
00:00002E32 67FE            	  1097:             beq.s *               * branch if Z set
00:00002E34 08A00000        	  1098:             bclr.b #0,-(a0)           *
00:00002E38 67FE            	  1099:             beq.s *               * branch if Z set
00:00002E3A 307C0102        	  1100:             move.l #$00000102,a0      * point to memory to address 0x100
00:00002E3E 4A20            	  1101:             cmpi.b #$00,-(a0)
00:00002E40 66FE            	  1102:             bne.s *               * branch if Z clear
00:00002E42 4A20            	  1103:             cmpi.b #$00,-(a0)
00:00002E44 66FE            	  1104:             bne.s *               * branch if Z clear
                            	  1105: 
                            	  1106: 
                            	  1107: *             EA = n(An)  - BYTE only
00:00002E46 307C0100        	  1108:             move.l #$00000100,a0      * point to memory to address
00:00002E4A 10FC00FF        	  1109:             move.b #$FF,(a0)+         * populate test data
00:00002E4E 10FC00FF        	  1110:             move.b #$FF,(a0)+         * populate test data
00:00002E52 307C0100        	  1111:             move.l #$00000100,a0      * point to memory to address
00:00002E56 08900000        	  1112:             bclr.b #0,0(a0)
00:00002E5A 67FE            	  1113:             beq.s *               * branch if Z set
00:00002E5C 08A800040001    	  1114:             bclr.b #4,1(a0)           *
00:00002E62 67FE            	  1115:             beq.s *               * branch if Z set
00:00002E64 307C0100        	  1116:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002E68 0C1800FE        	  1117:             cmpi.b #$FE,(a0)+
00:00002E6C 66FE            	  1118:             bne.s *               * branch if Z clear
00:00002E6E 0C1800EF        	  1119:             cmpi.b #$EF,(a0)+
00:00002E72 66FE            	  1120:             bne.s *               * branch if Z clear
                            	  1121: 
                            	  1122: 
                            	  1123: *             EA = n(An,D.W)  - BYTE only
00:00002E74 307C0100        	  1124:             move.l #$00000100,a0      * point to memory to address
00:00002E78 93C9            	  1125:             move.l #$00000000,a1      * point to memory to address
00:00002E7A 347C0001        	  1126:             move.l #$00000001,a2      * point to memory to address
00:00002E7E 7000            	  1127:             moveq  #$00000000,d0      * point to memory to address
00:00002E80 7201            	  1128:             moveq  #$00000001,d1      * point to memory to address
00:00002E82 10FC00FF        	  1129:             move.b #$FF,(a0)+         * populate test data
00:00002E86 10FC00FF        	  1130:             move.b #$FF,(a0)+         * populate test data
00:00002E8A 307C0100        	  1131:             move.l #$00000100,a0      * point to memory to address
00:00002E8E 08B000000000    	  1132:             bclr.b #0,0(a0,d0.w)
00:00002E94 67FE            	  1133:             beq.s *               * branch if Z set
00:00002E96 08B000011000    	  1134:             bclr.b #1,0(a0,d1.w)      *
00:00002E9C 67FE            	  1135:             beq.s *               * branch if Z set
00:00002E9E 08B000021001    	  1136:             bclr.b #2,1(a0,d1.w)      *
00:00002EA4 66FE            	  1137:             bne.s *               * branch if Z clear
                            	  1138: *             EA = n(An,D.L)  - BYTE only
00:00002EA6 08B000030800    	  1139:             bclr.b #3,0(a0,d0.l)
00:00002EAC 67FE            	  1140:             beq.s *               * branch if Z set
00:00002EAE 08B000041800    	  1141:             bclr.b #4,0(a0,d1.l)      *
00:00002EB4 67FE            	  1142:             beq.s *               * branch if Z set
00:00002EB6 08B000051801    	  1143:             bclr.b #5,1(a0,d1.l)      *
00:00002EBC 66FE            	  1144:             bne.s *               * branch if Z clear
                            	  1145: *             EA = n(An,A.W)  - BYTE only
00:00002EBE 08B000069000    	  1146:             bclr.b #6,0(a0,a1.w)
00:00002EC4 67FE            	  1147:             beq.s *               * branch if Z set
00:00002EC6 08B00001A000    	  1148:             bclr.b #1,0(a0,a2.w)      *
00:00002ECC 66FE            	  1149:             bne.s *               * branch if Z clear
00:00002ECE 08B00007A001    	  1150:             bclr.b #7,1(a0,a2.w)      *
00:00002ED4 67FE            	  1151:             beq.s *               * branch if Z set
                            	  1152: *             EA = n(An,A.L)  - BYTE only
00:00002ED6 08B000009800    	  1153:             bclr.b #0,0(a0,a1.l)
00:00002EDC 66FE            	  1154:             bne.s *               * branch if Z clear
00:00002EDE 08B00000A800    	  1155:             bclr.b #0,0(a0,a2.l)      *
00:00002EE4 67FE            	  1156:             beq.s *               * branch if Z set
00:00002EE6 08B00001A801    	  1157:             bclr.b #1,1(a0,a2.l)      *
00:00002EEC 66FE            	  1158:             bne.s *               * branch if Z clear
00:00002EEE 307C0100        	  1159:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002EF2 0C1800B6        	  1160:             cmpi.b #$B6,(a0)+
00:00002EF6 66FE            	  1161:             bne.s *               * branch if Z clear
00:00002EF8 0C1800EC        	  1162:             cmpi.b #$EC,(a0)+
00:00002EFC 66FE            	  1163:             bne.s *               * branch if Z clear
00:00002EFE 0C180059        	  1164:             cmpi.b #$59,(a0)+
00:00002F02 67FE            	  1165:             beq.s *               * branch if Z set
                            	  1166: 
                            	  1167: 
                            	  1168: *             EA = x.W  - BYTE only
00:00002F04 307C0100        	  1169:             move.l #$00000100,a0      * point to memory to address
00:00002F08 10FC00FF        	  1170:             move.b #$FF,(a0)+         * populate test data
00:00002F0C 08B800000100    	  1171:             bclr.b #0,$0100
00:00002F12 67FE            	  1172:             beq.s *               * branch if Z set
00:00002F14 08B800010100    	  1173:             bclr.b #1,$0100           *
00:00002F1A 67FE            	  1174:             beq.s *               * branch if Z set
00:00002F1C 307C0100        	  1175:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002F20 0C1800FC        	  1176:             cmpi.b #$FC,(a0)+
00:00002F24 66FE            	  1177:             bne.s *               * branch if Z clear
                            	  1178: 
                            	  1179: 
                            	  1180: *             EA = x.L  - BYTE only
00:00002F26 207C0000F100    	  1181:             move.l #$F100,a0      * point to memory to address 0x100
00:00002F2C 10BC00FF        	  1182:             move.b #$FF,(a0)          * populate test data
00:00002F30 08B900000000F100	  1183:             bclr.b #0,$F100
00:00002F38 67FE            	  1184:             beq.s *               * branch if Z set
00:00002F3A 08B900010000F100	  1185:             bclr.b #1,$F100       *
00:00002F42 67FE            	  1186:             beq.s *               * branch if Z set
00:00002F44 08B900020000F100	  1187:             bclr.b #2,$F100       *
00:00002F4C 67FE            	  1188:             beq.s *               * branch if Z set
00:00002F4E 207C0000F100    	  1189:             move.l #$F100,a0      * point to memory to address 0x100
00:00002F54 0C1800F8        	  1190:             cmpi.b #$F8,(a0)+
00:00002F58 66FE            	  1191:             bne.s *               * branch if Z clear
                            	  1192: 
                            	  1193: 
                            	  1194: * Bit Number.s Dynamic
                            	  1195: 
                            	  1196: *             EA = Dn  - LONG only
00:00002F5A 203CFF00FF00    	  1197:             move.l #$FF00FF00,d0      * populate test data
00:00002F60 7A00            	  1198:             move.l #0,d5              * populate bit.s number to test
00:00002F62 7C01            	  1199:             move.l #1,d6              * populate bit.s number to test
00:00002F64 7E1F            	  1200:             move.l #31,d7              * populate bit.s number to test
                            	  1201: 
00:00002F66 0B80            	  1202:             bclr.l d5,d0
00:00002F68 66FE            	  1203:             bne.s *               * branch if Z clear
00:00002F6A 0D80            	  1204:             bclr.l d6,d0              *
00:00002F6C 66FE            	  1205:             bne.s *               * branch if Z clear
00:00002F6E 0F80            	  1206:             bclr.l d7,d0             *
00:00002F70 67FE            	  1207:             beq.s *               * branch if Z set
00:00002F72 0C807F00FF00    	  1208:             cmpi.l #$7F00FF00,d0
00:00002F78 66FE            	  1209:             bne.s *               * branch if Z clear
                            	  1210: 
                            	  1211: 
                            	  1212: *             EA = (An)  - BYTE only
00:00002F7A 7A00            	  1213:             move.l #0,d5              * populate bit.s number to test
00:00002F7C 7C01            	  1214:             move.l #1,d6              * populate bit.s number to test
00:00002F7E 7E07            	  1215:             move.l #7,d7              * populate bit.s number to test
00:00002F80 307C0100        	  1216:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002F84 10BC0081        	  1217:             move.b #$81,(a0)          * populate test data
00:00002F88 0B90            	  1218:             bclr.b d5,(a0)
00:00002F8A 67FE            	  1219:             beq.s *               * branch if Z set
00:00002F8C 0D90            	  1220:             bclr.b d6,(a0)            *
00:00002F8E 66FE            	  1221:             bne.s *               * branch if Z clear
00:00002F90 0F90            	  1222:             bclr.b d7,(a0)            *
00:00002F92 67FE            	  1223:             beq.s *               * branch if Z set
00:00002F94 4A10            	  1224:             cmpi.b #$00,(a0)
00:00002F96 66FE            	  1225:             bne.s *               * branch if Z clear
                            	  1226: 
                            	  1227: 
                            	  1228: *             EA = (An)+  - BYTE only
00:00002F98 307C0100        	  1229:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002F9C 10FC0001        	  1230:             move.b #$01,(a0)+         * populate test data
00:00002FA0 10FC00FC        	  1231:             move.b #$FC,(a0)+         * populate test data
00:00002FA4 10FC0080        	  1232:             move.b #$80,(a0)+         * populate test data
00:00002FA8 307C0100        	  1233:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002FAC 0B98            	  1234:             bclr.b d5,(a0)+
00:00002FAE 67FE            	  1235:             beq.s *               * branch if Z set
00:00002FB0 0D98            	  1236:             bclr.b d6,(a0)+           *
00:00002FB2 66FE            	  1237:             bne.s *               * branch if Z clear
00:00002FB4 0F98            	  1238:             bclr.b d7,(a0)+           *
00:00002FB6 67FE            	  1239:             beq.s *               * branch if Z set
00:00002FB8 307C0100        	  1240:             move.l #$00000100,a0      * point to memory to address 0x100
00:00002FBC 4A18            	  1241:             cmpi.b #$00,(a0)+
00:00002FBE 66FE            	  1242:             bne.s *               * branch if Z clear
00:00002FC0 0C1800FC        	  1243:             cmpi.b #$FC,(a0)+
00:00002FC4 66FE            	  1244:             bne.s *               * branch if Z clear
00:00002FC6 4A18            	  1245:             cmpi.b #$00,(a0)+
00:00002FC8 66FE            	  1246:             bne.s *               * branch if Z clear
                            	  1247: 
                            	  1248: *             EA = -(An)  - BYTE only
00:00002FCA 307C0100        	  1249:             move.l #$00000100,a0      * point to memory to address
00:00002FCE 10FC0080        	  1250:             move.b #$80,(a0)+         * populate test data
00:00002FD2 10FC00FC        	  1251:             move.b #$FC,(a0)+         * populate test data
00:00002FD6 10FC0001        	  1252:             move.b #$01,(a0)+         * populate test data
00:00002FDA 307C0103        	  1253:             move.l #$00000103,a0      * point to memory to address
00:00002FDE 0BA0            	  1254:             bclr.b d5,-(a0)
00:00002FE0 67FE            	  1255:             beq.s *               * branch if Z set
00:00002FE2 0DA0            	  1256:             bclr.b d6,-(a0)           *
00:00002FE4 66FE            	  1257:             bne.s *               * branch if Z clear
00:00002FE6 0FA0            	  1258:             bclr.b d7,-(a0)           *
00:00002FE8 67FE            	  1259:             beq.s *               * branch if Z set
00:00002FEA 307C0103        	  1260:             move.l #$00000103,a0      * point to memory to address 0x100
00:00002FEE 4A20            	  1261:             cmpi.b #$00,-(a0)
00:00002FF0 66FE            	  1262:             bne.s *               * branch if Z clear
00:00002FF2 0C2000FC        	  1263:             cmpi.b #$FC,-(a0)
00:00002FF6 66FE            	  1264:             bne.s *               * branch if Z clear
00:00002FF8 4A20            	  1265:             cmpi.b #$00,-(a0)
00:00002FFA 66FE            	  1266:             bne.s *               * branch if Z clear
                            	  1267: 
                            	  1268: *             EA = n(An)  - BYTE only
00:00002FFC 307C0100        	  1269:             move.l #$00000100,a0      * point to memory to address
00:00003000 10FC0001        	  1270:             move.b #$01,(a0)+         * populate test data
00:00003004 10FC00FC        	  1271:             move.b #$FC,(a0)+         * populate test data
00:00003008 10FC0080        	  1272:             move.b #$80,(a0)+         * populate test data
00:0000300C 307C0100        	  1273:             move.l #$00000100,a0      * point to memory to address
00:00003010 0B90            	  1274:             bclr.b d5,0(a0)
00:00003012 67FE            	  1275:             beq.s *               * branch if Z set
00:00003014 0DA80001        	  1276:             bclr.b d6,1(a0)           *
00:00003018 66FE            	  1277:             bne.s *               * branch if Z clear
00:0000301A 0FA80002        	  1278:             bclr.b d7,2(a0)           *
00:0000301E 67FE            	  1279:             beq.s *               * branch if Z set
00:00003020 307C0100        	  1280:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003024 4A18            	  1281:             cmpi.b #$00,(a0)+
00:00003026 66FE            	  1282:             bne.s *               * branch if Z clear
00:00003028 0C1800FC        	  1283:             cmpi.b #$FC,(a0)+
00:0000302C 66FE            	  1284:             bne.s *               * branch if Z clear
00:0000302E 4A18            	  1285:             cmpi.b #$00,(a0)+
00:00003030 66FE            	  1286:             bne.s *               * branch if Z clear
                            	  1287: 
                            	  1288: *             EA = n(An,R.W)  - BYTE only
00:00003032 307C0100        	  1289:             move.l #$00000100,a0      * point to memory to address
00:00003036 10FC00FF        	  1290:             move.b #$FF,(a0)+         * populate test data
00:0000303A 10FC00FF        	  1291:             move.b #$FF,(a0)+         * populate test data
00:0000303E 10FC00FF        	  1292:             move.b #$FF,(a0)+         * populate test data
00:00003042 307C0103        	  1293:             move.l #$00000103,a0      * point to memory to address
00:00003046 307C0100        	  1294:             move.l #$00000100,a0      * point to memory to address
00:0000304A 93C9            	  1295:             move.l #$00000000,a1      * point to memory to address
00:0000304C 347C0001        	  1296:             move.l #$00000001,a2      * point to memory to address
00:00003050 7000            	  1297:             moveq  #$00000000,d0      * point to memory to address
00:00003052 7201            	  1298:             moveq  #$00000001,d1      * point to memory to address
00:00003054 0BB00000        	  1299:             bclr.b d5,0(a0,d0.w)
00:00003058 67FE            	  1300:             beq.s *               * branch if Z set
00:0000305A 0DB01000        	  1301:             bclr.b d6,0(a0,d1.w)      *
00:0000305E 67FE            	  1302:             beq.s *               * branch if Z set
00:00003060 0FB01001        	  1303:             bclr.b d7,1(a0,d1.w)      *
00:00003064 67FE            	  1304:             beq.s *               * branch if Z set
                            	  1305: *             EA = n(An,R.L)  - BYTE only
00:00003066 0BB00800        	  1306:             bclr.b d5,0(a0,d0.l)
00:0000306A 66FE            	  1307:             bne.s *               * branch if Z clear
00:0000306C 0DB01800        	  1308:             bclr.b d6,0(a0,d1.l)      *
00:00003070 66FE            	  1309:             bne.s *               * branch if Z clear
00:00003072 0FB01801        	  1310:             bclr.b d7,1(a0,d1.l)      *
00:00003076 66FE            	  1311:             bne.s *               * branch if Z clear
                            	  1312: *             EA = n(An,A.W)  - BYTE only
00:00003078 0BB09000        	  1313:             bclr.b d5,0(a0,a1.w)
00:0000307C 66FE            	  1314:             bne.s *               * branch if Z clear
00:0000307E 0DB0A000        	  1315:             bclr.b d6,0(a0,a2.w)      *
00:00003082 66FE            	  1316:             bne.s *               * branch if Z clear
00:00003084 0FB0A001        	  1317:             bclr.b d7,1(a0,a2.w)      *
00:00003088 66FE            	  1318:             bne.s *               * branch if Z clear
                            	  1319: *             EA = n(An,A.L)  - BYTE only
00:0000308A 0BB09800        	  1320:             bclr.b d5,0(a0,a1.l)
00:0000308E 66FE            	  1321:             bne.s *               * branch if Z clear
00:00003090 0DB0A800        	  1322:             bclr.b d6,0(a0,a2.l)      *
00:00003094 66FE            	  1323:             bne.s *               * branch if Z clear
00:00003096 0FB0A801        	  1324:             bclr.b d7,1(a0,a2.l)      *
00:0000309A 66FE            	  1325:             bne.s *               * branch if Z clear
00:0000309C 307C0100        	  1326:             move.l #$00000100,a0      * point to memory to address
00:000030A0 0C1000FE        	  1327:             cmpi.b #$FE,(a0)
00:000030A4 66FE            	  1328:             bne.s *               * branch if Z clear
                            	  1329: 
                            	  1330: *             EA = x.W  - BYTE only
00:000030A6 307C0100        	  1331:             move.l #$00000100,a0      * point to memory to address
00:000030AA 10FC00FF        	  1332:             move.b #$FF,(a0)+         * populate test data
00:000030AE 10FC00FF        	  1333:             move.b #$FF,(a0)+         * populate test data
00:000030B2 10FC00FF        	  1334:             move.b #$FF,(a0)+         * populate test data
00:000030B6 0BB80100        	  1335:             bclr.b d5,$0100
00:000030BA 67FE            	  1336:             beq.s *               * branch if Z set
00:000030BC 0DB80101        	  1337:             bclr.b d6,$0101           *
00:000030C0 67FE            	  1338:             beq.s *               * branch if Z set
00:000030C2 0FB80102        	  1339:             bclr.b d7,$0102           *
00:000030C6 67FE            	  1340:             beq.s *               * branch if Z set
00:000030C8 307C0100        	  1341:             move.l #$00000100,a0      * point to memory to address
00:000030CC 0C1800FE        	  1342:             cmpi.b #$FE,(a0)+
00:000030D0 66FE            	  1343:             bne.s *               * branch if Z clear
                            	  1344: 
                            	  1345: *             EA = x.L  - BYTE only
00:000030D2 207C0000F100    	  1346:             move.l #$F100,a0      * point to memory to address 0x100
00:000030D8 10FC0001        	  1347:             move.b #$01,(a0)+         * populate test data
00:000030DC 10FC00FC        	  1348:             move.b #$FC,(a0)+         * populate test data
00:000030E0 10FC0080        	  1349:             move.b #$80,(a0)+         * populate test data
00:000030E4 0BB90000F100    	  1350:             bclr.b d5,$F100
00:000030EA 67FE            	  1351:             beq.s *               * branch if Z set
00:000030EC 0DB90000F101    	  1352:             bclr.b d6,$F101       *
00:000030F2 66FE            	  1353:             bne.s *               * branch if Z clear
00:000030F4 0FB90000F102    	  1354:             bclr.b d7,$F102       *
00:000030FA 67FE            	  1355:             beq.s *               * branch if Z set
00:000030FC 207C0000F101    	  1356:             move.l #$F101,a0      * point to memory to address 0x100
00:00003102 0C1000FC        	  1357:             cmpi.b #$FC,(a0)
00:00003106 66FE            	  1358:             bne.s *               * branch if Z clear
                            	  1359: 
                            	  1360: 
                            	  1361: 
00:00003108 4E75            	  1362:     rts
                            	  1363: 
                            	  1364: *-----------------------------------------------------------
                            	  1365: *-----------------------------------------------------------
                            	  1366: * OPCODE : BSET
                            	  1367: *-----------------------------------------------------------
                            	  1368: *-----------------------------------------------------------
                            	  1369: op_BSET:
                            	  1370: 
                            	  1371: 
                            	  1372: *  Bit Number.s Static
                            	  1373: 
                            	  1374: *             EA = Dn  - LONG only
00:0000310A 7000            	  1375:             moveq  #$00000000,d0      * populate test data
00:0000310C 08C00000        	  1376:             bset.l #0,d0
00:00003110 66FE            	  1377:             bne.s *               * branch if Z clear
00:00003112 08C00001        	  1378:             bset.l #1,d0              *
00:00003116 66FE            	  1379:             bne.s *               * branch if Z clear
00:00003118 08C0000F        	  1380:             bset.l #15,d0             *
00:0000311C 66FE            	  1381:             bne.s *               * branch if Z clear
00:0000311E 08C0001F        	  1382:             bset.l #31,d0             *
00:00003122 66FE            	  1383:             bne.s *               * branch if Z clear
00:00003124 0C8080008003    	  1384:             cmpi.l #$80008003,d0
00:0000312A 66FE            	  1385:             bne.s *               * branch if Z clear
                            	  1386: 
                            	  1387: 
                            	  1388: *             EA = (An)  - BYTE only
00:0000312C 307C0100        	  1389:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003130 4210            	  1390:             move.b #$00,(a0)          * populate test data
00:00003132 08D00000        	  1391:             bset.b #0,(a0)
00:00003136 66FE            	  1392:             bne.s *               * branch if Z clear
00:00003138 08D00007        	  1393:             bset.b #7,(a0)            *
00:0000313C 66FE            	  1394:             bne.s *               * branch if Z clear
00:0000313E 0C100081        	  1395:             cmpi.b #$81,(a0)
00:00003142 66FE            	  1396:             bne.s *               * branch if Z clear
                            	  1397: 
                            	  1398: *             EA = (An)+  - BYTE only
00:00003144 307C0100        	  1399:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003148 4218            	  1400:             move.b #$00,(a0)+         * populate test data
00:0000314A 4218            	  1401:             move.b #$00,(a0)+         * populate test data
00:0000314C 307C0100        	  1402:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003150 08D80000        	  1403:             bset.b #0,(a0)+
00:00003154 66FE            	  1404:             bne.s *               * branch if Z clear
00:00003156 08D80001        	  1405:             bset.b #1,(a0)+           *
00:0000315A 66FE            	  1406:             bne.s *               * branch if Z clear
00:0000315C 307C0100        	  1407:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003160 0C180001        	  1408:             cmpi.b #$01,(a0)+
00:00003164 66FE            	  1409:             bne.s *               * branch if Z clear
00:00003166 0C180002        	  1410:             cmpi.b #$02,(a0)+
00:0000316A 66FE            	  1411:             bne.s *               * branch if Z clear
                            	  1412: 
                            	  1413: 
                            	  1414: *             EA = -(An)  - BYTE only
00:0000316C 307C0100        	  1415:             move.l #$00000100,a0      * point to memory to address
00:00003170 4218            	  1416:             move.b #$00,(a0)+         * populate test data
00:00003172 4218            	  1417:             move.b #$00,(a0)+         * populate test data
00:00003174 08E00007        	  1418:             bset.b #7,-(a0)
00:00003178 66FE            	  1419:             bne.s *               * branch if Z clear
00:0000317A 08E00000        	  1420:             bset.b #0,-(a0)           *
00:0000317E 66FE            	  1421:             bne.s *               * branch if Z clear
00:00003180 307C0102        	  1422:             move.l #$00000102,a0      * point to memory to address 0x100
00:00003184 0C200080        	  1423:             cmpi.b #$80,-(a0)
00:00003188 66FE            	  1424:             bne.s *               * branch if Z clear
00:0000318A 0C200001        	  1425:             cmpi.b #$01,-(a0)
00:0000318E 66FE            	  1426:             bne.s *               * branch if Z clear
                            	  1427: 
                            	  1428: 
                            	  1429: *             EA = n(An)  - BYTE only
00:00003190 307C0100        	  1430:             move.l #$00000100,a0      * point to memory to address
00:00003194 4218            	  1431:             move.b #$00,(a0)+         * populate test data
00:00003196 4218            	  1432:             move.b #$00,(a0)+         * populate test data
00:00003198 307C0100        	  1433:             move.l #$00000100,a0      * point to memory to address
00:0000319C 08D00000        	  1434:             bset.b #0,0(a0)
00:000031A0 66FE            	  1435:             bne.s *               * branch if Z clear
00:000031A2 08E800040001    	  1436:             bset.b #4,1(a0)           *
00:000031A8 66FE            	  1437:             bne.s *               * branch if Z clear
00:000031AA 307C0100        	  1438:             move.l #$00000100,a0      * point to memory to address 0x100
00:000031AE 0C180001        	  1439:             cmpi.b #$01,(a0)+
00:000031B2 66FE            	  1440:             bne.s *               * branch if Z clear
00:000031B4 0C180010        	  1441:             cmpi.b #$10,(a0)+
00:000031B8 66FE            	  1442:             bne.s *               * branch if Z clear
                            	  1443: 
                            	  1444: 
                            	  1445: *             EA = n(An,D.W)  - BYTE only
00:000031BA 307C0100        	  1446:             move.l #$00000100,a0      * point to memory to address
00:000031BE 93C9            	  1447:             move.l #$00000000,a1      * point to memory to address
00:000031C0 347C0004        	  1448:             move.l #$00000004,a2      * point to memory to address
00:000031C4 7000            	  1449:             moveq  #$00000000,d0      * point to memory to address
00:000031C6 7201            	  1450:             moveq  #$00000001,d1      * point to memory to address
00:000031C8 4218            	  1451:             move.b #$00,(a0)+         * populate test data
00:000031CA 4218            	  1452:             move.b #$00,(a0)+         * populate test data
00:000031CC 4218            	  1453:             move.b #$00,(a0)+         * populate test data
00:000031CE 4218            	  1454:             move.b #$00,(a0)+         * populate test data
00:000031D0 4218            	  1455:             move.b #$00,(a0)+         * populate test data
00:000031D2 4218            	  1456:             move.b #$00,(a0)+         * populate test data
00:000031D4 4218            	  1457:             move.b #$00,(a0)+         * populate test data
00:000031D6 4218            	  1458:             move.b #$00,(a0)+         * populate test data
00:000031D8 4218            	  1459:             move.b #$00,(a0)+         * populate test data
00:000031DA 4218            	  1460:             move.b #$00,(a0)+         * populate test data
00:000031DC 307C0100        	  1461:             move.l #$00000100,a0      * point to memory to address
00:000031E0 08F000000000    	  1462:             bset.b #0,0(a0,d0.w)
00:000031E6 66FE            	  1463:             bne.s *               * branch if Z clear
00:000031E8 08F000011000    	  1464:             bset.b #1,0(a0,d1.w)      *
00:000031EE 66FE            	  1465:             bne.s *               * branch if Z clear
00:000031F0 08F000021001    	  1466:             bset.b #2,1(a0,d1.w)      *
00:000031F6 66FE            	  1467:             bne.s *               * branch if Z clear
                            	  1468: *             EA = n(An,D.L)  - BYTE only
00:000031F8 08F000030802    	  1469:             bset.b #3,2(a0,d0.l)
00:000031FE 66FE            	  1470:             bne.s *               * branch if Z clear
00:00003200 08F000041800    	  1471:             bset.b #4,0(a0,d1.l)      *
00:00003206 66FE            	  1472:             bne.s *               * branch if Z clear
00:00003208 08F000051801    	  1473:             bset.b #5,1(a0,d1.l)      *
00:0000320E 66FE            	  1474:             bne.s *               * branch if Z clear
                            	  1475: *             EA = n(An,A.W)  - BYTE only
00:00003210 08F000069000    	  1476:             bset.b #6,0(a0,a1.w)
00:00003216 66FE            	  1477:             bne.s *               * branch if Z clear
00:00003218 08F00001A000    	  1478:             bset.b #1,0(a0,a2.w)      *
00:0000321E 66FE            	  1479:             bne.s *               * branch if Z clear
00:00003220 08F00007A001    	  1480:             bset.b #7,1(a0,a2.w)      *
00:00003226 66FE            	  1481:             bne.s *               * branch if Z clear
                            	  1482: *             EA = n(An,A.L)  - BYTE only
00:00003228 08F00000A802    	  1483:             bset.b #0,2(a0,a2.l)
00:0000322E 66FE            	  1484:             bne.s *               * branch if Z clear
00:00003230 08F00000A803    	  1485:             bset.b #0,3(a0,a2.l)      *
00:00003236 66FE            	  1486:             bne.s *               * branch if Z clear
00:00003238 08F00001A804    	  1487:             bset.b #1,4(a0,a2.l)      *
00:0000323E 66FE            	  1488:             bne.s *               * branch if Z clear
00:00003240 307C0100        	  1489:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003244 0C9841122C00    	  1490:             cmpi.l #$41122C00,(a0)+
00:0000324A 66FE            	  1491:             bne.s *               * branch if Z clear
00:0000324C 0C9802800101    	  1492:             cmpi.l #$02800101,(a0)+
00:00003252 66FE            	  1493:             bne.s *
                            	  1494: 
                            	  1495: 
                            	  1496: 
                            	  1497: *             EA = x.W  - BYTE only
00:00003254 307C0100        	  1498:             move.l #$00000100,a0      * point to memory to address
00:00003258 4218            	  1499:             move.b #$00,(a0)+         * populate test data
00:0000325A 08F800000100    	  1500:             bset.b #0,$0100
00:00003260 66FE            	  1501:             bne.s *               * branch if Z clear
00:00003262 08F800010100    	  1502:             bset.b #1,$0100           *
00:00003268 66FE            	  1503:             bne.s *               * branch if Z clear
00:0000326A 307C0100        	  1504:             move.l #$00000100,a0      * point to memory to address 0x100
00:0000326E 0C180003        	  1505:             cmpi.b #$03,(a0)+
00:00003272 66FE            	  1506:             bne.s *
                            	  1507: 
                            	  1508: 
                            	  1509: *             EA = x.L  - BYTE only
00:00003274 207C0000F100    	  1510:             move.l #$F100,a0      * point to memory to address 0x100
00:0000327A 4210            	  1511:             move.b #$00,(a0)          * populate test data
00:0000327C 08F900000000F100	  1512:             bset.b #0,$F100
00:00003284 66FE            	  1513:             bne.s *               * branch if Z clear
00:00003286 08F900010000F100	  1514:             bset.b #1,$F100       *
00:0000328E 66FE            	  1515:             bne.s *               * branch if Z clear
00:00003290 08F900020000F100	  1516:             bset.b #2,$F100       *
00:00003298 66FE            	  1517:             bne.s *               * branch if Z clear
00:0000329A 207C0000F100    	  1518:             move.l #$F100,a0      * point to memory to address 0x100
00:000032A0 0C180007        	  1519:             cmpi.b #$07,(a0)+
00:000032A4 66FE            	  1520:             bne.s *
                            	  1521: 
                            	  1522: 
                            	  1523: * Bit Number.s Dynamic
                            	  1524: 
                            	  1525: *             EA = Dn  - LONG only
00:000032A6 7000            	  1526:             moveq  #$00000000,d0      * populate test data
00:000032A8 7A00            	  1527:             move.l #0,d5              * populate bit.s number to test
00:000032AA 7C01            	  1528:             move.l #1,d6              * populate bit.s number to test
00:000032AC 7E1F            	  1529:             move.l #31,d7              * populate bit.s number to test
                            	  1530: 
00:000032AE 0BC0            	  1531:             bset.l d5,d0
00:000032B0 66FE            	  1532:             bne.s *               * branch if Z clear
00:000032B2 0DC0            	  1533:             bset.l d6,d0              *
00:000032B4 66FE            	  1534:             bne.s *               * branch if Z clear
00:000032B6 0FC0            	  1535:             bset.l d7,d0             *
00:000032B8 66FE            	  1536:             bne.s *               * branch if Z clear
00:000032BA 0C8080000003    	  1537:             cmpi.l #$80000003,d0
00:000032C0 66FE            	  1538:             bne.s *               * branch if Z clear
                            	  1539: 
                            	  1540: 
                            	  1541: *             EA = (An)  - BYTE only
00:000032C2 7A00            	  1542:             move.l #0,d5              * populate bit.s number to test
00:000032C4 7C01            	  1543:             move.l #1,d6              * populate bit.s number to test
00:000032C6 7E07            	  1544:             move.l #7,d7              * populate bit.s number to test
00:000032C8 307C0100        	  1545:             move.l #$00000100,a0      * point to memory to address 0x100
00:000032CC 4210            	  1546:             move.b #$00,(a0)          * populate test data
00:000032CE 0BD0            	  1547:             bset.b d5,(a0)
00:000032D0 66FE            	  1548:             bne.s *               * branch if Z clear
00:000032D2 0DD0            	  1549:             bset.b d6,(a0)            *
00:000032D4 66FE            	  1550:             bne.s *               * branch if Z clear
00:000032D6 0FD0            	  1551:             bset.b d7,(a0)            *
00:000032D8 66FE            	  1552:             bne.s *               * branch if Z clear
00:000032DA 0C100083        	  1553:             cmpi.b #$83,(a0)
00:000032DE 66FE            	  1554:             bne.s *               * branch if Z clear
                            	  1555: 
                            	  1556: 
                            	  1557: *             EA = (An)+  - BYTE only
00:000032E0 307C0100        	  1558:             move.l #$00000100,a0      * point to memory to address 0x100
00:000032E4 4218            	  1559:             move.b #$00,(a0)+         * populate test data
00:000032E6 4218            	  1560:             move.b #$00,(a0)+         * populate test data
00:000032E8 4218            	  1561:             move.b #$00,(a0)+         * populate test data
00:000032EA 307C0100        	  1562:             move.l #$00000100,a0      * point to memory to address 0x100
00:000032EE 0BD8            	  1563:             bset.b d5,(a0)+
00:000032F0 66FE            	  1564:             bne.s *               * branch if Z clear
00:000032F2 0DD8            	  1565:             bset.b d6,(a0)+           *
00:000032F4 66FE            	  1566:             bne.s *               * branch if Z clear
00:000032F6 0FD8            	  1567:             bset.b d7,(a0)+           *
00:000032F8 66FE            	  1568:             bne.s *               * branch if Z clear
00:000032FA 307C0100        	  1569:             move.l #$00000100,a0      * point to memory to address 0x100
00:000032FE 0C180001        	  1570:             cmpi.b #$01,(a0)+
00:00003302 66FE            	  1571:             bne.s *               * branch if Z clear
00:00003304 0C180002        	  1572:             cmpi.b #$02,(a0)+
00:00003308 66FE            	  1573:             bne.s *               * branch if Z clear
00:0000330A 0C180080        	  1574:             cmpi.b #$80,(a0)+
00:0000330E 66FE            	  1575:             bne.s *               * branch if Z clear
                            	  1576: 
                            	  1577: *             EA = -(An)  - BYTE only
00:00003310 307C0100        	  1578:             move.l #$00000100,a0      * point to memory to address
00:00003314 4218            	  1579:             move.b #$00,(a0)+         * populate test data
00:00003316 4218            	  1580:             move.b #$00,(a0)+         * populate test data
00:00003318 4218            	  1581:             move.b #$00,(a0)+         * populate test data
00:0000331A 307C0103        	  1582:             move.l #$00000103,a0      * point to memory to address
00:0000331E 0BE0            	  1583:             bset.b d5,-(a0)
00:00003320 66FE            	  1584:             bne.s *               * branch if Z clear
00:00003322 0DE0            	  1585:             bset.b d6,-(a0)           *
00:00003324 66FE            	  1586:             bne.s *               * branch if Z clear
00:00003326 0FE0            	  1587:             bset.b d7,-(a0)           *
00:00003328 66FE            	  1588:             bne.s *               * branch if Z clear
00:0000332A 307C0103        	  1589:             move.l #$00000103,a0      * point to memory to address 0x100
00:0000332E 0C200001        	  1590:             cmpi.b #$01,-(a0)
00:00003332 66FE            	  1591:             bne.s *               * branch if Z clear
00:00003334 0C200002        	  1592:             cmpi.b #$02,-(a0)
00:00003338 66FE            	  1593:             bne.s *               * branch if Z clear
00:0000333A 0C200080        	  1594:             cmpi.b #$80,-(a0)
00:0000333E 66FE            	  1595:             bne.s *               * branch if Z clear
                            	  1596: 
                            	  1597: *             EA = n(An)  - BYTE only
00:00003340 307C0100        	  1598:             move.l #$00000100,a0      * point to memory to address
00:00003344 4218            	  1599:             move.b #$00,(a0)+         * populate test data
00:00003346 4218            	  1600:             move.b #$00,(a0)+         * populate test data
00:00003348 4218            	  1601:             move.b #$00,(a0)+         * populate test data
00:0000334A 307C0100        	  1602:             move.l #$00000100,a0      * point to memory to address
00:0000334E 0BD0            	  1603:             bset.b d5,0(a0)
00:00003350 66FE            	  1604:             bne.s *               * branch if Z clear
00:00003352 0DE80001        	  1605:             bset.b d6,1(a0)           *
00:00003356 66FE            	  1606:             bne.s *               * branch if Z clear
00:00003358 0FE80002        	  1607:             bset.b d7,2(a0)           *
00:0000335C 66FE            	  1608:             bne.s *               * branch if Z clear
00:0000335E 307C0100        	  1609:             move.l #$00000100,a0      * point to memory to address 0x100
00:00003362 0C180001        	  1610:             cmpi.b #$01,(a0)+
00:00003366 66FE            	  1611:             bne.s *               * branch if Z clear
00:00003368 0C180002        	  1612:             cmpi.b #$02,(a0)+
00:0000336C 66FE            	  1613:             bne.s *               * branch if Z clear
00:0000336E 0C180080        	  1614:             cmpi.b #$80,(a0)+
00:00003372 66FE            	  1615:             bne.s *               * branch if Z clear
                            	  1616: 
                            	  1617: *             EA = n(An,R.W)  - BYTE only
00:00003374 307C0100        	  1618:             move.l #$00000100,a0      * point to memory to address
00:00003378 4218            	  1619:             move.b #$00,(a0)+         * populate test data
00:0000337A 4218            	  1620:             move.b #$00,(a0)+         * populate test data
00:0000337C 4218            	  1621:             move.b #$00,(a0)+         * populate test data
00:0000337E 4218            	  1622:             move.b #$00,(a0)+         * populate test data
00:00003380 4218            	  1623:             move.b #$00,(a0)+         * populate test data
00:00003382 4218            	  1624:             move.b #$00,(a0)+         * populate test data
00:00003384 4218            	  1625:             move.b #$00,(a0)+         * populate test data
00:00003386 4218            	  1626:             move.b #$00,(a0)+         * populate test data
00:00003388 4218            	  1627:             move.b #$00,(a0)+         * populate test data
00:0000338A 4218            	  1628:             move.b #$00,(a0)+         * populate test data
00:0000338C 4218            	  1629:             move.b #$00,(a0)+         * populate test data
00:0000338E 4218            	  1630:             move.b #$00,(a0)+         * populate test data
00:00003390 307C0100        	  1631:             move.l #$00000100,a0      * point to memory to address
00:00003394 93C9            	  1632:             move.l #$00000000,a1      * point to memory to address
00:00003396 347C0001        	  1633:             move.l #$00000001,a2      * point to memory to address
00:0000339A 7000            	  1634:             moveq  #$00000000,d0      * point to memory to address
00:0000339C 7201            	  1635:             moveq  #$00000001,d1      * point to memory to address
00:0000339E 0BF00000        	  1636:             bset.b d5,0(a0,d0.w)
00:000033A2 66FE            	  1637:             bne.s *               * branch if Z clear
00:000033A4 0DF01000        	  1638:             bset.b d6,0(a0,d1.w)      *
00:000033A8 66FE            	  1639:             bne.s *               * branch if Z clear
00:000033AA 0FF01001        	  1640:             bset.b d7,1(a0,d1.w)      *
00:000033AE 66FE            	  1641:             bne.s *               * branch if Z clear
                            	  1642: *             EA = n(An,R.L)  - BYTE only
00:000033B0 0BF00802        	  1643:             bset.b d5,2(a0,d0.l)
00:000033B4 66FE            	  1644:             bne.s *               * branch if Z clear
00:000033B6 0DF01803        	  1645:             bset.b d6,3(a0,d1.l)      *
00:000033BA 66FE            	  1646:             bne.s *               * branch if Z clear
00:000033BC 0FF01804        	  1647:             bset.b d7,4(a0,d1.l)      *
00:000033C0 66FE            	  1648:             bne.s *               * branch if Z clear
                            	  1649: *             EA = n(An,A.W)  - BYTE only
00:000033C2 0BF09005        	  1650:             bset.b d5,5(a0,a1.w)
00:000033C6 66FE            	  1651:             bne.s *               * branch if Z clear
00:000033C8 0DF0A006        	  1652:             bset.b d6,6(a0,a2.w)      *
00:000033CC 66FE            	  1653:             bne.s *               * branch if Z clear
00:000033CE 0FF0A007        	  1654:             bset.b d7,7(a0,a2.w)      *
00:000033D2 66FE            	  1655:             bne.s *               * branch if Z clear
                            	  1656: *             EA = n(An,A.L)  - BYTE only
00:000033D4 0BF09808        	  1657:             bset.b d5,8(a0,a1.l)
00:000033D8 66FE            	  1658:             bne.s *               * branch if Z clear
00:000033DA 0DF0A809        	  1659:             bset.b d6,9(a0,a2.l)      *
00:000033DE 66FE            	  1660:             bne.s *               * branch if Z clear
00:000033E0 0FF0A80A        	  1661:             bset.b d7,10(a0,a2.l)      *
00:000033E4 66FE            	  1662:             bne.s *               * branch if Z clear
00:000033E6 307C0100        	  1663:             move.l #$00000100,a0      * point to memory to address 0x100
00:000033EA 0C9801028100    	  1664:             cmpi.l #$01028100,(a0)+
00:000033F0 66FE            	  1665:             bne.s *               * branch if Z clear
00:000033F2 0C9802810002    	  1666:             cmpi.l #$02810002,(a0)+
00:000033F8 66FE            	  1667:             bne.s *
                            	  1668: 
                            	  1669: 
                            	  1670: *             EA = x.W  - BYTE only
00:000033FA 307C0100        	  1671:             move.l #$00000100,a0      * point to memory to address
00:000033FE 4218            	  1672:             move.b #$00,(a0)+         * populate test data
00:00003400 4218            	  1673:             move.b #$00,(a0)+         * populate test data
00:00003402 4218            	  1674:             move.b #$00,(a0)+         * populate test data
00:00003404 0BF80100        	  1675:             bset.b d5,$0100
00:00003408 66FE            	  1676:             bne.s *               * branch if Z clear
00:0000340A 0DF80100        	  1677:             bset.b d6,$0100           *
00:0000340E 66FE            	  1678:             bne.s *               * branch if Z clear
00:00003410 0FF80100        	  1679:             bset.b d7,$0100           *
00:00003414 66FE            	  1680:             bne.s *               * branch if Z clear
00:00003416 307C0100        	  1681:             move.l #$00000100,a0      * point to memory to address
00:0000341A 0C180083        	  1682:             cmpi.b #$83,(a0)+
00:0000341E 66FE            	  1683:             bne.s *               * branch if Z clear
                            	  1684: 
                            	  1685: *             EA = x.L  - BYTE only
00:00003420 207C0000F100    	  1686:             move.l #$F100,a0      * point to memory to address 0x100
00:00003426 4218            	  1687:             move.b #$00,(a0)+         * populate test data
00:00003428 4218            	  1688:             move.b #$00,(a0)+         * populate test data
00:0000342A 4218            	  1689:             move.b #$00,(a0)+         * populate test data
00:0000342C 0BF90000F100    	  1690:             bset.b d5,$F100
00:00003432 66FE            	  1691:             bne.s *               * branch if Z clear
00:00003434 0DF90000F100    	  1692:             bset.b d6,$F100       *
00:0000343A 66FE            	  1693:             bne.s *               * branch if Z clear
00:0000343C 0FF90000F100    	  1694:             bset.b d7,$F100       *
00:00003442 66FE            	  1695:             bne.s *               * branch if Z clear
00:00003444 207C0000F100    	  1696:             move.l #$F100,a0      * point to memory to address 0x100
00:0000344A 0C100083        	  1697:             cmpi.b #$83,(a0)
00:0000344E 66FE            	  1698:             bne.s *               * branch if Z clear
                            	  1699: 
                            	  1700: 
00:00003450 4E75            	  1701:     rts
                            	  1702: 
                            	  1703: *-----------------------------------------------------------
                            	  1704: *-----------------------------------------------------------
                            	  1705: * OPCODE : MOVEP
                            	  1706: *-----------------------------------------------------------
                            	  1707: *-----------------------------------------------------------
                            	  1708: op_MOVEP:
                            	  1709: 
                            	  1710: * Dn --> x(An)
00:00003452 307C0100        	  1711:             move.l #$00000100,a0
00:00003456 203C12345678    	  1712:             move.l #$12345678,d0
00:0000345C 223CAABBCCDD    	  1713:             move.l #$AABBCCDD,d1
00:00003462 4290            	  1714:             move.l #0,(a0)
00:00003464 42A80004        	  1715:             move.l #0,4(a0)
                            	  1716: 
00:00003468 01880000        	  1717:             movep.w d0,0(a0)      * even offset
00:0000346C 03880001        	  1718:             movep.w d1,1(a0)      * odd offset
                            	  1719: 
00:00003470 01C80004        	  1720:             movep.l d0,4(a0)      * even offset
00:00003474 03C80005        	  1721:             movep.l d1,5(a0)      * odd offset
                            	  1722: 
00:00003478 0C9056CC78DD    	  1723:             cmpi.l #$56CC78DD,(a0)
00:0000347E 66FE            	  1724:             bne.s *
00:00003480 0CA812AA34BB0004	  1725:             cmpi.l #$12AA34BB,4(a0)
00:00003488 66FE            	  1726:             bne.s *
00:0000348A 0CA856CC78DD0008	  1727:             cmpi.l #$56CC78DD,8(a0)
00:00003492 66FE            	  1728:             bne.s *
                            	  1729: 
                            	  1730: 
                            	  1731: * x(An)--> Dn
00:00003494 203C5A5A5A5A    	  1732:             move.l #$5a5a5a5a,d0
00:0000349A 223C5A5A5A5A    	  1733:             move.l #$5a5a5a5a,d1
00:000034A0 243C5A5A5A5A    	  1734:             move.l #$5a5a5a5a,d2
00:000034A6 263C5A5A5A5A    	  1735:             move.l #$5a5a5a5a,d3
                            	  1736: 
00:000034AC 01080000        	  1737:             movep.w 0(a0),d0      * even offset
00:000034B0 03080001        	  1738:             movep.w 1(a0),d1      * odd offset
                            	  1739: 
00:000034B4 05480004        	  1740:             movep.l 4(a0),d2      * even offset
00:000034B8 07480005        	  1741:             movep.l 5(a0),d3      * odd offset
                            	  1742: 
00:000034BC 0C805A5A5678    	  1743:             cmpi.l #$5a5a5678,d0
00:000034C2 66FE            	  1744:             bne.s *
00:000034C4 0C815A5ACCDD    	  1745:             cmpi.l #$5a5aCCDD,d1
00:000034CA 66FE            	  1746:             bne.s *
00:000034CC 0C8212345678    	  1747:             cmpi.l #$12345678,d2
00:000034D2 66FE            	  1748:             bne.s *
00:000034D4 0C83AABBCCDD    	  1749:             cmpi.l #$AABBCCDD,d3
00:000034DA 66FE            	  1750:             bne.s *
                            	  1751: 
00:000034DC 4E75            	  1752:             rts
                            	  1753: 
                            	  1754: 
                            	  1755: 
                            	  1756: *-----------------------------------------------------------
                            	  1757: *-----------------------------------------------------------
                            	  1758: * OPCODE : BOOL_I
                            	  1759: *-----------------------------------------------------------
                            	  1760: *-----------------------------------------------------------
                            	  1761: op_BOOL_I:
                            	  1762: 
                            	  1763: *     Dn -- BYTE
00:000034DE 203C12345678    	  1764:             move.l #$12345678,d0
00:000034E4 44FC000F        	  1765:             move.w #$000F,CCR          * pre-set Flags
00:000034E8 000000FF        	  1766:             ori.b  #$FF,d0
00:000034EC 0A00005A        	  1767:             eori.b #$5A,d0
00:000034F0 020000F0        	  1768:             andi.b #$F0,d0
00:000034F4 69FE            	  1769:             bvs.s *                       * Check V,C are cleared
00:000034F6 65FE            	  1770:             bcs.s *
00:000034F8 6AFE            	  1771:             bpl.s *                       * Verify if N flag is set
00:000034FA 4200            	  1772:             andi.b #$00,d0
00:000034FC 6BFE            	  1773:             bmi.s *                       * Verify if N flag is cleared
00:000034FE 66FE            	  1774:             bne.s *                       * Verify if Z flag is set
                            	  1775: 
                            	  1776: *     Dn -- WORD
00:00003500 223C12345678    	  1777:             move.l #$12345678,d1
00:00003506 44FC000F        	  1778:             move.w #$000F,CCR          * pre-set Flags
00:0000350A 0041FFFF        	  1779:             ori.w  #$FFFF,d1
00:0000350E 0A415A5A        	  1780:             eori.w #$5A5A,d1
00:00003512 0241F0F0        	  1781:             andi.w #$F0F0,d1
00:00003516 69FE            	  1782:             bvs.s *                       * Check V,C are cleared
00:00003518 65FE            	  1783:             bcs.s *
00:0000351A 6AFE            	  1784:             bpl.s *                       * Verify if N flag is set
00:0000351C 4241            	  1785:             andi.w #$0000,d1
00:0000351E 6BFE            	  1786:             bmi.s *                       * Verify if N flag is cleared
00:00003520 66FE            	  1787:             bne.s *                       * Verify if Z flag is set
                            	  1788: 
                            	  1789: *     Dn -- LONG
00:00003522 243C12345678    	  1790:             move.l #$12345678,d2
00:00003528 44FC000F        	  1791:             move.w #$000F,CCR          * pre-set Flags
00:0000352C 0082FFFFFFFF    	  1792:             ori.l  #$FFFFFFFF,d2
00:00003532 0A825A5A5A5A    	  1793:             eori.l #$5A5A5A5A,d2
00:00003538 0282F0F0F0F0    	  1794:             andi.l #$F0F0F0F0,d2
00:0000353E 69FE            	  1795:             bvs.s *                       * Check V,C are cleared
00:00003540 65FE            	  1796:             bcs.s *
00:00003542 6AFE            	  1797:             bpl.s *                       * Verify if N flag is set
00:00003544 4282            	  1798:             andi.l #$00000000,d2
00:00003546 6BFE            	  1799:             bmi.s *                       * Verify if N flag is cleared
00:00003548 66FE            	  1800:             bne.s *                       * Verify if Z flag is set
                            	  1801: 
                            	  1802: 
                            	  1803: *     (An) -- BYTE
00:0000354A 307C0100        	  1804:             move.l #$00000100,a0
00:0000354E 20BC12345678    	  1805:             move.l #$12345678,(a0)
00:00003554 44FC000F        	  1806:             move.w #$000F,CCR          * pre-set Flags
00:00003558 001000FF        	  1807:             ori.b  #$FF,(a0)
00:0000355C 0A10005A        	  1808:             eori.b #$5A,(a0)
00:00003560 021000F0        	  1809:             andi.b #$F0,(a0)
00:00003564 69FE            	  1810:             bvs.s *                       * Check V,C are cleared
00:00003566 65FE            	  1811:             bcs.s *
00:00003568 6AFE            	  1812:             bpl.s *                       * Verify if N flag is set
00:0000356A 4210            	  1813:             andi.b #$00,(a0)
00:0000356C 6BFE            	  1814:             bmi.s *                       * Verify if N flag is cleared
00:0000356E 66FE            	  1815:             bne.s *                       * Verify if Z flag is set
00:00003570 4A10            	  1816:             cmpi.b #$00,(a0)
00:00003572 66FE            	  1817:             bne.s *                       * Verify if Z flag is set
                            	  1818: 
                            	  1819: *     (An) -- WORD
00:00003574 20BC12345678    	  1820:             move.l #$12345678,(a0)
00:0000357A 44FC000F        	  1821:             move.w #$000F,CCR          * pre-set Flags
00:0000357E 0050FFFF        	  1822:             ori.w  #$FFFF,(a0)
00:00003582 0A505A5A        	  1823:             eori.w #$5A5A,(a0)
00:00003586 0250F0F0        	  1824:             andi.w #$F0F0,(a0)
00:0000358A 69FE            	  1825:             bvs.s *                       * Check V,C are cleared
00:0000358C 65FE            	  1826:             bcs.s *
00:0000358E 6AFE            	  1827:             bpl.s *                       * Verify if N flag is set
00:00003590 4250            	  1828:             andi.w #$0000,(a0)
00:00003592 6BFE            	  1829:             bmi.s *                       * Verify if N flag is cleared
00:00003594 66FE            	  1830:             bne.s *                       * Verify if Z flag is set
00:00003596 4A50            	  1831:             cmpi.w #$00,(a0)
00:00003598 66FE            	  1832:             bne.s *                       * Verify if Z flag is set
                            	  1833: 
                            	  1834: *     (An) -- LONG
00:0000359A 20BC12345678    	  1835:             move.l #$12345678,(a0)
00:000035A0 44FC000F        	  1836:             move.w #$000F,CCR          * pre-set Flags
00:000035A4 0090FFFFFFFF    	  1837:             ori.l  #$FFFFFFFF,(a0)
00:000035AA 0A905A5A5A5A    	  1838:             eori.l #$5A5A5A5A,(a0)
00:000035B0 0290F0F0F0F0    	  1839:             andi.l #$F0F0F0F0,(a0)
00:000035B6 69FE            	  1840:             bvs.s *                       * Check V,C are cleared
00:000035B8 65FE            	  1841:             bcs.s *
00:000035BA 6AFE            	  1842:             bpl.s *                       * Verify if N flag is set
00:000035BC 4290            	  1843:             andi.l #$00000000,(a0)
00:000035BE 6BFE            	  1844:             bmi.s *                       * Verify if N flag is cleared
00:000035C0 66FE            	  1845:             bne.s *                       * Verify if Z flag is set
00:000035C2 4A90            	  1846:             cmpi.l #$00,(a0)
00:000035C4 66FE            	  1847:             bne.s *                       * Verify if Z flag is set
                            	  1848: 
                            	  1849: 
                            	  1850: 
                            	  1851: *     (An)+ -- BYTE
00:000035C6 307C0100        	  1852:             move.l #$00000100,a0
00:000035CA 20BC00A5FF88    	  1853:             move.l #$00A5FF88,(a0)
00:000035D0 44FC000F        	  1854:             move.w #$000F,CCR          * pre-set Flags
                            	  1855: 
00:000035D4 001800F5        	  1856:             ori.b  #$F5,(a0)+
00:000035D8 6AFE            	  1857:             bpl.s *                       * Verify if N flag is set
00:000035DA 67FE            	  1858:             beq.s *                       * Verify if Z flag is cleared
                            	  1859: 
00:000035DC 4618            	  1860:             eori.b #$FF,(a0)+
00:000035DE 6BFE            	  1861:             bmi.s *                       * Verify if N flag is cleared
00:000035E0 67FE            	  1862:             beq.s *                       * Verify if Z flag is cleared
                            	  1863: 
00:000035E2 021800AA        	  1864:             andi.b #$AA,(a0)+
00:000035E6 6AFE            	  1865:             bpl.s *                       * Verify if N flag is set
00:000035E8 67FE            	  1866:             beq.s *                       * Verify if Z flag is cleared
                            	  1867: 
00:000035EA 307C0100        	  1868:             move.l #$00000100,a0
00:000035EE 0C90F55AAA88    	  1869:             cmpi.l #$F55AAA88,(a0)
00:000035F4 66FE            	  1870:             bne.s *                       * Verify if Z flag is set
                            	  1871: 
                            	  1872: 
                            	  1873: *     (An)+ -- WORD
00:000035F6 307C0100        	  1874:             move.l #$00000100,a0
00:000035FA 327C0104        	  1875:             move.l #$00000104,a1
00:000035FE 20BC00005A5A    	  1876:             move.l #$00005a5a,(a0)
00:00003604 22BC12345678    	  1877:             move.l #$12345678,(a1)
00:0000360A 44FC000F        	  1878:             move.w #$000F,CCR          * pre-set Flags
                            	  1879: 
00:0000360E 00585678        	  1880:             ori.w  #$5678,(a0)+
00:00003612 6BFE            	  1881:             bmi.s *                       * Verify if N flag is cleared
00:00003614 67FE            	  1882:             beq.s *                       * Verify if Z flag is cleared
                            	  1883: 
00:00003616 4658            	  1884:             eori.w #$FFFF,(a0)+
00:00003618 6AFE            	  1885:             bpl.s *                       * Verify if N flag is set
00:0000361A 67FE            	  1886:             beq.s *                       * Verify if Z flag is cleared
                            	  1887: 
00:0000361C 0258A55A        	  1888:             andi.w #$A55A,(a0)+
00:00003620 6BFE            	  1889:             bmi.s *                       * Verify if N flag is cleared
00:00003622 67FE            	  1890:             beq.s *                       * Verify if Z flag is cleared
                            	  1891: 
00:00003624 307C0100        	  1892:             move.l #$00000100,a0
00:00003628 0C905678A5A5    	  1893:             cmpi.l #$5678a5a5,(a0)
00:0000362E 307C0104        	  1894:             move.l #$00000104,a0
00:00003632 0C9000105678    	  1895:             cmpi.l #$00105678,(a0)
00:00003638 66FE            	  1896:             bne.s *                       * Verify if Z flag is set
                            	  1897: 
                            	  1898: *     (An)+ -- LONG
00:0000363A 307C0100        	  1899:             move.l #$00000100,a0
00:0000363E 4298            	  1900:             move.l #$00000000,(a0)+
00:00003640 20FC5A5A5A5A    	  1901:             move.l #$5a5a5a5a,(a0)+
00:00003646 20FCFFFFFFFF    	  1902:             move.l #$FFFFFFFF,(a0)+
00:0000364C 307C0100        	  1903:             move.l #$00000100,a0
00:00003650 44FC000F        	  1904:             move.w #$000F,CCR          * pre-set Flags
                            	  1905: 
00:00003654 009812345678    	  1906:             ori.l  #$12345678,(a0)+
00:0000365A 6BFE            	  1907:             bmi.s *                       * Verify if N flag is cleared
00:0000365C 67FE            	  1908:             beq.s *                       * Verify if Z flag is cleared
                            	  1909: 
00:0000365E 4698            	  1910:             eori.l #$FFFFFFFF,(a0)+
00:00003660 6AFE            	  1911:             bpl.s *                       * Verify if N flag is set
00:00003662 67FE            	  1912:             beq.s *                       * Verify if Z flag is cleared
                            	  1913: 
00:00003664 0298A5A5A55A    	  1914:             andi.l #$A5A5A55A,(a0)+
00:0000366A 6AFE            	  1915:             bpl.s *                       * Verify if N flag is set
00:0000366C 67FE            	  1916:             beq.s *                       * Verify if Z flag is cleared
                            	  1917: 
00:0000366E 307C0100        	  1918:             move.l #$00000100,a0
00:00003672 0C9812345678    	  1919:             cmpi.l #$12345678,(a0)+
00:00003678 0C98A5A5A5A5    	  1920:             cmpi.l #$a5a5a5a5,(a0)+
00:0000367E 0C98A5A5A55A    	  1921:             cmpi.l #$a5a5a55a,(a0)+
00:00003684 66FE            	  1922:             bne.s *                       * Verify if Z flag is set
                            	  1923: 
00:00003686 4E75            	  1924:             rts
                            	  1925: 
                            	  1926: 
                            	  1927: *-----------------------------------------------------------
                            	  1928: *-----------------------------------------------------------
                            	  1929: * OPCODE : BSR
                            	  1930: *-----------------------------------------------------------
                            	  1931: *-----------------------------------------------------------
                            	  1932: 
                            	  1933: 
00:00003688 223C11111111    	  1934: BSR_CLOSE1:     move.l #$11111111,d1
00:0000368E 4E75            	  1935:                 rts
                            	  1936: 
                            	  1937: 
                            	  1938: 
00:00003690 61F6            	  1939: op_BSR:         bsr BSR_CLOSE1        * Negative 8-bit.s displacement
00:00003692 612A            	  1940:                 bsr BSR_CLOSE2        * Positive 8-bit.s displacement
00:00003694 6100EF20        	  1941:                 bsr.w BSR_FAR1          * Negative 16-bit.s displacement
00:00003698 6100144E        	  1942:                 bsr.w BSR_FAR2          * Positive 16-bit.s displacement
                            	  1943: 
00:0000369C 0C8111111111    	  1944:                 cmpi.l #$11111111,d1
00:000036A2 66FE            	  1945:                 bne.s *
00:000036A4 0C8222222222    	  1946:                 cmpi.l #$22222222,d2
00:000036AA 66FE            	  1947:                 bne.s *
00:000036AC 0C8333333333    	  1948:                 cmpi.l #$33333333,d3
00:000036B2 66FE            	  1949:                 bne.s *
00:000036B4 0C8444444444    	  1950:                 cmpi.l #$44444444,d4
00:000036BA 66FE            	  1951:                 bne.s *
                            	  1952: 
00:000036BC 4E75            	  1953:                 rts
                            	  1954: 
                            	  1955: 
00:000036BE 243C22222222    	  1956: BSR_CLOSE2:     move.l #$22222222,d2
00:000036C4 4E75            	  1957:                 rts
                            	  1958: 
                            	  1959: *-----------------------------------------------------------
                            	  1960: *-----------------------------------------------------------
                            	  1961: * OPCODE : op_CMP_I
                            	  1962: *-----------------------------------------------------------
                            	  1963: *-----------------------------------------------------------
                            	  1964: op_CMP_I:
                            	  1965: 
00:000036C6 307C0100        	  1966:             move.l #$00000100,a0
00:000036CA 20BC00000100    	  1967:             move.l #$00000100,(a0)
                            	  1968: 
                            	  1969: *     REGISTER - BYTE
00:000036D0 7080            	  1970:             move.l #$FFFFFF80,d0
00:000036D2 0C000080        	  1971:             cmpi.b #$80,d0
00:000036D6 66FE            	  1972:             bne.s *                       * Check Z Flag  beq/bne
00:000036D8 6BFE            	  1973:             bmi.s *                       * Check N Flag  bmi/bpl
00:000036DA 65FE            	  1974:             bcs.s *                       * Check C Flag  bcc/bcs
00:000036DC 69FE            	  1975:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1976: 
00:000036DE 223CFFFFF000    	  1977:             move.l #$FFFFF000,d1
00:000036E4 4A01            	  1978:             cmpi.b #$00,d1
00:000036E6 66FE            	  1979:             bne.s *                       * Check Z Flag  beq/bne
00:000036E8 6BFE            	  1980:             bmi.s *                       * Check N Flag  bmi/bpl
00:000036EA 65FE            	  1981:             bcs.s *                       * Check C Flag  bcc/bcs
00:000036EC 69FE            	  1982:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1983: 
00:000036EE 7481D442        	  1984:             move.l #$FFFFFF02,d2
00:000036F2 0C0200FF        	  1985:             cmpi.b #$FF,d2
00:000036F6 67FE            	  1986:             beq.s *                       * Check Z Flag  beq/bne
00:000036F8 6BFE            	  1987:             bmi.s *                       * Check N Flag  bmi/bpl
00:000036FA 64FE            	  1988:             bcc.s *                       * Check C Flag  bcc/bcs
00:000036FC 69FE            	  1989:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  1990: 
00:000036FE 263CFFFFFF7F    	  1991:             move.l #$FFFFFF7F,d3
00:00003704 0C0300FF        	  1992:             cmpi.b #$FF,d3
00:00003708 67FE            	  1993:             beq.s *                       * Check Z Flag  beq/bne
00:0000370A 6AFE            	  1994:             bpl.s *                       * Check N Flag  bmi/bpl
00:0000370C 64FE            	  1995:             bcc.s *                       * Check C Flag  bcc/bcs
00:0000370E 68FE            	  1996:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  1997: 
                            	  1998: 
                            	  1999: *     REGISTER - WORD
00:00003710 203CFFFF8000    	  2000:             move.l #$FFFF8000,d0
00:00003716 0C408000        	  2001:             cmpi.w #$8000,d0
00:0000371A 66FE            	  2002:             bne.s *                       * Check Z Flag  beq/bne
00:0000371C 6BFE            	  2003:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000371E 65FE            	  2004:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003720 69FE            	  2005:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2006: 
00:00003722 223CFFF00000    	  2007:             move.l #$FFF00000,d1
00:00003728 4A41            	  2008:             cmpi.w #$0000,d1
00:0000372A 66FE            	  2009:             bne.s *                       * Check Z Flag  beq/bne
00:0000372C 6BFE            	  2010:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000372E 65FE            	  2011:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003730 69FE            	  2012:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2013: 
00:00003732 243CFFFF0002    	  2014:             move.l #$FFFF0002,d2
00:00003738 0C42FFFF        	  2015:             cmpi.w #$FFFF,d2
00:0000373C 67FE            	  2016:             beq.s *                       * Check Z Flag  beq/bne
00:0000373E 6BFE            	  2017:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003740 64FE            	  2018:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003742 69FE            	  2019:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2020: 
00:00003744 263CFFFF7FFF    	  2021:             move.l #$FFFF7FFF,d3
00:0000374A 0C43FFFF        	  2022:             cmpi.w #$FFFF,d3
00:0000374E 67FE            	  2023:             beq.s *                       * Check Z Flag  beq/bne
00:00003750 6AFE            	  2024:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003752 64FE            	  2025:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003754 68FE            	  2026:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2027: 
                            	  2028: *     REGISTER - LONG
00:00003756 203C80000000    	  2029:             move.l #$80000000,d0
00:0000375C 0C8080000000    	  2030:             cmpi.l #$80000000,d0
00:00003762 66FE            	  2031:             bne.s *                       * Check Z Flag  beq/bne
00:00003764 6BFE            	  2032:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003766 65FE            	  2033:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003768 69FE            	  2034:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2035: 
00:0000376A 7200            	  2036:             moveq  #$00000000,d1
00:0000376C 4A81            	  2037:             cmpi.l #$00000000,d1
00:0000376E 66FE            	  2038:             bne.s *                       * Check Z Flag  beq/bne
00:00003770 6BFE            	  2039:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003772 65FE            	  2040:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003774 69FE            	  2041:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2042: 
00:00003776 7402            	  2043:             moveq  #$00000002,d2
00:00003778 0C82FFFFFFFF    	  2044:             cmpi.l #$FFFFFFFF,d2
00:0000377E 67FE            	  2045:             beq.s *                       * Check Z Flag  beq/bne
00:00003780 6BFE            	  2046:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003782 64FE            	  2047:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003784 69FE            	  2048:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2049: 
00:00003786 263C7FFFFFFF    	  2050:             move.l #$7FFFFFFF,d3
00:0000378C 0C83FFFFFFFF    	  2051:             cmpi.l #$FFFFFFFF,d3
00:00003792 67FE            	  2052:             beq.s *                       * Check Z Flag  beq/bne
00:00003794 6AFE            	  2053:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003796 64FE            	  2054:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003798 68FE            	  2055:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2056: 
                            	  2057: 
                            	  2058: 
                            	  2059: 
                            	  2060: *     EA=x(An,Dn) - BYTE
00:0000379A 307C0100        	  2061:             move.l #$00000100,a0
00:0000379E 7E04            	  2062:             moveq  #$00000004,d7
                            	  2063: 
00:000037A0 21BCFFFFFF80700C	  2064:             move.l #$FFFFFF80,12(a0,d7)
00:000037A8 21BCFFFFFF80700C	  2065:             move.l #$FFFFFF80,12(a0,d7)
00:000037B0 0C300080700F    	  2066:             cmpi.b #$80,15(a0,d7)
00:000037B6 66FE            	  2067:             bne.s *                       * Check Z Flag  beq/bne
00:000037B8 6BFE            	  2068:             bmi.s *                       * Check N Flag  bmi/bpl
00:000037BA 65FE            	  2069:             bcs.s *                       * Check C Flag  bcc/bcs
00:000037BC 69FE            	  2070:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2071: 
00:000037BE 21BCFFFFF000700C	  2072:             move.l #$FFFFF000,12(a0,d7)
00:000037C6 4A30700F        	  2073:             cmpi.b #$00,15(a0,d7)
00:000037CA 66FE            	  2074:             bne.s *                       * Check Z Flag  beq/bne
00:000037CC 6BFE            	  2075:             bmi.s *                       * Check N Flag  bmi/bpl
00:000037CE 65FE            	  2076:             bcs.s *                       * Check C Flag  bcc/bcs
00:000037D0 69FE            	  2077:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2078: 
00:000037D2 21BCFFFFFF02700C	  2079:             move.l #$FFFFFF02,12(a0,d7)
00:000037DA 0C3000FF700F    	  2080:             cmpi.b #$FF,15(a0,d7)
00:000037E0 67FE            	  2081:             beq.s *                       * Check Z Flag  beq/bne
00:000037E2 6BFE            	  2082:             bmi.s *                       * Check N Flag  bmi/bpl
00:000037E4 64FE            	  2083:             bcc.s *                       * Check C Flag  bcc/bcs
00:000037E6 69FE            	  2084:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2085: 
00:000037E8 21BCFFFFFF7F700C	  2086:             move.l #$FFFFFF7F,12(a0,d7)
00:000037F0 0C3000FF700F    	  2087:             cmpi.b #$FF,15(a0,d7)
00:000037F6 67FE            	  2088:             beq.s *                       * Check Z Flag  beq/bne
00:000037F8 6AFE            	  2089:             bpl.s *                       * Check N Flag  bmi/bpl
00:000037FA 64FE            	  2090:             bcc.s *                       * Check C Flag  bcc/bcs
00:000037FC 68FE            	  2091:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2092: 
                            	  2093: 
                            	  2094: *     EA=x(An,Dn) - WORD
00:000037FE 21BCFFFF8000700C	  2095:             move.l #$FFFF8000,12(a0,d7)
00:00003806 0C708000700E    	  2096:             cmpi.w #$8000,14(a0,d7)
00:0000380C 66FE            	  2097:             bne.s *                       * Check Z Flag  beq/bne
00:0000380E 6BFE            	  2098:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003810 65FE            	  2099:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003812 69FE            	  2100:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2101: 
00:00003814 21BCFFF00000700C	  2102:             move.l #$FFF00000,12(a0,d7)
00:0000381C 4A70700E        	  2103:             cmpi.w #$0000,14(a0,d7)
00:00003820 66FE            	  2104:             bne.s *                       * Check Z Flag  beq/bne
00:00003822 6BFE            	  2105:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003824 65FE            	  2106:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003826 69FE            	  2107:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2108: 
00:00003828 21BCFFFF0002700C	  2109:             move.l #$FFFF0002,12(a0,d7)
00:00003830 0C70FFFF700E    	  2110:             cmpi.w #$FFFF,14(a0,d7)
00:00003836 67FE            	  2111:             beq.s *                       * Check Z Flag  beq/bne
00:00003838 6BFE            	  2112:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000383A 64FE            	  2113:             bcc.s *                       * Check C Flag  bcc/bcs
00:0000383C 69FE            	  2114:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2115: 
00:0000383E 21BCFFFF7FFF700C	  2116:             move.l #$FFFF7FFF,12(a0,d7)
00:00003846 0C70FFFF700E    	  2117:             cmpi.w #$FFFF,14(a0,d7)
00:0000384C 67FE            	  2118:             beq.s *                       * Check Z Flag  beq/bne
00:0000384E 6AFE            	  2119:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003850 64FE            	  2120:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003852 68FE            	  2121:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2122: 
                            	  2123: *     EA=x(An,Dn) - LONG
00:00003854 21BC80000000700C	  2124:             move.l #$80000000,12(a0,d7)
00:0000385C 0CB080000000700C	  2125:             cmpi.l #$80000000,12(a0,d7)
00:00003864 66FE            	  2126:             bne.s *                       * Check Z Flag  beq/bne
00:00003866 6BFE            	  2127:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003868 65FE            	  2128:             bcs.s *                       * Check C Flag  bcc/bcs
00:0000386A 69FE            	  2129:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2130: 
00:0000386C 42B0700C        	  2131:             move.l #$00000000,12(a0,d7)
00:00003870 4AB0700C        	  2132:             cmpi.l #$00000000,12(a0,d7)
00:00003874 66FE            	  2133:             bne.s *                       * Check Z Flag  beq/bne
00:00003876 6BFE            	  2134:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003878 65FE            	  2135:             bcs.s *                       * Check C Flag  bcc/bcs
00:0000387A 69FE            	  2136:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2137: 
00:0000387C 21BC00000002700C	  2138:             move.l #$00000002,12(a0,d7)
00:00003884 0CB0FFFFFFFF700C	  2139:             cmpi.l #$FFFFFFFF,12(a0,d7)
00:0000388C 67FE            	  2140:             beq.s *                       * Check Z Flag  beq/bne
00:0000388E 6BFE            	  2141:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003890 64FE            	  2142:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003892 69FE            	  2143:             bvs.s *                       * Check V Flag  bvc/bvs
                            	  2144: 
00:00003894 21BC7FFFFFFF700C	  2145:             move.l #$7FFFFFFF,12(a0,d7)
00:0000389C 0CB0FFFFFFFF700C	  2146:             cmpi.l #$FFFFFFFF,12(a0,d7)
00:000038A4 67FE            	  2147:             beq.s *                       * Check Z Flag  beq/bne
00:000038A6 6AFE            	  2148:             bpl.s *                       * Check N Flag  bmi/bpl
00:000038A8 64FE            	  2149:             bcc.s *                       * Check C Flag  bcc/bcs
00:000038AA 68FE            	  2150:             bvc.s *                       * Check V Flag  bvc/bvs
                            	  2151: 
                            	  2152: 
                            	  2153: 
                            	  2154: 
00:000038AC 4E75            	  2155:             rts
                            	  2156: 
                            	  2157: 
                            	  2158: 
                            	  2159: *-----------------------------------------------------------
                            	  2160: *-----------------------------------------------------------
                            	  2161: * OPCODE : ADD_I
                            	  2162: *-----------------------------------------------------------
                            	  2163: *-----------------------------------------------------------
                            	  2164: op_ADD_I:
                            	  2165: 
                            	  2166: *     EA = Dn  - Byte
00:000038AE 203C12345678    	  2167:             move.l #$12345678,d0      * populate test data
00:000038B4 06000000        	  2168:             addi.b #0,d0
00:000038B8 67FE            	  2169:             beq.s *                       * Check Z Flag  beq/bne
00:000038BA 6BFE            	  2170:             bmi.s *                       * Check N Flag  bmi/bpl
00:000038BC 65FE            	  2171:             bcs.s *                       * Check C Flag  bcc/bcs
00:000038BE 69FE            	  2172:             bvs.s *                       * Check V Flag  bvc/bvs
00:000038C0 06000010        	  2173:             addi.b #$10,d0
00:000038C4 67FE            	  2174:             beq.s *                       * Check Z Flag  beq/bne
00:000038C6 6AFE            	  2175:             bpl.s *                       * Check N Flag  bmi/bpl
00:000038C8 65FE            	  2176:             bcs.s *                       * Check C Flag  bcc/bcs
00:000038CA 68FE            	  2177:             bvc.s *                       * Check V Flag  bvc/bvs
00:000038CC 060000A5        	  2178:             addi.b #$A5,d0
00:000038D0 67FE            	  2179:             beq.s *                       * Check Z Flag  beq/bne
00:000038D2 6BFE            	  2180:             bmi.s *                       * Check N Flag  bmi/bpl
00:000038D4 64FE            	  2181:             bcc.s *                       * Check C Flag  bcc/bcs
00:000038D6 68FE            	  2182:             bvc.s *                       * Check V Flag  bvc/bvs
00:000038D8 0C00002D        	  2183:             cmpi.b #$2D,d0
00:000038DC 66FE            	  2184:             bne.s *                       * Check Z Flag  beq/bne
                            	  2185: 
                            	  2186: *     EA = Dn  - WORD
00:000038DE 203C12345678    	  2187:             move.l #$12345678,d0      * populate test data
00:000038E4 06400000        	  2188:             addi.w #0,d0
00:000038E8 67FE            	  2189:             beq.s *                       * Check Z Flag  beq/bne
00:000038EA 6BFE            	  2190:             bmi.s *                       * Check N Flag  bmi/bpl
00:000038EC 65FE            	  2191:             bcs.s *                       * Check C Flag  bcc/bcs
00:000038EE 69FE            	  2192:             bvs.s *                       * Check V Flag  bvc/bvs
00:000038F0 06407000        	  2193:             addi.w #$7000,d0
00:000038F4 67FE            	  2194:             beq.s *                       * Check Z Flag  beq/bne
00:000038F6 6AFE            	  2195:             bpl.s *                       * Check N Flag  bmi/bpl
00:000038F8 65FE            	  2196:             bcs.s *                       * Check C Flag  bcc/bcs
00:000038FA 68FE            	  2197:             bvc.s *                       * Check V Flag  bvc/bvs
00:000038FC 0640A55A        	  2198:             addi.w #$A55A,d0
00:00003900 67FE            	  2199:             beq.s *                       * Check Z Flag  beq/bne
00:00003902 6BFE            	  2200:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003904 64FE            	  2201:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003906 68FE            	  2202:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003908 0C406BD2        	  2203:             cmpi.w #$6BD2,d0
00:0000390C 66FE            	  2204:             bne.s *                       * Check Z Flag  beq/bne
                            	  2205: 
                            	  2206: *     EA = Dn  - LONG
00:0000390E 203C12345678    	  2207:             move.l #$12345678,d0      * populate test data
00:00003914 068000000000    	  2208:             addi.l #0,d0
00:0000391A 67FE            	  2209:             beq.s *                       * Check Z Flag  beq/bne
00:0000391C 6BFE            	  2210:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000391E 65FE            	  2211:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003920 69FE            	  2212:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003922 0680F0000000    	  2213:             addi.l #$F0000000,d0
00:00003928 67FE            	  2214:             beq.s *                       * Check Z Flag  beq/bne
00:0000392A 6BFE            	  2215:             bmi.s *                       * Check N Flag  bmi/bpl
00:0000392C 64FE            	  2216:             bcc.s *                       * Check C Flag  bcc/bcs
00:0000392E 69FE            	  2217:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003930 0680855AA55A    	  2218:             addi.l #$855AA55A,d0
00:00003936 67FE            	  2219:             beq.s *                       * Check Z Flag  beq/bne
00:00003938 6AFE            	  2220:             bpl.s *                       * Check N Flag  bmi/bpl
00:0000393A 65FE            	  2221:             bcs.s *                       * Check C Flag  bcc/bcs
00:0000393C 69FE            	  2222:             bvs.s *                       * Check V Flag  bvc/bvs
00:0000393E 0680A0000000    	  2223:             addi.l #$A0000000,d0
00:00003944 68FE            	  2224:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003946 0C80278EFBD2    	  2225:             cmpi.l #$278EFBD2,d0
00:0000394C 66FE            	  2226:             bne.s *                       * Check Z Flag  beq/bne
                            	  2227: 
                            	  2228: 
                            	  2229: 
                            	  2230: *     EA = x.L  - Byte
00:0000394E 207C0000F100    	  2231:             move.l #$F100,a0      * populate test data
00:00003954 20BC12345678    	  2232:             move.l #$12345678,(a0)     * populate test data
00:0000395A 063900000000F103	  2233:             addi.b #0,$F103
00:00003962 67FE            	  2234:             beq.s *                       * Check Z Flag  beq/bne
00:00003964 6BFE            	  2235:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003966 65FE            	  2236:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003968 69FE            	  2237:             bvs.s *                       * Check V Flag  bvc/bvs
00:0000396A 063900100000F103	  2238:             addi.b #$10,$F103
00:00003972 67FE            	  2239:             beq.s *                       * Check Z Flag  beq/bne
00:00003974 6AFE            	  2240:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003976 65FE            	  2241:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003978 68FE            	  2242:             bvc.s *                       * Check V Flag  bvc/bvs
00:0000397A 063900A50000F103	  2243:             addi.b #$A5,$F103
00:00003982 67FE            	  2244:             beq.s *                       * Check Z Flag  beq/bne
00:00003984 6BFE            	  2245:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003986 64FE            	  2246:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003988 68FE            	  2247:             bvc.s *                       * Check V Flag  bvc/bvs
00:0000398A 0C39002D0000F103	  2248:             cmpi.b #$2D,$F103
00:00003992 66FE            	  2249:             bne.s *                       * Check Z Flag  beq/bne
                            	  2250: 
                            	  2251: *     EA = x.L- WORD
00:00003994 207C0000F100    	  2252:             move.l #$F100,a0      * populate test data
00:0000399A 20BC12345678    	  2253:             move.l #$12345678,(a0)     * populate test data
00:000039A0 067900000000F100	  2254:             addi.w #0,$F100
00:000039A8 67FE            	  2255:             beq.s *                       * Check Z Flag  beq/bne
00:000039AA 6BFE            	  2256:             bmi.s *                       * Check N Flag  bmi/bpl
00:000039AC 65FE            	  2257:             bcs.s *                       * Check C Flag  bcc/bcs
00:000039AE 69FE            	  2258:             bvs.s *                       * Check V Flag  bvc/bvs
00:000039B0 067970000000F100	  2259:             addi.w #$7000,$F100
00:000039B8 67FE            	  2260:             beq.s *                       * Check Z Flag  beq/bne
00:000039BA 6AFE            	  2261:             bpl.s *                       * Check N Flag  bmi/bpl
00:000039BC 65FE            	  2262:             bcs.s *                       * Check C Flag  bcc/bcs
00:000039BE 68FE            	  2263:             bvc.s *                       * Check V Flag  bvc/bvs
00:000039C0 0679A55A0000F100	  2264:             addi.w #$A55A,$F100
00:000039C8 67FE            	  2265:             beq.s *                       * Check Z Flag  beq/bne
00:000039CA 6BFE            	  2266:             bmi.s *                       * Check N Flag  bmi/bpl
00:000039CC 64FE            	  2267:             bcc.s *                       * Check C Flag  bcc/bcs
00:000039CE 68FE            	  2268:             bvc.s *                       * Check V Flag  bvc/bvs
00:000039D0 0C79278E0000F100	  2269:             cmpi.w #$278E,$F100
00:000039D8 66FE            	  2270:             bne.s *                       * Check Z Flag  beq/bne
                            	  2271: 
                            	  2272: *     EA = x.L- LONG
00:000039DA 23FC123456780000	  2273:             move.l #$12345678,$F100  * populate test data
00:000039E2 F100
00:000039E4 06B9000000000000	  2274:             addi.l #0,$F100
00:000039EC F100
00:000039EE 67FE            	  2275:             beq.s *                       * Check Z Flag  beq/bne
00:000039F0 6BFE            	  2276:             bmi.s *                       * Check N Flag  bmi/bpl
00:000039F2 65FE            	  2277:             bcs.s *                       * Check C Flag  bcc/bcs
00:000039F4 69FE            	  2278:             bvs.s *                       * Check V Flag  bvc/bvs
00:000039F6 06B9F00000000000	  2279:             addi.l #$F0000000,$F100
00:000039FE F100
00:00003A00 67FE            	  2280:             beq.s *                       * Check Z Flag  beq/bne
00:00003A02 6BFE            	  2281:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A04 64FE            	  2282:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003A06 69FE            	  2283:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003A08 06B9855AA55A0000	  2284:             addi.l #$855AA55A,$F100
00:00003A10 F100
00:00003A12 67FE            	  2285:             beq.s *                       * Check Z Flag  beq/bne
00:00003A14 6AFE            	  2286:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003A16 65FE            	  2287:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003A18 69FE            	  2288:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003A1A 06B9A00000000000	  2289:             addi.l #$A0000000,$F100
00:00003A22 F100
00:00003A24 68FE            	  2290:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003A26 0CB9278EFBD20000	  2291:             cmpi.l #$278EFBD2,$F100
00:00003A2E F100
00:00003A30 66FE            	  2292:             bne.s *                       * Check Z Flag  beq/bne
                            	  2293: 
00:00003A32 4E75            	  2294:             rts
                            	  2295: 
                            	  2296: 
                            	  2297: *-----------------------------------------------------------
                            	  2298: *-----------------------------------------------------------
                            	  2299: * OPCODE : SUB_I
                            	  2300: *-----------------------------------------------------------
                            	  2301: *-----------------------------------------------------------
                            	  2302: op_SUB_I:
                            	  2303: 
                            	  2304: *     EA = Dn  - Byte
00:00003A34 203C12345678    	  2305:             move.l #$12345678,d0      * populate test data
00:00003A3A 04000000        	  2306:             subi.b #0,d0
00:00003A3E 67FE            	  2307:             beq.s *                       * Check Z Flag  beq/bne
00:00003A40 6BFE            	  2308:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A42 65FE            	  2309:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003A44 69FE            	  2310:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003A46 04000010        	  2311:             subi.b #$10,d0
00:00003A4A 67FE            	  2312:             beq.s *                       * Check Z Flag  beq/bne
00:00003A4C 6BFE            	  2313:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A4E 65FE            	  2314:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003A50 69FE            	  2315:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003A52 040000A5        	  2316:             subi.b #$A5,d0
00:00003A56 67FE            	  2317:             beq.s *                       * Check Z Flag  beq/bne
00:00003A58 6AFE            	  2318:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003A5A 64FE            	  2319:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003A5C 68FE            	  2320:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003A5E 0C0000C3        	  2321:             cmpi.b #$C3,d0
00:00003A62 66FE            	  2322:             bne.s *                       * Check Z Flag  beq/bne
                            	  2323: 
                            	  2324: *     EA = Dn  - WORD
00:00003A64 203C12345678    	  2325:             move.l #$12345678,d0      * populate test data
00:00003A6A 04400000        	  2326:             subi.w #0,d0
00:00003A6E 67FE            	  2327:             beq.s *                       * Check Z Flag  beq/bne
00:00003A70 6BFE            	  2328:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A72 65FE            	  2329:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003A74 69FE            	  2330:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003A76 04407000        	  2331:             subi.w #$7000,d0
00:00003A7A 67FE            	  2332:             beq.s *                       * Check Z Flag  beq/bne
00:00003A7C 6AFE            	  2333:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003A7E 64FE            	  2334:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003A80 69FE            	  2335:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003A82 0440A55A        	  2336:             subi.w #$A55A,d0
00:00003A86 67FE            	  2337:             beq.s *                       * Check Z Flag  beq/bne
00:00003A88 6BFE            	  2338:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003A8A 65FE            	  2339:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003A8C 69FE            	  2340:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003A8E 0C40411E        	  2341:             cmpi.w #$411E,d0
00:00003A92 66FE            	  2342:             bne.s *                       * Check Z Flag  beq/bne
                            	  2343: 
                            	  2344: *     EA = Dn  - LONG
00:00003A94 203C12345678    	  2345:             move.l #$12345678,d0      * populate test data
00:00003A9A 048000000000    	  2346:             subi.l #0,d0
00:00003AA0 67FE            	  2347:             beq.s *                       * Check Z Flag  beq/bne
00:00003AA2 6BFE            	  2348:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003AA4 65FE            	  2349:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003AA6 69FE            	  2350:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003AA8 0480F0000000    	  2351:             subi.l #$F0000000,d0
00:00003AAE 67FE            	  2352:             beq.s *                       * Check Z Flag  beq/bne
00:00003AB0 6BFE            	  2353:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003AB2 64FE            	  2354:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003AB4 69FE            	  2355:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003AB6 0480855AA55A    	  2356:             subi.l #$855AA55A,d0
00:00003ABC 67FE            	  2357:             beq.s *                       * Check Z Flag  beq/bne
00:00003ABE 6AFE            	  2358:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003AC0 64FE            	  2359:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003AC2 68FE            	  2360:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003AC4 0480A0000000    	  2361:             subi.l #$A0000000,d0
00:00003ACA 69FE            	  2362:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003ACC 0C80FCD9B11E    	  2363:             cmpi.l #$FCD9B11E,d0
00:00003AD2 66FE            	  2364:             bne.s *                       * Check Z Flag  beq/bne
                            	  2365: 
                            	  2366: 
                            	  2367: 
                            	  2368: *     EA = x.L  - Byte
00:00003AD4 207C0000F100    	  2369:             move.l #$F100,a0      * populate test data
00:00003ADA 20BC12345678    	  2370:             move.l #$12345678,(a0)     * populate test data
00:00003AE0 043900000000F103	  2371:             subi.b #0,$F103
00:00003AE8 67FE            	  2372:             beq.s *                       * Check Z Flag  beq/bne
00:00003AEA 6BFE            	  2373:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003AEC 65FE            	  2374:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003AEE 69FE            	  2375:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003AF0 043900100000F103	  2376:             subi.b #$10,$F103
00:00003AF8 67FE            	  2377:             beq.s *                       * Check Z Flag  beq/bne
00:00003AFA 6BFE            	  2378:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003AFC 65FE            	  2379:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003AFE 69FE            	  2380:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003B00 043900A50000F103	  2381:             subi.b #$A5,$F103
00:00003B08 67FE            	  2382:             beq.s *                       * Check Z Flag  beq/bne
00:00003B0A 6AFE            	  2383:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003B0C 64FE            	  2384:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003B0E 68FE            	  2385:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003B10 0C3900C30000F103	  2386:             cmpi.b #$C3,$F103
00:00003B18 66FE            	  2387:             bne.s *                       * Check Z Flag  beq/bne
                            	  2388: 
                            	  2389: *     EA = x.L- WORD
00:00003B1A 207C0000F100    	  2390:             move.l #$F100,a0      * populate test data
00:00003B20 20BC12345678    	  2391:             move.l #$12345678,(a0)     * populate test data
00:00003B26 047900000000F100	  2392:             subi.w #0,$F100
00:00003B2E 67FE            	  2393:             beq.s *                       * Check Z Flag  beq/bne
00:00003B30 6BFE            	  2394:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003B32 65FE            	  2395:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003B34 69FE            	  2396:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003B36 047970000000F100	  2397:             subi.w #$7000,$F100
00:00003B3E 67FE            	  2398:             beq.s *                       * Check Z Flag  beq/bne
00:00003B40 6AFE            	  2399:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003B42 64FE            	  2400:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003B44 69FE            	  2401:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003B46 0479A55A0000F100	  2402:             subi.w #$A55A,$F100
00:00003B4E 67FE            	  2403:             beq.s *                       * Check Z Flag  beq/bne
00:00003B50 6AFE            	  2404:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003B52 64FE            	  2405:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003B54 69FE            	  2406:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003B56 0C79FCDA0000F100	  2407:             cmpi.w #$FCDA,$F100
00:00003B5E 66FE            	  2408:             bne.s *                       * Check Z Flag  beq/bne
                            	  2409: 
                            	  2410: *     EA = x.L- LONG
00:00003B60 23FC123456780000	  2411:             move.l #$12345678,$F100  * populate test data
00:00003B68 F100
00:00003B6A 04B9000000000000	  2412:             subi.l #0,$F100
00:00003B72 F100
00:00003B74 67FE            	  2413:             beq.s *                       * Check Z Flag  beq/bne
00:00003B76 6BFE            	  2414:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003B78 65FE            	  2415:             bcs.s *                       * Check C Flag  bcc/bcs
00:00003B7A 69FE            	  2416:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003B7C 04B9F00000000000	  2417:             subi.l #$F0000000,$F100
00:00003B84 F100
00:00003B86 67FE            	  2418:             beq.s *                       * Check Z Flag  beq/bne
00:00003B88 6BFE            	  2419:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003B8A 64FE            	  2420:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003B8C 69FE            	  2421:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003B8E 04B9855AA55A0000	  2422:             subi.l #$855AA55A,$F100
00:00003B96 F100
00:00003B98 67FE            	  2423:             beq.s *                       * Check Z Flag  beq/bne
00:00003B9A 6AFE            	  2424:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003B9C 64FE            	  2425:             bcc.s *                       * Check C Flag  bcc/bcs
00:00003B9E 68FE            	  2426:             bvc.s *                       * Check V Flag  bvc/bvs
00:00003BA0 04B9A00000000000	  2427:             subi.l #$A0000000,$F100
00:00003BA8 F100
00:00003BAA 69FE            	  2428:             bvs.s *                       * Check V Flag  bvc/bvs
00:00003BAC 0CB9FCD9B11E0000	  2429:             cmpi.l #$FCD9B11E,$F100
00:00003BB4 F100
00:00003BB6 66FE            	  2430:             bne.s *                       * Check Z Flag  beq/bne
                            	  2431: 
00:00003BB8 4E75            	  2432:             rts
                            	  2433: 
                            	  2434: 
                            	  2435: 
                            	  2436: *-----------------------------------------------------------
                            	  2437: *-----------------------------------------------------------
                            	  2438: * OPCODE : MOVE
                            	  2439: *-----------------------------------------------------------
                            	  2440: *-----------------------------------------------------------
                            	  2441: op_MOVE:
00:00003BBA 203C11223344    	  2442:             move.l #$11223344,d0
00:00003BC0 223C55667788    	  2443:             move.l #$55667788,d1
00:00003BC6 243C8899AABB    	  2444:             move.l #$8899aabb,d2
00:00003BCC 263CCCDDEEFF    	  2445:             move.l #$ccddeeff,d3
00:00003BD2 7800            	  2446:             moveq  #$00000000,d4
00:00003BD4 7A00            	  2447:             moveq  #$00000000,d5
00:00003BD6 7C00            	  2448:             moveq  #$00000000,d6
00:00003BD8 7E00            	  2449:             moveq  #$00000000,d7
00:00003BDA 207C44332211    	  2450:             move.l #$44332211,a0
00:00003BE0 227C88776655    	  2451:             move.l #$88776655,a1
00:00003BE6 247CBBAA9988    	  2452:             move.l #$bbaa9988,a2
00:00003BEC 267CFFEEDDCC    	  2453:             move.l #$ffeeddcc,a3
                            	  2454: 
00:00003BF2 1800            	  2455:             move.b d0,d4              * BYTE - DATA REGISTER
00:00003BF4 67FE            	  2456:             beq.s *                       * Check Z Flag  beq/bne
00:00003BF6 6BFE            	  2457:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003BF8 0C8400000044    	  2458:             cmpi.l #$00000044,d4
00:00003BFE 66FE            	  2459:             bne.s *                       * Check Z Flag  beq/bne
                            	  2460: 
00:00003C00 3A01            	  2461:             move.w d1,d5              * WORD - DATA REGISTER
00:00003C02 67FE            	  2462:             beq.s *                       * Check Z Flag  beq/bne
00:00003C04 6BFE            	  2463:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003C06 0C8500007788    	  2464:             cmpi.l #$00007788,d5
00:00003C0C 66FE            	  2465:             bne.s *                       * Check Z Flag  beq/bne
                            	  2466: 
00:00003C0E 2C02            	  2467:             move.l d2,d6              * LONG - DATA REGISTER
00:00003C10 67FE            	  2468:             beq.s *                       * Check Z Flag  beq/bne
00:00003C12 6AFE            	  2469:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003C14 0C868899AABB    	  2470:             cmpi.l #$8899aabb,d6
00:00003C1A 66FE            	  2471:             bne.s *                       * Check Z Flag  beq/bne
                            	  2472: 
00:00003C1C 3A09            	  2473:             move.w a1,d5              * WORD - ADDRESS REGISTER
00:00003C1E 67FE            	  2474:             beq.s *                       * Check Z Flag  beq/bne
00:00003C20 6BFE            	  2475:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003C22 0C8500006655    	  2476:             cmpi.l #$00006655,d5
00:00003C28 66FE            	  2477:             bne.s *                       * Check Z Flag  beq/bne
                            	  2478: 
00:00003C2A 2C0A            	  2479:             move.l a2,d6              * LONG - ADDRESS REGISTER
00:00003C2C 67FE            	  2480:             beq.s *                       * Check Z Flag  beq/bne
00:00003C2E 6AFE            	  2481:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003C30 0C86BBAA9988    	  2482:             cmpi.l #$bbaa9988,d6
00:00003C36 66FE            	  2483:             bne.s *                       * Check Z Flag  beq/bne
                            	  2484: 
                            	  2485: 
00:00003C38 3842            	  2486:             movea.w d2,a4             * WORD - ADDRESS REGISTER as SOURCE ## MOVEA
00:00003C3A B9C2            	  2487:             cmpa.l d2,a4
00:00003C3C 67FE            	  2488:             beq.s *                       * Check Z Flag  beq/bne ## comopare fails because A4 was sign extended
                            	  2489: 
00:00003C3E 2A41            	  2490:             movea.l d1,a5             * LONG - ADDRESS REGISTER as SOURCE ## MOVEA
00:00003C40 BBC1            	  2491:             cmpa.l d1,a5
00:00003C42 66FE            	  2492:             bne.s *                       * Check Z Flag  beq/bne
                            	  2493: 
                            	  2494: 
                            	  2495: 
                            	  2496: *   Too mamy EA combinations to test,so we focus on a few of the more complicted EA's
                            	  2497: 
00:00003C44 203C11223344    	  2498:             move.l #$11223344,d0
00:00003C4A 223C00010100    	  2499:             move.l #$00010100,d1
00:00003C50 243C8899AABB    	  2500:             move.l #$8899aabb,d2
00:00003C56 7601            	  2501:             moveq  #$00000001,d3
00:00003C58 7800            	  2502:             moveq  #$00000000,d4
00:00003C5A 7A00            	  2503:             moveq  #$00000000,d5
00:00003C5C 7C00            	  2504:             moveq  #$00000000,d6
00:00003C5E 7E00            	  2505:             moveq  #$00000000,d7
00:00003C60 91C8            	  2506:             move.l #$00000000,a0
00:00003C62 227C00010100    	  2507:             move.l #$00010100,a1
                            	  2508: 
                            	  2509: *     x(An,AL) --> x.L
00:00003C68 11BC005A9804    	  2510:             move.b #$5A,4(a0,a1.l)    * BYTE
00:00003C6E 47F09804        	  2511:             lea 4(a0,a1.l),a3
00:00003C72 13F0980400010105	  2512:             move.b 4(a0,a1.l),$00010105
00:00003C7A 67FE            	  2513:             beq.s *                       * Check Z Flag  beq/bne
00:00003C7C 6BFE            	  2514:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003C7E 0C30005A9805    	  2515:             cmpi.b #$5A,5(a0,a1.l)
00:00003C84 66FE            	  2516:             bne.s *                       * Check Z Flag  beq/bne
                            	  2517: 
                            	  2518: *     x.L --> n(An,Dw)
00:00003C86 11B9000101051007	  2519: MOVE2:      move.b  $00010105,7(a0,d1.w)    * BYTE
00:00003C8E 67FE            	  2520:             beq.s *                       * Check Z Flag  beq/bne
00:00003C90 6BFE            	  2521:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003C92 0C30005A1007    	  2522:             cmpi.b #$5A,7(a0,d1.w)
00:00003C98 66FE            	  2523:             bne.s *                       * Check Z Flag  beq/bne
                            	  2524: 
                            	  2525: *     x(PC,Ds) --> x.w
00:00003C9A 11FB30660100    	  2526:             move.b  MOVE1(pc,d3.w),$0100 * BYTE
00:00003CA0 67FE            	  2527:             beq.s *                       * Check Z Flag  beq/bne
00:00003CA2 6AFE            	  2528:             bpl.s *                       * Check N Flag  bmi/bpl
00:00003CA4 0C3900B900003C87	  2529:             cmpi.b #$B9,1+MOVE2
00:00003CAC 66FE            	  2530:             bne.s *                       * Check Z Flag  beq/bne
                            	  2531: 
                            	  2532: *     #x -->    n(An,AL)
00:00003CAE 11BC00781007    	  2533:             move.b  #$78,7(a0,d1.w)    * BYTE
00:00003CB4 67FE            	  2534:             beq.s *                       * Check Z Flag  beq/bne
00:00003CB6 6BFE            	  2535:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003CB8 0C3000781007    	  2536:             cmpi.b #$78,7(a0,d1.w)
00:00003CBE 66FE            	  2537:             bne.s *                       * Check Z Flag  beq/bne
                            	  2538: 
00:00003CC0 203C11223344    	  2539:             move.l #$11223344,d0
00:00003CC6 223C00010100    	  2540:             move.l #$00010100,d1
00:00003CCC 243C8899AABB    	  2541:             move.l #$8899aabb,d2
00:00003CD2 7602            	  2542:             moveq  #$00000002,d3
00:00003CD4 7800            	  2543:             moveq  #$00000000,d4
00:00003CD6 7A00            	  2544:             moveq  #$00000000,d5
00:00003CD8 7C00            	  2545:             moveq  #$00000000,d6
00:00003CDA 7E00            	  2546:             moveq  #$00000000,d7
00:00003CDC 91C8            	  2547:             move.l #$00000000,a0
00:00003CDE 227C00010100    	  2548:             move.l #$00010100,a1
                            	  2549: 
                            	  2550: *     x(An,AL) --> x.L
00:00003CE4 31BC5A5A9804    	  2551:             move.w #$5A5A,4(a0,a1.l)    * WORD
00:00003CEA 49F09804        	  2552:             lea 4(a0,a1.l),a4
00:00003CEE 33F0980400010104	  2553:             move.w 4(a0,a1.l),$00010104
00:00003CF6 67FE            	  2554:             beq.s *                       * Check Z Flag  beq/bne
00:00003CF8 6BFE            	  2555:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003CFA 0C705A5A9804    	  2556:             cmpi.w #$5A5A,4(a0,a1.l)
00:00003D00 66FE            	  2557:             bne.s *                       * Check Z Flag  beq/bne
                            	  2558: 
                            	  2559: *     x.L --> n(An,Dw)
00:00003D02 31B9000101041006	  2560: MOVE1:      move.w  $00010104,6(a0,d1.w)    * WORD
00:00003D0A 67FE            	  2561:             beq.s *                       * Check Z Flag  beq/bne
00:00003D0C 6BFE            	  2562:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003D0E 0C705A5A1006    	  2563:             cmpi.w #$5A5A,6(a0,d1.w)
00:00003D14 66FE            	  2564:             bne.s *                       * Check Z Flag  beq/bne
                            	  2565: 
                            	  2566: *     x(PC,Ds) --> x.w
00:00003D16 31FB30EA0100    	  2567:             move.w  MOVE1(pc,d3),$0100 * WORD
00:00003D1C 67FE            	  2568:             beq.s *                       * Check Z Flag  beq/bne
00:00003D1E 6BFE            	  2569:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003D20 0C7967FE00003D0A	  2570:             cmpi.w #$67FE,8+MOVE1
00:00003D28 66FE            	  2571:             bne.s *                       * Check Z Flag  beq/bne
                            	  2572: 
                            	  2573: *     #x -->    n(An,AL)
00:00003D2A 31BC78781006    	  2574:             move.w  #$7878,6(a0,d1.w)    * WORD
00:00003D30 67FE            	  2575:             beq.s *                       * Check Z Flag  beq/bne
00:00003D32 6BFE            	  2576:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003D34 0C7078781006    	  2577:             cmpi.w #$7878,6(a0,d1.w)
00:00003D3A 66FE            	  2578:             bne.s *                       * Check Z Flag  beq/bne
                            	  2579: 
                            	  2580: * ---
                            	  2581: 
00:00003D3C 203C11223344    	  2582:             move.l #$11223344,d0
00:00003D42 223C00010100    	  2583:             move.l #$00010100,d1
00:00003D48 243C8899AABB    	  2584:             move.l #$8899aabb,d2
00:00003D4E 7602            	  2585:             moveq  #$00000002,d3
00:00003D50 7800            	  2586:             moveq  #$00000000,d4
00:00003D52 7A00            	  2587:             moveq  #$00000000,d5
00:00003D54 7C00            	  2588:             moveq  #$00000000,d6
00:00003D56 7E00            	  2589:             moveq  #$00000000,d7
00:00003D58 91C8            	  2590:             move.l #$00000000,a0
00:00003D5A 227C00010100    	  2591:             move.l #$00010100,a1
                            	  2592: 
                            	  2593: *     x(An,AL) --> x.L
00:00003D60 21BC5A5A12349804	  2594:             move.l #$5A5A1234,4(a0,a1.l)    * LONG
00:00003D68 49F09804        	  2595:             lea 4(a0,a1.l),a4
00:00003D6C 23F0980400010104	  2596:             move.l 4(a0,a1.l),$00010104
00:00003D74 67FE            	  2597:             beq.s *                       * Check Z Flag  beq/bne
00:00003D76 6BFE            	  2598:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003D78 0CB05A5A12349804	  2599:             cmpi.l #$5A5A1234,4(a0,a1.l)
00:00003D80 66FE            	  2600:             bne.s *                       * Check Z Flag  beq/bne
                            	  2601: 
                            	  2602: *     x.L --> n(An,Dw)
00:00003D82 21B9000101041006	  2603: MOVE3:      move.l  $00010104,6(a0,d1.w)    * LONG
00:00003D8A 67FE            	  2604:             beq.s *                       * Check Z Flag  beq/bne
00:00003D8C 6BFE            	  2605:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003D8E 0CB05A5A12341006	  2606:             cmpi.l #$5A5A1234,6(a0,d1.w)
00:00003D96 66FE            	  2607:             bne.s *                       * Check Z Flag  beq/bne
                            	  2608: 
                            	  2609: *     x(PC,Ds) --> x.w
00:00003D98 21FB30E80100    	  2610:             move.l  MOVE3(pc,d3),$0100 * LONG
00:00003D9E 67FE            	  2611:             beq.s *                       * Check Z Flag  beq/bne
00:00003DA0 6BFE            	  2612:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003DA2 0CB967FE6BFE0000	  2613:             cmpi.l #$67FE6BFE,8+MOVE3
00:00003DAA 3D8A
00:00003DAC 66FE            	  2614:             bne.s *                       * Check Z Flag  beq/bne
                            	  2615: 
                            	  2616: *     #x -->    n(An,AL)
00:00003DAE 21BC787823231006	  2617:             move.l  #$78782323,6(a0,d1.w)    * LONG
00:00003DB6 67FE            	  2618:             beq.s *                       * Check Z Flag  beq/bne
00:00003DB8 6BFE            	  2619:             bmi.s *                       * Check N Flag  bmi/bpl
00:00003DBA 0CB0787823231006	  2620:             cmpi.l #$78782323,6(a0,d1.w)
00:00003DC2 66FE            	  2621:             bne.s *                       * Check Z Flag  beq/bne
                            	  2622: 
                            	  2623: 
00:00003DC4 4E75            	  2624:          rts
                            	  2625: 
                            	  2626: 
                            	  2627: *-----------------------------------------------------------
                            	  2628: *-----------------------------------------------------------
                            	  2629: * OPCODE : MOVE_xxx_FLAGS
                            	  2630: *-----------------------------------------------------------
                            	  2631: *-----------------------------------------------------------
                            	  2632: op_MOVE_xxx_FLAGS:
                            	  2633: 
                            	  2634: *     Move_To_SR
                            	  2635: 
                            	  2636: *     Dn
                            	  2637: 
00:00003DC6 303C2FFF        	  2638:             move.w #$2FFF,d0
00:00003DCA 46C0            	  2639:             move.w d0,SR
00:00003DCC 6AFE            	  2640:             bpl.s *           * branch if Z clear
00:00003DCE 66FE            	  2641:             bne.s *           * branch if N clear
00:00003DD0 68FE            	  2642:             bvc.s *           * branch if V clear
00:00003DD2 64FE            	  2643:             bcc.s *           * branch if C clear
00:00003DD4 303C2F00        	  2644:             move.w #$2F00,d0
00:00003DD8 44C0            	  2645:             move d0,CCR
00:00003DDA 67FE            	  2646:             beq.s *           * branch if Z set
00:00003DDC 6BFE            	  2647:             bmi.s *           * branch if N set
00:00003DDE 69FE            	  2648:             bvs.s *           * branch if V set
00:00003DE0 65FE            	  2649:             bcs.s *           * branch if C set
                            	  2650: 
00:00003DE2 303C2000        	  2651:             move.w #$2000,d0
00:00003DE6 46C0            	  2652:             move.w d0,SR
00:00003DE8 67FE            	  2653:             beq.s *           * branch if Z set
00:00003DEA 6BFE            	  2654:             bmi.s *           * branch if N set
00:00003DEC 69FE            	  2655:             bvs.s *           * branch if V set
00:00003DEE 65FE            	  2656:             bcs.s *           * branch if C set
                            	  2657: 
                            	  2658: *     (An)
00:00003DF0 307C0100        	  2659:             move.l #$00000100,a0
00:00003DF4 30BC2FFF        	  2660:             move.w #$2FFF,(a0)
00:00003DF8 46D0            	  2661:             move.w (a0),SR
00:00003DFA 6AFE            	  2662:             bpl.s *           * branch if Z clear
00:00003DFC 66FE            	  2663:             bne.s *           * branch if N clear
00:00003DFE 68FE            	  2664:             bvc.s *           * branch if V clear
00:00003E00 64FE            	  2665:             bcc.s *           * branch if C clear
                            	  2666: 
00:00003E02 30BC2000        	  2667:             move.w #$2000,(a0)
00:00003E06 46D0            	  2668:             move.w (a0),SR
00:00003E08 67FE            	  2669:             beq.s *           * branch if Z set
00:00003E0A 6BFE            	  2670:             bmi.s *           * branch if N set
00:00003E0C 69FE            	  2671:             bvs.s *           * branch if V set
00:00003E0E 65FE            	  2672:             bcs.s *           * branch if C set
                            	  2673: 
                            	  2674: *     (An)+
00:00003E10 307C0100        	  2675:             move.l #$00000100,a0
00:00003E14 30BC2FFF        	  2676:             move.w #$2FFF,(a0)
00:00003E18 46D8            	  2677:             move.w (a0)+,SR
00:00003E1A 6AFE            	  2678:             bpl.s *           * branch if Z clear
00:00003E1C 66FE            	  2679:             bne.s *           * branch if N clear
00:00003E1E 68FE            	  2680:             bvc.s *           * branch if V clear
00:00003E20 64FE            	  2681:             bcc.s *           * branch if C clear
                            	  2682: 
00:00003E22 30BC2000        	  2683:             move.w #$2000,(a0)
00:00003E26 46D8            	  2684:             move.w (a0)+,SR
00:00003E28 67FE            	  2685:             beq.s *           * branch if Z set
00:00003E2A 6BFE            	  2686:             bmi.s *           * branch if N set
00:00003E2C 69FE            	  2687:             bvs.s *           * branch if V set
00:00003E2E 65FE            	  2688:             bcs.s *           * branch if C set
                            	  2689: 
                            	  2690: *     -(An)
00:00003E30 307C0102        	  2691:             move.l #$00000102,a0
00:00003E34 30BC2FFF        	  2692:             move.w #$2FFF,(a0)
00:00003E38 46D8            	  2693:             move.w (a0)+,SR
00:00003E3A 6AFE            	  2694:             bpl.s *           * branch if Z clear
00:00003E3C 66FE            	  2695:             bne.s *           * branch if N clear
00:00003E3E 68FE            	  2696:             bvc.s *           * branch if V clear
00:00003E40 64FE            	  2697:             bcc.s *           * branch if C clear
                            	  2698: 
00:00003E42 30BC2000        	  2699:             move.w #$2000,(a0)
00:00003E46 46D8            	  2700:             move.w (a0)+,SR
00:00003E48 67FE            	  2701:             beq.s *           * branch if Z set
00:00003E4A 6BFE            	  2702:             bmi.s *           * branch if N set
00:00003E4C 69FE            	  2703:             bvs.s *           * branch if V set
00:00003E4E 65FE            	  2704:             bcs.s *           * branch if C set
                            	  2705: 
                            	  2706: *     n(An)
00:00003E50 307C0102        	  2707:             move.l #$00000102,a0
00:00003E54 317C2FFF0002    	  2708:             move.w #$2FFF,2(a0)
00:00003E5A 46E80002        	  2709:             move.w 2(a0),SR
00:00003E5E 6AFE            	  2710:             bpl.s *           * branch if Z clear
00:00003E60 66FE            	  2711:             bne.s *           * branch if N clear
00:00003E62 68FE            	  2712:             bvc.s *           * branch if V clear
00:00003E64 64FE            	  2713:             bcc.s *           * branch if C clear
                            	  2714: 
00:00003E66 317C20000002    	  2715:             move.w #$2000,2(a0)
00:00003E6C 46E80002        	  2716:             move.w 2(a0),SR
00:00003E70 67FE            	  2717:             beq.s *           * branch if Z set
00:00003E72 6BFE            	  2718:             bmi.s *           * branch if N set
00:00003E74 69FE            	  2719:             bvs.s *           * branch if V set
00:00003E76 65FE            	  2720:             bcs.s *           * branch if C set
                            	  2721: 
                            	  2722: *     n(An,Rn.l)
00:00003E78 307C0100        	  2723:             move.l #$00000100,a0
00:00003E7C 7002            	  2724:             moveq  #$00000002,d0
00:00003E7E 31BC2FFF0802    	  2725:             move.w #$2FFF,2(a0,d0.l)
00:00003E84 46F00802        	  2726:             move.w 2(a0,d0.l),SR
00:00003E88 6AFE            	  2727:             bpl.s *           * branch if Z clear
00:00003E8A 66FE            	  2728:             bne.s *           * branch if N clear
00:00003E8C 68FE            	  2729:             bvc.s *           * branch if V clear
00:00003E8E 64FE            	  2730:             bcc.s *           * branch if C clear
                            	  2731: 
00:00003E90 31BC20000802    	  2732:             move.w #$2000,2(a0,d0.l)
00:00003E96 46F00802        	  2733:             move.w 2(a0,d0.l),SR
00:00003E9A 67FE            	  2734:             beq.s *           * branch if Z set
00:00003E9C 6BFE            	  2735:             bmi.s *           * branch if N set
00:00003E9E 69FE            	  2736:             bvs.s *           * branch if V set
00:00003EA0 65FE            	  2737:             bcs.s *           * branch if C set
                            	  2738: 
                            	  2739: *     x.W
00:00003EA2 31FC2FFF0100    	  2740:             move.w #$2FFF,$0100
00:00003EA8 46F80100        	  2741:             move.w $0100,SR
00:00003EAC 6AFE            	  2742:             bpl.s *           * branch if Z clear
00:00003EAE 66FE            	  2743:             bne.s *           * branch if N clear
00:00003EB0 68FE            	  2744:             bvc.s *           * branch if V clear
00:00003EB2 64FE            	  2745:             bcc.s *           * branch if C clear
                            	  2746: 
00:00003EB4 31FC20000100    	  2747:             move.w #$2000,$0100
00:00003EBA 46F80100        	  2748:             move.w $0100,SR
00:00003EBE 67FE            	  2749:             beq.s *           * branch if Z set
00:00003EC0 6BFE            	  2750:             bmi.s *           * branch if N set
00:00003EC2 69FE            	  2751:             bvs.s *           * branch if V set
00:00003EC4 65FE            	  2752:             bcs.s *           * branch if C set
                            	  2753: 
                            	  2754: *     x.L
00:00003EC6 33FC2FFF00010100	  2755:             move.w #$2FFF,$00010100
00:00003ECE 46F900010100    	  2756:             move.w $00010100,SR
00:00003ED4 6AFE            	  2757:             bpl.s *           * branch if Z clear
00:00003ED6 66FE            	  2758:             bne.s *           * branch if N clear
00:00003ED8 68FE            	  2759:             bvc.s *           * branch if V clear
00:00003EDA 64FE            	  2760:             bcc.s *           * branch if C clear
                            	  2761: 
00:00003EDC 33FC200000010100	  2762: MOVE4:      move.w #$2000,$00010100
00:00003EE4 46F900010100    	  2763:             move.w $00010100,SR
00:00003EEA 67FE            	  2764:             beq.s *           * branch if Z set
00:00003EEC 6BFE            	  2765:             bmi.s *           * branch if N set
00:00003EEE 69FE            	  2766:             bvs.s *           * branch if V set
00:00003EF0 65FE            	  2767:             bcs.s *           * branch if C set
                            	  2768: 
                            	  2769: *     x(PC)
00:00003EF2 46FAFFEA        	  2770:             move.w MOVE4+2(pc),SR
00:00003EF6 67FE            	  2771:             beq.s *           * branch if Z set
00:00003EF8 6BFE            	  2772:             bmi.s *           * branch if N set
00:00003EFA 69FE            	  2773:             bvs.s *           * branch if V set
00:00003EFC 65FE            	  2774:             bcs.s *           * branch if C set
                            	  2775: 
                            	  2776: *     x(PC,d0.l)
00:00003EFE 7000            	  2777:             moveq  #$00000000,d0
00:00003F00 46FB08DC        	  2778:             move.w MOVE4+2(pc,d0.l),SR
00:00003F04 67FE            	  2779:             beq.s *           * branch if Z set
00:00003F06 6BFE            	  2780:             bmi.s *           * branch if N set
00:00003F08 69FE            	  2781:             bvs.s *           * branch if V set
00:00003F0A 65FE            	  2782:             bcs.s *           * branch if C set
00:00003F0C 44FB08D0        	  2783:             move MOVE4+2(pc,d0.l),CCR
00:00003F10 67FE            	  2784:             beq.s *           * branch if Z set
00:00003F12 6BFE            	  2785:             bmi.s *           * branch if N set
00:00003F14 69FE            	  2786:             bvs.s *           * branch if V set
00:00003F16 65FE            	  2787:             bcs.s *           * branch if C set
                            	  2788: 
                            	  2789: *     #x
00:00003F18 46FC2FFF        	  2790:             move.w #$2FFF,SR
00:00003F1C 66FE            	  2791:             bne.s *           * branch if Z clear
00:00003F1E 6AFE            	  2792:             bpl.s *           * branch if N clear
00:00003F20 68FE            	  2793:             bvc.s *           * branch if V clear
00:00003F22 64FE            	  2794:             bcc.s *           * branch if C clear
                            	  2795: 
                            	  2796: 
                            	  2797: 
                            	  2798: *  MOVE_From_SR
                            	  2799: 
                            	  2800: 
                            	  2801: 
                            	  2802: *     Dn
00:00003F24 46FC275A        	  2803:             move.w #$275A,SR          * Initial value
00:00003F28 40C0            	  2804:             move.w SR,d0
00:00003F2A 0C40271A        	  2805:             cmpi.w #$271A,d0
                            	  2806: * The following fails because sr bits are implemented and non-zero so later code works.           
                            	  2807: *            bne.s *                   * branch if Z set
                            	  2808: 
                            	  2809: *     (An)
00:00003F2E 307C0100        	  2810:             move.l #$00000100,a0
00:00003F32 46FC275A        	  2811:             move.w #$275A,SR          * Initial value
00:00003F36 40D0            	  2812:             move.w SR,(a0)
00:00003F38 0C50275A        	  2813:             cmpi.w #$275A,(a0)
00:00003F3C 66FE            	  2814:             bne.s *                   * branch if Z set
                            	  2815: 
                            	  2816: *     (An)+
00:00003F3E 307C0100        	  2817:             move.l #$00000100,a0
00:00003F42 46FC257A        	  2818:             move.w #$257A,SR          * Initial value
00:00003F46 40D8            	  2819:             move.w SR,(a0)+
00:00003F48 307C0100        	  2820:             move.l #$00000100,a0
00:00003F4C 0C58257A        	  2821:             cmpi.w #$257A,(a0)+
00:00003F50 66FE            	  2822:             bne.s *                   * branch if Z set
                            	  2823: 
                            	  2824: *     -(An)
00:00003F52 307C0102        	  2825:             move.l #$00000102,a0
00:00003F56 46FC2766        	  2826:             move.w #$2766,SR          * Initial value
00:00003F5A 40E0            	  2827:             move.w SR,-(a0)
00:00003F5C 307C0100        	  2828:             move.l #$00000100,a0
00:00003F60 0C502766        	  2829:             cmpi.w #$2766,(a0)
00:00003F64 66FE            	  2830:             bne.s *                   * branch if Z set
                            	  2831: 
                            	  2832: *     x(An)
00:00003F66 307C0102        	  2833:             move.l #$00000102,a0
00:00003F6A 46FC2733        	  2834:             move.w #$2733,SR          * Initial value
00:00003F6E 40E80004        	  2835:             move.w SR,4(a0)
00:00003F72 0C6827330004    	  2836:             cmpi.w #$2733,4(a0)
00:00003F78 66FE            	  2837:             bne.s *                   * branch if Z set
                            	  2838: 
                            	  2839: *     x(An,rn)
00:00003F7A 307C0102        	  2840:             move.l #$00000102,a0
00:00003F7E 7004            	  2841:             moveq  #$00000004,d0
00:00003F80 46FC275A        	  2842:             move.w #$275a,SR          * Initial value
00:00003F84 40F00804        	  2843:             move.w SR,4(a0,d0.l)
00:00003F88 0C70275A0804    	  2844:             cmpi.w #$275a,4(a0,d0.l)
00:00003F8E 66FE            	  2845:             bne.s *                   * branch if Z set
                            	  2846: 
                            	  2847: *     x.W
00:00003F90 46FC2777        	  2848:             move.w #$2777,SR          * Initial value
00:00003F94 40F80102        	  2849:             move.w SR,$0102
00:00003F98 0C7827770102    	  2850:             cmpi.w #$2777,$0102
00:00003F9E 66FE            	  2851:             bne.s *                   * branch if Z set
                            	  2852: 
                            	  2853: *     x.L
00:00003FA0 46FC2777        	  2854:             move.w #$2777,SR          * Initial value
00:00003FA4 40F900010102    	  2855:             move.w SR,$10102
00:00003FAA 0C79277700010102	  2856:             cmpi.w #$2777,$10102
00:00003FB2 66FE            	  2857:             bne.s *                   * branch if Z set
                            	  2858: 
                            	  2859: 
                            	  2860: 
00:00003FB4 46FC2700        	  2861:             move.w #$2700,SR          * Put flags back to initial value
                            	  2862: 
00:00003FB8 4E75            	  2863:             rts
                            	  2864: 
                            	  2865: 
                            	  2866: *-----------------------------------------------------------
                            	  2867: *-----------------------------------------------------------
                            	  2868: * OPCODE : EXT
                            	  2869: *-----------------------------------------------------------
                            	  2870: *-----------------------------------------------------------
                            	  2871: op_EXT:
                            	  2872: 
00:00003FBA 707F            	  2873:             move.l #$0000007F,d0
00:00003FBC 223C00008FFF    	  2874:             move.l #$00008FFF,d1
00:00003FC2 7400            	  2875:             moveq  #$00000000,d2
                            	  2876: 
00:00003FC4 4880            	  2877:             ext.w d0
00:00003FC6 6BFE            	  2878:             bmi.s *                   * Check N Flag  bmi/bpl
00:00003FC8 67FE            	  2879:             beq.s *                   * Check Z Flag  beq/bne
00:00003FCA 0C800000007F    	  2880:             cmpi.l #$0000007F,d0
00:00003FD0 66FE            	  2881:             bne.s *                   * branch if Z set
                            	  2882: 
00:00003FD2 48C1            	  2883:             ext.l d1
00:00003FD4 6AFE            	  2884:             bpl.s *                   * Check N Flag  bmi/bpl
00:00003FD6 67FE            	  2885:             beq.s *                   * Check Z Flag  beq/bne
00:00003FD8 0C81FFFF8FFF    	  2886:             cmpi.l #$FFFF8FFF,d1
00:00003FDE 66FE            	  2887:             bne.s *                   * branch if Z set
                            	  2888: 
00:00003FE0 48C2            	  2889:             ext.l d2
00:00003FE2 66FE            	  2890:             bne.s *                   * Check Z Flag  beq/bne
                            	  2891: 
                            	  2892: 
                            	  2893: 
00:00003FE4 4E75            	  2894:             rts
                            	  2895: 
                            	  2896: 
                            	  2897: *-----------------------------------------------------------
                            	  2898: *-----------------------------------------------------------
                            	  2899: * OPCODE : SWAP
                            	  2900: *-----------------------------------------------------------
                            	  2901: *-----------------------------------------------------------
                            	  2902: op_SWAP:
                            	  2903: 
00:00003FE6 203C12345678    	  2904:             move.l #$12345678,d0
                            	  2905: 
00:00003FEC 4840            	  2906:             swap d0
00:00003FEE 6BFE            	  2907:             bmi.s *                   * Check N Flag  bmi/bpl
00:00003FF0 67FE            	  2908:             beq.s *                   * Check Z Flag  beq/bne
00:00003FF2 0C8056781234    	  2909:             cmpi.l #$56781234,d0
00:00003FF8 66FE            	  2910:             bne.s *                   * branch if Z set
                            	  2911: 
                            	  2912: 
                            	  2913: 
00:00003FFA 4E75            	  2914:             rts
                            	  2915: 
                            	  2916: 
                            	  2917: *-----------------------------------------------------------
                            	  2918: *-----------------------------------------------------------
                            	  2919: * OPCODE : LEA_PEA
                            	  2920: *-----------------------------------------------------------
                            	  2921: *-----------------------------------------------------------
                            	  2922: op_LEAPEA:
                            	  2923: 
00:00003FFC 207C00345678    	  2924:             move.l #$00345678,a0
00:00004002 7800            	  2925:             moveq  #$00000000,d4
                            	  2926: 
                            	  2927: *     (An)
00:00004004 4DD0            	  2928:             lea (a0),a6
00:00004006 200E            	  2929:             move.l a6,d0
00:00004008 0C8000345678    	  2930:             cmpi.l #$00345678,d0
00:0000400E 66FE            	  2931:             bne.s *                   * branch if Z set
00:00004010 4850            	  2932:             pea (a0)
00:00004012 0C9700345678    	  2933:             cmpi.l #$00345678,(a7)
00:00004018 66FE            	  2934:             bne.s *                   * branch if Z set
                            	  2935:             * This was without a specifier which the assembler defaulted to .w
00:0000401A 588F            	  2936:             addq.l #4,a7            * Restore Stack Pointer
                            	  2937: 
                            	  2938: *     x(An)
00:0000401C 4DE80004        	  2939:             lea 4(a0),a6
00:00004020 200E            	  2940:             move.l a6,d0
00:00004022 0C800034567C    	  2941:             cmpi.l #$0034567C,d0
00:00004028 66FE            	  2942:             bne.s *                   * branch if Z set
00:0000402A 48680004        	  2943:             pea 4(a0)
00:0000402E 0C970034567C    	  2944:             cmpi.l #$0034567C,(a7)
00:00004034 66FE            	  2945:             bne.s *                   * branch if Z set
                            	  2946:             * This was without a specifier which the assembler defaulted to .w
00:00004036 588F            	  2947:             addq.l #4,a7            * Restore Stack Pointer
                            	  2948: 
                            	  2949: *     x(An,Dn.l)
00:00004038 4DF04004        	  2950:             lea 4(a0,d4),a6
00:0000403C 200E            	  2951:             move.l a6,d0
00:0000403E 0C800034567C    	  2952:             cmpi.l #$0034567C,d0
00:00004044 66FE            	  2953:             bne.s *                   * branch if Z set
00:00004046 48704804        	  2954:             pea 4(a0,d4.l)
00:0000404A 0C970034567C    	  2955:             cmpi.l #$0034567C,(a7)
00:00004050 66FE            	  2956:             bne.s *                   * branch if Z set
                            	  2957:             * This was without a specifier which the assembler defaulted to .w
00:00004052 588F            	  2958:             addq.l #4,a7            * Restore Stack Pointer
                            	  2959: 
                            	  2960: *     x.W
00:00004054 4DF81234        	  2961:             lea $1234,a6
00:00004058 200E            	  2962:             move.l a6,d0
00:0000405A 0C401234        	  2963:             cmpi.w #$1234,d0
00:0000405E 66FE            	  2964:             bne.s *                   * branch if Z set
00:00004060 48781234        	  2965:             pea $1234
00:00004064 0C9700001234    	  2966:             cmpi.l #$00001234,(a7)
00:0000406A 66FE            	  2967:             bne.s *                   * branch if Z set
                            	  2968:             * This was without a specifier which the assembler defaulted to .w
00:0000406C 588F            	  2969:             addq.l #4,a7            * Restore Stack Pointer
                            	  2970: 
                            	  2971: *     x.L
00:0000406E 4DF900345678    	  2972:             lea $00345678,a6
00:00004074 200E            	  2973:             move.l a6,d0
00:00004076 B08E            	  2974:             cmp.l a6,d0
00:00004078 66FE            	  2975:             bne.s *                   * branch if Z set
00:0000407A 487900345678    	  2976:             pea $00345678
00:00004080 0C9700345678    	  2977:             cmpi.l #$00345678,(a7)
00:00004086 66FE            	  2978:             bne.s *                   * branch if Z set
                            	  2979:             * This was without a specifier which the assembler defaulted to .w
00:00004088 588F            	  2980:             addq.l #4,a7            * Restore Stack Pointer
                            	  2981: 
                            	  2982: *     x(PC)
00:0000408A 4DFA0008        	  2983:             lea LEA1(pc),a6
00:0000408E 200E            	  2984:             move.l a6,d0
00:00004090 B08E            	  2985:             cmp.l a6,d0
00:00004092 66FE            	  2986:             bne.s *                   * branch if Z set
00:00004094 487AFFFE        	  2987: LEA1:       pea LEA1(pc)
00:00004098 0C970000241E    	  2988:             cmpi.l #$0000241E,(a7)
00:0000409E 67FE            	  2989:             beq.s *                   * branch if Z clear
                            	  2990:             * This was without a specifier which the assembler defaulted to .w
00:000040A0 588F            	  2991:             addq.l #4,a7              * Restore Stack Pointer
                            	  2992: 
                            	  2993: 
                            	  2994: 
                            	  2995: 
00:000040A2 46FC2700        	  2996:             move.w #$2700,sr          * Put flags back to initial value
                            	  2997: 
00:000040A6 4E75            	  2998:             rts
                            	  2999:  	
                            	  3000: 
                            	  3001: 
                            	  3002: *-----------------------------------------------------------
                            	  3003: *-----------------------------------------------------------
                            	  3004: * OPCODE : LEA_TAS
                            	  3005: *-----------------------------------------------------------
                            	  3006: *-----------------------------------------------------------
                            	  3007: op_TAS:
                            	  3008: 
                            	  3009: *     Test just one addressing mode
                            	  3010: 
00:000040A8 307C0100        	  3011:             move.l #$00000100,a0
                            	  3012: 
                            	  3013: *     (An)
00:000040AC 4210            	  3014:             move.b #$00,(a0)
00:000040AE 6BFE            	  3015:             bmi.s *                   * Check N Flag  bmi/bpl
00:000040B0 66FE            	  3016:             bne.s *                   * Check Z Flag  beq/bne
00:000040B2 4AD0            	  3017:             tas (a0)
00:000040B4 0C100080        	  3018:             cmpi.b #$80,(a0)
00:000040B8 66FE            	  3019:             bne.s *                   * branch if Z set
00:000040BA 10BC00F5        	  3020:             move.b #$F5,(a0)
00:000040BE 4AD0            	  3021:             tas (a0)
00:000040C0 6AFE            	  3022:             bpl.s *                   * Check N Flag  bmi/bpl
00:000040C2 67FE            	  3023:             beq.s *                   * Check Z Flag  beq/bne
00:000040C4 4AD0            	  3024:             tas (a0)
00:000040C6 0C1000F5        	  3025:             cmpi.b #$F5,(a0)
00:000040CA 66FE            	  3026:             bne.s *                   * branch if Z set
                            	  3027: 
00:000040CC 4E75            	  3028:             rts
                            	  3029: 
                            	  3030: 
                            	  3031: *-----------------------------------------------------------
                            	  3032: *-----------------------------------------------------------
                            	  3033: * OPCODE : LEA_TST
                            	  3034: *-----------------------------------------------------------
                            	  3035: *-----------------------------------------------------------
                            	  3036: op_TST:
                            	  3037: 
                            	  3038: *     Test just one addressing mode
                            	  3039: 
00:000040CE 307C0100        	  3040:             move.l #$00000100,a0
                            	  3041: 
                            	  3042: *     (An) - BYTE
00:000040D2 4210            	  3043:             move.b #$00,(a0)
00:000040D4 4A10            	  3044:             tst.b (a0)
00:000040D6 6BFE            	  3045:             bmi.s *                   * Check N Flag  bmi/bpl
00:000040D8 66FE            	  3046:             bne.s *                   * Check Z Flag  beq/bne
00:000040DA 10BC00F5        	  3047:             move.b #$F5,(a0)
00:000040DE 4A10            	  3048:             tst.b (a0)
00:000040E0 6AFE            	  3049:             bpl.s *                   * Check N Flag  bmi/bpl
00:000040E2 67FE            	  3050:             beq.s *                   * Check Z Flag  beq/bne
                            	  3051: 
                            	  3052: *     (An) - WORD
00:000040E4 4250            	  3053:             move.w #$0000,(a0)
00:000040E6 4A50            	  3054:             tst.w (a0)
00:000040E8 6BFE            	  3055:             bmi.s *                   * Check N Flag  bmi/bpl
00:000040EA 66FE            	  3056:             bne.s *                   * Check Z Flag  beq/bne
00:000040EC 30BCF567        	  3057:             move.w #$F567,(a0)
00:000040F0 4A50            	  3058:             tst.w (a0)
00:000040F2 6AFE            	  3059:             bpl.s *                   * Check N Flag  bmi/bpl
00:000040F4 67FE            	  3060:             beq.s *                   * Check Z Flag  beq/bne
                            	  3061: 
                            	  3062: *     (An) - LONG
00:000040F6 4290            	  3063:             move.l #$00000000,(a0)
00:000040F8 4A90            	  3064:             tst.l (a0)
00:000040FA 6BFE            	  3065:             bmi.s *                   * Check N Flag  bmi/bpl
00:000040FC 66FE            	  3066:             bne.s *                   * Check Z Flag  beq/bne
00:000040FE 20BCF56789AB    	  3067:             move.l #$F56789ab,(a0)
00:00004104 4A90            	  3068:             tst.l (a0)
00:00004106 6AFE            	  3069:             bpl.s *                   * Check N Flag  bmi/bpl
00:00004108 67FE            	  3070:             beq.s *                   * Check Z Flag  beq/bne
                            	  3071: 
                            	  3072: 
00:0000410A 4E75            	  3073:             rts
                            	  3074: 
                            	  3075: 
                            	  3076: *-----------------------------------------------------------
                            	  3077: *-----------------------------------------------------------
                            	  3078: * OPCODE : LINKS
                            	  3079: *-----------------------------------------------------------
                            	  3080: *-----------------------------------------------------------
                            	  3081: op_LINKS:
                            	  3082: 
00:0000410C 207C11223344    	  3083:             move.l #$11223344,a0
00:00004112 203C11223344    	  3084:             move.l #$11223344,d0
00:00004118 4E500000        	  3085:             link a0,#$0
00:0000411C 0C9711223344    	  3086:             cmpi.l #$11223344,(a7)
                            	  3087: 
00:00004122 4E58            	  3088:             unlk a0
00:00004124 B1C0            	  3089:             cmp.l d0,a0
00:00004126 66FE            	  3090:             bne.s *                   * branch if Z set
                            	  3091: 
00:00004128 4E75            	  3092:             rts
                            	  3093: 
                            	  3094: *-----------------------------------------------------------
                            	  3095: *-----------------------------------------------------------
                            	  3096: * OPCODE : MOVE_USP
                            	  3097: *-----------------------------------------------------------
                            	  3098: *-----------------------------------------------------------
                            	  3099: op_MOVE_USP:
                            	  3100: 
00:0000412A 207C11223344    	  3101:             move.l #$11223344,a0
00:00004130 4E60            	  3102:             move a0,USP
00:00004132 4E69            	  3103:             move USP,a1
00:00004134 B3C8            	  3104:             cmp.l a0,a1
00:00004136 66FE            	  3105:             bne.s *                   * branch if Z set
                            	  3106: 
00:00004138 4E75            	  3107:             rts
                            	  3108: 
                            	  3109: 
                            	  3110: *-----------------------------------------------------------
                            	  3111: *-----------------------------------------------------------
                            	  3112: * OPCODE : CHK
                            	  3113: *-----------------------------------------------------------
                            	  3114: *-----------------------------------------------------------
                            	  3115: 
                            	  3116: op_CHK:
                            	  3117: 
00:0000413A 20780018        	  3118: 	move.l 6*4,a0							; get check vector
00:0000413E 21FC000025BE0018	  3119: 	move.l #EXCEPTION_6,6*4		; set vector
00:00004146 303C1122        	  3120: 	move.w #$1122,d0
00:0000414A 323C1122        	  3121: 	move.w #$1122,d1
00:0000414E 4380            	  3122: 	chk d0,d1
                            	  3123: 
00:00004150 4E71            	  3124: 	nop
00:00004152 4E71            	  3125: 	nop
                            	  3126: 
00:00004154 323C1122        	  3127: 	move.w #$1122,d1
00:00004158 43BC1122        	  3128: 	chk #$1122,d1
                            	  3129: 
00:0000415C 323C1122        	  3130: 	move.w #$1122,d1
00:00004160 43BC007A        	  3131: 	chk #00122,d1
00:00004164 BCBCEEEE0006    	  3132: 	cmp.l #$EEEE0006,d6
00:0000416A 66FE            	  3133: 	bne.s *                   ; branch if Z set
                            	  3134: 
00:0000416C 303C1122        	  3135: 	move.w #$1122,d0
00:00004170 323C8000        	  3136: 	move.w #$8000,d1
00:00004174 4380            	  3137: 	chk d0,d1
00:00004176 BCBCEEEE0006    	  3138: 	cmp.l #$EEEE0006,d6
00:0000417C 66FE            	  3139: 	bne.s *                   ; branch if Z set
                            	  3140: 
00:0000417E 21C80018        	  3141: 	move.l a0,6*4							; restore old vector
00:00004182 4E75            	  3142: 	rts
                            	  3143: 
                            	  3144: 
                            	  3145: *-----------------------------------------------------------
                            	  3146: *-----------------------------------------------------------
                            	  3147: * OPCODE : NEGS
                            	  3148: *-----------------------------------------------------------
                            	  3149: *-----------------------------------------------------------
                            	  3150: op_NEGS:
                            	  3151: 
                            	  3152: *     NOT - BYTE
00:00004184 307C0100        	  3153:             move.l #$00000100,a0
00:00004188 7000            	  3154:             moveq  #$00000000,d0
00:0000418A 4600            	  3155:             not.b d0
00:0000418C 6AFE            	  3156:             bpl.s *                   * Check N Flag  bmi/bpl
00:0000418E 67FE            	  3157:             beq.s *                   * Check Z Flag  beq/bne
00:00004190 4600            	  3158:             not.b d0
00:00004192 6BFE            	  3159:             bmi.s *                   * Check N Flag  bmi/bpl
00:00004194 66FE            	  3160:             bne.s *                   * Check Z Flag  beq/bne
00:00004196 4A00            	  3161:             cmpi.b #$00,d0
00:00004198 66FE            	  3162:             bne.s *                   * Check Z Flag  beq/bne
00:0000419A 10BC0080        	  3163:             move.b #$80,(a0)
00:0000419E 4610            	  3164:             not.b (a0)
00:000041A0 6BFE            	  3165:             bmi.s *                   * Check N Flag  bmi/bpl
00:000041A2 67FE            	  3166:             beq.s *                   * Check Z Flag  beq/bne
00:000041A4 4610            	  3167:             not.b (a0)
00:000041A6 6AFE            	  3168:             bpl.s *                   * Check N Flag  bmi/bpl
00:000041A8 67FE            	  3169:             beq.s *                   * Check Z Flag  beq/bne
00:000041AA 0C100080        	  3170:             cmpi.b #$80,(a0)
00:000041AE 66FE            	  3171:             bne.s *                   * Check Z Flag  beq/bne
                            	  3172: 
                            	  3173: *     NOT - WORD
00:000041B0 307C0100        	  3174:             move.l #$00000100,a0
00:000041B4 7000            	  3175:             moveq  #$00000000,d0
00:000041B6 4640            	  3176:             not.w d0
00:000041B8 6AFE            	  3177:             bpl.s *                   * Check N Flag  bmi/bpl
00:000041BA 67FE            	  3178:             beq.s *                   * Check Z Flag  beq/bne
00:000041BC 4640            	  3179:             not.w d0
00:000041BE 6BFE            	  3180:             bmi.s *                   * Check N Flag  bmi/bpl
00:000041C0 66FE            	  3181:             bne.s *                   * Check Z Flag  beq/bne
00:000041C2 4A40            	  3182:             cmpi.w #$0000,d0
00:000041C4 66FE            	  3183:             bne.s *                   * Check Z Flag  beq/bne
00:000041C6 30BC5A5A        	  3184:             move.w #$5a5a,(a0)
00:000041CA 4650            	  3185:             not.w (a0)
00:000041CC 6AFE            	  3186:             bpl.s *                   * Check N Flag  bmi/bpl
00:000041CE 67FE            	  3187:             beq.s *                   * Check Z Flag  beq/bne
00:000041D0 4650            	  3188:             not.w (a0)
00:000041D2 6BFE            	  3189:             bmi.s *                   * Check N Flag  bmi/bpl
00:000041D4 67FE            	  3190:             beq.s *                   * Check Z Flag  beq/bne
00:000041D6 0C505A5A        	  3191:             cmpi.w #$5a5a,(a0)
00:000041DA 66FE            	  3192:             bne.s *                   * Check Z Flag  beq/bne
                            	  3193: 
                            	  3194: *     NOT - LONG
00:000041DC 307C0100        	  3195:             move.l #$00000100,a0
00:000041E0 7000            	  3196:             moveq  #$00000000,d0
00:000041E2 4680            	  3197:             not.l d0
00:000041E4 6AFE            	  3198:             bpl.s *                   * Check N Flag  bmi/bpl
00:000041E6 67FE            	  3199:             beq.s *                   * Check Z Flag  beq/bne
00:000041E8 4680            	  3200:             not.l d0
00:000041EA 6BFE            	  3201:             bmi.s *                   * Check N Flag  bmi/bpl
00:000041EC 66FE            	  3202:             bne.s *                   * Check Z Flag  beq/bne
00:000041EE 4A80            	  3203:             cmpi.l #$00000000,d0
00:000041F0 66FE            	  3204:             bne.s *                   * Check Z Flag  beq/bne
00:000041F2 20BC5A5A1234    	  3205:             move.l #$5a5a1234,(a0)
00:000041F8 4690            	  3206:             not.l (a0)
00:000041FA 6AFE            	  3207:             bpl.s *                   * Check N Flag  bmi/bpl
00:000041FC 67FE            	  3208:             beq.s *                   * Check Z Flag  beq/bne
00:000041FE 4690            	  3209:             not.l (a0)
00:00004200 6BFE            	  3210:             bmi.s *                   * Check N Flag  bmi/bpl
00:00004202 67FE            	  3211:             beq.s *                   * Check Z Flag  beq/bne
00:00004204 0C905A5A1234    	  3212:             cmpi.l #$5a5a1234,(a0)
00:0000420A 66FE            	  3213:             bne.s *                   * Check Z Flag  beq/bne
                            	  3214: 
                            	  3215: * -----
                            	  3216: 
                            	  3217: *     NEG - BYTE
00:0000420C 307C0100        	  3218:             move.l #$00000100,a0
00:00004210 7000            	  3219:             moveq  #$00000000,d0
00:00004212 7240D241        	  3220:             move.l #$00000080,d1
00:00004216 4400            	  3221:             neg.b d0
00:00004218 6BFE            	  3222:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:0000421A 66FE            	  3223:             bne.s *                   * Check Z Flag  beq/bne 1
00:0000421C 65FE            	  3224:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:0000421E 69FE            	  3225:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004220 4401            	  3226:             neg.b d1
00:00004222 6AFE            	  3227:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004224 67FE            	  3228:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004226 64FE            	  3229:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004228 68FE            	  3230:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:0000422A 0C010080        	  3231:             cmpi.b #$80,d1
00:0000422E 66FE            	  3232:             bne.s *                   * Check Z Flag  beq/bne
00:00004230 10BC007F        	  3233:             move.b #$7F,(a0)
00:00004234 4410            	  3234:             neg.b (a0)
00:00004236 6AFE            	  3235:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004238 67FE            	  3236:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000423A 64FE            	  3237:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000423C 69FE            	  3238:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000423E 10BC00F5        	  3239:             move.b #$F5,(a0)
00:00004242 4410            	  3240:             neg.b (a0)
00:00004244 6BFE            	  3241:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004246 67FE            	  3242:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004248 64FE            	  3243:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000424A 69FE            	  3244:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000424C 0C10000B        	  3245:             cmpi.b #$0B,(a0)
00:00004250 66FE            	  3246:             bne.s *                   * Check Z Flag  beq/bne
                            	  3247: 
                            	  3248: * -----
                            	  3249: 
                            	  3250: *     NEG - WORD
00:00004252 307C0100        	  3251:             move.l #$00000100,a0
00:00004256 7000            	  3252:             moveq  #$00000000,d0
00:00004258 223C00008000    	  3253:             move.l #$00008000,d1
00:0000425E 4440            	  3254:             neg.w d0
00:00004260 6BFE            	  3255:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004262 66FE            	  3256:             bne.s *                   * Check Z Flag  beq/bne 1
00:00004264 65FE            	  3257:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:00004266 69FE            	  3258:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004268 4441            	  3259:             neg.w d1
00:0000426A 6AFE            	  3260:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:0000426C 67FE            	  3261:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000426E 64FE            	  3262:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004270 68FE            	  3263:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:00004272 0C418000        	  3264:             cmpi.w #$8000,d1
00:00004276 66FE            	  3265:             bne.s *                   * Check Z Flag  beq/bne
00:00004278 30BC7FFF        	  3266:             move.w #$7FFF,(a0)
00:0000427C 4450            	  3267:             neg.w (a0)
00:0000427E 6AFE            	  3268:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004280 67FE            	  3269:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004282 64FE            	  3270:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004284 69FE            	  3271:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004286 30BCF578        	  3272:             move.w #$F578,(a0)
00:0000428A 4450            	  3273:             neg.w (a0)
00:0000428C 6BFE            	  3274:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:0000428E 67FE            	  3275:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004290 64FE            	  3276:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004292 69FE            	  3277:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004294 0C500A88        	  3278:             cmpi.w #$0A88,(a0)
00:00004298 66FE            	  3279:             bne.s *                   * Check Z Flag  beq/bne
                            	  3280: 
                            	  3281: * -----
                            	  3282: 
                            	  3283: *     NEG - LONG
00:0000429A 307C0100        	  3284:             move.l #$00000100,a0
00:0000429E 7000            	  3285:             moveq  #$00000000,d0
00:000042A0 223C80000000    	  3286:             move.l #$80000000,d1
00:000042A6 4480            	  3287:             neg.l d0
00:000042A8 6BFE            	  3288:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000042AA 66FE            	  3289:             bne.s *                   * Check Z Flag  beq/bne 1
00:000042AC 65FE            	  3290:             bcs.s *                   * Check C Flag  bcc/bcs 1
00:000042AE 69FE            	  3291:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000042B0 4481            	  3292:             neg.l d1
00:000042B2 6AFE            	  3293:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000042B4 67FE            	  3294:             beq.s *                   * Check Z Flag  beq/bne 0
00:000042B6 64FE            	  3295:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000042B8 68FE            	  3296:             bvc.s *                   * Check V Flag  bvc/bvs 0
00:000042BA 0C8180000000    	  3297:             cmpi.l #$80000000,d1
00:000042C0 66FE            	  3298:             bne.s *                   * Check Z Flag  beq/bne
00:000042C2 20BC7FFFFFFF    	  3299:             move.l #$7FFFFFFF,(a0)
00:000042C8 4490            	  3300:             neg.l (a0)
00:000042CA 6AFE            	  3301:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000042CC 67FE            	  3302:             beq.s *                   * Check Z Flag  beq/bne 0
00:000042CE 64FE            	  3303:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000042D0 69FE            	  3304:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000042D2 20BCF5781234    	  3305:             move.l #$F5781234,(a0)
00:000042D8 4490            	  3306:             neg.l (a0)
00:000042DA 6BFE            	  3307:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000042DC 67FE            	  3308:             beq.s *                   * Check Z Flag  beq/bne 0
00:000042DE 64FE            	  3309:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000042E0 69FE            	  3310:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000042E2 0C900A87EDCC    	  3311:             cmpi.l #$0A87EDCC,(a0)
00:000042E8 66FE            	  3312:             bne.s *                   * Check Z Flag  beq/bne
                            	  3313: 
                            	  3314: 
                            	  3315: * -----
                            	  3316: 
                            	  3317: *     NEGX - BYTE
00:000042EA 307C0100        	  3318:             move.l #$00000100,a0
00:000042EE 7000            	  3319:             moveq  #$00000000,d0
00:000042F0 7240D241        	  3320:             move.l #$00000080,d1
00:000042F4 003C0010        	  3321:             ori.b #$10,CCR        * Set X Flag
00:000042F8 4000            	  3322:             negx.b d0
00:000042FA 6AFE            	  3323:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:000042FC 67FE            	  3324:             beq.s *                   * Check Z Flag  beq/bne 1
00:000042FE 64FE            	  3325:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:00004300 69FE            	  3326:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004302 023C00EF        	  3327:             andi.b #$EF,CCR       * Clear X Flag
00:00004306 4000            	  3328:             negx.b d0
00:00004308 6BFE            	  3329:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:0000430A 67FE            	  3330:             beq.s *                   * Check Z Flag  beq/bne 1
00:0000430C 64FE            	  3331:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:0000430E 69FE            	  3332:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004310 003C0010        	  3333:             ori.b #$10,CCR        * Set X Flag
00:00004314 4001            	  3334:             negx.b d1
00:00004316 6BFE            	  3335:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:00004318 67FE            	  3336:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000431A 64FE            	  3337:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000431C 69FE            	  3338:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:0000431E 0C01007F        	  3339:             cmpi.b #$7F,d1
00:00004322 66FE            	  3340:             bne.s *                   * Check Z Flag  beq/bne
00:00004324 023C00EF        	  3341:             andi.b #$EF,CCR       * Clear X Flag
00:00004328 4001            	  3342:             negx.b d1
00:0000432A 6AFE            	  3343:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:0000432C 67FE            	  3344:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000432E 64FE            	  3345:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004330 69FE            	  3346:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:00004332 0C010081        	  3347:             cmpi.b #$81,d1
00:00004336 66FE            	  3348:             bne.s *                   * Check Z Flag  beq/bne
00:00004338 10BC007F        	  3349:             move.b #$7F,(a0)
00:0000433C 003C0010        	  3350:             ori.b #$10,CCR        * Set X Flag
00:00004340 4010            	  3351:             negx.b (a0)
00:00004342 6AFE            	  3352:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004344 67FE            	  3353:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004346 64FE            	  3354:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3355:             * I think overflow should happen here.
                            	  3356: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004348 10BC007F        	  3357:             move.b #$7F,(a0)
00:0000434C 023C00EF        	  3358:             andi.b #$EF,CCR       * Clear X Flag
00:00004350 4010            	  3359:             negx.b (a0)
00:00004352 6AFE            	  3360:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004354 67FE            	  3361:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004356 64FE            	  3362:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004358 69FE            	  3363:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000435A 10BC00F5        	  3364:             move.b #$F5,(a0)
00:0000435E 003C0010        	  3365:             ori.b #$10,CCR        * Set X Flag
00:00004362 4010            	  3366:             negx.b (a0)
00:00004364 6BFE            	  3367:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004366 67FE            	  3368:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004368 64FE            	  3369:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000436A 69FE            	  3370:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000436C 0C10000A        	  3371:             cmpi.b #$0A,(a0)
00:00004370 66FE            	  3372:             bne.s *                   * Check Z Flag  beq/bne
00:00004372 023C00EF        	  3373:             andi.b #$EF,CCR       * Clear X Flag
00:00004376 4010            	  3374:             negx.b (a0)
00:00004378 6AFE            	  3375:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:0000437A 67FE            	  3376:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000437C 64FE            	  3377:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000437E 69FE            	  3378:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004380 0C1000F6        	  3379:             cmpi.b #$F6,(a0)
00:00004384 66FE            	  3380:             bne.s *                   * Check Z Flag  beq/bne
                            	  3381: 
                            	  3382: 
                            	  3383: 
                            	  3384: * -----
                            	  3385: 
                            	  3386: *     NEGX - WORD
00:00004386 307C0100        	  3387:             move.l #$00000100,a0
00:0000438A 7000            	  3388:             moveq  #$00000000,d0
00:0000438C 223C00008000    	  3389:             move.l #$00008000,d1
00:00004392 003C0010        	  3390:             ori.b #$10,CCR        * Set X Flag
00:00004396 4040            	  3391:             negx.w d0
00:00004398 6AFE            	  3392:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:0000439A 67FE            	  3393:             beq.s *                   * Check Z Flag  beq/bne 1
00:0000439C 64FE            	  3394:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:0000439E 69FE            	  3395:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000043A0 023C00EF        	  3396:             andi.b #$EF,CCR       * Clear X Flag
00:000043A4 4040            	  3397:             negx.w d0
00:000043A6 6BFE            	  3398:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000043A8 67FE            	  3399:             beq.s *                   * Check Z Flag  beq/bne 1
00:000043AA 64FE            	  3400:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:000043AC 69FE            	  3401:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000043AE 003C0010        	  3402:             ori.b #$10,CCR        * Set X Flag
00:000043B2 4041            	  3403:             negx.w d1
00:000043B4 6BFE            	  3404:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:000043B6 67FE            	  3405:             beq.s *                   * Check Z Flag  beq/bne 0
00:000043B8 64FE            	  3406:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000043BA 69FE            	  3407:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:000043BC 0C417FFF        	  3408:             cmpi.w #$7FFF,d1
00:000043C0 66FE            	  3409:             bne.s *                   * Check Z Flag  beq/bne
00:000043C2 023C00EF        	  3410:             andi.b #$EF,CCR       * Clear X Flag
00:000043C6 4041            	  3411:             negx.w d1
00:000043C8 6AFE            	  3412:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000043CA 67FE            	  3413:             beq.s *                   * Check Z Flag  beq/bne 0
00:000043CC 64FE            	  3414:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000043CE 69FE            	  3415:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:000043D0 0C418001        	  3416:             cmpi.w #$8001,d1
00:000043D4 66FE            	  3417:             bne.s *                   * Check Z Flag  beq/bne
00:000043D6 30BC7FFF        	  3418:             move.w #$7FFF,(a0)
00:000043DA 003C0010        	  3419:             ori.b #$10,CCR        * Set X Flag
00:000043DE 4050            	  3420:             negx.w (a0)
00:000043E0 6AFE            	  3421:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:000043E2 67FE            	  3422:             beq.s *                   * Check Z Flag  beq/bne 0
00:000043E4 64FE            	  3423:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3424: ***            
                            	  3425: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:000043E6 30BCF567        	  3426:             move.w #$F567,(a0)
00:000043EA 023C00EF        	  3427:             andi.b #$EF,CCR       * Clear X Flag
00:000043EE 4050            	  3428:             negx.w (a0)
00:000043F0 6BFE            	  3429:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:000043F2 67FE            	  3430:             beq.s *                   * Check Z Flag  beq/bne 0
00:000043F4 64FE            	  3431:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000043F6 69FE            	  3432:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000043F8 30BCF567        	  3433:             move.w #$F567,(a0)
00:000043FC 003C0010        	  3434:             ori.b #$10,CCR        * Set X Flag
00:00004400 4050            	  3435:             negx.w (a0)
00:00004402 6BFE            	  3436:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004404 67FE            	  3437:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004406 64FE            	  3438:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004408 69FE            	  3439:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000440A 0C500A98        	  3440:             cmpi.w #$0A98,(a0)
00:0000440E 66FE            	  3441:             bne.s *                   * Check Z Flag  beq/bne
00:00004410 023C00EF        	  3442:             andi.b #$EF,CCR       * Clear X Flag
00:00004414 4050            	  3443:             negx.w (a0)
00:00004416 6AFE            	  3444:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:00004418 67FE            	  3445:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000441A 64FE            	  3446:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000441C 69FE            	  3447:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000441E 0C50F568        	  3448:             cmpi.w #$F568,(a0)
00:00004422 66FE            	  3449:             bne.s *                   * Check Z Flag  beq/bne
                            	  3450: 
                            	  3451: 
                            	  3452: * -----
                            	  3453: 
                            	  3454: *     NEGX - LONG
00:00004424 307C0100        	  3455:             move.l #$00000100,a0
00:00004428 7000            	  3456:             moveq  #$00000000,d0
00:0000442A 223C80000000    	  3457:             move.l #$80000000,d1
00:00004430 003C0010        	  3458:             ori.b #$10,CCR        * Set X Flag
00:00004434 4080            	  3459:             negx.l d0
00:00004436 6AFE            	  3460:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:00004438 67FE            	  3461:             beq.s *                   * Check Z Flag  beq/bne 1
00:0000443A 64FE            	  3462:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:0000443C 69FE            	  3463:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000443E 023C00EF        	  3464:             andi.b #$EF,CCR       * Clear X Flag
00:00004442 4080            	  3465:             negx.l d0
00:00004444 6BFE            	  3466:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004446 67FE            	  3467:             beq.s *                   * Check Z Flag  beq/bne 1
00:00004448 64FE            	  3468:             bcc.s *                   * Check C Flag  bcc/bcs 1
00:0000444A 69FE            	  3469:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000444C 003C0010        	  3470:             ori.b #$10,CCR        * Set X Flag
00:00004450 4081            	  3471:             negx.l d1
00:00004452 6BFE            	  3472:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:00004454 67FE            	  3473:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004456 64FE            	  3474:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:00004458 69FE            	  3475:             bvs.s *                   * Check V Flag  bvc/bvs 0
00:0000445A 0C817FFFFFFF    	  3476:             cmpi.l #$7FFFFFFF,d1
00:00004460 66FE            	  3477:             bne.s *                   * Check Z Flag  beq/bne
00:00004462 023C00EF        	  3478:             andi.b #$EF,CCR       * Clear X Flag
00:00004466 4081            	  3479:             negx.l d1
00:00004468 6AFE            	  3480:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:0000446A 67FE            	  3481:             beq.s *                   * Check Z Flag  beq/bne 0
00:0000446C 64FE            	  3482:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3483: ****            
                            	  3484: *            bvs.s *                   * Check V Flag  bvc/bvs 0
00:0000446E 0C8180000001    	  3485:             cmpi.l #$80000001,d1
00:00004474 66FE            	  3486:             bne.s *                   * Check Z Flag  beq/bne
00:00004476 20BC00007FFF    	  3487:             move.l #$7FFF,(a0)
00:0000447C 003C0010        	  3488:             ori.b #$10,CCR        * Set X Flag
00:00004480 4090            	  3489:             negx.l (a0)
00:00004482 6AFE            	  3490:             bpl.s *                   * Check N Flag  bmi/bpl 1
00:00004484 67FE            	  3491:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004486 64FE            	  3492:             bcc.s *                   * Check C Flag  bcc/bcs 0
                            	  3493: ****            
                            	  3494: *            bvs.s *                   * Check V Flag  bvc/bvs 1
00:00004488 20BCF5671234    	  3495:             move.l #$F5671234,(a0)
00:0000448E 023C00EF        	  3496:             andi.b #$EF,CCR       * Clear X Flag
00:00004492 4090            	  3497:             negx.l (a0)
00:00004494 6BFE            	  3498:             bmi.s *                   * Check N Flag  bmi/bpl 1
00:00004496 67FE            	  3499:             beq.s *                   * Check Z Flag  beq/bne 0
00:00004498 64FE            	  3500:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:0000449A 69FE            	  3501:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:0000449C 20BCF5675678    	  3502:             move.l #$F5675678,(a0)
00:000044A2 003C0010        	  3503:             ori.b #$10,CCR        * Set X Flag
00:000044A6 4090            	  3504:             negx.l (a0)
00:000044A8 6BFE            	  3505:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000044AA 67FE            	  3506:             beq.s *                   * Check Z Flag  beq/bne 0
00:000044AC 64FE            	  3507:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000044AE 69FE            	  3508:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000044B0 0C900A98A987    	  3509:             cmpi.l #$0A98A987,(a0)
00:000044B6 66FE            	  3510:             bne.s *                   * Check Z Flag  beq/bne
00:000044B8 023C00EF        	  3511:             andi.b #$EF,CCR       * Clear X Flag
00:000044BC 4090            	  3512:             negx.l (a0)
00:000044BE 6AFE            	  3513:             bpl.s *                   * Check N Flag  bmi/bpl 0
00:000044C0 67FE            	  3514:             beq.s *                   * Check Z Flag  beq/bne 0
00:000044C2 64FE            	  3515:             bcc.s *                   * Check C Flag  bcc/bcs 0
00:000044C4 69FE            	  3516:             bvs.s *                   * Check V Flag  bvc/bvs 1
00:000044C6 0C90F5675679    	  3517:             cmpi.l #$F5675679,(a0)
00:000044CC 66FE            	  3518:             bne.s *                   * Check Z Flag  beq/bne
                            	  3519: 
                            	  3520: 
                            	  3521: * -----
                            	  3522: 
                            	  3523: *     CLR - BYTE
00:000044CE 307C0100        	  3524:             move.l #$00000100,a0
00:000044D2 203C12345678    	  3525:             move.l #$12345678,d0
00:000044D8 223C12345678    	  3526:             move.l #$12345678,d1
00:000044DE 243C12345678    	  3527:             move.l #$12345678,d2
00:000044E4 283C12345600    	  3528:             move.l #$12345600,d4
00:000044EA 2A3C12340000    	  3529:             move.l #$12340000,d5
00:000044F0 7C00            	  3530:             moveq  #$00000000,d6
                            	  3531: 
00:000044F2 4200            	  3532:             clr.b d0
00:000044F4 66FE            	  3533:             bne.s *                   * Check Z Flag  beq/bne 0
00:000044F6 6BFE            	  3534:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:000044F8 B880            	  3535:             cmp.l d0,d4
00:000044FA 66FE            	  3536:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3537: 
00:000044FC 4241            	  3538:             clr.w d1
00:000044FE 66FE            	  3539:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004500 6BFE            	  3540:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:00004502 BA81            	  3541:             cmp.l d1,d5
00:00004504 66FE            	  3542:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3543: 
00:00004506 7400            	  3544:             clr.l d2
00:00004508 66FE            	  3545:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000450A 6BFE            	  3546:             bmi.s *                   * Check N Flag  bmi/bpl 0
00:0000450C BC82            	  3547:             cmp.l d2,d6
00:0000450E 66FE            	  3548:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3549: 
00:00004510 4E75            	  3550:             rts
                            	  3551: 
                            	  3552: 
                            	  3553: 
                            	  3554: *-----------------------------------------------------------
                            	  3555: *-----------------------------------------------------------
                            	  3556: * OPCODE : MOVEM
                            	  3557: *-----------------------------------------------------------
                            	  3558: *-----------------------------------------------------------
                            	  3559: op_MOVEM:
                            	  3560: 
                            	  3561: *     WORD  Registers --> Memory
00:00004512 203C0000D0D0    	  3562:             move.l #$0000d0d0,d0
00:00004518 223C0000D1D1    	  3563:             move.l #$0000d1d1,d1
00:0000451E 243C0000D2D2    	  3564:             move.l #$0000d2d2,d2
00:00004524 263C0000D3D3    	  3565:             move.l #$0000d3d3,d3
00:0000452A 283C0000D4D4    	  3566:             move.l #$0000d4d4,d4
00:00004530 2A3C0000D5D5    	  3567:             move.l #$0000d5d5,d5
00:00004536 2C3C0000D6D6    	  3568:             move.l #$0000d6d6,d6
00:0000453C 2E3C0000D7D7    	  3569:             move.l #$0000d7d7,d7
00:00004542 307C0A0A        	  3570:             move.l #$00000a0a,a0
00:00004546 327C1A1A        	  3571:             move.l #$00001a1a,a1
00:0000454A 347C2A2A        	  3572:             move.l #$00002a2a,a2
00:0000454E 367C3A3A        	  3573:             move.l #$00003a3a,a3
00:00004552 387C4A4A        	  3574:             move.l #$00004a4a,a4
00:00004556 3A7C5A5A        	  3575:             move.l #$00005a5a,a5
00:0000455A 3C7C6A6A        	  3576:             move.l #$00006a6a,a6
                            	  3577: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3578: 
00:0000455E 48B8FFFF0100    	  3579:             movem.w D0-D7/A0-A7,$00000100
                            	  3580: 
00:00004564 307C0100        	  3581:             move.l #$00000100,a0
                            	  3582: 
00:00004568 B058            	  3583:             cmp.w (a0)+,d0
00:0000456A 66FE            	  3584:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000456C B258            	  3585:             cmp.w (a0)+,d1
00:0000456E 66FE            	  3586:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004570 B458            	  3587:             cmp.w (a0)+,d2
00:00004572 66FE            	  3588:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004574 B658            	  3589:             cmp.w (a0)+,d3
00:00004576 66FE            	  3590:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004578 B858            	  3591:             cmp.w (a0)+,d4
00:0000457A 66FE            	  3592:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000457C BA58            	  3593:             cmp.w (a0)+,d5
00:0000457E 66FE            	  3594:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004580 BC58            	  3595:             cmp.w (a0)+,d6
00:00004582 66FE            	  3596:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004584 BE58            	  3597:             cmp.w (a0)+,d7
00:00004586 66FE            	  3598:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3599: 
00:00004588 0C580A0A        	  3600:             cmpi.w #$0A0A,(a0)+    * Because we are using a0 as a pointer
00:0000458C 66FE            	  3601:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3602: 
00:0000458E B2D8            	  3603:             cmp.w (a0)+,a1
00:00004590 66FE            	  3604:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004592 B4D8            	  3605:             cmp.w (a0)+,a2
00:00004594 66FE            	  3606:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004596 B6D8            	  3607:             cmp.w (a0)+,a3
00:00004598 66FE            	  3608:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000459A B8D8            	  3609:             cmp.w (a0)+,a4
00:0000459C 66FE            	  3610:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000459E BAD8            	  3611:             cmp.w (a0)+,a5
00:000045A0 66FE            	  3612:             bne.s *                   * Check Z Flag  beq/bne 0
00:000045A2 BCD8            	  3613:             cmp.w (a0)+,a6
00:000045A4 66FE            	  3614:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3615: 
                            	  3616: 
                            	  3617: 
                            	  3618: 
                            	  3619: *     LONG  Registers --> Memory
00:000045A6 203CD0D0D0D0    	  3620:             move.l #$d0d0d0d0,d0
00:000045AC 223CD1D1D1D1    	  3621:             move.l #$d1d1d1d1,d1
00:000045B2 243CD2D2D2D2    	  3622:             move.l #$d2d2d2d2,d2
00:000045B8 263CD3D3D3D3    	  3623:             move.l #$d3d3d3d3,d3
00:000045BE 283CD4D4D4D4    	  3624:             move.l #$d4d4d4d4,d4
00:000045C4 2A3CD5D5D5D5    	  3625:             move.l #$d5d5d5d5,d5
00:000045CA 2C3CD6D6D6D6    	  3626:             move.l #$d6d6d6d6,d6
00:000045D0 2E3CD7D7D7D7    	  3627:             move.l #$d7d7d7d7,d7
00:000045D6 207C0A0A0A0A    	  3628:             move.l #$0a0a0a0a,a0
00:000045DC 227C1A1A1A1A    	  3629:             move.l #$1a1a1a1a,a1
00:000045E2 247C2A2A2A2A    	  3630:             move.l #$2a2a2a2a,a2
00:000045E8 267C3A3A3A3A    	  3631:             move.l #$3a3a3a3a,a3
00:000045EE 287C4A4A4A4A    	  3632:             move.l #$4a4a4a4a,a4
00:000045F4 2A7C5A5A5A5A    	  3633:             move.l #$5a5a5a5a,a5
00:000045FA 2C7C6A6A6A6A    	  3634:             move.l #$6a6a6a6a,a6
                            	  3635: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3636: 
                            	  3637: 
00:00004600 48F8FFFF0120    	  3638:             movem.l D0-D7/A0-A7,$00000120
                            	  3639: 
00:00004606 307C0120        	  3640:             move.l #$00000120,a0
                            	  3641: 
00:0000460A B098            	  3642:             cmp.l (a0)+,d0
00:0000460C 66FE            	  3643:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000460E B298            	  3644:             cmp.l (a0)+,d1
00:00004610 66FE            	  3645:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004612 B498            	  3646:             cmp.l (a0)+,d2
00:00004614 66FE            	  3647:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004616 B698            	  3648:             cmp.l (a0)+,d3
00:00004618 66FE            	  3649:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000461A B898            	  3650:             cmp.l (a0)+,d4
00:0000461C 66FE            	  3651:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000461E BA98            	  3652:             cmp.l (a0)+,d5
00:00004620 66FE            	  3653:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004622 BC98            	  3654:             cmp.l (a0)+,d6
00:00004624 66FE            	  3655:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004626 BE98            	  3656:             cmp.l (a0)+,d7
00:00004628 66FE            	  3657:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3658: 
00:0000462A 0C980A0A0A0A    	  3659:             cmpi.l #$0A0A0A0A,(a0)+    * Because we are using a0 as a pointer
00:00004630 66FE            	  3660:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3661: 
00:00004632 B3D8            	  3662:             cmp.l (a0)+,a1
00:00004634 66FE            	  3663:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004636 B5D8            	  3664:             cmp.l (a0)+,a2
00:00004638 66FE            	  3665:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000463A B7D8            	  3666:             cmp.l (a0)+,a3
00:0000463C 66FE            	  3667:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000463E B9D8            	  3668:             cmp.l (a0)+,a4
00:00004640 66FE            	  3669:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004642 BBD8            	  3670:             cmp.l (a0)+,a5
00:00004644 66FE            	  3671:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004646 BDD8            	  3672:             cmp.l (a0)+,a6
00:00004648 66FE            	  3673:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3674: *      ----
                            	  3675: 
                            	  3676: 
                            	  3677: *     WORD  Registers --> Memory  -(An) EA Mode
00:0000464A 203C0000D0D0    	  3678:             move.l #$0000d0d0,d0
00:00004650 223C0000D1D1    	  3679:             move.l #$0000d1d1,d1
00:00004656 243C0000D2D2    	  3680:             move.l #$0000d2d2,d2
00:0000465C 263C0000D3D3    	  3681:             move.l #$0000d3d3,d3
00:00004662 283C0000D4D4    	  3682:             move.l #$0000d4d4,d4
00:00004668 2A3C0000D5D5    	  3683:             move.l #$0000d5d5,d5
00:0000466E 2C3C0000D6D6    	  3684:             move.l #$0000d6d6,d6
00:00004674 2E3C0000D7D7    	  3685:             move.l #$0000d7d7,d7
00:0000467A 307C0A0A        	  3686:             move.l #$00000a0a,a0
00:0000467E 327C1A1A        	  3687:             move.l #$00001a1a,a1
00:00004682 347C2A2A        	  3688:             move.l #$00002a2a,a2
00:00004686 367C3A3A        	  3689:             move.l #$00003a3a,a3
00:0000468A 387C4A4A        	  3690:             move.l #$00004a4a,a4
00:0000468E 3A7C5A5A        	  3691:             move.l #$00005a5a,a5
00:00004692 3C7C6A6A        	  3692:             move.l #$00006a6a,a6
                            	  3693: *           move.l #$00007a7a,a7  * Dont change the Stack Pointer
                            	  3694: 
00:00004696 307C01A0        	  3695:             move.l #$000001A0,a0
00:0000469A 48A0FFFF        	  3696:             movem.w D0-D7/A0-A7,-(a0)
                            	  3697: 
00:0000469E 307C019E        	  3698:             move.l #$0000019E,a0
                            	  3699: 
00:000046A2 BCE0            	  3700:             cmp.w -(a0),a6
00:000046A4 66FE            	  3701:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046A6 BAE0            	  3702:             cmp.w -(a0),a5
00:000046A8 66FE            	  3703:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046AA B8E0            	  3704:             cmp.w -(a0),a4
00:000046AC 66FE            	  3705:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046AE B6E0            	  3706:             cmp.w -(a0),a3
00:000046B0 66FE            	  3707:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046B2 B4E0            	  3708:             cmp.w -(a0),a2
00:000046B4 66FE            	  3709:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046B6 B2E0            	  3710:             cmp.w -(a0),a1
00:000046B8 66FE            	  3711:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046BA B0E0            	  3712:             cmp.w -(a0),a0
                            	  3713: *            bne.s *                   * Check Z Flag  beq/bne 0
00:000046BC BE60            	  3714:             cmp.w -(a0),d7
00:000046BE 66FE            	  3715:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046C0 BC60            	  3716:             cmp.w -(a0),d6
00:000046C2 66FE            	  3717:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046C4 BA60            	  3718:             cmp.w -(a0),d5
00:000046C6 66FE            	  3719:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046C8 B860            	  3720:             cmp.w -(a0),d4
00:000046CA 66FE            	  3721:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046CC B660            	  3722:             cmp.w -(a0),d3
00:000046CE 66FE            	  3723:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046D0 B460            	  3724:             cmp.w -(a0),d2
00:000046D2 66FE            	  3725:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046D4 B260            	  3726:             cmp.w -(a0),d1
00:000046D6 66FE            	  3727:             bne.s *                   * Check Z Flag  beq/bne 0
00:000046D8 B060            	  3728:             cmp.w -(a0),d0
00:000046DA 66FE            	  3729:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3730: 
                            	  3731: 
                            	  3732: 
                            	  3733: 
                            	  3734: *     LONG  Registers --> Memory   -(An) EA Mode
00:000046DC 203CD0D0D0D0    	  3735:             move.l #$d0d0d0d0,d0
00:000046E2 223CD1D1D1D1    	  3736:             move.l #$d1d1d1d1,d1
00:000046E8 243CD2D2D2D2    	  3737:             move.l #$d2d2d2d2,d2
00:000046EE 263CD3D3D3D3    	  3738:             move.l #$d3d3d3d3,d3
00:000046F4 283CD4D4D4D4    	  3739:             move.l #$d4d4d4d4,d4
00:000046FA 2A3CD5D5D5D5    	  3740:             move.l #$d5d5d5d5,d5
00:00004700 2C3CD6D6D6D6    	  3741:             move.l #$d6d6d6d6,d6
00:00004706 2E3CD7D7D7D7    	  3742:             move.l #$d7d7d7d7,d7
00:0000470C 207C0A0A0A0A    	  3743:             move.l #$0a0a0a0a,a0
00:00004712 227C1A1A1A1A    	  3744:             move.l #$1a1a1a1a,a1
00:00004718 247C2A2A2A2A    	  3745:             move.l #$2a2a2a2a,a2
00:0000471E 267C3A3A3A3A    	  3746:             move.l #$3a3a3a3a,a3
00:00004724 287C4A4A4A4A    	  3747:             move.l #$4a4a4a4a,a4
00:0000472A 2A7C5A5A5A5A    	  3748:             move.l #$5a5a5a5a,a5
00:00004730 2C7C6A6A6A6A    	  3749:             move.l #$6a6a6a6a,a6
                            	  3750: *           move.l #$7a7a7a7a,a7  * Dont change the Stack Pointer
                            	  3751: 
                            	  3752: 
00:00004736 307C01A0        	  3753:             move.l #$000001A0,a0
00:0000473A 48E0FFFF        	  3754:             movem.l D0-D7/A0-A7,-(a0)
                            	  3755: 
00:0000473E 307C019C        	  3756:             move.l #$0000019C,a0
                            	  3757: 
00:00004742 BDE0            	  3758:             cmp.l -(a0),a6
00:00004744 66FE            	  3759:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004746 BBE0            	  3760:             cmp.l -(a0),a5
00:00004748 66FE            	  3761:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000474A B9E0            	  3762:             cmp.l -(a0),a4
00:0000474C 66FE            	  3763:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000474E B7E0            	  3764:             cmp.l -(a0),a3
00:00004750 66FE            	  3765:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004752 B5E0            	  3766:             cmp.l -(a0),a2
00:00004754 66FE            	  3767:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004756 B3E0            	  3768:             cmp.l -(a0),a1
00:00004758 66FE            	  3769:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000475A B1E0            	  3770:             cmp.l -(a0),a0
                            	  3771: *            bne.s *                   * Check Z Flag  beq/bne 0
00:0000475C BEA0            	  3772:             cmp.l -(a0),d7
00:0000475E 66FE            	  3773:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004760 BCA0            	  3774:             cmp.l -(a0),d6
00:00004762 66FE            	  3775:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004764 BAA0            	  3776:             cmp.l -(a0),d5
00:00004766 66FE            	  3777:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004768 B8A0            	  3778:             cmp.l -(a0),d4
00:0000476A 66FE            	  3779:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000476C B6A0            	  3780:             cmp.l -(a0),d3
00:0000476E 66FE            	  3781:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004770 B4A0            	  3782:             cmp.l -(a0),d2
00:00004772 66FE            	  3783:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004774 B2A0            	  3784:             cmp.l -(a0),d1
00:00004776 66FE            	  3785:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004778 B0A0            	  3786:             cmp.l -(a0),d0
00:0000477A 66FE            	  3787:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3788: 
                            	  3789: 
                            	  3790: 
                            	  3791: *     ----
                            	  3792: 
                            	  3793: *     WORD - Memory --> Registers
00:0000477C 7000            	  3794:             moveq  #$00000000,d0
00:0000477E 7200            	  3795:             moveq  #$00000000,d1
00:00004780 7400            	  3796:             moveq  #$00000000,d2
00:00004782 7600            	  3797:             moveq  #$00000000,d3
00:00004784 7800            	  3798:             moveq  #$00000000,d4
00:00004786 7A00            	  3799:             moveq  #$00000000,d5
00:00004788 7C00            	  3800:             moveq  #$00000000,d6
00:0000478A 7E00            	  3801:             moveq  #$00000000,d7
00:0000478C 91C8            	  3802:             move.l #$00000000,a0
00:0000478E 93C9            	  3803:             move.l #$00000000,a1
00:00004790 95CA            	  3804:             move.l #$00000000,a2
00:00004792 97CB            	  3805:             move.l #$00000000,a3
00:00004794 99CC            	  3806:             move.l #$00000000,a4
00:00004796 9BCD            	  3807:             move.l #$00000000,a5
00:00004798 9DCE            	  3808:             move.l #$00000000,a6
                            	  3809: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3810: 
00:0000479A 4CB82A550100    	  3811:             movem.w $00000100,D0/D2/D4/D6/A1/A3/A5
                            	  3812: 
00:000047A0 B0BCFFFFD0D0    	  3813:             cmp.l #$FFFFD0D0,d0
00:000047A6 66FE            	  3814:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047A8 B4BCFFFFD1D1    	  3815:             cmp.l #$FFFFD1D1,d2
00:000047AE 66FE            	  3816:             bne.s *                  * Check Z Flag  beq/bne 0
00:000047B0 B8BCFFFFD2D2    	  3817:             cmp.l #$FFFFD2D2,d4
00:000047B6 66FE            	  3818:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047B8 BCBCFFFFD3D3    	  3819:             cmp.l #$FFFFD3D3,d6
00:000047BE 66FE            	  3820:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047C0 B2FCD4D4        	  3821:             cmp.l #$FFFFD4D4,a1
00:000047C4 66FE            	  3822:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047C6 B6FCD5D5        	  3823:             cmp.l #$FFFFD5D5,a3
00:000047CA 66FE            	  3824:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047CC BAFCD6D6        	  3825:             cmp.l #$FFFFD6D6,a5
00:000047D0 66FE            	  3826:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3827: 
                            	  3828: 
                            	  3829: *     LONG - Memory --> Registers
00:000047D2 7000            	  3830:             moveq  #$00000000,d0
00:000047D4 7200            	  3831:             moveq  #$00000000,d1
00:000047D6 7400            	  3832:             moveq  #$00000000,d2
00:000047D8 7600            	  3833:             moveq  #$00000000,d3
00:000047DA 7800            	  3834:             moveq  #$00000000,d4
00:000047DC 7A00            	  3835:             moveq  #$00000000,d5
00:000047DE 7C00            	  3836:             moveq  #$00000000,d6
00:000047E0 7E00            	  3837:             moveq  #$00000000,d7
00:000047E2 91C8            	  3838:             move.l #$00000000,a0
00:000047E4 93C9            	  3839:             move.l #$00000000,a1
00:000047E6 95CA            	  3840:             move.l #$00000000,a2
00:000047E8 97CB            	  3841:             move.l #$00000000,a3
00:000047EA 99CC            	  3842:             move.l #$00000000,a4
00:000047EC 9BCD            	  3843:             move.l #$00000000,a5
00:000047EE 9DCE            	  3844:             move.l #$00000000,a6
                            	  3845: *           move.l #$00000000,a7  * Dont change the Stack Pointer
                            	  3846: 
00:000047F0 4CF82A550120    	  3847:             movem.l $00000120,D0/D2/D4/D6/A1/A3/A5
                            	  3848: 
00:000047F6 B0BCD0D0D0D0    	  3849:             cmp.l #$D0D0D0D0,d0
00:000047FC 66FE            	  3850:             bne.s *                   * Check Z Flag  beq/bne 0
00:000047FE B4BCD1D1D1D1    	  3851:             cmp.l #$D1D1D1D1,d2
00:00004804 66FE            	  3852:             bne.s *                  * Check Z Flag  beq/bne 0
00:00004806 B8BCD2D2D2D2    	  3853:             cmp.l #$D2D2D2D2,d4
00:0000480C 66FE            	  3854:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000480E BCBCD3D3D3D3    	  3855:             cmp.l #$D3D3D3D3,d6
00:00004814 66FE            	  3856:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004816 B3FCD4D4D4D4    	  3857:             cmp.l #$D4D4D4D4,a1
00:0000481C 66FE            	  3858:             bne.s *                   * Check Z Flag  beq/bne 0
00:0000481E B7FCD5D5D5D5    	  3859:             cmp.l #$D5D5D5D5,a3
00:00004824 66FE            	  3860:             bne.s *                   * Check Z Flag  beq/bne 0
00:00004826 BBFCD6D6D6D6    	  3861:             cmp.l #$D6D6D6D6,a5
00:0000482C 66FE            	  3862:             bne.s *                   * Check Z Flag  beq/bne 0
                            	  3863: 
00:0000482E 4E75            	  3864:             rts
                            	  3865: 
                            	  3866: 
                            	  3867: *-----------------------------------------------------------
                            	  3868: *-----------------------------------------------------------
                            	  3869: * OPCODE : ABCD
                            	  3870: *-----------------------------------------------------------
                            	  3871: *-----------------------------------------------------------
                            	  3872: op_ABCD:
                            	  3873: 
                            	  3874: *     Test with X Flag CLEARED
00:00004830 307C0110        	  3875:                 move.l #$00000110,a0 * Address pointer-X
00:00004834 327C0120        	  3876:                 move.l #$00000120,a1 * Address pointer-Y
00:00004838 7000            	  3877:                 moveq  #$00000000,d0 * BCD byte-X
00:0000483A 7200            	  3878:                 moveq  #$00000000,d1 * BCD byte-Y
00:0000483C 7400            	  3879:                 moveq  #$00000000,d2
00:0000483E 7600            	  3880:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00004840 7800            	  3881:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00004842 7A00            	  3882:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:00004844 2C3C00000099    	  3883:                 move.l #$00000099,d6 * Inner loop counter
00:0000484A 2E3C00000099    	  3884:                 move.l #$00000099,d7 * Outer loop counter
                            	  3885: 
00:00004850 2007            	  3886: ABCD_OUTER1:    move.l d7,d0
00:00004852 2206            	  3887: ABCD_INNER1:    move.l d6,d1
00:00004854 023C00EF        	  3888:                 andi.b #$EF,CCR     * Clear X Flag
00:00004858 307C0110        	  3889:                 move.l #$00000110,a0 * Address pointer-X
00:0000485C 327C0120        	  3890:                 move.l #$00000120,a1 * Address pointer-Y
00:00004860 1140FFFF        	  3891:                 move.b d0,-1(a0)
00:00004864 1341FFFF        	  3892:                 move.b d1,-1(a1)
                            	  3893: 
00:00004868 C300            	  3894:                 abcd d0,d1
00:0000486A 6402            	  3895:                 bcc.s ABCD_NO_C1          * Check C Flag  bcc/bcs 0
00:0000486C 5284            	  3896:                 add.l #1,d4
00:0000486E DA81            	  3897: ABCD_NO_C1:     add.l d1,d5
                            	  3898: 
00:00004870 C308            	  3899:                 abcd -(a0),-(a1)
00:00004872 6402            	  3900:                 bcc.s ABCD_NO_C2          * Check C Flag  bcc/bcs 0
00:00004874 5284            	  3901:                 add.l #1,d4
00:00004876 D611            	  3902: ABCD_NO_C2:     add.b (a1),d3
                            	  3903: 
                            	  3904: 
00:00004878 51CEFFD8        	  3905:                 dbf d6,ABCD_INNER1
00:0000487C 2C3C00000099    	  3906:                 move.l #$00000099,d6
00:00004882 51CFFFCC        	  3907:                 dbf d7,ABCD_OUTER1
00:00004886 0C8400005AFC    	  3908:                 cmpi.l #$00005AFC,d4  * Check the cumulative results
00:0000488C 66FE            	  3909:                 bne.s *
00:0000488E 0C85001C9A34    	  3910:                 cmpi.l #$001C9A34,d5
00:00004894 66FE            	  3911:                 bne.s *
00:00004896 0C8300000034    	  3912:                 cmpi.l #$00000034,d3
00:0000489C 66FE            	  3913:                 bne.s *
                            	  3914: 
                            	  3915: *     Test with X Flag SET
00:0000489E 307C0110        	  3916:                 move.l #$00000110,a0 * Address pointer-X
00:000048A2 327C0120        	  3917:                 move.l #$00000120,a1 * Address pointer-Y
00:000048A6 7000            	  3918:                 moveq  #$00000000,d0 * BCD byte-X
00:000048A8 7200            	  3919:                 moveq  #$00000000,d1 * BCD byte-Y
00:000048AA 7400            	  3920:                 moveq  #$00000000,d2
00:000048AC 7600            	  3921:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:000048AE 7800            	  3922:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:000048B0 7A00            	  3923:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:000048B2 2C3C00000099    	  3924:                 move.l #$00000099,d6 * Inner loop counter
00:000048B8 2E3C00000099    	  3925:                 move.l #$00000099,d7 * Outer loop counter
                            	  3926: 
00:000048BE 2007            	  3927: ABCD_OUTER2:    move.l d7,d0
00:000048C0 2206            	  3928: ABCD_INNER2:    move.l d6,d1
00:000048C2 003C0010        	  3929:                 ori.b #$10,CCR      * Set X Flag
00:000048C6 307C0110        	  3930:                 move.l #$00000110,a0 * Address pointer-X
00:000048CA 327C0120        	  3931:                 move.l #$00000120,a1 * Address pointer-Y
00:000048CE 1140FFFF        	  3932:                 move.b d0,-1(a0)
00:000048D2 1341FFFF        	  3933:                 move.b d1,-1(a1)
                            	  3934: 
00:000048D6 C300            	  3935:                 abcd d0,d1
00:000048D8 6402            	  3936:                 bcc.s ABCD_NO_C3          * Check C Flag  bcc/bcs 0
00:000048DA 5284            	  3937:                 add.l #1,d4
00:000048DC DA81            	  3938: ABCD_NO_C3:     add.l d1,d5
                            	  3939: 
00:000048DE C308            	  3940:                 abcd -(a0),-(a1)
00:000048E0 6402            	  3941:                 bcc.s ABCD_NO_C4          * Check C Flag  bcc/bcs 0
00:000048E2 5284            	  3942:                 add.l #1,d4
00:000048E4 D611            	  3943: ABCD_NO_C4:     add.b (a1),d3
                            	  3944: 
                            	  3945: 
00:000048E6 51CEFFD8        	  3946:                 dbf d6,ABCD_INNER2
00:000048EA 2C3C00000099    	  3947:                 move.l #$00000099,d6
00:000048F0 51CFFFCC        	  3948:                 dbf d7,ABCD_OUTER2
00:000048F4 0C8400005B60    	  3949:                 cmpi.l #$00005B60,d4  * Check the cumulative results
00:000048FA 66FE            	  3950:                 bne.s *
00:000048FC 0C85001CCFC8    	  3951:                 cmpi.l #$001CCFC8,d5
00:00004902 66FE            	  3952:                 bne.s *
00:00004904 0C8300000034    	  3953:                 cmpi.l #$00000034,d3
00:0000490A 66FE            	  3954:                 bne.s *
                            	  3955: 
                            	  3956: *             Quick check of Z Flag
00:0000490C 4200            	  3957:                 move.b #$00,d0
00:0000490E 4201            	  3958:                 move.b #$00,d1
00:00004910 44FC0000        	  3959:                 move #$00,CCR              * Set Z flag to 0
00:00004914 C101            	  3960:                 abcd d1,d0                  * Should NOT set Z Flag to 1
00:00004916 67FE            	  3961:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3962: 
00:00004918 103C0001        	  3963:                 move.b #$01,d0
00:0000491C 4201            	  3964:                 move.b #$00,d1
00:0000491E 44FC0004        	  3965:                 move #$04,CCR              * Set Z flag to 0
00:00004922 C101            	  3966:                 abcd d1,d0                  * Should NOT set Z Flag to 1
00:00004924 67FE            	  3967:                 beq.s *                       * Check Z Flag  beq/bne
                            	  3968: 
00:00004926 4E75            	  3969:                 rts
                            	  3970: 
                            	  3971: *-----------------------------------------------------------
                            	  3972: *-----------------------------------------------------------
                            	  3973: * OPCODE : SBCD
                            	  3974: *-----------------------------------------------------------
                            	  3975: *-----------------------------------------------------------
                            	  3976: op_SBCD:
                            	  3977: 
                            	  3978: *     Test with X Flag CLEARED
00:00004928 307C0110        	  3979:                 move.l #$00000110,a0 * Address pointer-X
00:0000492C 327C0120        	  3980:                 move.l #$00000120,a1 * Address pointer-Y
00:00004930 7000            	  3981:                 moveq  #$00000000,d0 * BCD byte-X
00:00004932 7200            	  3982:                 moveq  #$00000000,d1 * BCD byte-Y
00:00004934 7400            	  3983:                 moveq  #$00000000,d2
00:00004936 7600            	  3984:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:00004938 7800            	  3985:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:0000493A 7A00            	  3986:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:0000493C 2C3C00000099    	  3987:                 move.l #$00000099,d6 * Inner loop counter
00:00004942 2E3C00000099    	  3988:                 move.l #$00000099,d7 * Outer loop counter
                            	  3989: 
00:00004948 2007            	  3990: SBCD_OUTER1:    move.l d7,d0
00:0000494A 2206            	  3991: SBCD_INNER1:    move.l d6,d1
00:0000494C 023C00EF        	  3992:                 andi.b #$EF,CCR     * Clear X Flag
00:00004950 307C0110        	  3993:                 move.l #$00000110,a0 * Address pointer-X
00:00004954 327C0120        	  3994:                 move.l #$00000120,a1 * Address pointer-Y
00:00004958 1140FFFF        	  3995:                 move.b d0,-1(a0)
00:0000495C 1341FFFF        	  3996:                 move.b d1,-1(a1)
                            	  3997: 
00:00004960 8300            	  3998:                 sbcd d0,d1
00:00004962 6402            	  3999:                 bcc.s SBCD_NO_C1          * Check C Flag  bcc/bcs 0
00:00004964 5284            	  4000:                 add.l #1,d4
00:00004966 DA81            	  4001: SBCD_NO_C1:     add.l d1,d5
                            	  4002: 
00:00004968 8308            	  4003:                 sbcd -(a0),-(a1)
00:0000496A 6402            	  4004:                 bcc.s SBCD_NO_C2          * Check C Flag  bcc/bcs 0
00:0000496C 5284            	  4005:                 add.l #1,d4
00:0000496E D611            	  4006: SBCD_NO_C2:     add.b (a1),d3
                            	  4007: 
                            	  4008: 
00:00004970 51CEFFD8        	  4009:                 dbf d6,SBCD_INNER1
00:00004974 2C3C00000099    	  4010:                 move.l #$00000099,d6
00:0000497A 51CFFFCC        	  4011:                 dbf d7,SBCD_OUTER1
00:0000497E 0C8400005C0A    	  4012:                 cmpi.l #$00005C0A,d4  * Check the cumulative results
00:00004984 66FE            	  4013:                 bne.s *
00:00004986 0C85001C459E    	  4014:                 cmpi.l #$001C459E,d5
00:0000498C 66FE            	  4015:                 bne.s *
00:0000498E 0C830000009E    	  4016:                 cmpi.l #$0000009E,d3
00:00004994 66FE            	  4017:                 bne.s *
                            	  4018: 
                            	  4019: *     Test with X Flag SET
00:00004996 307C0110        	  4020:                 move.l #$00000110,a0 * Address pointer-X
00:0000499A 327C0120        	  4021:                 move.l #$00000120,a1 * Address pointer-Y
00:0000499E 7000            	  4022:                 moveq  #$00000000,d0 * BCD byte-X
00:000049A0 7200            	  4023:                 moveq  #$00000000,d1 * BCD byte-Y
00:000049A2 7400            	  4024:                 moveq  #$00000000,d2
00:000049A4 7600            	  4025:                 moveq  #$00000000,d3 * Cumulative -(An) BCD results
00:000049A6 7800            	  4026:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:000049A8 7A00            	  4027:                 moveq  #$00000000,d5 * Cumulative Register BCD results
00:000049AA 2C3C00000099    	  4028:                 move.l #$00000099,d6 * Inner loop counter
00:000049B0 2E3C00000099    	  4029:                 move.l #$00000099,d7 * Outer loop counter
                            	  4030: 
00:000049B6 2007            	  4031: SBCD_OUTER2:    move.l d7,d0
00:000049B8 2206            	  4032: SBCD_INNER2:    move.l d6,d1
00:000049BA 003C0010        	  4033:                 ori.b #$10,CCR      * Set X Flag
00:000049BE 307C0110        	  4034:                 move.l #$00000110,a0 * Address pointer-X
00:000049C2 327C0120        	  4035:                 move.l #$00000120,a1 * Address pointer-Y
00:000049C6 1140FFFF        	  4036:                 move.b d0,-1(a0)
00:000049CA 1341FFFF        	  4037:                 move.b d1,-1(a1)
                            	  4038: 
00:000049CE 8300            	  4039:                 sbcd d0,d1
00:000049D0 6402            	  4040:                 bcc.s SBCD_NO_C3          * Check C Flag  bcc/bcs 0
00:000049D2 5284            	  4041:                 add.l #1,d4
00:000049D4 DA81            	  4042: SBCD_NO_C3:     add.l d1,d5
                            	  4043: 
00:000049D6 8308            	  4044:                 sbcd -(a0),-(a1)
00:000049D8 6402            	  4045:                 bcc.s SBCD_NO_C4          * Check C Flag  bcc/bcs 0
00:000049DA 5284            	  4046:                 add.l #1,d4
00:000049DC D611            	  4047: SBCD_NO_C4:     add.b (a1),d3
                            	  4048: 
00:000049DE 51CEFFD8        	  4049:                 dbf d6,SBCD_INNER2
00:000049E2 2C3C00000099    	  4050:                 move.l #$00000099,d6
00:000049E8 51CFFFCC        	  4051:                 dbf d7,SBCD_OUTER2
00:000049EC 0C8400005CA4    	  4052:                 cmpi.l #$00005CA4,d4  * Check the cumulative results
00:000049F2 66FE            	  4053:                 bne.s *
00:000049F4 0C85001C5C66    	  4054:                 cmpi.l #$001C5C66,d5
00:000049FA 66FE            	  4055:                 bne.s *
00:000049FC 0C830000009E    	  4056:                 cmpi.l #$0000009E,d3
00:00004A02 66FE            	  4057:                 bne.s *
                            	  4058: 
                            	  4059: 
                            	  4060: *             Quick check of Z Flag
00:00004A04 4200            	  4061:                 move.b #$00,d0
00:00004A06 4201            	  4062:                 move.b #$00,d1
00:00004A08 44FC0000        	  4063:                 move #$00,CCR              * Set Z flag to 0
00:00004A0C 8101            	  4064:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
00:00004A0E 67FE            	  4065:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4066: 
00:00004A10 103C0001        	  4067:                 move.b #$01,d0
00:00004A14 4201            	  4068:                 move.b #$00,d1
00:00004A16 44FC0004        	  4069:                 move #$04,CCR              * Set Z flag to 0
00:00004A1A 8101            	  4070:                 sbcd d1,d0                  * Should NOT set Z Flag to 1
00:00004A1C 67FE            	  4071:                 beq.s *                       * Check Z Flag  beq/bne
                            	  4072: 
00:00004A1E 4E75            	  4073:                 rts
                            	  4074: 
                            	  4075: *-----------------------------------------------------------
                            	  4076: *-----------------------------------------------------------
                            	  4077: * OPCODE : NBCD
                            	  4078: *-----------------------------------------------------------
                            	  4079: *-----------------------------------------------------------
                            	  4080: op_NBCD:
                            	  4081: 
                            	  4082: *        NBCD to a  Register
                            	  4083: 
00:00004A20 7000            	  4084:                 moveq  #$00000000,d0 * BCD byte
00:00004A22 7200            	  4085:                 moveq  #$00000000,d1
00:00004A24 7400            	  4086:                 moveq  #$00000000,d2
00:00004A26 7600            	  4087:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
00:00004A28 7800            	  4088:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00004A2A 7A00            	  4089:                 moveq  #$00000000,d5 * Cumulative BCD results
00:00004A2C 2C3C00000099    	  4090:                 move.l #$00000099,d6
00:00004A32 2E3C00000099    	  4091:                 move.l #$00000099,d7 * Loop counter
                            	  4092: 
00:00004A38 2007            	  4093: NBCD_LOOP:      move.l d7,d0
00:00004A3A 44FC0004        	  4094:                 move #$04,CCR        * Set Z flag to 0
                            	  4095: 
00:00004A3E 4800            	  4096:                 nbcd d0
                            	  4097: 
00:00004A40 6402            	  4098:                 bcc.s NBCD_NO_C         * Check C Flag
00:00004A42 5284            	  4099:                 add.l #1,d4
00:00004A44 6602            	  4100: NBCD_NO_C:      bne.s NBCD_NO_Z         * Check Z Flag
00:00004A46 5283            	  4101:                 add.l #1,d3
00:00004A48 DA80            	  4102: NBCD_NO_Z:      add.l d0,d5         * Add results into d5
                            	  4103: 
00:00004A4A 51CFFFEC        	  4104:                 dbf d7,NBCD_LOOP
                            	  4105: 
00:00004A4E 0C8300000001    	  4106:                 cmpi.l #$00000001,d3  * Check the cumulative results
00:00004A54 66FE            	  4107:                 bne.s *
00:00004A56 0C8400000099    	  4108:                 cmpi.l #$00000099,d4
00:00004A5C 66FE            	  4109:                 bne.s *
00:00004A5E 0C8500002E3B    	  4110:                 cmpi.l #$00002E3B,d5
00:00004A64 66FE            	  4111:                 bne.s *
                            	  4112: 
                            	  4113: 
                            	  4114: *        NBCD to a memory location
                            	  4115: 
00:00004A66 7000            	  4116:                 moveq  #$00000000,d0 * BCD byte
00:00004A68 7200            	  4117:                 moveq  #$00000000,d1
00:00004A6A 7400            	  4118:                 moveq  #$00000000,d2
00:00004A6C 7600            	  4119:                 moveq  #$00000000,d3 * Cumulative number.s of times Z was set
00:00004A6E 7800            	  4120:                 moveq  #$00000000,d4 * Cumulative number.s of times C was set
00:00004A70 7A00            	  4121:                 moveq  #$00000000,d5 * Cumulative BCD results
00:00004A72 2C3C00000099    	  4122:                 move.l #$00000099,d6
00:00004A78 2E3C00000099    	  4123:                 move.l #$00000099,d7 * Loop counter
                            	  4124: 
00:00004A7E 11C70100        	  4125: NBCD_LOOP1:     move.b d7,$00000100
00:00004A82 44FC0004        	  4126:                 move #$04,CCR        * Set Z flag to 0
                            	  4127: 
00:00004A86 48380100        	  4128:                 nbcd $00000100
00:00004A8A 10380100        	  4129:                 move.b $00000100,d0
                            	  4130: 
00:00004A8E 6402            	  4131:                 bcc.s NBCD_NO_C1        * Check C Flag
00:00004A90 5284            	  4132:                 add.l #1,d4
00:00004A92 6602            	  4133: NBCD_NO_C1:     bne.s NBCD_NO_Z1        * Check Z Flag
00:00004A94 5283            	  4134:                 add.l #1,d3
00:00004A96 DA80            	  4135: NBCD_NO_Z1:     add.l d0,d5         * Add results into d5
                            	  4136: 
00:00004A98 51CFFFE4        	  4137:                 dbf d7,NBCD_LOOP1
                            	  4138: 
00:00004A9C 0C8300000001    	  4139:                 cmpi.l #$00000001,d3  * Check the cumulative results
00:00004AA2 66FE            	  4140:                 bne.s *
00:00004AA4 4A84            	  4141:                 cmpi.l #$00000000,d4
00:00004AA6 66FE            	  4142:                 bne.s *
00:00004AA8 0C8500002E3B    	  4143:                 cmpi.l #$00002E3B,d5
00:00004AAE 66FE            	  4144:                 bne.s *
                            	  4145: 
                            	  4146: 
00:00004AB0 4E75            	  4147:                 rts
                            	  4148: 
                            	  4149: 
                            	  4150: 
                            	  4151: *-----------------------------------------------------------
                            	  4152: *-----------------------------------------------------------
                            	  4153: * OPCODE : TRAPV
                            	  4154: *-----------------------------------------------------------
                            	  4155: *-----------------------------------------------------------
                            	  4156: op_TRAPV:
                            	  4157: 
                            	  4158: *     TRAPV will set d0 to 12345678 if V flag is set
                            	  4159: 
00:00004AB2 7000            	  4160:                 moveq  #$00000000,d0 * Clear d0
                            	  4161: 
00:00004AB4 44FC0000        	  4162:                 move #$00,CCR        * Clear V flag
00:00004AB8 4E76            	  4163:                 trapv
00:00004ABA 4A80            	  4164:                 cmpi.l #$00000000,d0  * Check of d0 was updated (should not be_)
00:00004ABC 66FE            	  4165:                 bne.s *
                            	  4166: 
00:00004ABE 44FC0002        	  4167:                 move #$02,CCR        * Set V flag
00:00004AC2 4E76            	  4168:                 trapv
00:00004AC4 0C8012345678    	  4169:                 cmpi.l #$12345678,d0  * Check of d0 was updated (should not be_)
00:00004ACA 66FE            	  4170:                 bne.s *
                            	  4171: 
                            	  4172: 
00:00004ACC 4E75            	  4173:                 rts
                            	  4174: 
                            	  4175: 
                            	  4176: 
                            	  4177: *-----------------------------------------------------------
                            	  4178: *-----------------------------------------------------------
                            	  4179: * OPCODE : RTR
                            	  4180: *-----------------------------------------------------------
                            	  4181: *-----------------------------------------------------------
                            	  4182: 
                            	  4183: op_RTR:
                            	  4184: 
                            	  4185: *     Leventhal claims only 5 LSB's are popped from the stack to the CCR
                            	  4186: 
00:00004ACE 41FA000A        	  4187:                 lea 		RTR_DONE,a0
00:00004AD2 2F08            	  4188:                 move.l 	a0,-(a7)     * push destination PC to the stack
00:00004AD4 3F3CFF15        	  4189:                 move.w 	#$FF15,-(a7)       * push flags=0xFFFF to the stack
00:00004AD8 4E77            	  4190:                 rtr
                            	  4191: 
00:00004ADA 40C0            	  4192: RTR_DONE:       move.w SR,d0
00:00004ADC 0240001F        	  4193:                 andi.w #$1F,d0
00:00004AE0 0C400015        	  4194:                 cmpi.w #$15,d0
00:00004AE4 66FE            	  4195:                 bne.s *
                            	  4196: 
00:00004AE6 4E75            	  4197:                 rts
                            	  4198: 
                            	  4199: 
00:00004AE8 283C44444444    	  4200: BSR_FAR2:       move.l #$44444444,d4
00:00004AEE 4E75            	  4201:                 rts
                            	  4202: 
                            	  4203: 
                            	  4204: *-----------------------------------------------------------
                            	  4205: *-----------------------------------------------------------
                            	  4206: * OPCODE : BCC
                            	  4207: *-----------------------------------------------------------
                            	  4208: *-----------------------------------------------------------
                            	  4209: 
00:00004AF0 44FC0000        	  4210: op_BCC:         move #$00,CCR
00:00004AF4 6202            	  4211:                 bhi.s BCC1            * Higher Than         C=0 AND Z=0
00:00004AF6 60FE            	  4212:                 bra.s *
                            	  4213: 
00:00004AF8 44FC0001        	  4214: BCC1:           move #$01,CCR
00:00004AFC 63000004        	  4215:                 bls.w BCC2            * Lower or Same       C=1 OR Z=1
00:00004B00 60FE            	  4216:                 bra.s *
                            	  4217: 
00:00004B02 44FC0000        	  4218: BCC2:           move #$00,CCR
00:00004B06 6402            	  4219:                 bcc.s BCC3            * Carry Clear         C=0
00:00004B08 60FE            	  4220:                 bra.s *
                            	  4221: 
00:00004B0A 44FC0001        	  4222: BCC3:           move #$01,CCR
00:00004B0E 65000004        	  4223:                 bcs.w BCC4            * Carry Set           C=1
00:00004B12 60FE            	  4224:                 bra.s *
                            	  4225: 
00:00004B14 44FC0000        	  4226: BCC4:           move #$00,CCR
00:00004B18 6602            	  4227:                 bne.s BCC5            * Not Equal           Z=0
00:00004B1A 60FE            	  4228:                 bra.s *
                            	  4229: 
00:00004B1C 44FC0004        	  4230: BCC5:           move #$04,CCR
00:00004B20 67000004        	  4231:                 beq.w BCC6            * Equal               Z=1
00:00004B24 60FE            	  4232:                 bra.s *
                            	  4233: 
00:00004B26 44FC0000        	  4234: BCC6:           move #$00,CCR
00:00004B2A 6802            	  4235:                 bvc.s BCC7            * V Clear             V=0
00:00004B2C 60FE            	  4236:                 bra.s *
                            	  4237: 
00:00004B2E 44FC0002        	  4238: BCC7:           move #$02,CCR
00:00004B32 69000004        	  4239:                 bvs.w BCC8            * V Set               V=1
00:00004B36 60FE            	  4240:                 bra.s *
                            	  4241: 
00:00004B38 44FC0000        	  4242: BCC8:           move #$00,CCR
00:00004B3C 6A02            	  4243:                 bpl.s BCC9            * Plus                N=0
00:00004B3E 60FE            	  4244:                 bra.s *
                            	  4245: 
00:00004B40 44FC0008        	  4246: BCC9:           move #$08,CCR
00:00004B44 6B000004        	  4247:                 bmi.w BCC10           * Minus               N=1
00:00004B48 60FE            	  4248:                 bra.s *
                            	  4249: 
00:00004B4A 44FC0000        	  4250: BCC10:          move #$00,CCR
00:00004B4E 6C02            	  4251:                 bge.s BCC11           * Greater or Equal    N=V
00:00004B50 60FE            	  4252:                 bra.s *
                            	  4253: 
00:00004B52 44FC0002        	  4254: BCC11:          move #$02,CCR
00:00004B56 6D000004        	  4255:                 blt.w BCC12           * Less Than           N!=V
00:00004B5A 60FE            	  4256:                 bra.s *
                            	  4257: 
00:00004B5C 44FC000A        	  4258: BCC12:          move #$0A,CCR
00:00004B60 6E02            	  4259:                 bgt.s BCC13           * Greater Than        N=V  AND Z=0
00:00004B62 60FE            	  4260:                 bra.s *
                            	  4261: 
00:00004B64 44FC0006        	  4262: BCC13:          move #$06,CCR
00:00004B68 6F000004        	  4263:                 ble.w BCC14           * Less Than or Equal  N!=V AND Z=1
00:00004B6C 60FE            	  4264:                 bra.s *
                            	  4265: 
                            	  4266: 
00:00004B6E 4E75            	  4267: BCC14:          rts
                            	  4268: 
                            	  4269: 
                            	  4270: *-----------------------------------------------------------
                            	  4271: *-----------------------------------------------------------
                            	  4272: * OPCODE : DBCC
                            	  4273: *-----------------------------------------------------------
                            	  4274: *-----------------------------------------------------------
                            	  4275: 
00:00004B70 7003            	  4276: op_DBCC:        moveq  #$00000003,d0    * Loop counter
00:00004B72 7200            	  4277:                 moveq  #$00000000,d1    * Accumulator
00:00004B74 44FC0000        	  4278:                 move #$00,CCR
                            	  4279: 
00:00004B78 5201            	  4280: DBCC_LOOP1:     addi.b #$1,d1
00:00004B7A 51C8FFFC        	  4281:                 dbf d0,DBCC_LOOP1
                            	  4282: 
00:00004B7E 0C8100000004    	  4283:                 cmpi.l #$00000004,d1  * Check Accumulator results
00:00004B84 66FE            	  4284:                 bne.s *
                            	  4285: 
00:00004B86 5201            	  4286: DBCC_LOOP2:     addi.b #$1,d1
00:00004B88 54C8FFFC        	  4287:                 dbcc d0,DBCC_LOOP2    * Dont loop
                            	  4288: 
00:00004B8C 0C8100000005    	  4289:                 cmpi.l #$00000005,d1  * Check Accumulator results
00:00004B92 66FE            	  4290:                 bne.s *
                            	  4291: 
00:00004B94 4E75            	  4292:                 rts
                            	  4293: 
                            	  4294: 
                            	  4295: *-----------------------------------------------------------
                            	  4296: *-----------------------------------------------------------
                            	  4297: * OPCODE : SCC
                            	  4298: *-----------------------------------------------------------
                            	  4299: *-----------------------------------------------------------
                            	  4300: 
00:00004B96 44FC0001        	  4301: op_SCC:         move #$01,CCR
00:00004B9A 54F900010000    	  4302:                 scc $00010000                   * Clear the EA byte
00:00004BA0 4A3900010000    	  4303:                 cmpi.b #$00,$00010000
00:00004BA6 66FE            	  4304:                 bne.s *
                            	  4305: 
00:00004BA8 44FC0000        	  4306:                 move #$00,CCR
00:00004BAC 54F900010000    	  4307:                 scc $00010000                   * Set the EA byte to 0xFF
00:00004BB2 0C3900FF00010000	  4308:                 cmpi.b #$FF,$00010000
00:00004BBA 66FE            	  4309:                 bne.s *
                            	  4310: 
00:00004BBC 54C0            	  4311: 								scc d0													* Test setting a data register
00:00004BBE 0C0000FF        	  4312: 								cmpi.b #$FF,d0
00:00004BC2 66FE            	  4313: 								bne.s *
00:00004BC4 4E75            	  4314:                 rts
                            	  4315: 
                            	  4316: 
                            	  4317: 
                            	  4318: *-----------------------------------------------------------
                            	  4319: *-----------------------------------------------------------
                            	  4320: * OPCODE : ADDQ
                            	  4321: *-----------------------------------------------------------
                            	  4322: *-----------------------------------------------------------
                            	  4323: 
                            	  4324: op_ADDQ:
                            	  4325: 
                            	  4326: *     BYTE
00:00004BC6 203C000000FF    	  4327:                 move.l #$000000FF,d0    * Loop counter
00:00004BCC 7200            	  4328:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004BCE 7400            	  4329:                 moveq  #$00000000,d2    * Data results accumulator
00:00004BD0 7600            	  4330:                 moveq  #$00000000,d3
00:00004BD2 7800            	  4331:                 moveq  #$00000000,d4
00:00004BD4 7A00            	  4332:                 moveq  #$00000000,d5
00:00004BD6 7C00            	  4333:                 moveq  #$00000000,d6
00:00004BD8 7E00            	  4334:                 moveq  #$00000000,d7
                            	  4335: 
00:00004BDA 5605            	  4336: ADDQ_LOOP1:     addq.b #3,d5
00:00004BDC 40C6            	  4337:                 move.w SR,d6
00:00004BDE 02860000001F    	  4338:                 andi.l #$1F,d6        * Isolate flags
00:00004BE4 D286            	  4339:                 add.l d6,d1           * Copy flag results into accumulator
00:00004BE6 D485            	  4340:                 add.l d5,d2           * Copy data results into data accumulator
00:00004BE8 51C8FFF0        	  4341:                 dbf d0,ADDQ_LOOP1
                            	  4342: 
00:00004BEC 0C810000043D    	  4343:                 cmpi.l #$0000043D,d1
00:00004BF2 66FE            	  4344:                 bne.s *
00:00004BF4 0C8200007F80    	  4345:                 cmpi.l #$00007F80,d2
00:00004BFA 66FE            	  4346:                 bne.s *
                            	  4347: 
                            	  4348: 
                            	  4349: *     WORD
00:00004BFC 203C000000FF    	  4350:                 move.l #$000000FF,d0    * Loop counter
00:00004C02 7200            	  4351:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004C04 7400            	  4352:                 moveq  #$00000000,d2    * Data results accumulator
00:00004C06 7600            	  4353:                 moveq  #$00000000,d3
00:00004C08 7800            	  4354:                 moveq  #$00000000,d4
00:00004C0A 2A3C0000FFF0    	  4355:                 move.l #$0000FFF0,d5
00:00004C10 7C00            	  4356:                 moveq  #$00000000,d6
00:00004C12 7E00            	  4357:                 moveq  #$00000000,d7
00:00004C14 307C0100        	  4358:                 move.l #$00000100,a0
                            	  4359: 
00:00004C18 5A45            	  4360: ADDQ_LOOP2:     addq.w #5,d5
00:00004C1A 40C6            	  4361:                 move.w SR,d6
00:00004C1C 02860000001F    	  4362:                 andi.l #$1F,d6        * Isolate flags
00:00004C22 D286            	  4363:                 add.l d6,d1           * Copy flag results into accumulator
00:00004C24 D485            	  4364:                 add.l d5,d2           * Copy data results into data accumulator
00:00004C26 51C8FFF0        	  4365:                 dbf d0,ADDQ_LOOP2
                            	  4366: 
00:00004C2A 0C8100000029    	  4367:                 cmpi.l #$00000029,d1
00:00004C30 66FE            	  4368:                 bne.s *
00:00004C32 0C8200057280    	  4369:                 cmpi.l #$00057280,d2
00:00004C38 66FE            	  4370:                 bne.s *
                            	  4371: 
                            	  4372: 
                            	  4373: *     LONG
00:00004C3A 203C000000FF    	  4374:                 move.l #$000000FF,d0    * Loop counter
00:00004C40 7200            	  4375:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004C42 7400            	  4376:                 moveq  #$00000000,d2    * Data results accumulator
00:00004C44 7600            	  4377:                 moveq  #$00000000,d3
00:00004C46 7800            	  4378:                 moveq  #$00000000,d4
00:00004C48 7AF0            	  4379:                 move.l #$FFFFFFF0,d5
00:00004C4A 7C00            	  4380:                 moveq  #$00000000,d6
00:00004C4C 7E00            	  4381:                 moveq  #$00000000,d7
                            	  4382: 
00:00004C4E 5285            	  4383: ADDQ_LOOP3:     addq.l #1,d5
00:00004C50 40C6            	  4384:                 move.w SR,d6
00:00004C52 02860000001F    	  4385:                 andi.l #$1F,d6        * Isolate flags
00:00004C58 D286            	  4386:                 add.l d6,d1           * Copy flag results into accumulator
00:00004C5A D485            	  4387:                 add.l d5,d2           * Copy data results into data accumulator
00:00004C5C 51C8FFF0        	  4388:                 dbf d0,ADDQ_LOOP3
                            	  4389: 
00:00004C60 0C810000008D    	  4390:                 cmpi.l #$0000008D,d1
00:00004C66 66FE            	  4391:                 bne.s *
00:00004C68 0C8200007080    	  4392:                 cmpi.l #$00007080,d2
00:00004C6E 66FE            	  4393:                 bne.s *
                            	  4394: 
                            	  4395: *     Check that Flags are not updated for Address registers
00:00004C70 207C0000FFFF    	  4396:                 move.l #$0000FFFF,a0
00:00004C76 44FC0000        	  4397:                 move #$00,CCR         * Clear flags
00:00004C7A 5E48            	  4398:                 addq.w #$7,a0
00:00004C7C 65FE            	  4399:                 bcs.s *
                            	  4400: 
00:00004C7E 4E75            	  4401:                 rts
                            	  4402: 
                            	  4403: 
                            	  4404: 
                            	  4405: *-----------------------------------------------------------
                            	  4406: *-----------------------------------------------------------
                            	  4407: * OPCODE : SUBQ
                            	  4408: *-----------------------------------------------------------
                            	  4409: *-----------------------------------------------------------
                            	  4410: 
                            	  4411: op_SUBQ:
                            	  4412: 
                            	  4413: *     BYTE
00:00004C80 203C000000FF    	  4414:                 move.l #$000000FF,d0    * Loop counter
00:00004C86 7200            	  4415:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004C88 243C00001234    	  4416:                 move.l #$00001234,d2    * Data results accumulator
00:00004C8E 7600            	  4417:                 moveq  #$00000000,d3
00:00004C90 7800            	  4418:                 moveq  #$00000000,d4
00:00004C92 7A12            	  4419:                 moveq  #$00000012,d5
00:00004C94 7C00            	  4420:                 moveq  #$00000000,d6
00:00004C96 7E00            	  4421:                 moveq  #$00000000,d7
                            	  4422: 
00:00004C98 5305            	  4423: SUBQ_LOOP1:     subq.b #1,d5
00:00004C9A 40C6            	  4424:                 move.w SR,d6
00:00004C9C 02860000001F    	  4425:                 andi.l #$1F,d6        * Isolate flags
00:00004CA2 D286            	  4426:                 add.l d6,d1           * Copy flag results into accumulator
00:00004CA4 D485            	  4427:                 add.l d5,d2           * Copy data results into data accumulator
00:00004CA6 51C8FFF0        	  4428:                 dbf d0,SUBQ_LOOP1
                            	  4429: 
00:00004CAA 0C8100000417    	  4430:                 cmpi.l #$00000417,d1
00:00004CB0 66FE            	  4431:                 bne.s *
00:00004CB2 0C82000091B4    	  4432:                 cmpi.l #$000091B4,d2
00:00004CB8 66FE            	  4433:                 bne.s *
                            	  4434: 
                            	  4435: 
                            	  4436: *     WORD
00:00004CBA 203C000000FF    	  4437:                 move.l #$000000FF,d0    * Loop counter
00:00004CC0 7200            	  4438:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004CC2 7400            	  4439:                 moveq  #$00000000,d2    * Data results accumulator
00:00004CC4 7600            	  4440:                 moveq  #$00000000,d3
00:00004CC6 7800            	  4441:                 moveq  #$00000000,d4
00:00004CC8 7A02            	  4442:                 moveq  #$00000002,d5
00:00004CCA 7C00            	  4443:                 moveq  #$00000000,d6
00:00004CCC 7E00            	  4444:                 moveq  #$00000000,d7
00:00004CCE 307C0100        	  4445:                 move.l #$00000100,a0
                            	  4446: 
00:00004CD2 5B45            	  4447: SUBQ_LOOP2:     subq.w #5,d5
00:00004CD4 40C6            	  4448:                 move.w SR,d6
00:00004CD6 02860000001F    	  4449:                 andi.l #$1F,d6        * Isolate flags
00:00004CDC D286            	  4450:                 add.l d6,d1           * Copy flag results into accumulator
00:00004CDE D485            	  4451:                 add.l d5,d2           * Copy data results into data accumulator
00:00004CE0 51C8FFF0        	  4452:                 dbf d0,SUBQ_LOOP2
                            	  4453: 
00:00004CE4 0C8100000811    	  4454:                 cmpi.l #$00000811,d1
00:00004CEA 66FE            	  4455:                 bne.s *
00:00004CEC 0C8200FD7F80    	  4456:                 cmpi.l #$00FD7F80,d2
00:00004CF2 66FE            	  4457:                 bne.s *
                            	  4458: 
                            	  4459: 
                            	  4460: *     LONG
00:00004CF4 203C000000FF    	  4461:                 move.l #$000000FF,d0    * Loop counter
00:00004CFA 7200            	  4462:                 moveq  #$00000000,d1    * Flag results accumulator
00:00004CFC 7400            	  4463:                 moveq  #$00000000,d2    * Data results accumulator
00:00004CFE 7600            	  4464:                 moveq  #$00000000,d3
00:00004D00 7800            	  4465:                 moveq  #$00000000,d4
00:00004D02 7A07            	  4466:                 moveq  #$00000007,d5
00:00004D04 7C00            	  4467:                 moveq  #$00000000,d6
00:00004D06 7E00            	  4468:                 moveq  #$00000000,d7
                            	  4469: 
00:00004D08 5385            	  4470: SUBQ_LOOP3:     subq.l #1,d5
00:00004D0A 40C6            	  4471:                 move.w SR,d6
00:00004D0C 02860000001F    	  4472:                 andi.l #$1F,d6        * Isolate flags
00:00004D12 D286            	  4473:                 add.l d6,d1           * Copy flag results into accumulator
00:00004D14 D485            	  4474:                 add.l d5,d2           * Copy data results into data accumulator
00:00004D16 51C8FFF0        	  4475:                 dbf d0,SUBQ_LOOP3
                            	  4476: 
00:00004D1A 0C81000007DD    	  4477:                 cmpi.l #$000007DD,d1
00:00004D20 66FE            	  4478:                 bne.s *
00:00004D22 0C82FFFF8680    	  4479:                 cmpi.l #$FFFF8680,d2
00:00004D28 66FE            	  4480:                 bne.s *
                            	  4481: 
                            	  4482: *     Check that Flags are not updated for Address registers
00:00004D2A 207C0001FFFF    	  4483:                 move.l #$0001FFFF,a0
00:00004D30 44FC0000        	  4484:                 move #$00,CCR         * Clear flags
00:00004D34 5F48            	  4485:                 subq.w #$7,a0
00:00004D36 65FE            	  4486:                 bcs.s *
                            	  4487: 
00:00004D38 4E75            	  4488:                 rts
                            	  4489: 
                            	  4490: 
                            	  4491: 
                            	  4492: 
                            	  4493: *-----------------------------------------------------------
                            	  4494: *-----------------------------------------------------------
                            	  4495: * OPCODE : MOVEQ
                            	  4496: *-----------------------------------------------------------
                            	  4497: *-----------------------------------------------------------
                            	  4498: 
                            	  4499: op_MOVEQ:
00:00004D3A 7000            	  4500:                 moveq  #$00000000,d0
00:00004D3C 7000            	  4501:                 moveq #$0,d0
00:00004D3E 66FE            	  4502:                 bne.s *
00:00004D40 4A80            	  4503:                 cmpi.l #$00000000,d0
00:00004D42 66FE            	  4504:                 bne.s *
                            	  4505: 
00:00004D44 7000            	  4506:                 moveq  #$00000000,d0
00:00004D46 7080            	  4507:                 moveq #-128,d0
00:00004D48 67FE            	  4508:                 beq.s *
00:00004D4A 6AFE            	  4509:                 bpl.s *
00:00004D4C 0C80FFFFFF80    	  4510:                 cmpi.l #$FFFFFF80,d0
00:00004D52 66FE            	  4511:                 bne.s *
                            	  4512: 
                            	  4513: 
00:00004D54 4E75            	  4514:                 rts
                            	  4515: 
                            	  4516: 
                            	  4517: *-----------------------------------------------------------
                            	  4518: *-----------------------------------------------------------
                            	  4519: * OPCODE : DIVU
                            	  4520: *-----------------------------------------------------------
                            	  4521: *-----------------------------------------------------------
                            	  4522: 
                            	  4523: op_DIVU:
                            	  4524: 
00:00004D56 203CA5A5A5A5    	  4525:                 move.l #$a5a5a5a5,d0        * Initial Numerator
00:00004D5C 223C00005A5A    	  4526:                 move.l #$00005a5a,d1        * Initial Divisor
00:00004D62 243CA5A5A5A5    	  4527:                 move.l #$a5a5a5a5,d2
00:00004D68 7600            	  4528:                 moveq  #$00000000,d3
00:00004D6A 7800            	  4529:                 moveq  #$00000000,d4        * Cumulative data results
00:00004D6C 7A00            	  4530:                 moveq  #$00000000,d5       * Cumulative flag results
00:00004D6E 7C0E            	  4531:                 move.l #$0000000E,d6       * Inner loop counter
00:00004D70 7E1E            	  4532:                 move.l #$0000001E,d7       * Outer loop counter
                            	  4533: 
                            	  4534: 
00:00004D72 80C1            	  4535: DIVU_OUTER1:    divu d1,d0               * !! Easy68K C not always cleared
00:00004D74 40C3            	  4536:                 move.w SR,d3
00:00004D76 02830000000C    	  4537:                 andi.l #$0C,d3            * Isolate flags
00:00004D7C DA83            	  4538:                 add.l d3,d5               * Copy flag results into accumulator
00:00004D7E D880            	  4539:                 add.l d0,d4               * Copy data results into data accumulator
00:00004D80 E289            	  4540:                 lsr.l #$1,d1
                            	  4541: 
00:00004D82 51CEFFEE        	  4542:                 dbf d6,DIVU_OUTER1
00:00004D86 E28A            	  4543:                 lsr.l #$1,d2
00:00004D88 2002            	  4544:                 move.l d2,d0
00:00004D8A 223C00005A5A    	  4545:                 move.l #$00005a5a,d1       * Initial Divisor
00:00004D90 7C0E            	  4546:                 move.l #$0000000E,d6       * Inner loop counter
00:00004D92 51CFFFDE        	  4547:                 dbf d7,DIVU_OUTER1
                            	  4548: 
00:00004D96 0C8492FEDB89    	  4549:                 cmpi.l #$92FEDB89,d4      * Check the data results
00:00004D9C 66FE            	  4550:                 bne.s *
                            	  4551: 
00:00004D9E 0C8500000110    	  4552:                 cmpi.l #$00000110,d5      * Check the Flag results
00:00004DA4 66FE            	  4553:                 bne.s *
                            	  4554: 
                            	  4555: 
00:00004DA6 4E75            	  4556:                 rts
                            	  4557: 
                            	  4558: 
                            	  4559: 
                            	  4560: *-----------------------------------------------------------
                            	  4561: *-----------------------------------------------------------
                            	  4562: * OPCODE : DIVS
                            	  4563: *-----------------------------------------------------------
                            	  4564: *-----------------------------------------------------------
                            	  4565: 
                            	  4566: op_DIVS:
                            	  4567: 
00:00004DA8 203CA5A5A5A5    	  4568: 	move.l #$a5a5a5a5,d0        * Initial Numerator
00:00004DAE 223C00005A5A    	  4569: 	move.l #$00005a5a,d1        * Initial Divisor
00:00004DB4 243CA5A5A5A5    	  4570: 	move.l #$a5a5a5a5,d2
00:00004DBA 7600            	  4571: 	moveq  #$00000000,d3
00:00004DBC 7800            	  4572: 	moveq  #$00000000,d4        * Cumulative data results
00:00004DBE 7A00            	  4573: 	moveq  #$00000000,d5       * Cumulative flag results
00:00004DC0 7C0E            	  4574: 	move.l #$0000000E,d6       * Inner loop counter
00:00004DC2 7E1E            	  4575: 	move.l #$0000001E,d7       * Outer loop counter
                            	  4576: 
                            	  4577: DIVS_OUTER1:
00:00004DC4 81C1            	  4578: 	divs d1,d0               * !! Easy68K C not always cleared
00:00004DC6 40C3            	  4579: 	move.w SR,d3
00:00004DC8 02830000000C    	  4580: 	andi.l #$0C,d3            * Isolate flags
00:00004DCE DA83            	  4581: 	add.l d3,d5               * Copy flag results into accumulator
00:00004DD0 D880            	  4582: 	add.l d0,d4               * Copy data results into data accumulator
00:00004DD2 E289            	  4583: 	lsr.l #$1,d1
                            	  4584: 
00:00004DD4 51CEFFEE        	  4585: 	dbf d6,DIVS_OUTER1
00:00004DD8 E28A            	  4586: 	lsr.l #$1,d2
00:00004DDA 2002            	  4587: 	move.l d2,d0
00:00004DDC 223C00005A5A    	  4588: 	move.l #$00005a5a,d1       * Initial Divisor
00:00004DE2 7C0E            	  4589: 	move.l #$0000000E,d6       * Inner loop counter
00:00004DE4 51CFFFDE        	  4590: 	dbf d7,DIVS_OUTER1
                            	  4591: 
00:00004DE8 0C844EC5D057    	  4592: 	cmpi.l #$4EC5D057,d4      * Check the data results
00:00004DEE 66FE            	  4593: 	bne.s *
                            	  4594: 
00:00004DF0 0C8500000038    	  4595: 	cmpi.l #$00000038,d5      * Check the Flag results
00:00004DF6 66FE            	  4596: 	bne.s *
00:00004DF8 4E75            	  4597: 	rts
                            	  4598: 
                            	  4599: 
                            	  4600: *-----------------------------------------------------------
                            	  4601: *-----------------------------------------------------------
                            	  4602: * OPCODE : OR
                            	  4603: *-----------------------------------------------------------
                            	  4604: *-----------------------------------------------------------
                            	  4605: 
                            	  4606: op_OR:
                            	  4607: 
                            	  4608: *  * <EA> to Register
                            	  4609: 
00:00004DFA 203CA5A5A5A5    	  4610:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00004E00 223C8167E123    	  4611:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00004E06 243CA5A5A5A5    	  4612:                 move.l #$a5a5a5a5,d2
00:00004E0C 7600            	  4613:                 moveq  #$00000000,d3
00:00004E0E 7800            	  4614:                 moveq  #$00000000,d4       * Cumulative data results
00:00004E10 7A00            	  4615:                 moveq  #$00000000,d5       * Cumulative flag results
00:00004E12 7C1E            	  4616:                 move.l #$0000001E,d6       * Inner loop counter
00:00004E14 7E1E            	  4617:                 move.l #$0000001E,d7       * Outer loop counter
00:00004E16 307C0100        	  4618:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4619: 
                            	  4620: 
                            	  4621: OR_OUTER1:
                            	  4622: 
                            	  4623: *     BYTE
00:00004E1A 2081            	  4624:                 move.l d1,(a0)
00:00004E1C 8010            	  4625:                 or.b (a0),d0
00:00004E1E 40C3            	  4626:                 move.w SR,d3
00:00004E20 02830000000C    	  4627:                 andi.l #$0C,d3            * Isolate flags
00:00004E26 DA83            	  4628:                 add.l d3,d5               * Copy flag results into accumulator
00:00004E28 D880            	  4629:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4630: 
                            	  4631: *     WORD
00:00004E2A 2081            	  4632:                 move.l d1,(a0)
00:00004E2C 8050            	  4633:                 or.w (a0),d0
00:00004E2E 40C3            	  4634:                 move.w SR,d3
00:00004E30 02830000000C    	  4635:                 andi.l #$0C,d3            * Isolate flags
00:00004E36 DA83            	  4636:                 add.l d3,d5               * Copy flag results into accumulator
00:00004E38 D880            	  4637:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4638: 
                            	  4639: *     LONG
00:00004E3A 2081            	  4640:                 move.l d1,(a0)
00:00004E3C 8090            	  4641:                 or.l (a0),d0
00:00004E3E 40C3            	  4642:                 move.w SR,d3
00:00004E40 02830000000F    	  4643:                 andi.l #$0F,d3            * Isolate flags
00:00004E46 DA83            	  4644:                 add.l d3,d5               * Copy flag results into accumulator
00:00004E48 D880            	  4645:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4646: 
                            	  4647: 
00:00004E4A E289            	  4648:                 lsr.l #$1,d1
00:00004E4C 51CEFFCC        	  4649:                 dbf d6,OR_OUTER1
00:00004E50 E28A            	  4650:                 lsr.l #$1,d2
00:00004E52 223C8167E123    	  4651:                 move.l #$8167E123,d1       * Initial Data-Y
00:00004E58 7C1E            	  4652:                 move.l #$0000001E,d6       * Inner loop counter
00:00004E5A 51CFFFBE        	  4653:                 dbf d7,OR_OUTER1
                            	  4654: 
00:00004E5E 0C8476EAC803    	  4655:                 cmpi.l #$76EAC803,d4      * Check the data results
00:00004E64 66FE            	  4656:                 bne.s *
00:00004E66 0C8500005A18    	  4657:                 cmpi.l #$00005A18,d5      * Check the Flag results
00:00004E6C 66FE            	  4658:                 bne.s *
                            	  4659: 
                            	  4660: 
                            	  4661: *  * Register to <EA>
                            	  4662: 
00:00004E6E 203C86738374    	  4663:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:00004E74 223CFC55F2FE    	  4664:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:00004E7A 243C86738374    	  4665:                 move.l #$86738374,d2
00:00004E80 7600            	  4666:                 moveq  #$00000000,d3
00:00004E82 7800            	  4667:                 moveq  #$00000000,d4       * Cumulative data results
00:00004E84 7A00            	  4668:                 moveq  #$00000000,d5       * Cumulative flag results
00:00004E86 7C1E            	  4669:                 move.l #$0000001E,d6       * Inner loop counter
00:00004E88 7E1D            	  4670:                 move.l #$0000001D,d7       * Outer loop counter
00:00004E8A 307C0100        	  4671:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4672: 
                            	  4673: 
                            	  4674: OR_OUTER2:
                            	  4675: 
                            	  4676: *     BYTE
00:00004E8E 2080            	  4677:                 move.l d0,(a0)
00:00004E90 8310            	  4678:                 or.b d1,(a0)
00:00004E92 40C3            	  4679:                 move.w SR,d3
00:00004E94 02830000000C    	  4680:                 andi.l #$0C,d3            * Isolate flags
00:00004E9A DA83            	  4681:                 add.l d3,d5               * Copy flag results into accumulator
00:00004E9C D890            	  4682:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4683: 
                            	  4684: *     WORD
00:00004E9E 2080            	  4685:                 move.l d0,(a0)
00:00004EA0 8350            	  4686:                 or.w d1,(a0)
00:00004EA2 40C3            	  4687:                 move.w SR,d3
00:00004EA4 02830000000C    	  4688:                 andi.l #$0C,d3            * Isolate flags
00:00004EAA DA83            	  4689:                 add.l d3,d5               * Copy flag results into accumulator
00:00004EAC D890            	  4690:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4691: 
                            	  4692: *     LONG
00:00004EAE 2080            	  4693:                 move.l d0,(a0)
00:00004EB0 8390            	  4694:                 or.l d1,(a0)
00:00004EB2 40C3            	  4695:                 move.w SR,d3
00:00004EB4 02830000000F    	  4696:                 andi.l #$0F,d3            * Isolate flags
00:00004EBA DA83            	  4697:                 add.l d3,d5               * Copy flag results into accumulator
00:00004EBC D890            	  4698:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4699: 
                            	  4700: 
00:00004EBE E289            	  4701:                 lsr.l #$1,d1
00:00004EC0 51CEFFCC        	  4702:                 dbf d6,OR_OUTER2
00:00004EC4 E28A            	  4703:                 lsr.l #$1,d2
00:00004EC6 223C8167E123    	  4704:                 move.l #$8167E123,d1       * Initial Data-Y
00:00004ECC 7C1E            	  4705:                 move.l #$0000001E,d6       * Inner loop counter
00:00004ECE 51CFFFBE        	  4706:                 dbf d7,OR_OUTER2
                            	  4707: 
00:00004ED2 0C84FA82B9E4    	  4708:                 cmpi.l #$FA82B9E4,d4      * Check the data results
00:00004ED8 66FE            	  4709:                 bne.s *
00:00004EDA 0C8500005730    	  4710:                 cmpi.l #$00005730,d5      * Check the Flag results
00:00004EE0 66FE            	  4711:                 bne.s *
                            	  4712: 
                            	  4713: 
00:00004EE2 4E75            	  4714:                 rts
                            	  4715: 
                            	  4716: 
                            	  4717: 
                            	  4718: *-----------------------------------------------------------
                            	  4719: *-----------------------------------------------------------
                            	  4720: * OPCODE : AND
                            	  4721: *-----------------------------------------------------------
                            	  4722: *-----------------------------------------------------------
                            	  4723: 
                            	  4724: op_AND:
                            	  4725: 
                            	  4726: *  * <EA> to Register
                            	  4727: 
00:00004EE4 203CA5A5A5A5    	  4728:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00004EEA 223C8167E123    	  4729:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00004EF0 243CA5A5A5A5    	  4730:                 move.l #$a5a5a5a5,d2
00:00004EF6 7600            	  4731:                 moveq  #$00000000,d3
00:00004EF8 7800            	  4732:                 moveq  #$00000000,d4       * Cumulative data results
00:00004EFA 7A00            	  4733:                 moveq  #$00000000,d5       * Cumulative flag results
00:00004EFC 7C1E            	  4734:                 move.l #$0000001E,d6       * Inner loop counter
00:00004EFE 7E1E            	  4735:                 move.l #$0000001E,d7       * Outer loop counter
00:00004F00 307C0100        	  4736:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4737: 
                            	  4738: 
                            	  4739: AND_OUTER1:
                            	  4740: 
                            	  4741: *     BYTE
00:00004F04 2081            	  4742:                 move.l d1,(a0)
00:00004F06 C010            	  4743:                 and.b (a0),d0
00:00004F08 40C3            	  4744:                 move.w sr,d3
00:00004F0A 02830000000C    	  4745:                 andi.l #$0C,d3            * Isolate flags
00:00004F10 DA83            	  4746:                 add.l d3,d5               * Copy flag results into accumulator
00:00004F12 D880            	  4747:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4748: 
                            	  4749: *     WORD
00:00004F14 2081            	  4750:                 move.l d1,(a0)
00:00004F16 C050            	  4751:                 and.w (a0),d0
00:00004F18 40C3            	  4752:                 move.w sr,d3
00:00004F1A 02830000000C    	  4753:                 andi.l #$0C,d3            * Isolate flags
00:00004F20 DA83            	  4754:                 add.l d3,d5               * Copy flag results into accumulator
00:00004F22 D880            	  4755:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4756: 
                            	  4757: *     LONG
00:00004F24 2081            	  4758:                 move.l d1,(a0)
00:00004F26 C090            	  4759:                 and.l (a0),d0
00:00004F28 40C3            	  4760:                 move.w sr,d3
00:00004F2A 02830000000F    	  4761:                 andi.l #$0F,d3            * Isolate flags
00:00004F30 DA83            	  4762:                 add.l d3,d5               * Copy flag results into accumulator
00:00004F32 D880            	  4763:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4764: 
                            	  4765: 
00:00004F34 E289            	  4766:                 lsr.l #$1,d1
00:00004F36 51CEFFCC        	  4767:                 dbf d6,AND_OUTER1
00:00004F3A E28A            	  4768:                 lsr.l #$1,d2
00:00004F3C 223C8167E123    	  4769:                 move.l #$8167E123,d1       * Initial Data-Y
00:00004F42 7C1E            	  4770:                 move.l #$0000001E,d6       * Inner loop counter
00:00004F44 51CFFFBE        	  4771:                 dbf d7,AND_OUTER1
                            	  4772: 
00:00004F48 0C84CF212883    	  4773:                 cmpi.l #$CF212883,d4      * Check the data results
00:00004F4E 66FE            	  4774:                 bne.s *
00:00004F50 0C8500002D10    	  4775:                 cmpi.l #$00002D10,d5      * Check the Flag results
00:00004F56 66FE            	  4776:                 bne.s *
                            	  4777: 
                            	  4778: 
                            	  4779: *  * Register to <EA>
                            	  4780: 
00:00004F58 203C86738374    	  4781:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:00004F5E 223CFC55F2FE    	  4782:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:00004F64 243C86738374    	  4783:                 move.l #$86738374,d2
00:00004F6A 7600            	  4784:                 moveq  #$00000000,d3
00:00004F6C 7800            	  4785:                 moveq  #$00000000,d4       * Cumulative data results
00:00004F6E 7A00            	  4786:                 moveq  #$00000000,d5       * Cumulative flag results
00:00004F70 7C1E            	  4787:                 move.l #$0000001E,d6       * Inner loop counter
00:00004F72 7E1D            	  4788:                 move.l #$0000001D,d7       * Outer loop counter
00:00004F74 307C0100        	  4789:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4790: 
                            	  4791: 
                            	  4792: AND_OUTER2:
                            	  4793: 
                            	  4794: *     BYTE
00:00004F78 2080            	  4795:                 move.l d0,(a0)
00:00004F7A C310            	  4796:                 and.b d1,(a0)
00:00004F7C 40C3            	  4797:                 move.w sr,d3
00:00004F7E 02830000000C    	  4798:                 andi.l #$0C,d3            * Isolate flags
00:00004F84 DA83            	  4799:                 add.l d3,d5               * Copy flag results into accumulator
00:00004F86 D890            	  4800:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4801: 
                            	  4802: *     WORD
00:00004F88 2080            	  4803:                 move.l d0,(a0)
00:00004F8A C350            	  4804:                 and.w d1,(a0)
00:00004F8C 40C3            	  4805:                 move.w sr,d3
00:00004F8E 02830000000C    	  4806:                 andi.l #$0C,d3            * Isolate flags
00:00004F94 DA83            	  4807:                 add.l d3,d5               * Copy flag results into accumulator
00:00004F96 D890            	  4808:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4809: 
                            	  4810: *     LONG
00:00004F98 2080            	  4811:                 move.l d0,(a0)
00:00004F9A C390            	  4812:                 and.l d1,(a0)
00:00004F9C 40C3            	  4813:                 move.w sr,d3
00:00004F9E 02830000000F    	  4814:                 andi.l #$0F,d3            * Isolate flags
00:00004FA4 DA83            	  4815:                 add.l d3,d5               * Copy flag results into accumulator
00:00004FA6 D890            	  4816:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4817: 
                            	  4818: 
00:00004FA8 E289            	  4819:                 lsr.l #$1,d1
00:00004FAA 51CEFFCC        	  4820:                 dbf d6,AND_OUTER2
00:00004FAE E28A            	  4821:                 lsr.l #$1,d2
00:00004FB0 223C8167E123    	  4822:                 move.l #$8167E123,d1       * Initial Data-Y
00:00004FB6 7C1E            	  4823:                 move.l #$0000001E,d6       * Inner loop counter
00:00004FB8 51CFFFBE        	  4824:                 dbf d7,AND_OUTER2
                            	  4825: 
00:00004FBC 0C844A3DE544    	  4826:                 cmpi.l #$4A3DE544,d4      * Check the data results
00:00004FC2 66FE            	  4827:                 bne.s *
00:00004FC4 0C85000018E8    	  4828:                 cmpi.l #$000018E8,d5      * Check the Flag results
00:00004FCA 66FE            	  4829:                 bne.s *
                            	  4830: 
                            	  4831: 
00:00004FCC 4E75            	  4832:                 rts
                            	  4833: 
                            	  4834: 
                            	  4835: 
                            	  4836: *-----------------------------------------------------------
                            	  4837: *-----------------------------------------------------------
                            	  4838: * OPCODE : EOR
                            	  4839: *-----------------------------------------------------------
                            	  4840: *-----------------------------------------------------------
                            	  4841: 
                            	  4842: op_EOR:
                            	  4843: 
                            	  4844: *  * Register to <EA>
                            	  4845: 
00:00004FCE 203C86738374    	  4846:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:00004FD4 223CFC55F2FE    	  4847:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:00004FDA 243C86738374    	  4848:                 move.l #$86738374,d2
00:00004FE0 7600            	  4849:                 moveq  #$00000000,d3
00:00004FE2 7800            	  4850:                 moveq  #$00000000,d4       * Cumulative data results
00:00004FE4 7A00            	  4851:                 moveq  #$00000000,d5       * Cumulative flag results
00:00004FE6 7C1E            	  4852:                 move.l #$0000001E,d6       * Inner loop counter
00:00004FE8 7E1D            	  4853:                 move.l #$0000001D,d7       * Outer loop counter
00:00004FEA 307C0100        	  4854:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4855: 
                            	  4856: 
                            	  4857: EOR_OUTER2:
                            	  4858: 
                            	  4859: *     BYTE
00:00004FEE 2080            	  4860:                 move.l d0,(a0)
00:00004FF0 B310            	  4861:                 eor.b d1,(a0)
00:00004FF2 40C3            	  4862:                 move.w sr,d3
00:00004FF4 02830000000C    	  4863:                 andi.l #$0C,d3            * Isolate flags
00:00004FFA DA83            	  4864:                 add.l d3,d5               * Copy flag results into accumulator
00:00004FFC D890            	  4865:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4866: 
                            	  4867: *     WORD
00:00004FFE 2080            	  4868:                 move.l d0,(a0)
00:00005000 B350            	  4869:                 eor.w d1,(a0)
00:00005002 40C3            	  4870:                 move.w sr,d3
00:00005004 02830000000C    	  4871:                 andi.l #$0C,d3            * Isolate flags
00:0000500A DA83            	  4872:                 add.l d3,d5               * Copy flag results into accumulator
00:0000500C D890            	  4873:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4874: 
                            	  4875: *     LONG
00:0000500E 2080            	  4876:                 move.l d0,(a0)
00:00005010 B390            	  4877:                 eor.l d1,(a0)
00:00005012 40C3            	  4878:                 move.w sr,d3
00:00005014 02830000000F    	  4879:                 andi.l #$0F,d3            * Isolate flags
00:0000501A DA83            	  4880:                 add.l d3,d5               * Copy flag results into accumulator
00:0000501C D890            	  4881:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  4882: 
                            	  4883: 
00:0000501E E289            	  4884:                 lsr.l #$1,d1
00:00005020 51CEFFCC        	  4885:                 dbf d6,EOR_OUTER2
00:00005024 E28A            	  4886:                 lsr.l #$1,d2
00:00005026 223C8167E123    	  4887:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000502C 7C1E            	  4888:                 move.l #$0000001E,d6       * Inner loop counter
00:0000502E 51CFFFBE        	  4889:                 dbf d7,EOR_OUTER2
                            	  4890: 
00:00005032 0C8455C5EB70    	  4891:                 cmpi.l #$55C5EB70,d4      * Check the data results
00:00005038 66FE            	  4892:                 bne.s *
00:0000503A 0C8500004430    	  4893:                 cmpi.l #$00004430,d5      * Check the Flag results
00:00005040 66FE            	  4894:                 bne.s *
                            	  4895: 
                            	  4896: 
00:00005042 4E75            	  4897:                 rts
                            	  4898: 
                            	  4899: 
                            	  4900: *-----------------------------------------------------------
                            	  4901: *-----------------------------------------------------------
                            	  4902: * OPCODE : CMP
                            	  4903: *-----------------------------------------------------------
                            	  4904: *-----------------------------------------------------------
                            	  4905: 
                            	  4906: op_CMP:
                            	  4907: 
                            	  4908: 
                            	  4909: *  * <EA> to Register
                            	  4910: 
00:00005044 203CA5A5A5A5    	  4911:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:0000504A 223C8167E123    	  4912:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:00005050 243CA5A5A5A5    	  4913:                 move.l #$a5a5a5a5,d2
00:00005056 7600            	  4914:                 moveq  #$00000000,d3
00:00005058 7800            	  4915:                 moveq  #$00000000,d4       * Cumulative data results
00:0000505A 7A00            	  4916:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000505C 7C1E            	  4917:                 move.l #$0000001E,d6       * Inner loop counter
00:0000505E 7E1E            	  4918:                 move.l #$0000001E,d7       * Outer loop counter
00:00005060 307C0100        	  4919:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  4920: 
                            	  4921: 
                            	  4922: CMP_OUTER1:
                            	  4923: 
                            	  4924: *     BYTE
00:00005064 2081            	  4925:                 move.l d1,(a0)
00:00005066 B010            	  4926:                 cmp.b (a0),d0
00:00005068 40C3            	  4927:                 move.w sr,d3
00:0000506A 02830000000F    	  4928:                 andi.l #$0F,d3            * Isolate flags
00:00005070 DA83            	  4929:                 add.l d3,d5               * Copy flag results into accumulator
00:00005072 D880            	  4930:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4931: 
                            	  4932: *     WORD
00:00005074 2081            	  4933:                 move.l d1,(a0)
00:00005076 B050            	  4934:                 cmp.w (a0),d0
00:00005078 40C3            	  4935:                 move.w sr,d3
00:0000507A 02830000000F    	  4936:                 andi.l #$0F,d3            * Isolate flags
00:00005080 DA83            	  4937:                 add.l d3,d5               * Copy flag results into accumulator
00:00005082 D880            	  4938:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4939: 
                            	  4940: *     LONG
00:00005084 2081            	  4941:                 move.l d1,(a0)
00:00005086 B090            	  4942:                 cmp.l (a0),d0
00:00005088 40C3            	  4943:                 move.w sr,d3
00:0000508A 02830000000F    	  4944:                 andi.l #$0F,d3            * Isolate flags
00:00005090 DA83            	  4945:                 add.l d3,d5               * Copy flag results into accumulator
00:00005092 D880            	  4946:                 add.l d0,d4               * Copy data results into data accumulator
                            	  4947: 
                            	  4948: 
00:00005094 E289            	  4949:                 lsr.l #$1,d1
00:00005096 51CEFFCC        	  4950:                 dbf d6,CMP_OUTER1
00:0000509A E28A            	  4951:                 lsr.l #$1,d2
00:0000509C 223C8167E123    	  4952:                 move.l #$8167E123,d1       * Initial Data-Y
00:000050A2 7C1E            	  4953:                 move.l #$0000001E,d6       * Inner loop counter
00:000050A4 51CFFFBE        	  4954:                 dbf d7,CMP_OUTER1
                            	  4955: 
00:000050A8 0C847878712F    	  4956:                 cmpi.l #$7878712F,d4      * Check the data results
00:000050AE 66FE            	  4957:                 bne.s *
00:000050B0 0C8500005502    	  4958:                 cmpi.l #$00005502,d5      * Check the Flag results
00:000050B6 66FE            	  4959:                 bne.s *
                            	  4960: 
                            	  4961: 
                            	  4962: 
00:000050B8 4E75            	  4963:                 rts
                            	  4964: 
                            	  4965: 
                            	  4966: *-----------------------------------------------------------
                            	  4967: *-----------------------------------------------------------
                            	  4968: * OPCODE : CMPA
                            	  4969: *-----------------------------------------------------------
                            	  4970: *-----------------------------------------------------------
                            	  4971: 
                            	  4972: op_CMPA:
                            	  4973: 
                            	  4974: 
                            	  4975: *  * <EA> to Register
                            	  4976: 
00:000050BA 207CA5A5A5A5    	  4977:                 move.l #$a5a5a5a5,a0       * Initial Data-X  Inner loop
00:000050C0 223C8167E123    	  4978:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:000050C6 243CA5A5A5A5    	  4979:                 move.l #$a5a5a5a5,d2
00:000050CC 7600            	  4980:                 moveq  #$00000000,d3
00:000050CE 7800            	  4981:                 moveq  #$00000000,d4       * Cumulative data results
00:000050D0 7A00            	  4982:                 moveq  #$00000000,d5       * Cumulative flag results
00:000050D2 7C1E            	  4983:                 move.l #$0000001E,d6       * Inner loop counter
00:000050D4 7E1E            	  4984:                 move.l #$0000001E,d7       * Outer loop counter
00:000050D6 327C0100        	  4985:                 move.l #$00000100,a1       * Address for memory EA operations
                            	  4986: 
                            	  4987: 
                            	  4988: CMPA_OUTER1:
                            	  4989: 
                            	  4990: 
                            	  4991: *     WORD
00:000050DA 2281            	  4992:                 move.l d1,(a1)
00:000050DC B0D1            	  4993:                 cmpa.w (a1),a0
00:000050DE 40C3            	  4994:                 move.w sr,d3
00:000050E0 02830000000F    	  4995:                 andi.l #$0F,d3            * Isolate flags
00:000050E6 DA83            	  4996:                 add.l d3,d5               * Copy flag results into accumulator
00:000050E8 D888            	  4997:                 add.l a0,d4               * Copy data results into data accumulator
                            	  4998: 
                            	  4999: *     LONG
00:000050EA 2281            	  5000:                 move.l d1,(a1)
00:000050EC B1D1            	  5001:                 cmpa.l (a1),a0
00:000050EE 40C3            	  5002:                 move.w sr,d3
00:000050F0 02830000000F    	  5003:                 andi.l #$0F,d3            * Isolate flags
00:000050F6 DA83            	  5004:                 add.l d3,d5               * Copy flag results into accumulator
00:000050F8 D888            	  5005:                 add.l a0,d4               * Copy data results into data accumulator
                            	  5006: 
                            	  5007: 
00:000050FA E289            	  5008:                 lsr.l #$1,d1
00:000050FC 51CEFFDC        	  5009:                 dbf d6,CMPA_OUTER1
00:00005100 E28A            	  5010:                 lsr.l #$1,d2
00:00005102 223C8167E123    	  5011:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005108 7C1E            	  5012:                 move.l #$0000001E,d6       * Inner loop counter
00:0000510A 51CFFFCE        	  5013:                 dbf d7,CMPA_OUTER1
                            	  5014: 
00:0000510E 0C84A5A5A0CA    	  5015:                 cmpi.l #$a5a5a0ca,d4      * Check the data results
00:00005114 66FE            	  5016:                 bne.s *
00:00005116 0C8500003A7D    	  5017:                 cmpi.l #$00003A7D,d5      * Check the Flag results
00:0000511C 66FE            	  5018:                 bne.s *
                            	  5019: 
                            	  5020: 
00:0000511E 4E75            	  5021:                 rts
                            	  5022: 
                            	  5023: 
                            	  5024: 
                            	  5025: *-----------------------------------------------------------
                            	  5026: *-----------------------------------------------------------
                            	  5027: * OPCODE : CMPM
                            	  5028: *-----------------------------------------------------------
                            	  5029: *-----------------------------------------------------------
                            	  5030: 
                            	  5031: op_CMPM:
                            	  5032: 
00:00005120 307C0100        	  5033:                 move.l #$00000100,a0       * Address for Data-X
00:00005124 327C0200        	  5034:                 move.l #$00000200,a1       * Address for Data-Y
00:00005128 7000            	  5035:                 moveq  #$00000000,d0
00:0000512A 7200            	  5036:                 moveq  #$00000000,d1
00:0000512C 7400            	  5037:                 moveq  #$00000000,d2
                            	  5038: 
00:0000512E 20FC11FF5580    	  5039:                 move.l #$11FF5580,(a0)+   * Populate test data
00:00005134 20FC1111FFFF    	  5040:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:0000513A 20FC33333333    	  5041:                 move.l #$33333333,(a0)+   * Populate test data
00:00005140 20FC44444444    	  5042:                 move.l #$44444444,(a0)+   * Populate test data
                            	  5043: 
00:00005146 22FC80FF337F    	  5044:                 move.l #$80FF337F,(a1)+   * Populate test data
00:0000514C 22FCFFFF1111    	  5045:                 move.l #$FFFF1111,(a1)+   * Populate test data
00:00005152 22FC33333333    	  5046:                 move.l #$33333333,(a1)+   * Populate test data
00:00005158 22FC44444444    	  5047:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5048: 
00:0000515E 307C0100        	  5049:                 move.l #$00000100,a0       * Address for Data-X
00:00005162 327C0200        	  5050:                 move.l #$00000200,a1       * Address for Data-Y
00:00005166 7C0F            	  5051:                 move.l #$0000000F,d6       * Loop counter
                            	  5052: 
00:00005168 B308            	  5053: CMPM_LOOP1:     cmpm.b (a0)+,(a1)+
00:0000516A 40C3            	  5054:                 move.w sr,d3
00:0000516C 02830000000F    	  5055:                 andi.l #$0F,d3            * Isolate flags
00:00005172 D083            	  5056:                 add.l d3,d0               * Copy flag results into accumulator
00:00005174 51CEFFF2        	  5057:                 dbf d6,CMPM_LOOP1
                            	  5058: 
                            	  5059: 
00:00005178 307C0100        	  5060:                 move.l #$00000100,a0       * Address for Data-X
00:0000517C 327C0200        	  5061:                 move.l #$00000200,a1       * Address for Data-Y
00:00005180 7C07            	  5062:                 moveq  #$00000007,d6       * Loop counter
                            	  5063: 
00:00005182 B348            	  5064: CMPM_LOOP2:     cmpm.w (a0)+,(a1)+
00:00005184 40C3            	  5065:                 move.w sr,d3
00:00005186 02830000000F    	  5066:                 andi.l #$0F,d3            * Isolate flags
00:0000518C D283            	  5067:                 add.l d3,d1               * Copy flag results into accumulator
00:0000518E 51CEFFF2        	  5068:                 dbf d6,CMPM_LOOP2
                            	  5069: 
                            	  5070: 
00:00005192 307C0100        	  5071:                 move.l #$00000100,a0       * Address for Data-X
00:00005196 327C0200        	  5072:                 move.l #$00000200,a1       * Address for Data-Y
00:0000519A 7C03            	  5073:                 moveq  #$00000003,d6       * Loop counter
                            	  5074: 
00:0000519C B388            	  5075: CMPM_LOOP3:     cmpm.l (a0)+,(a1)+
00:0000519E 40C3            	  5076:                 move.w sr,d3
00:000051A0 02830000000F    	  5077:                 andi.l #$0F,d3            * Isolate flags
00:000051A6 D483            	  5078:                 add.l d3,d2               * Copy flag results into accumulator
00:000051A8 51CEFFF2        	  5079:                 dbf d6,CMPM_LOOP3
                            	  5080: 
                            	  5081: 
00:000051AC 0C800000004C    	  5082:                 cmpi.l #$0000004C,d0      * Check the data results
00:000051B2 66FE            	  5083:                 bne.s *
00:000051B4 0C8100000024    	  5084:                 cmpi.l #$00000024,d1
00:000051BA 66FE            	  5085:                 bne.s *
00:000051BC 0C8200000012    	  5086:                 cmpi.l #$00000012,d2
00:000051C2 66FE            	  5087:                 bne.s *
                            	  5088: 
00:000051C4 4E75            	  5089:                 rts
                            	  5090: 
                            	  5091: 
                            	  5092: *-----------------------------------------------------------
                            	  5093: *-----------------------------------------------------------
                            	  5094: * OPCODE : ADD
                            	  5095: *-----------------------------------------------------------
                            	  5096: *-----------------------------------------------------------
                            	  5097: 
                            	  5098: op_ADD:
                            	  5099: 
                            	  5100: 
                            	  5101: *  * <EA> to Register
00:000051C6 203CA5A5A5A5    	  5102:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000051CC 223C8167E123    	  5103:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:000051D2 243CA5A5A5A5    	  5104:                 move.l #$a5a5a5a5,d2
00:000051D8 7600            	  5105:                 moveq  #$00000000,d3
00:000051DA 7800            	  5106:                 moveq  #$00000000,d4       * Cumulative data results
00:000051DC 7A00            	  5107:                 moveq  #$00000000,d5       * Cumulative flag results
00:000051DE 7C1E            	  5108:                 move.l #$0000001E,d6       * Inner loop counter
00:000051E0 7E1E            	  5109:                 move.l #$0000001E,d7       * Outer loop counter
00:000051E2 307C0100        	  5110:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5111: 
                            	  5112: 
                            	  5113: ADD_OUTER1:
                            	  5114: 
                            	  5115: *     BYTE
00:000051E6 2081            	  5116:                 move.l d1,(a0)
00:000051E8 D010            	  5117:                 add.b (a0),d0
00:000051EA 40C3            	  5118:                 move.w sr,d3
00:000051EC 02830000001F    	  5119:                 andi.l #$1F,d3            * Isolate flags
00:000051F2 DA83            	  5120:                 add.l d3,d5               * Copy flag results into accumulator
00:000051F4 D880            	  5121:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5122: 
                            	  5123: *     WORD
00:000051F6 2081            	  5124:                 move.l d1,(a0)
00:000051F8 D050            	  5125:                 add.w (a0),d0
00:000051FA 40C3            	  5126:                 move.w sr,d3
00:000051FC 02830000000C    	  5127:                 andi.l #$0C,d3            * Isolate flags
00:00005202 DA83            	  5128:                 add.l d3,d5               * Copy flag results into accumulator
00:00005204 D880            	  5129:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5130: 
                            	  5131: *     LONG
00:00005206 2081            	  5132:                 move.l d1,(a0)
00:00005208 D090            	  5133:                 add.l (a0),d0
00:0000520A 40C3            	  5134:                 move.w sr,d3
00:0000520C 02830000000F    	  5135:                 andi.l #$0F,d3            * Isolate flags
00:00005212 DA83            	  5136:                 add.l d3,d5               * Copy flag results into accumulator
00:00005214 D880            	  5137:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5138: 
                            	  5139: 
00:00005216 E299            	  5140:                 ror.l #$1,d1
00:00005218 51CEFFCC        	  5141:                 dbf d6,ADD_OUTER1
00:0000521C E29A            	  5142:                 ror.l #$1,d2
00:0000521E 223C8167E123    	  5143:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005224 7C1E            	  5144:                 move.l #$0000001E,d6       * Inner loop counter
00:00005226 51CFFFBE        	  5145:                 dbf d7,ADD_OUTER1
                            	  5146: 
00:0000522A 0C8423ED428F    	  5147:                 cmpi.l #$23ED428F,d4      * Check the data results
00:00005230 66FE            	  5148:                 bne.s *
00:00005232 0C8500004C96    	  5149:                 cmpi.l #$00004C96,d5      * Check the Flag results
00:00005238 66FE            	  5150:                 bne.s *
                            	  5151: 
                            	  5152: 
                            	  5153: *  * Register to <EA>
00:0000523A 203C86738374    	  5154:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:00005240 223CFC55F2FE    	  5155:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:00005246 243C86738374    	  5156:                 move.l #$86738374,d2
00:0000524C 7600            	  5157:                 moveq  #$00000000,d3
00:0000524E 7800            	  5158:                 moveq  #$00000000,d4       * Cumulative data results
00:00005250 7A00            	  5159:                 moveq  #$00000000,d5       * Cumulative flag results
00:00005252 7C1E            	  5160:                 move.l #$0000001E,d6       * Inner loop counter
00:00005254 7E1D            	  5161:                 move.l #$0000001D,d7       * Outer loop counter
00:00005256 307C0100        	  5162:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5163: 
                            	  5164: 
                            	  5165: ADD_OUTER2:
                            	  5166: 
                            	  5167: *     BYTE
00:0000525A 2080            	  5168:                 move.l d0,(a0)
00:0000525C D310            	  5169:                 add.b d1,(a0)
00:0000525E 40C3            	  5170:                 move.w sr,d3
00:00005260 02830000000C    	  5171:                 andi.l #$0C,d3            * Isolate flags
00:00005266 DA83            	  5172:                 add.l d3,d5               * Copy flag results into accumulator
00:00005268 D890            	  5173:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5174: 
                            	  5175: *     WORD
00:0000526A 2080            	  5176:                 move.l d0,(a0)
00:0000526C D350            	  5177:                 add.w d1,(a0)
00:0000526E 40C3            	  5178:                 move.w sr,d3
00:00005270 02830000001F    	  5179:                 andi.l #$1F,d3            * Isolate flags
00:00005276 DA83            	  5180:                 add.l d3,d5               * Copy flag results into accumulator
00:00005278 D890            	  5181:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5182: 
                            	  5183: *     LONG
00:0000527A 2080            	  5184:                 move.l d0,(a0)
00:0000527C D390            	  5185:                 add.l d1,(a0)
00:0000527E 40C3            	  5186:                 move.w sr,d3
00:00005280 02830000000F    	  5187:                 andi.l #$0F,d3            * Isolate flags
00:00005286 DA83            	  5188:                 add.l d3,d5               * Copy flag results into accumulator
00:00005288 D890            	  5189:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5190: 
                            	  5191: 
00:0000528A E299            	  5192:                 ror.l #$1,d1
00:0000528C 51CEFFCC        	  5193:                 dbf d6,ADD_OUTER2
00:00005290 E29A            	  5194:                 ror.l #$1,d2
00:00005292 223C8167E123    	  5195:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005298 7C1E            	  5196:                 move.l #$0000001E,d6       * Inner loop counter
00:0000529A 51CFFFBE        	  5197:                 dbf d7,ADD_OUTER2
                            	  5198: 
00:0000529E 0C846701B884    	  5199:                 cmpi.l #$6701B884,d4      * Check the data results
00:000052A4 66FE            	  5200:                 bne.s *
00:000052A6 0C8500005467    	  5201:                 cmpi.l #$00005467,d5      * Check the Flag results
00:000052AC 66FE            	  5202:                 bne.s *
                            	  5203: 
00:000052AE 4E75            	  5204:                 rts
                            	  5205: 
                            	  5206: *-----------------------------------------------------------
                            	  5207: *-----------------------------------------------------------
                            	  5208: * OPCODE : SUB
                            	  5209: *-----------------------------------------------------------
                            	  5210: *-----------------------------------------------------------
                            	  5211: 
                            	  5212: op_SUB:
                            	  5213: 
                            	  5214: *  * <EA> to Register
00:000052B0 203CA5A5A5A5    	  5215:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000052B6 223C8167E123    	  5216:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:000052BC 243CA5A5A5A5    	  5217:                 move.l #$a5a5a5a5,d2
00:000052C2 7600            	  5218:                 moveq  #$00000000,d3
00:000052C4 7800            	  5219:                 moveq  #$00000000,d4       * Cumulative data results
00:000052C6 7A00            	  5220:                 moveq  #$00000000,d5       * Cumulative flag results
00:000052C8 7C1E            	  5221:                 move.l #$0000001E,d6       * Inner loop counter
00:000052CA 7E1E            	  5222:                 move.l #$0000001E,d7       * Outer loop counter
00:000052CC 307C0100        	  5223:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5224: 
                            	  5225: 
                            	  5226: SUB_OUTER1:
                            	  5227: 
                            	  5228: *     BYTE
00:000052D0 2081            	  5229:                 move.l d1,(a0)
00:000052D2 9010            	  5230:                 sub.b (a0),d0
00:000052D4 40C3            	  5231:                 move.w sr,d3
00:000052D6 02830000001F    	  5232:                 andi.l #$1F,d3            * Isolate flags
00:000052DC DA83            	  5233:                 add.l d3,d5               * Copy flag results into accumulator
00:000052DE D880            	  5234:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5235: 
                            	  5236: *     WORD
00:000052E0 2081            	  5237:                 move.l d1,(a0)
00:000052E2 9050            	  5238:                 sub.w (a0),d0
00:000052E4 40C3            	  5239:                 move.w sr,d3
00:000052E6 02830000000C    	  5240:                 andi.l #$0C,d3            * Isolate flags
00:000052EC DA83            	  5241:                 add.l d3,d5               * Copy flag results into accumulator
00:000052EE D880            	  5242:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5243: 
                            	  5244: *     LONG
00:000052F0 2081            	  5245:                 move.l d1,(a0)
00:000052F2 9090            	  5246:                 sub.l (a0),d0
00:000052F4 40C3            	  5247:                 move.w sr,d3
00:000052F6 02830000000F    	  5248:                 andi.l #$0F,d3            * Isolate flags
00:000052FC DA83            	  5249:                 add.l d3,d5               * Copy flag results into accumulator
00:000052FE D880            	  5250:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5251: 
                            	  5252: 
00:00005300 E299            	  5253:                 ror.l #$1,d1
00:00005302 51CEFFCC        	  5254:                 dbf d6,SUB_OUTER1
00:00005306 E29A            	  5255:                 ror.l #$1,d2
00:00005308 223C8167E123    	  5256:                 move.l #$8167E123,d1       * Initial Data-Y
00:0000530E 7C1E            	  5257:                 move.l #$0000001E,d6       * Inner loop counter
00:00005310 51CFFFBE        	  5258:                 dbf d7,SUB_OUTER1
                            	  5259: 
00:00005314 0C841A8D14CF    	  5260:                 cmpi.l #$1A8D14CF,d4      * Check the data results
00:0000531A 66FE            	  5261:                 bne.s *
00:0000531C 0C8500004FC4    	  5262:                 cmpi.l #$00004FC4,d5      * Check the Flag results
00:00005322 66FE            	  5263:                 bne.s *
                            	  5264: 
                            	  5265: 
                            	  5266: *  * Register to <EA>
00:00005324 203C86738374    	  5267:                 move.l #$86738374,d0       * Initial Data-X  Inner loop
00:0000532A 223CFC55F2FE    	  5268:                 move.l #$FC55F2FE,d1       * Initial Data-Y  Outer loop
00:00005330 243C86738374    	  5269:                 move.l #$86738374,d2
00:00005336 7600            	  5270:                 moveq  #$00000000,d3
00:00005338 7800            	  5271:                 moveq  #$00000000,d4       * Cumulative data results
00:0000533A 7A00            	  5272:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000533C 7C1E            	  5273:                 move.l #$0000001E,d6       * Inner loop counter
00:0000533E 7E1D            	  5274:                 move.l #$0000001D,d7       * Outer loop counter
00:00005340 307C0100        	  5275:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5276: 
                            	  5277: 
                            	  5278: SUB_OUTER2:
                            	  5279: 
                            	  5280: *     BYTE
00:00005344 2080            	  5281:                 move.l d0,(a0)
00:00005346 9310            	  5282:                 sub.b d1,(a0)
00:00005348 40C3            	  5283:                 move.w sr,d3
00:0000534A 02830000000C    	  5284:                 andi.l #$0C,d3            * Isolate flags
00:00005350 DA83            	  5285:                 add.l d3,d5               * Copy flag results into accumulator
00:00005352 D890            	  5286:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5287: 
                            	  5288: *     WORD
00:00005354 2080            	  5289:                 move.l d0,(a0)
00:00005356 9350            	  5290:                 sub.w d1,(a0)
00:00005358 40C3            	  5291:                 move.w sr,d3
00:0000535A 02830000001F    	  5292:                 andi.l #$1F,d3            * Isolate flags
00:00005360 DA83            	  5293:                 add.l d3,d5               * Copy flag results into accumulator
00:00005362 D890            	  5294:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5295: 
                            	  5296: *     LONG
00:00005364 2080            	  5297:                 move.l d0,(a0)
00:00005366 9390            	  5298:                 sub.l d1,(a0)
00:00005368 40C3            	  5299:                 move.w sr,d3
00:0000536A 02830000000F    	  5300:                 andi.l #$0F,d3            * Isolate flags
00:00005370 DA83            	  5301:                 add.l d3,d5               * Copy flag results into accumulator
00:00005372 D890            	  5302:                 add.l (a0),d4             * Copy data results into data accumulator
                            	  5303: 
                            	  5304: 
00:00005374 E299            	  5305:                 ror.l #$1,d1
00:00005376 51CEFFCC        	  5306:                 dbf d6,SUB_OUTER2
00:0000537A E29A            	  5307:                 ror.l #$1,d2
00:0000537C 223C8167E123    	  5308:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005382 7C1E            	  5309:                 move.l #$0000001E,d6       * Inner loop counter
00:00005384 51CFFFBE        	  5310:                 dbf d7,SUB_OUTER2
                            	  5311: 
00:00005388 0C8436D38BEC    	  5312:                 cmpi.l #$36D38BEC,d4      * Check the data results
00:0000538E 66FE            	  5313:                 bne.s *
00:00005390 0C85000045A5    	  5314:                 cmpi.l #$000045A5,d5      * Check the Flag results
00:00005396 66FE            	  5315:                 bne.s *
                            	  5316: 
                            	  5317: 
                            	  5318: 
                            	  5319: 
00:00005398 4E75            	  5320:                 rts
                            	  5321: 
                            	  5322: 
                            	  5323: 
                            	  5324: *-----------------------------------------------------------
                            	  5325: *-----------------------------------------------------------
                            	  5326: * OPCODE : ADDA
                            	  5327: *-----------------------------------------------------------
                            	  5328: *-----------------------------------------------------------
                            	  5329: 
                            	  5330: op_ADDA:
                            	  5331: 
                            	  5332: *  * <EA> to Register
00:0000539A 203CA5A5A5A5    	  5333:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000053A0 223C8167E123    	  5334:                 move.l #$8167E123,d1
00:000053A6 243CA5A5A5A5    	  5335:                 move.l #$a5a5a5a5,d2
00:000053AC 7600            	  5336:                 moveq  #$00000000,d3
00:000053AE 7800            	  5337:                 moveq  #$00000000,d4       * Cumulative data results
00:000053B0 7A00            	  5338:                 moveq  #$00000000,d5       * Cumulative flag results
00:000053B2 7C1E            	  5339:                 move.l #$0000001E,d6       * Inner loop counter
00:000053B4 7E1E            	  5340:                 move.l #$0000001E,d7       * Outer loop counter
00:000053B6 307C0100        	  5341:                 move.l #$00000100,a0       * Address for memory EA operations
00:000053BA 227C8167E123    	  5342:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5343: 
                            	  5344: ADDA_OUTER1:
                            	  5345: 
                            	  5346: *     WORD
                            	  5347: *                move.l d1,(a0)       * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5348: *                adda.w (a0),a1
                            	  5349: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5350: 
                            	  5351: *     LONG
00:000053C0 2081            	  5352:                 move.l d1,(a0)
00:000053C2 D3D0            	  5353:                 adda.l (a0),a1
00:000053C4 D889            	  5354:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5355: 
00:000053C6 E299            	  5356:                 ror.l #$1,d1
00:000053C8 51CEFFF6        	  5357:                 dbf d6,ADDA_OUTER1
00:000053CC E299            	  5358:                 ror.l #$1,d1
00:000053CE 2241            	  5359:                 move.l d1,a1
00:000053D0 223C8167E123    	  5360:                 move.l #$8167E123,d1       * Initial Data-Y
00:000053D6 7C1E            	  5361:                 move.l #$0000001E,d6       * Inner loop counter
00:000053D8 51CFFFE6        	  5362:                 dbf d7,ADDA_OUTER1
                            	  5363: 
00:000053DC 0C84AC04DB4C    	  5364:                 cmpi.l #$AC04DB4C,d4      * Check the data results
00:000053E2 66FE            	  5365:                 bne.s *
                            	  5366: 
                            	  5367: 
00:000053E4 4E75            	  5368:                 rts
                            	  5369: 
                            	  5370: 
                            	  5371: *-----------------------------------------------------------
                            	  5372: *-----------------------------------------------------------
                            	  5373: * OPCODE : SUBA
                            	  5374: *-----------------------------------------------------------
                            	  5375: *-----------------------------------------------------------
                            	  5376: 
                            	  5377: op_SUBA:
                            	  5378: 
                            	  5379: *  * <EA> to Register
00:000053E6 203CA5A5A5A5    	  5380:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:000053EC 223C8167E123    	  5381:                 move.l #$8167E123,d1
00:000053F2 243CA5A5A5A5    	  5382:                 move.l #$a5a5a5a5,d2
00:000053F8 7600            	  5383:                 moveq  #$00000000,d3
00:000053FA 7800            	  5384:                 moveq  #$00000000,d4       * Cumulative data results
00:000053FC 7A00            	  5385:                 moveq  #$00000000,d5       * Cumulative flag results
00:000053FE 7C1E            	  5386:                 move.l #$0000001E,d6       * Inner loop counter
00:00005400 7E1E            	  5387:                 move.l #$0000001E,d7       * Outer loop counter
00:00005402 307C0100        	  5388:                 move.l #$00000100,a0       * Address for memory EA operations
00:00005406 227C8167E123    	  5389:                 move.l #$8167E123,a1       * Initial Data-Y  Outer loop
                            	  5390: 
                            	  5391: SUBA_OUTER1:
                            	  5392: 
                            	  5393: *     WORD
                            	  5394: *                move.l d1,(a0) * !!! Easy68K is not altering the whole 32-bits of the address register
                            	  5395: *                suba.w (a0),a1
                            	  5396: *                add.l a1,d4               * Copy data results into data accumulator
                            	  5397: 
                            	  5398: *     LONG
00:0000540C 2081            	  5399:                 move.l d1,(a0)
00:0000540E 93D0            	  5400:                 suba.l (a0),a1
00:00005410 D889            	  5401:                 add.l a1,d4               * Copy data results into data accumulator
                            	  5402: 
00:00005412 E299            	  5403:                 ror.l #$1,d1
00:00005414 51CEFFF6        	  5404:                 dbf d6,SUBA_OUTER1
00:00005418 E299            	  5405:                 ror.l #$1,d1
00:0000541A 2241            	  5406:                 move.l d1,a1
00:0000541C 223C8167E123    	  5407:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005422 7C1E            	  5408:                 move.l #$0000001E,d6       * Inner loop counter
00:00005424 51CFFFE6        	  5409:                 dbf d7,SUBA_OUTER1
                            	  5410: 
00:00005428 0C84E1E36D7A    	  5411:                 cmpi.l #$E1E36D7A,d4      * Check the data results
00:0000542E 66FE            	  5412:                 bne.s *
                            	  5413: 
                            	  5414: 
00:00005430 4E75            	  5415:                 rts
                            	  5416: 
                            	  5417: 
                            	  5418: 
                            	  5419: *-----------------------------------------------------------
                            	  5420: *-----------------------------------------------------------
                            	  5421: * OPCODE : ADDX
                            	  5422: *-----------------------------------------------------------
                            	  5423: *-----------------------------------------------------------
                            	  5424: 
                            	  5425: op_ADDX:
                            	  5426: 
                            	  5427: 
                            	  5428: *  * Register to Register
00:00005432 203CA5A5A5A5    	  5429:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00005438 223C8167E123    	  5430:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:0000543E 243CA5A5A5A5    	  5431:                 move.l #$a5a5a5a5,d2
00:00005444 7600            	  5432:                 moveq  #$00000000,d3
00:00005446 7800            	  5433:                 moveq  #$00000000,d4       * Cumulative data results
00:00005448 7A00            	  5434:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000544A 7C1E            	  5435:                 move.l #$0000001E,d6       * Inner loop counter
00:0000544C 7E1E            	  5436:                 move.l #$0000001E,d7       * Outer loop counter
00:0000544E 307C0100        	  5437:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5438: 
                            	  5439: 
                            	  5440: ADDX_OUTER1:
                            	  5441: 
                            	  5442: *     BYTE
00:00005452 2002            	  5443:                 move.l d2,d0
00:00005454 D101            	  5444:                 addx.b d1,d0
00:00005456 40C3            	  5445:                 move.w sr,d3
00:00005458 02830000001F    	  5446:                 andi.l #$1F,d3            * Isolate flags
00:0000545E DA83            	  5447:                 add.l d3,d5               * Copy flag results into accumulator
00:00005460 D880            	  5448:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5449: 
                            	  5450: *     WORD
00:00005462 2002            	  5451:                 move.l d2,d0
00:00005464 D141            	  5452:                 addx.w d1,d0
00:00005466 40C3            	  5453:                 move.w sr,d3
00:00005468 02830000001F    	  5454:                 andi.l #$1F,d3            * Isolate flags
00:0000546E DA83            	  5455:                 add.l d3,d5               * Copy flag results into accumulator
00:00005470 D880            	  5456:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5457: 
                            	  5458: *     LONG
00:00005472 2002            	  5459:                 move.l d2,d0
00:00005474 D181            	  5460:                 addx.l d1,d0
00:00005476 40C3            	  5461:                 move.w sr,d3
00:00005478 02830000001F    	  5462:                 andi.l #$1F,d3            * Isolate flags
00:0000547E DA83            	  5463:                 add.l d3,d5               * Copy flag results into accumulator
00:00005480 D880            	  5464:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5465: 
00:00005482 E299            	  5466:                 ror.l #$1,d1
00:00005484 51CEFFCC        	  5467:                 dbf d6,ADDX_OUTER1
00:00005488 E29A            	  5468:                 ror.l #$1,d2
00:0000548A 223C8167E123    	  5469:                 move.l #$8167E123,d1       * Initial Data-Y
00:00005490 7C1E            	  5470:                 move.l #$0000001E,d6       * Inner loop counter
00:00005492 51CFFFBE        	  5471:                 dbf d7,ADDX_OUTER1
                            	  5472: 
00:00005496 0C844E96A4D9    	  5473:                 cmpi.l #$4E96A4D9,d4      * Check the data results
00:0000549C 66FE            	  5474:                 bne.s *
00:0000549E 0C85000085CD    	  5475:                 cmpi.l #$000085CD,d5      * Check the Flag results
00:000054A4 66FE            	  5476:                 bne.s *
                            	  5477: 
                            	  5478: 
                            	  5479: 
                            	  5480: *     -(An),-(An)
                            	  5481: 
00:000054A6 7000            	  5482:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
00:000054A8 7200            	  5483:                 moveq  #$00000000,d1
00:000054AA 7400            	  5484:                 moveq  #$00000000,d2
00:000054AC 307C0100        	  5485:                 move.l #$00000100,a0       * Address for Data-X
00:000054B0 327C0200        	  5486:                 move.l #$00000200,a1       * Address for Data-Y
00:000054B4 20FC11FF5580    	  5487:                 move.l #$11FF5580,(a0)+   * Populate test data
00:000054BA 20FC1111FFFF    	  5488:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:000054C0 20FC33333333    	  5489:                 move.l #$33333333,(a0)+   * Populate test data
00:000054C6 20FC44444444    	  5490:                 move.l #$44444444,(a0)+   * Populate test data
00:000054CC 22FC80FF337F    	  5491:                 move.l #$80FF337F,(a1)+   * Populate test data
00:000054D2 22FCFFFF1111    	  5492:                 move.l #$FFFF1111,(a1)+   * Populate test data
00:000054D8 22FC33333333    	  5493:                 move.l #$33333333,(a1)+   * Populate test data
00:000054DE 22FC44444444    	  5494:                 move.l #$44444444,(a1)+   * Populate test data
                            	  5495: 
                            	  5496: 
00:000054E4 7C0F            	  5497:                 move.l #$0000000F,d6       * Loop counter
                            	  5498: 
00:000054E6 D308            	  5499: ADDX_LOOP3:     addx.b -(a0),-(a1)
00:000054E8 40C3            	  5500:                 move.w sr,d3
00:000054EA 02830000000F    	  5501:                 andi.l #$0F,d3            * Isolate flags
00:000054F0 D083            	  5502:                 add.l d3,d0               * Copy flag results into accumulator
00:000054F2 D211            	  5503:                 add.b (a1),d1
00:000054F4 51CEFFF0        	  5504:                 dbf d6,ADDX_LOOP3
                            	  5505: 
                            	  5506: 
00:000054F8 307C0110        	  5507:                 move.l #$00000110,a0       * Address for Data-X
00:000054FC 327C0210        	  5508:                 move.l #$00000210,a1       * Address for Data-Y
00:00005500 7C07            	  5509:                 moveq  #$00000007,d6       * Loop counter
                            	  5510: 
00:00005502 D348            	  5511: ADDX_LOOP4:     addx.w -(a0),-(a1)
00:00005504 40C3            	  5512:                 move.w sr,d3
00:00005506 02830000000F    	  5513:                 andi.l #$0F,d3            * Isolate flags
00:0000550C D083            	  5514:                 add.l d3,d0               * Copy flag results into accumulator
00:0000550E D251            	  5515:                 add.w (a1),d1
00:00005510 51CEFFF0        	  5516:                 dbf d6,ADDX_LOOP4
                            	  5517: 
                            	  5518: 
00:00005514 307C0110        	  5519:                 move.l #$00000110,a0       * Address for Data-X
00:00005518 327C0210        	  5520:                 move.l #$00000210,a1       * Address for Data-Y
00:0000551C 7C03            	  5521:                 moveq  #$00000003,d6       * Loop counter
                            	  5522: 
00:0000551E D388            	  5523: ADDX_LOOP5:     addx.l -(a0),-(a1)
00:00005520 40C3            	  5524:                 move.w sr,d3
00:00005522 02830000000F    	  5525:                 andi.l #$0F,d3            * Isolate flags
00:00005528 D083            	  5526:                 add.l d3,d0               * Copy flag results into accumulator
00:0000552A D291            	  5527:                 add.l (a1),d1
00:0000552C 51CEFFF0        	  5528:                 dbf d6,ADDX_LOOP5
                            	  5529: 
                            	  5530: 
00:00005530 0C8000000095    	  5531:                 cmpi.l #$00000095,d0      * Check the flag results
00:00005536 66FE            	  5532:                 bne.s *
00:00005538 0C81C812A682    	  5533:                 cmpi.l #$C812A682,d1      * Check the data results
00:0000553E 66FE            	  5534:                 bne.s *
                            	  5535: 
00:00005540 4E75            	  5536:                 rts
                            	  5537: 
                            	  5538: 
                            	  5539: 
                            	  5540: 
                            	  5541: *-----------------------------------------------------------
                            	  5542: *-----------------------------------------------------------
                            	  5543: * OPCODE : SUBX
                            	  5544: *-----------------------------------------------------------
                            	  5545: *-----------------------------------------------------------
                            	  5546: 
                            	  5547: op_SUBX:
                            	  5548: 
                            	  5549: 
                            	  5550: *  * Register to Register
00:00005542 203CA5A5A5A5    	  5551:                 move.l #$a5a5a5a5,d0       * Initial Data-X  Inner loop
00:00005548 223C8167E123    	  5552:                 move.l #$8167E123,d1       * Initial Data-Y  Outer loop
00:0000554E 243CA5A5A5A5    	  5553:                 move.l #$a5a5a5a5,d2
00:00005554 7600            	  5554:                 moveq  #$00000000,d3
00:00005556 7800            	  5555:                 moveq  #$00000000,d4       * Cumulative data results
00:00005558 7A00            	  5556:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000555A 7C1E            	  5557:                 move.l #$0000001E,d6       * Inner loop counter
00:0000555C 7E1E            	  5558:                 move.l #$0000001E,d7       * Outer loop counter
00:0000555E 307C0100        	  5559:                 move.l #$00000100,a0       * Address for memory EA operations
                            	  5560: 
                            	  5561: 
                            	  5562: SUBX_OUTER1:
                            	  5563: 
                            	  5564: *     BYTE
00:00005562 2002            	  5565:                 move.l d2,d0
00:00005564 9101            	  5566:                 subx.b d1,d0
00:00005566 40C3            	  5567:                 move.w sr,d3
00:00005568 02830000001F    	  5568:                 andi.l #$1F,d3            * Isolate flags
00:0000556E DA83            	  5569:                 add.l d3,d5               * Copy flag results into accumulator
00:00005570 D880            	  5570:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5571: 
                            	  5572: *     WORD
00:00005572 2002            	  5573:                 move.l d2,d0
00:00005574 9141            	  5574:                 subx.w d1,d0
00:00005576 40C3            	  5575:                 move.w sr,d3
00:00005578 02830000001F    	  5576:                 andi.l #$1F,d3            * Isolate flags
00:0000557E DA83            	  5577:                 add.l d3,d5               * Copy flag results into accumulator
00:00005580 D880            	  5578:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5579: 
                            	  5580: *     LONG
00:00005582 2002            	  5581:                 move.l d2,d0
00:00005584 9181            	  5582:                 subx.l d1,d0
00:00005586 40C3            	  5583:                 move.w sr,d3
00:00005588 02830000001F    	  5584:                 andi.l #$1F,d3            * Isolate flags
00:0000558E DA83            	  5585:                 add.l d3,d5               * Copy flag results into accumulator
00:00005590 D880            	  5586:                 add.l d0,d4               * Copy data results into data accumulator
                            	  5587: 
00:00005592 E299            	  5588:                 ror.l #$1,d1
00:00005594 51CEFFCC        	  5589:                 dbf d6,SUBX_OUTER1
00:00005598 E29A            	  5590:                 ror.l #$1,d2
00:0000559A 223C8167E123    	  5591:                 move.l #$8167E123,d1       * Initial Data-Y
00:000055A0 7C1E            	  5592:                 move.l #$0000001E,d6       * Inner loop counter
00:000055A2 51CFFFBE        	  5593:                 dbf d7,SUBX_OUTER1
                            	  5594: 
00:000055A6 0C84FCAA913E    	  5595:                 cmpi.l #$FCAA913E,d4      * Check the data results
00:000055AC 66FE            	  5596:                 bne.s *
00:000055AE 0C8500007E89    	  5597:                 cmpi.l #$00007E89,d5      * Check the Flag results
00:000055B4 66FE            	  5598:                 bne.s *
                            	  5599: 
                            	  5600: 
                            	  5601: 
                            	  5602: *     -(An),-(An)
                            	  5603: 
00:000055B6 7000            	  5604:                 moveq  #$00000000,d0       * BYTE Flag Results Accumulator
00:000055B8 7200            	  5605:                 moveq  #$00000000,d1
00:000055BA 7400            	  5606:                 moveq  #$00000000,d2
00:000055BC 307C0100        	  5607:                 move.l #$00000100,a0       * Address for Data-X
00:000055C0 327C0200        	  5608:                 move.l #$00000200,a1       * Address for Data-Y
00:000055C4 20FC11FF5580    	  5609:                 move.l #$11FF5580,(a0)+   * Populate test data
00:000055CA 20FC1111FFFF    	  5610:                 move.l #$1111FFFF,(a0)+   * Populate test data
00:000055D0 20FC80FF337F    	  5611:                 move.l #$80FF337F,(a0)+   * Populate test data
00:000055D6 20FC44444444    	  5612:                 move.l #$44444444,(a0)+   * Populate test data
00:000055DC 22FC80FF337F    	  5613:                 move.l #$80FF337F,(a1)+   * Populate test data
00:000055E2 22FC1111FFFF    	  5614:                 move.l #$1111FFFF,(a1)+   * Populate test data
00:000055E8 22FC33333333    	  5615:                 move.l #$33333333,(a1)+   * Populate test data
00:000055EE 22FC5580EECC    	  5616:                 move.l #$5580EECC,(a1)+   * Populate test data
                            	  5617: 
                            	  5618: 
00:000055F4 7C0F            	  5619:                 move.l #$0000000F,d6       * Loop counter
                            	  5620: 
00:000055F6 9308            	  5621: SUBX_LOOP3:     subx.b -(a0),-(a1)
00:000055F8 40C3            	  5622:                 move.w sr,d3
00:000055FA 02830000000F    	  5623:                 andi.l #$0F,d3            * Isolate flags
00:00005600 D083            	  5624:                 add.l d3,d0               * Copy flag results into accumulator
00:00005602 D211            	  5625:                 add.b (a1),d1
00:00005604 51CEFFF0        	  5626:                 dbf d6,SUBX_LOOP3
                            	  5627: 
                            	  5628: 
00:00005608 307C0110        	  5629:                 move.l #$00000110,a0       * Address for Data-X
00:0000560C 327C0210        	  5630:                 move.l #$00000210,a1       * Address for Data-Y
00:00005610 7C07            	  5631:                 moveq  #$00000007,d6       * Loop counter
                            	  5632: 
00:00005612 9348            	  5633: SUBX_LOOP4:     subx.w -(a0),-(a1)
00:00005614 40C3            	  5634:                 move.w sr,d3
00:00005616 02830000000F    	  5635:                 andi.l #$0F,d3            * Isolate flags
00:0000561C D083            	  5636:                 add.l d3,d0               * Copy flag results into accumulator
00:0000561E D251            	  5637:                 add.w (a1),d1
00:00005620 51CEFFF0        	  5638:                 dbf d6,SUBX_LOOP4
                            	  5639: 
                            	  5640: 
00:00005624 307C0110        	  5641:                 move.l #$00000110,a0       * Address for Data-X
00:00005628 327C0210        	  5642:                 move.l #$00000210,a1       * Address for Data-Y
00:0000562C 7C03            	  5643:                 moveq  #$00000003,d6       * Loop counter
                            	  5644: 
00:0000562E 9388            	  5645: SUBX_LOOP5:     subx.l -(a0),-(a1)
00:00005630 40C3            	  5646:                 move.w sr,d3
00:00005632 02830000000F    	  5647:                 andi.l #$0F,d3            * Isolate flags
00:00005638 D083            	  5648:                 add.l d3,d0               * Copy flag results into accumulator
00:0000563A D291            	  5649:                 add.l (a1),d1
00:0000563C 51CEFFF0        	  5650:                 dbf d6,SUBX_LOOP5
                            	  5651: 
                            	  5652: 
00:00005640 0C80000000B1    	  5653:                 cmpi.l #$000000B1,d0      * Check the flag results
00:00005646 66FE            	  5654:                 bne.s *
00:00005648 0C8162C6F417    	  5655:                 cmpi.l #$62C6F417,d1      * Check the data results
00:0000564E 66FE            	  5656:                 bne.s *
                            	  5657: 
00:00005650 4E75            	  5658:                 rts
                            	  5659: 
                            	  5660: 
                            	  5661: *-----------------------------------------------------------
                            	  5662: *-----------------------------------------------------------
                            	  5663: * OPCODE : MULU
                            	  5664: *-----------------------------------------------------------
                            	  5665: *-----------------------------------------------------------
                            	  5666: 
                            	  5667: op_MULU:
                            	  5668: 
00:00005652 203CFE805501    	  5669:                 move.l #$FE805501,d0        * Initial
00:00005658 223C5697EDB6    	  5670:                 move.l #$5697EDB6,d1        * Initial Y
00:0000565E 243CFE805501    	  5671:                 move.l #$FE805501,d2
00:00005664 7600            	  5672:                 moveq  #$00000000,d3
00:00005666 7800            	  5673:                 moveq  #$00000000,d4        * Cumulative data results
00:00005668 7A00            	  5674:                 moveq  #$00000000,d5       * Cumulative flag results
00:0000566A 7C0E            	  5675:                 move.l #$0000000E,d6       * Inner loop counter
00:0000566C 7E0E            	  5676:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5677: 
                            	  5678: 
00:0000566E C0C1            	  5679: MULU_OUTER1:    mulu d1,d0
00:00005670 40C3            	  5680:                 move.w sr,d3
00:00005672 02830000000C    	  5681:                 andi.l #$0C,d3            * Isolate flags
00:00005678 DA83            	  5682:                 add.l d3,d5               * Copy flag results into accumulator
00:0000567A D880            	  5683:                 add.l d0,d4               * Copy data results into data accumulator
00:0000567C E299            	  5684:                 ror.l #$1,d1
                            	  5685: 
00:0000567E 51CEFFEE        	  5686:                 dbf d6,MULU_OUTER1
00:00005682 E29A            	  5687:                 ror.l #$1,d2
00:00005684 2002            	  5688:                 move.l d2,d0
00:00005686 7C0E            	  5689:                 move.l #$0000000E,d6       * Inner loop counter
00:00005688 51CFFFE4        	  5690:                 dbf d7,MULU_OUTER1
                            	  5691: 
00:0000568C 0C8476FB988C    	  5692:                 cmpi.l #$76FB988C,d4      * Check the data results
00:00005692 66FE            	  5693:                 bne.s *
                            	  5694: 
00:00005694 0C8500000170    	  5695:                 cmpi.l #$00000170,d5      * Check the Flag results
00:0000569A 66FE            	  5696:                 bne.s *
                            	  5697: 
                            	  5698: 
00:0000569C 4E75            	  5699:                 rts
                            	  5700: 
                            	  5701: 
                            	  5702: *-----------------------------------------------------------
                            	  5703: *-----------------------------------------------------------
                            	  5704: * OPCODE : MULS
                            	  5705: *-----------------------------------------------------------
                            	  5706: *-----------------------------------------------------------
                            	  5707: 
                            	  5708: op_MULS:
                            	  5709: 
00:0000569E 203CFE805501    	  5710:                 move.l #$FE805501,d0        * Initial
00:000056A4 223C5697EDB6    	  5711:                 move.l #$5697EDB6,d1        * Initial Y
00:000056AA 243CFE805501    	  5712:                 move.l #$FE805501,d2
00:000056B0 7600            	  5713:                 moveq  #$00000000,d3
00:000056B2 7800            	  5714:                 moveq  #$00000000,d4        * Cumulative data results
00:000056B4 7A00            	  5715:                 moveq  #$00000000,d5       * Cumulative flag results
00:000056B6 7C0E            	  5716:                 move.l #$0000000E,d6       * Inner loop counter
00:000056B8 7E0E            	  5717:                 move.l #$0000000E,d7       * Outer loop counter
                            	  5718: 
                            	  5719: 
00:000056BA C1C1            	  5720: MULS_OUTER1:    muls d1,d0
00:000056BC 40C3            	  5721:                 move.w sr,d3
00:000056BE 02830000000C    	  5722:                 andi.l #$0C,d3            * Isolate flags
00:000056C4 DA83            	  5723:                 add.l d3,d5               * Copy flag results into accumulator
00:000056C6 D880            	  5724:                 add.l d0,d4               * Copy data results into data accumulator
00:000056C8 E299            	  5725:                 ror.l #$1,d1
                            	  5726: 
00:000056CA 51CEFFEE        	  5727:                 dbf d6,MULS_OUTER1
00:000056CE E29A            	  5728:                 ror.l #$1,d2
00:000056D0 2002            	  5729:                 move.l d2,d0
00:000056D2 7C0E            	  5730:                 move.l #$0000000E,d6       * Inner loop counter
00:000056D4 51CFFFE4        	  5731:                 dbf d7,MULS_OUTER1
                            	  5732: 
00:000056D8 0C84D4E2988C    	  5733:                 cmpi.l #$D4E2988C,d4      * Check the data results
00:000056DE 66FE            	  5734:                 bne.s *
                            	  5735: 
00:000056E0 0C85000003E0    	  5736:                 cmpi.l #$000003E0,d5      * Check the Flag results
00:000056E6 66FE            	  5737:                 bne.s *
                            	  5738: 
                            	  5739: 
00:000056E8 4E75            	  5740:                 rts
                            	  5741: 
                            	  5742: 
                            	  5743: 
                            	  5744: *-----------------------------------------------------------
                            	  5745: *-----------------------------------------------------------
                            	  5746: * OPCODE : EXG
                            	  5747: *-----------------------------------------------------------
                            	  5748: *-----------------------------------------------------------
                            	  5749: 
                            	  5750: op_EXG:
00:000056EA 223CD1D1D1D1    	  5751:                 move.l #$d1d1d1d1,d1
00:000056F0 243CD2D2D2D2    	  5752:                 move.l #$d2d2d2d2,d2
00:000056F6 263CD3D3D3D3    	  5753:                 move.l #$d3d3d3d3,d3
00:000056FC 227CA1A1A1A1    	  5754:                 move.l #$a1a1a1a1,a1
00:00005702 247CA2A2A2A2    	  5755:                 move.l #$a2a2a2a2,a2
00:00005708 267CA3A3A3A3    	  5756:                 move.l #$a3a3a3a3,a3
                            	  5757: 
00:0000570E C342            	  5758:                 exg d1,d2
00:00005710 C34A            	  5759:                 exg a1,a2
00:00005712 C78B            	  5760:                 exg d3,a3
                            	  5761: 
00:00005714 0C81D2D2D2D2    	  5762:                 cmpi.l #$d2d2d2d2,d1      * Check the results
00:0000571A 66FE            	  5763:                 bne.s *
00:0000571C 0C82D1D1D1D1    	  5764:                 cmpi.l #$d1d1d1d1,d2
00:00005722 66FE            	  5765:                 bne.s *
00:00005724 0C83A3A3A3A3    	  5766:                 cmpi.l #$a3a3a3a3,d3
00:0000572A 66FE            	  5767:                 bne.s *
                            	  5768: 
00:0000572C 2209            	  5769:                 move.l a1,d1
00:0000572E 240A            	  5770:                 move.l a2,d2
00:00005730 260B            	  5771:                 move.l a3,d3
                            	  5772: 
00:00005732 0C81A2A2A2A2    	  5773:                 cmpi.l #$a2a2a2a2,d1
00:00005738 66FE            	  5774:                 bne.s *
00:0000573A 0C82A1A1A1A1    	  5775:                 cmpi.l #$a1a1a1a1,d2
00:00005740 66FE            	  5776:                 bne.s *
00:00005742 0C83D3D3D3D3    	  5777:                 cmpi.l #$d3d3d3d3,d3
00:00005748 66FE            	  5778:                 bne.s *
                            	  5779: 
00:0000574A 4E75            	  5780:                 rts
                            	  5781: 
                            	  5782: 
                            	  5783: *-----------------------------------------------------------
                            	  5784: *-----------------------------------------------------------
                            	  5785: * OPCODE : ROx
                            	  5786: *-----------------------------------------------------------
                            	  5787: *-----------------------------------------------------------
                            	  5788: 
                            	  5789: *     Subroutine to check and accumulate the flags
00:0000574C 40C3            	  5790: ROx_FLAGS:      move.w sr,d3
00:0000574E 02830000000F    	  5791:                 andi.l #$0F,d3            * Isolate flags
00:00005754 DA83            	  5792:                 add.l d3,d5               * Copy flag results into accumulator
00:00005756 4E75            	  5793:                 rts
                            	  5794: 
                            	  5795: op_ROx:
                            	  5796: 
                            	  5797: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  5798: 
                            	  5799: *        BYTE LEFT
00:00005758 203C80018FF1    	  5800:                 move.l #$80018FF1,d0
00:0000575E 7A00            	  5801:                 moveq  #$00000000,d5
00:00005760 7C11            	  5802:                 moveq  #$00000011,d6
                            	  5803: ROx_LOOP1:
00:00005762 ED38            	  5804:                 rol.b d6,d0
00:00005764 61E6            	  5805:                 bsr ROx_FLAGS
00:00005766 51CEFFFA        	  5806:                 dbf d6,ROx_LOOP1
00:0000576A 0C8080018FE3    	  5807:                 cmpi.l #$80018FE3,d0
00:00005770 66FE            	  5808:                 bne.s *
00:00005772 0C850000006B    	  5809:                 cmpi.l #$0000006B,d5
00:00005778 66FE            	  5810:                 bne.s *
                            	  5811: 
                            	  5812: *        BYTE RIGHT
00:0000577A 203C80018FF1    	  5813:                 move.l #$80018FF1,d0
00:00005780 7C12            	  5814:                 moveq  #$00000012,d6
                            	  5815: ROx_LOOP2:
00:00005782 EC38            	  5816:                 ror.b d6,d0
00:00005784 61C6            	  5817:                 bsr ROx_FLAGS
00:00005786 51CEFFFA        	  5818:                 dbf d6,ROx_LOOP2
00:0000578A 0C8080018F3E    	  5819:                 cmpi.l #$80018F3E,d0
00:00005790 66FE            	  5820:                 bne.s *
00:00005792 0C85000000C5    	  5821:                 cmpi.l #$000000C5,d5
00:00005798 66FE            	  5822:                 bne.s *
                            	  5823: 
                            	  5824: 
                            	  5825: *        WORD LEFT
00:0000579A 203C80018FF1    	  5826:                 move.l #$80018FF1,d0
00:000057A0 7C13            	  5827:                 moveq  #$00000013,d6
                            	  5828: ROx_LOOP3:
00:000057A2 ED78            	  5829:                 rol.w d6,d0
00:000057A4 61A6            	  5830:                 bsr ROx_FLAGS
00:000057A6 51CEFFFA        	  5831:                 dbf d6,ROx_LOOP3
00:000057AA 0C80800163FC    	  5832:                 cmpi.l #$800163FC,d0
00:000057B0 66FE            	  5833:                 bne.s *
00:000057B2 0C8500000131    	  5834:                 cmpi.l #$00000131,d5
00:000057B8 66FE            	  5835:                 bne.s *
                            	  5836: 
                            	  5837: *        WORD RIGHT
00:000057BA 203C80018FF1    	  5838:                 move.l #$80018FF1,d0
00:000057C0 7C1E            	  5839:                 move.l #$0000001E,d6
                            	  5840: ROx_LOOP4:
00:000057C2 EC78            	  5841:                 ror.w d6,d0
00:000057C4 6186            	  5842:                 bsr ROx_FLAGS
00:000057C6 51CEFFFA        	  5843:                 dbf d6,ROx_LOOP4
00:000057CA 0C808001C7F8    	  5844:                 cmpi.l #$8001C7F8,d0
00:000057D0 66FE            	  5845:                 bne.s *
00:000057D2 0C85000001DB    	  5846:                 cmpi.l #$000001DB,d5
00:000057D8 66FE            	  5847:                 bne.s *
                            	  5848: 
                            	  5849: 
                            	  5850: *        LONG LEFT
00:000057DA 203C80018FF1    	  5851:                 move.l #$80018FF1,d0
00:000057E0 7C15            	  5852:                 moveq  #$00000015,d6
                            	  5853: ROx_LOOP5:
00:000057E2 EDB8            	  5854:                 rol.l d6,d0
00:000057E4 6100FF66        	  5855:                 bsr ROx_FLAGS
00:000057E8 51CEFFF8        	  5856:                 dbf d6,ROx_LOOP5
00:000057EC 0C8000C7F8C0    	  5857:                 cmpi.l #$00C7F8C0,d0
00:000057F2 66FE            	  5858:                 bne.s *
00:000057F4 0C850000021A    	  5859:                 cmpi.l #$0000021A,d5
00:000057FA 66FE            	  5860:                 bne.s *
                            	  5861: 
                            	  5862: *        LONG RIGHT
00:000057FC 203C80018FF1    	  5863:                 move.l #$80018FF1,d0
00:00005802 7C16            	  5864:                 moveq  #$00000016,d6
                            	  5865: ROx_LOOP6:
00:00005804 ECB8            	  5866:                 ror.l d6,d0
00:00005806 6100FF44        	  5867:                 bsr ROx_FLAGS
00:0000580A 51CEFFF8        	  5868:                 dbf d6,ROx_LOOP6
00:0000580E 0C80000C7F8C    	  5869:                 cmpi.l #$000C7F8C,d0
00:00005814 66FE            	  5870:                 bne.s *
00:00005816 0C8500000250    	  5871:                 cmpi.l #$00000250,d5
00:0000581C 66FE            	  5872:                 bne.s *
                            	  5873: 
                            	  5874: 
                            	  5875: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  5876: 
00:0000581E 203C80018FF1    	  5877:                 move.l #$80018FF1,d0
00:00005824 7A00            	  5878:                 moveq  #$00000000,d5
                            	  5879: 
                            	  5880: *        BYTE LEFT
00:00005826 E318            	  5881:                 rol.b #1,d0
00:00005828 6100FF22        	  5882:                 bsr ROx_FLAGS
00:0000582C EB18            	  5883:                 rol.b #5,d0
00:0000582E 6100FF1C        	  5884:                 bsr ROx_FLAGS
00:00005832 EF18            	  5885:                 rol.b #7,d0
00:00005834 6100FF16        	  5886:                 bsr ROx_FLAGS
00:00005838 E118            	  5887:                 rol.b #8,d0
00:0000583A 6100FF10        	  5888:                 bsr ROx_FLAGS
00:0000583E 0C8080018F3E    	  5889:                 cmpi.l #$80018F3E,d0
00:00005844 66FE            	  5890:                 bne.s *
00:00005846 0C8500000009    	  5891:                 cmpi.l #$00000009,d5
00:0000584C 66FE            	  5892:                 bne.s *
                            	  5893: 
                            	  5894: *        BYTE RIGHT
00:0000584E E218            	  5895:                 ror.b #1,d0
00:00005850 6100FEFA        	  5896:                 bsr ROx_FLAGS
00:00005854 EA18            	  5897:                 ror.b #5,d0
00:00005856 6100FEF4        	  5898:                 bsr ROx_FLAGS
00:0000585A EE18            	  5899:                 ror.b #7,d0
00:0000585C 6100FEEE        	  5900:                 bsr ROx_FLAGS
00:00005860 E018            	  5901:                 ror.b #8,d0
00:00005862 6100FEE8        	  5902:                 bsr ROx_FLAGS
00:00005866 0C8080018FF1    	  5903:                 cmpi.l #$80018FF1,d0
00:0000586C 66FE            	  5904:                 bne.s *
00:0000586E 0C8500000024    	  5905:                 cmpi.l #$00000024,d5
00:00005874 66FE            	  5906:                 bne.s *
                            	  5907: 
                            	  5908: *        WORD LEFT
00:00005876 E358            	  5909:                 rol.w #1,d0
00:00005878 6100FED2        	  5910:                 bsr ROx_FLAGS
00:0000587C EB58            	  5911:                 rol.w #5,d0
00:0000587E 6100FECC        	  5912:                 bsr ROx_FLAGS
00:00005882 EF58            	  5913:                 rol.w #7,d0
00:00005884 6100FEC6        	  5914:                 bsr ROx_FLAGS
00:00005888 E158            	  5915:                 rol.w #8,d0
00:0000588A 6100FEC0        	  5916:                 bsr ROx_FLAGS
00:0000588E 0C808001FE31    	  5917:                 cmpi.l #$8001FE31,d0
00:00005894 66FE            	  5918:                 bne.s *
00:00005896 0C8500000037    	  5919:                 cmpi.l #$00000037,d5
00:0000589C 66FE            	  5920:                 bne.s *
                            	  5921: 
                            	  5922: *        WORD RIGHT
00:0000589E E258            	  5923:                 ror.w #1,d0
00:000058A0 6100FEAA        	  5924:                 bsr ROx_FLAGS
00:000058A4 EA58            	  5925:                 ror.w #5,d0
00:000058A6 6100FEA4        	  5926:                 bsr ROx_FLAGS
00:000058AA EE58            	  5927:                 ror.w #7,d0
00:000058AC 6100FE9E        	  5928:                 bsr ROx_FLAGS
00:000058B0 E058            	  5929:                 ror.w #8,d0
00:000058B2 6100FE98        	  5930:                 bsr ROx_FLAGS
00:000058B6 0C8080018FF1    	  5931:                 cmpi.l #$80018FF1,d0
00:000058BC 66FE            	  5932:                 bne.s *
00:000058BE 0C850000005B    	  5933:                 cmpi.l #$0000005B,d5
00:000058C4 66FE            	  5934:                 bne.s *
                            	  5935: 
                            	  5936: *        LONG LEFT
00:000058C6 E398            	  5937:                 rol.l #1,d0
00:000058C8 6100FE82        	  5938:                 bsr ROx_FLAGS
00:000058CC EB98            	  5939:                 rol.l #5,d0
00:000058CE 6100FE7C        	  5940:                 bsr ROx_FLAGS
00:000058D2 EF98            	  5941:                 rol.l #7,d0
00:000058D4 6100FE76        	  5942:                 bsr ROx_FLAGS
00:000058D8 E198            	  5943:                 rol.l #8,d0
00:000058DA 6100FE70        	  5944:                 bsr ROx_FLAGS
00:000058DE 0C80FE300031    	  5945:                 cmpi.l #$FE300031,d0
00:000058E4 66FE            	  5946:                 bne.s *
00:000058E6 0C8500000065    	  5947:                 cmpi.l #$00000065,d5
00:000058EC 66FE            	  5948:                 bne.s *
                            	  5949: 
                            	  5950: *        LONG RIGHT
00:000058EE E298            	  5951:                 ror.l #1,d0
00:000058F0 6100FE5A        	  5952:                 bsr ROx_FLAGS
00:000058F4 EA98            	  5953:                 ror.l #5,d0
00:000058F6 6100FE54        	  5954:                 bsr ROx_FLAGS
00:000058FA EE98            	  5955:                 ror.l #7,d0
00:000058FC 6100FE4E        	  5956:                 bsr ROx_FLAGS
00:00005900 E098            	  5957:                 ror.l #8,d0
00:00005902 6100FE48        	  5958:                 bsr ROx_FLAGS
00:00005906 0C8080018FF1    	  5959:                 cmpi.l #$80018FF1,d0
00:0000590C 66FE            	  5960:                 bne.s *
00:0000590E 0C8500000080    	  5961:                 cmpi.l #$00000080,d5
00:00005914 66FE            	  5962:                 bne.s *
                            	  5963: 
                            	  5964: 
                            	  5965: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  5966: 
00:00005916 7A00            	  5967:                 moveq  #$00000000,d5
00:00005918 307C0100        	  5968:                 move.l #$00000100,a0
00:0000591C 30BC8FF1        	  5969:                 move.w #$8FF1,(a0)
                            	  5970: 
                            	  5971: *        WORD LEFT
00:00005920 E7D0            	  5972:                 rol (a0)
00:00005922 6100FE28        	  5973:                 bsr ROx_FLAGS
00:00005926 E7D0            	  5974:                 rol (a0)
00:00005928 6100FE22        	  5975:                 bsr ROx_FLAGS
00:0000592C E7D0            	  5976:                 rol (a0)
00:0000592E 6100FE1C        	  5977:                 bsr ROx_FLAGS
00:00005932 E7D0            	  5978:                 rol (a0)
00:00005934 6100FE16        	  5979:                 bsr ROx_FLAGS
00:00005938 3010            	  5980:                 move.w (a0),d0
00:0000593A 0C808001FF18    	  5981:                 cmpi.l #$8001FF18,d0
00:00005940 66FE            	  5982:                 bne.s *
00:00005942 0C8500000009    	  5983:                 cmpi.l #$00000009,d5
00:00005948 66FE            	  5984:                 bne.s *
                            	  5985: 
                            	  5986: *        WORD RIGHT
00:0000594A E6D0            	  5987:                 ror (a0)
00:0000594C 6100FDFE        	  5988:                 bsr ROx_FLAGS
00:00005950 E6D0            	  5989:                 ror (a0)
00:00005952 6100FDF8        	  5990:                 bsr ROx_FLAGS
00:00005956 E6D0            	  5991:                 ror (a0)
00:00005958 6100FDF2        	  5992:                 bsr ROx_FLAGS
00:0000595C E6D0            	  5993:                 ror (a0)
00:0000595E 6100FDEC        	  5994:                 bsr ROx_FLAGS
00:00005962 E6D0            	  5995:                 ror (a0)
00:00005964 6100FDE6        	  5996:                 bsr ROx_FLAGS
00:00005968 E6D0            	  5997:                 ror (a0)
00:0000596A 6100FDE0        	  5998:                 bsr ROx_FLAGS
00:0000596E 3010            	  5999:                 move.w (a0),d0
00:00005970 0C80800163FC    	  6000:                 cmpi.l #$800163FC,d0
00:00005976 66FE            	  6001:                 bne.s *
00:00005978 0C850000001B    	  6002:                 cmpi.l #$0000001B,d5
00:0000597E 66FE            	  6003:                 bne.s *
                            	  6004: 
00:00005980 4E75            	  6005:                 rts
                            	  6006: 
                            	  6007: 
                            	  6008: 
                            	  6009: *-----------------------------------------------------------
                            	  6010: *-----------------------------------------------------------
                            	  6011: * OPCODE : ROXx
                            	  6012: *-----------------------------------------------------------
                            	  6013: *-----------------------------------------------------------
                            	  6014: 
                            	  6015: *     Subroutine to check and accumulate the flags
00:00005982 40C3            	  6016: ROXx_FLAGS:     move.w sr,d3
00:00005984 02830000000F    	  6017:                 andi.l #$0F,d3            * Isolate flags
00:0000598A DA83            	  6018:                 add.l d3,d5               * Copy flag results into accumulator
00:0000598C 4E75            	  6019:                 rts
                            	  6020: 
                            	  6021: op_ROXx:
                            	  6022: 
                            	  6023: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6024: 
                            	  6025: *        BYTE LEFT
00:0000598E 203C80018FF1    	  6026:                 move.l #$80018FF1,d0
00:00005994 7A00            	  6027:                 moveq  #$00000000,d5
00:00005996 7C11            	  6028:                 moveq  #$00000011,d6
                            	  6029: ROXx_LOOP1:
00:00005998 ED30            	  6030:                 roxl.b d6,d0
00:0000599A 61E6            	  6031:                 bsr ROXx_FLAGS
00:0000599C 51CEFFFA        	  6032:                 dbf d6,ROXx_LOOP1
00:000059A0 0C8080018FD0    	  6033:                 cmpi.l #$80018FD0,d0
00:000059A6 66FE            	  6034:                 bne.s *
00:000059A8 0C8500000042    	  6035:                 cmpi.l #$00000042,d5
00:000059AE 66FE            	  6036:                 bne.s *
                            	  6037: 
                            	  6038: *        BYTE RIGHT
00:000059B0 203C80018FF1    	  6039:                 move.l #$80018FF1,d0
00:000059B6 7C12            	  6040:                 moveq  #$00000012,d6
                            	  6041: ROXx_LOOP2:
00:000059B8 EC30            	  6042:                 roxr.b d6,d0
00:000059BA 61C6            	  6043:                 bsr ROXx_FLAGS
00:000059BC 51CEFFFA        	  6044:                 dbf d6,ROXx_LOOP2
00:000059C0 0C8080018F51    	  6045:                 cmpi.l #$80018F51,d0
00:000059C6 66FE            	  6046:                 bne.s *
00:000059C8 0C850000009C    	  6047:                 cmpi.l #$0000009C,d5
00:000059CE 66FE            	  6048:                 bne.s *
                            	  6049: 
                            	  6050: 
                            	  6051: *        WORD LEFT
00:000059D0 203C80018FF1    	  6052:                 move.l #$80018FF1,d0
00:000059D6 7C13            	  6053:                 moveq  #$00000013,d6
                            	  6054: ROXx_LOOP3:
00:000059D8 ED70            	  6055:                 roxl.w d6,d0
00:000059DA 61A6            	  6056:                 bsr ROXx_FLAGS
00:000059DC 51CEFFFA        	  6057:                 dbf d6,ROXx_LOOP3
00:000059E0 0C8080013980    	  6058:                 cmpi.l #$80013980,d0
00:000059E6 66FE            	  6059:                 bne.s *
00:000059E8 0C85000000C9    	  6060:                 cmpi.l #$000000C9,d5
00:000059EE 66FE            	  6061:                 bne.s *
                            	  6062: 
                            	  6063: *        WORD RIGHT
00:000059F0 203C80018FF1    	  6064:                 move.l #$80018FF1,d0
00:000059F6 7C1E            	  6065:                 move.l #$0000001E,d6
                            	  6066: ROXx_LOOP4:
00:000059F8 EC70            	  6067:                 roxr.w d6,d0
00:000059FA 6186            	  6068:                 bsr ROXx_FLAGS
00:000059FC 51CEFFFA        	  6069:                 dbf d6,ROXx_LOOP4
00:00005A00 0C8080010A1D    	  6070:                 cmpi.l #$80010A1D,d0
00:00005A06 66FE            	  6071:                 bne.s *
00:00005A08 0C850000014D    	  6072:                 cmpi.l #$0000014D,d5
00:00005A0E 66FE            	  6073:                 bne.s *
                            	  6074: 
                            	  6075: 
                            	  6076: *        LONG LEFT
00:00005A10 203C80018FF1    	  6077:                 move.l #$80018FF1,d0
00:00005A16 7C15            	  6078:                 moveq  #$00000015,d6
                            	  6079: ROXx_LOOP5:
00:00005A18 EDB0            	  6080:                 roxl.l d6,d0
00:00005A1A 6100FF66        	  6081:                 bsr ROXx_FLAGS
00:00005A1E 51CEFFF8        	  6082:                 dbf d6,ROXx_LOOP5
00:00005A22 0C80800185D0    	  6083:                 cmpi.l #$800185D0,d0
00:00005A28 66FE            	  6084:                 bne.s *
00:00005A2A 0C85000001A1    	  6085:                 cmpi.l #$000001A1,d5
00:00005A30 66FE            	  6086:                 bne.s *
                            	  6087: 
                            	  6088: *        LONG RIGHT
00:00005A32 203C80018FF1    	  6089:                 move.l #$80018FF1,d0
00:00005A38 7C16            	  6090:                 moveq  #$00000016,d6
                            	  6091: ROXx_LOOP6:
00:00005A3A ECB0            	  6092:                 roxr.l d6,d0
00:00005A3C 6100FF44        	  6093:                 bsr ROXx_FLAGS
00:00005A40 51CEFFF8        	  6094:                 dbf d6,ROXx_LOOP6
00:00005A44 0C80082D8200    	  6095:                 cmpi.l #$082D8200,d0
00:00005A4A 66FE            	  6096:                 bne.s *
00:00005A4C 0C85000001DE    	  6097:                 cmpi.l #$000001DE,d5
00:00005A52 66FE            	  6098:                 bne.s *
                            	  6099: 
                            	  6100: 
                            	  6101: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6102: 
00:00005A54 203C80018FF1    	  6103:                 move.l #$80018FF1,d0
00:00005A5A 7A00            	  6104:                 moveq  #$00000000,d5
                            	  6105: 
                            	  6106: *        BYTE LEFT
00:00005A5C E310            	  6107:                 roxl.b #1,d0
00:00005A5E 6100FF22        	  6108:                 bsr ROXx_FLAGS
00:00005A62 EB10            	  6109:                 roxl.b #5,d0
00:00005A64 6100FF1C        	  6110:                 bsr ROXx_FLAGS
00:00005A68 EF10            	  6111:                 roxl.b #7,d0
00:00005A6A 6100FF16        	  6112:                 bsr ROXx_FLAGS
00:00005A6E E110            	  6113:                 roxl.b #8,d0
00:00005A70 6100FF10        	  6114:                 bsr ROXx_FLAGS
00:00005A74 0C8080018F09    	  6115:                 cmpi.l #$80018F09,d0
00:00005A7A 66FE            	  6116:                 bne.s *
00:00005A7C 0C850000000B    	  6117:                 cmpi.l #$0000000B,d5
00:00005A82 66FE            	  6118:                 bne.s *
                            	  6119: 
                            	  6120: *        BYTE RIGHT
00:00005A84 E210            	  6121:                 roxr.b #1,d0
00:00005A86 6100FEFA        	  6122:                 bsr ROXx_FLAGS
00:00005A8A EA10            	  6123:                 roxr.b #5,d0
00:00005A8C 6100FEF4        	  6124:                 bsr ROXx_FLAGS
00:00005A90 EE10            	  6125:                 roxr.b #7,d0
00:00005A92 6100FEEE        	  6126:                 bsr ROXx_FLAGS
00:00005A96 E010            	  6127:                 roxr.b #8,d0
00:00005A98 6100FEE8        	  6128:                 bsr ROXx_FLAGS
00:00005A9C 0C8080018F00    	  6129:                 cmpi.l #$80018F00,d0
00:00005AA2 66FE            	  6130:                 bne.s *
00:00005AA4 0C8500000015    	  6131:                 cmpi.l #$00000015,d5
00:00005AAA 66FE            	  6132:                 bne.s *
                            	  6133: 
                            	  6134: *        WORD LEFT
00:00005AAC E350            	  6135:                 roxl.w #1,d0
00:00005AAE 6100FED2        	  6136:                 bsr ROXx_FLAGS
00:00005AB2 EB50            	  6137:                 roxl.w #5,d0
00:00005AB4 6100FECC        	  6138:                 bsr ROXx_FLAGS
00:00005AB8 EF50            	  6139:                 roxl.w #7,d0
00:00005ABA 6100FEC6        	  6140:                 bsr ROXx_FLAGS
00:00005ABE E150            	  6141:                 roxl.w #8,d0
00:00005AC0 6100FEC0        	  6142:                 bsr ROXx_FLAGS
00:00005AC4 0C808001B000    	  6143:                 cmpi.l #$8001B000,d0
00:00005ACA 66FE            	  6144:                 bne.s *
00:00005ACC 0C8500000027    	  6145:                 cmpi.l #$00000027,d5
00:00005AD2 66FE            	  6146:                 bne.s *
                            	  6147: 
                            	  6148: *        WORD RIGHT
00:00005AD4 E250            	  6149:                 roxr.w #1,d0
00:00005AD6 6100FEAA        	  6150:                 bsr ROXx_FLAGS
00:00005ADA EA50            	  6151:                 roxr.w #5,d0
00:00005ADC 6100FEA4        	  6152:                 bsr ROXx_FLAGS
00:00005AE0 EE50            	  6153:                 roxr.w #7,d0
00:00005AE2 6100FE9E        	  6154:                 bsr ROXx_FLAGS
00:00005AE6 E050            	  6155:                 roxr.w #8,d0
00:00005AE8 6100FE98        	  6156:                 bsr ROXx_FLAGS
00:00005AEC 0C8080010A00    	  6157:                 cmpi.l #$80010A00,d0
00:00005AF2 66FE            	  6158:                 bne.s *
00:00005AF4 0C8500000028    	  6159:                 cmpi.l #$00000028,d5
00:00005AFA 66FE            	  6160:                 bne.s *
                            	  6161: 
                            	  6162: *        LONG LEFT
00:00005AFC E390            	  6163:                 roxl.l #1,d0
00:00005AFE 6100FE82        	  6164:                 bsr ROXx_FLAGS
00:00005B02 EB90            	  6165:                 roxl.l #5,d0
00:00005B04 6100FE7C        	  6166:                 bsr ROXx_FLAGS
00:00005B08 EF90            	  6167:                 roxl.l #7,d0
00:00005B0A 6100FE76        	  6168:                 bsr ROXx_FLAGS
00:00005B0E E190            	  6169:                 roxl.l #8,d0
00:00005B10 6100FE70        	  6170:                 bsr ROXx_FLAGS
00:00005B14 0C8040000010    	  6171:                 cmpi.l #$40000010,d0
00:00005B1A 66FE            	  6172:                 bne.s *
00:00005B1C 0C850000002A    	  6173:                 cmpi.l #$0000002A,d5
00:00005B22 66FE            	  6174:                 bne.s *
                            	  6175: 
                            	  6176: *        LONG RIGHT
00:00005B24 E290            	  6177:                 roxr.l #1,d0
00:00005B26 6100FE5A        	  6178:                 bsr ROXx_FLAGS
00:00005B2A EA90            	  6179:                 roxr.l #5,d0
00:00005B2C 6100FE54        	  6180:                 bsr ROXx_FLAGS
00:00005B30 EE90            	  6181:                 roxr.l #7,d0
00:00005B32 6100FE4E        	  6182:                 bsr ROXx_FLAGS
00:00005B36 E090            	  6183:                 roxr.l #8,d0
00:00005B38 6100FE48        	  6184:                 bsr ROXx_FLAGS
00:00005B3C 0C8000010200    	  6185:                 cmpi.l #$00010200,d0
00:00005B42 66FE            	  6186:                 bne.s *
00:00005B44 0C8500000032    	  6187:                 cmpi.l #$00000032,d5
00:00005B4A 66FE            	  6188:                 bne.s *
                            	  6189: 
                            	  6190: 
                            	  6191: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6192: 
00:00005B4C 7A00            	  6193:                 moveq  #$00000000,d5
00:00005B4E 307C0100        	  6194:                 move.l #$00000100,a0
00:00005B52 30BC8FF1        	  6195:                 move.w #$8FF1,(a0)
                            	  6196: 
                            	  6197: *        WORD LEFT
00:00005B56 E5D0            	  6198:                 roxl (a0)
00:00005B58 6100FE28        	  6199:                 bsr ROXx_FLAGS
00:00005B5C E5D0            	  6200:                 roxl (a0)
00:00005B5E 6100FE22        	  6201:                 bsr ROXx_FLAGS
00:00005B62 E5D0            	  6202:                 roxl (a0)
00:00005B64 6100FE1C        	  6203:                 bsr ROXx_FLAGS
00:00005B68 E5D0            	  6204:                 roxl (a0)
00:00005B6A 6100FE16        	  6205:                 bsr ROXx_FLAGS
00:00005B6E 3010            	  6206:                 move.w (a0),d0
00:00005B70 0C800001FF10    	  6207:                 cmpi.l #$0001FF10,d0
00:00005B76 66FE            	  6208:                 bne.s *
00:00005B78 0C8500000009    	  6209:                 cmpi.l #$00000009,d5
00:00005B7E 66FE            	  6210:                 bne.s *
                            	  6211: 
                            	  6212: *        WORD RIGHT
00:00005B80 E4D0            	  6213:                 roxr (a0)
00:00005B82 6100FDFE        	  6214:                 bsr ROXx_FLAGS
00:00005B86 E4D0            	  6215:                 roxr (a0)
00:00005B88 6100FDF8        	  6216:                 bsr ROXx_FLAGS
00:00005B8C E4D0            	  6217:                 roxr (a0)
00:00005B8E 6100FDF2        	  6218:                 bsr ROXx_FLAGS
00:00005B92 E4D0            	  6219:                 roxr (a0)
00:00005B94 6100FDEC        	  6220:                 bsr ROXx_FLAGS
00:00005B98 E4D0            	  6221:                 roxr (a0)
00:00005B9A 6100FDE6        	  6222:                 bsr ROXx_FLAGS
00:00005B9E E4D0            	  6223:                 roxr (a0)
00:00005BA0 6100FDE0        	  6224:                 bsr ROXx_FLAGS
00:00005BA4 3010            	  6225:                 move.w (a0),d0
00:00005BA6 0C80000103FC    	  6226:                 cmpi.l #$000103FC,d0
00:00005BAC 66FE            	  6227:                 bne.s *
00:00005BAE 0C850000000A    	  6228:                 cmpi.l #$0000000A,d5
00:00005BB4 66FE            	  6229:                 bne.s *
                            	  6230: 
00:00005BB6 4E75            	  6231:                 rts
                            	  6232: 
                            	  6233: 
                            	  6234: 
                            	  6235: 
                            	  6236: *-----------------------------------------------------------
                            	  6237: *-----------------------------------------------------------
                            	  6238: * OPCODE : SHIFTS
                            	  6239: *-----------------------------------------------------------
                            	  6240: *-----------------------------------------------------------
                            	  6241: 
                            	  6242: *     Subroutine to check and accumulate the flags
00:00005BB8 40C3            	  6243: SHIFTS_FLAGS:   move.w sr,d3
00:00005BBA 02830000000F    	  6244:                 andi.l #$0F,d3            * Isolate flags
00:00005BC0 DA83            	  6245:                 add.l d3,d5               * Copy flag results into accumulator
00:00005BC2 4E75            	  6246:                 rts
                            	  6247: 
                            	  6248: op_SHIFTS:
                            	  6249: 
                            	  6250: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6251: 
                            	  6252: *        BYTE LEFT
00:00005BC4 203C80018F81    	  6253:                 move.l #$80018F81,d0
00:00005BCA 7A00            	  6254:                 moveq  #$00000000,d5
00:00005BCC 7C02            	  6255:                 moveq  #$00000002,d6
                            	  6256: SHIFTS_LOOP1:
00:00005BCE ED20            	  6257:                 asl.b d6,d0
00:00005BD0 61E6            	  6258:                 bsr SHIFTS_FLAGS
00:00005BD2 51CEFFFA        	  6259:                 dbf d6,SHIFTS_LOOP1
00:00005BD6 0C8080018F08    	  6260:                 cmpi.l #$80018F08,d0
00:00005BDC 66FE            	  6261:                 bne.s *
00:00005BDE 0C8500000002    	  6262:                 cmpi.l #$00000002,d5
00:00005BE4 66FE            	  6263:                 bne.s *
                            	  6264: 
                            	  6265: *        BYTE RIGHT
00:00005BE6 203C80018F81    	  6266:                 move.l #$80018F81,d0
00:00005BEC 7C02            	  6267:                 moveq  #$00000002,d6
                            	  6268: SHIFTS_LOOP2:
00:00005BEE EC20            	  6269:                 asr.b d6,d0
00:00005BF0 61C6            	  6270:                 bsr SHIFTS_FLAGS
00:00005BF2 51CEFFFA        	  6271:                 dbf d6,SHIFTS_LOOP2
00:00005BF6 0C8080018FF0    	  6272:                 cmpi.l #$80018FF0,d0
00:00005BFC 66FE            	  6273:                 bne.s *
00:00005BFE 0C850000001A    	  6274:                 cmpi.l #$0000001A,d5
00:00005C04 66FE            	  6275:                 bne.s *
                            	  6276: 
                            	  6277: 
                            	  6278: *        WORD LEFT
00:00005C06 203C80018FF1    	  6279:                 move.l #$80018FF1,d0
00:00005C0C 7C02            	  6280:                 moveq  #$00000002,d6
                            	  6281: SHIFTS_LOOP3:
00:00005C0E ED60            	  6282:                 asl.w d6,d0
00:00005C10 61A6            	  6283:                 bsr SHIFTS_FLAGS
00:00005C12 51CEFFFA        	  6284:                 dbf d6,SHIFTS_LOOP3
00:00005C16 0C8080017F88    	  6285:                 cmpi.l #$80017F88,d0
00:00005C1C 66FE            	  6286:                 bne.s *
00:00005C1E 0C850000001C    	  6287:                 cmpi.l #$0000001C,d5
00:00005C24 66FE            	  6288:                 bne.s *
                            	  6289: 
                            	  6290: *        WORD RIGHT
00:00005C26 203C80018FF1    	  6291:                 move.l #$80018FF1,d0
00:00005C2C 7C02            	  6292:                 moveq  #$00000002,d6
                            	  6293: SHIFTS_LOOP4:
00:00005C2E EC60            	  6294:                 asr.w d6,d0
00:00005C30 6186            	  6295:                 bsr SHIFTS_FLAGS
00:00005C32 51CEFFFA        	  6296:                 dbf d6,SHIFTS_LOOP4
00:00005C36 0C808001F1FE    	  6297:                 cmpi.l #$8001F1FE,d0
00:00005C3C 66FE            	  6298:                 bne.s *
00:00005C3E 0C8500000034    	  6299:                 cmpi.l #$00000034,d5
00:00005C44 66FE            	  6300:                 bne.s *
                            	  6301: 
                            	  6302: 
                            	  6303: *        LONG LEFT
00:00005C46 203C80018FF1    	  6304:                 move.l #$80018FF1,d0
00:00005C4C 7C02            	  6305:                 moveq  #$00000002,d6
                            	  6306: SHIFTS_LOOP5:
00:00005C4E EDA0            	  6307:                 asl.l d6,d0
00:00005C50 6100FF66        	  6308:                 bsr SHIFTS_FLAGS
00:00005C54 51CEFFF8        	  6309:                 dbf d6,SHIFTS_LOOP5
00:00005C58 0C80000C7F88    	  6310:                 cmpi.l #$000C7F88,d0
00:00005C5E 66FE            	  6311:                 bne.s *
00:00005C60 0C8500000036    	  6312:                 cmpi.l #$00000036,d5
00:00005C66 66FE            	  6313:                 bne.s *
                            	  6314: 
                            	  6315: *        LONG RIGHT
00:00005C68 203C80018FF1    	  6316:                 move.l #$80018FF1,d0
00:00005C6E 7C02            	  6317:                 moveq  #$00000002,d6
                            	  6318: SHIFTS_LOOP6:
00:00005C70 ECA0            	  6319:                 asr.l d6,d0
00:00005C72 6100FF44        	  6320:                 bsr SHIFTS_FLAGS
00:00005C76 51CEFFF8        	  6321:                 dbf d6,SHIFTS_LOOP6
00:00005C7A 0C80F00031FE    	  6322:                 cmpi.l #$F00031FE,d0
00:00005C80 66FE            	  6323:                 bne.s *
00:00005C82 0C850000004E    	  6324:                 cmpi.l #$0000004E,d5
00:00005C88 66FE            	  6325:                 bne.s *
                            	  6326: 
                            	  6327: 
                            	  6328: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6329: 
00:00005C8A 203C80018FF1    	  6330:                 move.l #$80018FF1,d0
00:00005C90 7A00            	  6331:                 moveq  #$00000000,d5
                            	  6332: 
                            	  6333: *        BYTE LEFT
00:00005C92 D000            	  6334:                 asl.b #1,d0
00:00005C94 6100FF22        	  6335:                 bsr SHIFTS_FLAGS
00:00005C98 E500            	  6336:                 asl.b #2,d0
00:00005C9A 6100FF1C        	  6337:                 bsr SHIFTS_FLAGS
00:00005C9E D000            	  6338:                 asl.b #1,d0
00:00005CA0 6100FF16        	  6339:                 bsr SHIFTS_FLAGS
00:00005CA4 E700            	  6340:                 asl.b #3,d0
00:00005CA6 6100FF10        	  6341:                 bsr SHIFTS_FLAGS
00:00005CAA 0C8080018F80    	  6342:                 cmpi.l #$80018F80,d0
00:00005CB0 66FE            	  6343:                 bne.s *
00:00005CB2 0C850000001F    	  6344:                 cmpi.l #$0000001F,d5
00:00005CB8 66FE            	  6345:                 bne.s *
                            	  6346: 
                            	  6347: *        BYTE RIGHT
00:00005CBA E200            	  6348:                 asr.b #1,d0
00:00005CBC 6100FEFA        	  6349:                 bsr SHIFTS_FLAGS
00:00005CC0 E400            	  6350:                 asr.b #2,d0
00:00005CC2 6100FEF4        	  6351:                 bsr SHIFTS_FLAGS
00:00005CC6 E600            	  6352:                 asr.b #3,d0
00:00005CC8 6100FEEE        	  6353:                 bsr SHIFTS_FLAGS
00:00005CCC E200            	  6354:                 asr.b #1,d0
00:00005CCE 6100FEE8        	  6355:                 bsr SHIFTS_FLAGS
00:00005CD2 0C8080018FFF    	  6356:                 cmpi.l #$80018FFF,d0
00:00005CD8 66FE            	  6357:                 bne.s *
00:00005CDA 0C850000003F    	  6358:                 cmpi.l #$0000003F,d5
00:00005CE0 66FE            	  6359:                 bne.s *
                            	  6360: 
                            	  6361: *        WORD LEFT
00:00005CE2 D040            	  6362:                 asl.w #1,d0
00:00005CE4 6100FED2        	  6363:                 bsr SHIFTS_FLAGS
00:00005CE8 E540            	  6364:                 asl.w #2,d0
00:00005CEA 6100FECC        	  6365:                 bsr SHIFTS_FLAGS
00:00005CEE E740            	  6366:                 asl.w #3,d0
00:00005CF0 6100FEC6        	  6367:                 bsr SHIFTS_FLAGS
00:00005CF4 EB40            	  6368:                 asl.w #5,d0
00:00005CF6 6100FEC0        	  6369:                 bsr SHIFTS_FLAGS
00:00005CFA 0C808001F800    	  6370:                 cmpi.l #$8001F800,d0
00:00005D00 66FE            	  6371:                 bne.s *
00:00005D02 0C8500000056    	  6372:                 cmpi.l #$00000056,d5
00:00005D08 66FE            	  6373:                 bne.s *
                            	  6374: 
                            	  6375: *        WORD RIGHT
00:00005D0A EA40            	  6376:                 asr.w #5,d0
00:00005D0C 6100FEAA        	  6377:                 bsr SHIFTS_FLAGS
00:00005D10 E240            	  6378:                 asr.w #1,d0
00:00005D12 6100FEA4        	  6379:                 bsr SHIFTS_FLAGS
00:00005D16 E440            	  6380:                 asr.w #2,d0
00:00005D18 6100FE9E        	  6381:                 bsr SHIFTS_FLAGS
00:00005D1C E840            	  6382:                 asr.w #4,d0
00:00005D1E 6100FE98        	  6383:                 bsr SHIFTS_FLAGS
00:00005D22 0C808001FFFF    	  6384:                 cmpi.l #$8001FFFF,d0
00:00005D28 66FE            	  6385:                 bne.s *
00:00005D2A 0C8500000077    	  6386:                 cmpi.l #$00000077,d5
00:00005D30 66FE            	  6387:                 bne.s *
                            	  6388: 
                            	  6389: *        LONG LEFT
00:00005D32 203C80018FF1    	  6390:                 move.l #$80018FF1,d0
00:00005D38 D080            	  6391:                 asl.l #1,d0
00:00005D3A 6100FE7C        	  6392:                 bsr SHIFTS_FLAGS
00:00005D3E E580            	  6393:                 asl.l #2,d0
00:00005D40 6100FE76        	  6394:                 bsr SHIFTS_FLAGS
00:00005D44 EF80            	  6395:                 asl.l #7,d0
00:00005D46 6100FE70        	  6396:                 bsr SHIFTS_FLAGS
00:00005D4A E980            	  6397:                 asl.l #4,d0
00:00005D4C 6100FE6A        	  6398:                 bsr SHIFTS_FLAGS
00:00005D50 0C8063FC4000    	  6399:                 cmpi.l #$63FC4000,d0
00:00005D56 66FE            	  6400:                 bne.s *
00:00005D58 0C850000007A    	  6401:                 cmpi.l #$0000007A,d5
00:00005D5E 66FE            	  6402:                 bne.s *
                            	  6403: 
                            	  6404: *        LONG RIGHT
00:00005D60 203C80018FF1    	  6405:                 move.l #$80018FF1,d0
00:00005D66 E280            	  6406:                 asr.l #1,d0
00:00005D68 6100FE4E        	  6407:                 bsr SHIFTS_FLAGS
00:00005D6C EA80            	  6408:                 asr.l #5,d0
00:00005D6E 6100FE48        	  6409:                 bsr SHIFTS_FLAGS
00:00005D72 EE80            	  6410:                 asr.l #7,d0
00:00005D74 6100FE42        	  6411:                 bsr SHIFTS_FLAGS
00:00005D78 E080            	  6412:                 asr.l #8,d0
00:00005D7A 6100FE3C        	  6413:                 bsr SHIFTS_FLAGS
00:00005D7E 0C80FFFFFC00    	  6414:                 cmpi.l #$FFFFFC00,d0
00:00005D84 66FE            	  6415:                 bne.s *
00:00005D86 0C850000009C    	  6416:                 cmpi.l #$0000009C,d5
00:00005D8C 66FE            	  6417:                 bne.s *
                            	  6418: 
                            	  6419: 
                            	  6420: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6421: 
00:00005D8E 7A00            	  6422:                 moveq  #$00000000,d5
00:00005D90 307C0100        	  6423:                 move.l #$00000100,a0
00:00005D94 30BC8FF1        	  6424:                 move.w #$8FF1,(a0)
                            	  6425: 
                            	  6426: *        WORD LEFT
00:00005D98 E1D0            	  6427:                 asl  (a0)
00:00005D9A 6100FE1C        	  6428:                 bsr SHIFTS_FLAGS
00:00005D9E E1D0            	  6429:                 asl  (a0)
00:00005DA0 6100FE16        	  6430:                 bsr SHIFTS_FLAGS
00:00005DA4 E1D0            	  6431:                 asl  (a0)
00:00005DA6 6100FE10        	  6432:                 bsr SHIFTS_FLAGS
00:00005DAA E1D0            	  6433:                 asl  (a0)
00:00005DAC 6100FE0A        	  6434:                 bsr SHIFTS_FLAGS
00:00005DB0 3010            	  6435:                 move.w (a0),d0
00:00005DB2 0C80FFFFFF10    	  6436:                 cmpi.l #$FFFFFF10,d0
00:00005DB8 66FE            	  6437:                 bne.s *
00:00005DBA 0C850000000D    	  6438:                 cmpi.l #$0000000D,d5
00:00005DC0 66FE            	  6439:                 bne.s *
                            	  6440: 
                            	  6441: *        WORD RIGHT
00:00005DC2 E0D0            	  6442:                 asr (a0)
00:00005DC4 6100FDF2        	  6443:                 bsr SHIFTS_FLAGS
00:00005DC8 E0D0            	  6444:                 asr (a0)
00:00005DCA 6100FDEC        	  6445:                 bsr SHIFTS_FLAGS
00:00005DCE E0D0            	  6446:                 asr (a0)
00:00005DD0 6100FDE6        	  6447:                 bsr SHIFTS_FLAGS
00:00005DD4 E0D0            	  6448:                 asr (a0)
00:00005DD6 6100FDE0        	  6449:                 bsr SHIFTS_FLAGS
00:00005DDA E0D0            	  6450:                 asr (a0)
00:00005DDC 6100FDDA        	  6451:                 bsr SHIFTS_FLAGS
00:00005DE0 E0D0            	  6452:                 asr (a0)
00:00005DE2 6100FDD4        	  6453:                 bsr SHIFTS_FLAGS
00:00005DE6 3010            	  6454:                 move.w (a0),d0
00:00005DE8 0C80FFFFFFFC    	  6455:                 cmpi.l #$FFFFFFFC,d0
00:00005DEE 66FE            	  6456:                 bne.s *
00:00005DF0 0C850000003E    	  6457:                 cmpi.l #$0000003E,d5
00:00005DF6 66FE            	  6458:                 bne.s *
                            	  6459: 
00:00005DF8 4E75            	  6460:                 rts
                            	  6461: 
                            	  6462: 
                            	  6463: 
                            	  6464: *-----------------------------------------------------------
                            	  6465: *-----------------------------------------------------------
                            	  6466: * OPCODE : SHIFTS2
                            	  6467: *-----------------------------------------------------------
                            	  6468: *-----------------------------------------------------------
                            	  6469: 
                            	  6470: *     Subroutine to check and accumulate the flags
00:00005DFA 40C3            	  6471: SHIFTS2_FLAGS:  move.w sr,d3
00:00005DFC 02830000000F    	  6472:                 andi.l #$0F,d3            * Isolate flags
00:00005E02 DA83            	  6473:                 add.l d3,d5               * Copy flag results into accumulator
00:00005E04 4E75            	  6474:                 rts
                            	  6475: 
                            	  6476: op_SHIFTS2:
                            	  6477: 
                            	  6478: *     Shift a Register LEFT and RIGHT with shift_count ## IN A REGISTER ##
                            	  6479: 
                            	  6480: *        BYTE LEFT
00:00005E06 203C80018F81    	  6481:                 move.l #$80018F81,d0
00:00005E0C 7A00            	  6482:                 moveq  #$00000000,d5
00:00005E0E 7C02            	  6483:                 moveq  #$00000002,d6
                            	  6484: SHIFTS2_LOOP1:
00:00005E10 ED28            	  6485:                 lsl.b d6,d0
00:00005E12 61E6            	  6486:                 bsr SHIFTS2_FLAGS
00:00005E14 51CEFFFA        	  6487:                 dbf d6,SHIFTS2_LOOP1
00:00005E18 0C8080018F08    	  6488:                 cmpi.l #$80018F08,d0
00:00005E1E 66FE            	  6489:                 bne.s *
00:00005E20 4A85            	  6490:                 cmpi.l #$00000000,d5
00:00005E22 66FE            	  6491:                 bne.s *
                            	  6492: 
                            	  6493: *        BYTE RIGHT
00:00005E24 203C80018F81    	  6494:                 move.l #$80018F81,d0
00:00005E2A 7C02            	  6495:                 moveq  #$00000002,d6
                            	  6496: SHIFTS2_LOOP2:
00:00005E2C EC28            	  6497:                 lsr.b d6,d0
00:00005E2E 61CA            	  6498:                 bsr SHIFTS2_FLAGS
00:00005E30 51CEFFFA        	  6499:                 dbf d6,SHIFTS2_LOOP2
00:00005E34 0C8080018F10    	  6500:                 cmpi.l #$80018F10,d0
00:00005E3A 66FE            	  6501:                 bne.s *
00:00005E3C 4A85            	  6502:                 cmpi.l #$00000000,d5
00:00005E3E 66FE            	  6503:                 bne.s *
                            	  6504: 
                            	  6505: 
                            	  6506: *        WORD LEFT
00:00005E40 203C80018FF1    	  6507:                 move.l #$80018FF1,d0
00:00005E46 7C02            	  6508:                 moveq  #$00000002,d6
                            	  6509: SHIFTS2_LOOP3:
00:00005E48 ED68            	  6510:                 lsl.w d6,d0
00:00005E4A 61AE            	  6511:                 bsr SHIFTS2_FLAGS
00:00005E4C 51CEFFFA        	  6512:                 dbf d6,SHIFTS2_LOOP3
00:00005E50 0C8080017F88    	  6513:                 cmpi.l #$80017F88,d0
00:00005E56 66FE            	  6514:                 bne.s *
00:00005E58 4A85            	  6515:                 cmpi.l #$00000000,d5
00:00005E5A 66FE            	  6516:                 bne.s *
                            	  6517: 
                            	  6518: *        WORD RIGHT
00:00005E5C 203C80018FF1    	  6519:                 move.l #$80018FF1,d0
00:00005E62 7C02            	  6520:                 moveq  #$00000002,d6
                            	  6521: SHIFTS2_LOOP4:
00:00005E64 EC68            	  6522:                 lsr.w d6,d0
00:00005E66 6192            	  6523:                 bsr SHIFTS2_FLAGS
00:00005E68 51CEFFFA        	  6524:                 dbf d6,SHIFTS2_LOOP4
00:00005E6C 0C80800111FE    	  6525:                 cmpi.l #$800111FE,d0
00:00005E72 66FE            	  6526:                 bne.s *
00:00005E74 4A85            	  6527:                 cmpi.l #$00000000,d5
00:00005E76 66FE            	  6528:                 bne.s *
                            	  6529: 
                            	  6530: 
                            	  6531: *        LONG LEFT
00:00005E78 203C80018FF1    	  6532:                 move.l #$80018FF1,d0
00:00005E7E 7C02            	  6533:                 moveq  #$00000002,d6
                            	  6534: SHIFTS2_LOOP5:
00:00005E80 EDA8            	  6535:                 lsl.l d6,d0
00:00005E82 6100FF76        	  6536:                 bsr SHIFTS2_FLAGS
00:00005E86 51CEFFF8        	  6537:                 dbf d6,SHIFTS2_LOOP5
00:00005E8A 0C80000C7F88    	  6538:                 cmpi.l #$000C7F88,d0
00:00005E90 66FE            	  6539:                 bne.s *
00:00005E92 4A85            	  6540:                 cmpi.l #$00000000,d5
00:00005E94 66FE            	  6541:                 bne.s *
                            	  6542: 
                            	  6543: *        LONG RIGHT
00:00005E96 203C80018FF1    	  6544:                 move.l #$80018FF1,d0
00:00005E9C 7C02            	  6545:                 moveq  #$00000002,d6
                            	  6546: SHIFTS2_LOOP6:
00:00005E9E ECA8            	  6547:                 lsr.l d6,d0
00:00005EA0 6100FF58        	  6548:                 bsr SHIFTS2_FLAGS
00:00005EA4 51CEFFF8        	  6549:                 dbf d6,SHIFTS2_LOOP6
00:00005EA8 0C80100031FE    	  6550:                 cmpi.l #$100031FE,d0
00:00005EAE 66FE            	  6551:                 bne.s *
00:00005EB0 4A85            	  6552:                 cmpi.l #$00000000,d5
00:00005EB2 66FE            	  6553:                 bne.s *
                            	  6554: 
                            	  6555: 
                            	  6556: *     Shift a Register LEFT and RIGHT with shift_count ## IN THE OPCODE ##
                            	  6557: 
00:00005EB4 203C80018FF1    	  6558:                 move.l #$80018FF1,d0
00:00005EBA 7A00            	  6559:                 moveq  #$00000000,d5
                            	  6560: 
                            	  6561: *        BYTE LEFT
00:00005EBC E308            	  6562:                 lsl.b #1,d0
00:00005EBE 6100FF3A        	  6563:                 bsr SHIFTS2_FLAGS
00:00005EC2 E508            	  6564:                 lsl.b #2,d0
00:00005EC4 6100FF34        	  6565:                 bsr SHIFTS2_FLAGS
00:00005EC8 E308            	  6566:                 lsl.b #1,d0
00:00005ECA 6100FF2E        	  6567:                 bsr SHIFTS2_FLAGS
00:00005ECE E708            	  6568:                 lsl.b #3,d0
00:00005ED0 6100FF28        	  6569:                 bsr SHIFTS2_FLAGS
00:00005ED4 0C8080018F80    	  6570:                 cmpi.l #$80018F80,d0
00:00005EDA 66FE            	  6571:                 bne.s *
00:00005EDC 0C850000001B    	  6572:                 cmpi.l #$0000001B,d5
00:00005EE2 66FE            	  6573:                 bne.s *
                            	  6574: 
                            	  6575: *        BYTE RIGHT
00:00005EE4 E208            	  6576:                 lsr.b #1,d0
00:00005EE6 6100FF12        	  6577:                 bsr SHIFTS2_FLAGS
00:00005EEA E408            	  6578:                 lsr.b #2,d0
00:00005EEC 6100FF0C        	  6579:                 bsr SHIFTS2_FLAGS
00:00005EF0 E608            	  6580:                 lsr.b #3,d0
00:00005EF2 6100FF06        	  6581:                 bsr SHIFTS2_FLAGS
00:00005EF6 E208            	  6582:                 lsr.b #1,d0
00:00005EF8 6100FF00        	  6583:                 bsr SHIFTS2_FLAGS
00:00005EFC 0C8080018F01    	  6584:                 cmpi.l #$80018F01,d0
00:00005F02 66FE            	  6585:                 bne.s *
00:00005F04 0C850000001B    	  6586:                 cmpi.l #$0000001B,d5
00:00005F0A 66FE            	  6587:                 bne.s *
                            	  6588: 
                            	  6589: *        WORD LEFT
00:00005F0C E348            	  6590:                 lsl.w #1,d0
00:00005F0E 6100FEEA        	  6591:                 bsr SHIFTS2_FLAGS
00:00005F12 E548            	  6592:                 lsl.w #2,d0
00:00005F14 6100FEE4        	  6593:                 bsr SHIFTS2_FLAGS
00:00005F18 E748            	  6594:                 lsl.w #3,d0
00:00005F1A 6100FEDE        	  6595:                 bsr SHIFTS2_FLAGS
00:00005F1E EB48            	  6596:                 lsl.w #5,d0
00:00005F20 6100FED8        	  6597:                 bsr SHIFTS2_FLAGS
00:00005F24 0C8080010800    	  6598:                 cmpi.l #$80010800,d0
00:00005F2A 66FE            	  6599:                 bne.s *
00:00005F2C 0C8500000025    	  6600:                 cmpi.l #$00000025,d5
00:00005F32 66FE            	  6601:                 bne.s *
                            	  6602: 
                            	  6603: *        WORD RIGHT
00:00005F34 EA48            	  6604:                 lsr.w #5,d0
00:00005F36 6100FEC2        	  6605:                 bsr SHIFTS2_FLAGS
00:00005F3A E248            	  6606:                 lsr.w #1,d0
00:00005F3C 6100FEBC        	  6607:                 bsr SHIFTS2_FLAGS
00:00005F40 E448            	  6608:                 lsr.w #2,d0
00:00005F42 6100FEB6        	  6609:                 bsr SHIFTS2_FLAGS
00:00005F46 E848            	  6610:                 lsr.w #4,d0
00:00005F48 6100FEB0        	  6611:                 bsr SHIFTS2_FLAGS
00:00005F4C 0C8080010000    	  6612:                 cmpi.l #$80010000,d0
00:00005F52 66FE            	  6613:                 bne.s *
00:00005F54 0C850000002A    	  6614:                 cmpi.l #$0000002A,d5
00:00005F5A 66FE            	  6615:                 bne.s *
                            	  6616: 
                            	  6617: *        LONG LEFT
00:00005F5C 203C80018FF1    	  6618:                 move.l #$80018FF1,d0
00:00005F62 E388            	  6619:                 lsl.l #1,d0
00:00005F64 6100FE94        	  6620:                 bsr SHIFTS2_FLAGS
00:00005F68 E588            	  6621:                 lsl.l #2,d0
00:00005F6A 6100FE8E        	  6622:                 bsr SHIFTS2_FLAGS
00:00005F6E EF88            	  6623:                 lsl.l #7,d0
00:00005F70 6100FE88        	  6624:                 bsr SHIFTS2_FLAGS
00:00005F74 E988            	  6625:                 lsl.l #4,d0
00:00005F76 6100FE82        	  6626:                 bsr SHIFTS2_FLAGS
00:00005F7A 0C8063FC4000    	  6627:                 cmpi.l #$63FC4000,d0
00:00005F80 66FE            	  6628:                 bne.s *
00:00005F82 0C850000002B    	  6629:                 cmpi.l #$0000002B,d5
00:00005F88 66FE            	  6630:                 bne.s *
                            	  6631: 
                            	  6632: *        LONG RIGHT
00:00005F8A 203C80018FF1    	  6633:                 move.l #$80018FF1,d0
00:00005F90 E288            	  6634:                 lsr.l #1,d0
00:00005F92 6100FE66        	  6635:                 bsr SHIFTS2_FLAGS
00:00005F96 EA88            	  6636:                 lsr.l #5,d0
00:00005F98 6100FE60        	  6637:                 bsr SHIFTS2_FLAGS
00:00005F9C EE88            	  6638:                 lsr.l #7,d0
00:00005F9E 6100FE5A        	  6639:                 bsr SHIFTS2_FLAGS
00:00005FA2 E088            	  6640:                 lsr.l #8,d0
00:00005FA4 6100FE54        	  6641:                 bsr SHIFTS2_FLAGS
00:00005FA8 0C8000000400    	  6642:                 cmpi.l #$00000400,d0
00:00005FAE 66FE            	  6643:                 bne.s *
00:00005FB0 0C850000002D    	  6644:                 cmpi.l #$0000002D,d5
00:00005FB6 66FE            	  6645:                 bne.s *
                            	  6646: 
                            	  6647: 
                            	  6648: *     Shift a Memory location LEFT and RIGHT with shift_count of 1 - WORD only
                            	  6649: 
00:00005FB8 7A00            	  6650:                 moveq  #$00000000,d5
00:00005FBA 307C0100        	  6651:                 move.l #$00000100,a0
00:00005FBE 30BC8FF1        	  6652:                 move.w #$8FF1,(a0)
                            	  6653: 
                            	  6654: *        WORD LEFT
00:00005FC2 E3D0            	  6655:                 lsl  (a0)
00:00005FC4 6100FE34        	  6656:                 bsr SHIFTS2_FLAGS
00:00005FC8 E3D0            	  6657:                 lsl  (a0)
00:00005FCA 6100FE2E        	  6658:                 bsr SHIFTS2_FLAGS
00:00005FCE E3D0            	  6659:                 lsl  (a0)
00:00005FD0 6100FE28        	  6660:                 bsr SHIFTS2_FLAGS
00:00005FD4 E3D0            	  6661:                 lsl  (a0)
00:00005FD6 6100FE22        	  6662:                 bsr SHIFTS2_FLAGS
00:00005FDA 3010            	  6663:                 move.w (a0),d0
00:00005FDC 0C800000FF10    	  6664:                 cmpi.l #$0000FF10,d0
00:00005FE2 66FE            	  6665:                 bne.s *
00:00005FE4 0C8500000009    	  6666:                 cmpi.l #$00000009,d5
00:00005FEA 66FE            	  6667:                 bne.s *
                            	  6668: 
                            	  6669: *        WORD RIGHT
00:00005FEC E2D0            	  6670:                 lsr (a0)
00:00005FEE 6100FE0A        	  6671:                 bsr SHIFTS2_FLAGS
00:00005FF2 E2D0            	  6672:                 lsr (a0)
00:00005FF4 6100FE04        	  6673:                 bsr SHIFTS2_FLAGS
00:00005FF8 E2D0            	  6674:                 lsr (a0)
00:00005FFA 6100FDFE        	  6675:                 bsr SHIFTS2_FLAGS
00:00005FFE E2D0            	  6676:                 lsr (a0)
00:00006000 6100FDF8        	  6677:                 bsr SHIFTS2_FLAGS
00:00006004 E2D0            	  6678:                 lsr (a0)
00:00006006 6100FDF2        	  6679:                 bsr SHIFTS2_FLAGS
00:0000600A E2D0            	  6680:                 lsr (a0)
00:0000600C 6100FDEC        	  6681:                 bsr SHIFTS2_FLAGS
00:00006010 3010            	  6682:                 move.w (a0),d0
00:00006012 0C80000003FC    	  6683:                 cmpi.l #$000003FC,d0
00:00006018 66FE            	  6684:                 bne.s *
00:0000601A 0C850000000A    	  6685:                 cmpi.l #$0000000A,d5
00:00006020 66FE            	  6686:                 bne.s *
                            	  6687: 
00:00006022 4E75            	  6688:                 rts
                            	  6689: 
                            	  6690: ;-----------------------------------------------------------
                            	  6691: ;-----------------------------------------------------------
                            	  6692: ; OPCODE : BSR / RTS
                            	  6693: ;-----------------------------------------------------------
                            	  6694: ;-----------------------------------------------------------
                            	  6695: 
                            	  6696: ;t3_bsr:
                            	  6697: ;	moveq	#3,d3
                            	  6698: ;	rts
                            	  6699: 
                            	  6700: ;t1_bsr:
                            	  6701: ;	moveq	#1,d1
                            	  6702: ;	rts
                            	  6703: 
                            	  6704: ;op_bsr:
                            	  6705: ;	bsr			t1_bsr
                            	  6706: ;	bsr			t2_bsr
                            	  6707: ;	bsr.w		t3_bsr
                            	  6708: ;	bsr.w		t4_bsr
                            	  6709: ;	cmpi.l	#1,d1
                            	  6710: ;	bne			*
                            	  6711: ;	cmpi.l	#2,d2
                            	  6712: ;	bne			*
                            	  6713: ;	cmpi.l	#3,d3
                            	  6714: ;	bne			*
                            	  6715: ;	cmpi.l	#4,d4
                            	  6716: ;	bne			*
                            	  6717: ;	rts
                            	  6718: 
                            	  6719: ;t2_bsr:
                            	  6720: ;	moveq	#2,d2
                            	  6721: ;	rts
                            	  6722: 	
                            	  6723: ;t4_bsr:
                            	  6724: ;	moveq	#4,d4
                            	  6725: ;	rts
                            	  6726: *    END
                            	  6727:     
                            	  6728: 

Source: "boot.x68"
                            	   943: 	include "TinyBasicFlt.x68"

Source: "TinyBasicFlt.x68"
                            	     1: ******************************************************************
                            	     2: *								 *
                            	     3: *		Tiny Float BASIC for the Motorola MC68000		 *
                            	     4: *								 *
                            	     5: * Derived from Palo Alto Tiny BASIC as published in the May 1976 *
                            	     6: * issue of Dr. Dobb's Journal.  Adapted to the 68000 by:         *
                            	     7: *	Gordon Brandly						 *
                            	     8: *								 *
                            	     9: ******************************************************************
                            	    10: *    Copyright (C) 1984 by Gordon Brandly. This program may be	 *
                            	    11: *    freely distributed for personal use only. All commercial	 *
                            	    12: *		       rights are reserved.			 *
                            	    13: ******************************************************************
                            	    14: * Modified (c) 2022 for the rf68000. Robert Finch
                            	    15: * Numerics changed to floating-point
                            	    16: * added string handling
                            	    17: ******************************************************************
                            	    18: 
                            	    19: * Vers. 1.0  1984/7/17	- Original version by Gordon Brandly
                            	    20: *	1.1  1984/12/9	- Addition of '$' print term by Marvin Lipford
                            	    21: *	1.2  1985/4/9	- Bug fix in multiply routine by Rick Murray
                            	    22: 
                            	    23: *	OPT	FRS,BRS 	forward ref.'s & branches default to short
                            	    24: 
                            	    25: ;CR	EQU	$0D		ASCII equates
                            	    26: ;LF	EQU	$0A
                            	    27: ;TAB	EQU	$09
                            	    28: ;CTRLC	EQU	$03
                            	    29: ;CTRLH	EQU	$08
                            	    30: ;CTRLS	EQU	$13
                            	    31: ;CTRLX	EQU	$18
                            	    32: 
                            	    33: DT_NONE equ 0
                            	    34: DT_NUMERIC equ 1
                            	    35: DT_STRING equ 2		; string descriptor
                            	    36: DT_TEXTPTR equ 3	; pointer into program text
                            	    37: 
                            	    38: BUFLEN	EQU	80		length of keyboard input buffer
                            	    39: STRAREASIZE	EQU	2048	; size of string area
                            	    40: 	CODE
                            	    41: *	ORG	$10000		first free address using Tutor
                            	    42: *
                            	    43: * Standard jump table. You can change these addresses if you are
                            	    44: * customizing this interpreter for a different environment.
                            	    45: *
00:00006024 6020            	    46: START	BRA	CSTART		Cold Start entry point
00:00006026 60000088        	    47: GOWARM	BRA	WSTART		Warm Start entry point
00:0000602A 60001460        	    48: GOOUT	BRA OUTC		Jump to character-out routine
00:0000602E 6000146C        	    49: GOIN	BRA INC		Jump to character-in routine
00:00006032 60001488        	    50: GOAUXO	BRA	AUXOUT		Jump to auxiliary-out routine
00:00006036 60001498        	    51: GOAUXI	BRA	AUXIN		Jump to auxiliary-in routine
00:0000603A 600014B4        	    52: GOBYE	BRA	BYEBYE		Jump to monitor, DOS, etc.
                            	    53: *
                            	    54: * Modifiable system constants:
                            	    55: *
00:0000603E 00041000        	    56: TXTBGN	DC.L	$41000		beginning of program memory
00:00006042 00047FF0        	    57: ENDMEM	DC.L	$47FF0		end of available memory
                            	    58: *
                            	    59: * The main interpreter starts here:
                            	    60: *
                            	    61: CSTART
00:00006046 2E7AFFFA        	    62: 	MOVE.L ENDMEM,SP	initialize stack pointer
00:0000604A 23FC000074A80000	    63: 	move.l #INC1,INPPTR
00:00006052 7560
00:00006054 4239000400A4    	    64: 	move.b #0,InputDevice
00:0000605A 13FC0001000400A8	    65: 	move.b #1,OutputDevice
00:00006062 23FC000000010004	    66: 	move.l #1,_fpTextIncr
00:0000606A 0094
00:0000606C 4DFA1490        	    67: 	LEA	INITMSG,A6	tell who we are
00:00006070 61001402        	    68: 	BSR	PRMESG
00:00006074 23FAFFC8000075B0	    69: 	MOVE.L TXTBGN,TXTUNF	init. end-of-program pointer
00:0000607C 203AFFC4        	    70: 	MOVE.L ENDMEM,D0	get address of end of memory
00:00006080 23FAFFC00000756C	    71: 	move.l ENDMEM,STKFP
00:00006088 90BC00001000    	    72: 	SUB.L	#4096,D0	reserve 4K for the stack
00:0000608E 23C0000075A0    	    73: 	MOVE.L D0,STRSTK
00:00006094 D0BC00000020    	    74: 	ADD.L #32,D0
00:0000609A 23C0000075B8    	    75: 	MOVE.L D0,STKLMT
00:000060A0 90BC00000200    	    76: 	SUB.L	#512,D0 	reserve variable area (32 16 byte floats)
00:000060A6 23C0000075B4    	    77: 	MOVE.L D0,VARBGN
00:000060AC 610000C2        	    78: 	bsr ClearStringArea
                            	    79: WSTART
00:000060B0 7000            	    80: 	CLR.L	D0		initialize internal variables
00:000060B2 23FC000000010004	    81: 	move.l #1,_fpTextIncr
00:000060BA 0094
00:000060BC 42B90000759C    	    82: 	clr.l IRQROUT
00:000060C2 23C000007578    	    83: 	MOVE.L	D0,LOPVAR
00:000060C8 23C000007570    	    84: 	MOVE.L	D0,STKGOS
00:000060CE 23C000007568    	    85: 	MOVE.L	D0,CURRNT	; current line number pointer = 0
00:000060D4 2E7AFF6C        	    86: 	MOVE.L ENDMEM,SP	; init S.P. again, just in case
00:000060D8 610000B6        	    87: 	bsr ClearStringStack
00:000060DC 4DFA1444        	    88: 	LEA	OKMSG,A6			; display "OK"
00:000060E0 61001392        	    89: 	bsr	PRMESG
                            	    90: ST3
00:000060E4 103C003E        	    91: 	MOVE.B	#'>',D0         Prompt with a '>' and
00:000060E8 610010CE        	    92: 	bsr	GETLN		read a line.
00:000060EC 6100132A        	    93: 	bsr	TOUPBUF 	convert to upper case
00:000060F0 2848            	    94: 	MOVE.L	A0,A4		save pointer to end of line
00:000060F2 41FA14CC        	    95: 	LEA	BUFFER,A0	point to the beginning of line
00:000060F6 610012CA        	    96: 	bsr	TSTNUM		is there a number there?
00:000060FA 61001312        	    97: 	bsr	IGNBLK		skip trailing blanks
00:000060FE F2016080        	    98: 	FMOVE.L FP1,D1
00:00006102 4A82            	    99: 	TST.L D2			; does line no. exist? (or nonzero?)
00:00006104 67000246        	   100: 	BEQ	DIRECT		; if not, it's a direct statement
00:00006108 B2BC0000FFFF    	   101: 	CMP.L	#$FFFF,D1	see if line no. is <= 16 bits
00:0000610E 6400109A        	   102: 	BCC	QHOW		if not, we've overflowed
00:00006112 1101            	   103: 	MOVE.B	D1,-(A0)	store the binary line no.
00:00006114 E059            	   104: 	ROR	#8,D1		(Kludge to store a word on a
00:00006116 1101            	   105: 	MOVE.B	D1,-(A0)	possible byte boundary)
00:00006118 E159            	   106: 	ROL	#8,D1
00:0000611A 6100113A        	   107: 	bsr	FNDLN		find this line in save area
00:0000611E 2A49            	   108: 	MOVE.L	A1,A5		save possible line pointer
00:00006120 6614            	   109: 	BNE	ST4		if not found, insert
00:00006122 61001158        	   110: 	bsr	FNDNXT		find the next line (into A1)
00:00006126 244D            	   111: 	MOVE.L	A5,A2		pointer to line to be deleted
00:00006128 267A1486        	   112: 	MOVE.L	TXTUNF,A3	points to top of save area
00:0000612C 6100115E        	   113: 	bsr	MVUP		move up to delete
00:00006130 23CA000075B0    	   114: 	MOVE.L	A2,TXTUNF	update the end pointer
                            	   115: ST4
00:00006136 200C            	   116: 	MOVE.L	A4,D0		calculate the length of new line
00:00006138 9088            	   117: 	SUB.L	A0,D0
00:0000613A B0BC00000003    	   118: 	CMP.L	#3,D0		is it just a line no. & CR?
00:00006140 6FA2            	   119: 	BLE	ST3		if so, it was just a delete
00:00006142 267A146C        	   120: 	MOVE.L TXTUNF,A3	compute new end
00:00006146 2C4B            	   121: 	MOVE.L A3,A6
00:00006148 D7C0            	   122: 	ADD.L	D0,A3
00:0000614A 203A145C        	   123: 	MOVE.L StrArea,D0	see if there's enough room
00:0000614E B08B            	   124: 	CMP.L	A3,D0
00:00006150 63001050        	   125: 	BLS	QSORRY		if not, say so
00:00006154 23CB000075B0    	   126: 	MOVE.L	A3,TXTUNF	if so, store new end position
00:0000615A 224E            	   127: 	MOVE.L	A6,A1		points to old unfilled area
00:0000615C 244D            	   128: 	MOVE.L	A5,A2		points to beginning of move area
00:0000615E 61001140        	   129: 	bsr	MVDOWN		move things out of the way
00:00006162 2248            	   130: 	MOVE.L	A0,A1		set up to do the insertion
00:00006164 244D            	   131: 	MOVE.L	A5,A2
00:00006166 264C            	   132: 	MOVE.L	A4,A3
00:00006168 61001122        	   133: 	bsr	MVUP		do it
00:0000616C 6000FF76        	   134: 	BRA	ST3		go back and get another line
                            	   135: 
                            	   136: ClearStringArea:
00:00006170 203A1442        	   137: 	move.l VARBGN,d0
00:00006174 90BC00000800    	   138: 	SUB.L #STRAREASIZE,D0
00:0000617A 23C0000075A8    	   139: 	MOVE.L D0,StrArea
00:00006180 23C0000075AC    	   140: 	MOVE.L D0,LastStr
00:00006186 207A1420        	   141: 	move.l StrArea,a0
00:0000618A 4298            	   142: 	clr.l (a0)+
00:0000618C 4298            	   143: 	clr.l (a0)+
00:0000618E 4E75            	   144: 	rts
                            	   145: 
                            	   146: ClearStringStack:
00:00006190 7007            	   147: 	moveq #7,d0
00:00006192 227A140C        	   148: 	move.l STRSTK,a1
                            	   149: .0001
00:00006196 4299            	   150: 	clr.l (a1)+				; clear the string stack
00:00006198 51C8FFFC        	   151: 	dbra d0,.0001
00:0000619C 23C9000075A4    	   152: 	move.l a1,StrSp		; set string stack stack pointer
00:000061A2 4E75            	   153: 	rts
                            	   154: 
                            	   155: 	even
                            	   156: 
                            	   157: *******************************************************************
                            	   158: *
                            	   159: * *** Tables *** DIRECT *** EXEC ***
                            	   160: *
                            	   161: * This section of the code tests a string against a table. When
                            	   162: * a match is found, control is transferred to the section of
                            	   163: * code according to the table.
                            	   164: *
                            	   165: * At 'EXEC', A0 should point to the string, A1 should point to
                            	   166: * the character table, and A2 should point to the execution
                            	   167: * table. At 'DIRECT', A0 should point to the string, A1 and
                            	   168: * A2 will be set up to point to TAB1 and TAB1_1, which are
                            	   169: * the tables of all direct and statement commands.
                            	   170: *
                            	   171: * A '.' in the string will terminate the test and the partial
                            	   172: * match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
                            	   173: * 'PRIN.', or 'PRINT' will all match 'PRINT'.
                            	   174: *
                            	   175: * There are two tables: the character table and the execution
                            	   176: * table. The character table consists of any number of text items.
                            	   177: * Each item is a string of characters with the last character's
                            	   178: * high bit set to one. The execution table holds a 16-bit
                            	   179: * execution addresses that correspond to each entry in the
                            	   180: * character table.
                            	   181: *
                            	   182: * The end of the character table is a 0 byte which corresponds
                            	   183: * to the default routine in the execution table, which is
                            	   184: * executed if none of the other table items are matched.
                            	   185: *
                            	   186: * Character-matching tables:
                            	   187: TAB1
00:000061A4 3C434F          	   188: 	DC.B	'<CO',('M'+$80)
00:000061A7 CD
00:000061A8 3C434F          	   189: 	DC.B	'<CO',('N'+$80)
00:000061AB CE
00:000061AC 3E434F          	   190: 	DC.B	'>CO',('M'+$80)
00:000061AF CD
00:000061B0 3E434F          	   191: 	DC.B	'>CO',('N'+$80)
00:000061B3 CE
00:000061B4 3C3E434F        	   192: 	DC.B	'<>CO',('M'+$80)
00:000061B8 CD
00:000061B9 3C3E434F        	   193: 	DC.B	'<>CO',('N'+$80)
00:000061BD CE
00:000061BE 4C4953          	   194: 	DC.B	'LIS',('T'+$80)         Direct commands
00:000061C1 D4
00:000061C2 4C4F41          	   195: 	DC.B	'LOA',('D'+$80)
00:000061C5 C4
00:000061C6 4E45            	   196: 	DC.B	'NE',('W'+$80)
00:000061C8 D7
00:000061C9 5255            	   197: 	DC.B	'RU',('N'+$80)
00:000061CB CE
00:000061CC 534156          	   198: 	DC.B	'SAV',('E'+$80)
00:000061CF C5
00:000061D0 434C            	   199: 	DC.B 	'CL',('S'+$80)
00:000061D2 D3
                            	   200: TAB2
00:000061D3 4E4558          	   201: 	DC.B	'NEX',('T'+$80)         Direct / statement
00:000061D6 D4
00:000061D7 4C45            	   202: 	DC.B	'LE',('T'+$80)
00:000061D9 D4
00:000061DA 49              	   203: 	DC.B	'I',('F'+$80)
00:000061DB C6
00:000061DC 474F54          	   204: 	DC.B	'GOT',('O'+$80)
00:000061DF CF
00:000061E0 474F5355        	   205: 	DC.B	'GOSU',('B'+$80)
00:000061E4 C2
00:000061E5 5245545552      	   206: 	DC.B	'RETUR',('N'+$80)
00:000061EA CE
00:000061EB 5245            	   207: 	DC.B	'RE',('M'+$80)
00:000061ED CD
00:000061EE 464F            	   208: 	DC.B	'FO',('R'+$80)
00:000061F0 D2
00:000061F1 494E5055        	   209: 	DC.B	'INPU',('T'+$80)
00:000061F5 D4
00:000061F6 5052494E        	   210: 	DC.B	'PRIN',('T'+$80)
00:000061FA D4
00:000061FB 504F4B          	   211: 	DC.B	'POK',('E'+$80)
00:000061FE C5
00:000061FF 53544F          	   212: 	DC.B	'STO',('P'+$80)
00:00006202 D0
00:00006203 4259            	   213: 	DC.B	'BY',('E'+$80)
00:00006205 C5
00:00006206 43414C          	   214: 	DC.B	'CAL',('L'+$80)
00:00006209 CC
00:0000620A 4F4E4952        	   215: 	DC.B	'ONIR',('Q'+$80)
00:0000620E D1
00:0000620F 00              	   216: 	DC.B	0
                            	   217: TAB4
00:00006210 504545          	   218: 	DC.B	'PEE',('K'+$80)         Functions
00:00006213 CB
00:00006214 524E            	   219: 	DC.B	'RN',('D'+$80)
00:00006216 C4
00:00006217 4142            	   220: 	DC.B	'AB',('S'+$80)
00:00006219 D3
00:0000621A 53495A          	   221: 	DC.B	'SIZ',('E'+$80)
00:0000621D C5
00:0000621E 544943          	   222: 	DC.B	'TIC',('K'+$80)
00:00006221 CB
00:00006222 434F52454E      	   223: 	DC.B	'COREN',('O'+$80)
00:00006227 CF
00:00006228 4C454654        	   224: 	DC.B	'LEFT',('$'+$80)
00:0000622C A4
00:0000622D 5249474854      	   225: 	DC.B	'RIGHT',('$'+$80)
00:00006232 A4
00:00006233 4D4944          	   226: 	DC.B	'MID',('$'+$80)
00:00006236 A4
00:00006237 4C45            	   227: 	DC.B	'LE',('N'+$80)
00:00006239 CE
00:0000623A 494E            	   228: 	DC.B	'IN',('T'+$80)
00:0000623C D4
00:0000623D 434852          	   229: 	DC.B	'CHR',('$'+$80)
00:00006240 A4
00:00006241 00              	   230: 	DC.B	0
                            	   231: TAB5
00:00006242 54              	   232: 	DC.B	'T',('O'+$80)           "TO" in "FOR"
00:00006243 CF
00:00006244 00              	   233: 	DC.B	0
                            	   234: TAB6
00:00006245 535445          	   235: 	DC.B	'STE',('P'+$80)         "STEP" in "FOR"
00:00006248 D0
00:00006249 00              	   236: 	DC.B	0
                            	   237: TAB8
00:0000624A 3E              	   238: 	DC.B	'>',('='+$80)           Relational operators
00:0000624B BD
00:0000624C 3C              	   239: 	DC.B	'<',('>'+$80)
00:0000624D BE
00:0000624E BE              	   240: 	DC.B	('>'+$80)
00:0000624F BD              	   241: 	DC.B	('='+$80)
00:00006250 3C              	   242: 	DC.B	'<',('='+$80)
00:00006251 BD
00:00006252 BC              	   243: 	DC.B	('<'+$80)
00:00006253 00              	   244: 	DC.B	0
00:00006254 00              	   245: 	DC.B	0	<- for aligning on a word boundary
                            	   246: TAB9
00:00006255 414E            	   247: 	DC.B	'AN',('D'+$80)
00:00006257 C4
00:00006258 00              	   248: 	DC.B	0
                            	   249: TAB10
00:00006259 4F              	   250: 	DC.B	'O',('R'+$80)
00:0000625A D2
00:0000625B 00              	   251: 	DC.B	0
                            	   252: TAB11
00:0000625C 4D4F            	   253: 	DC.B	'MO',('D'+$80)
00:0000625E C4
00:0000625F 00              	   254: 	DC.B	0
00:00006260 00              	   255: 	DC.B	0
                            	   256: 
                            	   257: ; Execution address tables:
                            	   258: 	align 2
                            	   259: TAB1_1	
00:00006264 000063A4        	   260: 	DC.L	INCOM
00:00006268 00006396        	   261: 	DC.L	INCON
00:0000626C 000063BC        	   262: 	DC.L	OUTCOM
00:00006270 000063D2        	   263: 	DC.L	OUTCON
00:00006274 000063B2        	   264: 	DC.L	IOCOM
00:00006278 000063C8        	   265: 	DC.L	IOCON
00:0000627C 000064BC        	   266: 	DC.L	LIST			Direct commands
00:00006280 0000679A        	   267: 	DC.L	LOAD
00:00006284 000063DE        	   268: 	DC.L	NEW
00:00006288 000063FA        	   269: 	DC.L	RUN
00:0000628C 000067FA        	   270: 	DC.L	SAVE
00:00006290 00007480        	   271: 	DC.L	CLS
                            	   272: TAB2_1
00:00006294 00006658        	   273: 	DC.L	NEXT			Direct / statement
00:00006298 0000678A        	   274: 	DC.L	LET
00:0000629C 000066C4        	   275: 	DC.L	IF
00:000062A0 00006474        	   276: 	DC.L	GOTO
00:000062A4 00006572        	   277: 	DC.L	GOSUB
00:000062A8 000065AC        	   278: 	DC.L	RETURN
00:000062AC 000066C2        	   279: 	DC.L	REM
00:000062B0 000065D8        	   280: 	DC.L	FOR
00:000062B4 000066EC        	   281: 	DC.L	INPUT
00:000062B8 000064E8        	   282: 	DC.L	PRINT
00:000062BC 00006878        	   283: 	DC.L	POKE
00:000062C0 000063F2        	   284: 	DC.L	STOP
00:000062C4 0000603A        	   285: 	DC.L	GOBYE
00:000062C8 000068F2        	   286: 	DC.L	CALL
00:000062CC 00006488        	   287: 	DC.L	ONIRQ
00:000062D0 00006782        	   288: 	DC.L	DEFLT
                            	   289: TAB4_1
00:000062D4 00006EA2        	   290: 	DC.L	PEEK			; Functions
00:000062D8 00006F0A        	   291: 	DC.L	RND
00:000062DC 00006F34        	   292: 	DC.L	ABS
00:000062E0 00006F40        	   293: 	DC.L	SIZE
00:000062E4 00006F50        	   294: 	DC.L	TICK
00:000062E8 00006F5C        	   295: 	DC.L	CORENO
00:000062EC 0000706E        	   296: 	DC.L	LEFT
00:000062F0 0000707A        	   297: 	DC.L	RIGHT
00:000062F4 00006FA4        	   298: 	DC.L	MID
00:000062F8 000070A2        	   299: 	DC.L	LEN
00:000062FC 000070C8        	   300: 	DC.L	INT
00:00006300 000070DE        	   301: 	DC.L  CHR
00:00006304 00006BAC        	   302: 	DC.L	XP40
                            	   303: TAB5_1
00:00006308 000065F2        	   304: 	DC.L	FR1			; "TO" in "FOR"
00:0000630C 00007162        	   305: 	DC.L	QWHAT
                            	   306: TAB6_1
00:00006310 0000660A        	   307: 	DC.L	FR2			; "STEP" in "FOR"
00:00006314 00006610        	   308: 	DC.L	FR3
                            	   309: TAB8_1
00:00006318 000069E2        	   310: 	DC.L	XP11	>=		Relational operators
00:0000631C 000069EE        	   311: 	DC.L	XP12	<>
00:00006320 000069FA        	   312: 	DC.L	XP13	>
00:00006324 00006A12        	   313: 	DC.L	XP15	=
00:00006328 00006A06        	   314: 	DC.L	XP14	<=
00:0000632C 00006A20        	   315: 	DC.L	XP16	<
00:00006330 00006A3E        	   316: 	DC.L	XP17
                            	   317: TAB9_1
00:00006334 000069A0        	   318: 	DC.L	XP_AND
00:00006338 000069B6        	   319: 	DC.L	XP_ANDX
                            	   320: TAB10_1
00:0000633C 00006978        	   321: 	DC.L	XP_OR
00:00006340 000069B6        	   322: 	DC.L	XP_ORX
                            	   323: TAB11_1
00:00006344 00006B7E        	   324: 	DC.L	XP_MOD
00:00006348 00006B48        	   325: 	DC.L	XP31
                            	   326: 	even
                            	   327: 	
                            	   328: DIRECT
00:0000634C 33FC0001000075BC	   329: 	move.w #1,DIRFLG
00:00006354 43FAFE4E        	   330: 	LEA	TAB1,A1
00:00006358 45FAFF0A        	   331: 	LEA	TAB1_1,A2
                            	   332: EXEC
00:0000635C 610010B0        	   333: 	bsr	IGNBLK				; ignore leading blanks
00:00006360 2648            	   334: 	MOVE.L A0,A3			; save the pointer
00:00006362 4202            	   335: 	CLR.B	D2					; clear match flag
                            	   336: EXLP
00:00006364 1018            	   337: 	MOVE.B (A0)+,D0	 	; get the program character
00:00006366 1211            	   338: 	MOVE.B (A1),D1 		; get the table character
00:00006368 6604            	   339: 	BNE	EXNGO					; If end of table,
00:0000636A 204B            	   340: 	MOVE.L A3,A0			; restore the text pointer and...
00:0000636C 6024            	   341: 	BRA	EXGO					; execute the default.
                            	   342: EXNGO
00:0000636E 1600            	   343: 	MOVE.B D0,D3		 	; Else check for period...
00:00006370 C602            	   344: 	AND.B	D2,D3				; and a match.
00:00006372 B63C002E        	   345: 	CMP.B	#'.',D3
00:00006376 671A            	   346: 	BEQ	EXGO					; if so, execute
00:00006378 C23C007F        	   347: 	AND.B	#$7F,D1 		; ignore the table's high bit
00:0000637C B200            	   348: 	CMP.B	D0,D1				; is there a match?
00:0000637E 670C            	   349: 	BEQ	EXMAT
00:00006380 588A            	   350: 	ADDQ.L #4,A2			; if not, try the next entry
00:00006382 204B            	   351: 	MOVE.L A3,A0			; reset the program pointer
00:00006384 4202            	   352: 	CLR.B	D2					; sorry, no match
                            	   353: EX1
00:00006386 4A19            	   354: 	TST.B	(A1)+				; get to the end of the entry
00:00006388 6AFC            	   355: 	BPL	EX1
00:0000638A 60D8            	   356: 	BRA	EXLP					; back for more matching
                            	   357: EXMAT
00:0000638C 74FF            	   358: 	MOVEQ	#-1,D2			; we've got a match so far
00:0000638E 4A19            	   359: 	TST.B	(A1)+				; end of table entry?
00:00006390 6AD2            	   360: 	BPL	EXLP					; if not, go back for more
                            	   361: EXGO
00:00006392 2652            	   362: 	MOVE.L (A2),A3		; execute the appropriate routine
00:00006394 4ED3            	   363: 	JMP	(A3)
                            	   364: 
                            	   365: *******************************************************************
                            	   366: * Console redirection
                            	   367: * <COM will redirect input to the COM port
                            	   368: * >COM will redirect output to the COM port
                            	   369: * <CON will redirect input to the console
                            	   370: * >CON will redirect output to the console
                            	   371: * <>COM will redirect input and output to the COM port
                            	   372: * <>CON will redirect input and output to the console
                            	   373: *******************************************************************
                            	   374: INCON
00:00006396 23FC000074A80000	   375: 	move.l	#INC1,INPPTR
00:0000639E 7560
00:000063A0 600001C8        	   376: 	bra			FINISH
                            	   377: INCOM
00:000063A4 23FC000074D00000	   378: 	move.l	#AUXIN,INPPTR
00:000063AC 7560
00:000063AE 600001BA        	   379: 	bra			FINISH
                            	   380: IOCOM
00:000063B2 23FC000074D00000	   381: 	move.l	#AUXIN,INPPTR
00:000063BA 7560
                            	   382: OUTCOM
00:000063BC 13FC0002000400A8	   383: 	move.b #2,OutputDevice
00:000063C4 600001A4        	   384: 	bra	FINISH
                            	   385: IOCON
00:000063C8 23FC000074A80000	   386: 	move.l	#INC1,INPPTR
00:000063D0 7560
                            	   387: OUTCON
00:000063D2 13FC0001000400A8	   388: 	move.b #1,OutputDevice
00:000063DA 6000018E        	   389: 	bra	FINISH
                            	   390: 
                            	   391: *******************************************************************
                            	   392: *
                            	   393: * What follows is the code to execute direct and statement
                            	   394: * commands. Control is transferred to these points via the command
                            	   395: * table lookup code of 'DIRECT' and 'EXEC' in the last section.
                            	   396: * After the command is executed, control is transferred to other
                            	   397: * sections as follows:
                            	   398: *
                            	   399: * For 'LIST', 'NEW', and 'STOP': go back to the warm start point.
                            	   400: * For 'RUN': go execute the first stored line if any; else go
                            	   401: * back to the warm start point.
                            	   402: * For 'GOTO' and 'GOSUB': go execute the target line.
                            	   403: * For 'RETURN' and 'NEXT'; go back to saved return line.
                            	   404: * For all others: if 'CURRNT' is 0, go to warm start; else go
                            	   405: * execute next command. (This is done in 'FINISH'.)
                            	   406: *
                            	   407: *******************************************************************
                            	   408: *
                            	   409: * *** NEW *** STOP *** RUN (& friends) *** GOTO ***
                            	   410: *
                            	   411: * 'NEW<CR>' sets TXTUNF to point to TXTBGN
                            	   412: *
                            	   413: * 'STOP<CR>' goes back to WSTART
                            	   414: *
                            	   415: * 'RUN<CR>' finds the first stored line, stores its address
                            	   416: * in CURRNT, and starts executing it. Note that only those
                            	   417: * commands in TAB2 are legal for a stored program.
                            	   418: *
                            	   419: * There are 3 more entries in 'RUN':
                            	   420: * 'RUNNXL' finds next line, stores it's address and executes it.
                            	   421: * 'RUNTSL' stores the address of this line and executes it.
                            	   422: * 'RUNSML' continues the execution on same line.
                            	   423: *
                            	   424: * 'GOTO expr<CR>' evaluates the expression, finds the target
                            	   425: * line, and jumps to 'RUNTSL' to do it.
                            	   426: *
                            	   427: NEW
00:000063DE 61000D70        	   428: 	bsr	ENDCHK
00:000063E2 23FAFC5A000075B0	   429: 	MOVE.L TXTBGN,TXTUNF	set the end pointer
00:000063EA 6100FD84        	   430: 	bsr ClearStringArea
00:000063EE 6100FDA0        	   431: 	bsr ClearStringStack
                            	   432: 
                            	   433: STOP
00:000063F2 61000D5C        	   434: 	bsr	ENDCHK
00:000063F6 6000FCB8        	   435: 	BRA	WSTART
                            	   436: 
                            	   437: RUN
00:000063FA 4279000075BC    	   438: 	clr.w DIRFLG
00:00006400 61000D4E        	   439: 	bsr	ENDCHK
00:00006404 207AFC38        	   440: 	MOVE.L	TXTBGN,A0	set pointer to beginning
00:00006408 23C800007568    	   441: 	MOVE.L	A0,CURRNT
                            	   442: 
                            	   443: RUNNXL
00:0000640E 4AB900007568    	   444: 	TST.L	CURRNT		; executing a program?
00:00006414 6700FC9A        	   445: 	beq	WSTART			; if not, we've finished a direct stat.
00:00006418 4AB90000759C    	   446: 	tst.l	IRQROUT		; are we handling IRQ's ?
00:0000641E 672E            	   447: 	beq	RUN1
00:00006420 4A39000400A0    	   448: 	tst.b IRQFlag		; was there an IRQ ?
00:00006426 6726            	   449: 	beq	RUN1
00:00006428 4239000400A0    	   450: 	clr.b IRQFlag
                            	   451: 
                            	   452: 	; same code as GOSUB	
                            	   453: ;	sub.l #128,sp		; allocate storage for local variables
                            	   454: ;	move.l STKFP,-(sp)
                            	   455: ;	move.l sp,STKFP
00:0000642E 61000EB4        	   456: 	bsr	PUSHA				; save the current 'FOR' parameters
00:00006432 2F08            	   457: 	MOVE.L A0,-(SP)	; save text pointer
00:00006434 2F3A1132        	   458: 	MOVE.L CURRNT,-(SP)	found it, save old 'CURRNT'...
00:00006438 2F3A1136        	   459: 	MOVE.L STKGOS,-(SP)	and 'STKGOS'
00:0000643C 42B900007578    	   460: 	CLR.L	LOPVAR		; load new values
00:00006442 23CF00007570    	   461: 	MOVE.L SP,STKGOS
                            	   462: 
00:00006448 227A1152        	   463: 	move.l IRQROUT,a1
00:0000644C 600C            	   464: 	bra	RUNTSL
                            	   465: RUN1
00:0000644E 7200            	   466: 	CLR.L	D1			; else find the next line number
00:00006450 2248            	   467: 	MOVE.L A0,A1
00:00006452 61000E10        	   468: 	bsr	FNDLNP
00:00006456 6500FC58        	   469: 	BCS	WSTART		; if we've fallen off the end, stop
                            	   470: 
                            	   471: RUNTSL
00:0000645A 23C900007568    	   472: 	MOVE.L	A1,CURRNT	set CURRNT to point to the line no.
00:00006460 2049            	   473: 	MOVE.L	A1,A0		set the text pointer to
00:00006462 5488            	   474: 	ADDQ.L	#2,A0		the start of the line text
                            	   475: 
                            	   476: RUNSML
00:00006464 61000FFC        	   477: 	bsr	CHKIO		see if a control-C was pressed
00:00006468 43FAFD69        	   478: 	LEA	TAB2,A1 	find command in TAB2
00:0000646C 45FAFE26        	   479: 	LEA	TAB2_1,A2
00:00006470 6000FEEA        	   480: 	BRA	EXEC		and execute it
                            	   481: 
                            	   482: GOTO	
00:00006474 610004E0        	   483: 	bsr	INT_EXPR	; evaluate the following expression
00:00006478 61000CD6        	   484: 	bsr	ENDCHK		; must find end of line
00:0000647C 2200            	   485: 	move.l d0,d1
00:0000647E 61000DD6        	   486: 	bsr	FNDLN			; find the target line
00:00006482 66000D26        	   487: 	bne	QHOW			; no such line no.
00:00006486 60D2            	   488: 	bra	RUNTSL		; go do it
                            	   489: 
                            	   490: ;******************************************************************
                            	   491: ; ONIRQ <line number>
                            	   492: ; ONIRQ sets up an interrupt handler which acts like a specialized
                            	   493: ; subroutine call. ONIRQ is coded like a GOTO that never executes.
                            	   494: ;******************************************************************
                            	   495: 
                            	   496: ONIRQ:
00:00006488 610004CC        	   497: 	bsr	INT_EXPR		; evaluate the following expression
00:0000648C 61000CC2        	   498: 	bsr ENDCHK			; must find end of line
00:00006490 2200            	   499: 	move.l d0,d1
00:00006492 61000DC2        	   500: 	bsr FNDLN				; find the target line
00:00006496 660A            	   501: 	bne	ONIRQ1
00:00006498 42B90000759C    	   502: 	clr.l IRQROUT
00:0000649E 600000CA        	   503: 	bra	FINISH
                            	   504: ONIRQ1:
00:000064A2 23C90000759C    	   505: 	move.l a1,IRQROUT
00:000064A8 600000C0        	   506: 	jmp	FINISH
                            	   507: 
                            	   508: 
                            	   509: WAITIRQ:
00:000064AC 61000FB4        	   510: 	jsr	CHKIO				; see if a control-C was pressed
00:000064B0 4A39000400A0    	   511: 	tst.b IRQFlag
00:000064B6 67F4            	   512: 	beq	WAITIRQ
00:000064B8 600000B0        	   513: 	jmp	FINISH
                            	   514: 
                            	   515: *******************************************************************
                            	   516: *
                            	   517: * *** LIST *** PRINT ***
                            	   518: *
                            	   519: * LIST has two forms:
                            	   520: * 'LIST<CR>' lists all saved lines
                            	   521: * 'LIST #<CR>' starts listing at the line #
                            	   522: * Control-S pauses the listing, control-C stops it.
                            	   523: *
                            	   524: * PRINT command is 'PRINT ....:' or 'PRINT ....<CR>'
                            	   525: * where '....' is a list of expressions, formats, back-arrows,
                            	   526: * and strings.	These items a separated by commas.
                            	   527: *
                            	   528: * A format is a pound sign followed by a number.  It controls
                            	   529: * the number of spaces the value of an expression is going to
                            	   530: * be printed in.  It stays effective for the rest of the print
                            	   531: * command unless changed by another format.  If no format is
                            	   532: * specified, 11 positions will be used.
                            	   533: *
                            	   534: * A string is quoted in a pair of single- or double-quotes.
                            	   535: *
                            	   536: * An underline (back-arrow) means generate a <CR> without a <LF>
                            	   537: *
                            	   538: * A <CR LF> is generated after the entire list has been printed
                            	   539: * or if the list is empty.  If the list ends with a semicolon,
                            	   540: * however, no <CR LF> is generated.
                            	   541: *
                            	   542: 
                            	   543: LIST	
00:000064BC 61000F04        	   544: 	bsr	TSTNUM		see if there's a line no.
00:000064C0 61000C8E        	   545: 	bsr	ENDCHK		if not, we get a zero
00:000064C4 61000D90        	   546: 	bsr	FNDLN		find this or next line
                            	   547: LS1
00:000064C8 650000A0        	   548: 	BCS	FINISH		warm start if we passed the end
00:000064CC 61000EBE        	   549: 	bsr	PRTLN		print the line
00:000064D0 61000F90        	   550: 	bsr	CHKIO		check for listing halt request
00:000064D4 670C            	   551: 	BEQ	LS3
00:000064D6 B03C0013        	   552: 	CMP.B	#CTRLS,D0	pause the listing?
00:000064DA 6606            	   553: 	BNE	LS3
                            	   554: LS2
00:000064DC 61000F84        	   555: 	bsr	CHKIO		if so, wait for another keypress
00:000064E0 67FA            	   556: 	BEQ	LS2
                            	   557: LS3
00:000064E2 61000D80        	   558: 	bsr	FNDLNP		find the next line
00:000064E6 60E0            	   559: 	BRA	LS1
                            	   560: 
                            	   561: PRINT	
00:000064E8 780B            	   562: 	MOVE.L #11,D4		D4 = number of print spaces
00:000064EA 61000EBE        	   563: 	bsr	TSTC		if null list and ":"
00:000064EE 3A              	   564: 	DC.B	':',PR2-*
00:000064EF 09
00:000064F0 61001184        	   565: 	bsr	CRLF		give CR-LF and continue
00:000064F4 6000FF6E        	   566: 	BRA	RUNSML		execution on the same line
                            	   567: PR2	
00:000064F8 61000EB0        	   568: 	bsr	TSTC		if null list and <CR>
00:000064FC 0D              	   569: 	DC.B	CR,PR0-*
00:000064FD 09
00:000064FE 61001176        	   570: 	bsr	CRLF		also give CR-LF and
00:00006502 6000FF0A        	   571: 	BRA	RUNNXL		execute the next line
                            	   572: PR0
00:00006506 61000EA2        	   573: 	bsr	TSTC				; else is it a format?
00:0000650A 23              	   574: 	dc.b '#',PR1-*
00:0000650B 09
00:0000650C 61000448        	   575: 	bsr	INT_EXPR		; yes, evaluate expression
00:00006510 2800            	   576: 	move.l d0,d4		; and save it as print width
00:00006512 600E            	   577: 	bra	PR3					; look for more to print
                            	   578: PR1
00:00006514 61000E94        	   579: 	bsr	TSTC				; is character expression? (MRL)
00:00006518 24              	   580: 	dc.b '$',PR8-*
00:00006519 1B
00:0000651A 6100043A        	   581: 	bsr	INT_EXPR		; yep. Evaluate expression (MRL)
00:0000651E 6100FB0A        	   582: 	bsr	GOOUT				; print low byte (MRL)
                            	   583: 	bra	PR3					; look for more. (MRL)
                            	   584: PR3
00:00006522 61000E86        	   585: 	bsr	TSTC						; if ",", go find next
00:00006526 2C              	   586: 	dc.b ',',PR6-*
00:00006527 07
00:00006528 61000C0C        	   587: 	bsr	FIN							; in the list.
00:0000652C 60D8            	   588: 	BRA	PR0
                            	   589: PR6
00:0000652E 61001146        	   590: 	bsr	CRLF						; list ends here
00:00006532 6036            	   591: 	BRA	FINISH
                            	   592: PR8
00:00006534 2F04            	   593: 	move.l d4,-(SP)			; save the width value
00:00006536 61000430        	   594: 	bsr	EXPR						; evaluate the expression
00:0000653A 281F            	   595: 	move.l (sp)+,d4			; restore the width
00:0000653C 0C8000000002    	   596: 	cmpi.l #DT_STRING,d0	; is it a string?
00:00006542 670C            	   597: 	beq PR9
00:00006544 F2000080        	   598: 	fmove fp0,fp1
00:00006548 7823            	   599: 	move.l #35,d4
00:0000654A 61000DF6        	   600: 	bsr	PRTNUM					; print its value
00:0000654E 60D2            	   601: 	bra	PR3							; more to print?
                            	   602: 	; Print a string
                            	   603: PR9
00:00006550 F239680000040600	   604: 	fmove.x fp0,_fpWork
00:00006558 323900040600    	   605: 	move.w _fpWork,d1
00:0000655E 227900040604    	   606: 	move.l _fpWork+4,a1
00:00006564 61000DD6        	   607: 	bsr PRTSTR2
00:00006568 60B8            	   608: 	bra PR3
                            	   609: 
                            	   610: FINISH
00:0000656A 61000BCA        	   611: 	bsr	FIN			; Check end of command
00:0000656E 60000BF2        	   612: 	BRA	QWHAT		; print "What?" if wrong
                            	   613: 
                            	   614: ;******************************************************************
                            	   615: ;
                            	   616: ; *** GOSUB *** & RETURN ***
                            	   617: ;
                            	   618: ; 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
                            	   619: ; except that the current text pointer, stack pointer, etc. are
                            	   620: ; saved so that execution can be continued after the subroutine
                            	   621: ; 'RETURN's.  In order that 'GOSUB' can be nested (and even
                            	   622: ; recursive), the save area must be stacked.  The stack pointer
                            	   623: ; is saved in 'STKGOS'.  The old 'STKGOS' is saved on the stack.
                            	   624: ; If we are in the main routine, 'STKGOS' is zero (this was done
                            	   625: ; in the initialization section of the interpreter), but we still
                            	   626: ; save it as a flag for no further 'RETURN's.
                            	   627: ;
                            	   628: ; 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
                            	   629: ; returns the execution to the command after the most recent
                            	   630: ; 'GOSUB'.  If 'STKGOS' is zero, it indicates that we never had
                            	   631: ; a 'GOSUB' and is thus an error.
                            	   632: 
                            	   633: GOSUB:
00:00006572 4FEFFF80        	   634: 	sub.l #128,sp		; allocate storage for local variables
00:00006576 2F3A0FF4        	   635: 	move.l STKFP,-(sp)
00:0000657A 23CF0000756C    	   636: 	move.l sp,STKFP
00:00006580 61000D62        	   637: 	bsr	PUSHA				; save the current 'FOR' parameters
00:00006584 610003D0        	   638: 	bsr	INT_EXPR		; get line number
00:00006588 2F08            	   639: 	MOVE.L	A0,-(SP)	save text pointer
00:0000658A 2200            	   640: 	move.l	d0,d1
00:0000658C 61000CC8        	   641: 	bsr	FNDLN		find the target line
00:00006590 66000C1A        	   642: 	BNE	AHOW		if not there, say "How?"
00:00006594 2F3A0FD2        	   643: 	MOVE.L	CURRNT,-(SP)	found it, save old 'CURRNT'...
00:00006598 2F3A0FD6        	   644: 	MOVE.L	STKGOS,-(SP)	and 'STKGOS'
00:0000659C 42B900007578    	   645: 	CLR.L	LOPVAR		load new values
00:000065A2 23CF00007570    	   646: 	MOVE.L	SP,STKGOS
00:000065A8 6000FEB0        	   647: 	BRA	RUNTSL
                            	   648: 
                            	   649: RETURN:
00:000065AC 61000BA2        	   650: 	bsr	ENDCHK					; there should be just a <CR>
00:000065B0 223A0FBE        	   651: 	MOVE.L	STKGOS,D1		; get old stack pointer
00:000065B4 67000BAC        	   652: 	BEQ	QWHAT						; if zero, it doesn't exist
00:000065B8 2E41            	   653: 	MOVE.L	D1,SP				; else restore it
00:000065BA 23DF00007570    	   654: 	MOVE.L	(SP)+,STKGOS	; and the old 'STKGOS'
00:000065C0 23DF00007568    	   655: 	MOVE.L	(SP)+,CURRNT	; and the old 'CURRNT'
00:000065C6 205F            	   656: 	MOVE.L	(SP)+,A0		; and the old text pointer
00:000065C8 61000CDE        	   657: 	bsr	POPA						; and the old 'FOR' parameters
                            	   658: ;	move.l STKFP,sp
00:000065CC 23DF0000756C    	   659: 	move.l (sp)+,STKFP
00:000065D2 4FEF0080        	   660: 	add.l #128,sp				; remove local variable storage
00:000065D6 6092            	   661: 	BRA	FINISH					; and we are back home
                            	   662: 
                            	   663: *******************************************************************
                            	   664: *
                            	   665: * *** FOR *** & NEXT ***
                            	   666: *
                            	   667: * 'FOR' has two forms:
                            	   668: * 'FOR var=exp1 TO exp2 STEP exp1' and 'FOR var=exp1 TO exp2'
                            	   669: * The second form means the same thing as the first form with a
                            	   670: * STEP of positive 1.  The interpreter will find the variable 'var'
                            	   671: * and set its value to the current value of 'exp1'.  It also
                            	   672: * evaluates 'exp2' and 'exp1' and saves all these together with
                            	   673: * the text pointer, etc. in the 'FOR' save area, which consisits of
                            	   674: * 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'.  If there is
                            	   675: * already something in the save area (indicated by a non-zero
                            	   676: * 'LOPVAR'), then the old save area is saved on the stack before
                            	   677: * the new values are stored.  The interpreter will then dig in the
                            	   678: * stack and find out if this same variable was used in another
                            	   679: * currently active 'FOR' loop.  If that is the case, then the old
                            	   680: * 'FOR' loop is deactivated. (i.e. purged from the stack)
                            	   681: *
                            	   682: * 'NEXT var' serves as the logical (not necessarily physical) end
                            	   683: * of the 'FOR' loop.  The control variable 'var' is checked with
                            	   684: * the 'LOPVAR'.  If they are not the same, the interpreter digs in
                            	   685: * the stack to find the right one and purges all those that didn't
                            	   686: * match.  Either way, it then adds the 'STEP' to that variable and
                            	   687: * checks the result with against the limit value.  If it is within
                            	   688: * the limit, control loops back to the command following the
                            	   689: * 'FOR'.  If it's outside the limit, the save area is purged and
                            	   690: * execution continues.
                            	   691: 
                            	   692: FOR
00:000065D8 61000D0A        	   693: 	bsr	PUSHA			; save the old 'FOR' save area
00:000065DC 61000B38        	   694: 	bsr	SETVAL		; set the control variable
00:000065E0 23CE00007578    	   695: 	move.l a6,LOPVAR		; save its address
00:000065E6 43FAFC5A        	   696: 	LEA	TAB5,A1 	; use 'EXEC' to test for 'TO'
00:000065EA 45FAFD1C        	   697: 	LEA	TAB5_1,A2
00:000065EE 6000FD6C        	   698: 	BRA	EXEC
                            	   699: FR1	
00:000065F2 61000354        	   700: 	bsr	NUM_EXPR		; evaluate the limit
00:000065F6 F239680000007588	   701: 	FMOVE.X	FP0,LOPLMT	; save that
00:000065FE 43FAFC45        	   702: 	LEA	TAB6,A1 		; use 'EXEC' to look for the
00:00006602 45FAFD0C        	   703: 	LEA	TAB6_1,A2		; word 'STEP'
00:00006606 6000FD54        	   704: 	BRA	EXEC
                            	   705: FR2
00:0000660A 6100033C        	   706: 	bsr	NUM_EXPR		found it, get the step value
00:0000660E 6006            	   707: 	BRA	FR4
                            	   708: FR3
00:00006610 F23C58000001    	   709: 	FMOVE.B #1,FP0	; not found, step defaults to 1
                            	   710: FR4
00:00006616 F23968000000757C	   711: 	FMOVE.X	FP0,LOPINC	save that too
                            	   712: FR5	
00:0000661E 23FA0F4800007594	   713: 	MOVE.L	CURRNT,LOPLN	save address of current line number
00:00006626 23C800007598    	   714: 	MOVE.L	A0,LOPPT	and text pointer
00:0000662C 2C4F            	   715: 	MOVE.L	SP,A6		dig into the stack to find 'LOPVAR'
00:0000662E 600C            	   716: 	BRA	FR7
                            	   717: FR6
00:00006630 4DEE0024        	   718: 	lea 36(a6),a6			; look at next stack frame
00:00006634 BDFAFA0C        	   719: 	cmp.l ENDMEM,a6		; safety check
00:00006638 64000B28        	   720: 	bhs QWHAT
                            	   721: FR7
00:0000663C 2016            	   722: 	MOVE.L	(A6),D0 	; is it zero?
00:0000663E 6714            	   723: 	BEQ	FR8						; if so, we're done
00:00006640 B0BA0F36        	   724: 	CMP.L	LOPVAR,D0		; same as current LOPVAR?
00:00006644 66EA            	   725: 	BNE	FR6						; nope, look some more
00:00006646 244F            	   726: 	MOVE.L	SP,A2			; Else remove 9 long words from...
00:00006648 224E            	   727: 	MOVE.L	A6,A1			; inside the stack.
00:0000664A 47E90024        	   728: 	lea	36(a1),a3
00:0000664E 61000C50        	   729: 	bsr	MVDOWN
00:00006652 2E4B            	   730: 	MOVE.L	A3,SP		set the SP 9 long words up
                            	   731: FR8
00:00006654 6000FF14        	   732: 	BRA	FINISH		and continue execution
                            	   733: 
                            	   734: NEXT	
00:00006658 6100078A        	   735: 	bsr	TSTV						; get address of variable
00:0000665C 65000B04        	   736: 	bcs	QWHAT						; if no variable, say "What?"
00:00006660 2240            	   737: 	move.l d0,a1				; save variable's address
                            	   738: NX0
00:00006662 203A0F14        	   739: 	move.l LOPVAR,D0		; If 'LOPVAR' is zero, we never...
00:00006666 67000AFA        	   740: 	beq	QWHAT						; had a FOR loop, so say "What?"
00:0000666A B3C0            	   741: 	cmp.l	d0,a1					; else we check them
00:0000666C 6706            	   742: 	beq	NX3							; OK, they agree
00:0000666E 61000C38        	   743: 	bsr	POPA						; nope, let's see the next frame
00:00006672 60EE            	   744: 	bra	NX0
                            	   745: NX3	
00:00006674 F22948000004    	   746: 	fmove.x	4(a1),fp0		; get control variable's value
00:0000667A F23A48220EFE    	   747: 	fadd.x LOPINC,fp0		; add in loop increment
                            	   748: ;	BVS	QHOW		say "How?" for 32-bit overflow
00:00006680 F22968000004    	   749: 	fmove.x	fp0,4(a1)		; save control variable's new value
00:00006686 F23A48800EFE    	   750: 	fmove.x	LOPLMT,fp1	; get loop's limit value
00:0000668C F23A503A0EEC    	   751: 	ftst LOPINC
00:00006692 F293000E        	   752: 	FBGE NX1				; branch if loop increment is positive
00:00006696 F2276800        	   753: 	FMOVE.X FP0,-(a7)	; exchange FP0,FP1
00:0000669A F2000400        	   754: 	FMOVE.X FP1,FP0
00:0000669E F21F4880        	   755: 	FMOVE.X (a7)+,FP1
                            	   756: NX1	
00:000066A2 F20000B8        	   757: 	FCMP FP0,FP1		;	test against limit
00:000066A6 F2940012        	   758: 	FBLT NX2				; branch if outside limit
00:000066AA 23FA0EE800007568	   759: 	MOVE.L LOPLN,CURRNT	Within limit, go back to the...
00:000066B2 207A0EE4        	   760: 	MOVE.L LOPPT,A0	saved 'CURRNT' and text pointer.
00:000066B6 6000FEB2        	   761: 	BRA	FINISH
                            	   762: NX2
00:000066BA 61000BEC        	   763: 	bsr	POPA		purge this loop
00:000066BE 6000FEAA        	   764: 	BRA	FINISH
                            	   765: 
                            	   766: *******************************************************************
                            	   767: *
                            	   768: * *** REM *** IF *** INPUT *** LET (& DEFLT) ***
                            	   769: *
                            	   770: * 'REM' can be followed by anything and is ignored by the
                            	   771: * interpreter.
                            	   772: *
                            	   773: * 'IF' is followed by an expression, as a condition and one or
                            	   774: * more commands (including other 'IF's) separated by colons.
                            	   775: * Note that the word 'THEN' is not used.  The interpreter evaluates
                            	   776: * the expression.  If it is non-zero, execution continues.  If it
                            	   777: * is zero, the commands that follow are ignored and execution
                            	   778: * continues on the next line.
                            	   779: *
                            	   780: * 'INPUT' is like the 'PRINT' command, and is followed by a list
                            	   781: * of items.  If the item is a string in single or double quotes,
                            	   782: * or is an underline (back arrow), it has the same effect as in
                            	   783: * 'PRINT'.  If an item is a variable, this variable name is
                            	   784: * printed out followed by a colon, then the interpreter waits for
                            	   785: * an expression to be typed in.  The variable is then set to the
                            	   786: * value of this expression.  If the variable is preceeded by a
                            	   787: * string (again in single or double quotes), the string will be
                            	   788: * displayed followed by a colon.  The interpreter the waits for an
                            	   789: * expression to be entered and sets the variable equal to the
                            	   790: * expression's value.  If the input expression is invalid, the
                            	   791: * interpreter will print "What?", "How?", or "Sorry" and reprint
                            	   792: * the prompt and redo the input.  The execution will not terminate
                            	   793: * unless you press control-C.  This is handled in 'INPERR'.
                            	   794: *
                            	   795: * 'LET' is followed by a list of items separated by commas.
                            	   796: * Each item consists of a variable, an equals sign, and an
                            	   797: * expression.  The interpreter evaluates the expression and sets
                            	   798: * the variable to that value.  The interpreter will also handle
                            	   799: * 'LET' commands without the word 'LET'.  This is done by 'DEFLT'.
                            	   800: 
                            	   801: REM
00:000066C2 600A            	   802: 	BRA	IF2		skip the rest of the line
                            	   803: 
                            	   804: IF
00:000066C4 61000290        	   805: 	bsr	INT_EXPR		evaluate the expression
                            	   806: IF1
00:000066C8 4A80            	   807: 	TST.L	d0		is it zero?
00:000066CA 6600FD98        	   808: 	BNE	RUNSML		if not, continue
                            	   809: IF2
00:000066CE 2248            	   810: 	MOVE.L	A0,A1
00:000066D0 7200            	   811: 	CLR.L	D1
00:000066D2 61000BAA        	   812: 	bsr	FNDSKP		if so, skip the rest of the line
00:000066D6 6400FD82        	   813: 	BCC	RUNTSL		and run the next line
00:000066DA 6000F9D4        	   814: 	BRA	WSTART		if no next line, do a warm start
                            	   815: 
00:000066DE 2E7A0E94        	   816: INPERR	MOVE.L	STKINP,SP	restore the old stack pointer
00:000066E2 23DF00007568    	   817: 	MOVE.L	(SP)+,CURRNT	and old 'CURRNT'
00:000066E8 588F            	   818: 	ADDQ.L	#4,SP
00:000066EA 205F            	   819: 	MOVE.L	(SP)+,A0	and old text pointer
                            	   820: 
                            	   821: INPUT	
00:000066EC 2F08            	   822: 	MOVE.L	A0,-(SP)	save in case of error
00:000066EE 61000278        	   823: 	bsr EXPR
00:000066F2 0C000002        	   824: 	cmpi.b #DT_STRING,d0
00:000066F6 6622            	   825: 	bne IP6
00:000066F8 F239680000040600	   826: 	fmove.x fp0,_fpWork
00:00006700 323900040600    	   827: 	move.w _fpWork,d1
00:00006706 227900040604    	   828: 	move.l _fpWork+4,a1
00:0000670C 61000C2E        	   829: 	bsr PRTSTR2
                            	   830: ;	bsr	QTSTG		is next item a string?
                            	   831: ;	BRA.S	IP2		nope
                            	   832: IP7
00:00006710 610006D2        	   833: 	bsr	TSTV		yes, but is it followed by a variable?
00:00006714 655C            	   834: 	BCS	IP4		if not, branch
00:00006716 2440            	   835: 	MOVE.L	D0,A2		put away the variable's address
00:00006718 601E            	   836: 	BRA	IP3		if so, input to variable
                            	   837: IP6
00:0000671A 2057            	   838: 	move.l (sp),a0	; restore text pointer
00:0000671C 60F2            	   839: 	bra IP7
                            	   840: IP2
00:0000671E 2F08            	   841: 	MOVE.L	A0,-(SP)	save for 'PRTSTG'
00:00006720 610006C2        	   842: 	bsr	TSTV		must be a variable now
00:00006724 65000A3C        	   843: 	BCS	QWHAT		"What?" it isn't?
00:00006728 2440            	   844: 	MOVE.L	D0,A2		put away the variable's address
00:0000672A 1410            	   845: 	MOVE.B	(A0),D2 	get ready for 'PRTSTG'
00:0000672C 4200            	   846: 	CLR.B	D0
00:0000672E 1080            	   847: 	MOVE.B	D0,(A0)
00:00006730 225F            	   848: 	MOVE.L	(SP)+,A1
00:00006732 61000BE6        	   849: 	bsr	PRTSTG		print string as prompt
00:00006736 1082            	   850: 	MOVE.B	D2,(A0) 	restore text
                            	   851: IP3
00:00006738 2F08            	   852: 	MOVE.L	A0,-(SP)	save in case of error
00:0000673A 2F3A0E2C        	   853: 	MOVE.L	CURRNT,-(SP)	also save 'CURRNT'
00:0000673E 23FCFFFFFFFF0000	   854: 	MOVE.L	#-1,CURRNT	flag that we are in INPUT
00:00006746 7568
00:00006748 23CF00007574    	   855: 	MOVE.L	SP,STKINP	save the stack pointer too
00:0000674E 2F0A            	   856: 	MOVE.L	A2,-(SP)	save the variable address
00:00006750 103C003A        	   857: 	MOVE.B	#':',D0         print a colon first
00:00006754 61000A62        	   858: 	bsr	GETLN		then get an input line
00:00006758 41FA0E66        	   859: 	LEA	BUFFER,A0	point to the buffer
00:0000675C 6100020A        	   860: 	bsr	EXPR		evaluate the input
00:00006760 245F            	   861: 	MOVE.L	(SP)+,A2	restore the variable address
00:00006762 2480            	   862: 	move.l d0,(a2)			; save data type
00:00006764 F22A68000004    	   863: 	FMOVE.X	FP0,4(A2) 	; save value in variable
00:0000676A 23DF00007568    	   864: 	MOVE.L	(SP)+,CURRNT	restore old 'CURRNT'
00:00006770 205F            	   865: 	MOVE.L	(SP)+,A0	and the old text pointer
                            	   866: IP4
00:00006772 588F            	   867: 	ADDQ.L	#4,SP		clean up the stack
00:00006774 61000C34        	   868: 	bsr	TSTC		is the next thing a comma?
00:00006778 2C              	   869: 	DC.B	',',IP5-*
00:00006779 05
00:0000677A 6000FF70        	   870: 	BRA	INPUT		yes, more items
                            	   871: IP5
00:0000677E 6000FDEA        	   872: 	BRA	FINISH
                            	   873: 
                            	   874: DEFLT
00:00006782 0C10000D        	   875: 	CMP.B	#CR,(A0)	; empty line is OK
00:00006786 6700FDE2        	   876: 	BEQ	FINISH			; else it is 'LET'
                            	   877: 
                            	   878: LET
00:0000678A 6100098A        	   879: 	bsr	SETVAL		 	; do the assignment
00:0000678E 61000C1A        	   880: 	bsr	TSTC				; check for more 'LET' items
00:00006792 2C              	   881: 	DC.B	',',LT1-*
00:00006793 03
00:00006794 60F4            	   882: 	BRA	LET
                            	   883: LT1
00:00006796 6000FDD2        	   884: 	BRA	FINISH			; until we are finished.
                            	   885: 
                            	   886: 
                            	   887: *******************************************************************
                            	   888: *
                            	   889: * *** LOAD *** & SAVE ***
                            	   890: *
                            	   891: * These two commands transfer a program to/from an auxiliary
                            	   892: * device such as a cassette, another computer, etc.  The program
                            	   893: * is converted to an easily-stored format: each line starts with
                            	   894: * a colon, the line no. as 4 hex digits, and the rest of the line.
                            	   895: * At the end, a line starting with an '@' sign is sent.  This
                            	   896: * format can be read back with a minimum of processing time by
                            	   897: * the 68000.
                            	   898: *
                            	   899: LOAD	
00:0000679A 207AF8A2        	   900: 	MOVE.L TXTBGN,A0	set pointer to start of prog. area
00:0000679E 103C000D        	   901: 	MOVE.B #CR,D0		For a CP/M host, tell it we're ready...
00:000067A2 6100F88E        	   902: 	BSR	GOAUXO		by sending a CR to finish PIP command.
                            	   903: LOD1	
00:000067A6 6100F88E        	   904: 	BSR	GOAUXI		look for start of line
00:000067AA 67FA            	   905: 	BEQ	LOD1
00:000067AC B03C0040        	   906: 	CMP.B	#'@',D0         end of program?
00:000067B0 671E            	   907: 	BEQ	LODEND
00:000067B2 B03C003A        	   908: 	CMP.B	#':',D0         if not, is it start of line?
00:000067B6 66EE            	   909: 	BNE	LOD1		if not, wait for it
00:000067B8 6120            	   910: 	BSR	GBYTE		get first byte of line no.
00:000067BA 10C1            	   911: 	MOVE.B	D1,(A0)+	store it
00:000067BC 611C            	   912: 	BSR	GBYTE		get 2nd bye of line no.
00:000067BE 10C1            	   913: 	MOVE.B	D1,(A0)+	store that, too
                            	   914: LOD2
00:000067C0 6100F874        	   915: 	BSR	GOAUXI		get another text char.
00:000067C4 67FA            	   916: 	BEQ	LOD2
00:000067C6 10C0            	   917: 	MOVE.B	D0,(A0)+	store it
00:000067C8 B03C000D        	   918: 	CMP.B	#CR,D0		is it the end of the line?
00:000067CC 66F2            	   919: 	BNE	LOD2		if not, go back for more
00:000067CE 60D6            	   920: 	BRA	LOD1		if so, start a new line
                            	   921: LODEND
00:000067D0 23C8000075B0    	   922: 	MOVE.L	A0,TXTUNF	set end-of program pointer
00:000067D6 6000F8D8        	   923: 	BRA	WSTART		back to direct mode
                            	   924: 
                            	   925: GBYTE
00:000067DA 7401            	   926: 	MOVEQ	#1,D2		get two hex characters from auxiliary
00:000067DC 7200            	   927: 	CLR.L	D1		and store them as a byte in D1
                            	   928: GBYTE1	
00:000067DE 6100F856        	   929: 	BSR	GOAUXI		get a char.
00:000067E2 67FA            	   930: 	BEQ	GBYTE1
00:000067E4 B03C0041        	   931: 	CMP.B	#'A',D0
00:000067E8 6502            	   932: 	BCS	GBYTE2
00:000067EA 5F00            	   933: 	SUBQ.B	#7,D0		if greater than 9, adjust
                            	   934: GBYTE2
00:000067EC C03C000F        	   935: 	AND.B	#$F,D0		strip ASCII
00:000067F0 E909            	   936: 	LSL.B	#4,D1		put nybble into the result
00:000067F2 8200            	   937: 	OR.B	D0,D1
00:000067F4 51CAFFE8        	   938: 	DBRA	D2,GBYTE1	get another char.
00:000067F8 4E75            	   939: 	RTS
                            	   940: 
                            	   941: SAVE
00:000067FA 207AF842        	   942: 	MOVE.L	TXTBGN,A0	set pointer to start of prog. area
00:000067FE 227A0DB0        	   943: 	MOVE.L	TXTUNF,A1	set pointer to end of prog. area
                            	   944: SAVE1	
00:00006802 103C000D        	   945: 	MOVE.B	#CR,D0		send out a CR & LF (CP/M likes this)
00:00006806 6100F82A        	   946: 	BSR	GOAUXO
00:0000680A 103C000A        	   947: 	MOVE.B	#LF,D0
00:0000680E 6100F822        	   948: 	BSR	GOAUXO
00:00006812 B3C8            	   949: 	CMP.L	A0,A1		are we finished?
00:00006814 631E            	   950: 	BLS	SAVEND
00:00006816 103C003A        	   951: 	MOVE.B	#':',D0         if not, start a line
00:0000681A 6100F816        	   952: 	BSR	GOAUXO
00:0000681E 1218            	   953: 	MOVE.B	(A0)+,D1	send first half of line no.
00:00006820 6136            	   954: 	BSR	PBYTE
00:00006822 1218            	   955: 	MOVE.B	(A0)+,D1	and send 2nd half
00:00006824 6132            	   956: 	BSR	PBYTE
                            	   957: SAVE2
00:00006826 1018            	   958: 	MOVE.B	(A0)+,D0	get a text char.
00:00006828 B03C000D        	   959: 	CMP.B	#CR,D0		is it the end of the line?
00:0000682C 67D4            	   960: 	BEQ	SAVE1		if so, send CR & LF and start new line
00:0000682E 6100F802        	   961: 	BSR	GOAUXO		send it out
00:00006832 60F2            	   962: 	BRA	SAVE2		go back for more text
                            	   963: SAVEND
00:00006834 103C0040        	   964: 	MOVE.B	#'@',D0         send end-of-program indicator
00:00006838 6100F7F8        	   965: 	BSR	GOAUXO
00:0000683C 103C000D        	   966: 	MOVE.B	#CR,D0		followed by a CR & LF
00:00006840 6100F7F0        	   967: 	BSR	GOAUXO
00:00006844 103C000A        	   968: 	MOVE.B	#LF,D0
00:00006848 6100F7E8        	   969: 	BSR	GOAUXO
00:0000684C 103C001A        	   970: 	MOVE.B	#$1A,D0 	and a control-Z to end the CP/M file
00:00006850 6100F7E0        	   971: 	BSR	GOAUXO
00:00006854 6000F85A        	   972: 	BRA	WSTART		then go do a warm start
                            	   973: 
00:00006858 7401            	   974: PBYTE	MOVEQ	#1,D2		send two hex characters from D1's low byte
00:0000685A E919            	   975: PBYTE1	ROL.B	#4,D1		get the next nybble
00:0000685C 1001            	   976: 	MOVE.B	D1,D0
00:0000685E C03C000F        	   977: 	AND.B	#$F,D0		strip off garbage
00:00006862 D03C0030        	   978: 	ADD.B	#'0',D0         make it into ASCII
00:00006866 B03C0039        	   979: 	CMP.B	#'9',D0
00:0000686A 6302            	   980: 	BLS	PBYTE2
00:0000686C 5E00            	   981: 	ADDQ.B	#7,D0		adjust if greater than 9
00:0000686E 6100F7C2        	   982: PBYTE2	BSR	GOAUXO		send it out
00:00006872 51CAFFE6        	   983: 	DBRA	D2,PBYTE1	then send the next nybble
00:00006876 4E75            	   984: 	RTS
                            	   985: 
                            	   986: *******************************************************************
                            	   987: *
                            	   988: * *** POKE *** & CALL ***
                            	   989: *
                            	   990: * 'POKE expr1,expr2' stores the byte from 'expr2' into the memory
                            	   991: * address specified by 'expr1'.
                            	   992: *
                            	   993: * 'CALL expr' jumps to the machine language subroutine whose
                            	   994: * starting address is specified by 'expr'.  The subroutine can use
                            	   995: * all registers but must leave the stack the way it found it.
                            	   996: * The subroutine returns to the interpreter by executing an RTS.
                            	   997: *
                            	   998: POKE
00:00006878 1E3C0042        	   999: 	move.b #'B',d7
00:0000687C 1210            	  1000: 	move.b (a0),d1
00:0000687E 0C01002E        	  1001: 	cmpi.b #'.',d1
00:00006882 6620            	  1002: 	bne .0001
00:00006884 5248            	  1003: 	addq #1,a0
00:00006886 1210            	  1004: 	move.b (a0),d1
00:00006888 0C010042        	  1005: 	cmpi.b #'B',d1
00:0000688C 6712            	  1006: 	beq .0002
00:0000688E 0C010057        	  1007: 	cmpi.b #'W',d1
00:00006892 670C            	  1008: 	beq .0002
00:00006894 0C01004C        	  1009: 	cmpi.b #'L',d1
00:00006898 6706            	  1010: 	beq .0002
00:0000689A 0C010046        	  1011: 	cmpi.b #'F',d1
00:0000689E 664E            	  1012: 	bne	PKER
                            	  1013: .0002
00:000068A0 5248            	  1014: 	addq #1,a0
00:000068A2 1E01            	  1015: 	move.b d1,d7
                            	  1016: .0001
00:000068A4 610000B0        	  1017: 	BSR	INT_EXPR		get the memory address
00:000068A8 61000B00        	  1018: 	bsr	TSTC		it must be followed by a comma
00:000068AC 2C              	  1019: 	DC.B	',',PKER-*
00:000068AD 41
00:000068AE 2F00            	  1020: 	move.l d0,-(sp)		; save the address
00:000068B0 61000096        	  1021: 	BSR	NUM_EXPR			; get the value to be POKE'd
00:000068B4 225F            	  1022: 	move.l	(sp)+,a1	; get the address back
00:000068B6 0C070042        	  1023: 	CMPI.B #'B',D7
00:000068BA 6608            	  1024: 	BNE .0003
00:000068BC F2117800        	  1025: 	FMOVE.B	FP0,(A1) 	store the byte in memory
00:000068C0 6000FCA8        	  1026: 	BRA	FINISH
                            	  1027: .0003
00:000068C4 0C070057        	  1028: 	CMPI.B #'W',d7
00:000068C8 6608            	  1029: 	BNE .0004
00:000068CA F2117000        	  1030: 	FMOVE.W FP0,(A1)
00:000068CE 6000FC9A        	  1031: 	BRA FINISH
                            	  1032: .0004
00:000068D2 0C07004C        	  1033: 	CMPI.B #'L',D7
00:000068D6 6608            	  1034: 	BNE .0005
00:000068D8 F2116000        	  1035: 	FMOVE.L FP0,(A1)
00:000068DC 6000FC8C        	  1036: 	BRA FINISH
                            	  1037: .0005
00:000068E0 0C070046        	  1038: 	CMPI.B #'F',D7
00:000068E4 6608            	  1039: 	BNE .0006
00:000068E6 F2116800        	  1040: 	FMOVE.X FP0,(A1)
00:000068EA 6000FC7E        	  1041: 	BRA FINISH
                            	  1042: .0006
                            	  1043: PKER
00:000068EE 60000872        	  1044: 	BRA	QWHAT		if no comma, say "What?"
                            	  1045: 
                            	  1046: CALL	
00:000068F2 6162            	  1047: 	BSR	INT_EXPR		; get the subroutine's address
00:000068F4 4A80            	  1048: 	TST.l d0				; make sure we got a valid address
00:000068F6 670008B2        	  1049: 	BEQ QHOW				; if not, say "How?"
00:000068FA 2F08            	  1050: 	MOVE.L A0,-(SP)	; save the text pointer
00:000068FC 2240            	  1051: 	MOVE.L D0,A1
00:000068FE 4E91            	  1052: 	JSR	(A1)				; jump to the subroutine
00:00006900 205F            	  1053: 	MOVE.L (SP)+,A0	; restore the text pointer
00:00006902 6000FC66        	  1054: 	BRA	FINISH
                            	  1055: 
                            	  1056: ;******************************************************************
                            	  1057: ;
                            	  1058: ; *** EXPR ***
                            	  1059: ;
                            	  1060: ; 'EXPR' evaluates arithmetical or logical expressions.
                            	  1061: ; <EXPR>::=<EXPR2>
                            	  1062: ;	   <EXPR2><rel.op.><EXPR2>
                            	  1063: ; where <rel.op.> is one of the operators in TAB8 and the result
                            	  1064: ; of these operations is 1 if true and 0 if false.
                            	  1065: ; <EXPR2>::=(+ or -)<EXPR3>(+ or -)<EXPR3>(...
                            	  1066: ; where () are optional and (... are optional repeats.
                            	  1067: ; <EXPR3>::=<EXPR4>( <* or /><EXPR4> )(...
                            	  1068: ; <EXPR4>::=<variable>
                            	  1069: ;	    <function>
                            	  1070: ;	    (<EXPR>)
                            	  1071: ; <EXPR> is recursive so that the variable '@' can have an <EXPR>
                            	  1072: ; as an index, functions can have an <EXPR> as arguments, and
                            	  1073: ; <EXPR4> can be an <EXPR> in parenthesis.
                            	  1074: 
                            	  1075: ;-------------------------------------------------------------------------------
                            	  1076: ; Push a value on the stack.
                            	  1077: ;-------------------------------------------------------------------------------
                            	  1078: 
                            	  1079: XP_PUSH:
00:00006906 225F            	  1080: 	move.l (sp)+,a1				; a1 = return address
00:00006908 2F3900040098    	  1081: 	move.l _canary,-(sp)	; push the canary
00:0000690E 4FEFFFF0        	  1082: 	sub.l #16,sp					; allocate for value
00:00006912 2E80            	  1083: 	move.l d0,(sp)				; push data type
00:00006914 F22F68000004    	  1084: 	fmove.x fp0,4(sp)			; and value
00:0000691A 4ED1            	  1085: 	jmp (a1)
                            	  1086: 
                            	  1087: ;-------------------------------------------------------------------------------
                            	  1088: ; Pop value from stack into first operand.
                            	  1089: ;-------------------------------------------------------------------------------
                            	  1090: 	
                            	  1091: XP_POP:
00:0000691C 225F            	  1092: 	move.l (sp)+,a1			; get return address
00:0000691E 2017            	  1093: 	move.l (sp),d0			; pop data type
00:00006920 F22F48000004    	  1094: 	fmove.x 4(sp),fp0		; and data element
00:00006926 4FEF0010        	  1095: 	add.l #16,sp
00:0000692A A2970003        	  1096: 	cchk (sp)						; check the canary
00:0000692E 588F            	  1097: 	add.l #4,sp					; pop canary	
00:00006930 4ED1            	  1098: 	jmp (a1)
                            	  1099: 
                            	  1100: ;-------------------------------------------------------------------------------
                            	  1101: ; Pop value from stack into second operand.
                            	  1102: ;-------------------------------------------------------------------------------
                            	  1103: 
                            	  1104: XP_POP1:
00:00006932 225F            	  1105: 	move.l (sp)+,a1			; get return address
00:00006934 2217            	  1106: 	move.l (sp),d1			; pop data type
00:00006936 F22F48800004    	  1107: 	fmove.x 4(sp),fp1		; and data element
00:0000693C 4FEF0010        	  1108: 	add.l #16,sp
00:00006940 A2970003        	  1109: 	cchk (sp)						; check the canary
00:00006944 588F            	  1110: 	add.l #4,sp					; pop canary
00:00006946 4ED1            	  1111: 	jmp (a1)
                            	  1112: 
                            	  1113: ;-------------------------------------------------------------------------------
                            	  1114: ; Get and expression and make sure it is numeric.
                            	  1115: ;-------------------------------------------------------------------------------
                            	  1116: 
                            	  1117: NUM_EXPR:
00:00006948 611E            	  1118: 	bsr EXPR
00:0000694A 0C8000000001    	  1119: 	cmpi.l #DT_NUMERIC,d0
00:00006950 66000860        	  1120: 	bne ETYPE
00:00006954 4E75            	  1121: 	rts
                            	  1122: 
                            	  1123: ;-------------------------------------------------------------------------------
                            	  1124: ; Get and expression and make sure it is numeric. Convert to integer.
                            	  1125: ;-------------------------------------------------------------------------------
                            	  1126: 
                            	  1127: INT_EXPR:
00:00006956 6110            	  1128: 	bsr EXPR
00:00006958 0C8000000001    	  1129: 	cmpi.l #DT_NUMERIC,d0
00:0000695E 66000852        	  1130: 	bne ETYPE
00:00006962 F2006000        	  1131: 	fmove.l fp0,d0
00:00006966 4E75            	  1132: 	rts
                            	  1133: 
                            	  1134: ;-------------------------------------------------------------------------------
                            	  1135: ; The top level of the expression parser.
                            	  1136: ; Get an expression, string or numeric.
                            	  1137: ;
                            	  1138: ; EXEC will smash a lot of regs, so push the current expression value before
                            	  1139: ; doing EXEC
                            	  1140: ;-------------------------------------------------------------------------------
                            	  1141: 
                            	  1142: EXPR:
                            	  1143: EXPR_OR:
00:00006968 6124            	  1144: 	BSR EXPR_AND
00:0000696A 619A            	  1145: 	BSR XP_PUSH
00:0000696C 43FAF8EB        	  1146: 	LEA TAB10,A1
00:00006970 45FAF9CA        	  1147: 	LEA TAB10_1,A2
00:00006974 6000F9E6        	  1148: 	BRA EXEC
                            	  1149: 	
                            	  1150: ;-------------------------------------------------------------------------------
                            	  1151: ; Boolean 'Or' level
                            	  1152: ;-------------------------------------------------------------------------------
                            	  1153: 
                            	  1154: XP_OR:
00:00006978 6114            	  1155: 	BSR EXPR_AND
00:0000697A 61B6            	  1156: 	bsr XP_POP1
00:0000697C 613E            	  1157: 	bsr CheckNumeric
00:0000697E F2016080        	  1158: 	FMOVE.L FP1,D1
00:00006982 F2006000        	  1159: 	FMOVE.L FP0,D0
00:00006986 8081            	  1160: 	OR.L D1,D0
00:00006988 F2004000        	  1161: 	FMOVE.L D0,FP0
00:0000698C 4E75            	  1162: 	rts
                            	  1163: 	
                            	  1164: ;-------------------------------------------------------------------------------
                            	  1165: ; Boolean 'And' level
                            	  1166: ;-------------------------------------------------------------------------------
                            	  1167: 
                            	  1168: EXPR_AND:
00:0000698E 613E            	  1169: 	bsr EXPR_REL
00:00006990 6100FF74        	  1170: 	bsr XP_PUSH
00:00006994 43FAF8BF        	  1171: 	LEA TAB9,A1
00:00006998 45FAF99A        	  1172: 	LEA TAB9_1,A2
00:0000699C 6000F9BE        	  1173: 	BRA EXEC
                            	  1174: 
                            	  1175: XP_AND:
00:000069A0 612C            	  1176: 	BSR EXPR_REL
00:000069A2 618E            	  1177: 	bsr XP_POP1
00:000069A4 6116            	  1178: 	bsr CheckNumeric
00:000069A6 F2016080        	  1179: 	FMOVE.L FP1,D1
00:000069AA F2006000        	  1180: 	FMOVE.L FP0,D0
00:000069AE C081            	  1181: 	AND.L D1,D0
00:000069B0 F2004000        	  1182: 	FMOVE.L D0,FP0
00:000069B4 4E75            	  1183: 	RTS
                            	  1184: 	
                            	  1185: XP_ANDX:
                            	  1186: XP_ORX
00:000069B6 6100FF64        	  1187: 	bsr XP_POP
00:000069BA 4E75            	  1188: 	rts
                            	  1189: 
                            	  1190: ;-------------------------------------------------------------------------------
                            	  1191: ; Check that two numeric values are being used.
                            	  1192: ;-------------------------------------------------------------------------------
                            	  1193: 
                            	  1194: CheckNumeric:
00:000069BC 0C010001        	  1195: 	CMPI.B #DT_NUMERIC,D1
00:000069C0 660007F0        	  1196: 	BNE ETYPE
00:000069C4 0C000001        	  1197: 	CMPI.B #DT_NUMERIC,D0
00:000069C8 660007E8        	  1198: 	BNE ETYPE
00:000069CC 4E75            	  1199: 	RTS
                            	  1200: 
                            	  1201: ;-------------------------------------------------------------------------------
                            	  1202: ; Relational operator level, <,<=,>=,>,=,<>
                            	  1203: ;-------------------------------------------------------------------------------
                            	  1204: 
                            	  1205: EXPR_REL:
00:000069CE 61000088        	  1206: 	bsr	EXPR2
00:000069D2 6100FF32        	  1207: 	bsr XP_PUSH
00:000069D6 43FAF872        	  1208: 	LEA	TAB8,A1 				; look up a relational operator
00:000069DA 45FAF93C        	  1209: 	LEA	TAB8_1,A2
00:000069DE 6000F97C        	  1210: 	bra	EXEC		go do it
                            	  1211: 
                            	  1212: XP11:
00:000069E2 6100FF38        	  1213: 	bsr XP_POP
00:000069E6 615C            	  1214: 	BSR	XP18		is it ">="?
00:000069E8 F2940044        	  1215: 	FBLT XPRT0		no, return D0=0
00:000069EC 6048            	  1216: 	BRA	XPRT1		else return D0=1
                            	  1217: 
                            	  1218: XP12:
00:000069EE 6100FF2C        	  1219: 	bsr XP_POP
00:000069F2 6150            	  1220: 	BSR	XP18		is it "<>"?
00:000069F4 F2810038        	  1221: 	FBEQ XPRT0		no, return D0=0
00:000069F8 603C            	  1222: 	BRA	XPRT1		else return D0=1
                            	  1223: 
                            	  1224: XP13:
00:000069FA 6100FF20        	  1225: 	bsr XP_POP
00:000069FE 6144            	  1226: 	BSR	XP18		is it ">"?
00:00006A00 F295002C        	  1227: 	FBLE XPRT0		no, return D0=0
00:00006A04 6030            	  1228: 	BRA	XPRT1		else return D0=1
                            	  1229: 
                            	  1230: XP14:
00:00006A06 6100FF14        	  1231: 	bsr XP_POP
00:00006A0A 6138            	  1232: 	BSR	XP18		;is it "<="?
00:00006A0C F2920020        	  1233: 	FBGT XPRT0	;	no, return D0=0
00:00006A10 6024            	  1234: 	BRA	XPRT1		;else return D0=1
                            	  1235: 
                            	  1236: XP15:
00:00006A12 6100FF08        	  1237: 	bsr XP_POP
00:00006A16 612C            	  1238: 	BSR	XP18		; is it "="?
00:00006A18 F28E0014        	  1239: 	FBNE XPRT0	;	if not, return D0=0
00:00006A1C 6018            	  1240: 	BRA	XPRT1		;else return D0=1
                            	  1241: XP15RT
00:00006A1E 4E75            	  1242: 	RTS
                            	  1243: 
                            	  1244: XP16:
00:00006A20 6100FEFA        	  1245: 	bsr XP_POP
00:00006A24 611E            	  1246: 	BSR	XP18		; is it "<"?
00:00006A26 F2930006        	  1247: 	FBGE XPRT0	;	if not, return D0=0
00:00006A2A 600A            	  1248: 	BRA	XPRT1		; else return D0=1
00:00006A2C 4E75            	  1249: 	RTS
                            	  1250: 
                            	  1251: XPRT0:
00:00006A2E F23C58000000    	  1252: 	FMOVE.B #0,FP0	; return fp0 = 0 (false)
00:00006A34 4E75            	  1253: 	RTS
                            	  1254: 
                            	  1255: XPRT1:
00:00006A36 F23C58000001    	  1256: 	FMOVE.B #1,FP0	; return fp0 = 1 (true)
00:00006A3C 4E75            	  1257: 	RTS
                            	  1258: 
                            	  1259: XP17:								; it's not a rel. operator
00:00006A3E 6100FEDC        	  1260: 	bsr XP_POP				;	return FP0=<EXPR2>
00:00006A42 4E75            	  1261: 	rts
                            	  1262: 
                            	  1263: XP18:
00:00006A44 6100FEC0        	  1264: 	bsr XP_PUSH
00:00006A48 610E            	  1265: 	bsr	EXPR2					; do second <EXPR2>
00:00006A4A 6100FEE6        	  1266: 	bsr XP_POP1
00:00006A4E 6100FF6C        	  1267: 	bsr CheckNumeric
00:00006A52 F20000B8        	  1268: 	fcmp fp0,fp1			; compare with the first result
00:00006A56 4E75            	  1269: 	rts								; return the result
                            	  1270: 
                            	  1271: ;-------------------------------------------------------------------------------
                            	  1272: ; Add/Subtract operator level, +,-
                            	  1273: ;-------------------------------------------------------------------------------
                            	  1274: 
                            	  1275: EXPR2
00:00006A58 61000950        	  1276: 	bsr	TSTC		; negative sign?
00:00006A5C 2D              	  1277: 	DC.B	'-',XP21-*
00:00006A5D 09
00:00006A5E F23C58000000    	  1278: 	FMOVE.B #0,FP0
00:00006A64 604C            	  1279: 	BRA	XP26
                            	  1280: XP21	
00:00006A66 61000942        	  1281: 	bsr	TSTC		; positive sign? ignore it
00:00006A6A 2B              	  1282: 	DC.B	'+',XP22-*
00:00006A6B 01
                            	  1283: XP22
00:00006A6C 610000C8        	  1284: 	BSR	EXPR3		; first <EXPR3>
                            	  1285: XP23
00:00006A70 61000938        	  1286: 	bsr	TSTC		; add?
00:00006A74 2B              	  1287: 	DC.B	'+',XP25-*
00:00006A75 37
00:00006A76 6100FE8E        	  1288: 	bsr XP_PUSH
00:00006A7A 610000BA        	  1289: 	BSR	EXPR3					; get the second <EXPR3>
                            	  1290: XP24
00:00006A7E 6100FEB2        	  1291: 	bsr XP_POP1
00:00006A82 B03C0001        	  1292: 	CMP.B #DT_NUMERIC,d0
00:00006A86 660C            	  1293: 	BNE .notNum
00:00006A88 B23C0001        	  1294: 	CMP.B #DT_NUMERIC,d1
00:00006A8C 6606            	  1295: 	BNE .notNum
00:00006A8E F2000422        	  1296: 	FADD FP1,FP0			; add it to the first <EXPR3>
                            	  1297: ;	FBVS	QHOW		branch if there's an overflow
00:00006A92 60DC            	  1298: 	BRA	XP23		else go back for more operations
                            	  1299: .notNum
00:00006A94 B0BC00000002    	  1300: 	cmp.l #DT_STRING,d0
00:00006A9A 66000716        	  1301: 	bne ETYPE
00:00006A9E B2BC00000002    	  1302: 	cmp.l #DT_STRING,d1
00:00006AA4 6600070C        	  1303: 	bne ETYPE
00:00006AA8 611E            	  1304: 	bsr ConcatString
00:00006AAA 4E75            	  1305: 	rts
                            	  1306: 
                            	  1307: XP25
00:00006AAC 610008FC        	  1308: 	bsr	TSTC							; subtract?
00:00006AB0 2D              	  1309: 	dc.b	'-',XP27-*
00:00006AB1 15
                            	  1310: XP26
00:00006AB2 6100FE52        	  1311: 	bsr XP_PUSH
00:00006AB6 617E            	  1312: 	BSR	EXPR3					; get second <EXPR3>
00:00006AB8 0C000001        	  1313: 	cmpi.b #DT_NUMERIC,d0
00:00006ABC 660006F4        	  1314: 	bne ETYPE
00:00006AC0 F200001A        	  1315: 	FNEG FP0					; change its sign
00:00006AC4 60B8            	  1316: 	JMP	XP24					; and do an addition
                            	  1317: 
                            	  1318: XP27
00:00006AC6 4E75            	  1319: 	rts
                            	  1320: 
                            	  1321: ;-------------------------------------------------------------------------------
                            	  1322: ; Concatonate strings, for the '+' operator.
                            	  1323: ;
                            	  1324: ; Parameters:
                            	  1325: ;		fp0 = holds string descriptor for second string
                            	  1326: ;		fp1 = holds string descriptor for first string
                            	  1327: ;	Returns:
                            	  1328: ;		fp0 = string descriptor for combined strings
                            	  1329: ;-------------------------------------------------------------------------------
                            	  1330: 
                            	  1331: ConcatString:
00:00006AC8 F239688000040600	  1332: 	fmove.x fp1,_fpWork		; save first string descriptor to memory
00:00006AD0 F239680000040610	  1333: 	fmove.x fp0,_fpWork+16; save second string descriptor to memory
00:00006AD8 343900040600    	  1334: 	move.w _fpWork,d2			; d2 = length of first string
00:00006ADE D47900040610    	  1335: 	add.w	_fpWork+16,d2		; add length of second string
00:00006AE4 48C2            	  1336: 	ext.l d2							; make d2 a long word
00:00006AE6 61000164        	  1337: 	bsr AllocateString		; allocate
00:00006AEA 2849            	  1338: 	move.l a1,a4					; a4 = allocated string, saved for later
00:00006AEC 2449            	  1339: 	move.l a1,a2					; a2 = allocated string
00:00006AEE 3542FFFE        	  1340: 	move.w d2,-2(a2)			; save length of new string (a2)
00:00006AF2 227900040604    	  1341: 	move.l _fpWork+4,a1		; a1 = pointer to string text of first string
00:00006AF8 2649            	  1342: 	move.l a1,a3					; compute pointer to end of first string
00:00006AFA 363900040600    	  1343: 	move.w _fpWork,d3			; d3 = length of first string
00:00006B00 48C3            	  1344: 	ext.l d3
00:00006B02 D7C3            	  1345: 	add.l d3,a3						; add length of first string
00:00006B04 61000786        	  1346: 	bsr MVUP							; move from A1 to A2 until A1=A3
00:00006B08 227900040614    	  1347: 	move.l _fpWork+20,a1	; a1 = pointer to second string text
00:00006B0E 2649            	  1348: 	move.l a1,a3
00:00006B10 363900040610    	  1349: 	move.w _fpWork+16,d3	; d3 = length of second string
00:00006B16 48C3            	  1350: 	ext.l d3
00:00006B18 D7C3            	  1351: 	add.l d3,a3						; a3 points to end of second string
00:00006B1A 61000770        	  1352: 	bsr MVUP							; concatonate on second string
00:00006B1E 33C200040600    	  1353: 	move.w d2,_fpWork			; save total string length in fp work
00:00006B24 23CC00040604    	  1354: 	move.l a4,_fpWork+4		; save pointer in fp work area
00:00006B2A 7002            	  1355: 	moveq #DT_STRING,d0		; set return data type = string
00:00006B2C F239480000040600	  1356: 	fmove.x _fpWork,fp0		; fp0 = string descriptor
00:00006B34 4E75            	  1357: 	rts
                            	  1358: 
                            	  1359: ;-------------------------------------------------------------------------------
                            	  1360: ; Multiply / Divide operator level, *,/,mod
                            	  1361: ;-------------------------------------------------------------------------------
                            	  1362: 
                            	  1363: EXPR3
00:00006B36 6168            	  1364: 	bsr	EXPR4					; get first <EXPR4>
                            	  1365: XP36
00:00006B38 6100FDCC        	  1366: 	bsr XP_PUSH
                            	  1367: XP30
00:00006B3C 43FAF71E        	  1368: 	lea TAB11,a1
00:00006B40 45FAF802        	  1369: 	lea TAB11_1,a2
00:00006B44 6000F816        	  1370: 	bra EXEC
                            	  1371: XP31
00:00006B48 61000860        	  1372: 	bsr	TSTC					; multiply?
00:00006B4C 2A              	  1373: 	dc.b	'*',XP34-*
00:00006B4D 11
00:00006B4E 6150            	  1374: 	bsr	EXPR4					; get second <EXPR4>
00:00006B50 6100FDE0        	  1375: 	bsr XP_POP1
00:00006B54 6100FE66        	  1376: 	bsr CheckNumeric
00:00006B58 F2000423        	  1377: 	fmul fp1,fp0			; multiply the two
00:00006B5C 60DA            	  1378: 	bra	XP36					; then look for more terms
                            	  1379: XP34
00:00006B5E 6100084A        	  1380: 	bsr	TSTC					; divide?
00:00006B62 2F              	  1381: 	dc.b	'/',XP35-*
00:00006B63 15
00:00006B64 613A            	  1382: 	bsr	EXPR4					; get second <EXPR4>
00:00006B66 6100FDCA        	  1383: 	bsr XP_POP1
00:00006B6A 6100FE50        	  1384: 	bsr CheckNumeric
00:00006B6E F20000A0        	  1385: 	fdiv fp0,fp1			; do the division
00:00006B72 F2000400        	  1386: 	fmove fp1,fp0
00:00006B76 60C0            	  1387: 	bra	XP36					; go back for any more terms
                            	  1388: XP35
00:00006B78 6100FDA2        	  1389: 	bsr XP_POP
00:00006B7C 4E75            	  1390: 	rts
                            	  1391: XP_MOD:
00:00006B7E 6120            	  1392: 	bsr EXPR4
00:00006B80 6100FDB0        	  1393: 	bsr XP_POP1
00:00006B84 F20000A0        	  1394: 	fdiv fp0,fp1			; divide
00:00006B88 F2006080        	  1395: 	fmove.l fp1,d0		; convert to integer
00:00006B8C F2004180        	  1396: 	fmove.l d0,fp3		; convert back to float
00:00006B90 F20001A3        	  1397: 	fmul fp0,fp3			; multiply quotient times divisor
00:00006B94 F2000CA8        	  1398: 	fsub fp3,fp1			; subtract from original number
00:00006B98 F2000400        	  1399: 	fmove.x fp1,fp0		; return difference in fp0
00:00006B9C 7001            	  1400: 	moveq #DT_NUMERIC,d0
00:00006B9E 6098            	  1401: 	bra XP36					; go back and check for more multiply ops
                            	  1402: 	
                            	  1403: ;-------------------------------------------------------------------------------
                            	  1404: ; Lowest Level of expression evaluation.
                            	  1405: ;	Check for
                            	  1406: ;		a function or
                            	  1407: ;		a variable or
                            	  1408: ;		a number or
                            	  1409: ;		a string or
                            	  1410: ;		( expr )
                            	  1411: ;-------------------------------------------------------------------------------
                            	  1412: 
                            	  1413: EXPR4
00:00006BA0 43FAF66E        	  1414: 	LEA	TAB4,A1 			; find possible function
00:00006BA4 45FAF72E        	  1415: 	LEA	TAB4_1,A2
00:00006BA8 6000F7B2        	  1416: 	BRA	EXEC
                            	  1417: XP40
00:00006BAC 61000236        	  1418: 	bsr	TSTV					; nope, not a function
00:00006BB0 650C            	  1419: 	bcs	XP41					; nor a variable
00:00006BB2 2240            	  1420: 	move.l d0,a1			; a1 = variable address
00:00006BB4 2011            	  1421: 	move.l (a1),d0		; return type in d0
00:00006BB6 F22948000004    	  1422: 	fmove.x 4(a1),fp0	; if a variable, return its value in fp0
                            	  1423: EXP4RT
00:00006BBC 4E75            	  1424: 	rts
                            	  1425: XP41
00:00006BBE 61000802        	  1426: 	bsr	TSTNUM				; or is it a number?
00:00006BC2 F2000400        	  1427: 	fmove fp1,fp0
00:00006BC6 0C8000000001    	  1428: 	cmpi.l #DT_NUMERIC,d0
00:00006BCC 67EE            	  1429: 	beq	EXP4RT				; if so, return it in FP0
                            	  1430: XPSTNG
00:00006BCE 610007DA        	  1431: 	bsr TSTC					; is it a string constant?
00:00006BD2 22              	  1432: 	dc.b '"',XP44-*
00:00006BD3 57
00:00006BD4 163C0022        	  1433: 	move.b #'"',d3
                            	  1434: XP45
00:00006BD8 2248            	  1435: 	move.l a0,a1			; record start of string in a1
00:00006BDA 243C000001FF    	  1436: 	move.l #511,d2		; max 512 characters
                            	  1437: .0003	
00:00006BE0 1018            	  1438: 	move.b (a0)+,d0		; get a character
00:00006BE2 670E            	  1439: 	beq .0001					; should not be a NULL
00:00006BE4 0C00000D        	  1440: 	cmpi.b #CR,d0			; CR means the end of line was hit without a close quote
00:00006BE8 6708            	  1441: 	beq .0001
00:00006BEA B003            	  1442: 	cmp.b d3,d0				; close quote?
00:00006BEC 6708            	  1443: 	beq .0002
00:00006BEE 51CAFFF0        	  1444: 	dbra d2,.0003			; no close quote, go back for next char
                            	  1445: .0001
00:00006BF2 600005B6        	  1446: 	bra QHOW
                            	  1447: .0002
00:00006BF6 2008            	  1448: 	move.l a0,d0				; d0 = end of string pointer
00:00006BF8 9089            	  1449: 	sub.l a1,d0					; compute string length + 1
00:00006BFA 5340            	  1450: 	subq #1,d0					; subtract out closing quote
00:00006BFC 2400            	  1451: 	move.l d0,d2				; d2 = string length
00:00006BFE 2649            	  1452: 	move.l a1,a3				; a3 = pointer to string text
00:00006C00 614A            	  1453: 	bsr AllocateString
00:00006C02 2449            	  1454: 	move.l a1,a2				; a2 points to new text area
00:00006C04 2849            	  1455: 	move.l a1,a4				; save a1 for later
00:00006C06 224B            	  1456: 	move.l a3,a1				; a1 = pointer to string in program
00:00006C08 3542FFFE        	  1457: 	move.w d2,-2(a2)		; copy length into place
00:00006C0C D7C2            	  1458: 	add.l d2,a3					; a3 points to end of string
00:00006C0E 6100067C        	  1459: 	bsr MVUP						; move from A1 to A2 until A1=A3
00:00006C12 33C200040600    	  1460: 	move.w d2,_fpWork		; copy length into place
00:00006C18 23CC00040604    	  1461: 	move.l a4,_fpWork+4	; copy pointer to text into place
00:00006C1E F239480000040600	  1462: 	fmove.x _fpWork,fp0	; put string descriptor into fp0
00:00006C26 7002            	  1463: 	moveq #DT_STRING,d0	; return string data type
00:00006C28 4E75            	  1464: 	rts
                            	  1465: XP44
00:00006C2A 6100077E        	  1466: 	bsr TSTC					; alternate string constant?
00:00006C2E 27              	  1467: 	dc.b '''',PARN-*
00:00006C2F 07
00:00006C30 163C0027        	  1468: 	move.b #'''',d3
00:00006C34 60A2            	  1469: 	bra XP45
                            	  1470: PARN
00:00006C36 61000772        	  1471: 	bsr	TSTC					; else look for ( EXPR )
00:00006C3A 28              	  1472: 	dc.b '(',XP43-*
00:00006C3B 0D
00:00006C3C 6100FD2A        	  1473: 	bsr	EXPR
00:00006C40 61000768        	  1474: 	bsr	TSTC
00:00006C44 29              	  1475: 	dc.b ')',XP43-*
00:00006C45 03
                            	  1476: XP42	
00:00006C46 4E75            	  1477: 	rts
                            	  1478: XP43
00:00006C48 60000518        	  1479: 	bra	QWHAT					; else say "What?"
                            	  1480: 
                            	  1481: ;-------------------------------------------------------------------------------	
                            	  1482: ; Allocate storage for a string variable.
                            	  1483: ;
                            	  1484: ; Parameters:
                            	  1485: ;		d2 = number of bytes needed
                            	  1486: ; Returns:
                            	  1487: ;		a1 = pointer to string text area
                            	  1488: ;-------------------------------------------------------------------------------	
                            	  1489: 
                            	  1490: AllocateString:
00:00006C4C 48E7383C        	  1491: 	movem.l d2-d4/a2-a5,-(sp)
00:00006C50 283A0962        	  1492: 	move.l VARBGN,d4
00:00006C54 227A0956        	  1493: 	move.l LastStr,a1			; a1 = last string
00:00006C58 3611            	  1494: 	move.w (a1),d3				; d3 = length of last string (0)
00:00006C5A 48C3            	  1495: 	ext.l d3
00:00006C5C 9883            	  1496: 	sub.l d3,d4						; subtract off length
00:00006C5E 5784            	  1497: 	subq.l #3,d4					; size of length field+1 for rounding
00:00006C60 9889            	  1498: 	sub.l a1,d4						; and start position
00:00006C62 B484            	  1499: 	cmp.l d4,d2						; is there enough room?
00:00006C64 6224            	  1500: 	bhi .needMoreRoom
                            	  1501: .0001
00:00006C66 227A0944        	  1502: 	move.l LastStr,a1
00:00006C6A 2649            	  1503: 	move.l a1,a3
00:00006C6C 5489            	  1504: 	addq.l #2,a1					; point a1 to text part of string
00:00006C6E 3682            	  1505: 	move.w d2,(a3)				; save the length
00:00006C70 D7C2            	  1506: 	add.l d2,a3
00:00006C72 568B            	  1507: 	addq.l #3,a3					; 2 for length field, 1 for rounding
00:00006C74 260B            	  1508: 	move.l a3,d3
00:00006C76 0283FFFFFFFE    	  1509: 	andi.l #$FFFFFFFE,d3	; make pointer even wyde
00:00006C7C 23CB000075AC    	  1510: 	move.l a3,LastStr			; set new last str position
00:00006C82 4253            	  1511: 	clr.w (a3)						; set zero length
00:00006C84 4CDF3C1C        	  1512: 	movem.l (sp)+,d2-d4/a2-a5
00:00006C88 4E75            	  1513: 	rts
                            	  1514: .needMoreRoom
00:00006C8A 611E            	  1515: 	bsr GarbageCollectStrings
00:00006C8C 283A0926        	  1516: 	move.l VARBGN,d4			; d4 = start of variables
00:00006C90 227A091A        	  1517: 	move.l LastStr,a1			; a1 = pointer to last string
00:00006C94 3611            	  1518: 	move.w (a1),d3				; d3 = length of last string (likely 0)
00:00006C96 48C3            	  1519: 	ext.l d3
00:00006C98 D689            	  1520: 	add.l a1,d3						; d3 = pointer past end of last string
00:00006C9A 5683            	  1521: 	addq.l #3,d3					; 2 for length, 1 for rounding
00:00006C9C 9883            	  1522: 	sub.l d3,d4						; free = VARBGN - LastStr+length of (LastStr)
00:00006C9E B484            	  1523: 	cmp.l d4,d2						; request < free?
00:00006CA0 65C4            	  1524: 	blo .0001
00:00006CA2 4DFA089C        	  1525: 	lea NOSTRING,a6
00:00006CA6 600004C0        	  1526: 	bra ERROR
                            	  1527: 		
                            	  1528: ;-------------------------------------------------------------------------------	
                            	  1529: ; Garbage collect strings. This copies all strings in use to the lower end of
                            	  1530: ; the string area and adjusts the string pointers in variables and on the
                            	  1531: ; stack to point to the new location.
                            	  1532: ;
                            	  1533: ; Modifies:
                            	  1534: ;		none
                            	  1535: ;-------------------------------------------------------------------------------	
                            	  1536: 
                            	  1537: GarbageCollectStrings:
00:00006CAA 48E70074        	  1538: 	movem.l a1/a2/a3/a5,-(sp)
00:00006CAE 227A08F8        	  1539: 	move.l StrArea,a1			; source area pointer
00:00006CB2 247A08F4        	  1540: 	move.l StrArea,a2			; target area pointer
00:00006CB6 2A7A08F4        	  1541: 	move.l LastStr,a5
                            	  1542: .0001
00:00006CBA 6140            	  1543: 	bsr StringInVar				; check if the string is used by a variable
00:00006CBC 6506            	  1544: 	bcs .moveString
00:00006CBE 610000A6        	  1545: 	bsr StringOnStack			; check if string is on string expression stack
00:00006CC2 641C            	  1546: 	bcc .nextString				; if not on stack or in a var then move to next string
                            	  1547: 	
                            	  1548: 	; The string is in use, copy to active string area
                            	  1549: .moveString:
00:00006CC4 610000D0        	  1550: 	bsr UpdateStringPointers	; update pointer to string on stack or in variable
00:00006CC8 611C            	  1551: 	bsr NextString				; a3 = pointer to next string
00:00006CCA 610005CA        	  1552: 	bsr MVUPW							; will copy the length and string text
                            	  1553: .0005
00:00006CCE B3CD            	  1554: 	cmp.l a5,a1						; is it the last string?
00:00006CD0 63E8            	  1555: 	bls .0001
00:00006CD2 23CA000075AC    	  1556: 	move.l a2,LastStr			; update last string pointer
00:00006CD8 4252            	  1557: 	clr.w (a2)						; set zero length
00:00006CDA 4CDF2E00        	  1558: 	movem.l (sp)+,a1/a2/a3/a5
00:00006CDE 4E75            	  1559: 	rts
                            	  1560: .nextString:
00:00006CE0 6104            	  1561: 	bsr NextString
00:00006CE2 224B            	  1562: 	move.l a3,a1
00:00006CE4 60E8            	  1563: 	bra .0005
                            	  1564: 
                            	  1565: ;-------------------------------------------------------------------------------	
                            	  1566: ; Parameters:
                            	  1567: ;		a1 - pointer to current string
                            	  1568: ; Returns:
                            	  1569: ;		a3 - pointer to next string
                            	  1570: ;-------------------------------------------------------------------------------	
                            	  1571: 
                            	  1572: NextString:
00:00006CE6 2F04            	  1573: 	move.l d4,-(sp)
00:00006CE8 3811            	  1574: 	move.w (a1),d4				; d4 = string length
00:00006CEA 48C4            	  1575: 	ext.l d4							; make d4 long
00:00006CEC 5684            	  1576: 	addq.l #3,d4					; plus 2 for length field, 1 for rounding
00:00006CEE D889            	  1577: 	add.l a1,d4
00:00006CF0 0284FFFFFFFE    	  1578: 	andi.l #$FFFFFFFE,d4	; make even wyde address
00:00006CF6 2644            	  1579: 	move.l d4,a3
00:00006CF8 281F            	  1580: 	move.l (sp)+,d4
00:00006CFA 4E75            	  1581: 	rts
                            	  1582: 
                            	  1583: ;-------------------------------------------------------------------------------	
                            	  1584: ; Check if a variable is using a string
                            	  1585: ;
                            	  1586: ; Modifies:
                            	  1587: ;		d2,d3,a4
                            	  1588: ; Parameters:
                            	  1589: ;		a1 = pointer to string descriptor
                            	  1590: ; Returns:
                            	  1591: ;		cf = 1 if string in use, 0 otherwise
                            	  1592: ;-------------------------------------------------------------------------------	
                            	  1593: 
                            	  1594: StringInVar:
                            	  1595: 	; check global vars
00:00006CFC 287A08B6        	  1596: 	move.l VARBGN,a4
00:00006D00 761F            	  1597: 	moveq #31,d3			; 32 vars
00:00006D02 6116            	  1598: 	bsr SIV1
                            	  1599: 	; now check local vars
00:00006D04 287A0866        	  1600: 	move.l STKFP,a4
                            	  1601: .0001
00:00006D08 588C            	  1602: 	addq.l #4,a4			; point to variable area
00:00006D0A 7607            	  1603: 	moveq #7,d3
00:00006D0C 610C            	  1604: 	bsr SIV1					; check variable area
00:00006D0E 286CFFFC        	  1605: 	move.l -4(a4),a4	; get previous frame pointer
00:00006D12 B9FAF32E        	  1606: 	cmp.l ENDMEM,a4
00:00006D16 65F0            	  1607: 	blo .0001
00:00006D18 4E75            	  1608: 	rts
                            	  1609: 
                            	  1610: ;-------------------------------------------------------------------------------	
                            	  1611: ; SIV1 - string in variable helper. This routine does a two-up return if the
                            	  1612: ; string is found in a variable. No need to keep searching.
                            	  1613: ;
                            	  1614: ; Modifies:
                            	  1615: ;		d2,d3,a4
                            	  1616: ; Parameters:
                            	  1617: ;		d3 = number of variables-1 to check
                            	  1618: ;		a4 = string space
                            	  1619: ;		a1 = pointer to string descriptor
                            	  1620: ; Returns:
                            	  1621: ;		cf = 1 if string in use, 0 otherwise
                            	  1622: ;-------------------------------------------------------------------------------	
                            	  1623: 
                            	  1624: SIV1:
                            	  1625: .0003
00:00006D1A 0C9400000002    	  1626: 	cmp.l #DT_STRING,(a4)
00:00006D20 6612            	  1627: 	bne .0004
00:00006D22 242C0008        	  1628: 	move.l 8(a4),d2
00:00006D26 5582            	  1629: 	subq.l #2,d2
00:00006D28 B3C2            	  1630: 	cmp.l d2,a1
00:00006D2A 6608            	  1631: 	bne .0004
00:00006D2C 588F            	  1632: 	addq.l #4,sp			; pop return address
00:00006D2E 003C0001        	  1633: 	ori #1,ccr
00:00006D32 4E75            	  1634: 	rts								; do two up return
                            	  1635: .0004
00:00006D34 508C            	  1636: 	addq.l #8,a4			;  increment pointer by 16
00:00006D36 508C            	  1637: 	addq.l #8,a4
00:00006D38 51CBFFE0        	  1638: 	dbra d3,.0003
00:00006D3C 023C00FE        	  1639: 	andi #$FE,ccr
00:00006D40 4E75            	  1640: 	rts
                            	  1641: 
                            	  1642: ;-------------------------------------------------------------------------------	
                            	  1643: ; Check if a value could be a pointer into the string area.
                            	  1644: ; Even if the data type indicated a string, it may not be. It could just be a
                            	  1645: ; coincidence. So check that the pointer portion is pointing into string
                            	  1646: ; memory. It is extremely unlikely to have a data type and a valid pointer
                            	  1647: ; match and it not be a string.
                            	  1648: ;
                            	  1649: ; Returns
                            	  1650: ;		d3 = pointer to string
                            	  1651: ;		cf=1 if points into string area, 0 otherwise
                            	  1652: ;-------------------------------------------------------------------------------	
                            	  1653: 
                            	  1654: PointsIntoStringArea:
00:00006D42 0C9400000002    	  1655: 	cmp.l #DT_STRING,(a4)		; is it a string data type?
00:00006D48 6616            	  1656: 	bne .0001
00:00006D4A 262C0008        	  1657: 	move.l 8(a4),d3					; likely a string if
00:00006D4E B6BA0858        	  1658: 	cmp.l StrArea,d3				; flagged as a string, and pointer is into string area
00:00006D52 650C            	  1659: 	blo .0001
00:00006D54 B6BA085E        	  1660: 	cmp.l VARBGN,d3
00:00006D58 6406            	  1661: 	bhs .0001
00:00006D5A 003C0001        	  1662: 	ori #1,ccr
00:00006D5E 4E75            	  1663: 	rts
                            	  1664: .0001
00:00006D60 023C00FE        	  1665: 	andi #$FE,ccr
00:00006D64 4E75            	  1666: 	rts
                            	  1667: 
                            	  1668: ;-------------------------------------------------------------------------------	
                            	  1669: ; Check if the string is a temporary on stack
                            	  1670: ;
                            	  1671: ; Parameters:
                            	  1672: ;		a3 = pointer to old string text area
                            	  1673: ; Returns:
                            	  1674: ;		cf = 1 if string in use, 0 otherwise
                            	  1675: ;-------------------------------------------------------------------------------	
                            	  1676: 
                            	  1677: StringOnStack:
00:00006D66 48E72028        	  1678: 	movem.l d2/a2/a4,-(sp)
00:00006D6A 7607            	  1679: 	moveq #7,d3
00:00006D6C 284F            	  1680: 	move.l sp,a4
                            	  1681: .0002
00:00006D6E 61D2            	  1682: 	bsr PointsIntoStringArea
00:00006D70 6408            	  1683: 	bcc .0003
00:00006D72 242C0008        	  1684: 	move.l 8(a4),d2			; d2 = string text pointer
00:00006D76 B7C2            	  1685: 	cmp.l d2,a3					; compare string pointers
00:00006D78 6712            	  1686: 	beq .0001						; same pointer?
                            	  1687: .0003
00:00006D7A 588C            	  1688: 	addq.l #4,a4				; bump pointer into stack
00:00006D7C B9FAF2C4        	  1689: 	cmp.l ENDMEM,a4			; have we hit end of stack yet?
00:00006D80 65EC            	  1690: 	blo .0002
00:00006D82 4CDF1404        	  1691: 	movem.l (sp)+,d2/a2/a4
00:00006D86 023C00FE        	  1692: 	andi #$FE,ccr
00:00006D8A 4E75            	  1693: 	rts
                            	  1694: .0001
00:00006D8C 4CDF1404        	  1695: 	movem.l (sp)+,d2/a2/a4
00:00006D90 003C0001        	  1696: 	ori #1,ccr
00:00006D94 4E75            	  1697: 	rts
                            	  1698: 	
                            	  1699: ;-------------------------------------------------------------------------------	
                            	  1700: ; Update pointers to string to point to new area. All string areas must be
                            	  1701: ; completely checked because there may be more than one pointer to the string.
                            	  1702: ;
                            	  1703: ; Modifies:
                            	  1704: ;		d2,d3,d4,a4
                            	  1705: ; Parameters:
                            	  1706: ;		a1 = old pointer to string
                            	  1707: ;		a2 = new pointer to string
                            	  1708: ;-------------------------------------------------------------------------------	
                            	  1709: 
                            	  1710: UpdateStringPointers:
00:00006D96 2F0B            	  1711: 	move.l a3,-(sp)
00:00006D98 47E90002        	  1712: 	lea 2(a1),a3						; a3 points to old string text area
                            	  1713: 	; check global variable space
00:00006D9C 287A0816        	  1714: 	move.l VARBGN,a4
00:00006DA0 761F            	  1715: 	moveq #31,d3						; 32 vars to check
00:00006DA2 611E            	  1716: 	bsr USP1
                            	  1717: 	; check stack for strings
00:00006DA4 284F            	  1718: 	move.l sp,a4						; start at stack bottom and work towards top
                            	  1719: .0002
00:00006DA6 619A            	  1720: 	bsr PointsIntoStringArea
00:00006DA8 640C            	  1721: 	bcc .0001
                            	  1722: 	; Here we probably have a string, one last check
00:00006DAA B68A            	  1723: 	cmp.l a2,d3							; should be >= a2 as we are packing the space
00:00006DAC 6508            	  1724: 	blo .0001
00:00006DAE 294A0008        	  1725: 	move.l a2,8(a4)					; update pointer on stack with new address
00:00006DB2 546C0008        	  1726: 	addi.w #2,8(a4)					; bump up to text part of string
                            	  1727: .0001
00:00006DB6 588C            	  1728: 	addq.l #4,a4
00:00006DB8 B9FAF288        	  1729: 	cmp.l ENDMEM,a4
00:00006DBC 65E8            	  1730: 	blo .0002
00:00006DBE 265F            	  1731: 	move.l (sp)+,a3
00:00006DC0 4E75            	  1732: 	rts
                            	  1733: 
                            	  1734: ;-------------------------------------------------------------------------------	
                            	  1735: ; Both global and local variable spaces are updated in the same manner.
                            	  1736: ;
                            	  1737: ; Parameters:
                            	  1738: ;		a1 = old pointer to string
                            	  1739: ;		a2 = new pointer to string
                            	  1740: ;		a4 = start of string space
                            	  1741: ;		d3 = number of string variables
                            	  1742: ;-------------------------------------------------------------------------------	
                            	  1743: 
                            	  1744: USP1:
                            	  1745: .0002
00:00006DC2 0C9400000002    	  1746: 	cmp.l #DT_STRING,(a4)		; check the data type
00:00006DC8 6610            	  1747: 	bne .0001								; not a string, go to next
00:00006DCA 242C0008        	  1748: 	move.l 8(a4),d2					; d2 = pointer to string text
00:00006DCE B7C2            	  1749: 	cmp.l d2,a3							; does pointer match old pointer?
00:00006DD0 6608            	  1750: 	bne .0001
00:00006DD2 294A0008        	  1751: 	move.l a2,8(a4)					; copy in new pointer
00:00006DD6 54AC0008        	  1752: 	addi.l #2,8(a4)					; point to string text
                            	  1753: .0001
00:00006DDA 508C            	  1754: 	addq.l #8,a4						; increment pointer by 16
00:00006DDC 508C            	  1755: 	addq.l #8,a4
00:00006DDE 51CBFFE2        	  1756: 	dbra d3,.0002
00:00006DE2 4E75            	  1757: 	rts
                            	  1758: 
                            	  1759: ;-------------------------------------------------------------------------------	
                            	  1760: ; ===== Test for a valid variable name.  Returns Carry=1 if not
                            	  1761: ;	found, else returns Carry=0 and the address of the
                            	  1762: ;	variable in D0.
                            	  1763: 
                            	  1764: TSTV:
00:00006DE4 61000628        	  1765: 	bsr	IGNBLK
00:00006DE8 7000            	  1766: 	CLR.L	D0
00:00006DEA 1010            	  1767: 	MOVE.B (A0),D0 	 	; look at the program text
00:00006DEC 903C0040        	  1768: 	SUB.B	#'@',D0
00:00006DF0 6572            	  1769: 	BCS	TSTVRT				; C=1: not a variable
00:00006DF2 6638            	  1770: 	BNE	TV1						; branch if not "@" array
00:00006DF4 5248            	  1771: 	ADDQ #1,A0				; If it is, it should be
00:00006DF6 6100FE3E        	  1772: 	BSR	PARN					; followed by (EXPR) as its index.
00:00006DFA D080            	  1773: 	ADD.L	D0,D0
00:00006DFC 650003AC        	  1774: 	BCS	QHOW					; say "How?" if index is too big
00:00006E00 D080            	  1775: 	ADD.L	D0,D0
00:00006E02 650003A6        	  1776: 	BCS	QHOW
00:00006E06 D080            	  1777: 	ADD.L	D0,D0
00:00006E08 650003A0        	  1778: 	BCS	QHOW
00:00006E0C D080            	  1779: 	ADD.L	D0,D0
00:00006E0E 6500039A        	  1780: 	BCS	QHOW
00:00006E12 2F00            	  1781: 	move.l d0,-(sp)		; save the index
00:00006E14 6100012A        	  1782: 	bsr	SIZE					; get amount of free memory
00:00006E18 221F            	  1783: 	move.l (sp)+,d1		; get back the index
00:00006E1A F2006000        	  1784: 	fmove.l fp0,d0		; convert to integer
00:00006E1E B081            	  1785: 	cmp.l	d1,d0				; see if there's enough memory
00:00006E20 63000380        	  1786: 	bls	QSORRY				; if not, say "Sorry"
00:00006E24 203A078E        	  1787: 	move.l VARBGN,d0	; put address of array element...
00:00006E28 9081            	  1788: 	sub.l	d1,d0				; into D0
00:00006E2A 4E75            	  1789: 	rts
                            	  1790: TV1
00:00006E2C B03C001B        	  1791: 	CMP.B	#27,D0			; if not @, is it A through Z?
00:00006E30 0A3C0001        	  1792: 	EOR	#1,CCR
00:00006E34 652E            	  1793: 	BCS	TSTVRT				; if not, set Carry and return
00:00006E36 5248            	  1794: 	ADDQ #1,A0				; else bump the text pointer
00:00006E38 0C00004C        	  1795: 	cmpi.b #'L',d0		; is it a local? L0 to L7
00:00006E3C 661E            	  1796: 	bne TV2
00:00006E3E 1010            	  1797: 	move.b (a0),d0
00:00006E40 0C000030        	  1798: 	cmpi.b #'0',d0
00:00006E44 6516            	  1799: 	blo TV2
00:00006E46 0C000037        	  1800: 	cmpi.b #'7',d0
00:00006E4A 6210            	  1801: 	bhi TV2
00:00006E4C 903C0030        	  1802: 	sub.b #'0',d0
00:00006E50 5248            	  1803: 	addq #1,a0			; bump text pointer
00:00006E52 E988            	  1804: 	lsl.l #4,d0			; *16 bytes per var
00:00006E54 D0BA0716        	  1805: 	add.l STKFP,d0
00:00006E58 5880            	  1806: 	add.l #4,d0
00:00006E5A 4E75            	  1807: 	rts
                            	  1808: TV2
00:00006E5C E988            	  1809: 	LSL.L #4,D0			; compute the variable's address
00:00006E5E 223A0754        	  1810: 	MOVE.L VARBGN,D1
00:00006E62 D081            	  1811: 	ADD.L	D1,D0			; and return it in D0 with Carry=0
                            	  1812: TSTVRT
00:00006E64 4E75            	  1813: 	RTS
                            	  1814: 
                            	  1815: 
                            	  1816: * ===== Divide the 32 bit value in D0 by the 32 bit value in D1.
                            	  1817: *	Returns the 32 bit quotient in D0, remainder in D1.
                            	  1818: *
                            	  1819: DIV32
00:00006E66 4A81            	  1820: 	TST.L	D1		check for divide-by-zero
00:00006E68 67000340        	  1821: 	BEQ	QHOW		if so, say "How?"
00:00006E6C 2401            	  1822: 	MOVE.L	D1,D2
00:00006E6E 2801            	  1823: 	MOVE.L	D1,D4
00:00006E70 B184            	  1824: 	EOR.L	D0,D4		see if the signs are the same
00:00006E72 4A80            	  1825: 	TST.L	D0		take absolute value of D0
00:00006E74 6A02            	  1826: 	BPL	DIV1
00:00006E76 4480            	  1827: 	NEG.L	D0
00:00006E78 4A81            	  1828: DIV1	TST.L	D1		take absolute value of D1
00:00006E7A 6A02            	  1829: 	BPL	DIV2
00:00006E7C 4481            	  1830: 	NEG.L	D1
00:00006E7E 761F            	  1831: DIV2	MOVEQ	#31,D3		iteration count for 32 bits
00:00006E80 2200            	  1832: 	MOVE.L	D0,D1
00:00006E82 7000            	  1833: 	CLR.L	D0
00:00006E84 D281            	  1834: DIV3	ADD.L	D1,D1		(This algorithm was translated from
00:00006E86 D180            	  1835: 	ADDX.L	D0,D0		; the divide routine in Ron Cain's
00:00006E88 6708            	  1836: 	BEQ	DIV4		Small-C run time library.)
00:00006E8A B082            	  1837: 	CMP.L	D2,D0
00:00006E8C 6B04            	  1838: 	BMI	DIV4
00:00006E8E 5281            	  1839: 	ADDQ.L	#1,D1
00:00006E90 9082            	  1840: 	SUB.L	D2,D0
00:00006E92 51CBFFF0        	  1841: DIV4	DBRA	D3,DIV3
00:00006E96 C141            	  1842: 	EXG	D0,D1		put rem. & quot. in proper registers
00:00006E98 4A84            	  1843: 	TST.L	D4		were the signs the same?
00:00006E9A 6A04            	  1844: 	BPL	DIVRT
00:00006E9C 4480            	  1845: 	NEG.L	D0		if not, results are negative
00:00006E9E 4481            	  1846: 	NEG.L	D1
00:00006EA0 4E75            	  1847: DIVRT	RTS
                            	  1848: 
                            	  1849: 
                            	  1850: ; ===== The PEEK function returns the byte stored at the address
                            	  1851: ;	contained in the following expression.
                            	  1852: 
                            	  1853: PEEK
00:00006EA2 1E3C0042        	  1854: 	MOVE.B #'B',d7
00:00006EA6 1210            	  1855: 	MOVE.B (a0),d1
00:00006EA8 0C01002E        	  1856: 	CMPI.B #'.',d1
00:00006EAC 6604            	  1857: 	BNE .0001
00:00006EAE 5248            	  1858: 	ADDQ #1,a0
00:00006EB0 1E18            	  1859: 	move.b (a0)+,d7
                            	  1860: .0001
00:00006EB2 6100FD82        	  1861: 	BSR	PARN		get the memory address
00:00006EB6 0C8000000001    	  1862: 	cmpi.l #DT_NUMERIC,d0
00:00006EBC 660002F4        	  1863: 	bne ETYPE
00:00006EC0 F2006000        	  1864: 	FMOVE.L FP0,D0
00:00006EC4 2240            	  1865: 	MOVE.L D0,A1
00:00006EC6 0C070042        	  1866: 	cmpi.b #'B',d7
00:00006ECA 660C            	  1867: 	bne .0002
                            	  1868: .0005
00:00006ECC 7000            	  1869: 	CLR.L	D0				; upper 3 bytes will be zero
00:00006ECE 1011            	  1870: 	MOVE.B (A1),D0
00:00006ED0 F2005800        	  1871: 	FMOVE.B	D0,FP0 	; get the addressed byte
00:00006ED4 7001            	  1872: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00006ED6 4E75            	  1873: 	RTS							; and return it
                            	  1874: .0002
00:00006ED8 0C070057        	  1875: 	cmpi.b #'W',d7
00:00006EDC 660C            	  1876: 	bne .0003
00:00006EDE 7000            	  1877: 	CLR.L d0
00:00006EE0 3011            	  1878: 	MOVE.W (A1),D0
00:00006EE2 F2005000        	  1879: 	FMOVE.W	D0,FP0	;	get the addressed word
00:00006EE6 7001            	  1880: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00006EE8 4E75            	  1881: 	RTS							; and return it
                            	  1882: .0003
00:00006EEA 0C07004C        	  1883: 	cmpi.b #'L',d7
00:00006EEE 660C            	  1884: 	bne .0004
00:00006EF0 7000            	  1885: 	CLR.L d0
00:00006EF2 2011            	  1886: 	MOVE.L (A1),D0
00:00006EF4 F2004000        	  1887: 	FMOVE.L	D0,FP0 	; get the lword
00:00006EF8 7001            	  1888: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00006EFA 4E75            	  1889: 	RTS							; and return it
                            	  1890: .0004
00:00006EFC 0C070046        	  1891: 	cmpi.b #'F',d7
00:00006F00 66CA            	  1892: 	bne .0005
00:00006F02 F2114800        	  1893: 	FMOVE.X	(A1),FP0 		; get the addressed float
00:00006F06 7001            	  1894: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00006F08 4E75            	  1895: 	RTS			and return it
                            	  1896: 
                            	  1897: ;-------------------------------------------------------------------------------
                            	  1898: ; The RND function returns a random number from 0 to the value of the following
                            	  1899: ; expression in fp0.
                            	  1900: ;-------------------------------------------------------------------------------
                            	  1901: 
                            	  1902: RND:
00:00006F0A 6100FD2A        	  1903: 	bsr	PARN								; get the upper limit
00:00006F0E 0C8000000001    	  1904: 	cmpi.l #DT_NUMERIC,d0		; must be numeric
00:00006F14 6600029C        	  1905: 	bne ETYPE
00:00006F18 F200003A        	  1906: 	ftst.x fp0							; it must be positive and non-zero
00:00006F1C F281028C        	  1907: 	fbeq QHOW
00:00006F20 F2940288        	  1908: 	fblt QHOW
00:00006F24 F2000100        	  1909: 	fmove fp0,fp2
00:00006F28 7028            	  1910: 	moveq #40,d0						; function #40 get random float
00:00006F2A 4E4F            	  1911: 	trap #15
00:00006F2C F2000823        	  1912: 	fmul fp2,fp0
00:00006F30 7001            	  1913: 	moveq #DT_NUMERIC,d0		; data type is a number
00:00006F32 4E75            	  1914: 	rts
                            	  1915: 
                            	  1916: ; ===== The ABS function returns an absolute value in D0.
                            	  1917: 
                            	  1918: ABS:	
00:00006F34 6100FD00        	  1919: 	bsr	PARN			; get the following expr.'s value
00:00006F38 F2000018        	  1920: 	fabs.x fp0
00:00006F3C 7001            	  1921: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00006F3E 4E75            	  1922: 	rts
                            	  1923: 
                            	  1924: ; ===== The SIZE function returns the size of free memory in D0.
                            	  1925: 
                            	  1926: SIZE:
00:00006F40 203A0666        	  1927: 	move.l StrArea,d0		; get the number of free bytes...
00:00006F44 90BA066A        	  1928: 	sub.l	 TXTUNF,d0		; between 'TXTUNF' and 'StrArea'
00:00006F48 F2004000        	  1929: 	fmove.l d0,fp0
00:00006F4C 7001            	  1930: 	moveq #DT_NUMERIC,d0	; data type is a number
00:00006F4E 4E75            	  1931: 	rts										; return the number in fp0
                            	  1932: 	
                            	  1933: ; ===== The TICK function returns the processor tick register in D0.
                            	  1934: 
                            	  1935: TICK:
00:00006F50 4E7A0FF0        	  1936: 	movec tick,d0
00:00006F54 F2004000        	  1937: 	fmove.l d0,fp0
00:00006F58 7001            	  1938: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00006F5A 4E75            	  1939: 	rts
                            	  1940: 
                            	  1941: ; ===== The CORENO function returns the core number in D0.
                            	  1942: 
                            	  1943: CORENO:
00:00006F5C 4E7A0FE0        	  1944: 	movec coreno,d0
00:00006F60 F2004000        	  1945: 	fmove.l d0,fp0
00:00006F64 7001            	  1946: 	moveq #DT_NUMERIC,d0					; data type is a number
00:00006F66 4E75            	  1947: 	rts
                            	  1948: 
                            	  1949: ;-------------------------------------------------------------------------------
                            	  1950: ; Get a pair of argments for the LEFT$ and RIGHT$ functions.
                            	  1951: ; 	(STRING, NUM)
                            	  1952: ; Returns:
                            	  1953: ;		fp0 = number
                            	  1954: ;		fp1 = string
                            	  1955: ;-------------------------------------------------------------------------------
                            	  1956: 
                            	  1957: LorRArgs:
00:00006F68 61000440        	  1958: 	bsr	TSTC						; else look for ( STRING EXPR, NUM EXPR )
00:00006F6C 28              	  1959: 	dc.b	'(',LorR1-*
00:00006F6D 33
00:00006F6E 6100F9F8        	  1960: 	bsr	EXPR
00:00006F72 0C8000000002    	  1961: 	cmpi.l #DT_STRING,d0
00:00006F78 66000238        	  1962: 	bne ETYPE
00:00006F7C 6100F988        	  1963: 	bsr XP_PUSH
00:00006F80 61000428        	  1964: 	bsr TSTC
00:00006F84 2C              	  1965: 	dc.b ',',LorR1-*
00:00006F85 1B
00:00006F86 6100F9E0        	  1966: 	bsr EXPR
00:00006F8A 0C8000000001    	  1967: 	cmpi.l #DT_NUMERIC,d0
00:00006F90 66000220        	  1968: 	bne ETYPE
00:00006F94 61000414        	  1969: 	bsr	TSTC
00:00006F98 29              	  1970: 	dc.b	')',LorR1-*
00:00006F99 07
00:00006F9A 6100F996        	  1971: 	bsr XP_POP1
00:00006F9E 4E75            	  1972: 	rts
                            	  1973: LorR1
00:00006FA0 60000208        	  1974: 	bra QHOW
                            	  1975: 	
                            	  1976: ;-------------------------------------------------------------------------------
                            	  1977: ; MID$ function gets a substring of characters from start position for
                            	  1978: ; requested length.
                            	  1979: ;-------------------------------------------------------------------------------
                            	  1980: 
                            	  1981: MID:
00:00006FA4 61000404        	  1982: 	bsr	TSTC						; look for ( STRING EXPR, NUM EXPR [, NUM_EXPR] )
00:00006FA8 28              	  1983: 	dc.b	'(',MID1-*
00:00006FA9 C1
00:00006FAA 6100F9BC        	  1984: 	bsr	EXPR
00:00006FAE 0C8000000002    	  1985: 	cmpi.l #DT_STRING,d0
00:00006FB4 660001FC        	  1986: 	bne ETYPE
00:00006FB8 6100F94C        	  1987: 	bsr XP_PUSH
00:00006FBC 610003EC        	  1988: 	bsr TSTC
00:00006FC0 2C              	  1989: 	dc.b ',',MID1-*
00:00006FC1 A9
00:00006FC2 6100F9A4        	  1990: 	bsr EXPR
00:00006FC6 0C8000000001    	  1991: 	cmpi.l #DT_NUMERIC,d0
00:00006FCC 660001E4        	  1992: 	bne ETYPE
00:00006FD0 6100F934        	  1993: 	bsr XP_PUSH
00:00006FD4 7A02            	  1994: 	moveq #2,d5
00:00006FD6 610003D2        	  1995: 	bsr	TSTC
00:00006FDA 2C              	  1996: 	dc.b ',',MID2-*
00:00006FDB 11
00:00006FDC 6100F98A        	  1997: 	bsr EXPR
00:00006FE0 0C8000000001    	  1998: 	cmpi.l #DT_NUMERIC,d0
00:00006FE6 660001CA        	  1999: 	bne ETYPE
00:00006FEA 7A03            	  2000: 	moveq #3,d5					; d5 indicates 3 params
                            	  2001: MID2
00:00006FEC 610003BC        	  2002: 	bsr TSTC
00:00006FF0 29              	  2003: 	dc.b ')',MID1-*
00:00006FF1 79
00:00006FF2 6100F93E        	  2004: 	bsr XP_POP1
00:00006FF6 0C050003        	  2005: 	cmpi.b #3,d5				; did we have 3 arguments?
00:00006FFA 6708            	  2006: 	beq MID5						; branch if did
00:00006FFC F23C40000000FFFF	  2007: 	fmove.l #$FFFF,fp0	; set length = max
                            	  2008: MID5
00:00007004 F2000500        	  2009: 	fmove.x fp1,fp2			; fp2 = start pos
00:00007008 6100F928        	  2010: 	bsr XP_POP1					; fp1 = string descriptor
                            	  2011: ;-------------------------------------------------------------------------------
                            	  2012: ; Perform MID$ function
                            	  2013: ; 	fp1 = string descriptor
                            	  2014: ; 	fp2 = starting position
                            	  2015: ; 	fp0 = length
                            	  2016: ;-------------------------------------------------------------------------------
                            	  2017: DOMID
00:0000700C F239688000040600	  2018: 	fmove.x fp1,_fpWork	; _fpWork = string descriptor
00:00007014 F2036100        	  2019: 	fmove.l fp2,d3			; d3 = start pos
00:00007018 B67900040600    	  2020: 	cmp.w _fpWork,d3		; is start pos < length
00:0000701E 6400018A        	  2021: 	bhs QHOW
00:00007022 F2026000        	  2022: 	fmove.l fp0,d2			; d2=length
00:00007026 D682            	  2023: 	add.l d2,d3					; start pos + length < string length?
00:00007028 B47900040600    	  2024: 	cmp.w _fpWork,d2
00:0000702E 6308            	  2025: 	bls MID4
00:00007030 343900040600    	  2026: 	move.w _fpWork,d2		; move string length to d2
00:00007036 48C2            	  2027: 	ext.l d2
                            	  2028: MID4
00:00007038 6100FC12        	  2029: 	bsr AllocateString	; a1 = pointer to new string
00:0000703C 2449            	  2030: 	move.l a1,a2				; a2 = pointer to new string
00:0000703E 227900040604    	  2031: 	move.l _fpWork+4,a1	; a1 = pointer to string
00:00007044 F2036100        	  2032: 	fmove.l fp2,d3			; d3 = start pos
00:00007048 D3C3            	  2033: 	add.l d3,a1					; a1 = pointer to start pos
00:0000704A 33C200040600    	  2034: 	move.w d2,_fpWork		; length
00:00007050 23CA00040604    	  2035: 	move.l a2,_fpWork+4	; prep to return target string
00:00007056 2649            	  2036: 	move.l a1,a3				; a3 = pointer to start pos
00:00007058 D7C2            	  2037: 	add.l d2,a3					; a3 = pointer to end pos
00:0000705A 61000230        	  2038: 	bsr MVUP						; move A1 to A2 until A1 = A3
00:0000705E 7002            	  2039: 	moveq #DT_STRING,d0	; data type is a string
00:00007060 F239480000040600	  2040: 	fmove.x _fpWork,fp0	; string descriptor in fp0
00:00007068 4E75            	  2041: 	rts
                            	  2042: MID1
00:0000706A 6000013E        	  2043: 	bra QHOW
                            	  2044: 	
                            	  2045: ;-------------------------------------------------------------------------------
                            	  2046: ; LEFT$ function truncates the string after fp0 characters.
                            	  2047: ; Just like MID$ but with a zero starting postion.
                            	  2048: ;-------------------------------------------------------------------------------
                            	  2049: 	
                            	  2050: LEFT:
00:0000706E 6100FEF8        	  2051: 	bsr LorRArgs				; get arguments
00:00007072 F23C59000000    	  2052: 	fmove.b #0,fp2			; start pos = 0
00:00007078 6092            	  2053: 	bra DOMID
                            	  2054: 
                            	  2055: ;-------------------------------------------------------------------------------
                            	  2056: ; RIGHT$ function gets the rightmost characters.
                            	  2057: ; The start position must be calculated based on the number of characters
                            	  2058: ; requested and the string length.
                            	  2059: ;-------------------------------------------------------------------------------
                            	  2060: 
                            	  2061: RIGHT:
00:0000707A 6100FEEC        	  2062: 	bsr LorRArgs				; get arguments
00:0000707E F2026000        	  2063: 	fmove.l fp0,d2			; d2 = required length
00:00007082 F239688000040600	  2064: 	fmove.x fp1,_fpWork	; _fpWork = string descriptor
00:0000708A 363900040600    	  2065: 	move.w _fpWork,d3		; d3 = string length
00:00007090 48C3            	  2066: 	ext.l d3						; make d3 a long
00:00007092 B682            	  2067: 	cmp.l d2,d3					; is length > right
00:00007094 6202            	  2068: 	bhi .0001
00:00007096 7400            	  2069: 	moveq #0,d2					; we want all the characters if length <= right
                            	  2070: .0001
00:00007098 9682            	  2071: 	sub.l d2,d3					; d3 = startpos = length - right
00:0000709A F2034100        	  2072: 	fmove.l d3,fp2			; fp2 = start position
00:0000709E 6000FF6C        	  2073: 	bra DOMID
                            	  2074: 
                            	  2075: ;-------------------------------------------------------------------------------
                            	  2076: ; LEN( EXPR ) returns the length of a string expression.
                            	  2077: ;-------------------------------------------------------------------------------
                            	  2078: 
                            	  2079: LEN:
00:000070A2 6100FB92        	  2080: 	bsr PARN
00:000070A6 0C8000000002    	  2081: 	cmpi.l #DT_STRING,d0
00:000070AC 66000104        	  2082: 	bne ETYPE
00:000070B0 F239680000040600	  2083: 	fmove.x fp0,_fpWork
00:000070B8 303900040600    	  2084: 	move.w _fpWork,d0
00:000070BE 48C0            	  2085: 	ext.l d0
00:000070C0 F2005000        	  2086: 	fmove.w d0,fp0
00:000070C4 7001            	  2087: 	moveq #DT_NUMERIC,d0
00:000070C6 4E75            	  2088: 	rts
                            	  2089: 
                            	  2090: ;-------------------------------------------------------------------------------
                            	  2091: ; INT( EXPR ) returns the integer value of the expression.
                            	  2092: ; the expression must be in the range of a 32-bit integer.
                            	  2093: ;-------------------------------------------------------------------------------
                            	  2094: 
                            	  2095: INT:
00:000070C8 6100FB6C        	  2096: 	bsr PARN
00:000070CC 0C8000000001    	  2097: 	cmpi.l #DT_NUMERIC,d0
00:000070D2 660000DE        	  2098: 	bne ETYPE
00:000070D6 F2000003        	  2099: 	fintrz fp0,fp0
                            	  2100: ;	fmove.l fp0,d0
                            	  2101: ;	fmove.l d0,fp0
00:000070DA 7001            	  2102: 	moveq #DT_NUMERIC,d0
00:000070DC 4E75            	  2103: 	rts
                            	  2104: 
                            	  2105: 
                            	  2106: ;-------------------------------------------------------------------------------
                            	  2107: ; CHR$( EXPR ) returns a one byte string containing the character.
                            	  2108: ;-------------------------------------------------------------------------------
                            	  2109: 
                            	  2110: CHR:
00:000070DE 6100FB56        	  2111: 	bsr PARN
00:000070E2 0C8000000001    	  2112: 	cmpi.l #DT_NUMERIC,d0
00:000070E8 660000C8        	  2113: 	bne ETYPE
00:000070EC F2006000        	  2114: 	fmove.l fp0,d0
00:000070F0 7401            	  2115: 	moveq #1,d2
00:000070F2 6100FB58        	  2116: 	bsr AllocateString
00:000070F6 1280            	  2117: 	move.b d0,(a1)
00:000070F8 42290001        	  2118: 	clr.b 1(a1)
00:000070FC 7002            	  2119: 	moveq #DT_STRING,d0
00:000070FE 23C900040604    	  2120: 	move.l a1,_fpWork+4
00:00007104 33FC000100040600	  2121: 	move.w #1,_fpWork
00:0000710C F239480000040600	  2122: 	fmove.x _fpWork,fp0
00:00007114 4E75            	  2123: 	rts
                            	  2124: 
                            	  2125: ********************************************************************
                            	  2126: *
                            	  2127: * *** SETVAL *** FIN *** ENDCHK *** ERROR (& friends) ***
                            	  2128: *
                            	  2129: * 'SETVAL' expects a variable, followed by an equal sign and then
                            	  2130: * an expression.  It evaluates the expression and sets the variable
                            	  2131: * to that value.
                            	  2132: *
                            	  2133: * 'FIN' checks the end of a command.  If it ended with ":",
                            	  2134: * execution continues.	If it ended with a CR, it finds the
                            	  2135: * the next line and continues from there.
                            	  2136: *
                            	  2137: * 'ENDCHK' checks if a command is ended with a CR. This is
                            	  2138: * required in certain commands, such as GOTO, RETURN, STOP, etc.
                            	  2139: *
                            	  2140: * 'ERROR' prints the string pointed to by A0. It then prints the
                            	  2141: * line pointed to by CURRNT with a "?" inserted at where the
                            	  2142: * old text pointer (should be on top of the stack) points to.
                            	  2143: * Execution of Tiny BASIC is stopped and a warm start is done.
                            	  2144: * If CURRNT is zero (indicating a direct command), the direct
                            	  2145: * command is not printed. If CURRNT is -1 (indicating
                            	  2146: * 'INPUT' command in progress), the input line is not printed
                            	  2147: * and execution is not terminated but continues at 'INPERR'.
                            	  2148: *
                            	  2149: * Related to 'ERROR' are the following:
                            	  2150: * 'QWHAT' saves text pointer on stack and gets "What?" message.
                            	  2151: * 'AWHAT' just gets the "What?" message and jumps to 'ERROR'.
                            	  2152: * 'QSORRY' and 'ASORRY' do the same kind of thing.
                            	  2153: * 'QHOW' and 'AHOW' also do this for "How?".
                            	  2154: 
                            	  2155: ; SETVAL
                            	  2156: ; Returns:
                            	  2157: ;		a6 pointer to variable
                            	  2158: 
                            	  2159: SETVAL	
00:00007116 6100FCCC        	  2160: 	bsr	TSTV					; variable name?
00:0000711A 6546            	  2161: 	bcs	QWHAT					; if not, say "What?"
00:0000711C 2F00            	  2162: 	move.l d0,-(sp)		; save the variable's address
00:0000711E 6100028A        	  2163: 	bsr	TSTC					; get past the "=" sign
00:00007122 3D              	  2164: 	dc.b	'=',SV1-*
00:00007123 11
00:00007124 6100F842        	  2165: 	bsr	EXPR					; evaluate the expression
00:00007128 2C5F            	  2166: 	move.l (sp)+,a6
00:0000712A 2C80            	  2167: 	move.l d0,(a6)		; save type
00:0000712C F22E68000004    	  2168: 	fmove.x fp0,4(a6) ; and save its value in the variable
00:00007132 4E75            	  2169: 	rts
                            	  2170: SV1
00:00007134 602C            	  2171: 	bra	QWHAT					; if no "=" sign
                            	  2172: 
                            	  2173: FIN
00:00007136 61000272        	  2174: 	bsr	TSTC					; *** FIN ***
00:0000713A 3A              	  2175: 	DC.B ':',FI1-*
00:0000713B 07
00:0000713C 588F            	  2176: 	ADDQ.L #4,SP			; if ":", discard return address
00:0000713E 6000F324        	  2177: 	BRA	RUNSML				; continue on the same line
                            	  2178: FI1
00:00007142 61000266        	  2179: 	bsr	TSTC					; not ":", is it a CR?
00:00007146 0D              	  2180: 	DC.B	CR,FI2-*
00:00007147 07
00:00007148 588F            	  2181: 	ADDQ.L #4,SP			; yes, purge return address
00:0000714A 6000F2C2        	  2182: 	BRA	RUNNXL				; execute the next line
                            	  2183: FI2
00:0000714E 4E75            	  2184: 	RTS								; else return to the caller
                            	  2185: 
                            	  2186: ENDCHK
00:00007150 610002BC        	  2187: 	bsr	IGNBLK
00:00007154 0C10003A        	  2188: 	CMP.B #':',(a0)
00:00007158 6706            	  2189: 	BEQ ENDCHK1
00:0000715A 0C10000D        	  2190: 	CMP.B	#CR,(A0)		; does it end with a CR?
00:0000715E 6602            	  2191: 	BNE	QWHAT					; if not, say "WHAT?"
                            	  2192: ENDCHK1:
00:00007160 4E75            	  2193: 	RTS
                            	  2194: 
                            	  2195: QWHAT
00:00007162 2F08            	  2196: 	MOVE.L A0,-(SP)
                            	  2197: AWHAT
00:00007164 4DFA03CA        	  2198: 	LEA	WHTMSG,A6
                            	  2199: ERROR
00:00007168 6100030A        	  2200: 	bsr	PRMESG		display the error message
00:0000716C 205F            	  2201: 	MOVE.L	(SP)+,A0	restore the text pointer
00:0000716E 203A03F8        	  2202: 	MOVE.L	CURRNT,D0	get the current line number
00:00007172 6700EF3C        	  2203: 	BEQ	WSTART		if zero, do a warm start
00:00007176 B0BCFFFFFFFF    	  2204: 	CMP.L	#-1,D0		is the line no. pointer = -1?
00:0000717C 6700F560        	  2205: 	BEQ	INPERR		if so, redo input
00:00007180 1F10            	  2206: 	MOVE.B	(A0),-(SP)	save the char. pointed to
00:00007182 4210            	  2207: 	CLR.B	(A0)		put a zero where the error is
00:00007184 227A03E2        	  2208: 	MOVE.L	CURRNT,A1	point to start of current line
00:00007188 61000202        	  2209: 	bsr	PRTLN		display the line in error up to the 0
00:0000718C 109F            	  2210: 	MOVE.B	(SP)+,(A0)	restore the character
00:0000718E 103C003F        	  2211: 	MOVE.B	#'?',D0         display a "?"
00:00007192 6100EE96        	  2212: 	BSR	GOOUT
00:00007196 4240            	  2213: 	CLR	D0
00:00007198 5389            	  2214: 	SUBQ.L	#1,A1		point back to the error char.
00:0000719A 6100017E        	  2215: 	bsr	PRTSTG		display the rest of the line
00:0000719E 6000EF10        	  2216: 	BRA	WSTART		and do a warm start
                            	  2217: QSORRY
00:000071A2 2F08            	  2218: 	MOVE.L	A0,-(SP)
                            	  2219: ASORRY
00:000071A4 4DFA03AC        	  2220: 	LEA	SRYMSG,A6
00:000071A8 60BE            	  2221: 	BRA	ERROR
                            	  2222: QHOW
00:000071AA 2F08            	  2223: 	MOVE.L	A0,-(SP)	Error: "How?"
                            	  2224: AHOW
00:000071AC 4DFA037B        	  2225: 	LEA	HOWMSG,A6
00:000071B0 60B6            	  2226: 	BRA	ERROR
                            	  2227: ETYPE
00:000071B2 4DFA0384        	  2228: 	lea TYPMSG,a6
00:000071B6 60B0            	  2229: 	bra ERROR
                            	  2230: 
                            	  2231: *******************************************************************
                            	  2232: *
                            	  2233: * *** GETLN *** FNDLN (& friends) ***
                            	  2234: *
                            	  2235: * 'GETLN' reads in input line into 'BUFFER'. It first prompts with
                            	  2236: * the character in D0 (given by the caller), then it fills the
                            	  2237: * buffer and echos. It ignores LF's but still echos
                            	  2238: * them back. Control-H is used to delete the last character
                            	  2239: * entered (if there is one), and control-X is used to delete the
                            	  2240: * whole line and start over again. CR signals the end of a line,
                            	  2241: * and causes 'GETLN' to return.
                            	  2242: *
                            	  2243: * 'FNDLN' finds a line with a given line no. (in D1) in the
                            	  2244: * text save area.  A1 is used as the text pointer. If the line
                            	  2245: * is found, A1 will point to the beginning of that line
                            	  2246: * (i.e. the high byte of the line no.), and flags are NC & Z.
                            	  2247: * If that line is not there and a line with a higher line no.
                            	  2248: * is found, A1 points there and flags are NC & NZ. If we reached
                            	  2249: * the end of the text save area and cannot find the line, flags
                            	  2250: * are C & NZ.
                            	  2251: * 'FNDLN' will initialize A1 to the beginning of the text save
                            	  2252: * area to start the search. Some other entries of this routine
                            	  2253: * will not initialize A1 and do the search.
                            	  2254: * 'FNDLNP' will start with A1 and search for the line no.
                            	  2255: * 'FNDNXT' will bump A1 by 2, find a CR and then start search.
                            	  2256: * 'FNDSKP' uses A1 to find a CR, and then starts the search.
                            	  2257: 
                            	  2258: GETLN
00:000071B8 6100EE70        	  2259: 	BSR	GOOUT		display the prompt
00:000071BC 103C0020        	  2260: 	MOVE.B	#' ',D0         and a space
00:000071C0 6100EE68        	  2261: 	BSR	GOOUT
00:000071C4 41FA03FA        	  2262: 	LEA	BUFFER,A0	A0 is the buffer pointer
                            	  2263: GL1
00:000071C8 61000298        	  2264: 	bsr	CHKIO		check keyboard
00:000071CC 67FA            	  2265: 	BEQ	GL1		wait for a char. to come in
00:000071CE B03C0008        	  2266: 	CMP.B	#CTRLH,D0	delete last character?
00:000071D2 6726            	  2267: 	BEQ	GL3		if so
00:000071D4 B03C0018        	  2268: 	CMP.B	#CTRLX,D0	delete the whole line?
00:000071D8 6744            	  2269: 	BEQ	GL4		if so
00:000071DA B03C000D        	  2270: 	CMP.B	#CR,D0		accept a CR
00:000071DE 6706            	  2271: 	BEQ	GL2
00:000071E0 B03C0020        	  2272: 	CMP.B	#' ',D0         if other control char., discard it
00:000071E4 65E2            	  2273: 	BCS	GL1
                            	  2274: GL2
00:000071E6 10C0            	  2275: 	MOVE.B	D0,(A0)+	save the char.
00:000071E8 6100EE40        	  2276: 	BSR	GOOUT		echo the char back out
00:000071EC B03C000D        	  2277: 	CMP.B	#CR,D0		if it's a CR, end the line
00:000071F0 675C            	  2278: 	BEQ	GL7
00:000071F2 B1FC0000760F    	  2279: 	CMP.L	#(BUFFER+BUFLEN-1),A0	any more room?
00:000071F8 65CE            	  2280: 	BCS	GL1		yes: get some more, else delete last char.
                            	  2281: GL3
00:000071FA 103C0008        	  2282: 	MOVE.B	#CTRLH,D0	delete a char. if possible
00:000071FE 6100EE2A        	  2283: 	BSR	GOOUT
00:00007202 103C0020        	  2284: 	MOVE.B	#' ',D0
00:00007206 6100EE22        	  2285: 	BSR	GOOUT
00:0000720A B1FC000075C0    	  2286: 	CMP.L	#BUFFER,A0	any char.'s left?
00:00007210 63B6            	  2287: 	BLS	GL1		if not
00:00007212 103C0008        	  2288: 	MOVE.B	#CTRLH,D0	if so, finish the BS-space-BS sequence
00:00007216 6100EE12        	  2289: 	BSR	GOOUT
00:0000721A 5388            	  2290: 	SUBQ.L	#1,A0		decrement the text pointer
00:0000721C 60AA            	  2291: 	BRA	GL1		back for more
                            	  2292: GL4
00:0000721E 2208            	  2293: 	MOVE.L	A0,D1		delete the whole line
00:00007220 92BC000075C0    	  2294: 	SUB.L	#BUFFER,D1	figure out how many backspaces we need
00:00007226 671E            	  2295: 	BEQ	GL6		if none needed, branch
00:00007228 5341            	  2296: 	SUBQ	#1,D1		adjust for DBRA
                            	  2297: GL5
00:0000722A 103C0008        	  2298: 	MOVE.B	#CTRLH,D0	and display BS-space-BS sequences
00:0000722E 6100EDFA        	  2299: 	BSR	GOOUT
00:00007232 103C0020        	  2300: 	MOVE.B	#' ',D0
00:00007236 6100EDF2        	  2301: 	BSR	GOOUT
00:0000723A 103C0008        	  2302: 	MOVE.B	#CTRLH,D0
00:0000723E 6100EDEA        	  2303: 	BSR	GOOUT
00:00007242 51C9FFE6        	  2304: 	DBRA	D1,GL5
                            	  2305: GL6
00:00007246 41FA0378        	  2306: 	LEA	BUFFER,A0	reinitialize the text pointer
00:0000724A 6000FF7C        	  2307: 	BRA	GL1		and go back for more
                            	  2308: GL7
00:0000724E 103C000A        	  2309: 	MOVE.B	#LF,D0		echo a LF for the CR
00:00007252 6000EDD6        	  2310: 	BRA	GOOUT
                            	  2311: 
                            	  2312: FNDLN
00:00007256 B2BC0000FFFF    	  2313: 	CMP.L	#$FFFF,D1	line no. must be < 65535
00:0000725C 6400FF4C        	  2314: 	BCC	QHOW
00:00007260 227AEDDC        	  2315: 	MOVE.L	TXTBGN,A1	init. the text save pointer
                            	  2316: 
                            	  2317: FNDLNP
00:00007264 247A034A        	  2318: 	MOVE.L	TXTUNF,A2	check if we passed the end
00:00007268 538A            	  2319: 	SUBQ.L	#1,A2
00:0000726A B5C9            	  2320: 	CMP.L	A1,A2
00:0000726C 650C            	  2321: 	BCS	FNDRET		if so, return with Z=0 & C=1
00:0000726E 1411            	  2322: 	MOVE.B	(A1),D2	if not, get a line no.
00:00007270 E14A            	  2323: 	LSL	#8,D2
00:00007272 14290001        	  2324: 	MOVE.B	1(A1),D2
00:00007276 B441            	  2325: 	CMP.W	D1,D2		is this the line we want?
00:00007278 6502            	  2326: 	BCS	FNDNXT		no, not there yet
                            	  2327: FNDRET
00:0000727A 4E75            	  2328: 	RTS			return the cond. codes
                            	  2329: 
                            	  2330: FNDNXT
00:0000727C 5489            	  2331: 	ADDQ.L	#2,A1		find the next line
                            	  2332: 
                            	  2333: FNDSKP	
00:0000727E 0C19000D        	  2334: 	CMP.B	#CR,(A1)+	try to find a CR
00:00007282 67E0            	  2335: 	BEQ		FNDLNP
00:00007284 B3FA032A        	  2336: 	CMP.L	TXTUNF,A1
00:00007288 65F4            	  2337: 	BLO		FNDSKP
00:0000728A 60D8            	  2338: 	BRA		FNDLNP		check if end of text
                            	  2339: 
                            	  2340: ;******************************************************************
                            	  2341: ;
                            	  2342: ; *** MVUP *** MVDOWN *** POPA *** PUSHA ***
                            	  2343: ;
                            	  2344: ; 'MVUP' moves a block up from where A1 points to where A2 points
                            	  2345: ; until A1=A3
                            	  2346: ;
                            	  2347: ; 'MVDOWN' moves a block down from where A1 points to where A3
                            	  2348: ; points until A1=A2
                            	  2349: ;
                            	  2350: ; 'POPA' restores the 'FOR' loop variable save area from the stack
                            	  2351: ;
                            	  2352: ; 'PUSHA' stacks for 'FOR' loop variable save area onto the stack
                            	  2353: ;
                            	  2354: 
                            	  2355: MVUP
00:0000728C B7C9            	  2356: 	CMP.L	A1,A3					; see the above description
00:0000728E 6304            	  2357: 	BLS	MVRET
00:00007290 14D9            	  2358: 	MOVE.B	(A1)+,(A2)+
00:00007292 60F8            	  2359: 	BRA	MVUP
                            	  2360: MVRET
00:00007294 4E75            	  2361: 	RTS
                            	  2362: 
                            	  2363: ; For string movements only suitable in some circumstances
                            	  2364: 
                            	  2365: MVUPW
00:00007296 B3CB            	  2366: 	cmp.l a3,a1
00:00007298 6404            	  2367: 	bhs .0001
00:0000729A 34D9            	  2368: 	move.w (a1)+,(a2)+
00:0000729C 60F8            	  2369: 	bra MVUPW
                            	  2370: .0001
00:0000729E 4E75            	  2371: 	rts
                            	  2372: 
                            	  2373: MVDOWN
00:000072A0 B5C9            	  2374: 	CMP.L	A1,A2		see the above description
00:000072A2 67F0            	  2375: 	BEQ	MVRET
00:000072A4 1721            	  2376: 	MOVE.B	-(A1),-(A3)
00:000072A6 60F8            	  2377: 	BRA	MVDOWN
                            	  2378: 
                            	  2379: POPA
00:000072A8 2C5F            	  2380: 	MOVE.L	(SP)+,A6			; A6 = return address
00:000072AA 23DF00007578    	  2381: 	MOVE.L	(SP)+,LOPVAR	restore LOPVAR, but zero means no more
00:000072B0 6730            	  2382: 	BEQ	.0001
00:000072B2 23DF00007584    	  2383: 	MOVE.L	(SP)+,LOPINC+8	if not zero, restore the rest
00:000072B8 23DF00007580    	  2384: 	MOVE.L	(SP)+,LOPINC+4
00:000072BE 23DF0000757C    	  2385: 	MOVE.L	(SP)+,LOPINC
00:000072C4 23DF00007590    	  2386: 	MOVE.L	(SP)+,LOPLMT+8
00:000072CA 23DF0000758C    	  2387: 	MOVE.L	(SP)+,LOPLMT+4
00:000072D0 23DF00007588    	  2388: 	MOVE.L	(SP)+,LOPLMT
00:000072D6 23DF00007594    	  2389: 	MOVE.L	(SP)+,LOPLN
00:000072DC 23DF00007598    	  2390: 	MOVE.L	(SP)+,LOPPT
                            	  2391: .0001
00:000072E2 4ED6            	  2392: 	JMP	(A6)		return
                            	  2393: 
                            	  2394: PUSHA
00:000072E4 223A02D2        	  2395: 	MOVE.L	STKLMT,D1		; Are we running out of stack room?
00:000072E8 928F            	  2396: 	SUB.L	SP,D1
00:000072EA 6400FEB6        	  2397: 	BCC	QSORRY					; if so, say we're sorry
00:000072EE 2C5F            	  2398: 	MOVE.L	(SP)+,A6		; else get the return address
00:000072F0 223A0286        	  2399: 	MOVE.L	LOPVAR,D1		; save loop variables
00:000072F4 6720            	  2400: 	BEQ	.0001						; if LOPVAR is zero, that's all
00:000072F6 2F3A02A0        	  2401: 	MOVE.L	LOPPT,-(SP)	; else save all the others
00:000072FA 2F3A0298        	  2402: 	MOVE.L	LOPLN,-(SP)
00:000072FE 2F3A0288        	  2403: 	MOVE.L	LOPLMT,-(SP)
00:00007302 2F3A0288        	  2404: 	MOVE.L	LOPLMT+4,-(SP)
00:00007306 2F3A0288        	  2405: 	MOVE.L	LOPLMT+8,-(SP)
00:0000730A 2F3A0270        	  2406: 	MOVE.L	LOPINC,-(SP)
00:0000730E 2F3A0270        	  2407: 	MOVE.L	LOPINC+4,-(SP)
00:00007312 2F3A0270        	  2408: 	MOVE.L	LOPINC+8,-(SP)
                            	  2409: .0001
00:00007316 2F01            	  2410: 	MOVE.L	D1,-(SP)
00:00007318 4ED6            	  2411: 	JMP	(A6)		return
                            	  2412: 
                            	  2413: *******************************************************************
                            	  2414: *
                            	  2415: * *** PRTSTG *** QTSTG *** PRTNUM *** PRTLN ***
                            	  2416: *
                            	  2417: * 'PRTSTG' prints a string pointed to by A1. It stops printing
                            	  2418: * and returns to the caller when either a CR is printed or when
                            	  2419: * the next byte is the same as what was passed in D0 by the
                            	  2420: * caller.
                            	  2421: *
                            	  2422: * 'QTSTG' looks for an underline (back-arrow on some systems),
                            	  2423: * single-quote, or double-quote.  If none of these are found, returns
                            	  2424: * to the caller.  If underline, outputs a CR without a LF.  If single
                            	  2425: * or double quote, prints the quoted string and demands a matching
                            	  2426: * end quote.  After the printing, the next 2 bytes of the caller are
                            	  2427: * skipped over (usually a short branch instruction).
                            	  2428: *
                            	  2429: * 'PRTNUM' prints the 32 bit number in D1, leading blanks are added if
                            	  2430: * needed to pad the number of spaces to the number in D4.
                            	  2431: * However, if the number of digits is larger than the no. in
                            	  2432: * D4, all digits are printed anyway. Negative sign is also
                            	  2433: * printed and counted in, positive sign is not.
                            	  2434: *
                            	  2435: * 'PRTLN' prints the saved text line pointed to by A1
                            	  2436: * with line no. and all.
                            	  2437: *
                            	  2438: PRTSTG:
00:0000731A 1200            	  2439: 	MOVE.B	D0,D1		save the stop character
                            	  2440: PS1
00:0000731C 1019            	  2441: 	MOVE.B	(A1)+,D0	get a text character
00:0000731E B200            	  2442: 	CMP.B	D0,D1		same as stop character?
00:00007320 6712            	  2443: 	BEQ	PRTRET		if so, return
00:00007322 6100ED06        	  2444: 	BSR	GOOUT		display the char.
00:00007326 B03C000D        	  2445: 	CMP.B	#CR,D0		is it a C.R.?
00:0000732A 66F0            	  2446: 	BNE	PS1		no, go back for more
00:0000732C 103C000A        	  2447: 	MOVE.B	#LF,D0		yes, add a L.F.
00:00007330 6100ECF8        	  2448: 	BSR	GOOUT
                            	  2449: PRTRET
00:00007334 4E75            	  2450: 	RTS			then return
                            	  2451: 
                            	  2452: PRTSTR2a
00:00007336 1019            	  2453: 	move.b (a1)+,d0
00:00007338 6100ECF0        	  2454: 	bsr GOOUT
                            	  2455: PRTSTR2:
00:0000733C 51C9FFF8        	  2456: 	dbra d1,PRTSTR2a
00:00007340 4E75            	  2457: 	rts
                            	  2458: 	
                            	  2459: 	if 0
                            	  2460: QTSTG
                            	  2461: 	bsr	TSTC		*** QTSTG ***
                            	  2462: 	DC.B	'"',QT3-*
                            	  2463: 	MOVE.B	#'"',D0         it is a "
                            	  2464: QT1
                            	  2465: 	MOVE.L	A0,A1
                            	  2466: 	BSR	PRTSTG		print until another
                            	  2467: 	MOVE.L	A1,A0
                            	  2468: 	MOVE.L	(SP)+,A1	pop return address
                            	  2469: 	CMP.B	#LF,D0		was last one a CR?
                            	  2470: 	BEQ	RUNNXL		if so, run next line
                            	  2471: QT2
                            	  2472: 	ADDQ.L	#2,A1		skip 2 bytes on return
                            	  2473: 	JMP	(A1)		return
                            	  2474: QT3
                            	  2475: 	bsr	TSTC		is it a single quote?
                            	  2476: 	DC.B	'''',QT4-*
                            	  2477: 	MOVE.B	#'''',D0        if so, do same as above
                            	  2478: 	BRA	QT1
                            	  2479: QT4
                            	  2480: 	bsr	TSTC		is it an underline?
                            	  2481: 	DC.B	'_',QT5-*
                            	  2482: 	MOVE.B	#CR,D0		if so, output a CR without LF
                            	  2483: 	bsr	GOOUT
                            	  2484: 	MOVE.L	(SP)+,A1	pop return address
                            	  2485: 	BRA	QT2
                            	  2486: QT5
                            	  2487: 	RTS			none of the above
                            	  2488: 	endif
                            	  2489: 
                            	  2490: PRTNUM:
00:00007342 4E52FFD0        	  2491: 	link a2,#-48
00:00007346 217900040098002C	  2492: 	move.l _canary,44(a0)
00:0000734E 48D7020F        	  2493: 	movem.l d0/d1/d2/d3/a1,(sp)
00:00007352 F22F68000014    	  2494: 	fmove.x fp0,20(sp)
00:00007358 F22F68800020    	  2495: 	fmove.x fp1,32(sp)
00:0000735E F2000400        	  2496: 	fmove.x fp1,fp0					; fp0 = number to print
00:00007362 43F900040520    	  2497: 	lea _fpBuf,a1						; a1 = pointer to buffer to use
00:00007368 7027            	  2498: 	moveq #39,d0						; d0 = function #39 print float
00:0000736A 2204            	  2499: 	move.l d4,d1						; d1 = width
00:0000736C 2404            	  2500: 	move.l d4,d2						; d2 = precision max
00:0000736E 7665            	  2501: 	moveq #'e',d3
00:00007370 4E4F            	  2502: 	trap #15
00:00007372 4CD7020F        	  2503: 	movem.l (sp),d0/d1/d2/d3/a1
00:00007376 F22F48000014    	  2504: 	fmove.x 20(sp),fp0
00:0000737C F22F48800020    	  2505: 	fmove.x 32(sp),fp1
00:00007382 A2A80003002C    	  2506: 	cchk 44(a0)
00:00007388 4E5A            	  2507: 	unlk a2
00:0000738A 4E75            	  2508: 	rts
                            	  2509: 
                            	  2510: ; Debugging
                            	  2511: 	if 0
                            	  2512: PRTFP0:
                            	  2513: 	link a2,#-48
                            	  2514: 	move.l _canary,44(a0)
                            	  2515: 	movem.l d0/d1/d2/d3/a1,(sp)
                            	  2516: 	fmove.x fp0,20(sp)
                            	  2517: 	lea _fpBuf,a1						; a1 = pointer to buffer to use
                            	  2518: 	moveq #39,d0						; d0 = function #39 print float
                            	  2519: 	moveq #30,d1						; d1 = width
                            	  2520: 	moveq #25,d2						; d2 = precision max
                            	  2521: 	moveq #'e',d3
                            	  2522: 	trap #15
                            	  2523: 	movem.l (sp),d0/d1/d2/d3/a1
                            	  2524: 	fmove.x 20(sp),fp0
                            	  2525: 	cchk 44(a0)
                            	  2526: 	unlk a2
                            	  2527: 	rts
                            	  2528: 	endif
                            	  2529: 
                            	  2530: PRTLN:
00:0000738C 7200            	  2531: 	CLR.L	D1
00:0000738E 1219            	  2532: 	MOVE.B (A1)+,D1	get the binary line number
00:00007390 E149            	  2533: 	LSL	#8,D1
00:00007392 1219            	  2534: 	MOVE.B (A1)+,D1
00:00007394 F2015080        	  2535: 	FMOVE.W D1,FP1
00:00007398 7805            	  2536: 	MOVEQ	#5,D4			; display a 5 digit line no.
00:0000739A 61A6            	  2537: 	BSR	PRTNUM
00:0000739C 103C0020        	  2538: 	MOVE.B	#' ',D0         followed by a blank
00:000073A0 6100EC88        	  2539: 	BSR	GOOUT
00:000073A4 4240            	  2540: 	CLR	D0		stop char. is a zero
00:000073A6 6000FF72        	  2541: 	BRA	PRTSTG		display the rest of the line
                            	  2542: 
                            	  2543: 
                            	  2544: ; ===== Test text byte following the call to this subroutine. If it
                            	  2545: ; equals the byte pointed to by A0, return to the code following
                            	  2546: ; the call. If they are not equal, branch to the point
                            	  2547: ;	indicated by the offset byte following the text byte.
                            	  2548: 
                            	  2549: TSTC:
00:000073AA 6162            	  2550: 	BSR	IGNBLK				; ignore leading blanks
00:000073AC 225F            	  2551: 	MOVE.L (SP)+,A1		; get the return address
00:000073AE 1219            	  2552: 	MOVE.B (A1)+,D1		; get the byte to compare
00:000073B0 B210            	  2553: 	CMP.B	(A0),D1 		;	is it = to what A0 points to?
00:000073B2 6708            	  2554: 	BEQ	TC1						; if so
00:000073B4 7200            	  2555: 	CLR.L	D1					; If not, add the second
00:000073B6 1211            	  2556: 	MOVE.B (A1),D1 		; byte following the call to
00:000073B8 D3C1            	  2557: 	ADD.L	D1,A1				; the return address.
00:000073BA 4ED1            	  2558: 	JMP	(A1)					; jump to the routine
                            	  2559: TC1
00:000073BC 5288            	  2560: 	ADDQ.L #1,A0			; if equal, bump text pointer
00:000073BE 5289            	  2561: 	ADDQ.L #1,A1			; Skip the 2 bytes following
00:000073C0 4ED1            	  2562: 	JMP	(A1)					; the call and continue.
                            	  2563: 
                            	  2564: 
                            	  2565: ; ===== See if the text pointed to by A0 is a number. If so,
                            	  2566: ;	return the number in FP1 and the number of digits in D2,
                            	  2567: ;	else return zero in FP1 and D2.
                            	  2568: ; If text is not a number, then A0 is not updated, otherwise
                            	  2569: ; A0 is advanced past the number. Note A0 is always updated
                            	  2570: ; past leading spaces.
                            	  2571: 
                            	  2572: TSTNUM
00:000073C2 4E52FFE0        	  2573: 	link a2,#-32
00:000073C6 2F7900040098001C	  2574: 	move.l _canary,28(sp)
00:000073CE 48D70202        	  2575: 	movem.l d1/a1,(sp)
00:000073D2 F22F68000010    	  2576: 	fmove.x fp0,16(sp)
00:000073D8 7029            	  2577: 	moveq #41,d0						; function #41, get float
00:000073DA 7201            	  2578: 	moveq #1,d1							; d1 = input stride
00:000073DC 2248            	  2579: 	move.l a0,a1						; a1 = pointer to input buffer
00:000073DE 4E4F            	  2580: 	trap #15								; call BIOS get float function
00:000073E0 2049            	  2581: 	move.l a1,a0						; set text pointer
00:000073E2 7001            	  2582: 	moveq #DT_NUMERIC,d0		; default data type = number
00:000073E4 F2000080        	  2583: 	fmove.x fp0,fp1					; return expected in fp1
00:000073E8 4A41            	  2584: 	tst.w d1								; check if a number (digits > 0?)
00:000073EA 6706            	  2585: 	beq .0002
00:000073EC 7400            	  2586: 	clr.l d2								; d2.l = 0
00:000073EE 3401            	  2587: 	move.w d1,d2						; d2 = number of digits
00:000073F0 6008            	  2588: 	bra .0001
                            	  2589: .0002											; not a number, return with orignal text pointer
00:000073F2 7000            	  2590: 	moveq #0,d0							; data type = not a number
00:000073F4 7400            	  2591: 	moveq #0,d2							; d2 = 0
00:000073F6 F2024080        	  2592: 	fmove.l d2,fp1					; return a zero
                            	  2593: .0001
00:000073FA 4CD70202        	  2594: 	movem.l (sp),d1/a1
00:000073FE F22F48000010    	  2595: 	fmove.x 16(sp),fp0
00:00007404 A2AF0003001C    	  2596: 	cchk 28(sp)
00:0000740A 4E5A            	  2597: 	unlk a2
00:0000740C 4E75            	  2598: 	rts
                            	  2599: 		
                            	  2600: ; ===== Skip over blanks in the text pointed to by A0.
                            	  2601: 
                            	  2602: IGNBLK
00:0000740E 0C180020        	  2603: 	CMP.B	#' ',(A0)+		; see if it's a space
00:00007412 67FA            	  2604: 	BEQ	IGNBLK					; if so, swallow it
00:00007414 5388            	  2605: 	SUBQ.L #1,A0				; decrement the text pointer
00:00007416 4E75            	  2606: 	RTS
                            	  2607: 
                            	  2608: *
                            	  2609: * ===== Convert the line of text in the input buffer to upper
                            	  2610: *	case (except for stuff between quotes).
                            	  2611: *
00:00007418 41FA01A6        	  2612: TOUPBUF LEA	BUFFER,A0	set up text pointer
00:0000741C 4201            	  2613: 	CLR.B	D1		clear quote flag
                            	  2614: TOUPB1	
00:0000741E 1018            	  2615: 	MOVE.B	(A0)+,D0	get the next text char.
00:00007420 B03C000D        	  2616: 	CMP.B	#CR,D0		is it end of line?
00:00007424 6718            	  2617: 	BEQ	TOUPBRT 	if so, return
00:00007426 B03C0022        	  2618: 	CMP.B	#'"',D0         a double quote?
00:0000742A 6714            	  2619: 	BEQ	DOQUO
00:0000742C B03C0027        	  2620: 	CMP.B	#'''',D0        or a single quote?
00:00007430 670E            	  2621: 	BEQ	DOQUO
00:00007432 4A01            	  2622: 	TST.B	D1		inside quotes?
00:00007434 66E8            	  2623: 	BNE	TOUPB1		if so, do the next one
00:00007436 6118            	  2624: 	BSR	TOUPPER 	convert to upper case
00:00007438 1100            	  2625: 	MOVE.B	D0,-(A0)	store it
00:0000743A 5288            	  2626: 	ADDQ.L	#1,A0
00:0000743C 60E0            	  2627: 	BRA	TOUPB1		and go back for more
                            	  2628: TOUPBRT
00:0000743E 4E75            	  2629: 	RTS
                            	  2630: 
00:00007440 4A01            	  2631: DOQUO	TST.B	D1		are we inside quotes?
00:00007442 6604            	  2632: 	BNE	DOQUO1
00:00007444 1200            	  2633: 	MOVE.B	D0,D1		if not, toggle inside-quotes flag
00:00007446 60D6            	  2634: 	BRA	TOUPB1
00:00007448 B200            	  2635: DOQUO1	CMP.B	D0,D1		make sure we're ending proper quote
00:0000744A 66D2            	  2636: 	BNE	TOUPB1		if not, ignore it
00:0000744C 4201            	  2637: 	CLR.B	D1		else clear quote flag
00:0000744E 60CE            	  2638: 	BRA	TOUPB1
                            	  2639: 
                            	  2640: *
                            	  2641: * ===== Convert the character in D0 to upper case
                            	  2642: *
00:00007450 B03C0061        	  2643: TOUPPER CMP.B	#'a',D0         is it < 'a'?
00:00007454 650A            	  2644: 	BCS	TOUPRET
00:00007456 B03C007A        	  2645: 	CMP.B	#'z',D0         or > 'z'?
00:0000745A 6204            	  2646: 	BHI	TOUPRET
00:0000745C 903C0020        	  2647: 	SUB.B	#32,D0		if not, make it upper case
00:00007460 4E75            	  2648: TOUPRET RTS
                            	  2649: 
                            	  2650: *
                            	  2651: * 'CHKIO' checks the input. If there's no input, it will return
                            	  2652: * to the caller with the Z flag set. If there is input, the Z
                            	  2653: * flag is cleared and the input byte is in D0. However, if a
                            	  2654: * control-C is read, 'CHKIO' will warm-start BASIC and will not
                            	  2655: * return to the caller.
                            	  2656: *
                            	  2657: CHKIO
00:00007462 6100EBCA        	  2658: 	bsr	GOIN		get input if possible
00:00007466 670A            	  2659: 	BEQ	CHKRET		if Zero, no input
00:00007468 B03C0003        	  2660: 	CMP.B	#CTRLC,D0	is it control-C?
00:0000746C 6604            	  2661: 	BNE	CHKRET		if not
00:0000746E 6000EC40        	  2662: 	BRA	WSTART		if so, do a warm start
                            	  2663: CHKRET
00:00007472 4E75            	  2664: 	RTS
                            	  2665: 
                            	  2666: *
                            	  2667: * ===== Display a CR-LF sequence
                            	  2668: *
                            	  2669: ;CRLF	LEA	CLMSG,A6
                            	  2670: 
                            	  2671: 
                            	  2672: ; ===== Display a zero-ended string pointed to by register A6
                            	  2673: 
                            	  2674: PRMESG
00:00007474 101E            	  2675: 	MOVE.B (A6)+,D0		; get the char.
00:00007476 6706            	  2676: 	BEQ	PRMRET				; if it's zero, we're done
00:00007478 6100EBB0        	  2677: 	BSR	GOOUT					; else display it
00:0000747C 60F6            	  2678: 	BRA	PRMESG
                            	  2679: PRMRET
00:0000747E 4E75            	  2680: 	RTS
                            	  2681: 
                            	  2682: ******************************************************
                            	  2683: * The following routines are the only ones that need *
                            	  2684: * to be changed for a different I/O environment.     *
                            	  2685: ******************************************************
                            	  2686: 
                            	  2687: ; ===== Clear screen and home cursor
                            	  2688: 
                            	  2689: CLS:
00:00007480 700B            	  2690: 	moveq #11,d0			; set cursor position
00:00007482 323CFF00        	  2691: 	move.w #$FF00,d1	; home cursor and clear screen
00:00007486 4E4F            	  2692: 	trap #15
00:00007488 6000F0E0        	  2693: 	bra FINISH
                            	  2694: 
                            	  2695: ; ===== Output character to the console (Port 1) from register D0
                            	  2696: ;(Preserves all registers.)
                            	  2697: 
                            	  2698: OUTC:
00:0000748C 48E7C000        	  2699: 	movem.l d0/d1,-(sp)
00:00007490 2200            	  2700: 	move.l d0,d1
00:00007492 7006            	  2701: 	moveq #6,d0
00:00007494 4E4F            	  2702: 	trap #15
00:00007496 4CDF0003        	  2703: 	movem.l (sp)+,d0/d1
00:0000749A 4E75            	  2704: 	rts
                            	  2705: 
                            	  2706: * ===== Input a character from the console into register D0 (or
                            	  2707: *	return Zero status if there's no character available).
                            	  2708: *
                            	  2709: INC
00:0000749C 2F0E            	  2710: 	move.l	a6,-(a7)
00:0000749E 2C7A00C0        	  2711: 	move.l	INPPTR,a6
00:000074A2 4E96            	  2712: 	jsr			(a6)
00:000074A4 2C5F            	  2713: 	move.l	(a7)+,a6
00:000074A6 4E75            	  2714: 	rts
                            	  2715: 
                            	  2716: INC1
00:000074A8 2F01            	  2717: 	move.l	d1,-(a7)
00:000074AA 7005            	  2718: 	moveq.l	#5,d0			* function 5 GetKey
00:000074AC 4E4F            	  2719: 	trap		#15
00:000074AE 2001            	  2720: 	move.l	d1,d0
00:000074B0 221F            	  2721: 	move.l	(a7)+,d1
00:000074B2 0C0000FF        	  2722: 	cmpi.b	#-1,d0
00:000074B6 6602            	  2723: 	bne			.0001
00:000074B8 4200            	  2724: 	clr.b		d0
                            	  2725: .0001:
00:000074BA 4E75            	  2726: 	rts
                            	  2727: 
                            	  2728: *INC	BTST	#0,$10040	is character ready?
                            	  2729: *	BEQ	INCRET		if not, return Zero status
                            	  2730: *	MOVE.B	$10042,D0	else get the character
                            	  2731: *	AND.B	#$7F,D0 	zero out the high bit
                            	  2732: *INCRET	RTS
                            	  2733: 
                            	  2734: * ===== Output character to the host (Port 2) from register D0
                            	  2735: *	(Preserves all registers.)
                            	  2736: *
                            	  2737: AUXOUT:
00:000074BC 13FC0002000400A8	  2738: 	move.b #2,OutputDevice
00:000074C4 61C6            	  2739: 	bsr OUTC
00:000074C6 13FC0001000400A8	  2740: 	move.b #1,OutputDevice
00:000074CE 4E75            	  2741: 	rts
                            	  2742: 
                            	  2743: *AUXOUT	BTST	#1,$10041	is port 2 ready for a character?
                            	  2744: *	BEQ	AUXOUT		if not, wait for it
                            	  2745: *	MOVE.B	D0,$10043	out it goes.
                            	  2746: *	RTS
                            	  2747: 
                            	  2748: *
                            	  2749: * ===== Input a character from the host into register D0 (or
                            	  2750: *	return Zero status if there's no character available).
                            	  2751: *
                            	  2752: AUXIN:
00:000074D0 2F01            	  2753: 	move.l	d1,-(a7)
00:000074D2 7024            	  2754: 	moveq		#36,d0				; serial get char from buffer
00:000074D4 4E4F            	  2755: 	trap		#15
00:000074D6 2001            	  2756: 	move.l	d1,d0
00:000074D8 221F            	  2757: 	move.l	(a7)+,d1
00:000074DA 0C40FFFF        	  2758: 	cmpi.w	#-1,d0
00:000074DE 670A            	  2759: 	beq			.0001
00:000074E0 0200007F        	  2760: 	andi.b	#$7F,d0				; clear high bit
00:000074E4 4880            	  2761: 	ext.w		d0						; return character in d0
00:000074E6 48C0            	  2762: 	ext.l		d0
00:000074E8 4E75            	  2763: 	rts
                            	  2764: .0001:
00:000074EA 7000            	  2765: 	moveq		#0,d0					; return zf=1 if no character available
00:000074EC 4E75            	  2766: 	rts
                            	  2767: 
                            	  2768: ;AUXIN
                            	  2769: *AUXIN	BTST	#0,$10041	is character ready?
                            	  2770: *	BEQ	AXIRET		if not, return Zero status
                            	  2771: *	MOVE.B	$10043,D0	else get the character
                            	  2772: *	AND.B	#$7F,D0 	zero out the high bit
00:000074EE 4E75            	  2773: AXIRET	RTS
                            	  2774: 
                            	  2775: ; ===== Return to the resident monitor, operating system, etc.
                            	  2776: ;
                            	  2777: BYEBYE	
00:000074F0 23FC000000080004	  2778: 	move.l #8,_fpTextIncr
00:000074F8 0094
00:000074FA 60000788        	  2779: 	bra		Monitor
                            	  2780: ;	MOVE.B	#228,D7 	return to Tutor
                            	  2781: ;	TRAP	#14
                            	  2782: 
00:000074FE 0D              	  2783: INITMSG DC.B	CR,LF,'MC68000 Tiny Float BASIC, v1.0',CR,LF,LF,0
00:000074FF 0A
00:00007500 4D43363830303020
00:00007508 54696E7920466C6F
00:00007510 6174204241534943
00:00007518 2C2076312E30
00:0000751E 0D
00:0000751F 0A
00:00007520 0A
00:00007521 00
00:00007522 0D              	  2784: OKMSG	DC.B	CR,LF,'OK',CR,LF,0
00:00007523 0A
00:00007524 4F4B
00:00007526 0D
00:00007527 0A
00:00007528 00
00:00007529 486F773F        	  2785: HOWMSG	DC.B	'How?',CR,LF,0
00:0000752D 0D
00:0000752E 0A
00:0000752F 00
00:00007530 576861743F      	  2786: WHTMSG	DC.B	'What?',CR,LF,0
00:00007535 0D
00:00007536 0A
00:00007537 00
00:00007538 547970653F      	  2787: TYPMSG	DC.B	'Type?',CR,LF,0
00:0000753D 0D
00:0000753E 0A
00:0000753F 00
00:00007540 4E6F20737472696E	  2788: NOSTRING	DC.B 'No string space',CR,LF,0
00:00007548 67207370616365
00:0000754F 0D
00:00007550 0A
00:00007551 00
00:00007552 536F7272792E    	  2789: SRYMSG	DC.B	'Sorry.'
00:00007558 0D              	  2790: CLMSG	DC.B	CR,LF,0
00:00007559 0A
00:0000755A 00
00:0000755B 00              	  2791: 	DC.B	0	<- for aligning on a word boundary
                            	  2792: LSTROM	EQU	*		end of possible ROM area
                            	  2793: *
                            	  2794: * Internal variables follow:
                            	  2795: *
                            	  2796: 	align 2
00:0000755C 00006024        	  2797: RANPNT	DC.L	START		random number pointer
00:00007560 00000000        	  2798: INPPTR	DS.L	1		input pointer
00:00007564 00000000        	  2799: OUTPTR	DS.L	1 	output pointer
00:00007568 00000000        	  2800: CURRNT	DS.L	1		; Current line pointer
00:0000756C 00000000        	  2801: STKFP		DS.L	1		; saves frame pointer
00:00007570 00000000        	  2802: STKGOS	DS.L	1		Saves stack pointer in 'GOSUB'
00:00007574 00000000        	  2803: STKINP	DS.L	1		Saves stack pointer during 'INPUT'
00:00007578 00000000        	  2804: LOPVAR	DS.L	1		'FOR' loop save area
00:0000757C 00000000        	  2805: LOPINC	DS.L	3		increment
00:00007580 *
00:00007588 00000000        	  2806: LOPLMT	DS.L	3		limit
00:0000758C *
00:00007594 00000000        	  2807: LOPLN	DS.L	1		line number
00:00007598 00000000        	  2808: LOPPT	DS.L	1		text pointer
00:0000759C 00000000        	  2809: IRQROUT	DS.L	1
00:000075A0 00000000        	  2810: STRSTK	DS.L	1		; string pointer stack area, 8 entries
00:000075A4 00000000        	  2811: StrSp		DS.L	1		; string stack stack pointer
00:000075A8 00000000        	  2812: StrArea	DS.L	1		; pointer to string area
00:000075AC 00000000        	  2813: LastStr	DS.L	1		; pointer to last used string in area
00:000075B0 00000000        	  2814: TXTUNF	DS.L	1		points to unfilled text area
00:000075B4 00000000        	  2815: VARBGN	DS.L	1		points to variable area
00:000075B8 00000000        	  2816: STKLMT	DS.L	1		holds lower limit for stack growth
00:000075BC 00000000        	  2817: DIRFLG	DS.L	1		; indicates 1=DIRECT mode
00:000075C0 00              	  2818: BUFFER	DS.B	BUFLEN		Keyboard input buffer
00:000075C1 *
                            	  2819: TXT	EQU	*		Beginning of program area
                            	  2820: ;	END
                            	  2821: 

Source: "boot.x68"
                            	   944: 
                            	   945: ; -----------------------------------------------------------------------------
                            	   946: ; -----------------------------------------------------------------------------
                            	   947: 
                            	   948: set_text_mode:
00:00007610 7040            	   949: 	moveq #TEXTCOL,d0
00:00007612 13C0FD080000    	   950: 	move.b d0,TEXTREG					; number of columns
00:00007618 7020            	   951: 	moveq #TEXTROW,d0
00:0000761A 13C0FD080001    	   952: 	move.b d0,TEXTREG+1				; number of rows
00:00007620 7000            	   953: 	moveq #0,d0
00:00007622 13C0FD080003    	   954: 	move.b d0,TEXTREG+3				; text mode
00:00007628 7011            	   955: 	moveq #17,d0
00:0000762A 13C0FD080008    	   956: 	move.b d0,TEXTREG+8				; max row scan
00:00007630 700B            	   957: 	moveq #11,d0
00:00007632 13C0FD08000A    	   958: 	move.b d0,TEXTREG+10			; max pix
00:00007638 4E75            	   959: 	rts
                            	   960: 	
                            	   961: set_graphics_mode:
00:0000763A 7080            	   962: 	moveq #TEXTCOL*2,d0
00:0000763C 13C0FD080000    	   963: 	move.b d0,TEXTREG					; number of columns
00:00007642 7040            	   964: 	moveq #TEXTROW*2,d0
00:00007644 13C0FD080001    	   965: 	move.b d0,TEXTREG+1				; number of rows
00:0000764A 7001            	   966: 	moveq #1,d0
00:0000764C 13C0FD080003    	   967: 	move.b d0,TEXTREG+3				; graphics mode
00:00007652 7007            	   968: 	moveq #7,d0
00:00007654 13C0FD080008    	   969: 	move.b d0,TEXTREG+8				; max row scan
00:0000765A 7007            	   970: 	moveq #7,d0
00:0000765C 13C0FD08000A    	   971: 	move.b d0,TEXTREG+10			; max pix
00:00007662 4E75            	   972: 	rts
                            	   973: 
                            	   974: ; -----------------------------------------------------------------------------
                            	   975: ; -----------------------------------------------------------------------------
                            	   976: 
                            	   977: get_screen_address:
00:00007664 48E7E300        	   978: 	movem.l d0/d1/d2/d6/d7,-(a7)
00:00007668 7E02            	   979: 	moveq #2,d7
00:0000766A 7C10            	   980: 	moveq #DEV_GETBUF1,d6
00:0000766C 4E40            	   981: 	trap #0
00:0000766E 2041            	   982: 	move.l d1,a0
00:00007670 4CDF00C7        	   983: 	movem.l (a7)+,d0/d1/d2/d6/d7
00:00007674 4E75            	   984: 	rts
                            	   985: 	
                            	   986: 
                            	   987: CRLF:
00:00007676 48E7C000        	   988: 	movem.l d0/d1,-(a7)
00:0000767A 123C000D        	   989: 	move.b #13,d1
00:0000767E 7006            	   990: 	moveq #6,d0						; output character function
00:00007680 4E4F            	   991: 	trap #15
00:00007682 123C000A        	   992: 	move.b #10,d1
00:00007686 7006            	   993: 	moveq #6,d0						; output character function
00:00007688 4E4F            	   994: 	trap #15
00:0000768A 4CDF0003        	   995: 	movem.l (a7)+,d0/d1
00:0000768E 4E75            	   996: 	rts
                            	   997: 
                            	   998: ;------------------------------------------------------------------------------
                            	   999: ; Display a string on standard output.
                            	  1000: ;------------------------------------------------------------------------------
                            	  1001: 
                            	  1002: DisplayString:
00:00007690 48E7C040        	  1003: 	movem.l	d0/d1/a1,-(a7)
                            	  1004: dspj1:
00:00007694 7200            	  1005: 	clr.l d1							; clear upper bits of d1
00:00007696 1219            	  1006: 	move.b (a1)+,d1				; move string char into d1
00:00007698 6706            	  1007: 	beq.s dsret						; is it end of string ?
00:0000769A 7006            	  1008: 	moveq #6,d0						; output character function
00:0000769C 4E4F            	  1009: 	trap #15
00:0000769E 60F4            	  1010: 	bra.s	dspj1						; go back for next character
                            	  1011: dsret:
00:000076A0 4CDF0203        	  1012: 	movem.l	(a7)+,d0/d1/a1
00:000076A4 4E75            	  1013: 	rts
                            	  1014: 
                            	  1015: ;------------------------------------------------------------------------------
                            	  1016: ; Display a string on the screen followed by carriage return / linefeed.
                            	  1017: ;------------------------------------------------------------------------------
                            	  1018: 
                            	  1019: DisplayStringCRLF:
00:000076A6 61E8            	  1020: 	bsr		DisplayString
00:000076A8 60CC            	  1021: 	bra		CRLF
                            	  1022: 
                            	  1023: ;------------------------------------------------------------------------------
                            	  1024: ; Display a string on the screen limited to 255 chars max.
                            	  1025: ;------------------------------------------------------------------------------
                            	  1026: 
                            	  1027: DisplayStringLimited:
00:000076AA 48E7E040        	  1028: 	movem.l	d0/d1/d2/a1,-(a7)
00:000076AE 3401            	  1029: 	move.w	d1,d2					; d2 = max count
00:000076B0 024200FF        	  1030: 	andi.w	#$00FF,d2			; limit to 255 chars
00:000076B4 600A            	  1031: 	bra.s		.0003					; enter loop at bottom
                            	  1032: .0001:
00:000076B6 7200            	  1033: 	clr.l d1							; clear upper bits of d1
00:000076B8 1219            	  1034: 	move.b (a1)+,d1				; move string char into d1
00:000076BA 6708            	  1035: 	beq.s .0002						; is it end of string ?
00:000076BC 7006            	  1036: 	moveq #6,d0						; output character function
00:000076BE 4E4F            	  1037: 	trap #15
                            	  1038: .0003:
00:000076C0 51CAFFF4        	  1039: 	dbra		d2,.0001			; go back for next character
                            	  1040: .0002:
00:000076C4 4CDF0207        	  1041: 	movem.l	(a7)+,d0/d1/d2/a1
00:000076C8 4E75            	  1042: 	rts
                            	  1043: 
                            	  1044: DisplayStringLimitedCRLF:
00:000076CA 61DE            	  1045: 	bsr		DisplayStringLimited
00:000076CC 60A8            	  1046: 	bra		CRLF
                            	  1047: 	
                            	  1048: 
                            	  1049: ;==============================================================================
                            	  1050: ; TRAP #15 handler
                            	  1051: ;
                            	  1052: ; Parameters:
                            	  1053: ;		d0.w = function number to perform
                            	  1054: ;==============================================================================
                            	  1055: 
                            	  1056: TRAP15:
00:000076CE 48E78080        	  1057: 	movem.l	d0/a0,-(a7)
00:000076D2 41FA0010        	  1058: 	lea T15DispatchTable,a0
00:000076D6 E580            	  1059: 	asl.l #2,d0
00:000076D8 20700000        	  1060: 	move.l (a0,d0.w),a0
00:000076DC 4E90            	  1061: 	jsr (a0)
00:000076DE 4CDF0101        	  1062: 	movem.l (a7)+,d0/a0
00:000076E2 4E73            	  1063: 	rte
                            	  1064: 
                            	  1065: 		align	2
                            	  1066: T15DispatchTable:
00:000076E4 000076CA        	  1067: 	dc.l	DisplayStringLimitedCRLF
00:000076E8 000076AA        	  1068: 	dc.l	DisplayStringLimited
00:000076EC 00007B48        	  1069: 	dc.l	StubRout
00:000076F0 00007B48        	  1070: 	dc.l	StubRout
00:000076F4 00007B48        	  1071: 	dc.l	StubRout
00:000076F8 00000874        	  1072: 	dc.l	GetKey
00:000076FC 0000963A        	  1073: 	dc.l	OutputChar
00:00007700 00000868        	  1074: 	dc.l	CheckForKey
00:00007704 00007884        	  1075: 	dc.l	GetTick
00:00007708 00007B48        	  1076: 	dc.l	StubRout
                            	  1077: 	; 10
00:0000770C 00007B48        	  1078: 	dc.l	StubRout
00:00007710 00007B10        	  1079: 	dc.l	Cursor1
00:00007714 00000860        	  1080: 	dc.l	SetKeyboardEcho
00:00007718 000076A6        	  1081: 	dc.l	DisplayStringCRLF
00:0000771C 00007690        	  1082: 	dc.l	DisplayString
00:00007720 00007B48        	  1083: 	dc.l	StubRout
00:00007724 00007B48        	  1084: 	dc.l	StubRout
00:00007728 00007B48        	  1085: 	dc.l	StubRout
00:0000772C 00007B48        	  1086: 	dc.l	StubRout
00:00007730 00000868        	  1087: 	dc.l	CheckForKey
                            	  1088: 	; 20
00:00007734 00007B48        	  1089: 	dc.l	StubRout
00:00007738 00007B48        	  1090: 	dc.l	StubRout
00:0000773C 00007B48        	  1091: 	dc.l	StubRout
00:00007740 00007B48        	  1092: 	dc.l	StubRout
00:00007744 00007B48        	  1093: 	dc.l	StubRout
00:00007748 00007B48        	  1094: 	dc.l	StubRout
00:0000774C 00007B48        	  1095: 	dc.l	StubRout
00:00007750 00007B48        	  1096: 	dc.l	StubRout
00:00007754 00007B48        	  1097: 	dc.l	StubRout
00:00007758 00007B48        	  1098: 	dc.l	StubRout
                            	  1099: 	; 30
00:0000775C 00007B48        	  1100: 	dc.l	StubRout
00:00007760 00007B48        	  1101: 	dc.l	StubRout
00:00007764 00007874        	  1102: 	dc.l	SimHardware	;rotate_iofocus
00:00007768 00001716        	  1103: 	dc.l	SerialPeekCharDirect
00:0000776C 00001730        	  1104: 	dc.l	SerialPutChar
00:00007770 000016DA        	  1105: 	dc.l	SerialPeekChar
00:00007774 00001662        	  1106: 	dc.l	SerialGetChar
00:00007778 00002458        	  1107: 	dc.l	T15LockSemaphore
00:0000777C 0000245E        	  1108: 	dc.l	T15UnlockSemaphore
00:00007780 0000959A        	  1109: 	dc.l	prtflt
                            	  1110: 	; 40
00:00007784 0000239E        	  1111: 	dc.l  _GetRand
00:00007788 00002464        	  1112: 	dc.l	T15GetFloat
00:0000778C 00002472        	  1113: 	dc.l	T15Abort
00:00007790 000095E0        	  1114: 	dc.l	T15FloatToString
00:00007794 00007B48        	  1115: 	dc.l	StubRout
00:00007798 00007B48        	  1116: 	dc.l	StubRout
00:0000779C 00007B48        	  1117: 	dc.l	StubRout
00:000077A0 00007B48        	  1118: 	dc.l	StubRout
00:000077A4 00007B48        	  1119: 	dc.l	StubRout
00:000077A8 00007B48        	  1120: 	dc.l	StubRout
                            	  1121: 	; 50
00:000077AC 00007B48        	  1122: 	dc.l	StubRout
00:000077B0 00007B48        	  1123: 	dc.l	StubRout
00:000077B4 00007B48        	  1124: 	dc.l	StubRout
00:000077B8 00007B48        	  1125: 	dc.l	StubRout
00:000077BC 00007B48        	  1126: 	dc.l	StubRout
00:000077C0 00007B48        	  1127: 	dc.l	StubRout
00:000077C4 00007B48        	  1128: 	dc.l	StubRout
00:000077C8 00007B48        	  1129: 	dc.l	StubRout
00:000077CC 00007B48        	  1130: 	dc.l	StubRout
00:000077D0 00007B48        	  1131: 	dc.l	StubRout
                            	  1132: 	; 60
00:000077D4 00007B48        	  1133: 	dc.l	StubRout
00:000077D8 00007B48        	  1134: 	dc.l	StubRout
00:000077DC 00007B48        	  1135: 	dc.l	StubRout
00:000077E0 00007B48        	  1136: 	dc.l	StubRout
00:000077E4 00007B48        	  1137: 	dc.l	StubRout
00:000077E8 00007B48        	  1138: 	dc.l	StubRout
00:000077EC 00007B48        	  1139: 	dc.l	StubRout
00:000077F0 00007B48        	  1140: 	dc.l	StubRout
00:000077F4 00007B48        	  1141: 	dc.l	StubRout
00:000077F8 00007B48        	  1142: 	dc.l	StubRout
                            	  1143: 	; 70
00:000077FC 00007B48        	  1144: 	dc.l	StubRout
00:00007800 00007B48        	  1145: 	dc.l	StubRout
00:00007804 00007B48        	  1146: 	dc.l	StubRout
00:00007808 00007B48        	  1147: 	dc.l	StubRout
00:0000780C 00007B48        	  1148: 	dc.l	StubRout
00:00007810 00007B48        	  1149: 	dc.l	StubRout
00:00007814 00007B48        	  1150: 	dc.l	StubRout
00:00007818 00007B48        	  1151: 	dc.l	StubRout
00:0000781C 00007B48        	  1152: 	dc.l	StubRout
00:00007820 00007B48        	  1153: 	dc.l	StubRout
                            	  1154: 	; 80
00:00007824 000078AE        	  1155: 	dc.l	SetPenColor
00:00007828 00007B48        	  1156: 	dc.l	StubRout
00:0000782C 00007B48        	  1157: 	dc.l	StubRout
00:00007830 00007B48        	  1158: 	dc.l	StubRout
00:00007834 00007B48        	  1159: 	dc.l	StubRout
00:00007838 00007A30        	  1160: 	dc.l	DrawToXY
00:0000783C 00007A22        	  1161: 	dc.l	MoveToXY
00:00007840 00007B48        	  1162: 	dc.l	StubRout
00:00007844 00007B48        	  1163: 	dc.l	StubRout
00:00007848 00007B48        	  1164: 	dc.l	StubRout
                            	  1165: 	; 90
00:0000784C 00007B48        	  1166: 	dc.l	StubRout
00:00007850 00007B48        	  1167: 	dc.l	StubRout
00:00007854 0000788C        	  1168: 	dc.l	SetDrawMode
00:00007858 00007B48        	  1169: 	dc.l	StubRout
00:0000785C 000078BA        	  1170: 	dc.l	GRBufferToScreen
00:00007860 00007B48        	  1171: 	dc.l	StubRout
00:00007864 00007B48        	  1172: 	dc.l	StubRout
00:00007868 00007B48        	  1173: 	dc.l	StubRout
00:0000786C 00007B48        	  1174: 	dc.l	StubRout
00:00007870 00007B48        	  1175: 	dc.l	StubRout
                            	  1176: 
                            	  1177: ;------------------------------------------------------------------------------
                            	  1178: 
                            	  1179: SimHardware:
00:00007874 0C410003        	  1180: 	cmpi.w #3,d1
00:00007878 6608            	  1181: 	bne.s .0001
00:0000787A 223C000408B8    	  1182: 	move.l #sys_switches,d1
00:00007880 4E75            	  1183: 	rts
                            	  1184: .0001:
00:00007882 4E75            	  1185: 	rts
                            	  1186: 
                            	  1187: ;------------------------------------------------------------------------------
                            	  1188: ;
                            	  1189: GetTick:
00:00007884 22390004009C    	  1190: 	move.l tickcnt,d1
00:0000788A 4E75            	  1191: 	rts
                            	  1192: 
                            	  1193: ;------------------------------------------------------------------------------
                            	  1194: ;
                            	  1195: SetDrawMode:
00:0000788C 0C41000A        	  1196: 	cmpi.w #10,d1
00:00007890 660A            	  1197: 	bne.s .0001
00:00007892 13FC000500040D80	  1198: 	move.b #5,framebuf_dcb+DCB_OPCODE			; 'OR' operation
00:0000789A 4E75            	  1199: 	rts
                            	  1200: .0001:
00:0000789C 0C410011        	  1201: 	cmpi.w #17,d1
00:000078A0 660A            	  1202: 	bne.s .0002
00:000078A2 33FC0001000408AC	  1203: 	move.w #1,gr_double_buffer
00:000078AA 4E75            	  1204: 	rts
                            	  1205: .0002:
00:000078AC 4E75            	  1206: 	rts
                            	  1207: 	
                            	  1208: SetPenColor:
00:000078AE 6100A676        	  1209: 	bsr gfxaccel_set_color
00:000078B2 33C100040D7C    	  1210: 	move.w d1,framebuf_dcb+DCB_FGCOLOR
00:000078B8 4E75            	  1211: 	rts
                            	  1212: 
                            	  1213: ;------------------------------------------------------------------------------
                            	  1214: ; Page flip between two buffers.
                            	  1215: ;------------------------------------------------------------------------------
                            	  1216: 
                            	  1217: GRBufferToScreen:
00:000078BA 7E06            	  1218: 	move.l #6,d7						; framebuffer device
00:000078BC 7C0D            	  1219: 	move.l #DEV_SWAPBUF,d6	; swap buffers
00:000078BE 4E40            	  1220: 	trap #0
00:000078C0 4E75            	  1221: 	rts
                            	  1222: 
00:000078C2 48E740C0        	  1223: 	movem.l d1/a0/a1,-(a7)
00:000078C6 1239FD200003    	  1224: 	move.b FRAMEBUF+3,d1
00:000078CC 0A010001        	  1225: 	eor.b #1,d1
00:000078D0 13C1FD200003    	  1226: 	move.b d1,FRAMEBUF+3					; page flip
00:000078D6 2279000408B0    	  1227: 	move.l gr_bitmap_buffer,a1
00:000078DC 2079000408A4    	  1228: 	move.l gr_bitmap_screen,a0
00:000078E2 23C8000408B0    	  1229: 	move.l a0,gr_bitmap_buffer
00:000078E8 23C9000408A4    	  1230: 	move.l a1,gr_bitmap_screen
00:000078EE 4CDF0302        	  1231: 	movem.l (a7)+,d1/a0/a1
00:000078F2 4E75            	  1232: 	rts
                            	  1233: 
                            	  1234: ; The following copies the buffer, why? Not needed if page flipping.
                            	  1235: ;	movem.l d0/a0/a1,-(a7)
                            	  1236: ;	move.l gr_bitmap_buffer,a1
                            	  1237: ;	move.l gr_bitmap_screen,a0
                            	  1238: ;	move.w gr_width,d0
                            	  1239: ;	mulu gr_height,d0
                            	  1240: ;	lsr.l #4,d0							; moving 16 pixels per iteration
                            	  1241: ;	move.l #0,$BFFFFFF8			; set burst length zero
                            	  1242: ;	bra.s .loop
                            	  1243: ;.loop2:
                            	  1244: ;	swap d0
                            	  1245: ;.loop:
                            	  1246: ;	move.l a1,$BFFFFFF0			; set source address
                            	  1247: ;	tst.l $BFFFFFFC					; do a read op, no value needed
                            	  1248: ;	move.l a0,$BFFFFFF4			; set destination address
                            	  1249: ;	move.l d0,$BFFFFFFC			; do a write operation (any value)
                            	  1250: ;	dbra d0,.loop
                            	  1251: ;	swap d0									; might go over 32/64 kB
                            	  1252: ;	dbra d0,.loop2
                            	  1253: ;	movem.l (a7)+,d0/a0/a1
                            	  1254: ;	rts
                            	  1255: 
                            	  1256: 
                            	  1257: TestBitmap:
                            	  1258: ;	move.w #$0700,pen_color		; dark blue
00:000078F4 33FC070000040D78	  1259: 	move.w #$0700,framebuf_dcb+DCB_BKCOLOR
00:000078FC 7E06            	  1260: 	move.l #6,d7
00:000078FE 7C0C            	  1261: 	move.l #DEV_CLEAR,d6
00:00007900 4E40            	  1262: 	trap #0
                            	  1263: ;	bsr clear_bitmap_screen4
00:00007902 705E            	  1264: 	moveq #94,d0							; page flip (display blank screen)
00:00007904 4E4F            	  1265: 	trap #15
00:00007906 33FC007C00040890	  1266: 	move.w #$007c,pen_color		; red pen
00:0000790E 7E06            	  1267: 	moveq #6,d7
00:00007910 7C07            	  1268: 	moveq #DEV_SET_OUTPOS,d6
00:00007912 7200            	  1269: 	moveq #0,d1
00:00007914 7401            	  1270: 	moveq #1,d2
00:00007916 4E40            	  1271: 	trap #0
00:00007918 7C14            	  1272: 	moveq #DEV_GET_DIMEN,d6
00:0000791A 4E40            	  1273: 	trap #0
00:0000791C 5381            	  1274: 	subq.l #1,d1
00:0000791E 2601            	  1275: 	move.l d1,d3
00:00007920 7801            	  1276: 	moveq #1,d4
00:00007922 6100018A        	  1277: 	bsr DrawHorizTo
00:00007926 42B900040894    	  1278: 	clr.l gr_x
00:0000792C 42B900040898    	  1279: 	clr.l gr_y
00:00007932 7600            	  1280: 	move.l #0,d3
00:00007934 2839000408A0    	  1281: 	move.l gr_height,d4
00:0000793A 5384            	  1282: 	subq.l #1,d4
00:0000793C 610001A2        	  1283: 	bsr DrawVertTo
00:00007940 33FCE00100040890	  1284: 	move.w #$E001,pen_color		; green pen
00:00007948 23FC000000020004	  1285: 	move.l #2,gr_x
00:00007950 0894
00:00007952 42B900040898    	  1286: 	clr.l gr_y
00:00007958 7602            	  1287: 	move.l #2,d3
00:0000795A 2839000408A0    	  1288: 	move.l gr_height,d4
00:00007960 5384            	  1289: 	subq.l #1,d4
00:00007962 6100017C        	  1290: 	bsr DrawVertTo
00:00007966 42B900040894    	  1291: 	clr.l gr_x
00:0000796C 42B900040898    	  1292: 	clr.l gr_y
00:00007972 26390004089C    	  1293: 	move.l gr_width,d3
00:00007978 5383            	  1294: 	subq.l #1,d3
00:0000797A 23C300040894    	  1295: 	move.l d3,gr_x
00:00007980 2839000408A0    	  1296: 	move.l gr_height,d4
00:00007986 5384            	  1297: 	subq.l #1,d4
00:00007988 610000A6        	  1298: 	bsr DrawToXY
00:0000798C 705E            	  1299: 	moveq #94,d0							; page flip again
00:0000798E 4E4F            	  1300: 	trap #15
00:00007990 600002F2        	  1301: 	bra Monitor
                            	  1302: 
                            	  1303: Diagonal1:
00:00007994 42B900040894    	  1304: 	clr.l gr_x
00:0000799A 42B900040898    	  1305: 	clr.l gr_y
00:000079A0 26390004089C    	  1306: 	move.l gr_width,d3
00:000079A6 5383            	  1307: 	subq.l #1,d3
00:000079A8 2839000408A0    	  1308: 	move.l gr_height,d4
00:000079AE 5384            	  1309: 	subq.l #1,d4
00:000079B0 617E            	  1310: 	bsr DrawToXY
00:000079B2 4E75            	  1311: 	rts
                            	  1312: 
                            	  1313: Diagonal2:
00:000079B4 26390004089C    	  1314: 	move.l gr_width,d3
00:000079BA 5383            	  1315: 	subq.l #1,d3
00:000079BC 23C300040894    	  1316: 	move.l d3,gr_x
00:000079C2 42B900040898    	  1317: 	clr.l gr_y
00:000079C8 2639000408A0    	  1318: 	move.l gr_height,d3
00:000079CE 5383            	  1319: 	subq.l #1,d3
00:000079D0 7800            	  1320: 	moveq #0,d4
00:000079D2 33FCE00100040890	  1321: 	move.w #$E001,pen_color
00:000079DA 6154            	  1322: 	bsr DrawToXY
00:000079DC 4E75            	  1323: 	rts
                            	  1324: 
                            	  1325: Vertical1:
00:000079DE 42B900040894    	  1326: 	clr.l gr_x
00:000079E4 42B900040898    	  1327: 	clr.l gr_y
00:000079EA 7600            	  1328: 	move.l #0,d3
00:000079EC 2839000408A0    	  1329: 	move.l gr_height,d4
00:000079F2 5384            	  1330: 	subq.l #1,d4
00:000079F4 610000EA        	  1331: 	bsr DrawVertTo
00:000079F8 4E75            	  1332: 	rts
                            	  1333: 
                            	  1334: Vertical2:
00:000079FA 33FCE00100040890	  1335: 	move.w #$E001,pen_color		; green pen
00:00007A02 23FC000000020004	  1336: 	move.l #2,gr_x
00:00007A0A 0894
00:00007A0C 42B900040898    	  1337: 	clr.l gr_y
00:00007A12 7602            	  1338: 	move.l #2,d3
00:00007A14 2839000408A0    	  1339: 	move.l gr_height,d4
00:00007A1A 5384            	  1340: 	subq.l #1,d4
00:00007A1C 610000C2        	  1341: 	bsr DrawVertTo
00:00007A20 4E75            	  1342: 	rts
                            	  1343: 
                            	  1344: ;------------------------------------------------------------------------------
                            	  1345: ; Plot on bitmap screen using current pen color.
                            	  1346: ;
                            	  1347: ;	Parameters:
                            	  1348: ;		d1 = x co-ordinate
                            	  1349: ;		d2 = y co-ordinate
                            	  1350: ;------------------------------------------------------------------------------
                            	  1351: 	
                            	  1352: ;parameter OPBLACK = 4'd0;
                            	  1353: ;parameter OPCOPY = 4'd1;
                            	  1354: ;parameter OPINV = 4'd2;
                            	  1355: ;parameter OPAND = 4'd4;
                            	  1356: ;parameter OPOR = 4'd5;
                            	  1357: ;parameter OPXOR = 4'd6;
                            	  1358: ;parameter OPANDN = 4'd7;
                            	  1359: ;parameter OPNAND = 4'd8;
                            	  1360: ;parameter OPNOR = 4'd9;
                            	  1361: ;parameter OPXNOR = 4'd10;
                            	  1362: ;parameter OPORN = 4'd11;
                            	  1363: ;parameter OPWHITE = 4'd15;
                            	  1364: 
                            	  1365: ;------------------------------------------------------------------------------
                            	  1366: ; Set graphics cursor position.
                            	  1367: ;------------------------------------------------------------------------------
                            	  1368: 
                            	  1369: MoveToXY:
00:00007A22 23C300040894    	  1370: 	move.l d3,gr_x
00:00007A28 23C400040898    	  1371: 	move.l d4,gr_y
00:00007A2E 4E75            	  1372: 	rts
                            	  1373: 
                            	  1374: ;------------------------------------------------------------------------------
                            	  1375: ; Draw a line from the current graphics position to x1,y1.
                            	  1376: ;
                            	  1377: ; Register Usage:
                            	  1378: ;		d1 = x0
                            	  1379: ;		d2 = y0
                            	  1380: ;		d3 = x1
                            	  1381: ;		d4 = y1
                            	  1382: ;		d5 = dx
                            	  1383: ;		d6 = dy
                            	  1384: ;		d7 = sx
                            	  1385: ;		d0 = sy
                            	  1386: ;		a0 = err
                            	  1387: ;		a1 = 2*err
                            	  1388: ;------------------------------------------------------------------------------
                            	  1389: 
                            	  1390: DrawToXY:
00:00007A30 48E7E7C0        	  1391: 	movem.l d0/d1/d2/d5/d6/d7/a0/a1,-(a7)
00:00007A34 223900040894    	  1392: 	move.l gr_x,d1
00:00007A3A 243900040898    	  1393: 	move.l gr_y,d2
00:00007A40 2A03            	  1394: 	move.l d3,d5
00:00007A42 2C04            	  1395: 	move.l d4,d6
00:00007A44 9A81            	  1396: 	sub.l d1,d5			; d5 = x1-x0
00:00007A46 6608            	  1397: 	bne.s .notVert
00:00007A48 4CDF03E7        	  1398: 	movem.l (a7)+,d0/d1/d2/d5/d6/d7/a0/a1
00:00007A4C 60000092        	  1399: 	bra DrawVertTo
                            	  1400: .notVert:
00:00007A50 6A02            	  1401: 	bpl.s .0001
00:00007A52 4485            	  1402: 	neg.l d5				
                            	  1403: .0001:						; d5 = dx = abs(x1-x0)
00:00007A54 9C82            	  1404: 	sub.l d2,d6			; d6 = y1-y0
00:00007A56 6606            	  1405: 	bne.s .notHoriz
00:00007A58 4CDF03E7        	  1406: 	movem.l (a7)+,d0/d1/d2/d5/d6/d7/a0/a1
00:00007A5C 6050            	  1407: 	bra DrawHorizTo
                            	  1408: .notHoriz:
00:00007A5E 6B02            	  1409: 	bmi.s .0002
00:00007A60 4486            	  1410: 	neg.l d6
                            	  1411: .0002:						; d6 = dy = -abs(y1-y0)
00:00007A62 7E01            	  1412: 	move.l #1,d7		; d7 = sx (x0 < x1 ? 1 : -1)
00:00007A64 B681            	  1413: 	cmp.l d1,d3
00:00007A66 6202            	  1414: 	bhi.s .0004
00:00007A68 4487            	  1415: 	neg.l d7
                            	  1416: .0004:
00:00007A6A 7001            	  1417: 	move.l #1,d0		; d0 = sy (y0 < y1) ? 1 : -1)
00:00007A6C B882            	  1418: 	cmp.l d2,d4
00:00007A6E 6202            	  1419: 	bhi.s .0006
00:00007A70 4480            	  1420: 	neg.l d0
                            	  1421: .0006:
00:00007A72 2045            	  1422: 	move.l d5,a0		; a0 = error = dx + dy
00:00007A74 D1C6            	  1423: 	adda.l d6,a0
                            	  1424: .loop:
00:00007A76 61008E36        	  1425: 	bsr CheckForCtrlC
00:00007A7A 6100A158        	  1426: 	bsr plot				; plot(x0,y0)
00:00007A7E 2248            	  1427: 	move.l a0,a1
00:00007A80 D3C9            	  1428: 	adda.l a1,a1		; a1 = error *2
00:00007A82 BC89            	  1429: 	cmp.l a1,d6			; e2 >= dy?
00:00007A84 6E08            	  1430: 	bgt.s .0008
00:00007A86 B681            	  1431: 	cmp.l d1,d3			; x0==x1?
00:00007A88 6712            	  1432: 	beq.s .brkloop
00:00007A8A D1C6            	  1433: 	adda.l d6,a0		; err = err + dy
00:00007A8C D287            	  1434: 	add.l d7,d1			; x0 = x0 + sx
                            	  1435: .0008:
00:00007A8E BA89            	  1436: 	cmp.l a1,d5			; err2 <= dx?
00:00007A90 6D08            	  1437: 	blt.s .0009
00:00007A92 B882            	  1438: 	cmp.l d2,d4			; y0==y1?
00:00007A94 6706            	  1439: 	beq.s .brkloop
00:00007A96 D1C5            	  1440: 	adda.l d5,a0		; err = err + dx
00:00007A98 D480            	  1441: 	add.l d0,d2			; y0 = y0 + sy
                            	  1442: .0009:
00:00007A9A 60DA            	  1443: 	bra.s .loop
                            	  1444: .brkloop:
00:00007A9C 23C300040894    	  1445: 	move.l d3,gr_x
00:00007AA2 23C400040898    	  1446: 	move.l d4,gr_y
00:00007AA8 4CDF03E7        	  1447: 	movem.l (a7)+,d0/d1/d2/d5/d6/d7/a0/a1
00:00007AAC 4E75            	  1448: 	rts
                            	  1449: 
                            	  1450: ; Parameters:
                            	  1451: ;		d3 = x1
                            	  1452: ;		d4 = y1
                            	  1453: 
                            	  1454: DrawHorizTo:
00:00007AAE 48E76400        	  1455: 	movem.l d1/d2/d5,-(a7)
00:00007AB2 7E06            	  1456: 	moveq #6,d7
00:00007AB4 7C17            	  1457: 	moveq #DEV_GET_OUTPOS,d6
00:00007AB6 4E40            	  1458: 	trap #0
00:00007AB8 7A01            	  1459: 	move.l #1,d5			; assume increment
00:00007ABA B681            	  1460: 	cmp.l d1,d3
00:00007ABC 6202            	  1461: 	bhi.s .0001
00:00007ABE 4485            	  1462: 	neg.l d5					; switch to decrement
                            	  1463: .0001:
00:00007AC0 7E06            	  1464: 	moveq #6,d7
00:00007AC2 7C12            	  1465: 	moveq #DEV_WRITEAT,d6
00:00007AC4 4E40            	  1466: 	trap #0
00:00007AC6 B681            	  1467: 	cmp.l d1,d3
00:00007AC8 670A            	  1468: 	beq.s .0002
00:00007ACA D285            	  1469: 	add.l d5,d1
00:00007ACC 7E06            	  1470: 	moveq #6,d7
00:00007ACE 7C07            	  1471: 	moveq #DEV_SET_OUTPOS,d6
00:00007AD0 4E40            	  1472: 	trap #0
00:00007AD2 60EC            	  1473: 	bra.s .0001
                            	  1474: .0002:
00:00007AD4 7E06            	  1475: 	moveq #6,d7
00:00007AD6 7C07            	  1476: 	moveq #DEV_SET_OUTPOS,d6	; update output position
00:00007AD8 4E40            	  1477: 	trap #0
00:00007ADA 4CDF0026        	  1478: 	movem.l (a7)+,d1/d2/d5
00:00007ADE 4E75            	  1479: 	rts
                            	  1480: 	
                            	  1481: 	
                            	  1482: ; Parameters:
                            	  1483: ;		d3 = x1
                            	  1484: ;		d4 = y1
                            	  1485: 
                            	  1486: DrawVertTo:
00:00007AE0 48E76400        	  1487: 	movem.l d1/d2/d5,-(a7)
00:00007AE4 223900040894    	  1488: 	move.l gr_x,d1
00:00007AEA 243900040898    	  1489: 	move.l gr_y,d2
00:00007AF0 7A01            	  1490: 	move.l #1,d5			; assume increment
00:00007AF2 B882            	  1491: 	cmp.l d2,d4
00:00007AF4 6202            	  1492: 	bhi.s .0001
00:00007AF6 4485            	  1493: 	neg.l d5					; switch to decrement
                            	  1494: .0001:
00:00007AF8 6100A0DA        	  1495: 	bsr plot
00:00007AFC B882            	  1496: 	cmp.l d2,d4
00:00007AFE 6704            	  1497: 	beq.s .0002
00:00007B00 D485            	  1498: 	add.l d5,d2
00:00007B02 60F4            	  1499: 	bra.s .0001
                            	  1500: .0002:
00:00007B04 23C200040898    	  1501: 	move.l d2,gr_y
00:00007B0A 4CDF0026        	  1502: 	movem.l (a7)+,d1/d2/d5
00:00007B0E 4E75            	  1503: 	rts
                            	  1504: 	
                            	  1505: 	
                            	  1506: ;plotLine(x0, y0, x1, y1)
                            	  1507: ;    dx = abs(x1 - x0)
                            	  1508: ;    sx = x0 < x1 ? 1 : -1
                            	  1509: ;    dy = -abs(y1 - y0)
                            	  1510: ;    sy = y0 < y1 ? 1 : -1
                            	  1511: ;    error = dx + dy
                            	  1512: ;    
                            	  1513: ;    while true
                            	  1514: ;        plot(x0, y0)
                            	  1515: ;        e2 = 2 * error
                            	  1516: ;        if e2 >= dy
                            	  1517: ;            if x0 == x1 break
                            	  1518: ;            error = error + dy
                            	  1519: ;            x0 = x0 + sx
                            	  1520: ;        end if
                            	  1521: ;        if e2 <= dx
                            	  1522: ;            if y0 == y1 break
                            	  1523: ;            error = error + dx
                            	  1524: ;            y0 = y0 + sy
                            	  1525: ;        end if
                            	  1526: ;    end while
                            	  1527:     
                            	  1528: ;------------------------------------------------------------------------------
                            	  1529: ; Cursor positioning / Clear screen
                            	  1530: ; - out of range settings are ignored
                            	  1531: ;
                            	  1532: ; Parameters:
                            	  1533: ;		d1.w cursor position, bits 0 to 7 are row, bits 8 to 15 are column.
                            	  1534: ;	Returns:
                            	  1535: ;		none
                            	  1536: ;------------------------------------------------------------------------------
                            	  1537: 
                            	  1538: Cursor1:
00:00007B10 48E7F300        	  1539: 	movem.l d0/d1/d2/d3/d6/d7,-(a7)
00:00007B14 0C41FF00        	  1540: 	cmpi.w #$FF00,d1
00:00007B18 6616            	  1541: 	bne.s .0002
00:00007B1A 7E02            	  1542: 	moveq #2,d7
00:00007B1C 7C0C            	  1543: 	moveq #DEV_CLEAR,d6	; clear screen
00:00007B1E 4E40            	  1544: 	trap #0
00:00007B20 7C07            	  1545: 	moveq #DEV_SET_OUTPOS,d6
00:00007B22 7200            	  1546: 	moveq #0,d1
00:00007B24 7400            	  1547: 	moveq #0,d2
00:00007B26 7600            	  1548: 	moveq #0,d3
00:00007B28 4E40            	  1549: 	trap #0
00:00007B2A 4CDF00CF        	  1550: 	movem.l (a7)+,d0/d1/d2/d3/d6/d7
00:00007B2E 4E75            	  1551: 	rts
                            	  1552: .0002:
00:00007B30 7E02            	  1553: 	moveq #2,d7
00:00007B32 7C07            	  1554: 	moveq #DEV_SET_OUTPOS,d6
00:00007B34 7400            	  1555: 	clr.l d2
00:00007B36 1401            	  1556: 	move.b d1,d2		; d2 = row (y pos)
00:00007B38 E049            	  1557: 	lsr.w #8,d1			; d1 = col (x pos)
00:00007B3A 4881            	  1558: 	ext.w d1
00:00007B3C 48C1            	  1559: 	ext.l d1
00:00007B3E 7600            	  1560: 	moveq #0,d3
00:00007B40 4E40            	  1561: 	trap #0
00:00007B42 4CDF00CF        	  1562: 	movem.l (a7)+,d0/d1/d2/d3/d6/d7
00:00007B46 4E75            	  1563: 	rts
                            	  1564: 
                            	  1565: ;------------------------------------------------------------------------------
                            	  1566: ; Stub routine for unimplemented functionality.
                            	  1567: ;------------------------------------------------------------------------------
                            	  1568: 
                            	  1569: StubRout:
00:00007B48 4E75            	  1570: 	rts
                            	  1571: 
                            	  1572: ;------------------------------------------------------------------------------
                            	  1573: ; Select a specific IO focus.
                            	  1574: ;------------------------------------------------------------------------------
                            	  1575: 
                            	  1576: select_iofocus:
00:00007B4A 0C010002        	  1577: 	cmpi.b	#2,d1
00:00007B4E 650A            	  1578: 	blo.s		.0001
00:00007B50 0C010005        	  1579: 	cmpi.b	#NCORES+1,d1
00:00007B54 6204            	  1580: 	bhi.s		.0001
00:00007B56 2001            	  1581: 	move.l	d1,d0
00:00007B58 6014            	  1582: 	bra.s		select_focus1
                            	  1583: .0001:
00:00007B5A 4E75            	  1584: 	rts
                            	  1585: 
                            	  1586: ;------------------------------------------------------------------------------
                            	  1587: ; Rotate the IO focus, done when ALT-Tab is pressed.
                            	  1588: ;
                            	  1589: ; Modifies:
                            	  1590: ;		d0, IOFocus BIOS variable
                            	  1591: ;		updates the text screen pointer
                            	  1592: ;------------------------------------------------------------------------------
                            	  1593: 
                            	  1594: rotate_iofocus:
00:00007B5C 103900100000    	  1595: 	move.b IOFocus,d0					; d0 = focus, we can trash d0
00:00007B62 5200            	  1596: 	add.b	#1,d0								; increment the focus
00:00007B64 B03C0005        	  1597: 	cmp.b	#NCORES+1,d0				; limit to 2 to 9
00:00007B68 6304            	  1598: 	bls.s	.0001
00:00007B6A 103C0002        	  1599: 	move.b #2,d0
                            	  1600: .0001:
                            	  1601: select_focus1:
00:00007B6E 13C000100000    	  1602: 	move.b	d0,IOFocus				; set IO focus
                            	  1603: 	; reset keyboard processor to focus core
                            	  1604: ;	move.l #$3C060500,d0			; core=??,level sensitive,enabled,irq6,inta
                            	  1605: ;	or.b IOFocus,d0
                            	  1606: ;	move.l d0,PLIC+$80+4*30		; set register
                            	  1607: 	; Adjust text screen pointer
00:00007B74 5500            	  1608: 	subi.b #2,d0							; screen is 0 to 7, focus is 2 to 9
00:00007B76 4880            	  1609: 	ext.w	d0									; make into word value
00:00007B78 C0FC0800        	  1610: 	mulu #2048,d0							; * 2048	cells per screen
00:00007B7C E158            	  1611: 	rol.w	#8,d0								; swap byte order
00:00007B7E 4840            	  1612: 	swap d0										; get bits 16-31
00:00007B80 E158            	  1613: 	rol.w	#8,d0								; swap byte order
00:00007B82 23C0FD080028    	  1614: 	move.l d0,TEXTREG+$28			; update screen address in text controller
00:00007B88 60009938        	  1615: 	bra	SyncCursor						; set cursor position
                            	  1616: 
                            	  1617: ;==============================================================================
                            	  1618: ; PLIC - platform level interrupt controller
                            	  1619: ;
                            	  1620: ; Register layout:
                            	  1621: ;   bits 0 to 7  = cause code to issue (vector number)
                            	  1622: ;   bits 8 to 11 = irq level to issue
                            	  1623: ;   bit 16 = irq enable
                            	  1624: ;   bit 17 = edge sensitivity
                            	  1625: ;   bit 18 = 0=vpa, 1=inta
                            	  1626: ;		bit 24 to 29 target core
                            	  1627: ;
                            	  1628: ; Note byte order must be reversed for PLIC.
                            	  1629: ;==============================================================================
                            	  1630: 
                            	  1631: init_plic:
00:00007B8C 41F9FD090000    	  1632: 	lea	PLIC,a0							; a0 points to PLIC
00:00007B92 43E800F4        	  1633: 	lea	$80+4*29(a0),a1			; point to timer registers (29)
00:00007B96 22BC0006033F    	  1634: 	move.l #$0006033F,(a1)	; initialize, core=63,edge sensitive,enabled,irq6,vpa
00:00007B9C 5889            	  1635: 	lea	4(a1),a1						; point to keyboard registers (30)
00:00007B9E 22BC3C060502    	  1636: 	move.l #$3C060502,(a1)	; core=2,level sensitive,enabled,irq6,inta
00:00007BA4 5889            	  1637: 	lea	4(a1),a1						; point to nmi button register (31)
00:00007BA6 22BC00070302    	  1638: 	move.l #$00070302,(a1)	; initialize, core=2,edge sensitive,enabled,irq7,vpa
00:00007BAC 43E800C0        	  1639: 	lea	$80+4*16(a0),a1			; a1 points to ACIA register
00:00007BB0 22BC3D030502    	  1640: 	move.l #$3D030502,(a1)	; core=2,level sensitive,enabled,irq3,inta	
00:00007BB6 43E80090        	  1641: 	lea	$80+4*4(a0),a1			; a1 points to io_bitmap irq
00:00007BBA 22BC3B060702    	  1642: 	move.l #$3B060702,(a1)	; core=2,edge sensitive,enabled,irq6,inta	
00:00007BC0 4E75            	  1643: 	rts
                            	  1644: 
                            	  1645: 
                            	  1646: ;==============================================================================
                            	  1647: ;==============================================================================
                            	  1648: ; Monitor
                            	  1649: ;==============================================================================
                            	  1650: ;==============================================================================
                            	  1651: 
                            	  1652: cmdString:
00:00007BC2 BF              	  1653: 	dc.b	'?'+$80						; ? display help
00:00007BC3 41              	  1654: 	dc.b	'A','S'+$80				; AS = asteroids
00:00007BC4 D3
00:00007BC5 CC              	  1655: 	dc.b	'L'+$80						; L load S19 file
00:00007BC6 46              	  1656: 	dc.b	'F','B'+$80				; FB fill with byte
00:00007BC7 C2
00:00007BC8 46              	  1657: 	dc.b	'F','W'+$80				; FW fill with wyde
00:00007BC9 D7
00:00007BCA 46              	  1658: 	dc.b	'F','L'+$80				; FL fill with long wyde
00:00007BCB CC
00:00007BCC 464D54          	  1659: 	dc.b	'FMT','K'+$80			; FMTK run Femtiki OS
00:00007BCF CB
00:00007BD0 42              	  1660: 	dc.b	'B','A'+$80				; BA start Tiny Basic
00:00007BD1 C1
00:00007BD2 42              	  1661: 	dc.b	'B','R'+$80				; BR breakpoint
00:00007BD3 D2
00:00007BD4 44              	  1662: 	dc.b	'D','I'+$80				; DI disassemble
00:00007BD5 C9
00:00007BD6 44              	  1663: 	dc.b	'D','R'+$80				; DR dump registers
00:00007BD7 D2
00:00007BD8 C4              	  1664: 	dc.b	'D'+$80						; D dump memory
00:00007BD9 CA              	  1665: 	dc.b	'J'+$80						; J jump to code
00:00007BDA C5              	  1666: 	dc.b	'E'+$80						; : edit memory
00:00007BDB 434C            	  1667: 	dc.b	"CL",'S'+$80			; CLS clear screen
00:00007BDD D3
00:00007BDE 434F52          	  1668: 	dc.b	"COR",'E'+$80			; CORE <n> switch to core
00:00007BE1 C5
00:00007BE2 5446            	  1669: 	dc.b	"TF",'P'+$80			; TFP test fp
00:00007BE4 D0
00:00007BE5 5447            	  1670: 	dc.b  "TG",'F'+$80			; TGF test get float
00:00007BE7 C6
00:00007BE8 545241          	  1671: 	dc.b  "TRA",'M'+$80			; TRAM test RAM
00:00007BEB CD
00:00007BEC 54              	  1672: 	dc.b	'T','R'+$80				; TR test serial receive
00:00007BED D2
00:00007BEE D4              	  1673: 	dc.b	'T'+$80						; T test CPU
00:00007BEF D3              	  1674: 	dc.b	'S'+$80						; S send serial
00:00007BF0 52455345        	  1675: 	dc.b	"RESE",'T'+$80		; RESET <n>
00:00007BF4 D4
00:00007BF5 434C4F43        	  1676: 	dc.b	"CLOC",'K'+$80		; CLOCK <n>
00:00007BF9 CB
00:00007BFA D2              	  1677: 	dc.b	'R'+$80						; R receive serial
00:00007BFB D6              	  1678: 	dc.b	'V'+$80
00:00007BFC 47              	  1679: 	dc.b	'G','R'+$80				; graphics demo
00:00007BFD D2
00:00007BFE 00              	  1680: 	dc.b	0,0
00:00007BFF 00
                            	  1681: 
                            	  1682: 	align	2
                            	  1683: cmdTable:
00:00007C00 00007F0A        	  1684: 	dc.l	cmdHelp
00:00007C04 00007D8C        	  1685: 	dc.l	cmdAsteroids
00:00007C08 00008FB2        	  1686: 	dc.l	cmdLoadS19
00:00007C0C 000081C6        	  1687: 	dc.l	cmdFillB
00:00007C10 0000821A        	  1688: 	dc.l	cmdFillW
00:00007C14 0000826E        	  1689: 	dc.l	cmdFillL
00:00007C18 00007DD8        	  1690: 	dc.l	cmdFMTK
00:00007C1C 00007D94        	  1691: 	dc.l	cmdTinyBasic
00:00007C20 00007D68        	  1692: 	dc.l	cmdBreakpoint
00:00007C24 000086B4        	  1693: 	dc.l	cmdDisassemble
00:00007C28 000087CE        	  1694: 	dc.l	cmdDumpRegs
00:00007C2C 00008704        	  1695: 	dc.l	cmdDumpMemory
00:00007C30 0000838E        	  1696: 	dc.l	cmdJump
00:00007C34 0000831A        	  1697: 	dc.l	cmdEditMemory
00:00007C38 00007DA8        	  1698: 	dc.l	cmdClearScreen
00:00007C3C 00007DB4        	  1699: 	dc.l	cmdCore
00:00007C40 00007DE0        	  1700: 	dc.l  cmdTestFP
00:00007C44 00007E6C        	  1701: 	dc.l	cmdTestGF
00:00007C48 00008EEA        	  1702: 	dc.l  cmdTestRAM
00:00007C4C 00008878        	  1703: 	dc.l	cmdTestSerialReceive
00:00007C50 00007D98        	  1704: 	dc.l	cmdTestCPU
00:00007C54 00008162        	  1705: 	dc.l	cmdSendSerial
00:00007C58 00007EB8        	  1706: 	dc.l	cmdReset
00:00007C5C 00007E9A        	  1707: 	dc.l	cmdClock
00:00007C60 00008192        	  1708: 	dc.l	cmdReceiveSerial	
00:00007C64 00007D26        	  1709: 	dc.l	cmdVideoMode
00:00007C68 0000839E        	  1710: 	dc.l	cmdGrDemo
00:00007C6C 00007C84        	  1711: 	dc.l	cmdMonitor
                            	  1712: 
                            	  1713: ; Get a word from screen memory and swap byte order
                            	  1714: 
                            	  1715: FromScreen:
00:00007C70 2210            	  1716: 	move.l (a0),d1
00:00007C72 61001560        	  1717: 	bsr	rbo
                            	  1718: 	if (SCREEN_FORMAT==1)
00:00007C76 5888            	  1719: 		lea	4(a0),a0	; increment screen pointer
                            	  1720: 	else
                            	  1721: 		lea	8(a0),a0	; increment screen pointer
                            	  1722: 	endif
00:00007C78 4E75            	  1723: 	rts
                            	  1724: 
                            	  1725: StartMon:
00:00007C7A 427900040202    	  1726: 	clr.w	NumSetBreakpoints
00:00007C80 61001884        	  1727: 	bsr	ClearBreakpointList
                            	  1728: cmdMonitor:
                            	  1729: Monitor:
                            	  1730: 	; Reset the stack pointer on each entry into the monitor
00:00007C84 2E7C00047FFC    	  1731: 	move.l #$47FFC,sp		; reset core's stack
00:00007C8A 487AFFF8        	  1732: 	pea Monitor					; Cause any RTS to go here
00:00007C8E 46FC2200        	  1733: 	move.w #$2200,sr		; enable level 2 and higher interrupts
00:00007C92 4E7A0FE0        	  1734: 	movec	coreno,d0
00:00007C96 4840            	  1735: 	swap d0
00:00007C98 7201            	  1736: 	moveq	#1,d1
00:00007C9A 6100A7A0        	  1737: 	bsr	UnlockSemaphore
00:00007C9E 42390004000C    	  1738: 	clr.b KeybdEcho			; turn off keyboard echo
                            	  1739: PromptLn:
00:00007CA4 6100F9D0        	  1740: 	bsr	CRLF
00:00007CA8 123C0024        	  1741: 	move.b #'$',d1
00:00007CAC 6100198C        	  1742: 	bsr OutputChar
                            	  1743: 
                            	  1744: ; Get characters until a CR is keyed
                            	  1745: ;
                            	  1746: Prompt3:
00:00007CB0 61008BC2        	  1747: 	bsr	GetKey
00:00007CB4 0C0100FF        	  1748: 	cmpi.b #-1,d1
00:00007CB8 67F6            	  1749: 	beq.s	Prompt3
00:00007CBA 0C01000D        	  1750: 	cmpi.b #CR,d1
00:00007CBE 6706            	  1751: 	beq.s	Prompt1
00:00007CC0 61001978        	  1752: 	bsr	OutputChar
00:00007CC4 60EA            	  1753: 	bra.s	Prompt3
                            	  1754: 
                            	  1755: ; Process the screen line that the CR was keyed on
                            	  1756: 
                            	  1757: Prompt1:
00:00007CC6 7E02            	  1758: 	moveq #2,d7
00:00007CC8 7C17            	  1759: 	moveq #DEV_GET_OUTPOS,d6
00:00007CCA 4E40            	  1760: 	trap #0
                            	  1761: ;	clr.b	CursorCol				; go back to the start of the line
00:00007CCC 7C07            	  1762: 	moveq #DEV_SET_OUTPOS,d6
00:00007CCE 7200            	  1763: 	moveq #0,d1						; go back to the start of the line
00:00007CD0 4E40            	  1764: 	trap #0
00:00007CD2 7C18            	  1765: 	moveq #DEV_GET_OUTPTR,d6
00:00007CD4 4E40            	  1766: 	trap #0
00:00007CD6 2041            	  1767: 	move.l d1,a0					; a0 = pointer to buffer
                            	  1768: ;	bsr	CalcScreenLoc			; a0 = screen memory location
                            	  1769: .0001:
00:00007CD8 6196            	  1770: 	bsr	FromScreen				; grab character off screen
00:00007CDA 0C010024        	  1771: 	cmpi.b #'$',d1				; skip over '$' prompt character
00:00007CDE 67F8            	  1772: 	beq.s	.0001
                            	  1773: 
                            	  1774: ; Dispatch based on command string
                            	  1775: 
                            	  1776: cmdDispatch:
00:00007CE0 45FAFEE0        	  1777: 	lea	cmdString,a2
00:00007CE4 7800            	  1778: 	clr.l	d4							; command counter
                            	  1779: 	if (SCREEN_FORMAT==1)
00:00007CE6 5988            	  1780: 		lea	-4(a0),a0				; backup a character
                            	  1781: 	else
                            	  1782: 		lea	-8(a0),a0				; backup a character
                            	  1783: 	endif
00:00007CE8 2648            	  1784: 	move.l	a0,a3					; a3 = start of command on screen
                            	  1785: .checkNextCmd:
00:00007CEA 6184            	  1786: 	bsr	FromScreen				; d1 = char from input screen
00:00007CEC 1A1A            	  1787: 	move.b (a2)+,d5
00:00007CEE BB01            	  1788: 	eor.b	d5,d1						; does it match with command string?
00:00007CF0 67F8            	  1789: 	beq.s	.checkNextCmd		; If it does, keep matching for longest match
00:00007CF2 0C010080        	  1790: 	cmpi.b #$80,d1				; didn't match, was it the end of the command?
00:00007CF6 6724            	  1791: 	beq.s	.foundCmd
00:00007CF8 4A2AFFFF        	  1792: 	tst.b	-1(a2)					; was end of table hit?
00:00007CFC 6712            	  1793: 	beq.s	.endOfTable
00:00007CFE 5844            	  1794: 	addi.w #4,d4					; increment command counter
00:00007D00 204B            	  1795: 	move.l a3,a0					; reset input pointer
00:00007D02 4A2AFFFF        	  1796: 	tst.b	-1(a2)					; were we at the end of the command?
00:00007D06 6BE2            	  1797: 	bmi.s	.checkNextCmd		; if were at end continue, otherwise scan for end of cmd
                            	  1798: .scanToEndOfCmd
00:00007D08 4A1A            	  1799: 	tst.b	(a2)+						; scan to end of command
00:00007D0A 6704            	  1800: 	beq.s	.endOfTable
00:00007D0C 6AFA            	  1801: 	bpl.s	.scanToEndOfCmd
00:00007D0E 6BDA            	  1802: 	bmi.s	.checkNextCmd
                            	  1803: .endOfTable
00:00007D10 43FA038A        	  1804: 	lea	msgUnknownCmd,a1
00:00007D14 6100F990        	  1805: 	bsr	DisplayStringCRLF
00:00007D18 6000FF6A        	  1806: 	bra	Monitor
                            	  1807: .foundCmd:
00:00007D1C 43FAFEE2        	  1808: 	lea	cmdTable,a1				; a1 = pointer to command address table
00:00007D20 22714000        	  1809: 	move.l (a1,d4.w),a1		; fetch command routine address from table
00:00007D24 4ED1            	  1810: 	jmp	(a1)							; go execute command
                            	  1811: 
                            	  1812: cmdVideoMode:
00:00007D26 61000592        	  1813: 	bsr ignBlanks
00:00007D2A 61000B6E        	  1814: 	bsr GetHexNumber
00:00007D2E 4A01            	  1815: 	cmpi.b #0,d1
00:00007D30 660E            	  1816: 	bne.s .0001
00:00007D32 6100F8DC        	  1817: 	bsr set_text_mode
00:00007D36 7E02            	  1818: 	move.l #2,d7
00:00007D38 7C0C            	  1819: 	move.l #DEV_CLEAR,d6
00:00007D3A 4E40            	  1820: 	trap #0
00:00007D3C 6000FF46        	  1821: 	bra Monitor
                            	  1822: .0001:
00:00007D40 6100F8F8        	  1823: 	bsr set_graphics_mode
00:00007D44 6100F91E        	  1824: 	bsr get_screen_address
00:00007D48 42B9FD0FFD04    	  1825: 	move.l #0,RAND+4		; select stream 0
00:00007D4E 343C1D4B        	  1826: 	move.w #7499,d2
                            	  1827: .0002:
00:00007D52 2239FD0FFD00    	  1828: 	move.l RAND,d1
00:00007D58 42B9FD0FFD00    	  1829: 	move.l #0,RAND			; cause new number generation
00:00007D5E 20C1            	  1830: 	move.l d1,(a0)+			; random display
00:00007D60 51CAFFF0        	  1831: 	dbra d2,.0002
00:00007D64 6000FF1E        	  1832: 	bra Monitor
                            	  1833: 
                            	  1834: cmdBreakpoint:
00:00007D68 61000550        	  1835: 	bsr	ignBlanks
00:00007D6C 6100FF02        	  1836: 	bsr	FromScreen
00:00007D70 0C01002B        	  1837: 	cmpi.b	#'+',d1
00:00007D74 6700169E        	  1838: 	beq	ArmBreakpoint
00:00007D78 0C01002D        	  1839: 	cmpi.b	#'-',d1
00:00007D7C 67001714        	  1840: 	beq	DisarmBreakpoint
00:00007D80 0C01004C        	  1841: 	cmpi.b	#'L',d1
00:00007D84 67001760        	  1842: 	beq	ListBreakpoints
00:00007D88 6000FEFA        	  1843: 	bra	Monitor
                            	  1844: 
                            	  1845: cmdAsteroids:
00:00007D8C 487AFEF6        	  1846: 	pea Monitor
00:00007D90 60002846        	  1847: 	jmp asteroids_start
                            	  1848: 
                            	  1849: cmdTinyBasic:
00:00007D94 6000E2B0        	  1850: 	bra	CSTART
                            	  1851: 
                            	  1852: cmdTestCPU:
00:00007D98 6100A73C        	  1853: 	bsr	cpu_test
00:00007D9C 43FA1A79        	  1854: 	lea	msg_test_done,a1
00:00007DA0 6100F904        	  1855: 	bsr	DisplayStringCRLF
00:00007DA4 6000FEDE        	  1856: 	bra	Monitor
                            	  1857: 
                            	  1858: cmdClearScreen:
00:00007DA8 61001422        	  1859: 	bsr	ClearScreen
00:00007DAC 61009702        	  1860: 	bsr	HomeCursor
00:00007DB0 6000FED2        	  1861: 	bra	Monitor
                            	  1862: 
                            	  1863: cmdCore:
00:00007DB4 61000504        	  1864: 	bsr			ignBlanks
00:00007DB8 6100FEB6        	  1865: 	bsr			FromScreen
00:00007DBC 0C010032        	  1866: 	cmpi.b	#'2',d1					; check range
00:00007DC0 6500FEC2        	  1867: 	blo			Monitor
00:00007DC4 0C010035        	  1868: 	cmpi.b	#'0'+NCORES+1,d1
00:00007DC8 6200FEBA        	  1869: 	bhi			Monitor
00:00007DCC 04010030        	  1870: 	subi.b	#'0',d1					; convert ascii to binary
00:00007DD0 6100FD78        	  1871: 	bsr			select_iofocus
00:00007DD4 6000FEAE        	  1872: 	bra			Monitor
                            	  1873: 
                            	  1874: cmdFMTK:
00:00007DD8 61008446        	  1875: 	bsr FemtikiInit
00:00007DDC 6000FEA6        	  1876: 	bra Monitor
                            	  1877: 
                            	  1878: cmdTestFP:
00:00007DE0 7029            	  1879: 	moveq #41,d0						; function #41, get float
00:00007DE2 7208            	  1880: 	moveq #8,d1							; d1 = input stride
00:00007DE4 2248            	  1881: 	move.l a0,a1						; a1 = pointer to input buffer
00:00007DE6 4E4F            	  1882: 	trap #15
00:00007DE8 2049            	  1883: 	move.l a1,a0
00:00007DEA F2000200        	  1884: 	fmove.x fp0,fp4
00:00007DEE 610004CA        	  1885: 	bsr ignBlanks
00:00007DF2 6100FE7C        	  1886: 	bsr FromScreen
00:00007DF6 1E01            	  1887: 	move.b d1,d7
00:00007DF8 7029            	  1888: 	moveq #41,d0						; function #41, get float
00:00007DFA 7208            	  1889: 	move.l #8,d1						; d1 = input stride
00:00007DFC 2248            	  1890: 	move.l a0,a1						; a1 = pointer to input buffer
00:00007DFE 4E4F            	  1891: 	trap #15
00:00007E00 2049            	  1892: 	move.l a1,a0
00:00007E02 F2000100        	  1893: 	fmove.x fp0,fp2
00:00007E06 6100F86E        	  1894: 	bsr CRLF
                            	  1895: ;	moveq #39,d0
                            	  1896: ;	moveq #40,d1
                            	  1897: ;	moveq #30,d2
                            	  1898: ;	moveq #'e',d3
                            	  1899: ;	trap #15
                            	  1900: ;	bsr CRLF
00:00007E0A F2396A00000402C0	  1901: 	fmove.x fp4,fpBuf
00:00007E12 F2396900000402D0	  1902: 	fmove.x fp2,fpBuf+16
00:00007E1A 0C07002B        	  1903: 	cmpi.b #'+',d7
00:00007E1E 6606            	  1904: 	bne .0001
00:00007E20 F2000A22        	  1905: 	fadd fp2,fp4
00:00007E24 6022            	  1906: 	bra .0002
                            	  1907: .0001
00:00007E26 0C07002D        	  1908: 	cmpi.b #'-',d7
00:00007E2A 6606            	  1909: 	bne .0003
00:00007E2C F2000A28        	  1910: 	fsub fp2,fp4
00:00007E30 6016            	  1911: 	bra .0002
                            	  1912: .0003
00:00007E32 0C07002A        	  1913: 	cmpi.b #'*',d7
00:00007E36 6606            	  1914: 	bne .0004
00:00007E38 F2000A23        	  1915: 	fmul fp2,fp4
00:00007E3C 600A            	  1916: 	bra .0002
                            	  1917: .0004
00:00007E3E 0C07002F        	  1918: 	cmpi.b #'/',d7
00:00007E42 6620            	  1919: 	bne .0005
00:00007E44 F2000A20        	  1920: 	fdiv fp2,fp4
                            	  1921: 	bra .0002
                            	  1922: .0002
00:00007E48 F2396A00000402E0	  1923: 	fmove.x fp4,fpBuf+32
00:00007E50 F2001000        	  1924: 	fmove.x fp4,fp0
00:00007E54 43F900040520    	  1925: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
00:00007E5A 7027            	  1926: 	moveq #39,d0						; function #39 print float
00:00007E5C 7228            	  1927: 	moveq #40,d1						; width
00:00007E5E 741E            	  1928: 	moveq #30,d2						; precision
00:00007E60 7665            	  1929: 	moveq #'e',d3
00:00007E62 4E4F            	  1930: 	trap #15
                            	  1931: .0005
00:00007E64 6100F810        	  1932: 	bsr CRLF
00:00007E68 6000FE1A        	  1933: 	bra Monitor
                            	  1934: 
                            	  1935: cmdTestGF:
00:00007E6C 6100F808        	  1936: 	bsr CRLF
00:00007E70 7029            	  1937: 	moveq #41,d0						; function #41, get float
00:00007E72 7208            	  1938: 	move.l #8,d1						; d1 = input stride
00:00007E74 2248            	  1939: 	move.l a0,a1						; a1 = pointer to input buffer
00:00007E76 4E4F            	  1940: 	trap #15
00:00007E78 F2396800000402E0	  1941: 	fmove.x fp0,fpBuf+32
00:00007E80 43F900040520    	  1942: 	lea _fpBuf,a1						; a0 = pointer to buffer to use
00:00007E86 7027            	  1943: 	moveq #39,d0
00:00007E88 7228            	  1944: 	moveq #40,d1
00:00007E8A 741E            	  1945: 	moveq #30,d2
00:00007E8C 7665            	  1946: 	moveq #'e',d3
00:00007E8E 4E4F            	  1947: 	trap #15
00:00007E90 2049            	  1948: 	move.l a1,a0
00:00007E92 6100F7E2        	  1949: 	bsr CRLF
00:00007E96 6000FDEC        	  1950: 	bra Monitor
                            	  1951: 		
                            	  1952: ;-------------------------------------------------------------------------------
                            	  1953: ; CLOCK <n>
                            	  1954: ;    Set the clock register to n which will turn off or on clocks to the CPUs.
                            	  1955: ;-------------------------------------------------------------------------------
                            	  1956: 
                            	  1957: cmdClock:
00:00007E9A 6100041E        	  1958: 	bsr			ignBlanks
00:00007E9E 610009FA        	  1959: 	bsr			GetHexNumber
00:00007EA2 4A00            	  1960: 	tst.b		d0							; was there a number?
00:00007EA4 6700FDDE        	  1961: 	beq			Monitor
00:00007EA8 00400004        	  1962: 	ori.w		#4,d0						; primary core's clock cannot be turned off
00:00007EAC E159            	  1963: 	rol.w		#8,d1						; switch byte order
00:00007EAE 33C1FD0FFC02    	  1964: 	move.w	d1,RST_REG+2
00:00007EB4 6000FDCE        	  1965: 	bra			Monitor
                            	  1966: 
                            	  1967: ;-------------------------------------------------------------------------------
                            	  1968: ; RESET <n>
                            	  1969: ;    Reset the specified core. Resetting the core automatically turns on the 
                            	  1970: ; core's clock.
                            	  1971: ;-------------------------------------------------------------------------------
                            	  1972: 
                            	  1973: cmdReset:
00:00007EB8 61000400        	  1974: 	bsr			ignBlanks
00:00007EBC 6100FDB2        	  1975: 	bsr			FromScreen
00:00007EC0 0C010032        	  1976: 	cmpi.b	#'2',d1					; check range
00:00007EC4 6500FDBE        	  1977: 	blo			Monitor
00:00007EC8 0C010039        	  1978: 	cmpi.b	#'9',d1
00:00007ECC 6200FDB6        	  1979: 	bhi			Monitor
00:00007ED0 04010030        	  1980: 	subi.b	#'0',d1					; convert ascii to binary
00:00007ED4 E349            	  1981: 	lsl.w		#1,d1						; make into index
00:00007ED6 43FA0012        	  1982: 	lea			tblPow2,a1
00:00007EDA 32311000        	  1983: 	move.w	(a1,d1.w),d1
00:00007EDE E159            	  1984: 	rol.w		#8,d1						; reverse byte order
00:00007EE0 33C1FD0FFC00    	  1985: 	move.w	d1,RST_REG
00:00007EE6 6000FD9C        	  1986: 	bra			Monitor
                            	  1987: 
                            	  1988: tblPow2:
00:00007EEA 0001            	  1989: 	dc.w		1
00:00007EEC 0002            	  1990: 	dc.w		2
00:00007EEE 0004            	  1991: 	dc.w		4
00:00007EF0 0008            	  1992: 	dc.w		8
00:00007EF2 0010            	  1993: 	dc.w		16
00:00007EF4 0020            	  1994: 	dc.w		32
00:00007EF6 0040            	  1995: 	dc.w		64
00:00007EF8 0080            	  1996: 	dc.w		128
00:00007EFA 0100            	  1997: 	dc.w		256
00:00007EFC 0200            	  1998: 	dc.w		512
00:00007EFE 0400            	  1999: 	dc.w		1024
00:00007F00 0800            	  2000: 	dc.w		2048
00:00007F02 1000            	  2001: 	dc.w		4096
00:00007F04 2000            	  2002: 	dc.w		8192
00:00007F06 4000            	  2003: 	dc.w		16384
00:00007F08 8000            	  2004: 	dc.w		32768
                            	  2005: 	even
                            	  2006: 	
                            	  2007: cmdHelp:
                            	  2008: DisplayHelp:
00:00007F0A 43FA000A        	  2009: 	lea			HelpMsg,a1
00:00007F0E 6100F780        	  2010: 	bsr			DisplayString
00:00007F12 6000FD70        	  2011: 	bra			Monitor
                            	  2012: 
                            	  2013: HelpMsg:
00:00007F16 3F203D2044697370	  2014: 	dc.b	"? = Display help",LF,CR
00:00007F1E 6C61792068656C70
00:00007F26 0A
00:00007F27 0D
00:00007F28 434F5245206E203D	  2015: 	dc.b  "CORE n = switch to core n, n = 2 to 9",LF,CR
00:00007F30 2073776974636820
00:00007F38 746F20636F726520
00:00007F40 6E2C206E203D2032
00:00007F48 20746F2039
00:00007F4D 0A
00:00007F4E 0D
00:00007F4F 5245534554206E20	  2016: 	dc.b  "RESET n = reset core n",LF,CR
00:00007F57 3D20726573657420
00:00007F5F 636F7265206E
00:00007F65 0A
00:00007F66 0D
00:00007F67 434C53203D20636C	  2017: 	dc.b	"CLS = clear screen",LF,CR
00:00007F6F 6561722073637265
00:00007F77 656E
00:00007F79 0A
00:00007F7A 0D
00:00007F7B 4542203D20456469	  2018: 	dc.b	"EB = Edit memory bytes, EW, EL",LF,CR
00:00007F83 74206D656D6F7279
00:00007F8B 2062797465732C20
00:00007F93 45572C20454C
00:00007F99 0A
00:00007F9A 0D
00:00007F9B 4642203D2046696C	  2019: 	dc.b	"FB = Fill memory bytes, FW, FL",LF,CR
00:00007FA3 6C206D656D6F7279
00:00007FAB 2062797465732C20
00:00007FB3 46572C20464C
00:00007FB9 0A
00:00007FBA 0D
00:00007FBB 464D544B203D2072	  2020: 	dc.b	"FMTK = run Femtiki OS",LF,CR
00:00007FC3 756E2046656D7469
00:00007FCB 6B69204F53
00:00007FD0 0A
00:00007FD1 0D
00:00007FD2 4C203D204C6F6164	  2021: 	dc.b	"L = Load S19 file",LF,CR
00:00007FDA 205331392066696C
00:00007FE2 65
00:00007FE3 0A
00:00007FE4 0D
00:00007FE5 44203D2044756D70	  2022: 	dc.b	"D = Dump memory, DR = dump registers",LF,CR
00:00007FED 206D656D6F72792C
00:00007FF5 204452203D206475
00:00007FFD 6D70207265676973
00:00008005 74657273
00:00008009 0A
00:0000800A 0D
00:0000800B 4449203D20446973	  2023: 	dc.b	"DI = Disassemble",LF,CR
00:00008013 617373656D626C65
00:0000801B 0A
00:0000801C 0D
00:0000801D 4241203D20737461	  2024: 	dc.b	"BA = start tiny basic",LF,CR
00:00008025 72742074696E7920
00:0000802D 6261736963
00:00008032 0A
00:00008033 0D
00:00008034 4252203D20736574	  2025: 	dc.b  "BR = set breakpoint",LF,CR
00:0000803C 20627265616B706F
00:00008044 696E74
00:00008047 0A
00:00008048 0D
00:00008049 4A203D204A756D70	  2026: 	dc.b	"J = Jump to code",LF,CR
00:00008051 20746F20636F6465
00:00008059 0A
00:0000805A 0D
00:0000805B 53203D2073656E64	  2027: 	dc.b  "S = send to serial port",LF,CR
00:00008063 20746F2073657269
00:0000806B 616C20706F7274
00:00008072 0A
00:00008073 0D
00:00008074 54203D2063707520	  2028: 	dc.b	"T = cpu test program",LF,CR
00:0000807C 746573742070726F
00:00008084 6772616D
00:00008088 0A
00:00008089 0D
00:0000808A 5452414D203D2074	  2029: 	dc.b	"TRAM = test RAM",LF,CR,0
00:00008092 6573742052414D
00:00008099 0A
00:0000809A 0D
00:0000809B 00
                            	  2030: 
                            	  2031: msgUnknownCmd:
00:0000809C 636F6D6D616E6420	  2032: 	dc.b	"command unknown",0
00:000080A4 756E6B6E6F776E
00:000080AB 00
                            	  2033: 
                            	  2034: msgHello:
00:000080AC 0A              	  2035: 	dc.b	LF,CR,"Hello World!",LF,CR,0
00:000080AD 0D
00:000080AE 48656C6C6F20576F
00:000080B6 726C6421
00:000080BA 0A
00:000080BB 0D
00:000080BC 00
                            	  2036: 	even
                            	  2037: 
                            	  2038: ;------------------------------------------------------------------------------
                            	  2039: ; This routine borrowed from Gordo's Tiny Basic interpreter.
                            	  2040: ; Used to fetch a command line. (Not currently used).
                            	  2041: ;
                            	  2042: ; d0.b	- command prompt
                            	  2043: ;------------------------------------------------------------------------------
                            	  2044: 
                            	  2045: GetCmdLine:
00:000080BE 6100157A        	  2046: 		bsr		OutputChar		; display prompt
00:000080C2 103C0020        	  2047: 		move.b	#' ',d0
00:000080C6 61001572        	  2048: 		bsr		OutputChar
00:000080CA 41F900040040    	  2049: 		lea		CmdBuf,a0
                            	  2050: .0001:
00:000080D0 610087A2        	  2051: 		bsr		GetKey
00:000080D4 B03C0008        	  2052: 		cmp.b	#CTRLH,d0
00:000080D8 6728            	  2053: 		beq.s	.0003
00:000080DA B03C0018        	  2054: 		cmp.b	#CTRLX,d0
00:000080DE 6746            	  2055: 		beq.s	.0004
00:000080E0 B03C000D        	  2056: 		cmp.b	#CR,d0
00:000080E4 6706            	  2057: 		beq.s	.0002
00:000080E6 B03C0020        	  2058: 		cmp.b	#' ',d0
00:000080EA 65E4            	  2059: 		bcs.s	.0001
                            	  2060: .0002:
00:000080EC 1080            	  2061: 		move.b	d0,(a0)
00:000080EE 5088            	  2062: 		lea			8(a0),a0
00:000080F0 61001548        	  2063: 		bsr		OutputChar
00:000080F4 B03C000D        	  2064: 		cmp.b	#CR,d0
00:000080F8 675E            	  2065: 		beq		.0007
00:000080FA B1FC0004007F    	  2066: 		cmp.l	#CmdBufEnd-1,a0
00:00008100 65CE            	  2067: 		bcs.s	.0001
                            	  2068: .0003:
00:00008102 103C0008        	  2069: 		move.b	#CTRLH,d0
00:00008106 61001532        	  2070: 		bsr		OutputChar
00:0000810A 103C0020        	  2071: 		move.b	#' ',d0
00:0000810E 6100152A        	  2072: 		bsr		OutputChar
00:00008112 B1FC00040040    	  2073: 		cmp.l	#CmdBuf,a0
00:00008118 63B6            	  2074: 		bls.s	.0001
00:0000811A 103C0008        	  2075: 		move.b	#CTRLH,d0
00:0000811E 6100151A        	  2076: 		bsr		OutputChar
00:00008122 5388            	  2077: 		subq.l	#1,a0
00:00008124 60AA            	  2078: 		bra.s	.0001
                            	  2079: .0004:
00:00008126 2208            	  2080: 		move.l	a0,d1
00:00008128 92BC00040040    	  2081: 		sub.l	#CmdBuf,d1
00:0000812E 671E            	  2082: 		beq.s	.0006
00:00008130 5341            	  2083: 		subq	#1,d1
                            	  2084: .0005:
00:00008132 103C0008        	  2085: 		move.b	#CTRLH,d0
00:00008136 61001502        	  2086: 		bsr		OutputChar
00:0000813A 103C0020        	  2087: 		move.b	#' ',d0
00:0000813E 610014FA        	  2088: 		bsr		OutputChar
00:00008142 103C0008        	  2089: 		move.b	#CTRLH,d0
00:00008146 610014F2        	  2090: 		bsr		OutputChar
00:0000814A 51C9FFE6        	  2091: 		dbra	d1,.0005
                            	  2092: .0006:
00:0000814E 41F900040040    	  2093: 		lea		CmdBuf,a0
00:00008154 6000FF7A        	  2094: 		bra		.0001
                            	  2095: .0007:
00:00008158 103C000A        	  2096: 		move.b	#LF,d0
00:0000815C 610014DC        	  2097: 		bsr		OutputChar
00:00008160 4E75            	  2098: 		rts
                            	  2099: 
                            	  2100: ;------------------------------------------------------------------------------
                            	  2101: ; S <address> <length>
                            	  2102: ; Send data buffer to serial port
                            	  2103: ; S 40000 40
                            	  2104: ;------------------------------------------------------------------------------
                            	  2105: 
                            	  2106: cmdSendSerial:
00:00008162 61000156        	  2107: 	bsr			ignBlanks
00:00008166 61000732        	  2108: 	bsr			GetHexNumber
00:0000816A 6700FB18        	  2109: 	beq			Monitor
00:0000816E 2C01            	  2110: 	move.l	d1,d6					; d6 points to buffer
00:00008170 61000148        	  2111: 	bsr			ignBlanks
00:00008174 61000724        	  2112: 	bsr			GetHexNumber
00:00008178 6602            	  2113: 	bne.s		.0003
00:0000817A 7210            	  2114: 	moveq		#16,d1
                            	  2115: .0003:
00:0000817C 2246            	  2116: 	move.l	d6,a1					; a1 points to buffer
00:0000817E 2401            	  2117: 	move.l	d1,d2					; d2 = count of bytes to send
00:00008180 6008            	  2118: 	bra.s		.0002					; enter loop at bottom
                            	  2119: .0001:
00:00008182 1219            	  2120: 	move.b	(a1)+,d1
00:00008184 303C0022        	  2121: 	move.w	#34,d0				; serial putchar
00:00008188 4E4F            	  2122: 	trap		#15
                            	  2123: .0002:
00:0000818A 51CAFFF6        	  2124: 	dbra		d2,.0001
00:0000818E 6000FAF4        	  2125: 	bra			Monitor
                            	  2126: 		
                            	  2127: ;------------------------------------------------------------------------------
                            	  2128: ; R <address> <length>
                            	  2129: ; Send data buffer to serial port
                            	  2130: ; R 10000 40
                            	  2131: ;------------------------------------------------------------------------------
                            	  2132: 
                            	  2133: cmdReceiveSerial:
00:00008192 61000126        	  2134: 	bsr			ignBlanks
00:00008196 61000702        	  2135: 	bsr			GetHexNumber
00:0000819A 6700FAE8        	  2136: 	beq			Monitor
00:0000819E 2C01            	  2137: 	move.l	d1,d6					; d6 points to buffer
00:000081A0 61000118        	  2138: 	bsr			ignBlanks
00:000081A4 610006F4        	  2139: 	bsr			GetHexNumber
00:000081A8 6602            	  2140: 	bne.s		.0003
00:000081AA 7210            	  2141: 	moveq		#16,d1
                            	  2142: .0003:
00:000081AC 2246            	  2143: 	move.l	d6,a1					; a1 points to buffer
00:000081AE 2401            	  2144: 	move.l	d1,d2					; d2 = count of bytes to send
00:000081B0 600C            	  2145: 	bra.s		.0002					; enter loop at bottom
                            	  2146: .0001:
00:000081B2 303C0024        	  2147: 	move.w	#36,d0				; serial peek char
00:000081B6 4E4F            	  2148: 	trap		#15
00:000081B8 4A81            	  2149: 	tst.l		d1
00:000081BA 6BF6            	  2150: 	bmi.s		.0001
00:000081BC 12C1            	  2151: 	move.b	d1,(a1)+
                            	  2152: .0002:
00:000081BE 51CAFFF2        	  2153: 	dbra		d2,.0001
00:000081C2 6000FAC0        	  2154: 	bra			Monitor
                            	  2155: 		
                            	  2156: ;------------------------------------------------------------------------------
                            	  2157: ; Fill memory
                            	  2158: ;
                            	  2159: ; FB = fill bytes		FB 00000010 100 FF	; fill starting at 10 for 256 bytes
                            	  2160: ; FB = fill bytes		FB 00000010 100 R		; fill with random bytes
                            	  2161: ; FW = fill words
                            	  2162: ; FL = fill longs
                            	  2163: ; F = fill bytes
                            	  2164: ;------------------------------------------------------------------------------
                            	  2165: 
                            	  2166: cmdFillB:
00:000081C6 610000F2        	  2167: 	bsr			ignBlanks
00:000081CA 610006CE        	  2168: 	bsr			GetHexNumber
00:000081CE 2241            	  2169: 	move.l	d1,a1					; a1 = start
00:000081D0 610000E8        	  2170: 	bsr			ignBlanks
00:000081D4 610006C4        	  2171: 	bsr			GetHexNumber
00:000081D8 2601            	  2172: 	move.l	d1,d3					; d3 = count
00:000081DA 6700FAA8        	  2173: 	beq			Monitor
00:000081DE 610000DA        	  2174: 	bsr			ignBlanks
00:000081E2 610000E8        	  2175: 	bsr PeekScreenChar
00:000081E6 0C010052        	  2176: 	cmpi.b #'R',d1
00:000081EA 660A            	  2177: 	bne.s .0002
00:000081EC 6100FA82        	  2178: 	bsr FromScreen
00:000081F0 1A3C0052        	  2179: 	move.b #'R',d5
00:000081F4 6006            	  2180: 	bra.s .fmem
                            	  2181: .0002:
00:000081F6 610006A2        	  2182: 	bsr	GetHexNumber		; fill value
00:000081FA 1801            	  2183: 	move.b d1,d4
                            	  2184: .fmem:
00:000081FC 3409            	  2185: 	move.w a1,d2
00:000081FE 4A42            	  2186: 	tst.w d2
00:00008200 6604            	  2187: 	bne.s .0001
00:00008202 610086AA        	  2188: 	bsr	CheckForCtrlC
                            	  2189: .0001:	
00:00008206 0C050052        	  2190: 	cmpi.b #'R',d5
00:0000820A 6604            	  2191: 	bne.s .0003
00:0000820C 6100A106        	  2192: 	bsr RandGetNum
                            	  2193: .0003:
00:00008210 12C4            	  2194: 	move.b d4,(a1)+
00:00008212 5383            	  2195: 	sub.l	#1,d3
00:00008214 66E6            	  2196: 	bne.s	.fmem
00:00008216 6000FA6C        	  2197: 	bra	Monitor
                            	  2198: 	
                            	  2199: cmdFillW:
00:0000821A 6100009E        	  2200: 	bsr			ignBlanks
00:0000821E 6100067A        	  2201: 	bsr			GetHexNumber
00:00008222 2241            	  2202: 	move.l	d1,a1					; a1 = start
00:00008224 61000094        	  2203: 	bsr			ignBlanks
00:00008228 61000670        	  2204: 	bsr			GetHexNumber
00:0000822C 2601            	  2205: 	move.l	d1,d3					; d3 = count
00:0000822E 6700FA54        	  2206: 	beq			Monitor
00:00008232 61000086        	  2207: 	bsr			ignBlanks
00:00008236 61000094        	  2208: 	bsr PeekScreenChar
00:0000823A 0C010052        	  2209: 	cmpi.b #'R',d1
00:0000823E 660A            	  2210: 	bne.s .0002
00:00008240 6100FA2E        	  2211: 	bsr FromScreen
00:00008244 1A3C0052        	  2212: 	move.b #'R',d5
00:00008248 6006            	  2213: 	bra.s .fmem
                            	  2214: .0002:
00:0000824A 6100064E        	  2215: 	bsr	GetHexNumber			; fill value
00:0000824E 3801            	  2216: 	move.w d1,d4
                            	  2217: .fmem:
00:00008250 3409            	  2218: 	move.w a1,d2
00:00008252 4A42            	  2219: 	tst.w d2
00:00008254 6604            	  2220: 	bne.s .0001
00:00008256 61008656        	  2221: 	bsr	CheckForCtrlC
                            	  2222: .0001:	
00:0000825A 0C050052        	  2223: 	cmpi.b #'R',d5
00:0000825E 6604            	  2224: 	bne.s .0003
00:00008260 6100A0B2        	  2225: 	bsr RandGetNum
                            	  2226: .0003:
00:00008264 32C4            	  2227: 	move.w d4,(a1)+
00:00008266 5383            	  2228: 	sub.l	#1,d3
00:00008268 66E6            	  2229: 	bne.s	.fmem
00:0000826A 6000FA18        	  2230: 	bra	Monitor
                            	  2231: 	
                            	  2232: cmdFillL:
00:0000826E 614A            	  2233: 	bsr			ignBlanks
00:00008270 61000628        	  2234: 	bsr			GetHexNumber
00:00008274 2241            	  2235: 	move.l	d1,a1					; a1 = start
00:00008276 6142            	  2236: 	bsr			ignBlanks
00:00008278 61000620        	  2237: 	bsr			GetHexNumber
00:0000827C 2601            	  2238: 	move.l	d1,d3					; d3 = count
00:0000827E 6700FA04        	  2239: 	beq			Monitor
00:00008282 6136            	  2240: 	bsr			ignBlanks
00:00008284 6146            	  2241: 	bsr PeekScreenChar
00:00008286 0C010052        	  2242: 	cmpi.b #'R',d1
00:0000828A 660A            	  2243: 	bne.s .0002
00:0000828C 6100F9E2        	  2244: 	bsr FromScreen
00:00008290 1A3C0052        	  2245: 	move.b #'R',d5
00:00008294 6006            	  2246: 	bra.s .fmem
                            	  2247: .0002:
00:00008296 61000602        	  2248: 	bsr			GetHexNumber	; fill value
00:0000829A 2801            	  2249: 	move.l d1,d4
                            	  2250: .fmem:
00:0000829C 3409            	  2251: 	move.w a1,d2
00:0000829E 4A42            	  2252: 	tst.w d2
00:000082A0 6604            	  2253: 	bne.s .0001
00:000082A2 6100860A        	  2254: 	bsr	CheckForCtrlC
                            	  2255: .0001:	
00:000082A6 0C050052        	  2256: 	cmpi.b #'R',d5
00:000082AA 6604            	  2257: 	bne.s .0003
00:000082AC 6100A066        	  2258: 	bsr RandGetNum
                            	  2259: .0003:
00:000082B0 22C4            	  2260: 	move.l d4,(a1)+
00:000082B2 5383            	  2261: 	sub.l	#1,d3
00:000082B4 66E6            	  2262: 	bne.s	.fmem
00:000082B6 6000F9CC        	  2263: 	bra	Monitor
                            	  2264: 	
                            	  2265: ;------------------------------------------------------------------------------
                            	  2266: ; Modifies:
                            	  2267: ;	a0	- text pointer
                            	  2268: ;------------------------------------------------------------------------------
                            	  2269: 
                            	  2270: ignBlanks:
00:000082BA 2F01            	  2271: 	move.l d1,-(a7)
                            	  2272: .0001:
00:000082BC 6100F9B2        	  2273: 	bsr	FromScreen
00:000082C0 0C010020        	  2274: 	cmpi.b #' ',d1
00:000082C4 67F6            	  2275: 	beq.s .0001
                            	  2276: 	if (SCREEN_FORMAT==1)
00:000082C6 5988            	  2277: 		lea	-4(a0),a0
                            	  2278: 	else
                            	  2279: 		lea	-8(a0),a0
                            	  2280: 	endif
00:000082C8 221F            	  2281: 	move.l (a7)+,d1
00:000082CA 4E75            	  2282: 	rts
                            	  2283: 
                            	  2284: 
                            	  2285: ;------------------------------------------------------------------------------
                            	  2286: ;------------------------------------------------------------------------------
                            	  2287: 
                            	  2288: PeekScreenChar:
00:000082CC 2210            	  2289: 	move.l (a0),d1
00:000082CE 60000F04        	  2290: 	bra rbo
                            	  2291: 
                            	  2292: ;------------------------------------------------------------------------------
                            	  2293: ; Get the size character
                            	  2294: ; If the size is not recognized, assume a byte size
                            	  2295: ;
                            	  2296: ; Modifies:
                            	  2297: ;		a0	- text pointer
                            	  2298: ;		d1
                            	  2299: ; Returns:
                            	  2300: ;		d4 = size character 'B','W' or 'L'
                            	  2301: ;------------------------------------------------------------------------------
                            	  2302: 
                            	  2303: GetSzChar:
00:000082D2 61E6            	  2304: 	bsr	ignBlanks
00:000082D4 7842            	  2305: 	moveq #'B',d4		; assume byte
00:000082D6 2210            	  2306: 	move.l (a0),d1
00:000082D8 61000EFA        	  2307: 	bsr	rbo
00:000082DC 0C010042        	  2308: 	cmpi.b #'B',d1
00:000082E0 670E            	  2309: 	beq.s .0002
00:000082E2 0C010057        	  2310: 	cmpi.b #'W',d1
00:000082E6 6708            	  2311: 	beq.s .0002
00:000082E8 0C01004C        	  2312: 	cmpi.b #'L',d1
00:000082EC 6702            	  2313: 	beq.s .0002
00:000082EE 4E75            	  2314: 	rts
                            	  2315: .0002:
00:000082F0 6100F97E        	  2316: 	bsr FromScreen
00:000082F4 1801            	  2317: 	move.b d1,d4
00:000082F6 4E75            	  2318: 	rts
                            	  2319: 
                            	  2320: ;------------------------------------------------------------------------------
                            	  2321: ; Edit memory byte.
                            	  2322: ;    Bytes are built into long words in case the memory is only longword
                            	  2323: ; accessible.
                            	  2324: ;------------------------------------------------------------------------------
                            	  2325: 
                            	  2326: EditMemHelper:
00:000082F8 61C0            	  2327: 	bsr ignBlanks
00:000082FA 6100059E        	  2328: 	bsr GetHexNumber
00:000082FE 0C04004C        	  2329: 	cmpi.b #'L',d4
00:00008302 6604            	  2330: 	bne.s .0001
00:00008304 2401            	  2331: 	move.l d1,d2
00:00008306 4E75            	  2332: 	rts
                            	  2333: .0001:
00:00008308 0C040057        	  2334: 	cmpi.b #'W',d4
00:0000830C 6606            	  2335: 	bne.s .0002
00:0000830E 4842            	  2336: 	swap d2
00:00008310 3401            	  2337: 	move.w d1,d2
00:00008312 4E75            	  2338: 	rts
                            	  2339: .0002:
00:00008314 E18A            	  2340: 	lsl.l #8,d2
00:00008316 1401            	  2341: 	move.b d1,d2
00:00008318 4E75            	  2342: 	rts
                            	  2343: 	
                            	  2344: cmdEditMemory:
00:0000831A 61B6            	  2345: 	bsr GetSzChar
00:0000831C 619C            	  2346: 	bsr ignBlanks
00:0000831E 6100057A        	  2347: 	bsr	GetHexNumber
00:00008322 2241            	  2348: 	move.l d1,a1
                            	  2349: edtmem1:
00:00008324 0C04004C        	  2350: 	cmpi.b #'L',d4
00:00008328 6610            	  2351: 	bne.s .0004
00:0000832A 7400            	  2352: 	clr.l	d2
00:0000832C 61CA            	  2353: 	bsr EditMemHelper
00:0000832E 22C2            	  2354: 	move.l d2,(a1)+
00:00008330 7400            	  2355: 	clr.l	d2
00:00008332 61C4            	  2356: 	bsr EditMemHelper
00:00008334 22C2            	  2357: 	move.l d2,(a1)+
00:00008336 6000F94C        	  2358: 	bra Monitor
                            	  2359: .0004:
00:0000833A 0C040057        	  2360: 	cmpi.b #'W',d4
00:0000833E 6618            	  2361: 	bne.s .0005
00:00008340 7400            	  2362: 	clr.l	d2
00:00008342 61B4            	  2363: 	bsr EditMemHelper
00:00008344 61B2            	  2364: 	bsr EditMemHelper
00:00008346 4842            	  2365: 	swap d2
00:00008348 22C2            	  2366: 	move.l d2,(a1)+
00:0000834A 7400            	  2367: 	clr.l	d2
00:0000834C 61AA            	  2368: 	bsr EditMemHelper
00:0000834E 61A8            	  2369: 	bsr EditMemHelper
00:00008350 4842            	  2370: 	swap d2
00:00008352 22C2            	  2371: 	move.l d2,(a1)+
00:00008354 6000F92E        	  2372: 	bra Monitor
                            	  2373: .0005:
00:00008358 7400            	  2374: 	clr.l	d2
00:0000835A 619C            	  2375: 	bsr EditMemHelper
00:0000835C 619A            	  2376: 	bsr EditMemHelper
00:0000835E 6198            	  2377: 	bsr EditMemHelper
00:00008360 6196            	  2378: 	bsr EditMemHelper
00:00008362 C342            	  2379: 	exg d1,d2
00:00008364 61000E6E        	  2380: 	bsr rbo
00:00008368 22C1            	  2381: 	move.l d1,(a1)+
00:0000836A 61000E68        	  2382: 	bsr rbo
00:0000836E C342            	  2383: 	exg d1,d2
00:00008370 7400            	  2384: 	clr.l	d2
00:00008372 6184            	  2385: 	bsr EditMemHelper
00:00008374 6182            	  2386: 	bsr EditMemHelper
00:00008376 6180            	  2387: 	bsr EditMemHelper
00:00008378 6100FF7E        	  2388: 	bsr EditMemHelper
00:0000837C C342            	  2389: 	exg d1,d2
00:0000837E 61000E54        	  2390: 	bsr rbo
00:00008382 22C1            	  2391: 	move.l d1,(a1)+
00:00008384 61000E4E        	  2392: 	bsr rbo
00:00008388 C342            	  2393: 	exg d1,d2
00:0000838A 6000F8F8        	  2394: 	bra Monitor
                            	  2395: 
                            	  2396: ;------------------------------------------------------------------------------
                            	  2397: ; Execute code at the specified address.
                            	  2398: ;------------------------------------------------------------------------------
                            	  2399: 
                            	  2400: cmdJump:
                            	  2401: ExecuteCode:
00:0000838E 6100FF2A        	  2402: 	bsr	ignBlanks
00:00008392 61000506        	  2403: 	bsr	GetHexNumber
00:00008396 2041            	  2404: 	move.l d1,a0
00:00008398 4E90            	  2405: 	jsr	(a0)
00:0000839A 6000F8E8        	  2406: 	bra Monitor
                            	  2407: 
                            	  2408: cmdGrDemo:
00:0000839E 223C00001555    	  2409: 	move.l #$00001555,d1		; 16 bpp
00:000083A4 7E06            	  2410: 	moveq #6,d7							; framebuf device
00:000083A6 7C21            	  2411: 	moveq #DEV_SET_COLOR_DEPTH,d6
00:000083A8 4E40            	  2412: 	trap #0
00:000083AA 13FC0044FD200002	  2413: 	move.b #$44,FRAMEBUF+FRAMEBUF_CTRL+2	; 4 clocks/scanlines per pixel
00:000083B2 7E06            	  2414: 	moveq #6,d7							; framebuf device
00:000083B4 7C20            	  2415: 	moveq #DEV_SET_DIMEN,d6
00:000083B6 7000            	  2416: 	moveq #0,d0
00:000083B8 223C000001E0    	  2417: 	move.l #480,d1
00:000083BE 243C0000010E    	  2418: 	move.l #270,d2
00:000083C4 7600            	  2419: 	move.l #0,d3
00:000083C6 4E40            	  2420: 	trap #0
00:000083C8 7E07            	  2421: 	moveq #7,d7							; graphics accelerator device
00:000083CA 4E40            	  2422: 	trap #0
00:000083CC 61000082        	  2423: 	bsr clear_graphics_screen
                            	  2424: ;	moveq #94,d0							; page flip
                            	  2425: ;	trap #15
                            	  2426: 
                            	  2427: ;	moveq #0,d1
                            	  2428: ;	moveq #0,d2
                            	  2429: ;	move.l #1920,d3
                            	  2430: ;	move.l #1080,d4
                            	  2431: ;	bsr gfxaccel_clip_rect
                            	  2432: 	; Draw two diagonal white lines
00:000083D0 263C0000010E    	  2433: 	move.l #270,d3
00:000083D6 287C40000000    	  2434: 	move.l #$40000000,a4
                            	  2435: .0002:
00:000083DC 243CFF7FFF7F    	  2436: 	move.l #$FF7FFF7F,d2	; white
00:000083E2 3882            	  2437: 	move.w d2,(a4)
00:000083E4 49EC03C2        	  2438: 	add.l #962,a4
00:000083E8 51CBFFF2        	  2439: 	dbra d3,.0002
00:000083EC 263C0000010E    	  2440: 	move.l #270,d3
00:000083F2 287C400003C0    	  2441: 	move.l #$40000000+960,a4
                            	  2442: .0007:
00:000083F8 3882            	  2443: 	move.w d2,(a4)
00:000083FA 49EC03BE        	  2444: 	add.l #958,a4
00:000083FE 51CBFFF8        	  2445: 	dbra d3,.0007
00:00008402 6000F880        	  2446: 	bra Monitor
                            	  2447: 
                            	  2448: ;	bra Monitor
                            	  2449: plot_rand_points:
00:00008406 223C7F127F12    	  2450: 	move.l #$7F127F12,d1
00:0000840C 61000DC6        	  2451: 	bsr rbo
00:00008410 61009B14        	  2452: 	bsr gfxaccel_set_color
00:00008414 2A3C00002710    	  2453: 	move.l #10000,d5
                            	  2454: .0005:
00:0000841A 287C40000000    	  2455: 	move.l #$40000000,a4
00:00008420 61009EF2        	  2456: 	bsr RandGetNum
00:00008424 2801            	  2457: 	move.l d1,d4
00:00008426 61009EEC        	  2458: 	bsr RandGetNum
00:0000842A 2401            	  2459: 	move.l d1,d2
00:0000842C 0282000000FF    	  2460: 	andi.l #$ff,d2
00:00008432 61009EE0        	  2461: 	bsr RandGetNum
00:00008436 0281000001FF    	  2462: 	andi.l #$1ff,d1
00:0000843C C4FC03C0        	  2463: 	mulu #960,d2
00:00008440 D481            	  2464: 	add.l d1,d2
00:00008442 D481            	  2465: 	add.l d1,d2
00:00008444 D9C2            	  2466: 	add.l d2,a4
00:00008446 3884            	  2467: 	move.w d4,(a4)				; plot point
00:00008448 51CDFFD0        	  2468: 	dbra d5,.0005
00:0000844C 6000F836        	  2469: 	bra Monitor
                            	  2470: 
                            	  2471: clear_graphics_screen:
                            	  2472: ;	move.l #0,d1
                            	  2473: ;	bsr gfxaccel_set_color
                            	  2474: ;	move.l #0,d1
                            	  2475: ;	move.l #0,d2
                            	  2476: ;	move.l #1920<<16,d3
                            	  2477: ;	move.l #1080<<16,d4
                            	  2478: ;	bsr gfxaccel_draw_rectangle
00:00008450 2A3C0001FA40    	  2479: 	move.l #480*270,d5		; compute number of strips to write
00:00008456 E88D            	  2480: 	lsr.l #4,d5
00:00008458 287900040D54    	  2481: 	move.l framebuf_dcb+DCB_OUTBUFPTR,a4
00:0000845E 42B97FFFFFF8    	  2482: 	move.l #0,$7FFFFFF8		; burst length of zero
00:00008464 6002            	  2483: 	bra.s .0001
                            	  2484: .0002:
00:00008466 4845            	  2485: 	swap d5
                            	  2486: .0001:
00:00008468 220C            	  2487: 	move.l a4,d1
00:0000846A 61000D68        	  2488: 	bsr rbo
00:0000846E 23C17FFFFFF4    	  2489: 	move.l d1,$7FFFFFF4		; target address
00:00008474 42B97FFFFFFC    	  2490: 	move.l #0,$7FFFFFFC		; value to write
00:0000847A 49EC0020        	  2491: 	lea.l 32(a4),a4
00:0000847E 51CDFFE8        	  2492: 	dbra d5,.0001
                            	  2493: ;	swap d5
                            	  2494: ;	dbra d5,.0002
00:00008482 4E75            	  2495: 	rts
                            	  2496: 
                            	  2497: clear_graphics_screen2:
                            	  2498: ;	move.l #0,d1
                            	  2499: ;	bsr gfxaccel_set_color
                            	  2500: ;	move.l #0,d1
                            	  2501: ;	move.l #0,d2
                            	  2502: ;	move.l #1920<<16,d3
                            	  2503: ;	move.l #1080<<16,d4
                            	  2504: ;	bsr gfxaccel_draw_rectangle
00:00008484 2A3C0001FA40    	  2505: 	move.l #480*270,d5		; compute number of strips to write
00:0000848A E88D            	  2506: 	lsr.l #4,d5						; 16 pixels per strip
00:0000848C E88D            	  2507: 	lsr.l #4,d5						; and burst writing 16 strips at once
00:0000848E 287900040D54    	  2508: 	move.l framebuf_dcb+DCB_OUTBUFPTR,a4
00:00008494 42B97FFFFFF8    	  2509: 	move.l #0,$7FFFFFF8		; burst length of zero
00:0000849A 6002            	  2510: 	bra.s .0001
                            	  2511: .0002:
00:0000849C 4845            	  2512: 	swap d5
                            	  2513: .0001:
00:0000849E 220C            	  2514: 	move.l a4,d1
00:000084A0 61000D32        	  2515: 	bsr rbo
00:000084A4 23C17FFFFFF4    	  2516: 	move.l d1,$7FFFFFF4		; target address
00:000084AA 23FC0000000F7FFF	  2517: 	move.l #15,$7FFFFFF8	; burst length = 16
00:000084B2 FFF8
00:000084B4 42B97FFFFFFC    	  2518: 	move.l #0,$7FFFFFFC		; value to write
00:000084BA 49EC0020        	  2519: 	lea.l 32(a4),a4
00:000084BE 51CDFFDE        	  2520: 	dbra d5,.0001
                            	  2521: ;	swap d5
                            	  2522: ;	dbra d5,.0002
00:000084C2 6000F7C0        	  2523: 	bra Monitor
                            	  2524: 
                            	  2525: white_rect:
00:000084C6 72FF            	  2526: 	move.l #$FFFFFFFF,d1
00:000084C8 61009A5C        	  2527: 	bsr gfxaccel_set_color
00:000084CC 72644841        	  2528: 	move.l #100<<16,d1
00:000084D0 243C00C80000    	  2529: 	move.l #200<<16,d2
00:000084D6 263C00FA0000    	  2530: 	move.l #250<<16,d3
00:000084DC 283C00FA0000    	  2531: 	move.l #250<<16,d4
00:000084E2 61009BC8        	  2532: 	bsr gfxaccel_draw_rectangle
00:000084E6 6000F79C        	  2533: 	bra Monitor
                            	  2534: 
                            	  2535: rand_points:
00:000084EA 2A3C00002710    	  2536: 	move.l #10000,d5
                            	  2537: .0004:
00:000084F0 61009E22        	  2538: 	bsr RandGetNum
00:000084F4 61009A30        	  2539: 	bsr gfxaccel_set_color
00:000084F8 61009E1A        	  2540: 	bsr RandGetNum
00:000084FC 2601            	  2541: 	move.l d1,d3
00:000084FE 4843            	  2542: 	swap d3
00:00008500 0283007FFFFF    	  2543: 	andi.l #$7fffff,d3		; Z
00:00008506 61009E0C        	  2544: 	bsr RandGetNum
00:0000850A 2401            	  2545: 	move.l d1,d2
00:0000850C 4842            	  2546: 	swap d2
00:0000850E 028200FFFFFF    	  2547: 	andi.l #$ffffff,d2		; Y
00:00008514 61009DFE        	  2548: 	bsr RandGetNum
00:00008518 4841            	  2549: 	swap d1
00:0000851A 028101FFFFFF    	  2550: 	andi.l #$1ffffff,d1		; X
00:00008520 61009ACC        	  2551: 	bsr gfxaccel_plot_point
00:00008524 51CDFFCA        	  2552: 	dbra d5,.0004
00:00008528 6000F75A        	  2553: 	bra Monitor
                            	  2554: 
                            	  2555: rand_lines:
00:0000852C 2A3C00002710    	  2556: 	move.l #10000,d5
                            	  2557: .0001:
                            	  2558: .0006:
00:00008532 6100837A        	  2559: 	bsr CheckForCtrlC
00:00008536 61009DDC        	  2560: 	bsr RandGetNum
00:0000853A 610099EA        	  2561: 	bsr gfxaccel_set_color
00:0000853E 61009DD4        	  2562: 	bsr RandGetNum
00:00008542 2801            	  2563: 	move.l d1,d4
00:00008544 4844            	  2564: 	swap d4
00:00008546 028400FFFFFF    	  2565: 	andi.l #$ffffff,d4
00:0000854C 61009DC6        	  2566: 	bsr RandGetNum
00:00008550 2601            	  2567: 	move.l d1,d3
00:00008552 4843            	  2568: 	swap d3
00:00008554 028301FFFFFF    	  2569: 	andi.l #$1ffffff,d3
00:0000855A 61009DB8        	  2570: 	bsr RandGetNum
00:0000855E 2401            	  2571: 	move.l d1,d2
00:00008560 4842            	  2572: 	swap d2
00:00008562 028200FFFFFF    	  2573: 	andi.l #$ffffff,d2
00:00008568 61009DAA        	  2574: 	bsr RandGetNum
00:0000856C 4841            	  2575: 	swap d1
00:0000856E 028101FFFFFF    	  2576: 	andi.l #$1ffffff,d1
00:00008574 61009ACE        	  2577: 	bsr gfxaccel_draw_line
00:00008578 51CDFFB8        	  2578: 	dbra d5,.0001
00:0000857C 6000F706        	  2579: 	bra Monitor
                            	  2580: 
                            	  2581: rand_rect:
00:00008580 2A3C00002710    	  2582: 	move.l #10000,d5
                            	  2583: .0003:
                            	  2584: .0006:
00:00008586 61008326        	  2585: 	bsr CheckForCtrlC
00:0000858A 61009D88        	  2586: 	bsr RandGetNum
00:0000858E 61009996        	  2587: 	bsr gfxaccel_set_color
00:00008592 61009D80        	  2588: 	bsr RandGetNum
00:00008596 2801            	  2589: 	move.l d1,d4
00:00008598 4844            	  2590: 	swap d4
00:0000859A 028400FFFFFF    	  2591: 	andi.l #$ffffff,d4
00:000085A0 61009D72        	  2592: 	bsr RandGetNum
00:000085A4 2601            	  2593: 	move.l d1,d3
00:000085A6 4843            	  2594: 	swap d3
00:000085A8 028301FFFFFF    	  2595: 	andi.l #$1ffffff,d3
00:000085AE 61009D64        	  2596: 	bsr RandGetNum
00:000085B2 2401            	  2597: 	move.l d1,d2
00:000085B4 4842            	  2598: 	swap d2
00:000085B6 028200FFFFFF    	  2599: 	andi.l #$ffffff,d2
00:000085BC 61009D56        	  2600: 	bsr RandGetNum
00:000085C0 4841            	  2601: 	swap d1
00:000085C2 028101FFFFFF    	  2602: 	andi.l #$1ffffff,d1
00:000085C8 61009AE2        	  2603: 	bsr gfxaccel_draw_rectangle
00:000085CC 51CDFFB8        	  2604: 	dbra d5,.0003
00:000085D0 6000F6B2        	  2605: 	bra Monitor
                            	  2606: 
                            	  2607: rand_triangle:
00:000085D4 2E3C00002710    	  2608: 	move.l #10000,d7
                            	  2609: .0006:
00:000085DA 610082D2        	  2610: 	bsr CheckForCtrlC
00:000085DE 61009D34        	  2611: 	bsr RandGetNum
00:000085E2 61009942        	  2612: 	bsr gfxaccel_set_color
00:000085E6 61009D2C        	  2613: 	bsr RandGetNum
00:000085EA 2C01            	  2614: 	move.l d1,d6
00:000085EC 4846            	  2615: 	swap d6
00:000085EE 028600FFFFFF    	  2616: 	andi.l #$ffffff,d6
00:000085F4 61009D1E        	  2617: 	bsr RandGetNum
00:000085F8 2A01            	  2618: 	move.l d1,d5
00:000085FA 4845            	  2619: 	swap d5
00:000085FC 028501FFFFFF    	  2620: 	andi.l #$1ffffff,d5
00:00008602 61009D10        	  2621: 	bsr RandGetNum
00:00008606 2801            	  2622: 	move.l d1,d4
00:00008608 4844            	  2623: 	swap d4
00:0000860A 028400FFFFFF    	  2624: 	andi.l #$ffffff,d4
00:00008610 61009D02        	  2625: 	bsr RandGetNum
00:00008614 2601            	  2626: 	move.l d1,d3
00:00008616 4843            	  2627: 	swap d3
00:00008618 028301FFFFFF    	  2628: 	andi.l #$1ffffff,d3
00:0000861E 61009CF4        	  2629: 	bsr RandGetNum
00:00008622 2401            	  2630: 	move.l d1,d2
00:00008624 4842            	  2631: 	swap d2
00:00008626 028200FFFFFF    	  2632: 	andi.l #$ffffff,d2
00:0000862C 61009CE6        	  2633: 	bsr RandGetNum
00:00008630 4841            	  2634: 	swap d1
00:00008632 028101FFFFFF    	  2635: 	andi.l #$1ffffff,d1
00:00008638 61009ADA        	  2636: 	bsr gfxaccel_draw_triangle
00:0000863C 51CFFF9C        	  2637: 	dbra d7,.0006
00:00008640 6000F642        	  2638: 	bra Monitor
                            	  2639: 
                            	  2640: rand_curve:
00:00008644 2E3C00002710    	  2641: 	move.l #10000,d7
                            	  2642: .0006:
00:0000864A 61008262        	  2643: 	bsr CheckForCtrlC
00:0000864E 61009CC4        	  2644: 	bsr RandGetNum
00:00008652 610098D2        	  2645: 	bsr gfxaccel_set_color
00:00008656 61009CBC        	  2646: 	bsr RandGetNum
00:0000865A 2C01            	  2647: 	move.l d1,d6
00:0000865C 4846            	  2648: 	swap d6
00:0000865E 028600FFFFFF    	  2649: 	andi.l #$ffffff,d6
00:00008664 61009CAE        	  2650: 	bsr RandGetNum
00:00008668 2A01            	  2651: 	move.l d1,d5
00:0000866A 4845            	  2652: 	swap d5
00:0000866C 028501FFFFFF    	  2653: 	andi.l #$1ffffff,d5
00:00008672 61009CA0        	  2654: 	bsr RandGetNum
00:00008676 2801            	  2655: 	move.l d1,d4
00:00008678 4844            	  2656: 	swap d4
00:0000867A 028400FFFFFF    	  2657: 	andi.l #$ffffff,d4
00:00008680 61009C92        	  2658: 	bsr RandGetNum
00:00008684 2601            	  2659: 	move.l d1,d3
00:00008686 4843            	  2660: 	swap d3
00:00008688 028301FFFFFF    	  2661: 	andi.l #$1ffffff,d3
00:0000868E 61009C84        	  2662: 	bsr RandGetNum
00:00008692 2401            	  2663: 	move.l d1,d2
00:00008694 4842            	  2664: 	swap d2
00:00008696 028200FFFFFF    	  2665: 	andi.l #$ffffff,d2
00:0000869C 61009C76        	  2666: 	bsr RandGetNum
00:000086A0 4841            	  2667: 	swap d1
00:000086A2 028101FFFFFF    	  2668: 	andi.l #$1ffffff,d1
00:000086A8 61009AF2        	  2669: 	bsr gfxaccel_draw_curve
00:000086AC 51CFFF9C        	  2670: 	dbra d7,.0006
00:000086B0 6000F5D2        	  2671: 	bra Monitor
                            	  2672: 
                            	  2673: ;------------------------------------------------------------------------------
                            	  2674: ; Disassemble code
                            	  2675: ; DI 1000
                            	  2676: ;------------------------------------------------------------------------------
                            	  2677: ;        CALLING SEQUENCE:
                            	  2678: ;   D0,D1,D2 = CODE TO BE DISASSEMBLED
                            	  2679: ;   A4 = VALUE OF PROGRAM COUNTER FOR THE CODE
                            	  2680: ;   A5 = POINTER TO STORE DATA (BUFSIZE = 80 ASSUMED)
                            	  2681: ;        JSR       DCODE68K
                            	  2682: ;
                            	  2683: ;        RETURN:
                            	  2684: ;   A4 = VALUE OF PROGRAM COUNTER FOR NEXT INSTRUCTION
                            	  2685: ;   A5 = POINTER TO LINE AS DISASSEMBLED
                            	  2686: ;   A6 = POINTER TO END OF LINE
                            	  2687: 
                            	  2688: 
                            	  2689: cmdDisassemble:
00:000086B4 6100FC04        	  2690: 	bsr ignBlanks
00:000086B8 610001E0        	  2691: 	bsr GetHexNumber
00:000086BC 6700F5C6        	  2692: 	beq Monitor
00:000086C0 363C0014        	  2693: 	move.w #20,d3			; number of lines to disassemble
                            	  2694: .0002:
00:000086C4 2F03            	  2695: 	move.l d3,-(a7)
00:000086C6 2041            	  2696: 	move.l d1,a0
00:000086C8 2841            	  2697: 	move.l d1,a4			; a4 = PC of code
00:000086CA 3018            	  2698: 	move.w (a0)+,d0		; d0 to d2 = bytes of instruction to decode
00:000086CC 4840            	  2699: 	swap d0
00:000086CE 3018            	  2700: 	move.w (a0)+,d0
00:000086D0 3218            	  2701: 	move.w (a0)+,d1		; d0 to d2 = bytes of instruction to decode
00:000086D2 4841            	  2702: 	swap d1
00:000086D4 3218            	  2703: 	move.w (a0)+,d1
00:000086D6 3418            	  2704: 	move.w (a0)+,d2		; d0 to d2 = bytes of instruction to decode
00:000086D8 4842            	  2705: 	swap d2
00:000086DA 3418            	  2706: 	move.w (a0)+,d2
00:000086DC 4BF900040800    	  2707: 	lea _dasmbuf,a5		; a5 = pointer to disassembly buffer
00:000086E2 61001A4E        	  2708: 	bsr DCODE68K	
00:000086E6 383C003E        	  2709: 	move.w #62,d4
                            	  2710: .0001:
00:000086EA 121D            	  2711: 	move.b (a5)+,d1
00:000086EC 61000F4C        	  2712: 	bsr OutputChar
00:000086F0 51CCFFF8        	  2713: 	dbra d4,.0001
00:000086F4 6100EF80        	  2714: 	bsr CRLF
00:000086F8 220C            	  2715: 	move.l a4,d1
00:000086FA 261F            	  2716: 	move.l (a7)+,d3
00:000086FC 51CBFFC6        	  2717: 	dbra d3,.0002
00:00008700 6000F582        	  2718: 	bra Monitor
                            	  2719: 	
                            	  2720: ;------------------------------------------------------------------------------
                            	  2721: ; Do a memory dump of the requested location.
                            	  2722: ; DB 0800 0850
                            	  2723: ;------------------------------------------------------------------------------
                            	  2724: 
                            	  2725: cmdDumpMemory:
00:00008704 6100FBCC        	  2726: 	bsr GetSzChar
00:00008708 6100FBB0        	  2727: 	bsr ignBlanks
00:0000870C 6100018C        	  2728: 	bsr	GetHexNumber
00:00008710 6700F572        	  2729: 	beq	Monitor					; was there a number ? no, other garbage, just ignore
00:00008714 2601            	  2730: 	move.l d1,d3				; save off start of range
00:00008716 6100FBA2        	  2731: 	bsr	ignBlanks
00:0000871A 6100017E        	  2732: 	bsr	GetHexNumber
00:0000871E 6608            	  2733: 	bne.s	DumpMem1
00:00008720 2203            	  2734: 	move.l d3,d1
00:00008722 068100000040    	  2735: 	addi.l #64,d1				;	no end specified, just dump 64 bytes
                            	  2736: DumpMem1:
00:00008728 2043            	  2737: 	move.l d3,a0
00:0000872A 2241            	  2738: 	move.l d1,a1
00:0000872C 6100EF48        	  2739: 	bsr	CRLF
                            	  2740: .0001:
00:00008730 B3C8            	  2741: 	cmpa.l a0,a1
00:00008732 6300F550        	  2742: 	bls	Monitor
00:00008736 6102            	  2743: 	bsr	DisplayMem
00:00008738 60F6            	  2744: 	bra.s	.0001
                            	  2745: 
                            	  2746: ;------------------------------------------------------------------------------
                            	  2747: ; Display memory dump in a format suitable for edit.
                            	  2748: ;
                            	  2749: ;	EB 12345678 00 11 22 33 44 55 66 77  "........"
                            	  2750: ;
                            	  2751: ; Modifies:
                            	  2752: ;		d1,d2,a0
                            	  2753: ;------------------------------------------------------------------------------
                            	  2754: 	
                            	  2755: DisplayMem:
00:0000873A 123C0045        	  2756: 	move.b #'E',d1
00:0000873E 61000EFA        	  2757: 	bsr	OutputChar
00:00008742 1204            	  2758: 	move.b d4,d1
00:00008744 61000EF4        	  2759: 	bsr OutputChar
00:00008748 61000722        	  2760: 	bsr DisplaySpace
00:0000874C 2208            	  2761: 	move.l a0,d1
00:0000874E 61000724        	  2762: 	bsr	DisplayTetra
00:00008752 7407            	  2763: 	moveq #7,d2						; assume bytes
00:00008754 0C04004C        	  2764: 	cmpi.b #'L',d4
00:00008758 6604            	  2765: 	bne.s .0004
00:0000875A 7401            	  2766: 	moveq	#1,d2
00:0000875C 6008            	  2767: 	bra.s dspmem1
                            	  2768: .0004:
00:0000875E 0C040057        	  2769: 	cmpi.b #'W',d4
00:00008762 6602            	  2770: 	bne.s dspmem1
00:00008764 7403            	  2771: 	moveq #3,d2
                            	  2772: dspmem1:
00:00008766 123C0020        	  2773: 	move.b #' ',d1
00:0000876A 61000ECE        	  2774: 	bsr	OutputChar
00:0000876E 0C04004C        	  2775: 	cmpi.b #'L',d4
00:00008772 6608            	  2776: 	bne.s .0005
00:00008774 2218            	  2777: 	move.l (a0)+,d1
00:00008776 610006FC        	  2778: 	bsr	DisplayTetra
00:0000877A 6014            	  2779: 	bra.s .0006
                            	  2780: .0005:
00:0000877C 0C040057        	  2781: 	cmpi.b #'W',d4
00:00008780 6608            	  2782: 	bne.s .0007
00:00008782 3218            	  2783: 	move.w (a0)+,d1
00:00008784 610006F4        	  2784: 	bsr	DisplayWyde
00:00008788 6006            	  2785: 	bra.s .0006
                            	  2786: .0007:
00:0000878A 1218            	  2787: 	move.b (a0)+,d1
00:0000878C 610006F2        	  2788: 	bsr DisplayByte
                            	  2789: .0006:
00:00008790 51CAFFD4        	  2790: 	dbra d2,dspmem1
00:00008794 610006C4        	  2791: 	bsr	DisplayTwoSpaces
00:00008798 123C0022        	  2792: 	move.b #34,d1
00:0000879C 61000E9C        	  2793: 	bsr	OutputChar
00:000087A0 5188            	  2794: 	lea	-8(a0),a0
00:000087A2 7407            	  2795: 	moveq	#7,d2
                            	  2796: .0002:
00:000087A4 1218            	  2797: 	move.b (a0)+,d1
00:000087A6 B23C0020        	  2798: 	cmp.b	#' ',d1
00:000087AA 6506            	  2799: 	blo.s	.0003
00:000087AC B23C007F        	  2800: 	cmp.b	#127,d1
00:000087B0 6304            	  2801: 	bls.s	.0001
                            	  2802: .0003:
00:000087B2 123C002E        	  2803: 	move.b #'.',d1
                            	  2804: .0001:
00:000087B6 61000E82        	  2805: 	bsr	OutputChar
00:000087BA 51CAFFE8        	  2806: 	dbra d2,.0002
00:000087BE 123C0022        	  2807: 	move.b #34,d1
00:000087C2 61000E76        	  2808: 	bsr	OutputChar
00:000087C6 610080E6        	  2809: 	bsr	CheckForCtrlC
00:000087CA 6000EEAA        	  2810: 	bra	CRLF
                            	  2811: 
                            	  2812: ;------------------------------------------------------------------------------
                            	  2813: ; Dump Registers
                            	  2814: ;    The dump is in a format that allows the register value to be edited.
                            	  2815: ;
                            	  2816: ; RegD0 12345678
                            	  2817: ; RegD1 77777777
                            	  2818: ;	... etc
                            	  2819: ;------------------------------------------------------------------------------
                            	  2820: 
                            	  2821: cmdDumpRegs:
00:000087CE 6100EEA6        	  2822: 	bsr	CRLF
00:000087D2 363C000F        	  2823: 	move.w #15,d3						; number of registers-1
00:000087D6 41FA007A        	  2824: 	lea	msg_reglist,a0			;
00:000087DA 43FA0072        	  2825: 	lea	msg_regs,a1
00:000087DE 45F900040100    	  2826: 	lea	Regsave,a2					; a2 points to register save area
                            	  2827: .0001:
00:000087E4 6100EEAA        	  2828: 	bsr			DisplayString
00:000087E8 1218            	  2829: 	move.b	(a0)+,d1
00:000087EA 61000E4E        	  2830: 	bsr			OutputChar
00:000087EE 1218            	  2831: 	move.b	(a0)+,d1
00:000087F0 61000E48        	  2832: 	bsr			OutputChar
00:000087F4 61000676        	  2833: 	bsr			DisplaySpace
00:000087F8 221A            	  2834: 	move.l	(a2)+,d1
00:000087FA 61000678        	  2835: 	bsr			DisplayTetra
00:000087FE 6100EE76        	  2836: 	bsr			CRLF
00:00008802 51CBFFE0        	  2837: 	dbra		d3,.0001
00:00008806 6100EE88        	  2838: 	bsr			DisplayString
00:0000880A 1218            	  2839: 	move.b	(a0)+,d1
00:0000880C 61000E2C        	  2840: 	bsr			OutputChar
00:00008810 1218            	  2841: 	move.b	(a0)+,d1
00:00008812 61000E26        	  2842: 	bsr			OutputChar
00:00008816 61000654        	  2843: 	bsr			DisplaySpace
00:0000881A 223900040144    	  2844: 	move.l	Regsave+$44,d1
00:00008820 61000652        	  2845: 	bsr			DisplayTetra
00:00008824 6100EE50        	  2846: 	bsr			CRLF
00:00008828 6100EE66        	  2847: 	bsr			DisplayString
00:0000882C 1218            	  2848: 	move.b	(a0)+,d1
00:0000882E 61000E0A        	  2849: 	bsr			OutputChar
00:00008832 1218            	  2850: 	move.b	(a0)+,d1
00:00008834 61000E04        	  2851: 	bsr			OutputChar
00:00008838 61000632        	  2852: 	bsr			DisplaySpace
00:0000883C 323900040140    	  2853: 	move.w	Regsave+$40,d1
00:00008842 61000636        	  2854: 	bsr			DisplayWyde
00:00008846 6100EE2E        	  2855: 	bsr			CRLF
00:0000884A 6000F438        	  2856: 	bra			Monitor
                            	  2857: 
                            	  2858: msg_regs:
00:0000884E 526567          	  2859: 	dc.b	"Reg",0
00:00008851 00
                            	  2860: msg_reglist:
00:00008852 4430443144324433	  2861: 	dc.b	"D0D1D2D3D4D5D6D7A0A1A2A3A4A5A6A7PCSR",0
00:0000885A 4434443544364437
00:00008862 4130413141324133
00:0000886A 4134413541364137
00:00008872 50435352
00:00008876 00
                            	  2862: 
                            	  2863: 	align	1
                            	  2864: 
                            	  2865: ;------------------------------------------------------------------------------
                            	  2866: ;------------------------------------------------------------------------------
                            	  2867: 
                            	  2868: cmdTestSerialReceive:
                            	  2869: .0002:
00:00008878 7024            	  2870: 	moveq		#36,d0				; serial get char from buffer
00:0000887A 4E4F            	  2871: 	trap		#15
                            	  2872: ;	bsr			SerialPeekCharDirect
00:0000887C 4A41            	  2873: 	tst.w		d1
00:0000887E 6B0A            	  2874: 	bmi.s		.0001
00:00008880 0C01001A        	  2875: 	cmpi.b	#CTRLZ,d1
00:00008884 670A            	  2876: 	beq			.0003
00:00008886 61000DB2        	  2877: 	bsr			OutputChar
                            	  2878: .0001:	
00:0000888A 61008022        	  2879: 	bsr			CheckForCtrlC
00:0000888E 60E8            	  2880: 	bra			.0002
                            	  2881: .0003:
00:00008890 4EB9000006B4    	  2882: 	bsr			_KeybdInit
00:00008896 6000F3EC        	  2883: 	bra			Monitor
                            	  2884: 
                            	  2885: ;------------------------------------------------------------------------------
                            	  2886: ; Get a hexidecimal number. Maximum of eight digits.
                            	  2887: ;
                            	  2888: ; Returns:
                            	  2889: ;		d0 = number of digits
                            	  2890: ;		d1 = value of number
                            	  2891: ;		zf = number of digits == 0
                            	  2892: ;------------------------------------------------------------------------------
                            	  2893: 
                            	  2894: GetHexNumber:
00:0000889A 2F02            	  2895: 	move.l d2,-(a7)
00:0000889C 7400            	  2896: 	clr.l	d2
00:0000889E 7000            	  2897: 	moveq	#0,d0
                            	  2898: .0002
00:000088A0 6100F3CE        	  2899: 	bsr	FromScreen
00:000088A4 6100057A        	  2900: 	bsr	AsciiToHexNybble
00:000088A8 0C0100FF        	  2901: 	cmpi.b #$ff,d1
00:000088AC 6712            	  2902: 	beq.s	.0001
00:000088AE E98A            	  2903: 	lsl.l	#4,d2
00:000088B0 02810000000F    	  2904: 	andi.l #$0f,d1
00:000088B6 8481            	  2905: 	or.l d1,d2
00:000088B8 5240            	  2906: 	addq #1,d0
00:000088BA 0C000008        	  2907: 	cmpi.b #8,d0
00:000088BE 65E0            	  2908: 	blo.s	.0002
                            	  2909: .0001
00:000088C0 2202            	  2910: 	move.l d2,d1
00:000088C2 241F            	  2911: 	move.l (a7)+,d2
00:000088C4 4A00            	  2912: 	tst.b	d0
00:000088C6 4E75            	  2913: 	rts	
                            	  2914: 
                            	  2915: GetDecNumber:
00:000088C8 48E73000        	  2916: 	movem.l d2/d3,-(a7)
00:000088CC 7400            	  2917: 	clr.l d2
00:000088CE 7000            	  2918: 	clr.l d0
                            	  2919: .0002
00:000088D0 6100F39E        	  2920: 	bsr FromScreen					; grab a character off the screen
00:000088D4 6100054A        	  2921: 	bsr	AsciiToHexNybble		; convert to an ascii nybble
00:000088D8 0C0100FF        	  2922: 	cmpi.b #$ff,d1
00:000088DC 6718            	  2923: 	beq.s	.0001
00:000088DE 02810000000F    	  2924: 	andi.l #$0F,d1					; d1 = 0 to 9
00:000088E4 2602            	  2925: 	move.l d2,d3						; d3 = current number
00:000088E6 D683            	  2926: 	add.l d3,d3							; d3*2
00:000088E8 E78A            	  2927: 	lsl.l #3,d2							; current number * 8
00:000088EA D483            	  2928: 	add.l d3,d2							; current number * 10
00:000088EC D481            	  2929: 	add.l d1,d2							; add in new digit
00:000088EE 5240            	  2930: 	addq #1,d0							; increment number of digits
00:000088F0 0C000009        	  2931: 	cmpi.b #9,d0						; make sure 9 or fewer
00:000088F4 65DA            	  2932: 	blo .0002
                            	  2933: .0001
00:000088F6 2202            	  2934: 	move.l d2,d1						; return number in d1
00:000088F8 4CDF000C        	  2935: 	movem.l (a7)+,d2/d3
00:000088FC 4A00            	  2936: 	tst.b d0
00:000088FE 4E75            	  2937: 	rts
                            	  2938: 	
                            	  2939: 	include "FloatToString.x68"

Source: "FloatToString.x68"
                            	     1: 	code
                            	     2: ;==============================================================================
                            	     3: ; Decimal-Floating point to string conversion routine.
                            	     4: ;
                            	     5: ; Modifies
                            	     6: ;		_fpWork work area
                            	     7: ; Register Usage:
                            	     8: ; 	fp0 = input decimal-float to convert
                            	     9: ;		fp1 = constant holder, 1.0, 10.0
                            	    10: ;		fp2 = 1.0e<fp0 exponent> value for conversion
                            	    11: ;		fp3 = holds digit value during significand conversion
                            	    12: ; 	a0 = pointer to string buffer, updated to point to NULL at end of string
                            	    13: ;		a1 = pointer to "Nan" or "Inf" message string
                            	    14: ;		d0 = temporary
                            	    15: ;		d1 = digit value during exponent, significand conversion
                            	    16: ; 	d6 = exponent
                            	    17: ;==============================================================================
                            	    18: 	align 4
00:00008900 25FF0000        	    19: _dfOne	dc.l $25ff0000,$00000000,$00000000
00:00008904 00000000
00:00008908 00000000
00:0000890C 2600C000        	    20: _dfTen	dc.l $2600C000,$00000000,$00000000
00:00008910 00000000
00:00008914 00000000
00:00008918 2606DDFA        	    21: _dfMil  dc.l $2606DDFA,$1C000000,$00000000
00:0000891C 1C000000
00:00008920 00000000
                            	    22: 
00:00008924 4E614E          	    23: _msgNan	dc.b "NaN",0
00:00008927 00
00:00008928 496E66          	    24: _msgInf dc.b "Inf",0
00:0000892B 00
                            	    25: 	even
                            	    26: 
                            	    27: ;------------------------------------------------------------------------------
                            	    28: ; Check for the special Nan and infinity values. Output the appropriate string.
                            	    29: ;
                            	    30: ; Modifies
                            	    31: ;		_fpWork area
                            	    32: ;		a0
                            	    33: ; Parameters:
                            	    34: ;		fp0 = dbl
                            	    35: ;------------------------------------------------------------------------------
                            	    36: 
                            	    37: _CheckNan:
00:0000892C 4E52FFF4        	    38: 	link a2,#-12
00:00008930 48D70201        	    39: 	movem.l d0/a1,(sp)
00:00008934 2F79000400980008	    40: 	move.l _canary,8(sp)
00:0000893C F239680000040600	    41: 	fmove.x fp0,_fpWork
00:00008944 103900040600    	    42: 	move.b _fpWork,d0				; get sign+combo
00:0000894A 0200007C        	    43: 	andi.b #$7C,d0					; mask for combo bits
00:0000894E 0C00007C        	    44: 	cmpi.b #$7C,d0					; is it the Nan combo?
00:00008952 6606            	    45: 	bne .notNan
00:00008954 43FAFFCE        	    46: 	lea _msgNan,a1					; output "Nan"
00:00008958 600A            	    47: 	bra .outStr
                            	    48: .notNan
00:0000895A 0C000078        	    49: 	cmpi.b #$78,d0					; is it infinity combo?
00:0000895E 661E            	    50: 	bne .notInf
00:00008960 43FAFFC6        	    51: 	lea _msgInf,a1
                            	    52: .outStr
00:00008964 10D9            	    53: 	move.b (a1)+,(a0)+			; output "Inf"
00:00008966 10D9            	    54: 	move.b (a1)+,(a0)+
00:00008968 10D9            	    55: 	move.b (a1)+,(a0)+
00:0000896A 4210            	    56: 	clr.b (a0)
00:0000896C 4CD70201        	    57: 	movem.l (sp),d0/a1
00:00008970 A2AF00030008    	    58: 	cchk 8(sp)
00:00008976 4E5A            	    59: 	unlk a2
00:00008978 003C0001        	    60: 	ori #1,ccr							; set carry and return
00:0000897C 4E75            	    61: 	rts
                            	    62: .notInf
00:0000897E 4CD70201        	    63: 	movem.l (sp),d0/a1
00:00008982 A2AF00030008    	    64: 	cchk 8(sp)
00:00008988 4E5A            	    65: 	unlk a2
00:0000898A 023C00FE        	    66: 	andi #$FE,ccr						; clear carry and return
00:0000898E 4E75            	    67: 	rts
                            	    68: 
                            	    69: ;------------------------------------------------------------------------------
                            	    70: ; Check for a zero value. Output a single "0" if zero,
                            	    71: ;
                            	    72: ; Modifies:
                            	    73: ;		a0
                            	    74: ; Parameters:
                            	    75: ;		fp0 = dbl
                            	    76: ;------------------------------------------------------------------------------
                            	    77: 
                            	    78: _CheckZero:
00:00008990 F200003A        	    79: 	ftst fp0								; check if number is zero
00:00008994 F28E000E        	    80: 	fbne .0003
00:00008998 10FC0030        	    81: 	move.b #'0',(a0)+				; if zero output "0"
00:0000899C 4210            	    82: 	clr.b (a0)
00:0000899E 003C0004        	    83: 	ori #4,ccr							; set zf
00:000089A2 4E75            	    84: 	rts
                            	    85: .0003
00:000089A4 023C00FB        	    86: 	andi #$FB,ccr						; clear zf
00:000089A8 4E75            	    87: 	rts
                            	    88: 
                            	    89: ;------------------------------------------------------------------------------
                            	    90: ; Check for a negative number. This includes Nans and Infinities. Output a "-"
                            	    91: ; if negative.
                            	    92: ;
                            	    93: ;	Modifies
                            	    94: ;		a0
                            	    95: ; Parameters:
                            	    96: ;		fp0 = dbl
                            	    97: ;------------------------------------------------------------------------------
                            	    98: 
                            	    99: _CheckNegative:
00:000089AA F200003A        	   100: 	ftst fp0								; is number negative?
00:000089AE F293000A        	   101: 	fbge .0002
00:000089B2 10FC002D        	   102: 	move.b #'-',(a0)+				; yes, output '-'
00:000089B6 F200001A        	   103: 	fneg fp0								; make fp0 positive
                            	   104: .0002
00:000089BA 4E75            	   105: 	rts
                            	   106: 
                            	   107: ;------------------------------------------------------------------------------
                            	   108: ; Make the input value larger so that digits may appear before the decimal
                            	   109: ; point.
                            	   110: ;
                            	   111: ; Modifies:
                            	   112: ;		fp0,fp1,d6
                            	   113: ; Parameters:
                            	   114: ;		fp0 = dbl
                            	   115: ;------------------------------------------------------------------------------
                            	   116: 
                            	   117: ;	if (dbl < 1.0) {
                            	   118: ;		while (dbl < 1.0) {
                            	   119: ;			dbl *= 1000000.0;
                            	   120: ;			exp -= 6;  
                            	   121: ;		}
                            	   122: ;	}
                            	   123: 
                            	   124: _MakeBig:
00:000089BC F23C50800001    	   125: 	fmove.w #1,fp1
                            	   126: .0002
00:000089C2 F2000438        	   127: 	fcmp fp1,fp0						; is fp0 > 1?
00:000089C6 F293000E        	   128: 	fbge .0001							; yes, return
00:000089CA F23C402600000006	   129: 	fscale.l #6,fp0					; multiply fp0 by a million
00:000089D2 5D46            	   130: 	subi.w #6,d6						; decrement exponent by six
00:000089D4 60EC            	   131: 	bra .0002								; keep trying until number is > 1
                            	   132: .0001
00:000089D6 4E75            	   133: 	rts
                            	   134: 	
                            	   135: ;------------------------------------------------------------------------------
                            	   136: ;	Create a number dbl2 on the same order of magnitude as dbl, but
                            	   137: ;	less than dbl. The number will be 1.0e<dbl's exponent>
                            	   138: ;
                            	   139: ; Modifies:
                            	   140: ;		d6,fp2
                            	   141: ; Parameters:
                            	   142: ;		fp0 = dbl
                            	   143: ;------------------------------------------------------------------------------
                            	   144: 
                            	   145: ;	// The following is similar to using log10() and pow() functions.
                            	   146: ;	// Now dbl is >= 1.0
                            	   147: ;	// Create a number dbl2 on the same order of magnitude as dbl, but
                            	   148: ;	// less than dbl.
                            	   149: ;	dbl2 = 1.0;
                            	   150: ;	dbla = dbl2;
                            	   151: ;	if (dbl > dbl2) {	// dbl > 1.0 ?
                            	   152: ;		while (dbl2 <= dbl) {
                            	   153: ;			dbla = dbl2;
                            	   154: ;			dbl2 *= 10.0;	// increase power of 10
                            	   155: ;			exp++;
                            	   156: ;		}
                            	   157: ;		// The above loop goes one too far, we want the last value less
                            	   158: ;		// than dbl.
                            	   159: ;		dbl2 = dbla;
                            	   160: ;		exp--;
                            	   161: ;	}
                            	   162: 
                            	   163: _LessThanDbl:
00:000089D8 F23C51000001    	   164: 	fmove.w #1,fp2			; setup fp2 = 1
00:000089DE F2000838        	   165: 	fcmp fp2,fp0				; if (dbl > dbl2)
00:000089E2 F295001E        	   166: 	fble .0004
                            	   167: .0006
00:000089E6 F2000138        	   168: 	fcmp fp0,fp2				; while (dbl2 <= dbl)
00:000089EA F292000C        	   169: 	fbgt .0005
00:000089EE F23C51260001    	   170: 	fscale.w #1,fp2			; dbl2 *= 10 (increase exponent by one)
00:000089F4 5246            	   171: 	addi.w #1,d6				; exp++
00:000089F6 60EE            	   172: 	bra .0006
                            	   173: .0005
00:000089F8 F23C4126FFFFFFFF	   174: 	fscale.l #-1,fp2		; dbl2 /= 10 (decrease exponent by one)
00:00008A00 5346            	   175: 	subi.w #1,d6				; exp--;
                            	   176: .0004	
                            	   177: ;	fmove.x fp0,_fpWork	; debugging
                            	   178: ;	fmove.x fp2,_fpWork+12
00:00008A02 4E75            	   179: 	rts
                            	   180: 
                            	   181: ;------------------------------------------------------------------------------
                            	   182: ; Compute the number of digits before the decimal point.
                            	   183: ;
                            	   184: ; Modifies:
                            	   185: ;		d0,d6,_digits_before_decpt
                            	   186: ; Parameters:
                            	   187: ;		d6 = exponent
                            	   188: ;------------------------------------------------------------------------------
                            	   189: 
                            	   190: ; if (exp >= 0 && exp < 6) {
                            	   191: ;   digits_before_decpt = exp+1;
                            	   192: ;		exp = 0;
                            	   193: ;	}
                            	   194: ;	else if (exp >= -7)
                            	   195: ;		digits_before_decpt = 1;
                            	   196: ;	else
                            	   197: ;		digits_before_decpt = -1;
                            	   198: 
                            	   199: _ComputeDigitsBeforeDecpt:
00:00008A04 2F00            	   200: 	move.l d0,-(a7)
00:00008A06 4A46            	   201: 	tst.w d6
00:00008A08 6B16            	   202: 	bmi .0007
00:00008A0A 0C460006        	   203: 	cmpi.w #6,d6
00:00008A0E 6C10            	   204: 	bge .0007
00:00008A10 3006            	   205: 	move.w d6,d0
00:00008A12 5240            	   206: 	addi.w #1,d0
00:00008A14 33C000040510    	   207: 	move.w d0,_digits_before_decpt	
00:00008A1A 4246            	   208: 	clr.w d6
00:00008A1C 201F            	   209: 	move.l (a7)+,d0
00:00008A1E 4E75            	   210: 	rts
                            	   211: .0007
00:00008A20 0C46FFF9        	   212: 	cmpi.w #-7,d6
00:00008A24 6D0C            	   213: 	blt .0009
00:00008A26 33FC000100040510	   214: 	move.w #1,_digits_before_decpt
00:00008A2E 201F            	   215: 	move.l (a7)+,d0
00:00008A30 4E75            	   216: 	rts
                            	   217: .0009
00:00008A32 33FCFFFF00040510	   218: 	move.w #-1,_digits_before_decpt
00:00008A3A 201F            	   219: 	move.l (a7)+,d0
00:00008A3C 4E75            	   220: 	rts
                            	   221: 
                            	   222: ;------------------------------------------------------------------------------
                            	   223: ;	Spit out a leading zero before the decimal point for a small number.
                            	   224: ;
                            	   225: ; Modifies:
                            	   226: ;		a0
                            	   227: ; Parameters:
                            	   228: ;		d6 = exponent
                            	   229: ;------------------------------------------------------------------------------
                            	   230: 
                            	   231: ;  if (exp < -7) {
                            	   232: ;		 buf[ndx] = '0';
                            	   233: ;		 ndx++;
                            	   234: ;    buf[ndx] = '.';
                            	   235: ;    ndx++;
                            	   236: ;  }
                            	   237: 
                            	   238: _LeadingZero:
00:00008A3E 0C46FFF9        	   239: 	cmpi.w #-7,d6
00:00008A42 6C08            	   240: 	bge .0010
00:00008A44 10FC0030        	   241: 	move.b #'0',(a0)+
00:00008A48 10FC002E        	   242: 	move.b #'.',(a0)+
                            	   243: .0010
00:00008A4C 4E75            	   244: 	rts
                            	   245: 
                            	   246: ;------------------------------------------------------------------------------
                            	   247: ; Extract the digits of the significand.
                            	   248: ;
                            	   249: ; Modifies:
                            	   250: ;		_precision variable
                            	   251: ; Register Usage
                            	   252: ;		d0 = counter
                            	   253: ;		d1 = digit
                            	   254: ;		fp0 = dbl
                            	   255: ;		fp2 = dbl2
                            	   256: ;		fp3 = digit as decimal float
                            	   257: ;		fp7 = dbla
                            	   258: ; Parameters:
                            	   259: ;		fp0, fp2
                            	   260: ;------------------------------------------------------------------------------
                            	   261: 
                            	   262: ;	// Now loop processing one digit at a time.
                            	   263: ;  for (nn = 0; nn < 25 && precision > 0; nn++) {
                            	   264: ;    digit = 0;
                            	   265: ;		dbla = dbl;
                            	   266: ;		// dbl is on the same order of magnitude as dbl2 so
                            	   267: ;		// a repeated subtract can be used to find the digit.
                            	   268: ;    while (dbl >= dbl2) {
                            	   269: ;      dbl -= dbl2;
                            	   270: ;      digit++;
                            	   271: ;    }
                            	   272: ;    buf[ndx] = digit + '0';
                            	   273: ;		// Now go back and perform just a single subtract and
                            	   274: ;		// a multiply to find out how much to reduce dbl by.
                            	   275: ;		// This should improve the accuracy
                            	   276: ;		if (digit > 2)
                            	   277: ;			dbl = dbla - dbl2 * digit;
                            	   278: ;    ndx++;
                            	   279: ;    digits_before_decpt--;
                            	   280: ;    if (digits_before_decpt==0) {
                            	   281: ;			buf[ndx] = '.';
                            	   282: ;			ndx++;
                            	   283: ;    }
                            	   284: ;    else if (digits_before_decpt < 0)
                            	   285: ;      precision--;
                            	   286: ;		// Shift the next digit to be tested into position.
                            	   287: ;    dbl *= 10.0;
                            	   288: ;  }
                            	   289: 	
                            	   290: _SpitOutDigits:
00:00008A4E 4E52FFE8        	   291: 	link a2,#-24
00:00008A52 2F79000400980014	   292: 	move.l _canary,20(sp)
00:00008A5A F2176B80        	   293: 	fmove.x fp7,(sp)
00:00008A5E 48EF0003000C    	   294: 	movem.l d0/d1,12(sp)
00:00008A64 303C0018        	   295: 	move.w #24,d0			; d0 = nn
                            	   296: .0017	
00:00008A68 4AB900040514    	   297: 	tst.l _precision
00:00008A6E 6F46            	   298: 	ble .0011
00:00008A70 7200            	   299: 	moveq #0,d1				; digit = 0
00:00008A72 F2000380        	   300: 	fmove fp0,fp7			; dbla = dbl
                            	   301: .0013
00:00008A76 F2000838        	   302: 	fcmp fp2,fp0
00:00008A7A F294000A        	   303: 	fblt .0012
00:00008A7E F2000828        	   304: 	fsub fp2,fp0			; dbl -= dbl2
00:00008A82 5201            	   305: 	addi.b #1,d1			; digit++
00:00008A84 60F0            	   306: 	bra .0013
                            	   307: .0012
00:00008A86 06010030        	   308: 	addi.b #'0',d1		; convert digit to ascii
00:00008A8A 10C1            	   309: 	move.b d1,(a0)+		; and store
00:00008A8C 04010030        	   310: 	subi.b #'0',d1		; d1 = binary digit again
                            	   311: ;	cmpi.b #2,d1
                            	   312: ;	ble .0014
                            	   313: 
                            	   314: ;	ext.w d1
                            	   315: ;	ext.l d1
                            	   316: ;	fmove.l d1,fp3		; fp3 = digit
                            	   317: ;	fmul fp2,fp3			; fp3 = dbl2 * digit
                            	   318: ;	fmove fp7,fp0
                            	   319: ;	fsub fp3,fp0			; dbl = dbla - dbl2 * digit
                            	   320: .0014
00:00008A90 537900040510    	   321: 	subi.w #1,_digits_before_decpt
00:00008A96 6604            	   322: 	bne .0015
00:00008A98 10FC002E        	   323: 	move.b #'.',(a0)+
                            	   324: .0015
00:00008A9C 4A7900040510    	   325: 	tst.w _digits_before_decpt
00:00008AA2 6C06            	   326: 	bge .0016
00:00008AA4 53B900040514    	   327: 	subi.l #1,_precision
                            	   328: .0016
00:00008AAA F23C4126FFFFFFFF	   329: 	fscale.l #-1,fp2		; dbl *= 10.0
00:00008AB2 51C8FFB4        	   330: 	dbra d0,.0017
                            	   331: .0011
00:00008AB6 4CEF0003000C    	   332: 	movem.l 12(sp),d0/d1
00:00008ABC F2174B80        	   333: 	fmove.x (sp),fp7
00:00008AC0 A2AF00030014    	   334: 	cchk 20(sp)
00:00008AC6 4E5A            	   335: 	unlk a2
00:00008AC8 4E75            	   336: 	rts
                            	   337: 
                            	   338: ;------------------------------------------------------------------------------
                            	   339: ; If the number ends in a decimal point, trim off the point.
                            	   340: ;
                            	   341: ; Registers Modified:
                            	   342: ;		none
                            	   343: ; Parameters:
                            	   344: ;		a0 = pointer to end of number
                            	   345: ; Returns:
                            	   346: ;		a0 = updated to point just past last digit.
                            	   347: ;------------------------------------------------------------------------------
                            	   348: 
                            	   349: _TrimTrailingPoint:
00:00008ACA 0C28002EFFFF    	   350: 	cmpi.b #'.',-1(a0)
00:00008AD0 6604            	   351: 	bne .0001
00:00008AD2 4220            	   352: 	clr.b -(a0)
00:00008AD4 4E75            	   353: 	rts
                            	   354: .0001
00:00008AD6 0C10002E        	   355: 	cmpi.b #'.',(a0)
00:00008ADA 660A            	   356: 	bne .0002
00:00008ADC 4A280001        	   357: 	cmpi.b #0,1(a0)
00:00008AE0 6604            	   358: 	bne .0002
00:00008AE2 4210            	   359: 	clr.b (a0)
00:00008AE4 5348            	   360: 	subq #1,a0
                            	   361: .0002
00:00008AE6 4E75            	   362: 	rts
                            	   363: 	
                            	   364: ;------------------------------------------------------------------------------
                            	   365: ; If the number ends in .0 get rid of the .0
                            	   366: ;
                            	   367: ; Registers Modified:
                            	   368: ;		none
                            	   369: ; Parameters:
                            	   370: ;		a0 = pointer to last digits of number
                            	   371: ; Returns:
                            	   372: ;		a0 = updated to point just past last digit.
                            	   373: ;------------------------------------------------------------------------------
                            	   374: 
                            	   375: _TrimDotZero:
00:00008AE8 4A10            	   376: 	tst.b (a0)
00:00008AEA 6616            	   377: 	bne .0004
00:00008AEC 0C280030FFFF    	   378: 	cmpi.b #'0',-1(a0)
00:00008AF2 660E            	   379: 	bne .0004
00:00008AF4 0C28002EFFFE    	   380: 	cmpi.b #'.',-2(a0)
00:00008AFA 6606            	   381: 	bne .0004
00:00008AFC 4228FFFE        	   382: 	clr.b -2(a0)
00:00008B00 5548            	   383: 	subq #2,a0
                            	   384: .0004
00:00008B02 4E75            	   385: 	rts
                            	   386: 
                            	   387: ;------------------------------------------------------------------------------
                            	   388: ; Trim trailing zeros from the number. Generally there is no need to display
                            	   389: ; trailing zeros.
                            	   390: ; Turns a number like 652.000000000000000000000 into 650.0
                            	   391: ;
                            	   392: ; Registers Modified:
                            	   393: ;		none
                            	   394: ; Parameters:
                            	   395: ;		a0 = pointer to last digits of number
                            	   396: ; Returns:
                            	   397: ;		a0 = updated to point just past last digit.
                            	   398: ;------------------------------------------------------------------------------
                            	   399: 
                            	   400: ;	// Trim trailing zeros from the number
                            	   401: ;  do {
                            	   402: ;      ndx--;
                            	   403: ;  } while(buf[ndx]=='0');
                            	   404: ;  ndx++;
                            	   405: 
                            	   406: _TrimTrailingZeros:
                            	   407: .0018	
00:00008B04 0C200030        	   408: 	cmpi.b #'0',-(a0)		; if the last digit was a zero, backup
00:00008B08 67FA            	   409: 	beq .0018
00:00008B0A 5248            	   410: 	addq #1,a0					; now advance by one
00:00008B0C 4210            	   411: 	move.b #0,(a0)			; NULL terminate string
00:00008B0E 4E75            	   412: 	rts
                            	   413: 
                            	   414: ;------------------------------------------------------------------------------
                            	   415: ; Output 'e+' or 'e-'
                            	   416: ;
                            	   417: ; Registers Modified:
                            	   418: ;		d6.w (if negative)
                            	   419: ; Parameters:
                            	   420: ;		a0 = pointer to last digits of number
                            	   421: ; Returns:
                            	   422: ;		a0 = updated to point just past '+' or '-'.
                            	   423: ;------------------------------------------------------------------------------
                            	   424: 
                            	   425: ;	// Spit out +/-E
                            	   426: ;  buf[ndx] = E;
                            	   427: ;  ndx++;
                            	   428: ;  if (exp < 0) {
                            	   429: ;    buf[ndx]='-';
                            	   430: ;    ndx++;
                            	   431: ;    exp = -exp;
                            	   432: ;  }
                            	   433: ;  else {
                            	   434: ;		buf[ndx]='+';
                            	   435: ;		ndx++;
                            	   436: ;  }
                            	   437: 
                            	   438: _SpitOutE:	
00:00008B10 10F90004050C    	   439: 	move.b _E,(a0)+
00:00008B16 4A46            	   440: 	tst.w d6
00:00008B18 6C08            	   441: 	bge .0021
00:00008B1A 10FC002D        	   442: 	move.b #'-',(a0)+
00:00008B1E 4446            	   443: 	neg.w d6
00:00008B20 6004            	   444: 	bra .0022
                            	   445: .0021
00:00008B22 10FC002B        	   446: 	move.b #'+',(a0)+
                            	   447: .0022
00:00008B26 4E75            	   448: 	rts
                            	   449: 
                            	   450: ;------------------------------------------------------------------------------
                            	   451: ; Extract a single digit of the exponent. Extract works from the leftmost digit
                            	   452: ; to the rightmost.
                            	   453: ;
                            	   454: ; Register Usage
                            	   455: ;		d2 = history of zeros
                            	   456: ;		d3 = digit
                            	   457: ; Modifies
                            	   458: ;		d2,d6,a0
                            	   459: ; Parameter
                            	   460: ; 	d1.w = power of ten
                            	   461: ;		d6.w = exponent
                            	   462: ;------------------------------------------------------------------------------
                            	   463: 
                            	   464: _ExtExpDigit:
00:00008B28 2F03            	   465: 	move.l d3,-(a7)
00:00008B2A 48C6            	   466: 	ext.l d6				; make d6 a long
00:00008B2C 8CC1            	   467: 	divu d1,d6			; divide by power of ten
00:00008B2E 1606            	   468: 	move.b d6,d3		; d3 = quotient (0 to 9)
00:00008B30 4846            	   469: 	swap d6					; d6 = remainder, setup for next digit
00:00008B32 8403            	   470: 	or.b d3,d2
00:00008B34 4A03            	   471: 	tst.b d3
00:00008B36 6604            	   472: 	bne .0003
00:00008B38 4A02            	   473: 	tst.b d2	
00:00008B3A 6706            	   474: 	beq .0004
                            	   475: .0003
00:00008B3C 06030030        	   476: 	addi.b #'0',d3	; convert to ascii
00:00008B40 10C3            	   477: 	move.b d3,(a0)+
                            	   478: .0004
00:00008B42 261F            	   479: 	move.l (a7)+,d3
00:00008B44 4E75            	   480: 	rts
                            	   481: 
                            	   482: ;------------------------------------------------------------------------------
                            	   483: ; Extract all the digits of the exponent.
                            	   484: ;
                            	   485: ; Register Usage
                            	   486: ;		d1 = power of 10
                            	   487: ;		d2 = history of zeros
                            	   488: ; Parameters
                            	   489: ;		a0 = pointer to string buffer
                            	   490: ;		d6 = exponent
                            	   491: ;------------------------------------------------------------------------------
                            	   492: 
                            	   493: ;	// If the number is times 10^0 don't output the exponent
                            	   494: ;  if (exp==0) {
                            	   495: ;    buf[ndx]='\0';
                            	   496: ;    goto prt;
                            	   497: ;  }
                            	   498: 
                            	   499: _ExtExpDigits:
00:00008B46 2F01            	   500: 	move.l d1,-(a7)
00:00008B48 4A46            	   501: 	tst.w d6							; is exponent zero?
00:00008B4A 671C            	   502: 	beq .0002
00:00008B4C 61C2            	   503: 	bsr _SpitOutE					; exponent is non-zero e+
00:00008B4E 4202            	   504: 	clr.b d2							; d2 = history of zeros
00:00008B50 323C03E8        	   505: 	move.w #1000,d1
00:00008B54 61D2            	   506: 	bsr _ExtExpDigit
00:00008B56 323C0064        	   507: 	move.w #100,d1
00:00008B5A 61CC            	   508: 	bsr _ExtExpDigit
00:00008B5C 323C000A        	   509: 	move.w #10,d1
00:00008B60 61C6            	   510: 	bsr _ExtExpDigit
00:00008B62 323C0001        	   511: 	move.w #1,d1
00:00008B66 61C0            	   512: 	bsr _ExtExpDigit
                            	   513: .0002:
00:00008B68 221F            	   514: 	move.l (a7)+,d1
00:00008B6A 4210            	   515: 	move.b #0,(a0)				; NULL terminate string
00:00008B6C 4E75            	   516: 	rts										; and return
                            	   517: 
                            	   518: ;------------------------------------------------------------------------------
                            	   519: ; Pad the left side of the output string.
                            	   520: ;
                            	   521: ; Modifies:
                            	   522: ;		d0,d1,d2,d3
                            	   523: ;------------------------------------------------------------------------------
                            	   524: 
                            	   525: ;  // pad left
                            	   526: ;  if (width > 0) {
                            	   527: ;    if (ndx < width) {
                            	   528: ;      for (nn = 39; nn >= width-ndx; nn--)
                            	   529: ;        buf[nn] = buf[nn-(width-ndx)];
                            	   530: ;      for (; nn >= 0; nn--)
                            	   531: ;        buf[nn] = ' ';
                            	   532: ;    }
                            	   533: ;  }
                            	   534: 	
                            	   535: _PadLeft:
00:00008B6E 48E7F000        	   536: 	movem.l d0/d1/d2/d3,-(a7)
00:00008B72 4A3900040508    	   537: 	tst.b _width
00:00008B78 6F3E            	   538: 	ble .0041
00:00008B7A 2008            	   539: 	move.l a0,d0
00:00008B7C 90BC00040520    	   540: 	sub.l #_fpBuf,d0	; d0 = ndx
00:00008B82 B03900040508    	   541: 	cmp.b _width,d0
00:00008B88 6C2E            	   542: 	bge .0041
00:00008B8A 323C0031        	   543: 	move.w #49,d1			; d1 = nn
                            	   544: .0040
00:00008B8E 143900040508    	   545: 	move.b _width,d2
00:00008B94 4882            	   546: 	ext.w d2
00:00008B96 9440            	   547: 	sub.w d0,d2				; d2 = width-ndx
00:00008B98 B242            	   548: 	cmp.w d2,d1
00:00008B9A 6D0E            	   549: 	blt .0039
00:00008B9C 3601            	   550: 	move.w d1,d3			; d3 = nn
00:00008B9E 9642            	   551: 	sub.w d2,d3				; d3 = nn-(width-ndx)
00:00008BA0 11B030001000    	   552: 	move.b (a0,d3.w),(a0,d1.w)
00:00008BA6 5341            	   553: 	subi.w #1,d1
00:00008BA8 60E4            	   554: 	bra .0040
                            	   555: .0039
00:00008BAA 4A41            	   556: 	tst.w d1
00:00008BAC 6B0A            	   557: 	bmi .0041
00:00008BAE 11BC00201000    	   558: 	move.b #' ',(a0,d1.w)
00:00008BB4 5341            	   559: 	subi.w #1,d1
00:00008BB6 60F2            	   560: 	bra .0039
                            	   561: .0041
00:00008BB8 4CDF000F        	   562: 	movem.l (a7)+,d0/d1/d2/d3
00:00008BBC 4E75            	   563: 	rts
                            	   564: 
                            	   565: ;------------------------------------------------------------------------------
                            	   566: ; Pad the right side of the output string.
                            	   567: ;
                            	   568: ; Parameters:
                            	   569: ;		a0 = pointer to end of string
                            	   570: ; Modifies:
                            	   571: ;		none
                            	   572: ; Returns:
                            	   573: ;		none
                            	   574: ;------------------------------------------------------------------------------
                            	   575: 
                            	   576: ;  // pad right
                            	   577: ;  if (width < 0) {
                            	   578: ;    width = -width;
                            	   579: ;    while (ndx < width) {
                            	   580: ;      buf[ndx]=' ';
                            	   581: ;      ndx++;
                            	   582: ;    }
                            	   583: ;    buf[ndx]='\0';
                            	   584: ;  }
                            	   585: ;  return (ndx);
                            	   586: 
                            	   587: _PadRight:
00:00008BBE 2F00            	   588: 	move.l d0,-(a7)
00:00008BC0 4A3900040508    	   589: 	tst.b _width
00:00008BC6 6A24            	   590: 	bpl .0042
00:00008BC8 443900040508    	   591: 	neg.b _width
00:00008BCE 2008            	   592: 	move.l a0,d0
00:00008BD0 90BC00040520    	   593: 	sub.l #_fpBuf,d0	; d0 = ndx
                            	   594: .0044
00:00008BD6 B03900040508    	   595: 	cmp.b _width,d0
00:00008BDC 6C0A            	   596: 	bge .0043
00:00008BDE 11BC00200000    	   597: 	move.b #' ',(a0,d0.w)
00:00008BE4 5240            	   598: 	addi.w #1,d0
00:00008BE6 60EE            	   599: 	bra .0044
                            	   600: .0043
00:00008BE8 42300000        	   601: 	move.b #0,(a0,d0.w)
                            	   602: .0042
00:00008BEC 201F            	   603: 	move.l (a7)+,d0
00:00008BEE 4E75            	   604: 	rts
                            	   605: 
                            	   606: ;------------------------------------------------------------------------------
                            	   607: ; Output a string representation of a decimal floating point number to a 
                            	   608: ; buffer.
                            	   609: ;
                            	   610: ; Register Usage
                            	   611: ;		a0 = pointer to string buffer
                            	   612: ;		d6 = exponent
                            	   613: ; Modifies:
                            	   614: ;		a0 = points to end of string
                            	   615: ; Parameters:
                            	   616: ;		fp0 = number to convert
                            	   617: ; Returns:
                            	   618: ;		none
                            	   619: ;------------------------------------------------------------------------------
                            	   620: 
                            	   621: _FloatToString:
00:00008BF0 2F06            	   622: 	move.l d6,-(a7)
00:00008BF2 6100FDB6        	   623: 	bsr _CheckNegative			; is number negative?
00:00008BF6 6100FD98        	   624: 	bsr _CheckZero					; check for zero
00:00008BFA 6732            	   625: 	beq .0001								; branch since already output "0"
00:00008BFC 6100FD2E        	   626: 	bsr _CheckNan						; check for Nan or infinity
00:00008C00 652C            	   627: 	bcs .0001								; branch if nan/inf string output
                            	   628: 	; Now the fun begins
00:00008C02 7C00            	   629: 	clr.l d6								; exponent = 0
00:00008C04 6100FDB6        	   630: 	bsr _MakeBig
00:00008C08 6100FDCE        	   631: 	bsr _LessThanDbl
00:00008C0C 6100FDF6        	   632: 	bsr _ComputeDigitsBeforeDecpt
00:00008C10 6100FE2C        	   633: 	bsr _LeadingZero
00:00008C14 6100FE38        	   634: 	bsr _SpitOutDigits
00:00008C18 6100FEEA        	   635: 	bsr _TrimTrailingZeros
00:00008C1C 6100FEAC        	   636: 	bsr _TrimTrailingPoint
00:00008C20 6100FEC6        	   637: 	bsr _TrimDotZero
00:00008C24 6100FF20        	   638: 	bsr _ExtExpDigits				; extract exponent digits
00:00008C28 6100FF44        	   639: 	bsr _PadLeft						; pad the number to the left or right
00:00008C2C 6190            	   640: 	bsr _PadRight
                            	   641: .0001
00:00008C2E 2C1F            	   642: 	move.l (a7)+,d6
00:00008C30 4E75            	   643: 	rts
                            	   644: 
                            	   645: 

Source: "boot.x68"
                            	  2940: 	include "GetFloat.asm"

Source: "GetFloat.asm"
                            	     1: ; ============================================================================
                            	     2: ;        __
                            	     3: ;   \\__/ o\    (C) 2022  Robert Finch, Waterloo
                            	     4: ;    \  __ /    All rights reserved.
                            	     5: ;     \/_//     robfinch<remove>@opencores.org
                            	     6: ;       ||
                            	     7: ;  
                            	     8: ;
                            	     9: ; BSD 3-Clause License
                            	    10: ; Redistribution and use in source and binary forms, with or without
                            	    11: ; modification, are permitted provided that the following conditions are met:
                            	    12: ;
                            	    13: ; 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: ;    list of conditions and the following disclaimer.
                            	    15: ;
                            	    16: ; 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: ;    this list of conditions and the following disclaimer in the documentation
                            	    18: ;    and/or other materials provided with the distribution.
                            	    19: ;
                            	    20: ; 3. Neither the name of the copyright holder nor the names of its
                            	    21: ;    contributors may be used to endorse or promote products derived from
                            	    22: ;    this software without specific prior written permission.
                            	    23: ;
                            	    24: ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: ; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: ; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: ; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: ; CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: ; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: ;                                                                          
                            	    35: ; ============================================================================
                            	    36: ;
                            	    37: ; Get a floating point number
                            	    38: ;
                            	    39: _GetFloatGetChar:
00:00008C32 1210            	    40: 	move.b (a0),d1
00:00008C34 D1C0            	    41: 	add.l d0,a0
00:00008C36 4E75            	    42: 	rts
                            	    43: _GetFloatIgnBlanks:
                            	    44: .0001
00:00008C38 61F8            	    45: 	bsr _GetFloatGetChar
00:00008C3A 0C010020        	    46: 	cmpi.b #' ',d1
00:00008C3E 67F8            	    47: 	beq .0001
                            	    48: _GetFloatBackupChar:
00:00008C40 91C0            	    49: 	sub.l d0,a0
00:00008C42 4E75            	    50: 	rts
                            	    51: 
                            	    52: ;-------------------------------------------------------------------------------
                            	    53: ; Get fractional part of a number, 25 digits max, into a float register.
                            	    54: ;
                            	    55: ; Register Usage:
                            	    56: ;		d1 = digit from input screen
                            	    57: ;		d4 = digit count
                            	    58: ;		d6 = digit scaling factor
                            	    59: ;		fp1 = digit as float number
                            	    60: ; Returns:
                            	    61: ;		fp0 = fraction
                            	    62: ;-------------------------------------------------------------------------------
                            	    63: 
                            	    64: _GetFraction:
00:00008C44 4E52FFE4        	    65: 	link a2,#-28
00:00008C48 2F79000400980018	    66: 	move.l _canary,24(sp)
00:00008C50 48D70052        	    67: 	movem.l d1/d4/d6,(sp)
00:00008C54 F22F6880000C    	    68: 	fmove.x fp1,12(sp)
00:00008C5A 7C00            	    69: 	clr.l d6							; d6 = scale factor
00:00008C5C F23C50000000    	    70: 	fmove.w #0,fp0				; fract = 0.0
00:00008C62 7818            	    71: 	moveq #24,d4
                            	    72: .0002
00:00008C64 61CC            	    73: 	bsr _GetFloatGetChar
00:00008C66 0C010030        	    74: 	cmpi.b #'0',d1
00:00008C6A 6520            	    75: 	blo .0001
00:00008C6C 0C010039        	    76: 	cmpi.b #'9',d1				; make sure between 0 and 9
00:00008C70 621A            	    77: 	bhi .0001
00:00008C72 04010030        	    78: 	subi.b #'0',d1
00:00008C76 F23C50260001    	    79: 	fscale.w #1,fp0				; fract * 10.0
00:00008C7C 5246            	    80: 	addq #1,d6						; record scaling
00:00008C7E F2015880        	    81: 	fmove.b d1,fp1				; fp1 = digit
00:00008C82 F2000422        	    82: 	fadd fp1,fp0					; fract += digit
00:00008C86 5245            	    83: 	addq.w #1,d5					; increment number of digits in number
00:00008C88 51CCFFDA        	    84: 	dbra d4,.0002
                            	    85: .0001
00:00008C8C 61B2            	    86: 	bsr _GetFloatBackupChar
00:00008C8E 4446            	    87: 	neg d6
00:00008C90 F2064026        	    88: 	fscale.l d6,fp0				; fract /= scale
00:00008C94 4CD70052        	    89: 	movem.l (sp),d1/d4/d6
00:00008C98 F22F4880000C    	    90: 	fmove.x 12(sp),fp1
00:00008C9E A2AF00030018    	    91: 	cchk 24(sp)
00:00008CA4 4E5A            	    92: 	unlk a2
00:00008CA6 4E75            	    93: 	rts
                            	    94: 
                            	    95: ;-------------------------------------------------------------------------------
                            	    96: ; Get exponent part of a number, 4 digits max, into a float register.
                            	    97: ;
                            	    98: ; Register Usage:
                            	    99: ;		d1 = digit from input screen
                            	   100: ;		d2 = exponent
                            	   101: ;		d3 = temp, number times 2
                            	   102: ;		d4 = digit counter
                            	   103: ; Parameters:
                            	   104: ;		fp0 = float number
                            	   105: ; Returns:
                            	   106: ;		fp0 = float number with exponent factored in
                            	   107: ;-------------------------------------------------------------------------------
                            	   108: 
                            	   109: _GetExponent:
00:00008CA8 4E52FFE0        	   110: 	link a2,#-32
00:00008CAC 2F7900040098001C	   111: 	move.l _canary,28(sp)
00:00008CB4 48D7001E        	   112: 	movem.l d1/d2/d3/d4,(sp)
00:00008CB8 F22F69000010    	   113: 	fmove.x fp2,16(sp)
00:00008CBE 7400            	   114: 	clr.l d2							; d2 = number = 0
00:00008CC0 F23C51000000    	   115: 	fmove.w #0,fp2				; fp2 = exp = 0.0
00:00008CC6 7601            	   116: 	moveq #1,d3						; d3 = exscale = 1
00:00008CC8 6100FF68        	   117: 	bsr _GetFloatGetChar
00:00008CCC 0C01002D        	   118: 	cmpi.b #'-',d1
00:00008CD0 6608            	   119: 	bne .0001
00:00008CD2 4483            	   120: 	neg.l d3							; exscale = -1
                            	   121: .0006
00:00008CD4 6100FF62        	   122: 	bsr _GetFloatIgnBlanks
00:00008CD8 600A            	   123: 	bra .0002
                            	   124: .0001
00:00008CDA 0C01002B        	   125: 	cmpi.b #'+',d1
00:00008CDE 67F4            	   126: 	beq .0006
00:00008CE0 6100FF5E        	   127: 	bsr _GetFloatBackupChar
                            	   128: .0002	
00:00008CE4 7803            	   129: 	moveq #3,d4						; d4 = max 4 digits
                            	   130: .0004
00:00008CE6 6100FF4A        	   131: 	bsr _GetFloatGetChar	; d1 = digit char
00:00008CEA 0C010030        	   132: 	cmpi.b #'0',d1
00:00008CEE 651E            	   133: 	blo .0003
00:00008CF0 0C010039        	   134: 	cmpi.b #'9',d1				; ensure between 0 and 9
00:00008CF4 6218            	   135: 	bhi .0003
00:00008CF6 04010030        	   136: 	subi.b #'0',d1
00:00008CFA D482            	   137: 	add.l d2,d2						; number *2
00:00008CFC 2602            	   138: 	move.l d2,d3
00:00008CFE E58A            	   139: 	lsl.l #2,d2						; number *8
00:00008D00 D483            	   140: 	add.l d3,d2						; number *10	
00:00008D02 4881            	   141: 	ext.w d1
00:00008D04 48C1            	   142: 	ext.l d1
00:00008D06 D481            	   143: 	add.l d1,d2						; number + digit
00:00008D08 5245            	   144: 	addq.w #1,d5					; increment number of digits in number
00:00008D0A 51CCFFDA        	   145: 	dbra d4,.0004
                            	   146: .0003
00:00008D0E 6100FF30        	   147: 	bsr _GetFloatBackupChar	; backup a character
00:00008D12 C4C3            	   148: 	mulu d3,d2						; *1 or *-1
00:00008D14 48C2            	   149: 	ext.l d2
00:00008D16 F2024126        	   150: 	fscale.l d2,fp2				; exp * exmul
00:00008D1A F2000823        	   151: 	fmul fp2,fp0					; rval *= exp
00:00008D1E 4CD7001E        	   152: 	movem.l (sp),d1/d2/d3/d4
00:00008D22 F22F49000010    	   153: 	fmove.x 16(sp),fp2
00:00008D28 A2AF0003001C    	   154: 	cchk 28(sp)
00:00008D2E 4E5A            	   155: 	unlk a2
00:00008D30 4E75            	   156: 	rts	
                            	   157: 
                            	   158: ;-------------------------------------------------------------------------------
                            	   159: ; Get an integer number, positive or negative, 25 digits max, into a float
                            	   160: ; register.
                            	   161: ;
                            	   162: ; Register Usage:
                            	   163: ;		d1 = digit from input screen
                            	   164: ;		d2 = digit down counter
                            	   165: ;		d3 = sign of number '+' or '-'
                            	   166: ;		fp1 = digit
                            	   167: ; Modifies:
                            	   168: ;		a0,fp0
                            	   169: ; Returns:
                            	   170: ;		a0 = updated buffer pointer
                            	   171: ;		fp0 = integer number
                            	   172: ;-------------------------------------------------------------------------------
                            	   173: 
                            	   174: _GetInteger:
00:00008D32 4E52FFE4        	   175: 	link a2,#-28
00:00008D36 2F79000400980018	   176: 	move.l _canary,24(sp)
00:00008D3E 48D7000E        	   177: 	movem.l d1/d2/d3,(sp)
00:00008D42 F22F6880000C    	   178: 	fmove.x fp1,12(sp)
00:00008D48 F23C50000000    	   179: 	fmove.w #0,fp0
00:00008D4E 7418            	   180: 	moveq #24,d2					; d2 = digit count (25 max)
00:00008D50 6100FEE6        	   181: 	bsr _GetFloatIgnBlanks
00:00008D54 6100FEDC        	   182: 	bsr _GetFloatGetChar	; get the sign of the number
00:00008D58 0C01002B        	   183: 	cmpi.b #'+',d1
00:00008D5C 670A            	   184: 	beq .0002
                            	   185: .0003
00:00008D5E 0C01002D        	   186: 	cmpi.b #'-',d1
00:00008D62 6608            	   187: 	bne .0004
00:00008D64 1E3C002D        	   188: 	move.b #'-',d7
                            	   189: .0002
00:00008D68 6100FEC8        	   190: 	bsr _GetFloatGetChar
                            	   191: .0004
00:00008D6C 0C010030        	   192: 	cmpi.b #'0',d1				; only characters 0 to 9 valid
00:00008D70 651E            	   193: 	blo .0001
00:00008D72 0C010039        	   194: 	cmpi.b #'9',d1
00:00008D76 6218            	   195: 	bhi .0001
00:00008D78 04010030        	   196: 	subi.b #'0',d1
00:00008D7C F23C50260001    	   197: 	fscale.w #1,fp0				; number *10
00:00008D82 F2015880        	   198: 	fmove.b d1,fp1				; fp1 = digit
00:00008D86 F2000422        	   199: 	fadd fp1,fp0
00:00008D8A 5245            	   200: 	addq.w #1,d5
00:00008D8C 51CAFFDA        	   201: 	dbra d2,.0002
                            	   202: .0001
00:00008D90 6100FEAE        	   203: 	bsr _GetFloatBackupChar
00:00008D94 4CD7000E        	   204: 	movem.l (sp),d1/d2/d3
00:00008D98 F22F4880000C    	   205: 	fmove.x 12(sp),fp1
00:00008D9E A2AF00030018    	   206: 	cchk 24(sp)
00:00008DA4 4E5A            	   207: 	unlk a2
00:00008DA6 4E75            	   208: 	rts
                            	   209: 		
                            	   210: ;-------------------------------------------------------------------------------
                            	   211: ; Get a floating point number off the input screen.
                            	   212: ;
                            	   213: ; Parameters:
                            	   214: ;		a0 = pointer to buffer containing string
                            	   215: ;		d0 = stride of buffer (increment / decrement amount)
                            	   216: ; Register Usage:
                            	   217: ;		d1 = character from input screen
                            	   218: ;		d5.lo = number of digits in number, d5.hi = number of characters fetched
                            	   219: ; Returns:
                            	   220: ;		fp0 = number
                            	   221: ;		a0 = updated buffer pointer
                            	   222: ;		d0 = length of number >0 if a number
                            	   223: ;-------------------------------------------------------------------------------
                            	   224: 
                            	   225: _GetFloat:
00:00008DA8 4E52FFE0        	   226: 	link a2,#-32
00:00008DAC 2F7900040098001C	   227: 	move.l _canary,28(sp)
00:00008DB4 48D702A2        	   228: 	movem.l d1/d5/d7/a1,(sp)
00:00008DB8 F22F69000010    	   229: 	fmove.x fp2,16(sp)
00:00008DBE 7A00            	   230: 	clr.l d5
00:00008DC0 1E3C002B        	   231: 	move.b #'+',d7				; assume a positive number
00:00008DC4 2248            	   232: 	move.l a0,a1					; a1 = copy of pointer to buffer
00:00008DC6 6100FF6A        	   233: 	bsr _GetInteger				; rval = integer
00:00008DCA F2000100        	   234: 	fmove.x fp0,fp2
00:00008DCE 6100FE62        	   235: 	bsr _GetFloatGetChar
00:00008DD2 0C01002E        	   236: 	cmpi.b #'.',d1
00:00008DD6 6706            	   237: 	beq .0004
                            	   238: .0005
00:00008DD8 6100FE66        	   239: 	bsr _GetFloatBackupChar
00:00008DDC 601C            	   240: 	bra .0002
                            	   241: .0004
00:00008DDE 6100FE64        	   242: 	bsr _GetFraction
00:00008DE2 F2000822        	   243: 	fadd fp2,fp0					; rval += fraction
00:00008DE6 6100FE4A        	   244: 	bsr _GetFloatGetChar
00:00008DEA 0C010065        	   245: 	cmpi.b #'e',d1				; accept either 'e' or 'E' indicating exponent
00:00008DEE 6706            	   246: 	beq .0001
00:00008DF0 0C010045        	   247: 	cmpi.b #'E',d1
00:00008DF4 66E2            	   248: 	bne .0005
                            	   249: .0001
00:00008DF6 6100FEB0        	   250: 	bsr _GetExponent			; factor exponent into fp0
                            	   251: .0002
00:00008DFA 0C07002D        	   252: 	cmpi.b #'-',d7				; adjust number for sign
00:00008DFE 6604            	   253: 	bne .0003
00:00008E00 F200001A        	   254: 	fneg fp0
                            	   255: .0003
00:00008E04 93C8            	   256: 	suba.l a0,a1					; compute number of characters fetched
00:00008E06 3009            	   257: 	move.w a1,d0					; move it to d0.hi
00:00008E08 4840            	   258: 	swap d0
00:00008E0A 3005            	   259: 	move.w d5,d0					; return digit/character count in d0 (non zero for a number)
00:00008E0C 4CD702A2        	   260: 	movem.l (sp),d1/d5/d7/a1
00:00008E10 F22F49000010    	   261: 	fmove.x 16(sp),fp2
00:00008E16 A2AF0003001C    	   262: 	cchk 28(sp)
00:00008E1C 4E5A            	   263: 	unlk a2
00:00008E1E 4E75            	   264: 	rts	
                            	   265: 
                            	   266: 		

Source: "boot.x68"
                            	  2941: 
                            	  2942: ;------------------------------------------------------------------------------
                            	  2943: ; Convert ASCII character in the range '0' to '9', 'a' tr 'f' or 'A' to 'F'
                            	  2944: ; to a hex nybble.
                            	  2945: ;------------------------------------------------------------------------------
                            	  2946: 
                            	  2947: AsciiToHexNybble:
00:00008E20 0C010030        	  2948: 	cmpi.b	#'0',d1
00:00008E24 6530            	  2949: 	blo.s		gthx3
00:00008E26 0C010039        	  2950: 	cmpi.b	#'9',d1
00:00008E2A 6206            	  2951: 	bhi.s		gthx5
00:00008E2C 04010030        	  2952: 	subi.b	#'0',d1
00:00008E30 4E75            	  2953: 	rts
                            	  2954: gthx5:
00:00008E32 0C010041        	  2955: 	cmpi.b	#'A',d1
00:00008E36 651E            	  2956: 	blo.s		gthx3
00:00008E38 0C010046        	  2957: 	cmpi.b	#'F',d1
00:00008E3C 6206            	  2958: 	bhi.s		gthx6
00:00008E3E 060100C9        	  2959: 	addi.b	#10-'A',d1
00:00008E42 4E75            	  2960: 	rts
                            	  2961: gthx6:
00:00008E44 0C010061        	  2962: 	cmpi.b	#'a',d1
00:00008E48 650C            	  2963: 	blo.s		gthx3
00:00008E4A 0C010066        	  2964: 	cmpi.b	#'f',d1
00:00008E4E 6206            	  2965: 	bhi.s		gthx3
00:00008E50 060100A9        	  2966: 	addi.b	#10-'a',d1
00:00008E54 4E75            	  2967: 	rts
                            	  2968: gthx3:
00:00008E56 72FF            	  2969: 	moveq	#-1,d1		; not a hex number
00:00008E58 4E75            	  2970: 	rts
                            	  2971: 
                            	  2972: ;------------------------------------------------------------------------------
                            	  2973: ;------------------------------------------------------------------------------
                            	  2974: 
                            	  2975: DisplayTwoSpaces:
00:00008E5A 2F01            	  2976: 	move.l	d1,-(a7)
00:00008E5C 123C0020        	  2977: 	move.b	#' ',d1
00:00008E60 610007D8        	  2978: 	bsr			OutputChar
                            	  2979: dspspc1:
00:00008E64 610007D4        	  2980: 	bsr			OutputChar
00:00008E68 221F            	  2981: 	move.l	(a7)+,d1
00:00008E6A 4E75            	  2982: 	rts
                            	  2983: 
                            	  2984: DisplaySpace:
00:00008E6C 2F01            	  2985: 	move.l	d1,-(a7)
00:00008E6E 123C0020        	  2986: 	move.b	#' ',d1
00:00008E72 60F0            	  2987: 	bra			dspspc1
                            	  2988: 
                            	  2989: ;------------------------------------------------------------------------------
                            	  2990: ; Display the 32 bit word in D1.L
                            	  2991: ;------------------------------------------------------------------------------
                            	  2992: 
                            	  2993: DisplayTetra:
00:00008E74 4841            	  2994: 	swap	d1
00:00008E76 6102            	  2995: 	bsr		DisplayWyde
00:00008E78 4841            	  2996: 	swap	d1
                            	  2997: 
                            	  2998: ;------------------------------------------------------------------------------
                            	  2999: ; Display the byte in D1.W
                            	  3000: ;------------------------------------------------------------------------------
                            	  3001: 
                            	  3002: DisplayWyde:
00:00008E7A E059            	  3003: 	ror.w		#8,d1
00:00008E7C 6102            	  3004: 	bsr			DisplayByte
00:00008E7E E159            	  3005: 	rol.w		#8,d1
                            	  3006: 
                            	  3007: ;------------------------------------------------------------------------------
                            	  3008: ; Display the byte in D1.B
                            	  3009: ;------------------------------------------------------------------------------
                            	  3010: 
                            	  3011: DisplayByte:
00:00008E80 E819            	  3012: 	ror.b		#4,d1
00:00008E82 6102            	  3013: 	bsr			DisplayNybble
00:00008E84 E919            	  3014: 	rol.b		#4,d1
                            	  3015: 
                            	  3016: ;------------------------------------------------------------------------------
                            	  3017: ; Display nybble in D1.B
                            	  3018: ;------------------------------------------------------------------------------
                            	  3019: 
                            	  3020: DisplayNybble:
00:00008E86 2F01            	  3021: 	move.l	d1,-(a7)
00:00008E88 0201000F        	  3022: 	andi.b	#$F,d1
00:00008E8C 06010030        	  3023: 	addi.b	#'0',d1
00:00008E90 0C010039        	  3024: 	cmpi.b	#'9',d1
00:00008E94 6302            	  3025: 	bls.s		.0001
00:00008E96 5E01            	  3026: 	addi.b	#7,d1
                            	  3027: .0001:
00:00008E98 610007A0        	  3028: 	bsr			OutputChar
00:00008E9C 221F            	  3029: 	move.l	(a7)+,d1
00:00008E9E 4E75            	  3030: 	rts
                            	  3031: 
                            	  3032: ;------------------------------------------------------------------------------
                            	  3033: ; Buffer tetra in d0 to buffer pointed to by a6
                            	  3034: ;------------------------------------------------------------------------------
                            	  3035: 
                            	  3036: BufTetra:
00:00008EA0 4840            	  3037: 	swap d0
00:00008EA2 6102            	  3038: 	bsr BufWyde
00:00008EA4 4840            	  3039: 	swap d0
                            	  3040: 
                            	  3041: BufWyde:
00:00008EA6 E058            	  3042: 	ror.w #8,d0
00:00008EA8 6102            	  3043: 	bsr BufByte
00:00008EAA E158            	  3044: 	rol.w #8,d0
                            	  3045: 	
                            	  3046: BufByte:
00:00008EAC E818            	  3047: 	ror.b #4,d0
00:00008EAE 6102            	  3048: 	bsr BufNybble
00:00008EB0 E918            	  3049: 	rol.b #4,d0
                            	  3050: 
                            	  3051: BufNybble:
00:00008EB2 2F00            	  3052: 	move.l d0,-(a7)
00:00008EB4 0200000F        	  3053: 	andi.b #$F,d0
00:00008EB8 06000030        	  3054: 	addi.b #'0',d0
00:00008EBC 0C000039        	  3055: 	cmpi.b #'9',d0
00:00008EC0 6302            	  3056: 	bls.s .0001
00:00008EC2 5E00            	  3057: 	addi.b #7,d0
                            	  3058: .0001:
00:00008EC4 1CC0            	  3059: 	move.b d0,(a6)+
00:00008EC6 201F            	  3060: 	move.l (a7)+,d0
00:00008EC8 4E75            	  3061: 	rts
                            	  3062: 
                            	  3063: ;------------------------------------------------------------------------------
                            	  3064: ;------------------------------------------------------------------------------
                            	  3065: ;
                            	  3066: ;DisplayHexNumber:
                            	  3067: ;	move.w	#$A6A6,leds		; diagnostics
                            	  3068: ;	move.l	#VDGREG,a6
                            	  3069: ;	move.w	#7,d2		; number-1 of digits to display
                            	  3070: ;disphnum1:
                            	  3071: ;	move.b	d1,d0		; get digit into d0.b
                            	  3072: ;	andi.w	#$0f,d0
                            	  3073: ;	cmpi.w	#$09,d0
                            	  3074: ;	bls.s	disphnum2
                            	  3075: ;	addi.w	#7,d0
                            	  3076: ;disphnum2:
                            	  3077: ;	addi.w	#$30,d0	; convert to display char
                            	  3078: ;	move.w	d2,d3		; char count into d3
                            	  3079: ;	asl.w	#3,d3		; scale * 8
                            	  3080: ;disphnum3:
                            	  3081: ;	move.w	$42C(a6),d4			; read character queue index into d4
                            	  3082: ;	cmp.w	#28,d4					; allow up 28 entries to be in progress
                            	  3083: ;	bhs.s	disphnum3				; branch if too many chars queued
                            	  3084: ;	ext.w	d0						; zero out high order bits
                            	  3085: ;	move.w	d0,$420(a6)			; set char code
                            	  3086: ;	move.w	#WHITE,$422(a6)		; set fg color
                            	  3087: ;	move.w	#DARK_BLUE,$424(a6)	; set bk color
                            	  3088: ;	move.w	d3,$426(a6)			; set x pos
                            	  3089: ;	move.w	#8,$428(a6)			; set y pos
                            	  3090: ;	move.w	#$0707,$42A(a6)		; set font x,y extent
                            	  3091: ;	move.w	#0,$42E(a6)			; pulse character queue write signal
                            	  3092: ;	ror.l	#4,d1					; rot to next digit
                            	  3093: ;	dbeq	d2,disphnum1
                            	  3094: ;	jmp		(a5)
                            	  3095: 
                            	  3096: 	include "ramtest.x68"

Source: "ramtest.x68"
                            	     1: ;===============================================================================
                            	     2: ;    Perform ram test. (Uses checkerboard testing).
                            	     3: ; 
                            	     4: ;    Local ram, which does not get tested, is used for the stack.
                            	     5: ;===============================================================================
                            	     6: 	code
                            	     7: 	even
                            	     8: DisplayAddr:
00:00008ECA 2208            	     9: 	move.l a0,d1
00:00008ECC E089            	    10: 	lsr.l #8,d1
00:00008ECE E089            	    11: 	lsr.l #8,d1
00:00008ED0 E889            	    12: 	lsr.l #4,d1
00:00008ED2 04410400        	    13: 	subi.w #1024,d1
00:00008ED6 A2C10000        	    14: 	bin2bcd d1
00:00008EDA 619E            	    15: 	bsr	DisplayWyde
00:00008EDC 618E            	    16: 	bsr DisplaySpace
00:00008EDE 123C000D        	    17: 	move.b #CR,d1
00:00008EE2 61000756        	    18: 	bsr OutputChar
00:00008EE6 08000083        	    19: 	btst #$83,d0
                            	    20: 	
                            	    21: cmdTestRAM:
                            	    22: ramtest:
00:00008EEA 33FCA5A5FD0FFF00	    23: 	move.w	#$A5A5,leds		; diagnostics
00:00008EF2 263CAAAAAAAA    	    24:   move.l #$aaaaaaaa,d3
00:00008EF8 283C55555555    	    25:   move.l #$55555555,d4
00:00008EFE 6134            	    26:   bsr ramtest0
                            	    27:   ; switch checkerboard pattern and repeat test.
00:00008F00 C744            	    28:   exg d3,d4
00:00008F02 6130            	    29:   bsr ramtest0
                            	    30: 	; Save last ram address in end of memory pointer.
                            	    31: rmtst5:
00:00008F04 7025            	    32: 	moveq #37,d0					; lock semaphore
00:00008F06 7206            	    33: 	moveq #MEMORY_SEMA,d1
                            	    34: ;	trap #15
00:00008F08 207C7FFFFFF8    	    35:   movea.l #$7FFFFFF8,a0
00:00008F0E 23C800100004    	    36:   move.l a0,memend
                            	    37: 	; Create very first memory block.
00:00008F14 207C3FFFFFF4    	    38:   movea.l #$3FFFFFF4,a0
00:00008F1A 23C840000004    	    39:   move.l a0,$40000004		; length of block
00:00008F20 23FC465245454000	    40:   move.l #$46524545,$40000000
00:00008F28 0000
00:00008F2A 7026            	    41: 	moveq #38,d0					; unlock semaphore
00:00008F2C 7206            	    42: 	moveq #MEMORY_SEMA,d1
00:00008F2E 4E4F            	    43: 	trap #15
00:00008F30 6000ED52        	    44: 	bra Monitor
                            	    45: ;  rts
                            	    46: 
                            	    47: ramtest0:
00:00008F34 2003            	    48: 	move.l d3,d0
00:00008F36 207C40000000    	    49:   movea.l #$40000000,a0
                            	    50: ;-----------------------------------------------------------
                            	    51: ;   Write checkerboard pattern to ram then read it back to
                            	    52: ; find the highest usable ram address (maybe). This address
                            	    53: ; must be lower than the start of the rom (0xe00000).
                            	    54: ;-----------------------------------------------------------
                            	    55: ramtest1:
00:00008F3C 20C3            	    56:   move.l d3,(a0)+
00:00008F3E 20C4            	    57:   move.l d4,(a0)+
00:00008F40 2208            	    58:   move.l a0,d1
00:00008F42 4A41            	    59:   tst.w	d1
00:00008F44 6608            	    60:   bne.s rmtst1
00:00008F46 6182            	    61:   bsr DisplayAddr
00:00008F48 4EB9000008AE    	    62:   bsr CheckForCtrlC
                            	    63: rmtst1:
00:00008F4E B1FC7FFFFFF8    	    64:   cmpa.l #$7FFFFFF8,a0
00:00008F54 65E6            	    65:   blo.s ramtest1
00:00008F56 6100E71E        	    66:   bsr	CRLF
                            	    67: ;------------------------------------------------------
                            	    68: ;   Save maximum useable address for later comparison.
                            	    69: ;------------------------------------------------------
                            	    70: ramtest6:
00:00008F5A 33FCA7A7FD0FFF00	    71: 	move.w	#$A7A7,leds		; diagnostics
00:00008F62 2448            	    72:   movea.l a0,a2
00:00008F64 207C40000000    	    73:   movea.l #$40000000,a0
                            	    74: ;--------------------------------------------
                            	    75: ;   Read back checkerboard pattern from ram.
                            	    76: ;--------------------------------------------
                            	    77: ramtest2
00:00008F6A 2A18            	    78:   move.l (a0)+,d5
00:00008F6C 2C18            	    79:   move.l (a0)+,d6
00:00008F6E B1CA            	    80:   cmpa.l a2,a0
00:00008F70 643E            	    81:   bhs.s	ramtest3
00:00008F72 2208            	    82:   move.l a0,d1
00:00008F74 4A41            	    83:   tst.w	d1
00:00008F76 660A            	    84:   bne.s	rmtst2
00:00008F78 6100FF50        	    85:   bsr	DisplayAddr
00:00008F7C 4EB9000008AE    	    86: 	bsr CheckForCtrlC
                            	    87: rmtst2
00:00008F82 BA83            	    88:   cmp.l d3,d5
00:00008F84 6604            	    89:   bne.s rmtst3
00:00008F86 BC84            	    90:   cmp.l d4,d6
00:00008F88 67E0            	    91:   beq.s ramtest2
                            	    92: ;----------------------------------
                            	    93: ; Report error in ram.
                            	    94: ;----------------------------------
                            	    95: rmtst3
00:00008F8A 6100E6EA        	    96: 	bsr CRLF
00:00008F8E 7245            	    97: 	moveq	#'E',d1
00:00008F90 610006A8        	    98: 	bsr OutputChar
00:00008F94 6100FED6        	    99: 	bsr DisplaySpace
00:00008F98 2208            	   100: 	move.l a0,d1
00:00008F9A 6100FED8        	   101: 	bsr DisplayTetra
00:00008F9E 6100FECC        	   102: 	bsr DisplaySpace
00:00008FA2 2205            	   103: 	move.l d5,d1
00:00008FA4 6100FECE        	   104: 	bsr DisplayTetra
00:00008FA8 4EB9000008AE    	   105: 	bsr CheckForCtrlC
00:00008FAE 60BA            	   106: 	bra ramtest2
                            	   107: ramtest3
00:00008FB0 4E75            	   108: 	rts
                            	   109: 

Source: "boot.x68"
                            	  3097: 	include "LoadS19.x68"

Source: "LoadS19.x68"
                            	     1: ;==============================================================================
                            	     2: ; Load an S19 format file
                            	     3: ;==============================================================================
                            	     4: 	code
                            	     5: 	even
                            	     6: cmdLoadS19:
00:00008FB2 6100E6C2        	     7: 	bsr			CRLF					; move display to next line
00:00008FB6 6012            	     8: 	bra			ProcessRec
                            	     9: NextRec:
00:00008FB8 610001E4        	    10: 	bsr			sGetChar			; get character from serial port routines
00:00008FBC 0C01000A        	    11: 	cmpi.b	#LF,d1				; look for a line-feed
00:00008FC0 66F6            	    12: 	bne			NextRec
00:00008FC2 123C002E        	    13: 	move.b	#'.',d1				; progress display
00:00008FC6 61000672        	    14: 	bsr			OutputChar
                            	    15: ProcessRec:
00:00008FCA 4EB9000008AE    	    16: 	bsr			CheckForCtrlC	; check for CTRL-C once per record
00:00008FD0 610001CC        	    17: 	bsr			sGetChar
00:00008FD4 0C01000D        	    18: 	cmpi.b	#CR,d1
00:00008FD8 67F0            	    19: 	beq.s		ProcessRec
00:00008FDA 423900100150    	    20: 	clr.b		S19Checksum		; clear the checksum
00:00008FE0 1801            	    21: 	move.b	d1,d4
00:00008FE2 0C04001A        	    22: 	cmpi.b	#CTRLZ,d4			; CTRL-Z ?
00:00008FE6 6700EC9C        	    23: 	beq			Monitor
00:00008FEA 0C040053        	    24: 	cmpi.b	#'S',d4				; All records must begin with an 'S'
00:00008FEE 66C8            	    25: 	bne.s		NextRec
00:00008FF0 610001AC        	    26: 	bsr			sGetChar
00:00008FF4 1801            	    27: 	move.b	d1,d4
00:00008FF6 0C040030        	    28: 	cmpi.b	#'0',d4				; Record type must be between '0' and '9'
00:00008FFA 65BC            	    29: 	blo.s		NextRec
00:00008FFC 0C040039        	    30: 	cmpi.b	#'9',d4				; d4 = record type
00:00009000 62B6            	    31: 	bhi.s		NextRec
00:00009002 6100019A        	    32: 	bsr			sGetChar			; get byte count for record
00:00009006 6100FE18        	    33: 	bsr			AsciiToHexNybble
00:0000900A 1401            	    34: 	move.b	d1,d2
00:0000900C 61000190        	    35: 	bsr			sGetChar
00:00009010 6100FE0E        	    36: 	bsr			AsciiToHexNybble
00:00009014 E90A            	    37: 	lsl.b		#4,d2
00:00009016 8202            	    38: 	or.b		d2,d1					; d1 = byte count
00:00009018 1601            	    39: 	move.b	d1,d3					; d3 = byte count
00:0000901A D73900100150    	    40: 	add.b		d3,S19Checksum
00:00009020 0C040030        	    41: 	cmpi.b	#'0',d4				; manufacturer ID record, ignore
00:00009024 6792            	    42: 	beq			NextRec
00:00009026 0C040031        	    43: 	cmpi.b	#'1',d4
00:0000902A 670000A2        	    44: 	beq			ProcessS1
00:0000902E 0C040032        	    45: 	cmpi.b	#'2',d4
00:00009032 6700009E        	    46: 	beq			ProcessS2
00:00009036 0C040033        	    47: 	cmpi.b	#'3',d4
00:0000903A 6700009A        	    48: 	beq			ProcessS3
00:0000903E 0C040035        	    49: 	cmpi.b	#'5',d4				; record count record, ignore
00:00009042 6700FF74        	    50: 	beq			NextRec
00:00009046 0C040037        	    51: 	cmpi.b	#'7',d4
00:0000904A 6700008E        	    52: 	beq			ProcessS7
00:0000904E 0C040038        	    53: 	cmpi.b	#'8',d4
00:00009052 67000098        	    54: 	beq			ProcessS8
00:00009056 0C040039        	    55: 	cmpi.b	#'9',d4
00:0000905A 670000A2        	    56: 	beq			ProcessS9
00:0000905E 6000FF58        	    57: 	bra			NextRec
                            	    58: 
                            	    59: pcssxa:
00:00009062 2209            	    60: 	move.l	a1,d1
00:00009064 6100FE0E        	    61: 	bsr			DisplayTetra
00:00009068 123C000D        	    62: 	move.b	#CR,d1
00:0000906C 610005CC        	    63: 	bsr			OutputChar
00:00009070 024300FF        	    64: 	andi.w	#$ff,d3
00:00009074 5343            	    65: 	subi.w	#1,d3			; one less for dbra
                            	    66: .0001:
00:00009076 7400            	    67: 	clr.l		d2
00:00009078 61000124        	    68: 	bsr			sGetChar
00:0000907C 6100FDA2        	    69: 	bsr			AsciiToHexNybble
00:00009080 E98A            	    70: 	lsl.l		#4,d2
00:00009082 8401            	    71: 	or.b		d1,d2
00:00009084 61000118        	    72: 	bsr			sGetChar
00:00009088 6100FD96        	    73: 	bsr			AsciiToHexNybble
00:0000908C E98A            	    74: 	lsl.l		#4,d2
00:0000908E 8401            	    75: 	or.b		d1,d2
00:00009090 D53900100150    	    76: 	add.b		d2,S19Checksum
00:00009096 12C2            	    77: 	move.b	d2,(a1)+			; move byte to memory
00:00009098 51CBFFDC        	    78: 	dbra		d3,.0001
                            	    79: 	; Get the checksum byte
00:0000909C 7400            	    80: 	clr.l		d2
00:0000909E 610000FE        	    81: 	bsr			sGetChar
00:000090A2 6100FD7C        	    82: 	bsr			AsciiToHexNybble
00:000090A6 E98A            	    83: 	lsl.l		#4,d2
00:000090A8 8401            	    84: 	or.b		d1,d2
00:000090AA 610000F2        	    85: 	bsr			sGetChar
00:000090AE 6100FD70        	    86: 	bsr			AsciiToHexNybble
00:000090B2 E98A            	    87: 	lsl.l		#4,d2
00:000090B4 8401            	    88: 	or.b		d1,d2
00:000090B6 4602            	    89: 	eor.b		#$FF,d2
00:000090B8 B43900100150    	    90: 	cmp.b		S19Checksum,d2
00:000090BE 6700FEF8        	    91: 	beq			NextRec
00:000090C2 123C0045        	    92: 	move.b	#'E',d1
00:000090C6 61000572        	    93: 	bsr			OutputChar
00:000090CA 6000FEEC        	    94: 	bra			NextRec
                            	    95: 
                            	    96: ProcessS1:
00:000090CE 6140            	    97: 	bsr			S19Get16BitAddress
00:000090D0 6090            	    98: 	bra			pcssxa
                            	    99: ProcessS2:
00:000090D2 614A            	   100: 	bsr			S19Get24BitAddress
00:000090D4 608C            	   101: 	bra			pcssxa
                            	   102: ProcessS3:
00:000090D6 6152            	   103: 	bsr			S19Get32BitAddress
00:000090D8 6088            	   104: 	bra			pcssxa
                            	   105: ProcessS7:
00:000090DA 614E            	   106: 	bsr			S19Get32BitAddress
00:000090DC 23C900040008    	   107: 	move.l	a1,S19StartAddress
00:000090E2 4EB9000006B4    	   108: 	bsr			_KeybdInit
00:000090E8 6000EB9A        	   109: 	bra			Monitor
                            	   110: ProcessS8:
00:000090EC 6130            	   111: 	bsr			S19Get24BitAddress
00:000090EE 23C900040008    	   112: 	move.l	a1,S19StartAddress
00:000090F4 4EB9000006B4    	   113: 	bsr			_KeybdInit
00:000090FA 6000EB88        	   114: 	bra			Monitor
                            	   115: ProcessS9:
00:000090FE 6110            	   116: 	bsr			S19Get16BitAddress
00:00009100 23C900040008    	   117: 	move.l	a1,S19StartAddress
00:00009106 4EB9000006B4    	   118: 	bsr			_KeybdInit
00:0000910C 6000EB76        	   119: 	bra			Monitor
                            	   120: 
                            	   121: S19Get16BitAddress:
00:00009110 7400            	   122: 	clr.l		d2
00:00009112 6100008A        	   123: 	bsr			sGetChar
00:00009116 6100FD08        	   124: 	bsr			AsciiToHexNybble
00:0000911A 1401            	   125: 	move.b	d1,d2
00:0000911C 603E            	   126: 	bra			S1932b
                            	   127: 
                            	   128: S19Get24BitAddress:
00:0000911E 7400            	   129: 	clr.l		d2
00:00009120 617C            	   130: 	bsr			sGetChar
00:00009122 6100FCFC        	   131: 	bsr			AsciiToHexNybble
00:00009126 1401            	   132: 	move.b	d1,d2
00:00009128 601E            	   133: 	bra			S1932a
                            	   134: 
                            	   135: S19Get32BitAddress:
00:0000912A 7400            	   136: 	clr.l		d2
00:0000912C 6170            	   137: 	bsr			sGetChar
00:0000912E 6100FCF0        	   138: 	bsr			AsciiToHexNybble
00:00009132 1401            	   139: 	move.b	d1,d2
00:00009134 6168            	   140: 	bsr			sGetChar
00:00009136 6100FCE8        	   141: 	bsr			AsciiToHexNybble
00:0000913A E98A            	   142: 	lsl.l		#4,d2
00:0000913C 8401            	   143: 	or.b		d1,d2
00:0000913E 615E            	   144: 	bsr			sGetChar
00:00009140 6100FCDE        	   145: 	bsr			AsciiToHexNybble
00:00009144 E98A            	   146: 	lsl.l		#4,d2
00:00009146 8401            	   147: 	or.b		d1,d2
                            	   148: S1932a:
00:00009148 6154            	   149: 	bsr			sGetChar
00:0000914A 6100FCD4        	   150: 	bsr			AsciiToHexNybble
00:0000914E E98A            	   151: 	lsl.l		#4,d2
00:00009150 8401            	   152: 	or.b		d1,d2
00:00009152 614A            	   153: 	bsr			sGetChar
00:00009154 6100FCCA        	   154: 	bsr			AsciiToHexNybble
00:00009158 E98A            	   155: 	lsl.l		#4,d2
00:0000915A 8401            	   156: 	or.b		d1,d2
                            	   157: S1932b:
00:0000915C 6140            	   158: 	bsr			sGetChar
00:0000915E 6100FCC0        	   159: 	bsr			AsciiToHexNybble
00:00009162 E98A            	   160: 	lsl.l		#4,d2
00:00009164 8401            	   161: 	or.b		d1,d2
00:00009166 6136            	   162: 	bsr			sGetChar
00:00009168 6100FCB6        	   163: 	bsr			AsciiToHexNybble
00:0000916C E98A            	   164: 	lsl.l		#4,d2
00:0000916E 8401            	   165: 	or.b		d1,d2
00:00009170 612C            	   166: 	bsr			sGetChar
00:00009172 6100FCAC        	   167: 	bsr			AsciiToHexNybble
00:00009176 E98A            	   168: 	lsl.l		#4,d2
00:00009178 8401            	   169: 	or.b		d1,d2
00:0000917A 7800            	   170: 	clr.l		d4
00:0000917C 2242            	   171: 	move.l	d2,a1
                            	   172: 	; Add bytes from address value to checksum
00:0000917E D53900100150    	   173: 	add.b		d2,S19Checksum
00:00009184 E08A            	   174: 	lsr.l		#8,d2
00:00009186 D53900100150    	   175: 	add.b		d2,S19Checksum
00:0000918C E08A            	   176: 	lsr.l		#8,d2
00:0000918E D53900100150    	   177: 	add.b		d2,S19Checksum
00:00009194 E08A            	   178: 	lsr.l		#8,d2
00:00009196 D53900100150    	   179: 	add.b		d2,S19Checksum
00:0000919C 4E75            	   180: 	rts
                            	   181: 
                            	   182: ;------------------------------------------------------------------------------
                            	   183: ; Get a character from auxillary input. Waiting for a character is limited to
                            	   184: ; 32000 tries. If a character is not available within the limit, then a return
                            	   185: ; to the monitor is done.
                            	   186: ;
                            	   187: ;	Parameters:
                            	   188: ;		none
                            	   189: ; Returns:
                            	   190: ;		d1 = character from receive buffer or -1 if no char available
                            	   191: ;------------------------------------------------------------------------------
                            	   192: 
                            	   193: sGetChar:
00:0000919E 48E7A000        	   194: 	movem.l	d0/d2,-(a7)
00:000091A2 343C7D00        	   195: 	move.w	#32000,d2
                            	   196: .0001:
00:000091A6 7024            	   197: 	moveq		#36,d0				; serial get char from buffer
00:000091A8 4E4F            	   198: 	trap		#15
00:000091AA 4A41            	   199: 	tst.w		d1						; was there a char available?
00:000091AC 6A0C            	   200: 	bpl.s		.0002
00:000091AE 51CAFFF6        	   201: 	dbra		d2,.0001			; no - try again
00:000091B2 4CDF0005        	   202: 	movem.l	(a7)+,d0/d2
                            	   203: .0003:
                            	   204: ;	bsr			_KeybdInit
00:000091B6 6000EACC        	   205: 	bra			Monitor				; ran out of tries
                            	   206: .0002:
00:000091BA 4CDF0005        	   207: 	movem.l	(a7)+,d0/d2
00:000091BE 0C01001A        	   208: 	cmpi.b	#CTRLZ,d1			; receive end of file?
00:000091C2 67F2            	   209: 	beq			.0003
00:000091C4 4E75            	   210: 	rts
                            	   211: 
                            	   212: 

Source: "boot.x68"
                            	  3098: 	
                            	  3099: AudioInputTest:
00:000091C6 4E75            	  3100: 	rts
                            	  3101: BouncingBalls:
00:000091C8 4E75            	  3102: 	rts
                            	  3103: GraphicsDemo:
00:000091CA 4E75            	  3104: 	rts
                            	  3105: ClearScreen:
00:000091CC 7E02            	  3106: 	move.l #2,d7
00:000091CE 7C0C            	  3107: 	move.l #DEV_CLEAR,d6
00:000091D0 4E40            	  3108: 	trap #0
00:000091D2 4E75            	  3109: 	rts
                            	  3110: 
                            	  3111: ;------------------------------------------------------------------------------
                            	  3112: ; Reverse the order of bytes in d1.
                            	  3113: ;------------------------------------------------------------------------------
                            	  3114: 
                            	  3115: rbo:
00:000091D4 E159            	  3116: 	rol.w	#8,d1
00:000091D6 4841            	  3117: 	swap d1
00:000091D8 E159            	  3118: 	rol.w	#8,d1
00:000091DA 4E75            	  3119: 	rts
                            	  3120: 
                            	  3121: ;===============================================================================
                            	  3122: ; Generic I2C routines
                            	  3123: ;===============================================================================
                            	  3124: 
                            	  3125: 	even
                            	  3126: ; i2c
                            	  3127: i2c_setup:
                            	  3128: ;		lea		I2C,a6				
                            	  3129: ;		move.w	#19,I2C_PREL(a6)	; setup prescale for 400kHz clock
                            	  3130: ;		move.w	#0,I2C_PREH(a6)
                            	  3131: init_i2c:
00:000091DC 4DF9FD069000    	  3132: 	lea	I2C2,a6				
00:000091E2 1CBC0013        	  3133: 	move.b #19,I2C_PREL(a6)	; setup prescale for 400kHz clock, 40MHz master
00:000091E6 422E0001        	  3134: 	move.b #0,I2C_PREH(a6)
00:000091EA 4E75            	  3135: 	rts
                            	  3136: 
                            	  3137: ; Wait for I2C transfer to complete
                            	  3138: ;
                            	  3139: ; Parameters
                            	  3140: ; 	a6 - I2C controller base address
                            	  3141: 
                            	  3142: i2c_wait_tip:
00:000091EC 2F00            	  3143: 	move.l d0,-(a7)
                            	  3144: .0001				
00:000091EE 102E0004        	  3145: 	move.b I2C_STAT(a6),d0		; wait for tip to clear
00:000091F2 08000001        	  3146: 	btst #1,d0
00:000091F6 66F6            	  3147: 	bne.s	.0001
00:000091F8 201F            	  3148: 	move.l (a7)+,d0
00:000091FA 4E75            	  3149: 	rts
                            	  3150: 
                            	  3151: ; Parameters
                            	  3152: ;	d0.b - data to transmit
                            	  3153: ;	d1.b - command value
                            	  3154: ;	a6	 - I2C controller base address
                            	  3155: ;
                            	  3156: i2c_wr_cmd:
00:000091FC 1D400003        	  3157: 	move.b d0,I2C_TXR(a6)
00:00009200 1D410004        	  3158: 	move.b d1,I2C_CMD(a6)
00:00009204 61E6            	  3159: 	bsr	i2c_wait_tip
00:00009206 102E0004        	  3160: 	move.b I2C_STAT(a6),d0
00:0000920A 4E75            	  3161: 	rts
                            	  3162: 
                            	  3163: i2c_xmit1:
00:0000920C 2F00            	  3164: 	move.l d0,-(a7)
00:0000920E 1D7C00010002    	  3165: 	move.b #1,I2C_CTRL(a6)		; enable the core
00:00009214 7076            	  3166: 	moveq	#$76,d0				; set slave address = %0111011
00:00009216 323C0090        	  3167: 	move.w #$90,d1				; set STA, WR
00:0000921A 61E0            	  3168: 	bsr i2c_wr_cmd
00:0000921C 610C            	  3169: 	bsr	i2c_wait_rx_nack
00:0000921E 201F            	  3170: 	move.l (a7)+,d0
00:00009220 323C0050        	  3171: 	move.w #$50,d1				; set STO, WR
00:00009224 61D6            	  3172: 	bsr i2c_wr_cmd
00:00009226 61000002        	  3173: 	bsr	i2c_wait_rx_nack
                            	  3174: 
                            	  3175: i2c_wait_rx_nack:
00:0000922A 2F00            	  3176: 	move.l d0,-(a7)
                            	  3177: .0001						
00:0000922C 102E0004        	  3178: 	move.b I2C_STAT(a6),d0		; wait for RXack = 0
00:00009230 08000007        	  3179: 	btst #7,d0
00:00009234 66F6            	  3180: 	bne.s	.0001
00:00009236 201F            	  3181: 	move.l (a7)+,d0
00:00009238 4E75            	  3182: 	rts
                            	  3183: 
                            	  3184: ;===============================================================================
                            	  3185: ; Realtime clock routines
                            	  3186: ;===============================================================================
                            	  3187: 
                            	  3188: rtc_read:
00:0000923A 2C7CFD069000    	  3189: 	movea.l	#I2C2,a6
00:00009240 4BF900100200    	  3190: 	lea	RTCBuf,a5
00:00009246 1D7C00800002    	  3191: 	move.b	#$80,I2C_CTRL(a6)	; enable I2C
00:0000924C 103C00DE        	  3192: 	move.b	#$DE,d0				; read address, write op
00:00009250 123C0090        	  3193: 	move.b	#$90,d1				; STA + wr bit
00:00009254 61A6            	  3194: 	bsr	i2c_wr_cmd
00:00009256 4A00            	  3195: 	tst.b	d0
00:00009258 6B66            	  3196: 	bmi	.rxerr
00:0000925A 4200            	  3197: 	move.b #$00,d0				; address zero
00:0000925C 123C0010        	  3198: 	move.b #$10,d1				; wr bit
00:00009260 619A            	  3199: 	bsr	i2c_wr_cmd
00:00009262 4A00            	  3200: 	tst.b	d0
00:00009264 6B5A            	  3201: 	bmi	.rxerr
00:00009266 103C00DF        	  3202: 	move.b #$DF,d0				; read address, read op
00:0000926A 123C0090        	  3203: 	move.b #$90,d1				; STA + wr bit
00:0000926E 618C            	  3204: 	bsr i2c_wr_cmd
00:00009270 4A00            	  3205: 	tst.b	d0
00:00009272 6B4C            	  3206: 	bmi	.rxerr
                            	  3207: 		
00:00009274 343C0020        	  3208: 	move.w #$20,d2
                            	  3209: .0001
00:00009278 1D7C00200004    	  3210: 	move.b #$20,I2C_CMD(a6)	; rd bit
00:0000927E 6100FF6C        	  3211: 	bsr	i2c_wait_tip
00:00009282 61A6            	  3212: 	bsr	i2c_wait_rx_nack
00:00009284 102E0004        	  3213: 	move.b I2C_STAT(a6),d0
00:00009288 4A00            	  3214: 	tst.b	d0
00:0000928A 6B34            	  3215: 	bmi	.rxerr
00:0000928C 102E0003        	  3216: 	move.b I2C_RXR(a6),d0
00:00009290 1B802000        	  3217: 	move.b d0,(a5,d2.w)
00:00009294 5242            	  3218: 	addi.w #1,d2
00:00009296 0C42005F        	  3219: 	cmpi.w #$5F,d2
00:0000929A 66DC            	  3220: 	bne	.0001
00:0000929C 1D7C00680004    	  3221: 	move.b #$68,I2C_CMD(a6)	; STO, rd bit + nack
00:000092A2 6100FF48        	  3222: 	bsr i2c_wait_tip
00:000092A6 6182            	  3223: 	bsr i2c_wait_rx_nack
00:000092A8 102E0004        	  3224: 	move.b I2C_STAT(a6),d0
00:000092AC 4A00            	  3225: 	tst.b	d0
00:000092AE 6B10            	  3226: 	bmi	.rxerr
00:000092B0 102E0003        	  3227: 	move.b I2C_RXR(a6),d0
00:000092B4 1B802000        	  3228: 	move.b d0,(a5,d2.w)
00:000092B8 422E0002        	  3229: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
00:000092BC 7000            	  3230: 	moveq	#0,d0
00:000092BE 4E75            	  3231: 	rts
                            	  3232: .rxerr
00:000092C0 422E0002        	  3233: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
00:000092C4 4E75            	  3234: 	rts
                            	  3235: 
                            	  3236: rtc_write:
00:000092C6 2C7CFD069000    	  3237: 	movea.l	#I2C2,a6
00:000092CC 4BF900100200    	  3238: 	lea	RTCBuf,a5
00:000092D2 1D7C00800002    	  3239: 	move.b #$80,I2C_CTRL(a6)	; enable I2C
00:000092D8 103C00DE        	  3240: 	move.b #$DE,d0				; read address, write op
00:000092DC 123C0090        	  3241: 	move.b #$90,d1				; STA + wr bit
00:000092E0 6100FF1A        	  3242: 	bsr	i2c_wr_cmd
00:000092E4 4A00            	  3243: 	tst.b	d0
00:000092E6 6B42            	  3244: 	bmi	.rxerr
00:000092E8 4200            	  3245: 	move.b #$00,d0				; address zero
00:000092EA 123C0010        	  3246: 	move.b #$10,d1				; wr bit
00:000092EE 6100FF0C        	  3247: 	bsr	i2c_wr_cmd
00:000092F2 4A00            	  3248: 	tst.b	d0
00:000092F4 6B34            	  3249: 	bmi	.rxerr
00:000092F6 343C0020        	  3250: 	move.w #$20,d2
                            	  3251: .0001
00:000092FA 10352000        	  3252: 	move.b (a5,d2.w),d0
00:000092FE 123C0010        	  3253: 	move.b #$10,d1
00:00009302 6100FEF8        	  3254: 	bsr	i2c_wr_cmd
00:00009306 4A00            	  3255: 	tst.b	d0
00:00009308 6B20            	  3256: 	bmi	.rxerr
00:0000930A 5242            	  3257: 	addi.w #1,d2
00:0000930C 0C42005F        	  3258: 	cmpi.w #$5F,d2
00:00009310 66E8            	  3259: 	bne.s	.0001
00:00009312 10352000        	  3260: 	move.b (a5,d2.w),d0
00:00009316 123C0050        	  3261: 	move.b #$50,d1				; STO, wr bit
00:0000931A 6100FEE0        	  3262: 	bsr	i2c_wr_cmd
00:0000931E 4A00            	  3263: 	tst.b	d0
00:00009320 6B08            	  3264: 	bmi	.rxerr
00:00009322 422E0002        	  3265: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return 0
00:00009326 7000            	  3266: 	moveq	#0,d0
00:00009328 4E75            	  3267: 	rts
                            	  3268: .rxerr:
00:0000932A 422E0002        	  3269: 	move.b #0,I2C_CTRL(a6)		; disable I2C and return status
00:0000932E 4E75            	  3270: 	rts
                            	  3271: 
                            	  3272: msgRtcReadFail:
00:00009330 5254432072656164	  3273: 	dc.b	"RTC read/write failed.",$0A,$0D,$00
00:00009338 2F77726974652066
00:00009340 61696C65642E
00:00009346 0A
00:00009347 0D
00:00009348 00
                            	  3274: 
                            	  3275: msgBusErr:
00:00009349 0A              	  3276: 	dc.b	$0A,$0D,"Bus error at: ",$00
00:0000934A 0D
00:0000934B 427573206572726F
00:00009353 722061743A20
00:00009359 00
                            	  3277: 	even
                            	  3278: 
                            	  3279: ;------------------------------------------------------------------------------
                            	  3280: ;------------------------------------------------------------------------------
                            	  3281: 	even
                            	  3282: 
                            	  3283: bus_err:
00:0000935A 4E71            	  3284: 	nop
00:0000935C 43FAFFEB        	  3285: 	lea.l msgBusErr,a1
00:00009360 6100E32E        	  3286: 	bsr DisplayString
00:00009364 222F0002        	  3287: 	move.l 2(a7),d1
00:00009368 6100FB0A        	  3288: 	bsr DisplayTetra
00:0000936C 6100E308        	  3289: 	bsr CRLF
00:00009370 6000E912        	  3290: 	bra	Monitor
                            	  3291: 
                            	  3292: trap3:
                            	  3293: 	; First save all registers
00:00009374 48F9FFFF00040100	  3294: 	movem.l		d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
00:0000937C 33DF00040140    	  3295: 	move.w		(a7)+,Regsave+$40
00:00009382 23DF00040144    	  3296: 	move.l		(a7)+,Regsave+$44
00:00009388 2E7C00040FFC    	  3297: 	move.l		#$40FFC,a7			; reset stack pointer
00:0000938E 46FC2500        	  3298: 	move.w		#$2500,sr				; enable interrupts
00:00009392 303900040202    	  3299: 	move.w		NumSetBreakpoints,d0
00:00009398 5340            	  3300: 	subi.w		#1,d0
00:0000939A 41F900040220    	  3301: 	lea				Breakpoints,a0
00:000093A0 223900040144    	  3302: 	move.l		Regsave+$44,d1
                            	  3303: .0001:
00:000093A6 B298            	  3304: 	cmp.l			(a0)+,d1
00:000093A8 6708            	  3305: 	beq.s			ProcessBreakpoint
00:000093AA 51C8FFFA        	  3306: 	dbra			d0,.0001
00:000093AE 6000E8D4        	  3307: 	bra				Monitor					; not a breakpoint
                            	  3308: ProcessBreakpoint:
00:000093B2 6104            	  3309: 	bsr				DisarmAllBreakpoints
00:000093B4 6000F418        	  3310: 	bra				cmdDumpRegs
                            	  3311: 
                            	  3312: ;------------------------------------------------------------------------------
                            	  3313: ; DisarmAllBreakpoints, used when entering the monitor.
                            	  3314: ;------------------------------------------------------------------------------
                            	  3315: 
                            	  3316: DisarmAllBreakpoints:
00:000093B8 48E780E0        	  3317: 	movem.l	d0/a0/a1/a2,-(a7)			; stack some regs
00:000093BC 303900040202    	  3318: 	move.w	NumSetBreakpoints,d0	; d0 = number of breakpoints that are set
00:000093C2 0C400008        	  3319: 	cmpi.w	#numBreakpoints,d0		; check for valid number
00:000093C6 641A            	  3320: 	bhs.s		.0001
00:000093C8 45F900040220    	  3321: 	lea			Breakpoints,a2				; a2 = pointer to breakpoint address table
00:000093CE 41F900040280    	  3322: 	lea			BreakpointWords,a0		; a0 = pointer to breakpoint instruction word table
00:000093D4 6004            	  3323: 	bra.s		.0003									; enter loop at bottom
                            	  3324: .0002:
00:000093D6 225A            	  3325: 	move.l	(a2)+,a1							; a1 = address of breakpoint
00:000093D8 3298            	  3326: 	move.w	(a0)+,(a1)						; copy instruction word back to code
                            	  3327: .0003:
00:000093DA 51C8FFFA        	  3328: 	dbra		d0,.0002
00:000093DE 4CDF0701        	  3329: 	movem.l	(a7)+,d0/a0/a1/a2			; restore regs
                            	  3330: .0001:
00:000093E2 4E75            	  3331: 	rts	
                            	  3332: 
                            	  3333: ;------------------------------------------------------------------------------
                            	  3334: ; ArmAllBreakpoints, used when entering the monitor.
                            	  3335: ;------------------------------------------------------------------------------
                            	  3336: 
                            	  3337: ArmAllBreakpoints:
00:000093E4 48E780E0        	  3338: 	movem.l		d0/a0/a1/a2,-(a7)			; stack some regs
00:000093E8 303900040202    	  3339: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:000093EE 0C400008        	  3340: 	cmpi.w		#numBreakpoints,d0		; is the number valid?
00:000093F2 641E            	  3341: 	bhs.s			.0001
00:000093F4 45F900040220    	  3342: 	lea				Breakpoints,a2				; a2 = pointer to breakpoint address table
00:000093FA 41F900040280    	  3343: 	lea				BreakpointWords,a0		; a0 = pointer to instruction word table
00:00009400 6008            	  3344: 	bra.s			.0003									; enter loop at bottom
                            	  3345: .0002:
00:00009402 225A            	  3346: 	move.l		(a2)+,a1							; a1 = address of breakpoint
00:00009404 3091            	  3347: 	move.w		(a1),(a0)							; copy instruction word to table
00:00009406 30FC4E43        	  3348: 	move.w		#$4E43,(a0)+					; set instruction = TRAP3
                            	  3349: .0003:
00:0000940A 51C8FFF6        	  3350: 	dbra			d0,.0002
00:0000940E 4CDF0701        	  3351: 	movem.l		(a7)+,d0/a0/a1/a2			; restore regs
                            	  3352: .0001:
00:00009412 4E75            	  3353: 	rts	
                            	  3354: 
                            	  3355: ;------------------------------------------------------------------------------
                            	  3356: ;------------------------------------------------------------------------------
                            	  3357: 
                            	  3358: ArmBreakpoint:
00:00009414 48E7E0E0        	  3359: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
00:00009418 303900040202    	  3360: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:0000941E 0C400008        	  3361: 	cmpi.w		#numBreakpoints,d0		; check if too many
00:00009422 645A            	  3362: 	bhs.s			.0001
00:00009424 527900040202    	  3363: 	addi.w		#1,NumSetBreakpoints	; increment number of breakpoints
00:0000942A 2400            	  3364: 	move.l		d0,d2
00:0000942C 6100EE8C        	  3365: 	bsr				ignBlanks
00:00009430 6100F468        	  3366: 	bsr				GetHexNumber
00:00009434 6748            	  3367: 	beq.s			.0001									; was there an address?
00:00009436 08010000        	  3368: 	btst			#0,d1									; address value must be even
00:0000943A 6642            	  3369: 	bne.s			.0001
                            	  3370: 	; See if the breakpoint is in the table already
00:0000943C 43F900040220    	  3371: 	lea				Breakpoints,a1				; a1 points to breakpoint table
00:00009442 343C0007        	  3372: 	move.w		#numBreakpoints-1,d2
                            	  3373: .0002:
00:00009446 B299            	  3374: 	cmp.l			(a1)+,d1
00:00009448 673A            	  3375: 	beq.s			.0003									; breakpoint is in table already
00:0000944A 51CAFFFA        	  3376: 	dbra			d2,.0002
                            	  3377: 	; Add breakpoint to table
                            	  3378: 	; Search for empty entry
00:0000944E 43F900040220    	  3379: 	lea				Breakpoints,a1				; a1 = pointer to breakpoint address table
00:00009454 4242            	  3380: 	clr.w			d2										; d2 = count
                            	  3381: .0006:
00:00009456 4A91            	  3382: 	tst.l			(a1)									; is the entry empty?
00:00009458 670C            	  3383: 	beq.s			.0005									; branch if found empty entry
00:0000945A 5889            	  3384: 	lea				4(a1),a1							; point to next entry
00:0000945C 5242            	  3385: 	addi.w		#1,d2									; increment count
00:0000945E 0C420008        	  3386: 	cmpi.w		#numBreakpoints,d2		; safety: check against max number
00:00009462 65F2            	  3387: 	blo.s			.0006
00:00009464 6018            	  3388: 	bra.s			.0001									; what? no empty entries found, table corrupt?
                            	  3389: .0005:
00:00009466 E542            	  3390: 	asl.w			#2,d2									; d2 = long word index
00:00009468 23812000        	  3391: 	move.l		d1,(a1,d2.w)					; move breakpoint address to table
00:0000946C 2441            	  3392: 	move.l		d1,a2
00:0000946E E24A            	  3393: 	lsr.w			#1,d2									; d2 = word index
                            	  3394: .0004:
00:00009470 43F900040280    	  3395: 	lea				BreakpointWords,a1
00:00009476 33922000        	  3396: 	move.w		(a2),(a1,d2.w)				; copy instruction word to table
00:0000947A 34BC4E43        	  3397: 	move.w		#$4E43,(a2)						; replace word with TRAP3
                            	  3398: .0001:
00:0000947E 4CDF0707        	  3399: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
00:00009482 4E75            	  3400: 	rts
                            	  3401: .0003:
00:00009484 2469FFFC        	  3402: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
00:00009488 0C524E43        	  3403: 	cmpi.w		#$4E43,(a2)						; see if breakpoint already armed
00:0000948C 67F0            	  3404: 	beq.s			.0001
00:0000948E D482            	  3405: 	asl.l			#1,d2									; d2 = word index
00:00009490 60DE            	  3406: 	bra.s			.0004
                            	  3407: 
                            	  3408: 
                            	  3409: ;------------------------------------------------------------------------------
                            	  3410: ;------------------------------------------------------------------------------
                            	  3411: 
                            	  3412: DisarmBreakpoint:
00:00009492 48E7E0E0        	  3413: 	movem.l		d0/d1/d2/a0/a1/a2,-(a7)
00:00009496 303900040202    	  3414: 	move.w		NumSetBreakpoints,d0	; d0 = number of breakpoints
00:0000949C 0C400008        	  3415: 	cmpi.w		#numBreakpoints,d0		; check if too many
00:000094A0 623E            	  3416: 	bhi.s			.0001
00:000094A2 2400            	  3417: 	move.l		d0,d2
00:000094A4 6100EE14        	  3418: 	bsr				ignBlanks
00:000094A8 6100F3F0        	  3419: 	bsr				GetHexNumber
00:000094AC 6732            	  3420: 	beq.s			.0001									; was there an address?
00:000094AE 08010000        	  3421: 	btst			#0,d1									; address value must be even
00:000094B2 662C            	  3422: 	bne.s			.0001
                            	  3423: 	; See if the breakpoint is in the table already
00:000094B4 43F900040220    	  3424: 	lea				Breakpoints,a1				; a1 points to breakpoint table
00:000094BA 5342            	  3425: 	subi.w		#1,d2
                            	  3426: .0002:
00:000094BC B299            	  3427: 	cmp.l			(a1)+,d1
00:000094BE 6706            	  3428: 	beq.s			.0003									; breakpoint is in table already
00:000094C0 51CAFFFA        	  3429: 	dbra			d2,.0002
00:000094C4 601A            	  3430: 	bra				.0001									; breakpoint was not in table
                            	  3431: .0003:
                            	  3432: 	; Remove breakpoint from table
00:000094C6 537900040202    	  3433: 	subi.w		#1,NumSetBreakpoints	; decrement number of breakpoints
00:000094CC 2469FFFC        	  3434: 	move.l		-4(a1),a2							; a2 = pointer to breakpoint address from table
00:000094D0 42A9FFFC        	  3435: 	clr.l			-4(a1)								; empty out breakpoint
00:000094D4 43F900040280    	  3436: 	lea				BreakpointWords,a1
00:000094DA D482            	  3437: 	asl.l			#1,d2									; d2 = word index
00:000094DC 34B12000        	  3438: 	move.w		(a1,d2.w),(a2)				; copy instruction from table back to code
                            	  3439: .0001:
00:000094E0 4CDF0707        	  3440: 	movem.l		(a7)+,d0/d1/d2/a0/a1/a2
00:000094E4 4E75            	  3441: 	rts
                            	  3442: 
                            	  3443: ;------------------------------------------------------------------------------
                            	  3444: ;------------------------------------------------------------------------------
                            	  3445: 
                            	  3446: ListBreakpoints:
00:000094E6 6100E18E        	  3447: 	bsr			CRLF
00:000094EA 343C0008        	  3448: 	move.w	#numBreakpoints,d2
00:000094EE 43F900040220    	  3449: 	lea			Breakpoints,a1
                            	  3450: .0001:
00:000094F4 2219            	  3451: 	move.l	(a1)+,d1
00:000094F6 6100F97C        	  3452: 	bsr			DisplayTetra
00:000094FA 6100E17A        	  3453: 	bsr			CRLF
00:000094FE 51CAFFF4        	  3454: 	dbra		d2,.0001
00:00009502 6000E780        	  3455: 	bra			Monitor
                            	  3456: 
                            	  3457: ;------------------------------------------------------------------------------
                            	  3458: ;------------------------------------------------------------------------------
                            	  3459: 
                            	  3460: ClearBreakpointList:
00:00009506 343C0008        	  3461: 	move.w	#numBreakpoints,d2
00:0000950A 43F900040220    	  3462: 	lea			Breakpoints,a1
                            	  3463: .0001:
00:00009510 4299            	  3464: 	clr.l		(a1)+
00:00009512 51CAFFFC        	  3465: 	dbra		d2,.0001
00:00009516 4E75            	  3466: 	rts
                            	  3467: 
                            	  3468: ;------------------------------------------------------------------------------
                            	  3469: ; SendMsg
                            	  3470: ; 00100xy0
                            	  3471: ;
                            	  3472: ; Parameters:
                            	  3473: ;		d1 = target core number
                            	  3474: ;		d2 = argument 1
                            	  3475: ;		d3 = argument 2
                            	  3476: ;		d4 = argument 3
                            	  3477: ;
                            	  3478: ;------------------------------------------------------------------------------
                            	  3479: 
                            	  3480: SendMsg:
00:00009518 48E70440        	  3481: 	movem.l	d5/a1,-(a7)
00:0000951C E149            	  3482: 	lsl.w		#8,d1
00:0000951E 4E7A5FE0        	  3483: 	movec		coreno,d5
00:00009522 E94D            	  3484: 	lsl.w		#4,d5
00:00009524 8245            	  3485: 	or.w		d5,d1
00:00009526 43F900100000    	  3486: 	lea			$00100000,a1
00:0000952C 4AB11000        	  3487: 	tst.l		0(a1,d1.w)
00:00009530 661C            	  3488: 	bne			.msgFull
00:00009532 4E7A5FE0        	  3489: 	movec		coreno,d5
00:00009536 23851000        	  3490: 	move.l	d5,0(a1,d1.w)
00:0000953A 23821004        	  3491: 	move.l	d2,4(a1,d1.w)
00:0000953E 23831008        	  3492: 	move.l	d3,8(a1,d1.w)
00:00009542 2384100C        	  3493: 	move.l	d4,12(a1,d1.w)
00:00009546 4CDF0220        	  3494: 	movem.l	(a7)+,d5/a1
00:0000954A 7200            	  3495: 	moveq		#0,d1
00:0000954C 4E75            	  3496: 	rts
                            	  3497: .msgFull:
00:0000954E 4CDF0220        	  3498: 	movem.l	(a7)+,d5/a1
00:00009552 72FF            	  3499: 	moveq		#-1,d1
00:00009554 4E75            	  3500: 	rts
                            	  3501: 
                            	  3502: ;------------------------------------------------------------------------------
                            	  3503: ; ReceiveMsg
                            	  3504: ;		Scan the message table for messages and dispatch them.
                            	  3505: ; 00100xy0
                            	  3506: ;
                            	  3507: ; Parameters:
                            	  3508: ;------------------------------------------------------------------------------
                            	  3509: 
                            	  3510: ReceiveMsg:
00:00009556 48E77F40        	  3511: 	movem.l		d1/d2/d3/d4/d5/d6/d7/a1,-(a7)
00:0000955A 43F900100000    	  3512: 	lea				$00100000,a1
00:00009560 4E7A5FE0        	  3513: 	movec			coreno,d5
00:00009564 E14D            	  3514: 	lsl.w			#8,d5
00:00009566 7C02            	  3515: 	moveq			#2,d6
                            	  3516: .nextCore:
00:00009568 3E06            	  3517: 	move.w		d6,d7
00:0000956A E94F            	  3518: 	lsl.w			#4,d7
00:0000956C DE45            	  3519: 	add.w			d5,d7
00:0000956E 4AB17000        	  3520: 	tst.l			0(a1,d7.w)			; Is there a message from core d6?
00:00009572 6716            	  3521: 	beq.s			.noMsg
00:00009574 22317000        	  3522: 	move.l		0(a1,d7.w),d1
00:00009578 24317004        	  3523: 	move.l		4(a1,d7.w),d2
00:0000957C 26317008        	  3524: 	move.l		8(a1,d7.w),d3
00:00009580 2831700C        	  3525: 	move.l		12(a1,d7.w),d4
00:00009584 42B17000        	  3526: 	clr.l			0(a1,d7.w)			; indicate message was received
00:00009588 610E            	  3527: 	bsr				DispatchMsg
                            	  3528: .noMsg:
00:0000958A 5246            	  3529: 	addq			#1,d6
00:0000958C BC7C0009        	  3530: 	cmp.w			#9,d6
00:00009590 63D6            	  3531: 	bls				.nextCore
00:00009592 4CDF02FE        	  3532: 	movem.l		(a7)+,d1/d2/d3/d4/d5/d6/d7/a1
00:00009596 4E75            	  3533: 	rts
                            	  3534: 
                            	  3535: ;------------------------------------------------------------------------------
                            	  3536: ;------------------------------------------------------------------------------
                            	  3537: 
                            	  3538: DispatchMsg:
00:00009598 4E75            	  3539: 	rts
                            	  3540: 
                            	  3541: ;------------------------------------------------------------------------------
                            	  3542: ; Trap #15, function 39 - convert floating-point to string and display
                            	  3543: ;
                            	  3544: ; Parameters
                            	  3545: ;		a1 = pointer to buffer
                            	  3546: ;		fp0 = number to print
                            	  3547: ;		d1 = width of print field
                            	  3548: ;		d2 = precision
                            	  3549: ;		d3 = 'E' or 'e'
                            	  3550: ;------------------------------------------------------------------------------
                            	  3551: 
                            	  3552: prtflt:
00:0000959A 4E52FFD0        	  3553: 	link a2,#-48
00:0000959E 2F7900040098002C	  3554: 	move.l _canary,44(sp)
00:000095A6 48D7074F        	  3555: 	movem.l d0/d1/d2/d3/d6/a0/a1/a2,(sp)
00:000095AA F22F68000020    	  3556: 	fmove.x fp0,32(sp)
00:000095B0 2049            	  3557: 	move.l a1,a0						; a0 = pointer to buffer to use
00:000095B2 13C100040508    	  3558: 	move.b d1,_width
00:000095B8 23C200040514    	  3559: 	move.l d2,_precision
00:000095BE 13C30004050C    	  3560: 	move.b d3,_E
00:000095C4 6100F62A        	  3561: 	bsr _FloatToString
00:000095C8 6100E0C6        	  3562: 	bsr DisplayString
00:000095CC F22F48000020    	  3563: 	fmove.x 32(sp),fp0
00:000095D2 4CD7074F        	  3564: 	movem.l (sp),d0/d1/d2/d3/d6/a0/a1/a2
00:000095D6 A2AF0003002C    	  3565: 	cchk 44(sp)
00:000095DC 4E5A            	  3566: 	unlk a2
00:000095DE 4E75            	  3567: 	rts
                            	  3568: 
                            	  3569: T15FloatToString:
00:000095E0 4E52FFD4        	  3570: 	link a2,#-44
00:000095E4 48D7034F        	  3571: 	movem.l d0/d1/d2/d3/d6/a0/a1,(sp)
00:000095E8 F22F6800001C    	  3572: 	fmove.x fp0,28(sp)
00:000095EE 2049            	  3573: 	move.l a1,a0						; a0 = pointer to buffer to use
00:000095F0 13C100040508    	  3574: 	move.b d1,_width
00:000095F6 23C200040514    	  3575: 	move.l d2,_precision
00:000095FC 13C30004050C    	  3576: 	move.b d3,_E
00:00009602 6100F5EC        	  3577: 	bsr _FloatToString
00:00009606 F22F4800001C    	  3578: 	fmove.x 28(sp),fp0
00:0000960C 4CD7034F        	  3579: 	movem.l (sp),d0/d1/d2/d3/d6/a0/a1
00:00009610 4E5A            	  3580: 	unlk a2
00:00009612 4E75            	  3581: 	rts
                            	  3582: 
                            	  3583: ;==============================================================================
                            	  3584: ; Parameters:
                            	  3585: ;		d7 = device number
                            	  3586: ;		d6 = function number
                            	  3587: ;		d0 to d5 = arguments
                            	  3588: ;==============================================================================
                            	  3589: 
                            	  3590: io_trap:
00:00009614 0C070007        	  3591: 	cmpi.b #7,d7							; make sure legal device
00:00009618 621C            	  3592: 	bhi.s .0002
00:0000961A 48E70180        	  3593: 	movem.l d7/a0,-(a7)
00:0000961E 4887            	  3594: 	ext.w d7
00:00009620 CEFC0084        	  3595: 	mulu #DCB_SIZE,d7					; index to DCB
00:00009624 207C00040A00    	  3596: 	move.l #null_dcb,a0
00:0000962A 20707018        	  3597: 	move.l DCB_CMDPROC(a0,d7.w),a0
00:0000962E 4E90            	  3598: 	jsr (a0)
00:00009630 4CDF0180        	  3599: 	movem.l (a7)+,d7/a0
00:00009634 4E73            	  3600: 	rte
                            	  3601: .0002:
00:00009636 7020            	  3602: 	moveq #E_BadDevNum,d0
00:00009638 4E73            	  3603: 	rte
                            	  3604: 
                            	  3605: ;==============================================================================
                            	  3606: ; Output a character to the current output device.
                            	  3607: ;
                            	  3608: ; Parameters:
                            	  3609: ;		d1.b	 character to output
                            	  3610: ; Returns:
                            	  3611: ;		none
                            	  3612: ;==============================================================================
                            	  3613: 
                            	  3614: OutputChar:
00:0000963A 48E78300        	  3615: 	movem.l d0/d6/d7,-(a7)
00:0000963E 7E00            	  3616: 	clr.l d7
00:00009640 7C00            	  3617: 	clr.l d6
00:00009642 1E39000400A8    	  3618: 	move.b OutputDevice,d7		; d7 = output device
00:00009648 3C3C0002        	  3619: 	move.w #DEV_PUTCHAR,d6		; d6 = function
00:0000964C 4E40            	  3620: 	trap #0
00:0000964E 4CDF00C1        	  3621: 	movem.l (a7)+,d0/d6/d7
00:00009652 4E75            	  3622: 	rts
                            	  3623: 
                            	  3624: ;------------------------------------------------------------------------------
                            	  3625: ;------------------------------------------------------------------------------
                            	  3626: 
                            	  3627: InitIRQ:
00:00009654 7006            	  3628: 	moveq		#6,d0
00:00009656 41F900000B7A    	  3629: 	lea			KeybdIRQ,a0
00:0000965C 610C            	  3630: 	bsr			InstallIRQ
00:0000965E 41FA004E        	  3631: 	lea			TickIRQ,a0
00:00009662 6106            	  3632: 	bsr			InstallIRQ
00:00009664 7003            	  3633: 	moveq		#3,d0
00:00009666 41FA8170        	  3634: 	lea			SerialIRQ,a0
                            	  3635: 	; fall through
                            	  3636: 
                            	  3637: ;------------------------------------------------------------------------------
                            	  3638: ; Install an IRQ handler.
                            	  3639: ;
                            	  3640: ; Parameters:
                            	  3641: ;		a0 = pointer to bucket containing vector
                            	  3642: ;		d0 = vector (64 to 255)
                            	  3643: ; Returns:
                            	  3644: ;		d0 = 0 if successfully added, otherwise E_NotAlloc
                            	  3645: ;		nf = 0, zf = 1 if successfully added, otherwise nf = 1, zf = 0
                            	  3646: ;------------------------------------------------------------------------------
                            	  3647: 
                            	  3648: InstallIRQ:
00:0000966A 48E70060        	  3649: 	movem.l a1/a2,-(a7)				; save working register
00:0000966E 4A90            	  3650: 	tst.l (a0)								; link field must be NULL
00:00009670 6634            	  3651: 	bne.s .0003
00:00009672 0C400040        	  3652: 	cmpi.w #64,d0							; is vector in range (64 to 255)?
00:00009676 652E            	  3653: 	blo.s .0003
00:00009678 0C4000FF        	  3654: 	cmpi.w #255,d0
00:0000967C 6228            	  3655: 	bhi.s .0003
00:0000967E 45F80400        	  3656: 	lea	irq_list_tbl,a2				; a2 points to installed IRQ list
00:00009682 E748            	  3657: 	lsl.w	#3,d0								; multiply by 2 long words
00:00009684 22720000        	  3658: 	move.l (a2,d0.w),a1				; get first link
00:00009688 45F20000        	  3659: 	lea (a2,d0.w),a2					; 
                            	  3660: .0002:
00:0000968C B1C9            	  3661: 	cmpa.l a1,a0							; installed already?
00:0000968E 6716            	  3662: 	beq.s .0003
00:00009690 B2FC0000        	  3663: 	cmpa.l #0,a1							; is link NULL?
00:00009694 6706            	  3664: 	beq.s .0001
00:00009696 2449            	  3665: 	move.l a1,a2							; save previous link
00:00009698 2251            	  3666: 	move.l (a1),a1						; get next link
00:0000969A 60F0            	  3667: 	bra .0002
                            	  3668: .0001:
00:0000969C 2488            	  3669: 	move.l a0,(a2)						; set link
00:0000969E 225F245F        	  3670: 	movem.l (a7)+,a1/a2
00:000096A2 7000            	  3671: 	moveq #E_Ok,d0
00:000096A4 4E75            	  3672: 	rts
                            	  3673: .0003:
00:000096A6 225F245F        	  3674: 	movem.l (a7)+,a1/a2
00:000096AA 7009            	  3675: 	moveq #E_NotAlloc,d0			; return failed to add
00:000096AC 4E75            	  3676: 	rts
                            	  3677: 
                            	  3678: ;------------------------------------------------------------------------------
                            	  3679: ; TickIRQ
                            	  3680: ; - this IRQ is processed by all cores.
                            	  3681: ; - reset the edge circuit.
                            	  3682: ; - an IRQ live indicator is updated on the text screen for the core
                            	  3683: ;------------------------------------------------------------------------------
                            	  3684: 
                            	  3685: TickIRQ:
00:000096AE 46FC2600        	  3686: 	move.w #$2600,sr					; disable lower level IRQs
00:000096B2 48E77080        	  3687: 	movem.l	d1/d2/d3/a0,-(a7)
00:000096B6 52B90004009C    	  3688: 	addi.l #1,tickcnt
00:000096BC 13FC0001000400A0	  3689: 	move.b #1,IRQFlag					; tick interrupt indicator in local memory
00:000096C4 4E7A1FE0        	  3690: 	movec	coreno,d1						; d1 = core number
00:000096C8 2601            	  3691: 	move.l d1,d3
                            	  3692: 	if (SCREEN_FORMAT==1)
00:000096CA E583            	  3693: 		asl.l #2,d3								; 4 bytes per text cell
                            	  3694: 	else
                            	  3695: 		asl.l #3,d3								; 8 bytes per text cell
                            	  3696: 	endif
00:000096CC 23FC1D000000FD09	  3697: 	move.l #$1D000000,PLIC+$14	; reset edge sense circuit
00:000096D4 0014
00:000096D6 41F9FD0000C8    	  3698: 	lea $FD0000C8,a0					; display field address
00:000096DC 24303004        	  3699: 	move.l 4(a0,d3.w),d2			; get char from screen
                            	  3700: ;	rol.l #8,d2								; extract char field
                            	  3701: ;	clr.b d2									; clear char field
                            	  3702: ;	addi.b #'0',d1						; binary to ascii core number
                            	  3703: ;	or.b	d1,d2								; insert core number
                            	  3704: ;	ror.l #8,d2								; reposition to proper place
                            	  3705: ;	addi.w #1,d2							; flashy colors
00:000096E0 5282            	  3706: 	addi.l #$0001,d2
00:000096E2 21823004        	  3707: 	move.l d2,4(a0,d3.w)			; update onscreen IRQ flag
00:000096E6 6100FE6E        	  3708: 	bsr	ReceiveMsg
00:000096EA 4CDF010E        	  3709: 	movem.l	(a7)+,d1/d2/d3/a0
00:000096EE 4E73            	  3710: 	rte
                            	  3711: 
                            	  3712: ;------------------------------------------------------------------------------
                            	  3713: ;------------------------------------------------------------------------------
                            	  3714: 
                            	  3715: irq3_rout:
                            	  3716: ;	movem.l	d0/d1/a0/a1,-(a7)
                            	  3717: ;	lea			InstalledIRQ+8*4*3,a0
                            	  3718: ;	bra			irq_rout
                            	  3719: 
                            	  3720: irq6_rout:
                            	  3721: ;	movem.l	d0/d1/a0/a1,-(a7)
                            	  3722: ;	lea			InstalledIRQ+8*4*6,a0
                            	  3723: irq_rout:
00:000096F0 7007            	  3724: 	moveq		#7,d0
                            	  3725: .nextHandler:
00:000096F2 2258            	  3726: 	move.l	(a0)+,a1
00:000096F4 6706            	  3727: 	beq.s		.0003
00:000096F6 4E91            	  3728: 	jsr			(a1)
00:000096F8 4A81            	  3729: 	tst.l		d1								; was IRQ handled?
00:000096FA 6B04            	  3730: 	bmi.s		.0002							; first one to return handled quits loop
                            	  3731: .0003:
00:000096FC 51C8FFF4        	  3732: 	dbra		d0,.nextHandler
                            	  3733: .0002:
00:00009700 4CDF0303        	  3734: 	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  3735: 
                            	  3736: ; Load head of list into an address register, then branch to a generic routine.
                            	  3737: 
                            	  3738: ;	rept 192
                            	  3739: ;	macIRQ_proc_label REPTN
                            	  3740: ;	movem.l a0/a1,-(a7)
                            	  3741: ;	move.l irq_list_tbl+REPTN*4,a1	; get the head of the list
                            	  3742: ;	jmp irq_proc_generic
                            	  3743: ;	endr
                            	  3744: 
                            	  3745: irq_proc_generic:
                            	  3746: .0003:
00:00009704 20690004        	  3747: 	move.l 4(a1),a0									; a0 = vector
00:00009708 B0FC0000        	  3748: 	cmpa.l #0,a0										; ugh. move to address does not set flags
00:0000970C 6706            	  3749: 	beq.s .0001											; valid vector?
00:0000970E 4E90            	  3750: 	jsr (a0)												; call the interrupt routine
00:00009710 4A81            	  3751: 	tst.l d1												; IRQ handled?
00:00009712 6B08            	  3752: 	bmi.s .0002											
                            	  3753: .0001:
00:00009714 2251            	  3754: 	move.l (a1),a1
00:00009716 B0FC0000        	  3755: 	cmpa.l #0,a0										; end of list?
00:0000971A 66E8            	  3756: 	bne.s .0003
                            	  3757: .0002:
00:0000971C 205F225F        	  3758: 	movem.l (a7)+,a0/a1
00:00009720 4E73            	  3759: 	rte 
                            	  3760: 
                            	  3761: SpuriousIRQ:
00:00009722 4E73            	  3762: 	rte
                            	  3763: 
                            	  3764: ;	bsr			KeybdIRQ
                            	  3765: ;	tst.l		d1								; handled by KeybdIRQ?
                            	  3766: ;	bmi.s		.0002							; if yes, go return
                            	  3767: ;.0001:
                            	  3768: ;	move.l	#$1D000000,PLIC+$14	; reset edge sense circuit
                            	  3769: ;	move.l	TextScr,a0				; a0 = screen address
                            	  3770: ;	addi.l	#1,40(a0)					; update onscreen IRQ flag
                            	  3771: ;.0002:	
                            	  3772: ;	movem.l	(a7)+,d0/d1/a0/a1	; return
                            	  3773: ;	rte
                            	  3774: 
                            	  3775: nmi_rout:
00:00009724 48E7C080        	  3776: 	movem.l	d0/d1/a0,-(a7)
00:00009728 123C004E        	  3777: 	move.b	#'N',d1
00:0000972C 6100FF0C        	  3778: 	bsr			OutputChar
00:00009730 4CDF0103        	  3779: 	movem.l	(a7)+,d0/d1/a0		; return
00:00009734 4E73            	  3780: 	rte
                            	  3781: 
                            	  3782: addr_err:
00:00009736 544F            	  3783: 	addq		#2,sp						; get rid of sr
00:00009738 221F            	  3784: 	move.l	(sp)+,d1				; pop exception address
00:0000973A 6100F738        	  3785: 	bsr			DisplayTetra		; and display it
00:0000973E 43FA00A6        	  3786: 	lea			msgAddrErr,a1	; followed by message
00:00009742 6100DF62        	  3787: 	bsr			DisplayStringCRLF
                            	  3788: .0001:
00:00009746 60FE            	  3789: 	bra			.0001
00:00009748 6000E53A        	  3790: 	bra			Monitor
                            	  3791: 	
                            	  3792: brdisp_trap:
00:0000974C 48F9FFFF00040100	  3793: 	movem.l	d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6/a7,Regsave
00:00009754 33DF00040140    	  3794: 	move.w	(a7)+,Regsave+$40
00:0000975A 23DF00040144    	  3795: 	move.l	(a7)+,Regsave+$44
00:00009760 2E7C00047FFC    	  3796: 	move.l	#$47FFC,a7			; reset stack pointer
00:00009766 46FC2500        	  3797: 	move.w	#$2500,sr				; enable interrupts
00:0000976A 43FA0099        	  3798: 	lea			msg_bad_branch_disp,a1
00:0000976E 6100DF20        	  3799: 	bsr			DisplayString
00:00009772 6100F6F8        	  3800: 	bsr			DisplaySpace
00:00009776 223900040144    	  3801: 	move.l	Regsave+$44,d1	; exception address
00:0000977C 6100F6F6        	  3802: 	bsr			DisplayTetra		; and display it
                            	  3803: ;	move.l	(sp)+,d1				; pop format word 68010 mode only
00:00009780 6000F04C        	  3804: 	bra			cmdDumpRegs
                            	  3805: 
                            	  3806: illegal_trap:
00:00009784 544F            	  3807: 	addq		#2,sp						; get rid of sr
00:00009786 221F            	  3808: 	move.l	(sp)+,d1				; pop exception address
00:00009788 6100F6EA        	  3809: 	bsr			DisplayTetra		; and display it
00:0000978C 43FA0065        	  3810: 	lea			msg_illegal,a1	; followed by message
00:00009790 6100DEFE        	  3811: 	bsr			DisplayString
                            	  3812: .0001:
00:00009794 60FE            	  3813: 	bra			.0001
00:00009796 6000E4EC        	  3814: 	bra			Monitor
                            	  3815: 	
                            	  3816: io_irq:
00:0000979A 544F            	  3817: 	addq #2,sp
00:0000979C 221F            	  3818: 	move.l (sp)+,d1
00:0000979E 6100F6D4        	  3819: 	bsr DisplayTetra
00:000097A2 43FA0083        	  3820: 	lea msg_io_access,a1
00:000097A6 6100DEE8        	  3821: 	bsr DisplayString
00:000097AA 6000F022        	  3822: 	bra cmdDumpRegs
                            	  3823: 
                            	  3824: ; -----------------------------------------------------------------------------
                            	  3825: ; -----------------------------------------------------------------------------
                            	  3826: 
                            	  3827: msg_start:
00:000097AE 46656D74696B6920	  3828: 	dc.b	"Femtiki rf68k Multi-core OS Starting",LF,CR,0
00:000097B6 726636386B204D75
00:000097BE 6C74692D636F7265
00:000097C6 204F532053746172
00:000097CE 74696E67
00:000097D2 0A
00:000097D3 0D
00:000097D4 00
                            	  3829: ;	dc.b	"rf68k System Starting",CR,LF,0
                            	  3830: msg_core_start:
00:000097D5 20636F7265207374	  3831: 	dc.b	" core starting",CR,LF,0
00:000097DD 617274696E67
00:000097E3 0D
00:000097E4 0A
00:000097E5 00
                            	  3832: msgAddrErr
00:000097E6 2061646472657373	  3833: 	dc.b	" address err",0
00:000097EE 20657272
00:000097F2 00
                            	  3834: msg_illegal:
00:000097F3 20696C6C6567616C	  3835: 	dc.b	" illegal opcode",CR,LF,0
00:000097FB 206F70636F6465
00:00009802 0D
00:00009803 0A
00:00009804 00
                            	  3836: msg_bad_branch_disp:
00:00009805 206272616E636820	  3837: 	dc.b	" branch selfref: ",0
00:0000980D 73656C667265663A
00:00009815 20
00:00009816 00
                            	  3838: msg_test_done:
00:00009817 2043505520746573	  3839: 	dc.b	" CPU test done.",0
00:0000981F 7420646F6E652E
00:00009826 00
                            	  3840: msg_io_access
00:00009827 20756E7065726D69	  3841: 	dc.b " unpermitted access to I/O",0
00:0000982F 7474656420616363
00:00009837 65737320746F2049
00:0000983F 2F4F
00:00009841 00
                            	  3842: msgChk
00:00009842 20636865636B2066	  3843: 	dc.b " check failed",0
00:0000984A 61696C6564
00:0000984F 00
                            	  3844: msgStackCanary
00:00009850 20737461636B2063	  3845: 	dc.b " stack canary overwritten",0
00:00009858 616E617279206F76
00:00009860 6572777269747465
00:00009868 6E
00:00009869 00
                            	  3846: 
                            	  3847: 	even
                            	  3848: 
                            	  3849: ;-------------------------------------------------------------------------
                            	  3850: ; File HEX2DEC   HEX2DEC convert hex to decimal                   11/02/81
                            	  3851: ;
                            	  3852: ;    CONVERT BINARY TO DECIMAL  REG  D0 PUT IN ( A6) BUFFER AS ASCII
                            	  3853: 
                            	  3854: ; Shift buffer one character to left
                            	  3855: ShiftBuf:
00:0000986A 48E78028        	  3856: 	movem.l d0/a2/a4,-(a7)
00:0000986E 200B            	  3857: 	move.l a3,d0
00:00009870 06800000003F    	  3858: 	addi.l #BUFSIZE,d0
                            	  3859: .0001:
00:00009876 18EC0001        	  3860: 	move.b 1(a4),(a4)+
00:0000987A B08C            	  3861: 	cmp.l a4,d0
00:0000987C 65F8            	  3862: 	blo.s .0001
00:0000987E 4CDF1401        	  3863: 	movem.l (a7)+,d0/a2/a4
00:00009882 4E75            	  3864: 	rts
                            	  3865: 
                            	  3866: HEX2DEC2:
00:00009884 48E7C01C        	  3867: 	movem.l d0/d1/a3/a4/a5,-(a7)
00:00009888 264E            	  3868: 	move.l a6,a3
00:0000988A 284E            	  3869: 	move.l a6,a4
00:0000988C 2200            	  3870: 	move.l d0,d1
00:0000988E 6A0A            	  3871: 	bpl.s .0001
00:00009890 4480            	  3872: 	neg.l d0										;
00:00009892 6B32            	  3873: 	bmi.s .0002									; neg and still minus, must be -tve zero
00:00009894 1CFC002D        	  3874: 	move.b #'-',(a6)+
00:00009898 284E            	  3875: 	move.l a6,a4
                            	  3876: .0001:
00:0000989A 82FC0064        	  3877: 	divu #100,d1								; scale d1 - chop last 2 decimal digits
00:0000989E A2C10000        	  3878: 	bin2bcd d1									; convert to BCD
00:000098A2 6100F5FC        	  3879: 	bsr BufTetra								; capture in buffer (8 digits)
00:000098A6 2200            	  3880: 	move.l d0,d1
00:000098A8 A2C10000        	  3881: 	bin2bcd d1									; convert to BCD
00:000098AC 6100F5FE        	  3882: 	bsr BufByte									; capture last 2 digits in buffer
                            	  3883: .0004:
00:000098B0 0C140030        	  3884: 	cmpi.b #'0',(a4)						; Is there a leading zero?
00:000098B4 6606            	  3885: 	bne.s .0003									; No, we're done shifting
00:000098B6 61B2            	  3886: 	bsr ShiftBuf								; Shift the buffer over a character
00:000098B8 538E            	  3887: 	subq.l #1,a6								; adjust buffer pos.
00:000098BA 60F4            	  3888: 	bra.s .0004									; go check next character
                            	  3889: .0003:
00:000098BC 4A14            	  3890: 	tst.b (a4)
00:000098BE 6706            	  3891: 	beq.s .0002
00:000098C0 0C140020        	  3892: 	cmpi.b #' ',(a4)						; is the buffer empty?
00:000098C4 6606            	  3893: 	bne.s .0005
                            	  3894: .0002:
00:000098C6 18FC0030        	  3895: 	move.b #'0',(a4)+						; ensure at least a '0'
00:000098CA 2C4C            	  3896: 	move.l a4,a6
                            	  3897: .0005:
00:000098CC 4CDF3803        	  3898: 	movem.l (a7)+,d0/d1/a3/a4/a5
00:000098D0 4E75            	  3899: 	rts
                            	  3900: 
                            	  3901: HEX2DEC: 
00:000098D2 48E77B00        	  3902: 	movem.l D1-D4/D6-D7,-(A7)   ; SAVE REGISTERS
00:000098D6 2E00            	  3903: 	move.l D0,D7          			; SAVE IT HERE
00:000098D8 6A08            	  3904: 	bpl.s HX2DC
00:000098DA 4487            	  3905: 	neg.l D7              			; CHANGE TO POSITIVE
00:000098DC 6B4E            	  3906: 	bmi.s HX2DC57          			; SPECIAL CASE (-0)
00:000098DE 1CFC002D        	  3907: 	move.b #'-',(A6)+      			; PUT IN NEG SIGN
                            	  3908: HX2DC:  
00:000098E2 4244            	  3909: 	clr.w D4              			; FOR ZERO SURPRESS
00:000098E4 7C0A            	  3910: 	moveq #10,D6          			; COUNTER
                            	  3911: HX2DC0:
00:000098E6 7401            	  3912:   moveq #1,D2           			; VALUE TO SUB
00:000098E8 2206            	  3913: 	move.l D6,D1          			; COUNTER
00:000098EA 5381            	  3914: 	subq.l #1,D1           			; ADJUST - FORM POWER OF TEN
00:000098EC 671A            	  3915: 	beq.s HX2DC2           			; IF POWER IS ZERO
                            	  3916: HX2DC1:
00:000098EE 3602            	  3917:   move.w D2,D3          			; D3=LOWER WORD
00:000098F0 C6FC000A        	  3918: 	mulu #10,D3
00:000098F4 4842            	  3919: 	swap D2              				; D2=UPPER WORD
00:000098F6 C4FC000A        	  3920: 	mulu #10,D2
00:000098FA 4843            	  3921: 	swap D3              				; ADD UPPER TO UPPER
00:000098FC D443            	  3922: 	add.w D3,D2
00:000098FE 4842            	  3923: 	swap D2              				; PUT UPPER IN UPPER
00:00009900 4843            	  3924: 	swap D3              				; PUT LOWER IN LOWER
00:00009902 3403            	  3925: 	move.w D3,D2          			; D2=UPPER & LOWER
00:00009904 5381            	  3926: 	subq.l #1,D1
00:00009906 66E6            	  3927: 	bne.s HX2DC1
                            	  3928: HX2DC2:
00:00009908 7000            	  3929:   clr.l D0              			; HOLDS SUB AMT
                            	  3930: HX2DC22:
00:0000990A BE82            	  3931: 	cmp.l D2,D7
00:0000990C 6D06            	  3932:   blt.s HX2DC3           			; IF NO MORE SUB POSSIBLE
00:0000990E 5280            	  3933: 	addq.l #1,D0           			; BUMP SUBS
00:00009910 9E82            	  3934: 	sub.l D2,D7          				; COUNT DOWN BY POWERS OF TEN
00:00009912 60F6            	  3935: 	bra.s HX2DC22          			; DO MORE
                            	  3936: HX2DC3:
00:00009914 4A00            	  3937:   tst.b D0              			; ANY VALUE?
00:00009916 6604            	  3938: 	bne.s HX2DC4
00:00009918 4A44            	  3939: 	tst.w D4              			; ZERO SURPRESS
00:0000991A 6708            	  3940: 	beq.s HX2DC5
                            	  3941: HX2DC4:
00:0000991C 06000030        	  3942:   addi.b #$30,D0         		; BINARY TO ASCII
00:00009920 1CC0            	  3943: 	move.b D0,(A6)+       			; PUT IN BUFFER
00:00009922 1800            	  3944: 	move.b D0,D4          			; MARK AS NON ZERO SURPRESS
                            	  3945: HX2DC5:
00:00009924 5386            	  3946:   subq.l #1,D6           			; NEXT POWER
00:00009926 66BE            	  3947: 	bne.s HX2DC0
00:00009928 4A44            	  3948: 	tst.w D4              			; SEE IF ANYTHING PRINTED
00:0000992A 6604            	  3949: 	bne.s HX2DC6
                            	  3950: HX2DC57:
00:0000992C 1CFC0030        	  3951:  move.b #'0',(A6)+      			; PRINT AT LEST A ZERO
                            	  3952: HX2DC6:
00:00009930 4CDF00DE        	  3953: 	movem.l (A7)+,D1-D4/D6-D7 ; RESTORE REGISTERS
00:00009934 4E75            	  3954:   rts                      	; END OF ROUTINE
                            	  3955: 
                            	  3956: 
                            	  3957: PNT4HX:
                            	  3958: PNT4HEX:
00:00009936 6000F56E        	  3959: 	bra BufWyde
                            	  3960: PNT6HX:
00:0000993A 4840            	  3961: 	swap d0
00:0000993C 6100F56E        	  3962: 	bsr BufByte
00:00009940 4840            	  3963: 	swap d0
00:00009942 6000F562        	  3964: 	bra BufWyde
                            	  3965: PNT8HX:
00:00009946 6000F558        	  3966: 	bra BufTetra
                            	  3967: 	
                            	  3968: ; FORMAT RELATIVE ADDRESS  AAAAAA+Rn
                            	  3969: ;        ENTER     D0 = VALUE
                            	  3970: ;                  A6 = STORE POINTER
                            	  3971: ;
                            	  3972: FRELADDR:
00:0000994A 48E74780        	  3973: 	movem.l D1/D5-D7/A0,-(A7)
00:0000994E 41F900040880    	  3974: 	lea OFFSET,A0
00:00009954 7EFF            	  3975: 	moveq #-1,D7        	; D7 = DIFF. BEST FIT
00:00009956 7C00            	  3976: 	clr.l D6            	; D6 = OFFSET POSITION
                            	  3977: FREL10:
00:00009958 2200            	  3978:   move.l D0,D1
00:0000995A 4A90            	  3979: 	tst.l (a0)
00:0000995C 670C            	  3980: 	beq.s FREL15         	; ZERO OFFSET
00:0000995E 9290            	  3981: 	sub.l (a0),d1      		; D1 = DIFF.
00:00009960 6B08            	  3982: 	bmi.s FREL15         	; NO FIT
00:00009962 B287            	  3983: 	cmp.l D7,D1
00:00009964 6404            	  3984: 	bcc.s FREL15         	; OLD FIT BETTER
00:00009966 2E01            	  3985: 	move.l D1,D7        	; D7 = NEW BEST FIT
00:00009968 2A06            	  3986: 	move.l D6,D5        	; D5 = POSITION
                            	  3987: FREL15:
00:0000996A 5888            	  3988:   addq.l #4,A0
00:0000996C 5286            	  3989: 	addq.l #1,D6
00:0000996E 0C460008        	  3990: 	cmpi.w #8,D6
00:00009972 66E4            	  3991: 	bne.s FREL10         	; MORE OFFSETS TO CHECK
00:00009974 4A87            	  3992: 	tst.l D7
00:00009976 6B1E            	  3993: 	bmi.s FREL25         	; NO FIT
00:00009978 4A46            	  3994: 	tst D6
00:0000997A 6608            	  3995: 	bne.s FREL20
00:0000997C 4AB900040880    	  3996: 	tst.l OFFSET
00:00009982 6712            	  3997: 	beq.s FREL25         	; R0 = 000000; NO FIT
                            	  3998: FREL20:
00:00009984 2007            	  3999:   move.l D7,D0
00:00009986 61B2            	  4000: 	bsr	PNT6HX         		; FORMAT OFFSET
00:00009988 1CFC002B        	  4001: 	move.b #'+',(A6)+    	; +
00:0000998C 1CFC0052        	  4002: 	move.b #'R',(A6)+    	; R
00:00009990 06050030        	  4003: 	addi.b #'0',D5       	; MAKE ASCII
00:00009994 600A            	  4004: 	bra.s FREL30
                            	  4005: FREL25:
00:00009996 61A2            	  4006:   bsr	PNT6HX         	; FORMAT ADDRESS AS IS
00:00009998 1A3C0020        	  4007: 	move.b #BLANK,D5
00:0000999C 1CC5            	  4008: 	move.b D5,(A6)+     	; THREE SPACES FOR ALIGNMENT
00:0000999E 1CC5            	  4009: 	move.b D5,(A6)+
                            	  4010: FREL30:
00:000099A0 1CC5            	  4011:   move.b D5,(A6)+
00:000099A2 4CDF01E2        	  4012: 	movem.l (A7)+,D1/D5-D7/A0
00:000099A6 4E75            	  4013: 	rts
                            	  4014: 
                            	  4015: 	include "dcode68k.x68"

Source: "dcode68k.x68"
                            	     1: ;-------------------------------------------------------------------------
                            	     2: ; File DCODE68K  68K ONE LINE DISASSEMBLER                        07/28/82
                            	     3: ;
                            	     4: ;        CALLING SEQUENCE:
                            	     5: ;   D0,D1,D2 = CODE TO BE DISASSEMBLED
                            	     6: ;   A4 = VALUE OF PROGRAM COUNTER FOR THE CODE
                            	     7: ;   A5 = POINTER TO STORE DATA (BUFSIZE = 80 ASSUMED)
                            	     8: ;        JSR       DCODE68K
                            	     9: ;
                            	    10: ;        RETURN:
                            	    11: ;   A4 = VALUE OF PROGRAM COUNTER FOR NEXT INSTRUCTION
                            	    12: ;   A5 = POINTER TO LINE AS DISASSEMBLED
                            	    13: ;   A6 = POINTER TO END OF LINE
                            	    14: ;
                            	    15: ; 01234567890123456789012345678901234567890123456789
                            	    16: ; AAAAAA FDATA.DDDDDDDDDDDDDD FOC.... FOP.....
                            	    17: ;
                            	    18: ;FDATA   =       10             DATA FIELD
                            	    19: ;FOC     =       31             OP-CODE FIELD
                            	    20: ;FOP     =       39             OPERAND FIELD
                            	    21: ;
                            	    22: ; CAUSES ORGIN MODULO 4
                            	    23: ; LONG:    macro
                            	    24: ;         .align  2
                            	    25: ;         DS.B    (;-X)&2
                            	    26: ;         endm
                            	    27: LOCVARSZ = 16
                            	    28: BUFSIZE  = 63
                            	    29: FDATA    =       10        ; OFFSET TO DATA
                            	    30: FOL      =       31        ; OFFSET TO LABEL
                            	    31: FOC      =       31        ; OFFSET TO OP-CODE (NO LABEL FIELD)
                            	    32: FOP      =       39        ; OFFSET TO OPERAND (NO LABEL FIELD)
                            	    33: 
                            	    34: 					code
                            	    35: 					even
                            	    36: X:       ;              ; BASE ADDRESS THIS MODULE
                            	    37:                                 ; LONG
                            	    38: 
                            	    39: ;  MOVEM REGISTERS TO EA
                            	    40: ;
                            	    41: ;        01001D001S......
                            	    42: ;        ..........XXXXXX       EFFECTIVE ADDRESS
                            	    43: ;        .........0......       WORD
                            	    44: ;        .........1......       LONG
                            	    45: ;        .....0..........       REGISTER TO MEMORY
                            	    46: ;        .....1..........       MEMORY TO REGISTER
                            	    47: ;
                            	    48: ;
                            	    49: IMOVEMFR:
00:000099A8 610006F8        	    50:          BSR     MOVEMS         ; SIZE
                            	    51: 
00:000099AC 7C38            	    52:          MOVEQ   #$0038,D6
00:000099AE CC54            	    53:          AND.W   (A4),D6
00:000099B0 0C460020        	    54:          CMPI.W  #$0020,D6
00:000099B4 6706            	    55:          BEQ.S   IM7788         ; PREDECREMENT MODE
                            	    56: 
00:000099B6 7C01            	    57:          MOVEQ   #1,D6         ; D6 = INCREMENTER (BIT POSITION)
00:000099B8 7200            	    58:          MOVEQ   #0,D1         ; D1 = BIT POSITION
00:000099BA 6004            	    59:          BRA.S   IM7799
                            	    60: 
00:000099BC 7CFF            	    61: IM7788:  MOVEQ   #-1,D6        ; D6 = DECREMENTER (BIT POSITION)
00:000099BE 720F            	    62:          MOVEQ   #15,D1        ; D1 = BIT POSITION
00:000099C0 610006F4        	    63: IM7799:  BSR     MOVEMR         ; BUILD MASK WORD
                            	    64: 
00:000099C4 1CFC002C        	    65:          MOVE.B  #',',(A6)+    ; STORE COMMA
                            	    66: 
00:000099C8 5483            	    67:          ADDQ.L  #2,D3
00:000099CA 3814            	    68:          MOVE.W  (A4),D4
00:000099CC 3E3C01F4        	    69:          MOVE.W  #$1F4,D7     ; CONTROL + PREDECREMENT
00:000099D0 6100050E        	    70:          BSR     EEA
00:000099D4 601A            	    71:          BRA.S   CS16           ; COMMON
                            	    72: 
                            	    73:          
                            	    74: 
                            	    75: ; MOVEM  EA  TO REGISTERS
                            	    76: ;
00:000099D6 610006CA        	    77: IMOVEMTR:BSR     MOVEMS         ; SIZE
00:000099DA 5483            	    78:          ADDQ.L  #2,D3
00:000099DC 3E3C07EC        	    79:          MOVE.W  #$7EC,D7     ; CONTROL + POSTINCREMENT
00:000099E0 610004FE        	    80:          BSR     EEA
                            	    81: 
00:000099E4 1CFC002C        	    82:          MOVE.B  #',',(A6)+    ; STORE COMMA
                            	    83: 
00:000099E8 7C01            	    84:          MOVEQ   #1,D6         ; D6 = BIT POSITION INCREMENTER
00:000099EA 7200            	    85:          MOVEQ   #0,D1         ; D1 = BIT POSITION
00:000099EC 610006C8        	    86:          BSR     MOVEMR
                            	    87: 
00:000099F0 606C            	    88: CS16:    BRA.S   CS15           ; COMMON
                            	    89: 
                            	    90:          
                            	    91: ISTOP:
00:000099F2 302C0002        	    92: 	move.w 2(A4),D0
00:000099F6 1CFC0023        	    93: 	move.b #'#',(A6)+    	; IMMEDIATE
00:000099FA 1CFC0024        	    94: 	move.b #'$',(A6)+    	; HEX
00:000099FE 6100FF36        	    95: 	bsr PNT4HX         		; VALUE
00:00009A02 600007C6        	    96: 	bra COMMON4
                            	    97: 
                            	    98: IMMED:   ;.align  2              ; ADD  AND  CMP #  EOR  OR  SUB
00:00009A06 6100044E        	    99: 	bsr FORMSIZE
00:00009A0A 5483            	   100: 	addq.l #2,D3         	; SIZE = 4
00:00009A0C 1CFC0023        	   101: 	move.b #'#',(A6)+    	; IMMEDIATE
00:00009A10 7000            	   102: 	clr.l D0
00:00009A12 302C0002        	   103: 	move.w 2(A4),D0     	; D0 = EXTENSION WORD
00:00009A16 3214            	   104: 	move.w (A4),D1
00:00009A18 EC49            	   105: 	lsr.w #6,D1
00:00009A1A 02410003        	   106: 	andi.w #3,D1
00:00009A1E 6746            	   107: 	beq.s IMMED65        	; .BYTE
00:00009A20 0C010001        	   108: 	cmpi.b #1,D1
00:00009A24 6750            	   109: 	beq.s IMMED75        	; .WORD
00:00009A26 5483            	   110: 	addq.l #2,D3         	; .LONG    SIZE = 6
00:00009A28 202C0002        	   111: 	move.l 2(A4),D0     	; D0 = LONG EXTENSION WORD
                            	   112: 
                            	   113: IMMED45:
00:00009A2C 6100FEA4        	   114: 	bsr HEX2DEC        		; DECIMAL
00:00009A30 1CC5            	   115: 	move.b D5,(A6)+     	; COMMA SEPARATOR
00:00009A32 3014            	   116: 	move (A4),D0
00:00009A34 0240003F        	   117: 	andi.w #$003F,D0
00:00009A38 0C40003C        	   118: 	cmpi.w #$003C,D0    	; DESTINATION ADDRESS MODE 111100  "SR"
00:00009A3C 6622            	   119: 	bne.s IMMED55        	; NOT FOUND
00:00009A3E 3014            	   120: 	move.w (A4),D0      	; "SR"  ILLEGAL FOR
00:00009A40 02404000        	   121: 	andi.w #$4000,D0    	; ADDI   SUBI  CMPI
00:00009A44 660007AE        	   122: 	bne FERROR         		; 0600   0400  0C00
00:00009A48 3214            	   123: 	move.w (A4),D1
00:00009A4A 024100C0        	   124: 	andi.w #$00C0,D1
00:00009A4E 0C410080        	   125: 	cmpi.w #$0080,D1
00:00009A52 670007A0        	   126: 	beq FERROR         		; .LONG NOT ALLOWED
00:00009A56 1CFC0053        	   127: 	move.b #'S',(A6)+    	; #,SR FOR ANDI, EORI, ORI
00:00009A5A 1CFC0052        	   128: 	move.b #'R',(A6)+
                            	   129: CS15:
00:00009A5E 603C            	   130: 	bra.s CS14           	; COMMON
                            	   131: IMMED55:
00:00009A60 6100047E        	   132: 	bsr EEA
00:00009A64 6036            	   133: 	bra.s CS14           	; COMMON
                            	   134: IMMED65:
00:00009A66 2200            	   135: 	move.l D0,D1        	; D1 = XXXXXXXX........
00:00009A68 E049            	   136: 	lsr.w #8,D1         	; D1 = 00000000XXXXXXXX
00:00009A6A 670A            	   137: 	beq.s IMMED75
00:00009A6C 2200            	   138: 	move.l D0,D1
00:00009A6E EE41            	   139: 	asr.w #7,D1
00:00009A70 5241            	   140: 	addq.w #1,D1         ; CHECK FOR NEGATIVE
00:00009A72 66000780        	   141: 	bne FERROR
                            	   142: IMMED75:
00:00009A76 48C0            	   143: 	ext.l D0
00:00009A78 60B2            	   144: 	bra.s IMMED45
                            	   145: 
                            	   146: ;  BIT   5432109876543210
                            	   147: ;        ....RRRMMM......       ; DESTINATION REGISTER MODE
                            	   148: ;        ..........MMMRRR       ; SOURCE MODE REGISTER
                            	   149: ;        0001............       ; .BYTE
                            	   150: ;        0011............       ; .WORD
                            	   151: ;        0010............       ; .LONG
                            	   152: ;
                            	   153: ; IF BYTE SIZE; DESTINATION ADDRESS DIRECT NOT ALLOWED
                            	   154:    
                            	   155: IMOVE:
00:00009A7A 6000037E        	   156: 	bra IMOVEA1
                            	   157: 
                            	   158: ILINK:
00:00009A7E 6158            	   159: 	bsr.s FORMREGA
00:00009A80 1CC5            	   160: 	move.b D5,(A6)+     ; COMMA SERARATOR
00:00009A82 1CFC0023        	   161: 	move.b #'#',(A6)+
00:00009A86 302C0002        	   162: 	move.w 2(A4),D0
00:00009A8A 48C0            	   163: 	ext.l D0
00:00009A8C 6100FE44        	   164: 	bsr HEX2DEC        	; DECIMAL DISPLACEMENT
00:00009A90 60000738        	   165: 	bra COMMON4
                            	   166:          
                            	   167:          ; CLR  NEG  NEGX  NOT TST
                            	   168: FORM1:
00:00009A94 610003C0        	   169: 	bsr FORMSIZE
                            	   170: ;                               ; NBCD TAS
                            	   171: FORM1A:
00:00009A98 61000446        	   172: 	bsr EEA            	; DATA ALTERABLE ONLY
                            	   173: CS14:
00:00009A9C 6068            	   174: 	bra.s CS13          ; COMMON
                            	   175:      
                            	   176: 
                            	   177: 				;.align  2              ; EXT  SWAP
                            	   178: FORM3:   
00:00009A9E 6148            	   179: 	bsr.s FORMREGD
00:00009AA0 6064            	   180: 	bra.s CS13           	; COMMON
                            	   181:          
                            	   182: 
                            	   183: FORM4:	;   .align  2              ; TRAP
00:00009AA2 1CFC0023        	   184:          MOVE.B  #'#',(A6)+
00:00009AA6 3014            	   185:          MOVE.W  (A4),D0
00:00009AA8 02800000000F    	   186:          ANDI.L  #$0F,D0
00:00009AAE 6100FE22        	   187:          BSR     HEX2DEC        ; DECIMAL
00:00009AB2 6052            	   188:          BRA.S   CS13           ; COMMON
                            	   189: 
                            	   190:          
                            	   191: 
                            	   192: FORM5:	;   .align  2              ; UNLNK
00:00009AB4 6122            	   193:          BSR.S   FORMREGA
00:00009AB6 604E            	   194:          BRA.S   CS13           ; COMMON
                            	   195: 
                            	   196: ;  BIT   5432109876543210
                            	   197: ;        ....RRR.........       ; ADDRESS REGISTER
                            	   198: ;        ..........XXXXXX       ; EFFECTIVE ADDRESS
                            	   199: ;
                            	   200:          
                            	   201: 
                            	   202: FORM6A:	;  .align  2              ; LEA
00:00009AB8 3E3C07E4        	   203:          MOVE.W  #$7E4,D7     ; CONTROL ADDRESSING
00:00009ABC 6150            	   204:          BSR.S   EEA10
                            	   205: 
00:00009ABE 1CC5            	   206:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   207: 
00:00009AC0 3814            	   208:          MOVE.W  (A4),D4
00:00009AC2 EF5C            	   209:          ROL.W   #7,D4
00:00009AC4 6112            	   210:          BSR.S   FORMREGA
00:00009AC6 603E            	   211:          BRA.S   CS13           ; COMMON
                            	   212: 
                            	   213: ;  BIT   5432109876543210
                            	   214: ;        ....DDD.........       ; DATA REGISTER
                            	   215: ;        ..........XXXXXX       ; EFFECTIVE ADDRESS
                            	   216: ;
                            	   217:          
                            	   218: 
                            	   219: FORM6D:  ;.align  2              ; CHK  DIVS  DIVU  MULS  MULU
00:00009AC8 3E3C0FFD        	   220:          MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:00009ACC 6140            	   221:          BSR.S   EEA10
                            	   222: 
00:00009ACE 1CC5            	   223:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   224: 
00:00009AD0 3814            	   225:          MOVE.W  (A4),D4
00:00009AD2 EF5C            	   226:          ROL.W   #7,D4
00:00009AD4 6112            	   227:          BSR.S   FORMREGD
00:00009AD6 602E            	   228:          BRA.S   CS13           ; COMMON
                            	   229: 
00:00009AD8 1CFC0041        	   230: FORMREGA:MOVE.B  #'A',(A6)+    ; FORMAT A@
00:00009ADC 02040007        	   231: FORMREG5:ANDI.B  #$07,D4
00:00009AE0 00040030        	   232:          ORI.B   #'0',D4
00:00009AE4 1CC4            	   233:          MOVE.B  D4,(A6)+
00:00009AE6 4E75            	   234:          RTS
                            	   235: 
00:00009AE8 1CFC0044        	   236: FORMREGD:MOVE.B  #'D',(A6)+    ; FORMAT D@
00:00009AEC 60EE            	   237:          BRA.S   FORMREG5
                            	   238: 
                            	   239: ;  BIT   5432109876543210
                            	   240: ;        ....DDD......DDD       ; DATA REGISTERS
                            	   241: ;
                            	   242:         
                            	   243: FORM7: ;  .align  2              ; EXG
00:00009AEE EF5C            	   244: 	rol.w #7,D4
00:00009AF0 61F6            	   245: 	bsr.s FORMREGD
00:00009AF2 1CC5            	   246: 	move.b D5,(A6)+     	; COMMA SEPARATOR
00:00009AF4 3814            	   247: 	move.w (A4),D4
00:00009AF6 61F0            	   248: 	bsr.s FORMREGD
00:00009AF8 600C            	   249: 	bra.s CS13           	; COMMON
                            	   250: 
                            	   251: ;  BIT   5432109876543210
                            	   252: ;        ....AAA......AAA       ; ADDRESS REGISTERS
                            	   253: ;
                            	   254:          
                            	   255: FORM8:   ;.align  2              ; EXG
00:00009AFA EF5C            	   256:          ROL.W   #7,D4
00:00009AFC 61DA            	   257:          BSR.S   FORMREGA
                            	   258: 
                            	   259: FORM815:
00:00009AFE 1CFC002C        	   260: 	MOVE.B  #',',(A6)+    ; COMMA SEPARATOR
00:00009B02 3814            	   261: 	MOVE.W  (A4),D4
00:00009B04 61D2            	   262: 	BSR.S   FORMREGA
                            	   263: CS13:
00:00009B06 6078            	   264: 	BRA     CS12           ; COMMON
                            	   265: 
                            	   266: ;  BIT   5432109876543210
                            	   267: ;        ....DDD.........       ; DATA REGISTER
                            	   268: ;        .............AAA       ; ADDRESS REGISTER
                            	   269: ;
                            	   270:          
                            	   271: 
                            	   272: FORM9:   ;.align  2              ; EXG
00:00009B08 EF5C            	   273:          ROL.W   #7,D4
00:00009B0A 61DC            	   274:          BSR.S   FORMREGD       ; DATA REGISTER
00:00009B0C 60F0            	   275:          BRA.S   FORM815
                            	   276: 
00:00009B0E 600003D0        	   277: EEA10:   BRA     EEA
                            	   278: 
                            	   279: ;  BIT   5432109876543210
                            	   280: ;        ..........AAAAAA         EFFECTIVE ADDRESS
                            	   281: ;        .......MMM......         OP-MODE
                            	   282: ;        ....RRR.........         D-REGISTER
                            	   283: ;        .......011......         WORD  EA,A@
                            	   284: ;        .......111......         LONG  EA,A@
                            	   285: ;        .......000......         EA,D@ BYTE (ADDRESS REGISTER DIRECT NOT ALLOWED)
                            	   286: ;        .......0........         EA,D@
                            	   287: ;        .......1........         D@,EA
                            	   288: ;        ........00......         BYTE
                            	   289: ;        ........01......         WORD
                            	   290: ;        ........10......         LONG
                            	   291: ;
                            	   292:          
                            	   293: 
                            	   294: ;                               ADD <EA>,A@   CMP <EA>,A@   SUB <EA>,A@
                            	   295: FORM10EX:	;.align  2              ; ADD  CMP  SUB
00:00009B12 3E3C0FFF        	   296:          MOVE.W  #$FFF,D7     ; ALL MODES ALLOWED
00:00009B16 2004            	   297:          MOVE.L  D4,D0
00:00009B18 024001C0        	   298:          ANDI.W  #$01C0,D0
00:00009B1C 6738            	   299:          BEQ.S   FORM103        ; .......000......
00:00009B1E 0C4001C0        	   300:          CMPI.W  #$01C0,D0
00:00009B22 6710            	   301:          BEQ.S   FORM10E3       ; .......111......
00:00009B24 0C4000C0        	   302:          CMPI.W  #$00C0,D0
00:00009B28 661E            	   303:          BNE.S   FORM10E6
                            	   304: 
00:00009B2A 1AFC002E        	   305:          MOVE.B  #'.',(A5)+    ; .......011......       STORE PERIOD
00:00009B2E 1AFC0057        	   306:          MOVE.B  #'W',(A5)+
00:00009B32 6008            	   307:          BRA.S   FORM10E4
                            	   308: 
00:00009B34 1AFC002E        	   309: FORM10E3:MOVE.B  #'.',(A5)+
00:00009B38 1AFC004C        	   310:          MOVE.B  #'L',(A5)+
                            	   311: 
00:00009B3C 61D0            	   312: FORM10E4:BSR.S   EEA10
                            	   313: 
00:00009B3E 1CC5            	   314:          MOVE.B  D5,(A6)+     ; STORE COMMA SEPARATOR
                            	   315: 
00:00009B40 3814            	   316:          MOVE.W  (A4),D4
00:00009B42 EF5C            	   317:          ROL.W   #7,D4
00:00009B44 6192            	   318:          BSR.S   FORMREGA       ; <EA>,A@
00:00009B46 6038            	   319:          BRA.S   CS12           ; COMMON
                            	   320: 
00:00009B48 08140000        	   321: FORM10E6:BTST.B  #0,(A4)
00:00009B4C 661C            	   322:          BNE.S   FORM105        ; .......1........    D@,<EA>
00:00009B4E 600A            	   323:          BRA.S   FORM104        ; .......0........    <EA>,D@
                            	   324: 
                            	   325: ;  BIT   5432109876543210
                            	   326: ;        ..........AAAAAA       EFFECTIVE ADDRESS
                            	   327: ;        .......MMM......       OP-MODE
                            	   328: ;        ....RRR.........       D-REGISTER
                            	   329: ;        .......0........       EA,D@
                            	   330: ;        .......1........       D@,EA
                            	   331: ;        ........00......       BYTE
                            	   332: ;        ........01......       WORD
                            	   333: ;        ........10......       LONG
                            	   334: 
                            	   335:          
                            	   336: 
                            	   337: FORM10:  ;.align  2              ; AND  EOR  OR
00:00009B50 08140000        	   338:          BTST.B  #0,(A4)
00:00009B54 6614            	   339:          BNE.S   FORM105
                            	   340: 
00:00009B56 3E3C0FFD        	   341: FORM103: MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:00009B5A 610002FA        	   342: FORM104: BSR     FORMSIZE
00:00009B5E 61AE            	   343:          BSR.S   EEA10          ; <EA>,D@
                            	   344: 
00:00009B60 1CC5            	   345:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   346: 
00:00009B62 1814            	   347:          MOVE.B  (A4),D4
00:00009B64 E20C            	   348:          LSR.B   #1,D4
00:00009B66 6180            	   349:          BSR     FORMREGD
00:00009B68 6016            	   350:          BRA.S   CS12           ; COMMON
                            	   351: 
00:00009B6A 610002EA        	   352: FORM105: BSR     FORMSIZE       ; D@,<EA>
00:00009B6E 1814            	   353:          MOVE.B  (A4),D4
00:00009B70 E20C            	   354:          LSR.B   #1,D4
00:00009B72 6100FF74        	   355:          BSR     FORMREGD
                            	   356: 
00:00009B76 1CC5            	   357:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   358: 
00:00009B78 3814            	   359:          MOVE.W  (A4),D4
00:00009B7A 3E3C01FD        	   360:          MOVE.W  #$1FD,D7     ; ALTERABLE MEMORY ADDRESSING
00:00009B7E 618E            	   361:          BSR.S   EEA10
00:00009B80 6000064A        	   362: CS12:    BRA     COMMON
                            	   363: 
                            	   364:          
                            	   365: 
                            	   366: ;                               PEA     (JMP  JSR)
00:00009B84 3E3C07E4        	   367: FORM11:  MOVE.W  #$7E4,D7     ; CONTROL ADDERSSING
00:00009B88 6184            	   368:          BSR     EEA10
00:00009B8A 60F4            	   369:          BRA.S   CS12           ; COMMON
                            	   370: 
                            	   371:          
                            	   372: 
                            	   373: ;                               ; JMP  JSR
00:00009B8C 2004            	   374: FORM11SL:MOVE.L  D4,D0        ; LOOK FOR .S  OR  .L
00:00009B8E 0240003F        	   375:          ANDI.W  #$3F,D0
00:00009B92 0C400038        	   376:          CMPI.W  #$38,D0
00:00009B96 6608            	   377:          BNE.S   FORM112        ; NOT .S
00:00009B98 1AFC002E        	   378:          MOVE.B  #'.',(A5)+    ; PERIOD
00:00009B9C 1AFC0053        	   379:          MOVE.B  #'S',(A5)+    ; S
00:00009BA0 0C400039        	   380: FORM112: CMPI.W  #$39,D0
00:00009BA4 6608            	   381:          BNE.S   FORM114
00:00009BA6 1AFC002E        	   382:          MOVE.B  #'.',(A5)+    ; PERIOD
00:00009BAA 1AFC004C        	   383:          MOVE.B  #'L',(A5)+    ; L
00:00009BAE 60D4            	   384: FORM114: BRA.S   FORM11
                            	   385: 
                            	   386: ;  BIT   5432109876543210
                            	   387: ;        ....XXX.....0...       DATA DESTINATION REGISTER
                            	   388: ;        ....XXX.....1...       ADDRESS REGISTER
                            	   389: ;        ....XXX.00......       BYTE
                            	   390: ;        ........01......       WORD
                            	   391: ;        ........10......       LONG
                            	   392: ;        ............0...       DATA REGISTER TO DATA REGISTER
                            	   393: ;        ............1...       MEMORY TO MEMORY
                            	   394: ;        ............0xXX       DATA SOURCE REGISTER
                            	   395: ;        ............1XXX       ADDRESS SOURCE REGISTER
                            	   396: ;
                            	   397:          
                            	   398: 
                            	   399: FORM12:  ;.align  2              ; ABCD  ADDX  SBCD  SUBX
00:00009BB0 610002A4        	   400:          BSR     FORMSIZE
                            	   401: 
00:00009BB4 08040003        	   402:          BTST    #3,D4
00:00009BB8 6610            	   403:          BNE.S   FORM125
                            	   404: 
00:00009BBA 6100FF2C        	   405:          BSR     FORMREGD       ; D@,D@;   FORMAT SOURCE
                            	   406: 
00:00009BBE 1CC5            	   407:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   408: 
00:00009BC0 1814            	   409:          MOVE.B  (A4),D4
00:00009BC2 E20C            	   410:          LSR.B   #1,D4
00:00009BC4 6100FF22        	   411:          BSR     FORMREGD       ; FORMAT DESTINATION
00:00009BC8 6046            	   412:          BRA.S   CS11           ; COMMON
                            	   413: 
00:00009BCA 1CFC002D        	   414: FORM125: MOVE.B  #'-',(A6)+    ; -
00:00009BCE 1CFC0028        	   415:          MOVE.B  #'(',(A6)+    ; (
00:00009BD2 6100FF04        	   416:          BSR     FORMREGA       ; A@    SOURCE
                            	   417: 
00:00009BD6 203C282D2C29    	   418:          MOVE.L  #$282d2c29,D0 ; ),-(
00:00009BDC 6152            	   419:          BSR.S   SCHR           ; STORE CHARS
                            	   420: 
00:00009BDE 1814            	   421:          MOVE.B  (A4),D4
00:00009BE0 E20C            	   422:          LSR.B   #1,D4
00:00009BE2 6100FEF4        	   423:          BSR     FORMREGA       ; A@   DESTINATION
00:00009BE6 1CFC0029        	   424:          MOVE.B  #')',(A6)+
00:00009BEA 6024            	   425:          BRA.S   CS11           ; COMMON
                            	   426: 
                            	   427: ;  BIT   5432109876543210
                            	   428: ;        ....XXX.....1...       ADDRESS REGISTER    DESTINATION
                            	   429: ;        ....XXX.00......       BYTE
                            	   430: ;        ........01......       WORD
                            	   431: ;        ........10......       LONG
                            	   432: ;        ............1...       MEMORY TO MEMORY
                            	   433: ;        ............1XXX       ADDRESS SOURCE REGISTER
                            	   434: ;
                            	   435:          
                            	   436: 
                            	   437: FORM12A: ;.align  2              ; CMPM
00:00009BEC 61000268        	   438:          BSR     FORMSIZE
                            	   439: 
00:00009BF0 1CFC0028        	   440:          MOVE.B  #'(',(A6)+    ; (
00:00009BF4 6100FEE2        	   441:          BSR     FORMREGA       ; A@
                            	   442: 
00:00009BF8 203C282C2B29    	   443:          MOVE.L  #$282c2b29,D0  ; )+,(
00:00009BFE 6130            	   444:          BSR.S   SCHR           ; STORE CHARS
                            	   445: 
00:00009C00 1814            	   446:          MOVE.B  (A4),D4
00:00009C02 E20C            	   447:          LSR.B   #1,D4
00:00009C04 6100FED2        	   448:          BSR     FORMREGA       ; A@
00:00009C08 1CFC0029        	   449:          MOVE.B  #')',(A6)+
00:00009C0C 1CFC002B        	   450:          MOVE.B  #'+',(A6)+
00:00009C10 600005BA        	   451: CS11:    BRA     COMMON
                            	   452: 
                            	   453:          
                            	   454: 
00:00009C14 60000210        	   455: IQUICK:  BRA     IQUICKA        ; ADDQ  SUBQ
                            	   456: 
                            	   457: ;  BIT   5432109876543210
                            	   458: ;        0111...0........       FIXED
                            	   459: ;        ....RRR.........       DATA REGISTER
                            	   460: ;        ........DDDDDDDD       SIGN EXTENDED DATA
                            	   461: ;
                            	   462:          
                            	   463: 
                            	   464: IMOVEQ:  ;.align  2
00:00009C18 1CFC0023        	   465:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	   466: 
00:00009C1C 3014            	   467:          MOVE.W  (A4),D0
00:00009C1E 4880            	   468:          EXT.W   D0
00:00009C20 48C0            	   469:          EXT.L   D0
00:00009C22 6100FCAE        	   470:          BSR     HEX2DEC        ; DECIMAL
                            	   471: 
00:00009C26 1CC5            	   472:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   473: 
00:00009C28 EF5C            	   474:          ROL.W   #7,D4
00:00009C2A 6100FEBC        	   475:          BSR     FORMREGD
00:00009C2E 60E0            	   476:          BRA.S   CS11           ; COMMON
                            	   477: 
00:00009C30 1CC0            	   478: SCHR:    MOVE.B  D0,(A6)+     ; OUTPUT STRING
00:00009C32 E088            	   479:          LSR.L   #8,D0
00:00009C34 66FA            	   480:          BNE.S   SCHR           ; MORE TO OUTPUT
00:00009C36 4E75            	   481:          RTS
                            	   482: 
                            	   483: ; MOVE FROM SR  (STATUS REGISTER)
                            	   484: ;
                            	   485:          
                            	   486: 
00:00009C38 203C002C5253    	   487: IMVFSR:  MOVE.L  #$002c5253,D0 ; SR,
                            	   488: 
00:00009C3E 61F0            	   489:          BSR.S   SCHR
00:00009C40 6100029E        	   490:          BSR     EEA            ; DATA ALTERABLE
00:00009C44 60CA            	   491:          BRA.S   CS11           ; COMMON
                            	   492: 
                            	   493: ; MOVE FROM USP (USER STACK POINTER)
                            	   494: ;
                            	   495:          
                            	   496: 
00:00009C46 203C2C505355    	   497: IMVFUSP: MOVE.L  #$2c505355,D0 ; USP,
00:00009C4C 61E2            	   498:          BSR.S   SCHR
00:00009C4E 6100FE88        	   499:          BSR     FORMREGA
00:00009C52 60BC            	   500:          BRA.S   CS11           ; COMMON
                            	   501: 
                            	   502: ; MOVE TO SR (STATUS REGISTER)
                            	   503: ;
                            	   504:          
                            	   505: 
00:00009C54 3E3C0FFD        	   506: IMVTSR:  MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:00009C58 61000286        	   507:          BSR     EEA
00:00009C5C 203C0052532C    	   508:          MOVE.L  #$0052532c,D0 ; ,SR
00:00009C62 61CC            	   509: IMVT44:  BSR.S   SCHR
00:00009C64 60AA            	   510:          BRA.S   CS11           ; COMMON
                            	   511: 
                            	   512: ; MOVE TO USP (USER STACK POINTER)
                            	   513: ;
                            	   514:          
                            	   515: 
00:00009C66 6100FE70        	   516: IMVTUSP: BSR     FORMREGA
00:00009C6A 203C5053552C    	   517:          MOVE.L  #$5053552c,D0 ; ,USP
00:00009C70 60F0            	   518:          BRA.S   IMVT44
                            	   519: 
                            	   520: ;  MOVE TO CCR (CONDITION CODE REGISTER)
                            	   521: ;
                            	   522:          
                            	   523: 
00:00009C72 3E3C0FFD        	   524: IMVTCCR: MOVE.W  #$FFD,D7     ; DATA ADDRESSING
00:00009C76 61000268        	   525:          BSR     EEA
00:00009C7A 203C5243432C    	   526:          MOVE.L  #$5243432c,D0 ; ,CCR
00:00009C80 60E0            	   527:          BRA.S   IMVT44
                            	   528: 
                            	   529: ;  BIT   5432109876543210
                            	   530: ;        0000...1..001...       FIXED
                            	   531: ;        ....XXX.........       DATA REGISTER
                            	   532: ;        ........0.......       MEMORY TO REGISTER
                            	   533: ;        ........1.......       REGISTER TO MEMORY
                            	   534: ;        .........0......       WORD
                            	   535: ;        .........1......       LONG
                            	   536: ;        .............XXX       ADDRESS REGISTER
                            	   537: ;
                            	   538:          
                            	   539: 
                            	   540: IMOVEP:  ;.align  2
00:00009C82 1AFC002E        	   541:          MOVE.B  #'.',(A5)+    ; D@,#(A@)
00:00009C86 303C4C57        	   542:          MOVE.W  #$4c57,D0    ; "LW"
00:00009C8A 08040006        	   543:          BTST    #6,D4
00:00009C8E 6702            	   544:          BEQ.S   IMOVEP11       ; USE "W"
00:00009C90 E048            	   545:          LSR.W   #8,D0         ; USE "L"
00:00009C92 1AC0            	   546: IMOVEP11:MOVE.B  D0,(A5)+     ; LENGTH
                            	   547: 
00:00009C94 1814            	   548:          MOVE.B  (A4),D4
00:00009C96 E20C            	   549:          LSR.B   #1,D4
                            	   550: 
00:00009C98 082C00070001    	   551:          BTST.B  #7,1(A4)
00:00009C9E 670E            	   552:          BEQ.S   IMOVEP35
                            	   553: 
00:00009CA0 6100FE46        	   554:          BSR     FORMREGD       ; D@,$HHHH(A@)
                            	   555: 
00:00009CA4 1CC5            	   556:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   557: 
00:00009CA6 3814            	   558:          MOVE.W  (A4),D4
00:00009CA8 6112            	   559:          BSR.S   IMOVEP66
00:00009CAA 6000051E        	   560: CS20:    BRA     COMMON4
                            	   561: 
00:00009CAE 610C            	   562: IMOVEP35:BSR.S   IMOVEP66       ; $HHHH(A@),D@
                            	   563: 
00:00009CB0 1CC5            	   564:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   565: 
00:00009CB2 1814            	   566:          MOVE.B  (A4),D4
00:00009CB4 E20C            	   567:          LSR.B   #1,D4
00:00009CB6 6100FE30        	   568:          BSR     FORMREGD
00:00009CBA 60EE            	   569:          BRA.S   CS20           ; COMMON4
                            	   570: 
00:00009CBC 1CFC0024        	   571: IMOVEP66:MOVE.B  #'$',(A6)+    ; FORMAT DISPLACEMENT
00:00009CC0 302C0002        	   572:          MOVE.W  2(A4),D0
00:00009CC4 6100FC70        	   573:          BSR     PNT4HX
                            	   574: 
00:00009CC8 1CFC0028        	   575:          MOVE.B  #'(',(A6)+
                            	   576: 
00:00009CCC 3814            	   577:          MOVE.W  (A4),D4
00:00009CCE 6100FE08        	   578:          BSR     FORMREGA
00:00009CD2 1CFC0029        	   579:          MOVE.B  #')',(A6)+
00:00009CD6 4E75            	   580:          RTS
                            	   581: 
                            	   582: SCOMMON:
00:00009CD8 600004F2        	   583: 	bra COMMON         ; NOP RESET RTE RTR RTS TRAPV
                            	   584:         
                            	   585: 
00:00009CDC 610000E4        	   586: ISCC:    BSR     ICCCC          ; GET REST OF OP-CODE
00:00009CE0 610001FE        	   587:          BSR     EEA            ; DATA ALTERABLE
00:00009CE4 60F2            	   588:          BRA.S   SCOMMON
                            	   589: 
                            	   590:          
                            	   591: 
                            	   592: IDBCC:   ;.align  2              ; DB--
00:00009CE6 3814            	   593:          MOVE.W  (A4),D4
00:00009CE8 6100FDFE        	   594:          BSR     FORMREGD
                            	   595: 
00:00009CEC 1CC5            	   596:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
00:00009CEE 1CFC0024        	   597:          MOVE.B  #'$',(A6)+    ; HEX FIELD TO FOLLOW
                            	   598: 
00:00009CF2 610000CE        	   599:          BSR     ICCCC
00:00009CF6 602C            	   600:          BRA.S   ICC55
                            	   601: 
                            	   602: ;  BIT   5432109876543210
                            	   603: ;        0110............       FIXED
                            	   604: ;        ....CCCC........       CONDITION
                            	   605: ;        ........DDDDDDD0       DISPLACEMENT
                            	   606: ;        ...............1       ERROR (ODD BOUNDRY DISPLACEMENT)
                            	   607: ;
                            	   608:          
                            	   609: 
                            	   610: ICC:     ;.align  2              ; B--
00:00009CF8 610000C8        	   611:          BSR     ICCCC
                            	   612: 
00:00009CFC 1CFC0024        	   613: IBSR:    MOVE.B  #'$',(A6)+    ; BSR.S BRA
                            	   614: 
00:00009D00 4A04            	   615:          TST.B   D4
00:00009D02 6720            	   616:          BEQ.S   ICC55          ; 16 BIT DISPLACEMENT
                            	   617: 
00:00009D04 1AFC002E        	   618:          MOVE.B  #'.',(A5)+
00:00009D08 1AFC0053        	   619:          MOVE.B  #'S',(A5)+
00:00009D0C 4884            	   620:          EXT.W   D4            ; 8 BIT DISPLACEMENT
                            	   621: 
00:00009D0E 48C4            	   622: ICC35:   EXT.L   D4            ; SIGN-EXTENDED DISPLACEMENT
00:00009D10 D8A9FFFC        	   623:          ADD.L   HISPC(A1),D4  ; + PROGRAM COUNTER
00:00009D14 5484            	   624:          ADDQ.L  #2,D4         ; + TWO
00:00009D16 2004            	   625:          MOVE.L  D4,D0
                            	   626: 
00:00009D18 E284            	   627:          ASR.L   #1,D4
00:00009D1A 650004D8        	   628:          BCS     FERROR         ; ODD BOUNDRY DISPLACEMENT
                            	   629: 
00:00009D1E 6100FC1A        	   630:          BSR     PNT6HX
00:00009D22 60B4            	   631:          BRA.S   SCOMMON
                            	   632: 
00:00009D24 5483            	   633: ICC55:   ADDQ.L  #2,D3         ; SIZE
00:00009D26 382C0002        	   634:          MOVE.W  2(A4),D4
00:00009D2A 1AFC002E        	   635:          MOVE.B  #'.',(A5)+
00:00009D2E 1AFC004C        	   636:          MOVE.B  #'L',(A5)+    ; .L FOR 16 BIT DISPLACEMENT
00:00009D32 60DA            	   637:          BRA.S   ICC35
                            	   638: 
                            	   639:          
                            	   640: ;                               ; BCHG  BCLR  BSET  BTST
                            	   641: ISETD:   ;.align  2              ; DYNAMIC BIT
00:00009D34 EF5C            	   642:          ROL.W   #7,D4
00:00009D36 6100FDB0        	   643:          BSR     FORMREGD       ; DATA REGISTER
                            	   644: 
00:00009D3A 1CC5            	   645: ISETD12: MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   646: 
00:00009D3C 3814            	   647:          MOVE.W  (A4),D4
00:00009D3E 610001A0        	   648:          BSR     EEA            ; DATA ALTERABLE
00:00009D42 6094            	   649: CS18:    BRA.S   SCOMMON
                            	   650: 
                            	   651:          ;.align   4
                            	   652: 
                            	   653: ;                            BCHG  BCLR  BSET  BTST
                            	   654: ;  1ST WORD     .... .... ..XX XXXX    EA   DATA ALTERABLE ONLY
                            	   655: ;  2ND WORD     0000 0000 000Y YYYY    BIT NUMBER
                            	   656: ;
                            	   657: ISETS:   ;.align  2              ; STATIC BIT
00:00009D44 5483            	   658:          ADDQ.L  #2,D3         ; SIZE
00:00009D46 1CFC0023        	   659:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	   660: 
00:00009D4A 7000            	   661:          CLR.L   D0
00:00009D4C 302C0002        	   662:          MOVE.W  2(A4),D0     ; GET BIT POSITION FROM 2ND WORD
00:00009D50 2200            	   663:          MOVE.L  D0,D1
00:00009D52 EA89            	   664:          LSR.L   #5,D1
00:00009D54 6600049E        	   665:          BNE     FERROR
00:00009D58 6100FB78        	   666:          BSR     HEX2DEC        ; DECIMAL
                            	   667: 
00:00009D5C 60DC            	   668:          BRA.S   ISETD12
                            	   669: 
                            	   670: ;   BIT  5432109876543210
                            	   671: ;        ....XXX.........       IMMEDIATE COUNT/REGISTER
                            	   672: ;        .......0........       RIGHT SHIFT
                            	   673: ;        .......1........       LEFT SHIFT
                            	   674: ;        ........00......       BYTE
                            	   675: ;        ........01......       WORD
                            	   676: ;        ........10......       LONG
                            	   677: ;        ....0...11......       WORD (MEMORY)
                            	   678: ;        ....0...11AAAAAA       EFFECTIVE ADDRESS
                            	   679: ;        ..........0.....       SHIFT IMMEDIATE COUNT
                            	   680: ;        ..........1.....       SHIFT COUNT (MODULO 64) IN DATA REGISTER
                            	   681: ;
                            	   682:          ;.align   4
                            	   683: 
                            	   684: ISHIFT:  ;.align   2             ; AS-  LS-  RO-  ROX-
00:00009D5E 303C4C52        	   685:          MOVE.W  #$4c52,D0    ; "LR"
00:00009D62 08040008        	   686:          BTST    #8,D4         ; DIRECTION BIT
00:00009D66 6702            	   687:          BEQ.S   ISHIFT13       ; RIGHT
00:00009D68 E048            	   688:          LSR.W   #8,D0         ; LEFT
00:00009D6A 1AC0            	   689: ISHIFT13:MOVE.B  D0,(A5)+     ; DIRECTION; "L" OR "R"
                            	   690: 
00:00009D6C 3014            	   691:          MOVE.W  (A4),D0
00:00009D6E 024000C0        	   692:          ANDI.W  #$00C0,D0
00:00009D72 0C4000C0        	   693:          CMPI.W  #$00C0,D0
00:00009D76 6730            	   694:          BEQ.S   ISHIFTM1       ; MEMORY SHIFT
                            	   695: 
00:00009D78 610000DC        	   696:          BSR     FORMSIZE
                            	   697: 
00:00009D7C EF5C            	   698:          ROL.W   #7,D4
00:00009D7E 0804000C        	   699:          BTST    #12,D4        ; I/R BIT
00:00009D82 6616            	   700:          BNE.S   ISHIFT33       ; COUNT IN REGISTER
                            	   701: 
00:00009D84 02040007        	   702:          ANDI.B  #$07,D4      ; IMMEDIATE COUNT
00:00009D88 6604            	   703:          BNE.S   ISHIFT23
00:00009D8A 00040008        	   704:          ORI.B   #$08,D4      ; CHANGE ZERO TO EIGHT
00:00009D8E 00040030        	   705: ISHIFT23:ORI.B   #'0',D4
00:00009D92 1CFC0023        	   706:          MOVE.B  #'#',(A6)+
00:00009D96 1CC4            	   707:          MOVE.B  D4,(A6)+
00:00009D98 6004            	   708:          BRA.S   ISHIFT44
                            	   709: 
00:00009D9A 6100FD4C        	   710: ISHIFT33:BSR     FORMREGD
                            	   711: 
00:00009D9E 1CC5            	   712: ISHIFT44:MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   713: 
00:00009DA0 3814            	   714:          MOVE.W  (A4),D4
00:00009DA2 6100FD44        	   715:          BSR     FORMREGD
00:00009DA6 609A            	   716: CS17:    BRA.S   CS18           ; COMMON
                            	   717: 
00:00009DA8 1AFC002E        	   718: ISHIFTM1:MOVE.B  #'.',(A5)+    ; PERIOD
00:00009DAC 1AFC0057        	   719:          MOVE.B  #'W',(A5)+    ; .WORD
                            	   720: 
00:00009DB0 0804000B        	   721:          BTST    #11,D4
00:00009DB4 6600043E        	   722:          BNE     FERROR         ; BIT 11 MUST BE ZERO
                            	   723: 
00:00009DB8 3E3C01FC        	   724:          MOVE.W  #$1FC,D7     ; MEMORY ALTERABLE ADDRESSING
00:00009DBC 61000122        	   725:          BSR     EEA
00:00009DC0 60E4            	   726:          BRA.S   CS17           ; COMMON
                            	   727: 
00:00009DC2 700F            	   728: ICCCC:   MOVEQ   #$0F,D0      ; APPEND CONDITION CODE
00:00009DC4 C014            	   729:          AND.B   (A4),D0      ; D0 = CCC
00:00009DC6 E388            	   730:          LSL.L   #1,D0         ; D0 = CCC;2
                            	   731: 
00:00009DC8 323B0010        	   732:          MOVE.W  BRTBL(PC,D0.W),D1 ; GET BRANCH MNEMONIC
00:00009DCC 1AC1            	   733:          MOVE.B  D1,(A5)+     ; (REVERSED) FROM THE TABLE
00:00009DCE E049            	   734:          LSR.W   #8,D1         ; AND ADD THE NONBLANK PORTION
00:00009DD0 0C010020        	   735:          CMPI.B  #BLANK,D1     ; TO THE BUFFER.
00:00009DD4 6702            	   736:          BEQ.S   ICCCC9
00:00009DD6 1AC1            	   737:          MOVE.B  D1,(A5)+
00:00009DD8 4E75            	   738: ICCCC9:  RTS
                            	   739: 
00:00009DDA 2054            	   740: BRTBL:   dc.b  " T"           ; "T " BRA ACCEPTED
00:00009DDC 2046            	   741:          dc.b  " F"           ; "F "
00:00009DDE 4948            	   742:          dc.b  "IH"           ; "HI"
00:00009DE0 534C            	   743:          dc.b  "SL"           ; "LS"
00:00009DE2 4343            	   744:          dc.b  "CC"           ; "CC"
00:00009DE4 5343            	   745:          dc.b  "SC"           ; "CS"
00:00009DE6 454E            	   746:          dc.b  "EN"           ; "NE"
00:00009DE8 5145            	   747:          dc.b  "QE"           ; "EQ"
00:00009DEA 4356            	   748:          dc.b  "CV"           ; "VC"
00:00009DEC 5356            	   749:          dc.b  "SV"           ; "VS"
00:00009DEE 4C50            	   750:          dc.b  "LP"           ; "PL"
00:00009DF0 494D            	   751:          dc.b  "IM"           ; "MI"
00:00009DF2 4547            	   752:          dc.b  "EG"           ; "GE"
00:00009DF4 544C            	   753:          dc.b  "TL"           ; "LT"
00:00009DF6 5447            	   754:          dc.b  "TG"           ; "GT"
00:00009DF8 454C            	   755:          dc.b  "EL"           ; "LE"
                            	   756: 
                            	   757: ;   BIT  5432109876543210
                            	   758: ;        ....RRRMMM......    DESTINATION REGISTER MODE
                            	   759: ;        ..........MMMRRR    SOURCE MODE REGISTER
                            	   760: ;
                            	   761: ; IF BYTE SIZE; ADDRESS DIRECT NOT ALLOWED AS SOURCE
                            	   762: ;
                            	   763: 					even
                            	   764: IMOVEA1: ;.align  2
00:00009DFA 3E3C0FFF        	   765:          MOVE.W  #$FFF,D7     ; ALL MODES
00:00009DFE 610000E0        	   766:          BSR     EEA
                            	   767: 
00:00009E02 1CC5            	   768:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   769: 
00:00009E04 3814            	   770:          MOVE.W  (A4),D4      ; ....RRRMMM......
00:00009E06 E24C            	   771:          LSR.W   #1,D4         ; .....RRRMMM.....
00:00009E08 EA0C            	   772:          LSR.B   #5,D4         ; .....RRR.....MMM
00:00009E0A E05C            	   773:          ROR.W   #8,D4         ; .....MMM.....RRR
00:00009E0C EB0C            	   774:          LSL.B   #5,D4         ; .....MMMRRR.....
00:00009E0E EA4C            	   775:          LSR.W   #5,D4         ; ..........MMMRRR
                            	   776: 
                            	   777: ; IF .BYTE DESTINATION A@ NOT ALLOWED
00:00009E10 3E3C01FF        	   778:          MOVE.W  #$1FF,D7     ; DATA ALTERABLE + A@
00:00009E14 1014            	   779:          MOVE.B  (A4),D0
00:00009E16 0C000001        	   780:          CMPI.B  #$01,D0
00:00009E1A 6604            	   781:          BNE.S   IMOVE19        ; NOT BYTE SIZE
                            	   782: 
00:00009E1C 3E3C01FD        	   783:          MOVE.W  #$1FD,D7     ; DATA ALTERABLE
                            	   784: IMOVE19:
                            	   785: 
00:00009E20 610000BE        	   786:          BSR     EEA
00:00009E24 602C            	   787:          BRA.S   CS19           ; COMMON
                            	   788: 
                            	   789: ;  IF BYTE; ADDRESS REGISTER DIRECT NOT ALLOWED
                            	   790: IQUICKA: ;.align  2              ; ADDQ  SUBQ
00:00009E26 612E            	   791:          BSR.S   FORMSIZE
                            	   792: 
00:00009E28 1CFC0023        	   793:          MOVE.B  #'#',(A6)+
00:00009E2C EF5C            	   794:          ROL.W   #7,D4
00:00009E2E 02040007        	   795:          ANDI.B  #7,D4
00:00009E32 6604            	   796:          BNE.S   IQUICK21
00:00009E34 00040008        	   797:          ORI.B   #8,D4         ; MAKE ZERO INTO EIGHT
00:00009E38 00040030        	   798: IQUICK21:ORI.B   #'0',D4       ; MAKE ASCII
00:00009E3C 1CC4            	   799:          MOVE.B  D4,(A6)+
                            	   800: 
00:00009E3E 1CC5            	   801:          MOVE.B  D5,(A6)+     ; COMMA SEPARATOR
                            	   802: 
00:00009E40 3814            	   803:          MOVE.W  (A4),D4
                            	   804: 
00:00009E42 3014            	   805:          MOVE.W  (A4),D0
00:00009E44 024000C0        	   806:          ANDI.W  #$00C0,D0
00:00009E48 6704            	   807:          BEQ.S   IQUICK31       ; DATA ALTERABLE
00:00009E4A 3E3C01FF        	   808:          MOVE.W  #$1FF,D7     ; ALTERABLE ADDRESSING
00:00009E4E 61000090        	   809: IQUICK31:BSR     EEA
00:00009E52 60000378        	   810: CS19:    BRA     COMMON
                            	   811: 
                            	   812: ;  BIT   5432109876543210
                            	   813: ;        ........00......       BYTE
                            	   814: ;        ........01......       WORD
                            	   815: ;        ........10......       LONG
                            	   816: ;        ........11......       ERROR
                            	   817: ;
                            	   818: FORMSIZE: ;.align  2
00:00009E56 3414            	   819:          MOVE.W  (A4),D2
00:00009E58 1AFC002E        	   820:          MOVE.B  #'.',(A5)+    ; STORE PERIOD
00:00009E5C EC4A            	   821:          LSR.W   #6,D2
00:00009E5E 02420003        	   822:          ANDI.W  #$03,D2
00:00009E62 6606            	   823:          BNE.S   FORM91
00:00009E64 1AFC0042        	   824:          MOVE.B  #'B',(A5)+    ; STORE "B"
00:00009E68 6016            	   825:          BRA.S   FORM95
                            	   826: 
00:00009E6A 103C0057        	   827: FORM91:  MOVE.B  #'W',D0
00:00009E6E 0C020001        	   828:          CMPI.B  #1,D2
00:00009E72 670A            	   829:          BEQ.S   FORM93
00:00009E74 103C004C        	   830:          MOVE.B  #'L',D0
00:00009E78 0C020002        	   831:          CMPI.B  #2,D2
00:00009E7C 665E            	   832:          BNE.S   FE10           ; FERROR
00:00009E7E 1AC0            	   833: FORM93:  MOVE.B  D0,(A5)+     ; STORE "W" OR "L"
00:00009E80 4E75            	   834: FORM95:  RTS
                            	   835: 
00:00009E82 6100FC64        	   836: EA000:   BSR     FORMREGD
00:00009E86 08070000        	   837:          BTST    #0,D7
00:00009E8A 6750            	   838:          BEQ.S   FE10           ; FERROR
00:00009E8C 4E75            	   839:          RTS
                            	   840: 
00:00009E8E 6100FC48        	   841: EA001:   BSR     FORMREGA
00:00009E92 08070001        	   842:          BTST    #1,D7
00:00009E96 6744            	   843:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:00009E98 4E75            	   844:          RTS
                            	   845: 
00:00009E9A 1CFC0028        	   846: EA010:   MOVE.B  #'(',(A6)+
00:00009E9E 6100FC38        	   847:          BSR     FORMREGA
00:00009EA2 1CFC0029        	   848:          MOVE.B  #')',(A6)+
00:00009EA6 08070002        	   849:          BTST    #2,D7
00:00009EAA 6730            	   850:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:00009EAC 4E75            	   851:          RTS
                            	   852: 
00:00009EAE 1CFC0028        	   853: EA011:   MOVE.B  #'(',(A6)+
00:00009EB2 6100FC24        	   854:          BSR     FORMREGA
00:00009EB6 1CFC0029        	   855:          MOVE.B  #')',(A6)+
00:00009EBA 1CFC002B        	   856:          MOVE.B  #'+',(A6)+
00:00009EBE 08070003        	   857:          BTST    #3,D7
00:00009EC2 6718            	   858:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
00:00009EC4 4E75            	   859: EA011RTS:RTS
                            	   860: 
00:00009EC6 1CFC002D        	   861: EA100:   MOVE.B  #'-',(A6)+
00:00009ECA 1CFC0028        	   862:          MOVE.B  #'(',(A6)+
00:00009ECE 6100FC08        	   863:          BSR     FORMREGA
00:00009ED2 1CFC0029        	   864:          MOVE.B  #')',(A6)+
00:00009ED6 08070004        	   865:          BTST    #4,D7
00:00009EDA 66E8            	   866:          BNE.S   EA011RTS
00:00009EDC 60000316        	   867: FE10:    BRA     FERROR         ; THIS MODE NOT ALLOWED
                            	   868: 
                            	   869: ;  ENTER       A4 = POINTER TO FIRST WORD
                            	   870: ;              D3 = OFFSET TO EXTENSION
                            	   871: ;              D4 = VALUE TO PROCESS
                            	   872: ;              D7 = MODES ALLOWED MASK
                            	   873: ;
                            	   874: EEA:     ;.align  2
00:00009EE0 2004            	   875: 	move.l D4,D0
00:00009EE2 E648            	   876: 	lsr.w #3,D0
00:00009EE4 02400007        	   877: 	andi.w #$7,D0
00:00009EE8 6798            	   878: 	beq.s EA000
00:00009EEA 0C000001        	   879: 	cmpi.b #1,D0
00:00009EEE 679E            	   880: 	beq.s EA001
00:00009EF0 0C000002        	   881: 	cmpi.b #2,D0
00:00009EF4 67A4            	   882: 	beq.s EA010
00:00009EF6 0C000003        	   883: 	cmpi.b #3,D0
00:00009EFA 67B2            	   884: 	beq.s EA011
00:00009EFC 0C000004        	   885: 	cmpi.b #4,D0
00:00009F00 67C4            	   886: 	beq.s EA100
00:00009F02 0C000005        	   887: 	cmpi.b #5,D0
00:00009F06 6760            	   888: 	beq.s EA101
00:00009F08 0C000007        	   889: 	cmpi.b #7,D0
00:00009F0C 6770            	   890: 	beq.s EA111
                            	   891: 
                            	   892: ;    EXTENSION WORD
                            	   893: ;   BIT  5432109876543210
                            	   894: ;        0...............    DATA REGISTER
                            	   895: ;        1...............    ADDRESS REGISTER
                            	   896: ;        .RRR............    REGISTER
                            	   897: ;        ....0...........    SIGN EXTENDED, LOW ORDER INTEGER IN INDEX REG
                            	   898: ;        ....1...........    LONG VALUE IN INDEX REGISTER
                            	   899: ;        .....000........
                            	   900: ;        ........DDDDDDDD    DISPLACEMENT INTEGER
                            	   901: ;
                            	   902: ; EA110            ADDRESS REGISTER INDIRECT WITH INDEX
                            	   903: 
00:00009F0E 08070006        	   904:          BTST    #6,D7
00:00009F12 67C8            	   905:          BEQ.S   FE10           ; FERROR  THIS MODE NOT ALLOWED
                            	   906: 
00:00009F14 32343000        	   907:          MOVE.W  (A4,D3.W),D1
00:00009F18 02410700        	   908:          ANDI.W  #$0700,D1
00:00009F1C 66BE            	   909:          BNE.S   FE10           ; FERROR  BITS 10-8 MUST BE ZERO
                            	   910: 
00:00009F1E 30343000        	   911:          MOVE.W  (A4,D3.W),D0  ; D0 = DISPLACEMENT
00:00009F22 4880            	   912:          EXT.W   D0
00:00009F24 48C0            	   913:          EXT.L   D0
00:00009F26 6100F9AA        	   914:          BSR     HEX2DEC        ; DECIMAL
00:00009F2A 1CFC0028        	   915:          MOVE.B  #'(',(A6)+    ; (
                            	   916: 
00:00009F2E 6100FBA8        	   917:          BSR     FORMREGA       ; XX(A@
                            	   918: 
00:00009F32 1CFC002C        	   919:          MOVE.B  #',',(A6)+    ; XX(A@,
                            	   920: 
00:00009F36 18343000        	   921:          MOVE.B  (A4,D3.W),D4
00:00009F3A E804            	   922:          ASR.B   #4,D4
00:00009F3C 6A06            	   923:          BPL.S   EA1105
00:00009F3E 6100FB98        	   924:          BSR     FORMREGA
00:00009F42 6004            	   925:          BRA.S   EA1107
                            	   926: 
00:00009F44 6100FBA2        	   927: EA1105:  BSR     FORMREGD
00:00009F48 1CFC002E        	   928: EA1107:  MOVE.B  #'.',(A6)+    ; XX(A@,X@.
                            	   929: 
00:00009F4C 38343000        	   930:          MOVE.W  (A4,D3.W),D4 ; D4 = R@
00:00009F50 103C0057        	   931:          MOVE.B  #'W',D0       ; ..........W
00:00009F54 0804000B        	   932:          BTST    #11,D4
00:00009F58 6704            	   933:          BEQ.S   EA1109
00:00009F5A 103C004C        	   934:          MOVE.B  #'L',D0       ; ..........L
00:00009F5E 1CC0            	   935: EA1109:  MOVE.B  D0,(A6)+
00:00009F60 1CFC0029        	   936:          MOVE.B  #')',(A6)+    ; ...........)
00:00009F64 5483            	   937:          ADDQ.L  #2,D3
00:00009F66 4E75            	   938:          RTS
                            	   939: 
                            	   940: ; ADDRESS REGISTER INDIRECT WITH DISPLACEMENT
                            	   941: ;
                            	   942: EA101:
00:00009F68 08070005        	   943: 	btst #5,D7         	; 101000;   DIS(A@)
00:00009F6C 6756            	   944: 	beq.s FE11          ; FERROR;  THIS MODE NOT ALLOWED
00:00009F6E 30343000        	   945: 	move.w (A4,D3.W),D0
00:00009F72 48C0            	   946: 	ext.l D0
00:00009F74 6100F95C        	   947: 	bsr HEX2DEC        	; DECIMAL
00:00009F78 5483            	   948: 	addq.l #2,D3        ; SIZE
00:00009F7A 6000FF1E        	   949: 	bra EA010
                            	   950: 
                            	   951: ;  111000        ABSOLUTE SHORT
                            	   952: ;  111001        ABSOLUTE LONG
                            	   953: ;  111010        PROGRAM COUNTER WITH DISPLACEMENT
                            	   954: ;  111011        PROGRAM COUNTER WITH INDEX
                            	   955: ;  111100        IMMEDIATE OR STATUS REG
                            	   956: ;
                            	   957: EA111:
00:00009F7E 02440007        	   958: 	andi.w #7,D4
00:00009F82 6618            	   959: 	bne.s EA1112
00:00009F84 08070007        	   960: 	btst #7,D7
00:00009F88 673A            	   961: 	beq.s FE11           	; FERROR;  THIS MODE NOT ALLOWED
00:00009F8A 30343000        	   962: 	move.w (A4,D3.W),D0 	; 111000;   ABSOLUTE SHORT
00:00009F8E 48C0            	   963: 	ext.l D0
00:00009F90 1CFC0024        	   964: 	move.b #'$',(A6)+
00:00009F94 6100F9B0        	   965: 	bsr PNT8HX         		; SIGN EXTENDED VALUE
00:00009F98 5483            	   966: 	addq.l #2,D3         	; SIZE + 2
00:00009F9A 4E75            	   967: 	rts
                            	   968: 
                            	   969: EA1112:
00:00009F9C 0C040001        	   970: 	cmpi.b #1,D4
00:00009FA0 6616            	   971: 	bne.s EA1113
00:00009FA2 08070008        	   972: 	btst #8,D7
00:00009FA6 671C            	   973: 	beq.s FE11          	; FERROR;  THIS MODE NOT ALLOWED
00:00009FA8 1CFC0024        	   974: 	move.b #'$',(A6)+    	; HEX
00:00009FAC 20343000        	   975: 	move.l (A4,D3.W),D0  	; 111001;     ABSOLUTE LONG
00:00009FB0 6100F994        	   976: 	bsr PNT8HX
                            	   977: 	;-       MOVE.B  #'.',(A6)+    ; FORCE LONG FORMAT
                            	   978: 	;-       MOVE.B  #'L',(A6)+    ; IE   .L
00:00009FB4 5883            	   979: 	addq.l #4,D3
00:00009FB6 4E75            	   980: 	rts
                            	   981: 
                            	   982: EA1113:
00:00009FB8 0C040002        	   983: 	cmpi.b #2,D4
00:00009FBC 662C            	   984: 	bne.s EA1114
00:00009FBE 08070009        	   985: 	btst #9,D7
00:00009FC2 6604            	   986: 	bne.s EA1113A
                            	   987: FE11:
00:00009FC4 6000022E        	   988: 	bra FERROR         	; THIS MODE NOT ALLOWED
                            	   989: 
                            	   990: EA1113A:
00:00009FC8 30343000        	   991: 	move.w (A4,D3.W),D0  ; 111010;  PC + DISPLACEMENT  DESTINATION(PC)
00:00009FCC 48C0            	   992: 	ext.l D0
00:00009FCE D0A9FFFC        	   993: 	add.l HISPC(A1),D0
00:00009FD2 5480            	   994: 	addq.l #2,D0
00:00009FD4 1CFC0024        	   995: 	move.b #'$',(A6)+    ; HEX "$"
00:00009FD8 6100F96C        	   996: 	bsr PNT8HX         ; DESTINATION
00:00009FDC 203C29435028    	   997: 	move.l #$29435028,D0  ; (PC)
00:00009FE2 6100FC4C        	   998: 	bsr SCHR           ; STORE WORD
00:00009FE6 5483            	   999: 	addq.l #2,D3         ; SIZE
00:00009FE8 4E75            	  1000: 	rts
                            	  1001: 
                            	  1002: EA1114:
00:00009FEA 0C040003        	  1003: 	cmpi.b #3,D4
00:00009FEE 6664            	  1004: 	bne.s EA1115
                            	  1005: 
                            	  1006: ; PROGRAM COUNTER WITH INDEX    DESTINATION(PC,R@.X)
                            	  1007: ;
                            	  1008: ;        5432109876543210       SECOND WORD
                            	  1009: ;        0...............       DATA REGISTER
                            	  1010: ;        1...............       ADDRESS REGISTER
                            	  1011: ;        .XXX............       REGISTER
                            	  1012: ;        ....0...........       SIGN-EXTENDED, LOW ORDER WORD INTEGER
                            	  1013: ;                               ..IN INDEX REGISTER
                            	  1014: ;        ....1...........       LONG VALUE IN INDEX REGISTER
                            	  1015: ;        .....000........
                            	  1016: ;        ........XXXXXXXX       DISPLACEMENT INTEGER
                            	  1017: ;
00:00009FF0 0807000A        	  1018:          BTST    #10,D7
00:00009FF4 67CE            	  1019:          BEQ.S   FE11           ; FERROR  THIS MODE NOT ASLLOWED
                            	  1020: 
00:00009FF6 32343000        	  1021:          MOVE.W  (A4,D3.W),D1
00:00009FFA 02410700        	  1022:          ANDI.W  #$0700,D1
00:00009FFE 66C4            	  1023:          BNE.S   FE11           ; FERROR;  BITS 10-8 MUST BE ZERO
                            	  1024: 
00:0000A000 10343001        	  1025:          MOVE.B  1(A4,D3.W),D0 ; 111100;   DESTINATION(PC,R@.X)
00:0000A004 4880            	  1026:          EXT.W   D0
00:0000A006 48C0            	  1027:          EXT.L   D0
00:0000A008 D0A9FFFC        	  1028:          ADD.L   HISPC(A1),D0
00:0000A00C 5480            	  1029:          ADDQ.L  #2,D0
00:0000A00E 1CFC0024        	  1030:          MOVE.B  #'$',(A6)+    ; HEX "$"
00:0000A012 6100F932        	  1031:          BSR     PNT8HX         ; DESTINATION
                            	  1032: 
00:0000A016 203C2C435028    	  1033:          MOVE.L  #$2c435028,D0
00:0000A01C 6100FC12        	  1034:          BSR     SCHR           ; DES(PC,
                            	  1035: 
00:0000A020 38343000        	  1036:          MOVE.W  (A4,D3.W),D4
00:0000A024 E95C            	  1037:          ROL.W   #4,D4
00:0000A026 08040003        	  1038:          BTST    #3,D4
00:0000A02A 6706            	  1039:          BEQ.S   EAF25
00:0000A02C 6100FAAA        	  1040:          BSR     FORMREGA
00:0000A030 6004            	  1041:          BRA.S   EAF27
00:0000A032 6100FAB4        	  1042: EAF25:   BSR     FORMREGD       ; DES(PC,R@
                            	  1043: EAF27:
                            	  1044: 
00:0000A036 1CFC002E        	  1045:          MOVE.B  #'.',(A6)+    ; DES(PC,R@.
                            	  1046: 
00:0000A03A 38343000        	  1047:          MOVE.W  (A4,D3.W),D4
00:0000A03E 303C4C57        	  1048:          MOVE.W  #$4c57,D0    ; "LW"
00:0000A042 0804000B        	  1049:          BTST    #11,D4
00:0000A046 6702            	  1050:          BEQ.S   EAF35
00:0000A048 E048            	  1051:          LSR.W   #8,D0
00:0000A04A 1CC0            	  1052: EAF35:   MOVE.B  D0,(A6)+     ; DES(PC,R@.X
                            	  1053: 
00:0000A04C 1CFC0029        	  1054:          MOVE.B  #')',(A6)+    ; DES(PC,R@.X)
00:0000A050 5483            	  1055:          ADDQ.L  #2,D3
00:0000A052 4E75            	  1056:          RTS
                            	  1057: 
                            	  1058: ;   BIT  5432109876543210
                            	  1059: ;        ..........111100       ; FIRST WORD;  #<IMMEDIATE>
                            	  1060: ;
00:0000A054 0C040004        	  1061: EA1115:  CMPI.B  #4,D4
00:0000A058 6600FF6A        	  1062:          BNE     FE11           ; FERROR
                            	  1063: 
00:0000A05C 0807000B        	  1064:          BTST    #11,D7
00:0000A060 6700FF62        	  1065:          BEQ     FE11           ; FERROR;  THIS MODE NOT ALLOWED
                            	  1066: 
00:0000A064 1CFC0023        	  1067:          MOVE.B  #'#',(A6)+    ; IMMEDIATE
                            	  1068: 
00:0000A068 122DFFFF        	  1069:          MOVE.B  -1(A5),D1
00:0000A06C 0C01004C        	  1070:          CMPI.B  #'L',D1
00:0000A070 6724            	  1071:          BEQ.S   EA11155        ; LONG
                            	  1072: 
00:0000A072 30343000        	  1073:          MOVE.W  (A4,D3.W),D0
                            	  1074: 
00:0000A076 0C010042        	  1075:          CMPI.B  #'B',D1
00:0000A07A 6610            	  1076:          BNE.S   EA11153        ; .WORD
                            	  1077: 
                            	  1078: ; BYTE SIZE; DATA ALLOWED
                            	  1079: ;  0000 0000 XXXX XXXX
                            	  1080: ;  1111 1111 1XXX XXXX
00:0000A07C 2200            	  1081:          MOVE.L  D0,D1
00:0000A07E E049            	  1082:          LSR.W   #8,D1
00:0000A080 670A            	  1083:          BEQ.S   EA11153
00:0000A082 2200            	  1084:          MOVE.L  D0,D1
00:0000A084 EE41            	  1085:          ASR.W   #7,D1
00:0000A086 5241            	  1086:          ADDQ.W  #1,D1
00:0000A088 6600FF3A        	  1087:          BNE     FE11           ; FERROR
                            	  1088: 
00:0000A08C 48C0            	  1089: EA11153: EXT.L   D0
00:0000A08E 6100F842        	  1090:          BSR     HEX2DEC
00:0000A092 5483            	  1091:          ADDQ.L  #2,D3
00:0000A094 4E75            	  1092:          RTS
                            	  1093: 
00:0000A096 20343000        	  1094: EA11155: MOVE.L  (A4,D3.W),D0
00:0000A09A 6100F836        	  1095:          BSR     HEX2DEC
00:0000A09E 5883            	  1096:          ADDQ.L  #4,D3         ; SIZE
00:0000A0A0 4E75            	  1097:          RTS
                            	  1098: 
00:0000A0A2 1AFC002E        	  1099: MOVEMS:  MOVE.B  #'.',(A5)+    ; PERIOD
00:0000A0A6 303C4C57        	  1100:          MOVE.W  #$4c57,D0    ; "LW"
00:0000A0AA 08040006        	  1101:          BTST    #6,D4
00:0000A0AE 6702            	  1102:          BEQ.S   MOVEMS2
00:0000A0B0 E048            	  1103:          LSR.W   #8,D0
00:0000A0B2 1AC0            	  1104: MOVEMS2: MOVE.B  D0,(A5)+     ; SIZE
00:0000A0B4 4E75            	  1105:          RTS
                            	  1106: 
                            	  1107: ; MOVEM - REGISTER EXPANSION
                            	  1108: ;
                            	  1109: MOVEMR:  ;.align  2
00:0000A0B6 342C0002        	  1110:          MOVE.W  2(A4),D2     ; D2 = SECOND WORD
00:0000A0BA 7020            	  1111:          MOVEQ   #$20,D0      ; D0 = SPACE
00:0000A0BC 7E2F            	  1112:          MOVEQ   #$2F,D7      ; D7 = /
00:0000A0BE 538E            	  1113:          SUBQ.L  #1,A6         ; ADJUST STORE POINTER
00:0000A0C0 7A30            	  1114:          MOVEQ   #$30,D5      ; D5 = REGISTER #
00:0000A0C2 383C4144        	  1115:          MOVE.W  #$4144,D4    ; "AD" D4 = REG CLASS
                            	  1116: 
00:0000A0C6 0302            	  1117: MOVEMR11:BTST    D1,D2
00:0000A0C8 6730            	  1118:          BEQ.S   MOVEMR77       ; BIT RESET
                            	  1119: 
00:0000A0CA B016            	  1120:          CMP.B   (A6),D0      ; BIT SET
00:0000A0CC 6612            	  1121:          BNE.S   MOVEMR44       ; NOT SPACE
                            	  1122: 
00:0000A0CE 1D440001        	  1123: MOVEMR33:MOVE.B  D4,1(A6)     ; REG TYPE
00:0000A0D2 1D450002        	  1124:          MOVE.B  D5,2(A6)     ; REG #
00:0000A0D6 1D7C002D0003    	  1125:          MOVE.B  #'-',3(A6)    ; -
00:0000A0DC 568E            	  1126:          ADDQ.L  #3,A6
00:0000A0DE 602E            	  1127:          BRA.S   MOVEMR88
                            	  1128: 
                            	  1129: MOVEMR44:
00:0000A0E0 0C16002C        	  1130: 	cmpi.b #',',(A6)
00:0000A0E4 67E8            	  1131: 	beq.s MOVEMR33      ; COMMA SEPARATOR
00:0000A0E6 BE16            	  1132: 	cmp.b (A6),D7      	; / SEPARATOR
00:0000A0E8 67E4            	  1133: 	beq.s MOVEMR33
00:0000A0EA 1D440001        	  1134: 	move.b D4,1(A6)     ; REG TYPE
00:0000A0EE 1D450002        	  1135: 	move.b D5,2(A6)     ; REG #
00:0000A0F2 1D7C002D0003    	  1136: 	move.b #'-',3(A6)   ; - SEPARATOR
00:0000A0F8 6014            	  1137: 	bra.s MOVEMR88
                            	  1138: 
                            	  1139: MOVEMR77:
00:0000A0FA 0C16002C        	  1140: 	cmpi.b #',',(A6)
00:0000A0FE 670E            	  1141: 	beq.s MOVEMR88       ; COMMA
00:0000A100 B016            	  1142: 	cmp.b (A6),D0
00:0000A102 670A            	  1143: 	beq.s MOVEMR88       ; SPACE
00:0000A104 B02E0001        	  1144: 	cmp.b 1(A6),D0
00:0000A108 6702            	  1145: 	beq.s MOVEMR79       ; SPACE
00:0000A10A 568E            	  1146: 	addq.l #3,A6
                            	  1147: MOVEMR79:
00:0000A10C 1C87            	  1148: 	move.b D7,(A6)      ; / SEPARATOR
                            	  1149: 
                            	  1150: MOVEMR88:
00:0000A10E 5285            	  1151: 	addq.l #1,D5
00:0000A110 D286            	  1152: 	add.l D6,D1        ; D1 = BIT POSITION
00:0000A112 0C050038        	  1153: 	cmpi.b #'8',D5
00:0000A116 66AE            	  1154: 	bne.s MOVEMR11
00:0000A118 B016            	  1155: 	cmp.b (A6),D0      ; SPACE
00:0000A11A 670A            	  1156: 	beq.s MOVEMR94
00:0000A11C B02E0001        	  1157: 	cmp.b 1(A6),D0     ; SPACE
00:0000A120 6704            	  1158: 	beq.s MOVEMR94
00:0000A122 568E            	  1159: 	addq.l #3,A6
00:0000A124 1C87            	  1160: 	move.b D7,(A6)      ; /   SEPARATOR
                            	  1161: 
                            	  1162: MOVEMR94:
00:0000A126 1A3C0030        	  1163: 	move.b #'0',D5       	; RESET REG TO ZERO
00:0000A12A E04C            	  1164: 	lsr.w #8,D4         	; CHANGE REG TYPE
00:0000A12C 6698            	  1165: 	bne.s MOVEMR11       	; MORE
00:0000A12E 1C80            	  1166: 	move.b D0,(A6)      	; SPACE
00:0000A130 4E75            	  1167: 	rts
                            	  1168: 
                            	  1169: DCODE68K:
00:0000A132 4E51FFF0        	  1170: 	link A1,#-LOCVARSZ 	; CREATE A FRAME FOR THE
00:0000A136 48E91007FFF0    	  1171: 	movem.l D0-D2/A4,DDATA(A1)  ; CODE AND ITS PC.  A4
00:0000A13C 49E9FFF0        	  1172: 	lea DDATA(A1),A4 		; POINTS TO THE CODE.
00:0000A140 264D            	  1173: 	move.l A5,A3        ; A3 = START OF OUTPUT BUFFER
00:0000A142 2C4D            	  1174: 	move.l A5,A6
00:0000A144 703F            	  1175: 	moveq #BUFSIZE,D0
                            	  1176: DEC311:
00:0000A146 1CFC0020        	  1177:   move.b #BLANK,(a6)+  ; SPACE FILL BUFFER
00:0000A14A 5380            	  1178: 	subq.l #1,D0
00:0000A14C 66F8            	  1179: 	bne.s DEC311
00:0000A14E 421E            	  1180: 	clr.b (a6)+					; NULL temrinate
00:0000A150 2C4B            	  1181: 	move.l A3,A6        ; FORMAT ADDRESS
00:0000A152 2029FFFC        	  1182: 	move.l HISPC(A1),D0
00:0000A156 6100F7F2        	  1183: 	bsr FRELADDR
                            	  1184: 
                            	  1185: ; CHECK FOR KNOWN ILLEGAL CODES
00:0000A15A 3014            	  1186: 	move.w (a4),d0
00:0000A15C 4BFA00C0        	  1187: 	lea KI(PC),a5
00:0000A160 2C4D            	  1188: 	move.l a5,a6
00:0000A162 548E            	  1189: 	add.l #KIEND-KI,a6
                            	  1190: DEC404:
00:0000A164 B05D            	  1191:   cmp.w (a5)+,d0
00:0000A166 671A            	  1192: 	beq.s FE12           ; FERROR;  ILLEGAL CODE
00:0000A168 BBCE            	  1193: 	cmp.l a6,a5
00:0000A16A 66F8            	  1194: 	bne.s DEC404
                            	  1195: 
                            	  1196: ; LOOK FOR MATCH OF OP-CODE
                            	  1197: ;
00:0000A16C 4BFA00B2        	  1198: 	lea TBL(PC),A5   		; A5 = POINTER TO DECODE TABLE
00:0000A170 4DFA0366        	  1199: 	lea TBLE(PC),A6  		; A6 = POINTER TO END OF TABLE
                            	  1200: DEC411:
00:0000A174 3014            	  1201: 	move.w (A4),D0      ;  FIRST WORD
00:0000A176 C05D            	  1202: 	and.w (A5)+,D0     	;  MASK
00:0000A178 B05D            	  1203: 	cmp.w (A5)+,D0
00:0000A17A 6708            	  1204: 	beq.s DEC425        ; FOUND MATCH
00:0000A17C 588D            	  1205: 	addq.l #4,A5        ; UPDATE POINTER
00:0000A17E BBCE            	  1206: 	cmp.l A6,A5
00:0000A180 65F2            	  1207: 	blo.s DEC411        ; MORE TABLE
                            	  1208: FE12:
00:0000A182 6070            	  1209: 	bra.s FERROR        ; ILLEGAL INSTRUCTION
                            	  1210: DEC425:
00:0000A184 7C00            	  1211:   clr.l D6
00:0000A186 3C1D            	  1212: 	move.w (A5)+,D6     ; D6 = (GOTO OFFSET)/4
                            	  1213: ;         LSL.L   #2,D6
00:0000A188 7E00            	  1214: 	clr.l D7
00:0000A18A 3E1D            	  1215: 	move.w (A5)+,D7     ; D7 = INDEX TO OP-CODE
                            	  1216: 
                            	  1217: ; MOVE OP-CODE TO BUFFER
                            	  1218: ;
00:0000A18C 41FA034A        	  1219: 	lea OPCTBL(PC),A0
                            	  1220: DEC510:
00:0000A190 4A47            	  1221:   tst D7
00:0000A192 6708            	  1222: 	beq.s DEC530         	; AT INDEX
                            	  1223: DEC515:
00:0000A194 4A18            	  1224:   tst.b (A0)+
00:0000A196 6AFC            	  1225: 	bpl.s DEC515         	; MOVE THROUGH FIELD
00:0000A198 5387            	  1226: 	subq.l #1,D7
00:0000A19A 60F4            	  1227: 	bra.s DEC510
                            	  1228: DEC530:
00:0000A19C 701F            	  1229: 	moveq #FOC,D0
00:0000A19E 4BF30000        	  1230: 	lea.l (A3,D0.W),A5 		; A5 = STORE POINTER  OP-CODE
                            	  1231: DEC535:
00:0000A1A2 1018            	  1232:   move.b (A0)+,D0
00:0000A1A4 08800007        	  1233: 	bclr #7,D0
00:0000A1A8 6604            	  1234: 	bne.s DEC537         	; END OF MOVE
00:0000A1AA 1AC0            	  1235: 	move.b D0,(A5)+
00:0000A1AC 60F4            	  1236: 	bra.s DEC535
                            	  1237: DEC537:
00:0000A1AE 1AC0            	  1238:   move.b D0,(A5)+
                            	  1239: 
                            	  1240: ; CALCULATE GOTO AND GO
                            	  1241: ;
00:0000A1B0 7602            	  1242: 	moveq #2,D3         ; D3= SIZE
00:0000A1B2 41FAF7F4        	  1243: 	lea X(PC),A0
00:0000A1B6 D1C6            	  1244: 	add.l D6,A0
00:0000A1B8 7027            	  1245: 	moveq #FOP,D0
00:0000A1BA 4DF30000        	  1246: 	lea.l (A3,D0.W),A6 	; A6 = POINTER FOR OPERAND
00:0000A1BE 3814            	  1247: 	move.w (A4),D4      ; D4 = FIRST WORD
00:0000A1C0 1A3C002C        	  1248: 	move.b #',',D5      ; D5 = CONTAINS ASCII COMMA
00:0000A1C4 3E3C01FD        	  1249: 	move.w #$1FD,D7     ; D7 = DATA ALTERABLE MODES ALLOWED
00:0000A1C8 4ED0            	  1250: 	jmp (A0)
                            	  1251: 
                            	  1252: ;	 A3 = pointer to beginning of buffer
                            	  1253: ;  A4 = POINTER TO DATA IN FRAME CREATED BY "LINK A1,..."
                            	  1254: ;  A5 = POINTER STORE OP-CODE
                            	  1255: ;  A6 = POINTER STORE OPERAND
                            	  1256: ;  D3 = SIZE = 2 BYTES
                            	  1257: ;  D4 = FIRST WORD
                            	  1258: ;  D7 = ADDRESS MODES ALLOWED ($1FD) DATA ALTERABLE
                            	  1259: 
                            	  1260: COMMON4:
00:0000A1CA 5483            	  1261: 	addq.l #2,D3         	; SIZE = 4
                            	  1262: COMMON:
00:0000A1CC 2C03            	  1263: 	move.l D3,D6        	; D6 = SIZE
00:0000A1CE 1CFC0020        	  1264: 	move.b #BLANK,(A6)+ 	; SPACE AS LAST CHAR
00:0000A1D2 2A4E            	  1265: 	move.l A6,A5        	; SAVE END OF BUFFER POINTER
00:0000A1D4 700A            	  1266: 	moveq #FDATA,D0
00:0000A1D6 4DF30000        	  1267: 	lea.l (A3,D0.W),A6
                            	  1268: COMMON35:
00:0000A1DA 301C            	  1269: 	move.w (A4)+,D0     	; GET NEXT WORD OF DATA.
00:0000A1DC 54A9FFFC        	  1270: 	addq.l #2,HISPC(A1)  	; ADJUST PROG COUNTER.
00:0000A1E0 6100F754        	  1271: 	bsr PNT4HX         		; FORMAT DATA. (A6)+
00:0000A1E4 5503            	  1272: 	subq.b #2,D3
00:0000A1E6 66F2            	  1273: 	bne.s COMMON35
00:0000A1E8 2C4D            	  1274: 	move.l A5,A6        	; A6 = RESTORE END POINTER
00:0000A1EA 2A4B            	  1275: 	move.l A3,A5        	; A5 =  BEGINNING OF BUFFER
00:0000A1EC 2869FFFC        	  1276: 	move.l HISPC(A1),A4 	; MOVE THE UPDATED PC
00:0000A1F0 4E59            	  1277: 	unlk A1            		; TO A4 AND UNDO FRAME.
00:0000A1F2 4E75            	  1278: 	rts
                            	  1279: 
                            	  1280: FERROR:  ;.align  2
                            	  1281: ; ILLEGAL INSTRUCTION
                            	  1282: ;
00:0000A1F4 701F            	  1283: 	moveq #FOC,D0
00:0000A1F6 4DF30000        	  1284: 	lea.l (A3,D0.W),A6
00:0000A1FA 4BFA0018        	  1285: 	lea MSG111(PC),A5
                            	  1286: FERROR35:
00:0000A1FE 101D            	  1287: 	move.b (A5)+,D0
00:0000A200 0C000004        	  1288: 	cmpi.b #EOT,D0
00:0000A204 6704            	  1289: 	beq.s FERROR39
00:0000A206 1CC0            	  1290: 	move.b D0,(A6)+
00:0000A208 60F4            	  1291: 	bra.s FERROR35
                            	  1292: FERROR39:
00:0000A20A 3014            	  1293: 	move.w (A4),D0
00:0000A20C 6100F728        	  1294: 	bsr PNT4HX
00:0000A210 7602            	  1295: 	moveq #2,D3         ; SIZE
00:0000A212 60B8            	  1296: 	bra.s COMMON
                            	  1297: MSG111:  
00:0000A214 44432E5720202020	  1298: 	dc.b "DC.W    $"
00:0000A21C 24
00:0000A21D 04              	  1299: 	dc.b EOT
                            	  1300: 
                            	  1301: KI:
00:0000A21E 4AFB            	  1302: 	dc.w $4AFB         ; KNOWN ILLEGAL CODES
                            	  1303: KIEND:   
                            	  1304: 	even
                            	  1305: 
                            	  1306: ;  \1   MASK
                            	  1307: ;  \2   OP-CODE PATTERN
                            	  1308: ;  \3   GOTO OFFSET
                            	  1309: ;  \4   INDEX TO OP-CODE
                            	  1310: C68:     macro arg1,arg2,arg3,arg4
                            	  1311:          DC.W    $\1
                            	  1312:          DC.W    $\2
                            	  1313:          DC.W    (\3-X)
                            	  1314:          DC.w    \4
                            	  1315:          endm
                            	  1316: 
                            	  1317: 				 even
                            	  1318: TBL:     ;.align  2
                            	  1319:          C68     FEC0,E6C0,ISHIFT,56           ; RO
00:0000A220 FEC0            	     1M          DC.W    $FEC0
00:0000A222 E6C0            	     2M          DC.W    $E6C0
00:0000A224 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A226 0038            	     4M          DC.w    56
                            	  1320:          C68     FEC0,E4C0,ISHIFT,57           ; ROX
00:0000A228 FEC0            	     1M          DC.W    $FEC0
00:0000A22A E4C0            	     2M          DC.W    $E4C0
00:0000A22C 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A22E 0039            	     4M          DC.w    57
                            	  1321:          C68     FEC0,E2C0,ISHIFT,55           ; LS
00:0000A230 FEC0            	     1M          DC.W    $FEC0
00:0000A232 E2C0            	     2M          DC.W    $E2C0
00:0000A234 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A236 0037            	     4M          DC.w    55
                            	  1322:          C68     FEC0,E0C0,ISHIFT,54           ; AS
00:0000A238 FEC0            	     1M          DC.W    $FEC0
00:0000A23A E0C0            	     2M          DC.W    $E0C0
00:0000A23C 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A23E 0036            	     4M          DC.w    54
                            	  1323:          C68     F018,E018,ISHIFT,56           ; RO
00:0000A240 F018            	     1M          DC.W    $F018
00:0000A242 E018            	     2M          DC.W    $E018
00:0000A244 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A246 0038            	     4M          DC.w    56
                            	  1324:          C68     F018,E010,ISHIFT,57           ; ROX
00:0000A248 F018            	     1M          DC.W    $F018
00:0000A24A E010            	     2M          DC.W    $E010
00:0000A24C 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A24E 0039            	     4M          DC.w    57
                            	  1325:          C68     F018,E008,ISHIFT,55           ; LS
00:0000A250 F018            	     1M          DC.W    $F018
00:0000A252 E008            	     2M          DC.W    $E008
00:0000A254 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A256 0037            	     4M          DC.w    55
                            	  1326:          C68     F018,E000,ISHIFT,54           ; AS
00:0000A258 F018            	     1M          DC.W    $F018
00:0000A25A E000            	     2M          DC.W    $E000
00:0000A25C 03B6            	     3M          DC.W    (ISHIFT-X)
00:0000A25E 0036            	     4M          DC.w    54
                            	  1327:          C68     F0C0,D0C0,FORM10EX,4          ; ADD       <EA>,A@
00:0000A260 F0C0            	     1M          DC.W    $F0C0
00:0000A262 D0C0            	     2M          DC.W    $D0C0
00:0000A264 016A            	     3M          DC.W    (FORM10EX-X)
00:0000A266 0004            	     4M          DC.w    4
                            	  1328:          C68     F130,D100,FORM12,53           ; ADDX
00:0000A268 F130            	     1M          DC.W    $F130
00:0000A26A D100            	     2M          DC.W    $D100
00:0000A26C 0208            	     3M          DC.W    (FORM12-X)
00:0000A26E 0035            	     4M          DC.w    53
                            	  1329:          C68     F000,D000,FORM10EX,4          ; ADD
00:0000A270 F000            	     1M          DC.W    $F000
00:0000A272 D000            	     2M          DC.W    $D000
00:0000A274 016A            	     3M          DC.W    (FORM10EX-X)
00:0000A276 0004            	     4M          DC.w    4
                            	  1330:          C68     F1F8,C188,FORM9,50            ; EXG
00:0000A278 F1F8            	     1M          DC.W    $F1F8
00:0000A27A C188            	     2M          DC.W    $C188
00:0000A27C 0160            	     3M          DC.W    (FORM9-X)
00:0000A27E 0032            	     4M          DC.w    50
                            	  1331:          C68     F1F8,C148,FORM8,50            ; EXG
00:0000A280 F1F8            	     1M          DC.W    $F1F8
00:0000A282 C148            	     2M          DC.W    $C148
00:0000A284 0152            	     3M          DC.W    (FORM8-X)
00:0000A286 0032            	     4M          DC.w    50
                            	  1332:          C68     F1F8,C140,FORM7,50            ; EXG
00:0000A288 F1F8            	     1M          DC.W    $F1F8
00:0000A28A C140            	     2M          DC.W    $C140
00:0000A28C 0146            	     3M          DC.W    (FORM7-X)
00:0000A28E 0032            	     4M          DC.w    50
                            	  1333:          C68     F1F0,C100,FORM12,49           ; ABCD
00:0000A290 F1F0            	     1M          DC.W    $F1F0
00:0000A292 C100            	     2M          DC.W    $C100
00:0000A294 0208            	     3M          DC.W    (FORM12-X)
00:0000A296 0031            	     4M          DC.w    49
                            	  1334:          C68     F1C0,C1C0,FORM6D,48           ; MULS
00:0000A298 F1C0            	     1M          DC.W    $F1C0
00:0000A29A C1C0            	     2M          DC.W    $C1C0
00:0000A29C 0120            	     3M          DC.W    (FORM6D-X)
00:0000A29E 0030            	     4M          DC.w    48
                            	  1335:          C68     F1C0,C0C0,FORM6D,47           ; MULU
00:0000A2A0 F1C0            	     1M          DC.W    $F1C0
00:0000A2A2 C0C0            	     2M          DC.W    $C0C0
00:0000A2A4 0120            	     3M          DC.W    (FORM6D-X)
00:0000A2A6 002F            	     4M          DC.w    47
                            	  1336:          C68     F000,C000,FORM10,2            ; AND
00:0000A2A8 F000            	     1M          DC.W    $F000
00:0000A2AA C000            	     2M          DC.W    $C000
00:0000A2AC 01A8            	     3M          DC.W    (FORM10-X)
00:0000A2AE 0002            	     4M          DC.w    2
                            	  1337:          C68     F0C0,B0C0,FORM10EX,6          ; CMP     <EA>,A@
00:0000A2B0 F0C0            	     1M          DC.W    $F0C0
00:0000A2B2 B0C0            	     2M          DC.W    $B0C0
00:0000A2B4 016A            	     3M          DC.W    (FORM10EX-X)
00:0000A2B6 0006            	     4M          DC.w    6
                            	  1338:          C68     F138,B108,FORM12A,46          ; CMPM
00:0000A2B8 F138            	     1M          DC.W    $F138
00:0000A2BA B108            	     2M          DC.W    $B108
00:0000A2BC 0244            	     3M          DC.W    (FORM12A-X)
00:0000A2BE 002E            	     4M          DC.w    46
                            	  1339:          C68     F100,B100,FORM10,5            ; EOR
00:0000A2C0 F100            	     1M          DC.W    $F100
00:0000A2C2 B100            	     2M          DC.W    $B100
00:0000A2C4 01A8            	     3M          DC.W    (FORM10-X)
00:0000A2C6 0005            	     4M          DC.w    5
                            	  1340:          C68     F000,B000,FORM10EX,6          ; CMP
00:0000A2C8 F000            	     1M          DC.W    $F000
00:0000A2CA B000            	     2M          DC.W    $B000
00:0000A2CC 016A            	     3M          DC.W    (FORM10EX-X)
00:0000A2CE 0006            	     4M          DC.w    6
                            	  1341:          C68     F0C0,90C0,FORM10EX,44         ; SUB       <EA>,A@
00:0000A2D0 F0C0            	     1M          DC.W    $F0C0
00:0000A2D2 90C0            	     2M          DC.W    $90C0
00:0000A2D4 016A            	     3M          DC.W    (FORM10EX-X)
00:0000A2D6 002C            	     4M          DC.w    44
                            	  1342:          C68     F130,9100,FORM12,45           ; SUBX
00:0000A2D8 F130            	     1M          DC.W    $F130
00:0000A2DA 9100            	     2M          DC.W    $9100
00:0000A2DC 0208            	     3M          DC.W    (FORM12-X)
00:0000A2DE 002D            	     4M          DC.w    45
                            	  1343:          C68     F000,9000,FORM10EX,44         ; SUB
00:0000A2E0 F000            	     1M          DC.W    $F000
00:0000A2E2 9000            	     2M          DC.W    $9000
00:0000A2E4 016A            	     3M          DC.W    (FORM10EX-X)
00:0000A2E6 002C            	     4M          DC.w    44
                            	  1344:          C68     F1F0,8100,FORM12,43           ; SBCD
00:0000A2E8 F1F0            	     1M          DC.W    $F1F0
00:0000A2EA 8100            	     2M          DC.W    $8100
00:0000A2EC 0208            	     3M          DC.W    (FORM12-X)
00:0000A2EE 002B            	     4M          DC.w    43
                            	  1345:          C68     F1C0,81C0,FORM6D,42           ; DIVS
00:0000A2F0 F1C0            	     1M          DC.W    $F1C0
00:0000A2F2 81C0            	     2M          DC.W    $81C0
00:0000A2F4 0120            	     3M          DC.W    (FORM6D-X)
00:0000A2F6 002A            	     4M          DC.w    42
                            	  1346:          C68     F1C0,80C0,FORM6D,41           ; DIVU
00:0000A2F8 F1C0            	     1M          DC.W    $F1C0
00:0000A2FA 80C0            	     2M          DC.W    $80C0
00:0000A2FC 0120            	     3M          DC.W    (FORM6D-X)
00:0000A2FE 0029            	     4M          DC.w    41
                            	  1347:          C68     F000,8000,FORM10,40           ; OR
00:0000A300 F000            	     1M          DC.W    $F000
00:0000A302 8000            	     2M          DC.W    $8000
00:0000A304 01A8            	     3M          DC.W    (FORM10-X)
00:0000A306 0028            	     4M          DC.w    40
                            	  1348:          C68     F100,7000,IMOVEQ,39           ; MOVEQ
00:0000A308 F100            	     1M          DC.W    $F100
00:0000A30A 7000            	     2M          DC.W    $7000
00:0000A30C 0270            	     3M          DC.W    (IMOVEQ-X)
00:0000A30E 0027            	     4M          DC.w    39
                            	  1349:          C68     FF00,6100,IBSR,51             ; BSR
00:0000A310 FF00            	     1M          DC.W    $FF00
00:0000A312 6100            	     2M          DC.W    $6100
00:0000A314 0354            	     3M          DC.W    (IBSR-X)
00:0000A316 0033            	     4M          DC.w    51
                            	  1350:          C68     FF00,6000,IBSR,65             ; BRA
00:0000A318 FF00            	     1M          DC.W    $FF00
00:0000A31A 6000            	     2M          DC.W    $6000
00:0000A31C 0354            	     3M          DC.W    (IBSR-X)
00:0000A31E 0041            	     4M          DC.w    65
                            	  1351:          C68     F000,6000,ICC,38              ; B
00:0000A320 F000            	     1M          DC.W    $F000
00:0000A322 6000            	     2M          DC.W    $6000
00:0000A324 0350            	     3M          DC.W    (ICC-X)
00:0000A326 0026            	     4M          DC.w    38
                            	  1352:          C68     F0F8,50C8,IDBCC,37            ; DB
00:0000A328 F0F8            	     1M          DC.W    $F0F8
00:0000A32A 50C8            	     2M          DC.W    $50C8
00:0000A32C 033E            	     3M          DC.W    (IDBCC-X)
00:0000A32E 0025            	     4M          DC.w    37
                            	  1353:          C68     F0C0,50C0,ISCC,36             ; S
00:0000A330 F0C0            	     1M          DC.W    $F0C0
00:0000A332 50C0            	     2M          DC.W    $50C0
00:0000A334 0334            	     3M          DC.W    (ISCC-X)
00:0000A336 0024            	     4M          DC.w    36
                            	  1354:          C68     F100,5100,IQUICK,35           ; SUBQ
00:0000A338 F100            	     1M          DC.W    $F100
00:0000A33A 5100            	     2M          DC.W    $5100
00:0000A33C 026C            	     3M          DC.W    (IQUICK-X)
00:0000A33E 0023            	     4M          DC.w    35
                            	  1355:          C68     F100,5000,IQUICK,34           ; ADDQ
00:0000A340 F100            	     1M          DC.W    $F100
00:0000A342 5000            	     2M          DC.W    $5000
00:0000A344 026C            	     3M          DC.W    (IQUICK-X)
00:0000A346 0022            	     4M          DC.w    34
                            	  1356:          C68     F1C0,41C0,FORM6A,33           ; LEA
00:0000A348 F1C0            	     1M          DC.W    $F1C0
00:0000A34A 41C0            	     2M          DC.W    $41C0
00:0000A34C 0110            	     3M          DC.W    (FORM6A-X)
00:0000A34E 0021            	     4M          DC.w    33
                            	  1357:          C68     F1C0,4180,FORM6D,32           ; CHK
00:0000A350 F1C0            	     1M          DC.W    $F1C0
00:0000A352 4180            	     2M          DC.W    $4180
00:0000A354 0120            	     3M          DC.W    (FORM6D-X)
00:0000A356 0020            	     4M          DC.w    32
                            	  1358:          C68     FFC0,4EC0,FORM11SL,31         ; JMP
00:0000A358 FFC0            	     1M          DC.W    $FFC0
00:0000A35A 4EC0            	     2M          DC.W    $4EC0
00:0000A35C 01E4            	     3M          DC.W    (FORM11SL-X)
00:0000A35E 001F            	     4M          DC.w    31
                            	  1359:          C68     FFC0,4E80,FORM11SL,30         ; JSR
00:0000A360 FFC0            	     1M          DC.W    $FFC0
00:0000A362 4E80            	     2M          DC.W    $4E80
00:0000A364 01E4            	     3M          DC.W    (FORM11SL-X)
00:0000A366 001E            	     4M          DC.w    30
                            	  1360:          C68     FFFF,4E77,SCOMMON,29          ; RTR
00:0000A368 FFFF            	     1M          DC.W    $FFFF
00:0000A36A 4E77            	     2M          DC.W    $4E77
00:0000A36C 0330            	     3M          DC.W    (SCOMMON-X)
00:0000A36E 001D            	     4M          DC.w    29
                            	  1361:          C68     FFFF,4E76,SCOMMON,28          ; TRAPV
00:0000A370 FFFF            	     1M          DC.W    $FFFF
00:0000A372 4E76            	     2M          DC.W    $4E76
00:0000A374 0330            	     3M          DC.W    (SCOMMON-X)
00:0000A376 001C            	     4M          DC.w    28
                            	  1362:          C68     FFFF,4E75,SCOMMON,27          ; RTS
00:0000A378 FFFF            	     1M          DC.W    $FFFF
00:0000A37A 4E75            	     2M          DC.W    $4E75
00:0000A37C 0330            	     3M          DC.W    (SCOMMON-X)
00:0000A37E 001B            	     4M          DC.w    27
                            	  1363:          C68     FFFF,4E73,SCOMMON,26          ; RTE
00:0000A380 FFFF            	     1M          DC.W    $FFFF
00:0000A382 4E73            	     2M          DC.W    $4E73
00:0000A384 0330            	     3M          DC.W    (SCOMMON-X)
00:0000A386 001A            	     4M          DC.w    26
                            	  1364:          C68     FFFF,4E72,ISTOP,25            ; STOP
00:0000A388 FFFF            	     1M          DC.W    $FFFF
00:0000A38A 4E72            	     2M          DC.W    $4E72
00:0000A38C 004A            	     3M          DC.W    (ISTOP-X)
00:0000A38E 0019            	     4M          DC.w    25
                            	  1365:          C68     FFFF,4E71,SCOMMON,24          ; NOP
00:0000A390 FFFF            	     1M          DC.W    $FFFF
00:0000A392 4E71            	     2M          DC.W    $4E71
00:0000A394 0330            	     3M          DC.W    (SCOMMON-X)
00:0000A396 0018            	     4M          DC.w    24
                            	  1366:          C68     FFFF,4E70,SCOMMON,23          ; RESET
00:0000A398 FFFF            	     1M          DC.W    $FFFF
00:0000A39A 4E70            	     2M          DC.W    $4E70
00:0000A39C 0330            	     3M          DC.W    (SCOMMON-X)
00:0000A39E 0017            	     4M          DC.w    23
                            	  1367:          C68     FFF8,4E68,IMVFUSP,60          ; MOVE FROM USP
00:0000A3A0 FFF8            	     1M          DC.W    $FFF8
00:0000A3A2 4E68            	     2M          DC.W    $4E68
00:0000A3A4 029E            	     3M          DC.W    (IMVFUSP-X)
00:0000A3A6 003C            	     4M          DC.w    60
                            	  1368:          C68     FFF8,4E60,IMVTUSP,60          ; MOVE TO USP
00:0000A3A8 FFF8            	     1M          DC.W    $FFF8
00:0000A3AA 4E60            	     2M          DC.W    $4E60
00:0000A3AC 02BE            	     3M          DC.W    (IMVTUSP-X)
00:0000A3AE 003C            	     4M          DC.w    60
                            	  1369:          C68     FFF8,4E58,FORM5,22            ; UNLINK
00:0000A3B0 FFF8            	     1M          DC.W    $FFF8
00:0000A3B2 4E58            	     2M          DC.W    $4E58
00:0000A3B4 010C            	     3M          DC.W    (FORM5-X)
00:0000A3B6 0016            	     4M          DC.w    22
                            	  1370:          C68     FFF8,4E50,ILINK,21            ; LINK
00:0000A3B8 FFF8            	     1M          DC.W    $FFF8
00:0000A3BA 4E50            	     2M          DC.W    $4E50
00:0000A3BC 00D6            	     3M          DC.W    (ILINK-X)
00:0000A3BE 0015            	     4M          DC.w    21
                            	  1371:          C68     FFF0,4E40,FORM4,20            ; TRAP
00:0000A3C0 FFF0            	     1M          DC.W    $FFF0
00:0000A3C2 4E40            	     2M          DC.W    $4E40
00:0000A3C4 00FA            	     3M          DC.W    (FORM4-X)
00:0000A3C6 0014            	     4M          DC.w    20
                            	  1372:          C68     FF80,4C80,IMOVEMTR,15         ; MOVEM FROM REGISTERS
00:0000A3C8 FF80            	     1M          DC.W    $FF80
00:0000A3CA 4C80            	     2M          DC.W    $4C80
00:0000A3CC 002E            	     3M          DC.W    (IMOVEMTR-X)
00:0000A3CE 000F            	     4M          DC.w    15
                            	  1373:          C68     FFC0,4AC0,FORM1A,19           ; TAS
00:0000A3D0 FFC0            	     1M          DC.W    $FFC0
00:0000A3D2 4AC0            	     2M          DC.W    $4AC0
00:0000A3D4 00F0            	     3M          DC.W    (FORM1A-X)
00:0000A3D6 0013            	     4M          DC.w    19
                            	  1374:          C68     FF00,4A00,FORM1,18            ; TST
00:0000A3D8 FF00            	     1M          DC.W    $FF00
00:0000A3DA 4A00            	     2M          DC.W    $4A00
00:0000A3DC 00EC            	     3M          DC.W    (FORM1-X)
00:0000A3DE 0012            	     4M          DC.w    18
                            	  1375:          C68     FFF8,48C0,FORM3,17            ; EXT.L
00:0000A3E0 FFF8            	     1M          DC.W    $FFF8
00:0000A3E2 48C0            	     2M          DC.W    $48C0
00:0000A3E4 00F6            	     3M          DC.W    (FORM3-X)
00:0000A3E6 0011            	     4M          DC.w    17
                            	  1376:          C68     FFF8,4880,FORM3,16            ; EXT.W
00:0000A3E8 FFF8            	     1M          DC.W    $FFF8
00:0000A3EA 4880            	     2M          DC.W    $4880
00:0000A3EC 00F6            	     3M          DC.W    (FORM3-X)
00:0000A3EE 0010            	     4M          DC.w    16
                            	  1377:          C68     FF80,4880,IMOVEMFR,15         ; MOVEA TO REGISTERS
00:0000A3F0 FF80            	     1M          DC.W    $FF80
00:0000A3F2 4880            	     2M          DC.W    $4880
00:0000A3F4 0000            	     3M          DC.W    (IMOVEMFR-X)
00:0000A3F6 000F            	     4M          DC.w    15
                            	  1378:          C68     FFF8,4840,FORM3,14            ; SWAP
00:0000A3F8 FFF8            	     1M          DC.W    $FFF8
00:0000A3FA 4840            	     2M          DC.W    $4840
00:0000A3FC 00F6            	     3M          DC.W    (FORM3-X)
00:0000A3FE 000E            	     4M          DC.w    14
                            	  1379:          C68     FFC0,4840,FORM11,13           ; PEA
00:0000A400 FFC0            	     1M          DC.W    $FFC0
00:0000A402 4840            	     2M          DC.W    $4840
00:0000A404 01DC            	     3M          DC.W    (FORM11-X)
00:0000A406 000D            	     4M          DC.w    13
                            	  1380:          C68     FFC0,4800,FORM1A,12           ; NBCD
00:0000A408 FFC0            	     1M          DC.W    $FFC0
00:0000A40A 4800            	     2M          DC.W    $4800
00:0000A40C 00F0            	     3M          DC.W    (FORM1A-X)
00:0000A40E 000C            	     4M          DC.w    12
                            	  1381:          C68     FFC0,46C0,IMVTSR,59           ; MOVE TO SR
00:0000A410 FFC0            	     1M          DC.W    $FFC0
00:0000A412 46C0            	     2M          DC.W    $46C0
00:0000A414 02AC            	     3M          DC.W    (IMVTSR-X)
00:0000A416 003B            	     4M          DC.w    59
                            	  1382:          C68     FF00,4600,FORM1,11            ; NOT
00:0000A418 FF00            	     1M          DC.W    $FF00
00:0000A41A 4600            	     2M          DC.W    $4600
00:0000A41C 00EC            	     3M          DC.W    (FORM1-X)
00:0000A41E 000B            	     4M          DC.w    11
                            	  1383:          C68     FFC0,44C0,IMVTCCR,59          ; MOVE TO CCR
00:0000A420 FFC0            	     1M          DC.W    $FFC0
00:0000A422 44C0            	     2M          DC.W    $44C0
00:0000A424 02CA            	     3M          DC.W    (IMVTCCR-X)
00:0000A426 003B            	     4M          DC.w    59
                            	  1384:          C68     FF00,4400,FORM1,10            ; NEG
00:0000A428 FF00            	     1M          DC.W    $FF00
00:0000A42A 4400            	     2M          DC.W    $4400
00:0000A42C 00EC            	     3M          DC.W    (FORM1-X)
00:0000A42E 000A            	     4M          DC.w    10
                            	  1385:          C68     FF00,4200,FORM1,9             ; CLR
00:0000A430 FF00            	     1M          DC.W    $FF00
00:0000A432 4200            	     2M          DC.W    $4200
00:0000A434 00EC            	     3M          DC.W    (FORM1-X)
00:0000A436 0009            	     4M          DC.w    9
                            	  1386:          C68     FFC0,40C0,IMVFSR,59           ; MOVE.W  FROM  SR
00:0000A438 FFC0            	     1M          DC.W    $FFC0
00:0000A43A 40C0            	     2M          DC.W    $40C0
00:0000A43C 0290            	     3M          DC.W    (IMVFSR-X)
00:0000A43E 003B            	     4M          DC.w    59
                            	  1387:          C68     FF00,4000,FORM1,8             ; NEGX
00:0000A440 FF00            	     1M          DC.W    $FF00
00:0000A442 4000            	     2M          DC.W    $4000
00:0000A444 00EC            	     3M          DC.W    (FORM1-X)
00:0000A446 0008            	     4M          DC.w    8
                            	  1388:          C68     F000,3000,IMOVE,59            ; MOVE.W
00:0000A448 F000            	     1M          DC.W    $F000
00:0000A44A 3000            	     2M          DC.W    $3000
00:0000A44C 00D2            	     3M          DC.W    (IMOVE-X)
00:0000A44E 003B            	     4M          DC.w    59
                            	  1389:          C68     F000,2000,IMOVE,60            ; MOVE.L
00:0000A450 F000            	     1M          DC.W    $F000
00:0000A452 2000            	     2M          DC.W    $2000
00:0000A454 00D2            	     3M          DC.W    (IMOVE-X)
00:0000A456 003C            	     4M          DC.w    60
                            	  1390:          C68     F000,1000,IMOVE,58            ; MOVE.B
00:0000A458 F000            	     1M          DC.W    $F000
00:0000A45A 1000            	     2M          DC.W    $1000
00:0000A45C 00D2            	     3M          DC.W    (IMOVE-X)
00:0000A45E 003A            	     4M          DC.w    58
                            	  1391:          C68     FF00,0C00,IMMED,6             ; CMP       #
00:0000A460 FF00            	     1M          DC.W    $FF00
00:0000A462 0C00            	     2M          DC.W    $0C00
00:0000A464 005E            	     3M          DC.W    (IMMED-X)
00:0000A466 0006            	     4M          DC.w    6
                            	  1392:          C68     FF00,0A00,IMMED,5             ; EOR       #
00:0000A468 FF00            	     1M          DC.W    $FF00
00:0000A46A 0A00            	     2M          DC.W    $0A00
00:0000A46C 005E            	     3M          DC.W    (IMMED-X)
00:0000A46E 0005            	     4M          DC.w    5
                            	  1393:          C68     FF00,0600,IMMED,4             ; ADD       #
00:0000A470 FF00            	     1M          DC.W    $FF00
00:0000A472 0600            	     2M          DC.W    $0600
00:0000A474 005E            	     3M          DC.W    (IMMED-X)
00:0000A476 0004            	     4M          DC.w    4
                            	  1394:          C68     FF00,0400,IMMED,3             ; SUB       #
00:0000A478 FF00            	     1M          DC.W    $FF00
00:0000A47A 0400            	     2M          DC.W    $0400
00:0000A47C 005E            	     3M          DC.W    (IMMED-X)
00:0000A47E 0003            	     4M          DC.w    3
                            	  1395:          C68     FF00,0200,IMMED,2             ; AND       #
00:0000A480 FF00            	     1M          DC.W    $FF00
00:0000A482 0200            	     2M          DC.W    $0200
00:0000A484 005E            	     3M          DC.W    (IMMED-X)
00:0000A486 0002            	     4M          DC.w    2
                            	  1396:          C68     FF00,0000,IMMED,1             ; OR        #
00:0000A488 FF00            	     1M          DC.W    $FF00
00:0000A48A 0000            	     2M          DC.W    $0000
00:0000A48C 005E            	     3M          DC.W    (IMMED-X)
00:0000A48E 0001            	     4M          DC.w    1
                            	  1397:          C68     F138,0108,IMOVEP,0            ; MOVEP
00:0000A490 F138            	     1M          DC.W    $F138
00:0000A492 0108            	     2M          DC.W    $0108
00:0000A494 02DA            	     3M          DC.W    (IMOVEP-X)
00:0000A496 0000            	     4M          DC.w    0
                            	  1398:          C68     FFC0,08C0,ISETS,64            ; BSET
00:0000A498 FFC0            	     1M          DC.W    $FFC0
00:0000A49A 08C0            	     2M          DC.W    $08C0
00:0000A49C 039C            	     3M          DC.W    (ISETS-X)
00:0000A49E 0040            	     4M          DC.w    64
                            	  1399:          C68     FFC0,0880,ISETS,63            ; BCLR
00:0000A4A0 FFC0            	     1M          DC.W    $FFC0
00:0000A4A2 0880            	     2M          DC.W    $0880
00:0000A4A4 039C            	     3M          DC.W    (ISETS-X)
00:0000A4A6 003F            	     4M          DC.w    63
                            	  1400:          C68     FFC0,0840,ISETS,62            ; BCHG
00:0000A4A8 FFC0            	     1M          DC.W    $FFC0
00:0000A4AA 0840            	     2M          DC.W    $0840
00:0000A4AC 039C            	     3M          DC.W    (ISETS-X)
00:0000A4AE 003E            	     4M          DC.w    62
                            	  1401:          C68     FFC0,0800,ISETS,61            ; BTST
00:0000A4B0 FFC0            	     1M          DC.W    $FFC0
00:0000A4B2 0800            	     2M          DC.W    $0800
00:0000A4B4 039C            	     3M          DC.W    (ISETS-X)
00:0000A4B6 003D            	     4M          DC.w    61
                            	  1402:          C68     F1C0,01C0,ISETD,64            ; BSET
00:0000A4B8 F1C0            	     1M          DC.W    $F1C0
00:0000A4BA 01C0            	     2M          DC.W    $01C0
00:0000A4BC 038C            	     3M          DC.W    (ISETD-X)
00:0000A4BE 0040            	     4M          DC.w    64
                            	  1403:          C68     F1C0,0180,ISETD,63            ; BCLR
00:0000A4C0 F1C0            	     1M          DC.W    $F1C0
00:0000A4C2 0180            	     2M          DC.W    $0180
00:0000A4C4 038C            	     3M          DC.W    (ISETD-X)
00:0000A4C6 003F            	     4M          DC.w    63
                            	  1404:          C68     F1C0,0140,ISETD,62            ; BCHG
00:0000A4C8 F1C0            	     1M          DC.W    $F1C0
00:0000A4CA 0140            	     2M          DC.W    $0140
00:0000A4CC 038C            	     3M          DC.W    (ISETD-X)
00:0000A4CE 003E            	     4M          DC.w    62
                            	  1405:          C68     F1C0,0100,ISETD,61            ; BTST
00:0000A4D0 F1C0            	     1M          DC.W    $F1C0
00:0000A4D2 0100            	     2M          DC.W    $0100
00:0000A4D4 038C            	     3M          DC.W    (ISETD-X)
00:0000A4D6 003D            	     4M          DC.w    61
                            	  1406: TBLE:
                            	  1407:           even
                            	  1408: 
                            	  1409: N68:     macro arg1,arg2
                            	  1410:          dc.b  "\1",\2
                            	  1411:          endm
                            	  1412: 
                            	  1413: 				even
                            	  1414: OPCTBL:  ;.align  2
                            	  1415:          N68     MOVE,$d0    ; 0
00:0000A4D8 4D4F5645        	     1M          dc.b  "MOVE",$d0
00:0000A4DC D0
                            	  1416:          N68     O,$d2       ; 1
00:0000A4DD 4F              	     1M          dc.b  "O",$d2
00:0000A4DE D2
                            	  1417:          N68     AN,$c4      ; 2
00:0000A4DF 414E            	     1M          dc.b  "AN",$c4
00:0000A4E1 C4
                            	  1418:          N68     SU,$c2      ; 3
00:0000A4E2 5355            	     1M          dc.b  "SU",$c2
00:0000A4E4 C2
                            	  1419:          N68     AD,$c4      ; 4
00:0000A4E5 4144            	     1M          dc.b  "AD",$c4
00:0000A4E7 C4
                            	  1420:          N68     EO,$d2      ; 5
00:0000A4E8 454F            	     1M          dc.b  "EO",$d2
00:0000A4EA D2
                            	  1421:          N68     CM,$d0      ; 6
00:0000A4EB 434D            	     1M          dc.b  "CM",$d0
00:0000A4ED D0
                            	  1422:          N68     MOV,$c5     ; 7
00:0000A4EE 4D4F56          	     1M          dc.b  "MOV",$c5
00:0000A4F1 C5
                            	  1423:          N68     NEG,$d8     ; 8
00:0000A4F2 4E4547          	     1M          dc.b  "NEG",$d8
00:0000A4F5 D8
                            	  1424:          N68     CL,$d2      ; 9
00:0000A4F6 434C            	     1M          dc.b  "CL",$d2
00:0000A4F8 D2
                            	  1425:          N68     NE,$c7      ; 10
00:0000A4F9 4E45            	     1M          dc.b  "NE",$c7
00:0000A4FB C7
                            	  1426:          N68     NO,$d4      ; 11
00:0000A4FC 4E4F            	     1M          dc.b  "NO",$d4
00:0000A4FE D4
                            	  1427:          N68     NBC,$c4     ; 12
00:0000A4FF 4E4243          	     1M          dc.b  "NBC",$c4
00:0000A502 C4
                            	  1428:          N68     PEA.,$cc    ; 13
00:0000A503 5045412E        	     1M          dc.b  "PEA.",$cc
00:0000A507 CC
                            	  1429:          N68     SWAP.,$d7   ; 14
00:0000A508 535741502E      	     1M          dc.b  "SWAP.",$d7
00:0000A50D D7
                            	  1430:          N68     MOVE,$cd    ; 15
00:0000A50E 4D4F5645        	     1M          dc.b  "MOVE",$cd
00:0000A512 CD
                            	  1431:          N68     EXT.,$d7    ; 16
00:0000A513 4558542E        	     1M          dc.b  "EXT.",$d7
00:0000A517 D7
                            	  1432:          N68     EXT.,$cc    ; 17
00:0000A518 4558542E        	     1M          dc.b  "EXT.",$cc
00:0000A51C CC
                            	  1433:          N68     TS,$d4      ; 18
00:0000A51D 5453            	     1M          dc.b  "TS",$d4
00:0000A51F D4
                            	  1434:          N68     TAS.,$c2    ; 19
00:0000A520 5441532E        	     1M          dc.b  "TAS.",$c2
00:0000A524 C2
                            	  1435:          N68     TRA,$d0     ; 20
00:0000A525 545241          	     1M          dc.b  "TRA",$d0
00:0000A528 D0
                            	  1436:          N68     LIN,$cb     ; 21
00:0000A529 4C494E          	     1M          dc.b  "LIN",$cb
00:0000A52C CB
                            	  1437:          N68     UNL,$cb     ; 22
00:0000A52D 554E4C          	     1M          dc.b  "UNL",$cb
00:0000A530 CB
                            	  1438:          N68     RESE,$d4    ; 23
00:0000A531 52455345        	     1M          dc.b  "RESE",$d4
00:0000A535 D4
                            	  1439:          N68     NO,$d0      ; 24
00:0000A536 4E4F            	     1M          dc.b  "NO",$d0
00:0000A538 D0
                            	  1440:          N68     STO,$d0     ; 25
00:0000A539 53544F          	     1M          dc.b  "STO",$d0
00:0000A53C D0
                            	  1441:          N68     RT,$c5      ; 26
00:0000A53D 5254            	     1M          dc.b  "RT",$c5
00:0000A53F C5
                            	  1442:          N68     RT,$d3      ; 27
00:0000A540 5254            	     1M          dc.b  "RT",$d3
00:0000A542 D3
                            	  1443:          N68     TRAP,$d6    ; 28
00:0000A543 54524150        	     1M          dc.b  "TRAP",$d6
00:0000A547 D6
                            	  1444:          N68     RT,$d2      ; 29
00:0000A548 5254            	     1M          dc.b  "RT",$d2
00:0000A54A D2
                            	  1445:          N68     JS,$d2      ; 30
00:0000A54B 4A53            	     1M          dc.b  "JS",$d2
00:0000A54D D2
                            	  1446:          N68     JM,$d0      ; 31
00:0000A54E 4A4D            	     1M          dc.b  "JM",$d0
00:0000A550 D0
                            	  1447:          N68     CHK.,$d7    ; 32
00:0000A551 43484B2E        	     1M          dc.b  "CHK.",$d7
00:0000A555 D7
                            	  1448:          N68     LEA.,$cc    ; 33
00:0000A556 4C45412E        	     1M          dc.b  "LEA.",$cc
00:0000A55A CC
                            	  1449:          N68     ADD,$d1     ; 34
00:0000A55B 414444          	     1M          dc.b  "ADD",$d1
00:0000A55E D1
                            	  1450:          N68     SUB,$d1     ; 35
00:0000A55F 535542          	     1M          dc.b  "SUB",$d1
00:0000A562 D1
00:0000A563 D3              	  1451:          DC.B    $d3         ; 36
                            	  1452:          N68     D,$c2       ; 37
00:0000A564 44              	     1M          dc.b  "D",$c2
00:0000A565 C2
00:0000A566 C2              	  1453:          DC.B    $c2         ; 38
                            	  1454:          N68     MOVEQ.,$cc  ; .....39
00:0000A567 4D4F5645512E    	     1M          dc.b  "MOVEQ.",$cc
00:0000A56D CC
                            	  1455:          N68     O,$d2       ; 40
00:0000A56E 4F              	     1M          dc.b  "O",$d2
00:0000A56F D2
                            	  1456:          N68     DIVU.,$d7   ; 41
00:0000A570 444956552E      	     1M          dc.b  "DIVU.",$d7
00:0000A575 D7
                            	  1457:          N68     DIVS.,$d7   ; 42
00:0000A576 444956532E      	     1M          dc.b  "DIVS.",$d7
00:0000A57B D7
                            	  1458:          N68     SBC,$c4     ; 43
00:0000A57C 534243          	     1M          dc.b  "SBC",$c4
00:0000A57F C4
                            	  1459:          N68     SU,$c2      ; 44
00:0000A580 5355            	     1M          dc.b  "SU",$c2
00:0000A582 C2
                            	  1460:          N68     SUB,$d8     ; 45
00:0000A583 535542          	     1M          dc.b  "SUB",$d8
00:0000A586 D8
                            	  1461:          N68     CMP,$cd     ; 46
00:0000A587 434D50          	     1M          dc.b  "CMP",$cd
00:0000A58A CD
                            	  1462:          N68     MULU.,$d7   ; 47
00:0000A58B 4D554C552E      	     1M          dc.b  "MULU.",$d7
00:0000A590 D7
                            	  1463:          N68     MULS.,$d7   ; 48
00:0000A591 4D554C532E      	     1M          dc.b  "MULS.",$d7
00:0000A596 D7
                            	  1464:          N68     ABC,$c4     ; 49
00:0000A597 414243          	     1M          dc.b  "ABC",$c4
00:0000A59A C4
                            	  1465:          N68     EX,$c7      ; 50
00:0000A59B 4558            	     1M          dc.b  "EX",$c7
00:0000A59D C7
                            	  1466:          N68     BS,$d2      ; .....51
00:0000A59E 4253            	     1M          dc.b  "BS",$d2
00:0000A5A0 D2
                            	  1467:          N68     NUL,$cc     ; .....52
00:0000A5A1 4E554C          	     1M          dc.b  "NUL",$cc
00:0000A5A4 CC
                            	  1468:          N68     ADD,$d8     ; 53
00:0000A5A5 414444          	     1M          dc.b  "ADD",$d8
00:0000A5A8 D8
                            	  1469:          N68     A,$d3       ; 54
00:0000A5A9 41              	     1M          dc.b  "A",$d3
00:0000A5AA D3
                            	  1470:          N68     L,$d3       ; 55
00:0000A5AB 4C              	     1M          dc.b  "L",$d3
00:0000A5AC D3
                            	  1471:          N68     R,$cf       ; 56
00:0000A5AD 52              	     1M          dc.b  "R",$cf
00:0000A5AE CF
                            	  1472:          N68     RO,$d8      ; 57
00:0000A5AF 524F            	     1M          dc.b  "RO",$d8
00:0000A5B1 D8
                            	  1473:          N68     MOVE.,$c2   ; 58
00:0000A5B2 4D4F56452E      	     1M          dc.b  "MOVE.",$c2
00:0000A5B7 C2
                            	  1474:          N68     MOVE.,$d7   ; 59
00:0000A5B8 4D4F56452E      	     1M          dc.b  "MOVE.",$d7
00:0000A5BD D7
                            	  1475:          N68     MOVE.,$cc   ; 60
00:0000A5BE 4D4F56452E      	     1M          dc.b  "MOVE.",$cc
00:0000A5C3 CC
                            	  1476:          N68     BTS,$d4     ; 61
00:0000A5C4 425453          	     1M          dc.b  "BTS",$d4
00:0000A5C7 D4
                            	  1477:          N68     BCH,$c7     ; 62
00:0000A5C8 424348          	     1M          dc.b  "BCH",$c7
00:0000A5CB C7
                            	  1478:          N68     BCL,$d2     ; 63
00:0000A5CC 42434C          	     1M          dc.b  "BCL",$d2
00:0000A5CF D2
                            	  1479:          N68     BSE,$d4     ; 64
00:0000A5D0 425345          	     1M          dc.b  "BSE",$d4
00:0000A5D3 D4
                            	  1480:          N68     BR,$c1      ; 65
00:0000A5D4 4252            	     1M          dc.b  "BR",$c1
00:0000A5D6 C1
                            	  1481: 
00:0000A5D7 00              	  1482:          DC.B    0         ; PAD BYTE
                            	  1483: 
                            	  1484: 

Source: "boot.x68"
                            	  4016:  	include "games/asteroids/asteroids 1_0.x68"

Source: "games\asteroids\asteroids 1_0.x68"
                            	     1: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	     2: ;														;
                            	     3: ;	ASTEROIDS type game for the EASy68k simulator	2009/05/17	V1.00			;
                            	     4: ;														;
                            	     5: ;	The objective of of the game is to score as many points as possible by		;
                            	     6: ;	destroying asteroids and flying saucers. You control a triangular ship		;
                            	     7: ;	that can rotate, fire shots forward and thrust forward. As the ship moves,	;
                            	     8: ;	momentum is not conserved, the ship eventually comes to a stop when not		;
                            	     9: ;	thrusting. In moments of extreme danger you can send the ship into		;
                            	    10: ;	hyperspace, causing it to disappear and reappear in a random location.		;
                            	    11: ;														;
                            	    12: ;	Each wave starts with the asteroids drifting in random directions onto the	;
                            	    13: ;	screen. Objects wrap around screen edges, an asteroid that drifts off the	;
                            	    14: ;	left edge of the screen reappears at the right and continues moving in the	;
                            	    15: ;	same direction. As you shoot asteroids they break into smaller asteroids	;
                            	    16: ;	that often move faster and are more difficult to hit. The smaller the		;
                            	    17: ;	asteroid the higher the points scored.							;
                            	    18: ;														;
                            	    19: ;	Every so often a flying saucer will appear on one side of the screen and	;
                            	    20: ;	move to the other before disappearing again. Large saucers fire in random	;
                            	    21: ;	directions, while small saucers aim their fire towards the player's ship.	;
                            	    22: ;														;
                            	    23: ;	Once all of the asteroids and flying saucers have been cleared a new set of	;
                            	    24: ;	large asteroids appears. The number of asteroids increases by two each round	;
                            	    25: ;	up to a maximum of eleven. The game continues until all the player lives	;
                            	    26: ;	are lost, a bonus life being awarded for each 10,000 points scored up to a	;
                            	    27: ;	maximum of 255 lives. A maximum of only 18 lives are shown on screen.		;
                            	    28: ;														;
                            	    29: ;	Like the original game the maximum possible score in this game is 99,990	;
                            	    30: ;	points after which it rolls over back to zero.						;
                            	    31: ;														;
                            	    32: ;	Also like the original game some game parameters can be set using the		;
                            	    33: ;	switches in the hardware window. These can be changed at any time during	;
                            	    34: ;	the game.												;
                            	    35: ;														;
                            	    36: ;	Switch	Function										;
                            	    37: ;	------	--------										;
                            	    38: ;	7 - 3		Unused										;
                            	    39: ;	  2		Starting ship count. On = 4, off = 3					;
                            	    40: ;	1 - 0		Language	1	0								;
                            	    41: ;					off	off	English						;
                            	    42: ;					off	on	German						;
                            	    43: ;					on	off	French						;
                            	    44: ;					on	on	Spanish						;
                            	    45: ;														;
                            	    46: ;	Game controls...											;
                            	    47: ;														;
                            	    48: ;	 [1] or [2] for a one or two player game start						;
                            	    49: ;	 [s] to toggle the sound off and on								;
                            	    50: ;														;
                            	    51: ;	 [q] to rotate the ship widdershins								;
                            	    52: ;	 [w] to rotate the ship deocil								;
                            	    53: ;	 [l] to fire the ship thruster								;
                            	    54: ;	 [p] to fire the ship weapon									;
                            	    55: ;	 [SPACE] to jump to hyperspace								;
                            	    56: ;														;
                            	    57: ;	Other keys are:											;
                            	    58: ;														;
                            	    59: ;	 The F2, F3 and F4 keys can be used to select a screen size of 640 x 480,	;
                            	    60: ;	 800 x 600 and 1024 x 768 respectively.							;
                            	    61: ;														;
                            	    62: ;	The game saves the high scores in the file asteroids.hi If this file is		;
                            	    63: ;	not present it will be created after the first high score is entered. If	;
                            	    64: ;	this file is read only new high scores will not be saved. No check is made	;
                            	    65: ;	on the validity of this file, editing the file may cause the game to crash.	;
                            	    66: ;														;
                            	    67: ;	This version for Sim68K 4.6.0 or later							;
                            	    68: ;														;
                            	    69: ;	More 68000 and other projects can be found on my website at ..			;
                            	    70: ;														;
                            	    71: ;	 http://mycorner.no-ip.org/index.html							;
                            	    72: ;														;
                            	    73: ;	mail : leeedavison@googlemail.com								;
                            	    74: ;														;
                            	    75: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	    76: 
                            	    77: ; a0 = system calls and volatile
                            	    78: ; a1 = system calls and volatile
                            	    79: ; a2 = volatile
                            	    80: ; a3 = variables base address
                            	    81: ; a4 = vector list pointer
                            	    82: ; a5 = player 1 / current player
                            	    83: ; a6 = player 2 / other player
                            	    84: ; a7 = stack pointer
                            	    85: 
                            	    86: 
                            	    87: 	ORG	$10000
                            	    88: 	code
                            	    89: 	even
                            	    90: 
                            	    91: asteroids_start:
00:0000A5D8 61001226        	    92: 	bsr	Initialise				; go setup everything
00:0000A5DC 610006DE        	    93: 	bsr reset_game				; clear the scores and set the ship start count
                            	    94: 
                            	    95: ; main loop. this is executed at most once every 16ms, as it waits for the 16ms counter
                            	    96: ; to be incremented from zero since the last loop
                            	    97: 
                            	    98: main_loop:
00:0000A5E0 705E            	    99: 	moveq	#94,d0					; copy screen buffer to main (page flip)
00:0000A5E2 4E4F            	   100: 	trap #15
                            	   101: 
00:0000A5E4 7E06            	   102: 	moveq #6,d7						; video frame buffer
00:0000A5E6 7C0C            	   103: 	moveq #DEV_CLEAR,d6
00:0000A5E8 4E40            	   104: 	trap #0
                            	   105: 
                            	   106: ;	move.w #$FF00,d1			; clear screen
                            	   107: ;	moveq #11,d0					; position cursor
                            	   108: ;	trap #15
                            	   109: 
                            	   110: ;	bsr sound_key					; handle the sound key
00:0000A5EA 61001208        	   111: 	bsr s_controls				; go check the screen controls
                            	   112: 
00:0000A5EE 20390004009C    	   113: 	move.l tickcnt,d0
                            	   114: .0001:
00:0000A5F4 B0B90004009C    	   115: 	cmp.l tickcnt,d0
00:0000A5FA 67F8            	   116: 	beq.s .0001
00:0000A5FC 7001            	   117: 	moveq #1,d0
                            	   118: ;wait_16ms
                            	   119: ;	MOVE.b	sixteen_ms(a3),d0		; get the 16ms counter
                            	   120: ;	BEQ.s		wait_16ms			; if not there yet just loop
                            	   121: 
                            	   122: ;	clr.b	sixteen_ms(a3)			; clear the 16ms counter
00:0000A5FE D16B0059        	   123: 	add.w d0,game_count(a3)		; increment the game counter
00:0000A602 D12B0025        	   124: 	add.b d0,time_count(a3)		; increment the timeout counter
                            	   125: 
00:0000A606 49FA13E0        	   126: 	lea vector(pc),a4			; reset the vector RAM pointer
                            	   127: 
00:0000A60A 6168            	   128: 	bsr game_message			; do "PLAYER x", "GAME OVER" or credit messages
                            	   129: 
00:0000A60C 61000F20        	   130: 	bsr check_hiscores		; do the high score checks
00:0000A610 610004C4        	   131: 	bsr enter_hiscores		; get the player high score entries
00:0000A614 6A30            	   132: 	bpl.s no_play					; if the high scores are being entered skip the
                            	   133: 												; active play routines
                            	   134: 
00:0000A616 61000C74        	   135: 	bsr high_scores				; display the high score table if the game is
                            	   136: 												; over
00:0000A61A 652A            	   137: 	bcs.s	no_play					; if the high score table was displayed skip
                            	   138: 												; active play
                            	   139: 
00:0000A61C 4A2B001C        	   140: 	tst.b px_time(a3)			; test the "PLAYER x" timer
00:0000A620 661C            	   141: 	bne.s px_hide					; skip the control checks if the "PLAYER x"
                            	   142: 												; timer is not timed out
                            	   143: 
00:0000A622 4A2B001A        	   144: 	tst.b num_players(a3)	; test the number of players in the game
00:0000A626 6712            	   145: 	beq.s skip_player_cont		; if no players skip the player controls
                            	   146: 
00:0000A628 4A2D0027        	   147: 	tst.b p_flag_off(a5)			; test the player flag
00:0000A62C 6B08            	   148: 	bmi.s skip_player_move		; if the player is exploding skip the player
                            	   149: 														; move controls
                            	   150: 
00:0000A62E 610003FE        	   151: 	bsr	ship_fire					; handle the fire button			##
00:0000A632 610005F8        	   152: 	bsr	hyperspace				; handle the hyperspace button		##
                            	   153: skip_player_move
00:0000A636 610007F4        	   154: 	bsr ship_move					; handle ship rotation and thrust		##
                            	   155: skip_player_cont
00:0000A63A 61000284        	   156: 	bsr do_saucer					; handle the saucer
                            	   157: px_hide
00:0000A63E 610006FA        	   158: 	bsr move_items				; move all the objects and add them to the
                            	   159: 												; vector list
00:0000A642 6100014A        	   160: 	bsr check_hits				; check for player/saucer/shot hits
                            	   161: no_play
00:0000A646 61000AB4        	   162: 	bsr static_messages		; add (c), scores and players ships to the
                            	   163: 												; vector list
                            	   164: 
00:0000A64A 61000E2A        	   165: 	bsr fx_sounds					; do the saucer and thump sounds
                            	   166: 
00:0000A64E 38FCB000        	   167: 	move.w #HALT,(a4)+		; add HALT to the vector list
                            	   168: 
00:0000A652 49FA1394        	   169: 	lea vector(pc),a4			; reset the vector RAM pointer
00:0000A656 61001246        	   170: 	bsr do_vector					; go do the vector list, draw them
                            	   171: 
00:0000A65A 102D007B        	   172: 	move.b new_rocks(a5),d0			; test the generate new rocks flag
00:0000A65E 6704            	   173: 	beq.s no_dec_new_rocks			; if counted out skip the decrement
                            	   174: 
00:0000A660 532D007B        	   175: 	subq.b #1,new_rocks(a5)			; else decrement the generate new rocks flag
                            	   176: no_dec_new_rocks
00:0000A664 802D0076        	   177: 	or.b rock_count(a5),d0			; OR the new rocks flag with the rock count
00:0000A668 6600FF76        	   178: 	bne main_loop					; if not counted out or still rocks go do the
                            	   179: 												; main loop
                            	   180: 
00:0000A66C 487AFF72        	   181: 	pea main_loop					; return to the main loop
00:0000A670 60000910        	   182: 	bra make_rocks				; go generate new rocks
                            	   183: 
                            	   184: 
                            	   185: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   186: ;
                            	   187: ; do "PLAYER x", "GAME OVER" or credit messages
                            	   188: 
                            	   189: game_message:
00:0000A674 4A2B001A        	   190: 	tst.b num_players(a3)		; test the number of players in the game
00:0000A678 670E            	   191: 	beq.s do_start_mess			; if no players go do the start message
                            	   192: 
00:0000A67A 4A2B001C        	   193: 	tst.b px_time(a3)				; test the "PLAYER x" timer
00:0000A67E 677C            	   194: 	beq.s game_over					; if timed out go do "GAME OVER" or thump
                            	   195: 													; sound count
                            	   196: 
00:0000A680 532B001C        	   197: 	subq.b #1,px_time(a3)		; decrement the "PLAYER x" timer
00:0000A684 60001104        	   198: 	bra player_x						; add "PLAYER x" to the vector list and return
                            	   199: 
                            	   200: ; do the push start message
                            	   201: 
                            	   202: do_start_mess:
00:0000A688 7005            	   203: 	moveq #5,d0					; GetKey
00:0000A68A 4E4F            	   204: 	trap #15
00:0000A68C 4A81            	   205: 	tst.l d1
00:0000A68E 6B54            	   206: 	bmi.s push_start_mess
00:0000A690 7001            	   207: 	moveq #1,d0
00:0000A692 0C010031        	   208: 	cmpi.b #'1',d1
00:0000A696 6718            	   209: 	beq.s start_game
00:0000A698 0C010032        	   210: 	cmpi.b #'2',d1
00:0000A69C 6646            	   211: 	bne.s push_start_mess
                            	   212: 
                            	   213: ;	MOVE.l	#'2121',d1			; [2][1][2][1] key
                            	   214: ;	MOVEQ		#19,d0			; check for keypress
                            	   215: ;	TRAP		#15
                            	   216: 
                            	   217: ;	MOVEQ		#1,d0				; default to one player
                            	   218: ;	TST.b		d1				; test the [1] key result
                            	   219: ;	BMI.s		start_game			; if pressed go start a one player game
                            	   220: 
                            	   221: ;	TST.w		d1				; test the [2] key result
                            	   222: 	;BPL.s		push_start_mess		; if not pressed go do the "PUSH START" message
                            	   223: 
                            	   224: 							; else the two player start was pressed
00:0000A69E 4BEB01F7        	   225: 	lea player_2(a3),a5		; set the pointer to player two's variables
00:0000A6A2 61000618        	   226: 	bsr reset_game				; clear the score and set the ship start count
00:0000A6A6 61000982        	   227: 	bsr player_init				; initialise the player variables
00:0000A6AA 610008D6        	   228: 	bsr make_rocks				; generate new rocks
00:0000A6AE 7002            	   229: 	moveq #2,d0						; set two players in this game
                            	   230: 
                            	   231: ; one or two player game start
                            	   232: 
                            	   233: start_game:
00:0000A6B0 1740001A        	   234: 	move.b d0,num_players(a3)	; save the number of players in the game
                            	   235: 
00:0000A6B4 422B0018        	   236: 	clr.b player_idx(a3)			; clear the player index
00:0000A6B8 4BEB00F3        	   237: 	lea	player_1(a3),a5				; set the pointer to player one's variables
00:0000A6BC 4DEB01F7        	   238: 	lea player_2(a3),a6				; set the pointer to player two's variables
                            	   239: 
00:0000A6C0 610005FA        	   240: 	bsr reset_game				; clear the scores and set the ship start count
00:0000A6C4 61000964        	   241: 	bsr player_init				; initialise the player variables
00:0000A6C8 610008B8        	   242: 	bsr make_rocks				; generate new rocks
                            	   243: 
00:0000A6CC 7000            	   244: 	moveq #0,d0						; clear the longword
00:0000A6CE 3B400080        	   245: 	move.w d0,score_off(a5)		; clear player 1's score
00:0000A6D2 3D400080        	   246: 	move.w d0,score_off(a6)		; clear player 2's score
                            	   247: 
00:0000A6D6 177C0080001C    	   248: 	move.b #$80,px_time(a3)		; set the "PLAYER x" timer
00:0000A6DC 177C00040024    	   249: 	move.b #$04,thump_time(a3)	; set the thump sound change timer
00:0000A6E2 4E75            	   250: 	rts
                            	   251: 
                            	   252: ; else do the "PUSH START" message
                            	   253: 
                            	   254: push_start_mess:
00:0000A6E4 102B0176        	   255: 	move.b p1_high(a3),d0			; get the player 1 highscore flag
00:0000A6E8 C02B027A        	   256: 	and.b p2_high(a3),d0			; and with the player 2 highscore flag
00:0000A6EC 6A0C            	   257: 	bpl.s exit_push_start			; if either player is entering their high score
                            	   258: 														; skip the "PUSH START" message
                            	   259: 
00:0000A6EE 7206            	   260: 	moveq #$06,d1								; message 6 - "PUSH START"
00:0000A6F0 082B0005005A    	   261: 	btst.b #5,game_count+1(a3)	; test a bit in the game counter low byte
00:0000A6F6 67001024        	   262: 	beq add_message							; if set add message d1 to the display list
                            	   263: 															; and return
                            	   264: exit_push_start
00:0000A6FA 4E75            	   265: 	rts
                            	   266: 
                            	   267: ; do "GAME OVER" or thump sound count
                            	   268: 
                            	   269: game_over:
00:0000A6FC 703F            	   270: 	moveq #$3F,d0							; set the game counter mask
00:0000A6FE C06B0059        	   271: 	and.w game_count(a3),d0		; mask the game counter
00:0000A702 660C            	   272: 	bne.s nodec_thmpi					; branch if not zero
                            	   273: 
                            	   274: 							; gets here 1/64th of the time
00:0000A704 0C2D0006007C    	   275: 	cmpi.b #6,thmp_sndi(a5)		; compare the thump sound change timer initial
                            	   276: 							; value with the minimum value
00:0000A70A 6704            	   277: 	beq.s nodec_thmpi					; if there already don't decrement it
                            	   278: 
00:0000A70C 532D007C        	   279: 	subq.b #1,thmp_sndi(a5)		; else decrement the thump sound change timer
                            	   280: 							; initial value
                            	   281: nodec_thmpi
00:0000A710 4A2D0082        	   282: 	tst.b ships_off(a5)			; test the player ship count
00:0000A714 6624            	   283: 	bne.s no_game_over			; if ships left skip game over
                            	   284: 
                            	   285: 							; else this player has no ships left
00:0000A716 102D002B        	   286: 	move.b p_fire_off(a5),d0		; get player fire 1
00:0000A71A 802D002C        	   287: 	or.b p_fire_off+1(a5),d0		; OR with player fire 2
00:0000A71E 802D002D        	   288: 	or.b p_fire_off+2(a5),d0		; OR with player fire 3
00:0000A722 802D002E        	   289: 	or.b p_fire_off+3(a5),d0		; OR with player fire 4
00:0000A726 6612            	   290: 	bne.s no_game_over			; if shots still flying skip the game over
                            	   291: 
00:0000A728 7207            	   292: 	moveq #7,d1							; else message 7 - "GAME OVER"
00:0000A72A 61000FF0        	   293: 	bsr add_message					; add message d1 to the display list
                            	   294: 
00:0000A72E 0C2B0002001A    	   295: 	cmpi.b #$02,num_players(a3)	; compare the number of players with two
00:0000A734 6604            	   296: 	bne.s no_game_over			; if not two player skip which game's over
                            	   297: 
00:0000A736 61001052        	   298: 	bsr player_x						; add "PLAYER x" to the vector list
                            	   299: no_game_over
00:0000A73A 4A2D0027        	   300: 	tst.b p_flag_off(a5)		; test the player flag
00:0000A73E 6638            	   301: 	bne.s	exit_game_message		; if alive or exploding just exit
                            	   302: 
00:0000A740 0C2D0080007A    	   303: 	cmpi.b #$80,hide_p_cnt(a5)	; compare with about to die - 1 with the hide
                            	   304: 							; the player count
00:0000A746 6630            	   305: 	bne.s exit_game_message			; if not about to die just exit
                            	   306: 
00:0000A748 1B7C0010007A    	   307: 	move.b #$10,hide_p_cnt(a5)	; set the hide the player count
                            	   308: 
00:0000A74E 122B001A        	   309: 	move.b num_players(a3),d1	; get the number of players in the game
                            	   310: 
00:0000A752 102B0175        	   311: 	move.b p1_ships(a3),d0		; get player 1's ship count
00:0000A756 802B0279        	   312: 	or.b p2_ships(a3),d0			; OR with player 2's ship count
00:0000A75A 671E            	   313: 	beq.s end_game					; if no ships left go end the game
                            	   314: 
00:0000A75C 610006BA        	   315: 	bsr clear_saucer				; clear the saucer and restart the saucer timer
00:0000A760 5301            	   316: 	subq.b #1,d1						; decrement the number of players in the game
00:0000A762 6714            	   317: 	beq.s exit_game_message	; if that was the last player go flag no game
                            	   318: 							; and exit
                            	   319: 
00:0000A764 177C0080001C    	   320: 	move.b #$80,px_time(a3)		; set the "PLAYER x" timer
                            	   321: 
00:0000A76A 4A2E0082        	   322: 	tst.b ships_off(a6)			; test the other player's ship count
00:0000A76E 6708            	   323: 	beq.s exit_game_message		; if no ships left go flag no game and exit
                            	   324: 
                            	   325: 														; else change to the other player
00:0000A770 0A2B00010018    	   326: 	eori.b #1,player_idx(a3)		; toggle the player index
00:0000A776 CB4E            	   327: 	exg a5,a6									; swap the player pointers
                            	   328: exit_game_message
00:0000A778 4E75            	   329: 	rts
                            	   330: 
                            	   331: ; neither player has any ships left so end the game
                            	   332: 
                            	   333: end_game:
00:0000A77A 17410019        	   334: 	move.b d1,past_play(a3)		; save the number of players that were in the
                            	   335: 							; game
00:0000A77E 177C00FF001A    	   336: 	move.b #$FF,num_players(a3)	; clear the number of players in the game
00:0000A784 4BEB00F3        	   337: 	lea player_1(a3),a5		; set the pointer to player one's variables
00:0000A788 4DEB01F7        	   338: 	lea player_2(a3),a6		; set the pointer to player two's variables
00:0000A78C 4E75            	   339: 	rts
                            	   340: 
                            	   341: 
                            	   342: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   343: ;
                            	   344: ; check for player/saucer/shot hits
                            	   345: 
                            	   346: check_hits:
00:0000A78E 7C07            	   347: 	moveq #flag_end-p_flag_off-1,d6
                            	   348: 							; set the count/index for player/saucer/shots
                            	   349: pss_check_loop
00:0000A790 4A356027        	   350: 	tst.b p_flag_off(a5,d6.w)	; test if the player/saucer/shot exists
00:0000A794 6E06            	   351: 	bgt.s check_pss			; if the item exists and is not exploding go
                            	   352: 							; test it
                            	   353: 
                            	   354: next_pss
00:0000A796 51CEFFF8        	   355: 	dbf d6,pss_check_loop	; decrement count/index and loop if more to do
                            	   356: 
00:0000A79A 4E75            	   357: 	rts
                            	   358: 
                            	   359: ; the player/saucer/shot exists and is not exploding
                            	   360: 
                            	   361: check_pss
00:0000A79C 7E1C            	   362: 	moveq #s_flag_off-flags_off,d7
                            	   363: 							; set the item index to the saucer
00:0000A79E 0C460004        	   364: 	cmpi.w #p_fire_off-p_flag_off,d6
                            	   365: 							; compare the player/saucer/shot index with the
                            	   366: 							; first player shot
00:0000A7A2 640A            	   367: 	bcc.s check_all			; if it is a player shot go test it against all
                            	   368: 							; the items
                            	   369: 
00:0000A7A4 5347            	   370: 	subq.w #1,d7				; else skip the saucer
00:0000A7A6 4A46            	   371: 	tst.w d6						; test the player/saucer/shot index
00:0000A7A8 6604            	   372: 	bne.s check_all			; if not the player go test against everything
                            	   373: 
                            	   374: 							; else skip the player
                            	   375: check_next_object
00:0000A7AA 5347            	   376: 	subq.w #1,d7				; decrement the item index
00:0000A7AC 6BE8            	   377: 	bmi.s next_pss			; if all done go do next player/saucer/shot
                            	   378: 
                            	   379: check_all
00:0000A7AE 1435700C        	   380: 	MOVE.b	flags_off(a5,d7.w),d2	; get the item flag indexed by d7
00:0000A7B2 6FF6            	   381: 	BLE.s		check_next_object		; if the item doesn't exist or the item is
                            	   382: 							; exploding go try the next item
                            	   383: 
00:0000A7B4 3A07            	   384: 	MOVE.w	d7,d5				; copy the item index
00:0000A7B6 DA45            	   385: 	ADD.w		d5,d5				; ; 2 for the item position index
                            	   386: 
00:0000A7B8 3806            	   387: 	MOVE.w	d6,d4				; copy the fire item index
00:0000A7BA D844            	   388: 	ADD.w		d4,d4				; ; 2 for the fire item position index
                            	   389: 
00:0000A7BC 30355080        	   390: 	MOVE.w	x_pos_off(a5,d5.w),d0	; get item x position
00:0000A7C0 907540B6        	   391: 	SUB.w		p_xpos_off(a5,d4.w),d0	; subtract the player/saucer/shot x position
00:0000A7C4 6A02            	   392: 	BPL.s		delta_x_pos			; if the delta is positive skip the negate
                            	   393: 
00:0000A7C6 4440            	   394: 	NEG.w		d0				; else negate the delta
                            	   395: delta_x_pos
00:0000A7C8 0C400151        	   396: 	CMPI.w	#$0151,d0			; compare the range with $0151
00:0000A7CC 64DC            	   397: 	BCC.s		check_next_object		; if it's out of range go try the next item
                            	   398: 
00:0000A7CE 323550C6        	   399: 	MOVE.w	y_pos_off(a5,d5.w),d1	; get item y position
00:0000A7D2 927540FC        	   400: 	SUB.w		p_ypos_off(a5,d4.w),d1	; subtract the player/saucer/shot y position
00:0000A7D6 6A02            	   401: 	BPL.s		delta_y_pos			; if the delta is positive skip the negate
                            	   402: 
00:0000A7D8 4441            	   403: 	NEG.w		d1				; else negate the delta
                            	   404: delta_y_pos
00:0000A7DA 0C410151        	   405: 	CMPI.w	#$0151,d1			; compare the range with $0151
00:0000A7DE 64CA            	   406: 	BCC.s		check_next_object		; if it's out of range go try the next item
                            	   407: 
00:0000A7E0 C0C0            	   408: 	MULU.w	d0,d0				; calculate delta x^2
00:0000A7E2 C2C1            	   409: 	MULU.w	d1,d1				; calculate delta y^2
00:0000A7E4 D081            	   410: 	ADD.l		d1,d0				; calculate delta x^2 + delta y^2
00:0000A7E6 E480            	   411: 	ASR.l		#2,d0				; / 4 makes it a word value again
                            	   412: 
00:0000A7E8 02420007        	   413: 	ANDI.w	#$07,d2			; mask the size bits
00:0000A7EC 5302            	   414: 	SUBQ.b	#1,d2				; make $01 to $04 into $00 to $03
00:0000A7EE D402            	   415: 	ADD.b		d2,d2				; ; 2 bytes per size^2
                            	   416: 
00:0000A7F0 0C460001        	   417: 	CMPI.w	#s_flag_off-p_flag_off,d6
                            	   418: 							; compare the player/saucer/shot index with the
                            	   419: 							; saucer
00:0000A7F4 6E10            	   420: 	BGT.s		no_add_size			; if shot index just go get the collision size
                            	   421: 
00:0000A7F6 6B0C            	   422: 	BMI.s		add_p_size			; if player index only add the player offset
                            	   423: 
00:0000A7F8 083500016027    	   424: 	BTST.b	#1,p_flag_off(a5,d6.w)	; else test the saucer size flag
00:0000A7FE 6702            	   425: 	BEQ.s		small_s_size		; if not size $02 only add the small saucer size
                            	   426: 
00:0000A800 5042            	   427: 	ADDQ.w	#col_table_l-col_table_s,d2
                            	   428: 							; add the offset to the item + large saucer size
                            	   429: 							; table
                            	   430: small_s_size
00:0000A802 5042            	   431: 	ADDQ.w	#col_table_s-col_table_p,d2
                            	   432: 							; add the offset to the item + small saucer size
                            	   433: 							; table
                            	   434: add_p_size
00:0000A804 5042            	   435: 	ADDQ.w	#col_table_p-col_table,d2
                            	   436: 							; add the offset to the item + player size table
                            	   437: no_add_size
00:0000A806 343B200C        	   438: 	MOVE.w	col_table(pc,d2.w),d2	; get the collision size from the table
                            	   439: 
00:0000A80A B440            	   440: 	CMP.w		d0,d2				; compare the distance^2 with the collision size
00:0000A80C 659C            	   441: 	BCS.s		check_next_object		; if it's out of range go try the next item
                            	   442: 
00:0000A80E 487AFF86        	   443: 	PEA		next_pss(pc)		; now go try the next fire item, this one died
00:0000A812 6020            	   444: 	BRA.s		handle_collision		; else go handle a collision between items
                            	   445: 
                            	   446: ; table of collision distance squares
                            	   447: 
                            	   448: col_table
00:0000A814 06E4            	   449: 	dc.w	$06E4			; $24^2		small rock, small saucer, player
00:0000A816 1440            	   450: 	dc.w	$1440			; $48^2		medium rock, large saucer
00:0000A818 0000            	   451: 	dc.w	$0000			; no size 3 rock
00:0000A81A 4410            	   452: 	dc.w	$4410			; $84^2		large rock
                            	   453: col_table_p
00:0000A81C 1000            	   454: 	dc.w	$1000			; ($24 + $1C)^2	small rock  + player
00:0000A81E 2710            	   455: 	dc.w	$2710			; ($48 + $1C)^2	medium rock + player
00:0000A820 0000            	   456: 	dc.w	$0000			; no size 3 rock
00:0000A822 6400            	   457: 	dc.w	$6400			; ($84 + $1C)^2	large rock  + player
                            	   458: col_table_s
00:0000A824 0B64            	   459: 	dc.w	$0B64			; ($24 + $12)^2	small rock  + small saucer
00:0000A826 1FA4            	   460: 	dc.w	$1FA4			; ($48 + $12)^2	medium rock + small saucer
00:0000A828 0000            	   461: 	dc.w	$0000			; no size 3 rock
00:0000A82A 57E4            	   462: 	dc.w	$57E4			; ($84 + $12)^2	large rock  + small saucer
                            	   463: col_table_l
00:0000A82C 1440            	   464: 	dc.w	$1440			; ($24 + $24)^2	small rock  + large saucer
00:0000A82E 2D90            	   465: 	dc.w	$2D90			; ($48 + $24)^2	medium rock + large saucer
00:0000A830 0000            	   466: 	dc.w	$0000			; no size 3 rock
00:0000A832 6E40            	   467: 	dc.w	$6E40			; ($84 + $24)^2	large rock  + large saucer
                            	   468: 
                            	   469: 
                            	   470: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   471: ;
                            	   472: ; handle collision between items
                            	   473: ;
                            	   474: ; d6 = X = player/saucer/shot index
                            	   475: ; d7 = Y = object index
                            	   476: 
                            	   477: handle_collision:
00:0000A834 0C460001        	   478: 	CMPI.w	#s_flag_off-p_flag_off,d6
                            	   479: 							; compare the player/saucer/shot index with the
                            	   480: 							; saucer
00:0000A838 660A            	   481: 	BNE.s		not_saucer			; if not the saucer go find out what it was
                            	   482: 
                            	   483: 							; else the saucer hit something
00:0000A83A 0C47001B        	   484: 	CMPI.w	#p_flag_off-flags_off,d7
                            	   485: 							; compare the object with the player index
00:0000A83E 6612            	   486: 	BNE.s		not_player			; if not the player go find out what it was
                            	   487: 
                            	   488: 							; else the saucer hit the player so make it that
                            	   489: 							; the player hit the saucer
00:0000A840 7E1C            	   490: 	MOVEQ		#s_flag_off-flags_off,d7
                            	   491: 							; make the object the saucer
00:0000A842 7C00            	   492: 	MOVEQ		#p_flag_off-p_flag_off,d6
                            	   493: 							; make the player/saucer/shot index the player
                            	   494: not_saucer
00:0000A844 4A46            	   495: 	TST.w		d6				; test the player/saucer/shot index
00:0000A846 6622            	   496: 	BNE.s		not_pss_player		; if it's not the player go find out what it was
                            	   497: 
                            	   498: ; the player hit something
                            	   499: 
00:0000A848 1B7C0081007A    	   500: 	MOVE.b	#$81,hide_p_cnt(a5)	; set the hide the player count
00:0000A84E 532D0082        	   501: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
                            	   502: 
                            	   503: ; either the player hit the saucer or the player or saucer hit either a rock or a shot
                            	   504: 
                            	   505: not_player
00:0000A852 1BBC00A06027    	   506: 	MOVE.b	#$A0,p_flag_off(a5,d6.w)
                            	   507: 							; set the item is exploding flag
00:0000A858 7000            	   508: 	MOVEQ		#0,d0				; clear the longword
00:0000A85A 1B80604A        	   509: 	MOVE.b	d0,p_xvel_off(a5,d6.w)	; clear the player/saucer/shot x velocity
00:0000A85E 1B80606D        	   510: 	MOVE.b	d0,p_yvel_off(a5,d6.w)	; clear the player/saucer/shot y velocity
00:0000A862 0C47001B        	   511: 	CMPI.w	#p_flag_off-flags_off,d7
                            	   512: 							; compare the object with the player index
00:0000A866 650E            	   513: 	BCS.s		what_hit_rock		; if less go handle something hitting a rock
                            	   514: 
00:0000A868 6038            	   515: 	BRA.s		what_hit_saucer		; else go handle something hitting the saucer
                            	   516: 
                            	   517: ; else a shot hit something
                            	   518: 
                            	   519: not_pss_player
00:0000A86A 42356027        	   520: 	CLR.b		p_flag_off(a5,d6.w)	; clear the shot object
00:0000A86E 0C07001B        	   521: 	CMPI.b	#p_flag_off-flags_off,d7
                            	   522: 							; compare the item with the player's index
00:0000A872 6722            	   523: 	BEQ.s		player_shot			; if it's the player go handle a shot hitting
                            	   524: 							; the player
                            	   525: 
00:0000A874 642C            	   526: 	BCC.s		what_hit_saucer		; if it's the saucer go handle a shot hitting
                            	   527: 							; the saucer
                            	   528: 
                            	   529: what_hit_rock
00:0000A876 61000C40        	   530: 	BSR		hit_a_rock			; handle something hitting a rock
                            	   531: 
                            	   532: ; explode the object
                            	   533: 
                            	   534: explode_object
00:0000A87A 7203            	   535: 	MOVEQ		#$03,d1			; set the mask for the two size bits
00:0000A87C C235700C        	   536: 	AND.b		flags_off(a5,d7.w),d1	; and it with the item flag
00:0000A880 5A01            	   537: 	ADDQ.b	#sexpl_snd,d1		; add the small explosion sound to the size
00:0000A882 61002B94        	   538: 	BSR		play_sample			; go play the sample
                            	   539: 
00:0000A886 1BBC00A0700C    	   540: 	MOVE.b	#$A0,flags_off(a5,d7.w)	; set the item to exploding
00:0000A88C 4235702F        	   541: 	CLR.b		x_vel_off(a5,d7.w)	; clear the item x velocity byte
00:0000A890 42357052        	   542: 	CLR.b		y_vel_off(a5,d7.w)	; clear the item y velocity byte
00:0000A894 4E75            	   543: 	RTS
                            	   544: 
                            	   545: ; handle a shot hitting the player
                            	   546: 
                            	   547: player_shot
00:0000A896 532D0082        	   548: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
00:0000A89A 1B7C0081007A    	   549: 	MOVE.b	#$81,hide_p_cnt(a5)	; set the hide the player count
00:0000A8A0 60D8            	   550: 	BRA.s		explode_object		; go explode the player
                            	   551: 
                            	   552: ; handle something hitting the saucer
                            	   553: 
                            	   554: what_hit_saucer
00:0000A8A2 1B6D00780077    	   555: 	MOVE.b	i_sauc_tim(a5),sauc_cntdn(a5)
                            	   556: 							; save the small saucer boundary/initial saucer
                            	   557: 							; value to the saucer countdown timer
00:0000A8A8 4A2B001A        	   558: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000A8AC 67CC            	   559: 	BEQ.s		explode_object		; if no players skip adding the score
                            	   560: 
00:0000A8AE 7299            	   561: 	MOVEQ		#$99,d1			; default to 990 points for a small saucer
00:0000A8B0 082D00000028    	   562: 	BTST.b	#0,s_flag_off(a5)		; test the saucer size bit
00:0000A8B6 6602            	   563: 	BNE.s		keep_small			; if it was a small saucer keep the score value
                            	   564: 
00:0000A8B8 7220            	   565: 	MOVEQ		#$20,d1			; else set 200 points for the large saucer
                            	   566: keep_small
00:0000A8BA 6100099C        	   567: 	BSR		add_score			; add d1 to the current player's score
00:0000A8BE 60BA            	   568: 	BRA.s		explode_object		; go explode the saucer
                            	   569: 
                            	   570: 
                            	   571: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   572: ;
                            	   573: ; handle the saucer
                            	   574: 
                            	   575: do_saucer
00:0000A8C0 70FC            	   576: 	MOVEQ		#-4,d0			; set the timeout counter mask
00:0000A8C2 C02B0025        	   577: 	AND.b		time_count(a3),d0		; mask the timeout counter
00:0000A8C6 670000B0        	   578: 	BEQ		exit_do_saucer		; 3/4 of the time just exit
                            	   579: 
00:0000A8CA B12B0025        	   580: 	EOR.b		d0,time_count(a3)		; reset the timeout counter
                            	   581: 
00:0000A8CE 4A2D0028        	   582: 	TST.b		s_flag_off(a5)		; test the saucer flag
00:0000A8D2 6B0000A4        	   583: 	BMI		exit_do_saucer		; if the saucer is exploding just exit
                            	   584: 
00:0000A8D6 660000A2        	   585: 	BNE		existing_saucer		; if a saucer exists go handle it
                            	   586: 
                            	   587: ; no saucer exists so possibly generate a new one
                            	   588: 
00:0000A8DA 4A2B001A        	   589: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000A8DE 670C            	   590: 	BEQ.s		attract_saucer		; if no players go do the attract mode saucer
                            	   591: 
00:0000A8E0 4A2D0027        	   592: 	TST.b		p_flag_off(a5)		; test the player flag
00:0000A8E4 67000092        	   593: 	BEQ		exit_do_saucer		; if this player doesn't exist just exit
                            	   594: 
00:0000A8E8 6B00008E        	   595: 	BMI		exit_do_saucer		; if this player is exploding just exit
                            	   596: 
                            	   597: attract_saucer
00:0000A8EC 4A2D0079        	   598: 	TST.b		r_hit_tim(a5)		; test the rock hit timer
00:0000A8F0 6704            	   599: 	BEQ.s		rock_hit_out		; if counted out skip the decrement
                            	   600: 
00:0000A8F2 532D0079        	   601: 	SUBQ.b	#1,r_hit_tim(a5)		; else decrement the rock hit timer
                            	   602: rock_hit_out
00:0000A8F6 532D0077        	   603: 	SUBQ.b	#1,sauc_cntdn(a5)		; decrement the saucer countdown timer
00:0000A8FA 667C            	   604: 	BNE		exit_do_saucer		; if not there yet just exit
                            	   605: 
00:0000A8FC 1B7C00120077    	   606: 	MOVE.b	#$12,sauc_cntdn(a5)	; set the first saucer fire count
                            	   607: 
00:0000A902 4A2D0079        	   608: 	TST.b		r_hit_tim(a5)		; test the rock hit timer
00:0000A906 670C            	   609: 	BEQ.s		dec_isaucer_time		; if timed out go decrement the initial saucer
                            	   610: 							; timer
                            	   611: 
00:0000A908 102D0076        	   612: 	MOVE.b	rock_count(a5),d0		; get the rock count
00:0000A90C 676A            	   613: 	BEQ.s		exit_do_saucer		; if no rocks just exit
                            	   614: 
00:0000A90E B02D007D        	   615: 	CMP.b		min_rocks(a5),d0		; compare the rock count with the minimum rock
                            	   616: 							; count before the saucer initial timer starts
                            	   617: 							; to decrement
00:0000A912 6364            	   618: 	BLS.s		exit_do_saucer		; if the minimum rock count is >= the rock count
                            	   619: 							; just exit
                            	   620: 
                            	   621: dec_isaucer_time
00:0000A914 70FA            	   622: 	MOVEQ		#-6,d0			; set to subtract 6
00:0000A916 D02D0078        	   623: 	ADD.b		i_sauc_tim(a5),d0		; subtract it from the small saucer
                            	   624: 							; boundary/initial saucer timer
00:0000A91A 0C000020        	   625: 	CMPI.b	#$20,d0			; compare it with the minimum value
00:0000A91E 6504            	   626: 	BCS.s		no_save_ist			; if less skip the save
                            	   627: 
00:0000A920 1B400078        	   628: 	MOVE.b	d0,i_sauc_tim(a5)		; save the small saucer boundary/initial saucer
                            	   629: 							; timer
                            	   630: no_save_ist
00:0000A924 61000F66        	   631: 	BSR		gen_prng			; generate the next pseudo random number
00:0000A928 302B000A        	   632: 	MOVE.w	PRNlword(a3),d0		; get a pseudo random word
00:0000A92C 0C401800        	   633: 	CMPI.w	#$1800,d0			; compare with $1800
00:0000A930 6504            	   634: 	BCS.s		saucer_yok			; if less than $1800 just use it
                            	   635: 
00:0000A932 024017FF        	   636: 	ANDI.w	#$17FF,d0			; else mask to $17xx
                            	   637: saucer_yok
00:0000A936 3B40FFFE        	   638: 	MOVE.w	d0,s_ypos_off(a5)		; save the saucer y position
                            	   639: 
00:0000A93A 7000            	   640: 	MOVEQ		#0,d0				; clear the saucer x position
00:0000A93C 7210            	   641: 	MOVEQ		#$10,d1			; set the saucer x velocity to + $10
00:0000A93E 4A6B000C        	   642: 	TST.w		PRNlword+2(a3)		; test a pseudo random word
00:0000A942 6B06            	   643: 	BMI.s		start_left			; if bit set start on the left
                            	   644: 
                            	   645: 							; else start at the right side and move left
00:0000A944 303C1FFF        	   646: 	MOVE.w	#$1FFF,d0			; set the saucer x position
00:0000A948 72F0            	   647: 	MOVEQ		#$F0,d1			; set the saucer x velocity to - $10
                            	   648: start_left
00:0000A94A 1B41004B        	   649: 	MOVE.b	d1,s_xvel_off(a5)		; save the saucer x velocity byte
00:0000A94E 3B40FFB8        	   650: 	MOVE.w	d0,s_xpos_off(a5)		; save the saucer x position
                            	   651: 
00:0000A952 7202            	   652: 	MOVEQ		#$02,d1			; default to a large saucer
00:0000A954 4A2D0078        	   653: 	TST.b		i_sauc_tim(a5)		; test the small saucer boundary/initial saucer
                            	   654: 							; timer
00:0000A958 6B1A            	   655: 	BMI.s		save_saucer			; if > $80 always make a big saucer
                            	   656: 
00:0000A95A 0C2D00300080    	   657: 	CMPI.b	#$30,score_off(a5)	; compare the player's score with 30000 points
00:0000A960 6410            	   658: 	BCC.s		small_saucer		; if >= 30000 points go make a small saucer
                            	   659: 
00:0000A962 61000F28        	   660: 	BSR		gen_prng			; generate the next pseudo random number
00:0000A966 142D0078        	   661: 	MOVE.b	i_sauc_tim(a5),d2		; get the small saucer boundary/initial saucer
                            	   662: 							; timer
00:0000A96A E20A            	   663: 	LSR.b		#1,d2				; / 2
00:0000A96C B42B000C        	   664: 	CMP.b		PRNlword+2(a3),d2		; compare it with the random byte
00:0000A970 6402            	   665: 	BCC.s		save_saucer			; if the small saucer boundary is > the random
                            	   666: 							; byte go save the large saucer
                            	   667: 
                            	   668: small_saucer
00:0000A972 7201            	   669: 	MOVEQ		#$01,d1			; else make it a small saucer
                            	   670: save_saucer
00:0000A974 1B410028        	   671: 	MOVE.b	d1,s_flag_off(a5)		; save the saucer flag
                            	   672: exit_do_saucer
00:0000A978 4E75            	   673: 	RTS
                            	   674: 
                            	   675: ; there is an existing saucer
                            	   676: 
                            	   677: existing_saucer
00:0000A97A 707E            	   678: 	MOVEQ		#$7E,d0			; set saucer change mask
00:0000A97C C06B0059        	   679: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000A980 6610            	   680: 	BNE.s		keep_saucer_dir		; if it was not x000 000x skip the saucer
                            	   681: 							; direction change
                            	   682: 
00:0000A982 61000F08        	   683: 	BSR		gen_prng			; generate the next pseudo random number
00:0000A986 7003            	   684: 	MOVEQ		#3,d0				; set the direction mask
00:0000A988 C02B000A        	   685: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000A98C 1B7B0018006E    	   686: 	MOVE.b	saucer_yvel(pc,d0.w),s_yvel_off(a5)
                            	   687: 							; save the saucer y velocity byte
                            	   688: keep_saucer_dir
00:0000A992 4A2B001A        	   689: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000A996 6706            	   690: 	BEQ.s		attract_fire		; if no players just go do the fire countdown
                            	   691: 
00:0000A998 4A2D007A        	   692: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:0000A99C 6606            	   693: 	BNE.s		exit_existing_saucer	; if the player is hidden just exit
                            	   694: 
                            	   695: attract_fire
00:0000A99E 532D0077        	   696: 	SUBQ.b	#1,sauc_cntdn(a5)		; decrement the saucer countdown timer
00:0000A9A2 6706            	   697: 	BEQ.s		fire_saucer			; if counted out go fire
                            	   698: 
                            	   699: exit_existing_saucer
00:0000A9A4 4E75            	   700: 	RTS
                            	   701: 
                            	   702: ; saucer y velocity byte
                            	   703: 
                            	   704: saucer_yvel
00:0000A9A6 F0              	   705: 	dc.b	$F0			; down
00:0000A9A7 00              	   706: 	dc.b	$00			; horizontal
00:0000A9A8 00              	   707: 	dc.b	$00			; horizontal
00:0000A9A9 10              	   708: 	dc.b	$10			; up
                            	   709: 
                            	   710: 
                            	   711: ; handle the saucer fire
                            	   712: 
                            	   713: fire_saucer
00:0000A9AA 1B7C000A0077    	   714: 	MOVE.b	#$0A,sauc_cntdn(a5)	; set the time between saucer shots, save the
                            	   715: 							; countdown timer
00:0000A9B0 7001            	   716: 	MOVEQ		#1,d0				; set the mask for a small saucer
00:0000A9B2 C02D0028        	   717: 	AND.b		s_flag_off(a5),d0		; mask the saucer flag
00:0000A9B6 660A            	   718: 	BNE.s		aim_shot			; if it's a small saucer go aim at the player
                            	   719: 
00:0000A9B8 61000ED2        	   720: 	BSR		gen_prng			; generate the next pseudo random number
00:0000A9BC 102B000A        	   721: 	MOVE.b	PRNlword(a3),d0		; get a pseudo random byte
00:0000A9C0 6056            	   722: 	BRA.s		no_aim_shot			; and go fire wildly in any direction
                            	   723: 
                            	   724: ; aim the shot at the player
                            	   725: 
                            	   726: aim_shot
00:0000A9C2 1F2D004B        	   727: 	MOVE.b	s_xvel_off(a5),-(sp)	; copy the saucer x velocity byte
00:0000A9C6 301F            	   728: 	MOVE.w	(sp)+,d0			; get the byte as a word
00:0000A9C8 4200            	   729: 	CLR.b		d0				; clear the low byte
00:0000A9CA E240            	   730: 	ASR.w		#1,d0				; / 2
                            	   731: 
00:0000A9CC 322DFFB6        	   732: 	MOVE.w	p_xpos_off(a5),d1		; get the player x position
00:0000A9D0 926DFFB8        	   733: 	SUB.w		s_xpos_off(a5),d1		; subtract the saucer x position
00:0000A9D4 E541            	   734: 	ASL.w		#2,d1				; ; 4 delta x
                            	   735: 
00:0000A9D6 9240            	   736: 	SUB.w		d0,d1				; subtract the half saucer x velocity word
                            	   737: 
00:0000A9D8 1F2D006E        	   738: 	MOVE.b	s_yvel_off(a5),-(sp)	; copy the saucer y velocity byte
00:0000A9DC 301F            	   739: 	MOVE.w	(sp)+,d0			; get the byte as a word
00:0000A9DE 4200            	   740: 	CLR.b		d0				; clear the low byte
00:0000A9E0 E240            	   741: 	ASR.w		#1,d0				; / 2
                            	   742: 
00:0000A9E2 342DFFFC        	   743: 	MOVE.w	p_ypos_off(a5),d2		; get the player y position
00:0000A9E6 946DFFFE        	   744: 	SUB.w		s_ypos_off(a5),d2		; subtract the saucer y position
00:0000A9EA E542            	   745: 	ASL.w		#2,d2				; ; 4 delta x low byte
                            	   746: 
00:0000A9EC 9440            	   747: 	SUB.w		d0,d2				; subtract the half saucer y velocity word
                            	   748: 
00:0000A9EE 61000BE4        	   749: 	BSR		get_atn			; calculate the angle given the delta x,y in
                            	   750: 							; d1.w,d2.w
00:0000A9F2 1740001F        	   751: 	MOVE.b	d0,s_orient(a3)		; save the saucer shot direction
                            	   752: 
00:0000A9F6 61000E94        	   753: 	BSR		gen_prng			; generate the next pseudo random number
00:0000A9FA 7200            	   754: 	MOVEQ		#0,d1				; set index to +/- $0F degree units perturbation
00:0000A9FC 102B000A        	   755: 	MOVE.b	PRNlword(a3),d0		; get a pseudo random byte
00:0000AA00 0C2D00350080    	   756: 	CMPI.b	#$35,score_off(a5)	; compare the player's score with 35000
00:0000AA06 6502            	   757: 	BCS.s		wide_shot			; if less than 35000 skip the index change
                            	   758: 
00:0000AA08 7201            	   759: 	MOVEQ		#1,d1				; set index to +/- $07 degree units perturbation
                            	   760: wide_shot
00:0000AA0A C03B101E        	   761: 	AND.b		shot_mask(pc,d1.w),d0	; mask with the shot AND mask
00:0000AA0E 6A04            	   762: 	BPL.s		no_shot_or			; if the result is positive skip the bit set
                            	   763: 
00:0000AA10 803B101A        	   764: 	OR.b		shot_or(pc,d1.w),d0	; else set the correct bits for a negative
                            	   765: 							; perturbation
                            	   766: no_shot_or
00:0000AA14 D02B001F        	   767: 	ADD.b		s_orient(a3),d0		; add the saucer shot direction to the
                            	   768: 							; perturbation
                            	   769: no_aim_shot
00:0000AA18 1740001F        	   770: 	MOVE.b	d0,s_orient(a3)		; save the saucer shot direction
                            	   771: 
00:0000AA1C 7801            	   772: 	MOVEQ		#1,d4				; set the index to the saucer velocity
00:0000AA1E 7A02            	   773: 	MOVEQ		#2,d5				; set the index to the saucer position
00:0000AA20 7CFF            	   774: 	MOVEQ		#-1,d6			; set the minimum shot index - 1
00:0000AA22 7E01            	   775: 	MOVEQ		#1,d7				; set the shot start index
                            	   776: 
00:0000AA24 122B0021        	   777: 	MOVE.b	last_fire(a3),d1		; get the fire last state
00:0000AA28 6022            	   778: 	BRA.s		test_fire_loop		; go fire the shot
                            	   779: 
                            	   780: 
                            	   781: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   782: ;
                            	   783: ; these two byte pairs together effect the accuracy of the small saucer's shooting
                            	   784: ; by limiting the range of the random perturbation to the saucer's aim
                            	   785: 
                            	   786: ; shot AND mask, masks the perturbation to either +/- $0F or +/- $07 degree units
                            	   787: 
                            	   788: shot_mask
00:0000AA2A 8F              	   789: 	dc.b	$8F			; AND mask to +/- $0F degree units
00:0000AA2B 87              	   790: 	dc.b	$87			; AND mask to +/- $07 degree units
                            	   791: 
                            	   792: ; shot OR byte, sets the needed bits for a negative perturbation result
                            	   793: 
                            	   794: shot_or
00:0000AA2C 70              	   795: 	dc.b	$70			; OR to set bits after - $0F mask result
00:0000AA2D 78              	   796: 	dc.b	$78			; OR to set bits after - $07 mask result
                            	   797: 
                            	   798: 
                            	   799: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   800: ;
                            	   801: ; handle the fire button
                            	   802: 
                            	   803: ship_fire:
                            	   804: ;##	TST.b		num_players(a3)		; test the number of players in the game
                            	   805: ;##	BEQ.s		exit_ship_fire		; if no players just exit
                            	   806: 
                            	   807: ;##	TST.b		hide_p_cnt(a5)		; test the hide the player count
                            	   808: ;##	BNE.s		exit_ship_fire		; if the player is hidden just exit
                            	   809: 
                            	   810: ;	MOVEQ		#'P',d1			; [P] key
                            	   811: ;	MOVEQ		#19,d0			; check for keypress
                            	   812: ;	TRAP		#15
                            	   813: 
00:0000AA2E 7005            	   814: 	moveq #5,d0					; getkey
00:0000AA30 4E4F            	   815: 	trap #15
00:0000AA32 0C010050        	   816: 	cmpi.b #'P',d1
00:0000AA36 6620            	   817: 	bne.s save_ship_fire
                            	   818: 
                            	   819: ;	TST.b		d1				; test the result
                            	   820: ;	BEQ.s		save_ship_fire		; if fire not pressed go clear the fire state
                            	   821: 							; and exit
                            	   822: 
00:0000AA38 4A2B0021        	   823: 	tst.b last_fire(a3)		; test the fire last state
00:0000AA3C 661E            	   824: 	bne.s exit_ship_fire	; if the fire button is held just exit
                            	   825: 
00:0000AA3E 7800            	   826: 	moveq #0,d4					; set the index to the player velocity
00:0000AA40 7A00            	   827: 	moveq #0,d5					; set the index to the player position
00:0000AA42 7C01            	   828: 	moveq #1,d6					; set the minimum shot index - 1
00:0000AA44 7E05            	   829: 	moveq #5,d7					; set the shot start index
                            	   830: 
00:0000AA46 176B001E001F    	   831: 	move.b p_orient(a3),s_orient(a3)
                            	   832: 							; copy the player orientation
                            	   833: 
                            	   834: ; fire the shot, player or saucer
                            	   835: 
                            	   836: test_fire_loop
00:0000AA4C 4A357029        	   837: 	tst.b s_fire_off(a5,d7.w)	; test this fire object
00:0000AA50 670C            	   838: 	beq.s fire_shot			; if this shot is free go use it
                            	   839: 
00:0000AA52 5347            	   840: 	subq.w #1,d7				; decrement the shot index
00:0000AA54 BC47            	   841: 	cmp.w d7,d6					; compare with minimum - 1 index
00:0000AA56 66F4            	   842: 	bne.s test_fire_loop		; loop if more to do
                            	   843: 
                            	   844: save_ship_fire
00:0000AA58 17410021        	   845: 	move.b d1,last_fire(a3)		; save the fire last state
                            	   846: exit_ship_fire
00:0000AA5C 4E75            	   847: 	rts
                            	   848: 
                            	   849: ; player/saucer fired and a shot, indexed by d7, is free
                            	   850: 
                            	   851: fire_shot:
00:0000AA5E 3C07            	   852: 	move.w d7,d6				; copy the item index
00:0000AA60 DC46            	   853: 	add.w d6,d6					; 2 for position index
                            	   854: 
00:0000AA62 1BBC00127029    	   855: 	MOVE.b	#$12,s_fire_off(a5,d7.w)
                            	   856: 							; set the fire item flag
                            	   857: 
00:0000AA68 102B001F        	   858: 	MOVE.b	s_orient(a3),d0		; get the player/saucer orientation
00:0000AA6C 61000C0E        	   859: 	BSR		cos_d0			; do COS(d0)
                            	   860: 
00:0000AA70 1635404A        	   861: 	MOVE.b	p_xvel_off(a5,d4.w),d3	; get the player/saucer x velocity byte
00:0000AA74 613A            	   862: 	BSR.s		calc_fire_byte		; test the fire velocity and make 3/4 sin/cos
00:0000AA76 1B83704C        	   863: 	MOVE.b	d3,f_xvel_off(a5,d7.w)	; save the shot x velocity byte
                            	   864: 
00:0000AA7A D07550B6        	   865: 	ADD.w		p_xpos_off(a5,d5.w),d0	; add the player/saucer x position
00:0000AA7E 3B8060BA        	   866: 	MOVE.w	d0,f_xpos_off(a5,d6.w)	; save the shot x position
                            	   867: 
00:0000AA82 102B001F        	   868: 	MOVE.b	s_orient(a3),d0		; get the player/saucer orientation
00:0000AA86 61000BF8        	   869: 	BSR		sin_d0			; do SIN(d0)
                            	   870: 
00:0000AA8A 1635406D        	   871: 	MOVE.b	p_yvel_off(a5,d4.w),d3	; get the player/saucer y velocity byte
00:0000AA8E 6120            	   872: 	BSR		calc_fire_byte		; test the fire velocity and make 3/4 sin/cos
00:0000AA90 1B83706F        	   873: 	MOVE.b	d3,f_yvel_off(a5,d7.w)	; save the shot y velocity byte
                            	   874: 
00:0000AA94 D07550FC        	   875: 	ADD.w		p_ypos_off(a5,d5.w),d0	; add the player/saucer y position
00:0000AA98 3B806000        	   876: 	MOVE.w	d0,f_ypos_off(a5,d6.w)	; save the shot y position
                            	   877: 
00:0000AA9C 17410021        	   878: 	MOVE.b	d1,last_fire(a3)		; save the fire last state
                            	   879: 
00:0000AAA0 7201            	   880: 	MOVEQ		#pfire_snd,d1		; default to the player fire sound
00:0000AAA2 0C470002        	   881: 	CMPI.w	#2,d7				; compare the index with the lowest player fire
00:0000AAA6 64002970        	   882: 	BCC		play_sample			; if it was the player go play the sample and
                            	   883: 							; return
                            	   884: 
                            	   885: 							; else it must be the saucer that fired so
00:0000AAAA 7200            	   886: 	MOVEQ		#sfire_snd,d1		; set the saucer fire sound
00:0000AAAC 6000296A        	   887: 	BRA		play_sample			; play the sample and return
                            	   888: 
                            	   889: 
                            	   890: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   891: ;
                            	   892: ; test the fire velocity and make 3/4 sin/cos
                            	   893: 
                            	   894: calc_fire_byte
00:0000AAB0 E240            	   895: 	ASR.w		#1,d0				; / 2
                            	   896: 
00:0000AAB2 3F00            	   897: 	MOVE.w	d0,-(sp)			; push the word value
00:0000AAB4 101F            	   898: 	MOVE.b	(sp)+,d0			; pop it as a byte value
                            	   899: 
00:0000AAB6 D600            	   900: 	ADD.b		d0,d3				; add it to the COS / 2 value
00:0000AAB8 6B0A            	   901: 	BMI.s		test_neg_fire		; if negative go test the negative limit
                            	   902: 
00:0000AABA 0C030070        	   903: 	CMPI.b	#$70,d3			; else compare it with the positive limit
00:0000AABE 650C            	   904: 	BCS.s		fire_ok			; if < the positive limit skip the adjust
                            	   905: 
00:0000AAC0 766F            	   906: 	MOVEQ		#$6F,d3			; else set the value to the positive limit
00:0000AAC2 6008            	   907: 	BRA.s		fire_ok			; go save the shot x velocity
                            	   908: 
                            	   909: test_neg_fire
00:0000AAC4 0C030091        	   910: 	CMPI.b	#$91,d3			; compare it with the negative limit
00:0000AAC8 6402            	   911: 	BCC.s		fire_ok			; if < the negative limit skip the adjust
                            	   912: 
00:0000AACA 7691            	   913: 	MOVEQ		#$91,d3			; else set the value to the negative limit
                            	   914: fire_ok
00:0000AACC 4880            	   915: 	EXT.w		d0				; make the byte value into a word
                            	   916: 
00:0000AACE 3400            	   917: 	MOVE.w	d0,d2				; get the COS / 2 back
00:0000AAD0 E242            	   918: 	ASR.w		#1,d2				; / 4
00:0000AAD2 D142            	   919: 	ADDX.w	d2,d0				; make 3 / 4 COS and round up
                            	   920: 
00:0000AAD4 4E75            	   921: 	RTS
                            	   922: 
                            	   923: 
                            	   924: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	   925: ;
                            	   926: ; get the player high score entries
                            	   927: 
                            	   928: enter_hiscores
00:0000AAD6 102D0083        	   929: 	MOVE.b	high_off(a5),d0		; get the player 1 highscore flag
00:0000AADA C02E0083        	   930: 	AND.b		high_off(a6),d0		; and with the player 2 highscore flag
00:0000AADE 6B00014A        	   931: 	BMI		exit_enter_hiscores	; if neither player is entering their high
                            	   932: 							; score just exit
                            	   933: 
00:0000AAE2 102D0083        	   934: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:0000AAE6 6B000088        	   935: 	BMI		next_p_high			; if this player isn't entering their high
                            	   936: 							; score go try the other player
                            	   937: 
                            	   938: 							; get a player high score entry
00:0000AAEA 0C2B00010019    	   939: 	CMPI.b	#1,past_play(a3)		; compare 1 with the number of players that
                            	   940: 							; were in the game
00:0000AAF0 6712            	   941: 	BEQ.s		no_playerx			; if it was only 1 player skip the "PLAYER x"
                            	   942: 							; message
                            	   943: 
00:0000AAF2 7201            	   944: 	MOVEQ		#1,d1				; message 1 - "PLAYER "
00:0000AAF4 61000C26        	   945: 	BSR		add_message			; add message d1 to the display list
                            	   946: 
00:0000AAF8 7010            	   947: 	MOVEQ		#$10,d0			; set game counter mask
00:0000AAFA C06B0059        	   948: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000AAFE 6604            	   949: 	BNE.s		no_playerx			; if bit set skip the player number write
                            	   950: 
00:0000AB00 61000C8C        	   951: 	BSR		player_n			; add the player number to the vector list
                            	   952: no_playerx
00:0000AB04 7202            	   953: 	MOVEQ		#2,d1				; message 2 - "YOUR SCORE IS ONE OF THE TE..."
00:0000AB06 61000C14        	   954: 	BSR		add_message			; add message d1 to the display list
00:0000AB0A 7203            	   955: 	MOVEQ		#3,d1				; message 3 - "PLEASE ENTER YOUR INITIALS"
00:0000AB0C 61000C0E        	   956: 	BSR		add_message			; add message d1 to the display list
00:0000AB10 7204            	   957: 	MOVEQ		#4,d1				; message 4 - "PUSH ROTATE TO SELECT LETTER"
00:0000AB12 61000C08        	   958: 	BSR		add_message			; add message d1 to the display list
00:0000AB16 7205            	   959: 	MOVEQ		#5,d1				; message 5 - "PUSH HYPERSPACE WHEN LETTER..."
00:0000AB18 61000C02        	   960: 	BSR		add_message			; add message d1 to the display list
                            	   961: 
00:0000AB1C 36BC2000        	   962: 	MOVE.w	#$2000,glob_scale(a3)	; set the global scale
                            	   963: 
00:0000AB20 7264            	   964: 	MOVEQ		#$64,d1			; set the x co-ordinate
00:0000AB22 7439            	   965: 	MOVEQ		#$39,d2			; set the y co-ordinate
00:0000AB24 61000CAC        	   966: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	   967: 							; a draw command
                            	   968: 
00:0000AB28 323C7000        	   969: 	MOVE.w	#REL7,d1			; make a $7000,$0000 command
00:0000AB2C 61000CBE        	   970: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	   971: 
00:0000AB30 7000            	   972: 	MOVEQ		#0,d0				; clear the longword
00:0000AB32 102D0083        	   973: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:0000AB36 41F3003B        	   974: 	LEA		hinames(a3,d0.w),a0	; point to the high score names
                            	   975: 
00:0000AB3A 610001AA        	   976: 	BSR		write_initial		; write a high score initial to the vector list
00:0000AB3E 610001A6        	   977: 	BSR		write_initial		; write a high score initial to the vector list
00:0000AB42 610001A2        	   978: 	BSR		write_initial		; write a high score initial to the vector list
                            	   979: 
                            	   980: ;	MOVEQ		#' ',d1			; [SPACE] key
                            	   981: ;	MOVEQ		#19,d0			; check for keypress
                            	   982: ;	TRAP		#15
00:0000AB46 7005            	   983: 	moveq #5,d0
00:0000AB48 4E4F            	   984: 	trap #15
00:0000AB4A 4A81            	   985: 	tst.l d1
00:0000AB4C 6B6E            	   986: 	bmi.s save_hbutton
00:0000AB4E 0C010020        	   987: 	cmpi.b #' ',d1
00:0000AB52 6668            	   988: 	bne.s save_hbutton
                            	   989: 
                            	   990: ;	TST.b		d1				; test the result
                            	   991: ;	BEQ.s		save_hbutton		; if hyperspace not pressed go save the state
                            	   992: 
00:0000AB54 4A2B0022        	   993: 	TST.b		last_hype(a3)		; test the hyperspace last state
00:0000AB58 6662            	   994: 	BNE.s		save_hbutton		; if hyperspace is held go save the state
                            	   995: 
                            	   996: ; the hyperspace button has just been pressed
                            	   997: 
00:0000AB5A 522B0020        	   998: 	ADDQ.b	#1,hi_char(a3)		; increment the input character index
00:0000AB5E 0C2B00030020    	   999: 	CMPI.b	#3,hi_char(a3)		; compare with end + 1
00:0000AB64 653E            	  1000: 	BCS.s		next_hi_char		; if not there yet go and increment to the next
                            	  1001: 							; character
                            	  1002: 
                            	  1003: 							; else that was the last character
00:0000AB66 17410022        	  1004: 	MOVE.b	d1,last_hype(a3)		; save the hyperspace last state
00:0000AB6A 1B7C00FF0083    	  1005: 	MOVE.b	#$FF,high_off(a5)		; clear the player highscore flag
                            	  1006: next_p_high
00:0000AB70 7000            	  1007: 	MOVEQ		#0,d0				; clear the longword
00:0000AB72 17400020        	  1008: 	MOVE.b	d0,hi_char(a3)		; clear the input character index
                            	  1009: 
00:0000AB76 43FA29B2        	  1010: 	LEA		filename(pc),a1		; point to the highscore filename
00:0000AB7A 7034            	  1011: 	MOVEQ		#52,d0			; open new file
00:0000AB7C 4E4F            	  1012: 	TRAP		#15
                            	  1013: 
00:0000AB7E 4A40            	  1014: 	TST.w		d0				; check for errors
00:0000AB80 660A            	  1015: 	BNE.s		close_all			; if error go close all files
                            	  1016: 
00:0000AB82 43EB0027        	  1017: 	LEA		hiscores(a3),a1		; point to the highscore tables
00:0000AB86 7432            	  1018: 	MOVEQ		#50,d2			; set the table length
00:0000AB88 7036            	  1019: 	MOVEQ		#54,d0			; write file
00:0000AB8A 4E4F            	  1020: 	TRAP		#15
                            	  1021: 
                            	  1022: close_all
00:0000AB8C 7032            	  1023: 	MOVEQ		#50,d0			; close all files
00:0000AB8E 4E4F            	  1024: 	TRAP		#15
                            	  1025: 
00:0000AB90 17400018        	  1026: 	MOVE.b	d0,player_idx(a3)		; clear the player index
00:0000AB94 4BEB00F3        	  1027: 	LEA		player_1(a3),a5		; get the pointer to player one's variables
00:0000AB98 4DEB01F7        	  1028: 	LEA		player_2(a3),a6		; get the pointer to player two's variables
                            	  1029: 
00:0000AB9C 177C00F00059    	  1030: 	MOVE.b	#$F0,game_count(a3)	; set the game counter high byte, high score
                            	  1031: 							; entry timeout
00:0000ABA2 4E75            	  1032: 	RTS
                            	  1033: 
                            	  1034: ; hyperspace button press accepted and not at initials end
                            	  1035: 
                            	  1036: next_hi_char
00:0000ABA4 177C00F40059    	  1037: 	MOVE.b	#$F4,game_count(a3)	; set the game counter high byte, high score
                            	  1038: 							; entry timeout
                            	  1039: 
00:0000ABAA 7000            	  1040: 	MOVEQ		#0,d0				; clear the longword
00:0000ABAC 102D0083        	  1041: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:0000ABB0 D02B0020        	  1042: 	ADD.b		hi_char(a3),d0		; add the input character index
00:0000ABB4 41F3003B        	  1043: 	LEA		hinames(a3,d0.w),a0	; point to the high score names
00:0000ABB8 10BC000B        	  1044: 	MOVE.b	#$0B,(a0)			; set the next character to "A"
                            	  1045: save_hbutton
00:0000ABBC 17410022        	  1046: 	MOVE.b	d1,last_hype(a3)		; save the hyperspace button last state
                            	  1047: 
00:0000ABC0 4A2B0059        	  1048: 	TST.b		game_count(a3)		; test the game counter high byte
00:0000ABC4 660C            	  1049: 	BNE.s		not_timed_out		; if not timed out just continue
                            	  1050: 
00:0000ABC6 70FF            	  1051: 	MOVEQ		#-1,d0			; flag high score done
00:0000ABC8 1B400083        	  1052: 	MOVE.b	d0,high_off(a5)		; clear the player 1 highscore flag
00:0000ABCC 1D400083        	  1053: 	MOVE.b	d0,high_off(a6)		; clear the player 2 highscore flag
00:0000ABD0 609E            	  1054: 	BRA.s		next_p_high			; go save the entry end exit, branch always
                            	  1055: 
                            	  1056: not_timed_out
00:0000ABD2 70F8            	  1057: 	MOVEQ		#-8,d0			; set the timeout counter mask
00:0000ABD4 C02B0025        	  1058: 	AND.b		time_count(a3),d0		; mask the timeout counter
00:0000ABD8 674E            	  1059: 	BEQ.s		exit_not_done		; just exit 7/8ths of the time
                            	  1060: 
00:0000ABDA B12B0025        	  1061: 	EOR.b		d0,time_count(a3)		; reset the timeout counter
                            	  1062: 
00:0000ABDE 7400            	  1063: 	MOVEQ		#0,d2				; assume no rotate
                            	  1064: ;	MOVE.w	#'WQ',d1			; [WQ] keys
                            	  1065: ;	MOVEQ		#19,d0			; check for keypress
                            	  1066: ;	TRAP		#15
00:0000ABE0 7005            	  1067: 	moveq #5,d0
00:0000ABE2 4E4F            	  1068: 	trap #15
00:0000ABE4 0C010051        	  1069: 	cmpi.b #'Q',d1
00:0000ABE8 6604            	  1070: 	bne.s not_rot_left
00:0000ABEA 7401            	  1071: 	moveq #1,d2
00:0000ABEC 6008            	  1072: 	bra.s was_rot_left
                            	  1073: not_rot_left:
00:0000ABEE 0C010057        	  1074: 	cmpi.b #'W',d1
00:0000ABF2 6602            	  1075: 	bne.s not_rot_right2
00:0000ABF4 5302            	  1076: 	subq.b #1,d2	
                            	  1077: 
                            	  1078: ;	TST.b		d1				; test the result
                            	  1079: ;	BPL.s		rot_not_left		; if not pressed go test rotate right
                            	  1080: ;
                            	  1081: ;	MOVEQ		#1,d2				; if pressed set the offset to + 1
                            	  1082: rot_not_left
                            	  1083: ;	TST.w		d1				; test the result
                            	  1084: ;	BPL.s		rot_not_right		; if not pressed go add the rotation
                            	  1085: 
                            	  1086: ;	SUBQ.b	#1,d2				; if pressed set the offset to - 1
                            	  1087: not_rot_right2
                            	  1088: was_rot_left:
00:0000ABF6 7000            	  1089: 	MOVEQ		#0,d0				; clear the longword
00:0000ABF8 102D0083        	  1090: 	MOVE.b	high_off(a5),d0		; get the player highscore flag
00:0000ABFC D02B0020        	  1091: 	ADD.b		hi_char(a3),d0		; add the input character index
00:0000AC00 D433003B        	  1092: 	ADD.b		hinames(a3,d0.w),d2	; add the character to the offset
00:0000AC04 6B14            	  1093: 	BMI.s		wrap_to_z			; if negative go set "Z"
                            	  1094: 
00:0000AC06 0C02000B        	  1095: 	CMPI.b	#$0B,d2			; compare with "A"
00:0000AC0A 6410            	  1096: 	BCC.s		check_alpha			; if >= "A" go test for <= "Z"
                            	  1097: 
00:0000AC0C 0C020001        	  1098: 	CMPI.b	#$01,d2			; compare with "0"
00:0000AC10 6704            	  1099: 	BEQ.s		wrap_to_a			; if "0" go set to "A"
                            	  1100: 
                            	  1101: 							; gets here if it was "2" to "9"
00:0000AC12 7400            	  1102: 	MOVEQ		#0,d2				; else set to " "
00:0000AC14 600E            	  1103: 	BRA.s		save_char			; go save the new character
                            	  1104: 
                            	  1105: wrap_to_a
00:0000AC16 740B            	  1106: 	MOVEQ		#$0B,d2			; set to "A"
00:0000AC18 600A            	  1107: 	BRA.s		save_char			; go save the new character
                            	  1108: 
                            	  1109: wrap_to_z
00:0000AC1A 7424            	  1110: 	MOVEQ		#$24,d2			; set to "Z"
                            	  1111: check_alpha
00:0000AC1C 0C020025        	  1112: 	CMPI.b	#$25,d2			; compare with "Z" + 1
00:0000AC20 6502            	  1113: 	BCS.s		save_char			; if less skip the reset
                            	  1114: 
00:0000AC22 7400            	  1115: 	MOVEQ		#0,d2				; else reset it to " "
                            	  1116: save_char
00:0000AC24 1782003B        	  1117: 	MOVE.b	d2,hinames(a3,d0.w)	; save the new character
                            	  1118: exit_not_done
00:0000AC28 7000            	  1119: 	MOVEQ		#0,d0				; flag high score not complete
                            	  1120: exit_enter_hiscores
00:0000AC2A 4E75            	  1121: 	RTS
                            	  1122: 
                            	  1123: 
                            	  1124: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1125: ;
                            	  1126: ; handle the hyperspace button
                            	  1127: 
                            	  1128: hyperspace
                            	  1129: ;##	TST.b		num_players(a3)		; test the number of players in the game
                            	  1130: ;##	BEQ		exit_hyperspace		; if no players just exit
                            	  1131: 
                            	  1132: ;##	TST.b		hide_p_cnt(a5)		; test the hide the player count
                            	  1133: ;##	BNE		exit_hyperspace		; if the player is hidden just exit
                            	  1134: 
00:0000AC2C 4A2D0027        	  1135: 	tst.b p_flag_off(a5)		; test the player flag
00:0000AC30 6F000088        	  1136: 	ble exit_hyperspace			; if no player or player exploding just exit
                            	  1137: 
                            	  1138: ;	MOVEQ		#' ',d1			; [SPACE] key, read the hyperspace button
                            	  1139: ;	MOVEQ		#19,d0			; check for keypress
                            	  1140: ;	TRAP		#15
00:0000AC34 7005            	  1141: 	moveq #5,d0
00:0000AC36 4E4F            	  1142: 	trap #15
00:0000AC38 0C010020        	  1143: 	cmpi.b #' ',d1
00:0000AC3C 667C            	  1144: 	bne.s exit_hyperspace
                            	  1145: 
                            	  1146: ;	TST.b		d1				; test the result
                            	  1147: ;	BEQ.s		exit_hyperspace		; if the key is not pressed just exit
                            	  1148: 
00:0000AC3E 7000            	  1149: 	MOVEQ		#0,d0				; clear the longword
00:0000AC40 1B400027        	  1150: 	MOVE.b	d0,p_flag_off(a5)		; clear the player flag
00:0000AC44 1B40004A        	  1151: 	MOVE.b	d0,p_xvel_off(a5)		; clear the player x velocity
00:0000AC48 1B40006D        	  1152: 	MOVE.b	d0,p_yvel_off(a5)		; clear the player y velocity
                            	  1153: 
00:0000AC4C 1B7C0030007A    	  1154: 	MOVE.b	#$30,hide_p_cnt(a5)	; set the hide the player count
                            	  1155: 
00:0000AC52 61000C38        	  1156: 	BSR		gen_prng			; generate the next pseudo random number
00:0000AC56 302B000A        	  1157: 	MOVE.w	PRNlword(a3),d0		; get a pseudo random word
00:0000AC5A 02401FFF        	  1158: 	ANDI.w	#$1FFF,d0			; mask to $1Fxx
00:0000AC5E 0C401E00        	  1159: 	CMPI.w	#$1E00,d0			; compare with $1E00
00:0000AC62 6504            	  1160: 	BCS.s		hype_xok1			; if less than $1E00 just use it
                            	  1161: 
00:0000AC64 02401CFF        	  1162: 	ANDI.w	#$1CFF,d0			; else restrict it to $1Cxx
                            	  1163: hype_xok1
00:0000AC68 0C400400        	  1164: 	CMPI.w	#$0400,d0			; compare it with $0400
00:0000AC6C 6404            	  1165: 	BCC.s		hype_xok2			; if >= $0400 go use it
                            	  1166: 
00:0000AC6E 00400300        	  1167: 	ORI.w		#$0300,d0			; else make it $03xx
                            	  1168: hype_xok2
00:0000AC72 3B40FFB6        	  1169: 	MOVE.w	d0,p_xpos_off(a5)		; save the player x position
                            	  1170: 
00:0000AC76 61000C14        	  1171: 	BSR		gen_prng			; generate the next pseudo random number
00:0000AC7A 302B000A        	  1172: 	MOVE.w	PRNlword(a3),d0		; get a pseudo random word
00:0000AC7E 02401FFF        	  1173: 	ANDI.w	#$1FFF,d0			; mask to $1Fxx
                            	  1174: 
00:0000AC82 3F00            	  1175: 	MOVE.w	d0,-(sp)			; push the word
00:0000AC84 141F            	  1176: 	MOVE.b	(sp)+,d2			; pull the byte for later success/fail check
                            	  1177: 
00:0000AC86 0C401600        	  1178: 	CMPI.w	#$1600,d0			; compare with $1600
00:0000AC8A 6504            	  1179: 	BCS.s		hype_yok1			; if less than $1600 just use it
                            	  1180: 
00:0000AC8C 024014FF        	  1181: 	ANDI.w	#$14FF,d0			; else restrict it to $14xx
                            	  1182: hype_yok1
00:0000AC90 0C400400        	  1183: 	CMPI.w	#$0400,d0			; compare it with $0400
00:0000AC94 6404            	  1184: 	BCC.s		hype_yok2			; if >= $0400 go use it
                            	  1185: 
00:0000AC96 00400300        	  1186: 	ORI.w		#$0300,d0			; else make it $03xx
                            	  1187: hype_yok2
00:0000AC9A 3B40FFFC        	  1188: 	MOVE.w	d0,p_ypos_off(a5)		; save the player y position
                            	  1189: 
00:0000AC9E 7201            	  1190: 	MOVEQ		#1,d1				; default to a successful hyperspace jump
                            	  1191: 
00:0000ACA0 0C020018        	  1192: 	CMPI.b	#$18,d2			; compare with $18xx
00:0000ACA4 6510            	  1193: 	BCS.s		save_hyperspace		; if less than $18xx go save the hyperspace flag
                            	  1194: 
00:0000ACA6 02020007        	  1195: 	ANDI.b	#$07,d2			; else mask it
00:0000ACAA D402            	  1196: 	ADD.b		d2,d2				; ; 2
00:0000ACAC 5802            	  1197: 	ADDI.b	#$04,d2			; + 4
00:0000ACAE B42D0076        	  1198: 	CMP.b		rock_count(a5),d2		; compare this with the rock count
00:0000ACB2 6502            	  1199: 	BCS.s		save_hyperspace		; if < the rock count allow the jump
                            	  1200: 
00:0000ACB4 7280            	  1201: 	MOVEQ		#$80,d1			; else flag an unsuccessful hyperspace jump
                            	  1202: save_hyperspace
00:0000ACB6 17410026        	  1203: 	MOVE.b	d1,hyper(a3)		; save the hyperspace flag
                            	  1204: exit_hyperspace
00:0000ACBA 4E75            	  1205: 	RTS
                            	  1206: 
                            	  1207: 
                            	  1208: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1209: ;
                            	  1210: ; clear the items and set the ship start count
                            	  1211: 
                            	  1212: reset_game:
00:0000ACBC 7003            	  1213: 	MOVEQ		#3,d0				; default to a 3 ship game
00:0000ACBE 206B000E        	  1214: 	MOVEA.l	switch_addr(a3),a0	; point to the switch
00:0000ACC2 08100002        	  1215: 	BTST		#2,(a0)			; test the ship start switch
00:0000ACC6 6702            	  1216: 	BEQ.s		three_ship_start		; if 0 go start with three ships
                            	  1217: 
00:0000ACC8 7004            	  1218: 	MOVEQ		#4,d0				; else make it a 4 ship game
                            	  1219: three_ship_start
00:0000ACCA 1740001B        	  1220: 	MOVE.b	d0,ss_count(a3)		; save the starting ship count
                            	  1221: 
00:0000ACCE 1B7C00020075    	  1222: 	MOVE.b	#2,i_rk_count(a5)		; set the previous initial rock count
                            	  1223: 
00:0000ACD4 7000            	  1224: 	MOVEQ		#0,d0				; clear the longword
00:0000ACD6 7E22            	  1225: 	MOVEQ		#flag_end-flags_off-1,d7
                            	  1226: 							; set the count for the number of items
                            	  1227: clear_items_loop
00:0000ACD8 1B80700C        	  1228: 	MOVE.b	d0,flags_off(a5,d7.w)	; clear an item
00:0000ACDC 51CFFFFA        	  1229: 	DBF		d7,clear_items_loop	; loop if more to do
                            	  1230: 
00:0000ACE0 1B400076        	  1231: 	MOVE.b	d0,rock_count(a5)		; clear the rock count
                            	  1232: 
00:0000ACE4 4E75            	  1233: 	RTS
                            	  1234: 
                            	  1235: 
                            	  1236: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1237: ;
                            	  1238: ; write a high score initial to the vector list
                            	  1239: 
                            	  1240: write_initial:
00:0000ACE6 7200            	  1241: 	MOVEQ		#0,d1				; clear the longword
00:0000ACE8 1218            	  1242: 	MOVE.b	(a0)+,d1			; get a high score initial
00:0000ACEA 6614            	  1243: 	BNE.s		add_character		; if not [SPACE] just go add it
                            	  1244: 
00:0000ACEC 102B0176        	  1245: 	MOVE.b	p1_high(a3),d0		; get the player 1 highscore flag
00:0000ACF0 C02B027A        	  1246: 	AND.b		p2_high(a3),d0		; and with the player 2 highscore flag
00:0000ACF4 6B0A            	  1247: 	BMI.s		add_character		; if neither is entering their initials just
                            	  1248: 							; go add the character
                            	  1249: 
                            	  1250: 							; else add a "_" instead of a [SPACE]
00:0000ACF6 38FCF872        	  1251: 	MOVE.w	#$F872,(a4)+		; add the underline vector word to the vector
                            	  1252: 							; list
00:0000ACFA 38FCF801        	  1253: 	MOVE.w	#$F801,(a4)+		; add the step to next character vector word
                            	  1254: 							; to the vector list
00:0000ACFE 4E75            	  1255: 	RTS
                            	  1256: 
                            	  1257: 
                            	  1258: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1259: ;
                            	  1260: ; add character (d1) to the vector list
                            	  1261: 
                            	  1262: add_character:
00:0000AD00 2F08            	  1263: 	MOVE.l	a0,-(sp)			; save a0
00:0000AD02 D241            	  1264: 	ADD.w		d1,d1				; ; 2 bytes per character (d1) JSRL
00:0000AD04 41FA22FE        	  1265: 	LEA		char_set(pc),a0		; point to the character JSRL table
00:0000AD08 38F01000        	  1266: 	MOVE.w	(a0,d1.w),(a4)+		; add the JSRL word to the vector list
00:0000AD0C 205F            	  1267: 	MOVE.l	(sp)+,a0			; restore a0
00:0000AD0E 4E75            	  1268: 	RTS
                            	  1269: 
                            	  1270: 
                            	  1271: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1272: ;
                            	  1273: ; add d7 ships to the vector list. this is limited to a maximum of eighteen ships for
                            	  1274: ; speed and clarity
                            	  1275: 
                            	  1276: add_ships:
00:0000AD10 6726            	  1277: 	BEQ.s		exit_add_ships		; if no ships left just exit
                            	  1278: 
00:0000AD12 7012            	  1279: 	MOVEQ		#18,d0			; set the maximum ship count
00:0000AD14 B047            	  1280: 	CMP.w		d7,d0				; compare the ship count with the max count
00:0000AD16 6402            	  1281: 	BCC.s		show_ships			; if <= to max go show the ships
                            	  1282: 
00:0000AD18 3E00            	  1283: 	MOVE.w	d0,d7				; else set the ship count to the maximum
                            	  1284: show_ships
00:0000AD1A 9247            	  1285: 	SUB.w		d7,d1				; subtract the ship count twice to move the ..
00:0000AD1C 9247            	  1286: 	SUB.w		d7,d1				; .. ships further right the more there are
                            	  1287: 
00:0000AD1E 36BCE000        	  1288: 	MOVE.w	#$E000,glob_scale(a3)	; set the global scale
00:0000AD22 343C00D1        	  1289: 	MOVE.w	#$D1,d2			; set the ships y co-ordinate
00:0000AD26 61000AAA        	  1290: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1291: 							; a draw command
00:0000AD2A 5347            	  1292: 	SUBQ.w	#1,d7				; adjust for loop type
                            	  1293: add_ships_loop
00:0000AD2C 43FA20DC        	  1294: 	LEA		play_liv(pc),a1		; set the pointer to ships left
00:0000AD30 61000A8A        	  1295: 	BSR		add_address			; convert the a1 address and add it to the
                            	  1296: 							; vector list as a vector subroutine call
00:0000AD34 51CFFFF6        	  1297: 	DBF		d7,add_ships_loop		; decrement the ship count and loop if more
                            	  1298: 							; to do
                            	  1299: exit_add_ships
00:0000AD38 4E75            	  1300: 	RTS
                            	  1301: 
                            	  1302: 
                            	  1303: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1304: ;
                            	  1305: ; move all the items and add them to the vector list
                            	  1306: 
                            	  1307: ; d6 = object index
                            	  1308: ; d7 = position index
                            	  1309: 
                            	  1310: move_items:
00:0000AD3A 7E44            	  1311: 	MOVEQ		#x_pos_end-x_pos_off-2,d7
                            	  1312: 							; set the index to the last object position
00:0000AD3C 7C22            	  1313: 	MOVEQ		#flag_end-flags_off-1,d6
                            	  1314: 							; set the count to the last object
                            	  1315: move_next_item
00:0000AD3E 1035600C        	  1316: 	MOVE.b	flags_off(a5,d6.w),d0	; get an object flag
00:0000AD42 670000CC        	  1317: 	BEQ		move_next_object		; if no item go do the next one
                            	  1318: 
                            	  1319: ; have an active item
                            	  1320: 
00:0000AD46 6A5C            	  1321: 	BPL.s		move_item			; if the item is not exploding go move the item
                            	  1322: 
                            	  1323: 							; else the item is exploding
00:0000AD48 4400            	  1324: 	NEG.b		d0				; do twos complement [$A0 becones $60]
00:0000AD4A E808            	  1325: 	LSR.b		#4,d0				; shift the high nibble to the low nibble
                            	  1326: 							; [$60 becomes $06]
00:0000AD4C 5200            	  1327: 	ADDQ.b	#1,d0				; + 1
00:0000AD4E 0C06001B        	  1328: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  1329: 							; compare the index with the player index
00:0000AD52 6606            	  1330: 	BNE.s		skip_play_inc		; if not the player skip setting the player
                            	  1331: 							; increment
                            	  1332: 
                            	  1333: ; set the player explosion increment to 1/2 by only setting it to 1 on alternate loops
                            	  1334: 
00:0000AD54 7001            	  1335: 	MOVEQ		#1,d0				; set game counter mask
00:0000AD56 C06B0059        	  1336: 	AND.w		game_count(a3),d0		; mask the game counter
                            	  1337: skip_play_inc
00:0000AD5A D035600C        	  1338: 	ADD.b		flags_off(a5,d6.w),d0	; add the item flag
00:0000AD5E 6B2A            	  1339: 	BMI.s		item_exploding		; go handle the item still exploding
                            	  1340: 
00:0000AD60 0C46001B        	  1341: 	CMPI.w	#p_flag_off-flags_off,d6
                            	  1342: 							; compare the index with the player index
00:0000AD64 6716            	  1343: 	BEQ.s		go_reset_play		; if the player go reset the player and do next
                            	  1344: 
00:0000AD66 641A            	  1345: 	BCC.s		go_reset_sauc		; if the saucer go reset the saucer and do next
                            	  1346: 
                            	  1347: 							; else it was a rock so clear it
00:0000AD68 532D0076        	  1348: 	SUBQ.b	#1,rock_count(a5)		; decrement the rock count
00:0000AD6C 6606            	  1349: 	BNE.s		no_new_rocks		; skip flag set if rocks still left
                            	  1350: 
00:0000AD6E 1B7C007F007B    	  1351: 	MOVE.b	#$7F,new_rocks(a5)	; else set the generate new rocks flag
                            	  1352: no_new_rocks
00:0000AD74 4235600C        	  1353: 	CLR.b		flags_off(a5,d6.w)	; clear the item flag
00:0000AD78 60000096        	  1354: 	BRA		move_next_object		; go check next item
                            	  1355: 
                            	  1356: go_reset_play
00:0000AD7C 610002E2        	  1357: 	BSR		player_reset		; reset the player velocity and position
00:0000AD80 60F2            	  1358: 	BRA		no_new_rocks		; go clear the player and do the next item
                            	  1359: 
                            	  1360: ; reset the saucer timer
                            	  1361: 
                            	  1362: go_reset_sauc
00:0000AD82 1B6D00780077    	  1363: 	MOVE.b	i_sauc_tim(a5),sauc_cntdn(a5)
                            	  1364: 							; get the small saucer boundary/initial saucer
                            	  1365: 							; timer and reset the saucer countdown timer
00:0000AD88 60EA            	  1366: 	BRA.s		no_new_rocks		; go clear the saucer and do the next item
                            	  1367: 
                            	  1368: ; the item is still exploding
                            	  1369: 
                            	  1370: item_exploding
00:0000AD8A 1B80600C        	  1371: 	MOVE.b	d0,flags_off(a5,d6.w)	; save the incremented item flag
00:0000AD8E 1F00            	  1372: 	MOVE.b	d0,-(sp)			; save the byte
00:0000AD90 321F            	  1373: 	MOVE.w	(sp)+,d1			; pull the word
00:0000AD92 C27CF000        	  1374: 	AND.w		#$F000,d1			; mask the top nibble as the scale
00:0000AD96 D27C1000        	  1375: 	ADD.w		#$1000,d1			; + $10
00:0000AD9A 0C06001B        	  1376: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  1377: 							; compare the index with the player index
00:0000AD9E 6602            	  1378: 	BNE.s		no_reset_scale		; if not the player ship skip the scale reset
                            	  1379: 
00:0000ADA0 7200            	  1380: 	MOVEQ		#$0000,d1			; else it was the player so reset the scale
                            	  1381: no_reset_scale
00:0000ADA2 6066            	  1382: 	BRA.s		keep_scale			; go add the object to the vector list and do
                            	  1383: 							; the next item
                            	  1384: 
                            	  1385: ; the item is not exploding so move the item
                            	  1386: 
                            	  1387: move_item:
00:0000ADA4 1035602F        	  1388: 	MOVE.b	x_vel_off(a5,d6.w),d0	; get the x velocity byte
00:0000ADA8 4880            	  1389: 	EXT.w		d0				; extend it to a word value
00:0000ADAA D0757080        	  1390: 	ADD.w		x_pos_off(a5,d7.w),d0	; add the x position
00:0000ADAE 6B06            	  1391: 	BMI.s		x_pos_neg			; if negative go mask to $2000
                            	  1392: 
00:0000ADB0 B07C2000        	  1393: 	CMP.w		#$2000,d0			; compare the object x position with $2000
00:0000ADB4 6510            	  1394: 	BCS.s		not_x_max			; if less go do y position
                            	  1395: 
                            	  1396: x_pos_neg
00:0000ADB6 02401FFF        	  1397: 	ANDI.w	#$1FFF,d0			; else wrap round the x position
                            	  1398: 
00:0000ADBA 0C06001C        	  1399: 	CMPI.b	#s_flag_off-flags_off,d6
                            	  1400: 							; compare the index with the saucer index
00:0000ADBE 6606            	  1401: 	BNE.s		not_x_max			; if not saucer continue
                            	  1402: 
                            	  1403: 							; else the saucer has passed the screen end
00:0000ADC0 487A004E        	  1404: 	PEA		move_next_object(pc)	; on RTS go check the next item
00:0000ADC4 6052            	  1405: 	BRA.s		clear_saucer		; clear the saucer and restart the saucer timer
                            	  1406: 
                            	  1407: not_x_max
00:0000ADC6 3B807080        	  1408: 	MOVE.w	d0,x_pos_off(a5,d7.w)	; save the new x position
                            	  1409: 
00:0000ADCA 10356052        	  1410: 	MOVE.b	y_vel_off(a5,d6.w),d0	; get the y velocity byte
00:0000ADCE 4880            	  1411: 	EXT.w		d0				; extend it to a word value
00:0000ADD0 D07570C6        	  1412: 	ADD.w		y_pos_off(a5,d7.w),d0	; add the y position
00:0000ADD4 6A06            	  1413: 	BPL.s		y_not_neg			; skip add if not < 0
                            	  1414: 
00:0000ADD6 D07C1800        	  1415: 	ADD.w		#$1800,d0			; else wrap round the y position
00:0000ADDA 600A            	  1416: 	BRA.s		not_y_max			; and skip the max check
                            	  1417: 
                            	  1418: y_not_neg
00:0000ADDC B07C1800        	  1419: 	CMP.w		#$1800,d0			; compare the object y position with $1800
00:0000ADE0 6504            	  1420: 	BCS.s		not_y_max			; if less just continue
                            	  1421: 
00:0000ADE2 907C1800        	  1422: 	SUB.w		#$1800,d0			; else wrap round the y position
                            	  1423: not_y_max
00:0000ADE6 3B8070C6        	  1424: 	MOVE.w	d0,y_pos_off(a5,d7.w)	; save the new y position
                            	  1425: 
00:0000ADEA 323CE000        	  1426: 	MOVE.w	#$E000,d1			; set the scale to $E000
00:0000ADEE 0C46001D        	  1427: 	CMPI.w	#s_fire_off-flags_off,d6
                            	  1428: 							; compare the index with the fire objects
00:0000ADF2 6416            	  1429: 	BCC.s		keep_scale			; if fire object keep this scale and go add the
                            	  1430: 							; item and do next
                            	  1431: 
00:0000ADF4 1035600C        	  1432: 	MOVE.b	flags_off(a5,d6.w),d0	; get the object flag
00:0000ADF8 08000000        	  1433: 	BTST.l	#0,d0				; test bit 0
00:0000ADFC 660C            	  1434: 	BNE.s		keep_scale			; if %xx1 keep this scale and go add the item
                            	  1435: 							; and do next
                            	  1436: 
00:0000ADFE 323CF000        	  1437: 	MOVE.w	#$F000,d1			; set the scale to $F000
00:0000AE02 08000001        	  1438: 	BTST.l	#1,d0				; test bit 0
00:0000AE06 6602            	  1439: 	BNE.s		keep_scale			; if %x10 keep this scale and go add the item
                            	  1440: 							; and do next
                            	  1441: 
00:0000AE08 7200            	  1442: 	MOVEQ		#0,d1				; set the scale to $0000
                            	  1443: 
                            	  1444: ; add the item to the vector list and go do the next item
                            	  1445: 
                            	  1446: keep_scale
00:0000AE0A 3681            	  1447: 	MOVE.w	d1,glob_scale(a3)		; save the global scale
00:0000AE0C 610003DE        	  1448: 	BSR		add_to_list			; add an object to the vector list
                            	  1449: move_next_object
00:0000AE10 5547            	  1450: 	SUBQ.w	#2,d7				; decrement the position index
00:0000AE12 51CEFF2A        	  1451: 	DBF		d6,move_next_item		; decrement the count and loop if more to do
                            	  1452: 
00:0000AE16 4E75            	  1453: 	RTS
                            	  1454: 
                            	  1455: 
                            	  1456: 
                            	  1457: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1458: ;
                            	  1459: ; clear the saucer and restart the saucer timer
                            	  1460: 
                            	  1461: clear_saucer:
00:0000AE18 1B6D00780077    	  1462: 	move.b i_sauc_tim(a5),sauc_cntdn(a5)	
                            	  1463: 							; copy the small saucer boundary/initial saucer
                            	  1464: 							; timer to the saucer countdown timer
00:0000AE1E 422D0028        	  1465: 	clr.b s_flag_off(a5)		; clear the saucer flag
00:0000AE22 422D004B        	  1466: 	clr.b s_xvel_off(a5)		; clear the saucer x velocity byte
00:0000AE26 422D006E        	  1467: 	clr.b s_yvel_off(a5)		; clear the saucer y velocity byte
00:0000AE2A 4E75            	  1468: 	rts
                            	  1469: 
                            	  1470: 
                            	  1471: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1472: ;
                            	  1473: ; handle ship rotation and thrust
                            	  1474: 
                            	  1475: ship_move:
                            	  1476: ;##	TST.b		num_players(a3)		; test the number of players in the game
                            	  1477: ;##	BEQ.s		exit_ship_move		; if no players just exit
                            	  1478: 
00:0000AE2C 4A2D0027        	  1479: 	TST.b		p_flag_off(a5)		; test the player flag
00:0000AE30 6B4A            	  1480: 	BMI.s		exit_ship_move		; if the player is exploding just exit
                            	  1481: 
00:0000AE32 4A2D007A        	  1482: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:0000AE36 6746            	  1483: 	BEQ.s		rot_and_thrust		; if the player is visible go handle the ship
                            	  1484: 							; rotate and thrust
                            	  1485: 
00:0000AE38 532D007A        	  1486: 	SUBQ.b	#1,hide_p_cnt(a5)		; else decrement the hide the player count
00:0000AE3C 663E            	  1487: 	BNE.s		exit_ship_move		; if not timed out just exit
                            	  1488: 
00:0000AE3E 4A2B0026        	  1489: 	TST.b		hyper(a3)			; test the hyperspace flag
00:0000AE42 6B1E            	  1490: 	BMI.s		kill_the_player		; if negative go handle an unsuccessful
                            	  1491: 							; hyperspace jump
                            	  1492: 
00:0000AE44 6614            	  1493: 	BNE.s		reveal_player		; else if non zero go handle a successful
                            	  1494: 							; hyperspace jump
                            	  1495: 
                            	  1496: 							; else the player has just become visible
00:0000AE46 610000F8        	  1497: 	BSR		check_clear			; check items within $0400 range of the player
00:0000AE4A 662C            	  1498: 	BNE.s		clear_hyper			; if there are items within range go clear the
                            	  1499: 							; hyperspace flag and exit
                            	  1500: 
00:0000AE4C 4A2D0028        	  1501: 	TST.b		s_flag_off(a5)		; test the saucer flag
00:0000AE50 6708            	  1502: 	BEQ.s		reveal_player		; if there's no saucer go reveal the player
                            	  1503: 
00:0000AE52 1B7C0002007A    	  1504: 	MOVE.b	#$02,hide_p_cnt(a5)	; else set the hide the player count
00:0000AE58 4E75            	  1505: 	RTS
                            	  1506: 
                            	  1507: ; handle a successful hyperspace jump
                            	  1508: 
                            	  1509: reveal_player
00:0000AE5A 1B7C00010027    	  1510: 	MOVE.b	#$01,p_flag_off(a5)	; set the player flag
00:0000AE60 6016            	  1511: 	BRA.s		clear_hyper			; go clear the hyperspace flag and return
                            	  1512: 
                            	  1513: ; handle an unsuccessful hyperspace jump
                            	  1514: 
                            	  1515: kill_the_player:
00:0000AE62 1B7C00A00027    	  1516: 	MOVE.b	#$A0,p_flag_off(a5)	; flag that the player's ship is exploding
00:0000AE68 532D0082        	  1517: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
00:0000AE6C 1B7C0081007A    	  1518: 	MOVE.b	#$81,hide_p_cnt(a5)	; set the hide the player count
                            	  1519: 
00:0000AE72 7206            	  1520: 	MOVEQ		#mexpl_snd,d1		; set the medium explosion sound
00:0000AE74 610025A2        	  1521: 	BSR		play_sample			; go play the sample
                            	  1522: clear_hyper
00:0000AE78 422B0026        	  1523: 	CLR.b		hyper(a3)			; clear the hyperspace flag
                            	  1524: exit_ship_move
00:0000AE7C 4E75            	  1525: 	RTS
                            	  1526: 
                            	  1527: ; handle the ship rotate and thrust
                            	  1528: 
                            	  1529: rot_and_thrust
                            	  1530: ;	MOVEQ		#0,d2				; assume no rotate
                            	  1531: ;	MOVE.l	#'L WQ',d1			; [L WQ] keys
                            	  1532: ;	MOVEQ		#19,d0			; check for keypress
                            	  1533: ;	TRAP		#15
00:0000AE7E 7005            	  1534: 	moveq #5,d0
00:0000AE80 4E4F            	  1535: 	trap #15
00:0000AE82 0C010051        	  1536: 	cmpi.b #'Q',d1
00:0000AE86 6602            	  1537: 	bne.s not_rot_left1
00:0000AE88 7403            	  1538: 	moveq #3,d2
                            	  1539: not_rot_left1:
00:0000AE8A 0C010057        	  1540: 	cmpi.b #'W',d1
00:0000AE8E 6602            	  1541: 	bne.s not_rot_right1
00:0000AE90 5702            	  1542: 	subq.b #3,d2
                            	  1543: not_rot_right1:
                            	  1544: 
                            	  1545: ;	TST.b		d1				; test the [Q] result
                            	  1546: ;	BPL.s		not_rot_left		; if not pressed go test rotate right
                            	  1547: 
                            	  1548: ;	MOVEQ		#3,d2				; if pressed set the rotation angle to + 3
                            	  1549: ;not_rot_left
                            	  1550: ;	TST.w		d1				; test the [W] result
                            	  1551: ;	BPL.s		not_rot_right		; if not pressed go add the rotation
                            	  1552: 
                            	  1553: ;	SUBQ.b	#3,d2				; if pressed set the rotation angle to - 3
                            	  1554: ;not_rot_right
00:0000AE92 D52B001E        	  1555: 	add.b d2,p_orient(a3)		; add the roataion to the player orientation
                            	  1556: 
00:0000AE96 7001            	  1557: 	moveq #1,d0				; set game counter mask
00:0000AE98 C06B0059        	  1558: 	and.w game_count(a3),d0		; mask the game counter
00:0000AE9C 66DE            	  1559: 	bne.s exit_ship_move		; just exit half the time
                            	  1560: 
00:0000AE9E 0C01004C        	  1561: 	cmpi.b #'L',d1
00:0000AEA2 664C            	  1562: 	bne.s not_thrust
                            	  1563: ;	TST.l		d1				; test the [L] result
                            	  1564: ;	BPL.s		not_thrust			; if not pressed then go slow the ship
                            	  1565: 
                            	  1566: ; thrust button is pressed so increase the ship velocity
                            	  1567: 
00:0000AEA4 7202            	  1568: 	MOVEQ		#thrst_snd,d1		; set the thrust sound
00:0000AEA6 61002570        	  1569: 	BSR		play_sample			; play the sample and return
                            	  1570: 
00:0000AEAA 102B001E        	  1571: 	MOVE.b	p_orient(a3),d0		; get the player orientation
00:0000AEAE 610007CC        	  1572: 	BSR		cos_d0			; do COS(d0)
00:0000AEB2 EE40            	  1573: 	ASR.w		#7,d0				; scale to 1/128th
                            	  1574: 
00:0000AEB4 1F2D004A        	  1575: 	MOVE.b	p_xvel_off(a5),-(sp)	; get the x velocity high byte
00:0000AEB8 321F            	  1576: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000AEBA 122D007E        	  1577: 	MOVE.b	p_xvlo_off(a5),d1		; get the x velocity low byte
00:0000AEBE D240            	  1578: 	ADD.w		d0,d1				; add the thrust x component
00:0000AEC0 6164            	  1579: 	BSR.s		check_velocity		; limit check the velocity in d1
00:0000AEC2 1B41007E        	  1580: 	MOVE.b	d1,p_xvlo_off(a5)		; save the x velocity low byte
00:0000AEC6 3F01            	  1581: 	MOVE.w	d1,-(sp)			; save the word
00:0000AEC8 1B5F004A        	  1582: 	MOVE.b	(sp)+,p_xvel_off(a5)	; save the x velocity high byte
                            	  1583: 
00:0000AECC 102B001E        	  1584: 	MOVE.b	p_orient(a3),d0		; get the player orientation
00:0000AED0 610007AE        	  1585: 	BSR		sin_d0			; do SIN(d0)
00:0000AED4 EE40            	  1586: 	ASR.w		#7,d0				; scale to 1/128th
                            	  1587: 
00:0000AED6 1F2D006D        	  1588: 	MOVE.b	p_yvel_off(a5),-(sp)	; get the y velocity high byte
00:0000AEDA 321F            	  1589: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000AEDC 122D007F        	  1590: 	MOVE.b	p_yvlo_off(a5),d1		; get the y velocity low byte
00:0000AEE0 D240            	  1591: 	ADD.w		d0,d1				; add the thrust y component
00:0000AEE2 6142            	  1592: 	BSR.s		check_velocity		; limit check the velocity in d1
00:0000AEE4 1B41007F        	  1593: 	MOVE.b	d1,p_yvlo_off(a5)		; save the y velocity low byte
00:0000AEE8 3F01            	  1594: 	MOVE.w	d1,-(sp)			; save the word
00:0000AEEA 1B5F006D        	  1595: 	MOVE.b	(sp)+,p_yvel_off(a5)	; save the y velocity high byte
                            	  1596: 
00:0000AEEE 4E75            	  1597: 	RTS
                            	  1598: 
                            	  1599: ; thrust button is not pressed so slow the ship by adding - 128 ; velocity
                            	  1600: 
                            	  1601: not_thrust
00:0000AEF0 1F2D004A        	  1602: 	MOVE.b	p_xvel_off(a5),-(sp)	; get the x velocity high byte
00:0000AEF4 321F            	  1603: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000AEF6 122D007E        	  1604: 	MOVE.b	p_xvlo_off(a5),d1		; get the x velocity low byte
00:0000AEFA 3001            	  1605: 	MOVE.w	d1,d0				; copy the x velocity
00:0000AEFC EE40            	  1606: 	ASR.w		#7,d0				; scale to 1/128th
00:0000AEFE 9240            	  1607: 	SUB.w		d0,d1				; subtract the x drag component
00:0000AF00 1B41007E        	  1608: 	MOVE.b	d1,p_xvlo_off(a5)		; save the x velocity low byte
00:0000AF04 3F01            	  1609: 	MOVE.w	d1,-(sp)			; save the word
00:0000AF06 1B5F004A        	  1610: 	MOVE.b	(sp)+,p_xvel_off(a5)	; save the x velocity high byte
                            	  1611: 
                            	  1612: ; done the x velocity now do the y
                            	  1613: 
00:0000AF0A 1F2D006D        	  1614: 	MOVE.b	p_yvel_off(a5),-(sp)	; get the y velocity high byte
00:0000AF0E 321F            	  1615: 	MOVE.w	(sp)+,d1			; copy it to d1 high byte
00:0000AF10 122D007F        	  1616: 	MOVE.b	p_yvlo_off(a5),d1		; get the y velocity low byte
00:0000AF14 3001            	  1617: 	MOVE.w	d1,d0				; copy the y velocity
00:0000AF16 EE40            	  1618: 	ASR.w		#7,d0				; scale to 1/128th
00:0000AF18 9240            	  1619: 	SUB.w		d0,d1				; subtract the y drag component
00:0000AF1A 1B41007F        	  1620: 	MOVE.b	d1,p_yvlo_off(a5)		; save the y velocity low byte
00:0000AF1E 3F01            	  1621: 	MOVE.w	d1,-(sp)			; save the word
00:0000AF20 1B5F006D        	  1622: 	MOVE.b	(sp)+,p_yvel_off(a5)	; save the y velocity high byte
                            	  1623: 
00:0000AF24 4E75            	  1624: 	RTS
                            	  1625: 
                            	  1626: 
                            	  1627: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1628: ;
                            	  1629: ; limit check the velocity in XA
                            	  1630: 
                            	  1631: check_velocity:
00:0000AF26 6B0C            	  1632: 	BMI.s		check_neg_velocity	; if negative go check negative limit
                            	  1633: 
00:0000AF28 0C414000        	  1634: 	CMPI.w	#$4000,d1			; compare velocity with positive limit
00:0000AF2C 6510            	  1635: 	BCS.s		exit_check_velocity	; if less just exit
                            	  1636: 
00:0000AF2E 323C3FFF        	  1637: 	MOVE.w	#$3FFF,d1			; else set the velocity
00:0000AF32 4E75            	  1638: 	rts
                            	  1639: 
                            	  1640: ; velocity is negative so check against the negative limit
                            	  1641: 
                            	  1642: check_neg_velocity
00:0000AF34 0C41C002        	  1643: 	CMPI.w	#$C002,d1			; compare velocity with negative limit
00:0000AF38 6404            	  1644: 	BCC.s		exit_check_velocity	; if greater or equal just exit
                            	  1645: 
00:0000AF3A 323CC001        	  1646: 	MOVE.w	#$C001,d1			; else set the velocity
                            	  1647: exit_check_velocity
00:0000AF3E 4E75            	  1648: 	rts
                            	  1649: 
                            	  1650: 
                            	  1651: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1652: ;
                            	  1653: ; check items within $0400 range of the player
                            	  1654: 
                            	  1655: check_clear:
00:0000AF40 7C1C            	  1656: 	moveq #s_flag_off-flags_off,d6
                            	  1657: 							; set the count/index to the saucer
00:0000AF42 7E38            	  1658: 	moveq #s_xpos_off-x_pos_off,d7
                            	  1659: 							; set the index to the saucer position
                            	  1660: check_clear_loop
00:0000AF44 4A35600C        	  1661: 	tst.b flags_off(a5,d6.w)	; test the item flag
00:0000AF48 6F28            	  1662: 	BLE.s		not_closer			; if no item or exploding go do the next item
                            	  1663: 
00:0000AF4A 30357080        	  1664: 	MOVE.w	x_pos_off(a5,d7.w),d0	; get the item x position
00:0000AF4E 906DFFB6        	  1665: 	SUB.w		p_xpos_off(a5),d0		; subtract the player x position
00:0000AF52 0C400400        	  1666: 	CMPI.w	#$0400,d0			; compare the result with $0400
00:0000AF56 6506            	  1667: 	BCS.s		check_clear_y		; if closer go check the y distance
                            	  1668: 
00:0000AF58 0C40FC00        	  1669: 	CMPI.w	#$FC00,d0			; compare the result with -$0400
00:0000AF5C 6514            	  1670: 	BCS.s		not_closer			; if not closer go do the next item
                            	  1671: 
                            	  1672: check_clear_y
00:0000AF5E 303570C6        	  1673: 	MOVE.w	y_pos_off(a5,d7.w),d0	; get the item y position
00:0000AF62 906DFFFC        	  1674: 	SUB.w		p_ypos_off(a5),d0		; subtract the player y position
00:0000AF66 0C400400        	  1675: 	CMPI.w	#$0400,d0			; compare the result with $0400
00:0000AF6A 6510            	  1676: 	BCS.s		is_closer			; if closer go flag within distance and
                            	  1677: 							; increment the hide the player count
                            	  1678: 
00:0000AF6C 0C40FC00        	  1679: 	CMPI.w	#$FC00,d0			; compare the result with -$0400
00:0000AF70 640A            	  1680: 	BCC.s		is_closer			; if closer go flag within distance and
                            	  1681: 							; increment the hide the player count
                            	  1682: 
                            	  1683: not_closer
00:0000AF72 5547            	  1684: 	SUBQ.w	#2,d7				; decrement the position index
00:0000AF74 51CEFFCE        	  1685: 	DBF		d6,check_clear_loop	; decrement the count and loop if more to do
                            	  1686: 
00:0000AF78 7000            	  1687: 	MOVEQ		#0,d0				; return Zb = 1
00:0000AF7A 4E75            	  1688: 	rts
                            	  1689: 
                            	  1690: is_closer
00:0000AF7C 522D007A        	  1691: 	ADDQ.b	#1,hide_p_cnt(a5)		; increment the hide the player count
                            	  1692: 							; return Zb = 0
00:0000AF80 4E75            	  1693: 	rts
                            	  1694: 
                            	  1695: 
                            	  1696: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1697: ;
                            	  1698: ; generate new rocks
                            	  1699: 
                            	  1700: make_rocks:
00:0000AF82 4A2D0028        	  1701: 	TST.b		s_flag_off(a5)		; test the saucer flag
00:0000AF86 660000A0        	  1702: 	BNE		exit_make_rocks		; if existing saucer just exit
                            	  1703: 
00:0000AF8A 7C34            	  1704: 	MOVEQ		#p_xpos_off-x_pos_off-2,d6
                            	  1705: 							; set the index to the last rock position
00:0000AF8C 7A1A            	  1706: 	MOVEQ		#p_flag_off-flags_off-1,d5
                            	  1707: 							; set the count/index to the last rock flag
00:0000AF8E 4A2D007B        	  1708: 	TST.b		new_rocks(a5)		; test the generate new rocks flag
00:0000AF92 6600008A        	  1709: 	BNE		clear_rocks			; if not counted out go clear all the rocks
                            	  1710: 
                            	  1711: ; these are used as the new rock initial velocity
                            	  1712: 
00:0000AF96 7000            	  1713: 	MOVEQ		#0,d0				; clear the longword
00:0000AF98 1B40004B        	  1714: 	MOVE.b	d0,s_xvel_off(a5)		; clear the saucer x velocity byte
00:0000AF9C 1B40006E        	  1715: 	MOVE.b	d0,s_yvel_off(a5)		; clear the saucer y velocity byte
                            	  1716: 
00:0000AFA0 700A            	  1717: 	MOVEQ		#$0A,d0			; set the max value
00:0000AFA2 B02D007D        	  1718: 	CMP.b		min_rocks(a5),d0		; compare minimum rock count with $0A
00:0000AFA6 6504            	  1719: 	BCS.s		no_inc_min			; if > skip the increment
                            	  1720: 
00:0000AFA8 522D007D        	  1721: 	ADDQ.b	#1,min_rocks(a5)		; else decrement the minimum rock count before
                            	  1722: 							; the saucer initial timer starts to decrement
                            	  1723: no_inc_min
00:0000AFAC 7800            	  1724: 	MOVEQ		#0,d4				; clear the longword
00:0000AFAE 182D0075        	  1725: 	MOVE.b	i_rk_count(a5),d4		; get the initial rock count
00:0000AFB2 5404            	  1726: 	ADDQ.b	#2,d4				; + 2
00:0000AFB4 0C04000B        	  1727: 	CMPI.b	#11,d4			; compare the new rock count with 11 rocks
00:0000AFB8 6302            	  1728: 	BLS.s		no_set_max			; if less or equal just use it
                            	  1729: 
00:0000AFBA 780B            	  1730: 	MOVEQ		#11,d4			; else set the new rock count to 11
                            	  1731: no_set_max
00:0000AFBC 1B440076        	  1732: 	MOVE.b	d4,rock_count(a5)		; save the rock count
00:0000AFC0 1B440075        	  1733: 	MOVE.b	d4,i_rk_count(a5)		; save the initial rock count
                            	  1734: 
00:0000AFC4 7E1C            	  1735: 	MOVEQ		#s_xvel_off-x_vel_off,d7
                            	  1736: 							; set the index to the saucer for a zero initial
                            	  1737: 							; velocity
                            	  1738: 
00:0000AFC6 5344            	  1739: 	SUBQ.w	#1,d4				; adjust for the loop type
                            	  1740: gen_rock_loop
00:0000AFC8 610008C2        	  1741: 	BSR		gen_prng			; generate the next pseudo random number
00:0000AFCC 7018            	  1742: 	MOVEQ		#$18,d0			; set the rock type mask
00:0000AFCE C02B000A        	  1743: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000AFD2 00000004        	  1744: 	ORI.b		#$04,d0			; set the rock size to the largest
00:0000AFD6 1B80500C        	  1745: 	MOVE.b	d0,flags_off(a5,d5.w)	; save the rock flag
00:0000AFDA 610000C4        	  1746: 	BSR		copy_velocity		; copy the saucer velocity, (d7), plus a random
                            	  1747: 							; delta x,y velocity to the new rock, (d5),
                            	  1748: 							; velocity
                            	  1749: 
00:0000AFDE 610008AC        	  1750: 	BSR		gen_prng			; generate the next pseudo random number
00:0000AFE2 7200            	  1751: 	MOVEQ		#0,d1				; clear the other axis position
00:0000AFE4 303C3FFF        	  1752: 	MOVE.w	#$3FFF,d0			; set the starting position mask
00:0000AFE8 C06B000A        	  1753: 	AND.w		PRNlword(a3),d0		; mask a pseudo random word
00:0000AFEC E248            	  1754: 	LSR.w		#1,d0				; shift a random bit into Cb
00:0000AFEE 640C            	  1755: 	BCC.s		rock_on_x			; if Cb = 0 go set the rock at a point along
                            	  1756: 							; the x axis
                            	  1757: 
                            	  1758: ; set the rock at a point along the y axis
                            	  1759: 
00:0000AFF0 0C401800        	  1760: 	CMPI.w	#$1800,d0			; compare the position with the y axis maximum
00:0000AFF4 6504            	  1761: 	BCS.s		rock_y_ok			; if less just use it
                            	  1762: 
00:0000AFF6 024017FF        	  1763: 	ANDI.w	#$17FF,d0			; mask the position to the y axis maximum
                            	  1764: rock_y_ok
00:0000AFFA C340            	  1765: 	EXG		d1,d0				; swap y value to d1, zero to d0
                            	  1766: 
                            	  1767: ; set the rock at a point along the x axis
                            	  1768: 
                            	  1769: rock_on_x
00:0000AFFC 3B806080        	  1770: 	MOVE.w	d0,x_pos_off(a5,d6.w)	; save the rock x position
00:0000B000 3B8160C6        	  1771: 	MOVE.w	d1,y_pos_off(a5,d6.w)	; save the rock y position
00:0000B004 5546            	  1772: 	SUBQ.w	#2,d6				; decrement the rock position index
00:0000B006 5345            	  1773: 	SUBQ.w	#1,d5				; decrement the rock count/index
00:0000B008 51CCFFBE        	  1774: 	DBF		d4,gen_rock_loop		; decrement the new rock count and loop if more
                            	  1775: 							; to do
                            	  1776: 
00:0000B00C 1B7C007F0077    	  1777: 	MOVE.b	#$7F,sauc_cntdn(a5)	; set the saucer countdown timer
00:0000B012 1B7C0034007C    	  1778: 	MOVE.b	#$34,thmp_sndi(a5)	; reset the thump sound change timer initial
                            	  1779: 							; value
00:0000B018 177C00080023    	  1780: 	MOVE.b	#beat1_snd,thump_snd(a3)
                            	  1781: 							; reset the thump sound value
                            	  1782: 
                            	  1783: ; now clear all the other rocks
                            	  1784: 
                            	  1785: clear_rocks
00:0000B01E 7000            	  1786: 	MOVEQ		#0,d0				; clear the longword
                            	  1787: clear_rocks_loop
00:0000B020 1B80500C        	  1788: 	MOVE.b	d0,flags_off(a5,d5.w)	; clear the rock flag
00:0000B024 51CDFFFA        	  1789: 	DBF		d5,clear_rocks_loop	; decrement the count and loop if more to do
                            	  1790: 
                            	  1791: exit_make_rocks
00:0000B028 4E75            	  1792: 	rts
                            	  1793: 
                            	  1794: 
                            	  1795: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1796: ;
                            	  1797: ; initialise the player variables
                            	  1798: 
                            	  1799: player_init:
00:0000B02A 1B6B001B0082    	  1800: 	move.b ss_count(a3),ships_off(a5)
                            	  1801: 							; set the player's starting ship count
00:0000B030 1B7C00920078    	  1802: 	move.b #$92,i_sauc_tim(a5)	; set the small saucer boundary/initial saucer
                            	  1803: 							; timer
00:0000B036 1B7C00920077    	  1804: 	move.b #$92,sauc_cntdn(a5)	; set the saucer countdown timer
00:0000B03C 1B7C007F007B    	  1805: 	move.b #$7F,new_rocks(a5)	; set the generate new rocks flag
                            	  1806: 
00:0000B042 1B7C0005007D    	  1807: 	move.b #$05,min_rocks(a5)	; set the minimum rock count before the saucer
                            	  1808: 							; initial timer starts to decrement
00:0000B048 1B7C0034007C    	  1809: 	move.b #$34,thmp_sndi(a5)	; reset the thump sound change timer initial
                            	  1810: 							; value
00:0000B04E 177C00080023    	  1811: 	move.b #beat1_snd,thump_snd(a3)	; reset the thump sound value
00:0000B054 1B7C00FF0083    	  1812: 	move.b #$FF,high_off(a5)		; clear the player highscore flag
00:0000B05A 1B7C0001007A    	  1813: 	move.b #$01,hide_p_cnt(a5)	; set the hide the player count
                            	  1814: 
                            	  1815: 
                            	  1816: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1817: ;
                            	  1818: ; reset the player velocity and position
                            	  1819: 
                            	  1820: player_reset:
00:0000B060 3B7C1000FFB6    	  1821: 	move.w #$1000,p_xpos_off(a5)	; set the player x position
00:0000B066 3B7C0C00FFFC    	  1822: 	move.w #$0C00,p_ypos_off(a5)	; set the player y position
00:0000B06C 422D004A        	  1823: 	clr.b p_xvel_off(a5)					; clear the player x velocity
00:0000B070 422D006D        	  1824: 	clr.b p_yvel_off(a5)					; clear the player y velocity
00:0000B074 4E75            	  1825: 	rts
                            	  1826: 
                            	  1827: 
                            	  1828: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1829: ;
                            	  1830: ; copy the item parameters from the old rock, (d7), to the new rock, (d5)
                            	  1831: 
                            	  1832: copy_rock:
00:0000B076 3807            	  1833: 	MOVE.w	d7,d4				; copy the old rock index
00:0000B078 D844            	  1834: 	ADD.w		d4,d4				; ; 2 for the old rock position index
                            	  1835: 
                            	  1836: copy_rock_2
00:0000B07A 3605            	  1837: 	MOVE.w	d5,d3				; copy the new rock index
00:0000B07C D643            	  1838: 	ADD.w		d3,d3				; ; 2 for the new rock position index
                            	  1839: 
00:0000B07E 7207            	  1840: 	MOVEQ		#$07,d1			; set the size mask
00:0000B080 C235700C        	  1841: 	AND.b		flags_off(a5,d7.w),d1	; mask the old rock size
00:0000B084 61000806        	  1842: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B088 7018            	  1843: 	MOVEQ		#$18,d0			; set the rock type mask
00:0000B08A C02B000A        	  1844: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000B08E 8001            	  1845: 	OR.b		d1,d0				; OR in the old rock size
00:0000B090 1B80500C        	  1846: 	MOVE.b	d0,flags_off(a5,d5.w)	; save the new rock flag
                            	  1847: 
00:0000B094 3BB540803080    	  1848: 	MOVE.w	x_pos_off(a5,d4.w),x_pos_off(a5,d3.w)
                            	  1849: 							; copy the old rock x position to the new rock
                            	  1850: 							; x position
00:0000B09A 3BB540C630C6    	  1851: 	MOVE.w	y_pos_off(a5,d4.w),y_pos_off(a5,d3.w)
                            	  1852: 							; copy the old rock y position to the new rock
                            	  1853: 							; y position
                            	  1854: 
                            	  1855: 
                            	  1856: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1857: ;
                            	  1858: ; copy the old rock, (d7), velocity plus random delta x,y velocity to the new rock,
                            	  1859: ; (d5), velocity
                            	  1860: 
                            	  1861: copy_velocity:
00:0000B0A0 610007EA        	  1862: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B0A4 708F            	  1863: 	MOVEQ		#$8F,d0			; mask +/- $00 to $0F
00:0000B0A6 C02B000A        	  1864: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000B0AA 6A04            	  1865: 	BPL.s		x_off_pos			; skip bits set if positive
                            	  1866: 
00:0000B0AC 00000070        	  1867: 	ORI.b		#$70,d0			; else make $Fx
                            	  1868: x_off_pos
00:0000B0B0 D035702F        	  1869: 	ADD.b		x_vel_off(a5,d7.w),d0	; add the item (d7) to the delta x velocity
00:0000B0B4 6120            	  1870: 	BSR.s		limit_velocity		; ensure velocity is within limits
00:0000B0B6 1B80502F        	  1871: 	MOVE.b	d0,x_vel_off(a5,d5.w)	; save the rock x velocity
                            	  1872: 
                            	  1873: 
00:0000B0BA 610007D0        	  1874: 	BSR		gen_prng			; generate the next pseudo random number
00:0000B0BE 708F            	  1875: 	MOVEQ		#$8F,d0			; mask +/- $00 to $0F
00:0000B0C0 C02B000A        	  1876: 	AND.b		PRNlword(a3),d0		; mask a pseudo random byte
00:0000B0C4 6A04            	  1877: 	BPL.s		y_off_pos			; skip bits set if positive
                            	  1878: 
00:0000B0C6 00000070        	  1879: 	ORI.b		#$70,d0			; else make $Fx
                            	  1880: y_off_pos
00:0000B0CA D0357052        	  1881: 	ADD.b		y_vel_off(a5,d7.w),d0	; add the item (d5) to the delta y velocity
00:0000B0CE 6106            	  1882: 	BSR.s		limit_velocity		; ensure velocity is within limits
00:0000B0D0 1B805052        	  1883: 	MOVE.b	d0,y_vel_off(a5,d5.w)	; save the rock y velocity
                            	  1884: 
00:0000B0D4 4E75            	  1885: 	RTS
                            	  1886: 
                            	  1887: 
                            	  1888: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1889: ;
                            	  1890: ; ensure velocity is within limits
                            	  1891: 
                            	  1892: limit_velocity:
00:0000B0D6 6A12            	  1893: 	BPL.s		limit_p_vel			; if positive go test positive limit
                            	  1894: 
00:0000B0D8 0C0000E1        	  1895: 	CMPI.b	#$E1,d0			; compare velocity with upper limit
00:0000B0DC 6402            	  1896: 	BCC.s		neg_upper_ok		; if less skip set
                            	  1897: 
00:0000B0DE 70E1            	  1898: 	MOVEQ		#$E1,d0			; else set velocity to -$1F
                            	  1899: neg_upper_ok
00:0000B0E0 0C0000FB        	  1900: 	CMPI.b	#$FB,d0			; compare velocity with lower limit
00:0000B0E4 6514            	  1901: 	BCS.s		exit_limit_velocity	; if greater just exit
                            	  1902: 
00:0000B0E6 70FA            	  1903: 	MOVEQ		#$FA,d0			; else set velocity to -$06
00:0000B0E8 4E75            	  1904: 	RTS
                            	  1905: 
                            	  1906: ; test velocity positive limit
                            	  1907: 
                            	  1908: limit_p_vel
00:0000B0EA 0C000006        	  1909: 	CMPI.b	#$06,d0			; compare velocity with lower limit
00:0000B0EE 6402            	  1910: 	BCC.s		pos_lower_ok		; skip set if greater
                            	  1911: 
00:0000B0F0 7006            	  1912: 	MOVEQ		#$06,d0			; else set velocity to $06
                            	  1913: pos_lower_ok
00:0000B0F2 0C000020        	  1914: 	CMPI.b	#$20,d0			; compare velocity with upper limit
00:0000B0F6 6502            	  1915: 	BCS.s		exit_limit_velocity	; if less just exit
                            	  1916: 
00:0000B0F8 701F            	  1917: 	MOVEQ		#$1F,d0			; else set velocity to $1F
                            	  1918: exit_limit_velocity
00:0000B0FA 4E75            	  1919: 	RTS
                            	  1920: 
                            	  1921: 
                            	  1922: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  1923: ;
                            	  1924: ; add (c), scores and players ships to the vector list
                            	  1925: 
                            	  1926: static_messages:
00:0000B0FC 43FA18EA        	  1927: 	LEA		copy_msg(pc),a1		; set the pointer to the copyright message
00:0000B100 610006BA        	  1928: 	BSR		add_address			; convert the a1 address and add it to the
                            	  1929: 							; vector list as a vector subroutine call
                            	  1930: 
00:0000B104 36BC1000        	  1931: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
00:0000B108 7219            	  1932: 	MOVEQ		#$19,d1			; set the score x co-ordinate
00:0000B10A 343C00D7        	  1933: 	MOVE.w	#$D7,d2			; set the score y co-ordinate
00:0000B10E 610006C2        	  1934: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1935: 							; a draw command
                            	  1936: 
00:0000B112 323C7000        	  1937: 	MOVE.w	#REL7,d1			; make a $7000,$0000 command
00:0000B116 610006D4        	  1938: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  1939: 
00:0000B11A 0C2B0002001A    	  1940: 	CMPI.b	#$02,num_players(a3)	; compare the number of players in the game
00:0000B120 661E            	  1941: 	BNE.s		skip_play_flash		; if not two players skip flashing the active
                            	  1942: 							; player
                            	  1943: 
00:0000B122 4A2B0018        	  1944: 	TST.b		player_idx(a3)		; test the player index
00:0000B126 6618            	  1945: 	BNE.s		skip_play_flash		; if player 2 go add the player to the vector
                            	  1946: 							; list
                            	  1947: 
00:0000B128 102D0027        	  1948: 	MOVE.b	p_flag_off(a5),d0		; get the player flag
00:0000B12C 802B0026        	  1949: 	OR.b		hyper(a3),d0		; OR with the hyperspace flag
00:0000B130 660E            	  1950: 	BNE.s		skip_play_flash		; if playing go add player 1's score to the
                            	  1951: 							; vector list
                            	  1952: 
00:0000B132 4A2D007A        	  1953: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:0000B136 6B08            	  1954: 	BMI.s		skip_play_flash		; if the player is dieing go display the score
                            	  1955: 
00:0000B138 082B0004005A    	  1956: 	BTST.b	#4,game_count+1(a3)	; test a bit in the game counter low byte
00:0000B13E 6714            	  1957: 	BEQ.s		do_p1_ships			; skip the score display if the flash is off
                            	  1958: 
                            	  1959: ; add the active player to the vector list
                            	  1960: 
                            	  1961: skip_play_flash
00:0000B140 43EB0173        	  1962: 	LEA		p1_score(a3),a1		; point to player 1's score
00:0000B144 7E02            	  1963: 	MOVEQ		#$02,d7			; set the number byte count
00:0000B146 17470016        	  1964: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000B14A 61000512        	  1965: 	BSR		output_number		; output the number (a1) as a leading zero
                            	  1966: 							; suppressed character string
00:0000B14E 7200            	  1967: 	MOVEQ		#0,d1				; add player 1's score's trailing "0"
00:0000B150 61000650        	  1968: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  1969: 
                            	  1970: do_p1_ships
00:0000B154 7229            	  1971: 	MOVEQ		#$29,d1			; set the x co-ordinate for player 1's ships
00:0000B156 7E00            	  1972: 	MOVEQ		#0,d7				; clear the longword
00:0000B158 1E2B0175        	  1973: 	MOVE.b	p1_ships(a3),d7		; get player 1's ship count
00:0000B15C 6100FBB2        	  1974: 	BSR		add_ships			; add d7 ships to the vector list
                            	  1975: 
00:0000B160 4253            	  1976: 	MOVE.w	#$0000,glob_scale(a3)	; set the global scale
                            	  1977: 
00:0000B162 7278            	  1978: 	MOVEQ		#$78,d1			; set the high score x co-ordinate
00:0000B164 343C00D7        	  1979: 	MOVE.w	#$D7,d2			; set the high score y co-ordinate
00:0000B168 61000668        	  1980: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1981: 							; a draw command
00:0000B16C 323C5000        	  1982: 	MOVE.w	#REL5,d1			; make a $5000,$0000 command
00:0000B170 6100067A        	  1983: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  1984: 
00:0000B174 43EB0027        	  1985: 	LEA		hiscores(a3),a1		; point to the highest high score
00:0000B178 7E02            	  1986: 	MOVEQ		#$02,d7			; set the number byte count
00:0000B17A 17470016        	  1987: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000B17E 610004DE        	  1988: 	BSR		output_number		; output the number (a1) as a leading zero
                            	  1989: 							; suppressed character string
                            	  1990: 
00:0000B182 7200            	  1991: 	MOVEQ		#0,d1				; add the high score trailing "0"
00:0000B184 6100061C        	  1992: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  1993: 
00:0000B188 36BC1000        	  1994: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
                            	  1995: 
00:0000B18C 323C00C0        	  1996: 	MOVE.w	#$C0,d1			; set the score x co-ordinate
00:0000B190 343C00D7        	  1997: 	MOVE.w	#$D7,d2			; set the score y co-ordinate
00:0000B194 6100063C        	  1998: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  1999: 							; a draw command
00:0000B198 323C5000        	  2000: 	MOVE.w	#REL5,d1			; make a $5000,$0000 command
00:0000B19C 6100064E        	  2001: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  2002: 
00:0000B1A0 0C2B0001001A    	  2003: 	CMPI.b	#$01,num_players(a3)	; compare the number of players in the game
                            	  2004: 							; with one
00:0000B1A6 6742            	  2005: 	BEQ.s		exit_static			; if just one player skip displaying p2 score
                            	  2006: 
00:0000B1A8 651E            	  2007: 	BCS.s		do_p2_score			; if no players go add player 2's score to
                            	  2008: 							; the vector list
                            	  2009: 
00:0000B1AA 4A2B0018        	  2010: 	TST.b		player_idx(a3)		; test the player index
00:0000B1AE 6718            	  2011: 	BEQ.s		do_p2_score			; if player 1 go add the player to the vector
                            	  2012: 							; list
                            	  2013: 
00:0000B1B0 102D0027        	  2014: 	MOVE.b	p_flag_off(a5),d0		; get the player flag
00:0000B1B4 802B0026        	  2015: 	OR.b		hyper(a3),d0		; OR with the hyperspace flag
00:0000B1B8 660E            	  2016: 	BNE.s		do_p2_score			; if playing go add player 2's score to the
                            	  2017: 							; vector list
                            	  2018: 
00:0000B1BA 4A2D007A        	  2019: 	TST.b		hide_p_cnt(a5)		; test the hide the player count
00:0000B1BE 6B08            	  2020: 	BMI.s		do_p2_score			; if the player is dieing go display the score
                            	  2021: 
00:0000B1C0 082B0004005A    	  2022: 	BTST.b	#4,game_count+1(a3)	; test a bit in the game counter low byte
00:0000B1C6 6714            	  2023: 	BEQ.s		skip_p2_score		; skip the score display if the flash is off
                            	  2024: 
                            	  2025: do_p2_score
00:0000B1C8 43EB0277        	  2026: 	LEA		p2_score(a3),a1		; point to player 2's score
00:0000B1CC 7E02            	  2027: 	MOVEQ		#$02,d7			; set the number byte count
00:0000B1CE 17470016        	  2028: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000B1D2 6100048A        	  2029: 	BSR		output_number		; output the number (a1) as a leading zero
                            	  2030: 							; suppressed character string
00:0000B1D6 7200            	  2031: 	MOVEQ		#0,d1				; add player 2's score's trailing "0"
00:0000B1D8 610005C8        	  2032: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  2033: 
                            	  2034: skip_p2_score
00:0000B1DC 323C00D0        	  2035: 	MOVE.w	#$D0,d1			; set the x co-ordinate for player 2's ships
00:0000B1E0 7E00            	  2036: 	MOVEQ		#0,d7				; clear the longword
00:0000B1E2 1E2B0279        	  2037: 	MOVE.b	p2_ships(a3),d7		; get player 2's ship count
00:0000B1E6 6000FB28        	  2038: 	BRA		add_ships			; add d7 ships to the vector list and return
                            	  2039: 
                            	  2040: exit_static
00:0000B1EA 4E75            	  2041: 	RTS
                            	  2042: 
                            	  2043: 
                            	  2044: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2045: ;
                            	  2046: ; add an item to the vector list
                            	  2047: ;
                            	  2048: ; d6 = object flag offset
                            	  2049: ; d7 = position offset
                            	  2050: 
                            	  2051: 							; first add the DRAW to the item's origin
                            	  2052: add_to_list:
00:0000B1EC 303570C6        	  2053: 	MOVE.w	y_pos_off(a5,d7.w),d0	; get the y position
00:0000B1F0 D07C0400        	  2054: 	ADD.w		#$0400,d0			; add offset so y is centred around 512
00:0000B1F4 E648            	  2055: 	LSR.w		#3,d0				; / 8
00:0000B1F6 0040A000        	  2056: 	ORI.w		#DRAW,d0			; OR in the draw command
00:0000B1FA 38C0            	  2057: 	MOVE.w	d0,(a4)+			; add it to the vector list
                            	  2058: 
00:0000B1FC 30357080        	  2059: 	MOVE.w	x_pos_off(a5,d7.w),d0	; get the x position
00:0000B200 E648            	  2060: 	LSR.w		#3,d0				; / 8
00:0000B202 8041            	  2061: 	OR.w		d1,d0				; OR in the global scale
00:0000B204 38C0            	  2062: 	MOVE.w	d0,(a4)+			; add it to the vector list
                            	  2063: 
00:0000B206 7200            	  2064: 	MOVEQ		#0,d1				; clear the longword
00:0000B208 1235600C        	  2065: 	MOVE.b	flags_off(a5,d6.w),d1	; get the object flag
00:0000B20C 6A12            	  2066: 	BPL.s		add_item			; if not exploding go add the item to the
                            	  2067: 							; vector list
                            	  2068: 
                            	  2069: 							; else add an exploding item
00:0000B20E 0C06001B        	  2070: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  2071: 							; compare the index with the player index
00:0000B212 6700014A        	  2072: 	BEQ		add_play_explode		; if it is the player go add ship pieces to the
                            	  2073: 							; vector list
                            	  2074: 
00:0000B216 0201000C        	  2075: 	ANDI.b	#$0C,d1			; else mask the rock type
00:0000B21A 43FA180C        	  2076: 	LEA		expl_tab(pc),a1		; point to the explosion JSRL table
00:0000B21E 601A            	  2077: 	BRA.s		add_explode			; go add the JSRL word to the vector list and
                            	  2078: 							; return
                            	  2079: 
                            	  2080: ; add item d6 to the vector list
                            	  2081: 
                            	  2082: add_item:
00:0000B220 0C06001B        	  2083: 	CMPI.b	#p_flag_off-flags_off,d6
                            	  2084: 							; compare the index with the player index
00:0000B224 670001DE        	  2085: 	BEQ		add_player			; if = go add the player to the vector list
                            	  2086: 
00:0000B228 0C06001C        	  2087: 	CMPI.b	#s_flag_off-flags_off,d6
                            	  2088: 							; compare the index with the saucer index
00:0000B22C 6712            	  2089: 	BEQ.s		add_saucer			; if = go add the saucer to the vector list
                            	  2090: 
00:0000B22E 6416            	  2091: 	BCC.s		add_fire			; if > saucer go add fire to the vector list
                            	  2092: 
                            	  2093: 							; else add a rock to the vector list
00:0000B230 02410018        	  2094: 	ANDI.w	#$0018,d1			; mask the rock type
00:0000B234 E449            	  2095: 	LSR.w		#2,d1				; >> 3 << 1
00:0000B236 43FA18D6        	  2096: 	LEA		rock_tab(pc),a1		; point to the rock JSRL table
                            	  2097: add_explode
00:0000B23A 38F11000        	  2098: 	MOVE.w	(a1,d1.w),(a4)+		; add the JSRL word to the vector list
00:0000B23E 4E75            	  2099: 	RTS
                            	  2100: 
                            	  2101: ; add the saucer to the vector list
                            	  2102: 
                            	  2103: add_saucer:
00:0000B240 38FA193E        	  2104: 	MOVE.w	sauc_jsr(pc),(a4)+	; add the saucer JSRL to the vector list
00:0000B244 4E75            	  2105: 	RTS
                            	  2106: 
                            	  2107: ; add fire to the vector list
                            	  2108: 
                            	  2109: add_fire:
00:0000B246 38FA1E06        	  2110: 	MOVE.w	shot_jsr(pc),(a4)+	; add the shot JSRL to the vector list
                            	  2111: 
00:0000B24A 7003            	  2112: 	MOVEQ		#3,d0				; set the game counter mask
00:0000B24C C06B0059        	  2113: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000B250 6604            	  2114: 	BNE.s		no_shot_dec			; skip the shot decrement 3/4 of the time
                            	  2115: 
00:0000B252 5335600C        	  2116: 	SUBQ.b	#1,flags_off(a5,d6.w)	; decrement fire item (d7) flag
                            	  2117: no_shot_dec
00:0000B256 4E75            	  2118: 	RTS
                            	  2119: 
                            	  2120: 
                            	  2121: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2122: ;
                            	  2123: ; add d1.b to the current player's score
                            	  2124: 
                            	  2125: add_score:
00:0000B258 44FC0004        	  2126: 	MOVE.w	#4,CCR			; set Zb, clear everything else
00:0000B25C 142D0081        	  2127: 	MOVE.b	score_off+1(a5),d2	; get the player's score, tens
00:0000B260 C501            	  2128: 	ABCD.b	d1,d2				; add the value to the score
00:0000B262 6422            	  2129: 	BCC.s		exit_add_score		; if no carry just exit
                            	  2130: 
00:0000B264 7200            	  2131: 	MOVEQ		#0,d1				; clear the add high byte
00:0000B266 102D0080        	  2132: 	MOVE.b	score_off(a5),d0		; get the player's score, thousands
00:0000B26A C101            	  2133: 	ABCD.b	d1,d0				; add the value to the score
00:0000B26C 1B400080        	  2134: 	MOVE.b	d0,score_off(a5)		; save the player's score, thousands
                            	  2135: 
00:0000B270 0200000F        	  2136: 	ANDI.b	#$0F,d0			; mask the units of thousands
00:0000B274 6610            	  2137: 	BNE.s		exit_add_score		; if the score is not x0000 just exit
                            	  2138: 
00:0000B276 720A            	  2139: 	MOVEQ		#extra_snd,d1		; set the bonus ship sound
00:0000B278 6100219E        	  2140: 	BSR		play_sample			; go play the sample
                            	  2141: 
00:0000B27C 522D0082        	  2142: 	ADDQ.b	#1,ships_off(a5)		; increment the player's ship count
00:0000B280 6604            	  2143: 	BNE.s		exit_add_score		; exit if not wrappwd
                            	  2144: 
00:0000B282 532D0082        	  2145: 	SUBQ.b	#1,ships_off(a5)		; decrement the player's ship count
                            	  2146: exit_add_score
00:0000B286 1B420081        	  2147: 	MOVE.b	d2,score_off+1(a5)	; save the player's score, tens
00:0000B28A 4E75            	  2148: 	RTS
                            	  2149: 
                            	  2150: 
                            	  2151: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2152: ;
                            	  2153: ; display the high score table if the game is over
                            	  2154: 
                            	  2155: high_scores:
00:0000B28C 4A2B001A        	  2156: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000B290 660000A0        	  2157: 	BNE		exit_no_scores		; if playing skip the high scores
                            	  2158: 
00:0000B294 082B00020059    	  2159: 	BTST.b	#2,game_count(a3)		; test a bit in the game counter high byte
00:0000B29A 66000096        	  2160: 	BNE		exit_no_scores		; if not high score time just exit
                            	  2161: 
00:0000B29E 45EB0027        	  2162: 	LEA		hiscores(a3),a2		; point to the high score table
                            	  2163: 
00:0000B2A2 4A52            	  2164: 	TST.w		(a2)				; test the highest high score
00:0000B2A4 6700008C        	  2165: 	BEQ		exit_no_scores		; if the high score table is empty just exit
                            	  2166: 
00:0000B2A8 7200            	  2167: 	MOVEQ		#0,d1				; message 0 - "HIGH SCORES"
00:0000B2AA 61000470        	  2168: 	BSR		add_message			; add message d1 to the display list
                            	  2169: 
00:0000B2AE 36BC1000        	  2170: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
                            	  2171: 
00:0000B2B2 41EB003B        	  2172: 	LEA		hinames(a3),a0		; point to the high score names
00:0000B2B6 7C00            	  2173: 	MOVEQ		#0,d6				; clear the high score index
00:0000B2B8 377C00A70012    	  2174: 	MOVE.w	#$00A7,hiscore_y(a3)	; set the score's y co-ordinate
                            	  2175: high_scores_loop
00:0000B2BE 4A52            	  2176: 	TST.w		(a2)				; test the high score entry
00:0000B2C0 676A            	  2177: 	BEQ.s		exit_high_scores		; if this score is zero just exit
                            	  2178: 
00:0000B2C2 725F            	  2179: 	MOVEQ		#$5F,d1			; set the score's x co-ordinate
00:0000B2C4 342B0012        	  2180: 	MOVE.w	hiscore_y(a3),d2		; get the score's y co-ordinate
00:0000B2C8 61000508        	  2181: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  2182: 							; a draw command
                            	  2183: 
00:0000B2CC 323C4000        	  2184: 	MOVE.w	#REL4,d1			; make a $4000,$0000 command
00:0000B2D0 6100051A        	  2185: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  2186: 
00:0000B2D4 43EB0017        	  2187: 	LEA		high_idx(a3),a1		; point to the high score index
00:0000B2D8 7E01            	  2188: 	MOVEQ		#$01,d7			; set the number byte count and the increment
00:0000B2DA 44FC0004        	  2189: 	MOVE.w	#4,CCR			; set Zb, clear everything else
00:0000B2DE CD07            	  2190: 	ABCD.b	d7,d6				; add to the high score index
00:0000B2E0 1286            	  2191: 	MOVE.b	d6,(a1)			; save the high score decimal index
00:0000B2E2 17470016        	  2192: 	MOVE.b	d7,suppress_0(a3)		; set the flag to suppress leading zeros
00:0000B2E6 61000376        	  2193: 	BSR		output_number		; output a number as a leading zero suppressed
                            	  2194: 							; string
                            	  2195: 
                            	  2196: 							; set the point after the high score number
00:0000B2EA 323C4000        	  2197: 	MOVE.w	#REL4,d1			; make a $4000,$xx00 command
00:0000B2EE 3401            	  2198: 	MOVE.w	d1,d2				; make a $4000,$4000 command, point after entry
                            	  2199: 							; number
00:0000B2F0 610004FC        	  2200: 	BSR		add_pair			; add (d1)00,(d2)00 to the vector list
                            	  2201: 
00:0000B2F4 7200            	  2202: 	MOVEQ		#0,d1				; set [SPACE] character
00:0000B2F6 6100FA08        	  2203: 	BSR		add_character		; add character (d1) to the vector list
                            	  2204: 
00:0000B2FA 224A            	  2205: 	MOVEA.l	a2,a1				; point to the high score entry
00:0000B2FC 7E02            	  2206: 	MOVEQ		#$02,d7			; set the number byte count
00:0000B2FE 177C00FF0016    	  2207: 	MOVE.b	#-1,suppress_0(a3)	; set the flag to suppress leading zeros
00:0000B304 61000358        	  2208: 	BSR		output_number		; output a number as a leading zero suppressed
                            	  2209: 							; string
                            	  2210: 
00:0000B308 7200            	  2211: 	MOVEQ		#0,d1				; add the final "0"
00:0000B30A 61000496        	  2212: 	BSR		add_hex_chr			; write a hex character to the vector list
                            	  2213: 
00:0000B30E 7200            	  2214: 	MOVEQ		#0,d1				; set [SPACE] character
00:0000B310 6100F9EE        	  2215: 	BSR		add_character		; add character (d1) to the vector list
                            	  2216: 
00:0000B314 6100F9D0        	  2217: 	BSR		write_initial		; write a high score initial to the vector list
00:0000B318 6100F9CC        	  2218: 	BSR		write_initial		; write a high score initial to the vector list
00:0000B31C 6100F9C8        	  2219: 	BSR		write_initial		; write a high score initial to the vector list
                            	  2220: 
00:0000B320 516B0012        	  2221: 	SUBQ.w	#8,hiscore_y(a3)		; subtract 8 from the score's y co-ordinate
00:0000B324 544A            	  2222: 	ADDQ.w	#2,a2				; increment the high score pointer
                            	  2223: 
00:0000B326 0C060010        	  2224: 	CMPI.b	#$10,d6			; compare the high score index with 10
00:0000B32A 6592            	  2225: 	BCS.s		high_scores_loop		; loop if more to do
                            	  2226: 
                            	  2227: exit_high_scores
00:0000B32C 003C0001        	  2228: 	ORI.b		#$01,CCR			; set the carry, flag scores displayed
00:0000B330 4E75            	  2229: 	RTS
                            	  2230: 
                            	  2231: exit_no_scores
00:0000B332 023C00FE        	  2232: 	ANDI.b	#$FE,CCR			; clear the carry, flag scores not displayed
00:0000B336 4E75            	  2233: 	RTS
                            	  2234: 
                            	  2235: 
                            	  2236: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2237: ;
                            	  2238: ; find a free rock item, the index is returned in d5
                            	  2239: 
                            	  2240: find_rock:
00:0000B338 7A1A            	  2241: 	MOVEQ		#p_flag_off-flags_off-1,d5
                            	  2242: 							; set the count/index to the last rock flag
                            	  2243: 
                            	  2244: ; find a free rock item from d5
                            	  2245: 
                            	  2246: find_next_rock
00:0000B33A 4A35500C        	  2247: 	TST.b		flags_off(a5,d5.w)	; test the rock flag
00:0000B33E 6704            	  2248: 	BEQ.s		exit_find_rock		; if free return this index
                            	  2249: 
00:0000B340 51CDFFF8        	  2250: 	DBF		d5,find_next_rock		; else loop if more to do
                            	  2251: 
                            	  2252: exit_find_rock
00:0000B344 4E75            	  2253: 	RTS
                            	  2254: 
                            	  2255: 
                            	  2256: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2257: ;
                            	  2258: ; wrecked ship piece x,y velocities
                            	  2259: 
                            	  2260: ship_wrk_x
00:0000B346 FFD8            	  2261: 	dc.w	$FFD8					; x
00:0000B348 0032            	  2262: 	dc.w	$0032					; x
00:0000B34A 0000            	  2263: 	dc.w	$0000					; x
00:0000B34C 003C            	  2264: 	dc.w	$003C					; x
00:0000B34E 000A            	  2265: 	dc.w	$000A					; x
00:0000B350 FFD8            	  2266: 	dc.w	$FFD8					; x
                            	  2267: 
                            	  2268: ship_wrk_y
00:0000B352 001E            	  2269: 	dc.w	$001E					; y
00:0000B354 FFEC            	  2270: 	dc.w	$FFEC					; y
00:0000B356 FFC4            	  2271: 	dc.w	$FFC4					; y
00:0000B358 0014            	  2272: 	dc.w	$0014					; y
00:0000B35A 0046            	  2273: 	dc.w	$0046					; y
00:0000B35C FFD8            	  2274: 	dc.w	$FFD8					; y
                            	  2275: 
                            	  2276: 
                            	  2277: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2278: ;
                            	  2279: ; add the player explosion to the vector list
                            	  2280: 
                            	  2281: add_play_explode:
00:0000B35E 48E70300        	  2282: 	MOVEM.l	d6-d7,-(sp)			; save the registers
00:0000B362 7200            	  2283: 	MOVEQ		#0,d1				; clear the longword
00:0000B364 122D0027        	  2284: 	MOVE.b	p_flag_off(a5),d1		; get the player flag
00:0000B368 0C0100A2        	  2285: 	CMPI.b	#$A2,d1			; compare the player flag with $A2
00:0000B36C 641A            	  2286: 	BCC.s		no_reset_xy			; if >= $A2 skip resetting the explosion
                            	  2287: 							; start point
                            	  2288: 
                            	  2289: 							; else reset the explosion start point
00:0000B36E 7E0A            	  2290: 	MOVEQ		#$0A,d7			; set the index to the last piece x,y pair
                            	  2291: reset_xy_loop
00:0000B370 303B70D4        	  2292: 	MOVE.w	ship_wrk_x(pc,d7.w),d0	; get the x velocity word
00:0000B374 E948            	  2293: 	LSL.w		#4,d0				; ; 16
00:0000B376 3780705B        	  2294: 	MOVE.w	d0,expl_x_pos(a3,d7.w)	; save the x position word
                            	  2295: 
00:0000B37A 303B70D6        	  2296: 	MOVE.w	ship_wrk_y(pc,d7.w),d0	; get the y velocity word
00:0000B37E E948            	  2297: 	LSL.w		#4,d0				; ; 16
00:0000B380 37807067        	  2298: 	MOVE.w	d0,expl_y_pos(a3,d7.w)	; save the y position word
                            	  2299: 
00:0000B384 5547            	  2300: 	SUBQ.w	#2,d7				; decrement the index
00:0000B386 6AE8            	  2301: 	BPL.s		reset_xy_loop		; loop if more to do
                            	  2302: 
                            	  2303: ; now use the player flag as the start index to the ship pieces. this means there will
                            	  2304: ; be less pieces as the explosion progresses
                            	  2305: 
                            	  2306: no_reset_xy
00:0000B388 7070            	  2307: 	MOVEQ		#$70,d0			; set the mask
00:0000B38A B101            	  2308: 	EOR.b		d0,d1				; toggle the player flag
00:0000B38C C200            	  2309: 	AND.b		d0,d1				; mask the player flag
00:0000B38E E609            	  2310: 	LSR.b		#3,d1				; / 16 ; 2 gives the piece start index
00:0000B390 3E01            	  2311: 	MOVE.w	d1,d7				; copy the index
                            	  2312: 
                            	  2313: 							; the piece draw loop	
                            	  2314: piece_draw_loop
00:0000B392 303B70B2        	  2315: 	MOVE.w	ship_wrk_x(pc,d7.w),d0	; get the x velocity word
00:0000B396 D073705B        	  2316: 	ADD.w		expl_x_pos(a3,d7.w),d0	; add the x position word
00:0000B39A 3780705B        	  2317: 	MOVE.w	d0,expl_x_pos(a3,d7.w)	; save the x position word
                            	  2318: 
00:0000B39E 323B70B2        	  2319: 	MOVE.w	ship_wrk_y(pc,d7.w),d1	; get the y velocity word
00:0000B3A2 D2737067        	  2320: 	ADD.w		expl_y_pos(a3,d7.w),d1	; add the y position word
00:0000B3A6 37817067        	  2321: 	MOVE.w	d1,expl_y_pos(a3,d7.w)	; save the y position word
                            	  2322: 
00:0000B3AA 244C            	  2323: 	MOVEA.l	a4,a2				; copy the vector pointer
                            	  2324: 
00:0000B3AC 7400            	  2325: 	MOVEQ		#0,d2				; clear the x sign bit
00:0000B3AE 4A40            	  2326: 	TST.w		d0				; test the x position word
00:0000B3B0 6A06            	  2327: 	BPL.s		vec_x_pos			; if positive skip the negate
                            	  2328: 
00:0000B3B2 4440            	  2329: 	NEG.w		d0				; else negate the x position, make it positive
00:0000B3B4 343C0400        	  2330: 	MOVE.w	#$0400,d2			; and set the x sign bit
                            	  2331: vec_x_pos
                            	  2332: 
00:0000B3B8 7600            	  2333: 	MOVEQ		#0,d3				; clear the y sign bit
00:0000B3BA 4A41            	  2334: 	TST.w		d1				; test the y position word
00:0000B3BC 6A06            	  2335: 	BPL.s		vec_y_pos			; if positive skip the negate
                            	  2336: 
00:0000B3BE 4441            	  2337: 	NEG.w		d1				; else negate the y position, make it positive
00:0000B3C0 363C0400        	  2338: 	MOVE.w	#$0400,d3			; and set the y sign bit
                            	  2339: vec_y_pos
00:0000B3C4 E848            	  2340: 	LSR.w		#4,d0				; shift the x position
00:0000B3C6 E849            	  2341: 	LSR.w		#4,d1				; shift the y position
                            	  2342: 
00:0000B3C8 8042            	  2343: 	OR.w		d2,d0				; OR in the x sign bit
00:0000B3CA 00416000        	  2344: 	ORI.w		#$6000,d1			; fix the scale
00:0000B3CE 8243            	  2345: 	OR.w		d3,d1				; OR in the y sign bit
                            	  2346: 
00:0000B3D0 38C1            	  2347: 	MOVE.w	d1,(a4)+			; add y position to the vector list
00:0000B3D2 38C0            	  2348: 	MOVE.w	d0,(a4)+			; add x position to the vector list
                            	  2349: 
                            	  2350: 							; add the piece vector to the list
                            	  2351: 
00:0000B3D4 303B7022        	  2352: 	MOVE.w	ship_parts(pc,d7.w),d0	; get wrecked ship piece vector word
00:0000B3D8 38C0            	  2353: 	MOVE.w	d0,(a4)+			; add the wrecked ship piece vector word to the
                            	  2354: 							; vector list
                            	  2355: 
00:0000B3DA 0A400404        	  2356: 	EORI.w	#$0404,d0			; toggle the sign bits
00:0000B3DE 0240FF0F        	  2357: 	ANDI.w	#$FF0F,d0			; clear the intensity bits
00:0000B3E2 38C0            	  2358: 	MOVE.w	d0,(a4)+			; add the inverse wrecked ship piece vector word
                            	  2359: 							; to the vector list
                            	  2360: 
                            	  2361: 							; now copy an inverse relative long vector to
                            	  2362: 							; the list
00:0000B3E4 2012            	  2363: 	MOVE.l	(a2),d0			; get the vector to the piece
00:0000B3E6 0A8004000400    	  2364: 	EORI.l	#$04000400,d0		; toggle the sign bits
00:0000B3EC 28C0            	  2365: 	MOVE.l	d0,(a4)+			; save the inverse vector to the list
                            	  2366: 
00:0000B3EE 5547            	  2367: 	SUBQ.w	#2,d7				; decrement the index
00:0000B3F0 6AA0            	  2368: 	BPL		piece_draw_loop		; loop if more to do
                            	  2369: 
00:0000B3F2 4CDF00C0        	  2370: 	MOVEM.l	(sp)+,d6-d7			; restore the registers
00:0000B3F6 4E75            	  2371: 	rts
                            	  2372: 
                            	  2373: 
                            	  2374: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2375: ;
                            	  2376: ; pieces of wrecked ship
                            	  2377: 
                            	  2378: ship_parts
00:0000B3F8 FFC6            	  2379: 	dc.w	$FFC6				; x = -2, Y = -3
00:0000B3FA FEC1            	  2380: 	dc.w	$FEC1				; x =  1, Y = -2
00:0000B3FC F1C3            	  2381: 	dc.w	$F1C3				; x =  3, Y =  1
00:0000B3FE F1CD            	  2382: 	dc.w	$F1CD				; x = -1, Y =  1
00:0000B400 F1C7            	  2383: 	dc.w	$F1C7				; x = -3, Y =  1
00:0000B402 FDC1            	  2384: 	dc.w	$FDC1				; x =  1, Y = -1
                            	  2385: 
                            	  2386: 
                            	  2387: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2388: ;
                            	  2389: ; add the player ship to the vector list
                            	  2390: 
                            	  2391: add_player:
00:0000B404 7600            	  2392: 	MOVEQ		#0,d3				; clear the x_sign
00:0000B406 7400            	  2393: 	MOVEQ		#0,d2				; clear the y_sign
00:0000B408 7800            	  2394: 	MOVEQ		#0,d4				; yx_sign
                            	  2395: 
00:0000B40A 122B001E        	  2396: 	MOVE.b	p_orient(a3),d1		; get the player orientation
00:0000B40E 6A0A            	  2397: 	BPL.s		no_pos_reflect		; if positive skip reflection
                            	  2398: 
00:0000B410 343C0400        	  2399: 	MOVE.w	#$0400,d2			; set the y_sign
00:0000B414 3802            	  2400: 	MOVE.w	d2,d4				; set the yx_sign
00:0000B416 4401            	  2401: 	NEG.b		d1				; make ABS orientation
00:0000B418 6B06            	  2402: 	BMI.s		third_quad			; if still negative go do the third quad
                            	  2403: 
                            	  2404: no_pos_reflect
00:0000B41A 08010006        	  2405: 	BTST.l	#6,d1				; test the quadrant
00:0000B41E 670E            	  2406: 	BEQ.s		first_quad			; skip reflect if in first quadrant
                            	  2407: 
                            	  2408: third_quad
00:0000B420 363C0400        	  2409: 	MOVE.w	#$0400,d3			; set the x_sign
00:0000B424 183C0004        	  2410: 	MOVE.b	#$04,d4			; set the yx_sign
                            	  2411: 
00:0000B428 4401            	  2412: 	NEG.b		d1				; negate the byte
00:0000B42A D23C0080        	  2413: 	ADD.b		#$80,d1			; reflect the quadrant
                            	  2414: first_quad
00:0000B42E E209            	  2415: 	LSR.b		#1,d1				; do quadrant value / 2
00:0000B430 C23C003E        	  2416: 	AND.b		#$3E,d1			; mask to word boundary, value is $00 to $20
                            	  2417: 
00:0000B434 43FA1768        	  2418: 	LEA		play_tab(pc),a1		; point to the player ship table
00:0000B438 32311000        	  2419: 	MOVE.w	(a1,d1.w),d1		; get the offset to the player ship
00:0000B43C 43F11000        	  2420: 	LEA		(a1,d1.w),a1		; get the pointer to the player ship
00:0000B440 6118            	  2421: 	BSR.s		copy_vectors		; copy the vectors from (a1) to the vector list
                            	  2422: 
                            	  2423: ;	MOVEQ		#'L',d1			; set for the thrust button
                            	  2424: ;	MOVEQ		#19,d0			; check for keypress
                            	  2425: ;	TRAP		#15
00:0000B442 7005            	  2426: 	moveq #5,d0
00:0000B444 4E4F            	  2427: 	trap #15
00:0000B446 0C01004C        	  2428: 	cmpi.b #'L',d1
00:0000B44A 6608            	  2429: 	bne.s no_thrust
                            	  2430: 
                            	  2431: ;	TST.b		d1				; test the result
                            	  2432: ;	BEQ.s		no_thrust			; if not pressed then skip the thrust copy
                            	  2433: 
00:0000B44C 7003            	  2434: 	MOVEQ		#3,d0				; set the game counter mask
00:0000B44E C06B0059        	  2435: 	AND.w		game_count(a3),d0		; mask the game counter
00:0000B452 6606            	  2436: 	BNE.s		copy_vectors		; 3/4 of the time go copy the vectors from (a1)
                            	  2437: 							; to the vector list and return
                            	  2438: no_thrust
00:0000B454 4E75            	  2439: 	RTS
                            	  2440: 
                            	  2441: 
                            	  2442: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2443: ;
                            	  2444: ; copy the vectors from (a1) to the vector list
                            	  2445: 
                            	  2446: copy_short:
00:0000B456 B940            	  2447: 	EOR.w		d4,d0				; possibly toggle the x and y signs
00:0000B458 38C0            	  2448: 	MOVE.w	d0,(a4)+			; copy the word to the vector list
                            	  2449: 
                            	  2450: copy_vectors
00:0000B45A 3019            	  2451: 	MOVE.w	(a1)+,d0			; get a vector word
00:0000B45C B07CF000        	  2452: 	CMP.w		#SHRT,d0			; compare with short form vector
00:0000B460 64F4            	  2453: 	BCC.s		copy_short			; if short vector go copy it
                            	  2454: 
00:0000B462 B07CA000        	  2455: 	CMP.w		#DRAW,d0			; compare with the DRAW command
00:0000B466 640C            	  2456: 	BCC.s		exit_copy_vectors		; if DRAW or greater exit the vector copy
                            	  2457: 
                            	  2458: ; else it is a long vector
                            	  2459: 
00:0000B468 B540            	  2460: 	EOR.w		d2,d0				; possibly toggle the y sign
00:0000B46A 38C0            	  2461: 	MOVE.w	d0,(a4)+			; copy the word to the vector list
00:0000B46C 3019            	  2462: 	MOVE.w	(a1)+,d0			; get the second vector word
00:0000B46E B740            	  2463: 	EOR.w		d3,d0				; possibly toggle the x sign
00:0000B470 38C0            	  2464: 	MOVE.w	d0,(a4)+			; copy the word to the vector list
00:0000B472 60E6            	  2465: 	BRA.s		copy_vectors		; go do the next word
                            	  2466: 
                            	  2467: ; it's a short form vector
                            	  2468: 
                            	  2469: exit_copy_vectors
00:0000B474 4E75            	  2470: 	RTS
                            	  2471: 
                            	  2472: 
                            	  2473: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2474: ;
                            	  2475: ; do the game sounds
                            	  2476: 
                            	  2477: fx_sounds:
00:0000B476 7200            	  2478: 	MOVEQ		#0,d1				; clear the longword
00:0000B478 122D0028        	  2479: 	MOVE.b	s_flag_off(a5),d1		; get the saucer flag
00:0000B47C 6F06            	  2480: 	BLE.s		no_saucer_sound		; if no saucer or the saucer is exploding skip
                            	  2481: 							; the saucer sound
                            	  2482: 
00:0000B47E 5401            	  2483: 	ADDQ.b	#smsau_snd-1,d1		; add the small saucer sound to the size
00:0000B480 61001F96        	  2484: 	BSR		play_sample			; go play the sample
                            	  2485: no_saucer_sound
00:0000B484 4A2D0076        	  2486: 	TST.b		rock_count(a5)		; test the rock count
00:0000B488 672C            	  2487: 	BEQ.s		no_thump_sound		; if no rocks skip the thump sound
                            	  2488: 
00:0000B48A 4A2D0027        	  2489: 	TST.b		p_flag_off(a5)		; test the player flag
00:0000B48E 6F26            	  2490: 	BLE.s		no_thump_sound		; if no player or the player is exploding skip
                            	  2491: 							; the thump sound
                            	  2492: 
00:0000B490 4A2B0026        	  2493: 	TST.b		hyper(a3)			; test the hyperspace flag
00:0000B494 6620            	  2494: 	BNE.s		no_thump_sound		; if in hyperspace skip the thump sound
                            	  2495: 
00:0000B496 532B0024        	  2496: 	SUBQ.b	#1,thump_time(a3)		; decrement the thump sound change timer
00:0000B49A 661A            	  2497: 	BNE.s		no_thump_sound		; skip changing the sound if not timed out
                            	  2498: 
00:0000B49C 7004            	  2499: 	MOVEQ		#4,d0				; add the sound on time
00:0000B49E D02D007C        	  2500: 	ADD.b		thmp_sndi(a5),d0		; add the thump sound change timer initial
00:0000B4A2 17400024        	  2501: 	MOVE.b	d0,thump_time(a3)		; save the thump sound change timer
                            	  2502: 
00:0000B4A6 7001            	  2503: 	MOVEQ		#1,d0				; set the bitmap change mask
00:0000B4A8 122B0023        	  2504: 	MOVE.b	thump_snd(a3),d1		; get the thump sound value
00:0000B4AC B101            	  2505: 	EOR.b		d0,d1				; change the thump sound value
00:0000B4AE 17410023        	  2506: 	MOVE.b	d1,thump_snd(a3)		; save the thump sound value
00:0000B4B2 60001F64        	  2507: 	BRA		play_sample			; go play the sample and return
                            	  2508: 
                            	  2509: no_thump_sound
00:0000B4B6 4E75            	  2510: 	RTS
                            	  2511: 
                            	  2512: 
                            	  2513: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2514: ;
                            	  2515: ; handle something hitting a rock
                            	  2516: 
                            	  2517: ; d6 = player/saucer/shot object index
                            	  2518: ; d7 = object index
                            	  2519: 
                            	  2520: hit_a_rock:
00:0000B4B8 1B7C00500079    	  2521: 	MOVE.b	#$50,r_hit_tim(a5)	; set the rock hit timer
00:0000B4BE 1035700C        	  2522: 	MOVE.b	flags_off(a5,d7.w),d0	; get the rock flag
00:0000B4C2 7278            	  2523: 	MOVEQ		#$78,d1			; set the mask for the rock type
00:0000B4C4 C200            	  2524: 	AND.b		d0,d1				; mask the rock type
                            	  2525: 
00:0000B4C6 02400007        	  2526: 	ANDI.w	#$07,d0			; mask the rock size
00:0000B4CA E248            	  2527: 	LSR.w		#1,d0				; / 2
00:0000B4CC 3400            	  2528: 	MOVE.w	d0,d2				; copy the size
00:0000B4CE 6702            	  2529: 	BEQ.s		clear_rock			; if the size is zero then the rock is destroyed
                            	  2530: 							; so go clear the rock flag
                            	  2531: 
00:0000B4D0 8001            	  2532: 	OR.b		d1,d0				; else OR back the rock type
                            	  2533: clear_rock
00:0000B4D2 1B80700C        	  2534: 	MOVE.b	d0,flags_off(a5,d7.w)	; save the rock flag
                            	  2535: 
00:0000B4D6 4A2B001A        	  2536: 	TST.b		num_players(a3)		; test the number of players in the game
00:0000B4DA 6712            	  2537: 	BEQ.s		skip_add			; if no players skip the score add
                            	  2538: 
00:0000B4DC 4A46            	  2539: 	TST.w		d6				; test the player/saucer/shot index
00:0000B4DE 6706            	  2540: 	BEQ.s		add_to_score		; if the player hit the rock go add it to the
                            	  2541: 							; player's score
                            	  2542: 
00:0000B4E0 0C460004        	  2543: 	CMPI.w	#p_fire_off-p_flag_off,d6
                            	  2544: 							; compare the player/saucer/shot index with the
                            	  2545: 							; first of the player's fire
00:0000B4E4 6508            	  2546: 	BCS.s		skip_add			; if < the player's fire skip adding to the
                            	  2547: 							; player's score
                            	  2548: 
                            	  2549: add_to_score
00:0000B4E6 123B2042        	  2550: 	MOVE.b	rock_score(pc,d2.w),d1	; get the score per rock size
00:0000B4EA 6100FD6C        	  2551: 	BSR		add_score			; add d1.b to the current player's score
                            	  2552: skip_add
00:0000B4EE 4A35700C        	  2553: 	TST.b		flags_off(a5,d7.w)	; test the rock flag
00:0000B4F2 6734            	  2554: 	BEQ.s		exit_hit_a_rock		; if the rock was destroyed just exit
                            	  2555: 
                            	  2556: ; else break the rock into none, one, or two smaller rocks
                            	  2557: 
00:0000B4F4 6100FE42        	  2558: 	BSR		find_rock			; find a free rock, the index is returned in d5
00:0000B4F8 662E            	  2559: 	BNE.s		exit_hit_a_rock		; if there are no free rocks just exit
                            	  2560: 
00:0000B4FA 522D0076        	  2561: 	ADDQ.b	#1,rock_count(a5)		; else increment the rock count
                            	  2562: 
00:0000B4FE 6100FB76        	  2563: 	BSR		copy_rock			; copy the item parameters from the old rock,
                            	  2564: 							; (d7), to the new rock, (d5)
                            	  2565: 
00:0000B502 701F            	  2566: 	MOVEQ		#$1F,d0			; set the mask for the low 5 bits
00:0000B504 C035502F        	  2567: 	AND.b		x_vel_off(a5,d5.w),d0	; get the new rock x velocity byte
00:0000B508 D000            	  2568: 	ADD.b		d0,d0				; ; 2
00:0000B50A B1353081        	  2569: 	EOR.b		d0,x_pos_off+1(a5,d3.w)	; purturb the new rock x position low byte
                            	  2570: 
00:0000B50E 6100FE2A        	  2571: 	BSR		find_next_rock		; find a free rock from d5, the index is
                            	  2572: 							; returned in d5
00:0000B512 6614            	  2573: 	BNE.s		exit_hit_a_rock		; if there are no free rocks just exit
                            	  2574: 
00:0000B514 522D0076        	  2575: 	ADDQ.b	#1,rock_count(a5)		; else increment the rock count
                            	  2576: 
00:0000B518 6100FB60        	  2577: 	BSR		copy_rock_2			; copy the item parameters from the old rock,
                            	  2578: 							; (d7), to the new rock, (d5)
                            	  2579: 
00:0000B51C 701F            	  2580: 	MOVEQ		#$1F,d0			; set the mask for the low 5 bits
00:0000B51E C0355052        	  2581: 	AND.b		y_vel_off(a5,d5.w),d0	; get the new rock y velocity byte
00:0000B522 D000            	  2582: 	ADD.b		d0,d0				; ; 2
00:0000B524 B13530C7        	  2583: 	EOR.b		d0,y_pos_off+1(a5,d3.w)	; purturb the new rock y position low byte
                            	  2584: exit_hit_a_rock
00:0000B528 4E75            	  2585: 	RTS
                            	  2586: 
                            	  2587: 
                            	  2588: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2589: ;
                            	  2590: ; score per rock size
                            	  2591: 
                            	  2592: rock_score
00:0000B52A 10              	  2593: 	dc.b	$10					; 100 points, small rock
00:0000B52B 05              	  2594: 	dc.b	$05					;  50 points, medium rock
00:0000B52C 02              	  2595: 	dc.b	$02					;  20 points, large rock
00:0000B52D 00              	  2596: 	dc.b	$00					;   0 points, null pad byte
                            	  2597: 
                            	  2598: 
                            	  2599: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2600: ;
                            	  2601: ; do the high score checks
                            	  2602: 
                            	  2603: check_hiscores:
00:0000B52E 102B001A        	  2604: 	MOVE.b	num_players(a3),d0	; get the number of players in the game
00:0000B532 6A5A            	  2605: 	BPL.s		exit_check_hiscores	; if still players just exit
                            	  2606: 
00:0000B534 1B400083        	  2607: 	MOVE.b	d0,high_off(a5)		; clear the player 2 highscore flag
00:0000B538 1D400083        	  2608: 	MOVE.b	d0,high_off(a6)		; clear the player 1 highscore flag
                            	  2609: 
00:0000B53C 177C00010018    	  2610: 	MOVE.b	#$01,player_idx(a3)	; set the player index for player two
00:0000B542 4BEB01F7        	  2611: 	LEA		player_2(a3),a5		; set the pointer to player two's variables
00:0000B546 4DEB00F3        	  2612: 	LEA		player_1(a3),a6		; set the pointer to player one's variables
                            	  2613: check_hi_player
00:0000B54A 7400            	  2614: 	MOVEQ		#0,d2				; clear the high score index
00:0000B54C 302D0080        	  2615: 	MOVE.w	score_off(a5),d0		; get the player score
00:0000B550 670E            	  2616: 	BEQ.s		check_hi_next		; if zero go try the other player
                            	  2617: 
                            	  2618: check_hi_loop
00:0000B552 B0732027        	  2619: 	CMP.w		hiscores(a3,d2.w),d0	; compare the high score with the player score
00:0000B556 6238            	  2620: 	BHI.s		insert_hiscore		; if the player score was more go insert the
                            	  2621: 							; score
                            	  2622: 
00:0000B558 5442            	  2623: 	ADDQ.w	#2,d2				; increment the high score index
00:0000B55A 0C420014        	  2624: 	CMPI.w	#20,d2			; compare with max + 2
00:0000B55E 65F2            	  2625: 	BCS.s		check_hi_loop		; loop if more high scores to do
                            	  2626: 
                            	  2627: 							; else change to the other player
                            	  2628: check_hi_next
00:0000B560 CB4E            	  2629: 	EXG		a5,a6				; swap the players
00:0000B562 0A2B00010018    	  2630: 	EORI.b	#1,player_idx(a3)		; toggle the player index
00:0000B568 67E0            	  2631: 	BEQ.s		check_hi_player		; loop if more players to do
                            	  2632: 
00:0000B56A 102D0083        	  2633: 	MOVE.b	high_off(a5),d0		; get player 2's highscore flag
00:0000B56E 6B14            	  2634: 	BMI.s		exit_hi_chk			; if not entering a high score go clear the
                            	  2635: 							; player count and exit
                            	  2636: 
00:0000B570 B02E0083        	  2637: 	CMP.b		high_off(a6),d0		; compare with the player 1 highscore flag
00:0000B574 650E            	  2638: 	BCS.s		exit_hi_chk			; if player 2's position < player 1's position
                            	  2639: 							; just exit
                            	  2640: 
00:0000B576 5600            	  2641: 	ADDQ.b	#3,d0				; else increment player 2's position to the
                            	  2642: 							; next entry
00:0000B578 0C00001E        	  2643: 	CMPI.b	#$1E,d0			; compare the result with max + 1
00:0000B57C 6502            	  2644: 	BCS.s		save_hi_index		; if less go save the new player 1 index
                            	  2645: 
00:0000B57E 70FF            	  2646: 	MOVEQ		#-1,d0			; else reset player 2's highscore flag
                            	  2647: save_hi_index
00:0000B580 1B400083        	  2648: 	MOVE.b	d0,high_off(a5)		; save player 2's highscore flag
                            	  2649: exit_hi_chk
00:0000B584 7000            	  2650: 	MOVEQ		#0,d0				; clear the longword
00:0000B586 1740001A        	  2651: 	MOVE.b	d0,num_players(a3)	; clear the number of players in the game
00:0000B58A 17400020        	  2652: 	MOVE.b	d0,hi_char(a3)		; clear the input character index
                            	  2653: exit_check_hiscores
00:0000B58E 4E75            	  2654: 	RTS
                            	  2655: 
                            	  2656: ; insert a new high score into the high score table. the index is in d2.w
                            	  2657: 
                            	  2658: insert_hiscore:
00:0000B590 7612            	  2659: 	MOVEQ		#18,d3			; index to the last high score
00:0000B592 781B            	  2660: 	MOVEQ		#27,d4			; index to the last high score initials
                            	  2661: insert_loop
00:0000B594 B443            	  2662: 	CMP.w		d3,d2				; compare the current high score with the insert
                            	  2663: 							; point
00:0000B596 671E            	  2664: 	BEQ.s		exit_insert_loop		; if there exit the loop
                            	  2665: 
00:0000B598 37B330253027    	  2666: 	MOVE.w	hiscores-2(a3,d3.w),hiscores(a3,d3.w)
                            	  2667: 							; copy the (n-1)th high score to this one
00:0000B59E 17B34038403B    	  2668: 	MOVE.b	hinames-3(a3,d4.w),hinames(a3,d4.w)
                            	  2669: 							; copy the (n-1)th high score name first byte
00:0000B5A4 17B34039403C    	  2670: 	MOVE.b	hinames-2(a3,d4.w),hinames+1(a3,d4.w)
                            	  2671: 							; copy the (n-1)th high score name second byte
00:0000B5AA 17B3403A403D    	  2672: 	MOVE.b	hinames-1(a3,d4.w),hinames+2(a3,d4.w)
                            	  2673: 							; copy the (n-1)th high score name third byte
                            	  2674: 
00:0000B5B0 5543            	  2675: 	SUBQ.w	#2,d3				; decrement the index to the previous score
00:0000B5B2 5744            	  2676: 	SUBQ.w	#3,d4				; decrement the index to the previous initials
00:0000B5B4 66DE            	  2677: 	BNE.s		insert_loop			; loop for the next high score
                            	  2678: 
                            	  2679: exit_insert_loop
00:0000B5B6 1B440083        	  2680: 	MOVE.b	d4,high_off(a5)		; save the player highscore flag
00:0000B5BA 37803027        	  2681: 	MOVE.w	d0,hiscores(a3,d3.w)	; copy the player score to this one
00:0000B5BE 17BC000B403B    	  2682: 	MOVE.b	#$0B,hinames(a3,d4.w)	; make the high score name first byte "A"
00:0000B5C4 4233403C        	  2683: 	CLR.b		hinames+1(a3,d4.w)	; make the high score name second byte " "
00:0000B5C8 4233403D        	  2684: 	CLR.b		hinames+2(a3,d4.w)	; make the high score name third byte " "
                            	  2685: 
00:0000B5CC 177C00F00059    	  2686: 	MOVE.b	#$F0,game_count(a3)	; set the game counter high byte, high score
                            	  2687: 							; entry timeout
                            	  2688: 
00:0000B5D2 608C            	  2689: 	BRA.s		check_hi_next		; loop for the other player
                            	  2690: 
                            	  2691: 
                            	  2692: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2693: ;
                            	  2694: ; calculate the angle given the delta x,y. the delta is calculated by subtracting the
                            	  2695: ; source x,y co-ordinates from the target x,y co-ordinates. the angle is returned in
                            	  2696: ; d0.b with $00 being 3 o'clock
                            	  2697: ;
                            	  2698: ; d1.w = delta x = target x - source x
                            	  2699: ; d2.w = delta y = target y - source y
                            	  2700: 
                            	  2701: get_atn:
00:0000B5D4 4A42            	  2702: 	TST.w		d2				; test the delta y
00:0000B5D6 6A08            	  2703: 	BPL.s		atn_semi			; if +ve skip the delta y negate
                            	  2704: 
00:0000B5D8 4442            	  2705: 	NEG.w		d2				; else make delta y positive
00:0000B5DA 6104            	  2706: 	BSR.s		atn_semi			; get arctan(y/x) for the semicircle
00:0000B5DC 4400            	  2707: 	NEG.b		d0				; negate the result
00:0000B5DE 4E75            	  2708: 	RTS
                            	  2709: 
                            	  2710: ; get arctan(y/x) for the semicircle
                            	  2711: 
                            	  2712: atn_semi:
00:0000B5E0 4A41            	  2713: 	TST.w		d1				; test the delta x
00:0000B5E2 6A0C            	  2714: 	BPL.s		atn_quad			; if +ve skip the delta x negate
                            	  2715: 
00:0000B5E4 4441            	  2716: 	NEG.w		d1				; else make delta x positive
00:0000B5E6 6108            	  2717: 	BSR.s		atn_quad			; get arctan(y/x) or arctan(x/y)
00:0000B5E8 0A000080        	  2718: 	EORI.b	#$80,d0			; reflect 180 degrees
00:0000B5EC 4400            	  2719: 	NEG.b		d0				; negate the result
00:0000B5EE 4E75            	  2720: 	RTS
                            	  2721: 
                            	  2722: 
                            	  2723: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2724: ;
                            	  2725: ; get arctan(y/x) or arctan(x/y) for one quadrant.
                            	  2726: 
                            	  2727: atn_quad:
00:0000B5F0 B441            	  2728: 	CMP.w		d1,d2				; compare y with x
00:0000B5F2 650C            	  2729: 	BCS.s		atn_eight			; if x > y get arctan(y/x) from the table
                            	  2730: 							; and return
                            	  2731: 
00:0000B5F4 C342            	  2732: 	EXG		d1,d2				; else swap x,y
00:0000B5F6 6108            	  2733: 	BSR.s		atn_eight			; get arctan(x/y) from the table
00:0000B5F8 04000040        	  2734: 	SUBI.b	#$40,d0			; reflect the quadrant
00:0000B5FC 4400            	  2735: 	NEG.b		d0				; and negate the result
00:0000B5FE 4E75            	  2736: 	RTS
                            	  2737: 
                            	  2738: 
                            	  2739: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2740: ;
                            	  2741: ; divide d2.w by d1.w, the six bit result in d0.w is then used to index the ATN()
                            	  2742: ; table to get the result for this octant. (is that the right word for one eighth
                            	  2743: ; of a circle?)
                            	  2744: 
                            	  2745: atn_eight:
00:0000B600 7000            	  2746: 	MOVEQ		#0,d0				; clear the result
00:0000B602 7E05            	  2747: 	MOVEQ		#6-1,d7			; set the bit count
                            	  2748: loop_atn
00:0000B604 D442            	  2749: 	ADD.w		d2,d2				; shift the dividend
00:0000B606 3602            	  2750: 	MOVE.w	d2,d3				; copy the dividend
00:0000B608 9641            	  2751: 	SUB.w		d1,d3				; compare it with the divisor
00:0000B60A 6502            	  2752: 	BCS.s		skip_sub			; if the dividend < the divisor skip the
                            	  2753: 							; subtract
                            	  2754: 
00:0000B60C 9441            	  2755: 	SUB.w		d1,d2				; else subtract the divisor
                            	  2756: skip_sub
00:0000B60E D100            	  2757: 	ADDX.b	d0,d0				; shift a bit into the result
00:0000B610 51CFFFF2        	  2758: 	DBF		d7,loop_atn			; loop if more to do
                            	  2759: 
00:0000B614 0200003F        	  2760: 	ANDI.b	#$3F,d0			; mask the result to $0000 to $003F
00:0000B618 103B0004        	  2761: 	MOVE.b	atn_tab(pc,d0.w),d0	; get the arctan from the table
00:0000B61C 4E75            	  2762: 	RTS
                            	  2763: 
                            	  2764: 
                            	  2765: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2766: ;
                            	  2767: ; arctangent table. returns the effective angle of the dx/dy ratio for scaled values
                            	  2768: ; of dx/dy of up to 0.984375 or 63/64ths. this is only 1/8th of a full circle but it
                            	  2769: ; is easy to rotate and reflect these values to cover the other 7/8ths.
                            	  2770: 
                            	  2771: atn_tab
00:0000B61E 20              	  2772: 	dc.b	$20,$20,$1F,$1F,$1F,$1E,$1E,$1E,$1D,$1D,$1C,$1C,$1C,$1B,$1B,$1A
00:0000B61F 20
00:0000B620 1F
00:0000B621 1F
00:0000B622 1F
00:0000B623 1E
00:0000B624 1E
00:0000B625 1E
00:0000B626 1D
00:0000B627 1D
00:0000B628 1C
00:0000B629 1C
00:0000B62A 1C
00:0000B62B 1B
00:0000B62C 1B
00:0000B62D 1A
00:0000B62E 1A              	  2773: 	dc.b	$1A,$1A,$19,$19,$18,$18,$17,$17,$17,$16,$16,$15,$15,$14,$14,$13
00:0000B62F 1A
00:0000B630 19
00:0000B631 19
00:0000B632 18
00:0000B633 18
00:0000B634 17
00:0000B635 17
00:0000B636 17
00:0000B637 16
00:0000B638 16
00:0000B639 15
00:0000B63A 15
00:0000B63B 14
00:0000B63C 14
00:0000B63D 13
00:0000B63E 13              	  2774: 	dc.b	$13,$12,$12,$11,$11,$10,$0F,$0F,$0E,$0E,$0D,$0D,$0C,$0B,$0B,$0A
00:0000B63F 12
00:0000B640 12
00:0000B641 11
00:0000B642 11
00:0000B643 10
00:0000B644 0F
00:0000B645 0F
00:0000B646 0E
00:0000B647 0E
00:0000B648 0D
00:0000B649 0D
00:0000B64A 0C
00:0000B64B 0B
00:0000B64C 0B
00:0000B64D 0A
00:0000B64E 0A              	  2775: 	dc.b	$0A,$09,$08,$08,$07,$07,$06,$05,$05,$04,$03,$03,$02,$02,$01,$00
00:0000B64F 09
00:0000B650 08
00:0000B651 08
00:0000B652 07
00:0000B653 07
00:0000B654 06
00:0000B655 05
00:0000B656 05
00:0000B657 04
00:0000B658 03
00:0000B659 03
00:0000B65A 02
00:0000B65B 02
00:0000B65C 01
00:0000B65D 00
                            	  2776: 
                            	  2777: 
                            	  2778: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2779: ;
                            	  2780: ; output a number as a leading zero suppressed character string
                            	  2781: ;
                            	  2782: ; a1 = number address
                            	  2783: ; d7 = number byte count
                            	  2784: 
                            	  2785: output_number:
00:0000B65E 5347            	  2786: 	SUBQ.w	#1,d7				; adjust for the loop type
                            	  2787: output_number_loop
00:0000B660 1211            	  2788: 	MOVE.b	(a1),d1			; get a byte
00:0000B662 E809            	  2789: 	LSR.b		#4,d1				; shift the high nibble to the low nibble
00:0000B664 61000130        	  2790: 	BSR		add_sup_hex_chr		; add a leading zero suppressed character
00:0000B668 4A47            	  2791: 	TST.w		d7				; test the byte count
00:0000B66A 6604            	  2792: 	BNE.s		zero_suppress		; if this isn't the last byte skip the zero
                            	  2793: 							; suppress clear
                            	  2794: 
00:0000B66C 422B0016        	  2795: 	CLR.b		suppress_0(a3)		; clear the zero suppress for the last digit
                            	  2796: zero_suppress
00:0000B670 1219            	  2797: 	MOVE.b	(a1)+,d1			; get a byte and increment the pointer
00:0000B672 61000122        	  2798: 	BSR		add_sup_hex_chr		; add a leading zero suppressed character
00:0000B676 51CFFFE8        	  2799: 	DBF		d7,output_number_loop	; decrement count and loop if more to do
                            	  2800: 
00:0000B67A 4E75            	  2801: 	RTS
                            	  2802: 
                            	  2803: 
                            	  2804: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2805: ;
                            	  2806: ; get COS(d0) in d0. d0 is an eight bit value representing a full circle with the
                            	  2807: ; value increasing as you turn widdershins
                            	  2808: 
                            	  2809: cos_d0
00:0000B67C 06000040        	  2810: 	ADDI.b	#$40,d0			; add 1/4 rotation
                            	  2811: 
                            	  2812: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2813: ;
                            	  2814: ; get SIN(d0) in d0. d0 is an eight bit value representing a full circle with the
                            	  2815: ; value increasing as you turn widdershins
                            	  2816: 
                            	  2817: sin_d0
00:0000B680 024000FF        	  2818: 	ANDI.w	#$00FF,d0			; mask one full circle
00:0000B684 4A00            	  2819: 	TST.b		d0				; test angle sign
00:0000B686 6A06            	  2820: 	BPL.s		cossin_d0			; if +ve just get SIN/COS and return
                            	  2821: 
00:0000B688 6104            	  2822: 	BSR.s		cossin_d0			; else get SIN/COS
00:0000B68A 4440            	  2823: 	NEG.w		d0				; now do twos complement
00:0000B68C 4E75            	  2824: 	RTS
                            	  2825: 
                            	  2826: ; get d0 from SIN/COS table
                            	  2827: 
                            	  2828: cossin_d0
00:0000B68E D000            	  2829: 	ADD.b		d0,d0				; ; 2 bytes per word value
00:0000B690 6A02            	  2830: 	BPL.s		a_was_less			; branch if the angle < 1/4 circle
                            	  2831: 
00:0000B692 4400            	  2832: 	NEG.b		d0				; wrap $82 to $FE to $7E to $02
                            	  2833: a_was_less
00:0000B694 303B0004        	  2834: 	MOVE.w	sin_cos(pc,d0.w),d0	; get the SIN/COS value
00:0000B698 4E75            	  2835: 	RTS
                            	  2836: 
                            	  2837: 
                            	  2838: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2839: ;
                            	  2840: ; SIN/COS table, returns values between $0000 and $7FFF. the last value should be
                            	  2841: ; $8000 but that can cause an overflow in the word length calculations and it's
                            	  2842: ; easier to fudge the table a bit. no one will ever notice.
                            	  2843: 
                            	  2844: sin_cos
00:0000B69A 0000            	  2845: 	dc.w	$0000,$0324,$0648,$096B,$0C8C,$0FAB,$12C8,$15E2
00:0000B69C 0324
00:0000B69E 0648
00:0000B6A0 096B
00:0000B6A2 0C8C
00:0000B6A4 0FAB
00:0000B6A6 12C8
00:0000B6A8 15E2
00:0000B6AA 18F9            	  2846: 	dc.w	$18F9,$1C0C,$1F1A,$2224,$2528,$2827,$2B1F,$2E11
00:0000B6AC 1C0C
00:0000B6AE 1F1A
00:0000B6B0 2224
00:0000B6B2 2528
00:0000B6B4 2827
00:0000B6B6 2B1F
00:0000B6B8 2E11
00:0000B6BA 30FC            	  2847: 	dc.w	$30FC,$33DF,$36BA,$398D,$3C57,$3F17,$41CE,$447B
00:0000B6BC 33DF
00:0000B6BE 36BA
00:0000B6C0 398D
00:0000B6C2 3C57
00:0000B6C4 3F17
00:0000B6C6 41CE
00:0000B6C8 447B
00:0000B6CA 471D            	  2848: 	dc.w	$471D,$49B4,$4C40,$4EC0,$5134,$539B,$55F6,$5843
00:0000B6CC 49B4
00:0000B6CE 4C40
00:0000B6D0 4EC0
00:0000B6D2 5134
00:0000B6D4 539B
00:0000B6D6 55F6
00:0000B6D8 5843
00:0000B6DA 5A82            	  2849: 	dc.w	$5A82,$5CB4,$5ED7,$60EC,$62F2,$64E9,$66CF,$68A7
00:0000B6DC 5CB4
00:0000B6DE 5ED7
00:0000B6E0 60EC
00:0000B6E2 62F2
00:0000B6E4 64E9
00:0000B6E6 66CF
00:0000B6E8 68A7
00:0000B6EA 6A6E            	  2850: 	dc.w	$6A6E,$6C24,$6DCA,$6F5F,$70E3,$7255,$73B6,$7505
00:0000B6EC 6C24
00:0000B6EE 6DCA
00:0000B6F0 6F5F
00:0000B6F2 70E3
00:0000B6F4 7255
00:0000B6F6 73B6
00:0000B6F8 7505
00:0000B6FA 7642            	  2851: 	dc.w	$7642,$776C,$7885,$798A,$7A7D,$7B5D,$7C2A,$7CE4
00:0000B6FC 776C
00:0000B6FE 7885
00:0000B700 798A
00:0000B702 7A7D
00:0000B704 7B5D
00:0000B706 7C2A
00:0000B708 7CE4
00:0000B70A 7D8A            	  2852: 	dc.w	$7D8A,$7E1E,$7E9D,$7F0A,$7F62,$7FA7,$7FD9,$7FF6
00:0000B70C 7E1E
00:0000B70E 7E9D
00:0000B710 7F0A
00:0000B712 7F62
00:0000B714 7FA7
00:0000B716 7FD9
00:0000B718 7FF6
00:0000B71A 7FFF            	  2853: 	dc.w	$7FFF
                            	  2854: 
                            	  2855: 
                            	  2856: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2857: ;
                            	  2858: ; add message d1 to the display list
                            	  2859: 
                            	  2860: add_message:
00:0000B71C 36BC1000        	  2861: 	MOVE.w	#$1000,glob_scale(a3)	; set the global scale
                            	  2862: 
00:0000B720 D241            	  2863: 	ADD.w		d1,d1				; make into a word index
00:0000B722 3F01            	  2864: 	MOVE.w	d1,-(sp)			; save the index
                            	  2865: 
00:0000B724 D241            	  2866: 	ADD.w		d1,d1				; make into a word pair index
00:0000B726 41FA193A        	  2867: 	LEA		mess_origin(pc),a0	; point to the mesage co-ordinate table
00:0000B72A 34301002        	  2868: 	MOVE.w	2(a0,d1.w),d2		; get the message y co-ordinate
00:0000B72E 32301000        	  2869: 	MOVE.w	(a0,d1.w),d1		; get the message x co-ordinate
00:0000B732 6100009E        	  2870: 	BSR		add_coords			; add co-ordinate pair in d1,d2 to the list as
                            	  2871: 							; a draw command
                            	  2872: 
00:0000B736 323C7000        	  2873: 	MOVE.w	#REL7,d1			; make a $7000,$0000 command
00:0000B73A 610000B0        	  2874: 	BSR		add_single			; add (d1)00,0000 to the vector list
                            	  2875: 
00:0000B73E 7003            	  2876: 	MOVEQ		#$03,d0			; set the mask for the language bits
00:0000B740 206B000E        	  2877: 	MOVEA.l	switch_addr(a3),a0	; point to the switch
00:0000B744 C010            	  2878: 	AND.b		(a0),d0			; get and mask the switch bits
00:0000B746 D040            	  2879: 	ADD.w		d0,d0				; make into a word pointer
                            	  2880: 
00:0000B748 41FA1938        	  2881: 	LEA		mess_table(pc),a0		; point to the mesage language table
00:0000B74C 30300000        	  2882: 	MOVE.w	(a0,d0.w),d0		; get the offset to the messages
00:0000B750 41F00000        	  2883: 	LEA		(a0,d0.w),a0		; get the pointer to the messages
                            	  2884: 
00:0000B754 321F            	  2885: 	MOVE.w	(sp)+,d1			; restore the message index
                            	  2886: 
00:0000B756 32301000        	  2887: 	MOVE.w	(a0,d1.w),d1		; get the offset to the message
00:0000B75A 41F01000        	  2888: 	LEA		(a0,d1.w),a0		; get the pointer to the message
00:0000B75E 43FA18A4        	  2889: 	LEA		char_set(pc),a1		; get the pointer to the character JSRL table
00:0000B762 7000            	  2890: 	MOVEQ		#0,d0				; clear the longword
                            	  2891: add_char_loop
00:0000B764 1018            	  2892: 	MOVE.b	(a0)+,d0			; get the next character
00:0000B766 671A            	  2893: 	BEQ.s		exit_add_message		; if null just exit
                            	  2894: 
                            	  2895: ; convert the character and add it to the vector list
                            	  2896: 
00:0000B768 903C0020        	  2897: 	SUB.b		#' ',d0			; subtract [SPACE]
00:0000B76C 670C            	  2898: 	BEQ.s		add_the_char		; if it was [SPACE] go add it
                            	  2899: 
00:0000B76E 903C000F        	  2900: 	SUB.b		#15,d0			; convert a number
00:0000B772 0C00000B        	  2901: 	CMPI.b	#11,d0			; compare with converted "9"+1
00:0000B776 6502            	  2902: 	BCS.s		add_the_char		; if it was <="9" go add it
                            	  2903: 
00:0000B778 5F00            	  2904: 	SUBQ.b	#7,d0				; else convert "A" to "Z"
                            	  2905: add_the_char
00:0000B77A D000            	  2906: 	ADD.b		d0,d0				; ; 2
00:0000B77C 38F10000        	  2907: 	MOVE.w	(a1,d0.w),(a4)+		; copy the JSRL to the vector list
00:0000B780 60E2            	  2908: 	BRA.s		add_char_loop		; loop for next
                            	  2909: 
                            	  2910: exit_add_message
00:0000B782 4E75            	  2911: 	RTS
                            	  2912: 
                            	  2913: 
                            	  2914: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2915: ;
                            	  2916: ; timer interrupt. the timer interrupt should be triggered every 16ms
                            	  2917: 
                            	  2918: timer_interrupt
00:0000B784 522B001D        	  2919: 	ADDQ.b	#1,sixteen_ms(a3)		; increment the 16ms counter
00:0000B788 4E73            	  2920: 	RTE
                            	  2921: 
                            	  2922: 
                            	  2923: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2924: ;
                            	  2925: ; add "PLAYER x" to the vector list
                            	  2926: 
                            	  2927: player_x:
00:0000B78A 7201            	  2928: 	MOVEQ		#1,d1				; message 1 - "PLAYER "
00:0000B78C 618E            	  2929: 	BSR		add_message			; add message d1 to the display list
                            	  2930: player_n
00:0000B78E 7201            	  2931: 	MOVEQ		#1,d1				; make 0,1 into 1,2
00:0000B790 D22B0018        	  2932: 	ADD.b		player_idx(a3),d1		; add the player index
00:0000B794 600C            	  2933: 	BRA.s		add_hex_chr			; write a hex character to the vector list
                            	  2934: 							; and return
                            	  2935: 
                            	  2936: 
                            	  2937: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2938: ;
                            	  2939: ; if suppress_0 <> 0 write a leading zero suppressed hex character to the vector list
                            	  2940: 
                            	  2941: add_sup_hex_chr
00:0000B796 4A2B0016        	  2942: 	TST.b		suppress_0(a3)		; test the leading zero suppressed flag
00:0000B79A 6706            	  2943: 	BEQ.s		add_hex_chr			; if not suppressed go write a hex character
                            	  2944: 							; to the vector list
                            	  2945: 
                            	  2946: ; if supressed write a [SPACE] instead of a "0"
                            	  2947: 
00:0000B79C 700F            	  2948: 	MOVEQ		#$0F,d0			; set the nibble mask
00:0000B79E C240            	  2949: 	AND.w		d0,d1				; mask the low nibble
00:0000B7A0 670A            	  2950: 	BEQ.s		add_sup_zero		; if it is zero go write a space
                            	  2951: 
                            	  2952: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2953: ;
                            	  2954: ; write a hex character d1 to the vector list
                            	  2955: 
                            	  2956: add_hex_chr
00:0000B7A2 C27C000F        	  2957: 	AND.w		#$0F,d1			; mask the low nibble
00:0000B7A6 5241            	  2958: 	ADDQ.w	#1,d1				; add 1 to pass the [SPACE] character
00:0000B7A8 422B0016        	  2959: 	CLR.b		suppress_0(a3)		; clear the leading zero suppressed flag
                            	  2960: add_sup_zero
00:0000B7AC D241            	  2961: 	ADD.w		d1,d1				; ; 2, bytes per character
00:0000B7AE 2F08            	  2962: 	MOVE.l	a0,-(sp)			; save a0
00:0000B7B0 41FA1852        	  2963: 	LEA		char_set(pc),a0		; point to the character JSRL table
00:0000B7B4 38F01000        	  2964: 	MOVE.w	(a0,d1.w),(a4)+		; copy the character JSRL to the vector list
00:0000B7B8 205F            	  2965: 	MOVE.l	(sp)+,a0			; restore a0
                            	  2966: 
00:0000B7BA 4E75            	  2967: 	RTS
                            	  2968: 
                            	  2969: 
                            	  2970: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2971: ;
                            	  2972: ; convert the a1 address and add it to the vector list as a vector subroutine call
                            	  2973: 
                            	  2974: add_address:
00:0000B7BC 41FA022A        	  2975: 	LEA		vector(pc),a0		; point to the vector memory
00:0000B7C0 93C8            	  2976: 	SUBA.l	a0,a1				; convert the pointer to an offset
00:0000B7C2 2209            	  2977: 	MOVE.l	a1,d1				; copy the result
00:0000B7C4 E249            	  2978: 	LSR.w		#1,d1				; / 2
00:0000B7C6 C27C0FFF        	  2979: 	AND.w		#$0FFF,d1			; mask the address bits
00:0000B7CA 0041C000        	  2980: 	ORI.w		#JSRL,d1			; OR with vector subroutine call
00:0000B7CE 38C1            	  2981: 	MOVE.w	d1,(a4)+			; copy to the vector list
00:0000B7D0 4E75            	  2982: 	RTS
                            	  2983: 
                            	  2984: 
                            	  2985: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  2986: ;
                            	  2987: ; add 4 ; the co-ordinate pair in d1,d2 to the list as a draw command
                            	  2988: 
                            	  2989: add_coords:
00:0000B7D2 7002            	  2990: 	MOVEQ		#2,d0				; set shift count
00:0000B7D4 E161            	  2991: 	ASL.w		d0,d1				; x co-ordinate ; 4
00:0000B7D6 E162            	  2992: 	ASL.w		d0,d2				; y co-ordinate ; 4
                            	  2993: 
00:0000B7D8 303C0FFC        	  2994: 	MOVE.w	#$0FFC,d0			; set the co-ordinate mask
00:0000B7DC C240            	  2995: 	AND.w		d0,d1				; mask the x co-ordinate
00:0000B7DE C440            	  2996: 	AND.w		d0,d2				; mask the y co-ordinate
                            	  2997: 
00:0000B7E0 0042A000        	  2998: 	ORI.w		#DRAW,d2			; OR in the draw command
00:0000B7E4 8253            	  2999: 	OR.w		glob_scale(a3),d1		; OR in the global scale
                            	  3000: 
00:0000B7E6 38C2            	  3001: 	MOVE.w	d2,(a4)+			; save the command/y co-ordinate to the list
00:0000B7E8 38C1            	  3002: 	MOVE.w	d1,(a4)+			; save the scale/x co-ordinate to the list
00:0000B7EA 4E75            	  3003: 	RTS
                            	  3004: 
                            	  3005: 
                            	  3006: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3007: ;
                            	  3008: ; add (d1)00,0000 to the vector list
                            	  3009: 
                            	  3010: add_single
00:0000B7EC 7400            	  3011: 	MOVEQ		#0,d2				; clear the second word
                            	  3012: 
                            	  3013: 
                            	  3014: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3015: ;
                            	  3016: ; add (A)00,(X)00 to the vector list
                            	  3017: 
                            	  3018: add_pair
00:0000B7EE 38C1            	  3019: 	MOVE.w	d1,(a4)+			; save the first word to the vector list
00:0000B7F0 38C2            	  3020: 	MOVE.w	d2,(a4)+			; save the second word to the vector list
00:0000B7F2 4E75            	  3021: 	RTS
                            	  3022: 
                            	  3023: 
                            	  3024: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3025: ;
                            	  3026: ; check the [F2], [F3] and [F4] keys. set the screen size to 640 x 480, 800 x 600 or
                            	  3027: ; 1024 x 768 if the corresponding key has been pressed
                            	  3028: 
                            	  3029: s_controls
                            	  3030: ;	MOVE.l	#$71007273,d1		; [F2], [], [F3] and [F4] keys
                            	  3031: ;	MOVEQ		#19,d0			; check for keypress
                            	  3032: ;	TRAP		#15
                            	  3033: 
                            	  3034: ;	MOVEQ		#33,d0			; set/get output window size
                            	  3035: 
                            	  3036: ;	MOVE.l	d1,d2				; copy result
                            	  3037: ;	BEQ.s		notscreen			; skip screen size if no F key
                            	  3038: 
                            	  3039: ;	MOVE.l	#$028001E0,d1		; set 640 x 480
                            	  3040: ;	TST.l		d2				; test result
                            	  3041: ;	BMI.s		setscreen			; if F2 go set window size
                            	  3042: 
                            	  3043: ;	MOVE.l	#$03200258,d1		; set 800 x 600
                            	  3044: ;	TST.w		d2				; test result
                            	  3045: ;	BMI.s		setscreen			; if F3 go set window size
                            	  3046: 
                            	  3047: 							; else was F4 so ..
                            	  3048: ;	MOVE.l	#$04000300,d1		; set 1024 x 768
                            	  3049: setscreen
                            	  3050: ;	CMP.l		scr_x(a3),d1		; compare with current screen size
                            	  3051: ;	BEQ.s		notscreen			; if already set skip setting it now
                            	  3052: 
                            	  3053: ;	TRAP		#15
                            	  3054: 
                            	  3055: notscreen
                            	  3056: ;	MOVEQ		#0,d1				; get the current window size
                            	  3057: ;	TRAP		#15
                            	  3058: 
00:0000B7F4 223C03200258    	  3059: 	move.l #$03200258,d1		; always 800x600
00:0000B7FA 27410006        	  3060: 	move.l d1,scr_x(a3)			; save the screen x and y size
00:0000B7FE 4E75            	  3061: 	rts
                            	  3062: 
                            	  3063: 
                            	  3064: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3065: ;
                            	  3066: ; setup stuff.
                            	  3067: 
                            	  3068: Initialise:
00:0000B800 7200            	  3069: 	moveq	#0,d1					; turn off echo
00:0000B802 700C            	  3070: 	moveq	#12,d0				; keyboard echo
00:0000B804 4E4F            	  3071: 	trap #15
                            	  3072: 
00:0000B806 323CFF00        	  3073: 	move.w #$FF00,d1		; clear screen
00:0000B80A 700B            	  3074: 	moveq #11,d0				; position cursor
00:0000B80C 4E4F            	  3075: 	trap #15
                            	  3076: 
00:0000B80E 7211            	  3077: 	moveq #17,d1				; enable double buffering
00:0000B810 705C            	  3078: 	moveq	#92,d0				; set draw mode
00:0000B812 4E4F            	  3079: 	trap #15
                            	  3080: 
00:0000B814 720A            	  3081: 	moveq #10,d1				; OR mode drawing, this helps on two ways.
                            	  3082: 							; first it emulates a vector display where
                            	  3083: 							; the vectors that cross can bright up the
                            	  3084: 							; intersection and second it means we can
                            	  3085: 							; forget depth sorting of objects
00:0000B816 705C            	  3086: 	moveq #92,d0				; set draw mode
00:0000B818 4E4F            	  3087: 	trap #15
                            	  3088: 
00:0000B81A 47FA1D1B        	  3089: 	lea	variables(pc),a3	; get the pointer to the variables base
00:0000B81E 4BEB00F3        	  3090: 	lea player_1(a3),a5		; get the pointer to player one's variables
00:0000B822 4DEB01F7        	  3091: 	lea player_2(a3),a6		; get the pointer to player two's variables
                            	  3092: 
                            	  3093: 										; clear all the variable space
00:0000B826 7000            	  3094: 	moveq #0,d0				; clear the longword
00:0000B828 41EB0012        	  3095: 	lea hiscore_y(a3),a0		; get the start address
00:0000B82C 43EB027B        	  3096: 	lea p_2_end(a3),a1			; get the end address
                            	  3097: clear_loop
00:0000B830 30C0            	  3098: 	move.w d0,(a0)+			; clear the word
00:0000B832 B1C9            	  3099: 	cmpa.l a1,a0				; compare the addresses
00:0000B834 66FA            	  3100: 	bne.s clear_loop		; if not at end loop
                            	  3101: 
00:0000B836 7008            	  3102: 	moveq #8,d0					; get the time in 1/100 ths seconds
00:0000B838 4E4F            	  3103: 	trap #15
                            	  3104: 
00:0000B83A 0A81DEADBEEF    	  3105: 	eori.l	#$DEADBEEF,d1		; EOR with the initial PRNG seed, this must
                            	  3106: 													; result in any value but zero
00:0000B840 4EB9000022AA    	  3107: 	jsr InitRand
00:0000B846 2741000A        	  3108: 	move.l	d1,PRNlword(a3)		; save the initial PRNG seed
                            	  3109: 
00:0000B84A 7203            	  3110: 	moveq #3,d1					; get the switches address
00:0000B84C 7020            	  3111: 	moveq #32,d0				; simulator hardware
00:0000B84E 4E4F            	  3112: 	trap #15
                            	  3113: 
00:0000B850 2741000E        	  3114: 	move.l d1,switch_addr(a3)	; save the switches address
                            	  3115: 
                            	  3116: 	;LEA		timer_interrupt(pc),a0	; get the timer interrupt routine address
                            	  3117: 	;MOVE.l	a0,$64.w			; save the timer interrupt as interrupt 1
                            	  3118: 
                            	  3119: 	;MOVEQ		#6,d1				; set auto IRQ
                            	  3120: 	;MOVEQ		#$81,d2			; enable IRQ 1
                            	  3121: 	;MOVEQ		#16,d3			; set the time in ms
                            	  3122: 	;MOVEQ		#32,d0			; set simulator hardware
                            	  3123: 	;TRAP		#15
                            	  3124: 
                            	  3125: 	;MOVEQ		#5,d1				; enable exceptions
                            	  3126: 	;MOVEQ		#32,d0			; set simulator hardware
                            	  3127: 	;TRAP		#15
                            	  3128: 
00:0000B854 49FA0192        	  3129: 	lea vector(pc),a4			; get the pointer to the vector list RAM
00:0000B858 38BCB000        	  3130: 	move.w #HALT,(a4)			; add HALT to the vector list
                            	  3131: 
00:0000B85C 61001B4D        	  3132: 	bsr sound_init				; initialise the sounds
                            	  3133: 
00:0000B860 70FF            	  3134: 	moveq #-1,d0					; flag high score done
00:0000B862 17400176        	  3135: 	move.b d0,p1_high(a3)	; save the player 1 highscore flag
00:0000B866 1740027A        	  3136: 	move.b d0,p2_high(a3)	; save the player 2 highscore flag
                            	  3137: 
00:0000B86A 43FA1CBE        	  3138: 	lea filename(pc),a1		; point to the highscore filename
00:0000B86E 7033            	  3139: 	moveq	#51,d0					; open existing file
00:0000B870 4E4F            	  3140: 	trap #15
                            	  3141: 
00:0000B872 4A40            	  3142: 	tst.w d0							; check for errors
00:0000B874 6706            	  3143: 	beq.s read_hi					; if no error go read the file
                            	  3144: 
00:0000B876 0C400003        	  3145: 	cmpi.w #3,d0					; compare with read only
00:0000B87A 660A            	  3146: 	bne.s	close_all_2			; if not read only go close all files
                            	  3147: 
                            	  3148: read_hi
00:0000B87C 43EB0027        	  3149: 	lea hiscores(a3),a1		; point to the highscore tables
00:0000B880 7432            	  3150: 	moveq	#50,d2					; set the table length
00:0000B882 7035            	  3151: 	moveq	#53,d0					; read file
00:0000B884 4E4F            	  3152: 	trap #15
                            	  3153: 
                            	  3154: close_all_2
00:0000B886 7032            	  3155: 	moveq #50,d0					; close all files
00:0000B888 4E4F            	  3156: 	trap #15
                            	  3157: 
00:0000B88A 4E75            	  3158: 	rts
                            	  3159: 
                            	  3160: 
                            	  3161: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3162: ;
                            	  3163: ; This is the code that generates the pseudo random sequence. A seed word located in
                            	  3164: ; PRNlword(a3) is loaded into a register before being operated on to generate the
                            	  3165: ; next number in the sequence. This number is then saved as the seed for the next
                            	  3166: ; time it's called.
                            	  3167: ;
                            	  3168: ; This code is adapted from the 32 bit version of RND(n) used in EhBASIC68. Taking
                            	  3169: ; the 19th next number is slower but helps to hide the shift and add nature of this
                            	  3170: ; generator as can be seen from analysing the output.
                            	  3171: 
                            	  3172: gen_prng:
00:0000B88C 2F01            	  3173: 	move.l d1,-(a7)
00:0000B88E 4EB900002314    	  3174: 	jsr RandGetNum
00:0000B894 2741000A        	  3175: 	move.l d1,PRNlword(a3)
00:0000B898 221F            	  3176: 	move.l (a7)+,d1
00:0000B89A 4E75            	  3177: 	rts
                            	  3178: 
                            	  3179: ;	MOVEM.l	d0-d2,-(sp)			; save d0, d1 and d2
                            	  3180: ;	MOVE.l	PRNlword(a3),d0		; get current seed longword
                            	  3181: ;	MOVEQ		#$AF-$100,d1		; set the EOR value
                            	  3182: ;	MOVEQ		#18,d2			; do this 19 times
                            	  3183: Ninc0
                            	  3184: ;	ADD.l		d0,d0				; shift left 1 bit
                            	  3185: ;	BCC.s		Ninc1				; if bit not set skip feedback
                            	  3186: 
                            	  3187: ;	EOR.b		d1,d0				; do Galois LFSR feedback
                            	  3188: Ninc1
                            	  3189: ;	DBF		d2,Ninc0			; loop
                            	  3190: 
                            	  3191: ;	MOVE.l	d0,PRNlword(a3)		; save back to seed longword
                            	  3192: ;	MOVEM.l	(sp)+,d0-d2			; restore d0, d1 and d2
                            	  3193: 
                            	  3194: ;	RTS
                            	  3195: 
                            	  3196: 
                            	  3197: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3198: ;
                            	  3199: ; vector generator subroutines. this code emulates the atari digital vector generator
                            	  3200: ; and truns the vector draw list into lines on the screen
                            	  3201: 
                            	  3202: ; vector subroutine return code. if a vector subroutine is called the address for this
                            	  3203: ; code is pushed on the stack
                            	  3204: 
                            	  3205: op_rtsvec:
00:0000B89C 285F            	  3206: 	MOVE.l	(sp)+,a4			; restore the vector pointer
                            	  3207: 
                            	  3208: ; evaluate the next vector command. the command is pointed to by (a4) and execution
                            	  3209: ; will continue until an RTSL or HALT command is encountered. this is a subset of the
                            	  3210: ; battlezone DVG command set
                            	  3211: 
                            	  3212: do_vector:
00:0000B89E 381C            	  3213: 	MOVE.w	(a4)+,d4			; get the vector opcode
00:0000B8A0 3004            	  3214: 	MOVE.w	d4,d0				; copy it
00:0000B8A2 ED58            	  3215: 	ROL.w		#6,d0				; shift opcode bits to b5-b2
00:0000B8A4 0240003C        	  3216: 	ANDI.w	#$003C,d0			; mask the opcode bits
00:0000B8A8 4EFB0076        	  3217: 	JMP		vector_base(pc,d0.w)	; go do the vector opcode
                            	  3218: 
                            	  3219: ; call vector subroutine, push the vector pointer and then the vector subroutine
                            	  3220: ; address as the return address then do jump to vector address
                            	  3221: 
                            	  3222: op_call
00:0000B8AC 2F0C            	  3223: 	MOVE.l	a4,-(sp)			; save the vector pointer
00:0000B8AE 487AFFEC        	  3224: 	PEA		op_rtsvec(pc)		; push vector return code as return address
                            	  3225: 
                            	  3226: ; jump to vector, the address is a thirteen bit address
                            	  3227: 
                            	  3228: op_jump
00:0000B8B2 C87C0FFF        	  3229: 	AND.w		#$0FFF,d4			; mask the address
00:0000B8B6 D844            	  3230: 	ADD.w		d4,d4				; make it a word address
00:0000B8B8 49FA012E        	  3231: 	LEA		vector(pc),a4		; reset the vector RAM pointer
00:0000B8BC 49F44000        	  3232: 	LEA		(a4,d4.w),a4		; calculate the new address
00:0000B8C0 60DC            	  3233: 	BRA.s		do_vector			; go do the next vector
                            	  3234: 
                            	  3235: ; relative vector routine. co-ordinates are ten bit with sign numbers
                            	  3236: 
                            	  3237: op_vctr
00:0000B8C2 3E3C07FF        	  3238: 	MOVE.w	#$07FF,d7			; set the co-ordinate and sign bits mask
00:0000B8C6 720A            	  3239: 	MOVEQ		#10,d1			; set the sign bit number
                            	  3240: 
00:0000B8C8 C847            	  3241: 	AND.w		d7,d4				; mask the y co-ordinate and sign
00:0000B8CA 0384            	  3242: 	BCLR.l	d1,d4				; test and clear the sign bit
00:0000B8CC 6702            	  3243: 	BEQ.s		no_neg_y11			; if positive skip the negate
                            	  3244: 
00:0000B8CE 4444            	  3245: 	NEG.w		d4				; else negate the y co-ordinate
                            	  3246: no_neg_y11
                            	  3247: 
00:0000B8D0 361C            	  3248: 	MOVE.w	(a4)+,d3			; get the second word
00:0000B8D2 3403            	  3249: 	MOVE.w	d3,d2				; copy the intensity
                            	  3250: 
00:0000B8D4 C647            	  3251: 	AND.w		d7,d3				; mask the x co-ordinate and sign
00:0000B8D6 0383            	  3252: 	BCLR.l	d1,d3				; test and clear the sign bit
00:0000B8D8 6702            	  3253: 	BEQ.s		no_neg_x11			; if positive skip the negate
                            	  3254: 
00:0000B8DA 4443            	  3255: 	NEG.w		d3				; else negate the x co-ordinate
                            	  3256: no_neg_x11
                            	  3257: 
00:0000B8DC E440            	  3258: 	ASR.w		#2,d0				; make the scale count from the masked JMP
00:0000B8DE 4440            	  3259: 	NEG.w		d0				; make negative
00:0000B8E0 D07C0009        	  3260: 	ADD.w		#9,d0				; make 9 - scale
                            	  3261: 
00:0000B8E4 E063            	  3262: 	ASR.w		d0,d3				; scale the x co-ordinate
00:0000B8E6 E064            	  3263: 	ASR.w		d0,d4				; scale the y co-ordinate
                            	  3264: 
00:0000B8E8 600000A2        	  3265: 	BRA		end_vector			; go do the end of the vector draw
                            	  3266: 
                            	  3267: ; set scale and position the beam
                            	  3268: 
                            	  3269: op_abs
00:0000B8EC 3E3C07FF        	  3270: 	MOVE.w	#$07FF,d7			; set the co-ordinate and sign bits mask
00:0000B8F0 720A            	  3271: 	MOVEQ		#10,d1			; set the sign bit number
                            	  3272: 
00:0000B8F2 C847            	  3273: 	AND.w		d7,d4				; mask the y co-ordinate and sign
00:0000B8F4 0384            	  3274: 	BCLR.l	d1,d4				; test and clear the sign bit
00:0000B8F6 6702            	  3275: 	BEQ.s		no_neg_y10			; if positive skip the negate
                            	  3276: 
00:0000B8F8 4444            	  3277: 	NEG.w		d4				; else negate the y co-ordinate
                            	  3278: no_neg_y10
                            	  3279: 
00:0000B8FA 361C            	  3280: 	MOVE.w	(a4)+,d3			; get the second word
00:0000B8FC 3403            	  3281: 	MOVE.w	d3,d2				; copy the scale
                            	  3282: 
00:0000B8FE C647            	  3283: 	AND.w		d7,d3				; mask the x co-ordinate and sign
00:0000B900 0383            	  3284: 	BCLR.l	d1,d3				; test and clear the sign bit
00:0000B902 6702            	  3285: 	BEQ.s		no_neg_x10			; if positive skip the negate
                            	  3286: 
00:0000B904 4443            	  3287: 	NEG.w		d3				; else negate the x co-ordinate
                            	  3288: no_neg_x10
                            	  3289: 
                            	  3290: ; now convert the scale so it is b15 = direction flag and the rest is the shift count
                            	  3291: 
00:0000B906 E95A            	  3292: 	ROL.w		#4,d2				; move the scale bits to bits 3 to 0
00:0000B908 0242000F        	  3293: 	ANDI.w	#$000F,d2			; mask the scale bits
00:0000B90C 08820003        	  3294: 	BCLR.l	#3,d2				; clear the top bit
00:0000B910 6706            	  3295: 	BEQ.s		not_right			; ship right shift adjust
                            	  3296: 
00:0000B912 4442            	  3297: 	NEG.w		d2				; make negative
00:0000B914 D47C8008        	  3298: 	ADD.w		#$8008,d2			; add offset and flag right shift
                            	  3299: not_right
00:0000B918 3682            	  3300: 	MOVE.w	d2,(a3)			; save the global scal, offset is zero	##
                            	  3301: ;##	MOVE.w	d2,vector_s(a3)		; save the global scale
                            	  3302: 
00:0000B91A 7056            	  3303: 	MOVEQ		#86,d0			; set move to x,y
00:0000B91C 6000009E        	  3304: 	BRA		vector_move			; go do the move
                            	  3305: 
                            	  3306: vector_base
00:0000B920 4E75            	  3307: 	RTS						; treat $0xxx as HALT, quit processing vectors
00:0000B922 4E71            	  3308: 	NOP						; filler
00:0000B924 6000FF9C        	  3309: 	BRA.w		op_vctr			; scale 1 relative long vector
00:0000B928 6000FF98        	  3310: 	BRA.w		op_vctr			; scale 2 relative long vector
00:0000B92C 6000FF94        	  3311: 	BRA.w		op_vctr			; scale 3 relative long vector
00:0000B930 6000FF90        	  3312: 	BRA.w		op_vctr			; scale 4 relative long vector
00:0000B934 6000FF8C        	  3313: 	BRA.w		op_vctr			; scale 5 relative long vector
00:0000B938 6000FF88        	  3314: 	BRA.w		op_vctr			; scale 6 relative long vector
00:0000B93C 6000FF84        	  3315: 	BRA.w		op_vctr			; scale 7 relative long vector
00:0000B940 6000FF80        	  3316: 	BRA.w		op_vctr			; scale 8 relative long vector
00:0000B944 6000FF7C        	  3317: 	BRA.w		op_vctr			; scale 9 relative long vector
00:0000B948 6000FFA2        	  3318: 	BRA.w		op_abs			; set scale and position beam
00:0000B94C 4E75            	  3319: 	RTS						; do HALT, quit processing vectors
00:0000B94E 4E71            	  3320: 	NOP						; filler
00:0000B950 6000FF5A        	  3321: 	BRA.w		op_call			; call vector subroutine
00:0000B954 4E75            	  3322: 	RTS						; return from vector subroutine
00:0000B956 4E71            	  3323: 	NOP						; filler
00:0000B958 6000FF58        	  3324: 	BRA.w		op_jump			; do vector jump
                            	  3325: ;##	BRA.w		op_short			; draw relative short vector
                            	  3326: 
                            	  3327: ; do relative short vector
                            	  3328: 
                            	  3329: op_short
00:0000B95C 3E04            	  3330: 	MOVE.w	d4,d7				; copy the opcode
00:0000B95E 02470808        	  3331: 	ANDI.w	#$0808,d7			; mask the scale bits	0000 x000 0000 y000
00:0000B962 E94F            	  3332: 	LSL.w		#4,d7				; shift bits to b8,b0	x000 0000 y000 0000
00:0000B964 E31F            	  3333: 	ROL.b		#1,d7				; shift bits together	x000 0000 0000 000y
00:0000B966 E35F            	  3334: 	ROL.w		#1,d7				; shift bits to b1,b0	0000 0000 0000 00yx
00:0000B968 5247            	  3335: 	ADDQ.w	#1,d7				; make 1 to 4
                            	  3336: 
00:0000B96A 1F04            	  3337: 	MOVE.b	d4,-(sp)			; push the intensity byte
00:0000B96C 341F            	  3338: 	MOVE.w	(sp)+,d2			; pull the word, intensity now in high byte
                            	  3339: 
00:0000B96E 7007            	  3340: 	MOVEQ		#7,d0				; set the co-ordinate and sign bits mask
00:0000B970 7202            	  3341: 	MOVEQ		#2,d1				; set the sign bit number
                            	  3342: 
00:0000B972 3604            	  3343: 	MOVE.w	d4,d3				; copy the opcode for the x co-ordinate
                            	  3344: 
00:0000B974 3F04            	  3345: 	MOVE.w	d4,-(sp)			; push the opcode
00:0000B976 181F            	  3346: 	MOVE.b	(sp)+,d4			; pull the y co-ordinate byte
                            	  3347: 
00:0000B978 C840            	  3348: 	AND.w		d0,d4				; mask the y co-ordinate and sign bits
00:0000B97A 0384            	  3349: 	BCLR.l	d1,d4				; test and clear the sign bit
00:0000B97C 6702            	  3350: 	BEQ.s		no_neg_y2			; if positive just exit
                            	  3351: 
00:0000B97E 4444            	  3352: 	NEG.w		d4				; else negate the y co-ordinate
                            	  3353: no_neg_y2
                            	  3354: 
00:0000B980 C640            	  3355: 	AND.w		d0,d3				; mask the x co-ordinate and sign bits
00:0000B982 0383            	  3356: 	BCLR.l	d1,d3				; test and clear the sign bit
00:0000B984 6702            	  3357: 	BEQ.s		no_neg_x2			; if positive just exit
                            	  3358: 
00:0000B986 4443            	  3359: 	NEG.w		d3				; else negate the x co-ordinate
                            	  3360: no_neg_x2
                            	  3361: 
00:0000B988 EF63            	  3362: 	ASL.w		d7,d3				; scale the x magnitude
00:0000B98A EF64            	  3363: 	ASL.w		d7,d4				; scale the y magnitude
                            	  3364: 
                            	  3365: end_vector
00:0000B98C 3E13            	  3366: 	MOVE.w	(a3),d7			; get the global scale, offset is zero	##
                            	  3367: ;##	MOVE.w	vector_s(a3),d7		; get the global scale
00:0000B98E 6A06            	  3368: 	BPL.s		shift_left			; if positive go shift left
                            	  3369: 
                            	  3370: 							; else shift right
00:0000B990 EE63            	  3371: 	ASR.w		d7,d3				; scale the x co-ordinate
00:0000B992 EE64            	  3372: 	ASR.w		d7,d4				; scale the y co-ordinate
00:0000B994 6004            	  3373: 	BRA.s		last_vector			; continue
                            	  3374: 
                            	  3375: shift_left
00:0000B996 EF63            	  3376: 	ASL.w		d7,d3				; scale the x co-ordinate
00:0000B998 EF64            	  3377: 	ASL.w		d7,d4				; scale the y co-ordinate
                            	  3378: last_vector
00:0000B99A D66B0002        	  3379: 	ADD.w		local_x(a3),d3		; add x the co-ordinate to vector x
00:0000B99E D86B0004        	  3380: 	ADD.w		local_y(a3),d4		; add y the co-ordinate to vector y
                            	  3381: 
00:0000B9A2 7056            	  3382: 	MOVEQ		#86,d0			; set move to x,y
                            	  3383: 
00:0000B9A4 C47CF000        	  3384: 	AND.w		#$F000,d2			; d2 is intensity
00:0000B9A8 6712            	  3385: 	BEQ.s		vector_move			; if zero intensity just do move
                            	  3386: 
00:0000B9AA 7200            	  3387: 	MOVEQ		#0,d1				; clear the longword
00:0000B9AC 3F02            	  3388: 	MOVE.w	d2,-(sp)			; copy the intensity
00:0000B9AE 141F            	  3389: 	MOVE.b	(sp)+,d2			; to the low byte byte
00:0000B9B0 1202            	  3390: 	MOVE.b	d2,d1				; copy the intensity byte
00:0000B9B2 4841            	  3391: 	SWAP		d1				; move to the high word
00:0000B9B4 3202            	  3392: 	MOVE.w	d2,d1				; get the other word
                            	  3393: 
00:0000B9B6 7050            	  3394: 	MOVEQ		#80,d0			; set pen colour
00:0000B9B8 4E4F            	  3395: 	TRAP		#15
                            	  3396: 
00:0000B9BA 7055            	  3397: 	MOVEQ		#85,d0			; set draw to x,y
                            	  3398: vector_move
00:0000B9BC 3404            	  3399: 	MOVE.w	d4,d2				; copy the y co-ordinate
00:0000B9BE 3203            	  3400: 	MOVE.w	d3,d1				; copy the x co-ordinate
                            	  3401: ;##	BRA.s		display_vector		; display the vector
                            	  3402: 
                            	  3403: 
                            	  3404: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3405: ;
                            	  3406: ; display vector and do next. takes the vector, scales the x and y to the current
                            	  3407: ; screen size - does axis inversion if needed - and then displays it. set up the
                            	  3408: ; graphics function in d0, x co-ordinate in d1.w and y co-ordinate in d2.w
                            	  3409: 
                            	  3410: ;##display_vector
00:0000B9C0 37410002        	  3411: 	MOVE.w	d1,local_x(a3)		; save as new local x co-ordinate
00:0000B9C4 37420004        	  3412: 	MOVE.w	d2,local_y(a3)		; save as new local y co-ordinate
                            	  3413: 
00:0000B9C8 760A            	  3414: 	MOVEQ		#10,d3			; set the shift count for / 1024
                            	  3415: 
00:0000B9CA C3EB0006        	  3416: 	MULS.w	scr_x(a3),d1		; x ; screen x
00:0000B9CE E6A1            	  3417: 	ASR.l		d3,d1				; / 1024
                            	  3418: 
00:0000B9D0 947C0080        	  3419: 	SUB.w		#128,d2			; subtract offset to centre vertically
00:0000B9D4 C5EB0006        	  3420: 	MULS.w	scr_x(a3),d2		; y ; screen x
00:0000B9D8 E6A2            	  3421: 	ASR.l		d3,d2				; / 1024
00:0000B9DA 4442            	  3422: 	NEG.w		d2				; y = 0 is top of screen remember
00:0000B9DC D46B0008        	  3423: 	ADD.w		scr_y(a3),d2		; + screen y
00:0000B9E0 5342            	  3424: 	SUBQ.w	#1,d2				; - 1
                            	  3425: 
00:0000B9E2 4E4F            	  3426: 	TRAP		#15				; do move or draw
                            	  3427: 
00:0000B9E4 6000FEB8        	  3428: 	BRA		do_vector			; go do the next vector opcode
                            	  3429: 
                            	  3430: 
                            	  3431: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3432: ;
                            	  3433: ; vector commands
                            	  3434: 
                            	  3435: REL1		EQU $1000				; draw relative
                            	  3436: REL2		EQU $2000				; draw relative
                            	  3437: REL3		EQU $3000				; draw relative
                            	  3438: REL4		EQU $4000				; draw relative
                            	  3439: REL5		EQU $5000				; draw relative
                            	  3440: REL6		EQU $6000				; draw relative
                            	  3441: REL7		EQU $7000				; draw relative
                            	  3442: REL8		EQU $8000				; draw relative
                            	  3443: REL9		EQU $9000				; draw relative
                            	  3444: DRAW		EQU $A000				; draw absolute
                            	  3445: HALT		EQU $B000				; halt
                            	  3446: JSRL		EQU $C000				; vector subroutine call
                            	  3447: RTSL		EQU $D000				; return from vector subroutine
                            	  3448: JMPL		EQU $E000				; vector jump
                            	  3449: SHRT		EQU $F000				; relative short vector
                            	  3450: 
                            	  3451: 
                            	  3452: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3453: ;
                            	  3454: ; vector list RAM
                            	  3455: 
                            	  3456: vector
00:0000B9E8 00              	  3457: 	ds.b	$1000					; 4k of space
00:0000B9E9 *
                            	  3458: 
                            	  3459: 
                            	  3460: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3461: ;
                            	  3462: ; vector ROM
                            	  3463: 
                            	  3464: ; copyright symbol followed by JSR's to write "2009 LEE DAVISO", followed by a JMP to
                            	  3465: ; char_n, which is the routine for "N"
                            	  3466: 
                            	  3467: copy_msg
00:0000C9E8 A088            	  3468: 	dc.w	$A088,$019A,$7000,$0000,$F573,$F173,$F178,$F177
00:0000C9EA 019A
00:0000C9EC 7000
00:0000C9EE 0000
00:0000C9F0 F573
00:0000C9F2 F173
00:0000C9F4 F178
00:0000C9F6 F177
00:0000C9F8 F577            	  3469: 	dc.w	$F577,$F578,$3180,$0200,$F875,$FD70,$F871,$FD02
00:0000C9FA F578
00:0000C9FC 3180
00:0000C9FE 0200
00:0000CA00 F875
00:0000CA02 FD70
00:0000CA04 F871
00:0000CA06 FD02
00:0000CA08 CAD6            	  3470: 	dc.w	JSRL+(char_2-vector)>>1		; 2
00:0000CA0A CA81            	  3471: 	dc.w	JSRL+(char_o0-vector)>>1	; 0
00:0000CA0C CA81            	  3472: 	dc.w	JSRL+(char_o0-vector)>>1	; 0
00:0000CA0E CB07            	  3473: 	dc.w	JSRL+(char_9-vector)>>1		; 9
00:0000CA10 CAD0            	  3474: 	dc.w	JSRL+(char_spc-vector)>>1	; [SPACE]
00:0000CA12 CA71            	  3475: 	dc.w	JSRL+(char_l-vector)>>1		; L
00:0000CA14 CA3F            	  3476: 	dc.w	JSRL+(char_e-vector)>>1		; E
00:0000CA16 CA3F            	  3477: 	dc.w	JSRL+(char_e-vector)>>1		; E
00:0000CA18 CAD0            	  3478: 	dc.w	JSRL+(char_spc-vector)>>1	; [SPACE]
00:0000CA1A CA37            	  3479: 	dc.w	JSRL+(char_d-vector)>>1		; D
00:0000CA1C CA1C            	  3480: 	dc.w	JSRL+(char_a-vector)>>1		; A
00:0000CA1E CAB2            	  3481: 	dc.w	JSRL+(char_v-vector)>>1		; V
00:0000CA20 CA5E            	  3482: 	dc.w	JSRL+(char_i-vector)>>1		; I
00:0000CA22 CA9F            	  3483: 	dc.w	JSRL+(char_s-vector)>>1		; S
00:0000CA24 CA81            	  3484: 	dc.w	JSRL+(char_o0-vector)>>1	; O
00:0000CA26 EA7C            	  3485: 	dc.w	JMPL+(char_n-vector)>>1		; N
                            	  3486: 
                            	  3487: ; table for the various saucer and rock explosions
                            	  3488: 
                            	  3489: expl_tab
00:0000CA28 C874            	  3490: 	dc.w	JSRL+(expl_0-vector)>>1		; explosion 0
00:0000CA2A C859            	  3491: 	dc.w	JSRL+(expl_1-vector)>>1		; explosion 1
00:0000CA2C C83A            	  3492: 	dc.w	JSRL+(expl_2-vector)>>1		; explosion 2
00:0000CA2E C824            	  3493: 	dc.w	JSRL+(expl_3-vector)>>1		; explosion 3
                            	  3494: 
                            	  3495: ; explosion 3
                            	  3496: 
                            	  3497: expl_3
00:0000CA30 F80D            	  3498: 	dc.w	$F80D,$F8F8,$FD0D,$F8F8,$FD09,$F8F8,$F10B,$F8F8
00:0000CA32 F8F8
00:0000CA34 FD0D
00:0000CA36 F8F8
00:0000CA38 FD09
00:0000CA3A F8F8
00:0000CA3C F10B
00:0000CA3E F8F8
00:0000CA40 F50A            	  3499: 	dc.w	$F50A,$F8F8,$F908,$F8F8,$F309,$F8F8,$F30D,$F8F8
00:0000CA42 F8F8
00:0000CA44 F908
00:0000CA46 F8F8
00:0000CA48 F309
00:0000CA4A F8F8
00:0000CA4C F30D
00:0000CA4E F8F8
00:0000CA50 5480            	  3500: 	dc.w	$5480,$0600,$F8F8,$F10F,$F8F8,RTSL
00:0000CA52 0600
00:0000CA54 F8F8
00:0000CA56 F10F
00:0000CA58 F8F8
00:0000CA5A D000
                            	  3501: 
                            	  3502: ; explosion 2
                            	  3503: 
                            	  3504: expl_2
00:0000CA5C 3000            	  3505: 	dc.w	$3000,$0780,$F8F8,$3780,$0780,$F8F8,$3780,$0380
00:0000CA5E 0780
00:0000CA60 F8F8
00:0000CA62 3780
00:0000CA64 0780
00:0000CA66 F8F8
00:0000CA68 3780
00:0000CA6A 0380
00:0000CA6C F8F8            	  3506: 	dc.w	$F8F8,$40E0,$02A0,$F8F8,$35C0,$0380,$F8F8,$3380
00:0000CA6E 40E0
00:0000CA70 02A0
00:0000CA72 F8F8
00:0000CA74 35C0
00:0000CA76 0380
00:0000CA78 F8F8
00:0000CA7A 3380
00:0000CA7C 0000            	  3507: 	dc.w	$0000,$F8F8,$42A0,$00E0,$F8F8,$42A0,$04E0,$F8F8
00:0000CA7E F8F8
00:0000CA80 42A0
00:0000CA82 00E0
00:0000CA84 F8F8
00:0000CA86 42A0
00:0000CA88 04E0
00:0000CA8A F8F8
00:0000CA8C 44E0            	  3508: 	dc.w	$44E0,$0780,$F8F8,$40E0,$06A0,$F8F8,RTSL
00:0000CA8E 0780
00:0000CA90 F8F8
00:0000CA92 40E0
00:0000CA94 06A0
00:0000CA96 F8F8
00:0000CA98 D000
                            	  3509: 
                            	  3510: ; explosion 1
                            	  3511: 
                            	  3512: expl_1
00:0000CA9A F807            	  3513: 	dc.w	$F807,$F8F8,$FF07,$F8F8,$FF03,$F8F8,$40C0,$0240
00:0000CA9C F8F8
00:0000CA9E FF07
00:0000CAA0 F8F8
00:0000CAA2 FF03
00:0000CAA4 F8F8
00:0000CAA6 40C0
00:0000CAA8 0240
00:0000CAAA F8F8            	  3514: 	dc.w	$F8F8,$3580,$0300,$F8F8,$FB00,$F8F8,$4240,$00C0
00:0000CAAC 3580
00:0000CAAE 0300
00:0000CAB0 F8F8
00:0000CAB2 FB00
00:0000CAB4 F8F8
00:0000CAB6 4240
00:0000CAB8 00C0
00:0000CABA F8F8            	  3515: 	dc.w	$F8F8,$4240,$04C0,$F8F8,$44C0,$0700,$F8F8,$40C0
00:0000CABC 4240
00:0000CABE 04C0
00:0000CAC0 F8F8
00:0000CAC2 44C0
00:0000CAC4 0700
00:0000CAC6 F8F8
00:0000CAC8 40C0
00:0000CACA 0640            	  3516: 	dc.w	$0640,$F8F8,RTSL
00:0000CACC F8F8
00:0000CACE D000
                            	  3517: 
                            	  3518: ; explosion 0
                            	  3519: 
                            	  3520: expl_0
00:0000CAD0 3000            	  3521: 	dc.w	$3000,$0680,$F8F8,$3680,$0680,$F8F8,$3680,$0280
00:0000CAD2 0680
00:0000CAD4 F8F8
00:0000CAD6 3680
00:0000CAD8 0680
00:0000CADA F8F8
00:0000CADC 3680
00:0000CADE 0280
00:0000CAE0 F8F8            	  3522: 	dc.w	$F8F8,$3140,$03C0,$F8F8,$3540,$0280,$F8F8,$3280
00:0000CAE2 3140
00:0000CAE4 03C0
00:0000CAE6 F8F8
00:0000CAE8 3540
00:0000CAEA 0280
00:0000CAEC F8F8
00:0000CAEE 3280
00:0000CAF0 0000            	  3523: 	dc.w	$0000,$F8F8,$33C0,$0140,$F8F8,$33C0,$0540,$F8F8
00:0000CAF2 F8F8
00:0000CAF4 33C0
00:0000CAF6 0140
00:0000CAF8 F8F8
00:0000CAFA 33C0
00:0000CAFC 0540
00:0000CAFE F8F8
00:0000CB00 44A0            	  3524: 	dc.w	$44A0,$0680,$F8F8,$3140,$07C0,$F8F8,RTSL
00:0000CB02 0680
00:0000CB04 F8F8
00:0000CB06 3140
00:0000CB08 07C0
00:0000CB0A F8F8
00:0000CB0C D000
                            	  3525: 
                            	  3526: ; table for rocks
                            	  3527: 
                            	  3528: rock_tab
00:0000CB0E C897            	  3529: 	dc.w	JSRL+(rock_0-vector)>>1		; top notch rock
00:0000CB10 C8A3            	  3530: 	dc.w	JSRL+(rock_1-vector)>>1		; "X" rock
00:0000CB12 C8B1            	  3531: 	dc.w	JSRL+(rock_2-vector)>>1		; bottom and left notch rock
00:0000CB14 C8BE            	  3532: 	dc.w	JSRL+(rock_3-vector)>>1		; left and right notch rock
                            	  3533: 
                            	  3534: ; top notch rock
                            	  3535: 
                            	  3536: rock_0
00:0000CB16 F908            	  3537: 	dc.w	$F908,$F979,$FD79,$F67D,$F679,$F68F,$F08F,$F97D
00:0000CB18 F979
00:0000CB1A FD79
00:0000CB1C F67D
00:0000CB1E F679
00:0000CB20 F68F
00:0000CB22 F08F
00:0000CB24 F97D
00:0000CB26 FA78            	  3538: 	dc.w	$FA78,$F979,$FD79,RTSL
00:0000CB28 F979
00:0000CB2A FD79
00:0000CB2C D000
                            	  3539: 
                            	  3540: ; "X" rock
                            	  3541: 
                            	  3542: rock_1
00:0000CB2E F10A            	  3543: 	dc.w	$F10A,$F17A,$F97D,$F57E,$F17E,$FD7D,$F679,$F67D
00:0000CB30 F17A
00:0000CB32 F97D
00:0000CB34 F57E
00:0000CB36 F17E
00:0000CB38 FD7D
00:0000CB3A F679
00:0000CB3C F67D
00:0000CB3E FD79            	  3544: 	dc.w	$FD79,$F179,$F58B,$F38A,$F97D,RTSL
00:0000CB40 F179
00:0000CB42 F58B
00:0000CB44 F38A
00:0000CB46 F97D
00:0000CB48 D000
                            	  3545: 
                            	  3546: ; bottom and left notch rock
                            	  3547: 
                            	  3548: rock_2
00:0000CB4A F80D            	  3549: 	dc.w	$F80D,$F57E,$F77A,$F37A,$F778,$F879,$F37A,$F978
00:0000CB4C F57E
00:0000CB4E F77A
00:0000CB50 F37A
00:0000CB52 F778
00:0000CB54 F879
00:0000CB56 F37A
00:0000CB58 F978
00:0000CB5A F37E            	  3550: 	dc.w	$F37E,$F07F,$F77F,$F57A,RTSL
00:0000CB5C F07F
00:0000CB5E F77F
00:0000CB60 F57A
00:0000CB62 D000
                            	  3551: 
                            	  3552: ; left and right notch rock
                            	  3553: 
                            	  3554: rock_3
00:0000CB64 F009            	  3555: 	dc.w	$F009,$F17B,$F168,$F27F,$F07F,$F669,$F07F,$F778
00:0000CB66 F17B
00:0000CB68 F168
00:0000CB6A F27F
00:0000CB6C F07F
00:0000CB6E F669
00:0000CB70 F07F
00:0000CB72 F778
00:0000CB74 F77A            	  3556: 	dc.w	$F77A,$F17B,$F569,$F969,$F27F,RTSL
00:0000CB76 F17B
00:0000CB78 F569
00:0000CB7A F969
00:0000CB7C F27F
00:0000CB7E D000
                            	  3557: 
                            	  3558: ; indirect saucer table
                            	  3559: 
                            	  3560: sauc_jsr
00:0000CB80 C8CD            	  3561: 	dc.w	JSRL+(sauc_vec-vector)>>1	; saucer
                            	  3562: 
                            	  3563: ; saucer
                            	  3564: 
                            	  3565: sauc_vec
00:0000CB82 F10E            	  3566: 	dc.w	$F10E,$F8CA,$F60B,$6000,$D680,$F6DB,$F8CA,$F2DB
00:0000CB84 F8CA
00:0000CB86 F60B
00:0000CB88 6000
00:0000CB8A D680
00:0000CB8C F6DB
00:0000CB8E F8CA
00:0000CB90 F2DB
00:0000CB92 F2DF            	  3567: 	dc.w	$F2DF,$F2CD,$F8CD,$F6CD,$F6DF,RTSL
00:0000CB94 F2CD
00:0000CB96 F8CD
00:0000CB98 F6CD
00:0000CB9A F6DF
00:0000CB9C D000
                            	  3568: 
                            	  3569: ; player ship address table
                            	  3570: 
                            	  3571: play_tab
00:0000CB9E 0022            	  3572: 	dc.w	play_00-play_tab
00:0000CBA0 003A            	  3573: 	dc.w	play_01-play_tab
00:0000CBA2 005E            	  3574: 	dc.w	play_02-play_tab
00:0000CBA4 0082            	  3575: 	dc.w	play_03-play_tab
00:0000CBA6 00A6            	  3576: 	dc.w	play_04-play_tab
00:0000CBA8 00C8            	  3577: 	dc.w	play_05-play_tab
00:0000CBAA 00EC            	  3578: 	dc.w	play_06-play_tab
00:0000CBAC 0110            	  3579: 	dc.w	play_07-play_tab
00:0000CBAE 0134            	  3580: 	dc.w	play_08-play_tab
00:0000CBB0 0158            	  3581: 	dc.w	play_09-play_tab
00:0000CBB2 017C            	  3582: 	dc.w	play_0A-play_tab
00:0000CBB4 01A0            	  3583: 	dc.w	play_0B-play_tab
00:0000CBB6 01C4            	  3584: 	dc.w	play_0C-play_tab
00:0000CBB8 01E8            	  3585: 	dc.w	play_0D-play_tab
00:0000CBBA 020C            	  3586: 	dc.w	play_0E-play_tab
00:0000CBBC 0230            	  3587: 	dc.w	play_0F-play_tab
00:0000CBBE 0254            	  3588: 	dc.w	play_10-play_tab
                            	  3589: 
                            	  3590: ; ship and thrust outlines. each ship outline is followed by its thrust outline which
                            	  3591: ; is only copied if the thrust button is pressed
                            	  3592: 
                            	  3593: play_00
00:0000CBC0 F60F            	  3594: 	dc.w	$F60F,$FAC8,$F9BD,$6500,$C300,$6500,$C700,$F9B9
00:0000CBC2 FAC8
00:0000CBC4 F9BD
00:0000CBC6 6500
00:0000CBC8 C300
00:0000CBCA 6500
00:0000CBCC C700
00:0000CBCE F9B9
00:0000CBD0 D000            	  3595: 	dc.w	RTSL
00:0000CBD2 F9CE            	  3596: 	dc.w	$F9CE,$F9CA,RTSL
00:0000CBD4 F9CA
00:0000CBD6 D000
                            	  3597: play_01
00:0000CBD8 4640            	  3598: 	dc.w	$4640,$06C0,$5200,$C430,$41C0,$C620,$64B0,$C318
00:0000CBDA 06C0
00:0000CBDC 5200
00:0000CBDE C430
00:0000CBE0 41C0
00:0000CBE2 C620
00:0000CBE4 64B0
00:0000CBE6 C318
00:0000CBE8 6548            	  3599: 	dc.w	$6548,$C6E0,$4220,$C1C0,RTSL
00:0000CBEA C6E0
00:0000CBEC 4220
00:0000CBEE C1C0
00:0000CBF0 D000
00:0000CBF2 50D0            	  3600: 	dc.w	$50D0,$C610,$4260,$C3C0,RTSL
00:0000CBF4 C610
00:0000CBF6 4260
00:0000CBF8 C3C0
00:0000CBFA D000
                            	  3601: play_02
00:0000CBFC 4680            	  3602: 	dc.w	$4680,$0680,$43E0,$C4C0,$41A0,$C660,$6468,$C320
00:0000CBFE 0680
00:0000CC00 43E0
00:0000CC02 C4C0
00:0000CC04 41A0
00:0000CC06 C660
00:0000CC08 6468
00:0000CC0A C320
00:0000CC0C 6590            	  3603: 	dc.w	$6590,$C6C0,$4260,$C1A0,RTSL
00:0000CC0E C6C0
00:0000CC10 4260
00:0000CC12 C1A0
00:0000CC14 D000
00:0000CC16 5090            	  3604: 	dc.w	$5090,$C630,$42C0,$C380,RTSL
00:0000CC18 C630
00:0000CC1A 42C0
00:0000CC1C C380
00:0000CC1E D000
                            	  3605: play_03
00:0000CC20 46C0            	  3606: 	dc.w	$46C0,$0640,$43E0,$C520,$4160,$C680,$6418,$C328
00:0000CC22 0640
00:0000CC24 43E0
00:0000CC26 C520
00:0000CC28 4160
00:0000CC2A C680
00:0000CC2C 6418
00:0000CC2E C328
00:0000CC30 65D0            	  3607: 	dc.w	$65D0,$C698,$4280,$C160,RTSL
00:0000CC32 C698
00:0000CC34 4280
00:0000CC36 C160
00:0000CC38 D000
00:0000CC3A 5060            	  3608: 	dc.w	$5060,$C630,$4320,$C340,RTSL
00:0000CC3C C630
00:0000CC3E 4320
00:0000CC40 C340
00:0000CC42 D000
                            	  3609: play_04
00:0000CC44 F70E            	  3610: 	dc.w	$F70E,$43C0,$C580,$4120,$C6A0,$6038,$C328,$6610
00:0000CC46 43C0
00:0000CC48 C580
00:0000CC4A 4120
00:0000CC4C C6A0
00:0000CC4E 6038
00:0000CC50 C328
00:0000CC52 6610
00:0000CC54 C660            	  3611: 	dc.w	$C660,$42A0,$C120,RTSL
00:0000CC56 42A0
00:0000CC58 C120
00:0000CC5A D000
00:0000CC5C 5030            	  3612: 	dc.w	$5030,$C640,$4360,$C2E0,RTSL
00:0000CC5E C640
00:0000CC60 4360
00:0000CC62 C2E0
00:0000CC64 D000
                            	  3613: play_05
00:0000CC66 4720            	  3614: 	dc.w	$4720,$05C0,$4380,$C5E0,$40E0,$C6C0,$6088,$C320
00:0000CC68 05C0
00:0000CC6A 4380
00:0000CC6C C5E0
00:0000CC6E 40E0
00:0000CC70 C6C0
00:0000CC72 6088
00:0000CC74 C320
00:0000CC76 6648            	  3615: 	dc.w	$6648,$C630,$42C0,$C0E0,RTSL
00:0000CC78 C630
00:0000CC7A 42C0
00:0000CC7C C0E0
00:0000CC7E D000
00:0000CC80 5410            	  3616: 	dc.w	$5410,$C640,$43A0,$C2A0,RTSL
00:0000CC82 C640
00:0000CC84 43A0
00:0000CC86 C2A0
00:0000CC88 D000
                            	  3617: play_06
00:0000CC8A 4760            	  3618: 	dc.w	$4760,$0560,$4360,$C640,$4080,$C6C0,$60D8,$C310
00:0000CC8C 0560
00:0000CC8E 4360
00:0000CC90 C640
00:0000CC92 4080
00:0000CC94 C6C0
00:0000CC96 60D8
00:0000CC98 C310
00:0000CC9A 6680            	  3619: 	dc.w	$6680,$C5F0,$42C0,$C080,RTSL
00:0000CC9C C5F0
00:0000CC9E 42C0
00:0000CCA0 C080
00:0000CCA2 D000
00:0000CCA4 5440            	  3620: 	dc.w	$5440,$C630,$43E0,$C240,RTSL
00:0000CCA6 C630
00:0000CCA8 43E0
00:0000CCAA C240
00:0000CCAC D000
                            	  3621: play_07
00:0000CCAE 4780            	  3622: 	dc.w	$4780,$0500,$4320,$C680,$4040,$C6E0,$6120,$C2F8
00:0000CCB0 0500
00:0000CCB2 4320
00:0000CCB4 C680
00:0000CCB6 4040
00:0000CCB8 C6E0
00:0000CCBA 6120
00:0000CCBC C2F8
00:0000CCBE 66B0            	  3623: 	dc.w	$66B0,$C5B0,$42E0,$C040,RTSL
00:0000CCC0 C5B0
00:0000CCC2 42E0
00:0000CCC4 C040
00:0000CCC6 D000
00:0000CCC8 5480            	  3624: 	dc.w	$5480,$C630,$5210,$C0F0,RTSL
00:0000CCCA C630
00:0000CCCC 5210
00:0000CCCE C0F0
00:0000CCD0 D000
                            	  3625: play_08
00:0000CCD2 4780            	  3626: 	dc.w	$4780,$04C0,$42E0,$C6E0,$4000,$C6E0,$6168,$C2D8
00:0000CCD4 04C0
00:0000CCD6 42E0
00:0000CCD8 C6E0
00:0000CCDA 4000
00:0000CCDC C6E0
00:0000CCDE 6168
00:0000CCE0 C2D8
00:0000CCE2 66D8            	  3627: 	dc.w	$66D8,$C568,$42E0,$C000,RTSL
00:0000CCE4 C568
00:0000CCE6 42E0
00:0000CCE8 C000
00:0000CCEA D000
00:0000CCEC 54B0            	  3628: 	dc.w	$54B0,$C620,$5220,$C0B0,RTSL
00:0000CCEE C620
00:0000CCF0 5220
00:0000CCF2 C0B0
00:0000CCF4 D000
                            	  3629: play_09
00:0000CCF6 47A0            	  3630: 	dc.w	$47A0,$0460,$4280,$C720,$4440,$C6E0,$61B0,$C2B0
00:0000CCF8 0460
00:0000CCFA 4280
00:0000CCFC C720
00:0000CCFE 4440
00:0000CD00 C6E0
00:0000CD02 61B0
00:0000CD04 C2B0
00:0000CD06 66F8            	  3631: 	dc.w	$66F8,$C520,$42E0,$C440,RTSL
00:0000CD08 C520
00:0000CD0A 42E0
00:0000CD0C C440
00:0000CD0E D000
00:0000CD10 54F0            	  3632: 	dc.w	$54F0,$C610,$5230,$C080,RTSL
00:0000CD12 C610
00:0000CD14 5230
00:0000CD16 C080
00:0000CD18 D000
                            	  3633: play_0A
00:0000CD1A 47A0            	  3634: 	dc.w	$47A0,$0000,$4240,$C760,$4480,$C6C0,$61F0,$C280
00:0000CD1C 0000
00:0000CD1E 4240
00:0000CD20 C760
00:0000CD22 4480
00:0000CD24 C6C0
00:0000CD26 61F0
00:0000CD28 C280
00:0000CD2A 6710            	  3635: 	dc.w	$6710,$C4D8,$42C0,$C480,RTSL
00:0000CD2C C4D8
00:0000CD2E 42C0
00:0000CD30 C480
00:0000CD32 D000
00:0000CD34 4640            	  3636: 	dc.w	$4640,$C7E0,$5230,$C040,RTSL
00:0000CD36 C7E0
00:0000CD38 5230
00:0000CD3A C040
00:0000CD3C D000
                            	  3637: play_0B
00:0000CD3E 47A0            	  3638: 	dc.w	$47A0,$0060,$41E0,$C780,$44E0,$C6C0,$6230,$C248
00:0000CD40 0060
00:0000CD42 41E0
00:0000CD44 C780
00:0000CD46 44E0
00:0000CD48 C6C0
00:0000CD4A 6230
00:0000CD4C C248
00:0000CD4E 6720            	  3639: 	dc.w	$6720,$C488,$42C0,$C4E0,RTSL
00:0000CD50 C488
00:0000CD52 42C0
00:0000CD54 C4E0
00:0000CD56 D000
00:0000CD58 46A0            	  3640: 	dc.w	$46A0,$C7A0,$5240,$C010,RTSL
00:0000CD5A C7A0
00:0000CD5C 5240
00:0000CD5E C010
00:0000CD60 D000
                            	  3641: play_0C
00:0000CD62 4780            	  3642: 	dc.w	$4780,$00C0,$4180,$C7C0,$4520,$C6A0,$6260,$C210
00:0000CD64 00C0
00:0000CD66 4180
00:0000CD68 C7C0
00:0000CD6A 4520
00:0000CD6C C6A0
00:0000CD6E 6260
00:0000CD70 C210
00:0000CD72 6728            	  3643: 	dc.w	$6728,$C438,$42A0,$C520,RTSL
00:0000CD74 C438
00:0000CD76 42A0
00:0000CD78 C520
00:0000CD7A D000
00:0000CD7C 46E0            	  3644: 	dc.w	$46E0,$C760,$5240,$C430,RTSL
00:0000CD7E C760
00:0000CD80 5240
00:0000CD82 C430
00:0000CD84 D000
                            	  3645: play_0D
00:0000CD86 4780            	  3646: 	dc.w	$4780,$0100,$4120,$C7E0,$4560,$C680,$6298,$C1D0
00:0000CD88 0100
00:0000CD8A 4120
00:0000CD8C C7E0
00:0000CD8E 4560
00:0000CD90 C680
00:0000CD92 6298
00:0000CD94 C1D0
00:0000CD96 6728            	  3647: 	dc.w	$6728,$C018,$4280,$C560,RTSL
00:0000CD98 C018
00:0000CD9A 4280
00:0000CD9C C560
00:0000CD9E D000
00:0000CDA0 4740            	  3648: 	dc.w	$4740,$C720,$5230,$C460,RTSL
00:0000CDA2 C720
00:0000CDA4 5230
00:0000CDA6 C460
00:0000CDA8 D000
                            	  3649: play_0E
00:0000CDAA 4760            	  3650: 	dc.w	$4760,$0160,$40C0,$C7E0,$45A0,$C660,$62C0,$C190
00:0000CDAC 0160
00:0000CDAE 40C0
00:0000CDB0 C7E0
00:0000CDB2 45A0
00:0000CDB4 C660
00:0000CDB6 62C0
00:0000CDB8 C190
00:0000CDBA 6720            	  3651: 	dc.w	$6720,$C068,$4260,$C5A0,RTSL
00:0000CDBC C068
00:0000CDBE 4260
00:0000CDC0 C5A0
00:0000CDC2 D000
00:0000CDC4 4780            	  3652: 	dc.w	$4780,$C6C0,$5230,$C490,RTSL
00:0000CDC6 C6C0
00:0000CDC8 5230
00:0000CDCA C490
00:0000CDCC D000
                            	  3653: play_0F
00:0000CDCE 4720            	  3654: 	dc.w	$4720,$01C0,$5030,$C600,$45C0,$C620,$62E0,$C148
00:0000CDD0 01C0
00:0000CDD2 5030
00:0000CDD4 C600
00:0000CDD6 45C0
00:0000CDD8 C620
00:0000CDDA 62E0
00:0000CDDC C148
00:0000CDDE 6718            	  3655: 	dc.w	$6718,$C0B0,$4220,$C5C0,RTSL
00:0000CDE0 C0B0
00:0000CDE2 4220
00:0000CDE4 C5C0
00:0000CDE6 D000
00:0000CDE8 47C0            	  3656: 	dc.w	$47C0,$C660,$5210,$C4D0,RTSL
00:0000CDEA C660
00:0000CDEC 5210
00:0000CDEE C4D0
00:0000CDF0 D000
                            	  3657: play_10
00:0000CDF2 F70A            	  3658: 	dc.w	$F70A,$F8CE,$FDCD,$6300,$C100,$6700,$C100,$F9CD
00:0000CDF4 F8CE
00:0000CDF6 FDCD
00:0000CDF8 6300
00:0000CDFA C100
00:0000CDFC 6700
00:0000CDFE C100
00:0000CE00 F9CD
00:0000CE02 D000            	  3659: 	dc.w	RTSL
00:0000CE04 FECD            	  3660: 	dc.w	$FECD,$FACD,RTSL
00:0000CE06 FACD
00:0000CE08 D000
                            	  3661: 
                            	  3662: ; ship outline for player lives
                            	  3663: 
                            	  3664: play_liv
00:0000CE0A F70E            	  3665: 	dc.w	$F70E,$F87A,$FD79,$6300,$7500,$6700,$7500,$F979
00:0000CE0C F87A
00:0000CE0E FD79
00:0000CE10 6300
00:0000CE12 7500
00:0000CE14 6700
00:0000CE16 7500
00:0000CE18 F979
00:0000CE1A 60C0            	  3666: 	dc.w	$60C0,$0280,$D09F
00:0000CE1C 0280
00:0000CE1E D09F
                            	  3667: 
                            	  3668: ; character set
                            	  3669: 
                            	  3670: char_a						; A
00:0000CE20 FA70            	  3671: 	dc.w	$FA70,$F272,$F672,$FE70
00:0000CE22 F272
00:0000CE24 F672
00:0000CE26 FE70
00:0000CE28 F906            	  3672: 	dc.w	$F906,$F872,$F602,RTSL
00:0000CE2A F872
00:0000CE2C F602
00:0000CE2E D000
                            	  3673: char_b						; B
00:0000CE30 FB70            	  3674: 	dc.w	$FB70,$F073,$F571,$F570
00:0000CE32 F073
00:0000CE34 F571
00:0000CE36 F570
00:0000CE38 F575            	  3675: 	dc.w	$F575,$F077,$F003,$F571
00:0000CE3A F077
00:0000CE3C F003
00:0000CE3E F571
00:0000CE40 F570            	  3676: 	dc.w	$F570,$F575,$F077,$F803,RTSL
00:0000CE42 F575
00:0000CE44 F077
00:0000CE46 F803
00:0000CE48 D000
                            	  3677: char_c						; C
00:0000CE4A FB70            	  3678: 	dc.w	$FB70,$F872,$FF06,$F872
00:0000CE4C F872
00:0000CE4E FF06
00:0000CE50 F872
00:0000CE52 F002            	  3679: 	dc.w	$F002,RTSL
00:0000CE54 D000
                            	  3680: char_d						; D
00:0000CE56 FB70            	  3681: 	dc.w	$FB70,$F072,$F672,$F670
00:0000CE58 F072
00:0000CE5A F672
00:0000CE5C F670
00:0000CE5E F676            	  3682: 	dc.w	$F676,$F076,$F803,RTSL
00:0000CE60 F076
00:0000CE62 F803
00:0000CE64 D000
                            	  3683: char_e						; E
00:0000CE66 FB70            	  3684: 	dc.w	$FB70,$F872,$F705,$F077
00:0000CE68 F872
00:0000CE6A F705
00:0000CE6C F077
00:0000CE6E F700            	  3685: 	dc.w	$F700,$F872,$F002,RTSL
00:0000CE70 F872
00:0000CE72 F002
00:0000CE74 D000
                            	  3686: char_f						; F
00:0000CE76 FB70            	  3687: 	dc.w	$FB70,$F872,$F705,$F077
00:0000CE78 F872
00:0000CE7A F705
00:0000CE7C F077
00:0000CE7E F700            	  3688: 	dc.w	$F700,$F803,RTSL
00:0000CE80 F803
00:0000CE82 D000
                            	  3689: char_g						; G
00:0000CE84 FB70            	  3690: 	dc.w	$FB70,$F872,$F670,$F606
00:0000CE86 F872
00:0000CE88 F670
00:0000CE8A F606
00:0000CE8C F072            	  3691: 	dc.w	$F072,$F670,$F876,$F803
00:0000CE8E F670
00:0000CE90 F876
00:0000CE92 F803
00:0000CE94 D000            	  3692: 	dc.w	RTSL
                            	  3693: char_h						; H
00:0000CE96 FB70            	  3694: 	dc.w	$FB70,$F700,$F872,$F300
00:0000CE98 F700
00:0000CE9A F872
00:0000CE9C F300
00:0000CE9E FF70            	  3695: 	dc.w	$FF70,$F002,RTSL
00:0000CEA0 F002
00:0000CEA2 D000
                            	  3696: char_i						; I
00:0000CEA4 F872            	  3697: 	dc.w	$F872,$F006,$FB70,$F002
00:0000CEA6 F006
00:0000CEA8 FB70
00:0000CEAA F002
00:0000CEAC F876            	  3698: 	dc.w	$F876,$FF03,RTSL
00:0000CEAE FF03
00:0000CEB0 D000
                            	  3699: char_j						; J
00:0000CEB2 F200            	  3700: 	dc.w	$F200,$F672,$F072,$FB70
00:0000CEB4 F672
00:0000CEB6 F072
00:0000CEB8 FB70
00:0000CEBA FF01            	  3701: 	dc.w	$FF01,RTSL
00:0000CEBC D000
                            	  3702: char_k						; K
00:0000CEBE FB70            	  3703: 	dc.w	$FB70,$F003,$F777,$F773
00:0000CEC0 F003
00:0000CEC2 F777
00:0000CEC4 F773
00:0000CEC6 F003            	  3704: 	dc.w	$F003,RTSL
00:0000CEC8 D000
                            	  3705: char_l						; L
00:0000CECA FB00            	  3706: 	dc.w	$FB00,$FF70,$F872,$F002,RTSL
00:0000CECC FF70
00:0000CECE F872
00:0000CED0 F002
00:0000CED2 D000
                            	  3707: char_m						; M
00:0000CED4 FB70            	  3708: 	dc.w	$FB70,$F672,$F272,$FF70
00:0000CED6 F672
00:0000CED8 F272
00:0000CEDA FF70
00:0000CEDC F002            	  3709: 	dc.w	$F002,RTSL
00:0000CEDE D000
                            	  3710: char_n						; N
00:0000CEE0 FB70            	  3711: 	dc.w	$FB70,$FF72,$FB70,$FF01,RTSL
00:0000CEE2 FF72
00:0000CEE4 FB70
00:0000CEE6 FF01
00:0000CEE8 D000
                            	  3712: char_o0						; O,0
00:0000CEEA FB70            	  3713: 	dc.w	$FB70,$F872,$FF70,$F876
00:0000CEEC F872
00:0000CEEE FF70
00:0000CEF0 F876
00:0000CEF2 F803            	  3714: 	dc.w	$F803,RTSL
00:0000CEF4 D000
                            	  3715: char_p						; P
00:0000CEF6 FB70            	  3716: 	dc.w	$FB70,$F872,$F770,$F876
00:0000CEF8 F872
00:0000CEFA F770
00:0000CEFC F876
00:0000CEFE F703            	  3717: 	dc.w	$F703,$F003,RTSL
00:0000CF00 F003
00:0000CF02 D000
                            	  3718: char_q						; Q
00:0000CF04 FB70            	  3719: 	dc.w	$FB70,$F872,$FE70,$F676
00:0000CF06 F872
00:0000CF08 FE70
00:0000CF0A F676
00:0000CF0C F076            	  3720: 	dc.w	$F076,$F202,$F672,$F002
00:0000CF0E F202
00:0000CF10 F672
00:0000CF12 F002
00:0000CF14 D000            	  3721: 	dc.w	RTSL
                            	  3722: char_r						; R
00:0000CF16 FB70            	  3723: 	dc.w	$FB70,$F872,$F770,$F876
00:0000CF18 F872
00:0000CF1A F770
00:0000CF1C F876
00:0000CF1E F001            	  3724: 	dc.w	$F001,$F773,$F002,RTSL
00:0000CF20 F773
00:0000CF22 F002
00:0000CF24 D000
                            	  3725: char_s						; S
00:0000CF26 F872            	  3726: 	dc.w	$F872,$F370,$F876,$F370
00:0000CF28 F370
00:0000CF2A F876
00:0000CF2C F370
00:0000CF2E F872            	  3727: 	dc.w	$F872,$FF01,RTSL
00:0000CF30 FF01
00:0000CF32 D000
                            	  3728: char_t						; T
00:0000CF34 F002            	  3729: 	dc.w	$F002,$FB70,$F006,$F872
00:0000CF36 FB70
00:0000CF38 F006
00:0000CF3A F872
00:0000CF3C FF01            	  3730: 	dc.w	$FF01,RTSL
00:0000CF3E D000
                            	  3731: char_u						; U
00:0000CF40 FB00            	  3732: 	dc.w	$FB00,$FF70,$F872,$FB70
00:0000CF42 FF70
00:0000CF44 F872
00:0000CF46 FB70
00:0000CF48 FF01            	  3733: 	dc.w	$FF01,RTSL
00:0000CF4A D000
                            	  3734: char_v						; V
00:0000CF4C FB00            	  3735: 	dc.w	$FB00,$FF71,$FB71,$FF01,RTSL
00:0000CF4E FF71
00:0000CF50 FB71
00:0000CF52 FF01
00:0000CF54 D000
                            	  3736: char_w						; W
00:0000CF56 FB00            	  3737: 	dc.w	$FB00,$FF70,$F272,$F672
00:0000CF58 FF70
00:0000CF5A F272
00:0000CF5C F672
00:0000CF5E FB70            	  3738: 	dc.w	$FB70,$FF01,RTSL
00:0000CF60 FF01
00:0000CF62 D000
                            	  3739: char_x						; X
00:0000CF64 FB72            	  3740: 	dc.w	$FB72,$F806,$FF72,$F002,RTSL
00:0000CF66 F806
00:0000CF68 FF72
00:0000CF6A F002
00:0000CF6C D000
                            	  3741: char_y						; Y
00:0000CF6E F002            	  3742: 	dc.w	$F002,$FA70,$F276,$F802
00:0000CF70 FA70
00:0000CF72 F276
00:0000CF74 F802
00:0000CF76 F676            	  3743: 	dc.w	$F676,$FE02,RTSL
00:0000CF78 FE02
00:0000CF7A D000
                            	  3744: char_z						; Z
00:0000CF7C FB00            	  3745: 	dc.w	$FB00,$F872,$FF76,$F872
00:0000CF7E F872
00:0000CF80 FF76
00:0000CF82 F872
00:0000CF84 F002            	  3746: 	dc.w	$F002,RTSL
00:0000CF86 D000
                            	  3747: char_spc						; [SPACE]
00:0000CF88 F803            	  3748: 	dc.w	$F803,RTSL
00:0000CF8A D000
                            	  3749: char_1						; 1
00:0000CF8C F002            	  3750: 	dc.w	$F002,$FB70,$FF02,RTSL
00:0000CF8E FB70
00:0000CF90 FF02
00:0000CF92 D000
                            	  3751: char_2						; 2
00:0000CF94 FB00            	  3752: 	dc.w	$FB00,$F872,$F770,$F876
00:0000CF96 F872
00:0000CF98 F770
00:0000CF9A F876
00:0000CF9C F770            	  3753: 	dc.w	$F770,$F872,$F002,RTSL
00:0000CF9E F872
00:0000CFA0 F002
00:0000CFA2 D000
                            	  3754: char_3						; 3
00:0000CFA4 F872            	  3755: 	dc.w	$F872,$FB70,$F876,$F700
00:0000CFA6 FB70
00:0000CFA8 F876
00:0000CFAA F700
00:0000CFAC F872            	  3756: 	dc.w	$F872,$F702,RTSL
00:0000CFAE F702
00:0000CFB0 D000
                            	  3757: char_4						; 4
00:0000CFB2 FB00            	  3758: 	dc.w	$FB00,$F770,$F872,$F300
00:0000CFB4 F770
00:0000CFB6 F872
00:0000CFB8 F300
00:0000CFBA FF70            	  3759: 	dc.w	$FF70,$F002,RTSL
00:0000CFBC F002
00:0000CFBE D000
                            	  3760: char_5						; 6
00:0000CFC0 F872            	  3761: 	dc.w	$F872,$F370,$F876,$F370
00:0000CFC2 F370
00:0000CFC4 F876
00:0000CFC6 F370
00:0000CFC8 F872            	  3762: 	dc.w	$F872,$FF01,RTSL
00:0000CFCA FF01
00:0000CFCC D000
                            	  3763: char_6						; 6
00:0000CFCE F300            	  3764: 	dc.w	$F300,$F872,$F770,$F876
00:0000CFD0 F872
00:0000CFD2 F770
00:0000CFD4 F876
00:0000CFD6 FB70            	  3765: 	dc.w	$FB70,$FF03,RTSL
00:0000CFD8 FF03
00:0000CFDA D000
                            	  3766: char_7						; 7
00:0000CFDC FB00            	  3767: 	dc.w	$FB00,$F872,$FF70,$F002,RTSL
00:0000CFDE F872
00:0000CFE0 FF70
00:0000CFE2 F002
00:0000CFE4 D000
                            	  3768: char_8						; 8
00:0000CFE6 F872            	  3769: 	dc.w	$F872,$FB70,$F876,$FF70
00:0000CFE8 FB70
00:0000CFEA F876
00:0000CFEC FF70
00:0000CFEE F300            	  3770: 	dc.w	$F300,$F872,$F702,RTSL
00:0000CFF0 F872
00:0000CFF2 F702
00:0000CFF4 D000
                            	  3771: char_9						; 9
00:0000CFF6 F802            	  3772: 	dc.w	$F802,$FB70,$F876,$F770
00:0000CFF8 FB70
00:0000CFFA F876
00:0000CFFC F770
00:0000CFFE F872            	  3773: 	dc.w	$F872,$F702,RTSL
00:0000D000 F702
00:0000D002 D000
                            	  3774: 
                            	  3775: ; indirect table for character set
                            	  3776: 
                            	  3777: char_set
00:0000D004 CAD0            	  3778: 	dc.w	JSRL+(char_spc-vector)>>1	; [SPACE]
00:0000D006 CA81            	  3779: 	dc.w	JSRL+(char_o0-vector)>>1	; 0 also O
00:0000D008 CAD2            	  3780: 	dc.w	JSRL+(char_1-vector)>>1		; 1
00:0000D00A CAD6            	  3781: 	dc.w	JSRL+(char_2-vector)>>1		; 2
00:0000D00C CADE            	  3782: 	dc.w	JSRL+(char_3-vector)>>1		; 3
00:0000D00E CAE5            	  3783: 	dc.w	JSRL+(char_4-vector)>>1		; 4
00:0000D010 CAEC            	  3784: 	dc.w	JSRL+(char_5-vector)>>1		; 5
00:0000D012 CAF3            	  3785: 	dc.w	JSRL+(char_6-vector)>>1		; 6
00:0000D014 CAFA            	  3786: 	dc.w	JSRL+(char_7-vector)>>1		; 7
00:0000D016 CAFF            	  3787: 	dc.w	JSRL+(char_8-vector)>>1		; 8
00:0000D018 CB07            	  3788: 	dc.w	JSRL+(char_9-vector)>>1		; 9
00:0000D01A CA1C            	  3789: 	dc.w	JSRL+(char_a-vector)>>1		; A
00:0000D01C CA24            	  3790: 	dc.w	JSRL+(char_b-vector)>>1		; B
00:0000D01E CA31            	  3791: 	dc.w	JSRL+(char_c-vector)>>1		; C
00:0000D020 CA37            	  3792: 	dc.w	JSRL+(char_d-vector)>>1		; D
00:0000D022 CA3F            	  3793: 	dc.w	JSRL+(char_e-vector)>>1		; E
00:0000D024 CA47            	  3794: 	dc.w	JSRL+(char_f-vector)>>1		; F
00:0000D026 CA4E            	  3795: 	dc.w	JSRL+(char_g-vector)>>1		; G
00:0000D028 CA57            	  3796: 	dc.w	JSRL+(char_h-vector)>>1		; H
00:0000D02A CA5E            	  3797: 	dc.w	JSRL+(char_i-vector)>>1		; I
00:0000D02C CA65            	  3798: 	dc.w	JSRL+(char_j-vector)>>1		; J
00:0000D02E CA6B            	  3799: 	dc.w	JSRL+(char_k-vector)>>1		; K
00:0000D030 CA71            	  3800: 	dc.w	JSRL+(char_l-vector)>>1		; L
00:0000D032 CA76            	  3801: 	dc.w	JSRL+(char_m-vector)>>1		; M
00:0000D034 CA7C            	  3802: 	dc.w	JSRL+(char_n-vector)>>1		; N
00:0000D036 CA81            	  3803: 	dc.w	JSRL+(char_o0-vector)>>1	; O also 0
00:0000D038 CA87            	  3804: 	dc.w	JSRL+(char_p-vector)>>1		; P
00:0000D03A CA8E            	  3805: 	dc.w	JSRL+(char_q-vector)>>1		; Q
00:0000D03C CA97            	  3806: 	dc.w	JSRL+(char_r-vector)>>1		; R
00:0000D03E CA9F            	  3807: 	dc.w	JSRL+(char_s-vector)>>1		; S
00:0000D040 CAA6            	  3808: 	dc.w	JSRL+(char_t-vector)>>1		; T
00:0000D042 CAAC            	  3809: 	dc.w	JSRL+(char_u-vector)>>1		; U
00:0000D044 CAB2            	  3810: 	dc.w	JSRL+(char_v-vector)>>1		; V
00:0000D046 CAB7            	  3811: 	dc.w	JSRL+(char_w-vector)>>1		; W
00:0000D048 CABE            	  3812: 	dc.w	JSRL+(char_x-vector)>>1		; X
00:0000D04A CAC3            	  3813: 	dc.w	JSRL+(char_y-vector)>>1		; Y
00:0000D04C CACA            	  3814: 	dc.w	JSRL+(char_z-vector)>>1		; Z
                            	  3815: 
                            	  3816: ; indirect shot table
                            	  3817: 
                            	  3818: shot_jsr
00:0000D04E CB34            	  3819: 	dc.w	JSRL+(shot_vec-vector)>>1	; shot
                            	  3820: 
                            	  3821: ; shot vector object, a small cross of intensity $F
                            	  3822: 
                            	  3823: shot_vec
00:0000D050 7420            	  3824: 	dc.w	$7420,$0000
00:0000D052 0000
00:0000D054 7040            	  3825: 	dc.w	$7040,$F000
00:0000D056 F000
00:0000D058 7420            	  3826: 	dc.w	$7420,$0420
00:0000D05A 0420
00:0000D05C 7000            	  3827: 	dc.w	$7000,$F040
00:0000D05E F040
00:0000D060 D000            	  3828: 	dc.w	RTSL
                            	  3829: 
                            	  3830: 
                            	  3831: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3832: ;
                            	  3833: ; canned messages
                            	  3834: 
                            	  3835: ; x,y co-ordinates for the message origins
                            	  3836: 
                            	  3837: mess_origin
00:0000D062 0064            	  3838: 	dc.w	$0064,$00B6				; message 0 x,y
00:0000D064 00B6
00:0000D066 0064            	  3839: 	dc.w	$0064,$00B6				; message 1 x,y
00:0000D068 00B6
00:0000D06A 000C            	  3840: 	dc.w	$000C,$00AA				; message 2 x,y
00:0000D06C 00AA
00:0000D06E 000C            	  3841: 	dc.w	$000C,$00A2				; message 3 x,y
00:0000D070 00A2
00:0000D072 000C            	  3842: 	dc.w	$000C,$009A				; message 4 x,y
00:0000D074 009A
00:0000D076 000C            	  3843: 	dc.w	$000C,$0092				; message 5 x,y
00:0000D078 0092
00:0000D07A 0064            	  3844: 	dc.w	$0064,$00C6				; message 6 x,y
00:0000D07C 00C6
00:0000D07E 0064            	  3845: 	dc.w	$0064,$009D				; message 7 x,y
00:0000D080 009D
                            	  3846: 
                            	  3847: ; message tables
                            	  3848: 
                            	  3849: mess_table
00:0000D082 0008            	  3850: 	dc.w	e_messages-mess_table		; english
00:0000D084 00C2            	  3851: 	dc.w	d_messages-mess_table		; german
00:0000D086 019E            	  3852: 	dc.w	f_messages-mess_table		; french
00:0000D088 026C            	  3853: 	dc.w	s_messages-mess_table		; spanish
                            	  3854: 
                            	  3855: ; message offset table
                            	  3856: 
                            	  3857: e_messages
00:0000D08A 0010            	  3858: 	dc.w	e_mess_0-e_messages		; message 0
00:0000D08C 001C            	  3859: 	dc.w	e_mess_1-e_messages		; message 1
00:0000D08E 0024            	  3860: 	dc.w	e_mess_2-e_messages		; message 2
00:0000D090 0046            	  3861: 	dc.w	e_mess_3-e_messages		; message 3
00:0000D092 0061            	  3862: 	dc.w	e_mess_4-e_messages		; message 4
00:0000D094 007E            	  3863: 	dc.w	e_mess_5-e_messages		; message 5
00:0000D096 00A5            	  3864: 	dc.w	e_mess_6-e_messages		; message 6
00:0000D098 00B0            	  3865: 	dc.w	e_mess_7-e_messages		; message 7
                            	  3866: 
                            	  3867: e_mess_0
00:0000D09A 484947482053434F	  3868: 	dc.b	'HIGH SCORES',$00
00:0000D0A2 524553
00:0000D0A5 00
                            	  3869: e_mess_1
00:0000D0A6 504C4159455220  	  3870: 	dc.b	'PLAYER ',$00
00:0000D0AD 00
                            	  3871: e_mess_2
00:0000D0AE 594F55522053434F	  3872: 	dc.b	'YOUR SCORE IS ONE OF THE TEN BEST',$00
00:0000D0B6 5245204953204F4E
00:0000D0BE 45204F4620544845
00:0000D0C6 2054454E20424553
00:0000D0CE 54
00:0000D0CF 00
                            	  3873: e_mess_3
00:0000D0D0 504C454153452045	  3874: 	dc.b	'PLEASE ENTER YOUR INITIALS',$00
00:0000D0D8 4E54455220594F55
00:0000D0E0 5220494E49544941
00:0000D0E8 4C53
00:0000D0EA 00
                            	  3875: e_mess_4
00:0000D0EB 5055534820524F54	  3876: 	dc.b	'PUSH ROTATE TO SELECT LETTER',$00
00:0000D0F3 41544520544F2053
00:0000D0FB 454C454354204C45
00:0000D103 54544552
00:0000D107 00
                            	  3877: e_mess_5
00:0000D108 5055534820485950	  3878: 	dc.b	'PUSH HYPERSPACE WHEN LETTER IS CORRECT',$00
00:0000D110 4552535041434520
00:0000D118 5748454E204C4554
00:0000D120 5445522049532043
00:0000D128 4F5252454354
00:0000D12E 00
                            	  3879: e_mess_6
00:0000D12F 5055534820535441	  3880: 	dc.b	'PUSH START',$00
00:0000D137 5254
00:0000D139 00
                            	  3881: e_mess_7
00:0000D13A 47414D45204F5645	  3882: 	dc.b	'GAME OVER',$00
00:0000D142 52
00:0000D143 00
                            	  3883: 
                            	  3884: 	ds.w	0					; ensure even
                            	  3885: 
                            	  3886: ; german message offset table
                            	  3887: 
                            	  3888: d_messages
00:0000D144 0010            	  3889: 	dc.w	d_mess_0-d_messages		; message 0
00:0000D146 0020            	  3890: 	dc.w	d_mess_1-d_messages		; message 1
00:0000D148 0029            	  3891: 	dc.w	d_mess_2-d_messages		; message 2
00:0000D14A 0050            	  3892: 	dc.w	d_mess_3-d_messages		; message 3
00:0000D14C 0073            	  3893: 	dc.w	d_mess_4-d_messages		; message 4
00:0000D14E 0096            	  3894: 	dc.w	d_mess_5-d_messages		; message 5
00:0000D150 00BC            	  3895: 	dc.w	d_mess_6-d_messages		; message 6
00:0000D152 00D2            	  3896: 	dc.w	d_mess_7-d_messages		; message 7
                            	  3897: 
                            	  3898: d_mess_0
00:0000D154 484F454348535445	  3899: 	dc.b	'HOECHSTERGEBNIS',$00
00:0000D15C 524745424E4953
00:0000D163 00
                            	  3900: d_mess_1
00:0000D164 535049454C455220	  3901: 	dc.b	'SPIELER ',$00
00:0000D16C 00
                            	  3902: d_mess_2
00:0000D16D 4948522045524745	  3903: 	dc.b	'IHR ERGEBNIS IST EINES DER ZEHN BESTEN',$00
00:0000D175 424E495320495354
00:0000D17D 2045494E45532044
00:0000D185 4552205A45484E20
00:0000D18D 42455354454E
00:0000D193 00
                            	  3904: d_mess_3
00:0000D194 4249545445204745	  3905: 	dc.b	'BITTE GEBEN SIE IHRE INITIALEN EIN',$00
00:0000D19C 42454E2053494520
00:0000D1A4 4948524520494E49
00:0000D1AC 5449414C454E2045
00:0000D1B4 494E
00:0000D1B6 00
                            	  3906: d_mess_4
00:0000D1B7 5A55522042554348	  3907: 	dc.b	'ZUR BUCHSTABENWAHL ROTATE DRUECKEN',$00
00:0000D1BF 53544142454E5741
00:0000D1C7 484C20524F544154
00:0000D1CF 452044525545434B
00:0000D1D7 454E
00:0000D1D9 00
                            	  3908: d_mess_5
00:0000D1DA 57454E4E20425543	  3909: 	dc.b	'WENN BUCHSTABE OK HYPERSPACE DRUECKEN',$00
00:0000D1E2 485354414245204F
00:0000D1EA 4B20485950455253
00:0000D1F2 5041434520445255
00:0000D1FA 45434B454E
00:0000D1FF 00
                            	  3910: d_mess_6
00:0000D200 53544152544B4E4F	  3911: 	dc.b	'STARTKNOEPFE DRUECKEN',$00
00:0000D208 4550464520445255
00:0000D210 45434B454E
00:0000D215 00
                            	  3912: d_mess_7
00:0000D216 535049454C454E44	  3913: 	dc.b	'SPIELENDE',$00
00:0000D21E 45
00:0000D21F 00
                            	  3914: 
                            	  3915: 	ds.w	0					; ensure even
                            	  3916: 
                            	  3917: ; french message offset table
                            	  3918: 
                            	  3919: f_messages
00:0000D220 0010            	  3920: 	dc.w	f_mess_0-f_messages		; message 0
00:0000D222 001F            	  3921: 	dc.w	f_mess_1-f_messages		; message 1
00:0000D224 0026            	  3922: 	dc.w	f_mess_2-f_messages		; message 2
00:0000D226 004A            	  3923: 	dc.w	f_mess_3-f_messages		; message 3
00:0000D228 0063            	  3924: 	dc.w	f_mess_4-f_messages		; message 4
00:0000D22A 0085            	  3925: 	dc.w	f_mess_5-f_messages		; message 5
00:0000D22C 00AE            	  3926: 	dc.w	f_mess_6-f_messages		; message 6
00:0000D22E 00C0            	  3927: 	dc.w	f_mess_7-f_messages		; message 7
                            	  3928: 
                            	  3929: f_mess_0
00:0000D230 4D45494C4C455552	  3930: 	dc.b	'MEILLEUR SCORE',$00
00:0000D238 2053434F5245
00:0000D23E 00
                            	  3931: f_mess_1
00:0000D23F 4A4F55455220    	  3932: 	dc.b	'JOUER ',$00
00:0000D245 00
                            	  3933: f_mess_2
00:0000D246 564F545245205343	  3934: 	dc.b	'VOTRE SCORE EST UN DES 10 MEILLEURS',$00
00:0000D24E 4F52452045535420
00:0000D256 554E204445532031
00:0000D25E 30204D45494C4C45
00:0000D266 555253
00:0000D269 00
                            	  3935: f_mess_3
00:0000D26A 53565020454E5452	  3936: 	dc.b	'SVP ENTREZ VOS INITIALES',$00
00:0000D272 455A20564F532049
00:0000D27A 4E495449414C4553
00:0000D282 00
                            	  3937: f_mess_4
00:0000D283 504F555353455A20	  3938: 	dc.b	'POUSSEZ ROTATE POUR VOS INITIALES',$00
00:0000D28B 524F544154452050
00:0000D293 4F555220564F5320
00:0000D29B 494E495449414C45
00:0000D2A3 53
00:0000D2A4 00
                            	  3939: f_mess_5
00:0000D2A5 504F555353455A20	  3940: 	dc.b	'POUSSEZ HYPERSPACE QUAND LETTRE CORRECTE',$00
00:0000D2AD 4859504552535041
00:0000D2B5 4345205155414E44
00:0000D2BD 204C455454524520
00:0000D2C5 434F525245435445
00:0000D2CD 00
                            	  3941: f_mess_6
00:0000D2CE 4150505559455220	  3942: 	dc.b	'APPUYER SUR START',$00
00:0000D2D6 5355522053544152
00:0000D2DE 54
00:0000D2DF 00
                            	  3943: f_mess_7
00:0000D2E0 46494E2044452050	  3944: 	dc.b	'FIN DE PARTIE',$00
00:0000D2E8 4152544945
00:0000D2ED 00
                            	  3945: 
                            	  3946: 	ds.w	0					; ensure even
                            	  3947: 
                            	  3948: ; spanish message offset table
                            	  3949: 
                            	  3950: s_messages
00:0000D2EE 0010            	  3951: 	dc.w	s_mess_0-s_messages		; message 0
00:0000D2F0 0018            	  3952: 	dc.w	s_mess_1-s_messages		; message 1
00:0000D2F2 0021            	  3953: 	dc.w	s_mess_2-s_messages		; message 2
00:0000D2F4 0048            	  3954: 	dc.w	s_mess_3-s_messages		; message 3
00:0000D2F6 0066            	  3955: 	dc.w	s_mess_4-s_messages		; message 4
00:0000D2F8 008E            	  3956: 	dc.w	s_mess_5-s_messages		; message 5
00:0000D2FA 00A0            	  3957: 	dc.w	s_mess_6-s_messages		; message 6
00:0000D2FC 00AD            	  3958: 	dc.w	s_mess_7-s_messages		; message 7
                            	  3959: 
                            	  3960: s_mess_0
00:0000D2FE 5245434F524453  	  3961: 	dc.b	'RECORDS',$00
00:0000D305 00
                            	  3962: s_mess_1
00:0000D306 4A554741444F5220	  3963: 	dc.b	'JUGADOR ',$00
00:0000D30E 00
                            	  3964: s_mess_2
00:0000D30F 53552050554E5441	  3965: 	dc.b	'SU PUNTAJE ESTA ENTRE LOS DIEZ MEJORES',$00
00:0000D317 4A45204553544120
00:0000D31F 454E545245204C4F
00:0000D327 53204449455A204D
00:0000D32F 454A4F524553
00:0000D335 00
                            	  3966: s_mess_3
00:0000D336 504F52204641564F	  3967: 	dc.b	'POR FAVOR ENTRE SUS INICIALES',$00
00:0000D33E 5220454E54524520
00:0000D346 53555320494E4943
00:0000D34E 49414C4553
00:0000D353 00
                            	  3968: s_mess_4
00:0000D354 4F5052494D412052	  3969: 	dc.b	'OPRIMA ROTATE PARA SELECCIONAR LA LETRA',$00
00:0000D35C 4F54415445205041
00:0000D364 52412053454C4543
00:0000D36C 43494F4E4152204C
00:0000D374 41204C45545241
00:0000D37B 00
                            	  3970: s_mess_5
00:0000D37C 4F5052494D412048	  3971: 	dc.b	'OPRIMA HYPERSPACE',$00
00:0000D384 5950455253504143
00:0000D38C 45
00:0000D38D 00
                            	  3972: s_mess_6
00:0000D38E 50554C5341522053	  3973: 	dc.b	'PULSAR START',$00
00:0000D396 54415254
00:0000D39A 00
                            	  3974: s_mess_7
00:0000D39B 4A5545474F205445	  3975: 	dc.b	'JUEGO TERMINADO',$00
00:0000D3A3 524D494E41444F
00:0000D3AA 00
                            	  3976: 
                            	  3977: 	ds.w	0					; ensure even
                            	  3978: 
                            	  3979: 
                            	  3980: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3981: ;
                            	  3982: ; include files
                            	  3983: 
                            	  3984: 	INCLUDE	"games/asteroids/sounds.x68"

Source: "games\asteroids\sounds.x68"
                            	     1: *************************************************************************************
                            	     2: *														*
                            	     3: *	Sound routines V1.00. This is an include file for asteroids 1_0.x68		*
                            	     4: *														*
                            	     5: *	load the sounds, play an indexed sample. Uses the DirextX sound play and	*
                            	     6: *	requires EASy68K 3.7.10 beta or later.							*
                            	     7: *														*
                            	     8: *************************************************************************************
                            	     9: 
                            	    10: sfire_snd	EQU  0
                            	    11: pfire_snd	EQU  1
                            	    12: thrst_snd	EQU  2
                            	    13: smsau_snd	EQU  3
                            	    14: lgsau_snd	EQU  4
                            	    15: sexpl_snd	EQU  5
                            	    16: mexpl_snd	EQU  sexpl_snd+1
                            	    17: lexpl_snd	EQU  sexpl_snd+2
                            	    18: beat1_snd	EQU  8				* beat_2 must be beat_1 XOR 1
                            	    19: beat2_snd	EQU  9				* see above
                            	    20: extra_snd	EQU 10
                            	    21: 
                            	    22: 
                            	    23: *************************************************************************************
                            	    24: *
                            	    25: * initialise the sounds routine
                            	    26: 
                            	    27: sound_init
00:0000D3AC 422B0014        	    28: 	MOVE.b	#0,s_key(a3)		* clear the last [S] key status
00:0000D3B0 177C00FF0015    	    29: 	MOVE.b	#-1,play_sound(a3)	* set the sound flag
                            	    30: 
00:0000D3B6 43FA0098        	    31: 	LEA		beat1_sound(pc),a1	* point to the background beat sound file name
00:0000D3BA 7208            	    32: 	MOVEQ		#beat1_snd,d1		* index 10
00:0000D3BC 614E            	    33: 	BSR.s		load_sound			* load the sound into directx memory
                            	    34: 
00:0000D3BE 43FA00A2        	    35: 	LEA		beat2_sound(pc),a1	* point to the background beat sound file name
00:0000D3C2 7209            	    36: 	MOVEQ		#beat2_snd,d1		* index 9
00:0000D3C4 6146            	    37: 	BSR.s		load_sound			* load the sound into directx memory
                            	    38: 
00:0000D3C6 43FA00AC        	    39: 	LEA		lexpl_sound(pc),a1	* point to the large explosion sound file name
00:0000D3CA 7207            	    40: 	MOVEQ		#lexpl_snd,d1		* index 8
00:0000D3CC 613E            	    41: 	BSR.s		load_sound			* load the sound into directx memory
                            	    42: 
00:0000D3CE 43FA00B9        	    43: 	LEA		mexpl_sound(pc),a1	* point to the medium explosion sound file name
00:0000D3D2 7206            	    44: 	MOVEQ		#mexpl_snd,d1		* index 7
00:0000D3D4 6136            	    45: 	BSR.s		load_sound			* load the sound into directx memory
                            	    46: 
00:0000D3D6 43FA00C6        	    47: 	LEA		sexpl_sound(pc),a1	* point to the small explosion sound file name
00:0000D3DA 7205            	    48: 	MOVEQ		#sexpl_snd,d1		* index 6
00:0000D3DC 612E            	    49: 	BSR.s		load_sound			* load the sound into directx memory
                            	    50: 
00:0000D3DE 43FA00D3        	    51: 	LEA		extra_sound(pc),a1	* point to the extra life sound file name
00:0000D3E2 720A            	    52: 	MOVEQ		#extra_snd,d1		* index 5
00:0000D3E4 6126            	    53: 	BSR.s		load_sound			* load the sound into directx memory
                            	    54: 
00:0000D3E6 43FA00E1        	    55: 	LEA		lgsau_sound(pc),a1	* point to the large saucer sound file name
00:0000D3EA 7204            	    56: 	MOVEQ		#lgsau_snd,d1		* index 4
00:0000D3EC 6124            	    57: 	BSR.s		load_old_sound		* load the sound into sound memory
                            	    58: 
00:0000D3EE 43FA00EE        	    59: 	LEA		smsau_sound(pc),a1	* point to the small saucer sound file name
00:0000D3F2 7203            	    60: 	MOVEQ		#smsau_snd,d1		* index 3
00:0000D3F4 611C            	    61: 	BSR.s		load_old_sound		* load the sound into directx memory
                            	    62: 
00:0000D3F6 43FA00FB        	    63: 	LEA		thrst_sound(pc),a1	* point to the ship thrust sound file name
00:0000D3FA 7202            	    64: 	MOVEQ		#thrst_snd,d1		* index 2
00:0000D3FC 610E            	    65: 	BSR.s		load_sound			* load the sound into directx memory
                            	    66: 
00:0000D3FE 43FA0106        	    67: 	LEA		pfire_sound(pc),a1	* point to the player fire sound file name
00:0000D402 7201            	    68: 	MOVEQ		#pfire_snd,d1		* index 1
00:0000D404 6106            	    69: 	BSR.s		load_sound			* load the sound into directx memory
                            	    70: 
00:0000D406 43FA0110        	    71: 	LEA		sfire_sound(pc),a1	* point to the saucer fire sound file name
00:0000D40A 7200            	    72: 	MOVEQ		#sfire_snd,d1		* index 0
                            	    73: 
                            	    74: 
                            	    75: *************************************************************************************
                            	    76: *
                            	    77: * load the sound into directx memory
                            	    78: 
                            	    79: load_sound
00:0000D40C 704A            	    80: 	MOVEQ		#74,d0			* load the sound into directx memory
00:0000D40E 4E4F            	    81: 	TRAP		#15
                            	    82: 
00:0000D410 4E75            	    83: 	RTS
                            	    84: 
                            	    85: 
                            	    86: *************************************************************************************
                            	    87: *
                            	    88: * load the sound into sound memory
                            	    89: 
                            	    90: load_old_sound
00:0000D412 7047            	    91: 	MOVEQ		#71,d0			* load the sound into sound memory
00:0000D414 4E4F            	    92: 	TRAP		#15
                            	    93: 
00:0000D416 4E75            	    94: 	RTS
                            	    95: 
                            	    96: 
                            	    97: *************************************************************************************
                            	    98: *
                            	    99: * play a sound sample
                            	   100: 
                            	   101: play_sample
00:0000D418 4A2B001A        	   102: 	TST.b		num_players(a3)		* test the number of players in the game
00:0000D41C 6718            	   103: 	BEQ.s		exit_play_sample		* if no players left just exit
                            	   104: 
00:0000D41E 4A2B0015        	   105: 	TST.b		play_sound(a3)		* test the sound flag
00:0000D422 6712            	   106: 	BEQ.s		exit_play_sample		* if the sound is off just exit
                            	   107: 
00:0000D424 7048            	   108: 	MOVEQ		#72,d0			* play a sound from sound memory
00:0000D426 0C410003        	   109: 	CMPI.w	#smsau_snd,d1		* is it the small saucer sound
00:0000D42A 6708            	   110: 	BEQ.s		old_sound_play		* if so go play it with the old player
                            	   111: 
00:0000D42C 0C410004        	   112: 	CMPI.w	#lgsau_snd,d1		* is it the large saucer sound
00:0000D430 6702            	   113: 	BEQ.s		old_sound_play		* if so go play it with the old player
                            	   114: 
00:0000D432 704B            	   115: 	MOVEQ		#75,d0			* play a sound from directx memory
                            	   116: old_sound_play
00:0000D434 4E4F            	   117: 	TRAP		#15
                            	   118: 
                            	   119: exit_play_sample
00:0000D436 4E75            	   120: 	RTS
                            	   121: 
                            	   122: 
                            	   123: *************************************************************************************
                            	   124: *
                            	   125: * test the sound key
                            	   126: 
                            	   127: sound_key
00:0000D438 7253            	   128: 	MOVEQ		#$53,d1			* [][][][S] key
00:0000D43A 7013            	   129: 	MOVEQ		#19,d0			* check for keypress
00:0000D43C 4E4F            	   130: 	TRAP		#15
                            	   131: 
00:0000D43E 102B0014        	   132: 	MOVE.b	s_key(a3),d0		* get the last key(s) state
00:0000D442 B300            	   133: 	EOR.b		d1,d0				* compare the result with the last key(s) state,
                            	   134: 							* each byte is now $FF if a key has changed or
                            	   135: 							* $00 if a key has not changed
00:0000D444 C001            	   136: 	AND.b		d1,d0				* make each byte $FF if key just pressed or
                            	   137: 							* $00 if key not just pressed
00:0000D446 B12B0015        	   138: 	EOR.b		d0,play_sound(a3)		* if key just pressed toggle the sound flag
00:0000D44A 17410014        	   139: 	MOVE.b	d1,s_key(a3)		* save the last [S] key status
00:0000D44E 4E75            	   140: 	RTS
                            	   141: 
                            	   142: 
                            	   143: *************************************************************************************
                            	   144: *
                            	   145: * sound file names
                            	   146: 
                            	   147: beat1_sound
00:0000D450 73616D706C65735C	   148: 	dc.b	'samples\beat1.wav',$00		* background beat sound
00:0000D458 62656174312E7761
00:0000D460 76
00:0000D461 00
                            	   149: 
                            	   150: beat2_sound
00:0000D462 73616D706C65735C	   151: 	dc.b	'samples\beat2.wav',$00		* background beat sound
00:0000D46A 62656174322E7761
00:0000D472 76
00:0000D473 00
                            	   152: 
                            	   153: lexpl_sound
00:0000D474 73616D706C65735C	   154: 	dc.b	'samples\lexplode.wav',$00	* large explosion sound
00:0000D47C 6C6578706C6F6465
00:0000D484 2E776176
00:0000D488 00
                            	   155: 
                            	   156: mexpl_sound
00:0000D489 73616D706C65735C	   157: 	dc.b	'samples\mexplode.wav',$00	* medium explosion sound
00:0000D491 6D6578706C6F6465
00:0000D499 2E776176
00:0000D49D 00
                            	   158: 
                            	   159: sexpl_sound
00:0000D49E 73616D706C65735C	   160: 	dc.b	'samples\sexplode.wav',$00	* small explosion sound
00:0000D4A6 736578706C6F6465
00:0000D4AE 2E776176
00:0000D4B2 00
                            	   161: 
                            	   162: extra_sound
00:0000D4B3 73616D706C65735C	   163: 	dc.b	'samples\extraship.wav',$00	* extra life sound
00:0000D4BB 6578747261736869
00:0000D4C3 702E776176
00:0000D4C8 00
                            	   164: 
                            	   165: lgsau_sound
00:0000D4C9 73616D706C65735C	   166: 	dc.b	'samples\lgsaucer.wav',$00	* large saucer sound
00:0000D4D1 6C67736175636572
00:0000D4D9 2E776176
00:0000D4DD 00
                            	   167: 
                            	   168: smsau_sound
00:0000D4DE 73616D706C65735C	   169: 	dc.b	'samples\smsaucer.wav',$00	* small saucer sound
00:0000D4E6 736D736175636572
00:0000D4EE 2E776176
00:0000D4F2 00
                            	   170: 
                            	   171: thrst_sound
00:0000D4F3 73616D706C65735C	   172: 	dc.b	'samples\thrust.wav',$00	* ship thrust sound
00:0000D4FB 7468727573742E77
00:0000D503 6176
00:0000D505 00
                            	   173: 
                            	   174: pfire_sound
00:0000D506 73616D706C65735C	   175: 	dc.b	'samples\pfire.wav',$00		* player fire sound
00:0000D50E 70666972652E7761
00:0000D516 76
00:0000D517 00
                            	   176: 
                            	   177: sfire_sound
00:0000D518 73616D706C65735C	   178: 	dc.b	'samples\sfire.wav',$00		* saucer fire sound
00:0000D520 73666972652E7761
00:0000D528 76
00:0000D529 00
                            	   179: 
                            	   180: 	ds.w	0					* ensure even
                            	   181: 
                            	   182: 
                            	   183: *************************************************************************************
                            	   184: 
                            	   185: 

Source: "games\asteroids\asteroids 1_0.x68"
                            	  3985: 							; sound routines
                            	  3986: 
                            	  3987: 
                            	  3988: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3989: ;
                            	  3990: ; high score table filename
                            	  3991: 
                            	  3992: filename
00:0000D52A 61737465726F6964	  3993: 	dc.b		'asteroids.hi',0		; highscore filename
00:0000D532 732E6869
00:0000D536 00
                            	  3994: 	ds.w		0				; ensure even
                            	  3995: 
                            	  3996: 
                            	  3997: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  3998: ;
                            	  3999: ; variables
                            	  4000: 
                            	  4001: variables
                            	  4002: 
                            	  4003: 	OFFSET	0				; going to use relative addressing
                            	  4004: 
                            	  4005: vector_s
                            	  4006: ;##	ds.w	1				; vector scale
02:00000000 0000            	  4007: glob_scale	ds.w	1				; global scale
                            	  4008: 
                            	  4009: 
02:00000002 0000            	  4010: local_x	ds.w	1				; local screen x co-ordinate offset
02:00000004 0000            	  4011: local_y	ds.w	1				; local screen y co-ordinate offset
                            	  4012: 
02:00000006 0000            	  4013: scr_x		ds.w	1				; screen x size
02:00000008 0000            	  4014: scr_y		ds.w	1				; screen y size
                            	  4015: 
02:0000000A 00000000        	  4016: PRNlword	ds.l	1				; PRNG seed long word
                            	  4017: 
02:0000000E 00000000        	  4018: switch_addr	ds.l	1				; hardware switch address
                            	  4019: 
02:00000012 0000            	  4020: hiscore_y	ds.w	1				; high score y co-ordinate
                            	  4021: 
                            	  4022: 
02:00000014 00              	  4023: s_key		ds.b	1				; last [s] key status
02:00000015 00              	  4024: play_sound	ds.b	1				; sound flag
                            	  4025: 
02:00000016 00              	  4026: suppress_0	ds.b	1				; leading zero suppress flag
                            	  4027: 							; 0 = don't suppress
                            	  4028: 
02:00000017 00              	  4029: high_idx	ds.b	1				; high score index, single byte, 1 to 10 in BCD
                            	  4030: 
02:00000018 00              	  4031: player_idx	ds.b	1				; player index
                            	  4032: 							; 0 = player 1
                            	  4033: 							; 1 = player 2
                            	  4034: 
02:00000019 00              	  4035: past_play	ds.b	1				; number of players that were in the game
                            	  4036: 
02:0000001A 00              	  4037: num_players	ds.b	1				; number of players in the game
                            	  4038: 							; $00 - game over
                            	  4039: 							; $01 - 1 player game
                            	  4040: 							; $02 - 2 player game
                            	  4041: 							; $FF - game over, high score not checked
                            	  4042: 
02:0000001B 00              	  4043: ss_count	ds.b	1				; starting ship count
                            	  4044: 
02:0000001C 00              	  4045: px_time	ds.b	1				; "PLAYER x" timer. while this is non zero
                            	  4046: 							; "PLAYER x" will be displayed. this is used at
                            	  4047: 							; the beginning of any game and at the beginning
                            	  4048: 							; of each turn in a two player game
                            	  4049: 
02:0000001D 00              	  4050: sixteen_ms	ds.b	1				; 16ms counter, incremented every 16ms by the
                            	  4051: 							; timer interrupt and cleared by the main
                            	  4052: 							; program loop
                            	  4053: 
02:0000001E 00              	  4054: p_orient	ds.b	1				; player orientation, this is shared by both
                            	  4055: 							; players as it is in the arcade machine
                            	  4056: 							;
                            	  4057: 							; $00 = right
                            	  4058: 							; $40 = up
                            	  4059: 							; $80 = left
                            	  4060: 							; $C0 = down
                            	  4061: 							;
                            	  4062: 							; this is $00 = right then anticlockwise each
                            	  4063: 							; positive step being 1.40625 degrees so that
                            	  4064: 							; by the time you get back to $00 one full
                            	  4065: 							; rotation has been done
                            	  4066: 
02:0000001F 00              	  4067: s_orient	ds.b	1				; shot direction, see above
                            	  4068: 
02:00000020 00              	  4069: hi_char	ds.b	1				; high score input character index
                            	  4070: 
02:00000021 00              	  4071: last_fire	ds.b	1				; fire key last state register
02:00000022 00              	  4072: last_hype	ds.b	1				; hyperspace key last state register
                            	  4073: 
02:00000023 00              	  4074: thump_snd	ds.b	1				; thump sound value
02:00000024 00              	  4075: thump_time	ds.b	1				; thump sound change timer
02:00000025 00              	  4076: time_count	ds.b	1				; game counter byte
                            	  4077: 
02:00000026 00              	  4078: hyper		ds.b	1				; hyperspace flag
                            	  4079: 							; $00 = no jump
                            	  4080: 							; $01 = jump successful
                            	  4081: 							; $80 = jump unsuccessful
                            	  4082: 							; $xx = 
                            	  4083: 
                            	  4084: 		ds.w	0
                            	  4085: 
02:00000027 0000            	  4086: hiscores	ds.w	10				; high score table, each score is a BCD word
02:00000029 *
02:0000003B 00              	  4087: hinames	ds.b	3*10				; high score initials table
02:0000003C *
                            	  4088: 
02:00000059 0000            	  4089: game_count	ds.w	1				; game counter word
                            	  4090: 
02:0000005B 0000            	  4091: expl_x_pos	ds.w	6				; player ship explosion pieces x positions
02:0000005D *
                            	  4092: 
02:00000067 0000            	  4093: expl_y_pos	ds.w	6				; player ship explosion pieces y positions
02:00000069 *
                            	  4094: 
                            	  4095: 
                            	  4096: ; player 1 variables
                            	  4097: 
                            	  4098: player_1	EQU	*+$80				; player one variables base
                            	  4099: 
                            	  4100: x_pos_off	EQU	*-player_1			; offset to the x position base
02:00000073 0000            	  4101: 		ds.w	$1B				; item x position base address
02:00000075 *
                            	  4102: 
                            	  4103: p_xpos_off	EQU	*-player_1			; offset to the player x position
02:000000A9 0000            	  4104: 		ds.w	1				; player x position
                            	  4105: 
                            	  4106: s_xpos_off	EQU	*-player_1			; offset to the saucer x position
02:000000AB 0000            	  4107: 		ds.w	1				; saucer x position
                            	  4108: 
                            	  4109: f_xpos_off	EQU	*-player_1			; offset to the player x position
02:000000AD 0000            	  4110: 		ds.w	6				; fire objects x position
02:000000AF *
                            	  4111: x_pos_end	EQU	*-player_1			; offset to the flags end
                            	  4112: 
                            	  4113: y_pos_off	EQU	*-player_1			; offset to the y position base
02:000000B9 0000            	  4114: 		ds.w	$1B				; item y position base address
02:000000BB *
                            	  4115: 
                            	  4116: p_ypos_off	EQU	*-player_1			; offset to the player y position
02:000000EF 0000            	  4117: 		ds.w	1				; player y position
                            	  4118: s_ypos_off	EQU	*-player_1			; offset to the saucer y position
02:000000F1 0000            	  4119: 		ds.w	1				; saucer y position
                            	  4120: 
                            	  4121: f_ypos_off	EQU	*-player_1			; offset to the player y position
02:000000F3 0000            	  4122: 		ds.w	6				; fire objects y position
02:000000F5 *
                            	  4123: 
                            	  4124: 							; items $xx00 to $xx1A are rocks
                            	  4125: 							; $00 = no item
                            	  4126: 							; $0x = item exists
                            	  4127: 							; $Ax = item exploding
                            	  4128: 
                            	  4129: flags_off	EQU	*-player_1			; offset to the flags base
02:000000FF 00              	  4130: 		ds.b	$1B				; space for the rock flags
02:00000100 *
                            	  4131: 
                            	  4132: p_flag_off	EQU	*-player_1			; offset to the player flag
02:0000011A 00              	  4133: 		ds.b	1				; player flag
                            	  4134: 
                            	  4135: s_flag_off	EQU	*-player_1			; offset to the saucer flag
02:0000011B 00              	  4136: 		ds.b	1				; saucer flag
                            	  4137: 							; $00 = no saucer
                            	  4138: 							; $01 = small saucer
                            	  4139: 							; $02 = large saucer
                            	  4140: 							; $8x = saucer exploding
                            	  4141: 
                            	  4142: s_fire_off	EQU	*-player_1			; offset to the saucer fire flags
02:0000011C 00              	  4143: 		ds.b	2				; saucer fire objects
02:0000011D *
                            	  4144: 
                            	  4145: p_fire_off	EQU	*-player_1			; offset to the player fire flags
02:0000011E 00              	  4146: 		ds.b	4				; player fire objects
02:0000011F *
                            	  4147: flag_end	EQU	*-player_1			; offset to the flags end
                            	  4148: 
                            	  4149: x_vel_off	EQU	*-player_1			; offset to the x velocity base
02:00000122 00              	  4150: 		ds.b	$1B				; item x velocity base address
02:00000123 *
                            	  4151: 
                            	  4152: p_xvel_off	EQU	*-player_1			; offset to the player x velocity
02:0000013D 00              	  4153: 		ds.b	1				; player x velocity
                            	  4154: 
                            	  4155: s_xvel_off	EQU	*-player_1			; offset to the saucer x velocity
02:0000013E 00              	  4156: 		ds.b	1				; saucer x velocity
                            	  4157: 
                            	  4158: f_xvel_off	EQU	*-player_1			; offset to the fire objects x velocity
02:0000013F 00              	  4159: 		ds.b	6				; fire objects x velocity
02:00000140 *
                            	  4160: 
                            	  4161: y_vel_off	EQU	*-player_1			; offset to the x velocity base
02:00000145 00              	  4162: 		ds.b	$1B				; item y velocity base address
02:00000146 *
                            	  4163: 
                            	  4164: p_yvel_off	EQU	*-player_1			; offset to the player y velocity
02:00000160 00              	  4165: 		ds.b	1				; player y velocity
                            	  4166: 
                            	  4167: s_yvel_off	EQU	*-player_1			; offset to the saucer y velocity
02:00000161 00              	  4168: 		ds.b	1				; saucer y velocity
                            	  4169: 
                            	  4170: f_yvel_off	EQU	*-player_1			; offset to the fire objects y velocity
02:00000162 00              	  4171: 		ds.b	6				; fire objects y velocity
02:00000163 *
                            	  4172: 
                            	  4173: 
                            	  4174: i_rk_count	EQU	*-player_1			; offset to the initial rock count
02:00000168 00              	  4175: 		ds.b	1				; initial rock count
                            	  4176: rock_count	EQU	*-player_1			; offset to the rock count
02:00000169 00              	  4177: 		ds.b	1				; rock count
                            	  4178: 
                            	  4179: sauc_cntdn	EQU	*-player_1			; offset to the saucer countdown timer
02:0000016A 00              	  4180: 		ds.b	1				; saucer countdown timer
                            	  4181: 
                            	  4182: i_sauc_tim	EQU	*-player_1			; offset to the initial saucer timer
02:0000016B 00              	  4183: 		ds.b	1				; small saucer boundary/initial saucer timer
                            	  4184: 
                            	  4185: r_hit_tim	EQU	*-player_1			; offset to the rock hit timer
02:0000016C 00              	  4186: 		ds.b	1				; rock hit timer. if this times out because the
                            	  4187: 							; player hasn't shot a rock for a while then
                            	  4188: 							; the saucer timer initial value is decremented
                            	  4189: 							; so that the saucers come faster if the player
                            	  4190: 							; is just ignoring the last rock
                            	  4191: 
                            	  4192: hide_p_cnt	EQU	*-player_1			; offset to the hide the player count
02:0000016D 00              	  4193: 		ds.b	1				; hide the player count. when this count is non
                            	  4194: 							; zero the player is not displayed and the
                            	  4195: 							; thump sound does not sound. this count is set
                            	  4196: 							; to various lengths after certain events have
                            	  4197: 							; occured
                            	  4198: 							;
                            	  4199: 							; $0x player hidden, will appear
                            	  4200: 							; $8x player hidden, gonna die
                            	  4201: 
                            	  4202: new_rocks	EQU	*-player_1			; offset to the new rocks flag
02:0000016E 00              	  4203: 		ds.b	1				; generate new rocks flag
                            	  4204: 							; 0 = generate new rocks
                            	  4205: thmp_sndi	EQU	*-player_1			; offset to the thump sound change initial value
02:0000016F 00              	  4206: 		ds.b	1				; thump sound change timer initial value
                            	  4207: 
                            	  4208: min_rocks	EQU	*-player_1			; offset to the minimum rock count
02:00000170 00              	  4209: 		ds.b	1				; minimum rock count before the saucer initial
                            	  4210: 							; timer starts to decrement
                            	  4211: 
                            	  4212: p_xvlo_off	EQU	*-player_1			; offset to the player y velocity low byte
02:00000171 00              	  4213: 		ds.b	1				; player x velocity low byte
                            	  4214: p_yvlo_off	EQU	*-player_1			; offset to the player y velocity low byte
02:00000172 00              	  4215: 		ds.b	1				; player y velocity low byte
                            	  4216: 
                            	  4217: 		ds.w	0				; ensure even
                            	  4218: 
                            	  4219: score_off	EQU	*-player_1			; offset to the score word
02:00000173 0000            	  4220: p1_score	ds.w	1				; player score
                            	  4221: 
                            	  4222: ships_off	EQU	*-player_1			; offset to the ship count
02:00000175 00              	  4223: p1_ships	ds.b	1				; player 1 ship count
                            	  4224: 
                            	  4225: high_off	EQU	*-player_1			; offset to the player entering hiscore flag
02:00000176 00              	  4226: p1_high	ds.b	1				; player 1 highscore flag
                            	  4227: 							; $0x - entering high score, also index
                            	  4228: 							; $8x - done
                            	  4229: 
                            	  4230: 
                            	  4231: 		ds.w	0				; ensure even
                            	  4232: 
                            	  4233: ; player 2 variables
                            	  4234: 
                            	  4235: 
                            	  4236: player_2	EQU	*+$80				; player two variables base
02:00000177 00              	  4237: 		ds.b	score_off+$80		; space for the player two variables
02:00000178 *
                            	  4238: 
02:00000277 0000            	  4239: p2_score	ds.w	1				; player 2 score
                            	  4240: 
02:00000279 00              	  4241: p2_ships	ds.b	1				; player 2 ship count
                            	  4242: 
02:0000027A 00              	  4243: p2_high	ds.b	1				; player 2 highscore flag
                            	  4244: 							; $0x - entering high score, also index
                            	  4245: 							; $8x - done
                            	  4246: 
                            	  4247: 		ds.w	0				; ensure even
                            	  4248: 
                            	  4249: p_2_end
                            	  4250: 
                            	  4251: 
                            	  4252: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  4253: 
                            	  4254: 
                            	  4255: ;	END	asteroids_start
                            	  4256: 
                            	  4257: 
                            	  4258: ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                            	  4259: 

Source: "boot.x68"
                            	  4017: 


Symbols by name:
ABCD_INNER1                     00:00004852
ABCD_INNER2                     00:000048C0
ABCD_NO_C1                      00:0000486E
ABCD_NO_C2                      00:00004876
ABCD_NO_C3                      00:000048DC
ABCD_NO_C4                      00:000048E4
ABCD_OUTER1                     00:00004850
ABCD_OUTER2                     00:000048BE
ABS                             00:00006F34
ACIA                             E:FD060000
ACIA_CMD                         E:00000008
ACIA_CTRL                        E:0000000C
ACIA_RX                          E:00000000
ACIA_STAT                        E:00000004
ACIA_TX                          E:00000000
ADDA_OUTER1                     00:000053C0
ADDQ_LOOP1                      00:00004BDA
ADDQ_LOOP2                      00:00004C18
ADDQ_LOOP3                      00:00004C4E
ADDX_LOOP3                      00:000054E6
ADDX_LOOP4                      00:00005502
ADDX_LOOP5                      00:0000551E
ADDX_OUTER1                     00:00005452
ADD_OUTER1                      00:000051E6
ADD_OUTER2                      00:0000525A
AHOW                            00:000071AC
ALL_DONE                        00:000025B4
AND_OUTER1                      00:00004F04
AND_OUTER2                      00:00004F78
ASORRY                          00:000071A4
AUXIN                           00:000074D0
AUXOUT                          00:000074BC
AWHAT                           00:00007164
AXIRET                          00:000074EE
AllocateString                  00:00006C4C
ArmAllBreakpoints               00:000093E4
ArmBreakpoint                   00:00009414
AsciiToHexNybble                00:00008E20
AudioInputTest                  00:000091C6
BCC1                            00:00004AF8
BCC10                           00:00004B4A
BCC11                           00:00004B52
BCC12                           00:00004B5C
BCC13                           00:00004B64
BCC14                           00:00004B6E
BCC2                            00:00004B02
BCC3                            00:00004B0A
BCC4                            00:00004B14
BCC5                            00:00004B1C
BCC6                            00:00004B26
BCC7                            00:00004B2E
BCC8                            00:00004B38
BCC9                            00:00004B40
BLANK                            E:00000020
BRTBL                           00:00009DDA
BSR_CLOSE1                      00:00003688
BSR_CLOSE2                      00:000036BE
BSR_FAR1                        00:000025B6
BSR_FAR2                        00:00004AE8
BUFFER                          00:000075C0
BUFLEN                           E:00000050
BUFSIZE                          E:0000003F
BYEBYE                          00:000074F0
BlankLastLine                   00:00001456
BouncingBalls                   00:000091C8
BreakpointWords                  E:00040280
Breakpoints                      E:00040220
BufByte                         00:00008EAC
BufNybble                       00:00008EB2
BufTetra                        00:00008EA0
BufWyde                         00:00008EA6
CALL                            00:000068F2
CHKIO                           00:00007462
CHKRET                          00:00007472
CHR                             00:000070DE
CLMSG                           00:00007558
CLS                             00:00007480
CMPA_OUTER1                     00:000050DA
CMPM_LOOP1                      00:00005168
CMPM_LOOP2                      00:00005182
CMPM_LOOP3                      00:0000519C
CMP_OUTER1                      00:00005064
COMMON                          00:0000A1CC
COMMON35                        00:0000A1DA
COMMON4                         00:0000A1CA
COM_CMDTBL                      00:00001538
CORENO                          00:00006F5C
CR                               E:0000000D
CRLF                            00:00007676
CS11                            00:00009C10
CS12                            00:00009B80
CS13                            00:00009B06
CS14                            00:00009A9C
CS15                            00:00009A5E
CS16                            00:000099F0
CS17                            00:00009DA6
CS18                            00:00009D42
CS19                            00:00009E52
CS20                            00:00009CAA
CSTART                          00:00006046
CTRLC                            E:00000003
CTRLH                            E:00000008
CTRLS                            E:00000013
CTRLX                            E:00000018
CTRLZ                            E:0000001A
CURRNT                          00:00007568
CalcScreenLoc                   00:0000122A
CallOS                          00:00000240
CheckForCtrlC                   00:000008AE
CheckForKey                     00:00000868
CheckNumeric                    00:000069BC
ClearBreakpointList             00:00009506
ClearScreen                     00:000091CC
ClearStringArea                 00:00006170
ClearStringStack                00:00006190
CmdBuf                           E:00040040
CmdBufEnd                        E:00040080
ConcatString                    00:00006AC8
Cursor1                         00:00007B10
DBCC_LOOP1                      00:00004B78
DBCC_LOOP2                      00:00004B86
DCB_BKCOLOR                      E:00000060
DCB_CMDPROC                      E:00000018
DCB_FGCOLOR                      E:00000064
DCB_INBUFPTR                     E:00000038
DCB_INBUFPTR2                    E:00000070
DCB_INBUFSIZE                    E:00000040
DCB_INDIMX                       E:00000048
DCB_INDIMY                       E:0000004C
DCB_INDIMZ                       E:00000050
DCB_INPOSX                       E:0000002C
DCB_INPOSY                       E:00000030
DCB_INPOSZ                       E:00000034
DCB_MAGIC                        E:00000000
DCB_NAME                         E:00000004
DCB_OPCODE                       E:00000068
DCB_OUTBUFPTR                    E:0000003C
DCB_OUTBUFPTR2                   E:00000074
DCB_OUTBUFSIZE                   E:00000044
DCB_OUTBUFSIZE2                  E:0000007C
DCB_OUTDIMX                      E:00000054
DCB_OUTDIMY                      E:00000058
DCB_OUTDIMZ                      E:0000005C
DCB_OUTPOSX                      E:00000020
DCB_OUTPOSY                      E:00000024
DCB_OUTPOSZ                      E:00000028
DCB_SIZE                         E:00000084
DCB_UNIT                         E:00000080
DCODE68K                        00:0000A132
DDATA                            E:FFFFFFF0
DEC311                          00:0000A146
DEC404                          00:0000A164
DEC411                          00:0000A174
DEC425                          00:0000A184
DEC510                          00:0000A190
DEC515                          00:0000A194
DEC530                          00:0000A19C
DEC535                          00:0000A1A2
DEC537                          00:0000A1AE
DEFLT                           00:00006782
DEV_CLEAR                        E:0000000C
DEV_GETBUF1                      E:00000010
DEV_GET_COLOR                    E:00000015
DEV_GET_DIMEN                    E:00000014
DEV_GET_OUTPOS                   E:00000017
DEV_GET_OUTPTR                   E:00000018
DEV_PUTCHAR                      E:00000002
DEV_SET_COLOR_DEPTH              E:00000021
DEV_SET_DIMEN                    E:00000020
DEV_SET_OUTPOS                   E:00000007
DEV_SWAPBUF                      E:0000000D
DEV_WRITEAT                      E:00000012
DIRECT                          00:0000634C
DIRFLG                          00:000075BC
DIV1                            00:00006E78
DIV2                            00:00006E7E
DIV3                            00:00006E84
DIV32                           00:00006E66
DIV4                            00:00006E92
DIVRT                           00:00006EA0
DIVS_OUTER1                     00:00004DC4
DIVU_OUTER1                     00:00004D72
DOMID                           00:0000700C
DOQUO                           00:00007440
DOQUO1                          00:00007448
DRAW                             E:0000A000
DT_NUMERIC                       E:00000001
DT_STRING                        E:00000002
Delay3s                         00:00002496
Delay3s2                        00:000024BA
Diagonal1                       00:00007994
Diagonal2                       00:000079B4
DisarmAllBreakpoints            00:000093B8
DisarmBreakpoint                00:00009492
DispatchMsg                     00:00009598
DisplayAddr                     00:00008ECA
DisplayByte                     00:00008E80
DisplayHelp                     00:00007F0A
DisplayMem                      00:0000873A
DisplayNybble                   00:00008E86
DisplaySpace                    00:00008E6C
DisplayString                   00:00007690
DisplayStringCRLF               00:000076A6
DisplayStringLimited            00:000076AA
DisplayStringLimitedCRLF        00:000076CA
DisplayTetra                    00:00008E74
DisplayTwoSpaces                00:00008E5A
DisplayWyde                     00:00008E7A
DrawHorizTo                     00:00007AAE
DrawToXY                        00:00007A30
DrawVertTo                      00:00007AE0
DumpMem1                        00:00008728
EA000                           00:00009E82
EA001                           00:00009E8E
EA010                           00:00009E9A
EA011                           00:00009EAE
EA011RTS                        00:00009EC4
EA100                           00:00009EC6
EA101                           00:00009F68
EA1105                          00:00009F44
EA1107                          00:00009F48
EA1109                          00:00009F5E
EA111                           00:00009F7E
EA1112                          00:00009F9C
EA1113                          00:00009FB8
EA1113A                         00:00009FC8
EA1114                          00:00009FEA
EA1115                          00:0000A054
EA11153                         00:0000A08C
EA11155                         00:0000A096
EAF25                           00:0000A032
EAF27                           00:0000A036
EAF35                           00:0000A04A
EEA                             00:00009EE0
EEA10                           00:00009B0E
ENDCHK                          00:00007150
ENDCHK1                         00:00007160
ENDMEM                          00:00006042
EOR_OUTER2                      00:00004FEE
EOT                              E:00000004
ERROR                           00:00007168
ETYPE                           00:000071B2
EX1                             00:00006386
EXCEPTION_6                     00:000025BE
EXCEPTION_7                     00:000025C6
EXEC                            00:0000635C
EXGO                            00:00006392
EXLP                            00:00006364
EXMAT                           00:0000638C
EXNGO                           00:0000636E
EXP4RT                          00:00006BBC
EXPR                            00:00006968
EXPR2                           00:00006A58
EXPR3                           00:00006B36
EXPR4                           00:00006BA0
EXPR_AND                        00:0000698E
EXPR_OR                         00:00006968
EXPR_REL                        00:000069CE
E_BadDevNum                      E:00000020
E_Func                           E:00000002
E_NotAlloc                       E:00000009
E_NotSupported                   E:0000000A
E_Ok                             E:00000000
EditMemHelper                   00:000082F8
ExecuteCode                     00:0000838E
FDATA                            E:0000000A
FE10                            00:00009EDC
FE11                            00:00009FC4
FE12                            00:0000A182
FERROR                          00:0000A1F4
FERROR35                        00:0000A1FE
FERROR39                        00:0000A20A
FI1                             00:00007142
FI2                             00:0000714E
FIN                             00:00007136
FINISH                          00:0000656A
FMTK_SEMA                        E:00000008
FNDLN                           00:00007256
FNDLNP                          00:00007264
FNDNXT                          00:0000727C
FNDRET                          00:0000727A
FNDSKP                          00:0000727E
FOC                              E:0000001F
FOP                              E:00000027
FOR                             00:000065D8
FORM1                           00:00009A94
FORM10                          00:00009B50
FORM103                         00:00009B56
FORM104                         00:00009B5A
FORM105                         00:00009B6A
FORM10E3                        00:00009B34
FORM10E4                        00:00009B3C
FORM10E6                        00:00009B48
FORM10EX                        00:00009B12
FORM11                          00:00009B84
FORM112                         00:00009BA0
FORM114                         00:00009BAE
FORM11SL                        00:00009B8C
FORM12                          00:00009BB0
FORM125                         00:00009BCA
FORM12A                         00:00009BEC
FORM1A                          00:00009A98
FORM3                           00:00009A9E
FORM4                           00:00009AA2
FORM5                           00:00009AB4
FORM6A                          00:00009AB8
FORM6D                          00:00009AC8
FORM7                           00:00009AEE
FORM8                           00:00009AFA
FORM815                         00:00009AFE
FORM9                           00:00009B08
FORM91                          00:00009E6A
FORM93                          00:00009E7E
FORM95                          00:00009E80
FORMREG5                        00:00009ADC
FORMREGA                        00:00009AD8
FORMREGD                        00:00009AE8
FORMSIZE                        00:00009E56
FR1                             00:000065F2
FR2                             00:0000660A
FR3                             00:00006610
FR4                             00:00006616
FR5                             00:0000661E
FR6                             00:00006630
FR7                             00:0000663C
FR8                             00:00006654
FRAMEBUF                         E:FD200000
FRAMEBUF_CMDTBL                 00:000018B8
FRAMEBUF_COLOR_COMP              E:00000098
FRAMEBUF_CTRL                    E:00000000
FRAMEBUF_WINDOW_DIMEN            E:00000078
FREL10                          00:00009958
FREL15                          00:0000996A
FREL20                          00:00009984
FREL25                          00:00009996
FREL30                          00:000099A0
FRELADDR                        00:0000994A
FemtikiInit                     00:00000220
FemtikiInitIRQ                  00:00000230
FemtikiTimerIRQ                 00:0000030E
ForceUnlockSemaphore            00:00002422
FreeTCB                          E:0010030C
FromScreen                      00:00007C70
GBYTE                           00:000067DA
GBYTE1                          00:000067DE
GBYTE2                          00:000067EC
GETLN                           00:000071B8
GFXACCEL                         E:FD300000
GFXACCEL_CMDTBL                 00:00001D2C
GFX_CLIP_PIXEL0_X                E:00000074
GFX_CLIP_PIXEL0_Y                E:00000078
GFX_CLIP_PIXEL1_X                E:0000007C
GFX_CLIP_PIXEL1_Y                E:00000080
GFX_COLOR0                       E:00000084
GFX_COLOR1                       E:00000088
GFX_COLOR2                       E:0000008C
GFX_CTRL                         E:00000000
GFX_DEST_PIXEL_X                 E:00000038
GFX_DEST_PIXEL_Y                 E:0000003C
GFX_DEST_PIXEL_Z                 E:00000040
GFX_STATUS                       E:00000004
GFX_TARGET_BASE                  E:00000010
GFX_TARGET_SIZE_X                E:00000014
GFX_TARGET_SIZE_Y                E:00000018
GFX_TARGET_X0                    E:000000B0
GFX_TARGET_X1                    E:000000B8
GFX_TARGET_Y0                    E:000000B4
GFX_TARGET_Y1                    E:000000BC
GL1                             00:000071C8
GL2                             00:000071E6
GL3                             00:000071FA
GL4                             00:0000721E
GL5                             00:0000722A
GL6                             00:00007246
GL7                             00:0000724E
GOAUXI                          00:00006036
GOAUXO                          00:00006032
GOBYE                           00:0000603A
GOIN                            00:0000602E
GOOUT                           00:0000602A
GOSUB                           00:00006572
GOTO                            00:00006474
GOWARM                          00:00006026
GRBufferToScreen                00:000078BA
GarbageCollectStrings           00:00006CAA
GetCmdLine                      00:000080BE
GetDecNumber                    00:000088C8
GetHexNumber                    00:0000889A
GetKey                          00:00000874
GetRunningTCBPointer            00:000002AA
GetSzChar                       00:000082D2
GetTick                         00:00007884
GlobalReadLong                  00:00002250
GlobalWriteLong                 00:00002256
GraphicsDemo                    00:000091CA
HALT                             E:0000B000
HAS_MMU                          E:00000000
HEX2DEC                         00:000098D2
HEX2DEC2                        00:00009884
HISPC                            E:FFFFFFFC
HOWMSG                          00:00007529
HX2DC                           00:000098E2
HX2DC0                          00:000098E6
HX2DC1                          00:000098EE
HX2DC2                          00:00009908
HX2DC22                         00:0000990A
HX2DC3                          00:00009914
HX2DC4                          00:0000991C
HX2DC5                          00:00009924
HX2DC57                         00:0000992C
HX2DC6                          00:00009930
HelpMsg                         00:00007F16
HomeCursor                      00:000014B0
I2C2                             E:FD069000
I2C_CMD                          E:00000004
I2C_CTRL                         E:00000002
I2C_PREH                         E:00000001
I2C_PREL                         E:00000000
I2C_RXR                          E:00000003
I2C_STAT                         E:00000004
I2C_TXR                          E:00000003
IBSR                            00:00009CFC
ICC                             00:00009CF8
ICC35                           00:00009D0E
ICC55                           00:00009D24
ICCCC                           00:00009DC2
ICCCC9                          00:00009DD8
IDBCC                           00:00009CE6
IF                              00:000066C4
IF1                             00:000066C8
IF2                             00:000066CE
IGNBLK                          00:0000740E
ILINK                           00:00009A7E
IM7788                          00:000099BC
IM7799                          00:000099C0
IMMED                           00:00009A06
IMMED45                         00:00009A2C
IMMED55                         00:00009A60
IMMED65                         00:00009A66
IMMED75                         00:00009A76
IMOVE                           00:00009A7A
IMOVE19                         00:00009E20
IMOVEA1                         00:00009DFA
IMOVEMFR                        00:000099A8
IMOVEMTR                        00:000099D6
IMOVEP                          00:00009C82
IMOVEP11                        00:00009C92
IMOVEP35                        00:00009CAE
IMOVEP66                        00:00009CBC
IMOVEQ                          00:00009C18
IMVFSR                          00:00009C38
IMVFUSP                         00:00009C46
IMVT44                          00:00009C62
IMVTCCR                         00:00009C72
IMVTSR                          00:00009C54
IMVTUSP                         00:00009C66
INC                             00:0000749C
INC1                            00:000074A8
INCOM                           00:000063A4
INCON                           00:00006396
INITMSG                         00:000074FE
INPERR                          00:000066DE
INPPTR                          00:00007560
INPUT                           00:000066EC
INT                             00:000070C8
INT_EXPR                        00:00006956
IOCOM                           00:000063B2
IOCON                           00:000063C8
IOFocus                          E:00100000
IP2                             00:0000671E
IP3                             00:00006738
IP4                             00:00006772
IP5                             00:0000677E
IP6                             00:0000671A
IP7                             00:00006710
IQUICK                          00:00009C14
IQUICK21                        00:00009E38
IQUICK31                        00:00009E4E
IQUICKA                         00:00009E26
IRQFlag                          E:000400A0
IRQROUT                         00:0000759C
IRQ_trampolines                 01:00000100
ISCC                            00:00009CDC
ISETD                           00:00009D34
ISETD12                         00:00009D3A
ISETS                           00:00009D44
ISHIFT                          00:00009D5E
ISHIFT13                        00:00009D6A
ISHIFT23                        00:00009D8E
ISHIFT33                        00:00009D9A
ISHIFT44                        00:00009D9E
ISHIFTM1                        00:00009DA8
ISTOP                           00:000099F2
IncCursorPos                    00:000013CC
IncCursorRow                    00:000013E6
InitIOPBitmap                   00:0000225E
InitIRQ                         00:00009654
InitRand                        00:000022AA
InitSemaphores                  00:000023DA
Initialise                      00:0000B800
InputDevice                      E:000400A4
InstallIRQ                      00:0000966A
JMPL                             E:0000E000
JSRL                             E:0000C000
KBD_CMDTBL                      00:000005EC
KEYBD                            E:FD0FFE00
KEYBD_SEMA                       E:00000003
KI                              00:0000A21E
KIEND                           00:0000A220
KeybdEcho                        E:0004000C
KeybdGetChar                    00:000008CE
KeybdGetCharNoWait              00:000008BE
KeybdGetCharWait                00:000008C6
KeybdGetID                      00:0000064A
KeybdID                          E:00100018
KeybdIRQ                        00:00000B7A
KeybdInit                       00:000006B4
KeybdLEDs                        E:0010000E
KeybdRecvByte                   00:00000818
KeybdSendByte                   00:00000B3A
KeybdSetLED                     00:00000688
KeybdSetLEDStatus               00:00000AEA
KeybdWaitFlag                    E:0004000D
KeybdWaitTx                     00:0000083A
LEA1                            00:00004094
LEFT                            00:0000706E
LEN                             00:000070A2
LET                             00:0000678A
LF                               E:0000000A
LIST                            00:000064BC
LOAD                            00:0000679A
LOCVARSZ                         E:00000010
LOD1                            00:000067A6
LOD2                            00:000067C0
LODEND                          00:000067D0
LOPINC                          00:0000757C
LOPLMT                          00:00007588
LOPLN                           00:00007594
LOPPT                           00:00007598
LOPVAR                          00:00007578
LS1                             00:000064C8
LS2                             00:000064DC
LS3                             00:000064E2
LSTROM                          00:0000755C
LT1                             00:00006796
LastStr                         00:000075AC
ListBreakpoints                 00:000094E6
LockSemaphore                   00:00002400
LockSysSemaphore                00:00000396
LorR1                           00:00006FA0
LorRArgs                        00:00006F68
MAX_TID                          E:00000FFF
MEMORY_SEMA                      E:00000006
MID                             00:00006FA4
MID1                            00:0000706A
MID2                            00:00006FEC
MID4                            00:00007038
MID5                            00:00007004
MMU                              E:FDC00000
MOVE1                           00:00003D02
MOVE2                           00:00003C86
MOVE3                           00:00003D82
MOVE4                           00:00003EDC
MOVEMR                          00:0000A0B6
MOVEMR11                        00:0000A0C6
MOVEMR33                        00:0000A0CE
MOVEMR44                        00:0000A0E0
MOVEMR77                        00:0000A0FA
MOVEMR79                        00:0000A10C
MOVEMR88                        00:0000A10E
MOVEMR94                        00:0000A126
MOVEMS                          00:0000A0A2
MOVEMS2                         00:0000A0B2
MSG111                          00:0000A214
MULS_OUTER1                     00:000056BA
MULU_OUTER1                     00:0000566E
MVDOWN                          00:000072A0
MVRET                           00:00007294
MVUP                            00:0000728C
MVUPW                           00:00007296
Monitor                         00:00007C84
MoveToXY                        00:00007A22
NBCD_LOOP                       00:00004A38
NBCD_LOOP1                      00:00004A7E
NBCD_NO_C                       00:00004A44
NBCD_NO_C1                      00:00004A92
NBCD_NO_Z                       00:00004A48
NBCD_NO_Z1                      00:00004A96
NCORES                           E:00000004
NEW                             00:000063DE
NEXT                            00:00006658
NOSTRING                        00:00007540
NR_TCB                           E:00001000
NUM_EXPR                        00:00006948
NX0                             00:00006662
NX1                             00:000066A2
NX2                             00:000066BA
NX3                             00:00006674
NextRec                         00:00008FB8
NextString                      00:00006CE6
Ninc0                           00:0000B89C
Ninc1                           00:0000B89C
NumSetBreakpoints                E:00040202
OFFSET                           E:00040880
OKMSG                           00:00007522
ONIRQ                           00:00006488
ONIRQ1                          00:000064A2
OPCTBL                          00:0000A4D8
OR_OUTER1                       00:00004E1A
OR_OUTER2                       00:00004E8E
OSCallTable                     00:0000023E
OUTC                            00:0000748C
OUTCOM                          00:000063BC
OUTCON                          00:000063D2
OUTPTR                          00:00007564
OutputChar                      00:0000963A
OutputDevice                     E:000400A8
PARN                            00:00006C36
PBYTE                           00:00006858
PBYTE1                          00:0000685A
PBYTE2                          00:0000686E
PEEK                            00:00006EA2
PKER                            00:000068EE
PLIC                             E:FD090000
PNT4HEX                         00:00009936
PNT4HX                          00:00009936
PNT6HX                          00:0000993A
PNT8HX                          00:00009946
POKE                            00:00006878
POPA                            00:000072A8
PR0                             00:00006506
PR1                             00:00006514
PR2                             00:000064F8
PR3                             00:00006522
PR6                             00:0000652E
PR8                             00:00006534
PR9                             00:00006550
PRINT                           00:000064E8
PRMESG                          00:00007474
PRMRET                          00:0000747E
PRNlword                         S:0000000A
PRTLN                           00:0000738C
PRTNUM                          00:00007342
PRTRET                          00:00007334
PRTSTG                          00:0000731A
PRTSTR2                         00:0000733C
PRTSTR2a                        00:00007336
PS1                             00:0000731C
PUSHA                           00:000072E4
PeekScreenChar                  00:000082CC
PointsIntoStringArea            00:00006D42
ProcessBreakpoint               00:000093B2
ProcessRec                      00:00008FCA
ProcessS1                       00:000090CE
ProcessS2                       00:000090D2
ProcessS3                       00:000090D6
ProcessS7                       00:000090DA
ProcessS8                       00:000090EC
ProcessS9                       00:000090FE
Prompt1                         00:00007CC6
Prompt3                         00:00007CB0
PromptLn                        00:00007CA4
QHOW                            00:000071AA
QSORRY                          00:000071A2
QWHAT                           00:00007162
QueueCycle                       E:0010031C
RAND                             E:FD0FFD00
RAND_MW                          E:FD0FFD0C
RAND_MZ                          E:FD0FFD08
RAND_NUM                         E:FD0FFD00
RAND_SEMA                        E:00000004
RAND_STRM                        E:FD0FFD04
RANPNT                          00:0000755C
REL4                             E:00004000
REL5                             E:00005000
REL7                             E:00007000
REM                             00:000066C2
RETURN                          00:000065AC
RIGHT                           00:0000707A
RND                             00:00006F0A
ROXx_FLAGS                      00:00005982
ROXx_LOOP1                      00:00005998
ROXx_LOOP2                      00:000059B8
ROXx_LOOP3                      00:000059D8
ROXx_LOOP4                      00:000059F8
ROXx_LOOP5                      00:00005A18
ROXx_LOOP6                      00:00005A3A
ROx_FLAGS                       00:0000574C
ROx_LOOP1                       00:00005762
ROx_LOOP2                       00:00005782
ROx_LOOP3                       00:000057A2
ROx_LOOP4                       00:000057C2
ROx_LOOP5                       00:000057E2
ROx_LOOP6                       00:00005804
RST_REG                          E:FD0FFC00
RTCBuf                           E:00100200
RTR_DONE                        00:00004ADA
RTSL                             E:0000D000
RUN                             00:000063FA
RUN1                            00:0000644E
RUNNXL                          00:0000640E
RUNSML                          00:00006464
RUNTSL                          00:0000645A
RandGetNum                      00:00002314
RandInit                        00:000022AA
RandWait                        00:000023C2
ReceiveMsg                      00:00009556
Regsave                          E:00040100
RunningTCB                       E:00100224
S1932a                          00:00009148
S1932b                          00:0000915C
S19Checksum                      E:00100150
S19Get16BitAddress              00:00009110
S19Get24BitAddress              00:0000911E
S19Get32BitAddress              00:0000912A
S19StartAddress                  E:00040008
SAVE                            00:000067FA
SAVE1                           00:00006802
SAVE2                           00:00006826
SAVEND                          00:00006834
SBCD_INNER1                     00:0000494A
SBCD_INNER2                     00:000049B8
SBCD_NO_C1                      00:00004966
SBCD_NO_C2                      00:0000496E
SBCD_NO_C3                      00:000049D4
SBCD_NO_C4                      00:000049DC
SBCD_OUTER1                     00:00004948
SBCD_OUTER2                     00:000049B6
SCHR                            00:00009C30
SCOMMON                         00:00009CD8
SCREEN_FORMAT                    E:00000001
SCREEN_SEMA                      E:00000005
SC_ALT                           E:00000011
SC_CAPSLOCK                      E:00000058
SC_CTRL                          E:00000014
SC_EXTEND                        E:000000E0
SC_KEYUP                         E:000000F0
SC_LSHIFT                        E:00000012
SC_NUMLOCK                       E:00000077
SC_RSHIFT                        E:00000059
SC_SCROLLLOCK                    E:0000007E
SC_TAB                           E:0000000D
SERIAL_SEMA                      E:00000002
SETVAL                          00:00007116
SHIFTS2_FLAGS                   00:00005DFA
SHIFTS2_LOOP1                   00:00005E10
SHIFTS2_LOOP2                   00:00005E2C
SHIFTS2_LOOP3                   00:00005E48
SHIFTS2_LOOP4                   00:00005E64
SHIFTS2_LOOP5                   00:00005E80
SHIFTS2_LOOP6                   00:00005E9E
SHIFTS_FLAGS                    00:00005BB8
SHIFTS_LOOP1                    00:00005BCE
SHIFTS_LOOP2                    00:00005BEE
SHIFTS_LOOP3                    00:00005C0E
SHIFTS_LOOP4                    00:00005C2E
SHIFTS_LOOP5                    00:00005C4E
SHIFTS_LOOP6                    00:00005C70
SHRT                             E:0000F000
SIV1                            00:00006D1A
SIZE                            00:00006F40
SRYMSG                          00:00007552
ST3                             00:000060E4
ST4                             00:00006136
START                           00:00006024
STKFP                           00:0000756C
STKGOS                          00:00007570
STKINP                          00:00007574
STKLMT                          00:000075B8
STOP                            00:000063F2
STRAREASIZE                      E:00000800
STRSTK                          00:000075A0
SUBA_OUTER1                     00:0000540C
SUBQ_LOOP1                      00:00004C98
SUBQ_LOOP2                      00:00004CD2
SUBQ_LOOP3                      00:00004D08
SUBX_LOOP3                      00:000055F6
SUBX_LOOP4                      00:00005612
SUBX_LOOP5                      00:0000562E
SUBX_OUTER1                     00:00005562
SUB_OUTER1                      00:000052D0
SUB_OUTER2                      00:00005344
SV1                             00:00007134
ScrollUp                        00:00001410
SelectThreadToRun               00:000002C2
SendMsg                         00:00009518
SerHeadRcv                       E:00100162
SerHeadXmit                      E:00100168
SerRcvBuf                        E:00101000
SerRcvXoff                       E:00100165
SerRcvXon                        E:00100164
SerTailRcv                       E:00100160
SerTailXmit                      E:00100166
SerXmitBuf                       E:00102000
SerXmitXoff                      E:0010016A
SerialGetChar                   00:00001662
SerialIRQ                       00:000017D8
SerialInit                      00:00001624
SerialPeekChar                  00:000016DA
SerialPeekCharDirect            00:00001716
SerialPutChar                   00:00001730
SerialPutCharDirect             00:00001794
SerialRbo                       00:000017B0
SerialRcvCount                  00:000017B8
SetDrawMode                     00:0000788C
SetKeyboardEcho                 00:00000860
SetPenColor                     00:000078AE
ShiftBuf                        00:0000986A
SimHardware                     00:00007874
SpuriousIRQ                     00:00009722
StartMon                        00:00007C7A
StartQ                          00:00000172
StrArea                         00:000075A8
StrSp                           00:000075A4
StringInVar                     00:00006CFC
StringOnStack                   00:00006D66
StubRout                        00:00007B48
SyncCursor                      00:000014C2
T15Abort                        00:00002472
T15DispatchTable                00:000076E4
T15FloatToString                00:000095E0
T15GetFloat                     00:00002464
T15LockSemaphore                00:00002458
T15UnlockSemaphore              00:0000245E
TAB1                            00:000061A4
TAB10                           00:00006259
TAB10_1                         00:0000633C
TAB11                           00:0000625C
TAB11_1                         00:00006344
TAB1_1                          00:00006264
TAB2                            00:000061D3
TAB2_1                          00:00006294
TAB4                            00:00006210
TAB4_1                          00:000062D4
TAB5                            00:00006242
TAB5_1                          00:00006308
TAB6                            00:00006245
TAB6_1                          00:00006310
TAB8                            00:0000624A
TAB8_1                          00:00006318
TAB9                            00:00006255
TAB9_1                          00:00006334
TBL                             00:0000A220
TBLE                            00:0000A4D8
TC1                             00:000073BC
TCBAffineChose                  00:000000A0
TCBAffinity                      E:00000084
TCBAffinityBase                  E:00000082
TCBAlloc                        00:0000006E
TCBEndTick                       E:00000070
TCBFree                         00:00000092
TCBHandleToPointer              00:00000028
TCBIAlloc                       00:00000050
TCBIFree                        00:0000007C
TCBInit                         00:00000000
TCBInsertIntoReadyQueue         00:000000D8
TCBNext                          E:0000007C
TCBPC                            E:00000050
TCBPointerToHandle              00:00000040
TCBPopReadyQueue                00:0000017A
TCBPrev                          E:00000080
TCBPriority                      E:00000055
TCBRegs                          E:00000004
TCBRemoveFromReadyQueue         00:00000150
TCBSR                            E:0000004C
TCBSSP                           E:00000048
TCBStartTick                     E:0000006C
TCBStatus                        E:00000054
TCBTicks                         E:00000074
TCBUSP                           E:00000044
TCB_SIZE                         E:00000100
TEXTCOL                          E:00000040
TEXTREG                          E:FD080000
TEXTROW                          E:00000020
TEXTVID_CMDTBL                  00:00000F30
TICK                            00:00006F50
TOUPB1                          00:0000741E
TOUPBRT                         00:0000743E
TOUPBUF                         00:00007418
TOUPPER                         00:00007450
TOUPRET                         00:00007460
TRAP15                          00:000076CE
TSTC                            00:000073AA
TSTNUM                          00:000073C2
TSTV                            00:00006DE4
TSTVRT                          00:00006E64
TS_PREEMPT                       E:00000020
TS_RUNNING                       E:00000080
TV1                             00:00006E2C
TV2                             00:00006E5C
TXT                             00:00007610
TXTBGN                          00:0000603E
TXTUNF                          00:000075B0
TYPMSG                          00:00007538
TestBitmap                      00:000078F4
TextCols                         E:0004008D
TextRows                         E:0004008C
TextScr                          E:00040004
TickIRQ                         00:000096AE
TimerStack                       E:00041BFC
USP1                            00:00006DC2
UnlockSemaphore                 00:0000243C
UnlockSysSemaphore              00:000003A6
UpdateIRQLive                   00:000002EC
UpdateStringPointers            00:00006D96
VARBGN                          00:000075B4
Vertical1                       00:000079DE
Vertical2                       00:000079FA
WAITIRQ                         00:000064AC
WHTMSG                          00:00007530
WSTART                          00:000060B0
Wait10ms                        00:00000B42
Wait300ms                       00:00000B5E
X                               00:000099A8
XOFF                             E:00000013
XON                              E:00000011
XP11                            00:000069E2
XP12                            00:000069EE
XP13                            00:000069FA
XP14                            00:00006A06
XP15                            00:00006A12
XP15RT                          00:00006A1E
XP16                            00:00006A20
XP17                            00:00006A3E
XP18                            00:00006A44
XP21                            00:00006A66
XP22                            00:00006A6C
XP23                            00:00006A70
XP24                            00:00006A7E
XP25                            00:00006AAC
XP26                            00:00006AB2
XP27                            00:00006AC6
XP30                            00:00006B3C
XP31                            00:00006B48
XP34                            00:00006B5E
XP35                            00:00006B78
XP36                            00:00006B38
XP40                            00:00006BAC
XP41                            00:00006BBE
XP42                            00:00006C46
XP43                            00:00006C48
XP44                            00:00006C2A
XP45                            00:00006BD8
XPRT0                           00:00006A2E
XPRT1                           00:00006A36
XPSTNG                          00:00006BCE
XP_AND                          00:000069A0
XP_ANDX                         00:000069B6
XP_MOD                          00:00006B7E
XP_OR                           00:00006978
XP_ORX                          00:000069B6
XP_POP                          00:0000691C
XP_POP1                         00:00006932
XP_PUSH                         00:00006906
_CheckNan                       00:0000892C
_CheckNegative                  00:000089AA
_CheckZero                      00:00008990
_ComputeDigitsBeforeDecpt       00:00008A04
_E                               E:0004050C
_ExtExpDigit                    00:00008B28
_ExtExpDigits                   00:00008B46
_FloatToString                  00:00008BF0
_GetExponent                    00:00008CA8
_GetFloat                       00:00008DA8
_GetFloatBackupChar             00:00008C40
_GetFloatGetChar                00:00008C32
_GetFloatIgnBlanks              00:00008C38
_GetFraction                    00:00008C44
_GetInteger                     00:00008D32
_GetRand                        00:0000239E
_KeyState1                       E:0010000F
_KeyState2                       E:00100010
_KeybdBuf                        E:00100020
_KeybdClearIRQ                  00:00000802
_KeybdCnt                        E:00100013
_KeybdGetScancode               00:000007E4
_KeybdGetStatus                 00:000007C6
_KeybdHead                       E:00100011
_KeybdInit                      00:000006B4
_KeybdOBuf                       E:00100080
_KeybdTail                       E:00100012
_Keybd_tick                      E:0001001C
_LeadingZero                    00:00008A3E
_LessThanDbl                    00:000089D8
_MakeBig                        00:000089BC
_PadLeft                        00:00008B6E
_PadRight                       00:00008BBE
_SpitOutDigits                  00:00008A4E
_SpitOutE                       00:00008B10
_TrimDotZero                    00:00008AE8
_TrimTrailingPoint              00:00008ACA
_TrimTrailingZeros              00:00008B04
_canary                          E:00040098
_dasmbuf                         E:00040800
_dfMil                          00:00008918
_dfOne                          00:00008900
_dfTen                          00:0000890C
_digits_before_decpt             E:00040510
_fpBuf                           E:00040520
_fpTextIncr                      E:00040094
_fpWork                          E:00040600
_keybdControlCodes              00:00000E30
_keybdExtendedCodes             00:00000EB0
_msgInf                         00:00008928
_msgNan                         00:00008924
_precision                       E:00040514
_shiftedScanCodes               00:00000D30
_unshiftedScanCodes             00:00000C30
_width                           E:00040508
a_was_less                      00:0000B694
add_address                     00:0000B7BC
add_char_loop                   00:0000B764
add_character                   00:0000AD00
add_coords                      00:0000B7D2
add_explode                     00:0000B23A
add_fire                        00:0000B246
add_hex_chr                     00:0000B7A2
add_item                        00:0000B220
add_message                     00:0000B71C
add_p_size                      00:0000A804
add_pair                        00:0000B7EE
add_play_explode                00:0000B35E
add_player                      00:0000B404
add_saucer                      00:0000B240
add_score                       00:0000B258
add_ships                       00:0000AD10
add_ships_loop                  00:0000AD2C
add_single                      00:0000B7EC
add_sup_hex_chr                 00:0000B796
add_sup_zero                    00:0000B7AC
add_the_char                    00:0000B77A
add_to_list                     00:0000B1EC
add_to_score                    00:0000B4E6
addr_err                        00:00009736
aim_shot                        00:0000A9C2
asteroids_start                 00:0000A5D8
atn_eight                       00:0000B600
atn_quad                        00:0000B5F0
atn_semi                        00:0000B5E0
atn_tab                         00:0000B61E
attract_fire                    00:0000A99E
attract_saucer                  00:0000A8EC
beat1_snd                        E:00000008
beat1_sound                     00:0000D450
beat2_snd                        E:00000009
beat2_sound                     00:0000D462
bkColor                          E:00040088
brdisp_trap                     00:0000974C
bus_err                         00:0000935A
calc_fire_byte                  00:0000AAB0
char_1                          00:0000CF8C
char_2                          00:0000CF94
char_3                          00:0000CFA4
char_4                          00:0000CFB2
char_5                          00:0000CFC0
char_6                          00:0000CFCE
char_7                          00:0000CFDC
char_8                          00:0000CFE6
char_9                          00:0000CFF6
char_a                          00:0000CE20
char_b                          00:0000CE30
char_c                          00:0000CE4A
char_d                          00:0000CE56
char_e                          00:0000CE66
char_f                          00:0000CE76
char_g                          00:0000CE84
char_h                          00:0000CE96
char_i                          00:0000CEA4
char_j                          00:0000CEB2
char_k                          00:0000CEBE
char_l                          00:0000CECA
char_m                          00:0000CED4
char_n                          00:0000CEE0
char_o0                         00:0000CEEA
char_p                          00:0000CEF6
char_q                          00:0000CF04
char_r                          00:0000CF16
char_s                          00:0000CF26
char_set                        00:0000D004
char_spc                        00:0000CF88
char_t                          00:0000CF34
char_u                          00:0000CF40
char_v                          00:0000CF4C
char_w                          00:0000CF56
char_x                          00:0000CF64
char_y                          00:0000CF6E
char_z                          00:0000CF7C
check_all                       00:0000A7AE
check_alpha                     00:0000AC1C
check_clear                     00:0000AF40
check_clear_loop                00:0000AF44
check_clear_y                   00:0000AF5E
check_hi_loop                   00:0000B552
check_hi_next                   00:0000B560
check_hi_player                 00:0000B54A
check_hiscores                  00:0000B52E
check_hits                      00:0000A78E
check_neg_velocity              00:0000AF34
check_next_object               00:0000A7AA
check_pss                       00:0000A79C
check_velocity                  00:0000AF26
chk_exception                   00:00002482
clear_graphics_screen           00:00008450
clear_graphics_screen2          00:00008484
clear_hyper                     00:0000AE78
clear_items_loop                00:0000ACD8
clear_loop                      00:0000B830
clear_rock                      00:0000B4D2
clear_rocks                     00:0000B01E
clear_rocks_loop                00:0000B020
clear_saucer                    00:0000AE18
close_all                       00:0000AB8C
close_all_2                     00:0000B886
cmdAsteroids                    00:00007D8C
cmdBreakpoint                   00:00007D68
cmdClearScreen                  00:00007DA8
cmdClock                        00:00007E9A
cmdCore                         00:00007DB4
cmdDisassemble                  00:000086B4
cmdDispatch                     00:00007CE0
cmdDumpMemory                   00:00008704
cmdDumpRegs                     00:000087CE
cmdEditMemory                   00:0000831A
cmdFMTK                         00:00007DD8
cmdFillB                        00:000081C6
cmdFillL                        00:0000826E
cmdFillW                        00:0000821A
cmdGrDemo                       00:0000839E
cmdHelp                         00:00007F0A
cmdJump                         00:0000838E
cmdLoadS19                      00:00008FB2
cmdMonitor                      00:00007C84
cmdReceiveSerial                00:00008192
cmdReset                        00:00007EB8
cmdSendSerial                   00:00008162
cmdString                       00:00007BC2
cmdTable                        00:00007C00
cmdTestCPU                      00:00007D98
cmdTestFP                       00:00007DE0
cmdTestGF                       00:00007E6C
cmdTestRAM                      00:00008EEA
cmdTestSerialReceive            00:00008878
cmdTinyBasic                    00:00007D94
cmdVideoMode                    00:00007D26
col_table                       00:0000A814
col_table_l                     00:0000A82C
col_table_p                     00:0000A81C
col_table_s                     00:0000A824
copy_msg                        00:0000C9E8
copy_rock                       00:0000B076
copy_rock_2                     00:0000B07A
copy_short                      00:0000B456
copy_vectors                    00:0000B45A
copy_velocity                   00:0000B0A0
cos_d0                          00:0000B67C
cossin_d0                       00:0000B68E
cpu_test                        00:000024D6
d_mess_0                        00:0000D154
d_mess_1                        00:0000D164
d_mess_2                        00:0000D16D
d_mess_3                        00:0000D194
d_mess_4                        00:0000D1B7
d_mess_5                        00:0000D1DA
d_mess_6                        00:0000D200
d_mess_7                        00:0000D216
d_messages                      00:0000D144
dccr                            00:0000127E
dclf                            00:00001352
dcx10                           00:000012E6
dcx11                           00:00001308
dcx12                           00:000012FE
dcx14                           00:00001272
dcx16                           00:00001356
dcx4                            00:0000135A
dcx6                            00:0000129C
dcx7                            00:00001276
dcx8                            00:000012B2
dcx9                            00:000012C8
dec_isaucer_time                00:0000A914
delta_x_pos                     00:0000A7C8
delta_y_pos                     00:0000A7DA
dly3s1                          00:000024A6
dly3s2                          00:000024A4
doBackspace                     00:00001364
doCtrlX                         00:000013A8
doDelete                        00:00001372
do_nothing                      00:0000051A
do_p1_ships                     00:0000B154
do_p2_score                     00:0000B1C8
do_saucer                       00:0000A8C0
do_start_mess                   00:0000A688
do_vector                       00:0000B89E
dspj1                           00:00007694
dspmem1                         00:00008766
dspspc1                         00:00008E64
dsret                           00:000076A0
e_mess_0                        00:0000D09A
e_mess_1                        00:0000D0A6
e_mess_2                        00:0000D0AE
e_mess_3                        00:0000D0D0
e_mess_4                        00:0000D0EB
e_mess_5                        00:0000D108
e_mess_6                        00:0000D12F
e_mess_7                        00:0000D13A
e_messages                      00:0000D08A
edtmem1                         00:00008324
end_game                        00:0000A77A
end_vector                      00:0000B98C
enter_hiscores                  00:0000AAD6
err_cmdproc                     00:00001532
err_dcb                          E:00040B8C
err_init                        00:00001504
err_ret                         00:00001530
existing_saucer                 00:0000A97A
exit_add_message                00:0000B782
exit_add_score                  00:0000B286
exit_add_ships                  00:0000AD38
exit_check_hiscores             00:0000B58E
exit_check_velocity             00:0000AF3E
exit_copy_vectors               00:0000B474
exit_do_saucer                  00:0000A978
exit_enter_hiscores             00:0000AC2A
exit_existing_saucer            00:0000A9A4
exit_find_rock                  00:0000B344
exit_game_message               00:0000A778
exit_hi_chk                     00:0000B584
exit_high_scores                00:0000B32C
exit_hit_a_rock                 00:0000B528
exit_hyperspace                 00:0000ACBA
exit_insert_loop                00:0000B5B6
exit_limit_velocity             00:0000B0FA
exit_make_rocks                 00:0000B028
exit_no_scores                  00:0000B332
exit_not_done                   00:0000AC28
exit_play_sample                00:0000D436
exit_push_start                 00:0000A6FA
exit_ship_fire                  00:0000AA5C
exit_ship_move                  00:0000AE7C
exit_static                     00:0000B1EA
expl_0                          00:0000CAD0
expl_1                          00:0000CA9A
expl_2                          00:0000CA5C
expl_3                          00:0000CA30
expl_tab                        00:0000CA28
expl_x_pos                       S:0000005B
expl_y_pos                       S:00000067
explode_object                  00:0000A87A
extra_snd                        E:0000000A
extra_sound                     00:0000D4B3
f_mess_0                        00:0000D230
f_mess_1                        00:0000D23F
f_mess_2                        00:0000D246
f_mess_3                        00:0000D26A
f_mess_4                        00:0000D283
f_mess_5                        00:0000D2A5
f_mess_6                        00:0000D2CE
f_mess_7                        00:0000D2E0
f_messages                      00:0000D220
f_xpos_off                       E:FFFFFFBA
f_xvel_off                       E:0000004C
f_ypos_off                       E:00000000
f_yvel_off                       E:0000006F
fgColor                          E:00040084
filename                        00:0000D52A
find_next_rock                  00:0000B33A
find_rock                       00:0000B338
fire_ok                         00:0000AACC
fire_saucer                     00:0000A9AA
fire_shot                       00:0000AA5E
first_quad                      00:0000B42E
flag_end                         E:0000002F
flags_off                        E:0000000C
fpBuf                            E:000402C0
framebuf_clear                  00:00001CCC
framebuf_cmdproc                00:00001940
framebuf_dcb                     E:00040D18
framebuf_get_color              00:00001B4A
framebuf_get_dimen              00:00001B5A
framebuf_getbuf                 00:00001B34
framebuf_getbuf1                00:00001AA0
framebuf_getbuf2                00:00001AA8
framebuf_getchar                00:00001A82
framebuf_init                   00:000019D4
framebuf_putbuf                 00:00001B34
framebuf_putchar                00:00001A82
framebuf_set_color_depth        00:00001B38
framebuf_set_dimen              00:00001B8A
framebuf_set_inpos              00:00001A84
framebuf_set_outpos             00:00001A92
framebuf_set_unit               00:00001B2A
framebuf_setbuf1                00:00001AB0
framebuf_setbuf2                00:00001ABE
framebuf_stat                   00:00001A82
framebuf_stub                   00:00001B34
framebuf_swapbuf                00:00001ACC
framebuf_writeat                00:00001BD4
fx_sounds                       00:0000B476
game_count                       S:00000059
game_message                    00:0000A674
game_over                       00:0000A6FC
gen_prng                        00:0000B88C
gen_rock_loop                   00:0000AFC8
get_atn                         00:0000B5D4
get_screen_address              00:00007664
get_screen_color                00:0000120A
gfxaccel_clear                  00:00001EBE
gfxaccel_clip_rect              00:00001F7E
gfxaccel_cmdproc                00:00001DB4
gfxaccel_ctrl                    E:000408C0
gfxaccel_dcb                     E:00040D9C
gfxaccel_draw_curve             00:0000219C
gfxaccel_draw_line              00:00002044
gfxaccel_draw_rectangle         00:000020AC
gfxaccel_draw_triangle          00:00002114
gfxaccel_get_color              00:00001F1C
gfxaccel_get_dimen              00:00001EC2
gfxaccel_get_inpos              00:00001EC2
gfxaccel_get_outpos             00:00001EC2
gfxaccel_get_outptr             00:00001EC2
gfxaccel_getbuf                 00:00001EC2
gfxaccel_getbuf1                00:00001EC2
gfxaccel_getbuf2                00:00001EC2
gfxaccel_getchar                00:00001EC2
gfxaccel_init                   00:00001E48
gfxaccel_plot_point             00:00001FEE
gfxaccel_putbuf                 00:00001EC2
gfxaccel_putchar                00:00001EC2
gfxaccel_set_active_point       00:00001FC2
gfxaccel_set_color              00:00001F26
gfxaccel_set_color123           00:00001F46
gfxaccel_set_color_depth        00:00001EFA
gfxaccel_set_dimen              00:00001EC6
gfxaccel_set_inpos              00:00001EC2
gfxaccel_set_outpos             00:00001EC2
gfxaccel_set_unit               00:00001EC2
gfxaccel_setbuf1                00:00001EC2
gfxaccel_setbuf2                00:00001EC2
gfxaccel_stat                   00:00001EB0
gfxaccel_stub                   00:00001EC2
gfxaccel_swapbuf                00:00001EC2
gfxaccel_wait                   00:00002222
gfxaccel_writeat                00:00001EC2
glob_scale                       S:00000000
go_reset_play                   00:0000AD7C
go_reset_sauc                   00:0000AD82
gr_bitmap_buffer                 E:000408B0
gr_bitmap_screen                 E:000408A4
gr_double_buffer                 E:000408AC
gr_height                        E:000408A0
gr_width                         E:0004089C
gr_x                             E:00040894
gr_y                             E:00040898
gthx3                           00:00008E56
gthx5                           00:00008E32
gthx6                           00:00008E44
handle_collision                00:0000A834
hi_char                          S:00000020
hide_p_cnt                       E:0000007A
high_idx                         S:00000017
high_off                         E:00000083
high_scores                     00:0000B28C
high_scores_loop                00:0000B2BE
hinames                          S:0000003B
hiscore_y                        S:00000012
hiscores                         S:00000027
hit_a_rock                      00:0000B4B8
hype_xok1                       00:0000AC68
hype_xok2                       00:0000AC72
hype_yok1                       00:0000AC90
hype_yok2                       00:0000AC9A
hyper                            S:00000026
hyperspace                      00:0000AC2C
i2c_setup                       00:000091DC
i2c_wait_rx_nack                00:0000922A
i2c_wait_tip                    00:000091EC
i2c_wr_cmd                      00:000091FC
i2c_xmit1                       00:0000920C
i_rk_count                       E:00000075
i_sauc_tim                       E:00000078
icc1                            00:0000140E
ignBlanks                       00:000082BA
illegal_trap                    00:00009784
init_i2c                        00:000091DC
init_plic                       00:00007B8C
insert_hiscore                  00:0000B590
insert_loop                     00:0000B594
io_irq                          00:0000979A
io_trap                         00:00009614
irq3_rout                       00:000096F0
irq6_rout                       00:000096F0
irq_list_tbl                     A:00000400
irq_proc_generic                00:00009704
irq_rout                        00:000096F0
is_closer                       00:0000AF7C
item_exploding                  00:0000AD8A
kbdi0002                        00:000006E0
kbdi0004                        00:00000758
kbdi0005                        00:00000774
kbdiTryAgain                    00:0000074A
kbdiXmitBusy                    00:0000078E
keep_saucer_dir                 00:0000A992
keep_scale                      00:0000AE0A
keep_small                      00:0000A8BA
keybd_cmdproc                   00:0000060C
keybd_dcb                        E:00040A84
keybd_getbuf                    00:00000646
keybd_getchar                   00:0000063E
keybd_init                      00:00000568
keybd_putbuf                    00:00000646
keybd_putchar                   00:00000636
keybd_set_inpos                 00:00000646
keybd_set_outpos                00:00000646
keybd_stat                      00:0000062E
kgid1                           00:0000067C
kgnotKbd                        00:00000684
kill_the_player                 00:0000AE62
last_fire                        S:00000021
last_hype                        S:00000022
last_vector                     00:0000B99A
leds                             E:FD0FFF00
ledxit                          00:00000778
lexpl_snd                        E:00000007
lexpl_sound                     00:0000D474
lgsau_snd                        E:00000004
lgsau_sound                     00:0000D4C9
limit_p_vel                     00:0000B0EA
limit_velocity                  00:0000B0D6
load_old_sound                  00:0000D412
load_sound                      00:0000D40C
local_x                          S:00000002
local_y                          S:00000004
loop1                           00:000004E2
loop2                           00:000004E0
loop3                           00:000011EC
loop_atn                        00:0000B604
m_w                              E:000408D4
m_z                              E:000408D0
main_loop                       00:0000A5E0
make_rocks                      00:0000AF82
memend                           E:00100004
mess_origin                     00:0000D062
mess_table                      00:0000D082
mexpl_snd                        E:00000006
mexpl_sound                     00:0000D489
min_rocks                        E:0000007D
move_item                       00:0000ADA4
move_items                      00:0000AD3A
move_next_item                  00:0000AD3E
move_next_object                00:0000AE10
msgAddrErr                      00:000097E6
msgBadKeybd                     00:0000079C
msgBusErr                       00:00009349
msgChk                          00:00009842
msgHello                        00:000080AC
msgRtcReadFail                  00:00009330
msgStackCanary                  00:00009850
msgUnknownCmd                   00:0000809C
msgXmitBusy                     00:000007AB
msg_bad_branch_disp             00:00009805
msg_core_start                  00:000097D5
msg_illegal                     00:000097F3
msg_io_access                   00:00009827
msg_reglist                     00:00008852
msg_regs                        00:0000884E
msg_start                       00:000097AE
msg_test_done                   00:00009817
nd1                             00:0000225A
nd2                             00:0000225A
nd3                             00:0000225A
nd4                             00:0000225A
neg_upper_ok                    00:0000B0E0
net_delay                       00:0000225A
new_rocks                        E:0000007B
next_hi_char                    00:0000ABA4
next_m_w                         E:000408DC
next_m_z                         E:000408D8
next_p_high                     00:0000AB70
next_pss                        00:0000A796
nmeSerial                       00:000018AE
nmi_rout                        00:00009724
no_add_size                     00:0000A806
no_aim_shot                     00:0000AA18
no_dec_new_rocks                00:0000A664
no_game_over                    00:0000A73A
no_inc_min                      00:0000AFAC
no_neg_x10                      00:0000B906
no_neg_x11                      00:0000B8DC
no_neg_x2                       00:0000B988
no_neg_y10                      00:0000B8FA
no_neg_y11                      00:0000B8D0
no_neg_y2                       00:0000B980
no_new_rocks                    00:0000AD74
no_play                         00:0000A646
no_playerx                      00:0000AB04
no_pos_reflect                  00:0000B41A
no_reset_scale                  00:0000ADA2
no_reset_xy                     00:0000B388
no_saucer_sound                 00:0000B484
no_save_ist                     00:0000A924
no_set_max                      00:0000AFBC
no_shot_dec                     00:0000B256
no_shot_or                      00:0000AA14
no_thrust                       00:0000B454
no_thump_sound                  00:0000B4B6
nodec_thmpi                     00:0000A710
notRxInt                        00:0000184E
notTxInt                        00:0000189C
not_closer                      00:0000AF72
not_player                      00:0000A852
not_pss_player                  00:0000A86A
not_right                       00:0000B918
not_rot_left                    00:0000ABEE
not_rot_left1                   00:0000AE8A
not_rot_right1                  00:0000AE92
not_rot_right2                  00:0000ABF6
not_saucer                      00:0000A844
not_thrust                      00:0000AEF0
not_timed_out                   00:0000ABD2
not_x_max                       00:0000ADC6
not_y_max                       00:0000ADE6
notscreen                       00:0000B7F4
null_cmdproc                    00:00000564
null_dcb                         E:00040A00
null_init                       00:00000520
null_ret                        00:00000562
numBreakpoints                   E:00000008
num_players                      S:0000001A
old_sound_play                  00:0000D434
op_ABCD                         00:00004830
op_ADD                          00:000051C6
op_ADDA                         00:0000539A
op_ADDQ                         00:00004BC6
op_ADDX                         00:00005432
op_ADD_I                        00:000038AE
op_AND                          00:00004EE4
op_ANDI_TO_CCR                  00:0000265E
op_ANDI_TO_SR                   00:00002684
op_BCC                          00:00004AF0
op_BCHG                         00:00002A54
op_BCLR                         00:00002DBC
op_BOOL_I                       00:000034DE
op_BSET                         00:0000310A
op_BSR                          00:00003690
op_BTST                         00:000026AA
op_BTST0                        00:00002834
op_BTST1                        00:00002840
op_BTST10                       00:00002888
op_BTST11                       00:00002890
op_BTST12                       00:00002896
op_BTST2                        00:00002848
op_BTST20                       00:000029EE
op_BTST21                       00:000029F8
op_BTST22                       00:000029FE
op_BTST23                       00:00002A04
op_BTST24                       00:00002A0A
op_BTST25                       00:00002A10
op_BTST26                       00:00002A16
op_BTST27                       00:00002A1C
op_BTST28                       00:00002A22
op_BTST29                       00:00002A28
op_BTST3                        00:00002850
op_BTST30                       00:00002A2E
op_BTST31                       00:00002A34
op_BTST32                       00:00002A38
op_BTST4                        00:00002858
op_BTST5                        00:00002860
op_BTST6                        00:00002868
op_BTST7                        00:00002870
op_BTST8                        00:00002878
op_BTST9                        00:00002880
op_CHK                          00:0000413A
op_CMP                          00:00005044
op_CMPA                         00:000050BA
op_CMPM                         00:00005120
op_CMP_I                        00:000036C6
op_DBCC                         00:00004B70
op_DIVS                         00:00004DA8
op_DIVU                         00:00004D56
op_EOR                          00:00004FCE
op_EORI_TO_CCR                  00:00002612
op_EORI_TO_SR                   00:00002638
op_EXG                          00:000056EA
op_EXT                          00:00003FBA
op_LEAPEA                       00:00003FFC
op_LINKS                        00:0000410C
op_MOVE                         00:00003BBA
op_MOVEM                        00:00004512
op_MOVEP                        00:00003452
op_MOVEQ                        00:00004D3A
op_MOVE_USP                     00:0000412A
op_MOVE_xxx_FLAGS               00:00003DC6
op_MULS                         00:0000569E
op_MULU                         00:00005652
op_NBCD                         00:00004A20
op_NEGS                         00:00004184
op_OR                           00:00004DFA
op_ORI_TO_CCR                   00:000025CE
op_ORI_TO_SR                    00:000025F0
op_ROXx                         00:0000598E
op_ROx                          00:00005758
op_RTR                          00:00004ACE
op_SBCD                         00:00004928
op_SCC                          00:00004B96
op_SHIFTS                       00:00005BC4
op_SHIFTS2                      00:00005E06
op_SUB                          00:000052B0
op_SUBA                         00:000053E6
op_SUBQ                         00:00004C80
op_SUBX                         00:00005542
op_SUB_I                        00:00003A34
op_SWAP                         00:00003FE6
op_TAS                          00:000040A8
op_TRAPV                        00:00004AB2
op_TST                          00:000040CE
op_abs                          00:0000B8EC
op_call                         00:0000B8AC
op_jump                         00:0000B8B2
op_rtsvec                       00:0000B89C
op_short                        00:0000B95C
op_vctr                         00:0000B8C2
output_number                   00:0000B65E
output_number_loop              00:0000B660
p1_high                          S:00000176
p1_score                         S:00000173
p1_ships                         S:00000175
p2_high                          S:0000027A
p2_score                         S:00000277
p2_ships                         S:00000279
p_2_end                          S:0000027B
p_fire_off                       E:0000002B
p_flag_off                       E:00000027
p_orient                         S:0000001E
p_xpos_off                       E:FFFFFFB6
p_xvel_off                       E:0000004A
p_xvlo_off                       E:0000007E
p_ypos_off                       E:FFFFFFFC
p_yvel_off                       E:0000006D
p_yvlo_off                       E:0000007F
past_play                        S:00000019
pcssxa                          00:00009062
pen_color                        E:00040890
pfire_snd                        E:00000001
pfire_sound                     00:0000D506
piece_draw_loop                 00:0000B392
play_00                         00:0000CBC0
play_01                         00:0000CBD8
play_02                         00:0000CBFC
play_03                         00:0000CC20
play_04                         00:0000CC44
play_05                         00:0000CC66
play_06                         00:0000CC8A
play_07                         00:0000CCAE
play_08                         00:0000CCD2
play_09                         00:0000CCF6
play_0A                         00:0000CD1A
play_0B                         00:0000CD3E
play_0C                         00:0000CD62
play_0D                         00:0000CD86
play_0E                         00:0000CDAA
play_0F                         00:0000CDCE
play_10                         00:0000CDF2
play_liv                        00:0000CE0A
play_sample                     00:0000D418
play_sound                       S:00000015
play_tab                        00:0000CB9E
player_1                         E:000000F3
player_2                         E:000001F7
player_idx                       S:00000018
player_init                     00:0000B02A
player_n                        00:0000B78E
player_reset                    00:0000B060
player_shot                     00:0000A896
player_x                        00:0000B78A
plot                            00:00001BD4
plot_and                        00:00001C94
plot_black                      00:00001CB6
plot_copy                       00:00001CA8
plot_or                         00:00001C6A
plot_rand_points                00:00008406
plot_sw                         00:00001C44
plot_white                      00:00001CC0
plot_xor                        00:00001C7E
plottbl                         00:00001C08
pos_lower_ok                    00:0000B0F2
prng                            00:00002344
prtflt                          00:0000959A
pss_check_loop                  00:0000A790
push_start_mess                 00:0000A6E4
px_hide                         00:0000A63E
px_time                          S:0000001C
r_hit_tim                        E:00000079
ramtest                         00:00008EEA
ramtest0                        00:00008F34
ramtest1                        00:00008F3C
ramtest2                        00:00008F6A
ramtest3                        00:00008FB0
ramtest6                        00:00008F5A
rand_curve                      00:00008644
rand_lines                      00:0000852C
rand_points                     00:000084EA
rand_rect                       00:00008580
rand_triangle                   00:000085D4
rbo                             00:000091D4
read_hi                         00:0000B87C
readyQ                           E:00100320
reset_game                      00:0000ACBC
reset_xy_loop                   00:0000B370
reveal_player                   00:0000AE5A
rmtst1                          00:00008F4E
rmtst2                          00:00008F82
rmtst3                          00:00008F8A
rmtst5                          00:00008F04
rock_0                          00:0000CB16
rock_1                          00:0000CB2E
rock_2                          00:0000CB4A
rock_3                          00:0000CB64
rock_count                       E:00000076
rock_hit_out                    00:0000A8F6
rock_on_x                       00:0000AFFC
rock_score                      00:0000B52A
rock_tab                        00:0000CB0E
rock_y_ok                       00:0000AFFA
rot_and_thrust                  00:0000AE7E
rot_not_left                    00:0000ABF6
rotate_iofocus                  00:00007B5C
rtc_read                        00:0000923A
rtc_write                       00:000092C6
sGetChar                        00:0000919E
s_controls                      00:0000B7F4
s_fire_off                       E:00000029
s_flag_off                       E:00000028
s_key                            S:00000014
s_mess_0                        00:0000D2FE
s_mess_1                        00:0000D306
s_mess_2                        00:0000D30F
s_mess_3                        00:0000D336
s_mess_4                        00:0000D354
s_mess_5                        00:0000D37C
s_mess_6                        00:0000D38E
s_mess_7                        00:0000D39B
s_messages                      00:0000D2EE
s_orient                         S:0000001F
s_xpos_off                       E:FFFFFFB8
s_xvel_off                       E:0000004B
s_ypos_off                       E:FFFFFFFE
s_yvel_off                       E:0000006E
sauc_cntdn                       E:00000077
sauc_jsr                        00:0000CB80
sauc_vec                        00:0000CB82
saucer_yok                      00:0000A936
saucer_yvel                     00:0000A9A6
save_char                       00:0000AC24
save_hbutton                    00:0000ABBC
save_hi_index                   00:0000B580
save_hyperspace                 00:0000ACB6
save_saucer                     00:0000A974
save_ship_fire                  00:0000AA58
score_off                        E:00000080
scr_x                            S:00000006
scr_y                            S:00000008
select_focus1                   00:00007B6E
select_iofocus                  00:00007B4A
semamem                          E:FD050000
serial_cmdproc                  00:000015CC
serial_dcb                       E:00040C94
serial_getbuf                   00:00001620
serial_getchar                  00:000015FA
serial_getchar_direct           00:00001600
serial_init                     00:00001568
serial_peek_char                00:00001608
serial_peek_char_direct         00:00001610
serial_putbuf                   00:00001620
serial_putchar                  00:000015F2
serial_putchar_direct           00:00001618
serial_set_inpos                00:00001620
serial_set_outpos               00:00001620
serial_stat                     00:000015EE
set_graphics_mode               00:0000763A
set_text_mode                   00:00007610
setscreen                       00:0000B7F4
setup_err                       00:00001504
setup_framebuf                  00:00001962
setup_gfxaccel                  00:00001DD6
setup_keybd                     00:00000568
setup_null                      00:00000520
setup_serial                    00:00001568
setup_textvid                   00:00000FB8
sexpl_snd                        E:00000005
sexpl_sound                     00:0000D49E
sfire_snd                        E:00000000
sfire_sound                     00:0000D518
shift_left                      00:0000B996
ship_fire                       00:0000AA2E
ship_move                       00:0000AE2C
ship_parts                      00:0000B3F8
ship_wrk_x                      00:0000B346
ship_wrk_y                      00:0000B352
ships_off                        E:00000082
shot_jsr                        00:0000D04E
shot_mask                       00:0000AA2A
shot_or                         00:0000AA2C
shot_vec                        00:0000D050
show_ships                      00:0000AD1A
sin_cos                         00:0000B69A
sin_d0                          00:0000B680
sirq0001                        00:000017FE
sirq0002                        00:0000189C
sirqNxtByte                     00:000017EC
sirqRxFull                      00:0000184E
sirqTxEmpty                     00:0000189C
sirqXmitOff                     00:0000189C
sixteen_ms                       S:0000001D
skip_add                        00:0000B4EE
skip_p2_score                   00:0000B1DC
skip_play_flash                 00:0000B140
skip_play_inc                   00:0000AD5A
skip_player_cont                00:0000A63A
skip_player_move                00:0000A636
skip_sub                        00:0000B60E
small_s_size                    00:0000A802
small_saucer                    00:0000A972
smsau_snd                        E:00000003
smsau_sound                     00:0000D4DE
sound_init                      00:0000D3AB
sound_key                       00:0000D438
ss_count                         S:0000001B
start                           00:000003B8
start_game                      00:0000A6B0
start_left                      00:0000A94A
start_other                     00:000004F4
static_messages                 00:0000B0FC
suppress_0                       S:00000016
switch_addr                      S:0000000E
sys_switches                     E:000408B8
tblPow2                         00:00007EEA
tcbs                             E:20010000
test_fire_loop                  00:0000AA4C
test_neg_fire                   00:0000AAC4
textvid_clear                   00:000011A0
textvid_cmdproc                 00:00000F94
textvid_dcb                      E:00040B08
textvid_get_color               00:00001146
textvid_get_dimen               00:00001170
textvid_get_inpos               00:000010C8
textvid_get_outpos              00:0000110A
textvid_get_outptr              00:00001120
textvid_getbuf                  00:000010C4
textvid_getbuf1                 00:00001156
textvid_getchar                 00:000010BC
textvid_init                    00:00001010
textvid_putbuf                  00:000010C4
textvid_putchar                 00:00001254
textvid_set_inpos               00:000010DE
textvid_set_outpos              00:000010F4
textvid_set_unit                00:00001166
textvid_stat                    00:000010B8
textvid_stub                    00:000010C4
third_quad                      00:0000B420
thmp_sndi                        E:0000007C
three_ship_start                00:0000ACCA
thrst_snd                        E:00000002
thrst_sound                     00:0000D4F3
thump_snd                        S:00000023
thump_time                       S:00000024
tickcnt                          E:0004009C
time_count                       S:00000025
timer_interrupt                 00:0000B784
trap3                           00:00009374
variables                       00:0000D537
vec_x_pos                       00:0000B3B8
vec_y_pos                       00:0000B3C4
vector                          00:0000B9E8
vector_base                     00:0000B920
vector_move                     00:0000B9BC
was_rot_left                    00:0000ABF6
what_hit_rock                   00:0000A876
what_hit_saucer                 00:0000A8A2
white_rect                      00:000084C6
wide_shot                       00:0000AA0A
wrap_to_a                       00:0000AC16
wrap_to_z                       00:0000AC1A
write_initial                   00:0000ACE6
x_off_pos                       00:0000B0B0
x_pos_end                        E:FFFFFFC6
x_pos_neg                       00:0000ADB6
x_pos_off                        E:FFFFFF80
x_vel_off                        E:0000002F
y_not_neg                       00:0000ADDC
y_off_pos                       00:0000B0CA
y_pos_off                        E:FFFFFFC6
y_vel_off                        E:00000052
zero_suppress                   00:0000B670

Symbols by value:
FD050000 semamem
FD060000 ACIA
FD069000 I2C2
FD080000 TEXTREG
FD090000 PLIC
FD0FFC00 RST_REG
FD0FFD00 RAND
FD0FFD00 RAND_NUM
FD0FFD04 RAND_STRM
FD0FFD08 RAND_MZ
FD0FFD0C RAND_MW
FD0FFE00 KEYBD
FD0FFF00 leds
FD200000 FRAMEBUF
FD300000 GFXACCEL
FDC00000 MMU
FFFFFF80 x_pos_off
FFFFFFB6 p_xpos_off
FFFFFFB8 s_xpos_off
FFFFFFBA f_xpos_off
FFFFFFC6 y_pos_off
FFFFFFC6 x_pos_end
FFFFFFF0 DDATA
FFFFFFFC p_ypos_off
FFFFFFFC HISPC
FFFFFFFE s_ypos_off
00000000 ACIA_TX
00000000 I2C_PREL
00000000 GFX_CTRL
00000000 HAS_MMU
00000000 E_Ok
00000000 FRAMEBUF_CTRL
00000000 ACIA_RX
00000000 glob_scale
00000000 f_ypos_off
00000000 DCB_MAGIC
00000000 sfire_snd
00000000 TCBInit
00000001 pfire_snd
00000001 SCREEN_FORMAT
00000001 I2C_PREH
00000001 DT_NUMERIC
00000002 DEV_PUTCHAR
00000002 local_x
00000002 I2C_CTRL
00000002 E_Func
00000002 DT_STRING
00000002 SERIAL_SEMA
00000002 thrst_snd
00000003 smsau_snd
00000003 KEYBD_SEMA
00000003 I2C_RXR
00000003 I2C_TXR
00000003 CTRLC
00000004 I2C_STAT
00000004 TCBRegs
00000004 RAND_SEMA
00000004 NCORES
00000004 lgsau_snd
00000004 GFX_STATUS
00000004 DCB_NAME
00000004 EOT
00000004 local_y
00000004 I2C_CMD
00000004 ACIA_STAT
00000005 sexpl_snd
00000005 SCREEN_SEMA
00000006 MEMORY_SEMA
00000006 scr_x
00000006 mexpl_snd
00000007 lexpl_snd
00000007 DEV_SET_OUTPOS
00000008 numBreakpoints
00000008 scr_y
00000008 beat1_snd
00000008 FMTK_SEMA
00000008 CTRLH
00000008 ACIA_CMD
00000009 E_NotAlloc
00000009 beat2_snd
0000000A extra_snd
0000000A LF
0000000A E_NotSupported
0000000A PRNlword
0000000A FDATA
0000000C DEV_CLEAR
0000000C ACIA_CTRL
0000000C flags_off
0000000D SC_TAB
0000000D CR
0000000D DEV_SWAPBUF
0000000E switch_addr
00000010 DEV_GETBUF1
00000010 LOCVARSZ
00000010 GFX_TARGET_BASE
00000011 SC_ALT
00000011 XON
00000012 hiscore_y
00000012 SC_LSHIFT
00000012 DEV_WRITEAT
00000013 CTRLS
00000013 XOFF
00000014 s_key
00000014 SC_CTRL
00000014 GFX_TARGET_SIZE_X
00000014 DEV_GET_DIMEN
00000015 play_sound
00000015 DEV_GET_COLOR
00000016 suppress_0
00000017 DEV_GET_OUTPOS
00000017 high_idx
00000018 DEV_GET_OUTPTR
00000018 CTRLX
00000018 player_idx
00000018 GFX_TARGET_SIZE_Y
00000018 DCB_CMDPROC
00000019 past_play
0000001A CTRLZ
0000001A num_players
0000001B ss_count
0000001C px_time
0000001D sixteen_ms
0000001E p_orient
0000001F s_orient
0000001F FOC
00000020 BLANK
00000020 E_BadDevNum
00000020 DCB_OUTPOSX
00000020 hi_char
00000020 TEXTROW
00000020 DEV_SET_DIMEN
00000020 TS_PREEMPT
00000021 last_fire
00000021 DEV_SET_COLOR_DEPTH
00000022 last_hype
00000023 thump_snd
00000024 thump_time
00000024 DCB_OUTPOSY
00000025 time_count
00000026 hyper
00000027 FOP
00000027 p_flag_off
00000027 hiscores
00000028 TCBHandleToPointer
00000028 DCB_OUTPOSZ
00000028 s_flag_off
00000029 s_fire_off
0000002B p_fire_off
0000002C DCB_INPOSX
0000002F x_vel_off
0000002F flag_end
00000030 DCB_INPOSY
00000034 DCB_INPOSZ
00000038 DCB_INBUFPTR
00000038 GFX_DEST_PIXEL_X
0000003B hinames
0000003C DCB_OUTBUFPTR
0000003C GFX_DEST_PIXEL_Y
0000003F BUFSIZE
00000040 DCB_INBUFSIZE
00000040 GFX_DEST_PIXEL_Z
00000040 TCBPointerToHandle
00000040 TEXTCOL
00000044 TCBUSP
00000044 DCB_OUTBUFSIZE
00000048 TCBSSP
00000048 DCB_INDIMX
0000004A p_xvel_off
0000004B s_xvel_off
0000004C TCBSR
0000004C DCB_INDIMY
0000004C f_xvel_off
00000050 TCBPC
00000050 TCBIAlloc
00000050 BUFLEN
00000050 DCB_INDIMZ
00000052 y_vel_off
00000054 DCB_OUTDIMX
00000054 TCBStatus
00000055 TCBPriority
00000058 SC_CAPSLOCK
00000058 DCB_OUTDIMY
00000059 SC_RSHIFT
00000059 game_count
0000005B expl_x_pos
0000005C DCB_OUTDIMZ
00000060 DCB_BKCOLOR
00000064 DCB_FGCOLOR
00000067 expl_y_pos
00000068 DCB_OPCODE
0000006C TCBStartTick
0000006D p_yvel_off
0000006E TCBAlloc
0000006E s_yvel_off
0000006F f_yvel_off
00000070 TCBEndTick
00000070 DCB_INBUFPTR2
00000074 DCB_OUTBUFPTR2
00000074 TCBTicks
00000074 GFX_CLIP_PIXEL0_X
00000075 i_rk_count
00000076 rock_count
00000077 SC_NUMLOCK
00000077 sauc_cntdn
00000078 i_sauc_tim
00000078 FRAMEBUF_WINDOW_DIMEN
00000078 GFX_CLIP_PIXEL0_Y
00000079 r_hit_tim
0000007A hide_p_cnt
0000007B new_rocks
0000007C DCB_OUTBUFSIZE2
0000007C TCBNext
0000007C TCBIFree
0000007C thmp_sndi
0000007C GFX_CLIP_PIXEL1_X
0000007D min_rocks
0000007E SC_SCROLLLOCK
0000007E p_xvlo_off
0000007F p_yvlo_off
00000080 DCB_UNIT
00000080 GFX_CLIP_PIXEL1_Y
00000080 TS_RUNNING
00000080 TCBPrev
00000080 score_off
00000082 TCBAffinityBase
00000082 ships_off
00000083 high_off
00000084 TCBAffinity
00000084 GFX_COLOR0
00000084 DCB_SIZE
00000088 GFX_COLOR1
0000008C GFX_COLOR2
00000092 TCBFree
00000098 FRAMEBUF_COLOR_COMP
000000A0 TCBAffineChose
000000B0 GFX_TARGET_X0
000000B4 GFX_TARGET_Y0
000000B8 GFX_TARGET_X1
000000BC GFX_TARGET_Y1
000000D8 TCBInsertIntoReadyQueue
000000E0 SC_EXTEND
000000F0 SC_KEYUP
000000F3 player_1
00000100 IRQ_trampolines
00000100 TCB_SIZE
00000150 TCBRemoveFromReadyQueue
00000172 StartQ
00000173 p1_score
00000175 p1_ships
00000176 p1_high
0000017A TCBPopReadyQueue
000001F7 player_2
00000220 FemtikiInit
00000230 FemtikiInitIRQ
0000023E OSCallTable
00000240 CallOS
00000277 p2_score
00000279 p2_ships
0000027A p2_high
0000027B p_2_end
000002AA GetRunningTCBPointer
000002C2 SelectThreadToRun
000002EC UpdateIRQLive
0000030E FemtikiTimerIRQ
00000396 LockSysSemaphore
000003A6 UnlockSysSemaphore
000003B8 start
00000400 irq_list_tbl
000004E0 loop2
000004E2 loop1
000004F4 start_other
0000051A do_nothing
00000520 null_init
00000520 setup_null
00000562 null_ret
00000564 null_cmdproc
00000568 keybd_init
00000568 setup_keybd
000005EC KBD_CMDTBL
0000060C keybd_cmdproc
0000062E keybd_stat
00000636 keybd_putchar
0000063E keybd_getchar
00000646 keybd_set_inpos
00000646 keybd_putbuf
00000646 keybd_set_outpos
00000646 keybd_getbuf
0000064A KeybdGetID
0000067C kgid1
00000684 kgnotKbd
00000688 KeybdSetLED
000006B4 _KeybdInit
000006B4 KeybdInit
000006E0 kbdi0002
0000074A kbdiTryAgain
00000758 kbdi0004
00000774 kbdi0005
00000778 ledxit
0000078E kbdiXmitBusy
0000079C msgBadKeybd
000007AB msgXmitBusy
000007C6 _KeybdGetStatus
000007E4 _KeybdGetScancode
00000800 STRAREASIZE
00000802 _KeybdClearIRQ
00000818 KeybdRecvByte
0000083A KeybdWaitTx
00000860 SetKeyboardEcho
00000868 CheckForKey
00000874 GetKey
000008AE CheckForCtrlC
000008BE KeybdGetCharNoWait
000008C6 KeybdGetCharWait
000008CE KeybdGetChar
00000AEA KeybdSetLEDStatus
00000B3A KeybdSendByte
00000B42 Wait10ms
00000B5E Wait300ms
00000B7A KeybdIRQ
00000C30 _unshiftedScanCodes
00000D30 _shiftedScanCodes
00000E30 _keybdControlCodes
00000EB0 _keybdExtendedCodes
00000F30 TEXTVID_CMDTBL
00000F94 textvid_cmdproc
00000FB8 setup_textvid
00000FFF MAX_TID
00001000 NR_TCB
00001010 textvid_init
000010B8 textvid_stat
000010BC textvid_getchar
000010C4 textvid_putbuf
000010C4 textvid_getbuf
000010C4 textvid_stub
000010C8 textvid_get_inpos
000010DE textvid_set_inpos
000010F4 textvid_set_outpos
0000110A textvid_get_outpos
00001120 textvid_get_outptr
00001146 textvid_get_color
00001156 textvid_getbuf1
00001166 textvid_set_unit
00001170 textvid_get_dimen
000011A0 textvid_clear
000011EC loop3
0000120A get_screen_color
0000122A CalcScreenLoc
00001254 textvid_putchar
00001272 dcx14
00001276 dcx7
0000127E dccr
0000129C dcx6
000012B2 dcx8
000012C8 dcx9
000012E6 dcx10
000012FE dcx12
00001308 dcx11
00001352 dclf
00001356 dcx16
0000135A dcx4
00001364 doBackspace
00001372 doDelete
000013A8 doCtrlX
000013CC IncCursorPos
000013E6 IncCursorRow
0000140E icc1
00001410 ScrollUp
00001456 BlankLastLine
000014B0 HomeCursor
000014C2 SyncCursor
00001504 err_init
00001504 setup_err
00001530 err_ret
00001532 err_cmdproc
00001538 COM_CMDTBL
00001568 serial_init
00001568 setup_serial
000015CC serial_cmdproc
000015EE serial_stat
000015F2 serial_putchar
000015FA serial_getchar
00001600 serial_getchar_direct
00001608 serial_peek_char
00001610 serial_peek_char_direct
00001618 serial_putchar_direct
00001620 serial_putbuf
00001620 serial_set_inpos
00001620 serial_set_outpos
00001620 serial_getbuf
00001624 SerialInit
00001662 SerialGetChar
000016DA SerialPeekChar
00001716 SerialPeekCharDirect
00001730 SerialPutChar
00001794 SerialPutCharDirect
000017B0 SerialRbo
000017B8 SerialRcvCount
000017D8 SerialIRQ
000017EC sirqNxtByte
000017FE sirq0001
0000184E sirqRxFull
0000184E notRxInt
0000189C sirqTxEmpty
0000189C sirq0002
0000189C sirqXmitOff
0000189C notTxInt
000018AE nmeSerial
000018B8 FRAMEBUF_CMDTBL
00001940 framebuf_cmdproc
00001962 setup_framebuf
000019D4 framebuf_init
00001A82 framebuf_stat
00001A82 framebuf_getchar
00001A82 framebuf_putchar
00001A84 framebuf_set_inpos
00001A92 framebuf_set_outpos
00001AA0 framebuf_getbuf1
00001AA8 framebuf_getbuf2
00001AB0 framebuf_setbuf1
00001ABE framebuf_setbuf2
00001ACC framebuf_swapbuf
00001B2A framebuf_set_unit
00001B34 framebuf_putbuf
00001B34 framebuf_getbuf
00001B34 framebuf_stub
00001B38 framebuf_set_color_depth
00001B4A framebuf_get_color
00001B5A framebuf_get_dimen
00001B8A framebuf_set_dimen
00001BD4 framebuf_writeat
00001BD4 plot
00001C08 plottbl
00001C44 plot_sw
00001C6A plot_or
00001C7E plot_xor
00001C94 plot_and
00001CA8 plot_copy
00001CB6 plot_black
00001CC0 plot_white
00001CCC framebuf_clear
00001D2C GFXACCEL_CMDTBL
00001DB4 gfxaccel_cmdproc
00001DD6 setup_gfxaccel
00001E48 gfxaccel_init
00001EB0 gfxaccel_stat
00001EBE gfxaccel_clear
00001EC2 gfxaccel_putbuf
00001EC2 gfxaccel_stub
00001EC2 gfxaccel_putchar
00001EC2 gfxaccel_getbuf2
00001EC2 gfxaccel_set_unit
00001EC2 gfxaccel_get_dimen
00001EC2 gfxaccel_set_inpos
00001EC2 gfxaccel_get_outpos
00001EC2 gfxaccel_setbuf2
00001EC2 gfxaccel_get_outptr
00001EC2 gfxaccel_writeat
00001EC2 gfxaccel_getchar
00001EC2 gfxaccel_swapbuf
00001EC2 gfxaccel_setbuf1
00001EC2 gfxaccel_getbuf
00001EC2 gfxaccel_set_outpos
00001EC2 gfxaccel_get_inpos
00001EC2 gfxaccel_getbuf1
00001EC6 gfxaccel_set_dimen
00001EFA gfxaccel_set_color_depth
00001F1C gfxaccel_get_color
00001F26 gfxaccel_set_color
00001F46 gfxaccel_set_color123
00001F7E gfxaccel_clip_rect
00001FC2 gfxaccel_set_active_point
00001FEE gfxaccel_plot_point
00002044 gfxaccel_draw_line
000020AC gfxaccel_draw_rectangle
00002114 gfxaccel_draw_triangle
0000219C gfxaccel_draw_curve
00002222 gfxaccel_wait
00002250 GlobalReadLong
00002256 GlobalWriteLong
0000225A net_delay
0000225A nd4
0000225A nd2
0000225A nd1
0000225A nd3
0000225E InitIOPBitmap
000022AA InitRand
000022AA RandInit
00002314 RandGetNum
00002344 prng
0000239E _GetRand
000023C2 RandWait
000023DA InitSemaphores
00002400 LockSemaphore
00002422 ForceUnlockSemaphore
0000243C UnlockSemaphore
00002458 T15LockSemaphore
0000245E T15UnlockSemaphore
00002464 T15GetFloat
00002472 T15Abort
00002482 chk_exception
00002496 Delay3s
000024A4 dly3s2
000024A6 dly3s1
000024BA Delay3s2
000024D6 cpu_test
000025B4 ALL_DONE
000025B6 BSR_FAR1
000025BE EXCEPTION_6
000025C6 EXCEPTION_7
000025CE op_ORI_TO_CCR
000025F0 op_ORI_TO_SR
00002612 op_EORI_TO_CCR
00002638 op_EORI_TO_SR
0000265E op_ANDI_TO_CCR
00002684 op_ANDI_TO_SR
000026AA op_BTST
00002834 op_BTST0
00002840 op_BTST1
00002848 op_BTST2
00002850 op_BTST3
00002858 op_BTST4
00002860 op_BTST5
00002868 op_BTST6
00002870 op_BTST7
00002878 op_BTST8
00002880 op_BTST9
00002888 op_BTST10
00002890 op_BTST11
00002896 op_BTST12
000029EE op_BTST20
000029F8 op_BTST21
000029FE op_BTST22
00002A04 op_BTST23
00002A0A op_BTST24
00002A10 op_BTST25
00002A16 op_BTST26
00002A1C op_BTST27
00002A22 op_BTST28
00002A28 op_BTST29
00002A2E op_BTST30
00002A34 op_BTST31
00002A38 op_BTST32
00002A54 op_BCHG
00002DBC op_BCLR
0000310A op_BSET
00003452 op_MOVEP
000034DE op_BOOL_I
00003688 BSR_CLOSE1
00003690 op_BSR
000036BE BSR_CLOSE2
000036C6 op_CMP_I
000038AE op_ADD_I
00003A34 op_SUB_I
00003BBA op_MOVE
00003C86 MOVE2
00003D02 MOVE1
00003D82 MOVE3
00003DC6 op_MOVE_xxx_FLAGS
00003EDC MOVE4
00003FBA op_EXT
00003FE6 op_SWAP
00003FFC op_LEAPEA
00004000 REL4
00004094 LEA1
000040A8 op_TAS
000040CE op_TST
0000410C op_LINKS
0000412A op_MOVE_USP
0000413A op_CHK
00004184 op_NEGS
00004512 op_MOVEM
00004830 op_ABCD
00004850 ABCD_OUTER1
00004852 ABCD_INNER1
0000486E ABCD_NO_C1
00004876 ABCD_NO_C2
000048BE ABCD_OUTER2
000048C0 ABCD_INNER2
000048DC ABCD_NO_C3
000048E4 ABCD_NO_C4
00004928 op_SBCD
00004948 SBCD_OUTER1
0000494A SBCD_INNER1
00004966 SBCD_NO_C1
0000496E SBCD_NO_C2
000049B6 SBCD_OUTER2
000049B8 SBCD_INNER2
000049D4 SBCD_NO_C3
000049DC SBCD_NO_C4
00004A20 op_NBCD
00004A38 NBCD_LOOP
00004A44 NBCD_NO_C
00004A48 NBCD_NO_Z
00004A7E NBCD_LOOP1
00004A92 NBCD_NO_C1
00004A96 NBCD_NO_Z1
00004AB2 op_TRAPV
00004ACE op_RTR
00004ADA RTR_DONE
00004AE8 BSR_FAR2
00004AF0 op_BCC
00004AF8 BCC1
00004B02 BCC2
00004B0A BCC3
00004B14 BCC4
00004B1C BCC5
00004B26 BCC6
00004B2E BCC7
00004B38 BCC8
00004B40 BCC9
00004B4A BCC10
00004B52 BCC11
00004B5C BCC12
00004B64 BCC13
00004B6E BCC14
00004B70 op_DBCC
00004B78 DBCC_LOOP1
00004B86 DBCC_LOOP2
00004B96 op_SCC
00004BC6 op_ADDQ
00004BDA ADDQ_LOOP1
00004C18 ADDQ_LOOP2
00004C4E ADDQ_LOOP3
00004C80 op_SUBQ
00004C98 SUBQ_LOOP1
00004CD2 SUBQ_LOOP2
00004D08 SUBQ_LOOP3
00004D3A op_MOVEQ
00004D56 op_DIVU
00004D72 DIVU_OUTER1
00004DA8 op_DIVS
00004DC4 DIVS_OUTER1
00004DFA op_OR
00004E1A OR_OUTER1
00004E8E OR_OUTER2
00004EE4 op_AND
00004F04 AND_OUTER1
00004F78 AND_OUTER2
00004FCE op_EOR
00004FEE EOR_OUTER2
00005000 REL5
00005044 op_CMP
00005064 CMP_OUTER1
000050BA op_CMPA
000050DA CMPA_OUTER1
00005120 op_CMPM
00005168 CMPM_LOOP1
00005182 CMPM_LOOP2
0000519C CMPM_LOOP3
000051C6 op_ADD
000051E6 ADD_OUTER1
0000525A ADD_OUTER2
000052B0 op_SUB
000052D0 SUB_OUTER1
00005344 SUB_OUTER2
0000539A op_ADDA
000053C0 ADDA_OUTER1
000053E6 op_SUBA
0000540C SUBA_OUTER1
00005432 op_ADDX
00005452 ADDX_OUTER1
000054E6 ADDX_LOOP3
00005502 ADDX_LOOP4
0000551E ADDX_LOOP5
00005542 op_SUBX
00005562 SUBX_OUTER1
000055F6 SUBX_LOOP3
00005612 SUBX_LOOP4
0000562E SUBX_LOOP5
00005652 op_MULU
0000566E MULU_OUTER1
0000569E op_MULS
000056BA MULS_OUTER1
000056EA op_EXG
0000574C ROx_FLAGS
00005758 op_ROx
00005762 ROx_LOOP1
00005782 ROx_LOOP2
000057A2 ROx_LOOP3
000057C2 ROx_LOOP4
000057E2 ROx_LOOP5
00005804 ROx_LOOP6
00005982 ROXx_FLAGS
0000598E op_ROXx
00005998 ROXx_LOOP1
000059B8 ROXx_LOOP2
000059D8 ROXx_LOOP3
000059F8 ROXx_LOOP4
00005A18 ROXx_LOOP5
00005A3A ROXx_LOOP6
00005BB8 SHIFTS_FLAGS
00005BC4 op_SHIFTS
00005BCE SHIFTS_LOOP1
00005BEE SHIFTS_LOOP2
00005C0E SHIFTS_LOOP3
00005C2E SHIFTS_LOOP4
00005C4E SHIFTS_LOOP5
00005C70 SHIFTS_LOOP6
00005DFA SHIFTS2_FLAGS
00005E06 op_SHIFTS2
00005E10 SHIFTS2_LOOP1
00005E2C SHIFTS2_LOOP2
00005E48 SHIFTS2_LOOP3
00005E64 SHIFTS2_LOOP4
00005E80 SHIFTS2_LOOP5
00005E9E SHIFTS2_LOOP6
00006024 START
00006026 GOWARM
0000602A GOOUT
0000602E GOIN
00006032 GOAUXO
00006036 GOAUXI
0000603A GOBYE
0000603E TXTBGN
00006042 ENDMEM
00006046 CSTART
000060B0 WSTART
000060E4 ST3
00006136 ST4
00006170 ClearStringArea
00006190 ClearStringStack
000061A4 TAB1
000061D3 TAB2
00006210 TAB4
00006242 TAB5
00006245 TAB6
0000624A TAB8
00006255 TAB9
00006259 TAB10
0000625C TAB11
00006264 TAB1_1
00006294 TAB2_1
000062D4 TAB4_1
00006308 TAB5_1
00006310 TAB6_1
00006318 TAB8_1
00006334 TAB9_1
0000633C TAB10_1
00006344 TAB11_1
0000634C DIRECT
0000635C EXEC
00006364 EXLP
0000636E EXNGO
00006386 EX1
0000638C EXMAT
00006392 EXGO
00006396 INCON
000063A4 INCOM
000063B2 IOCOM
000063BC OUTCOM
000063C8 IOCON
000063D2 OUTCON
000063DE NEW
000063F2 STOP
000063FA RUN
0000640E RUNNXL
0000644E RUN1
0000645A RUNTSL
00006464 RUNSML
00006474 GOTO
00006488 ONIRQ
000064A2 ONIRQ1
000064AC WAITIRQ
000064BC LIST
000064C8 LS1
000064DC LS2
000064E2 LS3
000064E8 PRINT
000064F8 PR2
00006506 PR0
00006514 PR1
00006522 PR3
0000652E PR6
00006534 PR8
00006550 PR9
0000656A FINISH
00006572 GOSUB
000065AC RETURN
000065D8 FOR
000065F2 FR1
0000660A FR2
00006610 FR3
00006616 FR4
0000661E FR5
00006630 FR6
0000663C FR7
00006654 FR8
00006658 NEXT
00006662 NX0
00006674 NX3
000066A2 NX1
000066BA NX2
000066C2 REM
000066C4 IF
000066C8 IF1
000066CE IF2
000066DE INPERR
000066EC INPUT
00006710 IP7
0000671A IP6
0000671E IP2
00006738 IP3
00006772 IP4
0000677E IP5
00006782 DEFLT
0000678A LET
00006796 LT1
0000679A LOAD
000067A6 LOD1
000067C0 LOD2
000067D0 LODEND
000067DA GBYTE
000067DE GBYTE1
000067EC GBYTE2
000067FA SAVE
00006802 SAVE1
00006826 SAVE2
00006834 SAVEND
00006858 PBYTE
0000685A PBYTE1
0000686E PBYTE2
00006878 POKE
000068EE PKER
000068F2 CALL
00006906 XP_PUSH
0000691C XP_POP
00006932 XP_POP1
00006948 NUM_EXPR
00006956 INT_EXPR
00006968 EXPR
00006968 EXPR_OR
00006978 XP_OR
0000698E EXPR_AND
000069A0 XP_AND
000069B6 XP_ANDX
000069B6 XP_ORX
000069BC CheckNumeric
000069CE EXPR_REL
000069E2 XP11
000069EE XP12
000069FA XP13
00006A06 XP14
00006A12 XP15
00006A1E XP15RT
00006A20 XP16
00006A2E XPRT0
00006A36 XPRT1
00006A3E XP17
00006A44 XP18
00006A58 EXPR2
00006A66 XP21
00006A6C XP22
00006A70 XP23
00006A7E XP24
00006AAC XP25
00006AB2 XP26
00006AC6 XP27
00006AC8 ConcatString
00006B36 EXPR3
00006B38 XP36
00006B3C XP30
00006B48 XP31
00006B5E XP34
00006B78 XP35
00006B7E XP_MOD
00006BA0 EXPR4
00006BAC XP40
00006BBC EXP4RT
00006BBE XP41
00006BCE XPSTNG
00006BD8 XP45
00006C2A XP44
00006C36 PARN
00006C46 XP42
00006C48 XP43
00006C4C AllocateString
00006CAA GarbageCollectStrings
00006CE6 NextString
00006CFC StringInVar
00006D1A SIV1
00006D42 PointsIntoStringArea
00006D66 StringOnStack
00006D96 UpdateStringPointers
00006DC2 USP1
00006DE4 TSTV
00006E2C TV1
00006E5C TV2
00006E64 TSTVRT
00006E66 DIV32
00006E78 DIV1
00006E7E DIV2
00006E84 DIV3
00006E92 DIV4
00006EA0 DIVRT
00006EA2 PEEK
00006F0A RND
00006F34 ABS
00006F40 SIZE
00006F50 TICK
00006F5C CORENO
00006F68 LorRArgs
00006FA0 LorR1
00006FA4 MID
00006FEC MID2
00007000 REL7
00007004 MID5
0000700C DOMID
00007038 MID4
0000706A MID1
0000706E LEFT
0000707A RIGHT
000070A2 LEN
000070C8 INT
000070DE CHR
00007116 SETVAL
00007134 SV1
00007136 FIN
00007142 FI1
0000714E FI2
00007150 ENDCHK
00007160 ENDCHK1
00007162 QWHAT
00007164 AWHAT
00007168 ERROR
000071A2 QSORRY
000071A4 ASORRY
000071AA QHOW
000071AC AHOW
000071B2 ETYPE
000071B8 GETLN
000071C8 GL1
000071E6 GL2
000071FA GL3
0000721E GL4
0000722A GL5
00007246 GL6
0000724E GL7
00007256 FNDLN
00007264 FNDLNP
0000727A FNDRET
0000727C FNDNXT
0000727E FNDSKP
0000728C MVUP
00007294 MVRET
00007296 MVUPW
000072A0 MVDOWN
000072A8 POPA
000072E4 PUSHA
0000731A PRTSTG
0000731C PS1
00007334 PRTRET
00007336 PRTSTR2a
0000733C PRTSTR2
00007342 PRTNUM
0000738C PRTLN
000073AA TSTC
000073BC TC1
000073C2 TSTNUM
0000740E IGNBLK
00007418 TOUPBUF
0000741E TOUPB1
0000743E TOUPBRT
00007440 DOQUO
00007448 DOQUO1
00007450 TOUPPER
00007460 TOUPRET
00007462 CHKIO
00007472 CHKRET
00007474 PRMESG
0000747E PRMRET
00007480 CLS
0000748C OUTC
0000749C INC
000074A8 INC1
000074BC AUXOUT
000074D0 AUXIN
000074EE AXIRET
000074F0 BYEBYE
000074FE INITMSG
00007522 OKMSG
00007529 HOWMSG
00007530 WHTMSG
00007538 TYPMSG
00007540 NOSTRING
00007552 SRYMSG
00007558 CLMSG
0000755C LSTROM
0000755C RANPNT
00007560 INPPTR
00007564 OUTPTR
00007568 CURRNT
0000756C STKFP
00007570 STKGOS
00007574 STKINP
00007578 LOPVAR
0000757C LOPINC
00007588 LOPLMT
00007594 LOPLN
00007598 LOPPT
0000759C IRQROUT
000075A0 STRSTK
000075A4 StrSp
000075A8 StrArea
000075AC LastStr
000075B0 TXTUNF
000075B4 VARBGN
000075B8 STKLMT
000075BC DIRFLG
000075C0 BUFFER
00007610 TXT
00007610 set_text_mode
0000763A set_graphics_mode
00007664 get_screen_address
00007676 CRLF
00007690 DisplayString
00007694 dspj1
000076A0 dsret
000076A6 DisplayStringCRLF
000076AA DisplayStringLimited
000076CA DisplayStringLimitedCRLF
000076CE TRAP15
000076E4 T15DispatchTable
00007874 SimHardware
00007884 GetTick
0000788C SetDrawMode
000078AE SetPenColor
000078BA GRBufferToScreen
000078F4 TestBitmap
00007994 Diagonal1
000079B4 Diagonal2
000079DE Vertical1
000079FA Vertical2
00007A22 MoveToXY
00007A30 DrawToXY
00007AAE DrawHorizTo
00007AE0 DrawVertTo
00007B10 Cursor1
00007B48 StubRout
00007B4A select_iofocus
00007B5C rotate_iofocus
00007B6E select_focus1
00007B8C init_plic
00007BC2 cmdString
00007C00 cmdTable
00007C70 FromScreen
00007C7A StartMon
00007C84 Monitor
00007C84 cmdMonitor
00007CA4 PromptLn
00007CB0 Prompt3
00007CC6 Prompt1
00007CE0 cmdDispatch
00007D26 cmdVideoMode
00007D68 cmdBreakpoint
00007D8C cmdAsteroids
00007D94 cmdTinyBasic
00007D98 cmdTestCPU
00007DA8 cmdClearScreen
00007DB4 cmdCore
00007DD8 cmdFMTK
00007DE0 cmdTestFP
00007E6C cmdTestGF
00007E9A cmdClock
00007EB8 cmdReset
00007EEA tblPow2
00007F0A DisplayHelp
00007F0A cmdHelp
00007F16 HelpMsg
0000809C msgUnknownCmd
000080AC msgHello
000080BE GetCmdLine
00008162 cmdSendSerial
00008192 cmdReceiveSerial
000081C6 cmdFillB
0000821A cmdFillW
0000826E cmdFillL
000082BA ignBlanks
000082CC PeekScreenChar
000082D2 GetSzChar
000082F8 EditMemHelper
0000831A cmdEditMemory
00008324 edtmem1
0000838E cmdJump
0000838E ExecuteCode
0000839E cmdGrDemo
00008406 plot_rand_points
00008450 clear_graphics_screen
00008484 clear_graphics_screen2
000084C6 white_rect
000084EA rand_points
0000852C rand_lines
00008580 rand_rect
000085D4 rand_triangle
00008644 rand_curve
000086B4 cmdDisassemble
00008704 cmdDumpMemory
00008728 DumpMem1
0000873A DisplayMem
00008766 dspmem1
000087CE cmdDumpRegs
0000884E msg_regs
00008852 msg_reglist
00008878 cmdTestSerialReceive
0000889A GetHexNumber
000088C8 GetDecNumber
00008900 _dfOne
0000890C _dfTen
00008918 _dfMil
00008924 _msgNan
00008928 _msgInf
0000892C _CheckNan
00008990 _CheckZero
000089AA _CheckNegative
000089BC _MakeBig
000089D8 _LessThanDbl
00008A04 _ComputeDigitsBeforeDecpt
00008A3E _LeadingZero
00008A4E _SpitOutDigits
00008ACA _TrimTrailingPoint
00008AE8 _TrimDotZero
00008B04 _TrimTrailingZeros
00008B10 _SpitOutE
00008B28 _ExtExpDigit
00008B46 _ExtExpDigits
00008B6E _PadLeft
00008BBE _PadRight
00008BF0 _FloatToString
00008C32 _GetFloatGetChar
00008C38 _GetFloatIgnBlanks
00008C40 _GetFloatBackupChar
00008C44 _GetFraction
00008CA8 _GetExponent
00008D32 _GetInteger
00008DA8 _GetFloat
00008E20 AsciiToHexNybble
00008E32 gthx5
00008E44 gthx6
00008E56 gthx3
00008E5A DisplayTwoSpaces
00008E64 dspspc1
00008E6C DisplaySpace
00008E74 DisplayTetra
00008E7A DisplayWyde
00008E80 DisplayByte
00008E86 DisplayNybble
00008EA0 BufTetra
00008EA6 BufWyde
00008EAC BufByte
00008EB2 BufNybble
00008ECA DisplayAddr
00008EEA ramtest
00008EEA cmdTestRAM
00008F04 rmtst5
00008F34 ramtest0
00008F3C ramtest1
00008F4E rmtst1
00008F5A ramtest6
00008F6A ramtest2
00008F82 rmtst2
00008F8A rmtst3
00008FB0 ramtest3
00008FB2 cmdLoadS19
00008FB8 NextRec
00008FCA ProcessRec
00009062 pcssxa
000090CE ProcessS1
000090D2 ProcessS2
000090D6 ProcessS3
000090DA ProcessS7
000090EC ProcessS8
000090FE ProcessS9
00009110 S19Get16BitAddress
0000911E S19Get24BitAddress
0000912A S19Get32BitAddress
00009148 S1932a
0000915C S1932b
0000919E sGetChar
000091C6 AudioInputTest
000091C8 BouncingBalls
000091CA GraphicsDemo
000091CC ClearScreen
000091D4 rbo
000091DC init_i2c
000091DC i2c_setup
000091EC i2c_wait_tip
000091FC i2c_wr_cmd
0000920C i2c_xmit1
0000922A i2c_wait_rx_nack
0000923A rtc_read
000092C6 rtc_write
00009330 msgRtcReadFail
00009349 msgBusErr
0000935A bus_err
00009374 trap3
000093B2 ProcessBreakpoint
000093B8 DisarmAllBreakpoints
000093E4 ArmAllBreakpoints
00009414 ArmBreakpoint
00009492 DisarmBreakpoint
000094E6 ListBreakpoints
00009506 ClearBreakpointList
00009518 SendMsg
00009556 ReceiveMsg
00009598 DispatchMsg
0000959A prtflt
000095E0 T15FloatToString
00009614 io_trap
0000963A OutputChar
00009654 InitIRQ
0000966A InstallIRQ
000096AE TickIRQ
000096F0 irq3_rout
000096F0 irq6_rout
000096F0 irq_rout
00009704 irq_proc_generic
00009722 SpuriousIRQ
00009724 nmi_rout
00009736 addr_err
0000974C brdisp_trap
00009784 illegal_trap
0000979A io_irq
000097AE msg_start
000097D5 msg_core_start
000097E6 msgAddrErr
000097F3 msg_illegal
00009805 msg_bad_branch_disp
00009817 msg_test_done
00009827 msg_io_access
00009842 msgChk
00009850 msgStackCanary
0000986A ShiftBuf
00009884 HEX2DEC2
000098D2 HEX2DEC
000098E2 HX2DC
000098E6 HX2DC0
000098EE HX2DC1
00009908 HX2DC2
0000990A HX2DC22
00009914 HX2DC3
0000991C HX2DC4
00009924 HX2DC5
0000992C HX2DC57
00009930 HX2DC6
00009936 PNT4HX
00009936 PNT4HEX
0000993A PNT6HX
00009946 PNT8HX
0000994A FRELADDR
00009958 FREL10
0000996A FREL15
00009984 FREL20
00009996 FREL25
000099A0 FREL30
000099A8 IMOVEMFR
000099A8 X
000099BC IM7788
000099C0 IM7799
000099D6 IMOVEMTR
000099F0 CS16
000099F2 ISTOP
00009A06 IMMED
00009A2C IMMED45
00009A5E CS15
00009A60 IMMED55
00009A66 IMMED65
00009A76 IMMED75
00009A7A IMOVE
00009A7E ILINK
00009A94 FORM1
00009A98 FORM1A
00009A9C CS14
00009A9E FORM3
00009AA2 FORM4
00009AB4 FORM5
00009AB8 FORM6A
00009AC8 FORM6D
00009AD8 FORMREGA
00009ADC FORMREG5
00009AE8 FORMREGD
00009AEE FORM7
00009AFA FORM8
00009AFE FORM815
00009B06 CS13
00009B08 FORM9
00009B0E EEA10
00009B12 FORM10EX
00009B34 FORM10E3
00009B3C FORM10E4
00009B48 FORM10E6
00009B50 FORM10
00009B56 FORM103
00009B5A FORM104
00009B6A FORM105
00009B80 CS12
00009B84 FORM11
00009B8C FORM11SL
00009BA0 FORM112
00009BAE FORM114
00009BB0 FORM12
00009BCA FORM125
00009BEC FORM12A
00009C10 CS11
00009C14 IQUICK
00009C18 IMOVEQ
00009C30 SCHR
00009C38 IMVFSR
00009C46 IMVFUSP
00009C54 IMVTSR
00009C62 IMVT44
00009C66 IMVTUSP
00009C72 IMVTCCR
00009C82 IMOVEP
00009C92 IMOVEP11
00009CAA CS20
00009CAE IMOVEP35
00009CBC IMOVEP66
00009CD8 SCOMMON
00009CDC ISCC
00009CE6 IDBCC
00009CF8 ICC
00009CFC IBSR
00009D0E ICC35
00009D24 ICC55
00009D34 ISETD
00009D3A ISETD12
00009D42 CS18
00009D44 ISETS
00009D5E ISHIFT
00009D6A ISHIFT13
00009D8E ISHIFT23
00009D9A ISHIFT33
00009D9E ISHIFT44
00009DA6 CS17
00009DA8 ISHIFTM1
00009DC2 ICCCC
00009DD8 ICCCC9
00009DDA BRTBL
00009DFA IMOVEA1
00009E20 IMOVE19
00009E26 IQUICKA
00009E38 IQUICK21
00009E4E IQUICK31
00009E52 CS19
00009E56 FORMSIZE
00009E6A FORM91
00009E7E FORM93
00009E80 FORM95
00009E82 EA000
00009E8E EA001
00009E9A EA010
00009EAE EA011
00009EC4 EA011RTS
00009EC6 EA100
00009EDC FE10
00009EE0 EEA
00009F44 EA1105
00009F48 EA1107
00009F5E EA1109
00009F68 EA101
00009F7E EA111
00009F9C EA1112
00009FB8 EA1113
00009FC4 FE11
00009FC8 EA1113A
00009FEA EA1114
0000A000 DRAW
0000A032 EAF25
0000A036 EAF27
0000A04A EAF35
0000A054 EA1115
0000A08C EA11153
0000A096 EA11155
0000A0A2 MOVEMS
0000A0B2 MOVEMS2
0000A0B6 MOVEMR
0000A0C6 MOVEMR11
0000A0CE MOVEMR33
0000A0E0 MOVEMR44
0000A0FA MOVEMR77
0000A10C MOVEMR79
0000A10E MOVEMR88
0000A126 MOVEMR94
0000A132 DCODE68K
0000A146 DEC311
0000A164 DEC404
0000A174 DEC411
0000A182 FE12
0000A184 DEC425
0000A190 DEC510
0000A194 DEC515
0000A19C DEC530
0000A1A2 DEC535
0000A1AE DEC537
0000A1CA COMMON4
0000A1CC COMMON
0000A1DA COMMON35
0000A1F4 FERROR
0000A1FE FERROR35
0000A20A FERROR39
0000A214 MSG111
0000A21E KI
0000A220 KIEND
0000A220 TBL
0000A4D8 OPCTBL
0000A4D8 TBLE
0000A5D8 asteroids_start
0000A5E0 main_loop
0000A636 skip_player_move
0000A63A skip_player_cont
0000A63E px_hide
0000A646 no_play
0000A664 no_dec_new_rocks
0000A674 game_message
0000A688 do_start_mess
0000A6B0 start_game
0000A6E4 push_start_mess
0000A6FA exit_push_start
0000A6FC game_over
0000A710 nodec_thmpi
0000A73A no_game_over
0000A778 exit_game_message
0000A77A end_game
0000A78E check_hits
0000A790 pss_check_loop
0000A796 next_pss
0000A79C check_pss
0000A7AA check_next_object
0000A7AE check_all
0000A7C8 delta_x_pos
0000A7DA delta_y_pos
0000A802 small_s_size
0000A804 add_p_size
0000A806 no_add_size
0000A814 col_table
0000A81C col_table_p
0000A824 col_table_s
0000A82C col_table_l
0000A834 handle_collision
0000A844 not_saucer
0000A852 not_player
0000A86A not_pss_player
0000A876 what_hit_rock
0000A87A explode_object
0000A896 player_shot
0000A8A2 what_hit_saucer
0000A8BA keep_small
0000A8C0 do_saucer
0000A8EC attract_saucer
0000A8F6 rock_hit_out
0000A914 dec_isaucer_time
0000A924 no_save_ist
0000A936 saucer_yok
0000A94A start_left
0000A972 small_saucer
0000A974 save_saucer
0000A978 exit_do_saucer
0000A97A existing_saucer
0000A992 keep_saucer_dir
0000A99E attract_fire
0000A9A4 exit_existing_saucer
0000A9A6 saucer_yvel
0000A9AA fire_saucer
0000A9C2 aim_shot
0000AA0A wide_shot
0000AA14 no_shot_or
0000AA18 no_aim_shot
0000AA2A shot_mask
0000AA2C shot_or
0000AA2E ship_fire
0000AA4C test_fire_loop
0000AA58 save_ship_fire
0000AA5C exit_ship_fire
0000AA5E fire_shot
0000AAB0 calc_fire_byte
0000AAC4 test_neg_fire
0000AACC fire_ok
0000AAD6 enter_hiscores
0000AB04 no_playerx
0000AB70 next_p_high
0000AB8C close_all
0000ABA4 next_hi_char
0000ABBC save_hbutton
0000ABD2 not_timed_out
0000ABEE not_rot_left
0000ABF6 not_rot_right2
0000ABF6 was_rot_left
0000ABF6 rot_not_left
0000AC16 wrap_to_a
0000AC1A wrap_to_z
0000AC1C check_alpha
0000AC24 save_char
0000AC28 exit_not_done
0000AC2A exit_enter_hiscores
0000AC2C hyperspace
0000AC68 hype_xok1
0000AC72 hype_xok2
0000AC90 hype_yok1
0000AC9A hype_yok2
0000ACB6 save_hyperspace
0000ACBA exit_hyperspace
0000ACBC reset_game
0000ACCA three_ship_start
0000ACD8 clear_items_loop
0000ACE6 write_initial
0000AD00 add_character
0000AD10 add_ships
0000AD1A show_ships
0000AD2C add_ships_loop
0000AD38 exit_add_ships
0000AD3A move_items
0000AD3E move_next_item
0000AD5A skip_play_inc
0000AD74 no_new_rocks
0000AD7C go_reset_play
0000AD82 go_reset_sauc
0000AD8A item_exploding
0000ADA2 no_reset_scale
0000ADA4 move_item
0000ADB6 x_pos_neg
0000ADC6 not_x_max
0000ADDC y_not_neg
0000ADE6 not_y_max
0000AE0A keep_scale
0000AE10 move_next_object
0000AE18 clear_saucer
0000AE2C ship_move
0000AE5A reveal_player
0000AE62 kill_the_player
0000AE78 clear_hyper
0000AE7C exit_ship_move
0000AE7E rot_and_thrust
0000AE8A not_rot_left1
0000AE92 not_rot_right1
0000AEF0 not_thrust
0000AF26 check_velocity
0000AF34 check_neg_velocity
0000AF3E exit_check_velocity
0000AF40 check_clear
0000AF44 check_clear_loop
0000AF5E check_clear_y
0000AF72 not_closer
0000AF7C is_closer
0000AF82 make_rocks
0000AFAC no_inc_min
0000AFBC no_set_max
0000AFC8 gen_rock_loop
0000AFFA rock_y_ok
0000AFFC rock_on_x
0000B000 HALT
0000B01E clear_rocks
0000B020 clear_rocks_loop
0000B028 exit_make_rocks
0000B02A player_init
0000B060 player_reset
0000B076 copy_rock
0000B07A copy_rock_2
0000B0A0 copy_velocity
0000B0B0 x_off_pos
0000B0CA y_off_pos
0000B0D6 limit_velocity
0000B0E0 neg_upper_ok
0000B0EA limit_p_vel
0000B0F2 pos_lower_ok
0000B0FA exit_limit_velocity
0000B0FC static_messages
0000B140 skip_play_flash
0000B154 do_p1_ships
0000B1C8 do_p2_score
0000B1DC skip_p2_score
0000B1EA exit_static
0000B1EC add_to_list
0000B220 add_item
0000B23A add_explode
0000B240 add_saucer
0000B246 add_fire
0000B256 no_shot_dec
0000B258 add_score
0000B286 exit_add_score
0000B28C high_scores
0000B2BE high_scores_loop
0000B32C exit_high_scores
0000B332 exit_no_scores
0000B338 find_rock
0000B33A find_next_rock
0000B344 exit_find_rock
0000B346 ship_wrk_x
0000B352 ship_wrk_y
0000B35E add_play_explode
0000B370 reset_xy_loop
0000B388 no_reset_xy
0000B392 piece_draw_loop
0000B3B8 vec_x_pos
0000B3C4 vec_y_pos
0000B3F8 ship_parts
0000B404 add_player
0000B41A no_pos_reflect
0000B420 third_quad
0000B42E first_quad
0000B454 no_thrust
0000B456 copy_short
0000B45A copy_vectors
0000B474 exit_copy_vectors
0000B476 fx_sounds
0000B484 no_saucer_sound
0000B4B6 no_thump_sound
0000B4B8 hit_a_rock
0000B4D2 clear_rock
0000B4E6 add_to_score
0000B4EE skip_add
0000B528 exit_hit_a_rock
0000B52A rock_score
0000B52E check_hiscores
0000B54A check_hi_player
0000B552 check_hi_loop
0000B560 check_hi_next
0000B580 save_hi_index
0000B584 exit_hi_chk
0000B58E exit_check_hiscores
0000B590 insert_hiscore
0000B594 insert_loop
0000B5B6 exit_insert_loop
0000B5D4 get_atn
0000B5E0 atn_semi
0000B5F0 atn_quad
0000B600 atn_eight
0000B604 loop_atn
0000B60E skip_sub
0000B61E atn_tab
0000B65E output_number
0000B660 output_number_loop
0000B670 zero_suppress
0000B67C cos_d0
0000B680 sin_d0
0000B68E cossin_d0
0000B694 a_was_less
0000B69A sin_cos
0000B71C add_message
0000B764 add_char_loop
0000B77A add_the_char
0000B782 exit_add_message
0000B784 timer_interrupt
0000B78A player_x
0000B78E player_n
0000B796 add_sup_hex_chr
0000B7A2 add_hex_chr
0000B7AC add_sup_zero
0000B7BC add_address
0000B7D2 add_coords
0000B7EC add_single
0000B7EE add_pair
0000B7F4 notscreen
0000B7F4 setscreen
0000B7F4 s_controls
0000B800 Initialise
0000B830 clear_loop
0000B87C read_hi
0000B886 close_all_2
0000B88C gen_prng
0000B89C op_rtsvec
0000B89C Ninc1
0000B89C Ninc0
0000B89E do_vector
0000B8AC op_call
0000B8B2 op_jump
0000B8C2 op_vctr
0000B8D0 no_neg_y11
0000B8DC no_neg_x11
0000B8EC op_abs
0000B8FA no_neg_y10
0000B906 no_neg_x10
0000B918 not_right
0000B920 vector_base
0000B95C op_short
0000B980 no_neg_y2
0000B988 no_neg_x2
0000B98C end_vector
0000B996 shift_left
0000B99A last_vector
0000B9BC vector_move
0000B9E8 vector
0000C000 JSRL
0000C9E8 copy_msg
0000CA28 expl_tab
0000CA30 expl_3
0000CA5C expl_2
0000CA9A expl_1
0000CAD0 expl_0
0000CB0E rock_tab
0000CB16 rock_0
0000CB2E rock_1
0000CB4A rock_2
0000CB64 rock_3
0000CB80 sauc_jsr
0000CB82 sauc_vec
0000CB9E play_tab
0000CBC0 play_00
0000CBD8 play_01
0000CBFC play_02
0000CC20 play_03
0000CC44 play_04
0000CC66 play_05
0000CC8A play_06
0000CCAE play_07
0000CCD2 play_08
0000CCF6 play_09
0000CD1A play_0A
0000CD3E play_0B
0000CD62 play_0C
0000CD86 play_0D
0000CDAA play_0E
0000CDCE play_0F
0000CDF2 play_10
0000CE0A play_liv
0000CE20 char_a
0000CE30 char_b
0000CE4A char_c
0000CE56 char_d
0000CE66 char_e
0000CE76 char_f
0000CE84 char_g
0000CE96 char_h
0000CEA4 char_i
0000CEB2 char_j
0000CEBE char_k
0000CECA char_l
0000CED4 char_m
0000CEE0 char_n
0000CEEA char_o0
0000CEF6 char_p
0000CF04 char_q
0000CF16 char_r
0000CF26 char_s
0000CF34 char_t
0000CF40 char_u
0000CF4C char_v
0000CF56 char_w
0000CF64 char_x
0000CF6E char_y
0000CF7C char_z
0000CF88 char_spc
0000CF8C char_1
0000CF94 char_2
0000CFA4 char_3
0000CFB2 char_4
0000CFC0 char_5
0000CFCE char_6
0000CFDC char_7
0000CFE6 char_8
0000CFF6 char_9
0000D000 RTSL
0000D004 char_set
0000D04E shot_jsr
0000D050 shot_vec
0000D062 mess_origin
0000D082 mess_table
0000D08A e_messages
0000D09A e_mess_0
0000D0A6 e_mess_1
0000D0AE e_mess_2
0000D0D0 e_mess_3
0000D0EB e_mess_4
0000D108 e_mess_5
0000D12F e_mess_6
0000D13A e_mess_7
0000D144 d_messages
0000D154 d_mess_0
0000D164 d_mess_1
0000D16D d_mess_2
0000D194 d_mess_3
0000D1B7 d_mess_4
0000D1DA d_mess_5
0000D200 d_mess_6
0000D216 d_mess_7
0000D220 f_messages
0000D230 f_mess_0
0000D23F f_mess_1
0000D246 f_mess_2
0000D26A f_mess_3
0000D283 f_mess_4
0000D2A5 f_mess_5
0000D2CE f_mess_6
0000D2E0 f_mess_7
0000D2EE s_messages
0000D2FE s_mess_0
0000D306 s_mess_1
0000D30F s_mess_2
0000D336 s_mess_3
0000D354 s_mess_4
0000D37C s_mess_5
0000D38E s_mess_6
0000D39B s_mess_7
0000D3AB sound_init
0000D40C load_sound
0000D412 load_old_sound
0000D418 play_sample
0000D434 old_sound_play
0000D436 exit_play_sample
0000D438 sound_key
0000D450 beat1_sound
0000D462 beat2_sound
0000D474 lexpl_sound
0000D489 mexpl_sound
0000D49E sexpl_sound
0000D4B3 extra_sound
0000D4C9 lgsau_sound
0000D4DE smsau_sound
0000D4F3 thrst_sound
0000D506 pfire_sound
0000D518 sfire_sound
0000D52A filename
0000D537 variables
0000E000 JMPL
0000F000 SHRT
0001001C _Keybd_tick
00040004 TextScr
00040008 S19StartAddress
0004000C KeybdEcho
0004000D KeybdWaitFlag
00040040 CmdBuf
00040080 CmdBufEnd
00040084 fgColor
00040088 bkColor
0004008C TextRows
0004008D TextCols
00040094 _fpTextIncr
00040098 _canary
0004009C tickcnt
000400A0 IRQFlag
000400A4 InputDevice
000400A8 OutputDevice
00040100 Regsave
00040202 NumSetBreakpoints
00040220 Breakpoints
00040280 BreakpointWords
000402C0 fpBuf
00040508 _width
0004050C _E
00040510 _digits_before_decpt
00040514 _precision
00040520 _fpBuf
00040600 _fpWork
00040800 _dasmbuf
00040880 OFFSET
00040890 pen_color
00040894 gr_x
00040898 gr_y
0004089C gr_width
000408A0 gr_height
000408A4 gr_bitmap_screen
000408AC gr_double_buffer
000408B0 gr_bitmap_buffer
000408B8 sys_switches
000408C0 gfxaccel_ctrl
000408D0 m_z
000408D4 m_w
000408D8 next_m_z
000408DC next_m_w
00040A00 null_dcb
00040A84 keybd_dcb
00040B08 textvid_dcb
00040B8C err_dcb
00040C94 serial_dcb
00040D18 framebuf_dcb
00040D9C gfxaccel_dcb
00041BFC TimerStack
00100000 IOFocus
00100004 memend
0010000E KeybdLEDs
0010000F _KeyState1
00100010 _KeyState2
00100011 _KeybdHead
00100012 _KeybdTail
00100013 _KeybdCnt
00100018 KeybdID
00100020 _KeybdBuf
00100080 _KeybdOBuf
00100150 S19Checksum
00100160 SerTailRcv
00100162 SerHeadRcv
00100164 SerRcvXon
00100165 SerRcvXoff
00100166 SerTailXmit
00100168 SerHeadXmit
0010016A SerXmitXoff
00100200 RTCBuf
00100224 RunningTCB
0010030C FreeTCB
0010031C QueueCycle
00100320 readyQ
00101000 SerRcvBuf
00102000 SerXmitBuf
20010000 tcbs
